ических сообщений : true - поочередные/false - случайные")]
                    public Boolean AlertMessageType;

                    [JsonProperty(LanguageEn ? "List of automatic messages in chat" : "Список автоматических сообщений в чат")]
                    public List<String> MessageList;
                    [JsonProperty(LanguageEn ? "Interval for sending messages to chat (Broadcaster) (in seconds)" : "Интервал отправки сообщений в чат (Броадкастер) (в секундах)")]
                    public Int32 MessageListTimer;
                }
                internal class PlayerSession
                {
                    [JsonProperty(LanguageEn ? "When a player is notified about the entry / exit of the player, display his avatar opposite the nickname (true - yes / false - no)" : "При уведомлении о входе/выходе игрока отображать его аватар напротив ника (true - да/false - нет)")]
                    public Boolean ConnectedAvatarUse;

                    [JsonProperty(LanguageEn ? "Notify in chat when a player enters (true - yes/false - no)" : "Уведомлять в чате о входе игрока (true - да/false - нет)")]
                    public Boolean ConnectedAlert;
                    [JsonProperty(LanguageEn ? "Enable random notifications when a player from the list enters (true - yes / false - no)" : "Включить случайные уведомления о входе игрока из списка (true - да/false - нет)")]
                    public Boolean ConnectionAlertRandom;
                    [JsonProperty(LanguageEn ? "Show the country of the entered player (true - yes/false - no)" : "Отображать страну зашедшего игрока (true - да/false - нет")]
                    public Boolean ConnectedWorld;

                    [JsonProperty(LanguageEn ? "Notify when a player enters the chat (selected from the list) (true - yes/false - no)" : "Уведомлять о выходе игрока в чат(выбираются из списка) (true - да/false - нет)")]
                    public Boolean DisconnectedAlert;
                    [JsonProperty(LanguageEn ? "Enable random player exit notifications (true - yes/false - no)" : "Включить случайные уведомления о выходе игрока (true - да/false - нет)")]
                    public Boolean DisconnectedAlertRandom;
                    [JsonProperty(LanguageEn ? "Display reason for player exit (true - yes/false - no)" : "Отображать причину выхода игрока (true - да/false - нет)")]
                    public Boolean DisconnectedReason;

                    [JsonProperty(LanguageEn ? "Random player entry notifications({0} - player's nickname, {1} - country (if country display is enabled)" : "Случайные уведомления о входе игрока({0} - ник игрока, {1} - страна(если включено отображение страны)")]
                    public List<String> RandomConnectionAlert = new List<String>();
                    [JsonProperty(LanguageEn ? "Random notifications about the exit of the player ({0} - player's nickname, {1} - the reason for the exit (if the reason is enabled)" : "Случайные уведомления о выходе игрока({0} - ник игрока, {1} - причина выхода(если включена причина)")]
                    public List<String> RandomDisconnectedAlert = new List<String>();
                }
                internal class AdminSession
                {
                    [JsonProperty(LanguageEn ? "Notify admin on the server in the chat (true - yes/false - no)" : "Уведомлять о входе админа на сервер в чат (true - да/false - нет)")]
                    public Boolean ConnectedAlertAdmin;
                    [JsonProperty(LanguageEn ? "Notify about admin leaving the server in chat (true - yes/false - no)" : "Уведомлять о выходе админа на сервер в чат (true - да/false - нет)")]
                    public Boolean DisconnectedAlertAdmin;
                }
                internal class PersonalAlert
                {
                    [JsonProperty(LanguageEn ? "Enable random message to the player who has logged in (true - yes/false - no)" : "Включить случайное сообщение зашедшему игроку (true - да/false - нет)")]
                    public Boolean UseWelcomeMessage;
                    [JsonProperty(LanguageEn ? "List of messages to the player when entering" : "Список сообщений игроку при входе")]
                    public List<String> WelcomeMessage = new List<String>();
                }
            }

            
                        [JsonProperty(LanguageEn ? "Settings Rust+" : "Настройка Rust+")]
            public RustPlus RustPlusSettings;
            internal class RustPlus
            {
                [JsonProperty(LanguageEn ? "Use Rust+" : "Использовать Rust+")]
                public Boolean UseRustPlus;
                [JsonProperty(LanguageEn ? "Title for notification Rust+" : "Название для уведомления Rust+")]
                public String DisplayNameAlert;
            }
            
                        [JsonProperty(LanguageEn ? "Configuring support plugins" : "Настройка плагинов поддержки")]
            public ReferenceSettings ReferenceSetting = new ReferenceSettings();
            internal class ReferenceSettings
            {
                [JsonProperty(LanguageEn ? "Settings IQFakeActive" : "Настройка IQFakeActive")]
                public IQFakeActive IQFakeActiveSettings = new IQFakeActive();
                [JsonProperty(LanguageEn ? "Settings IQRankSystem" : "Настройка IQRankSystem")]
                public IQRankSystem IQRankSystems = new IQRankSystem();
                internal class IQRankSystem
                {
                    [JsonProperty(LanguageEn ? "Rank display format in chat ( {0} is the user's rank, do not delete this value)" : "Формат отображения ранга в чате ( {0} - это ранг юзера, не удаляйте это значение)")]
                    public String FormatRank = "[{0}]";
                    [JsonProperty(LanguageEn ? "Time display format with IQRank System in chat ( {0} is the user's time, do not delete this value)" : "Формат отображения времени с IQRankSystem в чате ( {0} - это время юзера, не удаляйте это значение)")]
                    public String FormatRankTime = "[{0}]";
                    [JsonProperty(LanguageEn ? "Use support IQRankSystem" : "Использовать поддержку рангов")]
                    public Boolean UseRankSystem;
                    [JsonProperty(LanguageEn ? "Show players their played time next to their rank" : "Отображать игрокам их отыгранное время рядом с рангом")]
                    public Boolean UseTimeStandart;
                }
                internal class IQFakeActive
                {
                    [JsonProperty(LanguageEn ? "Use support IQFakeActive" : "Использовать поддержку IQFakeActive")]
                    public Boolean UseIQFakeActive;
                }
            }
            
            
            [JsonProperty(LanguageEn ? "Setting up an answering machine" : "Настройка автоответчика")]
            public AnswerMessage AnswerMessages = new AnswerMessage();

            internal class AnswerMessage
            {
                [JsonProperty(LanguageEn ? "Enable auto-reply? (true - yes/false - no)" : "Включить автоответчик?(true - да/false - нет)")]
                public bool UseAnswer;
                [JsonProperty(LanguageEn ? "Customize Messages [Keyword] = Reply" : "Настройка сообщений [Ключевое слово] = Ответ")]
                public Dictionary<String, String> AnswerMessageList = new Dictionary<String, String>();
            }

            
                        [JsonProperty(LanguageEn ? "Additional setting" : "Дополнительная настройка")]
            public OtherSettings OtherSetting;

            internal class OtherSettings
            {
                [JsonProperty(LanguageEn ? "Setting up message logging" : "Настройка логирования сообщений")]
                public LoggedChat LogsChat = new LoggedChat();
                [JsonProperty(LanguageEn ? "Setting up logging of personal messages of players" : "Настройка логирования личных сообщений игроков")]
                public General LogsPMChat = new General();
                [JsonProperty(LanguageEn ? "Setting up chat/voice lock/unlock logging" : "Настройка логирования блокировок/разблокировок чата/голоса")]
                public General LogsMuted = new General();
                [JsonProperty(LanguageEn ? "Setting up logging of chat commands from players" : "Настройка логирования чат-команд от игроков")]
                public General LogsChatCommands = new General();
                internal class LoggedChat
                {
                    [JsonProperty(LanguageEn ? "Setting up general chat logging" : "Настройка логирования общего чата")]
                    public General GlobalChatSettings = new General();
                    [JsonProperty(LanguageEn ? "Setting up team chat logging" : "Настройка логирования тим чата")]
                    public General TeamChatSettings = new General();
                }
                internal class General
                {
                    [JsonProperty(LanguageEn ? "Enable logging (true - yes/false - no)" : "Включить логирование (true - да/false - нет)")]
                    public Boolean UseLogged = false;
                    [JsonProperty(LanguageEn ? "Webhooks channel for logging" : "Webhooks канала для логирования")]
                    public String Webhooks = "";
                }
            }
                    }

        
                public void BroadcastAuto()
        {
            Configuration.ControllerAlert.Alert Broadcast = config.ControllerAlertSetting.AlertSetting;

            if (Broadcast.AlertMessage)
            {
                Int32 IndexBroadkastNow = 0;
                String RandomMsg = String.Empty;

                timer.Every(Broadcast.MessageListTimer, () =>
                {
                    if (Broadcast.AlertMessageType)
                    {
                        foreach (BasePlayer p in BasePlayer.activePlayerList)
                        {
                            List<String> MessageList = GetMesagesList(p, Broadcast.MessageList.LanguageMessages);

                            if (IndexBroadkastNow >= MessageList.Count)
                                IndexBroadkastNow = 0;
                            RandomMsg = MessageList[IndexBroadkastNow];

                            ReplySystem(p, RandomMsg);
                        }

                        IndexBroadkastNow++;
                    }
                    else
                    {
                        foreach (BasePlayer p in BasePlayer.activePlayerList)
                            ReplySystem(p, GetMessages(p, Broadcast.MessageList.LanguageMessages));
                    }
                });

            }
        }
        internal class FlooderInfo
        {
            public Double Time;
            public String LastMessage;
            public Int32 TryFlood;
        }

        private String Format(Int32 units, String form1, String form2, String form3)
        {
            var tmp = units % 10;

            if (units >= 5 && units <= 20 || tmp >= 5 && tmp <= 9)
                return $"{units}{form1}";

            if (tmp >= 2 && tmp <= 4)
                return $"{units}{form2}";

            return $"{units}{form3}";
        }
        
        
        
        [ChatCommand("alert")]
        private void AlertChatCommand(BasePlayer Sender, String cmd, String[] args)
        {
            if (!permission.UserHasPermission(Sender.UserIDString, PermissionAlert)) return;
            Alert(Sender, args, false);
        }
        private void DrawUI_IQChat_Mute_And_Ignore_Player(BasePlayer player, SelectedAction Action, IEnumerable<BasePlayer> PlayerList, IEnumerable<FakePlayer> FakePlayerList = null)
        {
            User MyInfo = UserInformation[player.userID];
            if (MyInfo == null) return;
            Int32 X = 0, Y = 0;
            String ColorGreen = "0.5803922 1 0.5372549 1";
            String ColorRed = "0.8962264 0.2578764 0.3087685 1";
            String Color = String.Empty;

            if (IQFakeActive && FakePlayerList != null)
            {
                foreach (var playerInList in FakePlayerList)
                {
                    String Interface = InterfaceBuilder.GetInterface("UI_Chat_Mute_And_Ignore_Player");
                    if (Interface == null) return;

                    String DisplayName = playerInList.DisplayName;
                    if (GeneralInfo.RenameList.ContainsKey(playerInList.UserID))
                        if (!String.IsNullOrWhiteSpace(GeneralInfo.RenameList[playerInList.UserID].RenameNick))
                            DisplayName = GeneralInfo.RenameList[playerInList.UserID].RenameNick;

                    Interface = Interface.Replace("%OFFSET_MIN%", $"{-385.795 - (-281.17 * X)} {97.54 - (46.185 * Y)}");
                    Interface = Interface.Replace("%OFFSET_MAX%", $"{-186.345 - (-281.17 * X)} {132.03 - (46.185 * Y)}");
                    Interface = Interface.Replace("%DISPLAY_NAME%", $"{DisplayName}");
                    Interface = Interface.Replace("%COMMAND_ACTION%", $"newui.cmd action.mute.ignore ignore.and.mute.controller {Action} confirm.alert {playerInList.UserID}");

                    switch (Action)
                    {
                        case SelectedAction.Mute:
                            if (UserInformation.ContainsKey(playerInList.UserID) && UserInformation[playerInList.UserID] != null && (UserInformation[playerInList.UserID].MuteInfo.IsMute(MuteType.Chat) || UserInformation[playerInList.UserID].MuteInfo.IsMute(MuteType.Voice)))
                                Color = ColorRed;
                            else Color = ColorGreen;
                            break;
                        case SelectedAction.Ignore:
                            if (MyInfo.Settings.IsIgnored(playerInList.UserID))
                                Color = ColorRed;
                            else Color = ColorGreen;
                            break;
                        default:
                            break;
                    }

                    Interface = Interface.Replace("%COLOR%", Color);


                    X++;
                    if (X == 3)
                    {
                        X = 0;
                        Y++;
                    }

                    CuiHelper.AddUi(player, Interface);
                }
            }
            else
            {
                foreach (var playerInList in PlayerList)
                {
                    String Interface = InterfaceBuilder.GetInterface("UI_Chat_Mute_And_Ignore_Player");
                    if (Interface == null) return;
                    User Info = UserInformation[playerInList.userID];
                    if (Info == null) continue;

                    String DisplayName = playerInList.displayName;
                    if (GeneralInfo.RenameList.ContainsKey(playerInList.userID))
                        if (!String.IsNullOrWhiteSpace(GeneralInfo.RenameList[playerInList.userID].RenameNick))
                            DisplayName = GeneralInfo.RenameList[playerInList.userID].RenameNick;

                    Interface = Interface.Replace("%OFFSET_MIN%", $"{-385.795 - (-281.17 * X)} {97.54 - (46.185 * Y)}");
                    Interface = Interface.Replace("%OFFSET_MAX%", $"{-186.345 - (-281.17 * X)} {132.03 - (46.185 * Y)}");
                    Interface = Interface.Replace("%DISPLAY_NAME%", $"{DisplayName}");
                    Interface = Interface.Replace("%COMMAND_ACTION%", $"newui.cmd action.mute.ignore ignore.and.mute.controller {Action} confirm.alert {playerInList.userID}");

                    switch (Action)
                    {
                        case SelectedAction.Mute:
                            if (Info.MuteInfo.IsMute(MuteType.Chat) || Info.MuteInfo.IsMute(MuteType.Voice))
                                Color = ColorRed;
                            else Color = ColorGreen;
                            break;
                        case SelectedAction.Ignore:
                            if (MyInfo.Settings.IsIgnored(playerInList.userID))
                                Color = ColorRed;
                            else Color = ColorGreen;
                            break;
                        default:
                            break;
                    }

                    Interface = Interface.Replace("%COLOR%", Color);


                    X++;
                    if (X == 3)
                    {
                        X = 0;
                        Y++;
                    }

                    CuiHelper.AddUi(player, Interface);
                }
            }
        }

        public class Fields
        {
            public string name { get; set; }
            public string value { get; set; }
            public bool inline { get; set; }
            public Fields(string name, string value, bool inline)
            {
                this.name = name;
                this.value = value;
                this.inline = inline;
            }
        }
        private enum SelectedAction
        {
            Mute,
            Ignore
        }

        
                private void DrawUI_IQChat_DropList(BasePlayer player, String OffsetMin, String OffsetMax, String Title, TakeElementUser ElementType)
        {
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_DropList");
            if (Interface == null) return;

            Interface = Interface.Replace("%TITLE%", Title);
            Interface = Interface.Replace("%OFFSET_MIN%", OffsetMin);
            Interface = Interface.Replace("%OFFSET_MAX%", OffsetMax);
            Interface = Interface.Replace("%BUTTON_DROP_LIST_CMD%", $"newui.cmd droplist.controller open {ElementType}");
		   		 		  						  	   		  	  			  	  			  	 				  	  	
            CuiHelper.AddUi(player, Interface);
        }

        private void RegisteredPermissions()
        {
            Configuration.ControllerParameters Controller = config.ControllerParameter;
            IEnumerable<Configuration.ControllerParameters.AdvancedFuncion> Parametres = Controller.Prefixes.Prefixes
                .Concat(Controller.NickColorList).Concat(Controller.MessageColorList);

            foreach (Configuration.ControllerParameters.AdvancedFuncion Permission in Parametres.Where(perm =>
                         !permission.PermissionExists(perm.Permissions, this)))
                permission.RegisterPermission(Permission.Permissions, this);

            if (!permission.PermissionExists(PermissionHideOnline, this))
                permission.RegisterPermission(PermissionHideOnline, this);
            if (!permission.PermissionExists(PermissionRename, this))
                permission.RegisterPermission(PermissionRename, this);
            if (!permission.PermissionExists(PermissionMute, this))
                permission.RegisterPermission(PermissionMute, this);
            if (!permission.PermissionExists(PermissionAlert, this))
                permission.RegisterPermission(PermissionAlert, this);
            if (!permission.PermissionExists(PermissionAntiSpam, this))
                permission.RegisterPermission(PermissionAntiSpam, this);
            if (!permission.PermissionExists(PermissionHideConnection, this))
                permission.RegisterPermission(PermissionHideConnection, this);
            if (!permission.PermissionExists(PermissionHideDisconnection, this))
                permission.RegisterPermission(PermissionHideDisconnection, this);
            if (!permission.PermissionExists(PermissionMutedAdmin, this))
                permission.RegisterPermission(PermissionMutedAdmin, this);

            PrintWarning("Permissions - completed");
        }

        private String GetLastMessage(BasePlayer player, Int32 Count)
        {
            String Messages = String.Empty;

            if (LastMessagesChat.ContainsKey(player))
            {
                foreach (String Message in LastMessagesChat[player].Skip(LastMessagesChat[player].Count - Count))
                    Messages += $"\n{Message}";
            }

            return Messages;
        }
        List<String> IQRankListKey(ulong userID) => (List<string>)(IQRankSystem?.Call("API_RANK_USER_KEYS", userID));
        void OnPlayerConnected(BasePlayer player)
        {
            UserConnecteionData(player);
            AlertController(player);
        }
        
        
        
                [ChatCommand("rename")]
        private void ChatCommandRename(BasePlayer Renamer, string command, string[] args)
        {
            if (!permission.UserHasPermission(Renamer.UserIDString, PermissionRename)) return;
            GeneralInformation General = GeneralInfo;
            if (General == null) return;

            if (Renamer == null)
            {
                ReplySystem(Renamer, LanguageEn ? "You can only use this command while on the server" : "Вы можете использовать эту команду только находясь на сервере");
                return;
            }
            if (args.Length == 0 || args == null)
            {
                ReplySystem(Renamer, lang.GetMessage("COMMAND_RENAME_NOTARG", this, Renamer.UserIDString));
                return;
            }

            String Name = args[0];
            UInt64 ID = Renamer.userID;
            if (args.Length == 2 && args[1] != null && !String.IsNullOrWhiteSpace(args[1]))
                if (!UInt64.TryParse(args[1], out ID))
                {
                    ReplySystem(Renamer, GetLang("COMMAND_RENAME_NOT_ID", Renamer.UserIDString));
                    return;
                }

            if (General.RenameList.ContainsKey(Renamer.userID))
            {
                General.RenameList[Renamer.userID].RenameNick = Name;
                General.RenameList[Renamer.userID].RenameID = ID;
            }
            else General.RenameList.Add(Renamer.userID, new GeneralInformation.RenameInfo { RenameNick = Name, RenameID = ID });

            ReplySystem(Renamer, GetLang("COMMAND_RENAME_SUCCES", Renamer.UserIDString, Name, ID));
            Renamer.displayName = Name;
        }

        public Dictionary<UInt64, FlooderInfo> Flooders = new Dictionary<UInt64, FlooderInfo>();
        [ConsoleCommand("saybro")]
        private void AlertOnlyPlayerConsoleCommand(ConsoleSystem.Arg args)
        {
            BasePlayer Sender = args.Player();
            if (Sender != null)
                if (!permission.UserHasPermission(Sender.UserIDString, PermissionAlert)) return;

            if (args.Args == null || args.Args.Length == 0)
            {
                if (Sender != null)
                    ReplySystem(Sender, LanguageEn ? "You didn't specify a player!" : "Вы не указали игрока!");
                else PrintWarning(LanguageEn ? "You didn't specify a player" : "Вы не указали игрока!");
                return;
            }
            BasePlayer Recipient = BasePlayer.Find(args.Args[0]);
            if (Recipient == null)
            {
                if (Sender != null)
                    ReplySystem(Sender, LanguageEn ? "The player is not on the server!" : "Игрока нет на сервере!");
                else PrintWarning(LanguageEn ? "The player is not on the server!" : "Игрока нет на сервере!");
                return;
            }
            Alert(Sender, Recipient, args.Args.Skip(1).ToArray());
        }
        private void OnUserConnected(IPlayer player) => ControlledBadNick(player);
        private const String PermissionMutedAdmin = "iqchat.adminmuted";

            }
}



// --- End of file: IQChat.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/InstantCraft.cs ---
// --- Original Local Path: BeeRust/InstantCraft.cs ---

using Newtonsoft.Json;
using System.Collections.Generic;
using Oxide.Core;
using UnityEngine;
using System.Linq;
using System;

namespace Oxide.Plugins
{
    [Info("Instant Craft", "Vlad-0003 / Orange / rostov114", "2.2.5")]
    [Description("Allows players to instantly craft items with features")]
    public class InstantCraft : RustPlugin
    {
        #region Vars
        private const string permUse = "instantcraft.use";
        private const string permNormal = "instantcraft.normal";
        #endregion

        #region Oxide Hooks
        private void Init()
        {
            permission.RegisterPermission(permUse, this);
            permission.RegisterPermission(permNormal, this);
        }

        private object OnItemCraft(ItemCraftTask task, BasePlayer owner)
        {
            if (task.cancelled)
            {
                return null;
            }

            if (permission.UserHasPermission(owner.UserIDString, permNormal) || !permission.UserHasPermission(owner.UserIDString, permUse))
            {
                return null;
            }

            if (_config.IsBlocked(task))
            {
                CancelTask(task, owner, "Blocked");
                return false;
            }

            List<int> stacks = GetStacks(task.blueprint.targetItem, task.amount * task.blueprint.amountToCreate);
            int slots = FreeSlots(owner);
            if (!HasPlace(slots, stacks))
            {
                CancelTask(task, owner, "Slots", stacks.Count, slots);
                return false;
            }

            if (_config.IsNormal(task))
            {
                Message(owner, "Normal");
                return null;
            }

            if (!GiveItem(task, owner, stacks))
            {
                return null;
            }

            return true;
        }
        #endregion

        #region Helpers
        public void CancelTask(ItemCraftTask task, BasePlayer owner, string reason, params object[] args)
        {
            task.cancelled = true;
            Message(owner, reason, args);
            GiveRefund(task, owner);
            Interface.CallHook("OnItemCraftCancelled", task, owner.inventory.crafting);
        }

        public void GiveRefund(ItemCraftTask task, BasePlayer owner)
        {
            if (task.takenItems != null && task.takenItems.Count > 0)
            {
                foreach (var item in task.takenItems)
                {
                    owner.inventory.GiveItem(item, null);
                }
            }
        }

        public bool GiveItem(ItemCraftTask task, BasePlayer owner, List<int> stacks)
        {
            ulong skin = ItemDefinition.FindSkin(task.blueprint.targetItem.itemid, task.skinID);
            int iteration = 0;

            if (_config.split)
            {
                foreach (var stack in stacks)
                {
                    if (!Give(task, owner, stack, skin) && iteration <= 0)
                    {
                        return false;
                    }

                    iteration++;
                }
            }
            else
            {
                int final = 0;
                foreach (var stack in stacks)
                {
                    final += stack;
                }

                if (!Give(task, owner, final, skin))
                {
                    return false;
                }
            }

            task.cancelled = true;
            return true;
        }

        public bool Give(ItemCraftTask task, BasePlayer owner, int amount, ulong skin)
        {
            Item item = null;
            try
            {
                item = ItemManager.CreateByItemID(task.blueprint.targetItem.itemid, amount, skin);
            }
            catch (Exception e)
            {
                PrintError($"Exception creating item! targetItem: {task.blueprint.targetItem}-{amount}-{skin}; Exception: {e}");
            }

            if (item == null)
            {
                return false;
            }

            if (item.hasCondition && task.conditionScale != 1f)
            {
                item.maxCondition *= task.conditionScale;
                item.condition = item.maxCondition;
            }

            item.OnVirginSpawn();

            if (task.instanceData != null)
            {
                item.instanceData = task.instanceData;
            }

            Interface.CallHook("OnItemCraftFinished", task, item, owner.inventory.crafting);

            if (owner.inventory.GiveItem(item, false, null))
            {
                owner.Command("note.inv", new object[]{item.info.itemid, amount});
                return true;
            }

            ItemContainer itemContainer = owner.inventory.crafting.containers.First<ItemContainer>();
            owner.Command("note.inv", new object[]{item.info.itemid, item.amount});
            owner.Command("note.inv", new object[]{item.info.itemid, -item.amount});
            item.Drop(itemContainer.dropPosition, itemContainer.dropVelocity, default(Quaternion));

            return true;
        }

        public int FreeSlots(BasePlayer player)
        {
            var slots = player.inventory.containerMain.capacity + player.inventory.containerBelt.capacity;
            var taken = player.inventory.containerMain.itemList.Count + player.inventory.containerBelt.itemList.Count;
            return slots - taken;
        }

        public List<int> GetStacks(ItemDefinition item, int amount) 
        {
            var list = new List<int>();
            var maxStack = item.stackable;

            if (maxStack == 0)
            {
                maxStack = 1;
            }

            while (amount > maxStack)
            {
                amount -= maxStack;
                list.Add(maxStack);
            }
            
            list.Add(amount);
            
            return list; 
        }

        public bool HasPlace(int slots, List<int> stacks)
        {
            if (!_config.checkPlace)
            {
                return true;
            }

            if (_config.split && slots - stacks.Count < 0)
            {
                return false;
            }

            return slots > 0;
        }
        #endregion

        #region Localization 1.1.1
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"Blocked", "Crafting of that item is blocked!"},
                {"Slots", "You don't have enough place to craft! Need {0}, have {1}!"},
                {"Normal", "Item will be crafted with normal speed."}
            }, this, "en");
        }

        public void Message(BasePlayer player, string messageKey, params object[] args)
        {
            if (player == null)
            {
                return;
            }

            var message = GetMessage(messageKey, player.UserIDString, args);
            player.ChatMessage(message);
        }

        public string GetMessage(string messageKey, string playerID, params object[] args)
        {
            return string.Format(lang.GetMessage(messageKey, this, playerID), args);
        }
        #endregion
        
        #region Configuration 1.1.0
        private Configuration _config;
        private class Configuration
        {
            [JsonProperty(PropertyName = "Check for free place")]
            public bool checkPlace = true;
            
            [JsonProperty(PropertyName = "Split crafted stacks")]
            public bool split = true;
            
            [JsonProperty(PropertyName = "Normal Speed")]
            public string[] normal =
            {
                "hammer",
                "put item shortname here"
            };

            [JsonProperty(PropertyName = "Blacklist")]
            public string[] blocked =
            {
                "rock",
                "put item shortname here"
            };

            public bool IsNormal(ItemCraftTask task) => normal?.Contains(task.blueprint.targetItem.shortname) ?? false;
            public bool IsBlocked(ItemCraftTask task) => blocked?.Contains(task.blueprint.targetItem.shortname) ?? false;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                _config = Config.ReadObject<Configuration>();
                SaveConfig();
            }
            catch
            {
                PrintError("Error reading config, please check!");

                Unsubscribe(nameof(OnItemCraft));
            }
        }

        protected override void LoadDefaultConfig()
        {
            _config = new Configuration();
            SaveConfig();
        }

        protected override void SaveConfig() => Config.WriteObject(_config);
        #endregion
    }
}

// --- End of file: InstantCraft.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/NoEscape.cs ---
// --- Original Local Path: BeeRust/NoEscape.cs ---

using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Rust;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("NoEscape", "OxideBro", "2.4.01")]
    public class NoEscape : RustPlugin
    {
        [PluginReference] Plugin ImageLibrary = null, SRZone = null;
        #region Class
        private static List<SphereComponent> BlockerList = new List<SphereComponent>();

        private class PlayerBlockStatus : FacepunchBehaviour
        {
            private BasePlayer Player;
            public SphereComponent CurrentBlocker;
            public double CurrentTime = config.BlockSettings.BlockLength;
            const string LayerPopup = "NoEscapePopupNotification";
            public List<Notification> Notifications = new List<Notification>();

            public class Notification
            {
                public string Id;
                public string Title;
                public string Description;
                public string Icon = "assets/icons/broadcast.png";
                public int duration = config.uIPopupNotifications.PopupDestroyTime;

                public Notification()
                {
                    Id = CuiHelper.GetGuid();
                }
            }

            public static PlayerBlockStatus Get(BasePlayer player)
            {
                return player.GetComponent<PlayerBlockStatus>() ?? player.gameObject.AddComponent<PlayerBlockStatus>();
            }

            private void Awake()
            {
                Player = GetComponent<BasePlayer>();

            }

            private void ControllerUpdate()
            {
                if (CurrentBlocker != null)
                    UpdateUI();
                else
                    UnblockPlayer();
            }

            public void CreateUI()
            {
                ins.MenuAlerts?.Call("SendAlertMenu", Player, Facepunch.Math.Epoch.Current - (int)CurrentTime, (int)config.BlockSettings.BlockLength, $"РЕЙД БЛОК", $"Вы зашли в зону рейда.Теперь вам недоступны некоторые функции сервера, телепорт, строительство, трейд и т.д", true, "button_raid_block", $"{ins.Name}");
                if (CurrentBlocker != null) UpdateUI();
            }

            public void BlockPlayer(SphereComponent blocker, bool justCreated)
            {
                if (ins.permission.UserHasPermission(Player.UserIDString, config.BlockSettings.PermissionToIgnore))
                {
                    UnblockPlayer(true);
                    return;
                }

                CurrentBlocker = blocker;
                CurrentTime = CurrentBlocker.CurrentTime;
                CreateUI();
                InvokeRepeating(ControllerUpdate, 1f, 1f);
            }

            public void UpdateUI()
            {
                Boolean IsStopRaidPlayer = ins.SRZone?.Call<Boolean>("IsStopRaid", Player) ?? false;
                if(IsStopRaidPlayer)
                {
                    ins.MenuAlerts?.Call("UpdateStartTimeMenu", Player, ((Facepunch.Math.Epoch.Current - (int)CurrentTime) + 1), $"{ins.Name}");
                }
                else
                {
                    CurrentTime++;
                }
                
                if (CurrentTime >= config.BlockSettings.BlockLength)
                    UnblockPlayer();
            }

            public void UnblockPlayer(bool DoPerm = false)
            {
                if (Player == null)
                {
                    Destroy(this);
                    return;
                }
                if (!DoPerm)
                    Player.ChatMessage(ins.Messages["blocksuccess"]);
                CancelInvoke(ControllerUpdate);
                ins.MenuAlerts?.Call("RemoveAlertMenu", Player, $"{ins.Name}");
                //CuiHelper.DestroyUi(Player, "NoEscape");
                CurrentBlocker = null;
            }
            private void OnDestroy()
            {
                ins.MenuAlerts?.Call("RemoveAlertMenu", Player, $"{ins.Name}");
                //CuiHelper.DestroyUi(Player, "NoEscape");
                //CuiHelper.DestroyUi(Player, LayerPopup);
            }


            public void Remove(string id)
            {
                var remove = Notifications.Find(v => v.Id == id);
                if (remove == null)
                    return;

                Notifications.Remove(remove);
                DrawNotifications();
            }

            public void AddNotification(Notification notification)
            {
                Notifications.Add(notification);
                StartCoroutine(DestroyNotification(notification));
                if (Notifications.Count > config.uIPopupNotifications.MaxPopupNotifications)
                    Remove(Notifications.FirstOrDefault().Id);

                DrawNotifications();
            }

            private IEnumerator DestroyNotification(Notification messageData)
            {
                yield return new WaitForSeconds(messageData.duration);

                if (messageData == null)
                    yield break;

                Notifications.Remove(messageData);
                Remove(messageData.Id);
                DrawNotifications();
            }


            public void DrawNotifications()
            {
                CuiHelper.DestroyUi(Player, LayerPopup);
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"{config.uIPopupNotifications.AnchorPosX } {config.uIPopupNotifications.AnchorPosY}", AnchorMax = $"{config.uIPopupNotifications.AnchorPosX } {config.uIPopupNotifications.AnchorPosY}", OffsetMax = "0 0" },
                    Image = { Color = "0 0 0 0" }
                }, "Overlay", LayerPopup);

                float anchor = 0;

                foreach (var notify in Notifications)
                {
                    container.Add(new CuiPanel
                    {
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = $"{-config.uIPopupNotifications.OffsetX} {anchor - config.uIPopupNotifications.OffsetY}", OffsetMax = $"0 {anchor}" },
                        Image = { Color = config.uIPopupNotifications.InterfaceColor, Material = "" }
                    }, LayerPopup, LayerPopup + notify.Id);

                    string offset = string.IsNullOrEmpty(notify.Icon) ? "5" : "50";
                    container.Add(new CuiLabel
                    {
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = $"{offset} 0", OffsetMax = "0 -5" },
                        Text = { Text = notify.Title, Align = TextAnchor.UpperLeft, Font = "robotocondensed-bold.ttf", FontSize = 14, Color = "1 1 1 0.9" }
                    }, LayerPopup + notify.Id);

                    container.Add(new CuiLabel
                    {
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = $"{offset} 0", OffsetMax = "0 -20" },
                        Text = { Text = notify.Description, Align = TextAnchor.UpperLeft, Font = "robotocondensed-regular.ttf", FontSize = 12, Color = "1 1 1 0.8" }
                    }, LayerPopup + notify.Id);

                    if (!string.IsNullOrEmpty(notify.Icon))
                    {
                        container.Add(new CuiButton
                        {
                            RectTransform = { AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "10 -15", OffsetMax = "40 15" },
                            Button = { Color = "0.99 0.68 0.69 1.00", Sprite = notify.Icon },
                            Text = { Text = "" }
                        }, LayerPopup + notify.Id);
                    }


                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = "-15 -15", OffsetMax = "0 0" },
                        Button = { Color = "0 0 0 0.5", Command = $"noescape_popup {notify.Id}" },
                        Text = { Text = "X", Align = TextAnchor.MiddleCenter, FontSize = 9, Font = "robotocondensed-regular.ttf" }
                    }, LayerPopup + notify.Id);
                    anchor -= config.uIPopupNotifications.OffsetY + config.uIPopupNotifications.OffsetSkip;
                }

                CuiHelper.AddUi(Player, container);
            }
        }

        [ConsoleCommand("noescape_popup")]
        void cmdNoEscapePopupClose(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            var obj = PlayerBlockStatus.Get(player);

            var not = obj.Notifications.Find(v => v.Id == args.Args[0]);
            if (not != null)
            {
                obj.Notifications.Remove(not);
                obj.DrawNotifications();
            }
        }

        public void AddPlayerNotification(BasePlayer player, string attacker, string grid)
        {
            if (!config.uIPopupNotifications.EnabledPopup) return;
            var message = config.uIPopupNotifications.Message.Replace("%ATTACKER%", attacker).Replace("%GRID%", grid);
            PlayerBlockStatus.Get(player).AddNotification(new PlayerBlockStatus.Notification() { Description = message, Title = config.uIPopupNotifications.Title });
        }

        public class SphereComponent : FacepunchBehaviour
        {
            SphereCollider sphereCollider;
            public BasePlayer initPlayer;
            public List<ulong> Privilage = null;
            public ulong OwnerID;
            public double CurrentTime = 0;
            public double TotalTime = config.BlockSettings.BlockLength;
            void Awake()
            {
                var reply = 2808;
                if (reply == 0) { }
                gameObject.layer = (int)Layer.Reserved1;
                sphereCollider = gameObject.AddComponent<SphereCollider>();
                sphereCollider.isTrigger = true;
                sphereCollider.radius = config.BlockSettings.BlockerDistance;
            }

            public void Init(BasePlayer player, ulong owner, List<ulong> privilage)
            {
                initPlayer = player;
                OwnerID = owner;
                Privilage = privilage;
            }

            private void OnTriggerEnter(Collider other)
            {
                var target = other.GetComponentInParent<BasePlayer>();
                if (target == null) return;
                if (ins.permission.UserHasPermission(target.UserIDString, config.BlockSettings.PermissionToIgnore)) return;

                if (PlayerBlockStatus.Get(target).CurrentBlocker != null && PlayerBlockStatus.Get(target).CurrentBlocker != this && PlayerBlockStatus.Get(target).CurrentBlocker.CurrentTime > CurrentTime)
                {
                    PlayerBlockStatus.Get(target).CurrentBlocker = this;
                    PlayerBlockStatus.Get(target).CurrentTime = CurrentTime;
                    return;
                }
                if (config.BlockSettings.ShouldBlockEnter && PlayerBlockStatus.Get(target).CurrentBlocker == null)
                {
                    PlayerBlockStatus.Get(target).BlockPlayer(this, false);
                }
            }

            private void OnTriggerExit(Collider other)
            {
                if (!config.BlockSettings.UnBlockExit) return;
                var target = other.GetComponentInParent<BasePlayer>();
                if (target != null && target.userID.IsSteamId() && PlayerBlockStatus.Get(target).CurrentBlocker == this)
                    PlayerBlockStatus.Get(target).UnblockPlayer();
            }

            public void FixedUpdate()
            {
                Boolean IsStopRaidPlayer = ins.SRZone?.Call<Boolean>("IsStopRaid", transform.position) ?? false;
                if(!IsStopRaidPlayer)
                {
                    CurrentTime += Time.deltaTime;            
                }
                if (CurrentTime > TotalTime)
                {
                    if (BlockerList.Contains(this))
                        BlockerList.Remove(this);
                    Destroy(this);
                }
            }

            public bool IsInBlocker(BaseEntity player) => Vector3.Distance(player.transform.position, transform.position) < config.BlockSettings.BlockerDistance;
        }
        #endregion

        #region Variables

        static PluginConfig config;

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Благодарим за покупку плагина на сайте RustPlugin.ru. Если вы передадите этот плагин сторонним лицам знайте - это лишает вас гарантированных обновлений!");
            config = PluginConfig.DefaultConfig();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();

            if (config.PluginVersion < Version)
                UpdateConfigValues();

            Config.WriteObject(config, true);
        }

        void Loaded()
        {
            if (!config.PlayerBlockSettings.CanRepair) Unsubscribe(nameof(OnStructureRepair));
            else Subscribe(nameof(OnStructureRepair));
            if (!config.PlayerBlockSettings.CanUpgrade) Unsubscribe(nameof(CanAffordUpgrade));
            else Subscribe(nameof(CanAffordUpgrade));
            if (!config.PlayerBlockSettings.CanDefaultremove) Unsubscribe(nameof(OnStructureDemolish));
            else Subscribe(nameof(OnStructureDemolish));
            if (!config.PlayerBlockSettings.CanBuild && !config.PlayerBlockSettings.CanPlaceObjects) Unsubscribe(nameof(CanBuild));
            else Subscribe(nameof(CanBuild));
            permission.RegisterPermission(config.BlockSettings.PermissionToIgnore, this);
            permission.RegisterPermission(config.VkBotMessages.VkPrivilage, this);
            lang.RegisterMessages(Messages, this, "en");
            Messages = lang.GetMessages("en", this);
        }

        private void UpdateConfigValues()
        {
            PluginConfig baseConfig = PluginConfig.DefaultConfig();
            if (config.PluginVersion < Version)
            {
                PrintWarning("Config update detected! Updating config values...");

                if (config.PluginVersion < new VersionNumber(2, 2, 0))
                {
                    config.BlockSettings.WriteListDestroyEntity = new List<string>()
                    {
                        "barricade.metal",
                         "bed_deployed"
                    };
                    PrintWarning("Added Write List entity");
                }
                if (config.PluginVersion < new VersionNumber(2, 3, 1))
                {
                    config.PlayerBlockSettings.BlackListCommands = new List<string>()
                    {
                        "/bp",
                        "backpack.open",
                        "/trade"
                    };

                    PrintWarning("Added Black List commands");
                }
                if (config.PluginVersion < new VersionNumber(2, 4, 0))
                {
                    if (config.uIPopupNotifications == null)
                    {
                        config.uIPopupNotifications = new UIPopupNotifications();
                    }
                    PrintWarning("Added UI Popup Notifications");
                }
                PrintWarning("Config update completed!");
                config.PluginVersion = Version;
            }
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        public class UIPopupNotifications
        {
            [JsonProperty("Включить Popup Notifications")]
            public bool EnabledPopup = false;

            [JsonProperty("Цвет фона оповещения")]
            public string InterfaceColor = "0.121568628 0.419607848 0.627451 0.784313738";

            [JsonProperty("Позиция по вертикали X (0.0 - 1.0)")]
            public float AnchorPosX = 0.99f;

            [JsonProperty("Время жизни Popup оповещения в секундах")]
            public int PopupDestroyTime = 30;

            [JsonProperty("Позиция по вертикали Y (0.0 - 1.0)")]
            public float AnchorPosY = 0.99f;

            [JsonProperty("Ширина каждой панели (Offset X)")]
            public float OffsetX = 300;

            [JsonProperty("Высота каждой панели (Offset Y)")]
            public float OffsetY = 50;

            [JsonProperty("Пропуск между панелями (Offset)")]
            public float OffsetSkip = 10;

            [JsonProperty("Титл оповещения")]
            public string Title = "ОПОВЕЩЕНИЕ О РЕЙДЕ";

            [JsonProperty("Текст оповещения (%ATTACKER% - Имя атакующего, %GRID% - Грит координаты)")]
            public string Message = "ВНИМАНИЕ! Игрок <b>%ATTACKER%</b> атаковал ваше строение в квадрате <b>%GRID%</b>";

            [JsonProperty("Максимальное количество оповещений")]
            public int MaxPopupNotifications = 3;
        }

        public class UISettings
        {
            [JsonProperty("Цвет полосы активный полосы")]
            public string InterfaceColor = "0.121568628 0.419607848 0.627451 0.784313738";

            [JsonProperty("Цвет фона")]
            public string InterfaceColorBP = "1 1 1 0.3";

            [JsonProperty("Позиция AnchorMin")]
            public string AnchorMin = "0.3447913 0.112037";

            [JsonProperty("Позиция AnchorMax")]
            public string AnchorMax = "0.640625 0.1398148";
        }

        public class BlockSettings
        {
            [JsonProperty("Радиус зоны блокировки")]
            public float BlockerDistance = 150;

            [JsonProperty("Общее время блокировки в секундах")]
            public float BlockLength = 150;


            [JsonProperty("Не блокировать игрока если он создатель объекта")]
            public bool EnabledOwner = false;

            [JsonProperty("Блокировать создателя объекта какой разрушили, даже если он вне зоны рейда")]
            public bool BlockOwnersIfNotInZone = true;

            [JsonProperty("Блокировать игрока, который вошёл в активную зону блокировки")]
            public bool ShouldBlockEnter = true;

            [JsonProperty("Снимать блокировку с игрока если он вышел из зоны блокировки?")]
            public bool UnBlockExit = false;

            [JsonProperty("Не создавать блокировку если разрушенный объект не в зоне шкафа (Нету билды)")]
            public bool EnabledBuildingBlock = false;

            [JsonProperty("Блокировать всех игроков какие авторизаваны в шкафу (Если шкаф существует, и авторизованный игрок на сервере)")]
            public bool EnabledBlockAutCupboard = false;

            [JsonProperty("Привилегия, игроки с которой игнорируются РБ (на них он не действует")]
            public string PermissionToIgnore = "noescape.ignore";

            [JsonProperty("Белый список entity при разрушении каких не действует блокировка")]
            public List<string> WriteListDestroyEntity = new List<string>();
        }

        public class VkBotMessages
        {
            [JsonProperty("Включить отправку сообщения в ВК оффлайн игроку через VkBot")]
            public bool EnabledVkBOT = false;
            [JsonProperty("Сообщение какое будет отправлено игроку ({0} - Имя атакуещего, {1} - Квадрат на карте)")]
            public string Messages = "Внимание! Игрок {0} начал рейд вашего строения в квадрате {1} на сервере SERVERNAME.";
            [JsonProperty("Привилегия на использование оффлайн уведомления")]
            public string VkPrivilage = "noescape.vknotification";
        }

        public class PlayerBlockSettings
        {
            [JsonProperty("Блокировать использование китов")]
            public bool CanUseKits = true;

            [JsonProperty("Блокировать обмен между игроками (Trade)")]
            public bool CanUseTrade = true;

            [JsonProperty("Блокировать телепорты")]
            public bool CanTeleport = true;

            [JsonProperty("Блокировать удаление построек (CanRemove)")]
            public bool CanRemove = true;

            [JsonProperty("Блокировать улучшение построек (Upgrade, BuildingUpgrade и прочее)")]
            public bool CanBGrade = true;

            [JsonProperty("Блокировать удаление построек (стандартное)")]
            public bool CanDefaultremove = true;

            [JsonProperty("Блокировать строительство")]
            public bool CanBuild = true;

            [JsonProperty("Блокировать установку объектов")]
            public bool CanPlaceObjects = true;

            [JsonProperty("Блокировать ремонт построек (стандартный)")]
            public bool CanRepair = true;

            [JsonProperty("Блокировать улучшение построек (стандартное)")]
            public bool CanUpgrade = true;

            [JsonProperty("Белый список предметов какие можно строить при блокировке")]
            public List<string> WriteListBuildEntity = new List<string>();

            [JsonProperty("Черный список команд какие запрещены при рейд блоке (Чатовые и консольные)")]
            public List<string> BlackListCommands = new List<string>();

        }

        private class PluginConfig
        {
            [JsonProperty("Настройка UI")]
            public UISettings UISettings = new UISettings();

            [JsonProperty("Настройка Popup Notifications")]
            public UIPopupNotifications uIPopupNotifications = new UIPopupNotifications();

            [JsonProperty("Общая настройка блокировки")]
            public BlockSettings BlockSettings = new BlockSettings();

            [JsonProperty("Настройка запретов для игрока")]
            public PlayerBlockSettings PlayerBlockSettings = new PlayerBlockSettings();

            [JsonProperty("Настройка VkBOT")]
            public VkBotMessages VkBotMessages = new VkBotMessages();

            [JsonProperty("Версия конфигурации")]
            public VersionNumber PluginVersion = new VersionNumber();

            [JsonIgnore]
            [JsonProperty("Инициализация плагина")]
            public bool Init = false;

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig
                {
                    uIPopupNotifications = new UIPopupNotifications(),
                    BlockSettings = new BlockSettings()
                    {
                        BlockerDistance = 150,
                        BlockLength = 150,
                        BlockOwnersIfNotInZone = true,
                        ShouldBlockEnter = true,
                        UnBlockExit = false,
                        EnabledBuildingBlock = false,
                        EnabledBlockAutCupboard = false,
                        PermissionToIgnore = "noescape.ignore",
                        WriteListDestroyEntity = new List<string>()
                        {
                            "barricade.metal",
                            "bed_deployed"
                        }
                    },
                    PlayerBlockSettings = new PlayerBlockSettings()
                    {
                        CanUseKits = true,
                        CanUseTrade = true,
                        CanTeleport = true,
                        CanRemove = true,
                        CanBGrade = true,
                        CanDefaultremove = true,
                        CanBuild = true,
                        CanPlaceObjects = true,
                        CanRepair = true,
                        CanUpgrade = true,
                        WriteListBuildEntity = new List<string>()
                        {
                             "wall.external.high.stone",
                             "barricade.metal"
                        }
                    },
                    UISettings = new UISettings()
                    {
                        InterfaceColor = "0.12 0.41 0.62 0.78",
                        InterfaceColorBP = "1 1 1 0.3",
                        AnchorMin = "0.3447913 0.112037",
                        AnchorMax = "0.640625 0.1398148",
                    },
                    VkBotMessages = new VkBotMessages()
                    {
                        EnabledVkBOT = false,
                        Messages = "Внимание! Игрок {0} начал рейд вашего строения в квадрате {1} на сервере SERVERNAME.",
                        VkPrivilage = "noescape.vknotification",
                    },
                    PluginVersion = new VersionNumber(),
                };
            }
        }

        #endregion

        #region Oxide
        private static NoEscape ins;
        private void OnServerInitialized()
        {
            ins = this;
            config.Init = true;
            BasePlayer.activePlayerList.ToList().ForEach(OnPlayerConnected);

            ImageLibrary?.Call("AddImage", "https://cdn.discordapp.com/attachments/1071443662736732230/1133423223829172224/4.png", "button_raid_block");
        }

        void OnPlayerSleepEnded(BasePlayer player)
        {
            SphereComponent ActiveRaidZone = GetRaidZone(player.transform.position);
            if (ActiveRaidZone == null)
            {
                if (config.BlockSettings.UnBlockExit)
                {
                    if (PlayerBlockStatus.Get(player).CurrentBlocker != null)
                        PlayerBlockStatus.Get(player).UnblockPlayer();
                }
                return;
            }

            if (PlayerBlockStatus.Get(player).CurrentBlocker != null)
            {
                if (PlayerBlockStatus.Get(player).CurrentBlocker != ActiveRaidZone)
                    PlayerBlockStatus.Get(player).BlockPlayer(ActiveRaidZone, false);
            }
            else
            {
                PlayerBlockStatus.Get(player)?.BlockPlayer(ActiveRaidZone, false);
            }
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player.IsReceivingSnapshot)
            {
                timer.In(1f, () => OnPlayerConnected(player));
                return;
            }
            if (PlayerBlockStatus.Get(player).CurrentBlocker != null)
                PlayerBlockStatus.Get(player).CreateUI();
        }

        private void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
                if (PlayerBlockStatus.Get(player) != null)
                    UnityEngine.Object.Destroy(PlayerBlockStatus.Get(player));
            BlockerList.RemoveAll(x =>
            {
                UnityEngine.Object.Destroy(x);
                return true;
            });
        }

        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (!config.Init) return;
            if (entity == null || info == null || info.InitiatorPlayer == null || !(entity is StabilityEntity || entity is ShopFront || entity is BuildingPrivlidge)
                || config.BlockSettings.EnabledBuildingBlock && entity.GetBuildingPrivilege() == null || entity.OwnerID == 0 || config.BlockSettings.EnabledOwner && info.InitiatorPlayer.userID == entity.OwnerID) return;
            if (entity is BuildingBlock && (entity as BuildingBlock).currentGrade.gradeBase.type == BuildingGrade.Enum.Twigs
                || info?.damageTypes.GetMajorityDamageType() == DamageType.Decay || config.BlockSettings.WriteListDestroyEntity.Contains(entity.ShortPrefabName)) return;
            var alreadyBlock = BlockerList.FirstOrDefault(p => Vector3.Distance(entity.transform.position, p.transform.position) < (config.BlockSettings.BlockerDistance / 2));
            if (alreadyBlock)
            {
                alreadyBlock.CurrentTime = 0;
                if (config.BlockSettings.BlockOwnersIfNotInZone)
                {
                    var OwnerPlayer = BasePlayer.FindByID(entity.OwnerID);
                    if (OwnerPlayer != null)
                        PlayerBlockStatus.Get(OwnerPlayer).BlockPlayer(alreadyBlock, false);
                }
                PlayerBlockStatus.Get(info.InitiatorPlayer).BlockPlayer(alreadyBlock, false);
                if (entity.GetBuildingPrivilege() != null && config.BlockSettings.EnabledBlockAutCupboard)
                {
                    foreach (var aplayer in entity.GetBuildingPrivilege().authorizedPlayers)
                    {
                        var AuthPlayer = BasePlayer.Find(aplayer.userid.ToString());
                        if (AuthPlayer != null && AuthPlayer != info.InitiatorPlayer && AuthPlayer.IsConnected)
                            PlayerBlockStatus.Get(AuthPlayer).BlockPlayer(alreadyBlock, false);
                        else if (AuthPlayer == null || !AuthPlayer.IsConnected) SendOfflineMEssages(entity.transform.position, info.InitiatorPlayer.displayName, aplayer.userid);
                    }
                }
                var col = Vis.colBuffer;
                var count = Physics.OverlapSphereNonAlloc(alreadyBlock.transform.position, config.BlockSettings.BlockerDistance, col, LayerMask.GetMask("Player (Server)"));
                for (int i = 0; i < count; i++)
                {
                    var player = col[i].ToBaseEntity() as BasePlayer;
                    if (player == null) continue;
                    PlayerBlockStatus.Get(player).BlockPlayer(alreadyBlock, false);
                }
            }
            else
            {
                var obj = new GameObject();
                obj.transform.position = entity.transform.position;
                var sphere = obj.AddComponent<SphereComponent>();
                sphere.GetComponent<SphereComponent>().Init(info.InitiatorPlayer, entity.OwnerID, entity.GetBuildingPrivilege() != null ? entity.GetBuildingPrivilege().authorizedPlayers.Select(p => p.userid).ToList() : null);
                BlockerList.Add(sphere);
                PlayerBlockStatus.Get(info.InitiatorPlayer).BlockPlayer(sphere, true);
                
                Server.Broadcast($"<color=#2394cb>{GetClanTag(info.InitiatorPlayer.userID)}</color> начал рейдить <color=#2394cb>{GetClanTag(entity.OwnerID)}</color> в квадрате <color=#2394cb>{GetGridString(entity.transform.position)}</color>");
                var OwnerPlayer = BasePlayer.FindByID(entity.OwnerID);
                if (OwnerPlayer == null || !OwnerPlayer.IsConnected)
                {
                    SendOfflineMEssages(entity.transform.position, info.InitiatorPlayer.displayName, entity.OwnerID);
                }
                else if (OwnerPlayer != null)
                {
                    if (config.BlockSettings.BlockOwnersIfNotInZone) PlayerBlockStatus.Get(OwnerPlayer)?.BlockPlayer(sphere, false);
                    OwnerPlayer.ChatMessage(string.Format(Messages["blockactive"], GetGridString(entity.transform.position), NumericalFormatter.FormatTime(config.BlockSettings.BlockLength)));
                    AddPlayerNotification(OwnerPlayer, info.InitiatorPlayer.displayName, GetGridString(entity.transform.position));

                }
                var col = Vis.colBuffer;
                var count = Physics.OverlapSphereNonAlloc(sphere.transform.position, config.BlockSettings.BlockerDistance, col, LayerMask.GetMask("Player (Server)"));
                for (int i = 0; i < count; i++)
                {
                    var player = col[i].ToBaseEntity() as BasePlayer;
                    if (player == null || !player.IsConnected || OwnerPlayer == player) continue;
                    PlayerBlockStatus.Get(player).BlockPlayer(sphere, false);
                }

                if (entity.GetBuildingPrivilege() != null && config.BlockSettings.EnabledBlockAutCupboard)
                {
                    foreach (var aplayer in entity.GetBuildingPrivilege().authorizedPlayers)
                    {
                        var AuthPlayer = BasePlayer.Find(aplayer.userid.ToString());
                        if (AuthPlayer != null && AuthPlayer != info.InitiatorPlayer && OwnerPlayer != AuthPlayer)
                        {
                            PlayerBlockStatus.Get(AuthPlayer).BlockPlayer(sphere, false);
                            AddPlayerNotification(AuthPlayer, info.InitiatorPlayer.displayName, GetGridString(entity.transform.position));
                            SendReply(AuthPlayer, string.Format(Messages["blockactiveAuthCup"], GetGridString(entity.transform.position), NumericalFormatter.FormatTime(config.BlockSettings.BlockLength)));
                        }
                        else if (AuthPlayer != info.InitiatorPlayer && OwnerPlayer != AuthPlayer) SendOfflineMEssages(entity.transform.position, info.InitiatorPlayer.displayName, aplayer.userid);
                    }
                }
            }
        }

        [PluginReference] private Plugin Clans = null, MenuAlerts = null;

        private string GetClanTag(ulong id) => (string)Clans?.CallHook("GetClanTag", id);

        object CanBuild(Planner planner, Construction prefab, Construction.Target target)
        {
            var player = planner.GetOwnerPlayer();
            if (player == null || !IsRaidBlocked(player)) return null;
            var shortname = prefab.hierachyName.Substring(prefab.hierachyName.IndexOf("/") + 1);
            if (config.PlayerBlockSettings.WriteListBuildEntity.Contains(shortname))
                return null;
            var component = PlayerBlockStatus.Get(player);
            if (component == null || component.CurrentBlocker == null) return null;
            player.ChatMessage(string.Format(Messages["blockbuld"], NumericalFormatter.FormatTime(component.CurrentBlocker.TotalTime - component.CurrentTime)));
            return false;
        }

        private object OnUserCommand(IPlayer ipl, string command, string[] args)
        {
            if (ipl == null || !ipl.IsConnected) return null;
            var player = ipl.Object as BasePlayer;
            command = command.Insert(0, "/");
            if (player == null || !IsRaidBlocked(player)) return null;
            if (config.PlayerBlockSettings.BlackListCommands.Contains(command.ToLower()))
            {
                var component = PlayerBlockStatus.Get(player);
                if (component == null || component.CurrentBlocker == null) return null;
                player.ChatMessage(string.Format(Messages["commandBlock"], NumericalFormatter.FormatTime(component.CurrentBlocker.TotalTime - component.CurrentTime)));
                return false;
            }
            return null;
        }

        private object OnServerCommand(ConsoleSystem.Arg arg)
        {
            var connection = arg.Connection;
            if (connection == null || string.IsNullOrEmpty(arg.cmd?.FullName)) return null;
            var player = arg.Player();
            if (player == null || !IsRaidBlocked(player)) return null;
            if (config.PlayerBlockSettings.BlackListCommands.Contains(arg.cmd.Name.ToLower()) || config.PlayerBlockSettings.BlackListCommands.Contains(arg.cmd.FullName.ToLower()))
            {
                var component = PlayerBlockStatus.Get(player);
                if (component == null || component.CurrentBlocker == null) return null;
                player.ChatMessage(string.Format(Messages["commandBlock"], NumericalFormatter.FormatTime(component.CurrentBlocker.TotalTime - component.CurrentTime)));
                return false;
            }
            return null;
        }

        #endregion

        #region Functions
        private string GetGridString(Vector3 pos)
        {
            char letter = 'A';
            var x = Mathf.Floor((pos.x + (ConVar.Server.worldsize / 2)) / 146.3f) % 26;
            var z = (Mathf.Floor(ConVar.Server.worldsize / 146.3f) - 1) - Mathf.Floor((pos.z + (ConVar.Server.worldsize / 2)) / 146.3f);
            letter = (char)(((int)letter) + x);
            return $"{letter}{z}";
        }

        private string NumberToString(int number)
        {
            bool a = number > 26;
            Char c = (Char)(65 + (a ? number - 26 : number));
            return a ? "A" + c : c.ToString();
        }

        [PluginReference] private Plugin VKBot;
        private static void SendOfflineMEssages(Vector3 pos, string name = "", ulong playerid = 2875392)
        {
            if (!ins.permission.UserHasPermission(playerid.ToString(), config.VkBotMessages.VkPrivilage)) return;
            string receiver = (string)ins.VKBot?.Call("GetUserVKId", playerid) ?? "";
            if (string.IsNullOrEmpty(receiver)) return;
            ins.VKBot?.Call("SendVkMessage", receiver, config.VkBotMessages.Messages.Replace("{0}", name).Replace("{1}", ins.GetGridString(pos)));
        }

        private string GetFormatTime(TimeSpan timespan)
        {
            return string.Format(timespan.TotalHours >= 1 ? "{2:00}:{0:00}:{1:00}" : "{0:00}:{1:00}", timespan.Minutes, timespan.Seconds, System.Math.Floor(timespan.TotalHours));
        }

        private static class NumericalFormatter
        {
            private static string GetNumEndings(int origNum, string[] forms)
            {
                string result;
                var num = origNum % 100;
                if (num >= 11 && num <= 19)
                {
                    result = forms[2];
                }
                else
                {
                    num = num % 10;
                    switch (num)
                    {
                        case 1: result = forms[0]; break;
                        case 2:
                        case 3:
                        case 4:
                            result = forms[1]; break;
                        default:
                            result = forms[2]; break;
                    }
                }
                return string.Format("{0} {1} ", origNum, result);
            }

            private static string FormatSeconds(int seconds) =>
                GetNumEndings(seconds, new[] { "секунду", "секунды", "секунд" });
            private static string FormatMinutes(int minutes) =>
                GetNumEndings(minutes, new[] { "минуту", "минуты", "минут" });
            private static string FormatHours(int hours) =>
                GetNumEndings(hours, new[] { "час", "часа", "часов" });
            private static string FormatDays(int days) =>
                GetNumEndings(days, new[] { "день", "дня", "дней" });
            private static string FormatTime(TimeSpan timeSpan)
            {
                string result = string.Empty;
                if (timeSpan.Days > 0)
                    result += FormatDays(timeSpan.Days);
                if (timeSpan.Hours > 0)
                    result += FormatHours(timeSpan.Hours);
                if (timeSpan.Minutes > 0)
                    result += FormatMinutes(timeSpan.Minutes);
                if (timeSpan.Seconds > 0)
                    result += FormatSeconds(timeSpan.Seconds).TrimEnd(' ');
                return result;
            }

            public static string FormatTime(int seconds) => FormatTime(new TimeSpan(0, 0, seconds));
            public static string FormatTime(float seconds) => FormatTime((int)Math.Round(seconds));
            public static string FormatTime(double seconds) => FormatTime((int)Math.Round(seconds));
        }
        #endregion

        #region API
        private void UnblockedPlayer(BasePlayer player)
        {
            var component = PlayerBlockStatus.Get(player);
            if (component == null) return;

            if (component.CurrentBlocker != null)
                component.UnblockPlayer();
        }

        private bool IsBlocked(BasePlayer player) => IsRaidBlocked(player);

        private List<Vector3> ApiGetOwnerRaidZones(ulong playerid)
        {
            var OwnerList = BlockerList.Where(p => p.OwnerID == playerid || p.Privilage != null && p.Privilage.Contains(playerid)).Select(p => p.transform.position).ToList();
            return OwnerList;
        }

        private List<Vector3> ApiGetAllRaidZones()
          => BlockerList.Select(p => p.transform.position).ToList();

        private bool IsRaidBlock(ulong userId) => IsRaidBlocked(userId.ToString());

        private bool IsRaidBlocked(BasePlayer player) => PlayerBlockStatus.Get(player)?.CurrentBlocker != null;

        private bool IsRaidBlocked(string player)
        {
            BasePlayer target = BasePlayer.Find(player);
            if (target == null) return false;

            return IsRaidBlocked(target);
        }

        private int ApiGetTime(ulong userId)
        {
            if (!IsRaidBlocked(userId.ToString())) return 0;
            var targetBlock = PlayerBlockStatus.Get(BasePlayer.Find(userId.ToString()));
            return (int)(targetBlock.CurrentBlocker.TotalTime - targetBlock.CurrentTime);
        }

        private string CanTeleport(BasePlayer player)
        {
            if (!config.PlayerBlockSettings.CanTeleport) return null;
            if (!IsRaidBlocked(player)) return null;
            var component = PlayerBlockStatus.Get(player);
            if (component == null) return null;
            return string.Format(Messages["blocktp"], NumericalFormatter.FormatTime(component.CurrentBlocker.TotalTime - component.CurrentTime));
        }

        private int? CanBGrade(BasePlayer player, int grade, BuildingBlock block, Planner plan)
        {
            if (!config.PlayerBlockSettings.CanBGrade) return null;
            if (!IsRaidBlocked(player)) return null;
            var component = PlayerBlockStatus.Get(player);
            if (component == null) return null;
            player.ChatMessage(string.Format(Messages["blockupgrade"], NumericalFormatter.FormatTime(component.CurrentBlocker.TotalTime - component.CurrentTime)));
            return 0;
        }

        private string CanTrade(BasePlayer player)
        {
            if (!config.PlayerBlockSettings.CanUseTrade) return null;
            if (!IsRaidBlocked(player)) return null;
            var component = PlayerBlockStatus.Get(player);
            if (component == null) return null;
            return string.Format(Messages["blocktrade"], NumericalFormatter.FormatTime(component.CurrentBlocker.TotalTime - component.CurrentTime));
        }

        private string canRemove(BasePlayer player)
        {

            if (!config.PlayerBlockSettings.CanRemove) return null;
            if (!IsRaidBlocked(player)) return null;
            var component = PlayerBlockStatus.Get(player);
            if (component == null) return null;
            return string.Format(Messages["blockremove"], NumericalFormatter.FormatTime(component.CurrentBlocker.TotalTime - component.CurrentTime));
        }

        private string canTeleport(BasePlayer player)
        {
            if (!config.PlayerBlockSettings.CanTeleport) return null;
            if (!IsRaidBlocked(player)) return null;
            var component = PlayerBlockStatus.Get(player);
            if (component == null) return null;
            return string.Format(Messages["blocktp"], NumericalFormatter.FormatTime(component.CurrentBlocker.TotalTime - component.CurrentTime));
        }

        object canRedeemKit(BasePlayer player)
        {
            if (!config.PlayerBlockSettings.CanUseKits) return null;

            if (!IsRaidBlocked(player)) return null;
            var component = PlayerBlockStatus.Get(player);
            if (component == null) return null;
            return string.Format(Messages["blockKits"], NumericalFormatter.FormatTime(component.CurrentBlocker.TotalTime - component.CurrentTime));
        }

        private bool? CanAffordUpgrade(BasePlayer player, BuildingBlock block, BuildingGrade.Enum grade)
        {
            if (!IsRaidBlocked(player)) return null;
            var component = PlayerBlockStatus.Get(player);
            if (component == null) return null;
            player.ChatMessage(string.Format(Messages["blockupgrade"], NumericalFormatter.FormatTime(component.CurrentBlocker.TotalTime - component.CurrentTime)));
            return false;
        }

        private bool? OnStructureRepair(BaseCombatEntity entity, BasePlayer player)
        {
            if (!config.PlayerBlockSettings.CanRepair) return null;
            if (!IsRaidBlocked(player)) return null;
            var component = PlayerBlockStatus.Get(player);
            if (component == null) return null;
            player.ChatMessage(string.Format(Messages["blockrepair"], NumericalFormatter.FormatTime(component.CurrentBlocker.TotalTime - component.CurrentTime)));
            return false;
        }

        object OnStructureDemolish(BaseCombatEntity entity, BasePlayer player)
        {
            if (!config.PlayerBlockSettings.CanDefaultremove) return null;
            if (player == null) return null;
            if (!IsRaidBlocked(player)) return null;
            var component = PlayerBlockStatus.Get(player);
            if (component == null) return null;
            player.ChatMessage(string.Format(Messages["blockremove"], NumericalFormatter.FormatTime(component.CurrentBlocker.TotalTime - component.CurrentTime)));
            return null;
        }

        private SphereComponent GetRaidZone(Vector3 pos) =>
             BlockerList.Where(p => Vector3.Distance(p.transform.position, pos) < config.BlockSettings.BlockerDistance).FirstOrDefault();

        #endregion

        #region Messages

        Dictionary<string, string> Messages = new Dictionary<string, string>() {
                {
                "blocksuccess", "Блок деактивирован. Функции разблокированы"
            }
            , {
                "guitimertext", "Блок: {0}"
            }
            , {
                "blockactive", "Ваше строение в квадрате <color=#ECBE13>{0}</color> разрушено, активирован рейд блок на <color=#ECBE13>{1}</color>\nНекоторые функции временно недоступны."
            }
             , {
                "blockactiveOwner", "Внимание! Ваше строение в квадрате <color=#ECBE13>{0}</color> разрушено."
            }
             , {
                "enterRaidZone", "Внимание! Вы вошли в зону рейд блока, активирован блок на <color=#ECBE13>{0}</color>\nНекоторые функции временно недоступны."
            }
             , {
                "blockactiveAuthCup", "Внимание! Строение в каком вы проживаете в квадрате <color=#ECBE13>{0}</color> было разрушено, активирован рейд блок на <color=#ECBE13>{1}</color>\nНекоторые функции временно недоступны."
            }
            , {
                "blockactiveAttacker", "Вы уничтожили чужой объект, активирован рейд блок на <color=#ECBE13>{0}</color>\nНекоторые функции временно недоступны."
            }
            , {
                "blockrepair", "Вы не можете ремонтировать строения во время рейда, подождите {0}"
            }
            , {
                "blocktp", "Вы не можете использовать телепорт во время рейда, подождите {0}"
            }
            , {
                "blockremove", "Вы не можете удалить постройки во время рейда, подождите {0}"
            }
            , {
                "blockupgrade", "Вы не можете использовать улучшение построек во время рейда, подождите {0}"
            }
            , {
                "blockKits", "Вы не можете использовать киты во время рейда, подождите {0}"
            }
            , {
                "blockbuld", "Вы не можете строить во время рейда, подождите {0}"
            },
            {
                "raidremove", "Вы не можете удалять обьекты во время рейда, подождите {0}"
            },
            {
                "blocktrade", "Вы не можете использовать обмен во время рейда, подождите {0} "
            },
            {
                "commandBlock", "Вы не можете использовать данную команду во время рейда, подождите {0}"
            },
        };
        #endregion
    }
}

// --- End of file: NoEscape.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/DiscordLogger.cs ---
// --- Original Local Path: BeeRust/DiscordLogger.cs ---

﻿using System;
using System.Collections.Generic;
using System.Net;
using System.Text.RegularExpressions;
using System.Text;

using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Discord Logger", "MON@H", "2.0.13")]
    [Description("Logs events to Discord channels using webhooks")]
    class DiscordLogger : RustPlugin
    {
        #region Variables

        [PluginReference] private Plugin AntiSpam, BetterChatMute, CallHeli, PersonalHeli, UFilter;

        private readonly Hash<ulong, CargoShip> _cargoShips = new Hash<ulong, CargoShip>();
        private readonly List<ulong> _listBadCargoShips = new List<ulong>();
        private readonly List<ulong> _listSupplyDrops = new List<ulong>();
        private readonly Queue<QueuedMessage> _queue = new Queue<QueuedMessage>();
        private readonly StringBuilder _sb = new StringBuilder();

        private EventSettings _eventSettings;
        private int _retryCount = 0;
        private object _resultCall;
        private QueuedMessage _nextMessage;
        private QueuedMessage _queuedMessage;
        private string _langKey;
        private string[] _profanities;
        private Timer _timerQueue;
        private Timer _timerQueueCooldown;
        private ulong _entityID;
        private Vector3 _locationLargeOilRig;
        private Vector3 _locationOilRig;

        private readonly List<Regex> _regexTags = new List<Regex>
        {
            new Regex("<color=.+?>", RegexOptions.Compiled),
            new Regex("<size=.+?>", RegexOptions.Compiled)
        };

        private readonly List<string> _tags = new List<string>
        {
            "</color>",
            "</size>",
            "<i>",
            "</i>",
            "<b>",
            "</b>"
        };

        private class QueuedMessage
        {
            public string WebhookUrl {set; get;}
            public string Message {set; get;}
        }

        private enum TeamEventType
        {
            Created,
            Disbanded,
            Updated,
        }

        private class Response {
            [JsonProperty("country")]
            public string Country { get; set; }

            [JsonProperty("countryCode")]
            public string CountryCode { get; set; }
        }

        #endregion Variables

        #region Initialization

        private void Init()
        {
            UnsubscribeHooks();
        }

        private void Unload()
        {
            Application.logMessageReceivedThreaded -= HandleLog;
        }

        private void OnServerInitialized(bool isStartup)
        {
            if (isStartup && _configData.ServerStateSettings.Enabled)
            {
                LogToConsole("Server is online again!");

                DiscordSendMessage(Lang(LangKeys.Event.Initialized), _configData.ServerStateSettings.WebhookURL);
            }

            CacheOilRigsLocation();
            SubscribeHooks();
        }

        private void OnServerShutdown()
        {
            if (_configData.ServerStateSettings.Enabled)
            {
                LogToConsole("Server is shutting down!");

                string url = GetWebhookURL(_configData.ServerStateSettings.WebhookURL);

                if (!string.IsNullOrEmpty(url))
                {
                    webrequest.Enqueue(url, new DiscordMessage(Lang(LangKeys.Event.Shutdown)).ToJson(), DiscordSendMessageCallback, null, RequestMethod.POST, _headers);
                }
            }
        }

        #endregion Initialization

        #region Configuration

        private ConfigData _configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Global settings")]
            public GlobalSettings GlobalSettings = new GlobalSettings();

            [JsonProperty(PropertyName = "Admin Hammer settings")]
            public EventSettings AdminHammerSettings = new EventSettings();

            [JsonProperty(PropertyName = "Admin Radar settings")]
            public EventSettings AdminRadarSettings = new EventSettings();

            [JsonProperty(PropertyName = "Bradley settings")]
            public EventSettings BradleySettings = new EventSettings();

            [JsonProperty(PropertyName = "Cargo Ship settings")]
            public EventSettings CargoShipSettings = new EventSettings();

            [JsonProperty(PropertyName = "Cargo Plane settings")]
            public EventSettings CargoPlaneSettings = new EventSettings();

            [JsonProperty(PropertyName = "Chat settings")]
            public EventSettings ChatSettings = new EventSettings();

            [JsonProperty(PropertyName = "Chat (Team) settings")]
            public EventSettings ChatTeamSettings = new EventSettings();

            [JsonProperty(PropertyName = "CH47 Helicopter settings")]
            public EventSettings ChinookSettings = new EventSettings();

            [JsonProperty(PropertyName = "Christmas settings")]
            public EventSettings ChristmasSettings = new EventSettings();

            [JsonProperty(PropertyName = "Clan settings")]
            public EventSettings ClanSettings = new EventSettings();

            [JsonProperty(PropertyName = "Dangerous Treasures settings")]
            public EventSettings DangerousTreasuresSettings = new EventSettings();

            [JsonProperty(PropertyName = "Duel settings")]
            public EventSettings DuelSettings = new EventSettings();

            [JsonProperty(PropertyName = "Godmode settings")]
            public EventSettings GodmodeSettings = new EventSettings();

            [JsonProperty(PropertyName = "Easter settings")]
            public EventSettings EasterSettings = new EventSettings();

            [JsonProperty(PropertyName = "Error settings")]
            public EventSettings ErrorSettings = new EventSettings();

            [JsonProperty(PropertyName = "Hackable Locked Crate settings")]
            public EventSettings LockedCrateSettings = new EventSettings();

            [JsonProperty(PropertyName = "Halloween settings")]
            public EventSettings HalloweenSettings = new EventSettings();

            [JsonProperty(PropertyName = "Helicopter settings")]
            public EventSettings HelicopterSettings = new EventSettings();

            [JsonProperty(PropertyName = "NTeleportation settings")]
            public EventSettings NTeleportationSettings = new EventSettings();

            [JsonProperty(PropertyName = "Permissions settings")]
            public EventSettings PermissionsSettings = new EventSettings();

            [JsonProperty(PropertyName = "Player death settings")]
            public EventSettings PlayerDeathSettings = new EventSettings();

            [JsonProperty(PropertyName = "Player DeathNotes settings")]
            public EventSettings PlayerDeathNotesSettings = new EventSettings();

            [JsonProperty(PropertyName = "Player connect advanced info settings")]
            public EventSettings PlayerConnectedInfoSettings = new EventSettings();

            [JsonProperty(PropertyName = "Player connect settings")]
            public EventSettings PlayerConnectedSettings = new EventSettings();

            [JsonProperty(PropertyName = "Player disconnect settings")]
            public EventSettings PlayerDisconnectedSettings = new EventSettings();

            [JsonProperty(PropertyName = "Player Respawned settings")]
            public EventSettings PlayerRespawnedSettings = new EventSettings();

            [JsonProperty(PropertyName = "Private Messages settings")]
            public EventSettings PrivateMessagesSettings = new EventSettings();

            [JsonProperty(PropertyName = "Raidable Bases settings")]
            public EventSettings RaidableBasesSettings = new EventSettings();

            [JsonProperty(PropertyName = "Rcon command settings")]
            public EventSettings RconCommandSettings = new EventSettings();

            [JsonProperty(PropertyName = "Rcon connection settings")]
            public EventSettings RconConnectionSettings = new EventSettings();

            [JsonProperty(PropertyName = "Rust Kits settings")]
            public EventSettings RustKitsSettings = new EventSettings();

            [JsonProperty(PropertyName = "SantaSleigh settings")]
            public EventSettings SantaSleighSettings = new EventSettings();

            [JsonProperty(PropertyName = "Server messages settings")]
            public EventSettings ServerMessagesSettings = new EventSettings();

            [JsonProperty(PropertyName = "Server state settings")]
            public EventSettings ServerStateSettings = new EventSettings();

            [JsonProperty(PropertyName = "Supply Drop settings")]
            public EventSettings SupplyDropSettings = new EventSettings();

            [JsonProperty(PropertyName = "Teams settings")]
            public EventSettings TeamsSettings = new EventSettings();

            [JsonProperty(PropertyName = "User Banned settings")]
            public EventSettings UserBannedSettings = new EventSettings();

            [JsonProperty(PropertyName = "User Kicked settings")]
            public EventSettings UserKickedSettings = new EventSettings();

            [JsonProperty(PropertyName = "User Muted settings")]
            public EventSettings UserMutedSettings = new EventSettings();

            [JsonProperty(PropertyName = "User Name Updated settings")]
            public EventSettings UserNameUpdateSettings = new EventSettings();

            [JsonProperty(PropertyName = "Vanish settings")]
            public EventSettings VanishSettings = new EventSettings();
        }

        private class GlobalSettings
        {
            [JsonProperty(PropertyName = "Log to console?")]
            public bool LoggingEnabled = false;

            [JsonProperty(PropertyName = "Use AntiSpam plugin on chat messages")]
            public bool UseAntiSpam = false;

            [JsonProperty(PropertyName = "Use UFilter plugin on chat messages")]
            public bool UseUFilter = false;

            [JsonProperty(PropertyName = "Hide admin connect/disconnect messages")]
            public bool HideAdmin = false;

            [JsonProperty(PropertyName = "Hide NPC death messages")]
            public bool HideNPC = false;

            [JsonProperty(PropertyName = "Replacement string for tags")]
            public string TagsReplacement = "`";

            [JsonProperty(PropertyName = "Queue interval (1 message per ? seconds)")]
            public float QueueInterval = 1f;

            [JsonProperty(PropertyName = "Queue cooldown if connection error (seconds)")]
            public float QueueCooldown = 60f;

            [JsonProperty(PropertyName = "Default WebhookURL")]
            public string DefaultWebhookURL = string.Empty;

            [JsonProperty(PropertyName = "RCON command blacklist", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> RCONCommandBlacklist = new List<string>()
            {
                "playerlist",
                "status"
            };
        }

        private class EventSettings
        {
            [JsonProperty(PropertyName = "WebhookURL")]
            public string WebhookURL = "";

            [JsonProperty(PropertyName = "Enabled?")]
            public bool Enabled = false;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _configData = Config.ReadObject<ConfigData>();
                if (_configData == null)
                {
                    LoadDefaultConfig();
                    SaveConfig();
                }
            }
            catch
            {
                PrintError("The configuration file is corrupted");
                LoadDefaultConfig();
                SaveConfig();
            }
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            _configData = new ConfigData();
        }

        protected override void SaveConfig() => Config.WriteObject(_configData);

        #endregion Configuration

        #region Localization

        private string Lang(string key, string userIDString = null, params object[] args)
        {
            try
            {
                return string.Format(lang.GetMessage(key, this, userIDString).Replace("{time}", DateTime.Now.ToShortTimeString()), args);
            }
            catch (Exception ex)
            {
                PrintError($"Lang Key '{key}' threw exception:\n{ex}");
                throw;
            }
        }

        private static class LangKeys
        {
            public static class Event
            {
                private const string Base = nameof(Event) + ".";
                public const string Bradley = Base + nameof(Bradley);
                public const string CargoPlane = Base + nameof(CargoPlane);
                public const string CargoShip = Base + nameof(CargoShip);
                public const string Chat = Base + nameof(Chat);
                public const string ChatTeam = Base + nameof(ChatTeam);
                public const string Chinook = Base + nameof(Chinook);
                public const string Christmas = Base + nameof(Christmas);
                public const string Death = Base + nameof(Death);
                public const string Easter = Base + nameof(Easter);
                public const string EasterWinner = Base + nameof(EasterWinner);
                public const string Error = Base + nameof(Error);
                public const string Halloween = Base + nameof(Halloween);
                public const string HalloweenWinner = Base + nameof(HalloweenWinner);
                public const string Helicopter = Base + nameof(Helicopter);
                public const string Initialized = Base + nameof(Initialized);
                public const string LockedCrate = Base + nameof(LockedCrate);
                public const string PlayerConnected = Base + nameof(PlayerConnected);
                public const string PlayerConnectedInfo = Base + nameof(PlayerConnectedInfo);
                public const string PlayerDisconnected = Base + nameof(PlayerDisconnected);
                public const string PlayerRespawned = Base + nameof(PlayerRespawned);
                public const string RconCommand = Base + nameof(RconCommand);
                public const string RconConnection = Base + nameof(RconConnection);
                public const string SantaSleigh = Base + nameof(SantaSleigh);
                public const string ServerMessage = Base + nameof(ServerMessage);
                public const string Shutdown = Base + nameof(Shutdown);
                public const string SupplyDrop = Base + nameof(SupplyDrop);
                public const string SupplyDropLanded = Base + nameof(SupplyDropLanded);
                public const string SupplySignal = Base + nameof(SupplySignal);
                public const string Team = Base + nameof(Team);
                public const string UserBanned = Base + nameof(UserBanned);
                public const string UserKicked = Base + nameof(UserKicked);
                public const string UserMuted = Base + nameof(UserMuted);
                public const string UserNameUpdated = Base + nameof(UserNameUpdated);
                public const string UserUnbanned = Base + nameof(UserUnbanned);
                public const string UserUnmuted = Base + nameof(UserUnmuted);
            }

            public static class Permission
            {
                private const string Base = nameof(Permission) + ".";
                public const string GroupCreated = Base + nameof(GroupCreated);
                public const string GroupDeleted = Base + nameof(GroupDeleted);
                public const string UserGroupAdded = Base + nameof(UserGroupAdded);
                public const string UserGroupRemoved = Base + nameof(UserGroupRemoved);
                public const string UserPermissionGranted = Base + nameof(UserPermissionGranted);
                public const string UserPermissionRevoked = Base + nameof(UserPermissionRevoked);
            }

            public static class Plugin
            {
                private const string Base = nameof(Plugin) + ".";
                public const string AdminHammerOff = Base + nameof(AdminHammerOff);
                public const string AdminHammerOn = Base + nameof(AdminHammerOn);
                public const string AdminRadarOff = Base + nameof(AdminRadarOff);
                public const string AdminRadarOn = Base + nameof(AdminRadarOn);
                public const string ClanCreated = Base + nameof(ClanCreated);
                public const string ClanDisbanded = Base + nameof(ClanDisbanded);
                public const string DangerousTreasuresEnded = Base + nameof(DangerousTreasuresEnded);
                public const string DangerousTreasuresStarted = Base + nameof(DangerousTreasuresStarted);
                public const string DeathNotes = Base + nameof(DeathNotes);
                public const string Duel = Base + nameof(Duel);
                public const string GodmodeOff = Base + nameof(GodmodeOff);
                public const string GodmodeOn = Base + nameof(GodmodeOn);
                public const string NTeleportation = Base + nameof(NTeleportation);
                public const string PersonalHelicopter = Base + nameof(PersonalHelicopter);
                public const string PrivateMessage = Base + nameof(PrivateMessage);
                public const string RaidableBaseCompleted = Base + nameof(RaidableBaseCompleted);
                public const string RaidableBaseEnded = Base + nameof(RaidableBaseEnded);
                public const string RaidableBaseStarted = Base + nameof(RaidableBaseStarted);
                public const string RustKits = Base + nameof(RustKits);
                public const string TimedGroupAdded = Base + nameof(TimedGroupAdded);
                public const string TimedGroupExtended = Base + nameof(TimedGroupExtended);
                public const string TimedPermissionExtended = Base + nameof(TimedPermissionExtended);
                public const string TimedPermissionGranted = Base + nameof(TimedPermissionGranted);
                public const string VanishOff = Base + nameof(VanishOff);
                public const string VanishOn = Base + nameof(VanishOn);
            }

            public static class Format
            {
                private const string Base = nameof(Format) + ".";
                public const string CargoShip = Base + nameof(CargoShip);
                public const string Created = Base + nameof(Created);
                public const string Day = Base + nameof(Day);
                public const string Days = Base + nameof(Days);
                public const string Disbanded = Base + nameof(Disbanded);
                public const string Easy = Base + nameof(Easy);
                public const string Expert = Base + nameof(Expert);
                public const string Hard = Base + nameof(Hard);
                public const string Hour = Base + nameof(Hour);
                public const string Hours = Base + nameof(Hours);
                public const string LargeOilRig = Base + nameof(LargeOilRig);
                public const string Medium = Base + nameof(Medium);
                public const string Minute = Base + nameof(Minute);
                public const string Minutes = Base + nameof(Minutes);
                public const string Nightmare = Base + nameof(Nightmare);
                public const string OilRig = Base + nameof(OilRig);
                public const string Second = Base + nameof(Second);
                public const string Seconds = Base + nameof(Seconds);
                public const string Updated = Base + nameof(Updated);
            }
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [LangKeys.Event.Bradley] = ":dagger: {time} Bradley spawned `{0}`",
                [LangKeys.Event.CargoPlane] = ":airplane: {time} Cargo Plane incoming `{0}`",
                [LangKeys.Event.CargoShip] = ":ship: {time} Cargo Ship incoming `{0}`",
                [LangKeys.Event.Chat] = ":speech_left: {time} **{0}**: {1}",
                [LangKeys.Event.ChatTeam] = ":busts_in_silhouette: {time} **{0}**: {1}",
                [LangKeys.Event.Chinook] = ":helicopter: {time} Chinook 47 incoming `{0}`",
                [LangKeys.Event.Christmas] = ":christmas_tree: {time} Christmas event started",
                [LangKeys.Event.Death] = ":skull: {time} `{0}` died",
                [LangKeys.Event.Easter] = ":egg: {time} Easter event started",
                [LangKeys.Event.EasterWinner] = ":egg: {time} Easter event ended. The winner is `{0}`",
                [LangKeys.Event.Error] = ":octagonal_sign: {time}\n{0}",
                [LangKeys.Event.Halloween] = ":jack_o_lantern: {time} Halloween event started",
                [LangKeys.Event.HalloweenWinner] = ":jack_o_lantern: {time} Halloween event ended. The winner is `{0}`",
                [LangKeys.Event.Helicopter] = ":dagger: {time} Helicopter incoming `{0}`",
                [LangKeys.Event.Initialized] = ":ballot_box_with_check: {time} Server is online again!",
                [LangKeys.Event.LockedCrate] = ":package: {time} Codelocked crate is here `{0}`",
                [LangKeys.Event.PlayerConnected] = ":white_check_mark: {time} {0} connected",
                [LangKeys.Event.PlayerConnectedInfo] = ":detective: {time} {0} connected. SteamID: `{1}` IP: `{2}`",
                [LangKeys.Event.PlayerDisconnected] = ":x: {time} {0} disconnected ({1})",
                [LangKeys.Event.PlayerRespawned] = ":baby_symbol: {time} `{0}` has been spawned at `{1}`",
                [LangKeys.Event.RconCommand] = ":satellite: {time} RCON command `{0}` is run from `{1}`",
                [LangKeys.Event.RconConnection] = ":satellite: {time} RCON connection is opened from `{0}`",
                [LangKeys.Event.Team] = ":family_man_girl_boy: {time} Team was `{0}`\n{1}",
                [LangKeys.Event.SantaSleigh] = ":santa: {time} SantaSleigh Event started",
                [LangKeys.Event.ServerMessage] = ":desktop: {time} `{0}`",
                [LangKeys.Event.Shutdown] = ":stop_sign: {time} Server is shutting down!",
                [LangKeys.Event.SupplyDrop] = ":parachute: {time} SupplyDrop incoming at `{0}`",
                [LangKeys.Event.SupplyDropLanded] = ":gift: {time} SupplyDrop landed at `{0}`",
                [LangKeys.Event.SupplySignal] = ":firecracker: {time} SupplySignal was thrown by `{0}` at `{1}`",
                [LangKeys.Event.UserBanned] = ":no_entry: {time} Player `{0}` SteamID: `{1}` IP: `{2}` was banned: `{3}`",
                [LangKeys.Event.UserKicked] = ":hiking_boot: {time} Player `{0}` SteamID: `{1}` was kicked: `{2}`",
                [LangKeys.Event.UserMuted] = ":mute: {time} `{0}` was muted by `{1}` for `{2}` (`{3}`)",
                [LangKeys.Event.UserNameUpdated] = ":label: {time} `{0}` changed name to `{1}` SteamID: `{2}`",
                [LangKeys.Event.UserUnbanned] = ":ok: {time} Player `{0}` SteamID: `{1}` IP: `{2}` was unbanned",
                [LangKeys.Event.UserUnmuted] = ":speaker: {time} `{0}` was unmuted `{1}`",
                [LangKeys.Format.CargoShip] = "Cargo Ship",
                [LangKeys.Format.Created] = "created",
                [LangKeys.Format.Day] = "day",
                [LangKeys.Format.Days] = "days",
                [LangKeys.Format.Disbanded] = "disbanded",
                [LangKeys.Format.Easy] = "Easy",
                [LangKeys.Format.Expert] = "Expert",
                [LangKeys.Format.Hard] = "Hard",
                [LangKeys.Format.Hour] = "hour",
                [LangKeys.Format.Hours] = "hours",
                [LangKeys.Format.LargeOilRig] = "Large Oil Rig",
                [LangKeys.Format.Medium] = "Medium",
                [LangKeys.Format.Minute] = "minute",
                [LangKeys.Format.Minutes] = "minutes",
                [LangKeys.Format.Nightmare] = "Nightmare",
                [LangKeys.Format.OilRig] = "Oil Rig",
                [LangKeys.Format.Second] = "second",
                [LangKeys.Format.Seconds] = "seconds",
                [LangKeys.Format.Updated] = "updated",
                [LangKeys.Permission.GroupCreated] = ":family: {time} Group `{0}` has been created",
                [LangKeys.Permission.GroupDeleted] = ":family: {time} Group `{0}` has been deleted",
                [LangKeys.Permission.UserGroupAdded] = ":family: {time} `{0}` `{1}` is added to group `{2}`",
                [LangKeys.Permission.UserGroupRemoved] = ":family: {time} `{0}` `{1}` is removed from group `{2}`",
                [LangKeys.Permission.UserPermissionGranted] = ":key: {time} `{0}` `{1}` is granted `{2}`",
                [LangKeys.Permission.UserPermissionRevoked] = ":key: {time} `{0}` `{1}` is revoked `{2}`",
                [LangKeys.Plugin.AdminHammerOff] = ":hammer: {time} AdminHammer enabled by `{0}`",
                [LangKeys.Plugin.AdminHammerOn] = ":hammer: {time} AdminHammer disabled by `{0}`",
                [LangKeys.Plugin.AdminRadarOff] = ":compass: {time} Admin Radar enabled by `{0}`",
                [LangKeys.Plugin.AdminRadarOn] = ":compass: {time} Admin Radar disabled by `{0}`",
                [LangKeys.Plugin.ClanCreated] = ":family_mwgb: {time} **{0}** clan was created",
                [LangKeys.Plugin.ClanDisbanded] = ":family_mwgb: {time} **{0}** clan was disbanded",
                [LangKeys.Plugin.DangerousTreasuresEnded] = ":pirate_flag: {time} Dangerous Treasures event at `{0}` is ended",
                [LangKeys.Plugin.DangerousTreasuresStarted] = ":pirate_flag: {time} Dangerous Treasures started at `{0}`",
                [LangKeys.Plugin.DeathNotes] = ":skull_crossbones: {time} {0}",
                [LangKeys.Plugin.Duel] = ":crossed_swords: {time} `{0}` has defeated `{1}` in a duel",
                [LangKeys.Plugin.GodmodeOff] = ":angel: {time} Godmode disabled for `{0}`",
                [LangKeys.Plugin.GodmodeOn] = ":angel: {time} Godmode enabled for `{0}`",
                [LangKeys.Plugin.NTeleportation] = ":cyclone: {time} `{0}` teleported from `{1}` `{2}` to `{3}` `{4}`",
                [LangKeys.Plugin.PersonalHelicopter] = ":dagger: {time} Personal Helicopter incoming `{0}`",
                [LangKeys.Plugin.PrivateMessage] = ":envelope: {time} PM from `{0}` to `{1}`: {2}",
                [LangKeys.Plugin.RaidableBaseCompleted] = ":homes: {time} {1} Raidable Base owned by {2} at `{0}` has been raided by **{3}**",
                [LangKeys.Plugin.RaidableBaseEnded] = ":homes: {time} {1} Raidable Base at `{0}` has ended",
                [LangKeys.Plugin.RaidableBaseStarted] = ":homes: {time} {1} Raidable Base spawned at `{0}`",
                [LangKeys.Plugin.RustKits] = ":shopping_bags: {time} `{0}` redeemed a kit `{1}`",
                [LangKeys.Plugin.TimedGroupAdded] = ":timer: {time} `{0}` `{1}` is added to `{2}` for {3}",
                [LangKeys.Plugin.TimedGroupExtended] = ":timer: {time} `{0}` `{1}` timed group `{2}` is extended to {3}",
                [LangKeys.Plugin.TimedPermissionExtended] = ":timer: {time} `{0}` `{1}` timed permission `{2}` is extended to {3}",
                [LangKeys.Plugin.TimedPermissionGranted] = ":timer: {time} `{0}` `{1}` is granted `{2}` for {3}",
                [LangKeys.Plugin.VanishOff] = ":ghost: {time} Vanish: Disabled for `{0}`",
                [LangKeys.Plugin.VanishOn] = ":ghost: {time} Vanish: Enabled for `{0}`",
            }, this);
        }

        #endregion Localization

        #region Events Hooks

        private void OnAdminHammerEnabled(BasePlayer player)
        {
            LogToConsole($"AdminHammer enabled by {player.UserIDString} {player.displayName}");

            DiscordSendMessage(Lang(LangKeys.Plugin.AdminHammerOff, null, ReplaceChars(player.displayName)), _configData.AdminHammerSettings.WebhookURL);
        }

        private void OnAdminHammerDisabled(BasePlayer player)
        {
            LogToConsole($"AdminHammer disabled by {player.UserIDString} {player.displayName}");

            DiscordSendMessage(Lang(LangKeys.Plugin.AdminHammerOn, null, ReplaceChars(player.displayName)), _configData.AdminHammerSettings.WebhookURL);
        }

        private void OnBetterChatMuted(IPlayer target, IPlayer initiator, string reason)
        {
            LogToConsole($"{target.Name} was muted by {initiator.Name} for ever ({reason})");

            DiscordSendMessage(Lang(LangKeys.Event.UserMuted, null, ReplaceChars(target.Name), ReplaceChars(initiator.Name), "ever", ReplaceChars(reason)), _configData.UserMutedSettings.WebhookURL);
        }

        private void OnBetterChatMuteExpired(IPlayer player)
        {
            LogToConsole($"{player.Name} was unmuted by SERVER");

            DiscordSendMessage(Lang(LangKeys.Event.UserUnmuted, null, ReplaceChars(player.Name), "SERVER"), _configData.UserMutedSettings.WebhookURL);
        }

        private void OnBetterChatTimeMuted(IPlayer target, IPlayer initiator, TimeSpan time, string reason)
        {
            LogToConsole($"{target.Name} was muted by {initiator.Name} for {time.ToShortString()} ({reason})");

            DiscordSendMessage(Lang(LangKeys.Event.UserMuted, null, ReplaceChars(target.Name), ReplaceChars(initiator.Name), time.ToShortString(), ReplaceChars(reason)), _configData.UserMutedSettings.WebhookURL);
        }

        private void OnBetterChatUnmuted(IPlayer target, IPlayer initiator)
        {
            LogToConsole($"{target.Name} was unmuted by {initiator.Name}");

            DiscordSendMessage(Lang(LangKeys.Event.UserUnmuted, null, ReplaceChars(target.Name), ReplaceChars(initiator.Name)), _configData.UserMutedSettings.WebhookURL);
        }

        private void OnClanCreate(string tag)
        {
            LogToConsole($"{tag} clan was created");

            DiscordSendMessage(Lang(LangKeys.Plugin.ClanCreated, null, ReplaceChars(tag)), _configData.ClanSettings.WebhookURL);
        }

        private void OnClanDisbanded(string tag)
        {
            LogToConsole($"{tag} clan was disbanded");

            DiscordSendMessage(Lang(LangKeys.Plugin.ClanDisbanded, null, ReplaceChars(tag)), _configData.ClanSettings.WebhookURL);
        }

        private void OnDangerousEventStarted(Vector3 containerPos)
        {
            HandleDangerousTreasures(containerPos, LangKeys.Plugin.DangerousTreasuresStarted);
        }

        private void OnDangerousEventEnded(Vector3 containerPos)
        {
            HandleDangerousTreasures(containerPos, LangKeys.Plugin.DangerousTreasuresEnded);
        }

        private void OnDeathNotice(Dictionary<string, object> data, string message)
        {
            DiscordSendMessage(Lang(LangKeys.Plugin.DeathNotes, null, StripRustTags(Formatter.ToPlaintext(message))), _configData.PlayerDeathNotesSettings.WebhookURL);
        }

        private void OnDuelistDefeated(BasePlayer attacker, BasePlayer victim)
        {
            if (!attacker.IsValid() || !victim.IsValid())
            {
                return;
            }

            LogToConsole($"{attacker.displayName} has defeated {victim.displayName} in a duel");

            DiscordSendMessage(Lang(LangKeys.Plugin.Duel, null, ReplaceChars(attacker.displayName), ReplaceChars(victim.displayName)), _configData.DuelSettings.WebhookURL);
        }

        private void OnEntitySpawned(BaseHelicopter entity)
        {
            NextTick(() => HandleEntity(entity));
        }

        private void OnEntitySpawned(BradleyAPC entity) => HandleEntity(entity);

        private void OnEntitySpawned(CargoPlane entity) => HandleEntity(entity);

        private void OnEntitySpawned(CargoShip entity) => HandleEntity(entity);

        private void OnEntitySpawned(CH47HelicopterAIController entity) => HandleEntity(entity);

        private void OnEntitySpawned(EggHuntEvent entity) => HandleEntity(entity);

        private void OnEntitySpawned(HackableLockedCrate entity) => HandleEntity(entity);

        private void OnEntitySpawned(SantaSleigh entity) => HandleEntity(entity);

        private void OnEntitySpawned(SupplyDrop entity) => HandleEntity(entity);

        private void OnEntitySpawned(XMasRefill entity) => HandleEntity(entity);

        private void OnEntityDeath(BasePlayer player, HitInfo info)
        {
            if (!player.IsValid() || info == null)
            {
                return;
            }

            if (_configData.GlobalSettings.HideNPC && (player.IsNpc || !player.userID.IsSteamId()))
            {
                return;
            }

            LogToConsole($"{player.displayName} died.");

            DiscordSendMessage(Lang(LangKeys.Event.Death, null, ReplaceChars(player.displayName)), _configData.PlayerDeathSettings.WebhookURL);
        }

        private void OnEntityKill(EggHuntEvent entity)
        {
            if (!entity.IsValid())
            {
                return;
            }

            List<EggHuntEvent.EggHunter> winners = entity.GetTopHunters();
            string winner;
            if (winners.Count > 0)
            {
                winner = ReplaceChars(winners[0].displayName);
            }
            else
            {
                winner = "No winner";
            }

            bool isHalloween = entity is HalloweenHunt;
            if (isHalloween)
            {
                if (_configData.HalloweenSettings.Enabled)
                {
                    LogToConsole("Halloween Hunt Event has ended. The winner is " + winner);

                    DiscordSendMessage(Lang(LangKeys.Event.HalloweenWinner, null, winner), _configData.HalloweenSettings.WebhookURL);
                }
            }
            else
            {
                if (_configData.EasterSettings.Enabled)
                {
                    LogToConsole("Egg Hunt Event has ended. The winner is " + winner);

                    DiscordSendMessage(Lang(LangKeys.Event.EasterWinner, null, winner), _configData.EasterSettings.WebhookURL);
                }
            }
        }

        private void OnEntityKill(CargoShip cargoShip)
        {
            if (cargoShip.IsValid())
            {
                _cargoShips.Remove(cargoShip.net.ID.Value);
            }
        }

        private void OnExplosiveThrown(BasePlayer player, SupplySignal entity) => HandleSupplySignal(player, entity);

        private void OnExplosiveDropped(BasePlayer player, SupplySignal entity) => HandleSupplySignal(player, entity);

        private void OnGodmodeToggled(string playerID, bool enabled)
        {
            IPlayer player = covalence.Players.FindPlayerById(playerID);

            if (player == null)
            {
                return;
            }

            if (enabled)
            {
                LogToConsole($"Godmode disabled for {player.Id} {player.Name}");

                DiscordSendMessage(Lang(LangKeys.Plugin.GodmodeOn, null, ReplaceChars(player.Name)), _configData.GodmodeSettings.WebhookURL);

                return;
            }

            LogToConsole($"Godmode enabled for {player.Id} {player.Name}");

            DiscordSendMessage(Lang(LangKeys.Plugin.GodmodeOff, null, ReplaceChars(player.Name)), _configData.GodmodeSettings.WebhookURL);
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (_configData.PlayerConnectedSettings.Enabled)
            {
                LogToConsole($"Player {player.displayName} connected.");

                if (!_configData.GlobalSettings.HideAdmin || !player.IsAdmin)
                {
                    StringBuilder sb = new StringBuilder();

                    sb.Append(Lang(LangKeys.Event.PlayerConnected, null, ReplaceChars(player.displayName)));

                    if (player.net.connection.ipaddress.StartsWith("127.")
                    || player.net.connection.ipaddress.StartsWith("10.")
                    || player.net.connection.ipaddress.StartsWith("172.16.")
                    || player.net.connection.ipaddress.StartsWith("192.168."))
                    {
                        sb.Append(" :signal_strength:");
                        DiscordSendMessage(sb.ToString(), _configData.PlayerConnectedSettings.WebhookURL);
                    }
                    else
                    {
                        webrequest.Enqueue($"http://ip-api.com/json/{player.net.connection.ipaddress.Split(':')[0]}", null, (code, response) => {
                            if (code == 200 && response != null)
                            {
                                sb.Append(" :flag_");
                                sb.Append(JsonConvert.DeserializeObject<Response>(response).CountryCode.ToLower());
                                sb.Append(":");
                            }

                            DiscordSendMessage(sb.ToString(), _configData.PlayerConnectedSettings.WebhookURL);
                        }, this, RequestMethod.GET);
                    }
                }
            }

            if (_configData.PlayerConnectedInfoSettings.Enabled)
            {
                DiscordSendMessage(Lang(LangKeys.Event.PlayerConnectedInfo, null, ReplaceChars(player.displayName), player.UserIDString, player.net.connection.ipaddress.Split(':')[0]), _configData.PlayerConnectedInfoSettings.WebhookURL);
            }
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (!player.IsValid())
            {
                return;
            }

            LogToConsole($"Player {player.displayName} disconnected ({reason}).");

            if (!_configData.GlobalSettings.HideAdmin || !player.IsAdmin)
            {
                DiscordSendMessage(Lang(LangKeys.Event.PlayerDisconnected, null, ReplaceChars(player.displayName), ReplaceChars(reason)), _configData.PlayerDisconnectedSettings.WebhookURL);
            }
        }

        private void OnPlayerChat(BasePlayer player, string message, ConVar.Chat.ChatChannel channel)
        {
            if (!player.IsValid() || string.IsNullOrWhiteSpace(message))
            {
                return;
            }

            if (IsPluginLoaded(BetterChatMute))
            {
                _resultCall = BetterChatMute.Call("API_IsMuted", player.IPlayer);

                if (_resultCall is bool && (bool)_resultCall)
                {
                    return;
                }
            }

            if (_configData.GlobalSettings.UseAntiSpam && IsPluginLoaded(AntiSpam))
            {
                _resultCall = AntiSpam.Call("GetSpamFreeText", message);

                message = (_resultCall as string);

                if (string.IsNullOrWhiteSpace(message))
                {
                    return;
                }
            }

            if (_configData.GlobalSettings.UseUFilter && IsPluginLoaded(UFilter))
            {
                _sb.Clear();
                _sb.Append(message);

                _resultCall = UFilter.Call("Profanities", message);

                if (_resultCall is string[])
                {
                    _profanities = _resultCall as string[];
                }

                foreach (string profanity in _profanities)
                {
                    _sb.Replace(profanity, new string('＊', profanity.Length));
                }

                message = _sb.ToString();

                if (string.IsNullOrWhiteSpace(message))
                {
                    return;
                }
            }

            message = ReplaceChars(message);

            switch (channel)
            {
                case ConVar.Chat.ChatChannel.Global:
                case ConVar.Chat.ChatChannel.Local:
                    if (_configData.ChatSettings.Enabled)
                    {
                        DiscordSendMessage(Lang(LangKeys.Event.Chat, null, ReplaceChars(player.displayName), message), _configData.ChatSettings.WebhookURL);
                    }
                    break;
                case ConVar.Chat.ChatChannel.Team:
                    if (_configData.ChatTeamSettings.Enabled)
                    {
                        DiscordSendMessage(Lang(LangKeys.Event.ChatTeam, null, ReplaceChars(player.displayName), message), _configData.ChatTeamSettings.WebhookURL);
                    }
                    break;
            }
        }

        private void OnPlayerTeleported(BasePlayer player, Vector3 oldPosition, Vector3 newPosition)
        {
            LogToConsole($"NTeleportation {player.UserIDString} {player.displayName} from {oldPosition} to {newPosition}");

            DiscordSendMessage(Lang(LangKeys.Plugin.NTeleportation, null, ReplaceChars(player.displayName), GetGridPosition(oldPosition), oldPosition, GetGridPosition(newPosition), newPosition), _configData.NTeleportationSettings.WebhookURL);
        }

        private void OnPMProcessed(IPlayer sender, IPlayer target, string message)
        {
            LogToConsole($"PM from `{sender.Name}` to `{target.Name}`: {message}");

            DiscordSendMessage(Lang(LangKeys.Plugin.PrivateMessage, null, ReplaceChars(sender.Name), ReplaceChars(target.Name), ReplaceChars(message)), _configData.PrivateMessagesSettings.WebhookURL);
        }

        private void OnPlayerRespawned(BasePlayer player)
        {
            if (string.IsNullOrWhiteSpace(player?.displayName))
            {
                return;
            }

            LogToConsole($"{player.displayName} has been spawned at {GetGridPosition(player.transform.position)}");

            DiscordSendMessage(Lang(LangKeys.Event.PlayerRespawned, null, ReplaceChars(player.displayName), GetGridPosition(player.transform.position)), _configData.PlayerRespawnedSettings.WebhookURL);
        }

        private void OnRadarActivated(BasePlayer player)
        {
            LogToConsole($"Admin Radar enabled by {player.UserIDString} {player.displayName}");

            DiscordSendMessage(Lang(LangKeys.Plugin.AdminRadarOn, null, ReplaceChars(player.displayName)), _configData.AdminRadarSettings.WebhookURL);
        }

        private void OnRadarDeactivated(BasePlayer player)
        {
            LogToConsole($"Admin Radar disabled by {player.UserIDString} {player.displayName}");

            DiscordSendMessage(Lang(LangKeys.Plugin.AdminRadarOff, null, ReplaceChars(player.displayName)), _configData.AdminRadarSettings.WebhookURL);
        }

        private void OnRaidableBaseStarted(Vector3 raidPos, int difficulty)
        {
            HandleRaidableBase(raidPos, difficulty, LangKeys.Plugin.RaidableBaseStarted);
        }

        private void OnRaidableBaseEnded(Vector3 raidPos, int difficulty)
        {
            HandleRaidableBase(raidPos, difficulty, LangKeys.Plugin.RaidableBaseEnded);
        }

        private void OnRaidableBaseCompleted(Vector3 raidPos, int difficulty, bool allowPVP, string id, float spawnTime, float despawnTime, float loadTime, ulong ownerId, BasePlayer owner, List<BasePlayer> raiders)
        {
            HandleRaidableBase(raidPos, difficulty, LangKeys.Plugin.RaidableBaseCompleted, owner, raiders);
        }

        private void OnRconConnection(IPAddress ip)
        {
            LogToConsole($"RCON connection is opened from {ip}");

            DiscordSendMessage(Lang(LangKeys.Event.RconConnection, null, ip.ToString()), _configData.RconConnectionSettings.WebhookURL);
        }

        private void OnRconCommand(IPAddress ip, string command, string[] args)
        {
            foreach (string rconCommand in _configData.GlobalSettings.RCONCommandBlacklist)
            {
                if (command.ToLower().Equals(rconCommand.ToLower()))
                {
                    return;
                }
            }

            for (int i = 0; i < args.Length; i++)
            {
                command += $" {args[i]}";
            }

            LogToConsole($"RCON command {command} is run from {ip}");

            DiscordSendMessage(Lang(LangKeys.Event.RconCommand, null, command, ip), _configData.RconCommandSettings.WebhookURL);
        }

        private void OnSupplyDropLanded(SupplyDrop entity)
        {
            if (!entity.IsValid() || _listSupplyDrops.Contains(entity.net.ID.Value))
            {
                return;
            }

            LogToConsole($"SupplyDrop landed at {GetGridPosition(entity.transform.position)}");

            DiscordSendMessage(Lang(LangKeys.Event.SupplyDropLanded, null, GetGridPosition(entity.transform.position)), _configData.SupplyDropSettings.WebhookURL);

            _entityID = entity.net.ID.Value;

            _listSupplyDrops.Add(_entityID);

            timer.Once(60f, () => _listSupplyDrops.Remove(_entityID));
        }

        private void OnUserBanned(string name, string id, string ipAddress, string reason)
        {
            LogToConsole($"Player {name} ({id}) at {ipAddress} was banned: {reason}");

            DiscordSendMessage(Lang(LangKeys.Event.UserBanned, null, ReplaceChars(name), id, ipAddress, ReplaceChars(reason)), _configData.UserBannedSettings.WebhookURL);
        }

        private void OnUserKicked(IPlayer player, string reason)
        {
            LogToConsole($"Player {player.Name} ({player.Id}) was kicked ({reason})");

            DiscordSendMessage(Lang(LangKeys.Event.UserKicked, null, ReplaceChars(player.Name), player.Id, ReplaceChars(reason)), _configData.UserKickedSettings.WebhookURL);
        }

        private void OnUserUnbanned(string name, string id, string ipAddress)
        {
            LogToConsole($"Player {name} ({id}) at {ipAddress} was unbanned");

            DiscordSendMessage(Lang(LangKeys.Event.UserUnbanned, null, ReplaceChars(name), id, ipAddress), _configData.UserBannedSettings.WebhookURL);
        }

        private void OnUserNameUpdated(string id, string oldName, string newName)
        {
            if (oldName.Equals(newName) || oldName.Equals("Unnamed"))
            {
                return;
            }
            
            LogToConsole($"Player name changed from {oldName} to {newName} for ID {id}");

            DiscordSendMessage(Lang(LangKeys.Event.UserNameUpdated, null, ReplaceChars(oldName), ReplaceChars(newName), id), _configData.UserNameUpdateSettings.WebhookURL);
        }

        private void OnServerMessage(string message, string name, string color, ulong id)
        {
            LogToConsole($"ServerMessage: {message}");

            DiscordSendMessage(Lang(LangKeys.Event.ServerMessage, null, message), _configData.ServerMessagesSettings.WebhookURL);
        }

        private void OnKitRedeemed(BasePlayer player, string kitName)
        {
            LogToConsole($"{player.UserIDString} {player.displayName} redeemed a kit {kitName}");

            DiscordSendMessage(Lang(LangKeys.Plugin.RustKits, null, ReplaceChars(player.displayName), ReplaceChars(kitName)), _configData.RustKitsSettings.WebhookURL);
        }

        private void OnVanishDisappear(BasePlayer player)
        {
            LogToConsole($"Vanish: Enabled ({player.UserIDString} {player.displayName})");

            DiscordSendMessage(Lang(LangKeys.Plugin.VanishOn, null, ReplaceChars(player.displayName)), _configData.VanishSettings.WebhookURL);
        }

        private void OnVanishReappear(BasePlayer player)
        {
            LogToConsole($"Vanish: Disabled ({player.UserIDString} {player.displayName})");

            DiscordSendMessage(Lang(LangKeys.Plugin.VanishOff, null, ReplaceChars(player.displayName)), _configData.VanishSettings.WebhookURL);
        }

        #region Team Hooks

        private void OnTeamCreated(BasePlayer player, RelationshipManager.PlayerTeam team) => HandleTeam(team, TeamEventType.Created);

        private void OnTeamDisbanded(RelationshipManager.PlayerTeam team) => HandleTeam(team, TeamEventType.Disbanded);

        private void OnTeamUpdated(ulong currentTeam, RelationshipManager.PlayerTeam team, BasePlayer player)
        {
            NextTick( () => {
                if (team.members.Count > 0)
                {
                    HandleTeam(team, TeamEventType.Updated);
                }
            });
        }

        private void OnTeamPromote(RelationshipManager.PlayerTeam team, BasePlayer newLeader)
        {
            NextTick( () => { HandleTeam(team, TeamEventType.Updated); });
        }

        private void OnTeamLeave(RelationshipManager.PlayerTeam team, BasePlayer player)
        {
            NextTick( () => {
                if (team?.members?.Count > 0)
                {
                    HandleTeam(team, TeamEventType.Updated);
                }
            });
        }

        private void OnTeamKick(RelationshipManager.PlayerTeam team, BasePlayer player, ulong target)
        {
            NextTick( () => { HandleTeam(team, TeamEventType.Updated); });
        }

        private void OnTeamAcceptInvite(RelationshipManager.PlayerTeam team, BasePlayer player)
        {
            NextTick( () => { HandleTeam(team, TeamEventType.Updated); });
        }

        #endregion Team Hooks

        #region Permissions

        private void OnGroupCreated(string name)
        {
            LogToConsole($"Group {name} has been created");

            DiscordSendMessage(Lang(LangKeys.Permission.GroupCreated, null, name), _configData.PermissionsSettings.WebhookURL);
        }

        private void OnGroupDeleted(string name)
        {
            LogToConsole($"Group {name} has been deleted");

            DiscordSendMessage(Lang(LangKeys.Permission.GroupDeleted, null, name), _configData.PermissionsSettings.WebhookURL);
        }

        private void OnTimedPermissionGranted(string playerID, string permission, TimeSpan duration)
        {
            IPlayer player = covalence.Players.FindPlayerById(playerID);

            if (player == null)
            {
                return;
            }

            LogToConsole($"{playerID} {player.Name} is granted {permission} for {duration}");

            DiscordSendMessage(Lang(LangKeys.Plugin.TimedPermissionGranted, null, playerID, ReplaceChars(player.Name), permission, GetFormattedDurationTime(duration)), _configData.PermissionsSettings.WebhookURL);
        }

        private void OnTimedPermissionExtended(string playerID, string permission, TimeSpan duration)
        {
            IPlayer player = covalence.Players.FindPlayerById(playerID);

            if (player == null)
            {
                return;
            }

            LogToConsole($"{playerID} {player.Name} timed permission {permission} is extended for {duration}");

            DiscordSendMessage(Lang(LangKeys.Plugin.TimedPermissionExtended, null, playerID, ReplaceChars(player.Name), permission, GetFormattedDurationTime(duration)), _configData.PermissionsSettings.WebhookURL);
        }

        private void OnTimedGroupAdded(string playerID, string group, TimeSpan duration)
        {
            IPlayer player = covalence.Players.FindPlayerById(playerID);

            if (player == null)
            {
                return;
            }

            LogToConsole($"{playerID} {player.Name} is added to {group} for {duration}");

            DiscordSendMessage(Lang(LangKeys.Plugin.TimedGroupAdded, null, playerID, ReplaceChars(player.Name), group, GetFormattedDurationTime(duration)), _configData.PermissionsSettings.WebhookURL);
        }

        private void OnTimedGroupExtended(string playerID, string group, TimeSpan duration)
        {
            IPlayer player = covalence.Players.FindPlayerById(playerID);

            if (player == null)
            {
                return;
            }

            LogToConsole($"{playerID} {player.Name} timed group {group} is extended for {duration}");

            DiscordSendMessage(Lang(LangKeys.Plugin.TimedGroupExtended, null, playerID, ReplaceChars(player.Name), group, GetFormattedDurationTime(duration)), _configData.PermissionsSettings.WebhookURL);
        }

        private void OnUserGroupAdded(string playerID, string groupName)
        {
            IPlayer player = covalence.Players.FindPlayerById(playerID);

            if (player == null)
            {
                return;
            }

            LogToConsole($"{playerID} {player.Name} is added to group {groupName}");

            DiscordSendMessage(Lang(LangKeys.Permission.UserGroupAdded, null, playerID, ReplaceChars(player.Name), groupName), _configData.PermissionsSettings.WebhookURL);
        }

        private void OnUserGroupRemoved(string playerID, string groupName)
        {
            IPlayer player = covalence.Players.FindPlayerById(playerID);

            if (player == null)
            {
                return;
            }

            LogToConsole($"{playerID} {player.Name} is removed from group {groupName}");

            DiscordSendMessage(Lang(LangKeys.Permission.UserGroupRemoved, null, playerID, ReplaceChars(player.Name), groupName), _configData.PermissionsSettings.WebhookURL);
        }

        private void OnUserPermissionGranted(string playerID, string permName)
        {
            IPlayer player = covalence.Players.FindPlayerById(playerID);

            if (player == null)
            {
                return;
            }

            LogToConsole($"{playerID} {player.Name} is granted permission {permName}");

            DiscordSendMessage(Lang(LangKeys.Permission.UserPermissionGranted, null, playerID, ReplaceChars(player.Name), permName), _configData.PermissionsSettings.WebhookURL);
        }

        private void OnUserPermissionRevoked(string playerID, string permName)
        {
            IPlayer player = covalence.Players.FindPlayerById(playerID);

            if (player == null)
            {
                return;
            }

            LogToConsole($"{playerID} {player.Name} is revoked permission {permName}");

            DiscordSendMessage(Lang(LangKeys.Permission.UserPermissionRevoked, null, playerID, ReplaceChars(player.Name), permName), _configData.PermissionsSettings.WebhookURL);
        }

        #endregion

        #endregion Events Hooks

        #region Core Methods

        private string ReplaceChars(string text)
        {
            if (string.IsNullOrWhiteSpace(text))
            {
                return string.Empty;
            }

            _sb.Clear();
            _sb.Append(text);
            _sb.Replace("*", "＊");
            _sb.Replace("`", "'");
            _sb.Replace("_", "＿");
            _sb.Replace("~", "～");
            _sb.Replace(">", "＞");
            _sb.Replace("@here", "here");
            _sb.Replace("@everyone", "everyone");

            return _sb.ToString();
        }

        private void DiscordSendMessage(string message, string webhookUrl, bool stripTags = false)
        {
            webhookUrl = GetWebhookURL(webhookUrl);

            if (string.IsNullOrWhiteSpace(webhookUrl))
            {
                PrintError("DiscordSendMessage: webhookUrl is null or empty!");
                return;
            }

            if (stripTags)
            {
                message = StripRustTags(message);
            }

            if (string.IsNullOrWhiteSpace(message))
            {
                PrintError("DiscordSendMessage: message is null or empty!");
                return;
            }

            _queue.Enqueue(new QueuedMessage() {
                Message = message,
                WebhookUrl = webhookUrl
            });

            HandleQueue();
        }

        private void HandleQueue()
        {
            if (_retryCount > 0)
            {
                if (_timerQueueCooldown == null)
                {
                    float timeout = _configData.GlobalSettings.QueueCooldown * Math.Min(_retryCount, 10);
                    PrintWarning($"HandleQueue: connection problem detected! Retry # {_retryCount}. Next try in {timeout} seconds. Messages in queue: {_queue.Count}");

                    _timerQueueCooldown = timer.Once(timeout, () =>
                    {
                        DiscordSendMessage(_queuedMessage.WebhookUrl, new DiscordMessage(_queuedMessage.Message));

                        QueueCooldownDisable();

                        HandleQueue();
                    });
                }

                return;
            }

            if (_timerQueueCooldown == null && _timerQueue == null && _queue.Count > 0)
            {
                _queuedMessage = _queue.Dequeue();

                _sb.Clear();

                if (_queuedMessage.Message.Length > 1990)
                {
                    _queuedMessage.Message = $"{_queuedMessage.Message.Substring(0, 1990)}\n```";
                }

                _sb.AppendLine(_queuedMessage.Message);

                for (int i = 0; i < _queue.Count; i++)
                {
                    _nextMessage = _queue.Peek();

                    if (_sb.Length + _nextMessage.Message.Length > 1990
                     || _queuedMessage.WebhookUrl != _nextMessage.WebhookUrl)
                    {
                        break;
                    }

                    _nextMessage = _queue.Dequeue();
                    _sb.AppendLine(_nextMessage.Message);
                }

                _queuedMessage.Message = _sb.ToString();

                DiscordSendMessage(_queuedMessage.WebhookUrl, new DiscordMessage(_queuedMessage.Message));

                _timerQueue = timer.Once(_configData.GlobalSettings.QueueInterval, () => {
                    _timerQueue?.Destroy();
                    _timerQueue = null;

                    HandleQueue();
                });
            }
        }

        private void QueueCooldownDisable()
        {
            _timerQueueCooldown?.Destroy();
            _timerQueueCooldown = null;
        }

        private void HandleEntity(BaseEntity baseEntity)
        {
            if (!baseEntity.IsValid())
            {
                return;
            }

            Vector3 position = baseEntity.transform.position;

            if (baseEntity is BaseHelicopter)
            {
                _langKey = LangKeys.Event.Helicopter;
                _eventSettings = _configData.HelicopterSettings;
            }
            else if (baseEntity is BradleyAPC)
            {
                _langKey = LangKeys.Event.Bradley;
                _eventSettings = _configData.BradleySettings;
                LogToConsole($"BradleyAPC spawned at {GetGridPosition(position)}");
            }
            else if (baseEntity is CargoPlane)
            {
                _langKey = LangKeys.Event.CargoPlane;
                _eventSettings = _configData.CargoPlaneSettings;
                LogToConsole($"CargoPlane spawned at {GetGridPosition(position)}");
            }
            else if (baseEntity is CargoShip)
            {
                _langKey = LangKeys.Event.CargoShip;
                _eventSettings = _configData.CargoShipSettings;
                LogToConsole($"CargoShip spawned at {GetGridPosition(position)}");

                NextTick( () => {
                    if (baseEntity.IsValid() && !_cargoShips.ContainsKey(baseEntity.net.ID.Value))
                    {
                        _cargoShips[baseEntity.net.ID.Value] = (CargoShip)baseEntity;
                    }
                });
            }
            else if (baseEntity is CH47HelicopterAIController)
            {
                _langKey = LangKeys.Event.Chinook;
                _eventSettings = _configData.ChinookSettings;
                LogToConsole($"CH47Helicopter spawned at {GetGridPosition(position)}");
            }
            else if (baseEntity is HalloweenHunt)
            {
                _langKey = LangKeys.Event.Halloween;
                _eventSettings = _configData.HalloweenSettings;
                LogToConsole($"HalloweenHunt spawned at {GetGridPosition(position)}");
            }
            else if (baseEntity is EggHuntEvent)
            {
                _langKey = LangKeys.Event.Easter;
                _eventSettings = _configData.EasterSettings;
                LogToConsole("Easter event has started");
            }
            else if (baseEntity is HackableLockedCrate)
            {
                _langKey = LangKeys.Event.LockedCrate;
                _eventSettings = _configData.LockedCrateSettings;
                LogToConsole($"HackableLockedCrate spawned at {GetGridPosition(position)}");
            }
            else if (baseEntity is SantaSleigh)
            {
                _langKey = LangKeys.Event.SantaSleigh;
                _eventSettings = _configData.SantaSleighSettings;
                LogToConsole($"SantaSleigh spawned at {GetGridPosition(position)}");
            }
            else if (baseEntity is SupplyDrop)
            {
                _langKey = LangKeys.Event.SupplyDrop;
                _eventSettings = _configData.SupplyDropSettings;
                LogToConsole($"SupplyDrop spawned at {GetGridPosition(position)}");
            }
            else if (baseEntity is SupplySignal)
            {
                _langKey = LangKeys.Event.SupplySignal;
                _eventSettings = _configData.SupplyDropSettings;
                LogToConsole($"SupplySignal dropped at {GetGridPosition(position)}");
            }
            else if (baseEntity is XMasRefill)
            {
                _langKey = LangKeys.Event.Christmas;
                _eventSettings = _configData.ChristmasSettings;
                LogToConsole("Christmas event has started");
            }

            if (_eventSettings.Enabled)
            {
                if (baseEntity is BaseHelicopter)
                {
                    if (IsPluginLoaded(CallHeli))
                    {
                        _resultCall = CallHeli.Call("IsPersonal", baseEntity);

                        if (_resultCall is bool && (bool)_resultCall)
                        {
                            LogToConsole("Personal Helicopter spawned at " + GetGridPosition(position));

                            DiscordSendMessage(Lang(LangKeys.Plugin.PersonalHelicopter, null, GetGridPosition(position)), _eventSettings.WebhookURL);
                            return;
                        }
                    }

                    if (IsPluginLoaded(PersonalHeli))
                    {
                        _resultCall = PersonalHeli.Call("IsPersonal", baseEntity);

                        if (_resultCall is bool && (bool)_resultCall)
                        {
                            LogToConsole("Personal Helicopter spawned at " + GetGridPosition(position));

                            DiscordSendMessage(Lang(LangKeys.Plugin.PersonalHelicopter, null, GetGridPosition(position)), _eventSettings.WebhookURL);
                            return;
                        }
                    }

                    LogToConsole("BaseHelicopter spawned at " + GetGridPosition(position));
                }

                if (baseEntity is HackableLockedCrate)
                {
                    DiscordSendMessage(Lang(_langKey, null, GetHackableLockedCratePosition(position)), _eventSettings.WebhookURL);
                    return;
                }

                DiscordSendMessage(Lang(_langKey, null, GetGridPosition(position)), _eventSettings.WebhookURL);
            }
        }

        private void HandleSupplySignal(BasePlayer player, SupplySignal entity)
        {
            if (_configData.SupplyDropSettings.Enabled)
            {
                NextTick(() => {
                    if (player != null && entity != null)
                    {
                        LogToConsole($"SupplySignal was thrown by {player.displayName} at {GetGridPosition(entity.transform.position)}");

                        DiscordSendMessage(Lang(LangKeys.Event.SupplySignal, null, ReplaceChars(player.displayName), GetGridPosition(entity.transform.position)), _configData.SupplyDropSettings.WebhookURL);
                    }
                });
            }
        }

        private void HandleRaidableBase(Vector3 raidPos, int difficulty, string langKey, BasePlayer owner = null, List<BasePlayer> raiders = null)
        {
            if (raidPos == null)
            {
                PrintError($"{langKey}: raidPos == null");
                return;
            }

            string difficultyString;
            switch (difficulty)
            {
                case 0:
                    difficultyString = LangKeys.Format.Easy;
                    break;
                case 1:
                    difficultyString = LangKeys.Format.Medium;
                    break;
                case 2:
                    difficultyString = LangKeys.Format.Hard;
                    break;
                case 3:
                    difficultyString = LangKeys.Format.Expert;
                    break;
                case 4:
                    difficultyString = LangKeys.Format.Nightmare;
                    break;
                case 512:
                    difficultyString = string.Empty;
                    break;
                default:
                    PrintError($"{langKey}: Unknown difficulty: {difficulty}");
                    return;
            }

            switch (langKey)
            {
                case LangKeys.Plugin.RaidableBaseCompleted:
                    _sb.Clear();
                    for (int i = 0; i < raiders?.Count; i++)
                    {
                        if (i > 0)
                        {
                            _sb.Append(", ");
                        }
                        _sb.Append(raiders[i].displayName);
                    }
                    LogToConsole($"{difficultyString} Raidable Base owned by {owner?.displayName} at {GetGridPosition(raidPos)} has been raided by {_sb.ToString()}");
                    DiscordSendMessage(Lang(langKey, null, GetGridPosition(raidPos), Lang(difficultyString), owner?.displayName, _sb.ToString()), _configData.RaidableBasesSettings.WebhookURL);
                    break;
                case LangKeys.Plugin.RaidableBaseEnded:
                case LangKeys.Plugin.RaidableBaseStarted:
                    LogToConsole(difficultyString + " Raidable Base at " + GetGridPosition(raidPos) + " has " + (langKey == LangKeys.Plugin.RaidableBaseStarted ? "spawned" : "ended"));
                    DiscordSendMessage(Lang(langKey, null, GetGridPosition(raidPos), Lang(difficultyString)), _configData.RaidableBasesSettings.WebhookURL);
                    break;
            }
        }

        private void HandleDangerousTreasures(Vector3 containerPos, string langKey)
        {
            if (containerPos == null)
            {
                PrintError($"{langKey}: containerPos == null");
                return;
            }

            LogToConsole("Dangerous Treasures at " + GetGridPosition(containerPos) + " is " + (langKey == LangKeys.Plugin.DangerousTreasuresStarted ? "spawned" : "ended"));

            DiscordSendMessage(Lang(langKey, null, GetGridPosition(containerPos)), _configData.DangerousTreasuresSettings.WebhookURL);
        }

        private void HandleLog(string logString, string stackTrace, LogType type)
        {
            if (_configData.ErrorSettings.Enabled && type == LogType.Error)
            {
                _sb.Clear();

                _sb.AppendLine("```cs");
                _sb.AppendLine(logString);
                _sb.AppendLine("```");

                if (!string.IsNullOrEmpty(stackTrace))
                {
                    _sb.AppendLine("```cs");
                    _sb.AppendLine(stackTrace);
                    _sb.AppendLine("```");
                }

                DiscordSendMessage(Lang(LangKeys.Event.Error, null, _sb), _configData.ErrorSettings.WebhookURL);
            }
        }

        private void HandleTeam(RelationshipManager.PlayerTeam team, TeamEventType teamEventType)
        {
            _sb.Clear();

            BasePlayer player = RelationshipManager.FindByID(team.teamLeader);

            if (!player.IsValid())
            {
                return;
            }

            _sb.AppendLine("```cs");
            _sb.AppendLine();
            _sb.Append("TeamID: ");
            _sb.Append(team.teamID);
            _sb.AppendLine();
            _sb.Append("TeamLeader: ");
            _sb.Append(player.userID);
            _sb.Append(" (");
            _sb.Append(player.displayName);
            _sb.Append(")");
            if (team.members.Count > 0)
            {
                _sb.AppendLine();
                _sb.Append("Members:");
            }

            foreach (ulong userID in team.members)
            {
                player = RelationshipManager.FindByID(userID);

                if (!player.IsValid())
                {
                    continue;
                }

                _sb.AppendLine();
                _sb.Append(player.userID);
                _sb.Append(" (");
                _sb.Append(player.displayName);
                _sb.Append(")");
            }

            _sb.AppendLine("```");

            string eventType = string.Empty;

            switch (teamEventType)
            {
                case TeamEventType.Created:
                    eventType = Lang(LangKeys.Format.Created);
                    break;
                case TeamEventType.Disbanded:
                    eventType = Lang(LangKeys.Format.Disbanded);
                    break;
                case TeamEventType.Updated:
                    eventType = Lang(LangKeys.Format.Updated);
                    break;
            }

            LogToConsole($"Team was {eventType}\n{_sb.ToString()}");

            DiscordSendMessage(Lang(LangKeys.Event.Team, null, eventType, _sb.ToString()), _configData.TeamsSettings.WebhookURL);
        }

        private void CacheOilRigsLocation()
        {
            foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
            {
                if (!monument.shouldDisplayOnMap)
                {
                    continue;
                }

                switch (monument.displayPhrase.english)
                {
                    case "Large Oil Rig":
                        _locationLargeOilRig = monument.transform.position;
                        break;
                    case "Oil Rig":
                        _locationOilRig = monument.transform.position;
                        break;
                }
            }
        }

        private string GetHackableLockedCratePosition(Vector3 position)
        {
            if (Vector3.Distance(position, _locationOilRig) < 51f)
            {
                return Lang(LangKeys.Format.OilRig);
            }

            if (Vector3.Distance(position, _locationLargeOilRig) < 51f)
            {
                return Lang(LangKeys.Format.LargeOilRig);
            }

            try
            {
                foreach (KeyValuePair<ulong, CargoShip> cargoShip in _cargoShips)
                {
                    if (!cargoShip.Value.IsValid() || cargoShip.Value.IsDestroyed)
                    {
                        _listBadCargoShips.Add(cargoShip.Key);
                        continue;
                    }

                    if (Vector3.Distance(position, cargoShip.Value.transform.position) < 85f)
                    {
                        return Lang(LangKeys.Format.CargoShip);
                    }
                }
            }
            finally
            {
                for (int i = 0; i < _listBadCargoShips.Count; i++)
                {
                    _cargoShips.Remove(_listBadCargoShips[i]);
                }
                _listBadCargoShips.Clear();
            }

            return GetGridPosition(position);
        }

        #endregion Core Methods

        #region Helpers

        private void UnsubscribeHooks()
        {
            Unsubscribe(nameof(OnAdminHammerDisabled));
            Unsubscribe(nameof(OnAdminHammerEnabled));
            Unsubscribe(nameof(OnBetterChatMuted));
            Unsubscribe(nameof(OnBetterChatMuteExpired));
            Unsubscribe(nameof(OnBetterChatTimeMuted));
            Unsubscribe(nameof(OnBetterChatUnmuted));
            Unsubscribe(nameof(OnClanCreate));
            Unsubscribe(nameof(OnClanDisbanded));
            Unsubscribe(nameof(OnDangerousEventEnded));
            Unsubscribe(nameof(OnDangerousEventStarted));
            Unsubscribe(nameof(OnDeathNotice));
            Unsubscribe(nameof(OnDuelistDefeated));
            Unsubscribe(nameof(OnEntityDeath));
            Unsubscribe(nameof(OnEntityKill));
            Unsubscribe(nameof(OnEntitySpawned));
            Unsubscribe(nameof(OnExplosiveDropped));
            Unsubscribe(nameof(OnExplosiveThrown));
            Unsubscribe(nameof(OnGodmodeToggled));
            Unsubscribe(nameof(OnGroupCreated));
            Unsubscribe(nameof(OnGroupDeleted));
            Unsubscribe(nameof(OnKitRedeemed));
            Unsubscribe(nameof(OnPlayerChat));
            Unsubscribe(nameof(OnPlayerConnected));
            Unsubscribe(nameof(OnPlayerDisconnected));
            Unsubscribe(nameof(OnPlayerRespawned));
            Unsubscribe(nameof(OnPlayerTeleported));
            Unsubscribe(nameof(OnPMProcessed));
            Unsubscribe(nameof(OnRadarActivated));
            Unsubscribe(nameof(OnRadarDeactivated));
            Unsubscribe(nameof(OnRaidableBaseCompleted));
            Unsubscribe(nameof(OnRaidableBaseEnded));
            Unsubscribe(nameof(OnRaidableBaseStarted));
            Unsubscribe(nameof(OnRconCommand));
            Unsubscribe(nameof(OnRconConnection));
            Unsubscribe(nameof(OnServerMessage));
            Unsubscribe(nameof(OnSupplyDropLanded));
            Unsubscribe(nameof(OnTeamAcceptInvite));
            Unsubscribe(nameof(OnTeamCreated));
            Unsubscribe(nameof(OnTeamDisbanded));
            Unsubscribe(nameof(OnTeamKick));
            Unsubscribe(nameof(OnTeamLeave));
            Unsubscribe(nameof(OnTeamPromote));
            Unsubscribe(nameof(OnTeamUpdated));
            Unsubscribe(nameof(OnTimedGroupAdded));
            Unsubscribe(nameof(OnTimedGroupExtended));
            Unsubscribe(nameof(OnTimedPermissionExtended));
            Unsubscribe(nameof(OnTimedPermissionGranted));
            Unsubscribe(nameof(OnUserBanned));
            Unsubscribe(nameof(OnUserGroupAdded));
            Unsubscribe(nameof(OnUserGroupRemoved));
            Unsubscribe(nameof(OnUserKicked));
            Unsubscribe(nameof(OnUserNameUpdated));
            Unsubscribe(nameof(OnUserPermissionGranted));
            Unsubscribe(nameof(OnUserPermissionRevoked));
            Unsubscribe(nameof(OnUserUnbanned));
            Unsubscribe(nameof(OnVanishDisappear));
            Unsubscribe(nameof(OnVanishReappear));
        }

        private void SubscribeHooks()
        {
            if (_configData.AdminHammerSettings.Enabled)
            {
                Subscribe(nameof(OnAdminHammerDisabled));
                Subscribe(nameof(OnAdminHammerEnabled));
            }

            if (_configData.UserMutedSettings.Enabled)
            {
                Subscribe(nameof(OnBetterChatMuted));
                Subscribe(nameof(OnBetterChatMuteExpired));
                Subscribe(nameof(OnBetterChatTimeMuted));
                Subscribe(nameof(OnBetterChatUnmuted));
            }

            if (_configData.ClanSettings.Enabled)
            {
                Subscribe(nameof(OnClanCreate));
                Subscribe(nameof(OnClanDisbanded));
            }

            if (_configData.DangerousTreasuresSettings.Enabled)
            {
                Subscribe(nameof(OnDangerousEventEnded));
                Subscribe(nameof(OnDangerousEventStarted));
            }

            if (_configData.PlayerDeathNotesSettings.Enabled)
            {
                Subscribe(nameof(OnDeathNotice));
            }

            if (_configData.DuelSettings.Enabled)
            {
                Subscribe(nameof(OnDuelistDefeated));
            }

            if (_configData.PlayerDeathSettings.Enabled)
            {
                Subscribe(nameof(OnEntityDeath));
            }

            if (_configData.EasterSettings.Enabled
             || _configData.HalloweenSettings.Enabled
             || _configData.LockedCrateSettings.Enabled)
            {
                Subscribe(nameof(OnEntityKill));
            }

            if (_configData.BradleySettings.Enabled
             || _configData.CargoPlaneSettings.Enabled
             || _configData.CargoShipSettings.Enabled
             || _configData.ChinookSettings.Enabled
             || _configData.ChristmasSettings.Enabled
             || _configData.EasterSettings.Enabled
             || _configData.HalloweenSettings.Enabled
             || _configData.HelicopterSettings.Enabled
             || _configData.LockedCrateSettings.Enabled
             || _configData.SantaSleighSettings.Enabled
             || _configData.SupplyDropSettings.Enabled)
            {
                Subscribe(nameof(OnEntitySpawned));
            }

            if (_configData.SupplyDropSettings.Enabled)
            {
                Subscribe(nameof(OnExplosiveDropped));
                Subscribe(nameof(OnExplosiveThrown));
                Subscribe(nameof(OnSupplyDropLanded));
            }

            if (_configData.GodmodeSettings.Enabled)
            {
                Subscribe(nameof(OnGodmodeToggled));
            }

            if (_configData.RustKitsSettings.Enabled)
            {
                Subscribe(nameof(OnKitRedeemed));
            }

            if (_configData.PermissionsSettings.Enabled)
            {
                Subscribe(nameof(OnGroupCreated));
                Subscribe(nameof(OnGroupDeleted));
                Subscribe(nameof(OnTimedGroupAdded));
                Subscribe(nameof(OnTimedGroupExtended));
                Subscribe(nameof(OnTimedPermissionExtended));
                Subscribe(nameof(OnTimedPermissionGranted));
                Subscribe(nameof(OnUserGroupAdded));
                Subscribe(nameof(OnUserGroupRemoved));
                Subscribe(nameof(OnUserPermissionGranted));
                Subscribe(nameof(OnUserPermissionRevoked));
            }

            if (_configData.PlayerConnectedSettings.Enabled
             || _configData.PlayerConnectedInfoSettings.Enabled)
            {
                Subscribe(nameof(OnPlayerConnected));
            }

            if (_configData.ChatSettings.Enabled
             || _configData.ChatTeamSettings.Enabled)
            {
                Subscribe(nameof(OnPlayerChat));
            }

            if (_configData.PlayerDisconnectedSettings.Enabled)
            {
                Subscribe(nameof(OnPlayerDisconnected));
            }

            if (_configData.PlayerRespawnedSettings.Enabled)
            {
                Subscribe(nameof(OnPlayerRespawned));
            }

            if (_configData.NTeleportationSettings.Enabled)
            {
                Subscribe(nameof(OnPlayerTeleported));
            }

            if (_configData.PrivateMessagesSettings.Enabled)
            {
                Subscribe(nameof(OnPMProcessed));
            }

            if (_configData.AdminRadarSettings.Enabled)
            {
                Subscribe(nameof(OnRadarActivated));
                Subscribe(nameof(OnRadarDeactivated));
            }

            if (_configData.RaidableBasesSettings.Enabled)
            {
                Subscribe(nameof(OnRaidableBaseCompleted));
                Subscribe(nameof(OnRaidableBaseEnded));
                Subscribe(nameof(OnRaidableBaseStarted));
            }

            if (_configData.RconCommandSettings.Enabled)
            {
                Subscribe(nameof(OnRconCommand));
            }

            if (_configData.RconConnectionSettings.Enabled)
            {
                Subscribe(nameof(OnRconConnection));
            }

            if (_configData.ServerMessagesSettings.Enabled)
            {
                Subscribe(nameof(OnServerMessage));
            }

            if (_configData.UserBannedSettings.Enabled)
            {
                Subscribe(nameof(OnUserBanned));
                Subscribe(nameof(OnUserUnbanned));
            }

            if (_configData.UserKickedSettings.Enabled)
            {
                Subscribe(nameof(OnUserKicked));
            }

            if (_configData.UserNameUpdateSettings.Enabled)
            {
                Subscribe(nameof(OnUserNameUpdated));
            }

            if (_configData.VanishSettings.Enabled)
            {
                Subscribe(nameof(OnVanishDisappear));
                Subscribe(nameof(OnVanishReappear));
            }

            if (_configData.ErrorSettings.Enabled)
            {
                Application.logMessageReceivedThreaded += HandleLog;
            }

            if (_configData.TeamsSettings.Enabled)
            {
                Subscribe(nameof(OnTeamAcceptInvite));
                Subscribe(nameof(OnTeamCreated));
                Subscribe(nameof(OnTeamDisbanded));
                Subscribe(nameof(OnTeamKick));
                Subscribe(nameof(OnTeamLeave));
                Subscribe(nameof(OnTeamPromote));
                Subscribe(nameof(OnTeamUpdated));
            }
        }

        private string StripRustTags(string text)
        {
            if (string.IsNullOrEmpty(text))
            {
                return string.Empty;
            }

            foreach (string tag in _tags)
            {
                text = text.Replace(tag, _configData.GlobalSettings.TagsReplacement);
            }

            foreach (Regex regexTag in _regexTags)
            {
                text = regexTag.Replace(text, _configData.GlobalSettings.TagsReplacement);
            }

            return text;
        }

        private string GetWebhookURL(string url)
        {
            if (string.IsNullOrEmpty(url))
            {
                return _configData.GlobalSettings.DefaultWebhookURL;
            }

            return url;
        }

        private string GetGridPosition(Vector3 position) => PhoneController.PositionToGridCoord(position);

        private string GetFormattedDurationTime(TimeSpan time, string id = null)
        {
            _sb.Clear();

            if (time.Days > 0)
            {
                BuildTime(_sb, time.Days == 1 ? LangKeys.Format.Day : LangKeys.Format.Days, id, time.Days);
            }

            if (time.Hours > 0)
            {
                BuildTime(_sb, time.Hours == 1 ? LangKeys.Format.Hour : LangKeys.Format.Hours, id, time.Hours);
            }

            if (time.Minutes > 0)
            {
                BuildTime(_sb, time.Minutes == 1 ? LangKeys.Format.Minute : LangKeys.Format.Minutes, id, time.Minutes);
            }

            BuildTime(_sb, time.Seconds == 1 ? LangKeys.Format.Second : LangKeys.Format.Seconds, id, time.Seconds);

            return _sb.ToString();
        }

        private void BuildTime(StringBuilder sb, string lang, string playerID, int value)
        {
            sb.Append(_configData.GlobalSettings.TagsReplacement);
            sb.Append(value);
            sb.Append(_configData.GlobalSettings.TagsReplacement);
            sb.Append(" ");
            sb.Append(Lang(lang, playerID));
            sb.Append(" ");
        }

        private bool IsPluginLoaded(Plugin plugin) => plugin != null && plugin.IsLoaded;

        private void LogToConsole(string text)
        {
            if (_configData.GlobalSettings.LoggingEnabled)
            {
                Puts(text);
            }
        }

        #endregion Helpers

        #region Discord Embed

        #region Send Embed Methods
        /// <summary>
        /// Headers when sending an embeded message
        /// </summary>
        private readonly Dictionary<string, string> _headers = new Dictionary<string, string>()
        {
            {"Content-Type", "application/json"}
        };

        /// <summary>
        /// Sends the DiscordMessage to the specified webhook url
        /// </summary>
        /// <param name="url">Webhook url</param>
        /// <param name="message">Message being sent</param>
        private void DiscordSendMessage(string url, DiscordMessage message)
        {
            webrequest.Enqueue(url, message.ToJson(), DiscordSendMessageCallback, this, RequestMethod.POST, _headers);
        }

        /// <summary>
        /// Callback when sending the embed if any errors occured
        /// </summary>
        /// <param name="code">HTTP response code</param>
        /// <param name="message">Response message</param>
        private void DiscordSendMessageCallback(int code, string message)
        {
            switch (code)
            {
                case 204:
                    _retryCount = 0;
                    QueueCooldownDisable();
                    return;
                case 401:
                    Dictionary<string, object> objectJson = JsonConvert.DeserializeObject<Dictionary<string, object>>(message);
                    int messageCode = 0;
                    if (objectJson["code"] != null && int.TryParse(objectJson["code"].ToString(), out messageCode))
                    {
                        if (messageCode == 50027)
                        {
                            PrintError($"Invalid Webhook Token: '{_queuedMessage.WebhookUrl}'");
                            return;
                        }
                    }
                    break;
                case 404:
                    PrintError($"Invalid Webhook (404: Not Found): '{_queuedMessage.WebhookUrl}'");
                    return;
                case 405:
                    PrintError($"Invalid Webhook (405: Method Not Allowed): '{_queuedMessage.WebhookUrl}'");
                    return;
                case 429:
                    message = "You are being rate limited. To avoid this try to increase queue interval in your config file.";
                    break;
                case 500:
                    message = "There are some issues with Discord server (500 Internal Server Error)";
                    break;
                case 502:
                    message = "There are some issues with Discord server (502 Bad Gateway)";
                    break;
                default:
                    message = $"DiscordSendMessageCallback: code = {code} message = {message}";
                    break;
            }

            _retryCount++;
            PrintError(message);
        }
        #endregion Send Embed Methods

        #region Embed Classes

        private class DiscordMessage
        {
            /// <summary>
            /// String only content to be sent
            /// </summary>
            [JsonProperty("content")]
            private string Content { get; set; }

            public DiscordMessage(string content)
            {
                Content = content;
            }

            /// <summary>
            /// Adds string content to the message
            /// </summary>
            /// <param name="content"></param>
            /// <returns></returns>
            public DiscordMessage AddContent(string content)
            {
                Content = content;
                return this;
            }

            /// <summary>
            /// Returns string content of the message
            /// </summary>
            /// <param name="content"></param>
            /// <returns></returns>
            public string GetContent()
            {
                return Content;
            }

            /// <summary>
            /// Returns message as JSON to be sent in the web request
            /// </summary>
            /// <returns></returns>
            public string ToJson() => JsonConvert.SerializeObject(this, Formatting.None,
                new JsonSerializerSettings {NullValueHandling = NullValueHandling.Ignore});
        }
        #endregion Embed Classes

        #endregion Discord Embed
    }
}

// --- End of file: DiscordLogger.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/AutoDoors.cs ---
// --- Original Local Path: BeeRust/AutoDoors.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Facepunch;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Auto Doors", "Wulf/lukespragg/Arainrr/James/Bushhy", "3.3.10", ResourceId = 1924)]
    [Description("Automatically closes doors behind players after X seconds")]
    public class AutoDoors : RustPlugin
    {
        #region Fields

        [PluginReference] private Plugin RustTranslationAPI;
        private const string PERMISSION_USE = "autodoors.use";
        private readonly Hash<ulong, Timer> doorTimers = new Hash<ulong, Timer>();
        private readonly Dictionary<string, string> supportedDoors = new Dictionary<string, string>();
        private HashSet<DoorManipulator> doorManipulators;

        #endregion Fields

        #region Oxide Hooks

        private void Init()
        {
            LoadData();
            Unsubscribe(nameof(OnEntitySpawned));
            permission.RegisterPermission(PERMISSION_USE, this);
            if (configData.chatS.commands.Length == 0)
            {
                configData.chatS.commands = new[] { "ad" };
            }
            foreach (var command in configData.chatS.commands)
            {
                cmd.AddChatCommand(command, this, nameof(CmdAutoDoor));
            }
        }

        private void OnServerInitialized()
        {
            UpdateConfig();
            if (configData.globalS.excludeDoorController)
            {
                doorManipulators = new HashSet<DoorManipulator>();
                Subscribe(nameof(OnEntitySpawned));
                foreach (var doorManipulator in BaseNetworkable.serverEntities.OfType<DoorManipulator>())
                {
                    OnEntitySpawned(doorManipulator);
                }
            }
        }

        private void OnEntitySpawned(DoorManipulator doorManipulator)
        {
            if (doorManipulator == null || doorManipulator.OwnerID == 0) return;
            doorManipulators.Add(doorManipulator);
        }

        private void OnEntityKill(DoorManipulator doorManipulator)
        {
            if (doorManipulator == null || doorManipulators == null) return;
            doorManipulators.RemoveWhere(x => x == doorManipulator);
        }

        private void OnEntityKill(Door door)
        {
            if (door == null || door.net == null) return;
            var doorID = door.net.ID.Value;
            Timer value;
            if (doorTimers.TryGetValue(doorID, out value))
            {
                value?.Destroy();
                doorTimers.Remove(doorID);
            }
            foreach (var playerData in storedData.playerData.Values)
            {
                playerData.theDoorS.Remove(doorID);
            }
        }

        private void OnServerSave() => timer.Once(UnityEngine.Random.Range(0f, 60f), SaveData);

        private void Unload()
        {
            foreach (var value in doorTimers.Values)
            {
                value?.Destroy();
            }
            SaveData();
        }

        private void OnDoorOpened(Door door, BasePlayer player)
        {
            if (door == null || door.net == null || !door.IsOpen()) return;
            if (!supportedDoors.ContainsKey(door.ShortPrefabName)) return;
            if (!configData.globalS.useUnownedDoor && door.OwnerID == 0) return;
            if (configData.globalS.excludeDoorController && HasDoorController(door)) return;
            if (configData.usePermission && !permission.UserHasPermission(player.UserIDString, PERMISSION_USE)) return;

            var playerData = GetPlayerData(player.userID, true);
            if (!playerData.doorData.enabled) return;
            float autoCloseTime;
            var doorID = door.net.ID.Value;
            StoredData.DoorData doorData;
            if (playerData.theDoorS.TryGetValue(doorID, out doorData))
            {
                if (!doorData.enabled) return;
                autoCloseTime = doorData.time;
            }
            else if (playerData.doorTypeS.TryGetValue(door.ShortPrefabName, out doorData))
            {
                if (!doorData.enabled) return;
                autoCloseTime = doorData.time;
            }
            else autoCloseTime = playerData.doorData.time;

            if (autoCloseTime <= 0) return;
            if (Interface.CallHook("OnDoorAutoClose", player, door) != null) return;

            Timer value;
            if (doorTimers.TryGetValue(doorID, out value))
            {
                value?.Destroy();
            }
            doorTimers[doorID] = timer.Once(autoCloseTime, () =>
            {
                doorTimers.Remove(doorID);
                if (door == null || !door.IsOpen()) return;
                if (configData.globalS.cancelOnKill && player != null && player.IsDead()) return;
                door.SetFlag(BaseEntity.Flags.Open, false);
                door.SendNetworkUpdateImmediate();
            });
        }

        private void OnDoorClosed(Door door, BasePlayer player)
        {
            if (door == null || door.net == null || door.IsOpen()) return;
            Timer value;
            if (doorTimers.TryGetValue(door.net.ID.Value, out value))
            {
                value?.Destroy();
                doorTimers.Remove(door.net.ID.Value);
            }
        }

        #endregion Oxide Hooks

        #region Methods

        private bool HasDoorController(Door door)
        {
            foreach (var doorManipulator in doorManipulators)
            {
                if (doorManipulator != null && doorManipulator.targetDoor == door)
                {
                    return true;
                }
            }
            return false;
        }

        private StoredData.PlayerData GetPlayerData(ulong playerID, bool readOnly = false)
        {
            StoredData.PlayerData playerData;
            if (!storedData.playerData.TryGetValue(playerID, out playerData))
            {
                playerData = new StoredData.PlayerData
                {
                    doorData = new StoredData.DoorData
                    {
                        enabled = configData.globalS.defaultEnabled,
                        time = configData.globalS.defaultDelay,
                    }
                };
                if (readOnly)
                {
                    return playerData;
                }
                storedData.playerData.Add(playerID, playerData);
            }

            return playerData;
        }

        private static Door GetLookingAtDoor(BasePlayer player)
        {
            RaycastHit rHit;
            if (Physics.Raycast(player.eyes.HeadRay(), out rHit, 10f, Rust.Layers.Mask.Construction))
            {
                return rHit.GetEntity() as Door;
            }
            return null;
        }

        private void UpdateConfig()
        {
            foreach (var itemDefinition in ItemManager.GetItemDefinitions())
            {
                var itemModDeployable = itemDefinition.GetComponent<ItemModDeployable>();
                if (itemModDeployable == null) continue;
                var door = GameManager.server.FindPrefab(itemModDeployable.entityPrefab.resourcePath)?.GetComponent<Door>();
                if (door == null || string.IsNullOrEmpty(door.ShortPrefabName)) continue;
                ConfigData.DoorSettings doorSettings;
                if (!configData.doorS.TryGetValue(itemDefinition.shortname, out doorSettings))
                {
                    doorSettings = new ConfigData.DoorSettings
                    {
                        enabled = true,
                        displayName = itemDefinition.displayName.english
                    };
                    configData.doorS.Add(itemDefinition.shortname, doorSettings);
                }
                if (doorSettings.enabled && !supportedDoors.ContainsKey(door.ShortPrefabName))
                {
                    supportedDoors.Add(door.ShortPrefabName, doorSettings.displayName);
                }
            }
            SaveConfig();
        }

        #region RustTranslationAPI

        private string GetDeployableTranslation(string language, string deployable) => (string)RustTranslationAPI.Call("GetDeployableTranslation", language, deployable);

        private string GetDeployableDisplayName(BasePlayer player, string deployable, string displayName)
        {
            if (RustTranslationAPI != null)
            {
                displayName = GetDeployableTranslation(lang.GetLanguage(player.UserIDString), deployable);
                if (!string.IsNullOrEmpty(displayName))
                {
                    return displayName;
                }
            }
            return displayName;
        }

        #endregion RustTranslationAPI

        #endregion Methods

        #region ChatCommand

        private void CmdAutoDoor(BasePlayer player, string command, string[] args)
        {
            if (configData.usePermission && !permission.UserHasPermission(player.UserIDString, PERMISSION_USE))
            {
                Print(player, Lang("NotAllowed", player.UserIDString));
                return;
            }
            var playerData = GetPlayerData(player.userID);
            if (args == null || args.Length == 0)
            {
                playerData.doorData.enabled = !playerData.doorData.enabled;
                Print(player, Lang("AutoDoor", player.UserIDString, playerData.doorData.enabled ? Lang("Enabled", player.UserIDString) : Lang("Disabled", player.UserIDString)));
                return;
            }
            float time;
            if (float.TryParse(args[0], out time))
            {
                if (time <= configData.globalS.maximumDelay && time >= configData.globalS.minimumDelay)
                {
                    playerData.doorData.time = time;
                    if (!playerData.doorData.enabled) playerData.doorData.enabled = true;
                    Print(player, Lang("AutoDoorDelay", player.UserIDString, time));
                    return;
                }
                Print(player, Lang("AutoDoorDelayLimit", player.UserIDString, configData.globalS.minimumDelay, configData.globalS.maximumDelay));
                return;
            }
            switch (args[0].ToLower())
            {
                case "a":
                case "all":
                    {
                        if (args.Length > 1)
                        {
                            if (float.TryParse(args[1], out time))
                            {
                                if (time <= configData.globalS.maximumDelay && time >= configData.globalS.minimumDelay)
                                {
                                    playerData.doorData.time = time;
                                    playerData.doorTypeS.Clear();
                                    playerData.theDoorS.Clear();
                                    Print(player, Lang("AutoDoorDelayAll", player.UserIDString, time));
                                    return;
                                }

                                Print(player,
                                    Lang("AutoDoorDelayLimit", player.UserIDString, configData.globalS.minimumDelay,
                                        configData.globalS.maximumDelay));
                                return;
                            }
                        }

                        break;
                    }
                case "s":
                case "single":
                    {
                        var door = GetLookingAtDoor(player);
                        if (door == null || door.net == null)
                        {
                            Print(player, Lang("DoorNotFound", player.UserIDString));
                            return;
                        }

                        string doorDisplayName;
                        if (!supportedDoors.TryGetValue(door.ShortPrefabName, out doorDisplayName))
                        {
                            Print(player, Lang("DoorNotSupported", player.UserIDString));
                            return;
                        }

                        StoredData.DoorData doorData;
                        if (!playerData.theDoorS.TryGetValue(door.net.ID.Value, out doorData))
                        {
                            doorData = new StoredData.DoorData
                            { enabled = true, time = configData.globalS.defaultDelay };
                            playerData.theDoorS.Add(door.net.ID.Value, doorData);
                        }

                        if (args.Length <= 1)
                        {
                            doorData.enabled = !doorData.enabled;
                            Print(player,
                                Lang("AutoDoorSingle", player.UserIDString,
                                    GetDeployableDisplayName(player, door.ShortPrefabName, doorDisplayName),
                                    doorData.enabled
                                        ? Lang("Enabled", player.UserIDString)
                                        : Lang("Disabled", player.UserIDString)));
                            return;
                        }

                        if (float.TryParse(args[1], out time))
                        {
                            if (time <= configData.globalS.maximumDelay && time >= configData.globalS.minimumDelay)
                            {
                                doorData.time = time;
                                Print(player, Lang("AutoDoorSingleDelay", player.UserIDString,
                                    GetDeployableDisplayName(player, door.ShortPrefabName, doorDisplayName), time));
                                return;
                            }

                            Print(player,
                                Lang("AutoDoorDelayLimit", player.UserIDString, configData.globalS.minimumDelay,
                                    configData.globalS.maximumDelay));
                            return;
                        }

                        break;
                    }

                case "t":
                case "type":
                    {
                        var door = GetLookingAtDoor(player);
                        if (door == null || door.net == null)
                        {
                            Print(player, Lang("DoorNotFound", player.UserIDString));
                            return;
                        }

                        string doorDisplayName;
                        if (!supportedDoors.TryGetValue(door.ShortPrefabName, out doorDisplayName))
                        {
                            Print(player, Lang("DoorNotSupported", player.UserIDString));
                            return;
                        }

                        StoredData.DoorData doorData;
                        if (!playerData.doorTypeS.TryGetValue(door.ShortPrefabName, out doorData))
                        {
                            doorData = new StoredData.DoorData
                            { enabled = true, time = configData.globalS.defaultDelay };
                            playerData.doorTypeS.Add(door.ShortPrefabName, doorData);
                        }

                        if (args.Length <= 1)
                        {
                            doorData.enabled = !doorData.enabled;
                            Print(player,
                                Lang("AutoDoorType", player.UserIDString, GetDeployableDisplayName(player, door.ShortPrefabName, doorDisplayName),
                                    doorData.enabled
                                        ? Lang("Enabled", player.UserIDString)
                                        : Lang("Disabled", player.UserIDString)));
                            return;
                        }

                        if (float.TryParse(args[1], out time))
                        {
                            if (time <= configData.globalS.maximumDelay && time >= configData.globalS.minimumDelay)
                            {
                                doorData.time = time;
                                Print(player, Lang("AutoDoorTypeDelay", player.UserIDString,
                                    GetDeployableDisplayName(player, door.ShortPrefabName, doorDisplayName), time));
                                return;
                            }

                            Print(player,
                                Lang("AutoDoorDelayLimit", player.UserIDString, configData.globalS.minimumDelay,
                                    configData.globalS.maximumDelay));
                            return;
                        }

                        break;
                    }

                case "h":
                case "help":
                    {
                        StringBuilder stringBuilder = Pool.Get<StringBuilder>();
                        stringBuilder.AppendLine();
                        var firstCmd = configData.chatS.commands[0];
                        stringBuilder.AppendLine(Lang("AutoDoorSyntax", player.UserIDString, firstCmd));
                        stringBuilder.AppendLine(Lang("AutoDoorSyntax1", player.UserIDString, firstCmd,
                            configData.globalS.minimumDelay, configData.globalS.maximumDelay));
                        stringBuilder.AppendLine(Lang("AutoDoorSyntax2", player.UserIDString, firstCmd));
                        stringBuilder.AppendLine(Lang("AutoDoorSyntax3", player.UserIDString, firstCmd,
                            configData.globalS.minimumDelay, configData.globalS.maximumDelay));
                        stringBuilder.AppendLine(Lang("AutoDoorSyntax4", player.UserIDString, firstCmd));
                        stringBuilder.AppendLine(Lang("AutoDoorSyntax5", player.UserIDString, firstCmd,
                            configData.globalS.minimumDelay, configData.globalS.maximumDelay));
                        stringBuilder.AppendLine(Lang("AutoDoorSyntax6", player.UserIDString, firstCmd,
                            configData.globalS.minimumDelay, configData.globalS.maximumDelay));
                        Print(player, stringBuilder.ToString());
                        stringBuilder.Clear();
                        Pool.Free(ref stringBuilder);
                        return;
                    }
            }
            Print(player, Lang("SyntaxError", player.UserIDString, configData.chatS.commands[0]));
        }

        #endregion ChatCommand

        #region ConfigurationFile

        private ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Use permissions")]
            public bool usePermission = false;

            [JsonProperty(PropertyName = "Clear data on map wipe")]
            public bool clearDataOnWipe = false;

            [JsonProperty(PropertyName = "Global settings")]
            public GlobalSettings globalS = new GlobalSettings();

            [JsonProperty(PropertyName = "Chat settings")]
            public ChatSettings chatS = new ChatSettings();

            [JsonProperty(PropertyName = "Door Settings")]
            public Dictionary<string, DoorSettings> doorS = new Dictionary<string, DoorSettings>();

            public class DoorSettings
            {
                public bool enabled;
                public string displayName;
            }

            public class GlobalSettings
            {
                [JsonProperty(PropertyName = "Allows automatic closing of unowned doors")]
                public bool useUnownedDoor = false;

                [JsonProperty(PropertyName = "Exclude door controller")]
                public bool excludeDoorController = true;

                [JsonProperty(PropertyName = "Cancel on player dead")]
                public bool cancelOnKill = false;

                [JsonProperty(PropertyName = "Default enabled")]
                public bool defaultEnabled = true;

                [JsonProperty(PropertyName = "Default delay")]
                public float defaultDelay = 5f;

                [JsonProperty(PropertyName = "Maximum delay")]
                public float maximumDelay = 10f;

                [JsonProperty(PropertyName = "Minimum delay")]
                public float minimumDelay = 5f;
            }

            public class ChatSettings
            {
                [JsonProperty(PropertyName = "Chat command")]
                public string[] commands = { "ad", "autodoor" };

                [JsonProperty(PropertyName = "Chat prefix")]
                public string prefix = "<color=#00FFFF>[AutoDoors]</color>: ";

                [JsonProperty(PropertyName = "Chat steamID icon")]
                public ulong steamIDIcon = 0;
            }

            [JsonProperty(PropertyName = "Version")]
            public VersionNumber version;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                configData = Config.ReadObject<ConfigData>();
                if (configData == null)
                {
                    LoadDefaultConfig();
                }
                else
                {
                    UpdateConfigValues();
                }
            }
            catch (Exception ex)
            {
                PrintError($"The configuration file is corrupted. \n{ex}");
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            configData = new ConfigData();
            configData.version = Version;
        }

        protected override void SaveConfig() => Config.WriteObject(configData);

        private void UpdateConfigValues()
        {
            if (configData.version < Version)
            {
                if (configData.version <= default(VersionNumber))
                {
                    string prefix, prefixColor;
                    if (GetConfigValue(out prefix, "Chat Settings", "Chat Prefix") && GetConfigValue(out prefixColor, "Chat Settings", "Chat Prefix Color"))
                    {
                        configData.chatS.prefix = $"<color={prefixColor}>{prefix}</color>: ";
                    }
                }
                configData.version = Version;
            }
        }

        private bool GetConfigValue<T>(out T value, params string[] path)
        {
            var configValue = Config.Get(path);
            if (configValue == null)
            {
                value = default(T);
                return false;
            }
            value = Config.ConvertValue<T>(configValue);
            return true;
        }

        #endregion ConfigurationFile

        #region DataFile

        private StoredData storedData;

        private class StoredData
        {
            public readonly Dictionary<ulong, PlayerData> playerData = new Dictionary<ulong, PlayerData>();

            public class PlayerData
            {
                public DoorData doorData = new DoorData();
                public readonly Dictionary<ulong, DoorData> theDoorS = new Dictionary<ulong, DoorData>();
                public readonly Dictionary<string, DoorData> doorTypeS = new Dictionary<string, DoorData>();
            }

            public class DoorData
            {
                public bool enabled;
                public float time;
            }
        }

        private void LoadData()
        {
            try
            {
                storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
            }
            catch
            {
                storedData = null;
            }
            finally
            {
                if (storedData == null)
                {
                    ClearData();
                }
            }
        }

        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, storedData);

        private void ClearData()
        {
            storedData = new StoredData();
            SaveData();
        }

        private void OnNewSave(string filename)
        {
            if (configData.clearDataOnWipe)
            {
                ClearData();
            }
            else
            {
                foreach (var value in storedData.playerData.Values)
                {
                    value.theDoorS.Clear();
                }
                SaveData();
            }
        }

        #endregion DataFile

        #region LanguageFile

        private void Print(BasePlayer player, string message)
        {
            Player.Message(player, message, configData.chatS.prefix, configData.chatS.steamIDIcon);
        }

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NotAllowed"] = "You do not have permission to use this command",
                ["Enabled"] = "<color=#8ee700>Enabled</color>",
                ["Disabled"] = "<color=#ce422b>Disabled</color>",
                ["AutoDoor"] = "Automatic door closing is now {0}",
                ["AutoDoorDelay"] = "Automatic door closing delay set to {0}s. (Doors set by 'single' and 'type' are not included)",
                ["AutoDoorDelayAll"] = "Automatic closing delay of all doors set to {0}s",
                ["DoorNotFound"] = "You need to look at a door",
                ["DoorNotSupported"] = "This type of door is not supported",
                ["AutoDoorDelayLimit"] = "Automatic door closing delay allowed is between {0}s and {1}s",
                ["AutoDoorSingle"] = "Automatic closing of this <color=#4DFF4D>{0}</color> is {1}",
                ["AutoDoorSingleDelay"] = "Automatic closing delay of this <color=#4DFF4D>{0}</color> is {1}s",
                ["AutoDoorType"] = "Automatic closing of <color=#4DFF4D>{0}</color> door is {1}",
                ["AutoDoorTypeDelay"] = "Automatic closing delay of <color=#4DFF4D>{0}</color> door is {1}s",
                ["SyntaxError"] = "Syntax error, type '<color=#ce422b>/{0} <help | h></color>' to view help",

                ["AutoDoorSyntax"] = "<color=#ce422b>/{0} </color> - Enable/Disable automatic door closing",
                ["AutoDoorSyntax1"] = "<color=#ce422b>/{0} [time (seconds)]</color> - Set automatic closing delay for doors, the allowed time is between {1}s and {2}s. (Doors set by 'single' and 'type' are not included)",
                ["AutoDoorSyntax2"] = "<color=#ce422b>/{0} <single | s></color> - Enable/Disable automatic closing of the door you are looking at",
                ["AutoDoorSyntax3"] = "<color=#ce422b>/{0} <single | s> [time (seconds)]</color> - Set automatic closing delay for the door you are looking at, the allowed time is between {1}s and {2}s",
                ["AutoDoorSyntax4"] = "<color=#ce422b>/{0} <type | t></color> - Enable/disable automatic door closing for the type of door you are looking at. ('type' is just a word, not the type of door)",
                ["AutoDoorSyntax5"] = "<color=#ce422b>/{0} <type | t> [time (seconds)]</color> - Set automatic closing delay for the type of door you are looking at, the allowed time is between {1}s and {2}s. ('type' is just a word, not the type of door)",
                ["AutoDoorSyntax6"] = "<color=#ce422b>/{0} <all | a> [time (seconds)]</color> - Set automatic closing delay for all doors, the allowed time is between {1}s and {2}s.",
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NotAllowed"] = "您没有权限使用该命令",
                ["Enabled"] = "<color=#8ee700>已启用</color>",
                ["Disabled"] = "<color=#ce422b>已禁用</color>",
                ["AutoDoor"] = "自动关门现在的状态为 {0}",
                ["AutoDoorDelay"] = "自动关门延迟设置为 {0}秒",
                ["AutoDoorDelayAll"] = "全部门的自动关闭延迟设置为 {0}秒",
                ["DoorNotFound"] = "请您看着一条门再输入指令",
                ["DoorNotSupported"] = "不支持您看着的这种门",
                ["AutoDoorDelayLimit"] = "自动关门延迟应该在 {0}秒 和 {1}秒 之间",
                ["AutoDoorSingle"] = "这条 <color=#4DFF4D>{0}</color> 的自动关闭状态为 {1}",
                ["AutoDoorSingleDelay"] = "这条 <color=#4DFF4D>{0}</color> 的自动关闭延迟为 {1}秒",
                ["AutoDoorType"] = "这种 <color=#4DFF4D>{0}</color> 的自动关闭状态为 {1}",
                ["AutoDoorTypeDelay"] = "这种 <color=#4DFF4D>{0}</color> 的自动关闭延迟为 {1}秒",
                ["SyntaxError"] = "语法错误, 输入 '<color=#ce422b>/{0} <help | h></color>' 查看帮助",

                ["AutoDoorSyntax"] = "<color=#ce422b>/{0} </color> - 启用/禁用自动关门",
                ["AutoDoorSyntax1"] = "<color=#ce422b>/{0} [时间 (秒)]</color> - 设置自动关门延迟。(时间在 {1}秒 和 {2}秒 之间) (不包括'single'和'type'设置的门)",
                ["AutoDoorSyntax2"] = "<color=#ce422b>/{0} <single | s></color> - 为您看着的这条门，启用/禁用自动关门",
                ["AutoDoorSyntax3"] = "<color=#ce422b>/{0} <single | s> [时间 (秒)]</color> - 为您看着的这条门设置自动关闭延迟。(时间在 {1}秒 和 {2}秒 之间)",
                ["AutoDoorSyntax4"] = "<color=#ce422b>/{0} <type | t></color> - 为您看着的这种门，启用/禁用自动关门",
                ["AutoDoorSyntax5"] = "<color=#ce422b>/{0} <type | t> [时间 (秒)]</color> - 为您看着的这种门设置自动关闭延迟。(时间在 {1}秒 和 {2}秒 之间)",
                ["AutoDoorSyntax6"] = "<color=#ce422b>/{0} <all | a> [时间 (秒)]</color> - 为所有门设置自动关闭延迟。(时间在 {1}秒 和 {2}秒 之间)",
            }, this, "zh-CN");
        }

        #endregion LanguageFile
    }
}

// --- End of file: AutoDoors.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/DamageReducer.cs ---
// --- Original Local Path: BeeRust/DamageReducer.cs ---

using Newtonsoft.Json;
using Rust;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("DamageReducer", "Reheight", "1.0.0")]
    [Description("Allows you to change the damage of specific entities.")]
    public class DamageReducer : RustPlugin
    {
        PluginConfig _config;

        private void Init()
        {
            _config = Config.ReadObject<PluginConfig>();
        }

        protected override void LoadDefaultConfig() => _config = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                _config = Config.ReadObject<PluginConfig>();

                if (_config == null)
                {
                    throw new JsonException();
                }

                if (!_config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    PrintWarning($"PluginConfig file {Name}.json updated.");

                    SaveConfig();
                }
            }
            catch
            {
                LoadDefaultConfig();

                PrintError("Config file contains an error and has been replaced with the default file.");
            }

        }

        protected override void SaveConfig() => Config.WriteObject(_config, true);

        private class PluginConfig
        {
            [JsonProperty(PropertyName = "Damage Scale", Order = 0)]
            public Dictionary<string, float> DamageScale { get; set; }

            [JsonProperty(PropertyName = "Debug Mode", Order = 1)]
            public bool debug { get; set; }

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        private PluginConfig GetDefaultConfig()
        {
            return new PluginConfig
            {
                DamageScale = new Dictionary<string, float>()
                {
                    { "rocket_hv", 56f },
                    { "40mm_grenade_he", 70f },
                    { "grenade.f1.deployed", 60f }
                },
                debug = false
            };
        }

        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
        {
            if (entity == null || hitInfo == null || entity is BasePlayer == false) return;

            DamageType type = hitInfo?.damageTypes.GetMajorityDamageType() ?? DamageType.Generic;

            if (type == DamageType.Suicide) return;

            BasePlayer attacker = hitInfo?.Initiator as BasePlayer;
            if (attacker == null) return;

            if (hitInfo.WeaponPrefab)
            {
                if (_config.debug)
                {
                    Puts(type.ToString());
                    Puts(hitInfo.WeaponPrefab.ShortPrefabName);
                }

                float damagePercentage;

                if (!_config.DamageScale.TryGetValue(hitInfo.WeaponPrefab.ShortPrefabName, out damagePercentage))
                {
                    return;
                }

                hitInfo.damageTypes.ScaleAll(damagePercentage / 100);

                if (_config.debug)
                {
                    Puts((damagePercentage / 100).ToString());
                }
            }
        }
    }
}

// --- End of file: DamageReducer.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/Rocke.cs ---
// --- Original Local Path: BeeRust/Rocke.cs ---

﻿using Oxide.Core;
using System;
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using ConVar;
using System.IO;
using System.Text;
using Network;
using UnityEngine;
using Oxide.Game.Rust.Cui;

namespace Oxide.Plugins
{
    [Info("Rocke", "sdapro", "1.0.0")]
    public class Rocke : CovalencePlugin
    {
        int bigRocketCount = 1;
        int littleRocketCount = 1;

        bool javalinBlowUp = false;


        int xSize = 1;
        int ySize = 1;
        int maxRange = 200;

        int scatterSize = 3;

        ulong javalin = 2656578790;

        int instaHealAmount = 15;
        int passiveHealAmount = 50;

        bool spawnFlares = true;
        int stunDuration = 4;

        HashSet<ulong> skins = new HashSet<ulong>();
        #region Config

        private void Init()
        {
			permission.RegisterPermission("rocke.rq", this);
            javalinBlowUp = (bool)Config["javalinDestroyOnShoot"];
			javalin = ulong.Parse(Config["javalinSkin"].ToString());


            if (Config["SpawnFlares"] == null)
            {
                Config["SpawnFlares"] = true;
                SaveConfig();

            }

            
            spawnFlares = (bool)Config["SpawnFlares"];

            skins.Add(javalin);

        }


        protected override void LoadDefaultConfig()
        {
            Config["javalinDestroyOnShoot"] = false;
			Config["javalinSkin"] = 2656578790;
        }

        #endregion



        #region Commands
        [Command("jar"), Permission("rocke.jav")]
        private void jar(IPlayer iplayer, string command, string[] args)
        {
            BasePlayer player = iplayer.Object as BasePlayer;

            player.inventory.GiveItem(ItemManager.CreateByName("multiplegrenadelauncher", 1, javalin),
                          player.inventory.containerBelt);
        }
        #endregion

        #region Hooks
        void OnRocketLaunched(BasePlayer player, BaseEntity entity)
        {
            HeldEntity item = player.GetHeldEntity();
            Item invItem = item.GetItem();
            if(invItem.skin == javalin)
			if(permission.UserHasPermission(player.userID.ToString(), "rocke.rq"))
            {
                entity.Kill();
                JavalinRocket(player.IPlayer);
                if(javalinBlowUp)
                    invItem.DoRemove();
            }

            return;    
        }
        #endregion
private void JavalinRocket(IPlayer iplayer)
{
    BasePlayer player = iplayer.Object as BasePlayer;
    Vector3 firingDir = player.GetNetworkRotation() * Vector3.forward;

    RaycastHit hitInfo;
    Vector3 firingPos = player.eyes.transform.position + Vector3.up;
    Vector3 target;
    if (UnityEngine.Physics.Raycast(firingPos, firingDir, out hitInfo, maxRange, 1236478737))
    {
        target = hitInfo.point;
    }
    else
    {
        target = firingPos + (firingDir.normalized * maxRange);
    }

    BaseEntity entity = GameManager.server.CreateEntity("assets/prefabs/npc/patrol helicopter/rocket_heli.prefab", firingPos + firingDir);
    ServerProjectile projectile = entity.GetComponent<ServerProjectile>();
    Vector3 vector3 = projectile.initialVelocity + firingDir * 1;
    projectile.gravityModifier = 2;
    projectile.InitializeVelocity(vector3);

    entity.creatorEntity = (BaseEntity)player;
    entity.OwnerID = player.userID;
    entity.Spawn();

    timer.Once(0.1f, () => // Start up motion
    {
        if (entity == null || projectile == null || entity.IsDestroyed) return;
        projectile.gravityModifier = 0f;
        Vector3 newVel = projectile.initialVelocity + firingDir * 100;
        projectile.InitializeVelocity(newVel);
    });

    timer.Once(0.01f, () =>
    {
        TimedExplosive newNade = entity as TimedExplosive;
        if (newNade != null)
        {
            newNade.SetFuse(30.0f);
        }
    });
}

        private List<BasePlayer> FindAllPlayersNear(Vector3 pos, float radius)
        {
            Collider[] cast = UnityEngine.Physics.OverlapSphere(pos, radius);
            List<BasePlayer> ents = new List<BasePlayer>();
            foreach (Collider item in cast)
            {
                BaseEntity entity = item.gameObject.ToBaseEntity();
                if (entity.IsValid() && entity is BasePlayer && entity is ScientistNPC == false && entity.IsVisible(pos))
                {
                    ents.Add(entity as BasePlayer);
                }
            }
            return ents;
        }
        
        private static void PlayEffect(string effect, BaseEntity entity)
        {
            BaseEntity playerEntity = entity;
            Effect reusableInstance = new Effect();
            reusableInstance.Clear();

            reusableInstance.Init(Effect.Type.Generic, playerEntity, 0, new Vector3(0, 0, 0), new Vector3(0, 0, 0), null);
            reusableInstance.scale = false ? 0.0f : 1f;


            reusableInstance.pooledString = effect;
            EffectNetwork.Send(reusableInstance);
        }
        public class OnCollisionExplode : MonoBehaviour
        {
            public TimedExplosive ent { get; set; }


            void OnCollisionEnter(Collision collision)
            {
                ent.Explode();
                Destroy(this);
            }
        }
    }
}

// --- End of file: Rocke.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/GameStoresRUST.cs ---
// --- Original Local Path: BeeRust/GameStoresRUST.cs ---

﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using WebSocketSharp;

namespace Oxide.Plugins
{
    [Info("GameStoresRUST", "HOUGAN & Sstine & rostov114 # GAMESTORES", "0.4.0")]
    public class GameStoresRUST : RustPlugin
    {
        #region References

        [PluginReference] private Plugin ImageLibrary;

        #endregion

        #region Classes

        private static class Delays
        {
            //[JsonProperty("Игроки с активными запросами к АПИ")]
            public static List<ulong> ItemList = new List<ulong>();
            //[JsonProperty("Количество запросов за последнюю секунду")]
            public static int RequestPerSecond = 0;
            //[JsonProperty("Ограничение запросов в секунду")]
            public static int RequestPerSecondLimit = 20;

            public static bool CanRequest(BasePlayer player)
            {
                if (RequestPerSecond > RequestPerSecondLimit)
                {
                    return false;
                }

                if (ItemList.Contains(player.userID))
                {
                    player.ChatMessage(instance._(player, "WaitPreviousAction"));
                    return false;
                }
                return true;
            }

            public static void FinishRequest(BasePlayer player)
            {
                if (ItemList.Contains(player.userID))
                    ItemList.Remove(player.userID);
            }

            public static IEnumerator MakeRequest(BasePlayer player)
            {
                RequestPerSecond++;

                if (ItemList.Contains(player.userID)) yield return null;
                ItemList.Add(player.userID);

                yield return new WaitForSeconds(3f);
                if (ItemList.Contains(player.userID))
                    ItemList.Remove(player.userID);
            }
        }

        private class Stats
        {

        }

        private class Configuration
        {
            public class API
            {
                [JsonProperty("ИД магазина в сервисе")]
                public string ShopID = "UNDEFINED";
                [JsonProperty("ИД сервера в сервисе")]
                public string ServerID = "UNDEFINED";
                [JsonProperty("Секретный ключ (не распространяйте его)")]
                public string SecretKey = "UNDEFINED";
            }

            public class Interface
            {
                [JsonProperty("Включить изображение корзины")]
                public bool BucketEnable = true;
                [JsonProperty("Включить отображение названий предметов")]
                public bool TextShow = true;
                [JsonProperty("Ссылка на изображение корзины (BUCKET - стандартное изображение)")]
                public string BucketURL = "BUCKET";
                [JsonProperty("Количество предметов на строке")]
                public int ItemOnString = 7;
                [JsonProperty("Количество строк в интерфейсе")]
                public int StringAmount = 3;
                [JsonProperty("Сторона одного предмета")]
                public int ItemSide = 150;
                [JsonProperty("Отступ между предметами")]
                public int ItemMargin = 5;
				[JsonProperty("Настройки позиции изображение корзины")]
                public Position BucketPosition = new Position();

				public class Position
				{
					public string AnchorMin = "0 1";
					public string AnchorMax = "0 1";
					public string OffsetMin = "8 -40";
					public string OffsetMax = "43 -6";
				}
            }

            public class TOP
            {
                [JsonProperty("Отправлять данные топа игроков")]
                public bool UseTop = false;
            }

            [JsonProperty("Настройки API плагина")]
            public API APISettings = new API();
            [JsonProperty("Настройки интерфейса плагина")]
            public Interface InterfaceSettings = new Interface();
            [JsonProperty("Настройки статистики сервера")]
            public TOP TOPSettings = new TOP();
        }

        private class WItem
        {
            public string ID;
            public string Name;
            public int ItemID;
            public int Amount;
            public string ShortName;
            public string Command;
            public string ImageUrl;

            public bool Blocked;
            public double Block_Date = 0;
            public bool IsBlueprint;
            public bool IsCommand;
            public bool IsItem;

            public WItem(Dictionary<string, object> data, bool show = true)
            {
                try
                {
                    if (data.ContainsKey("id")) ID = data["id"].ToString();

                    if (data.ContainsKey("name")) Name = data["name"].ToString();
                    if (data.ContainsKey("item_id")) ItemID = System.Convert.ToInt32(data["item_id"]);
                    if (data.ContainsKey("amount")) Amount = System.Convert.ToInt32(data["amount"]);
                    if (data.ContainsKey("command")) Command = data["command"].ToString();
                    if (data.ContainsKey("img")) ImageUrl = data["img"].ToString();

                    if (data.ContainsKey("blocked")) Blocked = bool.Parse(data["blocked"].ToString());

                    if (data.ContainsKey("block_date") && data["block_date"] is int)
                    {
                        double.TryParse(data["block_date"].ToString(), out Block_Date);
                    }

                    if (data.ContainsKey("type"))
                    {
                        IsBlueprint = data["type"].ToString() == "bp";
                        IsCommand = data["type"].ToString() == "command";
                        IsItem = data["type"].ToString() == "item";
                    }

                    if (ItemID != 0)
                    {
                        var itemInfo = ItemManager.FindItemDefinition(ItemID);
                        if (itemInfo != null) ShortName = itemInfo.shortname;
                        else if (IDToShortName.ContainsKey(ItemID))
                        {
                            itemInfo = ItemManager.FindItemDefinition(IDToShortName[ItemID]);
                            if (itemInfo == null) return;

                            ShortName = itemInfo.shortname;
                        }
                    }

                    var imageLibrary = instance.plugins.Find("ImageLibrary");
                    if (imageLibrary != null)
                    {
                        //if (ItemID == 0)
                        //{
                            if ((bool)imageLibrary.Call("HasImage", $"IconGS.{ID}"))
                            {
                                string probablyId = (string)imageLibrary.Call("GetImage", $"IconGS.{ID}");
                                if (!probablyId.IsNullOrEmpty() && probablyId != instance.NoImageID && probablyId != instance.LoadingImageID)
                                    ImageUrl = probablyId;
                                return;
                            }

                            if (!ImageUrl.IsNullOrEmpty())
                            {
                                imageLibrary.Call("AddImage", ImageUrl.Replace("https", "http"), $"IconGS.{ID}");
                            }
                        //}
                        //else
                        //{
                        //    string probablyId = (string)imageLibrary.Call("GetImage", ShortName);
                        //    if (!probablyId.IsNullOrEmpty() && probablyId != instance.NoImageID && probablyId != instance.LoadingImageID)
                        //        ImageUrl = probablyId;
                        //}
                    }
                }
                catch (NullReferenceException e)
                {
                    Interface.Oxide.LogError(JsonConvert.SerializeObject(data));
                }
            }
        }

        #endregion

        #region Variables

        private static bool initialization = false;
        private static bool Initialized = false;
        private static bool SecureConnection = true;
        private static GameStoresRUST instance;
        private static Configuration Settings = new Configuration();
        private string ShopURL = "UNDEFINED";
        private int StartBalance = 0;
        public string NoImageID = "";
        public string LoadingImageID = "";
        private Coroutine LoadingCoroutine;
        private Dictionary<int, Dictionary<ulong, int>> ListTimeOutCommand = new Dictionary<int, Dictionary<ulong, int>>();
        private Dictionary<ulong, List<int>> playersBasketCache = new Dictionary<ulong, List<int>>();
        private HashSet<ulong> ListBannedCommandUserID = new HashSet<ulong>();
        private Timer TimerCheckInstant;
        private string MainApiLink = "https://gamestores.app/api/";
        private string ReserveApiLink = "https://gs.gamestores.app/api/";
        //private string BaseRequest => $"https://gamestores.app/api/?shop_id={Settings.APISettings.ShopID}&secret={Settings.APISettings.SecretKey}{(!Settings.APISettings.ServerID.IsNullOrEmpty() && Settings.APISettings.ServerID != "0" && Settings.APISettings.ServerID != "1" && Settings.APISettings.ServerID != "UNDEFINED" ? $"&server={Settings.APISettings.ServerID}" : "")}";
        private string BaseRequestParams => $"?shop_id={Settings.APISettings.ShopID}&secret={Settings.APISettings.SecretKey}{(!Settings.APISettings.ServerID.IsNullOrEmpty() && Settings.APISettings.ServerID != "0" && Settings.APISettings.ServerID != "1" && Settings.APISettings.ServerID != "UNDEFINED" ? $"&server={Settings.APISettings.ServerID}" : "")}";
        private string BaseRequest = "";
        #endregion

        #region Language
        private void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>() 
            {
                // Global
                { "days", "дн." },
                { "hour", "ч." },
                { "minutes", "мин." },
                { "seconds", "сек." },
                
                
                // Chat messages
                { "PluginNotInitialized", "Плагин магазина запущен некорректно" },
                { "PlayerFloodBlock", "Вы сделали слишком много запросов. Отдохните немного, скоро возможность выполнять действие к вам вернется." },
                { "ItemNotFound", "Предмет не найден, попробуйте перезапустить корзину" },
                { "UnexpectedError", "Непредвиденная ошибка со стороны сервера, просим прощения!" },
                { "WaitPreviousAction", "Пожалуйста, дождитесь <<окончания>> предыдущего действия!"},

                // UI
                { "BASKET", "КОРЗИНА СЕРВЕРА" },
                { "EXIT", "ВЫХОД" },
                { "BASKET.DESCRIPTION", "Это ваша корзина с покупками, вы можете забрать их в любой момент" },
                { "BASKET.EMPTY", "Ваша корзина пуста" },
                { "HELP", "ПОМОЩЬ" },
                { "REQUEST.PROCESSING", "Подождите, мы обрабатываем ваш запрос..." },
                { "BASKET.UNAVAILABLE", "Корзина временно недоступна, попробуйте позже" },
                { "BASKET.NO.AUTH", "Вы не авторизованы в магазине!\n" +
                                    "Ссылку на авторизацию вы можете найти в разделе 'ПОМОЩЬ'" },


                { "USER.MANUAL", "ИНСТРУКЦИЯ ПОЛЬЗОВАТЕЛЯ" },
                { "USER.MANUAL.DESCRIPTION", "Здесь вы можете забрать товары приобретенные у нас в магазине!\n" +
                                             "Пополнить счёт можно различными способами: электронные кошельки, карты и т.д.\n" +
                                             "Авторизация в магазине происходит при помощи вашего аккаунта STEAM" },

                { "USER.MANUAL.BALANCE", "\n<size=18>При первой авторизации вы получите в подарок <b>{0} рублей</b>!</size>" },
                { "TAKE.ITEM.BLOCKED", "Вы не можете забрать этот предмет из корзины!\n" +
                                       "До его разблокировки осталось: {0}" },
                { "TAKE.REQUEST.PROCESSING", "Подождите, ваш запрос обрабатывается!" },
                { "TAKE.LAST.REQUEST.PROCESSING", "Подождите, ваш предыдущий запрос ещё обрабатывается!" },
                { "TAKE.WAIT", "ПОДОЖДИТЕ" },
                { "TAKE.GIVE.ERROR", "ОШИБКА\nПОЛУЧЕНИЯ" },
                { "TAKE.GIVE.ERROR.NOTIFY", "Произошла непредвиденная ошибка, попробуйте позже!\n" +
                                            "Ваш предмет в безопасности, не переживайте!" },
                { "TAKE.GIVE.SUCCESS", "УСПЕШНО\nПОЛУЧЕНО" },
                { "TAKE.GIVE.FEET", "Вы успешно получили предмет  › <size=20>{0}</size> ‹\n" +
                                    "У вас недостаточно места в инвентаре, <b>предмет брошен</b> под ноги!" },
                { "TAKE.GIVE.INVENTORY", "Вы успешно получили предмет  › <size=20>{0}</size> ‹" },
                { "TAKE.GIVE.COMMAND", "Вы успешно получили предмет  › <size=20>{0}</size> ‹\n" +
                                       "Теперь вам доступны новые привилегии!" },
                { "TAKE.GIVE.BLUEPRINT.FEET", "Вы успешно получили рецепт предмета  › <size=20>{0}</size> ‹\n" +
                                              "У вас недостаточно места в инвентаре, <b>предмет брошен</b> под ноги!" },
                { "TAKE.GIVE.BLUEPRINT.INVENTORY", "Вы успешно получили рецепт предмета  › <size=20>{0}</size> ‹" },
                { "MANY.REQUESTS", "Вы делаете слишком много запросов к серверу!\n" +
                                   "Подождите <b>одну секунду</b>!" }
            }, this, "ru");

            lang.RegisterMessages(new Dictionary<string, string>() 
            {
                // Global
                { "days", "d." },
                { "hour", "h." },
                { "minutes", "m." },
                { "seconds", "s." },
                
                
                // Chat messages
                { "PluginNotInitialized", "The store plugin is not launched correctly" },
                { "PlayerFloodBlock", "You have made too many requests. Relax a little, soon the ability to perform the action will return to you." },
                { "ItemNotFound", "Item not found, try restarting your cart" },
                { "UnexpectedError", "Unexpected error from server side, sorry!" },
                { "WaitPreviousAction", "Please wait for the <<end>> of the previous step!"},

                // UI
                { "BASKET", "SERVER BASKET" },
                { "EXIT", "EXIT" },
                { "BASKET.DESCRIPTION", "This is your shopping cart, you can pick them up at any time" },
                { "BASKET.EMPTY", "Basket empty" },
                { "HELP", "HELP" },
                { "REQUEST.PROCESSING", "Please wait, we are processing your request ..." },
                { "BASKET.UNAVAILABLE", "Cart is temporarily unavailable, please try again later" },
                { "BASKET.NO.AUTH", "You are not authorized in the store!\n" +
                                    "You can find a link to authorization in the 'HELP' section" },


                { "USER.MANUAL", "USER'S MANUAL" },
                { "USER.MANUAL.DESCRIPTION", "Here you can pick up the products purchased from our store!\n" +
                                             "You can replenish your account in various ways: e-wallets, cards, etc.\n" +
                                             "Authorization in the store takes place using your STEAM account" },

                { "USER.MANUAL.BALANCE", "\n<size=18>At the first authorization, you will receive a gift of <b>{0} rubles</b>!</size>" },
                { "TAKE.ITEM.BLOCKED", "You cannot pick up this item from your cart!\n" +
                                       "Before its unlocking, there are: {0}" },
                { "TAKE.REQUEST.PROCESSING", "Please wait, your request is being processed!" },
                { "TAKE.LAST.REQUEST.PROCESSING", "Please wait, your previous request is still being processed!" },
                { "TAKE.WAIT", "WAIT" },
                { "TAKE.GIVE.ERROR", "ERROR\nRECEIVING" },
                { "TAKE.GIVE.ERROR.NOTIFY", "An unexpected error occured, please try again later!\n" +
                                            "Your item is safe, don't worry!" },
                { "TAKE.GIVE.SUCCESS", "SUCCESSFULLY\nRECEIVED" },
                { "TAKE.GIVE.FEET", "You have successfully obtained an item  › <size=20>{0}</size> ‹\n" +
                                    "You don't have enough space in your inventory, <b>the item was thrown</b> at your feet!" },
                { "TAKE.GIVE.INVENTORY", "You have successfully obtained an item  › <size=20>{0}</size> ‹" },
                { "TAKE.GIVE.COMMAND", "You have successfully obtained an item  › <size=20>{0}</size> ‹\n" +
                                       "New privileges are now available to you!" },
                { "TAKE.GIVE.BLUEPRINT.FEET", "You have successfully obtained the item blueprint  › <size=20>{0}</size> ‹\n" +
                                              "You don't have enough space in your inventory, <b>the item was thrown</b> at your feet!" },
                { "TAKE.GIVE.BLUEPRINT.INVENTORY", "You have successfully obtained the item blueprint  › <size=20>{0}</size> ‹" },
                { "MANY.REQUESTS", "You are making too many server requests!\n" +
                                   "Wait <b>one second</b>!" }
            }, this, "en");
        }

        private string _(BasePlayer player, string key, params object[] args)
        {
            return string.Format(lang.GetMessage(key, this, player?.UserIDString), args);
        }
        #endregion

        #region Interface

        private int TryImageCounter = 0;
        private void OnServerInitialized()
        {
            BaseRequest = MainApiLink + BaseRequestParams;
            if (Settings.APISettings.ServerID != "0" && Settings.APISettings.ServerID != "UNDEFINED")
            {
                TimerCheckInstant = timer.Repeat(60, 0, CheckInstant);
            } else
            {
                LogAction(null, $"Некорректный ServerID, автоматическая выдача команд невозможна");
                PrintError($"Incorrect ServerID, reciving auto commands (Products) disabled");
            }
            
            if (!ImageLibrary)
            {
                if (TryImageCounter < 3)
                {
                    LogAction(null, $"ImageLibrary is not initialized, try again in 1 sec.", true);
                    TryImageCounter++;

                    timer.Once(1, OnServerInitialized);
                    return;
                }
                else LogAction(null, $"Starting without ImageLibrary", true);
            }

            if (ImageLibrary)
            {
                NoImageID = (string)ImageLibrary.Call("GetImage", "NONE");
                LoadingImageID = (string)ImageLibrary.Call("GetImage", "LOADING");
            }

            if (Settings.InterfaceSettings.BucketURL.Contains("http") && plugins.Find("ImageLibrary") != null)
            {
                ImageLibrary.Call("AddImage", Settings.InterfaceSettings.BucketURL, "GameStoresRUSTBucket");
                LoadingCoroutine = ServerMgr.Instance.StartCoroutine(WaitForLoad());
            }
            else
            {
                //BasePlayer.activePlayerList.ForEach(OnPlayerInit);
                for (var i = 0; i < BasePlayer.activePlayerList.Count; i++)
                {
                    OnPlayerConnected(BasePlayer.activePlayerList[i]);
                }
            }

			if (plugins.Find("ImageLibrary") != null && ImageLibrary != null && !(bool)ImageLibrary.Call("HasImage", $"blueprintbase"))
				ImageLibrary.Call("AddImage", "http://gamestores.ru/img/games/rust/blueprintbase.png", "blueprintbase");
				
            instance = this;
            Settings.TOPSettings.UseTop = false; //Принудительное отключение топа игроков
            if (!Settings.TOPSettings.UseTop) Unsubscribe(nameof(OnEntityDeath));
            if (!Settings.TOPSettings.UseTop) Unsubscribe(nameof(OnPlayerDisconnected));

            if (Settings.APISettings.ShopID == "UNDEFINED" || Settings.APISettings.SecretKey == "UNDEFINED")
            {
                LogAction(null, $"Verify that plugin is installed correct! Some of API settings are 'UNDEFINED'", true, true);
                return;
            }

            timer.Once(2, FetchShopUrl);

            timer.Every(1, () => Delays.RequestPerSecond = 0);

            ListTimeOutCommand[0] = new Dictionary<ulong, int>();
            ListTimeOutCommand[1] = new Dictionary<ulong, int>();
            ListTimeOutCommand[2] = new Dictionary<ulong, int>();

            int totalTick = 0;
            int tick = 0;
            timer.Repeat(2, 0, () =>
            {
                if (totalTick == 30)
                {
                    totalTick = 0;
                    ListBannedCommandUserID.Clear();
                }
                ListTimeOutCommand[0].Clear();
                if (tick == 3 || tick == 6)
                {
                    ListTimeOutCommand[1].Clear();
                }

                if (tick == 6)
                {
                    tick = 0;
                    ListTimeOutCommand[2].Clear();
                }
                tick++;
                totalTick++;
            });
        }

        private IEnumerator WaitForLoad()
        {
            while (!(bool)ImageLibrary.Call("HasImage", "GameStoresRUSTBucket"))
            {
                PrintError($"Image of bucket is loading!");
                yield return new WaitForSeconds(1);
            }

            PrintWarning("Image of bucket loaded correct!");
            //BasePlayer.activePlayerList.ForEach(OnPlayerInit);
            for (var i = 0; i < BasePlayer.activePlayerList.Count; i++)
            {
                OnPlayerConnected(BasePlayer.activePlayerList[i]);
            }
            yield return 0;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                Settings = Config.ReadObject<Configuration>();
                if (Settings?.APISettings == null) LoadDefaultConfig();
            }
            catch
            {
                LogAction(null, $"Error reading config, creating one new config!", true, true);
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig()
        {
            Settings = new Configuration();
        }

        protected override void SaveConfig() => Config.WriteObject(Settings);

        private void Unload()
        {
            //if (Initialized) StatHandler.SendStats();

            if (LoadingCoroutine != null) ServerMgr.Instance.StopCoroutine(LoadingCoroutine);
            //BasePlayer.activePlayerList.ForEach(p => CuiHelper.DestroyUi(p, IconLayer));
            //BasePlayer.activePlayerList.ForEach(p => CuiHelper.DestroyUi(p, StoreLayer));
            foreach (var pl in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(pl, IconLayer);
                CuiHelper.DestroyUi(pl, StoreLayer);
                OnPlayerConnected(pl);
            }
        }

        #endregion

        #region Hooks

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            StatHandler.AddStat(new StatHandler.TimeStat(player));
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player.IsReceivingSnapshot)
            {
                NextTick(() => OnPlayerConnected(player));
                return;
            }

            if (Settings.InterfaceSettings.BucketEnable)
                InitializeIcon(player);
        }

        #endregion

        #region Stats

        private static class StatHandler
        {
            internal class Stat
            {
                [JsonProperty("dataType")]
                public string DataType;
            }
            internal class KillStat : Stat
            {
                [JsonProperty("player_id")]
                public string PlayerUserId;
                [JsonProperty("victim_id")]
                public string VictimUserID;
                [JsonProperty("type")]
                public string Type;
                [JsonProperty("time")]
                public string Time;
            }
            internal class TimeStat : Stat
            {
                [JsonProperty("player_id")]
                public string PlayerID;
                [JsonProperty("username")]
                public string PlayerName;
                [JsonProperty("played")]
                public string Played;
                [JsonProperty("time")]
                public string Time;

                public TimeStat(BasePlayer player)
                {
                    PlayerID = player.UserIDString;
                    PlayerName = player.displayName;
                    DataType = "leave";
                    Played = player.secondsConnected.ToString();
                    Time = CurrentTime().ToString();
                }
            }

            private static List<Stat> Stats = new List<Stat>();
            public static void AddStat(Stat stat)
            {
                Stats.Add(stat);
                if (Stats.Count > 10)
                {
                    SendStats();
                    Stats.Clear();
                }
            }

            public static void SendStats()
            {
                try
                {


                    if (!Initialized)
                    {
                        instance.LogAction(null, $"Sending stats error! Plugin not initialized", true, true);
                        return;
                    }
                    if (Stats.Count == 0)
                    {
                        instance.LogAction(null, $"Nothing to send", true);
                        return;
                    }

                    var obj = JsonConvert.SerializeObject(Stats);
                    RequestPost($"&method=topData&data={obj}", (i, s) => {
                        if (i != 200)
                            return;

                        Dictionary<string, object> response = JsonConvert.DeserializeObject<Dictionary<string, object>>(s, new KeyValuesConverter());
                        if (response.ContainsKey("result") && response["result"].ToString() == "success")
                        {
                            instance.LogAction(null, $"GameStores sent stats successful!", true);
                            Stats.Clear();
                        }
                        else
                        {
                            instance.LogAction(null, $"Sending stats error!", true, true);
                        }
                    });


                }
                catch
                {
                    // ignored 
                }
            }
        }

        [ConsoleCommand("sendtop")]
        private void CmdSendTop(ConsoleSystem.Arg args)
        {
            if (args.Player() != null && !args.Player().IsAdmin) return;

            StatHandler.SendStats();
        }

        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (entity == null || info == null || info.Initiator == null)
                return;
            if (Settings.TOPSettings.UseTop)
            {
                BaseEntity initiator = info.Initiator;

                if (entity as BasePlayer == null && initiator as BasePlayer == null)
                    return;
                StatHandler.KillStat stat = new StatHandler.KillStat();

                if (initiator as BasePlayer != null) stat.PlayerUserId = initiator.ToPlayer().UserIDString;
                else if (initiator.PrefabName.Contains("agents")) stat.PlayerUserId = "1";
                else return;

                if (entity as BasePlayer != null)
                {
                    stat.VictimUserID = entity.ToPlayer().UserIDString;
                    stat.Type = entity.ToPlayer().IsSleeping() ? "sleeper" : "kill";
                }
                else if (entity.PrefabName.Contains("agents"))
                {
                    stat.VictimUserID = "1";
                    stat.Type = "kill";
                }
                else
                {
                    return;
                }

                stat.DataType = "death";

                stat.Time = CurrentTime().ToString();
                StatHandler.AddStat(stat);
            }
        }

        #endregion

        #region Commands

        [ChatCommand("store")]
        private void CmdChatStore(BasePlayer player, string command, string[] args)
        {
            if (player == null || player.Connection == null || player.IsSleeping())
            {
                return;
            }                                                                                  
            if (!Initialized)
            {
                errorsReq++;
                player.ChatMessage(_(player, "PluginNotInitialized"));
                return;

            }

            if (args.Length == 1 && args[0].ToLower() == "hide")
            {
                CuiHelper.DestroyUi(player, IconLayer);
            }
            else
            {
                if (!Delays.CanRequest(player)) return;
                InitializeStore(player, 0, true);
            }
        }

        [ConsoleCommand("UI_GameStoresRUST")]
        private void CmdConsoleCommand(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Player();
            if (player == null) return;

            if (ListBannedCommandUserID.Contains(player.userID))
            {
                player.ChatMessage(_(player, "PlayerFloodBlock"));
                return;
            }

            if (ListTimeOutCommand[0].ContainsKey(player.userID) == false)
                ListTimeOutCommand[0][player.userID] = 1;
            else
                ListTimeOutCommand[0][player.userID] = ListTimeOutCommand[0][player.userID] + 1;

            if (ListTimeOutCommand[1].ContainsKey(player.userID) == false)
                ListTimeOutCommand[1][player.userID] = 1;
            else
                ListTimeOutCommand[1][player.userID] = ListTimeOutCommand[1][player.userID] + 1;

            if (ListTimeOutCommand[2].ContainsKey(player.userID) == false)
                ListTimeOutCommand[2][player.userID] = 1;
            else
                ListTimeOutCommand[2][player.userID] = ListTimeOutCommand[2][player.userID] + 1;

            if (ListTimeOutCommand[0][player.userID] >= 10 || ListTimeOutCommand[1][player.userID] >= 20 || ListTimeOutCommand[2][player.userID] >= 30)
            {
                this.ListBannedCommandUserID.Add(player.userID);
            }

            if (!args.HasArgs(1))
            {
                player.SendConsoleCommand("chat.say /store");
                return;
            }

            switch (args.Args[0].ToLower())
            {
                case "page":
                    {
                        int page = 0;
                        if (!args.HasArgs(2) || !int.TryParse(args.Args[1], out page)) return;
                        InitializeStore(player, page, false);
                        break;
                    }
                case "help":
                    {
                        string helpLayer = StoreLayer + ".Help";
                        CuiHelper.DestroyUi(player, helpLayer);
                        CuiHelper.DestroyUi(player, StoreLayer);

                        CuiElementContainer container = new CuiElementContainer();
                        container.Add(new CuiPanel
                        {
                            CursorEnabled = true,
                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                            Image = { Color = "0 0 0 0.9", Material = "assets/content/ui/uibackgroundblur.mat" },
                        }, "Overlay", helpLayer);

                        container.Add(new CuiLabel
                        {
                            RectTransform = { AnchorMin = "0 0.6", AnchorMax = "1 0.78", OffsetMax = "0 0" },
                            Text = { Text = _(player, "USER.MANUAL"), Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 34 }
                        }, helpLayer);

                        container.Add(new CuiLabel
                        {
                            RectTransform = { AnchorMin = "0 0.3", AnchorMax = "1 0.72", OffsetMax = "0 0" },
                            Text = { Text = _(player, "USER.MANUAL.DESCRIPTION"), 
                            Font = "robotocondensed-regular.ttf", FontSize = 22, Align = TextAnchor.MiddleCenter
                        }
                        }, helpLayer);

                        string addText = StartBalance > 0 ? _(player, "USER.MANUAL.BALANCE", StartBalance) : "";
                        container.Add(new CuiLabel
                        {
                            RectTransform = { AnchorMin = "0 0.1", AnchorMax = "1 0.48", OffsetMax = "0 0" },
                            Text = { Text = $"{addText}\n{ShopURL.ToUpper()}", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 32}
                        }, helpLayer);
                        container.Add(new CuiButton
                        {
                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                            Button = { Color = "0 0 0 0", Close = helpLayer, Command = "chat.say /store" },
                            Text = { Text = "" }
                        }, helpLayer);

                        CuiHelper.AddUi(player, container);
                        break;
                    }
                case "take":
                    {
                        if (!args.HasArgs(3)) return;

                        int index = 0, id = 0;
                        if (!int.TryParse(args.Args[1], out index) || !int.TryParse(args.Args[2], out id)) return;

                        if (!playersBasketCache.ContainsKey(player.userID))
                        {
                            player.ChatMessage(_(player, "ItemNotFound"));
                            return;
                        } 
                        else if (!playersBasketCache[player.userID].Contains(id))
                        {
                            player.ChatMessage(_(player, "ItemNotFound"));
                            return;
                        }

                        if (args.HasArgs(5) && args.Args[3].ToLower() == "blocked")
                        {
                            double left = 0;
                            if (!double.TryParse(args.Args[4], out left)) return;

                            TimeSpan span = TimeSpan.FromSeconds(left);

                            string text = "";
                            if (span.Days >= 1)
                                text += $"{span.Days} " + _(player, "days") + " ";
                            if (span.Hours >= 1)
                                text += $"{span.Hours} " + _(player, "hours") + " ";
                            if (span.Minutes >= 1)
                                text += $"{span.Minutes} " + _(player, "minutes") + " ";
                            if (span.Seconds >= 1)
                                text += $"{span.Seconds} " + _(player, "seconds");

                            ShowNotify(player, _(player, "TAKE.ITEM.BLOCKED", text));
                            return;
                        }

                        ShowNotify(player, _(player, "TAKE.REQUEST.PROCESSING"));
                        CuiElementContainer container = new CuiElementContainer();

                        if (!Delays.CanRequest(player))
                        {
                            ShowNotify(player, _(player, "TAKE.LAST.REQUEST.PROCESSING"));
                            container.Add(new CuiButton
                            {
                                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                                Button = { Color = "1 1 1 0.2", Close = StoreLayer + ".BlockPanel." + index + ".Open", Command = $"UI_GameStoresRUST take {index} {id}" },
                                Text = { Text = _(player, "TAKE.WAIT"), Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", Color = "1 1 1 0.4", FontSize = 24 }
                            }, StoreLayer + ".BlockPanel." + index, StoreLayer + ".BlockPanel." + index + ".Open");

                            CuiHelper.AddUi(player, container);
                            return;
                        }

                        container.Add(new CuiButton
                        {
                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                            Button = { FadeIn = 1f, Color = "1 1 1 0.2", Close = StoreLayer + ".BlockPanel." + index + ".Open", Command = $"UI_GameStoresRUST take {index} {id}" },
                            Text = { Text = _(player, "TAKE.WAIT"), Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", Color = "1 1 1 0.4", FontSize = 24 }
                        }, StoreLayer + ".BlockPanel." + index, StoreLayer + ".BlockPanel." + index + ".Open");
                        CuiHelper.AddUi(player, container);

                        LogAction(null, $"---------------------------------");
                        LogAction(player, $"Запрос на получение предмета: {id}");
                        Request($"&item=true&steam_id={player.UserIDString}&id={id}", (i, s) =>
                        {
                            switch (i)
                            {
                                case 0:
                                    LogAction(player, $"API не ответило на запрос: {id}");
                                    PrintError("Api does not responded to a request");
                                    if (player != null)
                                    {
                                        player.ChatMessage(_(player, "UnexpectedError"));
                                        CuiHelper.DestroyUi(player, StoreLayer);
                                    }
                                    break;
                                case 200:
                                    Dictionary<string, object> response = JsonConvert.DeserializeObject<Dictionary<string, object>>(s, new KeyValuesConverter());
                                    if (!response.ContainsKey("data"))
                                    {
                                        LogAction(player, $"Ошибка получения товара, отсутствует Data [{id}]");

                                        container.Clear();
                                        CuiHelper.DestroyUi(player, StoreLayer + ".BlockPanel." + index + ".Open");
                                        container.Add(new CuiButton
                                        {
                                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                                            Button = { FadeIn = 1f, Color = "1 0.5 0.5 0.2", Close = StoreLayer + ".BlockPanel." + index + ".Open", Command = $"UI_GameStoresRUST take {index} {id}" },
                                            Text = { Text = _(player, "TAKE.GIVE.ERROR"), Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", Color = "1 0.7 0.7 1", FontSize = 22 }
                                        }, StoreLayer + ".BlockPanel." + index, StoreLayer + ".BlockPanel." + index + ".Open");
                                        ShowNotify(player, _(player, "TAKE.GIVE.ERROR.NOTIFY"));
                                        CuiHelper.AddUi(player, container);
                                        return;
                                    }

                                    LogAction(player, $"Товар отмечен полученным [{id}]");
                                    Request($"&gived=true&id={id}", (code, newResponse) =>
                                    {
                                        if (code != 200 || JsonConvert.DeserializeObject<JObject>(newResponse)["result"].ToString() != "success")
                                        {
                                            container.Clear();
                                            CuiHelper.DestroyUi(player, StoreLayer + ".BlockPanel." + index + ".Open");
                                            container.Add(new CuiButton
                                            {
                                                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                                                Button = { FadeIn = 1f, Color = "1 0.5 0.5 0.2", Close = StoreLayer + ".BlockPanel." + index + ".Open", Command = $"UI_GameStoresRUST take {index} {id}" },
                                                Text = { Text = _(player, "TAKE.GIVE.ERROR"), Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", Color = "1 0.7 0.7 1", FontSize = 22 }
                                            }, StoreLayer + ".BlockPanel." + index, StoreLayer + ".BlockPanel." + index + ".Open");
                                            ShowNotify(player, _(player, "TAKE.GIVE.ERROR.NOTIFY"));
                                            CuiHelper.AddUi(player, container);
                                            return;
                                        }
                                        ProcessTake(player, response["data"] as Dictionary<string, object>);
                                    }, player);

                                    container.Clear();
                                    CuiHelper.DestroyUi(player, StoreLayer + ".BlockPanel." + index + ".Open");
                                    container.Add(new CuiButton
                                    {
                                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                                        Button = { FadeIn = 1f, Color = "0.5 1 0.5 0.2" },
                                        Text = { Text = _(player, "TAKE.GIVE.SUCCESS"), Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", Color = "0.7 1 0.7 1", FontSize = 22 }
                                    }, StoreLayer + ".BlockPanel." + index, StoreLayer + ".BlockPanel." + index + ".Open");

                                    if (playersBasketCache.ContainsKey(player.userID) && playersBasketCache[player.userID].Contains(id))
                                        playersBasketCache[player.userID].RemoveAt(playersBasketCache[player.userID].IndexOf(id));

                                    CuiHelper.AddUi(player, container);
                                    break;
                                case 404:
                                    LogAction(player, $"Сайт не ответил на запрос: {id}");
                                    player.ChatMessage(_(player, "UnexpectedError"));
                                    CuiHelper.DestroyUi(player, StoreLayer);
                                    LogAction(null, "Response code: 404, please check your configurations", true);
                                    break;
                            }
                        }, player);
                        break;
                    }
            }
        }

        #endregion

        #region Interface

        private static string StoreLayer = "UI_GameStoresRUST_Store";
        private void InitializeStore(BasePlayer player, int page, bool first = true)
        {
            CuiElementContainer container = new CuiElementContainer();

            if (first)
            {
                CuiHelper.DestroyUi(player, StoreLayer);
                container.Add(new CuiPanel
                {
                    CursorEnabled = true,
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                    Image = { Color = "0 0 0 0.8", Material = "assets/content/ui/uibackgroundblur.mat" },
                }, "Overlay", StoreLayer);

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.3 0.9", AnchorMax = "0.7 1", OffsetMax = "0 0" },
                    Button = { Color = "0 0 0 0" },
                    Text = { Text = _(player, "BASKET"), Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 32, Color = "1 1 1 0.6" }
                }, StoreLayer, StoreLayer + ".ITT");

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.8 0.9", AnchorMax = "0.935 1", OffsetMax = "0 0" },
                    Button = { Color = "0 0 0 0", Close = StoreLayer, Command = "closemenu" },
                    Text = { Text = _(player, "EXIT"), Align = TextAnchor.MiddleRight, Font = "robotocondensed-regular.ttf", FontSize = 28 }
                }, StoreLayer);
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0", OffsetMin = "0 -0", OffsetMax = "0 20" },
                    Text = { Text = _(player, "BASKET.DESCRIPTION"), Align = TextAnchor.UpperCenter, Font = "robotocondensed-regular.ttf", Color = "1 1 1 0.4" }
                }, StoreLayer + ".ITT");

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.065 0.9", AnchorMax = "0.2 1", OffsetMax = "0 0" },
                    Button = { Color = "0 0 0 0", Command = "UI_GameStoresRUST help" },
                    Text = { Text = _(player, "HELP"), Align = TextAnchor.MiddleLeft, Font = "robotocondensed-regular.ttf", FontSize = 28 }
                }, StoreLayer);
            }

            CuiHelper.DestroyUi(player, StoreLayer + ".BlockPanel");
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.9", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0" }
            }, StoreLayer, StoreLayer + ".BlockPanel");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1.1", OffsetMax = "0 0" },
                Text = { Text = _(player, "REQUEST.PROCESSING"), Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 34 }
            }, StoreLayer + ".BlockPanel", StoreLayer + ".BlockPanel.Text");

            CuiHelper.AddUi(player, container);

            Request($"&method=basket&steam_id={player.UserIDString}", (code, response) =>
            {
               
                switch (code)
                {
                    default:
                        {
                            CuiHelper.DestroyUi(player, StoreLayer + ".BlockPanel.Text");
                            CuiElementContainer secondContainer = new CuiElementContainer();
                            secondContainer.Add(new CuiLabel
                            {
                                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                                Text = { Text = _(player, "BASKET.UNAVAILABLE"), Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 38 }
                            }, StoreLayer + ".BlockPanel", StoreLayer + ".BlockPanel.Text");
                            CuiHelper.AddUi(player, secondContainer);
                            break;
                        }
                    case 200:
                        {
                            var firstInfo = JsonConvert.DeserializeObject<Dictionary<string, object>>(response, new KeyValuesConverter());
                            if (firstInfo.ContainsKey("result"))
                            {
                                if (firstInfo["result"].ToString() == "fail")
                                {
                                    if (firstInfo["code"].ToString() == "104")
                                    {
                                        CuiHelper.DestroyUi(player, StoreLayer + ".BlockPanel.Text");
                                        CuiElementContainer secondContainer = new CuiElementContainer();
                                        secondContainer.Add(new CuiLabel
                                        {
                                            RectTransform = { AnchorMin = "0 0.1", AnchorMax = "1 1", OffsetMax = "0 0" },
                                            Text = { Text = _(player, "BASKET.EMPTY"), Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 34 }
                                        }, StoreLayer + ".BlockPanel", StoreLayer + ".BlockPanel.Text");
                                        CuiHelper.AddUi(player, secondContainer);
                                    }
                                    if (firstInfo["code"].ToString() == "105")
                                    {
                                        CuiHelper.DestroyUi(player, StoreLayer + ".BlockPanel.Text");
                                        CuiElementContainer secondContainer = new CuiElementContainer();
                                        secondContainer.Add(new CuiLabel
                                        {
                                            RectTransform = { AnchorMin = "0 0.1", AnchorMax = "1 1", OffsetMax = "0 0" },
                                            Text = { Text = _(player, "BASKET.NO.AUTH"), Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 34 }
                                        }, StoreLayer + ".BlockPanel", StoreLayer + ".BlockPanel.Text");
                                        CuiHelper.AddUi(player, secondContainer);
                                    }
                                }
                                else
                                {
                                    CuiElementContainer secondContainer = new CuiElementContainer();

                                    if (!(firstInfo["data"] is List<object>))
                                    {
                                        PrintError("Unkown error #1");
                                        CuiHelper.DestroyUi(player, StoreLayer);
                                        return;
                                    }
                                    List<object> data = firstInfo["data"] as List<object>;
                                    List<WItem> wItems = new List<WItem>();

                                    foreach (var check in data.Skip(page * 21).Take(21))
                                    {
                                        wItems.Add(new WItem(check as Dictionary<string, object>));

                                    }
                                    if (playersBasketCache.ContainsKey(player.userID))
                                        playersBasketCache[player.userID].Clear();

                                    foreach (Dictionary<string, object> product in data)
                                    {
                                        if (product.ContainsKey("id"))
                                        {
                                            if (!playersBasketCache.ContainsKey(player.userID))
                                                playersBasketCache.Add(player.userID, new List<int>());

                                            playersBasketCache[player.userID].Add(Convert.ToInt32(product["id"]));
                                        }
                                    }
                                    secondContainer.Add(new CuiLabel
                                    {
                                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.14", OffsetMax = "0 0" },
                                        Text = { Text = (page + 1).ToString(), Align = TextAnchor.MiddleCenter, FontSize = 34 }
                                    }, StoreLayer + ".BlockPanel");

                                    secondContainer.Add(new CuiButton
                                    {
                                        RectTransform = { AnchorMin = "0.4 0.14", AnchorMax = "0.4 0.14", OffsetMin = "-40 -125", OffsetMax = "125 40" },
                                        Button = { Color = "0 0 0 0", Command = page > 0 ? $"UI_GameStoresRUST page {page - 1}" : "" },
                                        Text = { Text = "<", Color = page > 0 ? "1 1 1 1" : "1 1 1 0.2", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 80 }
                                    }, StoreLayer + ".BlockPanel");

                                    secondContainer.Add(new CuiButton
                                    {
                                        RectTransform = { AnchorMin = "0.6 0.14", AnchorMax = "0.6 0.14", OffsetMin = "-125 -125", OffsetMax = "40 40" },
                                        Button = { Color = "0 0 0 0", Command = (page + 1) * 21 < data.Count ? $"UI_GameStoresRUST page {page + 1}" : "" },
                                        Text = { Text = ">", Color = (page + 1) * 21 < data.Count ? "1 1 1 1" : "1 1 1 0.2", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 80 }
                                    }, StoreLayer + ".BlockPanel");


                                    double xSwitch = 0;
                                    double ySwitch = 0;
                                    for (int i = 0; i < Settings.InterfaceSettings.ItemOnString * Settings.InterfaceSettings.StringAmount; i++)
                                    {
                                        UI_RecountPosition(ref xSwitch, ref ySwitch, i, Settings.InterfaceSettings.ItemOnString * Settings.InterfaceSettings.StringAmount);

                                        secondContainer.Add(new CuiButton
                                        {
                                            RectTransform = { AnchorMin = "0.495 0.55", AnchorMax = "0.495 0.55", OffsetMin = $"{xSwitch} {ySwitch - Settings.InterfaceSettings.ItemSide}", OffsetMax = $"{xSwitch + Settings.InterfaceSettings.ItemSide} {ySwitch}" },
                                            Button = { Color = "1 1 1 0.2", Command = $"" },
                                            Text = { Text = "" }
                                        }, StoreLayer + ".BlockPanel", StoreLayer + $".BlockPanel.{i}");
                                    }

                                    /*if (player.IsAdmin) 
                                    {
                                        LogToFile("Test", "123 - " + JsonConvert.SerializeObject(wItems), this);  
                                    } */
                                    foreach (var check in wItems.Select((i, t) => new { A = i, B = t }))
                                    {
                                        if (check.A.IsBlueprint)
                                        {
                                            if (plugins.Find("ImageLibrary") != null)
                                            {
                                                secondContainer.Add(new CuiElement
                                                {
                                                    Parent = StoreLayer + ".BlockPanel." + check.B,
                                                    Components =
                                                {
                                                    new CuiRawImageComponent { Png = (string) plugins.Find("ImageLibrary").Call("GetImage", "blueprintbase") },
                                                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 5", OffsetMax = "-5 -5" },
                                                }
                                                });
                                            }
                                            else
                                            {
                                                secondContainer.Add(new CuiElement
                                                {
                                                    Parent = StoreLayer + ".BlockPanel." + check.B,
                                                    Components =
                                                {
                                                    new CuiRawImageComponent { Url = "https://gamestores.app/img/games/rust/blueprintbase.png" },
                                                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 5", OffsetMax = "-5 -5" },
                                                }
                                                });
                                            }
                                        }
                                        if (!check.A.ImageUrl.Contains("http"))
                                        {
                                            secondContainer.Add(new CuiElement
                                            {
                                                Parent = StoreLayer + ".BlockPanel." + check.B,
                                                Components =
                                            {
                                                new CuiRawImageComponent { Png = check.A.ImageUrl },
                                                new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 5", OffsetMax = "-5 -5" },
                                            }
                                            });
                                        }
                                        else
                                        {
                                            secondContainer.Add(new CuiElement
                                            {
                                                Parent = StoreLayer + ".BlockPanel." + check.B,
                                                Components =
                                            {
                                                new CuiRawImageComponent { Url = check.A.ImageUrl },
                                                new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 5", OffsetMax = "-5 -5" },
                                            }
                                            });
                                        }

                                        if (check.A.Amount > 1)
                                        {
                                            secondContainer.Add(new CuiLabel
                                            {
                                                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 5", OffsetMax = "-5 0" },
                                                Text = { Text = "x" + check.A.Amount, Align = TextAnchor.LowerRight, Font = "robotocondensed-regular.ttf", FontSize = 24 }
                                            }, StoreLayer + ".BlockPanel." + check.B);
                                        }

                                        if (check.A.Blocked)
                                        {
                                            double left = check.A.Block_Date - CurrentTime();

                                            secondContainer.Add(new CuiButton
                                            {
                                                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                                                Button = { Color = "1 0.5 0.5 0.2", Command = $"UI_GameStoresRUST take {check.B} {check.A.ID} blocked {left}" },
                                                Text = { Text = "", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 38 }
                                            }, StoreLayer + ".BlockPanel." + check.B, StoreLayer + ".BlockPanel." + check.B + ".Open");
                                        }
                                        else
                                        {
                                            secondContainer.Add(new CuiButton
                                            {
                                                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                                                Button = { Color = "0 0 0 0", Close = StoreLayer + ".BlockPanel." + check.B + ".Open", Command = $"UI_GameStoresRUST take {check.B} {check.A.ID}" },
                                                Text = { Text = "" }
                                            }, StoreLayer + ".BlockPanel." + check.B, StoreLayer + ".BlockPanel." + check.B + ".Open");
                                        }

                                        /*secondContainer.Add(new CuiLabel
                                        {
                                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0", OffsetMin = "0 -22.5", OffsetMax = "0 0" },
                                            Text = { Text = ((check.A.Name.IndexOf("lang:") == 0) ? _(player, check.A.Name.Substring(5)) : check.A.Name) , Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 16, Color = "1 1 1 0.8" }
                                        }, StoreLayer + ".BlockPanel." + check.B);*/

                                        secondContainer.Add(new CuiLabel
                                        {
                                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0", OffsetMin = "0 -22.5", OffsetMax = "0 0" },
                                            Text = { Text = check.A.Name, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 16, Color = "1 1 1 0.8" }
                                        }, StoreLayer + ".BlockPanel." + check.B);
                                    }

                                    CuiHelper.AddUi(player, secondContainer);
                                    CuiHelper.DestroyUi(player, StoreLayer + ".BlockPanel.Text");
                                }
                            }
                            break;
                        }
                }
            }, player);
        }

        private string IconLayer = "UI_GameStoresRUST_Bucket";
        private void InitializeIcon(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, IconLayer);
            CuiElementContainer container = new CuiElementContainer();
            if (Settings.InterfaceSettings.BucketURL.Contains("http"))
            {
                if (ImageLibrary)
                {
                    container.Add(new CuiElement
                    {
                        Parent = "Overlay",
                        Name = IconLayer,
                        Components =
                        {
                            new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", "GameStoresRUSTBucket") },
                            new CuiRectTransformComponent { AnchorMin = Settings.InterfaceSettings.BucketPosition.AnchorMin, AnchorMax = Settings.InterfaceSettings.BucketPosition.AnchorMax, OffsetMin = Settings.InterfaceSettings.BucketPosition.OffsetMin, OffsetMax = Settings.InterfaceSettings.BucketPosition.OffsetMax }
                        }
                    });

                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                        Button = { Color = "0 0 0 0", Command = "chat.say /store" },
                        Text = { Text = "" }
                    }, IconLayer);
                }
                else
                {
                    container.Add(new CuiElement
                    {
                        Parent = "Overlay",
                        Name = IconLayer,
                        Components =
                        {
                            new CuiRawImageComponent { Url = Settings.InterfaceSettings.BucketURL },
                            new CuiRectTransformComponent { AnchorMin = Settings.InterfaceSettings.BucketPosition.AnchorMin, AnchorMax = Settings.InterfaceSettings.BucketPosition.AnchorMax, OffsetMin = Settings.InterfaceSettings.BucketPosition.OffsetMin, OffsetMax = Settings.InterfaceSettings.BucketPosition.OffsetMax }
                        }
                    });

                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                        Button = { Color = "0 0 0 0", Command = "chat.say /store" },
                        Text = { Text = "" }
                    }, IconLayer);
                }
            }
            else
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = Settings.InterfaceSettings.BucketPosition.AnchorMin, AnchorMax = Settings.InterfaceSettings.BucketPosition.AnchorMax, OffsetMin = Settings.InterfaceSettings.BucketPosition.OffsetMin, OffsetMax = Settings.InterfaceSettings.BucketPosition.OffsetMax },
                    Button = { Color = "1 1 1 0.6", Sprite = "assets/icons/open.png", Command = "chat.say /store" },
                    Text = { Text = "" }
                }, "Overlay", IconLayer);
            }

            CuiHelper.AddUi(player, container);
        }

        #endregion

        #region Utils

        private void ShowNotify(BasePlayer player, string text)
        {
            CuiHelper.DestroyUi(player, StoreLayer + ".Notify");
            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.80", AnchorMax = "1 0.90", OffsetMax = "0 0" },
                Text = { FadeIn = 1f, Text = text, Align = TextAnchor.UpperCenter, Font = "robotocondensed-regular.ttf", FontSize = 16 }
            }, StoreLayer, StoreLayer + ".Notify");

            CuiHelper.AddUi(player, container);
        }

        private void ProcessTake(BasePlayer player, Dictionary<string, object> obj)
        {
            //foreach (var check in obj)
            //   PrintError(check.Key + " -> " + check.Value); 
            LogAction(player, $"Начало обработки товара");
            WItem itemInfo = new WItem(obj);
            try
            {
                if (itemInfo.IsItem)
                {
                    LogAction(player, $"Попытка получения предмета: {itemInfo.ShortName} [{itemInfo.Amount}]");
                    var info = ItemManager.FindItemDefinition(itemInfo.ShortName);
                    if (info == null) return;

                    var item = ItemManager.Create(info, itemInfo.Amount);
                    if (!player.inventory.GiveItem(item))
                    {
                        LogAction(player, $"У игрока не было места для получения предмета, предмет выброшен {itemInfo.ShortName} [{itemInfo.Amount} {player.transform.position}]");

                        item.Drop(player.transform.position, Vector3.down * 3);
                        ShowNotify(player, _(player, "TAKE.GIVE.FEET", info.displayName.english));
                    }
                    else
                    {
                        LogAction(player, $"Предмет выдан игроку в инвентарь");
                        ShowNotify(player, _(player, "TAKE.GIVE.INVENTORY", info.displayName.english));
                    }
                }

                if (itemInfo.IsCommand)
                {
                    LogAction(player, $"Попытка получения команды");

                    string command = itemInfo.Command.Replace("\n", "|").Replace("%steamid%", player.UserIDString, StringComparison.OrdinalIgnoreCase).Replace("%username%", player.displayName, StringComparison.OrdinalIgnoreCase);
                    foreach (var check in command.Split('|'))
                    {
                        LogAction(player, $"Исполнение команды: {check}");
                        Server.Command(check);
                    }

                    ShowNotify(player, _(player, "TAKE.GIVE.COMMAND", itemInfo.Name));
                }

                if (itemInfo.IsBlueprint)
                {
                    LogAction(player, $"Попытка получения рецепта {itemInfo.ShortName}");
                    Item create = ItemManager.CreateByItemID(-996920608);

                    var info = ItemManager.FindItemDefinition(itemInfo.ShortName);
                    create.blueprintTarget = info.itemid;

                    if (!player.inventory.GiveItem(create))
                    {
                        LogAction(player, $"У игрока не было места для получения рецепта, рецепт выброшен {itemInfo.ShortName} [{itemInfo.Amount} {player.transform.position}]");

                        create.Drop(player.transform.position, Vector3.down * 3);
                        ShowNotify(player, _(player, "TAKE.GIVE.BLUEPRINT.FEET", info.displayName.english));
                    }
                    else
                    {
                        LogAction(player, $"Рецепт выдан игроку в инвентарь");
                        ShowNotify(player, _(player, "TAKE.GIVE.BLUEPRINT.INVENTORY", info.displayName.english));
                    }
                }
            }
            catch (Exception e)
            {
                LogAction(player, $"Ошибка получения товара [{itemInfo.ID}][{itemInfo.Name}]");
                LogToFile("!Errors", $"{DateTime.Now.ToShortTimeString()}| Error: '{e.ToString()}'", this);
                PrintError($"Error receiving product [{itemInfo.ID}], info saved to log");
            }
            
        }

        private static readonly Dictionary<int, string> IDToShortName = new Dictionary<int, string> { [-1461508848] = "rifle.ak", [2115555558] = "ammo.handmade.shell", [-533875561] = "ammo.pistol", [1621541165] = "ammo.pistol.fire", [-422893115] = "ammo.pistol.hv", [815896488] = "ammo.rifle", [805088543] = "ammo.rifle.explosive", [449771810] = "ammo.rifle.incendiary", [1152393492] = "ammo.rifle.hv", [1578894260] = "ammo.rocket.basic", [1436532208] = "ammo.rocket.fire", [542276424] = "ammo.rocket.hv", [1594947829] = "ammo.rocket.smoke", [-1035059994] = "ammo.shotgun", [1818890814] = "ammo.shotgun.fire", [1819281075] = "ammo.shotgun.slug", [1685058759] = "antiradpills", [93029210] = "apple", [-1565095136] = "apple.spoiled", [-1775362679] = "arrow.bone", [-1775249157] = "arrow.fire", [-1280058093] = "arrow.hv", [-420273765] = "arrow.wooden", [563023711] = "autoturret", [790921853] = "axe.salvaged", [-337261910] = "bandage", [498312426] = "barricade.concrete", [504904386] = "barricade.metal", [-1221200300] = "barricade.sandbags", [510887968] = "barricade.stone", [-814689390] = "barricade.wood", [1024486167] = "barricade.woodwire", [2021568998] = "battery.small", [97329] = "bbq", [1046072789] = "trap.bear", [97409] = "bed", [-1480119738] = "tool.binoculars", [1611480185] = "black.raspberries", [-1386464949] = "bleach", [93832698] = "blood", [-1063412582] = "blueberries", [-1887162396] = "blueprintbase", [-55660037] = "rifle.bolt", [919780768] = "bone.club", [-365801095] = "bone.fragments", [68998734] = "botabag", [-853695669] = "bow.hunting", [271534758] = "box.wooden.large", [-770311783] = "box.wooden", [-1192532973] = "bucket.water", [-307490664] = "building.planner", [707427396] = "burlap.shirt", [707432758] = "burlap.shoes", [-2079677721] = "cactusflesh", [-1342405573] = "tool.camera", [-139769801] = "campfire", [-1043746011] = "can.beans", [2080339268] = "can.beans.empty", [-171664558] = "can.tuna", [1050986417] = "can.tuna.empty", [-1693683664] = "candycaneclub", [523409530] = "candycane", [1300054961] = "cctv.camera", [-2095387015] = "ceilinglight", [1428021640] = "chainsaw", [94623429] = "chair", [1436001773] = "charcoal", [1711323399] = "chicken.burned", [1734319168] = "chicken.cooked", [-1658459025] = "chicken.raw", [-726947205] = "chicken.spoiled", [-341443994] = "chocholate", [1540879296] = "xmasdoorwreath", [94756378] = "cloth", [3059095] = "coal", [3059624] = "corn", [2045107609] = "clone.corn", [583366917] = "seed.corn", [2123300234] = "crossbow", [1983936587] = "crude.oil", [1257201758] = "cupboard.tool", [-1144743963] = "diving.fins", [-1144542967] = "diving.mask", [-1144334585] = "diving.tank", [1066729526] = "diving.wetsuit", [-1598790097] = "door.double.hinged.metal", [-933236257] = "door.double.hinged.toptier", [-1575287163] = "door.double.hinged.wood", [-2104481870] = "door.hinged.metal", [-1571725662] = "door.hinged.toptier", [1456441506] = "door.hinged.wood", [1200628767] = "door.key", [-778796102] = "door.closer", [1526866730] = "xmas.door.garland", [1925723260] = "dropbox", [1891056868] = "ducttape", [1295154089] = "explosive.satchel", [498591726] = "explosive.timed", [1755466030] = "explosives", [726730162] = "facialhair.style01", [-1034048911] = "fat.animal", [252529905] = "femalearmpithair.style01", [471582113] = "femaleeyebrow.style01", [-1138648591] = "femalepubichair.style01", [305916740] = "female_hairstyle_01", [305916742] = "female_hairstyle_03", [305916744] = "female_hairstyle_05", [1908328648] = "fireplace.stone", [-2078972355] = "fish.cooked", [-533484654] = "fish.raw", [1571660245] = "fishingrod.handmade", [1045869440] = "flamethrower", [1985408483] = "flameturret", [97513422] = "flare", [1496470781] = "flashlight.held", [1229879204] = "weapon.mod.flashlight", [-1722829188] = "floor.grill", [1849912854] = "floor.ladder.hatch", [-1266285051] = "fridge", [-1749787215] = "boots.frog", [28178745] = "lowgradefuel", [-505639592] = "furnace", [1598149413] = "furnace.large", [-1779401418] = "gates.external.high.stone", [-57285700] = "gates.external.high.wood", [98228420] = "gears", [1422845239] = "geiger.counter", [277631078] = "generator.wind.scrap", [115739308] = "burlap.gloves", [-522149009] = "gloweyes", [3175989] = "glue", [718197703] = "granolabar", [384204160] = "grenade.beancan", [-1308622549] = "grenade.f1", [-217113639] = "fun.guitar", [-1580059655] = "gunpowder", [-1832205789] = "male_hairstyle_01", [305916741] = "female_hairstyle_02", [936777834] = "attire.hide.helterneck", [-1224598842] = "hammer", [-1976561211] = "hammer.salvaged", [-1406876421] = "hat.beenie", [-1397343301] = "hat.boonie", [1260209393] = "bucket.helmet", [-1035315940] = "burlap.headwrap", [-1381682752] = "hat.candle", [696727039] = "hat.cap", [-2128719593] = "coffeecan.helmet", [-1178289187] = "deer.skull.mask", [1351172108] = "heavy.plate.helmet", [-450738836] = "hat.miner", [-966287254] = "attire.reindeer.headband", [340009023] = "riot.helmet", [124310981] = "hat.wolf", [1501403549] = "wood.armor.helmet", [698310895] = "hatchet", [523855532] = "hazmatsuit", [2045246801] = "clone.hemp", [583506109] = "seed.hemp", [-148163128] = "attire.hide.boots", [-132588262] = "attire.hide.skirt", [-1666761111] = "attire.hide.vest", [-465236267] = "weapon.mod.holosight", [-1211618504] = "hoodie", [2133577942] = "hq.metal.ore", [-1014825244] = "humanmeat.burned", [-991829475] = "humanmeat.cooked", [-642008142] = "humanmeat.raw", [661790782] = "humanmeat.spoiled", [-1440143841] = "icepick.salvaged", [569119686] = "bone.armor.suit", [1404466285] = "heavy.plate.jacket", [-1616887133] = "jacket.snow", [-1167640370] = "jacket", [-1284735799] = "jackolantern.angry", [-1278649848] = "jackolantern.happy", [776005741] = "knife.bone", [108061910] = "ladder.wooden.wall", [255101535] = "trap.landmine", [-51678842] = "lantern", [-789202811] = "largemedkit", [516382256] = "weapon.mod.lasersight", [50834473] = "leather", [-975723312] = "lock.code", [1908195100] = "lock.key", [-1097452776] = "locker", [146685185] = "longsword", [-1716193401] = "rifle.lr300", [193190034] = "lmg.m249", [371156815] = "pistol.m92", [3343606] = "mace", [825308669] = "machete", [830965940] = "mailbox", [1662628660] = "male.facialhair.style02", [1662628661] = "male.facialhair.style03", [1662628662] = "male.facialhair.style04", [-1832205788] = "male_hairstyle_02", [-1832205786] = "male_hairstyle_04", [1625090418] = "malearmpithair.style01", [-1269800768] = "maleeyebrow.style01", [429648208] = "malepubichair.style01", [-1832205787] = "male_hairstyle_03", [-1832205785] = "male_hairstyle_05", [107868] = "map", [997973965] = "mask.balaclava", [-46188931] = "mask.bandana", [-46848560] = "metal.facemask", [-2066726403] = "bearmeat.burned", [-2043730634] = "bearmeat.cooked", [1325935999] = "bearmeat", [-225234813] = "deermeat.burned", [-202239044] = "deermeat.cooked", [-322501005] = "deermeat.raw", [-1851058636] = "horsemeat.burned", [-1828062867] = "horsemeat.cooked", [-1966381470] = "horsemeat.raw", [968732481] = "meat.pork.burned", [991728250] = "meat.pork.cooked", [-253819519] = "meat.boar", [-1714986849] = "wolfmeat.burned", [-1691991080] = "wolfmeat.cooked", [179448791] = "wolfmeat.raw", [431617507] = "wolfmeat.spoiled", [688032252] = "metal.fragments", [-1059362949] = "metal.ore", [1265861812] = "metal.plate.torso", [374890416] = "metal.refined", [1567404401] = "metalblade", [-1057402571] = "metalpipe", [-758925787] = "mining.pumpjack", [-1411620422] = "mining.quarry", [88869913] = "fish.minnows", [-2094080303] = "smg.mp5", [843418712] = "mushroom", [-1569356508] = "weapon.mod.muzzleboost", [-1569280852] = "weapon.mod.muzzlebrake", [449769971] = "pistol.nailgun", [590532217] = "ammo.nailgun.nails", [3387378] = "note", [1767561705] = "burlap.trousers", [106433500] = "pants", [-1334615971] = "heavy.plate.pants", [-135651869] = "attire.hide.pants", [-1595790889] = "roadsign.kilt", [-459156023] = "pants.shorts", [106434956] = "paper", [-578028723] = "pickaxe", [-586116979] = "jar.pickle", [-1379225193] = "pistol.eoka", [-930579334] = "pistol.revolver", [548699316] = "pistol.semiauto", [142147109] = "planter.large", [148953073] = "planter.small", [102672084] = "attire.hide.poncho", [640562379] = "pookie.bear", [-1732316031] = "xmas.present.large", [-2130280721] = "xmas.present.medium", [-1725510067] = "xmas.present.small", [1974032895] = "propanetank", [-225085592] = "pumpkin", [509654999] = "clone.pumpkin", [466113771] = "seed.pumpkin", [2033918259] = "pistol.python", [2069925558] = "target.reactive", [-1026117678] = "box.repair.bench", [1987447227] = "research.table", [540154065] = "researchpaper", [1939428458] = "riflebody", [-288010497] = "roadsign.jacket", [-847065290] = "roadsigns", [3506021] = "rock", [649603450] = "rocket.launcher", [3506418] = "rope", [569935070] = "rug.bear", [113284] = "rug", [1916127949] = "water.salt", [-1775234707] = "salvaged.cleaver", [-388967316] = "salvaged.sword", [2007564590] = "santahat", [-1705696613] = "scarecrow", [670655301] = "hazmatsuit_scientist", [1148128486] = "hazmatsuit_scientist_peacekeeper", [-141135377] = "weapon.mod.small.scope", [109266897] = "scrap", [-527558546] = "searchlight", [-1745053053] = "rifle.semiauto", [1223860752] = "semibody", [-419069863] = "sewingkit", [-1617374968] = "sheetmetal", [2057749608] = "shelves", [24576628] = "shirt.collared", [-1659202509] = "shirt.tanktop", [2107229499] = "shoes.boots", [191795897] = "shotgun.double", [-1009492144] = "shotgun.pump", [2077983581] = "shotgun.waterpipe", [378365037] = "guntrap", [-529054135] = "shutter.metal.embrasure.a", [-529054134] = "shutter.metal.embrasure.b", [486166145] = "shutter.wood.a", [1628490888] = "sign.hanging.banner.large", [1498516223] = "sign.hanging", [-632459882] = "sign.hanging.ornate", [-626812403] = "sign.pictureframe.landscape", [385802761] = "sign.pictureframe.portrait", [2117976603] = "sign.pictureframe.tall", [1338515426] = "sign.pictureframe.xl", [-1455694274] = "sign.pictureframe.xxl", [1579245182] = "sign.pole.banner.large", [-587434450] = "sign.post.double", [-163742043] = "sign.post.single", [-1224714193] = "sign.post.town", [644359987] = "sign.post.town.roof", [-1962514734] = "sign.wooden.huge", [-705305612] = "sign.wooden.large", [-357728804] = "sign.wooden.medium", [-698499648] = "sign.wooden.small", [1213686767] = "weapon.mod.silencer", [386382445] = "weapon.mod.simplesight", [1859976884] = "skull_fire_pit", [960793436] = "skull.human", [1001265731] = "skull.wolf", [1253290621] = "sleepingbag", [470729623] = "small.oil.refinery", [1051155022] = "stash.small", [865679437] = "fish.troutsmall", [927253046] = "smallwaterbottle", [109552593] = "smg.2", [-2092529553] = "smgbody", [691633666] = "snowball", [-2055888649] = "snowman", [621575320] = "shotgun.spas12", [-2118132208] = "spear.stone", [-1127699509] = "spear.wooden", [-685265909] = "spikes.floor", [552706886] = "spinner.wheel", [1835797460] = "metalspring", [-892259869] = "sticks", [-1623330855] = "stocking.large", [-1616524891] = "stocking.small", [789892804] = "stone.pickaxe", [-1289478934] = "stonehatchet", [-892070738] = "stones", [-891243783] = "sulfur", [889398893] = "sulfur.ore", [-1625468793] = "supply.signal", [1293049486] = "surveycharge", [1369769822] = "fishtrap.small", [586484018] = "syringe.medical", [110115790] = "table", [1490499512] = "targeting.computer", [3552619] = "tarp", [1471284746] = "techparts", [456448245] = "smg.thompson", [110547964] = "torch", [1588977225] = "xmas.decoration.baubels", [918540912] = "xmas.decoration.candycanes", [-471874147] = "xmas.decoration.gingerbreadmen", [205978836] = "xmas.decoration.lights", [-1044400758] = "xmas.decoration.pinecone", [-2073307447] = "xmas.decoration.star", [435230680] = "xmas.decoration.tinsel", [-864578046] = "tshirt", [1660607208] = "tshirt.long", [260214178] = "tunalight", [-1847536522] = "vending.machine", [-496055048] = "wall.external.high.stone", [-1792066367] = "wall.external.high", [562888306] = "wall.frame.cell.gate", [-427925529] = "wall.frame.cell", [995306285] = "wall.frame.fence.gate", [-378017204] = "wall.frame.fence", [447918618] = "wall.frame.garagedoor", [313836902] = "wall.frame.netting", [1175970190] = "wall.frame.shopfront", [525244071] = "wall.frame.shopfront.metal", [-1021702157] = "wall.window.bars.metal", [-402507101] = "wall.window.bars.toptier", [-1556671423] = "wall.window.bars.wood", [61936445] = "wall.window.glass.reinforced", [112903447] = "water", [1817873886] = "water.catcher.large", [1824679850] = "water.catcher.small", [-1628526499] = "water.barrel", [547302405] = "waterjug", [1840561315] = "water.purifier", [-460592212] = "xmas.window.garland", [3655341] = "wood", [1554697726] = "wood.armor.jacket", [-1883959124] = "wood.armor.pants", [-481416622] = "workbench1", [-481416621] = "workbench2", [-481416620] = "workbench3", [-1151126752] = "xmas.lightstring", [-1926458555] = "xmas.tree" };

        private void UI_RecountPosition(ref double xSwitch, ref double ySwitch, int count, int max)
        {
            var stringAmount = Math.Ceiling((double)max / Settings.InterfaceSettings.ItemOnString);
            var currentString = Math.Floor((double)count / Settings.InterfaceSettings.ItemOnString);
            var currentPosition = count % Settings.InterfaceSettings.ItemOnString;


            var topYPosition = 0 + (float)stringAmount / 2 * Settings.InterfaceSettings.ItemSide + ((float)stringAmount / 2 - 1) * Settings.InterfaceSettings.ItemMargin;
            var topXPosition = 0 - (float)Settings.InterfaceSettings.ItemOnString / 2 * Settings.InterfaceSettings.ItemSide - ((float)Settings.InterfaceSettings.ItemOnString / 2 - 1) * Settings.InterfaceSettings.ItemMargin;

            var curYPosition = topYPosition - currentString * Settings.InterfaceSettings.ItemSide - (currentString) * (Settings.InterfaceSettings.ItemMargin + (Settings.InterfaceSettings.TextShow ? 20 : 0));
            var curXPosition = topXPosition + currentPosition * Settings.InterfaceSettings.ItemSide + (currentPosition) * Settings.InterfaceSettings.ItemMargin;

            xSwitch = curXPosition;
            ySwitch = curYPosition;
        }

        public static bool CheckInstantWork = false;
        public Timer CheckInstantWorkGlobalTimer = null;

        private void CheckInstant()
        {
            if (CheckInstantWork == true)
                return;

            CheckInstantWork = true;
            if (CheckInstantWorkGlobalTimer != null)
                CheckInstantWorkGlobalTimer.Destroy();

            CheckInstantWorkGlobalTimer = timer.Once(300, () => { CheckInstantWork = false; });

            Request($"&method=basket.commands.instant", (code, response) =>
            {
                switch (code)
                {
                    case 0:
                        {
                            LogAction(null, $"Ошибка выполнения запроса для выдачи автоматических команд");
                            CheckInstantWork = false;
                            break;
                        }
                    case 200:
                        {
                            var firstInfo = JsonConvert.DeserializeObject<Dictionary<string, object>>(response, new KeyValuesConverter());
                            if (firstInfo.ContainsKey("result"))
                            {
                                if (firstInfo["result"].ToString() == "success")
                                {
                                    List<object> data = firstInfo["data"] as List<object>;
                                    int i = 1;
                                    timer.Once(data.Count + 2, () => { CheckInstantWork = false; });

                                    foreach (Dictionary<string, object> product in data)
                                    {
                                        if (product.ContainsKey("id"))
                                        {
                                            timer.Once(i, () => { TakeInstant(Convert.ToInt32(product["id"]), product["steam_id"].ToString()); } );
                                            i++;
                                        }

                                    }
                                } else CheckInstantWork = false;
                            } else CheckInstantWork = false;
                            break;
                        }
                    default:
                        {
                            LogAction(null, $"Ошибка выполнения запроса для выдачи автоматических команд");
                            CheckInstantWork = false;
                            break;
                        }
                }
            }, null); 
        }

        private void TakeInstant(int GsProductId, string SteamId)
        {
            LogAction(null, $"---------------------------------");
            LogAction(null, $"[AutoCommands] Запрос на получение товара [{GsProductId}][{SteamId}]");
            Request($"&item=true&id={GsProductId}", (i, s) =>
            {
                switch (i)
                {
                    case 0:
                        LogAction(null, $"[AutoCommands] API не ответило на запрос: {GsProductId}");
                        PrintError("Api does not responded to a request");
                        break;
                    case 200:
                        Dictionary<string, object> response = JsonConvert.DeserializeObject<Dictionary<string, object>>(s, new KeyValuesConverter());
                        if (!response.ContainsKey("data"))
                        {
                            LogAction(null, $"[AutoCommands] Ошибка получения товара, отсутствует Data [{GsProductId}]");
                            return;
                        } else
                        {
                            Request($"&gived=true&id={GsProductId}", (code, newResponse) =>
                            {
                                if (code != 200 || JsonConvert.DeserializeObject<JObject>(newResponse)["result"].ToString() != "success")
                                {
                                    LogAction(null, $"[AutoCommands] Ошибка получения товара [{GsProductId}][{SteamId}]");
                                    return;
                                }
                                else
                                {
                                    WItem itemInfo = new WItem(response["data"] as Dictionary<string, object>);
                                    if (itemInfo.IsCommand)
                                    {
                                        LogAction(null, $"[AutoCommands] Товар отмечен полученным [{GsProductId}][{SteamId}]");
                                        string command = itemInfo.Command.Replace("\n", "|").Replace("%steamid%", SteamId, StringComparison.OrdinalIgnoreCase);
                                        foreach (var check in command.Split('|'))
                                        {
                                            LogAction(null, $"[AutoCommands] Исполнение команды: {check} [{GsProductId}][{SteamId}]");
                                            Server.Command(check);
                                        }
                                    }
                                    else
                                    {
                                        LogAction(null, $"[AutoCommands] Ошибка получения (товар не является командой) [{GsProductId}][{SteamId}]");
                                    }
                                }
                            }, null);
                        }
                       
                        break;
                    case 404:
                        LogAction(null, $"[AutoCommands] Api не ответило на запрос: {GsProductId}");
                        LogAction(null, "Response code: 404, please check your configurations", true);
                        break;
                }
            }, null);
        }

        private Timer RestartTimer = null;
        private void SetReserveApiLink()
        {
            if (BaseRequest.Contains(MainApiLink))
            {
                LogAction(null, $"Trying use reserve api link", true);
                BaseRequest = ReserveApiLink + BaseRequestParams;
                if (!Initialized)
                    FetchShopUrl();
                timer.Once(300, () => {
                    TryChangeLink();
                });
            } else
            {
                LogAction(null, $"Plugin will automatically restart after 10 minutes", true);
                RestartTimer = timer.Once(600, () => { LogAction(null, $"Restarting...", true); Server.Command("o.reload GameStoresRUST"); });
            }                         
        }

        private void TryChangeLink()
        {
            string newLink = ReserveApiLink + BaseRequestParams;
            if (BaseRequest.Contains(ReserveApiLink))
            {
                newLink = MainApiLink + BaseRequestParams;
            }
            CheckRequest($"{newLink}&info=true", (code, response) =>
            {
                switch (code)
                {
                    case 200:
                        {
                            if (response.Length < 1)
                            {
                                return;
                            }
                            var firstInfo = JsonConvert.DeserializeObject<Dictionary<string, object>>(response, new KeyValuesConverter());
                            if (!firstInfo.ContainsKey("data"))
                            {
                                initialization = false;
                            }
                            else
                            {
                                if (RestartTimer != null)
                                {
                                    LogAction(null, $"Restart was canceled");
                                    RestartTimer.Destroy();
                                    RestartTimer = null;
                                }
                                LogAction(null, $"API link was changed", true);
                                BaseRequest = newLink;
                                if (!Initialized)
                                    FetchShopUrl();
                                if (BaseRequest.Contains(ReserveApiLink))
                                    timer.Once(600, () => { TryChangeLink(); });
                            }
                            break;
                        }
                    default:
                        break;

                }
            });
        }

        private void FetchShopUrl()
        {
            initialization = true;
            timer.Once(5, () => { initialization = false; });
            Request($"&info=true", (code, response) =>
            {
                LogAction(null, $"-----------------------------", true);
                LogAction(null, $" GameStores {Version} (c) 2023", true);
                try
                {
                    if (response.Length < 1)
                    {
                        LogToFile("!Errors", $"{DateTime.Now.ToShortTimeString()}| Response: '{response}'", this);
                        LogAction(null, " Incorrect API response! Saved to log!", true, true);
                        LogAction(null, $"-----------------------------", true);
                        SetReserveApiLink();
                        initialization = false;
                        return;
                    }
                    var firstInfo = JsonConvert.DeserializeObject<Dictionary<string, object>>(response, new KeyValuesConverter());
                    if (!firstInfo.ContainsKey("data"))
                    {
                        LogAction(null, $"     Wrong Secret Key", true, true);
                        LogAction(null, $"-----------------------------", true);
                        initialization = false;
                    }
                    else
                    { 
                        firstInfo = firstInfo["data"] as Dictionary<string, object>;
                        ShopURL = firstInfo["link"].ToString();
                        StartBalance = int.Parse(firstInfo["default_balance"].ToString());
                        LogAction(null, "      Initialized - OK", true);
                        LogAction(null, $"-----------------------------", true);
                        //BasePlayer.activePlayerList.ForEach(OnPlayerInit);
                        foreach (var pl in BasePlayer.activePlayerList)
                        {
                            OnPlayerConnected(pl);
                        }

                        Initialized = true;
                        initialization = false;
                    }
                }
                catch (JsonException e)
                {
                    
                    LogToFile("Errors", $"{DateTime.Now.ToShortTimeString()}| JsonError | Response: '{response}'", this);
                    LogAction(null, " JSON Error! Saved to log!", true, true);
                    LogAction(null, $"-----------------------------", true);
                    SetReserveApiLink();
                    initialization = false;
                }

            });
        }

        private static int errorsReq = 0;
        private static void Request(string ask, Action<int, string> callback, BasePlayer player = null, bool cancel = true)
        {
            if (player != null && !Delays.CanRequest(player))
            {
                instance.ShowNotify(player, instance._(player, "MANY.REQUESTS"));
                instance.timer.Once(1f, () =>
                {
                    CuiHelper.DestroyUi(player, StoreLayer + ".Notify");
                    Request(ask, callback, player, cancel);
                });

                return;
            };
            if (player != null) ServerMgr.Instance.StartCoroutine(Delays.MakeRequest(player));
            Dictionary<string, string> reqHeaders = new Dictionary<string, string>{{ "User-Agent", "GameStores Plugin" }};
            if (!SecureConnection && instance.BaseRequest.Contains("https://")) instance.BaseRequest = instance.BaseRequest.Replace("https://", "http://");
            instance.webrequest.Enqueue(instance.BaseRequest + ask, "", (code, response) =>
            {
                if (instance == null) return;
                
                switch (code)
                {
                    case 200:
                        {
                            break;
                        }

                    case 404:
                        {
                            instance.LogAction(null, $"Please check your configuration! [404] #2", true);
                            break;
                        }

                    default:
                        {
                            instance.LogAction(null, $"Time out waiting for GS API #1");
                            errorsReq++;
                            
                            if (errorsReq >= 10)
                            {
                                errorsReq = 0;
                                instance.TryChangeLink();
                            }
                            
                            break;
                        }
                }

                if (SecureConnection && response.Contains("The authentication or decryption has failed."))
                {
                    instance.LogAction(null, "HTTPS request is broken (broken CA certificate?). Changed to non secure connection!", true, true);

                    SecureConnection = false;
                    instance.BaseRequest = instance.BaseRequest.Replace("https://", "http://");

                    Request(ask, callback, player, cancel);
                    return;
                }

                if (player != null && cancel) Delays.FinishRequest(player);

                callback?.Invoke(code, response);
            }, instance, RequestMethod.GET, reqHeaders);
                      
        }
        private static void CheckRequest(string link, Action<int, string> callback)
        {
            Dictionary<string, string> reqHeaders = new Dictionary<string, string> { { "User-Agent", "GameStores Plugin" } };
            if (!SecureConnection && link.Contains("https://")) link = link.Replace("https://", "http://");
            instance.webrequest.Enqueue(link, "", (code, response) =>
            {
                if (instance == null) return;

                switch (code)
                {
                    case 0:
                        {
                            
                            break;
                        }
                    case 404:
                        {
                            
                            break;
                        }
                }

                callback?.Invoke(code, response);
            }, instance, RequestMethod.GET, reqHeaders);

        }

        private static void RequestPost(string ask, Action<int, string> callback, BasePlayer player = null, bool cancel = true)
        {
            if (player != null && !Delays.CanRequest(player))
            {
                instance.ShowNotify(player, instance._(player, "MANY.REQUESTS"));
                instance.timer.Once(1f, () =>
                {
                    CuiHelper.DestroyUi(player, StoreLayer + ".Notify");
                    RequestPost(ask, callback, player, cancel);
                });
                return;
            };
            if (player != null) ServerMgr.Instance.StartCoroutine(Delays.MakeRequest(player));
            string body, reqLink;
            int pos = instance.BaseRequest.IndexOf("?");
            if (pos < 0)
            {
                body = ask;
                reqLink = instance.BaseRequest;
            }
            else
            {
                reqLink = instance.BaseRequest.Substring(0, pos);
                body = $"{instance.BaseRequest.Substring(pos + 1)}{ask}";
            }
            Dictionary<string, string> reqHeaders = new Dictionary<string, string> { { "User-Agent", "GameStores Plugin" } };
            if (!SecureConnection && reqLink.Contains("https://")) reqLink = reqLink.Replace("https://", "http://");
            instance.webrequest.Enqueue(reqLink, body, (code, response) =>
            {
                if (instance == null) return;

                switch (code)
                {
                    case 0:
                        {
                            instance.PrintError($"Time out waiting for GS API #1");
                            break;
                        }
                    case 404:
                        {
                            instance.PrintError($"Plese check your configuration! [404] #2");
                            break;
                        }
                }

                if (player != null && cancel) Delays.FinishRequest(player);

                callback?.Invoke(code, response);
            }, instance, RequestMethod.POST, reqHeaders);
        }

        private void LogAction(BasePlayer player, string text, bool printToConsole = false, bool printError = false)
        {
            LogToFile($"!global", $"{DateTime.Now.ToShortTimeString()} {(player != null ? "[" + player.userID + "]" : " ")}{text}", this);

            if (printToConsole)
                if (printError)
                    instance.PrintError($"{text}");
                else 
                    PrintWarning($"{text}");
            if (player != null)
                LogPlayerAction(player, text);
        }
        private void LogPlayerAction(BasePlayer player, string text) => LogToFile($"{player.userID}", $"{DateTime.Now.ToShortTimeString()} {text}", this);
        private static double CurrentTime() => DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1)).TotalSeconds;

        #endregion
    }
}

// --- End of file: GameStoresRUST.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/WaterBlock.cs ---
// --- Original Local Path: BeeRust/WaterBlock.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("WaterBlock", "", "1.1.0")]
    class WaterBlock : RustPlugin
    {
        int terrainMask = LayerMask.GetMask("Terrain");
        int constructionMask = LayerMask.GetMask("Construction");

        WaterCollision collision;

        void OnServerInitialized()
        {
            lang.RegisterMessages(Messages, this, "en");
            Messages = lang.GetMessages("en", this);
            collision = UnityEngine.Object.FindObjectOfType<WaterCollision>();
        }

        static void DrawBox(BasePlayer player, Vector3 center, Quaternion rotation, Vector3 size)
        {
            size /= 2;
            var point1 = RotatePointAroundPivot(new Vector3(center.x + size.x, center.y + size.y, center.z + size.z), center, rotation);
            var point2 = RotatePointAroundPivot(new Vector3(center.x + size.x, center.y - size.y, center.z + size.z), center, rotation);
            var point3 = RotatePointAroundPivot(new Vector3(center.x + size.x, center.y + size.y, center.z - size.z), center, rotation);
            var point4 = RotatePointAroundPivot(new Vector3(center.x + size.x, center.y - size.y, center.z - size.z), center, rotation);
            var point5 = RotatePointAroundPivot(new Vector3(center.x - size.x, center.y + size.y, center.z + size.z), center, rotation);
            var point6 = RotatePointAroundPivot(new Vector3(center.x - size.x, center.y - size.y, center.z + size.z), center, rotation);
            var point7 = RotatePointAroundPivot(new Vector3(center.x - size.x, center.y + size.y, center.z - size.z), center, rotation);
            var point8 = RotatePointAroundPivot(new Vector3(center.x - size.x, center.y - size.y, center.z - size.z), center, rotation);

            player.SendConsoleCommand("ddraw.line", 5, Color.blue, point1, point2);
            player.SendConsoleCommand("ddraw.line", 5, Color.blue, point1, point3);
            player.SendConsoleCommand("ddraw.line", 5, Color.blue, point1, point5);
            player.SendConsoleCommand("ddraw.line", 5, Color.blue, point4, point2);
            player.SendConsoleCommand("ddraw.line", 5, Color.blue, point4, point3);
            player.SendConsoleCommand("ddraw.line", 5, Color.blue, point4, point8);

            player.SendConsoleCommand("ddraw.line", 5, Color.blue, point5, point6);
            player.SendConsoleCommand("ddraw.line", 5, Color.blue, point5, point7);
            player.SendConsoleCommand("ddraw.line", 5, Color.blue, point6, point2);
            player.SendConsoleCommand("ddraw.line", 5, Color.blue, point8, point6);
            player.SendConsoleCommand("ddraw.line", 5, Color.blue, point8, point7);
            player.SendConsoleCommand("ddraw.line", 5, Color.blue, point7, point3);
        }

        static Vector3 RotatePointAroundPivot(Vector3 point, Vector3 pivot, Quaternion rotation)
        {
            return rotation * (point - pivot) + pivot;
        }

        void OnEntityBuilt(Planner planner, GameObject gameobject, Vector3 Pos)
        {
            if (planner == null || gameobject == null) return;
            var player = planner.GetOwnerPlayer();
            BaseEntity entity = gameobject.ToBaseEntity();
            if (entity == null) return;
            int waterLevel = 2;
            Vector3 pos = entity.GetNetworkPosition();

            if (TerrainMeta.WaterMap.GetHeight(pos) - pos.y > waterLevel)
            {
                Refund(player, entity);
                player.ChatMessage(string.Format(Messages["waterLevel"], waterLevel));
                //entity.Kill();
                NextTick(() => { entity.Kill(); });
                return;
            }
        }

        bool CompareFoundationStacking(Vector3 vec1, Vector3 vec2)
        {
            return vec1.ToString("F4") == vec2.ToString("F4");
        }

        void SendReply(BasePlayer player, string msg)
        {
            base.SendReply(player, $"<size=16><color=#ff5400>{msg}</color></size>");
        }

        bool InCave(Vector3 vec) => collision.GetIgnore(vec);

        void Refund(BasePlayer player, BaseEntity entity)
        {
            RefundHelper.Refund(player, entity);
        }

        #region Refund
        public static class RefundHelper
        {
            private static Dictionary<uint, Dictionary<ItemDefinition, int>> refundItems =
                new Dictionary<uint, Dictionary<ItemDefinition, int>>();

            public static void Refund(BasePlayer player, BaseEntity entity, float percent = 1)
            {
                StorageContainer storage = entity as StorageContainer;
                if (storage)
                {
                    for (int i = storage.inventory.itemList.Count - 1; i >= 0; i--)
                    {
                        var item = storage.inventory.itemList[i];
                        if (item == null) continue;
                        item.amount = (int)(item.amount * percent);
                        float single = 20f;
                        Vector3 vector32 = Quaternion.Euler(UnityEngine.Random.Range(-single * 0.5f, single * 0.5f), UnityEngine.Random.Range(-single * 0.5f, single * 0.5f), UnityEngine.Random.Range(-single * 0.5f, single * 0.5f)) * Vector3.up;
                        BaseEntity baseEntity = item.Drop(storage.transform.position + (Vector3.up * 1f), vector32 * UnityEngine.Random.Range(5f, 10f), UnityEngine.Random.rotation);
                        baseEntity.SetAngularVelocity(UnityEngine.Random.rotation.eulerAngles * 5f);
                    }
                }

                BuildingBlock block = entity as BuildingBlock;
                if (block != null)
                {
                    try
                    {
                        if (block.currentGrade == null) return;
                        foreach (var item in block.currentGrade.CostToBuild())
                        {
                            var amount = (int)(item.amount * (Mathf.Approximately(percent, -1) ? 0.5f : percent));
                            if (amount < 1) amount = 1;
                            player.GiveItem(ItemManager.Create(item.itemDef, amount, 0));
                        }

                    }
                    catch
                    {
                    }
                    return;
                }
                Dictionary<ItemDefinition, int> items;
                if (refundItems.TryGetValue(entity.prefabID, out items))
                {
                    foreach (var item in items)
                        if (item.Value > 0)
                            player.GiveItem(ItemManager.Create(item.Key, (int)(item.Value)));
                }
            }

            private static void InitRefundItems()
            {
                foreach (var item in ItemManager.itemList)
                {
                    var deployable = item.GetComponent<ItemModDeployable>();
                    if (deployable != null)
                    {
                        if (item.Blueprint == null || deployable.entityPrefab == null) continue;
                        refundItems.Add(deployable.entityPrefab.resourceID, item.Blueprint.ingredients.ToDictionary(p => p.itemDef, p => ((int)p.amount)));
                    }
                }
            }
        }
        #endregion

        #region MESSAGES

        Dictionary<string, string> Messages = new Dictionary<string, string>()
        {
            { "buildingBlocked", "Строительство в BuildingBlocked запрещено!"},
            { "waterLevel", "Строительство глубже {0} метров под водой запрещено!"},
            { "heightLevel", "Строительство выше {0} метров запрещено!" },
            { "iceBlock", "Строительство на айсбергах запрещено!" },
            { "roadBlock", "Строительство на дорогах запрещено!" },
            { "treeBlock", "Строительство рядом с деревьями в радиусе {0}м. запрещено" },
            { "StackFoundation","Стакать фундаменты запрещено!"},
            { "AlreadyBuildingBuilt", "Шкаф уже стоит!" }
        };

        #endregion
    }
}
                                

// --- End of file: WaterBlock.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/CompoundOptions.cs ---
// --- Original Local Path: BeeRust/CompoundOptions.cs ---

﻿using System.Collections.Generic;
using System.Linq;
using Rust.Ai;
using Oxide.Core;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Compound Options", "FastBurst", "1.2.5")]
    [Description("Compound monument options")]
    class CompoundOptions : RustPlugin
    {
        #region Vars
        private bool dataChanged;
        private StorageData data;
        private StorageData defaultOrders;
        #endregion

        #region Oxide hooks
        private void Loaded()
        {
            try
            {
                data = Interface.Oxide.DataFileSystem.ReadObject<StorageData>(Name);
                defaultOrders = Interface.Oxide.DataFileSystem.ReadObject<StorageData>(Name + "_default");
            }
            catch { }

            if (data == null)
            {
                data = new StorageData();
            }
            if (defaultOrders == null)
            {
                defaultOrders = new StorageData();
            }

            if (data.VendingMachinesOrders == null)
            {
                data.VendingMachinesOrders = new Dictionary<string, Order[]>();
            }
            if (defaultOrders.VendingMachinesOrders == null)
            {
                defaultOrders.VendingMachinesOrders = new Dictionary<string, Order[]>();
            }
        }

        private void Unload()
        {
            foreach (var entity in BaseNetworkable.serverEntities.ToList())
            {
                if (entity is NPCVendingMachine)
                {
                    var vending = entity as NPCVendingMachine;
                    if (configData.General.allowConsoleOutput)
                        Puts($"Restoring default orders for {vending.ShortPrefabName}");
                    if (defaultOrders.VendingMachinesOrders != null)
                    {
                        vending.vendingOrders.orders = GetDefaultOrders(vending);
                        vending.InstallFromVendingOrders();
                    }
                }
            }
        }

        private void Init()
        {
            Unsubscribe(nameof(OnEntitySpawned));
            //LoadVariables();
        }

        private void OnServerInitialized()
        {
            Subscribe(nameof(OnEntitySpawned));

            foreach (var entity in BaseNetworkable.serverEntities.ToList())
            {
                if (entity is NPCVendingMachine)
                {
                    var vending = entity as NPCVendingMachine;
                    AddVendingOrders(vending, true);
                    UpdateVending(vending);
                }
                else if (entity is NPCPlayer)
                {
                    KillNPCPlayer(entity as NPCPlayer);
                }
                else if (entity is NPCAutoTurret)
                {
                    ProcessNPCTurret(entity as NPCAutoTurret);
                }
            }

            //LoadVariables();
            SaveData();
        }

        private void OnEntityEnter(TriggerBase trigger, BaseEntity entity)
        {
            if (!(trigger is TriggerSafeZone) && !(entity is BasePlayer)) return;

            var safeZone = trigger as TriggerSafeZone;
            if (safeZone == null) return;

            safeZone.enabled = !configData.General.disableCompoundTrigger;
        }

        private void OnEntitySpawned(BaseNetworkable entity)
        {
            if (entity is NPCVendingMachine)
            {
                UpdateVending(entity as NPCVendingMachine);
                SaveData();
            }
            else if (entity is NPCPlayer)
            {
                KillNPCPlayer(entity as NPCPlayer);
            }
            else if (entity is NPCAutoTurret)
            {
                ProcessNPCTurret(entity as NPCAutoTurret);
            }
        }
        #endregion

        #region Implementation
        private void KillNPCPlayer(NPCPlayer npcPlayer)
        {
            var npcSpawner = npcPlayer.gameObject.GetComponent<ScientistSpawner>();
            if (npcSpawner == null) return;

            if (npcSpawner.IsMilitaryTunnelLab && configData.General.disallowCompoundNPC || npcSpawner.IsBandit && configData.General.disallowBanditNPC)
            {
                if (!npcPlayer.IsDestroyed) npcPlayer.Kill(BaseNetworkable.DestroyMode.Gib);
            }
        }

        private void ProcessNPCTurret(NPCAutoTurret npcAutoTurret)
        {
            npcAutoTurret.SetFlag(NPCAutoTurret.Flags.On, !configData.General.disableCompoundTurrets, !configData.General.disableCompoundTurrets);
            npcAutoTurret.UpdateNetworkGroup();
            npcAutoTurret.SendNetworkUpdateImmediate();
        }

        private void AddVendingOrders(NPCVendingMachine vending, bool def = false)
        {
            if (vending == null || vending.IsDestroyed)
            {
                Puts("Null or destroyed machine...");
                return;
            }
            if (!def)
            {
                if (data.VendingMachinesOrders.ContainsKey(vending.vendingOrders.name))
                {
                    return;
                }
            }
            List<Order> orders = new List<Order>();
            foreach (var order in vending.vendingOrders.orders)
            {
                orders.Add(new Order
                {
                    _comment = $"Sell {order.sellItem.displayName.english} x {order.sellItemAmount} for {order.currencyItem.displayName.english} x {order.currencyAmount}",
                    sellAmount = order.currencyAmount,
                    currencyAmount = order.sellItemAmount,
                    sellId = order.sellItem.itemid,
                    sellAsBP = order.sellItemAsBP,
                    currencyId = order.currencyItem.itemid,
                    weight = 100,
                    refillAmount = 100000,
                    refillDelay = 0.0f
                });
            }
            if (def)
            {
                if (orders == null) return;

                if (configData.General.allowConsoleOutput)
                    Puts($"Trying to save default vendingOrders for {vending.vendingOrders.name}");

                if (defaultOrders == null) defaultOrders = new StorageData();
                if (defaultOrders.VendingMachinesOrders.ContainsKey(vending.vendingOrders.name)) return;
                defaultOrders.VendingMachinesOrders.Add(vending.vendingOrders.name, orders.ToArray());
            }
            else
            {
                data.VendingMachinesOrders.Add(vending.vendingOrders.name, orders.ToArray());
            }
            if (configData.General.allowConsoleOutput)
                Puts($"Added Vending Machine: {vending.vendingOrders.name} to data file!");
            dataChanged = true;
        }

        private void UpdateVending(NPCVendingMachine vending)
        {
            if (vending == null || vending.IsDestroyed)
            {
                return;
            }

            AddVendingOrders(vending);
            NextTick(() =>
            {
                vending.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                vending.SendNetworkUpdateImmediate();
            });

            if (configData.General.disableCompoundVendingMachines)
            {
                vending.ClearSellOrders();
                vending.inventory.Clear();
            }
            else if (configData.General.allowCustomCompoundVendingMachines)
            {
                vending.vendingOrders.orders = GetNewOrders(vending);
                vending.InstallFromVendingOrders();
            }
        }

        private NPCVendingOrder.Entry[] GetDefaultOrders(NPCVendingMachine vending)
        {
            List<NPCVendingOrder.Entry> temp = new List<NPCVendingOrder.Entry>();
            foreach (var order in defaultOrders.VendingMachinesOrders[vending.vendingOrders.name])
            {
                temp.Add(new NPCVendingOrder.Entry
                {
                    currencyAmount = order.sellAmount,
                    currencyAsBP = order.currencyAsBP,
                    currencyItem = ItemManager.FindItemDefinition(order.currencyId),
                    sellItem = ItemManager.FindItemDefinition(order.sellId),
                    sellItemAmount = order.currencyAmount,
                    sellItemAsBP = order.sellAsBP,
                    weight = 100,
                    refillAmount = 100000,
                    refillDelay = 0.0f
                });
            }
            return temp.ToArray();
        }

        private NPCVendingOrder.Entry[] GetNewOrders(NPCVendingMachine vending)
        {
            List<NPCVendingOrder.Entry> temp = new List<NPCVendingOrder.Entry>();
            foreach (var order in data.VendingMachinesOrders[vending.vendingOrders.name])
            {
                ItemDefinition currencyItem = ItemManager.FindItemDefinition(order.currencyId);
                if (currencyItem == null)
                {
                    PrintError($"Item id {order.currencyId} is invalid. Skipping sell order.");
                    continue;
                }

                ItemDefinition sellItem = ItemManager.FindItemDefinition(order.sellId);
                if (sellItem == null)
                {
                    PrintError($"Item id {order.sellId} is invalid. Skipping sell order.");
                    continue;
                }

                temp.Add(new NPCVendingOrder.Entry
                {
                    currencyAmount = order.sellAmount,
                    currencyAsBP = order.currencyAsBP,
                    currencyItem = currencyItem,
                    sellItem = sellItem,
                    sellItemAmount = order.currencyAmount,
                    sellItemAsBP = order.sellAsBP,
                    weight = 100,
                    refillAmount = 100000,
                    refillDelay = 0.0f
                });
            }
            return temp.ToArray();
        }
        #endregion       

        #region Commmands
        [ChatCommand("compreset")]
        private void cmdCompReset(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin)
            {
                SendReply(player, "You doesn't have permission to that!");
                return;
            }

            Interface.Oxide.ReloadPlugin(Name);
        }

        [ConsoleCommand("compreset")]
        private void ccmdCompReset(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null)
                return;

            if (arg.IsAdmin == false)
            {
                Puts("You doesn't have permission to that!");
                return;
            }

            Interface.Oxide.ReloadPlugin(Name);
        }
        #endregion

        #region Save data classes
        private class StorageData
        {
            public Dictionary<string, Order[]> VendingMachinesOrders { get; set; }
        }

        private class Order
        {
            public string _comment;
            public int sellId;
            public int sellAmount;
            public bool sellAsBP;
            public int currencyId;
            public int currencyAmount;
            public bool currencyAsBP;
            public int weight;
            public int refillAmount;
            public float refillDelay;
        }
        private void SaveData()
        {
            if (dataChanged)
            {
                Interface.Oxide.DataFileSystem.WriteObject(Name, data);
                Interface.Oxide.DataFileSystem.WriteObject(Name + "_default", defaultOrders);
                dataChanged = false;
            }
        }

        #endregion

        #region Config
        private static ConfigData configData;
        class ConfigData
        {
            [JsonProperty(PropertyName = "General Settings")]
            public GeneralSettings General { get; set; }

            public class GeneralSettings
            {
                [JsonProperty(PropertyName = "Allow console status outputs")]
                public bool allowConsoleOutput { get; set; }
                [JsonProperty(PropertyName = "Allow custom sell list for Compound vending machines (see in data)")]
                public bool allowCustomCompoundVendingMachines { get; set; }
                [JsonProperty(PropertyName = "Disallow Bandit NPC")]
                public bool disallowBanditNPC { get; set; }
                [JsonProperty(PropertyName = "Disallow Compound NPC")]
                public bool disallowCompoundNPC { get; set; }
                [JsonProperty(PropertyName = "Disable Compound Turrets")]
                public bool disableCompoundTurrets { get; set; }
                [JsonProperty(PropertyName = "Disable Compound SafeZone trigger")]
                public bool disableCompoundTrigger { get; set; }
                [JsonProperty(PropertyName = "Disable Compound Vending Machines")]
                public bool disableCompoundVendingMachines { get; set; }
            }

            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();

            if (configData.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();
        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                General = new ConfigData.GeneralSettings
                {
                    allowConsoleOutput = true,
                    allowCustomCompoundVendingMachines = true,
                    disallowBanditNPC = false,
                    disallowCompoundNPC = false,
                    disableCompoundTurrets = false,
                    disableCompoundTrigger = false,
                    disableCompoundVendingMachines = false
                },
                Version = Version
            };
        }
        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();
            if (configData.Version < new Core.VersionNumber(1, 2, 5))
            {
                configData = baseConfig;
            }

            configData.Version = Version;
            PrintWarning("Config update completed!");
        }
        #endregion
    }
}

// --- End of file: CompoundOptions.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/AdminMenu.cs ---
// --- Original Local Path: BeeRust/AdminMenu.cs ---

using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Ext.Chaos;
using Oxide.Core.Plugins;
using UnityEngine;
using System.Linq;
using System.Globalization;
using Newtonsoft.Json.Converters;
using Oxide.Core.Libraries.Covalence;
using Oxide.Ext.Chaos.Data;
using Oxide.Ext.Chaos.UIFramework;
using UnityEngine.UI;

using Chaos = Oxide.Ext.Chaos;
using Color = Oxide.Ext.Chaos.UIFramework.Color;
using GridLayoutGroup = Oxide.Ext.Chaos.UIFramework.GridLayoutGroup;
using HorizontalLayoutGroup = Oxide.Ext.Chaos.UIFramework.HorizontalLayoutGroup;
using VerticalLayoutGroup = Oxide.Ext.Chaos.UIFramework.VerticalLayoutGroup;

///Скачано с дискорд сервера Rust Edit [PRO+]
///discord.gg/9vyTXsJyKR

namespace Oxide.Plugins
{
    [Info("AdminMenu", "123", "2.0.10")]
    class AdminMenu : ChaosPlugin
    {
	    private Datafile<RecentPlayers> m_RecentPlayers;

	    private CommandCallbackHandler m_CallbackHandler;
        
	    private readonly Hash<ulong, UIUser> m_UIUsers = new Hash<ulong, UIUser>();
	    private readonly List<KeyValuePair<string, bool>> m_Permissions = new List<KeyValuePair<string, bool>>();
	    
	    private readonly string[] m_IgnoreItems = new string[] { "ammo.snowballgun", "blueprintbase", "rhib", "spraycandecal", "vehicle.chassis", "vehicle.module", "water", "water.salt" };

        [Chaos.Permission] private const string USE_PERMISSION = "adminmenu.userpopass";
        [Chaos.Permission] private const string PERM_PERMISSION = "adminmenu.userpopassssss";
        [Chaos.Permission] private const string GROUP_PERMISSION = "adminmenu.userpopassssss";
        [Chaos.Permission] private const string CONVAR_PERMISSION = "adminmenu.userpopass";

        [Chaos.Permission] private const string GIVE_PERMISSION = "adminmenu.userpopass";
        [Chaos.Permission] private const string GIVE_SELF_PERMISSION = "adminmenu.userpopass";
        [Chaos.Permission] private const string PLAYER_PERMISSION = "adminmenu.userpopass";

        [Chaos.Permission] private const string PLAYER_KICKBAN_PERMISSION = "adminmenu.userpopass";
        [Chaos.Permission] private const string PLAYER_MUTE_PERMISSION = "adminmenu.userpopass";
        [Chaos.Permission] private const string PLAYER_BLUERPRINTS_PERMISSION = "adminmenu.userpopass";
        [Chaos.Permission] private const string PLAYER_HURT_PERMISSION = "adminmenu.userpopass";
        [Chaos.Permission] private const string PLAYER_HEAL_PERMISSION = "adminmenu.userpopass";
        [Chaos.Permission] private const string PLAYER_KILL_PERMISSION = "adminmenu.userpopass";
        [Chaos.Permission] private const string PLAYER_STRIP_PERMISSION = "adminmenu.userpopass";
        [Chaos.Permission] private const string PLAYER_TELEPORT_PERMISSION = "adminmenu.userpopass";

        #region Oxide Hooks
        private void Init()
	    {
		    m_MenuTypes = (MenuType[])Enum.GetValues(typeof(MenuType));
		    m_PermissionSubTypes = (int[])Enum.GetValues(typeof(PermissionSubType));
		    m_GroupSubTypes = (int[])Enum.GetValues(typeof(GroupSubType));
		    m_CommandSubTypes = (int[]) Enum.GetValues(typeof(CommandSubType));
		    
		    m_RecentPlayers = new Datafile<RecentPlayers>("AdminMenu/recent_players");
		    m_RecentPlayers.Data.PurgeCollection();

		    m_CallbackHandler = new CommandCallbackHandler(this);

		    SetupPlayerActions();
		    
		    cmd.AddChatCommand("penisslonika", this, ((player, command, args) =>
		    {
			    if (!permission.UserHasPermission(player.UserIDString, USE_PERMISSION))
			    {
				    player.LocalizedMessage(this, "Error.NoPermission");
				    return;
			    }
			    
			    BaseContainer root = BaseContainer.Create(ADMINMENU_MOUSE, Layer.Hud, Anchor.Center, Offset.Default)
				    .NeedsCursor()
				    .NeedsKeyboard();
			    
			    ChaosUI.Show(player, root);
			    CreateAdminMenu(player);
		    }));
	    }

	    private void OnServerInitialized()
	    {
		    List<string> commandPermissions = Facepunch.Pool.GetList<string>();
		    
		    commandPermissions.AddRange(Configuration.ChatCommands.Select(x => x.RequiredPermission));
		    commandPermissions.AddRange(Configuration.ConsoleCommands.Select(x => x.RequiredPermission));
		    Configuration.PlayerInfoCommands.ForEach(customCommand => commandPermissions.AddRange(customCommand.Commands.Select(x => x.RequiredPermission)));

		    foreach (string perm in commandPermissions)
		    {
			    if (!string.IsNullOrEmpty(perm) && perm.StartsWith("adminmenu.", StringComparison.OrdinalIgnoreCase))
				    permission.RegisterPermission(perm, this);
		    }
		    
		    Facepunch.Pool.FreeList(ref commandPermissions);
		    
		    if (ImageLibrary.IsLoaded)
		    {
			    ImageLibrary.AddImage("https://chaoscode.io/oxide/Images/magnifyingglass.png", "adminmenu.search", 0UL, () =>
			    {
				    m_MagnifyImage = ImageLibrary.GetImage("adminmenu.search", 0UL);
			    });
		    }

		    m_ItemDefinitionsPerCategory = new Hash<ItemCategory, List<ItemDefinition>>();
		    foreach (ItemDefinition itemDefinition in ItemManager.itemList)
		    {
			    if (m_IgnoreItems.Contains(itemDefinition.shortname))
				    continue;
			    
			    List<ItemDefinition> list;
			    if (!m_ItemDefinitionsPerCategory.TryGetValue(itemDefinition.category, out list))
				    list = m_ItemDefinitionsPerCategory[itemDefinition.category] = new List<ItemDefinition>();
			    
			    list.Add(itemDefinition);

			    m_AllItemDefinitions.Add(itemDefinition);
		    }

		    foreach (KeyValuePair<ItemCategory, List<ItemDefinition>> kvp in m_ItemDefinitionsPerCategory)
			    kvp.Value.Sort(((a, b) => a.displayName.english.CompareTo(b.displayName.english)));
	    }
	    
	    private void OnPermissionRegistered(string name, Plugin owner) => UpdatePermissionList();

	    private void OnPluginUnloaded(Plugin plugin) => UpdatePermissionList();

	    private void OnPlayerConnected(BasePlayer player) => m_RecentPlayers.Data.OnPlayerConnected(player);
	    
	    private void OnPlayerDisconnected(BasePlayer player)
	    {
		    m_RecentPlayers.Data.OnPlayerDisconnected(player);
		    
		    ChaosUI.Destroy(player, ADMINMENU_MOUSE);
		    ChaosUI.Destroy(player, ADMINMENU_UI);
		    ChaosUI.Destroy(player, ADMINMENU_UI_POPUP);

		    m_UIUsers.Remove(player.userID);
	    }

	    private void OnServerSave() => m_RecentPlayers.Save();

	    private void Unload()
	    {
		    foreach (BasePlayer player in BasePlayer.activePlayerList)
			    OnPlayerDisconnected(player);
	    }
	    #endregion
	    
	    #region Functions
	    private void UpdatePermissionList()
	    {
		    m_Permissions.Clear();

		    List<string> permissions = Facepunch.Pool.GetList<string>();
		    List<Plugin> plugin = Facepunch.Pool.GetList<Plugin>();
		    
		    permissions.AddRange(permission.GetPermissions());
		    permissions.RemoveAll(x => x.ToLower().StartsWith("oxide."));
		    permissions.Sort();
		    
		    plugin.AddRange(plugins.PluginManager.GetPlugins());
		    
		    string lastName = string.Empty;
		    foreach (string perm in permissions)
		    {
			    string name;
			    if (perm.Contains("."))
			    {
				    string permStart = perm.Substring(0, perm.IndexOf("."));
				    name = plugin.Find(x => x?.Name?.ToLower() == permStart)?.Title ?? permStart;
			    }
			    else name = perm;
			    
			    if (lastName != name)
			    {
				    m_Permissions.Add(new KeyValuePair<string, bool>(name, false));
				    lastName = name;
			    }

			    m_Permissions.Add(new KeyValuePair<string, bool>(perm, true));
		    }
		    
		    Facepunch.Pool.FreeList(ref permissions);
		    Facepunch.Pool.FreeList(ref plugin);
	    }

	    private bool HasPermissionForMenuType(BasePlayer player, MenuType menuType)
	    {
		    switch (menuType)
		    {
			    case MenuType.Commands:
				    return true;
			    case MenuType.Permissions:
				    return player.HasPermission(PERM_PERMISSION);
			    case MenuType.Groups:
				    return player.HasPermission(GROUP_PERMISSION);
			    case MenuType.Convars:
				    return player.HasPermission(CONVAR_PERMISSION);
			    case MenuType.Give:
				    return player.HasPermission(GIVE_PERMISSION);
		    }

		    return false;
	    }

	    private bool HasPermissionForSubMenu(BasePlayer player, MenuType menuType, int subMenuIndex)
	    {
		    if (menuType == MenuType.Commands)
		    {
			    if (subMenuIndex == (int) CommandSubType.PlayerInfo)
				    return player.HasPermission(PLAYER_PERMISSION);
		    }

		    return true;
	    }

	    private bool UserHasPermissionNoGroup(string playerId, string perm)
	    {
		    if (string.IsNullOrEmpty(perm))
			    return false;
		    
		    Core.Libraries.UserData userData = permission.GetUserData(playerId);
		    
		    return userData != null && userData.Perms.Contains(perm, StringComparer.OrdinalIgnoreCase);
	    }

	    private bool UsersGroupsHavePermission(string playerId, string perm)
	    {
		    if (string.IsNullOrEmpty(perm))
			    return false;
		    
		    Core.Libraries.UserData userData = permission.GetUserData(playerId);
		    
		    return userData != null && permission.GroupsHavePermission(userData.Groups, perm);
	    }
	    #endregion
	    
	    #region Types
	    protected enum MenuType { Commands, Permissions, Groups, Convars, Give }

	    protected enum PermissionSubType { Player, Group }
	    
	    [JsonConverter(typeof(StringEnumConverter))]
	    protected enum CommandSubType { Chat, Console, PlayerInfo }
	    
	    protected enum GroupSubType { List, Create, UserGroups, GroupUsers }
	    #endregion
	    
	    #region Localization
	    protected override void PopulatePhrases()
	    {
		    m_Messages = new Dictionary<string, string>
		    {
			    ["Button.Exit"] = "Exit",
			    ["Button.Give"] = "Give",
			    ["Button.Cancel"] = "Cancel",
			    ["Button.Confirm"] = "Confirm",
			    ["Button.Create"] = "Create",
			    ["Button.Delete"] = "Delete",
			    ["Button.Clone"] = "Clone",
			    ["Button.Remove"] = "Remove",
			    
			    ["Label.Amount"] = "Amount",
			    ["Label.SkinID"] = "Skin ID",
			    ["Label.InheritedPermission"] = "Inherited from group",
			    ["Label.DirectPermission"] = "Has direct permission",
			    ["Label.TogglePermission"] = "Toggle permissions for : {0}",
			    ["Label.ToggleGroup"] = "Toggle groups for : {0}",
			    ["Label.SelectPlayer"] = "Select a player",
			    ["Label.SelectPlayer1"] = "Select player for first argument",
			    ["Label.SelectPlayer2"] = "Select player for second argument",
			    ["Label.SelectGroup"] = "Select a usergroup",
			    ["Label.Reason"] = "Reason",
			    ["Label.Kick"] = "Do you want to kick {0}?",
			    ["Label.Ban"] = "Do you want to ban {0}?",
			    ["Label.CreateUsergroup"] = "Create Usergroup",
			    ["Label.CloneUsergroup"] = "Clone Usergroup from {0}",
			    ["Label.Name"] = "Name",
			    ["Label.Title"] = "Title (optional)",
			    ["Label.Rank"] = "Rank (optional)",
			    ["Label.CopyUsers"] = "Copy Users",
			    ["Label.DeleteConfirm"] = "Are you sure you want to delete {0}?",
			    ["Label.ViewGroups"] = "Viewing Oxide user groups",
			    ["Label.GiveToPlayer"] = "Select a item to give to {0}",
			    ["Label.ViewGroupUsers"] = "Viewing users in group {0}",
			    ["Label.OfflinePlayers"] = "Offline Players",
			    ["Label.OnlinePlayers"] = "Online Players",
			    
			    ["Notification.RunCommand"] = "You have run the command : {0}",
			    ["Notification.Give.Success"] = "You have given {0} {1} x {2}",

			    ["PlayerInfo.Info"] = "Player Information",
			    ["PlayerInfo.Actions"] = "Actions",
			    ["PlayerInfo.CustomActions"] = "Custom Actions",
			    ["PlayerInfo.Name"] = "Name : {0}",
		        ["PlayerInfo.ID"] = "ID : {0}",
		        ["PlayerInfo.Auth"] = "Auth Level : {0}",
		        ["PlayerInfo.Status"] = "Status : {0}",
		        ["PlayerInfo.Position"] = "World Position : {0}",
		        ["PlayerInfo.Grid"] = "Grid Location : {0}",
		        ["PlayerInfo.Health"] = "Health : {0}",
		        ["PlayerInfo.Calories"] = "Calories : {0}",
		        ["PlayerInfo.Hydration"] = "Hydration : {0}",
		        ["PlayerInfo.Temperature"] = "Temperature : {0}",
		        ["PlayerInfo.Comfort"] = "Comfort : {0}",
		        ["PlayerInfo.Wetness"] = "Wetness : {0}",
		        ["PlayerInfo.Bleeding"] = "Bleeding : {0}",
		        ["PlayerInfo.Radiation"] = "Radiation : {0}",
		        ["PlayerInfo.Clan"] = "Clan : {0}",
		        ["PlayerInfo.Playtime"] = "Playtime : {0}",
		        ["PlayerInfo.AFKTime"] = "AFK Time : {0}",
		        ["PlayerInfo.IdleTime"] = "Idle Time : {0}",
		        ["PlayerInfo.ServerRewards"] = "RP : {0}",
		        ["PlayerInfo.Economics"] = "Economics : {0}",
		        ["Action.Kick"] = "Kick",
				["Action.Ban"] = "Ban",
				["Action.StripInventory"] = "Strip Inventory",
				["Action.ResetMetabolism"] = "Reset Metabolism",
				["Action.GiveBlueprints"] = "Unlock Blueprints",
				["Action.RevokeBlueprints"] = "Revoke Blueprints",
				["Action.Mute"] = "Mute Chat",
				["Action.Unmute"] = "Unmute Chat",
				["Action.Hurt25"] = "Hurt 25%",
				["Action.Hurt50"] = "Hurt 50%",
				["Action.Hurt75"] = "Hurt 75%",
				["Action.Kill"] = "Kill",
				["Action.Heal25"] = "Heal 25%",
				["Action.Heal50"] = "Heal 50%",
				["Action.Heal75"] = "Heal 75%",
				["Action.Heal100"] = "Heal 100%",
				["Action.TeleportSelfTo"] = "Teleport Self To",
				["Action.TeleportToSelf"] = "Teleport To Self",
				["Action.ViewPermissions"] = "View Permissions",
				["Action.TeleportAuthedItem"] = "Teleport Authed Item",
				["Action.TeleportOwnedItem"] = "Teleport Owned Item",

				["Action.StripInventory.Success"] = "{0}'s inventory was stripped",
				["Action.ResetMetabolism.Success"] = "{0}'s metabolism was reset",
				["Action.GiveBlueprints.Success"] = "Unlocked all blueprints for {0}",
				["Action.RevokeBlueprints.Success"] = "Revoked all blueprints for {0}",
				["Action.Mute.Success"] = "{0} is now chat muted",
				["Action.Unmute.Success"] = "{0} chat mute has been lifted",
				["Action.Hurt25.Success"] = "{0}'s health has been reduced by 25%",
				["Action.Hurt50.Success"] = "{0}'s health has been reduced by 50%",
				["Action.Hurt75.Success"] = "{0}'s health has been reduced by 75%",
				["Action.Kill.Success"] = "You have killed {0}",
				["Action.Heal25.Success"] = "{0}'s health has been restored 25%",
				["Action.Heal50.Success"] = "{0}'s health has been restored 50%",
				["Action.Heal75.Success"] = "{0}'s health has been restored 75%",
				["Action.Heal100.Success"] = "{0}'s health has been restored 100%",
				["Action.TeleportSelfTo.Success"] = "Teleported to {0}",
				["Action.TeleportToSelf.Success"] = "Teleported {0} to you",
				["Action.TeleportAuthedItem.Success"] = "Teleported to {0} at {1}",
				["Action.TeleportOwnedItem.Success"] = "Teleported to {0} at {1}",

				["Action.StripInventory.Failed"] = "Failed to strip {0}'s inventory. They may be dead or not on the server",
				["Action.ResetMetabolism.Failed"] = "Failed to reset {0}'s metabolism. They may be dead or not on the server",
				["Action.GiveBlueprints.Failed"] = "Failed to unlock all blueprints for {0}. They may be dead or not on the server",
				["Action.RevokeBlueprints.Failed"] = "Failed to revoked all blueprints for {0}. They may be dead or not on the server",
				["Action.Mute.Failed"] = "Failed to mute chat for {0}. They may be dead or not on the server",
				["Action.Unmute.Failed"] = "Failed to unmute chat for {0}. They may be dead or not on the server",
				["Action.Hurt25.Failed"] = "Failed to reduce {0}'s health. They may be dead or not on the server",
				["Action.Hurt50.Failed"] = "Failed to reduce {0}'s health. They may be dead or not on the server",
				["Action.Hurt75.Failed"] = "Failed to reduce {0}'s health. They may be dead or not on the serverFailed to reduce {0}'s health. They may be dead or not on the server",
				["Action.Kill.Failed"] = "Failed to kill {0}. They may be dead or not on the server",
				["Action.Heal25.Failed"] = "Failed to heal {0}. They may be dead or not on the server",
				["Action.Heal50.Failed"] = "Failed to heal {0}. They may be dead or not on the server",
				["Action.Heal75.Failed"] = "Failed to heal {0}. They may be dead or not on the server",
				["Action.Heal100.Failed"] = "Failed to heal {0}. They may be dead or not on the server",
				["Action.TeleportSelfTo.Failed"] = "Failed to teleport to {0}. They may be dead or not on the server",
				["Action.TeleportToSelf.Failed"] = "Failed to teleport {0} to you. They may be dead or not on the server",
				["Action.TeleportAuthedItem.Failed"] = "Failed to teleport to authed item. The target player may be dead or not on the server",
				["Action.TeleportOwnedItem.Failed"] = "Failed to teleport to owned item. The target player may be dead or not on the server",
				
				["Action.TeleportAuthedItem.Failed.Entities"] = "No entities found for player",
				["Action.TeleportOwnedItem.Failed.Entities"] = "No entities found for player",
				
				["Error.NoPermission"] = "хуя от куда коману узнал?? (там еще пермсы поменяны)"
		    };

		    MenuType[] menuTypes = (MenuType[])Enum.GetValues(typeof(MenuType));
		    for (int i = 0; i < menuTypes.Length; i++)
		    {
			    MenuType menuType = menuTypes[i];
			    m_Messages[$"Category.{menuType}"] = menuType.ToString();
		    }

		    PermissionSubType[] permissionTypes = (PermissionSubType[])Enum.GetValues(typeof(PermissionSubType));
		    for (int i = 0; i < permissionTypes.Length; i++)
		    {
			    PermissionSubType index = permissionTypes[i];
			    m_Messages[$"Permissions.{(int)index}"] = index.ToString();
		    }
		    
		    CommandSubType[] commandTypes = (CommandSubType[])Enum.GetValues(typeof(CommandSubType));
		    for (int i = 0; i < commandTypes.Length; i++)
		    {
			    CommandSubType index = commandTypes[i];
			    m_Messages[$"Commands.{(int)index}"] = index.ToString();
		    }
		    m_Messages[$"Commands.{(int)CommandSubType.PlayerInfo}"] = "Player Info";

		    GroupSubType[] groupTypes = (GroupSubType[])Enum.GetValues(typeof(GroupSubType));
		    for (int i = 0; i < groupTypes.Length; i++)
		    {
			    GroupSubType index = groupTypes[i];
			    m_Messages[$"Groups.{(int)index}"] = index.ToString();
		    }
		    m_Messages[$"Groups.{(int)GroupSubType.UserGroups}"] = "User Groups";
		    m_Messages[$"Groups.{(int)GroupSubType.GroupUsers}"] = "Group Users";
		    
		    ItemCategory[] itemCategories = (ItemCategory[])Enum.GetValues(typeof(ItemCategory));
		    for (int i = 0; i < itemCategories.Length; i++)
		    {
			    ItemCategory index = itemCategories[i];
			    m_Messages[$"Give.{(int)index}"] = index.ToString();
		    }
	    }
	    #endregion
	    
        #region UI
        private string[] m_CharacterFilter = new string[] { "~", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z" };

        private string m_MagnifyImage;
        
        private MenuType[] m_MenuTypes;
        private int[] m_PermissionSubTypes;
        private int[] m_GroupSubTypes;
        private int[] m_CommandSubTypes;
        private int[] m_ItemCategoryTypes = new int[] {(int) ItemCategory.Weapon, (int) ItemCategory.Construction, (int)ItemCategory.Items, (int)ItemCategory.Resources, (int)ItemCategory.Attire, (int)ItemCategory.Tool, (int)ItemCategory.Medical, (int)ItemCategory.Food, (int)ItemCategory.Ammunition, (int)ItemCategory.Traps, (int)ItemCategory.Misc, (int)ItemCategory.Component, (int)ItemCategory.Electrical, (int)ItemCategory.Fun};

        private readonly List<ItemDefinition> m_AllItemDefinitions = new List<ItemDefinition>();
        private Hash<ItemCategory, List<ItemDefinition>> m_ItemDefinitionsPerCategory;
        
        private const string ADMINMENU_MOUSE = "adminmenu.ui.mouse";
        private const string ADMINMENU_UI = "adminmenu.ui";
        private const string ADMINMENU_UI_POPUP = "adminmenu.ui.popup";
        
        #region Outline Components
        private OutlineComponent m_OutlineGreen = new OutlineComponent(new Color(0.7695657f, 1f, 0f, 1f));
        private OutlineComponent m_OutlineBlue = new OutlineComponent(new Color(0f, 0.5590005f, 1f, 1f));
        private OutlineComponent m_OutlineRed = new OutlineComponent(new Color(0.8078431f, 0.2588235f, 0.1686275f, 1f));
        private OutlineComponent m_OutlineWhite = new OutlineComponent(new Color(0.1647059f, 0.1803922f, 0.1921569f, 1f));
		#endregion
		
        #region Styles
        private Style m_BackgroundStyle = new Style
        {
	        ImageColor = new Color(0.08235294f, 0.08235294f, 0.08235294f, 0.9490196f),
	        Sprite = Sprites.Background_Rounded,
	        Material = Materials.BackgroundBlur,
	        ImageType = Image.Type.Tiled
        };
        
        private Style m_ButtonStyle = new Style
        {
	        ImageColor = new Color(0.1647059f, 0.1803922f, 0.1921569f, 1f),
	        Sprite = Sprites.Background_Rounded,
	        ImageType = Image.Type.Tiled,
	        Alignment = TextAnchor.MiddleCenter
        };
        
        private Style m_DisabledButtonStyle = new Style
        {
	        ImageColor = new Color(0.1647059f, 0.1803922f, 0.1921569f, 0.8f),
	        Sprite = Sprites.Background_Rounded,
	        ImageType = Image.Type.Tiled,
	        FontColor = new Color(1f, 1f, 1f, 0.2f),
	        Alignment = TextAnchor.MiddleCenter
        };

        private Style m_PermissionStyle = new Style
        {
	        ImageColor = new Color(0.1647059f, 0.1803922f, 0.1921569f, 1f),
	        Sprite = Sprites.Background_Rounded,
	        ImageType = Image.Type.Tiled,
	        FontSize = 12,
	        Alignment = TextAnchor.MiddleCenter
        };
        
        private Style m_PermissionHeaderStyle = new Style
        {
	        ImageColor = new Color(0.8117647f, 0.8117647f, 0.8117647f, 0.8f),
	        Sprite = Sprites.Background_Rounded,
	        ImageType = Image.Type.Tiled,
	        FontColor = new Color(0.1647059f, 0.1803922f, 0.1921569f, 1f),
	        FontSize = 14,
	        Alignment = TextAnchor.MiddleCenter,
        };

        private Style m_ConvarStyle = new Style
        {
	        ImageColor = new Color(1f, 1f, 1f, 0.172549f),
	        Sprite = Sprites.Background_Rounded,
	        ImageType = Image.Type.Tiled
        };

        private Style m_ConvarDescriptionStyle = new Style
        {
	        FontColor = new Color(0.745283f, 0.745283f, 0.745283f, 1f),
	        FontSize = 10,
	        Alignment = TextAnchor.LowerLeft
        };
        
        private Style m_PanelStyle = new Style
        {
	        ImageColor = new Color(1f, 1f, 1f, 0.1647059f),
	        Sprite = Sprites.Background_Rounded,
	        ImageType = Image.Type.Tiled
        };
        
        private Style m_ToggleLabelStyle = new Style
        {
	        FontSize = 40,
	        Alignment = TextAnchor.MiddleCenter,
	        WrapMode = VerticalWrapMode.Overflow,
	        FontColor = new Color(0.7695657f, 1f, 0f, 1f)
        };
        
        private Style m_GroupDeleteButton = new Style
        {
	        ImageColor = new Color(0.8078431f, 0.2588235f, 0.1686275f, 0.5254902f),
	        Sprite = Sprites.Background_Rounded,
	        ImageType = Image.Type.Tiled
        };
						
        private Style m_GroupCloneButton = new Style
        {
	        ImageColor = new Color(0.7695657f, 1f, 0f, 0.4196078f),
	        Sprite = Sprites.Background_Rounded,
	        ImageType = Image.Type.Tiled
        };
        #endregion
        
        #region Layout Groups
        private HorizontalLayoutGroup m_CategoryLayout = new HorizontalLayoutGroup()
        {
	        Area = new Area(-535f, -15f, 535f, 15f),
	        Spacing = new Spacing(5f, 0f),
	        Padding = new Padding(0f, 0f, 0f, 0f),
	        Corner = Corner.Centered,
	        FixedSize = new Vector2(100, 20),
	        FixedCount = new Vector2Int(5, 0)
        };
        
        private HorizontalLayoutGroup m_SubLayoutGroup = new HorizontalLayoutGroup()
        {
	        Area = new Area(-535f, -12.5f, 535f, 12.5f),
	        Spacing = new Spacing(5f, 5f),
	        Padding = new Padding(0f, 0f, 0f, 0f),
	        Corner = Corner.Centered,
	        FixedSize = new Vector2(71.5f, 20),
        };

        private readonly GridLayoutGroup m_ListLayout = new GridLayoutGroup(5, 15, Axis.Vertical)
        {
	        Area = new Area(-522.5f, -257.5f, 522.5f, 257.5f),
	        Spacing = new Spacing(5f, 5f),
	        Padding = new Padding(5f, 5f, 5f, 5f),
	        Corner = Corner.TopLeft,
        };

        private readonly GridLayoutGroup m_ConvarLayout = new GridLayoutGroup(3, 15, Axis.Vertical)
        {
	        Area = new Area(-522.5f, -257.5f, 522.5f, 257.5f),
	        Spacing = new Spacing(5f, 5f),
	        Padding = new Padding(5f, 5f, 5f, 5f),
	        Corner = Corner.TopLeft,
        };
        
        private GridLayoutGroup m_CommandLayoutGroup = new GridLayoutGroup(5, 13, Axis.Horizontal)
        {
	        Area = new Area(-535f, -272.5f, 535f, 272.5f),
	        Spacing = new Spacing(5f, 5f),
	        Padding = new Padding(5f, 5f, 5f, 5f),
	        Corner = Corner.TopLeft,
        };

        private GridLayoutGroup m_GiveLayoutGroup = new GridLayoutGroup(Axis.Horizontal)
        {
	        Area = new Area(-522.5f, -257.5f, 522.5f, 257.5f),
	        Spacing = new Spacing(5f, 5f),
	        Padding = new Padding(5f, 5f, 5f, 5f),
	        Corner = Corner.TopLeft,
	        FixedSize = new Vector2(125, 97),
	        FixedCount = new Vector2Int(8, 5),
        };
        
        private VerticalLayoutGroup m_CharacterFilterLayout = new VerticalLayoutGroup
        {
	        Area = new Area(-10f, -257.5f, 10f, 257.5f),
	        Spacing = new Spacing(0f, 3f),
	        Padding = new Padding(2f, 2f, 2f, 2f),
	        Corner = Corner.TopLeft,
	        FixedSize = new Vector2(16, 16),
	        FixedCount = new Vector2Int(1, 27)
        };
        
        private VerticalLayoutGroup m_PlayerInfoLayout = new VerticalLayoutGroup(24)
        {
	        Area = new Area(-100f, -257.5f, 100f, 257.5f),
	        Spacing = new Spacing(0f, 0f),
	        Padding = new Padding(5f, 5f, 5f, 5f),
	        Corner = Corner.TopLeft,
        };

        private GridLayoutGroup m_GroupViewLayout = new GridLayoutGroup(4, 15, Axis.Horizontal)
        {
	        Area = new Area(-522.5f, -257.5f, 522.5f, 257.5f),
	        Spacing = new Spacing(5f, 5f),
	        Padding = new Padding(5f, 5f, 5f, 5f),
	        Corner = Corner.TopLeft,
        };

        private VerticalLayoutGroup m_PluginActionsLayout = new VerticalLayoutGroup(19)
        {
	        Area = new Area(-287.5f, -257.5f, 287.5f, 257.5f),
	        Spacing = new Spacing(5f, 5f),
	        Padding = new Padding(5f, 5f, 5f, 5f),
	        Corner = Corner.TopLeft,
        };

        private VerticalLayoutGroup m_CustomActionsLayout = new VerticalLayoutGroup(19)
        {
	        Area = new Area(-142.5f, -257.5f, 142.5f, 257.5f),
	        Spacing = new Spacing(0f, 5f),
	        Padding = new Padding(5f, 5f, 5f, 5f),
	        Corner = Corner.TopLeft,
        };

        private HorizontalLayoutGroup m_InternalPluginActionsLayout = new HorizontalLayoutGroup(6)
        {
	        Area = new Area(-427.5f, -10.92105f, 427.5f, 10.92105f),
	        Spacing = new Spacing(5f, 0f),
	        Padding = new Padding(0f, 0f, 0f, 0f),
	        Corner = Corner.TopLeft,
        };

        private HorizontalLayoutGroup m_InternalCustomActionsLayout = new HorizontalLayoutGroup(2)
        {
	        Area = new Area(-137.5f, -10.92105f, 137.5f, 10.92105f),
	        Spacing = new Spacing(5f, 0f),
	        Padding = new Padding(0f, 0f, 0f, 0f),
	        Corner = Corner.TopLeft,
        };
		#endregion

		#region UI User
		private class UIUser
        {
	        public readonly BasePlayer Player;
	        
	        public MenuType MenuIndex = MenuType.Commands;
	        public int SubMenuIndex = 0;
		    
	        public string SearchFilter = string.Empty;
	        public string CharacterFilter = "~";
	        public int Page = 0;

	        public bool ShowOnlinePlayers = true;
	        public bool ShowOfflinePlayers = false;
	        
	        public string PermissionTarget = string.Empty;
	        public string PermissionTargetName = string.Empty;
	        
	        public ConfigData.CommandEntry CommandEntry = null;
	        public bool RequireTarget1;
	        public bool RequireTarget2;
	        public IPlayer CommandTarget1;
	        public IPlayer CommandTarget2;

	        public string GroupName = string.Empty;
	        public string GroupTitle = string.Empty;
	        public int GroupRank = 0;
	        public bool CopyUsers = false;

	        public int GiveAmount = 1;
	        public ulong SkinID = 0UL;
	        
	        public string KickBanReason = string.Empty;

	        public UIUser(BasePlayer player)
	        {
		        this.Player = player;
	        }

	        public void Reset()
	        {
		        SearchFilter = string.Empty;
		        CharacterFilter = "~";
		        Page = 0;
		        PermissionTarget = string.Empty;
		        PermissionTargetName = string.Empty;
		        KickBanReason = string.Empty;
		        ClearGroup();
		        ClearCommand();
	        }

	        public void ClearGroup()
	        {
		        GroupName = string.Empty;
		        GroupTitle = string.Empty;
		        GroupRank = 0;
		        CopyUsers = false;
	        }

	        public void ClearCommand()
	        {
		        CommandEntry = null;
		        RequireTarget1 = false;
		        RequireTarget2 = false;
		        CommandTarget1 = null;
		        CommandTarget2 = null;
		        GiveAmount = 1;
		        SkinID = 0UL;
	        }
        }
        #endregion
        
        private void CreateAdminMenu(BasePlayer player)
        {
	        UIUser uiUser;
	        if (!m_UIUsers.TryGetValue(player.userID, out uiUser))
		        uiUser = m_UIUsers[player.userID] = new UIUser(player);

	        if (uiUser.MenuIndex == MenuType.Groups && uiUser.SubMenuIndex == (int) GroupSubType.Create)
	        {
		        uiUser.SubMenuIndex = 0;
		        CreateGroupCreateOverlay(uiUser);
		        return;
	        }

	        BaseContainer root = ImageContainer.Create(ADMINMENU_UI, Layer.Overall, Anchor.Center, new Offset(-540f, -310f, 540f, 310f))
		        .WithStyle(m_BackgroundStyle)
		        .WithChildren(mainContainer =>
		        {
			        CreateTitleBar(uiUser, mainContainer);

			        CreateSubMenu(uiUser, mainContainer);

			        BaseContainer subContainer = BaseContainer.Create(mainContainer, Anchor.FullStretch, new Offset(5, 5, -5, -70));
			        switch (uiUser.MenuIndex)
			        {
				        case MenuType.Commands:
					        CommandSubType commandSubType = (CommandSubType) uiUser.SubMenuIndex;

					        if (commandSubType <= CommandSubType.Console)
						        CreateCommandMenu(uiUser, subContainer);
					        else if (commandSubType == CommandSubType.PlayerInfo)
						        CreatePlayerMenu(uiUser, subContainer);
					        break;

				        case MenuType.Permissions:
					        CreatePermissionsMenu(uiUser, subContainer);
					        break;

				        case MenuType.Groups:
					        GroupSubType groupSubType = (GroupSubType) uiUser.SubMenuIndex;

					        if (groupSubType == GroupSubType.List)
						        CreateGroupMenu(uiUser, subContainer);
					        else if (groupSubType == GroupSubType.GroupUsers)
						        CreateGroupUsersMenu(uiUser, subContainer);
					        else if (groupSubType == GroupSubType.UserGroups)
						        CreateUserGroupsMenu(uiUser, subContainer);
					        break;

				        case MenuType.Convars:
					        CreateConvarMenu(uiUser, subContainer);
					        break;

				        case MenuType.Give:
					        CreateGiveMenu(uiUser, subContainer);
					        break;
			        }
		        });
		        //.NeedsCursor()
		        //.NeedsKeyboard();
	        
	        ChaosUI.Destroy(player, ADMINMENU_UI);
	        ChaosUI.Show(player, root);
        }

        #region Menus
        private void CreateTitleBar(UIUser uiUser, BaseContainer parent)
        {
	        ImageContainer.Create(parent, Anchor.TopStretch, new Offset(5f, -35f, -5f, -5f))
		        .WithStyle(m_PanelStyle)
		        .WithChildren(titleBar =>
		        {
			        TextContainer.Create(titleBar, Anchor.CenterLeft, new Offset(10f, -15f, 205f, 15f))
				        .WithSize(18)
				        .WithText($"{Title} v{Version}")
				        .WithAlignment(TextAnchor.MiddleLeft)
				        .WithOutline(m_OutlineWhite);

			        // Category Buttons
			        BaseContainer.Create(titleBar, Anchor.FullStretch, Offset.zero)
				        .WithLayoutGroup(m_CategoryLayout, m_MenuTypes, 0, (int i, MenuType menuType, BaseContainer buttons, Anchor anchor, Offset offset) =>
				        {
					        if (!HasPermissionForMenuType(uiUser.Player, menuType))
						        return;

					        BaseContainer menuButton = ImageContainer.Create(buttons, anchor, offset)
						        .WithStyle(m_ButtonStyle)
						        .WithChildren(template =>
						        {
							        TextContainer.Create(template, Anchor.FullStretch, Offset.zero)
								        .WithText(GetString($"Category.{menuType}", uiUser.Player))
								        .WithAlignment(TextAnchor.MiddleCenter);

							        ButtonContainer.Create(template, Anchor.FullStretch, Offset.zero)
								        .WithColor(Color.Clear)
								        .WithCallback(m_CallbackHandler, arg =>
								        {
									        uiUser.MenuIndex = menuType;
									        uiUser.SubMenuIndex = 0;
									        uiUser.Reset();
									        
									        CreateAdminMenu(uiUser.Player);
								        }, $"{uiUser.Player.UserIDString}.{(int)menuType}");

						        });

					        if (menuType == uiUser.MenuIndex)
						        menuButton.WithOutline(m_OutlineGreen);
				        });

			        // Exit Button
			        ImageContainer.Create(titleBar, Anchor.CenterRight, new Offset(-55f, -10f, -5f, 10f))
				        .WithStyle(m_ButtonStyle)
				        .WithOutline(m_OutlineRed)
				        .WithChildren(exit =>
				        {
					        TextContainer.Create(exit, Anchor.FullStretch, Offset.zero)
						        .WithText(GetString("Button.Exit", uiUser.Player))
						        .WithAlignment(TextAnchor.MiddleCenter);

					        ButtonContainer.Create(exit, Anchor.FullStretch, Offset.zero)
						        .WithColor(Color.Clear)
						        .WithCallback(m_CallbackHandler, arg =>
						        {
							        ChaosUI.Destroy(uiUser.Player, ADMINMENU_MOUSE);
							        ChaosUI.Destroy(uiUser.Player, ADMINMENU_UI);
							        ChaosUI.Destroy(uiUser.Player, ADMINMENU_UI_POPUP);
							        m_UIUsers.Remove(uiUser.Player.userID);
						        }, $"{uiUser.Player.UserIDString}.exit");

				        });
		        });
        }

        private void CreateSubMenu(UIUser uiUser, BaseContainer parent)
        {
	        int[] subTypes = uiUser.MenuIndex == MenuType.Commands ? m_CommandSubTypes : 
							 uiUser.MenuIndex == MenuType.Permissions ? m_PermissionSubTypes : 
					         uiUser.MenuIndex == MenuType.Groups ? m_GroupSubTypes :
					         uiUser.MenuIndex == MenuType.Give && (uiUser.CommandTarget1 != null || uiUser.Player.HasPermission(GIVE_SELF_PERMISSION)) ? m_ItemCategoryTypes : 
					         Array.Empty<int>();

	        m_SubLayoutGroup.FixedCount = new Vector2Int(subTypes.Length, 0);
	        
	        ImageContainer.Create(parent, Anchor.Center, new Offset(-535f, 245f, 535f, 270f))
		        .WithStyle(m_PanelStyle)
		        .WithLayoutGroup(m_SubLayoutGroup, subTypes, 0, (int i, int t, BaseContainer subMenu, Anchor anchor, Offset offset) =>
		        {
			        if (!HasPermissionForSubMenu(uiUser.Player, uiUser.MenuIndex, t))
				        return;
			        
			        BaseContainer subMenuButton = ImageContainer.Create(subMenu, anchor, offset)
				        .WithStyle(m_ButtonStyle)
				        .WithChildren(commands =>
				        {
					        TextContainer.Create(commands, Anchor.FullStretch, Offset.zero)
						        .WithText(GetString($"{uiUser.MenuIndex}.{t}", uiUser.Player))
						        .WithSize(12)
						        .WithAlignment(TextAnchor.MiddleCenter);

					        ButtonContainer.Create(commands, Anchor.FullStretch, Offset.zero)
						        .WithColor(Color.Clear)
						        .WithCallback(m_CallbackHandler, arg =>
						        {
							        if (uiUser.MenuIndex != MenuType.Give)
										uiUser.Reset();
							        else
							        {
								        uiUser.SearchFilter = string.Empty;
								        uiUser.CharacterFilter = m_CharacterFilter[0];
								        uiUser.Page = 0;
							        }
							        
							        uiUser.SubMenuIndex = i;
							        CreateAdminMenu(uiUser.Player);
						        }, $"{uiUser.Player.UserIDString}.{(int)uiUser.MenuIndex}.{i}");

				        });

			        if (i == uiUser.SubMenuIndex)
				        subMenuButton.WithOutline(m_OutlineGreen);
		        });
        }

        private BaseContainer CreateSelectionHeader(UIUser uiUser, BaseContainer parent, string label, bool pageUp, bool pageDown, bool showPlayerToggles)
        {
	        // Header Bar
	        return ImageContainer.Create(parent, Anchor.TopStretch, new Offset(0f, -25f, 0f, 0f))
		        .WithStyle(m_PanelStyle)
		        .WithChildren(header =>
		        {

			        // Previous Page
			        ImageContainer.Create(header, Anchor.CenterLeft, new Offset(5f, -10f, 35f, 10f))
				        .WithStyle(pageDown ? m_ButtonStyle : m_DisabledButtonStyle)
				        .WithChildren(backButton =>
				        {
					        TextContainer.Create(backButton, Anchor.FullStretch, Offset.zero)
						        .WithText("<<<")
						        .WithStyle(pageDown ? m_ButtonStyle : m_DisabledButtonStyle);

					        if (pageDown)
					        {
						        ButtonContainer.Create(backButton, Anchor.FullStretch, Offset.zero)
							        .WithColor(Color.Clear)
							        .WithCallback(m_CallbackHandler, arg =>
							        {
								        uiUser.Page--;
								        CreateAdminMenu(uiUser.Player);
							        }, $"{uiUser.Player.UserIDString}.back");
					        }
				        });



			        // Next Page
			        ImageContainer.Create(header, Anchor.CenterRight, new Offset(-35f, -10f, -5f, 10f))
				        .WithStyle(pageUp ? m_ButtonStyle : m_DisabledButtonStyle)
				        .WithChildren(nextButton =>
				        {
					        TextContainer.Create(nextButton, Anchor.FullStretch, Offset.zero)
						        .WithText(">>>")
						        .WithStyle(pageUp ? m_ButtonStyle : m_DisabledButtonStyle);

					        if (pageUp)
					        {
						        ButtonContainer.Create(nextButton, Anchor.FullStretch, Offset.zero)
							        .WithColor(Color.Clear)
							        .WithCallback(m_CallbackHandler, arg =>
							        {
								        uiUser.Page++;
								        CreateAdminMenu(uiUser.Player);
							        }, $"{uiUser.Player.UserIDString}.next");
					        }
				        });


			        // Search Input
			        ImageContainer.Create(header, Anchor.CenterRight, new Offset(-240f, -10f, -40f, 10f))
				        .WithStyle(m_ButtonStyle)
				        .WithChildren(searchInput =>
				        {
					        InputFieldContainer.Create(searchInput, Anchor.FullStretch, new Offset(5f, 0f, -5f, 0f))
						        .WithText(uiUser.SearchFilter)
						        .WithAlignment(TextAnchor.MiddleLeft)
						        .WithCallback(m_CallbackHandler, arg =>
						        {
							        uiUser.SearchFilter = arg.Args.Length > 1 ? string.Join(" ", arg.Args.Skip(1)) : string.Empty;
							        uiUser.Page = 0;
							        CreateAdminMenu(uiUser.Player);
						        }, $"{uiUser.Player.UserIDString}.searchinput");
				        });

			        if (!string.IsNullOrEmpty(m_MagnifyImage))
			        {
				        RawImageContainer.Create(header, Anchor.Center, new Offset(275f, -10f, 295f, 10f))
					        .WithPNG(m_MagnifyImage);
			        }

			        // Label
			        TextContainer.Create(header, Anchor.Center, new Offset(-200f, -12.5f, 200f, 12.5f))
				        .WithText(label)
				        .WithAlignment(TextAnchor.MiddleCenter);

			        if (showPlayerToggles)
			        {
				        // Online player toggle
				        ImageContainer.Create(header, Anchor.CenterLeft, new Offset(40f, -10f, 60f, 10f))
					        .WithStyle(m_ButtonStyle)
					        .WithChildren(toggle =>
					        {
						        if (uiUser.ShowOnlinePlayers)
						        {
							        TextContainer.Create(toggle, Anchor.FullStretch, Offset.zero)
								        .WithText("•")
								        .WithStyle(m_ToggleLabelStyle);
						        }

						        ButtonContainer.Create(toggle, Anchor.FullStretch, Offset.zero)
							        .WithColor(Color.Clear)
							        .WithCallback(m_CallbackHandler, arg =>
							        {
								        uiUser.ShowOnlinePlayers = !uiUser.ShowOnlinePlayers;
								        CreateAdminMenu(uiUser.Player);
							        });

						        TextContainer.Create(toggle, Anchor.CenterLeft, new Offset(25f, -10f, 125f, 10f))
							        .WithText(GetString("Label.OnlinePlayers", uiUser.Player))
							        .WithAlignment(TextAnchor.MiddleLeft);
					        });

				        // Offline player toggle
				        ImageContainer.Create(header, Anchor.CenterLeft, new Offset(155f, -10f, 175f, 10f))
					        .WithStyle(m_ButtonStyle)
					        .WithChildren(toggle =>
					        {
						        if (uiUser.ShowOfflinePlayers)
						        {
							        TextContainer.Create(toggle, Anchor.FullStretch, Offset.zero)
								        .WithText("•")
								        .WithStyle(m_ToggleLabelStyle);
						        }

						        ButtonContainer.Create(toggle, Anchor.FullStretch, Offset.zero)
							        .WithColor(Color.Clear)
							        .WithCallback(m_CallbackHandler, arg =>
							        {
								        uiUser.ShowOfflinePlayers = !uiUser.ShowOfflinePlayers;
								        CreateAdminMenu(uiUser.Player);
							        });

						        TextContainer.Create(toggle, Anchor.CenterLeft, new Offset(25f, -10f, 125f, 10f))
							        .WithText(GetString("Label.OfflinePlayers", uiUser.Player))
							        .WithAlignment(TextAnchor.MiddleLeft);

					        });
			        }
		        });
        }

        #endregion

        #region Commands
        private void CreateCommandMenu(UIUser uiUser, BaseContainer parent)
        {
	        if (uiUser.CommandEntry != null)
	        {
		        if (uiUser.RequireTarget1 && uiUser.CommandTarget1 == null)
		        {
			        List<IPlayer> dst = Facepunch.Pool.GetList<IPlayer>();

			        GetApplicablePlayers(uiUser, dst);
	        
			        CreateSelectionHeader(uiUser, parent, GetString("Label.SelectPlayer1", uiUser.Player), m_ListLayout.HasNextPage(uiUser.Page, dst.Count), uiUser.Page > 0, true);

			        CreateCharacterFilter(uiUser, parent);
			        
			        LayoutSelectionGrid(uiUser, parent,  dst, (s) => s.Name.StripTags(), iPlayer =>
			        {
				        uiUser.CommandTarget1 = iPlayer;
				        
				        if (!uiUser.RequireTarget2)
					        RunCommand(uiUser, uiUser.CommandEntry, uiUser.SubMenuIndex == 0);
			        });
	        
			        Facepunch.Pool.FreeList(ref dst);
			        return;
		        }
		        
		        if (uiUser.RequireTarget2 && uiUser.CommandTarget2 == null)
		        {
			        List<IPlayer> dst = Facepunch.Pool.GetList<IPlayer>();

			        GetApplicablePlayers(uiUser, dst);
	        
			        CreateSelectionHeader(uiUser, parent, GetString("Label.SelectPlayer2", uiUser.Player), m_ListLayout.HasNextPage(uiUser.Page, dst.Count), uiUser.Page > 0, true);

			        CreateCharacterFilter(uiUser, parent);
			        
			        LayoutSelectionGrid(uiUser, parent,  dst, (s) => s.Name.StripTags(), iPlayer =>
			        {
				        uiUser.CommandTarget2 = iPlayer;
				        RunCommand(uiUser, uiUser.CommandEntry, uiUser.SubMenuIndex == 0);
			        });
	        
			        Facepunch.Pool.FreeList(ref dst);
			        return;
		        }
	        }
	        else
	        {
		        List<ConfigData.CommandEntry> commands = Facepunch.Pool.GetList<ConfigData.CommandEntry>();
		        commands.AddRange(uiUser.SubMenuIndex == 0 ? Configuration.ChatCommands : Configuration.ConsoleCommands);

		        for (int i = commands.Count - 1; i >= 0; i--)
		        {
			        ConfigData.CommandEntry command = commands[i];
			        if (!string.IsNullOrEmpty(command.RequiredPermission) && !uiUser.Player.HasPermission(command.RequiredPermission))
				        commands.RemoveAt(i);
		        }

		        ImageContainer.Create(parent, Anchor.FullStretch, Offset.zero)
			        .WithStyle(m_PanelStyle)
			        .WithLayoutGroup(m_CommandLayoutGroup, commands, 0, (int i, ConfigData.CommandEntry t, BaseContainer commandList, Anchor anchor, Offset offset) =>
			        {
				        ImageContainer.Create(commandList, anchor, offset)
					        .WithStyle(m_ButtonStyle)
					        .WithChildren(commandTemplate =>
					        {
						        TextContainer.Create(commandTemplate, Anchor.FullStretch, new Offset(5f, 5f, -5f, -5f))
							        .WithText(t.Name)
							        .WithAlignment(TextAnchor.UpperCenter);

						        TextContainer.Create(commandTemplate, Anchor.FullStretch, new Offset(5f, 5f, -5f, -5f))
							        .WithSize(10)
							        .WithText(t.Description)
							        .WithAlignment(TextAnchor.LowerCenter);

						        ButtonContainer.Create(commandTemplate, Anchor.FullStretch, Offset.zero)
							        .WithColor(Color.Clear)
							        .WithCallback(m_CallbackHandler, arg =>
							        {
								        uiUser.CommandEntry = t;
								        uiUser.RequireTarget1 = t.Command.Contains("{target1_name}") || t.Command.Contains("{target1_id}");
								        uiUser.RequireTarget2 = t.Command.Contains("{target2_name}") || t.Command.Contains("{target2_id}");

								        if (uiUser.RequireTarget1 || uiUser.RequireTarget2)
									        CreateAdminMenu(uiUser.Player);
								        else RunCommand(uiUser, t, uiUser.SubMenuIndex == 0);

							        }, $"{uiUser.Player.UserIDString}.command.{i}");

					        });
			        });
	        }
        }
       
        private void CreateGiveMenu(UIUser uiUser, BaseContainer parent)
        {
	        RESTART:
	        if (uiUser.CommandTarget1 == null)
	        {
		        if (uiUser.Player.HasPermission(GIVE_SELF_PERMISSION))
		        {
			        uiUser.CommandTarget1 = uiUser.Player.IPlayer;
			        goto RESTART;
		        }
		        
		        List<IPlayer> dst = Facepunch.Pool.GetList<IPlayer>();

		        GetApplicablePlayers(uiUser, dst);
		        
		        CreateSelectionHeader(uiUser, parent, GetString("Label.SelectPlayer", uiUser.Player), m_ListLayout.HasNextPage(uiUser.Page, dst.Count), uiUser.Page > 0, true);

		        CreateCharacterFilter(uiUser, parent);
		        
		        LayoutSelectionGrid(uiUser, parent,  dst, (s) => s.Name.StripTags(), iPlayer =>
		        {
			        uiUser.CommandTarget1 = iPlayer;
			        CreateAdminMenu(uiUser.Player);
		        });
		        
		        Facepunch.Pool.FreeList(ref dst);
	        }
	        else
	        {
		        List<ItemDefinition> dst = Facepunch.Pool.GetList<ItemDefinition>();

		        if (uiUser.CharacterFilter != m_CharacterFilter[0] || !string.IsNullOrEmpty(uiUser.SearchFilter))
		        {
			        List<ItemDefinition> src = Facepunch.Pool.GetList<ItemDefinition>();

			        src.AddRange(m_AllItemDefinitions);
			        
			        FilterList(src, dst, uiUser, (s, itemDefinition) => StartsWithValidator(s, itemDefinition.displayName.english), (s, itemDefinition) => ContainsValidator(s, itemDefinition.displayName.english));
			        
			        Facepunch.Pool.FreeList(ref src);
		        }
		        else dst.AddRange(m_ItemDefinitionsPerCategory[(ItemCategory)m_ItemCategoryTypes[uiUser.SubMenuIndex]]);
		        
		        CreateSelectionHeader(uiUser, parent, FormatString("Label.GiveToPlayer", uiUser.Player, uiUser.CommandTarget1.Name.StripTags()), m_GiveLayoutGroup.HasNextPage(uiUser.Page, dst.Count), uiUser.Page > 0, false);

		        CreateCharacterFilter(uiUser, parent);
		        
		        ImageContainer.Create(parent, Anchor.FullStretch, new Offset(25f, 0f, 0f, -30f))
			        .WithStyle(m_PanelStyle)
			        .WithLayoutGroup(m_GiveLayoutGroup, dst, uiUser.Page, (int i, ItemDefinition t, BaseContainer layout, Anchor anchor, Offset offset) =>
			        {
				        ImageContainer.Create(layout, anchor, offset)
					        .WithStyle(m_PanelStyle)
					        .WithChildren(template =>
					        {
						        ImageContainer.Create(template, Anchor.TopCenter, new Offset(-37.5f, -75f, 37.5f, 0f))
							        .WithIcon(t.itemid);

						        TextContainer.Create(template, Anchor.BottomStretch, new Offset(0f, 0f, 0f, 25f))
							        .WithSize(10)
							        .WithText(t.displayName.english)
							        .WithAlignment(TextAnchor.MiddleCenter);

						        ButtonContainer.Create(template, Anchor.FullStretch, Offset.zero)
							        .WithColor(Color.Clear)
							        .WithCallback(m_CallbackHandler, arg =>
							        {
								        BasePlayer target = uiUser.CommandTarget1.Object as BasePlayer;
								        if (!target)
								        {
									        CreatePopupMessage(uiUser, "The selected user is not valid at this time. They may be dead or disconnected");
									        return;
								        }
										        
								        CreateGiveOverlay(uiUser, target, t);
							        }, $"{uiUser.Player.UserIDString}.{t.shortname}" );

						        Action<int> quickGiveAction = new Action<int>((int amount) =>
						        {
							        BasePlayer target = uiUser.CommandTarget1.Object as BasePlayer;
							        if (!target)
							        {
								        CreatePopupMessage(uiUser, "The selected user is not valid at this time. They may be dead or disconnected");
								        return;
							        }

							        target.GiveItem(ItemManager.Create(t, amount), BaseEntity.GiveItemReason.PickedUp);
							        CreatePopupMessage(uiUser, FormatString("Notification.Give.Success", uiUser.Player, target.displayName, amount, t.displayName.english));
						        });
						        
						        ImageContainer.Create(template, Anchor.TopRight, new Offset(-23f, -18f, -3f, -3f))
							        .WithStyle(m_ButtonStyle)
							        .WithChildren(giveOne =>
							        {
								        TextContainer.Create(giveOne, Anchor.FullStretch, Offset.zero)
									        .WithSize(8)
									        .WithText("1")
									        .WithAlignment(TextAnchor.MiddleCenter)
									        .WithWrapMode(VerticalWrapMode.Overflow);

								        ButtonContainer.Create(giveOne, Anchor.FullStretch, Offset.zero)
									        .WithColor(Color.Clear)
									        .WithCallback(m_CallbackHandler, arg => quickGiveAction(1), $"{uiUser.Player.UserIDString}.quick.{t.shortname}.1");
							        });

						        ImageContainer.Create(template, Anchor.TopRight, new Offset(-23f, -35f, -3f, -20f))
							        .WithStyle(m_ButtonStyle)
							        .WithChildren(giveOneHundred =>
							        {
								        TextContainer.Create(giveOneHundred, Anchor.FullStretch, Offset.zero)
									        .WithSize(8)
									        .WithText("100")
									        .WithAlignment(TextAnchor.MiddleCenter)
									        .WithWrapMode(VerticalWrapMode.Overflow);

								        ButtonContainer.Create(giveOneHundred, Anchor.FullStretch, Offset.zero)
									        .WithColor(Color.Clear)
									        .WithCallback(m_CallbackHandler, arg => quickGiveAction(100), $"{uiUser.Player.UserIDString}.quick.{t.shortname}.100");
							        });

						        ImageContainer.Create(template, Anchor.TopRight, new Offset(-23f, -52f, -3f, -37f))
							        .WithStyle(m_ButtonStyle)
							        .WithChildren(giveOneThousand =>
							        {
								        TextContainer.Create(giveOneThousand, Anchor.FullStretch, Offset.zero)
									        .WithSize(8)
									        .WithText("1000")
									        .WithAlignment(TextAnchor.MiddleCenter)
									        .WithWrapMode(VerticalWrapMode.Overflow);

								        ButtonContainer.Create(giveOneThousand, Anchor.FullStretch, Offset.zero)
									        .WithColor(Color.Clear)
									        .WithCallback(m_CallbackHandler, arg => quickGiveAction(1000), $"{uiUser.Player.UserIDString}.quick.{t.shortname}.1000");

							        });
					        });
			        });
		        
		        Facepunch.Pool.FreeList(ref dst);
	        }
        }

        private void CreateGiveOverlay(UIUser uiUser, BasePlayer target, ItemDefinition itemDefinition)
        {
	        BaseContainer baseContainer = ButtonContainer.Create(ADMINMENU_UI, Layer.Overall, Anchor.FullStretch, Offset.zero)
				.WithStyle(m_BackgroundStyle)
				.WithCallback(m_CallbackHandler, arg => CreateAdminMenu(uiUser.Player), $"{uiUser.Player.UserIDString}.give.cancel")
				.WithChildren(givePopup =>
				{
					ImageContainer.Create(givePopup, Anchor.Center, new Offset(-100f, 107.5f, 100f, 127.5f))
						.WithStyle(m_PanelStyle)
						.WithChildren(infoBar =>
						{
							TextContainer.Create(infoBar, Anchor.FullStretch, Offset.zero)
								.WithText(itemDefinition.displayName.english)
								.WithAlignment(TextAnchor.MiddleCenter);
						});
					
					ImageContainer.Create(givePopup, Anchor.Center, new Offset(-100f, -102.5f, 100f, 102.5f))
						.WithStyle(m_PanelStyle)
						.WithChildren(givePanel =>
						{
							// Item Icon
							ImageContainer.Create(givePanel, Anchor.TopCenter, new Offset(-64f, -128f, 64f, 0f))
								.WithIcon(itemDefinition.itemid);

							// Amount Input
							TextContainer.Create(givePanel, Anchor.BottomStretch, new Offset(4.999969f, 55f, -145f, 75f))
								.WithText(GetString("Label.Amount", uiUser.Player))
								.WithAlignment(TextAnchor.MiddleLeft);

							ImageContainer.Create(givePanel, Anchor.BottomStretch, new Offset(60f, 55f, -4.999985f, 75f))
								.WithStyle(m_ButtonStyle)
								.WithChildren(amountInput =>
								{
									InputFieldContainer.Create(amountInput, Anchor.FullStretch, new Offset(5f, 0f, -5f, 0f))
										.WithText(uiUser.GiveAmount.ToString())
										.WithAlignment(TextAnchor.MiddleLeft)
										.WithCallback(m_CallbackHandler, arg =>
										{
											uiUser.GiveAmount = arg.GetInt(1);
											CreateGiveOverlay(uiUser, target, itemDefinition);
										});
								});
							
							// Skin Input
							TextContainer.Create(givePanel, Anchor.BottomStretch, new Offset(4.999969f, 30f, -145f, 50f))
								.WithText(GetString("Label.SkinID", uiUser.Player))
								.WithAlignment(TextAnchor.MiddleLeft);
							
							ImageContainer.Create(givePanel, Anchor.BottomStretch, new Offset(60f, 30f, -4.999985f, 50f))
								.WithStyle(m_ButtonStyle)
								.WithChildren(skinId =>
								{
									InputFieldContainer.Create(skinId, Anchor.FullStretch, new Offset(5f, 0f, -5f, 0f))
										.WithText(uiUser.SkinID.ToString())
										.WithAlignment(TextAnchor.MiddleLeft)
										.WithCallback(m_CallbackHandler, arg =>
										{
											uiUser.SkinID = arg.GetUInt64(1);
											CreateGiveOverlay(uiUser, target, itemDefinition);
										});
								});
							
							// Buttons
							ImageContainer.Create(givePanel, Anchor.BottomLeft, new Offset(5f, 5f, 95f, 25f))
								.WithStyle(m_ButtonStyle)
								.WithOutline(m_OutlineGreen)
								.WithChildren(giveButton =>
								{
									TextContainer.Create(giveButton, Anchor.FullStretch, Offset.zero)
										.WithText(GetString("Button.Give", uiUser.Player))
										.WithAlignment(TextAnchor.MiddleCenter);

									ButtonContainer.Create(giveButton, Anchor.FullStretch, Offset.zero)
										.WithColor(Color.Clear)
										.WithCallback(m_CallbackHandler, arg =>
										{
											if (uiUser.GiveAmount == 0)
												return;

											target.GiveItem(ItemManager.Create(itemDefinition, uiUser.GiveAmount, uiUser.SkinID), BaseEntity.GiveItemReason.PickedUp);
											
											CreateAdminMenu(uiUser.Player);
											CreatePopupMessage(uiUser, FormatString("Notification.Give.Success", uiUser.Player, target.displayName, uiUser.GiveAmount, itemDefinition.displayName.english));
										}, $"{uiUser.Player.UserIDString}.give");

								});

							ImageContainer.Create(givePanel, Anchor.BottomRight, new Offset(-95f, 5f, -5f, 25f))
								.WithStyle(m_ButtonStyle)
								.WithOutline(m_OutlineRed)
								.WithChildren(cancel =>
								{
									TextContainer.Create(cancel, Anchor.FullStretch, Offset.zero)
										.WithText(GetString("Button.Cancel", uiUser.Player))
										.WithAlignment(TextAnchor.MiddleCenter);

									ButtonContainer.Create(cancel, Anchor.FullStretch, Offset.zero)
										.WithColor(Color.Clear)
										.WithCallback(m_CallbackHandler, arg => CreateAdminMenu(uiUser.Player), $"{uiUser.Player.UserIDString}.give.cancel");

								});
						});
				});
				//.NeedsCursor()
				//.NeedsKeyboard();
	        
	        ChaosUI.Destroy(uiUser.Player, ADMINMENU_UI);
	        ChaosUI.Show(uiUser.Player, baseContainer);
        }

        private void CreatePlayerMenu(UIUser uiUser, BaseContainer parent)
        {
	        if (uiUser.CommandTarget1 == null)
	        {
		        List<IPlayer> dst = Facepunch.Pool.GetList<IPlayer>();

		        GetApplicablePlayers(uiUser, dst);
		        
		        CreateSelectionHeader(uiUser, parent, GetString("Label.SelectPlayer", uiUser.Player), m_ListLayout.HasNextPage(uiUser.Page, dst.Count), uiUser.Page > 0, true);

		        CreateCharacterFilter(uiUser, parent);
		        
		        LayoutSelectionGrid(uiUser, parent,  dst, (s) => s.Name.StripTags(), iPlayer =>
		        {
			        uiUser.CommandTarget1 = iPlayer;
			        CreateAdminMenu(uiUser.Player);
		        });
		        
		        Facepunch.Pool.FreeList(ref dst);
	        }
	        else
	        {
		        // Headers
		        BaseContainer.Create(parent, Anchor.TopStretch, new Offset(0f, -25f, 0f, 0f))
			        .WithChildren(headers =>
			        {
				        ImageContainer.Create(headers, Anchor.LeftStretch, new Offset(0f, 0f, 200f, 0f))
					        .WithStyle(m_PanelStyle)
					        .WithChildren(statsheader =>
					        {
						        TextContainer.Create(statsheader, Anchor.FullStretch, new Offset(5f, 0f, -5f, 0f))
							        .WithText(GetString("PlayerInfo.Info", uiUser.Player))
							        .WithAlignment(TextAnchor.MiddleLeft);
					        });

				        ImageContainer.Create(headers, Anchor.LeftStretch, new Offset(205f, 0f, 1070f, 0f))
					        .WithStyle(m_PanelStyle)
					        .WithChildren(actionsHeader =>
					        {
						        TextContainer.Create(actionsHeader, Anchor.FullStretch, new Offset(5f, 0f, -5f, 0f))
							        .WithText(GetString("PlayerInfo.Actions", uiUser.Player))
							        .WithAlignment(TextAnchor.MiddleLeft);
					        });
			        });


		        // Player Information
		        ImageContainer.Create(parent, Anchor.LeftStretch, new Offset(0f, 0f, 200f, -30f))
			        .WithStyle(m_PanelStyle)
			        .WithLayoutGroup(m_PlayerInfoLayout, m_PlayerInfo, 0, (int i, PlayerInfo t, BaseContainer stats, Anchor anchor, Offset offset) =>
			        {
				        if (string.IsNullOrEmpty(t.Name))
					        return;

				        TextContainer.Create(stats, anchor, offset)
					        .WithText(FormatString(t.Name, uiUser.Player, t.Result(uiUser.CommandTarget1)))
					        .WithAlignment(TextAnchor.MiddleLeft)
					        .WithSize(12);
			        });

		        // Plugin Actions
		        ImageContainer.Create(parent, Anchor.FullStretch, new Offset(205f, 0f, 0f, -30f))
			        .WithStyle(m_PanelStyle)
			        .WithLayoutGroup(m_PluginActionsLayout, m_PluginActions, 0, (int i, List<PluginAction> list, BaseContainer actions, Anchor anchor, Offset offset) =>
			        {
				        if (list == null)
					        return;

				        BaseContainer.Create(actions, anchor, offset)
					        .WithLayoutGroup(m_InternalPluginActionsLayout, list, 0, (int ii, PluginAction t, BaseContainer innerGrid, Anchor anchor2, Offset offset2) =>
					        {
						        if (string.IsNullOrEmpty(t.Name) || !t.IsViewable())
							        return;
						        
						        if ((Configuration.UsePlayerAdminPermissions || t.ForcePermissionCheck) && !t.HasPermission(uiUser))
							        return;

						        ImageContainer.Create(innerGrid, anchor2, offset2)
							        .WithStyle(m_ButtonStyle)
							        .WithChildren(template =>
							        {
								        TextContainer.Create(template, Anchor.FullStretch, Offset.zero)
									        .WithText(GetString(t.Name, uiUser.Player))
									        .WithAlignment(TextAnchor.MiddleCenter)
									        .WithSize(12);

								        ButtonContainer.Create(template, Anchor.FullStretch, Offset.zero)
									        .WithColor(Color.Clear)
									        .WithCallback(m_CallbackHandler, arg => t.OnClick(uiUser), $"{uiUser.Player.UserIDString}.pluginaction.{t.Name}");
							        });
					        });
			        });
	        }
        }

        private void CreateKickBanOverlay(UIUser uiUser, IPlayer target, bool isKick)
        {
	        BaseContainer baseContainer = ButtonContainer.Create(ADMINMENU_UI, Layer.Overall, Anchor.FullStretch, Offset.zero)
				.WithStyle(m_BackgroundStyle)
				.WithChildren(kickBanPopup =>
				{
					ImageContainer.Create(kickBanPopup, Anchor.Center, new Offset(-175f, 32.5f, 175f, 52.5f))
						.WithStyle(m_PanelStyle)
						.WithChildren(infoBar =>
						{
							TextContainer.Create(infoBar, Anchor.FullStretch, Offset.zero)
								.WithText(FormatString(isKick ? "Label.Kick" : "Label.Ban", uiUser.Player, target.Name.StripTags()))
								.WithAlignment(TextAnchor.MiddleCenter);

						});

					ImageContainer.Create(kickBanPopup, Anchor.Center, new Offset(-175f, -27.5f, 175f, 27.5f))
						.WithStyle(m_PanelStyle)
						.WithChildren(titleBar =>
						{
							//Reason Input
							TextContainer.Create(titleBar, Anchor.BottomStretch, new Offset(4.999969f, 30f, -145f, 50f))
								.WithText(GetString("Label.Reason", uiUser.Player))
								.WithAlignment(TextAnchor.MiddleLeft);
							
							ImageContainer.Create(titleBar, Anchor.BottomStretch, new Offset(60f, 30f, -4.999985f, 50f))
								.WithStyle(m_ButtonStyle)
								.WithChildren(reasonInput =>
								{
									InputFieldContainer.Create(reasonInput, Anchor.FullStretch, new Offset(5f, 0f, -5f, 0f))
										.WithText(isKick ? "Kicked by Administrator" : "Banned by Administrator")
										.WithAlignment(TextAnchor.MiddleLeft)
										.WithCallback(m_CallbackHandler, arg =>
										{
											uiUser.KickBanReason = arg.Args.Length > 1 ? string.Join(" ", arg.Args.Skip(1)) : (isKick ? "Kicked by Administrator" : "Banned by Administrator");
											CreateKickBanOverlay(uiUser, target, isKick);
										}, $"{uiUser.Player.UserIDString}.kickban.reason");
								});
							
							// Buttons
							ImageContainer.Create(titleBar, Anchor.BottomLeft, new Offset(5f, 5f, 95f, 25f))
								.WithStyle(m_ButtonStyle)
								.WithOutline(m_OutlineGreen)
								.WithChildren(confirm =>
								{
									TextContainer.Create(confirm, Anchor.FullStretch, Offset.zero)
										.WithText(GetString("Button.Confirm", uiUser.Player))
										.WithAlignment(TextAnchor.MiddleCenter);

									ButtonContainer.Create(confirm, Anchor.FullStretch, Offset.zero)
										.WithColor(Color.Clear)
										.WithCallback(m_CallbackHandler, arg =>
										{
											if (isKick)
											{
												string reason = string.IsNullOrEmpty(uiUser.KickBanReason) ? "Kicked by Administrator" : uiUser.KickBanReason;
												
												ConVar.Chat.Broadcast($"Kicked {target.Name} ({reason})", "SERVER", "#eee", (ulong)0);
												
												BasePlayer targetPlayer = target.Object as BasePlayer;
												if (targetPlayer)
													Network.Net.sv.Kick(targetPlayer.net.connection, reason);
											}
											else
											{
												string reason = string.IsNullOrEmpty(uiUser.KickBanReason) ? "Banned by Administrator" : uiUser.KickBanReason;

												ConVar.Chat.Broadcast($"Banned {target.Name} ({reason})", "SERVER", "#eee", (ulong)0);
												target.Ban(reason);
											}
											CreateAdminMenu(uiUser.Player);
										}, $"{uiUser.Player.UserIDString}.kickban.confirm");

								});

							ImageContainer.Create(titleBar, Anchor.BottomRight, new Offset(-95f, 5f, -5f, 25f))
								.WithStyle(m_ButtonStyle)
								.WithOutline(m_OutlineRed)
								.WithChildren(cancel =>
								{
									TextContainer.Create(cancel, Anchor.FullStretch, Offset.zero)
										.WithText(GetString("Button.Cancel", uiUser.Player))
										.WithAlignment(TextAnchor.MiddleCenter);

									ButtonContainer.Create(cancel, Anchor.FullStretch, Offset.zero)
										.WithColor(Color.Clear)
										.WithCallback(m_CallbackHandler, arg => CreateAdminMenu(uiUser.Player), $"{uiUser.Player.UserIDString}.kickban.cancel");
								});
						});
				});
				//.NeedsCursor()
				//.NeedsKeyboard();
	        
	        ChaosUI.Destroy(uiUser.Player, ADMINMENU_UI);
	        ChaosUI.Show(uiUser.Player, baseContainer);
        }
        
        #region Player Info Functions
	    private struct PluginAction
	    {
		    public readonly string Name;
		    public readonly bool ForcePermissionCheck;
		    public readonly Func<bool> IsViewable;
		    public readonly Func<UIUser, bool> HasPermission;
		    public readonly Action<UIUser> OnClick;

		    public PluginAction(string name, Func<UIUser, bool> hasPermission, Action<UIUser> onClick, bool forcePermissionCheck = false)
		    {
			    this.Name = name;
			    this.IsViewable = () => true;
			    this.HasPermission = hasPermission;
			    this.OnClick = onClick;
			    this.ForcePermissionCheck = forcePermissionCheck;
		    }
		    
		    public PluginAction(string name, Func<bool> isViewable, Func<UIUser, bool> hasPermission, Action<UIUser> onClick, bool forcePermissionCheck = false)
		    {
			    this.Name = name;
			    this.IsViewable = isViewable;
			    this.HasPermission = hasPermission;
			    this.OnClick = onClick;
			    this.ForcePermissionCheck = forcePermissionCheck;
		    }
	    }

	    private struct PlayerInfo
	    {
		    public readonly string Name;
		    public readonly Func<IPlayer, string> Result;

		    public PlayerInfo(string name, Func<IPlayer, string> result)
		    {
			    this.Name = name;
			    this.Result = result;
		    }
	    }
        
	    private List<List<PluginAction>> m_PluginActions;
	    
        private readonly List<PlayerInfo> m_PlayerInfo = new List<PlayerInfo>()
        {
	        new PlayerInfo("PlayerInfo.Name", (player => player.Name.StripTags())),
	        new PlayerInfo("PlayerInfo.ID", (player => player.Id)),
	        new PlayerInfo("PlayerInfo.Auth", (player =>
	        {
		        ulong userId = ulong.Parse(player.Id);
		        return (DeveloperList.Contains(userId) ? "Developer" : (ServerUsers.Get(userId)?.group ?? ServerUsers.UserGroup.None).ToString());
	        })),
	        new PlayerInfo("PlayerInfo.Status", (player => player.IsConnected ? "Online" : "Offline")),
	        new PlayerInfo("PlayerInfo.IdleTime", (player =>
	        {
		        BasePlayer basePlayer = (player.Object as BasePlayer);
		        return basePlayer ? FormatTime(basePlayer.IdleTime) : string.Empty;
	        })),
	        new PlayerInfo(string.Empty, null),
	        new PlayerInfo("PlayerInfo.Position", (player =>
	        {
		        BasePlayer basePlayer = (player.Object as BasePlayer);
		        return basePlayer ? basePlayer.ServerPosition.ToString() : string.Empty;
	        })),
	        new PlayerInfo("PlayerInfo.Grid", (player =>
	        {
		        BasePlayer basePlayer = (player.Object as BasePlayer);
		        return basePlayer ? PhoneController.PositionToGridCoord(basePlayer.ServerPosition) : string.Empty;
	        })),
	        new PlayerInfo(string.Empty, null),
	        new PlayerInfo("PlayerInfo.Health", (player =>
	        {
		        BasePlayer basePlayer = (player.Object as BasePlayer);
		        return basePlayer ? Math.Round(basePlayer.health, 2).ToString() : string.Empty;
	        })),
	        new PlayerInfo("PlayerInfo.Calories", (player =>
	        {
		        BasePlayer basePlayer = (player.Object as BasePlayer);
		        return basePlayer ? Math.Round(basePlayer.metabolism.calories.value, 2).ToString() : string.Empty;
	        })),
	        new PlayerInfo("PlayerInfo.Hydration", (player =>
	        {
		        BasePlayer basePlayer = (player.Object as BasePlayer);
		        return basePlayer ? Math.Round(basePlayer.metabolism.hydration.value, 2).ToString() : string.Empty;
	        })),
	        new PlayerInfo("PlayerInfo.Temperature", (player =>
	        {
		        BasePlayer basePlayer = (player.Object as BasePlayer);
		        return basePlayer ? Math.Round(basePlayer.metabolism.temperature.value, 2).ToString() : string.Empty;
	        })),
	        new PlayerInfo("PlayerInfo.Comfort", (player =>
	        {
		        BasePlayer basePlayer = (player.Object as BasePlayer);
		        return basePlayer ? Math.Round(basePlayer.metabolism.comfort.value, 2).ToString() : string.Empty;
	        })),
	        new PlayerInfo("PlayerInfo.Wetness", (player =>
	        {
		        BasePlayer basePlayer = (player.Object as BasePlayer);
		        return basePlayer ? Math.Round(basePlayer.metabolism.wetness.value, 2).ToString() : string.Empty;
	        })),
	        new PlayerInfo("PlayerInfo.Bleeding", (player =>
	        {
		        BasePlayer basePlayer = (player.Object as BasePlayer);
		        return basePlayer ? Math.Round(basePlayer.metabolism.bleeding.value, 2).ToString() : string.Empty;
	        })),
	        new PlayerInfo("PlayerInfo.Radiation", (player =>
	        {
		        BasePlayer basePlayer = (player.Object as BasePlayer);
		        return basePlayer ? Math.Round(basePlayer.metabolism.radiation_level.value, 2).ToString() : string.Empty;
	        })),
        };

        private void SetupPlayerActions()
        {
	        m_PluginActions = new List<List<PluginAction>>()
	        {
		        new List<PluginAction>()
		        {
			        new PluginAction("Action.Kick", (s) => s.Player.HasPermission(PLAYER_KICKBAN_PERMISSION), uiUser => CreateKickBanOverlay(uiUser, uiUser.CommandTarget1, true)),
			        new PluginAction("Action.Ban", (s) => s.Player.HasPermission(PLAYER_KICKBAN_PERMISSION), (uiUser) => CreateKickBanOverlay(uiUser, uiUser.CommandTarget1, false))
		        },
		        new List<PluginAction>()
		        {
			        new PluginAction("Action.StripInventory", (s) => s.Player.HasPermission(PLAYER_STRIP_PERMISSION), (uiUser) =>
			        {
				        BasePlayer player = (uiUser.CommandTarget1.Object as BasePlayer);
				        if (player)
				        {
					        player.inventory.Strip();
					        CreatePopupMessage(uiUser, FormatString("Action.StripInventory.Success", uiUser.Player, uiUser.CommandTarget1.Name.StripTags()));
					        return;
				        }

				        CreatePopupMessage(uiUser, FormatString("Action.StripInventory.Failed", uiUser.Player, uiUser.CommandTarget1.Name.StripTags()));
			        }),
			        new PluginAction("Action.ResetMetabolism", (s) => s.Player.HasPermission(PLAYER_HEAL_PERMISSION), (uiUser) =>
			        {
				        BasePlayer player = (uiUser.CommandTarget1.Object as BasePlayer);
				        if (player)
				        {
					        player.metabolism.bleeding.value = 0;
					        player.metabolism.calories.value = player.metabolism.calories.max;
					        player.metabolism.hydration.value = player.metabolism.hydration.max;
					        player.metabolism.radiation_level.value = 0;
					        player.metabolism.radiation_poison.value = 0;
					        player.metabolism.poison.value = 0;
					        player.metabolism.wetness.value = 0;

					        player.metabolism.SendChangesToClient();
					        CreatePopupMessage(uiUser, FormatString("Action.ResetMetabolism.Success", uiUser.Player, uiUser.CommandTarget1.Name.StripTags()));
					        CreateAdminMenu(uiUser.Player);
					        return;
				        }

				        CreatePopupMessage(uiUser, FormatString("Action.ResetMetabolism.Failed", uiUser.Player, uiUser.CommandTarget1.Name.StripTags()));
			        }),
		        },
		        new List<PluginAction>()
		        {
			        new PluginAction("Action.GiveBlueprints", (s) => s.Player.HasPermission(PLAYER_BLUERPRINTS_PERMISSION), (uiUser) =>
			        {
				        BasePlayer player = (uiUser.CommandTarget1.Object as BasePlayer);
				        if (player)
				        {
					        ProtoBuf.PersistantPlayer persistantPlayerInfo = player.PersistantPlayerInfo;
					        foreach (ItemBlueprint itemBlueprint in ItemManager.bpList)
					        {
						        if (!itemBlueprint.userCraftable || itemBlueprint.defaultBlueprint || persistantPlayerInfo.unlockedItems.Contains(itemBlueprint.targetItem.itemid))
						        {
							        continue;
						        }

						        persistantPlayerInfo.unlockedItems.Add(itemBlueprint.targetItem.itemid);
					        }

					        player.PersistantPlayerInfo = persistantPlayerInfo;
					        player.SendNetworkUpdateImmediate(false);
					        player.ClientRPCPlayer<int>(null, player, "UnlockedBlueprint", 0);
					        CreatePopupMessage(uiUser, FormatString("Action.GiveBlueprints.Success", uiUser.Player, uiUser.CommandTarget1.Name.StripTags()));
					        return;
				        }

				        CreatePopupMessage(uiUser, FormatString("Action.GiveBlueprints.Failed", uiUser.Player, uiUser.CommandTarget1.Name.StripTags()));
			        }),
			        new PluginAction("Action.RevokeBlueprints", (s) => s.Player.HasPermission(PLAYER_BLUERPRINTS_PERMISSION), (uiUser) =>
			        {
				        BasePlayer player = (uiUser.CommandTarget1.Object as BasePlayer);
				        if (player)
				        {
					        player.blueprints.Reset();
					        CreatePopupMessage(uiUser, FormatString("Action.RevokeBlueprints.Success", uiUser.Player, uiUser.CommandTarget1.Name.StripTags()));
					        return;
				        }

				        CreatePopupMessage(uiUser, FormatString("Action.RevokeBlueprints.Failed", uiUser.Player, uiUser.CommandTarget1.Name.StripTags()));
			        }),
			        default(PluginAction),
			        new PluginAction("Action.ViewPermissions", (s) => s.Player.HasPermission(PERM_PERMISSION), uiUser =>
			        {
				        uiUser.MenuIndex = MenuType.Permissions;
				        uiUser.SubMenuIndex = (int) PermissionSubType.Player;
				        uiUser.PermissionTarget = uiUser.CommandTarget1.Id;
				        uiUser.PermissionTargetName = uiUser.CommandTarget1.Name.StripTags();
				        uiUser.CommandTarget1 = null;
				        CreateAdminMenu(uiUser.Player);
			        }, true),
		        },
		        new List<PluginAction>()
		        {
			        new PluginAction("Action.Mute", (s) => s.Player.HasPermission(PLAYER_MUTE_PERMISSION), (uiUser) =>
			        {
				        BasePlayer player = (uiUser.CommandTarget1.Object as BasePlayer);
				        if (player)
				        {
					        player.SetPlayerFlag(BasePlayer.PlayerFlags.ChatMute, true);
					        CreatePopupMessage(uiUser, FormatString("Action.Mute.Success", uiUser.Player, uiUser.CommandTarget1.Name.StripTags()));
					        return;
				        }

				        CreatePopupMessage(uiUser, FormatString("Action.Mute.Failed", uiUser.Player, uiUser.CommandTarget1.Name.StripTags()));
			        }),
			        new PluginAction("Action.Unmute", (s) => s.Player.HasPermission(PLAYER_MUTE_PERMISSION), (uiUser) =>
			        {
				        BasePlayer player = (uiUser.CommandTarget1.Object as BasePlayer);
				        if (player)
				        {
					        player.SetPlayerFlag(BasePlayer.PlayerFlags.ChatMute, false);
					        CreatePopupMessage(uiUser, FormatString("Action.Unmute.Success", uiUser.Player, uiUser.CommandTarget1.Name.StripTags()));
					        return;
				        }

				        CreatePopupMessage(uiUser, FormatString("Action.Unmute.Failed", uiUser.Player, uiUser.CommandTarget1.Name.StripTags()));
			        }),
		        },
		        new List<PluginAction>()
		        {
			        new PluginAction("Action.Hurt25", (s) => s.Player.HasPermission(PLAYER_HURT_PERMISSION), (uiUser) =>
			        {
				        BasePlayer player = (uiUser.CommandTarget1.Object as BasePlayer);
				        if (player)
				        {
					        player.Hurt(player.health * 0.25f);
					        CreatePopupMessage(uiUser, FormatString("Action.Hurt25.Success", uiUser.Player, uiUser.CommandTarget1.Name.StripTags()));
					        return;
				        }

				        CreatePopupMessage(uiUser, FormatString("Action.Hurt25.Failed", uiUser.Player, uiUser.CommandTarget1.Name.StripTags()));
			        }),
			        new PluginAction("Action.Hurt50", (s) => s.Player.HasPermission(PLAYER_HURT_PERMISSION), (uiUser) =>
			        {
				        BasePlayer player = (uiUser.CommandTarget1.Object as BasePlayer);
				        if (player)
				        {
					        player.Hurt(player.health * 0.5f);
					        CreatePopupMessage(uiUser, FormatString("Action.Hurt50.Success", uiUser.Player, uiUser.CommandTarget1.Name.StripTags()));
					        return;
				        }

				        CreatePopupMessage(uiUser, FormatString("Action.Hurt50.Failed", uiUser.Player, uiUser.CommandTarget1.Name.StripTags()));
			        }),
			        new PluginAction("Action.Hurt75", (s) => s.Player.HasPermission(PLAYER_HURT_PERMISSION), (uiUser) =>
			        {
				        BasePlayer player = (uiUser.CommandTarget1.Object as BasePlayer);
				        if (player)
				        {
					        player.Hurt(player.health * 0.75f);
					        CreatePopupMessage(uiUser, FormatString("Action.Hurt75.Success", uiUser.Player, uiUser.CommandTarget1.Name.StripTags()));
					        return;
				        }

				        CreatePopupMessage(uiUser, FormatString("Action.Hurt75.Failed", uiUser.Player, uiUser.CommandTarget1.Name.StripTags()));
			        }),
			        new PluginAction("Action.Kill", (s) => s.Player.HasPermission(PLAYER_KILL_PERMISSION), (uiUser) =>
			        {
				        BasePlayer player = (uiUser.CommandTarget1.Object as BasePlayer);
				        if (player)
				        {
					        player.Die(new HitInfo(player, player, Rust.DamageType.Stab, 1000));
					        CreatePopupMessage(uiUser, FormatString("Action.Kill.Success", uiUser.Player, uiUser.CommandTarget1.Name.StripTags()));
					        return;
				        }

				        CreatePopupMessage(uiUser, FormatString("Action.Kill.Failed", uiUser.Player, uiUser.CommandTarget1.Name.StripTags()));
			        })
		        },
		        new List<PluginAction>()
		        {
			        new PluginAction("Action.Heal25", (s) => s.Player.HasPermission(PLAYER_HEAL_PERMISSION), (uiUser) =>
			        {
				        BasePlayer player = (uiUser.CommandTarget1.Object as BasePlayer);
				        if (player)
				        {
					        if (player.IsWounded())
						        player.StopWounded();

					        player.Heal(player.MaxHealth() * 0.25f);
					        CreatePopupMessage(uiUser, FormatString("Action.Heal25.Success", uiUser.Player, uiUser.CommandTarget1.Name.StripTags()));
					        return;
				        }

				        CreatePopupMessage(uiUser, FormatString("Action.Heal25.Failed", uiUser.Player, uiUser.CommandTarget1.Name.StripTags()));
			        }),
			        new PluginAction("Action.Heal50", (s) => s.Player.HasPermission(PLAYER_HEAL_PERMISSION), (uiUser) =>
			        {
				        BasePlayer player = (uiUser.CommandTarget1.Object as BasePlayer);
				        if (player)
				        {
					        if (player.IsWounded())
						        player.StopWounded();

					        player.Heal(player.MaxHealth() * 0.5f);
					        CreatePopupMessage(uiUser, FormatString("Action.Heal50.Success", uiUser.Player, uiUser.CommandTarget1.Name.StripTags()));
					        return;
				        }

				        CreatePopupMessage(uiUser, FormatString("Action.Heal50.Failed", uiUser.Player, uiUser.CommandTarget1.Name.StripTags()));
			        }),
			        new PluginAction("Action.Heal75", (s) => s.Player.HasPermission(PLAYER_HEAL_PERMISSION), (uiUser) =>
			        {
				        BasePlayer player = (uiUser.CommandTarget1.Object as BasePlayer);
				        if (player)
				        {
					        if (player.IsWounded())
						        player.StopWounded();

					        player.Heal(player.MaxHealth() * 0.75f);
					        CreatePopupMessage(uiUser, FormatString("Action.Heal75.Success", uiUser.Player, uiUser.CommandTarget1.Name.StripTags()));
					        return;
				        }

				        CreatePopupMessage(uiUser, FormatString("Action.Heal75.Failed", uiUser.Player, uiUser.CommandTarget1.Name.StripTags()));
			        }),
			        new PluginAction("Action.Heal100", (s) => s.Player.HasPermission(PLAYER_HEAL_PERMISSION), (uiUser) =>
			        {
				        BasePlayer player = (uiUser.CommandTarget1.Object as BasePlayer);
				        if (player)
				        {
					        if (player.IsWounded())
						        player.StopWounded();

					        player.Heal(player.MaxHealth());
					        CreatePopupMessage(uiUser, FormatString("Action.Heal100.Success", uiUser.Player, uiUser.CommandTarget1.Name.StripTags()));
					        return;
				        }

				        CreatePopupMessage(uiUser, FormatString("Action.Heal100.Failed", uiUser.Player, uiUser.CommandTarget1.Name.StripTags()));
			        })
		        },
		        new List<PluginAction>()
		        {
			        new PluginAction("Action.TeleportSelfTo", (s) => s.Player.HasPermission(PLAYER_TELEPORT_PERMISSION), uiUser =>
			        {
				        BasePlayer player = (uiUser.CommandTarget1.Object as BasePlayer);
				        if (player)
				        {
					        uiUser.Player.Teleport(player.transform.position);
					        CreatePopupMessage(uiUser, FormatString("Action.TeleportSelfTo.Success", uiUser.Player, uiUser.CommandTarget1.Name.StripTags()));
					        return;
				        }

				        CreatePopupMessage(uiUser, FormatString("Action.TeleportSelfTo.Failed", uiUser.Player, uiUser.CommandTarget1.Name.StripTags()));
			        }),
			        new PluginAction("Action.TeleportToSelf", (s) => s.Player.HasPermission(PLAYER_TELEPORT_PERMISSION), uiUser =>
			        {
				        BasePlayer player = (uiUser.CommandTarget1.Object as BasePlayer);
				        if (player)
				        {
					        player.Teleport(uiUser.Player.transform.position);
					        CreatePopupMessage(uiUser, FormatString("Action.TeleportToSelf.Success", uiUser.Player, uiUser.CommandTarget1.Name.StripTags()));
					        return;
				        }

				        CreatePopupMessage(uiUser, FormatString("Action.TeleportToSelf.Failed", uiUser.Player, uiUser.CommandTarget1.Name.StripTags()));
			        }),
			        new PluginAction("Action.TeleportAuthedItem", (s) => s.Player.HasPermission(PLAYER_TELEPORT_PERMISSION), uiUser =>
			        {
				        BasePlayer player = (uiUser.CommandTarget1.Object as BasePlayer);
				        if (player)
				        {
					        BaseEntity[] entities = BaseEntity.Util.FindTargetsAuthedTo(player.userID, string.Empty);
					        if (entities.Length > 0)
					        {
						        int random = UnityEngine.Random.Range(0, (int) entities.Length);

						        player.Teleport(entities[random].transform.position);
						        CreatePopupMessage(uiUser, FormatString("Action.TeleportAuthedItem.Success", uiUser.Player, entities[random].ShortPrefabName, entities[random].transform.position));
					        }
					        else CreatePopupMessage(uiUser, FormatString("Action.TeleportAuthedItem.Failed.Entities", uiUser.Player, uiUser.CommandTarget1.Name.StripTags()));

					        return;
				        }

				        CreatePopupMessage(uiUser, FormatString("Action.TeleportAuthedItem.Failed", uiUser.Player, uiUser.CommandTarget1.Name.StripTags()));
			        }),
			        new PluginAction("Action.TeleportOwnedItem", (s) => s.Player.HasPermission(PLAYER_TELEPORT_PERMISSION), uiUser =>
			        {
				        BasePlayer player = (uiUser.CommandTarget1.Object as BasePlayer);
				        if (player)
				        {
					        BaseEntity[] entities = BaseEntity.Util.FindTargetsOwnedBy(player.userID, string.Empty);
					        if (entities.Length > 0)
					        {
						        int random = UnityEngine.Random.Range(0, (int) entities.Length);

						        player.Teleport(entities[random].transform.position);
						        CreatePopupMessage(uiUser, FormatString("Action.TeleportOwnedItem.Success", uiUser.Player, entities[random].ShortPrefabName, entities[random].transform.position));
					        }
					        else CreatePopupMessage(uiUser, FormatString("Action.TeleportOwnedItem.Failed.Entities", uiUser.Player, uiUser.CommandTarget1.Name.StripTags()));

					        return;
				        }

				        CreatePopupMessage(uiUser, FormatString("Action.TeleportOwnedItem.Failed", uiUser.Player, uiUser.CommandTarget1.Name.StripTags()));
			        }),
		        },
		        null
	        };

	        foreach (ConfigData.CustomCommands playerInfoCommand in Configuration.PlayerInfoCommands)
	        {
		        if (playerInfoCommand?.Commands?.Count > 0)
		        {
			        List<PluginAction> customActions = new List<PluginAction>();

			        foreach (ConfigData.CustomCommands.PlayerInfoCommandEntry customCommand in playerInfoCommand.Commands)
			        {
				        customActions.Add(new PluginAction(customCommand.Name, () =>
				        {
					        if (!string.IsNullOrEmpty(customCommand.RequiredPlugin) && !plugins.Exists(customCommand.RequiredPlugin))
						        return false;

					        return true;
				        }, (user =>
				        {
					        if (!string.IsNullOrEmpty(customCommand.RequiredPermission) && !user.Player.HasPermission(customCommand.RequiredPermission))
						        return false;

					        return true;
				        }), user => RunCommand(user, customCommand, customCommand.SubType == CommandSubType.Chat)));
			        }

			        m_PluginActions.Add(customActions);
		        }
	        }

	        m_PlayerInfo.Add(new PlayerInfo(string.Empty, null));
	        m_PlayerInfo.Add(new PlayerInfo("PlayerInfo.Clan", (player =>
	        {
		        if (Clans.IsLoaded)
		        {
			        BasePlayer basePlayer = (player.Object as BasePlayer);
			        if (basePlayer)
				        return Clans.GetClanOf(basePlayer) ?? "None";
		        }

		        return string.Empty;
	        })));
	        m_PlayerInfo.Add(new PlayerInfo("PlayerInfo.Playtime", (player =>
	        {
		        if (PlaytimeTracker.IsLoaded)
		        {
			        BasePlayer basePlayer = (player.Object as BasePlayer);
			        if (basePlayer)
			        {
				        object obj = PlaytimeTracker.GetPlayTime(basePlayer.UserIDString);
				        return FormatTime(obj == null ? 0 : (double) obj);
			        }
		        }

		        return string.Empty;
	        })));
	        m_PlayerInfo.Add(new PlayerInfo("PlayerInfo.AFKTime", (player =>
	        {
		        if (PlaytimeTracker.IsLoaded)
		        {
			        BasePlayer basePlayer = (player.Object as BasePlayer);
			        if (basePlayer)
			        {
				        object obj = PlaytimeTracker.GetAFKTime(basePlayer.UserIDString);
				        return FormatTime(obj == null ? 0 : (double) obj);
			        }
		        }

		        return string.Empty;
	        })));
	        m_PlayerInfo.Add(new PlayerInfo("PlayerInfo.ServerRewards", (player =>
	        {
		        if (ServerRewards.IsLoaded)
		        {
			        BasePlayer basePlayer = (player.Object as BasePlayer);
			        if (basePlayer)
			        {
				        object obj = ServerRewards.CheckPoints(basePlayer.UserIDString);
				        return obj == null ? "0" : obj.ToString();
			        }
		        }

		        return string.Empty;
	        })));
	        m_PlayerInfo.Add(new PlayerInfo("PlayerInfo.Economics", (player =>
	        {
		        if (Economics.IsLoaded)
		        {
			        BasePlayer basePlayer = (player.Object as BasePlayer);
			        if (basePlayer)
			        {
				        return Math.Round(Economics.Balance(basePlayer.userID), 2).ToString();
			        }
		        }

		        return string.Empty;
	        })));
        }

        #endregion

        private void RunCommand(UIUser uiUser, ConfigData.CommandEntry commandEntry, bool chat)
        {
	        string command = commandEntry.Command.Replace("{target1_name}", $"\"{uiUser.CommandTarget1?.Name}\"")
										         .Replace("{target1_id}", uiUser.CommandTarget1?.Id)
										         .Replace("{target2_name}", $"\"{uiUser.CommandTarget2?.Name}\"")
										         .Replace("{target2_id}", uiUser.CommandTarget2?.Id);
	        
	        if (chat)
		        rust.RunClientCommand(uiUser.Player, "chat.say", command);
	        else rust.RunServerCommand(command);

	        uiUser.ClearCommand();
	        
	        CreatePopupMessage(uiUser, FormatString("Notification.RunCommand", uiUser.Player, command.Replace("\"", string.Empty)));
	        
	        if (commandEntry.CloseOnRun)
	        {
		        ChaosUI.Destroy(uiUser.Player, ADMINMENU_MOUSE);
		        ChaosUI.Destroy(uiUser.Player, ADMINMENU_UI);
		        m_UIUsers.Remove(uiUser.Player.userID);
	        }
	        else CreateAdminMenu(uiUser.Player);
        }
        #endregion
        
        #region Usergroups

        private void CreateGroupMenu(UIUser uiUser, BaseContainer parent)
        {
	        List<string> src = Facepunch.Pool.GetList<string>();
	        List<string> dst = Facepunch.Pool.GetList<string>();

	        src.AddRange(permission.GetGroups());

	        FilterList(src, dst, uiUser, ((s, pair) => StartsWithValidator(s, pair)), (s, pair) => ContainsValidator(s, pair));

	        CreateCharacterFilter(uiUser, parent);

	        CreateSelectionHeader(uiUser, parent, FormatString("Label.ViewGroups", uiUser.Player, uiUser.PermissionTargetName.StripTags()), m_ListLayout.HasNextPage(uiUser.Page, dst.Count), uiUser.Page > 0, false);

	        ImageContainer.Create(parent, Anchor.FullStretch, new Offset(25f, 0f, 0f, -30f))
		        .WithStyle(m_PanelStyle)
		        .WithLayoutGroup(m_GroupViewLayout, dst, uiUser.Page, (int i, string t, BaseContainer layout, Anchor anchor, Offset offset) =>
		        {
			        ImageContainer.Create(layout, anchor, offset)
				        .WithStyle(m_ButtonStyle)
				        .WithChildren(template =>
				        {
					        TextContainer.Create(template, Anchor.FullStretch, Offset.zero)
						        .WithText(t)
						        .WithAlignment(TextAnchor.MiddleCenter);

					        ImageContainer.Create(template, Anchor.CenterRight, new Offset(-45f, -10f, -5f, 10f))
						        .WithStyle(m_GroupDeleteButton)
						        .WithChildren(button =>
						        {
							        TextContainer.Create(button, Anchor.FullStretch, Offset.zero)
								        .WithSize(10)
								        .WithText(GetString("Button.Delete", uiUser.Player))
								        .WithAlignment(TextAnchor.MiddleCenter);

							        ButtonContainer.Create(button, Anchor.FullStretch, Offset.zero)
								        .WithColor(Color.Clear)
								        .WithCallback(m_CallbackHandler, arg => CreateDeleteGroupOverlay(uiUser, t), $"{uiUser.Player.UserIDString}.delete.{i}");
						        });

					        ImageContainer.Create(template, Anchor.CenterLeft, new Offset(5f, -10f, 45f, 10f))
						        .WithStyle(m_GroupCloneButton)
						        .WithChildren(button =>
						        {
							        TextContainer.Create(button, Anchor.FullStretch, Offset.zero)
								        .WithSize(10)
								        .WithText(GetString("Button.Clone", uiUser.Player))
								        .WithAlignment(TextAnchor.MiddleCenter);

							        ButtonContainer.Create(button, Anchor.FullStretch, Offset.zero)
								        .WithColor(Color.Clear)
								        .WithCallback(m_CallbackHandler, arg => CreateCloneGroupOverlay(uiUser, t), $"{uiUser.Player.UserIDString}.clone.{i}");
						        });
				        });
		        });

	        Facepunch.Pool.FreeList(ref src);
	        Facepunch.Pool.FreeList(ref dst);
        }
        
        private void CreateGroupUsersMenu(UIUser uiUser, BaseContainer parent)
        {
	        if (string.IsNullOrEmpty(uiUser.PermissionTarget))
	        {
		        List<string> dst = Facepunch.Pool.GetList<string>();

		        GetApplicableGroups(uiUser, dst);
		        
		        CreateSelectionHeader(uiUser, parent, GetString("Label.SelectGroup", uiUser.Player), m_ListLayout.HasNextPage(uiUser.Page, dst.Count), uiUser.Page > 0, false);

		        CreateCharacterFilter(uiUser, parent);
		        
		        LayoutSelectionGrid(uiUser, parent,  dst, (s) => s, s =>
		        {
			        uiUser.PermissionTarget = s;
			        CreateAdminMenu(uiUser.Player);
		        });
		        
		        Facepunch.Pool.FreeList(ref dst);
	        }
	        else
	        {
		        List<string> src = Facepunch.Pool.GetList<string>();
		        List<string> dst = Facepunch.Pool.GetList<string>();

		        src.AddRange(permission.GetUsersInGroup(uiUser.PermissionTarget));

		        FilterList(src, dst, uiUser, ((s, pair) => StartsWithValidator(s, pair)), (s, pair) => ContainsValidator(s, pair));

		        CreateCharacterFilter(uiUser, parent);

		        CreateSelectionHeader(uiUser, parent, FormatString("Label.ViewGroupUsers", uiUser.Player, uiUser.PermissionTarget), m_ListLayout.HasNextPage(uiUser.Page, dst.Count), uiUser.Page > 0, false);

		        ImageContainer.Create(parent, Anchor.FullStretch, new Offset(25f, 0f, 0f, -30f))
			        .WithStyle(m_PanelStyle)
			        .WithLayoutGroup(m_GroupViewLayout, dst, uiUser.Page, (int i, string t, BaseContainer layout, Anchor anchor, Offset offset) =>
			        {
				        ImageContainer.Create(layout, anchor, offset)
					        .WithStyle(m_ButtonStyle)
					        .WithChildren(template =>
					        {
						        TextContainer.Create(template, Anchor.FullStretch, Offset.zero)
							        .WithText(t.Substring(18).TrimStart('(').TrimEnd(')'))
							        .WithAlignment(TextAnchor.MiddleCenter);

						        ImageContainer.Create(template, Anchor.CenterRight, new Offset(-45f, -10f, -5f, 10f))
							        .WithStyle(m_GroupDeleteButton)
							        .WithChildren(button =>
							        {
								        TextContainer.Create(button, Anchor.FullStretch, Offset.zero)
									        .WithSize(10)
									        .WithText(GetString("Button.Remove", uiUser.Player))
									        .WithAlignment(TextAnchor.MiddleCenter);

								        ButtonContainer.Create(button, Anchor.FullStretch, Offset.zero)
									        .WithColor(Color.Clear)
									        .WithCallback(m_CallbackHandler, arg =>
									        {
										        string id = t.Split(' ')?[0];
										        if (!string.IsNullOrEmpty(id))
										        {
											        permission.RemoveUserGroup(id, uiUser.PermissionTarget);
											        CreateAdminMenu(uiUser.Player);
										        }
									        }, $"{uiUser.Player.UserIDString}.removegroup.{i}");
							        });
					        });
			        });

		        Facepunch.Pool.FreeList(ref src);
		        Facepunch.Pool.FreeList(ref dst);
	        }
        }

        private void CreateUserGroupsMenu(UIUser uiUser, BaseContainer parent)
        {
	        CreateCharacterFilter(uiUser, parent);

	        if (string.IsNullOrEmpty(uiUser.PermissionTarget))
	        {
		        List<IPlayer> dst = Facepunch.Pool.GetList<IPlayer>();

		        GetApplicablePlayers(uiUser, dst);

		        CreateSelectionHeader(uiUser, parent, GetString("Label.SelectPlayer", uiUser.Player), m_ListLayout.HasNextPage(uiUser.Page, dst.Count), uiUser.Page > 0, true);

		        LayoutSelectionGrid(uiUser, parent, dst, (s) => s.Name.StripTags(), player =>
		        {
			        uiUser.CharacterFilter = m_CharacterFilter[0];
			        uiUser.SearchFilter = string.Empty;
			        uiUser.PermissionTarget = player.Id;
			        uiUser.PermissionTargetName = player.Name;
		        });

		        Facepunch.Pool.FreeList(ref dst);
	        }
	        else
	        {
		        List<string> dst = Facepunch.Pool.GetList<string>();
		        GetApplicableGroups(uiUser, dst);

		        CreateSelectionHeader(uiUser, parent, FormatString("Label.ToggleGroup", uiUser.Player, uiUser.PermissionTargetName.StripTags()), m_ListLayout.HasNextPage(uiUser.Page, dst.Count), uiUser.Page > 0, false);

		        ImageContainer.Create(parent, Anchor.FullStretch, new Offset(25f, 0f, 0f, -30f))
			        .WithStyle(m_PanelStyle)
			        .WithLayoutGroup(m_ListLayout, dst, uiUser.Page, (int i, string t, BaseContainer permissionLayout, Anchor anchor, Offset offset) =>
			        {
				        bool isInGroup = permission.UserHasGroup(uiUser.PermissionTarget, t);

				        BaseContainer permissionEntry = ImageContainer.Create(permissionLayout, anchor, offset)
					        .WithStyle(m_PermissionStyle)
					        .WithChildren(template =>
					        {
						        TextContainer.Create(template, Anchor.FullStretch, new Offset(5, 0, -5, 0))
							        .WithText(t)
							        .WithAlignment(TextAnchor.MiddleCenter);

						        ButtonContainer.Create(template, Anchor.FullStretch, Offset.zero)
							        .WithColor(Color.Clear)
							        .WithCallback(m_CallbackHandler, arg =>
							        {
								        if (isInGroup)
									        permission.RemoveUserGroup(uiUser.PermissionTarget, t);
								        else permission.AddUserGroup(uiUser.PermissionTarget, t);

								        CreateAdminMenu(uiUser.Player);
							        }, $"{uiUser.Player.UserIDString}.group.{i}");
					        });

				        if (isInGroup)
					        permissionEntry.WithOutline(m_OutlineGreen);
			        });

		        Facepunch.Pool.FreeList(ref dst);
	        }
        }

        private void CreateGroupCreateOverlay(UIUser uiUser)
        {
	        BaseContainer baseContainer = ButtonContainer.Create(ADMINMENU_UI, Layer.Overall, Anchor.FullStretch, Offset.zero)
		        .WithStyle(m_BackgroundStyle)
		        .WithCallback(m_CallbackHandler, arg =>
		        {
			        uiUser.SubMenuIndex = 0;
			        CreateAdminMenu(uiUser.Player);
		        }, $"{uiUser.Player.UserIDString}.cancel")
		        .WithChildren(createGroupPopup =>
				{
					ImageContainer.Create(createGroupPopup, Anchor.Center, new Offset(-175f, 60f, 175f, 80f))
						.WithStyle(m_PanelStyle)
						.WithChildren(title =>
						{
							TextContainer.Create(title, Anchor.FullStretch, Offset.zero)
								.WithText(GetString("Label.CreateUsergroup", uiUser.Player))
								.WithAlignment(TextAnchor.MiddleCenter);

						});

					ImageContainer.Create(createGroupPopup, Anchor.Center, new Offset(-175f, -55f, 175f, 55f))
						.WithStyle(m_PanelStyle)
						.WithChildren(inputs =>
						{
							TextContainer.Create(inputs, Anchor.TopStretch, new Offset(5f, -25f, -145f, -5f))
								.WithText(GetString("Label.Name", uiUser.Player))
								.WithAlignment(TextAnchor.MiddleLeft);

							ImageContainer.Create(inputs, Anchor.TopStretch, new Offset(120f, -25f, -4.999996f, -5f))
								.WithStyle(m_ButtonStyle)
								.WithChildren(nameInput =>
								{
									InputFieldContainer.Create(nameInput, Anchor.FullStretch, new Offset(5f, 0f, -5f, 0f))
										.WithText(uiUser.GroupName)
										.WithAlignment(TextAnchor.MiddleLeft)
										.WithCallback(m_CallbackHandler, arg =>
										{
											uiUser.GroupName = arg.GetString(1);
										}, $"{uiUser.Player.UserIDString}.name.input");
								});

							TextContainer.Create(inputs, Anchor.TopStretch, new Offset(5f, -50f, -145f, -30f))
								.WithText(GetString("Label.Title", uiUser.Player))
								.WithAlignment(TextAnchor.MiddleLeft);

							ImageContainer.Create(inputs, Anchor.TopStretch, new Offset(120f, -50f, -4.999996f, -30f))
								.WithStyle(m_ButtonStyle)
								.WithChildren(titleInput =>
								{
									InputFieldContainer.Create(titleInput, Anchor.FullStretch, new Offset(5f, 0f, -5f, 0f))
										.WithText(uiUser.GroupTitle)
										.WithAlignment(TextAnchor.MiddleLeft)
										.WithCallback(m_CallbackHandler, arg =>
										{
											uiUser.GroupTitle = arg.GetString(1);
										}, $"{uiUser.Player.UserIDString}.title.input");
								});

							TextContainer.Create(inputs, Anchor.TopStretch, new Offset(5f, -75f, -145f, -55f))
								.WithText(GetString("Label.Rank", uiUser.Player))
								.WithAlignment(TextAnchor.MiddleLeft);

							ImageContainer.Create(inputs, Anchor.TopStretch, new Offset(120f, -75f, -4.999969f, -55f))
								.WithStyle(m_ButtonStyle)
								.WithChildren(rankInput =>
								{
									InputFieldContainer.Create(rankInput, Anchor.FullStretch, new Offset(5f, 0f, -5f, 0f))
										.WithText(uiUser.GroupRank.ToString())
										.WithAlignment(TextAnchor.MiddleLeft)
										.WithCallback(m_CallbackHandler, arg =>
										{
											uiUser.GroupRank = arg.GetInt(1);
											CreateGroupCreateOverlay(uiUser);
										}, $"{uiUser.Player.UserIDString}.rank.input");
								});

							ImageContainer.Create(inputs, Anchor.BottomLeft, new Offset(5f, 5f, 95f, 25f))
								.WithStyle(m_ButtonStyle)
								.WithOutline(m_OutlineGreen)
								.WithChildren(create =>
								{
									TextContainer.Create(create, Anchor.FullStretch, Offset.zero)
										.WithText(GetString("Button.Create", uiUser.Player))
										.WithAlignment(TextAnchor.MiddleCenter);

									ButtonContainer.Create(create, Anchor.FullStretch, Offset.zero)
										.WithColor(Color.Clear)
										.WithCallback(m_CallbackHandler, arg =>
										{
											if (string.IsNullOrEmpty(uiUser.GroupName))
											{
												CreatePopupMessage(uiUser, "You must enter a group name");
												return;
											}

											if (permission.GroupExists(uiUser.GroupName))
											{
												CreatePopupMessage(uiUser, "A group with that name already exists");
												return;
											}
											
											permission.CreateGroup(uiUser.GroupName, uiUser.GroupTitle, uiUser.GroupRank);
											
											uiUser.ClearGroup();
											uiUser.SubMenuIndex = 0;
											CreateAdminMenu(uiUser.Player);
											CreatePopupMessage(uiUser, "Group created");
										},$"{uiUser.Player.UserIDString}.create");

								});

							ImageContainer.Create(inputs, Anchor.BottomRight, new Offset(-95f, 5f, -5f, 25f))
								.WithStyle(m_ButtonStyle)
								.WithOutline(m_OutlineRed)
								.WithChildren(cancel =>
								{
									TextContainer.Create(cancel, Anchor.FullStretch, Offset.zero)
										.WithText(GetString("Button.Cancel", uiUser.Player))
										.WithAlignment(TextAnchor.MiddleCenter);

									ButtonContainer.Create(cancel, Anchor.FullStretch, Offset.zero)
										.WithColor(Color.Clear)
										.WithCallback(m_CallbackHandler, arg =>
										{
											uiUser.SubMenuIndex = 0;
											CreateAdminMenu(uiUser.Player);
										},$"{uiUser.Player.UserIDString}.cancel");

								});
						});
				});
		        //.NeedsCursor()
		        //.NeedsKeyboard();
	        
	        ChaosUI.Destroy(uiUser.Player, ADMINMENU_UI);
	        ChaosUI.Show(uiUser.Player, baseContainer);
        }

        private void CreateCloneGroupOverlay(UIUser uiUser, string usergroup)
        {
	        BaseContainer baseContainer = ButtonContainer.Create(ADMINMENU_UI, Layer.Overall, Anchor.FullStretch, Offset.zero)
				.WithStyle(m_BackgroundStyle)
				.WithCallback(m_CallbackHandler, arg => CreateAdminMenu(uiUser.Player), $"{uiUser.Player.UserIDString}.cancel")
				.WithChildren(cloneGroupPopup =>
				{
					ImageContainer.Create(cloneGroupPopup, Anchor.Center, new Offset(-175f, 72.5f, 175f, 92.5f))
						.WithStyle(m_PanelStyle)
						.WithChildren(title =>
						{
							TextContainer.Create(title, Anchor.FullStretch, Offset.zero)
								.WithText(FormatString("Label.CloneUsergroup", uiUser.Player, usergroup))
								.WithAlignment(TextAnchor.MiddleCenter);

						});

					ImageContainer.Create(cloneGroupPopup, Anchor.Center, new Offset(-175f, -67.5f, 175f, 67.5f))
						.WithStyle(m_PanelStyle)
						.WithChildren(inputs =>
						{
							TextContainer.Create(inputs, Anchor.TopStretch, new Offset(5f, -25f, -145f, -5f))
								.WithText(GetString("Label.Name", uiUser.Player))
								.WithAlignment(TextAnchor.MiddleLeft);

							ImageContainer.Create(inputs, Anchor.TopStretch, new Offset(120f, -25f, -4.999996f, -5f))
								.WithStyle(m_ButtonStyle)
								.WithChildren(nameInput =>
								{
									InputFieldContainer.Create(nameInput, Anchor.FullStretch, new Offset(5f, 0f, -5f, 0f))
										.WithText(uiUser.GroupName)
										.WithAlignment(TextAnchor.MiddleLeft)
										.WithCallback(m_CallbackHandler, arg =>
										{
											uiUser.GroupName = arg.GetString(1);
										}, $"{uiUser.Player.UserIDString}.name.input");
								});

							TextContainer.Create(inputs, Anchor.TopStretch, new Offset(5f, -50f, -145f, -30f))
								.WithText(GetString("Label.Title", uiUser.Player))
								.WithAlignment(TextAnchor.MiddleLeft);

							ImageContainer.Create(inputs, Anchor.TopStretch, new Offset(120f, -50f, -4.999996f, -30f))
								.WithStyle(m_ButtonStyle)
								.WithChildren(titleInput =>
								{
									InputFieldContainer.Create(titleInput, Anchor.FullStretch, new Offset(5f, 0f, -5f, 0f))
										.WithText(uiUser.GroupTitle)
										.WithAlignment(TextAnchor.MiddleLeft)
										.WithCallback(m_CallbackHandler, arg =>
										{
											uiUser.GroupTitle = arg.GetString(1);
										}, $"{uiUser.Player.UserIDString}.title.input");
								});

							TextContainer.Create(inputs, Anchor.TopStretch, new Offset(5f, -75f, -145f, -55f))
								.WithText(GetString("Label.Rank", uiUser.Player))
								.WithAlignment(TextAnchor.MiddleLeft);

							ImageContainer.Create(inputs, Anchor.TopStretch, new Offset(120f, -75f, -4.999969f, -55f))
								.WithStyle(m_ButtonStyle)
								.WithChildren(rankInput =>
								{
									InputFieldContainer.Create(rankInput, Anchor.FullStretch, new Offset(5f, 0f, -5f, 0f))
										.WithAlignment(TextAnchor.MiddleLeft)
										.WithText(uiUser.GroupRank.ToString())
										.WithCallback(m_CallbackHandler, arg =>
										{
											uiUser.GroupRank = arg.GetInt(1);
											CreateCloneGroupOverlay(uiUser, usergroup);
										}, $"{uiUser.Player.UserIDString}.rank.input");

								});

							ImageContainer.Create(inputs, Anchor.TopStretch, new Offset(120f, -100f, -210f, -80f))
								.WithStyle(m_ButtonStyle)
								.WithChildren(toggle =>
								{
									if (uiUser.CopyUsers)
									{
										TextContainer.Create(toggle, Anchor.FullStretch, Offset.zero)
											.WithStyle(m_ToggleLabelStyle)
											.WithText("•");
									}

									ButtonContainer.Create(toggle, Anchor.FullStretch, Offset.zero)
										.WithColor(Color.Clear)
										.WithCallback(m_CallbackHandler, arg =>
										{
											uiUser.CopyUsers = !uiUser.CopyUsers;
											CreateCloneGroupOverlay(uiUser, usergroup);
										},$"{uiUser.Player.UserIDString}.rank.input");

									TextContainer.Create(toggle, Anchor.CenterLeft, new Offset(-115f, -10f, -15f, 10f))
										.WithText(GetString("Label.CopyUsers", uiUser.Player))
										.WithAlignment(TextAnchor.MiddleLeft);

								});

							ImageContainer.Create(inputs, Anchor.BottomLeft, new Offset(5f, 5f, 95f, 25f))
								.WithStyle(m_ButtonStyle)
								.WithOutline(m_OutlineGreen)
								.WithChildren(create =>
								{
									TextContainer.Create(create, Anchor.FullStretch, Offset.zero)
										.WithText(GetString("Button.Create", uiUser.Player))
										.WithAlignment(TextAnchor.MiddleCenter);

									ButtonContainer.Create(create, Anchor.FullStretch, Offset.zero)
										.WithColor(Color.Clear)
										.WithCallback(m_CallbackHandler, arg =>
										{
											if (string.IsNullOrEmpty(uiUser.GroupName))
											{
												CreatePopupMessage(uiUser, "You must enter a group name");
												return;
											}

											if (permission.GroupExists(uiUser.GroupName))
											{
												CreatePopupMessage(uiUser, "A group with that name already exists");
												return;
											}

											if (permission.CreateGroup(uiUser.GroupName, uiUser.GroupTitle, uiUser.GroupRank))
											{
												string[] perms = permission.GetGroupPermissions(usergroup);
												
												for (int i = 0; i < perms.Length; i++)
													permission.GrantGroupPermission(uiUser.GroupName, perms[i], null);

												if (uiUser.CopyUsers)
												{
													string[] users = permission.GetUsersInGroup(usergroup);
													for (int i = 0; i < users.Length; i++)
													{
														string userId = users[i].Split(' ')?[0];
														if (!string.IsNullOrEmpty(userId))
															userId.AddToGroup(uiUser.GroupName);
													}
												}
											}
											
											uiUser.ClearGroup();
											uiUser.SubMenuIndex = 0;
											CreateAdminMenu(uiUser.Player);
											CreatePopupMessage(uiUser, "Group cloned successfully");
										},$"{uiUser.Player.UserIDString}.create");

								});

							ImageContainer.Create(inputs, Anchor.BottomRight, new Offset(-95f, 5f, -5f, 25f))
								.WithStyle(m_ButtonStyle)
								.WithOutline(m_OutlineRed)
								.WithChildren(cancel =>
								{
									TextContainer.Create(cancel, Anchor.FullStretch, Offset.zero)
										.WithText(GetString("Button.Cancel", uiUser.Player))
										.WithAlignment(TextAnchor.MiddleCenter);

									ButtonContainer.Create(cancel, Anchor.FullStretch, Offset.zero)
										.WithColor(Color.Clear)
										.WithCallback(m_CallbackHandler, arg => CreateAdminMenu(uiUser.Player), $"{uiUser.Player.UserIDString}.cancel");
								});
						});
				});
				//.NeedsCursor()
				//.NeedsKeyboard();
	        
	        ChaosUI.Destroy(uiUser.Player, ADMINMENU_UI);
	        ChaosUI.Show(uiUser.Player, baseContainer);
        }

        private void CreateDeleteGroupOverlay(UIUser uiUser, string usergroup)
        {
	        BaseContainer baseContainer = ButtonContainer.Create(ADMINMENU_UI, Layer.Overall, Anchor.FullStretch, Offset.zero)
		        .WithStyle(m_BackgroundStyle)
		        .WithCallback(m_CallbackHandler, arg => CreateAdminMenu(uiUser.Player), $"{uiUser.Player.UserIDString}.cancel")
		        .WithChildren(deleteGroupPopup =>
		        {
			        ImageContainer.Create(deleteGroupPopup, Anchor.Center, new Offset(-150f, 20f, 150f, 40f))
				        .WithStyle(m_PanelStyle)
				        .WithChildren(title =>
				        {
					        TextContainer.Create(title, Anchor.FullStretch, Offset.zero)
						        .WithText(FormatString("Label.DeleteConfirm", uiUser.Player, usergroup))
						        .WithAlignment(TextAnchor.MiddleCenter);
				        });

			        ImageContainer.Create(deleteGroupPopup, Anchor.Center, new Offset(-150f, -15f, 150f, 15f))
				        .WithStyle(m_PanelStyle)
				        .WithChildren(inputs =>
				        {
					        ImageContainer.Create(inputs, Anchor.BottomLeft, new Offset(5f, 5f, 135f, 25f))
						        .WithStyle(m_ButtonStyle)
						        .WithOutline(m_OutlineGreen)
						        .WithChildren(confirm =>
						        {
							        TextContainer.Create(confirm, Anchor.FullStretch, Offset.zero)
								        .WithText(GetString("Button.Confirm", uiUser.Player))
								        .WithAlignment(TextAnchor.MiddleCenter);

							        ButtonContainer.Create(confirm, Anchor.FullStretch, Offset.zero)
								        .WithColor(Color.Clear)
								        .WithCallback(m_CallbackHandler, arg =>
								        {
									        permission.RemoveGroup(usergroup);
									        CreateAdminMenu(uiUser.Player);
								        }, $"{uiUser.Player.UserIDString}.delete");

						        });

					        ImageContainer.Create(inputs, Anchor.BottomRight, new Offset(-135f, 5f, -5f, 25f))
						        .WithStyle(m_ButtonStyle)
						        .WithOutline(m_OutlineRed)
						        .WithChildren(cancel =>
						        {
							        TextContainer.Create(cancel, Anchor.FullStretch, Offset.zero)
								        .WithText(GetString("Button.Cancel", uiUser.Player))
								        .WithAlignment(TextAnchor.MiddleCenter);

							        ButtonContainer.Create(cancel, Anchor.FullStretch, Offset.zero)
								        .WithColor(Color.Clear)
								        .WithCallback(m_CallbackHandler, arg => CreateAdminMenu(uiUser.Player), $"{uiUser.Player.UserIDString}.cancel");

						        });
				        });
		        });
		        //.NeedsCursor()
		        //.NeedsKeyboard();
	        
	        ChaosUI.Destroy(uiUser.Player, ADMINMENU_UI);
	        ChaosUI.Show(uiUser.Player, baseContainer);
        }

        #endregion
        
        #region Convars
        private void CreateConvarMenu(UIUser uiUser, BaseContainer parent)
        {
	        List<ConsoleSystem.Command> src = Facepunch.Pool.GetList<ConsoleSystem.Command>();
	        List<ConsoleSystem.Command> dst = Facepunch.Pool.GetList<ConsoleSystem.Command>();

	        src.AddRange(ConsoleGen.All.Where(x => x.ServerAdmin && x.Variable));
	        
	        FilterList(src, dst, uiUser, (s, command) => StartsWithValidator(s, command.FullName), (s, command) => ContainsValidator(s, command.FullName));

	        CreateCharacterFilter(uiUser, parent);
			        
	        CreateSelectionHeader(uiUser, parent, string.Empty, m_ListLayout.HasNextPage(uiUser.Page, dst.Count), uiUser.Page > 0, false);
	        
	        ImageContainer.Create(parent, Anchor.FullStretch, new Offset(25f, 0f, 0f, -30f))
		        .WithStyle(m_PanelStyle)
		        .WithLayoutGroup(m_ConvarLayout, dst, uiUser.Page, (int i, ConsoleSystem.Command t, BaseContainer layout, Anchor anchor, Offset offset) =>
		        {
			        ImageContainer.Create(layout, anchor, offset)
				        .WithStyle(m_ConvarStyle)
				        .WithChildren(template =>
				        {
					        TextContainer.Create(template, Anchor.FullStretch, new Offset(5f, 13f, -130f, -1f))
						        .WithSize(12)
						        .WithText(t.FullName);

					        if (!string.IsNullOrEmpty(t.Description))
					        {
						        TextContainer.Create(template, Anchor.FullStretch, new Offset(5f, 1f, -130f, -15f))
							        .WithStyle(m_ConvarDescriptionStyle)
							        .WithText(t.Description);
					        }

					        ImageContainer.Create(template, Anchor.CenterRight, new Offset(-125f, -10f, -5f, 10f))
						        .WithStyle(m_ButtonStyle)
						        .WithChildren(input =>
						        {
							        InputFieldContainer.Create(input, Anchor.FullStretch, Offset.zero)
								        .WithSize(12)
								        .WithText(t.String)
								        .WithAlignment(TextAnchor.MiddleCenter)
								        .WithCallback(m_CallbackHandler, arg =>
								        {
									        ConsoleSystem.Run(ConsoleSystem.Option.Server, t.FullName, arg.GetString(1));
									        CreateAdminMenu(uiUser.Player);
								        }, $"{uiUser.Player.UserIDString}.convar.{i}");
						        });
				        });
		        });
	        
	        Facepunch.Pool.FreeList(ref src);
	        Facepunch.Pool.FreeList(ref dst);
        }
        #endregion

		#region Filters
        private void CreateCharacterFilter(UIUser uiUser, BaseContainer parent)
        {
	        ImageContainer.Create(parent, Anchor.LeftStretch, new Offset(0f, 0f, 20f, -30f))
		        .WithStyle(m_PanelStyle)
		        .WithLayoutGroup(m_CharacterFilterLayout, m_CharacterFilter, 0, (int i, string t, BaseContainer filterList, Anchor anchor, Offset offset) =>
		        {
			        BaseContainer filterButton = ImageContainer.Create(filterList, anchor, offset)
				        .WithStyle(m_ButtonStyle)
				        .WithChildren(characterTemplate =>
				        {
					        TextContainer.Create(characterTemplate, Anchor.FullStretch, Offset.zero)
						        .WithSize(12)
						        .WithText(t)
						        .WithAlignment(TextAnchor.MiddleCenter);

					        if (t != uiUser.CharacterFilter)
					        {
						        ButtonContainer.Create(characterTemplate, Anchor.FullStretch, Offset.zero)
							        .WithColor(Color.Clear)
							        .WithCallback(m_CallbackHandler, arg =>
							        {
								        uiUser.CharacterFilter = t;
								        uiUser.Page = 0;
								        CreateAdminMenu(uiUser.Player);
							        }, $"{uiUser.Player.UserIDString}.filter.{i}");
					        }
				        });

			        if (t == uiUser.CharacterFilter)
				        filterButton.WithOutline(m_OutlineGreen);
		        });
        }
        
        private void FilterList<T>(List<T> src, List<T> dst, UIUser uiUser, Func<string, T, bool> startsWith, Func<string, T, bool> contains)
        {
	        bool useCharacterFilter = !string.IsNullOrEmpty(uiUser.CharacterFilter) && uiUser.CharacterFilter != m_CharacterFilter[0];
	        bool useSearchFilter = !string.IsNullOrEmpty(uiUser.SearchFilter);
				        
	        if (!useCharacterFilter && !useSearchFilter)
		        dst.AddRange(src);
	        else
	        {
		        for (int i = 0; i < src.Count; i++)
		        {
			        T t = src[i];

			        if (useSearchFilter && useCharacterFilter)
			        {
				        if (startsWith(uiUser.CharacterFilter, t) && contains(uiUser.SearchFilter, t))
					        dst.Add(t);

				        continue;
			        }

			        if (useCharacterFilter)
			        {
				        if (startsWith(uiUser.CharacterFilter, t))
					        dst.Add(t);
				        
				        continue;
			        }
						        
			        if (useSearchFilter && contains(uiUser.SearchFilter, t))
				        dst.Add(t);
		        }
	        }
        }

        private bool StartsWithValidator(string character, string phrase) => phrase.StartsWith(character, StringComparison.OrdinalIgnoreCase);
        
        private bool ContainsValidator(string character, string phrase) => phrase.Contains(character, CompareOptions.OrdinalIgnoreCase);
        
        private void GetApplicablePlayers(UIUser uiUser, List<IPlayer> dst)
        {
	        List<IPlayer> src = Facepunch.Pool.GetList<IPlayer>();

	        if (uiUser.ShowOnlinePlayers)
		        src.AddRange(covalence.Players.Connected);

	        if (uiUser.ShowOfflinePlayers)
		        m_RecentPlayers.Data.GetRecentPlayers(covalence.Players.All, ref src);

	        FilterList(src, dst, uiUser, (s, player) => StartsWithValidator(s, player.Name.StripTags()), (s, player) => ContainsValidator(s, player.Name.StripTags()));

	        Facepunch.Pool.FreeList(ref src);
        }

        private void GetApplicableGroups(UIUser uiUser, List<string> dst)
        {
	        List<string> src = Facepunch.Pool.GetList<string>();

	        src.AddRange(permission.GetGroups());

	        FilterList(src, dst, uiUser, (s, group) => StartsWithValidator(s, group), (s, group) => ContainsValidator(s, group));

	        Facepunch.Pool.FreeList(ref src);
        }
        #endregion
        
        #region Permission Toggling

        private void CreatePermissionsMenu(UIUser uiUser, BaseContainer parent)
        {
	        CreateCharacterFilter(uiUser, parent);

	        if (string.IsNullOrEmpty(uiUser.PermissionTarget))
	        {
		        if (uiUser.SubMenuIndex == 0)
		        {
			        List<IPlayer> dst = Facepunch.Pool.GetList<IPlayer>();

			        GetApplicablePlayers(uiUser, dst);

			        CreateSelectionHeader(uiUser, parent, GetString("Label.SelectPlayer", uiUser.Player), m_ListLayout.HasNextPage(uiUser.Page, dst.Count), uiUser.Page > 0, true);

			        LayoutSelectionGrid(uiUser, parent, dst, (s) => s.Name.StripTags(), player =>
			        {
				        uiUser.CharacterFilter = m_CharacterFilter[0];
				        uiUser.SearchFilter = string.Empty;
				        uiUser.PermissionTarget = player.Id;
				        uiUser.PermissionTargetName = player.Name;
			        });

			        Facepunch.Pool.FreeList(ref dst);
		        }
		        else
		        {
			        List<string> dst = Facepunch.Pool.GetList<string>();

			        GetApplicableGroups(uiUser, dst);

			        CreateSelectionHeader(uiUser, parent, GetString("Label.SelectGroup", uiUser.Player), m_ListLayout.HasNextPage(uiUser.Page, dst.Count), uiUser.Page > 0, true);

			        LayoutSelectionGrid(uiUser, parent, dst, (s) => s, s =>
			        {
				        uiUser.PermissionTarget = uiUser.PermissionTargetName = s;
				        uiUser.CharacterFilter = m_CharacterFilter[0];
				        uiUser.SearchFilter = string.Empty;
			        });

			        Facepunch.Pool.FreeList(ref dst);
		        }
	        }
	        else
	        {
		        List<KeyValuePair<string, bool>> dst = Facepunch.Pool.GetList<KeyValuePair<string, bool>>();

		        if (uiUser.CharacterFilter != m_CharacterFilter[0] || !string.IsNullOrEmpty(uiUser.SearchFilter))
		        {
			        List<KeyValuePair<string, bool>> src = Facepunch.Pool.GetList<KeyValuePair<string, bool>>();
			        
			        for (int i = 0; i < m_Permissions.Count; i++)
			        {
				        KeyValuePair<string, bool> kvp = m_Permissions[i];
				        if (kvp.Value)
							src.Add(kvp);
			        }
			        
			        FilterList(src, dst, uiUser, ((s, pair) => StartsWithValidator(s, pair.Key)), (s, pair) => ContainsValidator(s, pair.Key));
			        Facepunch.Pool.FreeList(ref src);

		        }
		        else dst.AddRange(m_Permissions);

		        BaseContainer header = CreateSelectionHeader(uiUser, parent, FormatString("Label.TogglePermission", uiUser.Player, uiUser.PermissionTargetName.StripTags()), m_ListLayout.HasNextPage(uiUser.Page, dst.Count), uiUser.Page > 0, false);

		        if (uiUser.SubMenuIndex == 0)
		        {
			        ImageContainer.Create(header, Anchor.CenterLeft, new Offset(40f, -5f, 50f, 5f))
				        .WithColor(m_OutlineGreen.Color)
				        .WithSprite(Sprites.Background_Rounded)
				        .WithImageType(Image.Type.Tiled)
				        .WithChildren(permissionColorHas =>
				        {
					        TextContainer.Create(permissionColorHas, Anchor.CenterRight, new Offset(5f, -10f, 155f, 10f))
						        .WithSize(12)
						        .WithText(GetString("Label.DirectPermission", uiUser.Player))
						        .WithAlignment(TextAnchor.MiddleLeft);

				        });

			        ImageContainer.Create(header, Anchor.CenterLeft, new Offset(165f, -5f, 175f, 5f))
				        .WithColor(m_OutlineBlue.Color)
				        .WithSprite(Sprites.Background_Rounded)
				        .WithImageType(Image.Type.Tiled)
				        .WithChildren(permissionColorInherit =>
				        {
					        TextContainer.Create(permissionColorInherit, Anchor.CenterRight, new Offset(5f, -10f, 155f, 10f))
						        .WithSize(12)
						        .WithText(GetString("Label.InheritedPermission", uiUser.Player))
						        .WithAlignment(TextAnchor.MiddleLeft);

				        });

		        }
		        LayoutPermissionGrid(uiUser, parent, dst);

		        Facepunch.Pool.FreeList(ref dst);
	        }
        }

        private void LayoutPermissionGrid(UIUser uiUser, BaseContainer parent, List<KeyValuePair<string, bool>> list)
        {
	        ImageContainer.Create(parent, Anchor.FullStretch, new Offset(25f, 0f, 0f, -30f))
		        .WithStyle(m_PanelStyle)
		        .WithLayoutGroup(m_ListLayout, list, uiUser.Page, (int i, KeyValuePair<string, bool> t, BaseContainer permissionLayout, Anchor anchor, Offset offset) =>
		        {
			        bool isUserPermission = uiUser.SubMenuIndex == 0;
			        bool isGroupPermission = uiUser.SubMenuIndex == 1;

			        bool hasPermission = (isUserPermission && UserHasPermissionNoGroup(uiUser.PermissionTarget, t.Key)) || (isGroupPermission && permission.GroupHasPermission(uiUser.PermissionTarget, t.Key));
			        bool usersGroupHasPermission = isUserPermission && UsersGroupsHavePermission(uiUser.PermissionTarget, t.Key);
			        
			        BaseContainer permissionEntry = ImageContainer.Create(permissionLayout, anchor, offset + (t.Value ? new Offset(5f, 0f, -5f, 0f) : Offset.zero))
				        .WithStyle(t.Value ? m_PermissionStyle : m_PermissionHeaderStyle)
				        .WithChildren(template =>
				        {
					        if (t.Key.Contains("."))
					        {
						        int index = t.Key.IndexOf(".");
						       
						        TextContainer.Create(template, Anchor.FullStretch, new Offset(5, 1, -5, -1))
							        .WithText(t.Key.Substring(0, index))
							        .WithStyle(t.Value ? m_PermissionStyle : m_PermissionHeaderStyle)
							        .WithAlignment(TextAnchor.UpperCenter);

						        TextContainer.Create(template, Anchor.FullStretch, new Offset(5, 1, -5, -1))
							        .WithText(t.Key.Substring(index + 1))
							        .WithStyle(t.Value ? m_PermissionStyle : m_PermissionHeaderStyle)
							        .WithAlignment(TextAnchor.LowerCenter);
					        }
					        else
					        {
						        TextContainer.Create(template, Anchor.FullStretch, new Offset(5, 0, -5, 0))
							        .WithText(t.Key)
							        .WithStyle(t.Value ? m_PermissionStyle : m_PermissionHeaderStyle);
					        }
				        

							if (isUserPermission || isGroupPermission)
					        {
						        ButtonContainer.Create(template, Anchor.FullStretch, Offset.zero)
							        .WithColor(Color.Clear)
							        .WithCallback(m_CallbackHandler, arg =>
							        {
								        if (isUserPermission)
								        {
									        if (hasPermission)
										        permission.RevokeUserPermission(uiUser.PermissionTarget, t.Key);
									        else permission.GrantUserPermission(uiUser.PermissionTarget, t.Key, null);
								        }

								        if (isGroupPermission)
								        {
									        if (hasPermission)
										        permission.RevokeGroupPermission(uiUser.PermissionTarget, t.Key);
									        else permission.GrantGroupPermission(uiUser.PermissionTarget, t.Key, null);
								        }

								        CreateAdminMenu(uiUser.Player);
							        }, $"{uiUser.Player.UserIDString}.permission.{i}");
					        }
				        });

			        if (!t.Value)
				        permissionEntry.WithOutline(m_OutlineWhite);
			        else
			        {
				        if (hasPermission)
					        permissionEntry.WithOutline(m_OutlineGreen);

				        if (!hasPermission && usersGroupHasPermission)
					        permissionEntry.WithOutline(m_OutlineBlue);
			        }
		        });
        }
        #endregion
        
        #region Selection Grid
        private void LayoutSelectionGrid<T>(UIUser uiUser, BaseContainer parent, List<T> list, Func<T, string> asString,Action<T> callback)
        {
	        ImageContainer.Create(parent, Anchor.FullStretch, new Offset(25f, 0f, 0f, -30f))
		        .WithStyle(m_PanelStyle)
		        .WithLayoutGroup(m_ListLayout, list, uiUser.Page, (int i, T t, BaseContainer layout, Anchor anchor, Offset offset) =>
		        {
			        ImageContainer.Create(layout, anchor, offset)
				        .WithStyle(m_ButtonStyle)
				        .WithChildren(header =>
				        {
					        TextContainer.Create(header, Anchor.FullStretch, Offset.zero)
						        .WithText(asString(t))
						        .WithAlignment(TextAnchor.MiddleCenter);

					        ButtonContainer.Create(header, Anchor.FullStretch, Offset.zero)
						        .WithColor(Color.Clear)
						        .WithCallback(m_CallbackHandler, arg =>
						        {
							        callback.Invoke(t);
							        CreateAdminMenu(uiUser.Player);
						        }, $"{uiUser.Player.UserIDString}.select.{i}");
				        });
		        });
        }
        #endregion
        
        #region Popup Message

        private Hash<ulong, Timer> m_PopupTimers = new Hash<ulong, Timer>();

        private void CreatePopupMessage(UIUser uiUser, string message)
        {
	        BaseContainer baseContainer = ImageContainer.Create(ADMINMENU_UI_POPUP, Layer.Overall, Anchor.Center, new Offset(-540f, -345f, 540f, -315f))
		        .WithStyle(m_BackgroundStyle)
		        .WithChildren(popup =>
		        {
			        ImageContainer.Create(popup, Anchor.FullStretch, new Offset(5f, 5f, -5f, -5f))
				        .WithStyle(m_PanelStyle)
				        .WithChildren(titleBar =>
				        {
					        TextContainer.Create(titleBar, Anchor.FullStretch, Offset.zero)
						        .WithText(message)
						        .WithAlignment(TextAnchor.MiddleCenter);

				        });
		        });
			
	        ChaosUI.Destroy(uiUser.Player, ADMINMENU_UI_POPUP);
	        ChaosUI.Show(uiUser.Player, baseContainer);

	        Timer t;
	        if (m_PopupTimers.TryGetValue(uiUser.Player.userID, out t))
		        t?.Destroy();

	        m_PopupTimers[uiUser.Player.userID] = timer.Once(5f, () => ChaosUI.Destroy(uiUser.Player, ADMINMENU_UI_POPUP));
        }
        #endregion
        #endregion
        
        #region Configuration
        private ConfigData Configuration => ConfigurationData as ConfigData;
        

        protected override ConfigurationFile OnLoadConfig(ref ConfigurationFile configurationFile) => configurationFile = new ConfigurationFile<ConfigData>(Config);
        

        protected override void OnConfigurationUpdated(VersionNumber oldVersion)
        {
	        ConfigData baseConfigData = GenerateDefaultConfiguration<ConfigData>();
	        
	        if (oldVersion < new VersionNumber(2, 0, 0))
		        ConfigurationData = baseConfigData;
        }
        
        protected class ConfigData : BaseConfigData
        {
            [JsonProperty(PropertyName = "Chat Command List")]
            public List<CommandEntry> ChatCommands { get; set; }

            [JsonProperty(PropertyName = "Console Command List")]
            public List<CommandEntry> ConsoleCommands { get; set; }

            [JsonProperty(PropertyName = "Player Info Custom Commands")]
            public List<CustomCommands> PlayerInfoCommands { get; set; }

            [JsonProperty(PropertyName = "Use different permissions for each section of the player administration tab")]
            public bool UsePlayerAdminPermissions { get; set; }
            
            public class CommandEntry
            {
                public string Name { get; set; }
                
                public string Command { get; set; }
                
                public string Description { get; set; }
                
                public bool CloseOnRun { get; set; }
                
                public string RequiredPermission { get; set; } = string.Empty;
            }
            
            public class CustomCommands
            {
                public string Name { get; set; }

                public List<PlayerInfoCommandEntry> Commands { get; set; }
                
                public class PlayerInfoCommandEntry : CommandEntry
                {            
                    public string RequiredPlugin { get; set; }

                    [JsonProperty(PropertyName = "Command Type ( Chat, Console )")]
                    public CommandSubType SubType { get; set; }            
                }
            }
        }
        
        protected override T GenerateDefaultConfiguration<T>()
        {
            return new ConfigData
            {
                ChatCommands = new List<ConfigData.CommandEntry>
                {
	                new ConfigData.CommandEntry
	                {
		                Name = "These are examples",
		                Command = "/example",
		                Description = "To show how to create your own"
	                },
                    new ConfigData.CommandEntry
                    {
                        Name = "TP to 0 0 0",
                        Command = "/tp 0 0 0",
                        Description = "Teleport self to 0 0 0"
                    },
                    new ConfigData.CommandEntry
                    {
                        Name = "TP to player",
                        Command = "/tp {target1_name}",
                        Description = "Teleport self to player"
                    },
                    new ConfigData.CommandEntry
                    {
                        Name = "TP P2P",
                        Command = "/tp {target1_name} {target2_name}",
                        Description = "Teleport player to player"
                    },
                    new ConfigData.CommandEntry
                    {
                        Name = "God",
                        Command = "/god",
                        Description = "Toggle god mode"
                    }
                },
                ConsoleCommands = new List<ConfigData.CommandEntry>
                {
	                new ConfigData.CommandEntry
	                {
		                Name = "These are examples",
		                Command = "example",
		                Description = "To show how to create your own"
	                },
                    new ConfigData.CommandEntry
                    {
                        Name = "Set time to 9",
                        Command = "env.time 9",
                        Description = "Set the time to 9am"
                    },
                    new ConfigData.CommandEntry
                    {
                        Name = "Set to to 22",
                        Command = "env.time 22",
                        Description = "Set the time to 10pm"
                    },
                    new ConfigData.CommandEntry
                    {
                        Name = "TP P2P",
                        Command = "teleport.topos {target1_name} {target2_name}",
                        Description = "Teleport player to player"
                    },
                    new ConfigData.CommandEntry
                    {
                        Name = "Call random strike",
                        Command = "airstrike strike random",
                        Description = "Call a random Airstrike"
                    }
                },
                PlayerInfoCommands = new List<ConfigData.CustomCommands>
                {
                    new ConfigData.CustomCommands
                    {
                        Name = "Backpacks",
                        Commands = new List<ConfigData.CustomCommands.PlayerInfoCommandEntry>
                        {
                            new ConfigData.CustomCommands.PlayerInfoCommandEntry
                            {
                                RequiredPlugin = "Backpacks",
                                RequiredPermission = "backpacks.admin",
                                Name = "View Backpack",
                                CloseOnRun = true,
                                Command = "/viewbackpack {target1_id}",
                                SubType = CommandSubType.Chat
                            }
                        }
                    },
                    new ConfigData.CustomCommands
                    {
                        Name = "InventoryViewer",
                        Commands = new List<ConfigData.CustomCommands.PlayerInfoCommandEntry>
                        {
                            new ConfigData.CustomCommands.PlayerInfoCommandEntry
                            {
                                RequiredPlugin = "InventoryViewer",
                                RequiredPermission = "inventoryviewer.allowed",
                                Name = "View Inventory",
                                CloseOnRun = true,
                                Command = "/viewinv {target1_id}",
                                SubType = CommandSubType.Chat
                            }
                        }
                    },
                    new ConfigData.CustomCommands
                    {
                        Name = "Freeze",
                        Commands = new List<ConfigData.CustomCommands.PlayerInfoCommandEntry>
                        {
                            new ConfigData.CustomCommands.PlayerInfoCommandEntry
                            {
                                RequiredPlugin = "Freeze",
                                RequiredPermission = "freeze.use",
                                Name = "Freeze",
                                CloseOnRun = false,
                                Command = "/freeze {target1_id}",
                                SubType = CommandSubType.Chat
                            },
                            new ConfigData.CustomCommands.PlayerInfoCommandEntry
                            {
                                RequiredPlugin = "Freeze",
                                RequiredPermission = "freeze.use",
                                Name = "Unfreeze",
                                CloseOnRun = false,
                                Command = "/unfreeze {target1_id}",
                                SubType = CommandSubType.Chat
                            }
                        }
                    }
                },
                UsePlayerAdminPermissions = false,
            } as T;
        }
        #endregion
        
        #region Data

        private static DateTime EPOCH = new DateTime(1970, 1, 1, 0, 0, 0);
        
        private static double CurrentTimeStamp() =>  DateTime.UtcNow.Subtract(EPOCH).TotalSeconds;  

        private class RecentPlayers
        {
	        [JsonProperty]
	        private Hash<string, double> m_RecentPlayers = new Hash<string, double>();

	        public void OnPlayerConnected(BasePlayer player)
	        {
		        m_RecentPlayers.Remove(player.UserIDString);
	        }
	        
	        public void OnPlayerDisconnected(BasePlayer player)
	        {
		        m_RecentPlayers[player.UserIDString] = CurrentTimeStamp();
	        }

	        public void GetRecentPlayers(IEnumerable<IPlayer> allPlayers, ref List<IPlayer> list)
	        {
		        foreach (IPlayer player in allPlayers)
		        {
			        if (m_RecentPlayers.ContainsKey(player.Id))
				        list.Add(player);
		        }
	        }

	        public void PurgeCollection()
	        {
		        double currentTime = CurrentTimeStamp();
		        
		        for (int i = m_RecentPlayers.Count - 1; i >= 0; i--)
		        {
			        KeyValuePair<string, double> kvp = m_RecentPlayers.ElementAt(i);
			        if (currentTime - kvp.Value > 604800)
				        m_RecentPlayers.Remove(kvp);
		        }
	        }
        }
        #endregion
    }
}

// --- End of file: AdminMenu.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/HitMarker.cs ---
// --- Original Local Path: BeeRust/HitMarker.cs ---

using System; using System.Collections.Generic; using System.Linq; using System.Text; using Oxide.Core; using Oxide.Core.Plugins; using Oxide.Game.Rust.Cui; using Random = System.Random; using UnityEngine; using Newtonsoft.Json; namespace Oxide.Plugins { [Info("HitMarker", "Nimant", "1.0.8")] class HitMarker : RustPlugin { private const string FQESDScddeVSnMtmMZIDHysoQQeud = "hitmarker.allow"; private const float jmwbJqIfnPFuCLc = 0.1f; private const float JjVBsPmxzClQcxfPLGYklXphElAEL = 0.05f; private const float MYUzWGsPPPAjW = 0.475f; private const float pLfOPAzItAZvENLYHJKa = 0.515f; private const float phNZPBUfWkxbAAjjLKoQn = 0.51f; private const float YDwaEHcSSTpdfVwEYDWeifdhvyUGUG = 0.54f; private const int pbEYgDuukAhQIvKAJEvuwJGRnX = 50; [PluginReference] private Plugin Friends, Clans; private static string pPolAKqdVykL = "<size={size}>МЁРТВ</size>"; private static string YlxbtUWZOSDptMsAzQZcIwi = "<size={size}>ЛЁГ</size>"; private static string ROTBuIYSvOAADCshJ = "<size={size}>{AMOUNT}</size>"; private static Random KcmKFTzCpT = new Random(); private static bool yWVTHCfyjloropSb = false; private static HashSet<ulong> YSRTmIWdKsCFqqGACmjvrtldzeAql = new HashSet<ulong>(); private static Dictionary<ulong, List<KmSRLTezgXWZQtUCPP>> vENIlwkjClONhcjqdvoqcWdykGPsAR = new Dictionary<ulong, List<KmSRLTezgXWZQtUCPP>>(); private static Dictionary<ulong, Timer> HZNKZzHXexvWyCw = new Dictionary<ulong, Timer>(); private static Dictionary<ulong, int> PVJZIIMBljwltlPwBUJLvnAtqboXly = new Dictionary<ulong, int>(); private static Dictionary<ulong, HitTempData> oduSURcrTdLIAiUja = new Dictionary<ulong, HitTempData>(); private class HitTempData { public HitInfo WTErBWOgNxznmhdeuupUlRgzX; public float timeSS; } private class KmSRLTezgXWZQtUCPP { public int ZemtfYLMNQppzPcMQ; public int pJiukTaQyZuARIIhxWeh; public int TjmUvSIAVMUfL; public bool uxRKkIhORRANsHqVAzy; public bool vMBmipZWyOWJlPfNSwOmGZAwEBjfoe; public bool GTAMETsGPzQqHq; public bool DbyQbqasvMURhff; public ulong EkkDQHJpAFpiEVRGplp; public string pWILvPlyaQPDxgEKcPTatabVqkzsOY; public double mypvetKcWiGeeaVzcGbmzMRoPSQaz; public double nxZkLTVXQQVCxGSBqZb; public double BnaDETkqaq; public double fCweONHNklRzOARIiwKDzQgC; public BasePlayer hKMidlTOFwwrKDeigwKHhQayStaK; } private void Init() { yWVTHCfyjloropSb = false; vENIlwkjClONhcjqdvoqcWdykGPsAR.Clear(); HZNKZzHXexvWyCw.Clear(); PVJZIIMBljwltlPwBUJLvnAtqboXly.Clear(); oduSURcrTdLIAiUja.Clear(); permission.RegisterPermission(FQESDScddeVSnMtmMZIDHysoQQeud, this); KczZmGUZKFxFOdESykMiI(); LoadDefaultMessages(); XSOTfIcDwGMmwuPKrnKASItRXc(); if (ZKXvyhGByQjwSbnuAmdUq.xqUCnXSUJxGICyh == null) { ZKXvyhGByQjwSbnuAmdUq.xqUCnXSUJxGICyh = true; jwICZLLCOLOBtAZK(ZKXvyhGByQjwSbnuAmdUq); } if (ZKXvyhGByQjwSbnuAmdUq.sMJZnclGAudTXZUpkliIU == null) { ZKXvyhGByQjwSbnuAmdUq.sMJZnclGAudTXZUpkliIU = 0.1f; jwICZLLCOLOBtAZK(ZKXvyhGByQjwSbnuAmdUq); } pPolAKqdVykL = pPolAKqdVykL.Replace("{size}", $"{ZKXvyhGByQjwSbnuAmdUq.kDzlpKVVhCZOtLyiXSqilnLHgmPe}"); YlxbtUWZOSDptMsAzQZcIwi = YlxbtUWZOSDptMsAzQZcIwi.Replace("{size}", $"{ZKXvyhGByQjwSbnuAmdUq.kDzlpKVVhCZOtLyiXSqilnLHgmPe}"); ROTBuIYSvOAADCshJ = ROTBuIYSvOAADCshJ.Replace("{size}", $"{ZKXvyhGByQjwSbnuAmdUq.kDzlpKVVhCZOtLyiXSqilnLHgmPe}"); } private void OnServerSave() => wmnMznvSdBMsjifLOubXOSvXYub(); private void Unload() { yWVTHCfyjloropSb = true; foreach(var xXxDDFeqcfYTYTuVGTklsGYvAD in BasePlayer.activePlayerList.Where(x=> x != null && x.userID.IsSteamId())) if (vENIlwkjClONhcjqdvoqcWdykGPsAR.ContainsKey(xXxDDFeqcfYTYTuVGTklsGYvAD.userID)) foreach(var dbuNWhZTsapNvMQoE in vENIlwkjClONhcjqdvoqcWdykGPsAR[xXxDDFeqcfYTYTuVGTklsGYvAD.userID]) CuiHelper.DestroyUi(xXxDDFeqcfYTYTuVGTklsGYvAD, dbuNWhZTsapNvMQoE.pWILvPlyaQPDxgEKcPTatabVqkzsOY); wmnMznvSdBMsjifLOubXOSvXYub(); } [ChatCommand("hitmarker")] private void UKHLUcyxhSdnewiWxcHMYC(BasePlayer xXxDDFeqcfYTYTuVGTklsGYvAD, string BzYcrLrhhVYbBuBxKF, string[] LbgzPbECnAiYdGwZNVtSCMSwV) { if (ZKXvyhGByQjwSbnuAmdUq.KtBLDlYWPkMkDaG && !lXVelXRENKCggSmMohvLIgyxHtp(xXxDDFeqcfYTYTuVGTklsGYvAD, FQESDScddeVSnMtmMZIDHysoQQeud)) { SendReply(xXxDDFeqcfYTYTuVGTklsGYvAD, qYWsfeIjhPmUOhImNPubC("HM.NO.PERM")); return; } if (LbgzPbECnAiYdGwZNVtSCMSwV.Length == 0) { SendReply(xXxDDFeqcfYTYTuVGTklsGYvAD, qYWsfeIjhPmUOhImNPubC("CMD.HM.HELP")); return; } var TrrQgYXflRZame = LbgzPbECnAiYdGwZNVtSCMSwV[0].ToLower(); if (TrrQgYXflRZame != "on" && TrrQgYXflRZame != "off") { SendReply(xXxDDFeqcfYTYTuVGTklsGYvAD, string.Format(qYWsfeIjhPmUOhImNPubC("CMD.HM.UNKNOWN.ARG"), LbgzPbECnAiYdGwZNVtSCMSwV[0])); return; } switch (TrrQgYXflRZame) { case "on": if (ZKXvyhGByQjwSbnuAmdUq.xqUCnXSUJxGICyh == true) { if (!YSRTmIWdKsCFqqGACmjvrtldzeAql.Contains(xXxDDFeqcfYTYTuVGTklsGYvAD.userID)) SendReply(xXxDDFeqcfYTYTuVGTklsGYvAD, qYWsfeIjhPmUOhImNPubC("HM.ALREADY.ON")); else { YSRTmIWdKsCFqqGACmjvrtldzeAql.Remove(xXxDDFeqcfYTYTuVGTklsGYvAD.userID); SendReply(xXxDDFeqcfYTYTuVGTklsGYvAD, qYWsfeIjhPmUOhImNPubC("HM.ON")); } } else { if (YSRTmIWdKsCFqqGACmjvrtldzeAql.Contains(xXxDDFeqcfYTYTuVGTklsGYvAD.userID)) SendReply(xXxDDFeqcfYTYTuVGTklsGYvAD, qYWsfeIjhPmUOhImNPubC("HM.ALREADY.ON")); else { YSRTmIWdKsCFqqGACmjvrtldzeAql.Add(xXxDDFeqcfYTYTuVGTklsGYvAD.userID); SendReply(xXxDDFeqcfYTYTuVGTklsGYvAD, qYWsfeIjhPmUOhImNPubC("HM.ON")); } } break; case "off": if (ZKXvyhGByQjwSbnuAmdUq.xqUCnXSUJxGICyh == true) { if (YSRTmIWdKsCFqqGACmjvrtldzeAql.Contains(xXxDDFeqcfYTYTuVGTklsGYvAD.userID)) SendReply(xXxDDFeqcfYTYTuVGTklsGYvAD, qYWsfeIjhPmUOhImNPubC("HM.ALREADY.OFF")); else { YSRTmIWdKsCFqqGACmjvrtldzeAql.Add(xXxDDFeqcfYTYTuVGTklsGYvAD.userID); SendReply(xXxDDFeqcfYTYTuVGTklsGYvAD, qYWsfeIjhPmUOhImNPubC("HM.OFF")); } } else { if (!YSRTmIWdKsCFqqGACmjvrtldzeAql.Contains(xXxDDFeqcfYTYTuVGTklsGYvAD.userID)) SendReply(xXxDDFeqcfYTYTuVGTklsGYvAD, qYWsfeIjhPmUOhImNPubC("HM.ALREADY.OFF")); else { YSRTmIWdKsCFqqGACmjvrtldzeAql.Remove(xXxDDFeqcfYTYTuVGTklsGYvAD.userID); SendReply(xXxDDFeqcfYTYTuVGTklsGYvAD, qYWsfeIjhPmUOhImNPubC("HM.OFF")); } } break; } } private void OnEntityDeath(BasePlayer xXxDDFeqcfYTYTuVGTklsGYvAD, HitInfo info) => RjABDyMmlcsl(xXxDDFeqcfYTYTuVGTklsGYvAD, info, true); private void OnEntityTakeDamage(BasePlayer hKMidlTOFwwrKDeigwKHhQayStaK, HitInfo WTErBWOgNxznmhdeuupUlRgzX) { if (hKMidlTOFwwrKDeigwKHhQayStaK == null || WTErBWOgNxznmhdeuupUlRgzX == null || (!ZKXvyhGByQjwSbnuAmdUq.mijMxoNNKsg && !hKMidlTOFwwrKDeigwKHhQayStaK.UserIDString.IsSteamId())) return; if (!oduSURcrTdLIAiUja.ContainsKey(hKMidlTOFwwrKDeigwKHhQayStaK.userID)) oduSURcrTdLIAiUja.Add(hKMidlTOFwwrKDeigwKHhQayStaK.userID, new HitTempData()); oduSURcrTdLIAiUja[hKMidlTOFwwrKDeigwKHhQayStaK.userID].WTErBWOgNxznmhdeuupUlRgzX = WTErBWOgNxznmhdeuupUlRgzX; oduSURcrTdLIAiUja[hKMidlTOFwwrKDeigwKHhQayStaK.userID].timeSS = UnityEngine.Time.realtimeSinceStartup; } private void OnPlayerHealthChange(BasePlayer hKMidlTOFwwrKDeigwKHhQayStaK, float oldvalue, float newvalue) { var wpXwTxHuXKCLpK = oldvalue - newvalue; if (hKMidlTOFwwrKDeigwKHhQayStaK == null || wpXwTxHuXKCLpK <= 0f) return; if (oduSURcrTdLIAiUja.ContainsKey(hKMidlTOFwwrKDeigwKHhQayStaK.userID) && UnityEngine.Time.realtimeSinceStartup - oduSURcrTdLIAiUja[hKMidlTOFwwrKDeigwKHhQayStaK.userID].timeSS < 0.1f) RjABDyMmlcsl(hKMidlTOFwwrKDeigwKHhQayStaK, oduSURcrTdLIAiUja[hKMidlTOFwwrKDeigwKHhQayStaK.userID].WTErBWOgNxznmhdeuupUlRgzX, false, wpXwTxHuXKCLpK); } private void RjABDyMmlcsl(BasePlayer hKMidlTOFwwrKDeigwKHhQayStaK, HitInfo WTErBWOgNxznmhdeuupUlRgzX, bool DbyQbqasvMURhff = false, float wpXwTxHuXKCLpK = -1f) { if (hKMidlTOFwwrKDeigwKHhQayStaK == null || WTErBWOgNxznmhdeuupUlRgzX == null || (!ZKXvyhGByQjwSbnuAmdUq.mijMxoNNKsg && !hKMidlTOFwwrKDeigwKHhQayStaK.UserIDString.IsSteamId())) return; var nuDcCqXRpJNJPuwpZXmenYHUClBnB = WTErBWOgNxznmhdeuupUlRgzX.InitiatorPlayer; if (nuDcCqXRpJNJPuwpZXmenYHUClBnB == null || nuDcCqXRpJNJPuwpZXmenYHUClBnB == hKMidlTOFwwrKDeigwKHhQayStaK) return; if (ZKXvyhGByQjwSbnuAmdUq.xqUCnXSUJxGICyh == true && YSRTmIWdKsCFqqGACmjvrtldzeAql.Contains(nuDcCqXRpJNJPuwpZXmenYHUClBnB.userID)) return; if (ZKXvyhGByQjwSbnuAmdUq.xqUCnXSUJxGICyh == false && !YSRTmIWdKsCFqqGACmjvrtldzeAql.Contains(nuDcCqXRpJNJPuwpZXmenYHUClBnB.userID)) return; if (ZKXvyhGByQjwSbnuAmdUq.KtBLDlYWPkMkDaG && !lXVelXRENKCggSmMohvLIgyxHtp(nuDcCqXRpJNJPuwpZXmenYHUClBnB, FQESDScddeVSnMtmMZIDHysoQQeud)) return; var rvUYHPHWzP = WTErBWOgNxznmhdeuupUlRgzX.isHeadshot; var RFWQCbyFRbrFrzySozq = false; if (hKMidlTOFwwrKDeigwKHhQayStaK.UserIDString.IsSteamId()) { if (ZKXvyhGByQjwSbnuAmdUq.IttjgRZsHrAORkAUSX) RFWQCbyFRbrFrzySozq = bjiMhgGIkTtGMrwoLHZ(nuDcCqXRpJNJPuwpZXmenYHUClBnB, hKMidlTOFwwrKDeigwKHhQayStaK); if (!RFWQCbyFRbrFrzySozq && Friends != null) RFWQCbyFRbrFrzySozq = (Friends?.Call("AreFriends", nuDcCqXRpJNJPuwpZXmenYHUClBnB.userID, hKMidlTOFwwrKDeigwKHhQayStaK.userID) as bool?) ?? false; if (!RFWQCbyFRbrFrzySozq && Clans != null) { var VekFgNuDeSSLPPNW = Clans?.Call("GetClanOf", nuDcCqXRpJNJPuwpZXmenYHUClBnB) as string; if (!string.IsNullOrEmpty(VekFgNuDeSSLPPNW)) { var eaIZuOgXdQM = Clans?.Call("GetClanOf", hKMidlTOFwwrKDeigwKHhQayStaK) as string; RFWQCbyFRbrFrzySozq = VekFgNuDeSSLPPNW == eaIZuOgXdQM; } } } wpXwTxHuXKCLpK = wpXwTxHuXKCLpK < 0f ? (float)(Math.Round(olgPFSgEZabwjJtjYQKcgs(WTErBWOgNxznmhdeuupUlRgzX.damageTypes.types), 0, MidpointRounding.AwayFromZero)) : wpXwTxHuXKCLpK; eQgBWpgTQv(nuDcCqXRpJNJPuwpZXmenYHUClBnB, hKMidlTOFwwrKDeigwKHhQayStaK, (int)Math.Round(wpXwTxHuXKCLpK), rvUYHPHWzP, RFWQCbyFRbrFrzySozq, DbyQbqasvMURhff); } private static string OMbnrvSKZGAsucYF(ulong userID) { if (!PVJZIIMBljwltlPwBUJLvnAtqboXly.ContainsKey(userID)) PVJZIIMBljwltlPwBUJLvnAtqboXly.Add(userID, pbEYgDuukAhQIvKAJEvuwJGRnX); if (PVJZIIMBljwltlPwBUJLvnAtqboXly[userID] >= pbEYgDuukAhQIvKAJEvuwJGRnX) PVJZIIMBljwltlPwBUJLvnAtqboXly[userID] = 0; else PVJZIIMBljwltlPwBUJLvnAtqboXly[userID]++; return PVJZIIMBljwltlPwBUJLvnAtqboXly[userID].ToString(); } private static float olgPFSgEZabwjJtjYQKcgs(float[] GxFfYcAYiJzEhZGfN) { var IqzDRadaczN = 0f; for (int i = 0; i < (int)GxFfYcAYiJzEhZGfN.Length; i++) { float RemVkGINuUTvJawKjzVrwqxSOEScm = GxFfYcAYiJzEhZGfN[i]; if (!float.IsNaN(RemVkGINuUTvJawKjzVrwqxSOEScm)) { if (!float.IsInfinity(RemVkGINuUTvJawKjzVrwqxSOEScm)) IqzDRadaczN = IqzDRadaczN + RemVkGINuUTvJawKjzVrwqxSOEScm; } } return IqzDRadaczN; } private static bool bjiMhgGIkTtGMrwoLHZ(BasePlayer xXxDDFeqcfYTYTuVGTklsGYvAD, BasePlayer GSwFeUOlQSOKEpxo) => xXxDDFeqcfYTYTuVGTklsGYvAD.currentTeam != (long)0 && xXxDDFeqcfYTYTuVGTklsGYvAD.currentTeam == GSwFeUOlQSOKEpxo.currentTeam; private bool lXVelXRENKCggSmMohvLIgyxHtp(BasePlayer xXxDDFeqcfYTYTuVGTklsGYvAD, string GsuOOXCOuuJsfoY) => permission.UserHasPermission(xXxDDFeqcfYTYTuVGTklsGYvAD.UserIDString, GsuOOXCOuuJsfoY); private void eQgBWpgTQv(BasePlayer xXxDDFeqcfYTYTuVGTklsGYvAD, BasePlayer hKMidlTOFwwrKDeigwKHhQayStaK, int wpXwTxHuXKCLpK, bool isHeadshot, bool RFWQCbyFRbrFrzySozq, bool DbyQbqasvMURhff) { if (xXxDDFeqcfYTYTuVGTklsGYvAD == null || hKMidlTOFwwrKDeigwKHhQayStaK == null) return; if (!vENIlwkjClONhcjqdvoqcWdykGPsAR.ContainsKey(xXxDDFeqcfYTYTuVGTklsGYvAD.userID)) vENIlwkjClONhcjqdvoqcWdykGPsAR.Add(xXxDDFeqcfYTYTuVGTklsGYvAD.userID, new List<KmSRLTezgXWZQtUCPP>()); if (DbyQbqasvMURhff && vENIlwkjClONhcjqdvoqcWdykGPsAR[xXxDDFeqcfYTYTuVGTklsGYvAD.userID].Count > 0) vENIlwkjClONhcjqdvoqcWdykGPsAR[xXxDDFeqcfYTYTuVGTklsGYvAD.userID].RemoveAt(vENIlwkjClONhcjqdvoqcWdykGPsAR[xXxDDFeqcfYTYTuVGTklsGYvAD.userID].Count-1); var dbuNWhZTsapNvMQoE = new KmSRLTezgXWZQtUCPP(); dbuNWhZTsapNvMQoE.ZemtfYLMNQppzPcMQ = 0; dbuNWhZTsapNvMQoE.pJiukTaQyZuARIIhxWeh = wpXwTxHuXKCLpK; dbuNWhZTsapNvMQoE.TjmUvSIAVMUfL = 0; dbuNWhZTsapNvMQoE.uxRKkIhORRANsHqVAzy = isHeadshot; dbuNWhZTsapNvMQoE.vMBmipZWyOWJlPfNSwOmGZAwEBjfoe = RFWQCbyFRbrFrzySozq; dbuNWhZTsapNvMQoE.GTAMETsGPzQqHq = hKMidlTOFwwrKDeigwKHhQayStaK.IsWounded(); dbuNWhZTsapNvMQoE.DbyQbqasvMURhff = DbyQbqasvMURhff; dbuNWhZTsapNvMQoE.EkkDQHJpAFpiEVRGplp = hKMidlTOFwwrKDeigwKHhQayStaK.userID; dbuNWhZTsapNvMQoE.hKMidlTOFwwrKDeigwKHhQayStaK = hKMidlTOFwwrKDeigwKHhQayStaK; dbuNWhZTsapNvMQoE.pWILvPlyaQPDxgEKcPTatabVqkzsOY = OMbnrvSKZGAsucYF(xXxDDFeqcfYTYTuVGTklsGYvAD.userID); dbuNWhZTsapNvMQoE.mypvetKcWiGeeaVzcGbmzMRoPSQaz = (KcmKFTzCpT.Next((int)Math.Round(MYUzWGsPPPAjW*1000f), (int)Math.Round(pLfOPAzItAZvENLYHJKa*1000f))/1000f); dbuNWhZTsapNvMQoE.BnaDETkqaq = dbuNWhZTsapNvMQoE.mypvetKcWiGeeaVzcGbmzMRoPSQaz + jmwbJqIfnPFuCLc; dbuNWhZTsapNvMQoE.fCweONHNklRzOARIiwKDzQgC = (KcmKFTzCpT.Next((int)Math.Round((1f-YDwaEHcSSTpdfVwEYDWeifdhvyUGUG)*1000f), (int)Math.Round((1f-phNZPBUfWkxbAAjjLKoQn)*1000f))/1000f); dbuNWhZTsapNvMQoE.nxZkLTVXQQVCxGSBqZb = dbuNWhZTsapNvMQoE.fCweONHNklRzOARIiwKDzQgC - JjVBsPmxzClQcxfPLGYklXphElAEL; vENIlwkjClONhcjqdvoqcWdykGPsAR[xXxDDFeqcfYTYTuVGTklsGYvAD.userID].Add(dbuNWhZTsapNvMQoE); if (!HZNKZzHXexvWyCw.ContainsKey(xXxDDFeqcfYTYTuVGTklsGYvAD.userID)) HZNKZzHXexvWyCw.Add(xXxDDFeqcfYTYTuVGTklsGYvAD.userID, null); if (HZNKZzHXexvWyCw[xXxDDFeqcfYTYTuVGTklsGYvAD.userID] == null) HZNKZzHXexvWyCw[xXxDDFeqcfYTYTuVGTklsGYvAD.userID] = timer.Once(0.1f, ()=> BHsuvsDvmylfxYItMdJo(xXxDDFeqcfYTYTuVGTklsGYvAD)); } private void BHsuvsDvmylfxYItMdJo(BasePlayer xXxDDFeqcfYTYTuVGTklsGYvAD) { if (xXxDDFeqcfYTYTuVGTklsGYvAD == null) return; HZNKZzHXexvWyCw[xXxDDFeqcfYTYTuVGTklsGYvAD.userID] = null; if (yWVTHCfyjloropSb || !vENIlwkjClONhcjqdvoqcWdykGPsAR.ContainsKey(xXxDDFeqcfYTYTuVGTklsGYvAD.userID)) return; var HiOpOlScYHjXcprOOL = vENIlwkjClONhcjqdvoqcWdykGPsAR[xXxDDFeqcfYTYTuVGTklsGYvAD.userID].ToList(); if (HiOpOlScYHjXcprOOL.Count == 0) return; ulong EkkDQHJpAFpiEVRGplp = 0; var gvvCzMKVYi = new List<KmSRLTezgXWZQtUCPP>(); foreach(var dbuNWhZTsapNvMQoE in HiOpOlScYHjXcprOOL.Where(x=> x.ZemtfYLMNQppzPcMQ == 0).OrderBy(x=> x.EkkDQHJpAFpiEVRGplp)) { if (EkkDQHJpAFpiEVRGplp != dbuNWhZTsapNvMQoE.EkkDQHJpAFpiEVRGplp) { EkkDQHJpAFpiEVRGplp = dbuNWhZTsapNvMQoE.EkkDQHJpAFpiEVRGplp; dbuNWhZTsapNvMQoE.GTAMETsGPzQqHq = !dbuNWhZTsapNvMQoE.GTAMETsGPzQqHq ? dbuNWhZTsapNvMQoE.hKMidlTOFwwrKDeigwKHhQayStaK?.IsWounded() == true : dbuNWhZTsapNvMQoE.GTAMETsGPzQqHq; dbuNWhZTsapNvMQoE.DbyQbqasvMURhff = !dbuNWhZTsapNvMQoE.DbyQbqasvMURhff ? dbuNWhZTsapNvMQoE.hKMidlTOFwwrKDeigwKHhQayStaK?.IsDead() == true : dbuNWhZTsapNvMQoE.DbyQbqasvMURhff; gvvCzMKVYi.Add(dbuNWhZTsapNvMQoE); } else { gvvCzMKVYi[gvvCzMKVYi.Count - 1].pJiukTaQyZuARIIhxWeh += dbuNWhZTsapNvMQoE.pJiukTaQyZuARIIhxWeh; gvvCzMKVYi[gvvCzMKVYi.Count - 1].uxRKkIhORRANsHqVAzy = false; gvvCzMKVYi[gvvCzMKVYi.Count - 1].GTAMETsGPzQqHq = dbuNWhZTsapNvMQoE.GTAMETsGPzQqHq ? dbuNWhZTsapNvMQoE.GTAMETsGPzQqHq : gvvCzMKVYi[gvvCzMKVYi.Count - 1].GTAMETsGPzQqHq; gvvCzMKVYi[gvvCzMKVYi.Count - 1].GTAMETsGPzQqHq = !gvvCzMKVYi[gvvCzMKVYi.Count - 1].GTAMETsGPzQqHq ? gvvCzMKVYi[gvvCzMKVYi.Count - 1].hKMidlTOFwwrKDeigwKHhQayStaK?.IsWounded() == true : gvvCzMKVYi[gvvCzMKVYi.Count - 1].GTAMETsGPzQqHq; gvvCzMKVYi[gvvCzMKVYi.Count - 1].DbyQbqasvMURhff = dbuNWhZTsapNvMQoE.DbyQbqasvMURhff ? dbuNWhZTsapNvMQoE.DbyQbqasvMURhff : gvvCzMKVYi[gvvCzMKVYi.Count - 1].DbyQbqasvMURhff; gvvCzMKVYi[gvvCzMKVYi.Count - 1].DbyQbqasvMURhff = !gvvCzMKVYi[gvvCzMKVYi.Count - 1].DbyQbqasvMURhff ? gvvCzMKVYi[gvvCzMKVYi.Count - 1].hKMidlTOFwwrKDeigwKHhQayStaK?.IsDead() == true : gvvCzMKVYi[gvvCzMKVYi.Count - 1].DbyQbqasvMURhff; } } gvvCzMKVYi.AddRange(HiOpOlScYHjXcprOOL.Where(x=> x.ZemtfYLMNQppzPcMQ > 0)); foreach(var dbuNWhZTsapNvMQoE in gvvCzMKVYi) { if (dbuNWhZTsapNvMQoE.ZemtfYLMNQppzPcMQ == 1) { if (dbuNWhZTsapNvMQoE.DbyQbqasvMURhff || dbuNWhZTsapNvMQoE.GTAMETsGPzQqHq) { if (dbuNWhZTsapNvMQoE.TjmUvSIAVMUfL < ZKXvyhGByQjwSbnuAmdUq.AtmXIpQrwuCtiwDWDbUS) { dbuNWhZTsapNvMQoE.TjmUvSIAVMUfL += 1; continue; } } else { if (dbuNWhZTsapNvMQoE.TjmUvSIAVMUfL < ZKXvyhGByQjwSbnuAmdUq.gttNQcNEBcWRDWR) { dbuNWhZTsapNvMQoE.TjmUvSIAVMUfL += 1; continue; } } var mhiPfUWrNmJKqcNyNjGRELGsFxltZ = "1723"; CuiHelper.DestroyUi(xXxDDFeqcfYTYTuVGTklsGYvAD, dbuNWhZTsapNvMQoE.pWILvPlyaQPDxgEKcPTatabVqkzsOY); dbuNWhZTsapNvMQoE.ZemtfYLMNQppzPcMQ = 2; } else if (dbuNWhZTsapNvMQoE.ZemtfYLMNQppzPcMQ == 0) { jxSnQeHRYbgSYvaEKBhf(xXxDDFeqcfYTYTuVGTklsGYvAD, dbuNWhZTsapNvMQoE); dbuNWhZTsapNvMQoE.TjmUvSIAVMUfL += 1; dbuNWhZTsapNvMQoE.ZemtfYLMNQppzPcMQ = 1; } } gvvCzMKVYi.RemoveAll(x=> x.ZemtfYLMNQppzPcMQ == 2); vENIlwkjClONhcjqdvoqcWdykGPsAR[xXxDDFeqcfYTYTuVGTklsGYvAD.userID] = gvvCzMKVYi; if (gvvCzMKVYi.Count == 0) return; if (HZNKZzHXexvWyCw[xXxDDFeqcfYTYTuVGTklsGYvAD.userID] == null) HZNKZzHXexvWyCw[xXxDDFeqcfYTYTuVGTklsGYvAD.userID] = timer.Once(0.1f, ()=> BHsuvsDvmylfxYItMdJo(xXxDDFeqcfYTYTuVGTklsGYvAD)); } private void jxSnQeHRYbgSYvaEKBhf(BasePlayer xXxDDFeqcfYTYTuVGTklsGYvAD, KmSRLTezgXWZQtUCPP dbuNWhZTsapNvMQoE) { if (xXxDDFeqcfYTYTuVGTklsGYvAD == null) return; var RrgMDAkLmABl = "[{\"name\":\"{name}\",\"parent\":\"Hud\",\"fadeOut\":\"{fadeOut}\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{text}\",\"font\":\"{font}\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 1\",\"distance\":\"0.3 -0.3\"},{\"type\":\"RectTransform\",\"anchormin\":\"{xmin} {ymin}\",\"anchormax\":\"{xmax} {ymax}\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]}]"; RrgMDAkLmABl = RrgMDAkLmABl.Replace("{name}", dbuNWhZTsapNvMQoE.pWILvPlyaQPDxgEKcPTatabVqkzsOY); RrgMDAkLmABl = RrgMDAkLmABl.Replace("{xmin}", $"{dbuNWhZTsapNvMQoE.mypvetKcWiGeeaVzcGbmzMRoPSQaz}"); RrgMDAkLmABl = RrgMDAkLmABl.Replace("{xmax}", $"{dbuNWhZTsapNvMQoE.BnaDETkqaq}"); RrgMDAkLmABl = RrgMDAkLmABl.Replace("{ymin}", $"{dbuNWhZTsapNvMQoE.nxZkLTVXQQVCxGSBqZb}"); RrgMDAkLmABl = RrgMDAkLmABl.Replace("{ymax}", $"{dbuNWhZTsapNvMQoE.fCweONHNklRzOARIiwKDzQgC}"); RrgMDAkLmABl = RrgMDAkLmABl.Replace("{font}", $"{ZKXvyhGByQjwSbnuAmdUq.qFCJXIkCunttAsNTwzDJEoZvkuQ}"); RrgMDAkLmABl = RrgMDAkLmABl.Replace("{fadeOut}", $"{ZKXvyhGByQjwSbnuAmdUq.sMJZnclGAudTXZUpkliIU}"); var HtQcNDpAVUlX = ZKXvyhGByQjwSbnuAmdUq.qSZQyzeLcPQuQiewCIKjnQArZr; var lIvWSYRQEDhYFgRij = (ZKXvyhGByQjwSbnuAmdUq.yRbuQBYevRTRKjAJk ? "-" : "") + ROTBuIYSvOAADCshJ.Replace("{AMOUNT}", dbuNWhZTsapNvMQoE.pJiukTaQyZuARIIhxWeh.ToString()); if (dbuNWhZTsapNvMQoE.vMBmipZWyOWJlPfNSwOmGZAwEBjfoe) { HtQcNDpAVUlX = ZKXvyhGByQjwSbnuAmdUq.cAbIFjAlJrrJHal; if (dbuNWhZTsapNvMQoE.DbyQbqasvMURhff) lIvWSYRQEDhYFgRij = pPolAKqdVykL; else if (dbuNWhZTsapNvMQoE.GTAMETsGPzQqHq) lIvWSYRQEDhYFgRij = YlxbtUWZOSDptMsAzQZcIwi; } else if (dbuNWhZTsapNvMQoE.DbyQbqasvMURhff) { lIvWSYRQEDhYFgRij = pPolAKqdVykL; HtQcNDpAVUlX = ZKXvyhGByQjwSbnuAmdUq.SDbXfPLMIkyvZNMrTcoSufgpCjkQTf; } else if (dbuNWhZTsapNvMQoE.GTAMETsGPzQqHq) { lIvWSYRQEDhYFgRij = YlxbtUWZOSDptMsAzQZcIwi; HtQcNDpAVUlX = ZKXvyhGByQjwSbnuAmdUq.RcZHoMsURuSKwBPrV; } else if (dbuNWhZTsapNvMQoE.uxRKkIhORRANsHqVAzy) HtQcNDpAVUlX = ZKXvyhGByQjwSbnuAmdUq.xEESiugkPZKsBMVdyFEGrEWuhJsqD; RrgMDAkLmABl = RrgMDAkLmABl.Replace("{text}", $"<color={HtQcNDpAVUlX}>{lIvWSYRQEDhYFgRij}</color>"); CuiHelper.AddUi(xXxDDFeqcfYTYTuVGTklsGYvAD, RrgMDAkLmABl); } private void LoadDefaultMessages() { lang.RegisterMessages(new Dictionary<string, string> { {"CMD.HM.HELP", "ДОСТУПНЫЕ КОМАНДЫ:\n/hitmarker on - включить отображение урона по игрокам.\n/hitmarker off - выключить отображение урона по игрокам."}, {"HM.ON", "Вы включили отображение урона по игрокам."}, {"HM.OFF", "Вы выключили отображение урона по игрокам."}, {"HM.ALREADY.ON", "У вас уже включено отображение урона по игрокам."}, {"HM.ALREADY.OFF", "У вас уже выключено отображение урона по игрокам."}, {"CMD.HM.UNKNOWN.ARG", "Неизвестный параметр \"{0}\".\nИспользуйте /hitmarker чтобы посмотреть список доступных команд."}, {"HM.NO.PERM", "У вас нет прав на эту команду."} }, this); } private string qYWsfeIjhPmUOhImNPubC(string nQZpQwjmcBoJpfMWfdn, string aZycMyihQopsy = null) => lang.GetMessage(nQZpQwjmcBoJpfMWfdn, this, aZycMyihQopsy); private static yauPlNsmRLCQVA ZKXvyhGByQjwSbnuAmdUq; private class yauPlNsmRLCQVA { [JsonProperty(PropertyName = "Разрешать видеть урон только тем, у кого есть привилегия")] public bool KtBLDlYWPkMkDaG; [JsonProperty(PropertyName = "Отображать урон по учёным")] public bool mijMxoNNKsg; [JsonProperty(PropertyName = "Использовать встроенные в игру кланы для подсветки их как друзей")] public bool IttjgRZsHrAORkAUSX; [JsonProperty(PropertyName = "Отображать урон со знаком минус")] public bool yRbuQBYevRTRKjAJk; [JsonProperty(PropertyName = "Время отображения текста с величиной урона (в разах, где раз = 0.1 секунда)")] public int gttNQcNEBcWRDWR; [JsonProperty(PropertyName = "Время отображения текста о убийстве или падении (в разах, где раз = 0.1 секунда)")] public int AtmXIpQrwuCtiwDWDbUS; [JsonProperty(PropertyName = "Размер текста")] public int kDzlpKVVhCZOtLyiXSqilnLHgmPe; [JsonProperty(PropertyName = "Шрифт текста")] public string qFCJXIkCunttAsNTwzDJEoZvkuQ; [JsonProperty(PropertyName = "Цвет текста при попадании в тело")] public string qSZQyzeLcPQuQiewCIKjnQArZr; [JsonProperty(PropertyName = "Цвет текста при попадании в голову")] public string xEESiugkPZKsBMVdyFEGrEWuhJsqD; [JsonProperty(PropertyName = "Цвет текста при убийстве противника")] public string RcZHoMsURuSKwBPrV; [JsonProperty(PropertyName = "Цвет текста при падении противника")] public string SDbXfPLMIkyvZNMrTcoSufgpCjkQTf; [JsonProperty(PropertyName = "Цвет текста при попадании в друга")] public string cAbIFjAlJrrJHal; [JsonProperty(PropertyName = "Плавное пропадание текста")] public float? sMJZnclGAudTXZUpkliIU; [JsonProperty(PropertyName = "Отображение урона включено по умолчанию")] public bool? xqUCnXSUJxGICyh; } private void KczZmGUZKFxFOdESykMiI() => ZKXvyhGByQjwSbnuAmdUq = Config.ReadObject<yauPlNsmRLCQVA>(); protected override void LoadDefaultConfig() { ZKXvyhGByQjwSbnuAmdUq = new yauPlNsmRLCQVA { KtBLDlYWPkMkDaG = false, mijMxoNNKsg = true, gttNQcNEBcWRDWR = 4, AtmXIpQrwuCtiwDWDbUS = 12, IttjgRZsHrAORkAUSX = true, yRbuQBYevRTRKjAJk = false, kDzlpKVVhCZOtLyiXSqilnLHgmPe = 14, qFCJXIkCunttAsNTwzDJEoZvkuQ = "robotocondensed-bold.ttf", qSZQyzeLcPQuQiewCIKjnQArZr = "white", xEESiugkPZKsBMVdyFEGrEWuhJsqD = "red", RcZHoMsURuSKwBPrV = "red", SDbXfPLMIkyvZNMrTcoSufgpCjkQTf = "white", cAbIFjAlJrrJHal = "lime", xqUCnXSUJxGICyh = true, sMJZnclGAudTXZUpkliIU = 0.1f }; jwICZLLCOLOBtAZK(ZKXvyhGByQjwSbnuAmdUq); timer.Once(0.1f, ()=> jwICZLLCOLOBtAZK(ZKXvyhGByQjwSbnuAmdUq)); } private void jwICZLLCOLOBtAZK(yauPlNsmRLCQVA tiTilaTtjtxAieYXrpsSA) => Config.WriteObject(tiTilaTtjtxAieYXrpsSA, true); private void XSOTfIcDwGMmwuPKrnKASItRXc() => YSRTmIWdKsCFqqGACmjvrtldzeAql = Interface.GetMod().DataFileSystem.ReadObject<HashSet<ulong>>("HitMarkerData"); private static void wmnMznvSdBMsjifLOubXOSvXYub() => Interface.GetMod().DataFileSystem.WriteObject("HitMarkerData", YSRTmIWdKsCFqqGACmjvrtldzeAql); } }

// --- End of file: HitMarker.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/DiscordStatus.cs ---
// --- Original Local Path: BeeRust/DiscordStatus.cs ---

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Linq;
using System.Text;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Ext.Discord;
using Oxide.Ext.Discord.Attributes;
using Oxide.Ext.Discord.Constants;
using Oxide.Ext.Discord.Entities;
using Oxide.Ext.Discord.Entities.Activities;
using Oxide.Ext.Discord.Entities.Applications;
using Oxide.Ext.Discord.Entities.Channels;
using Oxide.Ext.Discord.Entities.Gatway;
using Oxide.Ext.Discord.Entities.Gatway.Commands;
using Oxide.Ext.Discord.Entities.Gatway.Events;
using Oxide.Ext.Discord.Entities.Guilds;
using Oxide.Ext.Discord.Entities.Messages;
using Oxide.Ext.Discord.Entities.Messages.Embeds;
using Oxide.Ext.Discord.Entities.Permissions;
using Oxide.Ext.Discord.Libraries.Linking;
using Oxide.Ext.Discord.Logging;
using Random = Oxide.Core.Random;

namespace Oxide.Plugins
{
    [Info("Discord Status", "Gonzi", "4.0.1")]
    [Description("Shows server information as a discord bot status")]

    public class DiscordStatus : CovalencePlugin
    {
        private string seperatorText = string.Join("-", new string[25 + 1]);
        private bool enableChatSeparators;

        #region Fields

        [DiscordClient]
        private DiscordClient Client;

        private readonly DiscordSettings _settings = new DiscordSettings
        {
            Intents = GatewayIntents.Guilds | GatewayIntents.GuildMessages | GatewayIntents.GuildMembers
        };
        
        private DiscordGuild _guild;
        
        private readonly DiscordLink _link = GetLibrary<DiscordLink>();

        Configuration config;
        private int statusIndex = -1;
        private string[] StatusTypes = new string[]
        {
            "Game",
            "Stream",
            "Listen",
            "Watch"
        };

        #endregion

        #region Config
        class Configuration
        {
            [JsonProperty(PropertyName = "Discord Bot Token")]
            public string BotToken = string.Empty;
            
            [JsonProperty(PropertyName = "Discord Server ID (Optional if bot only in 1 guild)")]
            public Snowflake GuildId { get; set; }

            [JsonProperty(PropertyName = "Prefix")]
            public string Prefix = "!";

            [JsonProperty(PropertyName = "Discord Group Id needed for Commands (null to disable)")]
            public Snowflake? GroupId;

            [JsonProperty(PropertyName = "Update Interval (Seconds)")]
            public int UpdateInterval = 5;

            [JsonProperty(PropertyName = "Randomize Status")]
            public bool Randomize = false;

            [JsonProperty(PropertyName = "Status Type (Game/Stream/Listen/Watch)")]
            public string StatusType = "Game";

            [JsonProperty(PropertyName = "Status", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> Status = new List<string>
            {
                "{players.online} / {server.maxplayers} Online!",
                "{server.entities} Entities",
                "{players.sleepers} Sleepers!",
                "{players.authenticated} Linked Account(s)"
            };
            
            [JsonConverter(typeof(StringEnumConverter))]
            [DefaultValue(DiscordLogLevel.Info)]
            [JsonProperty(PropertyName = "Discord Extension Log Level (Verbose, Debug, Info, Warning, Error, Exception, Off)")]
            public DiscordLogLevel ExtensionDebugging { get; set; } = DiscordLogLevel.Info;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) throw new Exception();
            }
            catch
            {
                Config.WriteObject(config, false, $"{Interface.Oxide.ConfigDirectory}/{Name}.jsonError");
                PrintError("The configuration file contains an error and has been replaced with a default config.\n" +
                           "The error configuration file was saved in the .jsonError extension");
                LoadDefaultConfig();
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion

        #region Lang
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Title"] = "Players List",
                ["Players"] = "Online Players [{0}/{1}] 🎆\n {2}",
                ["IPAddress"] = "steam://connect/{0}:{1}"

            }, this, "en");

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Title"] = "플레이어 목록",
                ["Players"] = "접속중인 플레이어 [{0}/{1}] 🎆\n {2}",
                ["IPAddress"] = "steam://connect/{0}:{1}"
            }, this, "kr");
        }

        private string Lang(string key, params object[] args)
        {
            return string.Format(lang.GetMessage(key, this), args);
        }

        #endregion

        #region Discord
        public DiscordEmbed ServerStats(string content)
        {
            DiscordEmbed embed = new DiscordEmbed
            {
                Title = Lang("Title", ConVar.Server.hostname),
                Description = content,
                Thumbnail = new EmbedThumbnail
                {
                    Url = $"{ConVar.Server.headerimage}"
                },
                Footer = new EmbedFooter
                {
                    Text = $"Gonzi V{Version}",
                    IconUrl = "https://cdn.discordapp.com/avatars/321373026488811520/08f996472c573473e7e30574e0e28da0.png"
                },

                Color = new DiscordColor(15158332)
            };
            return embed;
        }
        
        [HookMethod(DiscordHooks.OnDiscordGuildMessageCreated)]
        void OnDiscordGuildMessageCreated(DiscordMessage message)
        {
            if (message.Author.Bot == true) return;


            if (message.Content[0] == config.Prefix[0])
            {

                string cmd;
                try
                {
                    cmd = message.Content.Split(' ')[0].ToLower();
                    if (string.IsNullOrEmpty(cmd.Trim()))
                        cmd = message.Content.Trim().ToLower();
                }
                catch
                {
                    cmd = message.Content.Trim().ToLower();
                }

                cmd = cmd.Remove(0, 1);

                cmd = cmd.Trim();
                cmd = cmd.ToLower();

                DiscordCMD(cmd, message);
            }
        }

        private void DiscordCMD(string command, DiscordMessage message)
        {
            if (config.GroupId.HasValue && !message.Member.Roles.Contains(config.GroupId.Value)) return;

            switch (command)
            {
                case "players":
                    {
                        string maxplayers = Convert.ToString(ConVar.Server.maxplayers);
                        string onlineplayers = Convert.ToString(BasePlayer.activePlayerList.Count);
                        string list = string.Empty;
                        var playerList = BasePlayer.activePlayerList;
                        foreach (var player in playerList)
                        {
                            list += $"[{player.displayName}](https://steamcommunity.com/profiles/{player.UserIDString}/) \n";
                        }

                        DiscordChannel.GetChannel(Client, message.ChannelId, channel =>
                        {
                            channel.CreateMessage(Client, ServerStats(Lang("Players", BasePlayer.activePlayerList.Count, ConVar.Server.maxplayers, list)));
                        });
                        break;
                    }
                case "ip":
                    {
                        DiscordChannel.GetChannel(Client, message.ChannelId, channel =>
                        {
                            webrequest.Enqueue("http://icanhazip.com", "", (code, response) =>
                            {
                                string ip = response.Trim();
                                channel.CreateMessage(Client, Lang("IPAddress", ip, ConVar.Server.port));
                            }, this);
                        });
                    }
                    break;
            }
        }

        #endregion

        #region Oxide Hooks
        private void OnServerInitialized()
        {
            lang.SetServerLanguage("en");

            if (config.BotToken == string.Empty)
                return;

            _settings.ApiToken = config.BotToken;
            _settings.LogLevel = config.ExtensionDebugging;
            Client.Connect(_settings);

            timer.Every(config.UpdateInterval, () => UpdateStatus());
        }
        
        [HookMethod(DiscordHooks.OnDiscordGatewayReady)]
        private void OnDiscordGatewayReady(GatewayReadyEvent ready)
        {
            if (ready.Guilds.Count == 0)
            {
                PrintError("Your bot was not found in any discord servers. Please invite it to a server and reload the plugin.");
                return;
            }

            DiscordGuild guild = null;
            if (ready.Guilds.Count == 1 && !config.GuildId.IsValid())
            {
                guild = ready.Guilds.Values.FirstOrDefault();
            }

            if (guild == null)
            {
                guild = ready.Guilds[config.GuildId];
            }

            if (guild == null)
            {
                PrintError("Failed to find a matching guild for the Discord Server Id. " +
                           "Please make sure your guild Id is correct and the bot is in the discord server.");
                return;
            }
                
            if (Client.Bot.Application.Flags.HasValue && !Client.Bot.Application.Flags.Value.HasFlag(ApplicationFlags.GatewayGuildMembersLimited))
            {
                PrintError($"You need to enable \"Server Members Intent\" for {Client.Bot.BotUser.Username} @ https://discord.com/developers/applications\n" +
                           $"{Name} will not function correctly until that is fixed. Once updated please reload {Name}.");
                return;
            }
            
            _guild = guild;
        }
        #endregion

        #region Discord Hooks

        #endregion

        #region Status Update
        private void UpdateStatus()
        {
            try
            {
                if (config.Status.Count == 0)
                    return;

                var index = GetStatusIndex();

                Client.Bot.UpdateStatus(new UpdatePresenceCommand
                {
                    Activities = new List<DiscordActivity>
                    {
                        new DiscordActivity
                        {
                            Name = Format(config.Status[index]),
                            Type = ActivityType.Game
                        }
                    }
                });

                statusIndex = index;
            }
            catch (Exception err)
            {
                LogToFile("DiscordStatus", $"{err}", this);
            }
        }
        #endregion

        #region Helper Methods
        private int GetStatusIndex()
        {
            if (!config.Randomize)
                return (statusIndex + 1) % config.Status.Count;

            var index = 0;
            do index = Random.Range(0, config.Status.Count - 1);
            while (index == statusIndex);

            return index;
        }

        private ActivityType GetStatusType()
        {
            if (!StatusTypes.Contains(config.StatusType))
                PrintError($"Unknown Status Type '{config.StatusType}'");

            switch (config.StatusType)
            {
                case "Game":
                    return ActivityType.Game;
                case "Stream":
                    return ActivityType.Streaming;
                case "Listen":
                    return ActivityType.Listening;
                case "Watch":
                    return ActivityType.Watching;
                default:
                    return default(ActivityType);
            }
        }

        private string Format(string message)
        {
            message = message
                .Replace("{guild.name}", _guild.Name ?? "{unknown}")
                .Replace("{members.total}", _guild.MemberCount?.ToString() ?? "{unknown}")
                .Replace("{channels.total}", _guild.Channels?.Count.ToString() ?? "{unknown}")
                .Replace("{server.hostname}", server.Name)
                .Replace("{server.maxplayers}", server.MaxPlayers.ToString())
                .Replace("{players.online}", players.Connected.Count().ToString())
                .Replace("{players.authenticated}", GetAuthCount().ToString());

#if RUST
        message = message
            .Replace("{server.ip}", ConVar.Server.ip)
            .Replace("{server.port}", ConVar.Server.port.ToString())
            .Replace("{server.entities}", BaseNetworkable.serverEntities.Count.ToString())
            .Replace("{server.worldsize}", ConVar.Server.worldsize.ToString())
            .Replace("{server.seed}", ConVar.Server.seed.ToString())
            .Replace("{server.fps}", Performance.current.frameRate.ToString())
            .Replace("{server.avgfps}", Convert.ToInt32(Performance.current.frameRateAverage).ToString())
            .Replace("{players.queued}", ConVar.Admin.ServerInfo().Queued.ToString())
            .Replace("{players.joining}", ConVar.Admin.ServerInfo().Joining.ToString())
            .Replace("{players.sleepers}", BasePlayer.sleepingPlayerList.Count.ToString())
            .Replace("{players.total}", (players.Connected.Count() + BasePlayer.sleepingPlayerList.Count).ToString());
#endif

            return message;
        }

        private int GetAuthCount() => _link.GetLinkedCount();

        #endregion
    }
}

// --- End of file: DiscordStatus.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/NoBackpacks.cs ---
// --- Original Local Path: BeeRust/NoBackpacks.cs ---

﻿using System;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("No Backpacks", "hoppel", "1.0.4")]
    [Description("Removes backpacks after the configured amount of time")]
    public class NoBackpacks : RustPlugin
    {
        #region Hooks
        private void OnEntitySpawned(BaseNetworkable entity)
        {
            if (entity != null && entity.name.Contains("item_drop_backpack"))
            {
                timer.Once(despawnTimer, () =>
                {
                    if(!entity.IsDestroyed)
                        entity?.Kill();
                });
            }
        }
        #endregion

        #region Config
        private int despawnTimer;

        private new void LoadConfig()
        {
            GetConfig(ref despawnTimer, "Settings", "Despawn timer (seconds)");
            SaveConfig();
        }

        private void Init() => LoadConfig();

        private void GetConfig<T>(ref T variable, params string[] path)
        {
            if (path.Length == 0)
                return;

            if (Config.Get(path) == null)
            {
                Config.Set(path.Concat(new object[] { variable }).ToArray());
            }

            variable = (T)Convert.ChangeType(Config.Get(path), typeof(T));
        }

        protected override void LoadDefaultConfig() => PrintWarning("Generating new configuration file...");
        #endregion
    }
}

// --- End of file: NoBackpacks.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/RecyclerSpeed.cs ---
// --- Original Local Path: BeeRust/RecyclerSpeed.cs ---

using System;
using System.Collections.Generic;
using Newtonsoft.Json;

namespace Oxide.Plugins {

	[Info("Recycler Speed", "Ryz0r/yetzt", "2.0.2")]
	[Description("Easily set the speed at which the recycler... recycles")]

	public class RecyclerSpeed : RustPlugin {

		private const string UsePerm = "recyclerspeed.use";

		#region Config
		private Configuration _config;
		protected override void SaveConfig() => Config.WriteObject(_config);
		protected override void LoadDefaultConfig() => _config = new Configuration();

		private class Configuration {
			[JsonProperty(PropertyName = "Recyler Speed (Lower = Faster) (Seconds)")]
			public float RecyclerSpeed = 5.0f;
		}

		protected override void LoadConfig() {
			base.LoadConfig();
			try
			{
				_config = Config.ReadObject<Configuration>();
				if (_config == null) throw new Exception();

				Convert.ToSingle(_config.RecyclerSpeed);
				SaveConfig();
			}
			catch
			{
				PrintError("Your configuration file contains an error. Using default configuration values.");
				LoadDefaultConfig();
			}
		}
		#endregion

		private void Init() {
			permission.RegisterPermission(UsePerm, this);
		}

		private void OnRecyclerToggle(Recycler recycler, BasePlayer player) {
			if (recycler.IsOn()) return;
			if (!permission.UserHasPermission(player.userID.ToString(), UsePerm)) return;

			recycler.CancelInvoke(nameof(recycler.RecycleThink));
			timer.Once(0.1f, () => recycler.InvokeRepeating(recycler.RecycleThink, _config.RecyclerSpeed - 0.1f, _config.RecyclerSpeed));
		}
	}
}

// --- End of file: RecyclerSpeed.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/BublikMenu.cs ---
// --- Original Local Path: BeeRust/BublikMenu.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("BublikMenu", "King", "1.0.0")]
    public class BublikMenu : RustPlugin
    {
        #region [Vars]
        [PluginReference] private Plugin ImageLibrary = null;

        private const String Layer = "BubliliMenu.Layer";
        private List<UInt64> ButtonOpen = new List<UInt64>();

        private Dictionary<string, string> EventColor = new Dictionary<string, string>
        {
            ["PatrolHelicopter"] = "1 1 1 0.9",
            ["BradleyAPC"] = "1 1 1 0.9"
        };

        private Dictionary<String, String> ButtonList = new Dictionary<String, String>()
        {
            ["Клан"] = "/clan",
            ["КланТоп"] = "/ctop",
            ["Топ"] = "/top",
            ["Прицелы"] = "/hair",
            ["Репорты"] = "/report"
            
        };
        #endregion

        #region [ImageLibrary]
        private Boolean HasImage(String imageName, UInt64 imageId = 0) => (Boolean)ImageLibrary.Call("HasImage", imageName, imageId);
        private Boolean AddImage(String url, String shortname, UInt64 skin = 0) => (Boolean)ImageLibrary?.Call("AddImage", url, shortname, skin);
        private String GetImage(String shortname, UInt64 skin = 0) => (String)ImageLibrary?.Call("GetImage", shortname, skin);
        #endregion

        #region [Oxide-Api]
        private void OnServerInitialized()
        {
             AddImage("https://cdn.discordapp.com/attachments/1092142749035278414/1175407539597344808/pchela_9vpufk9409gm_64.png?ex=656b1e93&is=6558a993&hm=6980a10c9198e77bc980b67642dfa98ea055a26309ec266d6e3c43a2fa54e243&", $"{Name}.Online");
            AddImage("https://cdn.discordapp.com/attachments/1092142749035278414/1175406934778708028/icons8-honey-jar-64.png?ex=656b1e03&is=6558a903&hm=e3e4df45a561f4bd2dd41cd6d8bcce40f6159a58306d75ddb721d7d646cc160e&", $"{Name}.Button");
            AddImage("https://cdn.discordapp.com/attachments/1092142749035278414/1175363589943603210/8nx4pnW.png?ex=656af5a5&is=655880a5&hm=f9790fe542d7b608c93e989c74df6b0a57d6383a3d600bdfa4684a1becb0e870&", $"{Name}.PatrolHelicopter");
            AddImage("https://cdn.discordapp.com/attachments/1092142749035278414/1175363500902723595/bqB9Gkb.png?ex=656af58f&is=6558808f&hm=298194b03e80f042a70310ba292353fd3cb6719dccc543a15d569b3068cfda7c&", $"{Name}.BradleyAPC");

            foreach (BasePlayer player in BasePlayer.activePlayerList)
                OnPlayerConnected(player);

			foreach (var entity in BaseNetworkable.serverEntities)
				OnEntitySpawned(entity as BaseEntity);
        }

        private void Unload()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, Layer + ".Button");
                CuiHelper.DestroyUi(player, Layer + ".Online");
                CuiHelper.DestroyUi(player, Layer + ".Event");
            }
        }
        #endregion
        
        #region [Rust-Api]
        private void OnPlayerConnected(BasePlayer player)
        {
			if (player.IsReceivingSnapshot || player.IsSleeping())
			{
				timer.In(1, () => OnPlayerConnected(player));
				return;
			}

            InitializeBublikMenu(player);
            UpdateOnline();
        }

		private void OnPlayerDisconnected(BasePlayer player)
		{
            if (ButtonOpen.Contains(player.userID))
                ButtonOpen.Remove(player.userID);

			timer.In(1f, UpdateOnline);
		}

		private void OnEntitySpawned(BaseEntity entity)
		{
			EntityHandle(entity, true);
		}
		private void OnEntityKill(BaseEntity entity)
		{
			EntityHandle(entity, false);
		}
        #endregion

        #region [Functional]
        private void InitializeBublikMenu(BasePlayer player)
        {
			CuiElementContainer container = new CuiElementContainer();

            ButtonBublikMenu(ref container, player);
            OnlineBublikMenu(ref container, player);
            EventBublikMenu(ref container, player);

            CuiHelper.DestroyUi(player, Layer);
            CuiHelper.AddUi(player, container);
        }

        private void ButtonBublikMenu(ref CuiElementContainer container, BasePlayer player)
        {
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "4 -42.5", OffsetMax = "42.5 -4" },
                Image = { Color = "1 0.96 0.88 0.15" },
            }, "Overlay", Layer + ".Button");

            container.Add(new CuiElement
            {
                Parent = Layer + ".Button",
                Components =
                {
                    new CuiRawImageComponent { Png = GetImage($"{Name}.Button") },
                    new CuiRectTransformComponent { AnchorMin = "0.125 0.125", AnchorMax = "0.875 0.875" }
                }
            });

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Button = { Color = "0 0 0 0", Command = "BublikiButton" },
                Text = { Text = "" }
            }, Layer + ".Button");

            CuiHelper.DestroyUi(player, Layer + ".Button");
        }

        private void OnlineBublikMenu(ref CuiElementContainer container, BasePlayer player)
        {
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "46.5 -42.5", OffsetMax = "85 -4" },
                Image = { Color = "1 0.96 0.88 0.15" },
            }, "Overlay", Layer + ".Online");

            container.Add(new CuiElement
            {
                Parent = Layer + ".Online",
                Components =
                {
                    new CuiRawImageComponent { Png = GetImage($"{Name}.Online") },
                    new CuiRectTransformComponent { AnchorMin = "0.125 0.25", AnchorMax = "0.875 0.925" }
                }
            });

			container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.32" },
                Text = { Text = $"{BasePlayer.activePlayerList.Count}", Align = TextAnchor.MiddleCenter, FontSize = 9, Color = "1 1 1 1" }
            }, Layer + ".Online", Layer + ".Online" + ".Text");

            CuiHelper.DestroyUi(player, Layer + ".Online");
        }

        private void EventBublikMenu(ref CuiElementContainer container, BasePlayer player)
        {
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1" },
                Image = { Color = "0 0 0 0" },
            }, "Overlay", Layer + ".Event");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "89 -18.9", OffsetMax = "103.2 -4.7" },
                Image = { Color = "1 0.96 0.88 0.15" },
            }, Layer + ".Event", Layer + ".Event" + ".HeliCopter");

            container.Add(new CuiElement
            {
                Name = Layer + ".Event" + ".HeliCopter" + ".Image",
                Parent = Layer + ".Event" + ".HeliCopter",
                Components =
                {
                    new CuiRawImageComponent { Png = GetImage($"{Name}.PatrolHelicopter"), Color = EventColor["PatrolHelicopter"] },
                    new CuiRectTransformComponent { AnchorMin = "0.1 0.1", AnchorMax = "0.9 0.9" }
                }
            });

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "89 -36.1", OffsetMax = "103.2 -21.9" },
                Image = { Color = "1 0.96 0.88 0.15" },
            }, Layer + ".Event", Layer + ".Event" + ".BradleyAPC");

            container.Add(new CuiElement
            {
                Name = Layer + ".Event" + ".BradleyAPC" + ".Image",
                Parent = Layer + ".Event" + ".BradleyAPC",
                Components =
                {
                    new CuiRawImageComponent { Png = GetImage($"{Name}.BradleyAPC"), Color = EventColor["BradleyAPC"] },
                    new CuiRectTransformComponent { AnchorMin = "0.13 0.1", AnchorMax = "0.85 0.9" }
                }
            });

            CuiHelper.DestroyUi(player, Layer + ".Event");
        }

        private void ButtonsBublikMenu(BasePlayer player)
        {
            CuiElementContainer container = new CuiElementContainer();

			container.Add(new CuiPanel
			{
				RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1" },
				Image = { Color = "0 0 0 0" }
			}, Layer + ".Button", Layer + ".Buttons");

            Single ySwitchMin = -66.5f;
            Single ySwitchMax = -46.5f;

            foreach (KeyValuePair<String,String> button in ButtonList)
			{
				container.Add(new CuiPanel
				{
					RectTransform =
					{
						AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = $"0 {ySwitchMin}", OffsetMax = $"81 {ySwitchMax}"
					},
					Image = { Color = "1 0.96 0.88 0.15" }
				}, Layer + ".Buttons", Layer + ".Buttons" + $".{button.Key}");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Text = { Text = button.Key, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter, FontSize = 12, Color = "1 1 1 1" }
                }, Layer + ".Buttons" + $".{button.Key}");

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Color = "0 0 0 0", Command = $"playerSendly chat.say {button.Value}" },
                    Text = { Text = "" }
                }, Layer + ".Buttons" + $".{button.Key}");

                ySwitchMin += -24f;
                ySwitchMax += -24f;
            }

            CuiHelper.DestroyUi(player, Layer + ".Buttons");
            CuiHelper.AddUi(player, container);
        }

        private void UpdateOnline()
        {
            CuiElementContainer container = new CuiElementContainer();

			container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.32" },
                Text = { Text = $"{BasePlayer.activePlayerList.Count}", Align = TextAnchor.MiddleCenter, FontSize = 11, Color = "1 1 1 1" }
            }, Layer + ".Online", Layer + ".Online" + ".Text");

            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, Layer + ".Online" + ".Text");
                CuiHelper.AddUi(player, container);
            }
        }

        private void EntityHandle(BaseEntity entity, bool spawn)
		{
            if (entity == null) return;

            if (entity is PatrolHelicopter)
            {
                EventColor["PatrolHelicopter"] = spawn ? "0.97 0.62 0.62 1" : "1 1 1 0.9";

                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = Layer + ".Event" + ".HeliCopter" + ".Image",
                    Parent = Layer + ".Event" + ".HeliCopter",
                    Components =
                    {
                        new CuiRawImageComponent { Png = GetImage($"{Name}.PatrolHelicopter"), Color = EventColor["PatrolHelicopter"] },
                        new CuiRectTransformComponent { AnchorMin = "0.1 0.1", AnchorMax = "0.9 0.9" }
                    }
                });

                foreach (BasePlayer player in BasePlayer.activePlayerList)
                {
                    CuiHelper.DestroyUi(player, Layer + ".Event" + ".HeliCopter" + ".Image");
                    CuiHelper.AddUi(player, container);
                }
            }

            if (entity is BradleyAPC)
            {
                EventColor["BradleyAPC"] = spawn ? "1.00 0.84 0.52 1" : "1 1 1 0.9";

                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = Layer + ".Event" + ".BradleyAPC" + ".Image",
                    Parent = Layer + ".Event" + ".BradleyAPC",
                    Components =
                    {
                        new CuiRawImageComponent { Png = GetImage($"{Name}.BradleyAPC"), Color = EventColor["BradleyAPC"] },
                        new CuiRectTransformComponent { AnchorMin = "0.13 0.1", AnchorMax = "0.85 0.9" }
                    }
                });

                foreach (BasePlayer player in BasePlayer.activePlayerList)
                {
                    CuiHelper.DestroyUi(player, Layer + ".Event" + ".BradleyAPC" + ".Image");
                    CuiHelper.AddUi(player, container);
                }
            }
		}
        #endregion

        #region [ConsoleCommand]
		[ConsoleCommand("BublikiButton")]
		private void cmdBublikiButton(ConsoleSystem.Arg args)
		{
			BasePlayer player = args.Player();
			if (player == null) return;

			if (ButtonOpen.Contains(player.userID))
			{
				CuiHelper.DestroyUi(player, Layer + ".Buttons");
				ButtonOpen.Remove(player.userID);
			}
			else
			{
				ButtonsBublikMenu(player);
				ButtonOpen.Add(player.userID);
			}
		}

		[ConsoleCommand("playerSendly")]
		private void SendlyPlayer(ConsoleSystem.Arg args)
		{
			if (args.Player() != null)
			{
				var player = args.Player();
				var convertcmd =
					$"{args.Args[0]}  \" {string.Join(" ", args.Args.ToList().GetRange(1, args.Args.Length - 1))}\" 0";
				player.SendConsoleCommand(convertcmd);
			}
		}
        #endregion
    }
}

// --- End of file: BublikMenu.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/ClanPoint.cs ---
// --- Original Local Path: BeeRust/ClanPoint.cs ---

﻿using Facepunch.Extend;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust;
using Oxide.Game.Rust.Cui;
using ProtoBuf;
using Rust;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info( "ClanPoint", "Molik", "0.0.1" )]
    class ClanPoint : RustPlugin
    {
        [PluginReference] Plugin Clans;
        [ChatCommand("giveclan")]
        void CmdChatGiveClan(BasePlayer player, string command, string[] args )
        {
            if(player.IsAdmin || player == null)
            {
            string tag = args[0];
            int amount = Convert.ToInt32(args[1]);
            if(amount <= 0)
            {
                player.ChatMessage("Нельзя очки меньше нуля!");
            }
            else
            {
            Clans?.Call("GiveClanPoints", tag, amount);
            player.ChatMessage("Все вы выдали очки!");
            }
            }
            else
            {
                player.ChatMessage("Вы не админ!!!");
            }
        }
        [ChatCommand("remclan")]
        void CmdChatRemClan(BasePlayer player, string command, string[] args )
        {
            if(player.IsAdmin || player == null)
            {
            string tag = args[0];
            int amount = Convert.ToInt32(args[1]);
            if(amount <= 0)
            {
                player.ChatMessage("Нельзя очки меньше нуля!");
            }
            else
            {
            Clans?.Call("RemClanPoints", tag, amount);
            player.ChatMessage("Все вы забрали очки!");
            }
            }
            else
            {
                player.ChatMessage("Вы не админ!!!");
            }
        }
    }
}

// --- End of file: ClanPoint.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/InfiniteAmmo.cs ---
// --- Original Local Path: BeeRust/InfiniteAmmo.cs ---

﻿using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Infinite Ammo", "collect_vood & Mughisi", "1.3.0")]
    [Description("Allows permission based Infinite Ammo")]
    public class InfiniteAmmo : CovalencePlugin
    {
        #region Fields

        private readonly string _usePermission = "infiniteammo.use";

        #endregion

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>()
            {
                { "Disabled", "You no longer have infinite ammo!" },
                { "Enabled", "You now have infinite ammo!" },
                { "NotAllowed", "You are not allowed to use this command." },
            }, this);
        }

        #endregion

        #region Configuration

        private ConfigurationFile _configuration;

        public class ConfigurationFile
        {
            [JsonProperty(PropertyName = "Ammo Toggle Command")]
            public string AmmoToggleCommand = "toggleammo";     
            
            [JsonProperty(PropertyName = "Chat Prefix")]
            public string ChatPrefix = "Infinite Ammo";    
            
            [JsonProperty(PropertyName = "Chat Prefix Color")]
            public string ChatPrefixColor = "#008800";            
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            _configuration = new ConfigurationFile();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _configuration = Config.ReadObject<ConfigurationFile>();
            SaveConfig();
        }

        protected override void SaveConfig() => Config.WriteObject(_configuration);

        #endregion

        #region Data

        private StoredData _storedData;

        public class StoredData
        {
            [JsonProperty(PropertyName = "Active Infinite Ammo Player UserIds", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<ulong> ActiveUsers = new List<ulong>();
        }
        
        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(Name, _storedData);
        }

        private void Unload()
        {
            SaveData();
        }

        #endregion

        #region Hooks

        private void Init()
        {
            _storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);

            permission.RegisterPermission(_usePermission, this);

            AddCovalenceCommand(_configuration.AmmoToggleCommand, nameof(CommandToggleAmmo));
        }

        private void OnWeaponFired(BaseProjectile projectile, BasePlayer player)
        {
            if (!IsInfiniteAmmo(player.userID))
            {
                return;
            }

            var heldEntity = projectile.GetItem();
            heldEntity.condition = heldEntity.info.condition.max;

            if (projectile.primaryMagazine.contents > 0)
            {
                return;
            }

            projectile.primaryMagazine.contents = projectile.primaryMagazine.capacity;
            projectile.SendNetworkUpdateImmediate();
        }

        private void OnRocketLaunched(BasePlayer player)
        {
            if (!IsInfiniteAmmo(player.userID))
            {
                return;
            }

            var heldEntity = player.GetActiveItem();
            if (heldEntity == null)
            {
                return;
            }

            heldEntity.condition = heldEntity.info.condition.max;

            var weapon = heldEntity.GetHeldEntity() as BaseProjectile;
            if (weapon == null)
            {
                return;
            }

            if (weapon.primaryMagazine.contents > 0)
            {
                return;
            }

            weapon.primaryMagazine.contents = weapon.primaryMagazine.capacity;
            weapon.SendNetworkUpdateImmediate();
        }

        private void OnMeleeThrown(BasePlayer player, Item item)
        {
            if (!IsInfiniteAmmo(player.userID))
            {
                return;
            }

            var newMelee = ItemManager.CreateByItemID(item.info.itemid, item.amount, item.skin);
            newMelee._condition = item._condition;

            player.GiveItem(newMelee, BaseEntity.GiveItemReason.PickedUp);
        }

        private void OnServerSave()
        {
            SaveData();
        }

        #endregion

        #region Commands

        private void CommandToggleAmmo(IPlayer iPlayer, string cmd, string[] args)
        {
            var bPlayer = iPlayer.Object as BasePlayer;

            if (bPlayer == null)
            {
                return;
            }

            if (!CanUseInfiniteAmmo(bPlayer))
            {
                SendMessage(bPlayer, GetMessage("NotAllowed", bPlayer));
                return;
            }

            if (!IsInfiniteAmmo(bPlayer.userID))
            {
                _storedData.ActiveUsers.Add(bPlayer.userID);
                SendMessage(bPlayer, GetMessage("Enabled", bPlayer));
            }
            else
            {
                _storedData.ActiveUsers.Remove(bPlayer.userID);
                SendMessage(bPlayer, GetMessage("Disabled", bPlayer));
            }
        }

        #endregion

        #region Methods

        private void SendMessage(BasePlayer player, string message)
        {
            player.ChatMessage($"<color={_configuration.ChatPrefixColor}>{_configuration.ChatPrefix}</color>: {message}");
        }

        private bool IsInfiniteAmmo(ulong userId) => _storedData.ActiveUsers.Contains(userId);

        private bool CanUseInfiniteAmmo(BasePlayer player)
            => (player.IsAdmin || permission.UserHasPermission(player.UserIDString, _usePermission));

        private string GetMessage(string key, BasePlayer player, params string[] args) 
            => String.Format(lang.GetMessage(key, this, player.UserIDString), args);

        #endregion
    }
}

// --- End of file: InfiniteAmmo.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/AutoCleanup.cs ---
// --- Original Local Path: BeeRust/AutoCleanup.cs ---

using System.Collections.Generic;
using System.Collections;
using System.Linq;
using UnityEngine;
using System;

namespace Oxide.Plugins
{
    [Info("AutoCleanup", "Server-rust.ru fixed by pahan0772", "1.0.8")]
    class AutoCleanup : RustPlugin
    {
        bool Changed = false;

        bool logToConsole, broadcastToChat, cleanOnLoad;
        float timerIntervalInSeconds, decayPercentage;
        string commandPermission, excludePermission, cleanupChatCommand, cleanupConsoleCommand;

        List<object> entityList;

        List<object> GetDefaultEntityList()
        {
            return new List<object>()
            {
                "assets/prefabs/building/gates.external.high/gates.external.high.stone/gates.external.high.stone.prefab",
                "assets/prefabs/building/gates.external.high/gates.external.high.wood/gates.external.high.wood.prefab",
                "assets/prefabs/building/wall.external.high.stone/wall.external.high.stone.prefab",
                "assets/prefabs/building/wall.external.high.wood/wall.external.high.wood.prefab",
                "assets/prefabs/misc/item drop/item_drop_backpack.prefab",
                "assets/prefabs/gamemodes/objects/reclaim/reclaimbackpack.prefab",
                "assets/prefabs/misc/item drop/item_drop.prefab",
                "assets/prefabs/misc/item drop/item_drop.prefab",

                "assets/prefabs/deployable/barricades/barricade.concrete.prefab",
                "assets/prefabs/deployable/barricades/barricade.metal.prefab",
                "assets/prefabs/deployable/barricades/barricade.sandbags.prefab",
                "assets/prefabs/deployable/barricades/barricade.stone.prefab",
                "assets/prefabs/deployable/barricades/barricade.wood.prefab",
                "assets/prefabs/deployable/barricades/barricade.woodwire.prefab",
                
            };
        }

        void Init()
        {
            LoadVariables();
            LoadDefaultMessages();
            RegisterPermissions();

            cmd.AddChatCommand(cleanupChatCommand, this, "cmdCleanupChatCommand");
            cmd.AddConsoleCommand(cleanupConsoleCommand, this, "cmdCleanupConsoleCommand");

            if (cleanOnLoad) CleanUp();

            timer.Every(timerIntervalInSeconds, () => { CleanUp(); });
        }

        void cmdCleanupChatCommand(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, commandPermission))
            {
                player.ChatMessage(Lang("NoPermission", player.UserIDString));
                return;
            }

            CleanUp();
        }

        void cmdCleanupConsoleCommand(ConsoleSystem.Arg arg)
        {
            if (arg?.Connection != null && !permission.UserHasPermission(arg?.Player()?.userID.ToString(), commandPermission)) return;

            CleanUp();
        }
        void CleanUp()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                player.ChatMessage($"<size=20>Запущена <color=#ffde5a>оптимизация карты!</color></size>\n<size=15>Все стенки будут уничтожены в течение <color=#ffde5a>20 секунд.</color></size>");

            }
            timer.Once(20f, () =>
            {
                CCleanUp();
            });
        }
        void CCleanUp()
        {
            if (broadcastToChat)
                PrintToChat(Lang("LocatingEntities", null));
            if (logToConsole)
                PrintWarning(Lang("LocatingEntities", null));

            int reduced = 0;
            int destroyed = 0;

            foreach (var entity in BaseNetworkable.serverEntities.Where(e => (e as BaseEntity).OwnerID != 0 && !permission.UserHasPermission((e as BaseEntity).OwnerID.ToString(), excludePermission) && entityList.Contains((e as BaseEntity).name)).ToList())
            {
                var entityRadius = Physics.OverlapSphere(entity.transform.position, 0.5f, LayerMask.GetMask("Trigger"));
                int cupboards = 0;

                foreach (var cupboard in entityRadius.Where(x => x.GetComponentInParent<BuildingPrivlidge>() != null)) cupboards++;

                if (cupboards == 0)
                {
                    var ent = ((BaseCombatEntity)entity);

                    if (ent.health - (ent.MaxHealth() * (decayPercentage / 100)) <= 0)
                    {
                        entity?.KillMessage();
                        destroyed++;
                    }
                    else
                    {
                        ent.health -= (ent.MaxHealth() * (decayPercentage / 100));

                        ent.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                        reduced++;
                    }
                }
            }

            /*if (broadcastToChat)
            {
                PrintToChat(Lang("EntitiesReducedHealth", null, reduced, decayPercentage));
                PrintToChat(Lang("EntitiesDestroyed", null, destroyed));
            }

            if (logToConsole)
            {
                PrintWarning(Lang("EntitiesReducedHealth", null, reduced, decayPercentage));
                PrintWarning(Lang("EntitiesDestroyed", null, destroyed));
            }*/
        }

        void LoadDefaultMessages()
        {
            // English
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["LocatingEntities"] = "Locating all External Walls/Gates & Barricades outside Cupboard Range...",
                ["EntitiesReducedHealth"] = "Reduced the health of {0} External Walls/Gates & Barricades by {1}%.",
                ["EntitiesDestroyed"] = "Destroyed {0} External Walls/Gates & Barricades.",
                ["NoPermission"] = "You do not have permission to use this command."
            }, this);
        }

        void RegisterPermissions()
		{
			permission.RegisterPermission(excludePermission, this);
			permission.RegisterPermission(commandPermission, this);
		}

        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            LoadVariables();
        }

        void LoadVariables()
        {
            timerIntervalInSeconds = Convert.ToSingle(GetConfig("Settings", "Timer Interval (Seconds)", 3600f));
            decayPercentage = Convert.ToSingle(GetConfig("Settings", "Reduce health by (Percentage)", 10.0f));

            logToConsole = Convert.ToBoolean(GetConfig("Settings", "Log Messages to Console", true));
            broadcastToChat = Convert.ToBoolean(GetConfig("Settings", "Broadcast Messages to Chat", true));
            cleanOnLoad = Convert.ToBoolean(GetConfig("Settings", "Clean up when plugin is loaded", false));


            entityList = (List<object>)GetConfig("Settings", "List of entities", GetDefaultEntityList());

            excludePermission = Convert.ToString(GetConfig("Permissions", "ExcludePermission", "autocleanup.exclude"));
            commandPermission = Convert.ToString(GetConfig("Permissions", "CommandPermission", "autocleanup.cleanup"));
			
			
            cleanupChatCommand = Convert.ToString(GetConfig("Commands", "CleanupChatCommand", "cleanup"));
            cleanupConsoleCommand = Convert.ToString(GetConfig("Commands", "CleanupConsoleCommand", "autocleanup.cleanup"));

            if (!Changed) return;
            SaveConfig();
            Changed = false;
        }

        object GetConfig(string menu, string dataValue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }

            object value;
            if (!data.TryGetValue(dataValue, out value))
            {
                value = defaultValue;
                data[dataValue] = value;
                Changed = true;
            }

            return value;
        }

        string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);
    }
}

// --- End of file: AutoCleanup.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/MenuAlerts.cs ---
// --- Original Local Path: BeeRust/MenuAlerts.cs ---

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using Facepunch;

namespace Oxide.Plugins
{
    [Info("MenuAlerts", "King", "1.0.5")]
    public class MenuAlerts : RustPlugin
    {
        #region [Vars]
        [PluginReference] private Plugin ImageLibrary = null;
        private static MenuAlerts plugin;
        private const String Layer = "MenuAlerts_UI";
        #endregion

        #region [ImageLibrary]
        private Boolean HasImage(String imageName, ulong imageId = 0) => (Boolean)ImageLibrary.Call("HasImage", imageName, imageId);
        private Boolean AddImage(String url, String shortname, ulong skin = 0) => (Boolean)ImageLibrary?.Call("AddImage", url, shortname, skin);
        private String GetImage(String shortname, ulong skin = 0) => (String)ImageLibrary?.Call("GetImage", shortname, skin);
        #endregion

        #region [MenuAlerts Data]
        private readonly Dictionary<BasePlayer, MenuAlertsComponent> _MenuAlerts = new Dictionary<BasePlayer, MenuAlertsComponent>();

        private class AlertsData
        {
            public Int32 _startTime;
            public Int32 _cooldown;
            
            public String _titleUI;
            public String _textUI;

            public Boolean _isLarge;
            public Boolean _isOpen;
            public String _imageUI;
            public String _pluginName;
        }
        #endregion

        #region [Oxide]
        private void OnServerInitialized()
        {
            plugin = this;
        }

        private void Unload()
        {
            _MenuAlerts.Values.ToList().ForEach(MenuAlerts =>
            {
                if (MenuAlerts != null)
                    MenuAlerts.Kill();
            });

            foreach (BasePlayer player in BasePlayer.activePlayerList)
                CuiHelper.DestroyUi(player, Layer);

            plugin = null;
        }
        #endregion

        #region [ConsoleCommand]
		[ConsoleCommand("MenuAlerts_UI")]
		private void CmdConsoleNotify(ConsoleSystem.Arg arg)
		{
			BasePlayer player = arg?.Player();
			if (player == null || !arg.HasArgs()) return;

			switch (arg.Args[0])
			{
				case "openMenu":
				{
                    MenuAlertsComponent menuAlert = GetComponent(player);
                    if (menuAlert == null) return;

                    AlertsData find = menuAlert._alertsData.FirstOrDefault(p => p._pluginName == arg.Args[1]);
                    if (find == null || find._isOpen) return;

                    find._isOpen = true;
                    menuAlert.MainUi();
					break;
				}
                case "closeMenu":
                {
                    MenuAlertsComponent menuAlert = GetComponent(player);
                    if (menuAlert == null) return;

                    AlertsData find = menuAlert._alertsData.FirstOrDefault(p => p._pluginName == arg.Args[1]);
                    if (find == null || !find._isOpen) return;
            
                    find._isOpen = false;
                    menuAlert.MainUi();
                    break;
                }
			}
		}
        #endregion

        #region [Component]
        private MenuAlertsComponent GetComponent(BasePlayer player)
        {
            MenuAlertsComponent component;
            return _MenuAlerts.TryGetValue(player, out component)
                ? component
                : (player.gameObject.AddComponent<MenuAlertsComponent>());
        }

        private class MenuAlertsComponent : FacepunchBehaviour
        {
            #region [Fields]
            private BasePlayer _player;
            public readonly List<AlertsData> _alertsData = new List<AlertsData>();

            private void Awake()
            {
                _player = GetComponent<BasePlayer>();

                plugin._MenuAlerts[_player] = this;

                Invoke(MenuAlertController, 1);
            }

            private void MenuAlertController()
            {
                CancelInvoke(MenuAlertController);
                if (_alertsData.Count == 0 || !_player.IsConnected)
                {
                    Kill();
                    return;
                }

                List<AlertsData> result = Pool.GetList<AlertsData>();

				_alertsData.ForEach(key =>
				{
                    if (Facepunch.Math.Epoch.Current - key._startTime >= key._cooldown)
                    {
                        result.Add(key);
                    }
                    else
                    {
					    CuiElementContainer container = new CuiElementContainer();
					    MenuLine(ref container, key);
                        if (key._isOpen)
                        {
                            TextUi(ref container, key);
                        }
					    CuiHelper.AddUi(_player, container);
                    }
				});


                if (result.Count > 0)
                {
                    foreach (AlertsData key in result)
                    {
                        RemoveMenu(_alertsData.IndexOf(key));
                    }
                }

                Pool.FreeList(ref result);
                Invoke(MenuAlertController, 1);
            }
            #endregion

            #region [Destroy]
            private void OnDestroy()
            {
                CancelInvoke();

                CuiHelper.DestroyUi(_player, Layer);

                plugin?._MenuAlerts.Remove(_player);
            }

            public void Kill()
            {
                DestroyImmediate(this);
            }
            #endregion

            #region [AddRemove]
            public void AddMenu(AlertsData data)
            {
                _alertsData.Add(data);

                MainUi();
            }

            public void RemoveMenu(Int32 index)
            {
                _alertsData.RemoveAt(index);

                if (_alertsData.Count == 0)
                {
                    Kill();
                    return;
                }

                MainUi();
            }
            #endregion

            #region [UI]
            public void MainUi()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = "1 0.5", AnchorMax = "1 0.5" },
                    Image = {Color = "0 0 0 0"}
                }, "Overlay", Layer);

                Single StartPosition = _alertsData.Count == 1 ? 0f : _alertsData.Count * 15f;
                Single SwitchMax = 20f + StartPosition;
                Single SwitchMin = -20f + StartPosition;

				_alertsData.ForEach(key =>
				{
                    container.Add(new CuiPanel
                    {
                        RectTransform = { AnchorMin = "1 0.5", AnchorMax = "1 0.5", OffsetMin = $"-44 {SwitchMin}", OffsetMax = $"-4 {SwitchMax}" },
                        Image = { Color = "0.5 0.5 0.5 0.25", Material = "assets/icons/greyout.mat" }
                    }, Layer, Layer + $".{key._pluginName}");

                    container.Add(new CuiElement
                    {
                        Parent = Layer + $".{key._pluginName}",
                        Components =
                        {
                            new CuiRawImageComponent { Png = plugin.GetImage(key._imageUI)},
                            new CuiRectTransformComponent {AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "4 4", OffsetMax = "-4 -4"},
                            new CuiOutlineComponent{Color = "0 0 0 1", Distance = "0.15 0.15"}
                        }
                    });

                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                        Button = {  Color = "0 0 0 0", Command = $"MenuAlerts_UI openMenu {key._pluginName}" },
                        Text = { Text = "" }
                    }, Layer + $".{key._pluginName}");

                    MenuLine(ref container, key);

                    if (key._isOpen)
                    {
                        InfoUi(ref container, key);
                    }

                    if (key._isLarge && key._isOpen)
                    {
                        SwitchMin += -86;
                        SwitchMax += -86;
                    }
                    else
                    {
                        SwitchMin += -44;
                        SwitchMax += -44;
                    }
				});

                CuiHelper.DestroyUi(_player, Layer);
                CuiHelper.AddUi(_player, container);
            }

			public void MenuLine(ref CuiElementContainer container, AlertsData key)
			{
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = $"{0.97f - ((float)(Facepunch.Math.Epoch.Current - key._startTime) / key._cooldown)} 0.025" },
                    Image = { Color = GetColorLine(Facepunch.Math.Epoch.Current - key._startTime, key._cooldown) }
                }, Layer + $".{key._pluginName}", Layer + $".{key._pluginName}" + ".Bar");

                CuiHelper.DestroyUi(_player, Layer + $".{key._pluginName}" + ".Bar");
			}

            public void InfoUi(ref CuiElementContainer container, AlertsData key)
            {
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = $"-203.5 {(key._isLarge == true ? -42 : 0)}", OffsetMax = $"-44 0" },
                    Image = { Color = "0.5 0.5 0.5 0.25", Material = "assets/icons/greyout.mat" }
                }, Layer + $".{key._pluginName}", Layer + $".{key._pluginName}" + ".Info");

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"0.93 {(key._isLarge == true ? 0.825 : (0.625))}", AnchorMax = $"0.995 {(key._isLarge == true ? 0.99 : (0.97))}"},
                    Button = { Command = $"MenuAlerts_UI closeMenu {key._pluginName}", Color = "0.9 0 0 0.65", Material = "assets/icons/greyout.mat" },
                    Text = { Text = "✘", Color = "1 1 1 1", Align = TextAnchor.MiddleCenter, FontSize = 12, Font = "robotocondensed-bold.ttf" }
                }, Layer + $".{key._pluginName}" + ".Info");

                container.Add(new CuiElement()
                {
                    Parent = Layer + $".{key._pluginName}" + ".Info",
                    Components =
                    {
                        new CuiTextComponent{Color = "1 1 1 0.9", Text = $"{key._textUI}", Align = TextAnchor.UpperLeft, FontSize = 12, Font = "robotocondensed-regular.ttf"},
                        new CuiRectTransformComponent{AnchorMin = "0.03 0", AnchorMax = $"0.925 {(key._isLarge == true ? 0.77 : 0.5)}"},
                        new CuiOutlineComponent {Color = "0 0 0 1", Distance = "0.45 0.45"},
                    }
                });

                TextUi(ref container, key);
                CuiHelper.DestroyUi(_player, Layer + $".{key._pluginName}" + ".Info");
            }

            public void TextUi(ref CuiElementContainer container, AlertsData key)
            {
                TimeSpan time = TimeSpan.FromSeconds(key._startTime - Facepunch.Math.Epoch.Current + key._cooldown);
                container.Add(new CuiElement()
                {
                    Parent = Layer + $".{key._pluginName}" + ".Info",
                    Name = Layer + $".{key._pluginName}" + ".Info" + ".Text",
                    Components =
                    {
                        new CuiTextComponent{Color = "1 1 1 1", Text = $"{key._titleUI}: ({GetFormatTime(time)})", Align = TextAnchor.UpperLeft, FontSize = 16, Font = "robotocondensed-bold.ttf"},
                        new CuiRectTransformComponent{AnchorMin = "0.03 0", AnchorMax = $"0.925 {(key._isLarge == true ? 0.98 : 0.95)}"},
                        new CuiOutlineComponent {Color = "0 0 0 1", Distance = "0.45 0.45"},
                    }
                });

                CuiHelper.DestroyUi(_player, Layer + $".{key._pluginName}" + ".Info" + ".Text");
            }
            #endregion

            private String GetColorLine(Int32 count, Int32 max)
            {
                float n = max > 0 ? (float)ColorLine.Length / max : 0;
                Int32 index = (Int32)(count * n);
                if (index > 0) index--;
                return ColorLine[index];
            }

            private String[] ColorLine = { "1.00 1.00 1.00 1.00", "1.00 0.98 0.96 1.00", "1.00 0.97 0.92 1.00", "1.00 0.96 0.88 1.00", "1.00 0.94 0.84 1.00", "1.00 0.93 0.80 1.00", "1.00 0.91 0.76 1.00", "1.00 0.90 0.71 1.00", "1.00 0.89 0.67 1.00", "1.00 0.87 0.63 1.00", "1.00 0.85 0.59 1.00", "1.00 0.84 0.55 1.00", "1.00 0.83 0.51 1.00", "1.00 0.81 0.47 1.00", "1.00 0.80 0.43 1.00", "1.00 0.78 0.39 1.00", "1.00 0.77 0.35 1.00", "1.00 0.76 0.31 1.00", "1.00 0.74 0.27 1.00", "1.00 0.73 0.22 1.00", "1.00 0.71 0.18 1.00", "1.00 0.70 0.14 1.00", "1.00 0.68 0.10 1.00", "1.00 0.67 0.06 1.00", "1.00 0.65 0.02 1.00", "1.00 0.64 0.00 1.00", "1.00 0.61 0.00 1.00", "1.00 0.58 0.00 1.00", "1.00 0.55 0.00 1.00", "1.00 0.53 0.00 1.00", "1.00 0.50 0.00 1.00", "1.00 0.47 0.00 1.00", "1.00 0.45 0.00 1.00", "1.00 0.42 0.00 1.00", "1.00 0.40 0.00 1.00", "1.00 0.37 0.00 1.00", "1.00 0.35 0.00 1.00", "1.00 0.32 0.00 1.00", "1.00 0.29 0.00 1.00", "1.00 0.26 0.00 1.00", "1.00 0.24 0.00 1.00", "1.00 0.21 0.00 1.00", "1.00 0.18 0.00 1.00", "1.00 0.16 0.00 1.00", "1.00 0.13 0.00 1.00", "1.00 0.11 0.00 1.00", "1.00 0.08 0.00 1.00", "1.00 0.05 0.00 1.00", "1.00 0.03 0.00 1.00", "1.00 0.00 0.00 1.00" };

            private String GetFormatTime(TimeSpan timespan) => String.Format(timespan.TotalHours >= 1 ? "{2:00}:{0:00}:{1:00}" : "{0:00}:{1:00}", timespan.Minutes, timespan.Seconds, System.Math.Floor(timespan.TotalHours));
        }
        #endregion

        #region [API]
        private void UpdateCooldownTimeMenu(BasePlayer player, Int32 cooldown, String pluginName)
        {
            MenuAlertsComponent menuAlert = GetComponent(player);
            if (menuAlert == null) return;

            AlertsData find = menuAlert._alertsData.FirstOrDefault(p => p._pluginName == pluginName);
            if (find == null) return;

            find._cooldown = cooldown;
        }

        private void UpdateStartTimeMenu(BasePlayer player, Int32 startTime, String pluginName)
        {
            MenuAlertsComponent menuAlert = GetComponent(player);
            if (menuAlert == null) return;

            AlertsData find = menuAlert._alertsData.FirstOrDefault(p => p._pluginName == pluginName);
            if (find == null) return;

            find._startTime = startTime;
        }

        private void SendAlertMenu(BasePlayer player, Int32 startTime, Int32 cooldown, String titleUI, String textUI, Boolean isLarge, String imageUI, String pluginName)
        {
            MenuAlertsComponent menuAlert = GetComponent(player);
            if (menuAlert == null) return;

            AlertsData find = menuAlert._alertsData.FirstOrDefault(p => p._pluginName == pluginName);
            if (find != null)
            {
                find._startTime = startTime;
                find._cooldown = cooldown;

                find._titleUI = titleUI;
                find._textUI = textUI;

                find._isLarge = isLarge;
                find._isOpen = false;
                find._imageUI = imageUI;

                menuAlert.MainUi();
                return;
            }

            AlertsData data = new AlertsData
            {
                _startTime = startTime,
                _cooldown = cooldown,

                _titleUI = titleUI,
                _textUI = textUI,

                _isLarge = isLarge,
                _isOpen = false,
                _imageUI = imageUI,
                _pluginName = pluginName
            };

            menuAlert.AddMenu(data);
        }

        private void RemoveAlertMenu(BasePlayer player, String pluginName)
        {
            if (player == null) return;

            MenuAlertsComponent menuAlert = GetComponent(player);
            if (menuAlert == null) return;

            AlertsData find = menuAlert._alertsData.FirstOrDefault(p => p._pluginName == pluginName);
            if (find == null) return;

            menuAlert.RemoveMenu(menuAlert._alertsData.IndexOf(find));
        }
        #endregion
    }
}

// --- End of file: MenuAlerts.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/InstantBarrel.cs ---
// --- Original Local Path: BeeRust/InstantBarrel.cs ---

﻿/*
 * Exotic Plugins © 2023
 * File can not be copied, modified and/or distributed without the express permission from Tryhard
 * For support join our discord - https://discord.gg/YnbYaugRMh
 */

using System;
using CompanionServer.Handlers;
using Newtonsoft.Json;
using Oxide.Core;
using Rust;
using UnityEngine; 

namespace Oxide.Plugins
{
    [Info("Instant Barrel", "Tryhard", "1.1.5")]
    [Description("Makes barrels and road signs 1 hp and instantly spawns loot in player inventory")]
    public class InstantBarrel : RustPlugin
    {
        private const string onPermission = "InstantBarrel.on";

        private readonly string[] lootBarrelsNames = { "loot_barrel_1", "loot_barrel_2", "loot-barrel-1", "loot-barrel-2", "oil_barrel", "roadsign1", "roadsign2", "roadsign3", "roadsign4", "roadsign5", "roadsign6", "roadsign7", "roadsign8", "roadsign9" };

        private void OnServerInitialized() => permission.RegisterPermission(onPermission, this);

        private object OnEntityTakeDamage(LootContainer lootContainer, HitInfo hitInfo)
        {
            if (lootContainer == null || hitInfo == null || hitInfo.ProjectileDistance > config.maxDistance)
                return null;

            if (!config.oneShot && hitInfo.damageTypes.Total() < lootContainer.health) 
                return null;

            var lootContainerName = lootContainer.ShortPrefabName;

            if (lootContainerName == null || !lootBarrelsNames.Contains(lootContainerName))
                return null;

            var player = lootContainer.lastAttacker as BasePlayer ?? hitInfo.InitiatorPlayer;

            if (player == null || !permission.UserHasPermission(player.UserIDString, onPermission))
                return null;

            var itemContainer = lootContainer?.inventory;

            if (itemContainer == null) return null;

            if ((int)Vector2.Distance(player.transform.position, lootContainer.transform.position) > config.maxDistance) return null;

            if (!config.eWeapon && hitInfo.IsProjectile()) return null;

            for (int i = itemContainer.itemList.Count - 1; i >= 0; i--)
                player.GiveItem(itemContainer.itemList[i], BaseEntity.GiveItemReason.PickedUp);

            if (itemContainer.itemList == null || itemContainer.itemList.Count <= 0)
            {
                NextTick(() =>
                {
                    Interface.CallHook("OnEntityDeath", lootContainer, hitInfo);

                    if (config.gibs) lootContainer?.Kill(BaseNetworkable.DestroyMode.Gib);

                    else lootContainer?.Kill();
                });
            }

            return false;
        }

        #region Config
        static Configuration config;
        public class Configuration
        {
            [JsonProperty("Enable farming with weapons")]
            public bool eWeapon = true;

            [JsonProperty("Max farming distance")]
            public float maxDistance = 3f;

            [JsonProperty("Make barrels 1 hit to kill")]
            public bool oneShot = true;

            [JsonProperty("Enable barrel gibs")]
            public bool gibs = true;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
                SaveConfig();
            }
            catch (Exception e)
            {
                Debug.LogException(e);
                PrintWarning("Creating new config file.");
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig() => config = new Configuration();
        protected override void SaveConfig() => Config.WriteObject(config);
        #endregion
    }
}

// --- End of file: InstantBarrel.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/ClansTop.cs ---
// --- Original Local Path: BeeRust/ClansTop.cs ---

using System;
using System.Linq;
using System.Globalization;
using System.Collections.Generic;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
	[Info("Clans Top", "King", "1.0.1")]
	public class ClansTop : RustPlugin
	{
        #region [Vars]
        [PluginReference] private Plugin Clans;
        private Dictionary<string, int> clanList = new Dictionary<string, int>();

        private const string Layer = "ClansTop.Layer";
        #endregion

        #region [Config]
        private PluginConfig config;

        protected override void LoadDefaultConfig()
        {
            config = PluginConfig.DefaultConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();

            if (config.PluginVersion < Version)
                UpdateConfigValues();

            Config.WriteObject(config, true);
        }

        private void UpdateConfigValues()
        {
            PluginConfig baseConfig = PluginConfig.DefaultConfig();
            if (config.PluginVersion < Version)
            {
                config.PluginVersion = Version;
                if (Version == new VersionNumber(1, 0, 1))
                {
                    config.Settings.colorFirsClan = "#6692BBCC";
                    config.Settings.colorTwoClan = "#C08D5CCC";
                    config.Settings.colorThreeClan = "#C08D5CCC";
                }

                PrintWarning("Config checked completed!");
            }
            config.PluginVersion = Version;
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        public class Settings
        {
            [JsonProperty("Раз в сколько секунд будет отправлятся сообщение ?")]
            public int chatSendTopTime;

            [JsonProperty("Отправлять в чат сообщения с топ 5 кланами ?")]
            public bool chatSendTop;

            [JsonProperty("Раз в сколько секунд обновлять панель топ трех кланов ?")]
            public int updatePanelTime;

            [JsonProperty("Использовать панель топ трех кланов ?")]
            public bool usePanelTop;

            [JsonProperty("Цвет первого места из панельки ( При использовании панели топ трех кланов )")]
            public string colorFirsClan;

            [JsonProperty("Цвет второго места из панельки ( При использовании панели топ трех кланов )")]
            public string colorTwoClan;

            [JsonProperty("Цвет третьего места из панельки ( При использовании панели топ трех кланов )")]
            public string colorThreeClan;
        }

        private class PluginConfig
        {
            [JsonProperty("Основные настройки плагина")]
            public Settings Settings;

            [JsonProperty("Config version")]
            public VersionNumber PluginVersion = new VersionNumber();

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    Settings = new Settings()
                    {
                        chatSendTopTime = 600,
                        chatSendTop = true,
                        updatePanelTime = 10,
                        usePanelTop = true,
                        colorFirsClan = "#6692BBCC",
                        colorTwoClan = "#C08D5CCC",
                        colorThreeClan = "#C08D5CCC",
                    },
                    PluginVersion = new VersionNumber()
                };
            }
        }
        #endregion

        #region [Oxide-Api]
		private void OnServerInitialized()
		{
            if (!Clans)
            {
                NextTick(() =>
                {
                    PrintWarning("Проверьте, установлен ли у вас плагин Clans");
                    Interface.Oxide.UnloadPlugin(Name);
                });
                return;
            }

            ChatPrintTop();
            
            if (config.Settings.chatSendTop)
                timer.Once(config.Settings.chatSendTopTime, ChatPrintTop);
            if (config.Settings.usePanelTop)
            {
                timer.Every(config.Settings.updatePanelTime, () =>
                {
                    UpdateTopDictionary();

                    foreach (var player in BasePlayer.activePlayerList)
                        GenerateTopUI(player);
                });

                foreach (var player in BasePlayer.activePlayerList)
                    OnPlayerConnected(player);
            }
		}

		private void Unload()
		{
			foreach (var player in BasePlayer.activePlayerList) 
                CuiHelper.DestroyUi(player, Layer);
		}
        #endregion

        #region [Rust-Api]
		private void OnPlayerConnected(BasePlayer player)
		{
			UpdateTopDictionary();
            GenerateTopUI(player);
		}
        #endregion

        #region [Gui]
        private void GenerateTopUI(BasePlayer player)
        {
            var container = new CuiElementContainer();
            
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "0 0", OffsetMax = "1 1" },
                Image = { Color = "0 0 0 0" }
            }, "Overlay", Layer);

            foreach (var check in clanList.Select((i, t) => new { A = i, B = t }).Take(3))
            {
                string Color = check.B == 0 ? $"{HexToRustFormat(config.Settings.colorFirsClan)}" : check.B == 1 ? $"{HexToRustFormat(config.Settings.colorTwoClan)}" : check.B == 2 ? $"{HexToRustFormat(config.Settings.colorThreeClan)}" : "0 0 0 0";

                container.Add(new CuiPanel
                {
                    RectTransform = {   AnchorMin = "0 0", AnchorMax = "0 0",
                                        OffsetMin = $"{-199.5 + check.B * 128 - Math.Floor((float) check.B / 3) * 3 * 128} 0",
                                        OffsetMax = $"{-76 + check.B * 128 - Math.Floor((float) check.B / 3) * 3 * 128} 16.5", },
                    Image = { Color = "0 0 0 0", }
                }, Layer, Layer + ".Top" + $".{check.B}");

                container.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "0.145 1" },
                    Image = { Color = "1 1 1 0.025", Material = "assets/icons/greyout.mat" }
                }, Layer + ".Top" + $".{check.B}", Layer + ".Top" + $".{check.B}" + $".Pos{check.B}");

                container.Add(new CuiElement
                {
                    Parent = Layer + ".Top" + $".{check.B}" + $".Pos{check.B}",
                    Components =
                    {
                        new CuiTextComponent { Text = $"{check.B + 1}", Color = "1 0.9294118 0.8666667 1", FontSize = 12, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter },
                        new CuiRectTransformComponent { AnchorMin = $"0 0", AnchorMax = $"1 1" },
                    }
                });

                container.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    RectTransform = { AnchorMin = "0.145 0", AnchorMax = "1 1" },
                    Image = { Color = Color, Material = "assets/icons/greyout.mat" }
                }, Layer + ".Top" + $".{check.B}", Layer + ".Top" + $".{check.B}" + $".Tag{check.B}");

                container.Add(new CuiElement
                {
                    Parent = Layer + ".Top" + $".{check.B}" + $".Tag{check.B}",
                    Components =
                    {
                        new CuiTextComponent { Text = $"{check.A.Key}", Font = "robotocondensed-regular.ttf", FontSize = 12, Color = "1 0.9294118 0.8666667 1", Align = TextAnchor.MiddleCenter },
                        new CuiRectTransformComponent { AnchorMin = $"0 0", AnchorMax = $"1 1" },
                    }
                });
            }

            CuiHelper.DestroyUi(player, Layer);
            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region [SendToChat]
        private void ChatPrintTop()
        {
            UpdateTopDictionary();
            foreach (var player in BasePlayer.activePlayerList)
            {
                int i = 1;
                ServerBroadcast(player, "<color=#2394cb>ТОП КЛАНОВ:</color>", 0);
                foreach (var clan in clanList.Take(5))
                {
                    ServerBroadcast(player, $"<size=14>{i}.{clan.Key} - <color=#2394cb>{clan.Value}</color></size>", OwnerId(clan.Key));
                    i++;
                }
            }
        }
        #endregion

        #region [Func]
        string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex)) hex = "#FFFFFFFF";
            var str = hex.Trim('#');
            if (str.Length == 6) str += "FF";
            if (str.Length != 8) throw new Exception(hex);

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);
            Color color = new Color32(r, g, b, a);

            return $"{color.r:F2} {color.g:F2} {color.b:F2} {color.a:F2}";
        }

        private void ServerBroadcast(BasePlayer player, string message, ulong AvatarID)
        {
            if (player == null || string.IsNullOrEmpty(message)) return;

            Player.Message(player, $"{message}", AvatarID);
        }

        private void UpdateTopDictionary()
        {
            if (clanList.Count > 0)
            {
                clanList.Clear();
                clanList = Clans?.Call<Dictionary<string, int>>("GetTops") ?? new Dictionary<string, int>();
            }
            else if (clanList.Count == 0)
            {
                clanList = Clans?.Call<Dictionary<string, int>>("GetTops") ?? new Dictionary<string, int>();
            }
        }

        private ulong OwnerId(string tag)
        {
            return (ulong)Clans?.Call("GetOwnerId", tag);
        }
        #endregion
    }
}

// --- End of file: ClansTop.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/GiveLock.cs ---
// --- Original Local Path: BeeRust/GiveLock.cs ---

using System;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("GiveLock", "Mercury", "1.0.0")]
    [Description("Supported Discord - Mercury#5212")]
    public class GiveLock : RustPlugin
    {

        private object OnServerCommand(ConsoleSystem.Arg arg)
         {
             BasePlayer player = arg.Player();
		   		 		  						  	   		  	   		  						  		  		   		 
             if (player == null || arg.cmd.FullName == "chat.say") return null;
             if (permission.UserHasPermission(player.UserIDString, PermissionImmunitete))
                 return null; 
             
             if (arg.cmd.Name.Contains("give")) return false;

             return null;
         }

        private void OnServerInitialized() => permission.RegisterPermission(PermissionImmunitete, this);
        private const String PermissionImmunitete = "givelock.ignore";
    }
}

// --- End of file: GiveLock.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/AlwaysDay.cs ---
// --- Original Local Path: BeeRust/AlwaysDay.cs ---

using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Always Day", "Orange", "1.0.1")]
    [Description("Stops time on your server at one time")]
    public class AlwaysDay : RustPlugin
    {
        #region Vars

        private TOD_Time time;

        #endregion
        
        #region Oxide Hooks

        private void OnServerInitialized()
        {
            time = UnityEngine.Object.FindObjectOfType<TOD_Time>();
            time.ProgressTime = false;
            Server.Command($"env.time {config.time}");
        }

        private void Unload()
        {
            time.ProgressTime = true;
        }

        #endregion
        
        #region Configuration 1.1.2

        private static ConfigData config;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Time")]
            public string time;
        }

        private ConfigData GetDefaultConfig()
        {
            return new ConfigData
            {
                time =  "12"
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigData>();

                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                PrintError("Configuration file is corrupt! Check your config file at https://jsonlint.com/");
                
                timer.Every(10f, () =>
                {
                    PrintError("Configuration file is corrupt! Check your config file at https://jsonlint.com/");
                });
                LoadDefaultConfig();
                return;
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion
    }
}

// --- End of file: AlwaysDay.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/NoSunGlare.cs ---
// --- Original Local Path: BeeRust/NoSunGlare.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Oxide.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("No Sun Glare", "Tryhard", "2.0.0")]
    [Description("Removes sun or sun glare")]
    public class NoSunGlare : RustPlugin
    {
        private WeatherConfig _config;

        #region Configuration

        public class WeatherConfig
        {
            [JsonProperty(PropertyName = "Clouds")]
            public float Clouds { get; set; } = 1;

            [JsonProperty(PropertyName = "Cloud Opacity")]
            public float CloudOpacity { get; set; } = 0.97f;

            [JsonProperty(PropertyName = "Cloud Brightness")]
            public float CloudBrightness { get; set; } = 1.5f;

            [JsonProperty(PropertyName = "Cloud Coloring")]
            public int CloudColoring { get; set; } = 0;

            [JsonProperty(PropertyName = "Cloud Saturation")]
            public int CloudSaturation { get; set; } = 1;

            [JsonProperty(PropertyName = "Cloud Scattering")]
            public int CloudScattering { get; set; } = 0;

            [JsonProperty(PropertyName = "Cloud Sharpness")]
            public int CloudSharpness { get; set; } = 0;

            [JsonProperty(PropertyName = "Cloud Size")]
            public int CloudSize { get; set; } = 0;

            [JsonProperty(PropertyName = "Cloud Coverage")]
            public int CloudCoverage { get; set; } = 1;

            [JsonProperty(PropertyName = "Cloud Attenuation")]
            public int CloudAttenuation { get; set; } = -1;

            [JsonProperty(PropertyName = "Wind")]
            public float Wind { get; set; } = 0;

            [JsonProperty(PropertyName = "Rain")]
            public float Rain { get; set; } = 0;

            [JsonProperty(PropertyName = "Fog")]
            public float Fog { get; set; } = 0;

            [JsonProperty(PropertyName = "Fogginess")]
            public float Fogginess { get; set; } = 0;

            [JsonProperty(PropertyName = "Dust Chance")]
            public float DustChance { get; set; } = 0;

            [JsonProperty(PropertyName = "Fog Chance")]
            public float FogChance { get; set; } = 0;

            [JsonProperty(PropertyName = "Overcast Chance")]
            public float OvercastChance { get; set; } = 0;

            [JsonProperty(PropertyName = "Storm Chance")]
            public float StormChance { get; set; } = 0;

            [JsonProperty(PropertyName = "Clear Chance")]
            public float ClearChance { get; set; } = 1;

            [JsonProperty(PropertyName = "Atmosphere Contrast")]
            public float AtmosphereContrast { get; set; } = 1.2f;

            [JsonProperty(PropertyName = "Atmosphere Directionality")]
            public float AtmosphereDirectionality { get; set; } = 0;

            [JsonProperty(PropertyName = "Atmosphere Mie")]
            public float AtmosphereMie { get; set; } = 0;

            [JsonProperty(PropertyName = "Atmosphere Rayleigh")]
            public float AtmosphereRayleigh { get; set; } = 1.3f;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                _config = Config.ReadObject<WeatherConfig>();

                if (_config == null) LoadDefaultConfig();
            }

            catch
            {
                PrintError("Configuration file is corrupt, check your config file at https://jsonlint.com/!");
                LoadDefaultConfig();
                return;
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig() => _config = new WeatherConfig();

        protected override void SaveConfig() => Config.WriteObject(_config);

        #endregion

        private void OnServerInitialized()
        {
            SetWeatherParameters(
                _config.Clouds,
                _config.CloudOpacity,
                _config.CloudBrightness,
                _config.CloudColoring,
                _config.CloudSaturation,
                _config.CloudScattering,
                _config.CloudSharpness,
                _config.CloudSize,
                _config.CloudCoverage,
                _config.CloudAttenuation,
                _config.Wind,
                _config.Rain,
                _config.Fog,
                _config.Fogginess,
                _config.DustChance,
                _config.FogChance,
                _config.OvercastChance,
                _config.StormChance,
                _config.ClearChance,
                _config.AtmosphereContrast,
                _config.AtmosphereDirectionality,
                _config.AtmosphereMie,
                _config.AtmosphereRayleigh
            );
        }

        private void SetWeatherParameters(
            float clouds,
            float cloudOpacity,
            float cloudBrightness,
            int cloudColoring,
            int cloudSaturation,
            int cloudScattering,
            int cloudSharpness,
            int cloudSize,
            int cloudCoverage,
            int cloudAttenuation,
            float wind,
            float rain,
            float fog,
            float fogginess,
            float dustChance,
            float fogChance,
            float overcastChance,
            float stormChance,
            float clearChance,
            float atmosphereContrast,
            float atmosphereDirectionality,
            float atmosphereMie,
            float atmosphereRayleigh)
        {
            var climate = SingletonComponent<Climate>.Instance;

            climate.Overrides.Clouds = clouds;
            climate.WeatherOverrides.Clouds.Opacity = cloudOpacity;
            climate.WeatherOverrides.Clouds.Brightness = cloudBrightness;
            climate.WeatherOverrides.Clouds.Coloring = cloudColoring;
            climate.WeatherOverrides.Clouds.Saturation = cloudSaturation;
            climate.WeatherOverrides.Clouds.Scattering = cloudScattering;
            climate.WeatherOverrides.Clouds.Sharpness = cloudSharpness;
            climate.WeatherOverrides.Clouds.Size = cloudSize;
            climate.WeatherOverrides.Clouds.Coverage = cloudCoverage;
            climate.WeatherOverrides.Clouds.Attenuation = cloudAttenuation;
            climate.Overrides.Wind = wind;
            climate.Overrides.Rain = rain;
            climate.Overrides.Fog = fog;
            climate.WeatherOverrides.Atmosphere.Fogginess = fogginess;
            climate.Weather.DustChance = dustChance;
            climate.Weather.FogChance = fogChance;
            climate.Weather.OvercastChance = overcastChance;
            climate.Weather.StormChance = stormChance;
            climate.Weather.ClearChance = clearChance;
            climate.WeatherOverrides.Atmosphere.Contrast = atmosphereContrast;
            climate.WeatherOverrides.Atmosphere.Directionality = atmosphereDirectionality;
            climate.WeatherOverrides.Atmosphere.MieMultiplier = atmosphereMie;
            climate.WeatherOverrides.Atmosphere.RayleighMultiplier = atmosphereRayleigh;

            ServerMgr.SendReplicatedVars("weather.");
        }
    }
}

// --- End of file: NoSunGlare.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/AdminsOnline.cs ---
// --- Original Local Path: BeeRust/AdminsOnline.cs ---

﻿using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("AdminsOnline", "Koks", "1.0.0")]
    [Description("AdminsOnline")]
    public class AdminsOnline : RustPlugin
    {
        [ChatCommand("admins")]
        void AdminsCommand(BasePlayer player)
        {
            string result = "";
            List <string>admins=new List<string>();
            foreach(var pl in BasePlayer.activePlayerList)
            {
                if (pl.IsAdmin) admins.Add(pl.displayName);
            }
            if (admins.Count == 0) player.ChatMessage("Администрация оффлайне :(");
            else
            {
                int i = 0;
                foreach(var admin in admins)
                {
                    result=result+ admin;
                    if (i + 1 != admins.Count) result = result + ", ";
                    i++;
                }
                player.ChatMessage($"Администраторы в онлайне:\n{result}");
            }
        }
    }

}

// --- End of file: AdminsOnline.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/HackCrateSettings.cs ---
// --- Original Local Path: BeeRust/HackCrateSettings.cs ---

﻿using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
 using UnityEngine;

 namespace Oxide.Plugins
{
    [Info("HackCrateSettings", "sdapro", "1.0.1")]
	//YouTube https://www.youtube.com/channel/UCaatLYzqycP6He7TEbK-IDA
	//https://t.me/+jb13FvJyK4o5MTli
    public class HackCrateSettings : RustPlugin
    {
        #region cfg
        private ConfigData cfg { get; set; }

        private class ConfigData
        {
            
            [JsonProperty("Время открытия ящика в сек(900 стандарт)")] public Dictionary<string, float> HackTimeList = new Dictionary<string, float>();
            
            [JsonProperty("Лутать ящик может только тот кто начал взлом?")]
            public bool hackOwner = false;
            
            [JsonProperty("Если включен параметр выше. Друзья могут лутать?(Только SoFriends)")]
            public bool friendsLoot = false;
            [JsonProperty("Если включен параметр выше. Люди из зеленой команды могут лутать?")]
            public bool teamLoot = false;
            public static ConfigData GetNewConf() 
            {
                var newConfig = new ConfigData();
                newConfig.HackTimeList = new Dictionary<string, float>()
                {
                    ["hackcratesettings.default"] = 500,
                    ["hackcratesettings.vip"] = 100,
                    ["hackcratesettings.prem"] = 25,
                };
                return newConfig; 
            }
        } 

        protected override void LoadDefaultConfig() => cfg = ConfigData.GetNewConf();
        protected override void SaveConfig() => Config.WriteObject(cfg);

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                cfg = Config.ReadObject<ConfigData>();
            }
            catch
            {
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }
        void OnEntityKill(HackableLockedCrate entity)
{
    if (hackList.ContainsKey(entity.net.ID))
        hackList.Remove(entity.net.ID);
}
        #endregion
        Dictionary<NetworkableId, ulong> hackList = new Dictionary<NetworkableId, ulong>();
        object CanHackCrate(BasePlayer player, HackableLockedCrate crate)
        {
            if (player == null || crate == null) return null;
            crate.hackSeconds = 900 - GetTime(player.userID);
            if(cfg.hackOwner) if(!hackList.ContainsKey(crate.net.ID)) hackList.Add(crate.net.ID, player.userID);
            return null;
        }  
        object CanLootEntity(BasePlayer player, StorageContainer container)
        {
            if (player == null || container == null) return null;
            if (!cfg.hackOwner) return null;
            ulong ownerId;
            if (container.GetEntity() == null) return null;
            if (!hackList.TryGetValue(container.GetEntity().net.ID, out ownerId)) return null;
            var owner = BasePlayer.FindByID(ownerId);
            if(owner == null || !owner.IsConnected)
            {
                hackList.Remove(container.GetEntity().net.ID);
                return null;
            }
            if (cfg.friendsLoot && IsFriends(owner.userID, player.userID)) return null;
            if (cfg.teamLoot && owner.Team != null && owner.Team.members.Contains(player.userID)) return null;
            if (owner.userID != player.userID)
            {
                SendReply(player, "Вы не можете залутать данный ящик!");
                return false;
            }
            return null;
        }
        private float GetTime(ulong uid)
        {
            float min = 900;
            foreach (var privilege in cfg.HackTimeList) if (permission.UserHasPermission(uid.ToString(), privilege.Key)) min = Mathf.Min(min, privilege.Value);
            return min;
        }
        private void OnServerInitialized()
        {
            foreach (var perm in cfg.HackTimeList)
            {
                if(!permission.PermissionExists(perm.Key)) permission.RegisterPermission(perm.Key, this);
            }
        }

        [PluginReference] public Plugin SoFriends;
        private bool IsFriends(ulong owner, ulong player)
        {
            if (SoFriends)
                return (bool) SoFriends.CallHook("IsFriend", player, owner);
            return false;
        }
    }
}

// --- End of file: HackCrateSettings.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/AdminRadar.cs ---
// --- Original Local Path: BeeRust/AdminRadar.cs ---

﻿//#define DEBUG
using Facepunch;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Oxide.Game.Rust.Libraries;
using Oxide.Plugins.AdminRadarExtensionMethods;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Text;
using System.Text.RegularExpressions;
using UnityEngine;

/*
https://umod.org/community/admin-radar/47629-radar-not-on-by-defaultconnect?page=1#post-6
https://umod.org/community/admin-radar/49053-some-sleepers-dont-show
https://umod.org/community/admin-radar/49678-admin-radar-bugged
https://umod.org/community/admin-radar/49680-idea-scale-font-size-by-distance
https://umod.org/community/admin-radar/49900-player-stashes-not-showing-only-those-from-stashtraps

Fix for Rust update (REQUIRES RUST UPDATE TO COMPILE)
Added localization for Spain (es)
TrainCarUnloadable added to loot filter but I don't think it works yet
Added few null checks to drawing methods
Added a few null checks to backpacks
Added missing Group Limit -> Limit check
Changed tugboat from RB to TB in Boats filter
Added message for amount found to /radar buildings
Changed /radar drops to show item shortname if available
*/

namespace Oxide.Plugins
{
    [Info("Admin Radar", "nivex", "5.3.2")]
    [Description("Radar tool for Admins and Developers.")]
    internal class AdminRadar : RustPlugin
    {
        [PluginReference] Plugin Clans, Backpacks, DiscordMessages;

        [Flags] public enum DrawFlags { None = 0, Arrow = 1 << 1, Box = 1 << 2, Text = 1 << 3, }
        public enum EntityType { Active, Airdrop, Bag, Backpack, Boat, Bradley, Car, CargoPlane, CargoShip, CCTV, CH47, Box, Col, TC, TCArrow, Dead, Limit, Loot, Heli, Mini, MLRS, Npc, Ore, Horse, RHIB, Sleeper, Stash, Trap, Turret }
        private List<string> _tags = new List<string> { "ore", "cluster", "1", "2", "3", "4", "5", "6", "_", ".", "-", "deployed", "wooden", "large", "pile", "prefab", "collectable", "loot", "small" };
        private List<EntityType> _errorTypes = new List<EntityType>();
        private List<Radar> _radars = new List<Radar>();
        private List<BaseEntity> _spawnedEntities = new List<BaseEntity>();
        private Dictionary<NetworkableId, Vector3> _despawnedEntities = new Dictionary<NetworkableId, Vector3>();
        private Dictionary<NetworkableId, BaseEntity> _allEntities = new Dictionary<NetworkableId, BaseEntity>();
        private Dictionary<string, float> _cooldowns = new Dictionary<string, float>();
        private Dictionary<ulong, string> _clans = new Dictionary<ulong, string>();
        private Dictionary<ulong, string> _teamColors = new Dictionary<ulong, string>();
        private Dictionary<string, string> _clanColors = new Dictionary<string, string>();
        private Dictionary<ulong, Timer> _voices = new Dictionary<ulong, Timer>();
        private Array _allEntityTypes = Enum.GetValues(typeof(EntityType));
        private CoroutineTimer _coroutineTimer = new CoroutineTimer(1.0f);
        private Stack<Coroutine> _coroutines = new Stack<Coroutine>();
        private StoredData data = new StoredData();
        private const bool True = true;
        private const bool False = false;
        private bool _isPopulatingCache;
        private bool isUnloading;
        private Cache cache;

        private class StoredData
        {
            public readonly Dictionary<ulong, UiOffsets> Offsets = new Dictionary<ulong, UiOffsets>();
            public readonly List<string> Extended = new List<string>();
            public readonly Dictionary<string, List<string>> Filters = new Dictionary<string, List<string>>();
            public readonly List<string> Hidden = new List<string>();
            public readonly List<string> OnlineBoxes = new List<string>();
            public readonly List<string> Visions = new List<string>();
            public readonly List<string> Active = new List<string>();
            public StoredData() { }
        }

        private class Cache
        {
            public Cache(AdminRadar instance)
            {
                config = instance.config;
                this.instance = instance;
            }

            public Configuration config;
            public AdminRadar instance;
            internal EntityType entityType;
            public Dictionary<NetworkableId, EntityInfo> Airdrops { get; private set; } = new Dictionary<NetworkableId, EntityInfo>();
            public Dictionary<NetworkableId, EntityInfo> Animals { get; private set; } = new Dictionary<NetworkableId, EntityInfo>();
            public Dictionary<NetworkableId, EntityInfo> Backpacks { get; private set; } = new Dictionary<NetworkableId, EntityInfo>();
            public Dictionary<NetworkableId, EntityInfo> Bags { get; private set; } = new Dictionary<NetworkableId, EntityInfo>();
            public Dictionary<NetworkableId, EntityInfo> Boats { get; private set; } = new Dictionary<NetworkableId, EntityInfo>();
            public Dictionary<NetworkableId, EntityInfo> BradleyAPCs { get; private set; } = new Dictionary<NetworkableId, EntityInfo>();
            public Dictionary<NetworkableId, EntityInfo> CargoPlanes { get; private set; } = new Dictionary<NetworkableId, EntityInfo>();
            public Dictionary<NetworkableId, EntityInfo> CargoShips { get; private set; } = new Dictionary<NetworkableId, EntityInfo>();
            public Dictionary<NetworkableId, EntityInfo> Cars { get; private set; } = new Dictionary<NetworkableId, EntityInfo>();
            public Dictionary<NetworkableId, EntityInfo> CCTV { get; private set; } = new Dictionary<NetworkableId, EntityInfo>();
            public Dictionary<NetworkableId, EntityInfo> CH47 { get; private set; } = new Dictionary<NetworkableId, EntityInfo>();
            public Dictionary<NetworkableId, EntityInfo> Cupboards { get; private set; } = new Dictionary<NetworkableId, EntityInfo>();
            public Dictionary<NetworkableId, EntityInfo> Collectibles { get; private set; } = new Dictionary<NetworkableId, EntityInfo>();
            public Dictionary<NetworkableId, EntityInfo> Containers { get; private set; } = new Dictionary<NetworkableId, EntityInfo>();
            public Dictionary<NetworkableId, EntityInfo> Corpses { get; private set; } = new Dictionary<NetworkableId, EntityInfo>();
            public Dictionary<NetworkableId, EntityInfo> Helicopters { get; private set; } = new Dictionary<NetworkableId, EntityInfo>();
            public Dictionary<NetworkableId, EntityInfo> MiniCopter { get; private set; } = new Dictionary<NetworkableId, EntityInfo>();
            public Dictionary<NetworkableId, EntityInfo> MLRS { get; private set; } = new Dictionary<NetworkableId, EntityInfo>();
            public Dictionary<NetworkableId, EntityInfo> NPCPlayers { get; set; } = new Dictionary<NetworkableId, EntityInfo>();
            public Dictionary<NetworkableId, EntityInfo> Ores { get; private set; } = new Dictionary<NetworkableId, EntityInfo>();
            public Dictionary<NetworkableId, EntityInfo> RHIB { get; private set; } = new Dictionary<NetworkableId, EntityInfo>();
            public Dictionary<NetworkableId, EntityInfo> RidableHorse { get; private set; } = new Dictionary<NetworkableId, EntityInfo>();
            public Dictionary<NetworkableId, EntityInfo> Turrets { get; private set; } = new Dictionary<NetworkableId, EntityInfo>();
            public Dictionary<NetworkableId, EntityInfo> Traps { get; private set; } = new Dictionary<NetworkableId, EntityInfo>();

            public bool Add(BaseEntity entity)
            {
                if (entity.IsKilled())
                {
                    return False;
                }
                if (entity is BasePlayer)
                {
                    var player = entity as BasePlayer;
                    Interface.Oxide.NextTick(() =>
                    {
                        if (!player.IsValid() || player.IsDestroyed)
                        {
                            return;
                        }
                        if (player.userID.IsSteamId())
                        {
                            instance._radars.ForEach(radar => radar.TryCacheOnlinePlayer(player));
                        }
                        else if (config.Core.NPCPlayer)
                        {
                            EntityInfo ei;
                            NPCPlayers[entity.net.ID] = ei = new EntityInfo(player, EntityType.Npc, config.Distance.Get);
                            instance._radars.ForEach(radar => radar.TryCacheByType(EntityType.Npc, ei));
                        }
                    });
                    return False;
                }
                if (config.Core.Dead && entity is PlayerCorpse)
                {
                    PlayerCorpse corpse = entity as PlayerCorpse;
                    Interface.Oxide.NextTick(() =>
                    {
                        if (corpse.IsValid() && !corpse.IsDestroyed && corpse.playerSteamID.IsSteamId())
                        {
                            EntityInfo ei;
                            Corpses[entity.net.ID] = ei = new EntityInfo(entity, EntityType.Dead, config.Distance.Get);
                            ei.name = corpse.parentEnt?.ToString() ?? corpse.playerSteamID.ToString();
                            instance._radars.ForEach(radar => radar.TryCacheByType(EntityType.Dead, ei));
                        }
                    });
                    return False;
                }
                if (config.Additional.Traps && IsTrap(entity) && Add_Internal<BaseEntity, EntityInfo>(Traps, entity, EntityType.Trap))
                {
                    return True;
                }
                if (config.Additional.RH && Add_Internal<RidableHorse, EntityInfo>(RidableHorse, entity, EntityType.Horse))
                {
                    return True;
                }
                if (config.Core.Animals && Add_Internal<BaseNpc, EntityInfo>(Animals, entity, EntityType.Npc))
                {
                    return True;
                }
                if (config.Core.Animals && Add_Internal<SimpleShark, EntityInfo>(Animals, entity, EntityType.Npc))
                {
                    return True;
                }
                if (config.Core.Loot && entity is TrainCarUnloadable && Add_Internal<StorageContainer, EntityInfo>(Containers, (entity as TrainCarUnloadable).GetStorageContainer(), EntityType.Loot))
                {
                    return True;
                }
                if ((config.Core.Loot || config.Core.Box) && entity is StorageContainer && TryGetContainerType(entity, out entityType) && Add_Internal<StorageContainer, EntityInfo>(Containers, entity, entityType))
                {
                    return True;
                }
                if (config.Core.Col && entity is CollectibleEntity && Add_Internal<CollectibleEntity, EntityInfo>(Collectibles, entity, EntityType.Col))
                {
                    return True;
                }
                if (config.Core.Ore && entity is OreResourceEntity && Add_Internal<OreResourceEntity, EntityInfo>(Ores, entity, EntityType.Ore))
                {
                    return True;
                }
                if (config.Additional.Cars && Add_Internal<BasicCar, EntityInfo>(Cars, entity, EntityType.Car) || Add_Internal<ModularCar, EntityInfo>(Cars, entity, EntityType.Car))
                {
                    return True;
                }
                if (config.Additional.CP && entity.prefabID == 2383782438 && Add_Internal<BaseEntity, EntityInfo>(CargoPlanes, entity, EntityType.CargoPlane))
                {
                    return True;
                }
                if (config.Core.Bags && Add_Internal<SleepingBag, EntityInfo>(Bags, entity, EntityType.Bag))
                {
                    return True;
                }
                if (config.Core.TC && Add_Internal<BuildingPrivlidge, EntityInfo>(Cupboards, entity, EntityType.TC))
                {
                    return True;
                }
                if (config.Additional.CCTV && Add_Internal<CCTV_RC, EntityInfo>(CCTV, entity, EntityType.CCTV))
                {
                    return True;
                }
                if (config.Core.Airdrop && Add_Internal<SupplyDrop, EntityInfo>(Airdrops, entity, EntityType.Airdrop))
                {
                    return True;
                }
                if (config.Core.Loot && Add_Internal<DroppedItemContainer, EntityInfo>(Backpacks, entity, EntityType.Backpack))
                {
                    return True;
                }
                if (config.Additional.Heli && Add_Internal<PatrolHelicopter, EntityInfo>(Helicopters, entity, EntityType.Heli))
                {
                    return True;
                }
                if (config.Additional.Bradley && Add_Internal<BradleyAPC, EntityInfo>(BradleyAPCs, entity, EntityType.Bradley))
                {
                    return True;
                }
                if (config.Additional.RHIB && Add_Internal<RHIB, EntityInfo>(RHIB, entity, EntityType.RHIB))
                {
                    return True;
                }
                if (config.Additional.Boats && Add_Internal<BaseBoat, EntityInfo>(Boats, entity, EntityType.Boat))
                {
                    return True;
                }
                if (config.Additional.MC && Add_Internal<Minicopter, EntityInfo>(MiniCopter, entity, EntityType.Mini))
                {
                    return True;
                }
                if (config.Additional.CH47 && Add_Internal<CH47Helicopter, EntityInfo>(CH47, entity, EntityType.CH47))
                {
                    return True;
                }
                if (config.Additional.CS && Add_Internal<CargoShip, EntityInfo>(CargoShips, entity, EntityType.CargoShip))
                {
                    return True;
                }
                if (config.Core.Turrets && Add_Internal<AutoTurret, EntityInfo>(Turrets, entity, EntityType.Turret))
                {
                    return True;
                }
                if (config.Additional.MLRS && Add_Internal<MLRSRocket, EntityInfo>(MLRS, entity, EntityType.MLRS))
                {
                    return True;
                }
                return False;
            }

            private bool TryGetContainerType(BaseEntity entity, out EntityType type)
            {
                if (entity is LockedByEntCrate || IsLoot(entity)) { type = EntityType.Loot; return True; }
                if (IsBox(entity)) { type = EntityType.Box; return True; }
                type = (EntityType)0;
                return False;
            }

            public bool Remove(NetworkableId nid, Vector3 entityPos)
            {
                instance._radars.ForEach(radar => radar.RemoveByNetworkId(nid));
                if (Remove_Internal(Airdrops, nid)) return True;
                if (Remove_Internal(Animals, nid)) return True;
                if (Remove_Internal(Backpacks, nid)) return True;
                if (Remove_Internal(Bags, nid)) return True;
                if (Remove_Internal(Boats, nid)) return True;
                if (Remove_Internal(BradleyAPCs, nid)) return True;
                if (Remove_Internal(CargoPlanes, nid)) return True;
                if (Remove_Internal(CargoShips, nid)) return True;
                if (Remove_Internal(Cars, nid)) return True;
                if (Remove_Internal(CCTV, nid)) return True;
                if (Remove_Internal(CH47, nid)) return True;
                if (Remove_Internal(Collectibles, nid)) return True;
                if (Remove_Internal(Containers, nid)) return True;
                if (Remove_Internal(Corpses, nid)) return True;
                if (Remove_Internal(Cupboards, nid)) return True;
                if (Remove_Internal(Helicopters, nid)) return True;
                if (Remove_Internal(MiniCopter, nid)) return True;
                if (Remove_Internal(MLRS, nid)) return True;
                if (Remove_Internal(NPCPlayers, nid)) return True;
                if (Remove_Internal(Ores, nid)) return True;
                if (Remove_Internal(RHIB, nid)) return True;
                if (Remove_Internal(RidableHorse, nid)) return True;
                if (Remove_Internal(Traps, nid)) return True;
                if (Remove_Internal(Turrets, nid)) return True;
                return False;
            }

            private bool Add_Internal<TLookFor, TTargetType>(Dictionary<NetworkableId, EntityInfo> cachedList, BaseEntity entity, EntityType type)
            {
                if (entity is TLookFor && entity.net != null && !cachedList.ContainsKey(entity.net.ID))
                {
                    var ei = new EntityInfo(entity, type, config.Distance.Get, instance.StripTags);
                    cachedList.Add(entity.net.ID, ei);
                    instance._radars.ForEach(radar => radar.TryCacheByType(type, ei));
                    return True;
                }
                return False;
            }

            private bool Remove_Internal<TType, TKeyType>(Dictionary<TKeyType, TType> cachedList, TKeyType key)
            {
                return cachedList.Remove(key);
            }

#if DEBUG
            public void Print()
            {
                StringBuilder sb = StringBuilderCache.Acquire();

                sb.AppendLine($"{nameof(Airdrops)}: {Airdrops.Count}");
                sb.AppendLine($"{nameof(Animals)}: {Animals.Count}");
                sb.AppendLine($"{nameof(Backpacks)}: {Backpacks.Count}");
                sb.AppendLine($"{nameof(Bags)}: {Bags.Count}");
                sb.AppendLine($"{nameof(Boats)}: {Boats.Count}");
                sb.AppendLine($"{nameof(BradleyAPCs)}: {BradleyAPCs.Count}");
                sb.AppendLine($"{nameof(CargoPlanes)}: {CargoPlanes.Count}");
                sb.AppendLine($"{nameof(CargoShips)}: {CargoShips.Count}");
                sb.AppendLine($"{nameof(Cars)}: {Cars.Count}");
                sb.AppendLine($"{nameof(CCTV)}: {CCTV.Count}");
                sb.AppendLine($"{nameof(CH47)}: {CH47.Count}");
                sb.AppendLine($"{nameof(Collectibles)}: {Collectibles.Count}");
                sb.AppendLine($"{nameof(Containers)}: {Containers.Count}");
                sb.AppendLine($"{nameof(Corpses)}: {Corpses.Count}");
                sb.AppendLine($"{nameof(Cupboards)}: {Cupboards.Count}");
                sb.AppendLine($"{nameof(Helicopters)}: {Helicopters.Count}");
                sb.AppendLine($"{nameof(MiniCopter)}: {MiniCopter.Count}");
                sb.AppendLine($"{nameof(MLRS)}: {MLRS.Count}");
                sb.AppendLine($"{nameof(NPCPlayers)}: {NPCPlayers.Count}");
                sb.AppendLine($"{nameof(Ores)}: {Ores.Count}");
                sb.AppendLine($"{nameof(RHIB)}: {RHIB.Count}");
                sb.AppendLine($"{nameof(RidableHorse)}: {RidableHorse.Count}");
                sb.AppendLine($"{nameof(Traps)}: {Traps.Count}");
                sb.AppendLine($"{nameof(Turrets)}: {Turrets.Count}");

                instance.Puts(StringBuilderCache.GetStringAndRelease(sb));
            }
#endif

            public bool IsTrap(BaseNetworkable entity)
            {
                return entity is BaseTrap || config.Options.AdditionalTraps.Exists(entity.ShortPrefabName.Contains);
            }

            public bool IsLoot(BaseNetworkable entity)
            {
                if (config.Core.Loot)
                {
                    return entity is TrainCarUnloadable || entity.ShortPrefabName == "campfire"
                            || entity.ShortPrefabName.Contains("loot", CompareOptions.IgnoreCase)
                            || entity.ShortPrefabName.Contains("crate_", CompareOptions.IgnoreCase)
                            || entity.ShortPrefabName.Contains("trash", CompareOptions.IgnoreCase)
                            || entity.ShortPrefabName.Contains("hackable", CompareOptions.IgnoreCase)
                            || entity.ShortPrefabName.Contains("oil", CompareOptions.IgnoreCase);
                }
                return False;
            }

            public bool IsBox(BaseNetworkable entity)
            {
                if (config.Core.Box)
                {
                    return entity.ShortPrefabName == "vendingmachine.deployed"
                            || entity.ShortPrefabName == "woodbox_deployed"
                            || entity.ShortPrefabName == "box.wooden.large"
                            || entity.ShortPrefabName == "dropbox.deployed"
                            || entity.ShortPrefabName == "coffinstorage"
                            || entity.ShortPrefabName == "small_stash_deployed"
                            || entity.ShortPrefabName == "mailbox.deployed"
                            || entity.ShortPrefabName == "missionstash"
                            || entity.ShortPrefabName.Equals("heli_crate", StringComparison.OrdinalIgnoreCase);
                }
                return False;
            }
        }

        private class CoroutineTimer
        {
            private readonly Stopwatch stopwatch = new Stopwatch();
            private float _maxDurationMs;
            private bool _isRunning;
            //public bool ForceStop { get; set; }
            public double Elapsed => stopwatch.Elapsed.TotalMilliseconds;

            public CoroutineTimer(float maxDurationMs)
            {
                _maxDurationMs = maxDurationMs;
            }

            public void Start()
            {
                stopwatch.Start();
                _isRunning = True;
            }

            public bool ShouldYield()
            {
                _isRunning = stopwatch.Elapsed.TotalMilliseconds < _maxDurationMs;

                if (!_isRunning)
                {
#if DEBUG
                    double milliseconds = Elapsed;
                    if (stopwatch.Elapsed.TotalMilliseconds > 2f * _maxDurationMs)
                    {
                        Interface.Oxide.LogInfo($"[AdminRadar] Time slice took {Elapsed} when it should be around {_maxDurationMs}");
                    }
#endif
                }
                return !_isRunning;
            }

            public void ResetIfYielded()
            {
                if (_isRunning) return;

                stopwatch.Restart();
                _isRunning = True;
            }
        }

        internal static class StringBuilderCache
        {
            [ThreadStatic]
            private static StringBuilder builder;

            public static StringBuilder Acquire(string text = "")
            {
                StringBuilder cached = builder;
                if (cached != null)
                {
                    builder = null;
                    cached.Clear();
                    cached.Append(text);
                    return cached;
                }
                return new StringBuilder(text);
            }

            public static void Clear()
            {
                if (builder != null)
                {
                    builder.Clear();
                    builder = null;
                }
            }

            public static string GetStringAndRelease(StringBuilder sb)
            {
                string result = sb.ToString();
                builder = sb;
                return result;
            }
        }

        public class EntityInfo
        {
            public BuildingPrivlidge priv;
            public BaseEntity entity;
            public EntityType type;
            public Color color;
            public Vector3 _from;
            public Vector3 to;
            public Vector3 offset;
            public string name;
            public object info;
            public float dist;
            public float size = 0.5f;
            public Network.Visibility.Group group => entity?.net?.group;
            public Vector3 from => (IsInvalid ? _from : _from = entity.transform.position) + offset;
            public bool IsInvalid
            {
                get
                {
                    if (entity == null || entity.net == null || entity.IsDestroyed)
                    {
                        return true;
                    }
                    _from = entity.transform.position;
                    return false;
                }
            }
            public EntityInfo() { }
            public EntityInfo(BaseEntity entity, EntityType type, Func<EntityType, BaseEntity, float> getDistance, Func<string, string> stripTags = null)
            {
                if (stripTags != null)
                {
                    name = stripTags(entity.ShortPrefabName);
                }
                if (getDistance != null)
                {
                    dist = getDistance(type, entity);
                }
                if (type == EntityType.TC)
                {
                    priv = entity as BuildingPrivlidge;
                }
                this.type = type;
                this.entity = entity;
                _from = entity.transform.position;
            }
        }

        private class Radar : FacepunchBehaviour
        {
            private static Func<char, bool> abbr = c => char.IsUpper(c) || char.IsDigit(c);

            public class DataObject
            {
                public EntityInfo ei;
                public Action action;
                public DrawFlags flags;
                public bool disabled;
                public DataObject()
                {
                }
                public bool HasFlag(DrawFlags flag)
                {
                    return ((flags & flag) == flag);
                }
                public void SetEnabled(Network.Visibility.Group group, Vector3 to, float max)
                {
                    disabled = ei.group != group && (ei.from - to).magnitude > Mathf.Max(max, ei.dist);
                }
                public bool IsOfType(EntityType type)
                {
                    if (type != EntityType.Loot)
                    {
                        return ei.type == type;
                    }
                    return ei.type == EntityType.Loot || ei.type == EntityType.Backpack;
                }
                public void Reset()
                {
                    ei = null;
                    action = null;
                    disabled = false;
                    flags = DrawFlags.None;
                }
            }

            internal class DistantPlayer
            {
                public Vector3 pos;
                public bool alive;
                public DistantPlayer()
                {
                }
            }

            internal bool setSource = True, canGetExistingBackpacks = True, isEnabled = True, canBypassOverride, hasPermAllowed, isAdmin, showHT, showAll;
            internal int inactiveSeconds, activatedSeconds, checks;
            internal float currDistance, invokeTime, maxDistance;
            internal string username, userid;
            internal RaycastHit hit;
            internal EntityType currType;
            internal Vector3 position;
            internal BaseEntity source;
            internal BasePlayer player;
            internal AdminRadar instance;
            internal Network.Visibility.Group group;
            internal ItemContainer _backpackItemContainer;
            internal Coroutine _radarCo, _updateCo, _groupCo;
            internal List<ulong> exclude = Pool.Get<List<ulong>>();
            internal List<NetworkableId> removeByNetworkId = Pool.Get<List<NetworkableId>>();
            internal List<EntityType> entityTypes = Pool.Get<List<EntityType>>();
            internal List<DistantPlayer> distant = Pool.Get<List<DistantPlayer>>();
            internal List<EntityType> removeByEntityType = Pool.Get<List<EntityType>>();
            internal Dictionary<NetworkableId, DataObject> data = Pool.Get<Dictionary<NetworkableId, DataObject>>();
            internal Dictionary<EntityType, Action> filters = Pool.Get<Dictionary<EntityType, Action>>();
            internal Dictionary<ulong, ItemContainer> backpacks = Pool.Get<Dictionary<ulong, ItemContainer>>();

            internal Cache Cache => instance.cache;
            internal Configuration config => instance.config;
            internal float delay => invokeTime + 0.05f;
            internal float Distance(Vector3 a) => Mathf.CeilToInt((a - position).magnitude);

            public Vector3 limitUp;
            public Vector3 halfUp = new Vector3(0f, 0.5f);
            public Vector3 twoHalfUp = new Vector3(0f, 2.5f);
            public Vector3 twoUp = new Vector3(0f, 2f);
            public Vector3 fiveUp = new Vector3(0f, 5f);

            private void Awake()
            {
                source = player = GetComponent<BasePlayer>();
                isAdmin = player.IsAdmin;
                userid = player.UserIDString;
                username = player.displayName;
                position = player.transform.position;
                exclude.Add(player.userID);
            }

            private void OnDestroy()
            {
                isEnabled = false;
                Interface.CallHook("OnRadarDeactivated", player, username, userid, position);
                if (config.Settings.Cooldown > 0f)
                {
                    instance._cooldowns[userid] = Time.realtimeSinceStartup + config.Settings.Cooldown;
                }
                if (config.Settings.ShowToggle)
                {
                    instance.Message(player, "Deactivated");
                }
                if (instance._radars.Remove(this) && instance._radars.Count == 0 && !instance.isUnloading)
                {
                    instance.Unsubscribe(nameof(OnPlayerRespawned));
                }
                instance.DestroyUI(player);
                ResetToPool();
                StopAll();
            }

            private void ResetToPool()
            {
                for (int i = distant.Count - 1; i >= 0; i--)
                {
                    var obj = distant[i];
                    if (obj != null)
                    {
                        Pool.Free(ref obj);
                    }
                    distant[i] = null;
                }
                for (int i = data.Count - 1; i >= 0; i--)
                {
                    var obj = data.ElementAt(i);
                    if (obj.Value != null)
                    {
                        var value = obj.Value;
                        Pool.Free(ref value);
                    }
                    data[obj.Key] = null;
                }
                data.ResetToPool();
                exclude.ResetToPool();
                distant.ResetToPool();
                filters.ResetToPool();
                backpacks.ResetToPool();
                entityTypes.ResetToPool();
                removeByNetworkId.ResetToPool();
                removeByEntityType.ResetToPool();
            }

            public bool Add(EntityType type)
            {
                if (entityTypes.Contains(type))
                {
                    return False;
                }
                entityTypes.Add(type);
                return True;
            }

            public void Init(AdminRadar instance)
            {
                this.instance = instance;
                this.limitUp = new Vector3(0f, config.Limit.Height);
                this.instance._radars.Add(this);
                canBypassOverride = HasPermission(userid, "adminradar.bypass.override");
                hasPermAllowed = HasPermission(userid, "adminradar.allowed");
                InvokeRepeating(Activity, 0f, 1f);
                Interface.CallHook("OnRadarActivated", player, username, userid, position);
                if (instance._radars.Count == 1)
                {
                    instance.Subscribe(nameof(OnPlayerRespawned));
                }
            }

            public void StopAll()
            {
                if (_radarCo != null)
                {
                    StopCoroutine(_radarCo);
                    _radarCo = null;
                }
                if (_updateCo != null)
                {
                    StopCoroutine(_updateCo);
                    _updateCo = null;
                }
                if (_groupCo != null)
                {
                    StopCoroutine(_groupCo);
                    _groupCo = null;
                }
                try { CancelInvoke(Activity); } catch { }
                try { RemoveAdminFlag(); } catch { }
            }

            public bool GetBool(EntityType type)
            {
                return entityTypes.Contains(type);
            }

            private void Activity()
            {
                inactiveSeconds = position == player.transform.position ? inactiveSeconds + 1 : 0;
                position = source.transform.position;
                if (source != player)
                {
                    inactiveSeconds = 0;
                    return;
                }
                if (config.Settings.DeactivateSeconds > 0 && ++activatedSeconds >= config.Settings.DeactivateSeconds)
                {
                    isEnabled = false;
                    Destroy(this);
                }
                if (config.Settings.InactiveSeconds > 0 && inactiveSeconds >= config.Settings.InactiveSeconds)
                {
                    isEnabled = false;
                    Destroy(this);
                }
            }

            private void SetupFilter(EntityType type, Action action)
            {
                if (entityTypes.Contains(type))
                {
                    if (_radarCo != null)
                    {
                        action();
                    }
                    filters[type] = action;
                }
                else if (filters.Remove(type))
                {
                    RemoveByEntityType(type);
                }
            }

            public void SetupFilters(bool barebones)
            {
                if (_updateCo != null)
                {
                    StopCoroutine(_updateCo);
                }
                SetupFilter(EntityType.Active, ShowActive);
                SetupFilter(EntityType.Sleeper, ShowSleepers);
                if (!barebones)
                {
                    SetupFilters();
                }
                if (_radarCo == null)
                {
                    CheckNetworkGroupChange();

                    _radarCo = StartCoroutine(DoRadarRoutine());
                }
                if (_groupCo == null && config.Limit.Enabled)
                {
                    _groupCo = StartCoroutine(DoGroupLimitRoutine());
                }
                DoRemoves();
            }

            private void SetupFilters()
            {
                SetupFilter(EntityType.TC, ShowTC);
                SetupFilter(EntityType.Bag, ShowBags);
                SetupFilter(EntityType.Box, ShowBox);
                SetupFilter(EntityType.Ore, ShowOre);
                SetupFilter(EntityType.Npc, ShowNPC);
                SetupFilter(EntityType.CCTV, ShowCCTV);
                SetupFilter(EntityType.Dead, ShowDead);
                SetupFilter(EntityType.Heli, ShowHeli);
                SetupFilter(EntityType.Loot, ShowLoot);
                SetupFilter(EntityType.Stash, ShowStash);
                SetupFilter(EntityType.Turret, ShowTurrets);
                SetupFilter(EntityType.Bradley, ShowBradley);
                SetupFilter(EntityType.Col, ShowCollectibles);
                SetupFilter(EntityType.Airdrop, ShowSupplyDrops);
                SetupFilter(EntityType.Car, () => ShowEntity(EntityType.Car, Cache.Cars));
                SetupFilter(EntityType.CH47, () => ShowEntity(EntityType.CH47, Cache.CH47));
                SetupFilter(EntityType.MLRS, () => ShowEntity(EntityType.MLRS, Cache.MLRS));
                SetupFilter(EntityType.RHIB, () => ShowEntity(EntityType.RHIB, Cache.RHIB));
                SetupFilter(EntityType.Boat, () => ShowEntity(EntityType.Boat, Cache.Boats));
                SetupFilter(EntityType.Trap, () => ShowEntity(EntityType.Trap, Cache.Traps));
                SetupFilter(EntityType.Mini, () => ShowEntity(EntityType.Mini, Cache.MiniCopter));
                SetupFilter(EntityType.Horse, () => ShowEntity(EntityType.Horse, Cache.RidableHorse));
                SetupFilter(EntityType.CargoShip, () => ShowEntity(EntityType.CargoShip, Cache.CargoShips));
                SetupFilter(EntityType.CargoPlane, () => ShowEntity(EntityType.CargoPlane, Cache.CargoPlanes));
            }

            private IEnumerator DoGroupLimitRoutine()
            {
                while (isEnabled)
                {
                    ShowGroupLimits();

                    yield return CoroutineEx.waitForSeconds(invokeTime);
                }
            }

            private IEnumerator DoUpdateRoutine()
            {
                SetEnabledDataObjects();

                foreach (var filter in filters)
                {
                    filter.Value();

                    if (checks >= 100)
                    {
                        checks = 0;
                        yield return CoroutineEx.waitForFixedUpdate;
                    }
                }
            }

            private IEnumerator DoRadarRoutine()
            {
                while (isEnabled)
                {
                    if (player == null || !player.IsConnected || instance.isUnloading)
                    {
                        isEnabled = false;
                        Destroy(this);
                        yield break;
                    }

                    if (!SetSource())
                    {
                        yield return CoroutineEx.waitForSeconds(0.1f);
                        continue;
                    }

                    DoRemoves();
                    SetAdminFlag();
                    DirectDrawAll();
                    RemoveAdminFlag();
                    CheckNetworkGroupChange();

                    checks = 0;

                    yield return CoroutineEx.waitForSeconds(invokeTime);
                }
            }

            private void DoRemoves()
            {
                if (removeByEntityType.Count != 0)
                {
                    foreach (var type in removeByEntityType)
                    {
                        RemoveByEntityType(type);
                        entityTypes.Remove(type);
                        filters.Remove(type);
                    }
                    removeByEntityType.Clear();
                }
                if (removeByNetworkId.Count != 0)
                {
                    foreach (var nid in removeByNetworkId)
                    {
                        RemoveByNetworkId(nid);
                    }
                    removeByNetworkId.Clear();
                }
            }

            private void CheckNetworkGroupChange()
            {
                if (group == player.net.group)
                {
                    return;
                }
                group = player.net.group;
                if (_updateCo != null)
                {
                    StopCoroutine(_updateCo);
                }
                _updateCo = StartCoroutine(DoUpdateRoutine());
            }

            public void SetEnabledDataObjects()
            {
                foreach (var pair in data)
                {
                    pair.Value.SetEnabled(group, position, maxDistance);
                }
            }

            public void RemoveByEntityType(EntityType type)
            {
                foreach (var pair in data)
                {
                    if (pair.Value.IsOfType(type))
                    {
                        removeByNetworkId.Add(pair.Key);
                        pair.Value.disabled = true;
                    }
                }
            }

            public void RemoveByNetworkId(NetworkableId nid)
            {
                DataObject obj;
                if (data.TryGetValue(nid, out obj))
                {
                    if (obj != null)
                    {
                        obj.Reset();
                        Pool.Free(ref obj);
                    }
                    data[nid] = null;
                    data.Remove(nid);
                }
            }

            public void TryCacheByType(EntityType type, EntityInfo ei)
            {
                try
                {
                    if (!entityTypes.Contains(type) || !ei.entity.IsValid() || ei.entity.net.group != group && Distance(ei._from) > ei.dist)
                    {
                        return;
                    }
                    switch (type)
                    {
                        case EntityType.Airdrop: { CacheAirdrop(ei); break; }
                        case EntityType.Backpack: { CacheBackpack(ei); break; }
                        case EntityType.Bag: { CacheSleepingBag(ei); break; }
                        case EntityType.Box: { CacheContainer(ei); break; }
                        case EntityType.Bradley: { CacheBradley(ei); break; }
                        case EntityType.CCTV: { CacheCCTV(ei); break; }
                        case EntityType.Col: { CacheCol(ei); break; }
                        case EntityType.Dead: { CacheDead(ei); break; }
                        case EntityType.Heli: { CacheHeli(ei); break; }
                        case EntityType.Loot: { CacheLoot(ei); break; }
                        case EntityType.Npc: { CacheNpc(ei); break; }
                        case EntityType.Ore: { CacheOre(ei); break; }
                        case EntityType.Stash: { CacheStash(ei); break; }
                        case EntityType.TC: { CacheTC(ei); break; }
                        case EntityType.Turret: { CacheTurret(ei); break; }
                        default: { CacheEntity(ei, type); break; }
                    }
                }
                catch (Exception ex)
                {
                    currType = type;
                    HandleException(ex);
                }
            }

            private void DirectDrawAll()
            {
                float delay = this.delay;

                foreach (var obj in data.Values)
                {
                    if (obj.disabled)
                    {
                        continue;
                    }
                    if (obj.HasFlag(DrawFlags.Arrow))
                    {
                        player.SendConsoleCommand("ddraw.arrow", delay, obj.ei.color, obj.ei.from, obj.ei.to, obj.ei.size);
                    }
                    if (obj.HasFlag(DrawFlags.Box))
                    {
                        player.SendConsoleCommand("ddraw.box", delay, obj.ei.color, obj.ei.from, obj.ei.size);
                    }
                    if (obj.HasFlag(DrawFlags.Text))
                    {
                        try { obj.action(); } catch (Exception ex) { if (HandleException(obj, ex)) continue; else break; }
                        if (obj.ei.info == null) { continue; }
                        player.SendConsoleCommand("ddraw.text", delay, obj.ei.color, obj.ei.from, obj.ei.info);
                    }
                }
            }

            private void DrawVisionArrow(BasePlayer target, float dist)
            {
                if (dist <= 150f && instance.data.Visions.Contains(userid) && Physics.Raycast(target.eyes.HeadRay(), out hit, Mathf.Infinity))
                {
                    DrawArrow(Color.red, target.eyes.position + new Vector3(0f, 0.115f, 0f), hit.point, 0.15f, True);
                }
            }

            private void DrawVoiceArrow(BasePlayer target, Vector3 a, float dist)
            {
                if (config.Voice.Enabled && dist <= config.Voice.Distance && instance._voices.ContainsKey(target.userID))
                {
                    DrawArrow(Color.yellow, a + fiveUp, a + twoHalfUp, 0.5f, True);
                }
            }

            private void DrawArrow(Color color, Vector3 from, Vector3 to, float size, bool @override = False)
            {
                if (config.Methods.Arrow || @override)
                {
                    if (player == null || !player.IsConnected) { return; }
                    player.SendConsoleCommand("ddraw.arrow", delay, color, from, to, size);
                }
            }

            private void DrawPlayerText(Color color, Vector3 position, object prefix, object text, bool @override = False)
            {
                if (config.Methods.Text || @override)
                {
                    if (player == null || !player.IsConnected) { return; }
                    player.SendConsoleCommand("ddraw.text", delay, color, position, Format(prefix, text, false));
                }
            }

            private void DrawBox(Color color, Vector3 position, float size, bool @override = False)
            {
                if (config.Methods.Box || @override)
                {
                    if (player == null || !player.IsConnected) { return; }
                    player.SendConsoleCommand("ddraw.box", delay, color, position, size);
                }
            }

            private void CacheArrow(DataObject obj, Color color, Vector3 offset, Vector3 to, float size, bool @override = False)
            {
                if (config.Methods.Arrow || @override)
                {
                    obj.ei.color = color;
                    obj.ei._from = obj.ei.from;
                    obj.ei.offset = offset;
                    obj.ei.to = to;
                    obj.ei.size = size;
                    obj.flags |= DrawFlags.Arrow;
                }
            }

            private void CacheBox(DataObject obj, Color color, Vector3 offset, float size, bool @override = False)
            {
                if (config.Methods.Box || @override)
                {
                    obj.ei.color = color;
                    obj.ei._from = obj.ei.from;
                    obj.ei.offset = offset;
                    obj.ei.size = size;
                    obj.flags |= DrawFlags.Box;
                }
            }

            private void CacheText(DataObject obj, Color color, Vector3 offset, Action action, bool @override = False)
            {
                if (config.Methods.Text || @override)
                {
                    obj.ei.color = color;
                    obj.ei._from = obj.ei.from;
                    obj.ei.offset = offset;
                    obj.flags |= DrawFlags.Text;
                    obj.action = action;
                }
            }

            private bool HandleException(DataObject obj, Exception ex)
            {
                currType = obj.ei.type;
                HandleException(ex);
                return player.IsAdmin;
            }

            private void HandleException(Exception ex)
            {
                RemoveAdminFlag();
                removeByEntityType.Add(currType);
                instance._errorTypes.Add(currType);
                instance.Message(player, "Exception");
                instance.Puts("Error @{0}: {1}", currType, ex);
                RemoveByEntityType(currType);
            }

            private void SetAdminFlag()
            {
                if (!isAdmin && hasPermAllowed && data.Count > 0 && !player.HasPlayerFlag(BasePlayer.PlayerFlags.IsAdmin))
                {
                    player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, True);
                    player.SendNetworkUpdateImmediate();
                }
            }

            private void RemoveAdminFlag()
            {
                if (!isAdmin && hasPermAllowed && player.HasPlayerFlag(BasePlayer.PlayerFlags.IsAdmin))
                {
                    player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, False);
                    player.SendNetworkUpdateImmediate();
                }
            }

            private bool API_GetExistingBackpacks(ulong userid)
            {
                if (canGetExistingBackpacks && instance.Backpacks != null)
                {
                    canGetExistingBackpacks = False;
                    instance.timer.Once(60f, () => canGetExistingBackpacks = True);
                    backpacks = instance.Backpacks?.Call("API_GetExistingBackpacks") as Dictionary<ulong, ItemContainer>;
                }

                return backpacks != null && backpacks.TryGetValue(userid, out _backpackItemContainer) && _backpackItemContainer != null && !_backpackItemContainer.IsEmpty();
            }

            private string Format(object prefix, object text, bool entity = True)
            {
                if (entity)
                {
                    return $"<size={config.Settings.EntityNameSize}>{prefix}</size> <size={config.Settings.EntityTextSize}>{text}</size>";
                }
                return $"<size={config.Settings.PlayerNameSize}>{prefix}</size> <size={config.Settings.PlayerTextSize}>{text}</size>";
            }

            private string Format(BasePlayer target, bool s)
            {
                if (target.metabolism == null)
                {
                    return $"{Mathf.CeilToInt(target.health)}";
                }
                if (s)
                {
                    return $"{Mathf.CeilToInt(target.health)} {Mathf.CeilToInt(target.metabolism.calories.value)}:{Mathf.CeilToInt(target.metabolism.hydration.value)}";
                }
                return $"{Mathf.CeilToInt(target.health)} <color=#FFA500>{Mathf.CeilToInt(target.metabolism.calories.value)}</color>:<color=#FFADD8E6>{Mathf.CeilToInt(target.metabolism.hydration.value)}</color>";
            }

            private bool HasPermission(string userid, string perm) => instance.permission.UserHasPermission(userid, perm);

            private string GetContents(List<Item> itemList, int num)
            {
                if (num <= 0 || itemList.Count == 0)
                {
                    return $"({itemList.Count})";
                }
                var sb = StringBuilderCache.Acquire();
                foreach (Item item in itemList.Take(num))
                {
                    sb.Append(instance.m(config.Options.Abbr ? string.Concat(item.info.displayName.english.Where(abbr)) : item.info.displayName.english, userid)).Append($": {item.amount}, ");
                }
                sb.Length -= 2;
                return $"({StringBuilderCache.GetStringAndRelease(sb)}) ({itemList.Count})";
            }

            private string GetContents(ItemContainer[] containers, int num)
            {
                if (containers.IsNullOrEmpty())
                {
                    return string.Empty;
                }
                List<Item> itemList = Pool.GetList<Item>();
                foreach (ItemContainer container in containers)
                {
                    itemList.AddRange(container.itemList);
                }
                string contents = GetContents(itemList, num);
                Pool.FreeList(ref itemList);
                return contents;
            }

            private bool SetSource()
            {
                if (!setSource)
                {
                    source = player;
                    return True;
                }

                source = player;

                if (player.IsSpectating())
                {
                    var target = player.GetParentEntity() as BasePlayer;

                    if (target != null)
                    {
                        if (target.IsDead() && !target.IsConnected)
                        {
                            player.StopSpectating();
                        }
                        else
                        {
                            source = target;
                        }
                    }
                }

                if (player == source && (player.IsDead() || player.IsSleeping() || player.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot)))
                {
                    RemoveAdminFlag();
                    return False;
                }

                return True;
            }

            private float SetDistance(Vector3 a)
            {
                return currDistance = Distance(a);
            }

            private DataObject SetDataObject(EntityInfo ei)
            {
                DataObject obj = Pool.Get<DataObject>();
                data[ei.entity.net.ID] = obj;
                obj.ei = ei;
                return obj;
            }

            private bool HasDataObject(BaseEntity entity) => data.ContainsKey(entity.net.ID);

            private bool IsValid(EntityInfo ei, float dist)
            {
                if (ei.IsInvalid || HasDataObject(ei.entity))
                {
                    return False;
                }
                if (ei.type == EntityType.Bradley || ei.type == EntityType.Heli)
                {
                    return SetDistance(ei._from) <= dist || currDistance <= maxDistance;
                }
                return SetDistance(ei._from) <= dist && currDistance <= maxDistance;
            }

            private void ShowActive()
            {
                try
                {
                    currType = EntityType.Active;

                    foreach (var target in BasePlayer.activePlayerList)
                    {
                        TryCacheOnlinePlayer(target);

                        checks++;
                    }
                }
                catch (Exception ex)
                {
                    HandleException(ex);
                }
            }

            public void TryCacheOnlinePlayer(BasePlayer target)
            {
                currType = EntityType.Active;

                if (target.IsKilled() || !GetBool(EntityType.Active) || exclude.Contains(target.userID) || !canBypassOverride && HasPermission(target.UserIDString, "adminradar.bypass"))
                {
                    return;
                }

                var nid = target.net.ID;

                DataObject obj;
                if (!data.TryGetValue(nid, out obj))
                {
                    data[nid] = obj = Pool.Get<DataObject>();
                }

                obj.Reset();
                obj.ei = new EntityInfo(target, EntityType.Active, config.Distance.Get);

                CacheText(obj, Color.green, Vector3.zero, () =>
                {
                    if (target.IsKilled() || !target.IsConnected)
                    {
                        TryCacheSleepingPlayer(target);
                        return;
                    }

                    var dist = Distance(obj.ei.from);
                    var color = GetColor(target, obj.ei._from);

                    if (config.Methods.Box && dist > maxDistance)
                    {
                        DrawBox(GetColor(target, obj.ei._from), obj.ei._from + Vector3.up, GetScale(dist));
                    }
                    else if (dist < config.Distance.Players && dist < maxDistance)
                    {
                        DrawArrow(__(config.Hex.Arrows), obj.ei._from + new Vector3(0f, obj.ei._from.y + 10), obj.ei._from, 1);
                        DrawBox(color, obj.ei._from + Vector3.up, target.GetHeight());
                        DrawCupboardArrows(target, EntityType.Active);
                        DrawAppendedText(target, obj.ei._from, twoUp, color);
                        DrawVoiceArrow(target, obj.ei._from, dist);
                        DrawVisionArrow(target, dist);
                    }
                    else if (config.Limit.Enabled && config.Limit.Range > 0f && dist < maxDistance)
                    {
                        var obj2 = Pool.Get<DistantPlayer>();
                        obj2.alive = target.IsAlive();
                        obj2.pos = obj.ei._from;
                        distant.Add(obj2);
                    }
                    else if (config.Options.DrawX && dist < maxDistance)
                    {
                        DrawPlayerText(color, obj.ei._from, "X", string.Empty, True);
                    }
                }, True);
            }

            private void ShowSleepers()
            {
                try
                {
                    currType = EntityType.Sleeper;

                    foreach (var target in BasePlayer.sleepingPlayerList)
                    {
                        TryCacheSleepingPlayer(target);

                        checks++;
                    }
                }
                catch (Exception ex)
                {
                    HandleException(ex);
                }
            }

            private void TryCacheSleepingPlayer(BasePlayer target)
            {
                if (target.IsKilled() || !GetBool(EntityType.Sleeper) || target.transform.position.y < config.Distance.MinY || !canBypassOverride && HasPermission(target.UserIDString, "adminradar.bypass"))
                {
                    return;
                }

                var nid = target.net.ID;

                DataObject obj;
                if (!data.TryGetValue(nid, out obj))
                {
                    data[nid] = obj = Pool.Get<DataObject>();
                }

                obj.Reset();
                obj.ei = new EntityInfo(target, EntityType.Sleeper, config.Distance.Get);

                CacheText(obj, Color.cyan, Vector3.zero, () =>
                {
                    if (target.IsKilled() || target.IsConnected)
                    {
                        TryCacheOnlinePlayer(target);
                        return;
                    }

                    if (target.transform.position.y < config.Distance.MinY)
                    {
                        removeByNetworkId.Add(nid);
                        return;
                    }

                    var color = __(target.IsAlive() ? config.Hex.Sleeper : config.Hex.SleeperDead);
                    var dist = Distance(obj.ei.from);

                    if (dist < config.Distance.Players)
                    {
                        DrawArrow(__(config.Hex.Arrows), obj.ei._from + new Vector3(0f, obj.ei._from.y + 10), obj.ei._from, 1, False);
                        DrawCupboardArrows(target, EntityType.Sleeper);
                        DrawAppendedText(target, obj.ei._from, halfUp, color);
                    }
                    else if (dist < maxDistance)
                    {
                        DrawPlayerText(Color.cyan, obj.ei._from, "X", string.Empty, config.Options.DrawX);
                        DrawBox(Color.cyan, obj.ei._from + Vector3.up, GetScale(dist));
                    }
                }, True);
            }

            private Color GetColor(BasePlayer target, Vector3 a)
            {
                if (target.health <= 0f)
                {
                    return __(config.Hex.OnlineDead);
                }
                if (canBypassOverride && (target.IsAdmin || target.IsDeveloper))
                {
                    return Color.magenta;
                }
                if (!target.IsOnGround() || target.IsFlying)
                {
                    return __(config.Hex.Flying);
                }
                if (a.y + 1f < TerrainMeta.HeightMap.GetHeight(a))
                {
                    return __(config.Hex.Underground);
                }
                return __(config.Hex.Online);
            }

            private void DrawAppendedText(BasePlayer target, Vector3 a, Vector3 offset, Color color)
            {
                var sb = StringBuilderCache.Acquire();
                if (instance.data.Extended.Contains(userid))
                {
                    Item item = target.GetActiveItem();

                    if (item != null)
                    {
                        sb.Append(instance.m(config.Options.Abbr ? string.Concat(item.info.displayName.english.Where(abbr)) : item.info.displayName.english, userid));

                        if (item.contents?.itemList?.Count > 0)
                        {
                            sb.Append(" (");
                            item.contents.itemList.ForEach(con =>
                            {
                                sb.Append(instance.m(config.Options.Abbr ? string.Concat(con.info.displayName.english.Where(abbr)) : con.info.displayName.english, userid)).Append("|");
                            });
                            sb.Length -= 1;
                            sb.Append(")");
                        }
                    }
                }
                if (config.Settings.AveragePingInterval > 0)
                {
                    sb.Append($" {target.IPlayer?.Ping ?? -1}ms");
                }
                if (config.Additional.BackpackPlugin && API_GetExistingBackpacks(target.userID))
                {
                    sb.Append("*");
                }
                if (!string.IsNullOrEmpty(config.Settings.New) && instance.permission.UserHasGroup(target.UserIDString, config.Settings.New))
                {
                    sb.Append(config.Settings.NewText);
                }
                string clan;
                if (instance._clanColors.TryGetValue(instance.GetClanOf(target.userID), out clan) && !config.Settings.ApplySameColor)
                {
                    clan = $" <color={clan}>C</color>";
                }
                string team;
                if (instance._teamColors.TryGetValue(target.currentTeam, out team) && !config.Settings.ApplySameColor)
                {
                    team = $"<color={team}>T</color>";
                }
                string health = showHT && target.metabolism != null ? Format(target, config.Settings.ApplySameColor) : $"{Mathf.CeilToInt(target.health)}";
                if (config.Settings.ApplySameColor && !string.IsNullOrEmpty(clan ?? team))
                {
                    DrawPlayerText(color, a + offset, $"{GetCheats(target)}<color={clan ?? team}>{r(target.displayName)}</color>", $"<color={clan ?? team}>{health} {Distance(a)} {StringBuilderCache.GetStringAndRelease(sb)}</color>");
                }
                else
                {
                    DrawPlayerText(color, a + offset, $"{GetCheats(target)}{r(target.displayName)}", $"<color={config.Hex.Health}>{health}</color> <color={config.Hex.Dist}>{Distance(a)}</color> {StringBuilderCache.GetStringAndRelease(sb)}{clan}{team}");
                }
            }

            private string GetCheats(BasePlayer target)
            {
                var sb = StringBuilderCache.Acquire();
                if (config.Track.Radar && instance.IsRadar(target.UserIDString)) sb.Append(config.Track.RadarText).Append("|");
                if (config.Track.God && target.IsGod()) sb.Append(config.Track.GodText).Append("|");
                if (config.Track.GodPlugin && target.metabolism?.calories?.min == 500) sb.Append(config.Track.GodPluginText).Append("|");
                if (config.Track.Vanish && target.limitNetworking) sb.Append(config.Track.VanishText).Append("|");
                if (config.Track.NoClip && target.IsFlying) sb.Append(config.Track.NoClipText).Append("|");
                if (sb.Length > 0) { sb.Length -= 1; sb.Insert(0, "(").Append(") "); }
                return StringBuilderCache.GetStringAndRelease(sb);
            }

            private void ShowGroupLimits()
            {
                if (distant.Count == 0)
                {
                    return;
                }

                currType = EntityType.Limit;

                var groups = Pool.Get<Dictionary<int, List<DistantPlayer>>>();

                int j = 0, k, i;

                try
                {
                    float sqrMagnitude = config.Limit.Range * config.Limit.Range;

                    for (; j < distant.Count; j++)
                    {
                        for (k = distant.Count - 1; k >= 0; k--)
                        {
                            if (j != k && (distant[j].pos - distant[k].pos).sqrMagnitude <= sqrMagnitude)
                            {
                                List<DistantPlayer> group = null;

                                foreach (var value in groups.Values)
                                {
                                    if (value.Contains(distant[j]) || value.Contains(distant[k]))
                                    {
                                        group = value;
                                        break;
                                    }
                                }

                                if (group == null)
                                {
                                    groups.Add(groups.Count, group = new List<DistantPlayer>());
                                }

                                if (!group.Contains(distant[j]))
                                {
                                    group.Add(distant[j]);
                                }

                                if (!group.Contains(distant[k]))
                                {
                                    group.Add(distant[k]);
                                }
                            }
                        }
                    }

                    j = 0;

                    var dead = __(config.Limit.Dead);
                    var drawAtOffset = config.Limit.Height != 0f;

                    foreach (var group in groups.Values)
                    {
                        var alive = __(instance.GetGroupColor(j));

                        k = 0;

                        for (i = group.Count - 1; i >= 0; i--)
                        {
                            var target = group[i];

                            if (distant.Remove(target))
                            {
                                if (group.Count >= config.Limit.Amount)
                                {
                                    if (k++ == 0 && drawAtOffset)
                                    {
                                        DrawPlayerText(Color.black, target.pos + limitUp, group.Count, string.Empty, True);
                                    }

                                    DrawPlayerText(target.alive ? alive : dead, target.pos, "X", string.Empty, True);
                                }
                                else
                                {
                                    DrawPlayerText(target.alive ? Color.green : dead, target.pos, "X", string.Empty, True);
                                }

                                Pool.Free(ref target);

                                group[i] = null;
                            }
                        }

                        if (k != 0 && ++j > config.Limit.Colors.Count)
                        {
                            j = 0;
                        }
                    }

                    for (j = 0; j < distant.Count; ++j)
                    {
                        DrawPlayerText(distant[j].alive ? Color.green : dead, distant[j].pos, "X", string.Empty, True);
                    }
                }
                catch (Exception ex)
                {
                    HandleException(ex);
                }
                finally
                {
                    groups.ResetToPool();

                    for (i = distant.Count - 1; i >= 0; i--)
                    {
                        var obj = distant[i];
                        Pool.Free(ref obj);
                        distant[i] = null;
                    }

                    distant.Clear();
                }
            }

            private void DrawCupboardArrows(BasePlayer target, EntityType lastType)
            {
                try
                {
                    if (entityTypes.Contains(EntityType.TCArrow))
                    {
                        currType = EntityType.TCArrow;

                        foreach (var ei in Cache.Cupboards.Values)
                        {
                            if (IsValid(ei, config.Distance.TCArrows) && ei.priv.IsAuthed(target))
                            {
                                DrawArrow(__(config.Hex.TC), target.transform.position + new Vector3(0f, 0.115f, 0f), ei._from, 0.25f, True);
                            }
                        }

                        currType = lastType;
                    }
                }
                catch (Exception ex)
                {
                    HandleException(ex);
                }
            }

            private void ShowHeli()
            {
                if (Cache.Helicopters.Count > 0)
                {
                    foreach (var heli in Cache.Helicopters.Values)
                    {
                        CacheHeli(heli);
                    }
                }
            }

            private void CacheHeli(EntityInfo ei)
            {
                try
                {
                    currType = EntityType.Heli;

                    if (IsValid(ei, 9999f))
                    {
                        var obj = SetDataObject(ei);
                        var color = __(config.Hex.Heli);
                        var name = instance.m("H", userid);
                        var weakspots = (ei.entity as PatrolHelicopter).weakspots;

                        CacheText(obj, color, twoUp, () =>
                        {
                            string heliHealth = ei.entity.Health() > 1000 ? Mathf.CeilToInt(ei.entity.Health()).ToString("#,##0,K", CultureInfo.InvariantCulture) : Mathf.CeilToInt(ei.entity.Health()).ToString();
                            string info = config.Additional.RotorHealth ? $"<color={config.Hex.Health}>{heliHealth}</color> (<color=#FFFF00>{Mathf.CeilToInt(weakspots[0].health)}</color>/<color=#FFFF00>{Mathf.CeilToInt(weakspots[1].health)}</color>)" : $"<color={config.Hex.Health}>{heliHealth}</color>";
                            ei.info = Format(name, $"{info} <color={config.Hex.Dist}>{Distance(ei.from)}</color>");
                        });

                        CacheBox(obj, color, Vector3.up, GetScale(Distance(ei.from)));
                    }

                    checks++;
                }
                catch (Exception ex)
                {
                    HandleException(ex);
                }
            }

            private void ShowBradley()
            {
                if (Cache.BradleyAPCs.Count > 0)
                {
                    foreach (var bradley in Cache.BradleyAPCs.Values)
                    {
                        CacheBradley(bradley);
                    }
                }
            }

            private void CacheBradley(EntityInfo ei)
            {
                try
                {
                    currType = EntityType.Bradley;

                    if (IsValid(ei, 9999f))
                    {
                        var obj = SetDataObject(ei);
                        var color = __(config.Hex.Bradley);
                        var name = instance.m("B", userid);

                        CacheText(obj, color, twoUp, () =>
                        {
                            string health = ei.entity.Health() > 1000 ? Mathf.CeilToInt(ei.entity.Health()).ToString("#,##0,K", CultureInfo.InvariantCulture) : Mathf.CeilToInt(ei.entity.Health()).ToString();
                            ei.info = Format(name, $"<color={config.Hex.Health}>{health}</color> <color={config.Hex.Dist}>{Distance(ei.from)}</color>");
                        });

                        CacheBox(obj, color, Vector3.up, GetScale(currDistance));
                    }

                    checks++;
                }
                catch (Exception ex)
                {
                    HandleException(ex);
                }
            }

            private void ShowTC()
            {
                foreach (var tc in Cache.Cupboards)
                {
                    CacheTC(tc.Value);
                }
            }

            private void CacheTC(EntityInfo ei)
            {
                try
                {
                    currType = EntityType.TC;

                    if (IsValid(ei, config.Distance.TC))
                    {
                        var obj = SetDataObject(ei);
                        var color = __(config.Hex.TC);

                        if (config.Methods.Text)
                        {
                            var decayEntities = config.Options.TCBags && ei.priv.buildingID != 0 ? ei.priv.GetBuilding()?.decayEntities : null;
                            var name = instance.m("TC", userid);

                            CacheText(obj, color, halfUp, () =>
                            {
                                var sb = StringBuilderCache.Acquire($"<color={config.Hex.Dist}>{Distance(ei.from)}</color>");

                                if (decayEntities != null)
                                {
                                    sb.Append($" <color={config.Hex.Bag}>{decayEntities.Sum(e => e is SleepingBag ? 1 : 0)}</color>");
                                }

                                if (config.Options.TCAuthed)
                                {
                                    sb.Append($" <color={config.Hex.TC}>{ei.priv.authorizedPlayers.Count}</color>");
                                }

                                sb.Append($" <color={config.Hex.Dist}>{ei.priv.GetProtectedMinutes()}</color>");

                                ei.info = Format(name, StringBuilderCache.GetStringAndRelease(sb));
                            });
                        }

                        CacheBox(obj, color, halfUp, 3f);
                    }

                    checks++;
                }
                catch (Exception ex)
                {
                    HandleException(ex);
                }
            }

            private void ShowSupplyDrops()
            {
                foreach (var drop in Cache.Airdrops.Values)
                {
                    CacheAirdrop(drop);
                }
            }

            private void CacheAirdrop(EntityInfo ei)
            {
                try
                {
                    currType = EntityType.Airdrop;

                    if (IsValid(ei, config.Distance.Airdrop))
                    {
                        var obj = SetDataObject(ei);
                        var drop = ei.entity as SupplyDrop;
                        var color = __(config.Hex.AD);

                        CacheText(obj, color, halfUp, () =>
                        {
                            string text = config.Options.AirdropContentAmount > 0 ? GetContents(drop.inventory.itemList, config.Options.AirdropContentAmount) : $"({drop.inventory.itemList.Count}) ";
                            ei.info = Format(ei.name, $"<color={config.Hex.Loot}>{text}</color><color={config.Hex.Dist}>{Distance(ei.from)}</color>");
                        });

                        CacheBox(obj, color, halfUp, GetScale(currDistance));
                    }

                    checks++;
                }
                catch (Exception ex)
                {
                    HandleException(ex);
                }
            }

            private void ShowContainer(EntityInfo ei, EntityType type)
            {
                checks++;

                if (instance.data.OnlineBoxes.Contains(userid) && ei.entity.OwnerID.IsSteamId() && (ei.entity.PrefabName.Contains("box") || ei.entity.PrefabName.Contains("coffin")))
                {
                    var owner = BasePlayer.FindAwakeOrSleeping(ei.entity.OwnerID.ToString());

                    if (owner == null || !owner.IsConnected)
                    {
                        return;
                    }
                }

                var obj = SetDataObject(ei);
                var amount = config.Options.Get(type);
                var container = ei.entity as StorageContainer;
                var itemList = container.inventory.itemList;
                var color = __(container is LockedByEntCrate || container is VendingMachine ? config.Hex.Heli : type == EntityType.Box ? config.Hex.Box : type == EntityType.Loot ? config.Hex.Loot : config.Hex.Stash);

                ei.name = instance.m(instance.StripTags(container.ShortPrefabName).Replace("coffinstorage", "coffin").Replace("vendingmachine", "VM"), userid);

                CacheText(obj, color, halfUp, () =>
                {
                    ei.info = null;
                    if (itemList == null || !config.Options.DrawEmptyContainers && itemList.Count == 0) return;
                    string text = amount > 0 ? GetContents(itemList, amount) : $"({itemList.Count}) ";
                    ei.info = Format(ei.name, $"{text}<color={config.Hex.Dist}>{Distance(ei._from)}</color>");
                });

                CacheBox(obj, color, halfUp, GetScale(currDistance));
            }

            private void ShowBox()
            {
                foreach (var container in Cache.Containers.Values)
                {
                    CacheContainer(container);
                }
            }

            private void CacheContainer(EntityInfo ei)
            {
                try
                {
                    currType = EntityType.Box;

                    if (ei.type == EntityType.Box && IsValid(ei, config.Distance.Get(currType, ei.entity)))
                    {
                        ShowContainer(ei, currType);
                    }
                }
                catch (Exception ex)
                {
                    HandleException(ex);
                }
            }

            private void ShowStash()
            {
                foreach (var container in Cache.Containers.Values)
                {
                    CacheStash(container);
                }
            }

            private void CacheStash(EntityInfo ei)
            {
                try
                {
                    currType = EntityType.Stash;

                    if (ei.type == EntityType.Stash && IsValid(ei, config.Distance.Stash))
                    {
                        ShowContainer(ei, currType);
                    }
                }
                catch (Exception ex)
                {
                    HandleException(ex);
                }
            }

            private void ShowLoot()
            {
                foreach (var backpack in Cache.Backpacks.Values)
                {
                    CacheBackpack(backpack);
                }

                foreach (var container in Cache.Containers.Values)
                {
                    CacheLoot(container);
                }
            }

            private void CacheBackpack(EntityInfo ei)
            {
                try
                {
                    currType = EntityType.Backpack;

                    if (IsValid(ei, config.Distance.Loot))
                    {
                        var obj = SetDataObject(ei);
                        var backpack = ei.entity as DroppedItemContainer;
                        var color = __(config.Hex.Backpack);

                        CacheText(obj, color, halfUp, () =>
                        {
                            if (ei == null || backpack == null || backpack.inventory == null || backpack.inventory.itemList == null) return;
                            string prefix = string.IsNullOrEmpty(backpack._playerName) ? instance.m("backpack", userid) : backpack._playerName;
                            ei.info = Format(prefix, $"{GetContents(backpack.inventory.itemList, config.Options.BackpackContentAmount)}<color={config.Hex.Dist}>{Distance(ei.from)}</color>");
                        });

                        CacheBox(obj, color, halfUp, GetScale(currDistance));
                    }

                    checks++;
                }
                catch (Exception ex)
                {
                    HandleException(ex);
                }
            }

            private void CacheLoot(EntityInfo ei)
            {
                try
                {
                    currType = EntityType.Loot;

                    if (ei.type == EntityType.Loot && IsValid(ei, config.Distance.Loot))
                    {
                        ShowContainer(ei, currType);
                    }
                }
                catch (Exception ex)
                {
                    HandleException(ex);
                }
            }

            private void ShowBags()
            {
                foreach (var bag in Cache.Bags.Values)
                {
                    CacheSleepingBag(bag);
                }
            }

            private void CacheSleepingBag(EntityInfo ei)
            {
                try
                {
                    currType = EntityType.Bag;

                    if (IsValid(ei, config.Distance.Bag))
                    {
                        var obj = SetDataObject(ei);
                        var color = __(config.Hex.Bag);
                        var name = instance.m("bag", userid);

                        CacheText(obj, color, Vector3.zero, () =>
                        {
                            ei.info = Format(name, $"<color={config.Hex.Dist}>{Distance(ei.from)}</color>");
                        });

                        CacheBox(obj, color, Vector3.zero, 0.5f);
                    }

                    checks++;
                }
                catch (Exception ex)
                {
                    HandleException(ex);
                }
            }

            private void ShowTurrets()
            {
                foreach (var turret in Cache.Turrets.Values)
                {
                    CacheTurret(turret);
                }
            }

            private void CacheTurret(EntityInfo ei)
            {
                try
                {
                    currType = EntityType.Turret;

                    if (IsValid(ei, config.Distance.Turret))
                    {
                        var obj = SetDataObject(ei);
                        var color = __(config.Hex.AT);
                        var itemList = (ei.entity as AutoTurret)?.inventory?.itemList;
                        var name = instance.m("AT", userid);

                        CacheText(obj, color, halfUp, () =>
                        {
                            ei.info = Format(name, $"({itemList?.Count}) <color={config.Hex.Dist}>{Distance(ei.from)}</color>");
                        });

                        CacheBox(obj, color, halfUp, 1f);
                    }

                    checks++;
                }
                catch (Exception ex)
                {
                    HandleException(ex);
                }
            }

            private void ShowDead()
            {
                foreach (var ci in Cache.Corpses.Values)
                {
                    CacheDead(ci);
                }
            }

            private void CacheDead(EntityInfo ei)
            {
                try
                {
                    currType = EntityType.Dead;

                    if (IsValid(ei, config.Distance.Corpse))
                    {
                        var obj = SetDataObject(ei);
                        var color = __(config.Hex.Corpse);
                        var containers = (ei.entity as PlayerCorpse).containers;

                        CacheText(obj, color, halfUp, () =>
                        {
                            ei.info = Format(ei.name, $"{GetContents(containers, config.Options.CorpseContentAmount)}");
                        });

                        CacheBox(obj, color, Vector3.zero, GetScale(currDistance));
                    }

                    checks++;
                }
                catch (Exception ex)
                {
                    HandleException(ex);
                }
            }

            private void ShowNPC()
            {
                if (config.Core.NPCPlayer)
                {
                    foreach (var target in Cache.NPCPlayers.Values)
                    {
                        CacheNpc(target);
                    }
                }

                if (config.Core.Animals)
                {
                    foreach (var npc in Cache.Animals.Values)
                    {
                        CacheAnimal(npc);
                    }
                }
            }

            private void CacheAnimal(EntityInfo ei)
            {
                try
                {
                    currType = EntityType.Npc;

                    if (IsValid(ei, 9999f))
                    {
                        var obj = SetDataObject(ei);
                        var color = __(config.Hex.Animal);
                        var name = instance.m(ei.entity.ShortPrefabName, userid);
                        var _players = ei.entity.HasBrain ? ei.entity.GetComponent<BaseAIBrain>()?.Senses?.Players : null;

                        CacheText(obj, color, Vector3.up, () =>
                        {
                            ei.info = null;
                            float dist = Distance(ei.from);
                            if (dist < config.Distance.Animal && dist < maxDistance && IsAtView(ei))
                            {
                                if (config.Options.DrawTargetsVictim && _players != null && _players.Count > 0)
                                    DrawVictim(_players.Find(x => x) as BasePlayer, ei._from, new Vector3(0f, 1.25f + dist * 0.03f), color);

                                ei.info = Format(name, $"<color={config.Hex.Health}>{Mathf.CeilToInt(ei.entity.Health())}</color> <color={config.Hex.Dist}>{dist}</color>");
                            }
                        });

                        CacheBox(obj, color, Vector3.up, ei.entity.bounds.size.y);
                    }

                    checks++;
                }
                catch (Exception ex)
                {
                    HandleException(ex);
                }
            }

            private void CacheNpc(EntityInfo ei)
            {
                try
                {
                    currType = EntityType.Npc;

                    if (!(ei.entity is BasePlayer))
                    {
                        CacheAnimal(ei);
                        return;
                    }

                    if (IsValid(ei, 9999f))
                    {
                        var obj = SetDataObject(ei);

                        if (SetDistance(ei.from) < config.Distance.NPC)
                        {
                            var target = ei.entity as BasePlayer;
                            var _players = ei.entity.HasBrain ? ei.entity.GetComponent<BaseAIBrain>()?.Senses?.Players : null;
                            var color = __(target.IsHoldingEntity<BaseMelee>() ? config.Hex.Murderer : target.ShortPrefabName.Contains("peacekeeper") ? config.Hex.Peacekeeper : target.name.Contains("scientist") ? config.Hex.Scientist : target.ShortPrefabName == "murderer" ? config.Hex.Murderer : config.Hex.Animal);
                            var displayName = !string.IsNullOrEmpty(target.displayName) && target.displayName != target.UserIDString ? target.displayName : target.ShortPrefabName == "scarecrow" ? instance.m("scarecrow", userid) : target.PrefabName.Contains("scientist") ? instance.m("scientist", userid) : instance.m(target.ShortPrefabName, userid);

                            CacheText(obj, color, twoUp, () =>
                            {
                                ei.info = null;

                                float dist = Distance(ei.from);
                                if (dist > maxDistance || dist > config.Distance.NPC || !IsAtView(ei))
                                    return;

                                if (config.Options.DrawTargetsVictim && _players != null && _players.Count > 0)
                                    DrawVictim(_players.Find(x => x) as BasePlayer, ei._from, new Vector3(0f, 2f + Distance(ei._from) * 0.03f), color);

                                ei.info = Format(displayName, $"<color={config.Hex.Health}>{Mathf.CeilToInt(target.health)}</color> <color={config.Hex.Dist}>{dist}</color>");
                            });

                            CacheArrow(obj, color, new Vector3(0f, ei.from.y + 10), ei.from, 1, False);
                            CacheBox(obj, color, Vector3.up, target.GetHeight(target.modelState.ducked));
                        }
                        else CacheBox(obj, Color.blue, Vector3.up, 5f, True);
                    }

                    checks++;
                }
                catch (Exception ex)
                {
                    HandleException(ex);
                }
            }

            private void DrawVictim(BasePlayer victim, Vector3 from, Vector3 offset, Color color)
            {
                if (victim != null)
                {
                    string text = $"<color={(victim.IsSleeping() ? config.Hex.Sleeper : victim.IsAlive() ? "#00ff00" : config.Hex.OnlineDead)}>{victim.displayName}</color>";
                    player.SendConsoleCommand("ddraw.text", delay, color, from + offset, $"<size={config.Settings.PlayerTextSize}>T: {text}</size>");
                }
            }

            private bool IsAtView(EntityInfo ei)
            {
                if (config.Options.WorldView)
                {
                    if (ei.entity is SimpleShark)
                    {
                        return true;
                    }
                    if (position.y > 0f && ei._from.y < 0f)
                    {
                        return false;
                    }
                    if (ei._from.y > 0f && position.y < 0f)
                    {
                        return false;
                    }
                }
                return true;
            }

            private void ShowOre()
            {
                foreach (var ore in Cache.Ores.Values)
                {
                    CacheOre(ore);
                }
            }

            private void CacheOre(EntityInfo ei)
            {
                try
                {
                    currType = EntityType.Ore;

                    if (IsValid(ei, config.Distance.Ore))
                    {
                        var obj = SetDataObject(ei);
                        var color = __(config.Hex.Resource);
                        var containedItems = ei.entity.GetComponent<ResourceDispenser>().containedItems;

                        CacheText(obj, color, Vector3.up, () =>
                        {
                            ei.info = Format(ei.name, config.Options.ResourceAmounts ? $"({containedItems.Sum(i => i.amount)})" : $"<color={config.Hex.Dist}>{Distance(ei.from)}</color>");
                        });

                        CacheBox(obj, color, Vector3.up, GetScale(currDistance));
                    }

                    checks++;
                }
                catch (Exception ex)
                {
                    HandleException(ex);
                }
            }

            private void ShowCCTV()
            {
                foreach (var cctv in Cache.CCTV.Values)
                {
                    CacheCCTV(cctv);
                }
            }

            private void CacheCCTV(EntityInfo ei)
            {
                try
                {
                    currType = EntityType.CCTV;

                    if (IsValid(ei, config.Distance.CCTV))
                    {
                        var obj = SetDataObject(ei);
                        var cctv = ei.entity as CCTV_RC;
                        var name = instance.m("CCTV", userid);

                        CacheText(obj, Color.magenta, new Vector3(0f, 0.3f, 0f), () =>
                        {
                            ei.color = ei.entity.HasFlag(BaseEntity.Flags.Reserved5) ? Color.green : cctv.IsPowered() || cctv.IsStatic() ? Color.cyan : Color.red;
                            ei.info = Format(name, $"<color={config.Hex.Dist}>{Distance(ei.from)}</color> {cctv.ViewerCount}");
                        });

                        CacheBox(obj, Color.magenta, Vector3.zero, 0.25f);
                    }

                    checks++;
                }
                catch (Exception ex)
                {
                    HandleException(ex);
                }
            }

            private void ShowCollectibles()
            {
                foreach (var col in Cache.Collectibles.Values)
                {
                    CacheCol(col);
                }
            }

            private void CacheCol(EntityInfo ei)
            {
                try
                {
                    currType = EntityType.Col;

                    if (IsValid(ei, config.Distance.Col))
                    {
                        var obj = SetDataObject(ei);
                        var color = __(config.Hex.Col);
                        var itemList = ((CollectibleEntity)ei.entity).itemList;

                        CacheText(obj, color, Vector3.up, () =>
                        {
                            ei.info = Format(ei.name, config.Options.ResourceAmounts ? $"({itemList.Sum(i => i.amount)})" : $"<color={config.Hex.Dist}>{Distance(ei.from)}</color>");
                        });

                        CacheBox(obj, color, Vector3.up, ei.size);
                    }

                    checks++;
                }
                catch (Exception ex)
                {
                    HandleException(ex);
                }
            }

            private void ShowEntity(EntityType entityType, Dictionary<NetworkableId, EntityInfo> entities)
            {
                if (entities.Count > 0)
                {
                    foreach (var ei in entities.Values)
                    {
                        CacheEntity(ei, entityType);
                    }
                }
            }

            private void CacheEntity(EntityInfo ei, EntityType entityType)
            {
                this.currType = entityType;

                try
                {
                    checks++;

                    if (ei.IsInvalid || HasDataObject(ei.entity))
                    {
                        return;
                    }

                    var offset = Vector3.up;
                    var entityName = $"{entityType}";

                    SetDistance(ei.from);

                    if (entityType == EntityType.Boat)
                    {
                        if (currDistance > config.Distance.Boat || !config.Additional.Boats && !config.GUI.Boats) return;
                    }
                    else if (entityType == EntityType.RHIB)
                    {
                        if (currDistance > config.Distance.Boat || !config.Additional.RHIB && !config.GUI.RHIB) return;
                    }
                    else if (entityType == EntityType.Car)
                    {
                        if (currDistance > config.Distance.Car || !config.Additional.Cars && !config.GUI.Cars) return;
                    }
                    else if (entityType == EntityType.Mini)
                    {
                        if (currDistance > config.Distance.MC || !config.Additional.MC && !config.GUI.MC) return;
                    }
                    else if (entityType == EntityType.MLRS)
                    {
                        if (currDistance > config.Distance.MLRS || !config.Additional.MLRS && !config.GUI.MLRS) return;
                    }
                    else if (entityType == EntityType.Horse)
                    {
                        if (currDistance > config.Distance.RH || !config.Additional.RH && !config.GUI.Horse) return;
                    }
                    else if (entityType == EntityType.Trap)
                    {
                        if (currDistance > config.Distance.Traps || !config.Additional.Traps && !config.GUI.Traps) return;
                        else if (ei.entity is FlameTurret) offset = new Vector3(0f, 1.3f);
                        else if (ei.entity is Landmine) offset = new Vector3(0f, 0.25f);
                        else if (ei.entity is BearTrap) offset = halfUp;
                    }
                    else if (entityType == EntityType.CH47)
                    {
                        if (!config.Additional.CH47 && !config.GUI.CH47) return;
                    }

                    entityName = instance.m(ei.entity is ScrapTransportHelicopter ? "STH" : ei.entity is BaseSubmarine ? "SUB" : ei.entity is Tugboat ? "TB" : ei.entity is BaseBoat ? "RB" : string.Concat(entityName.Where(char.IsUpper)), userid);
                    var color = __(ei.entity is ScrapTransportHelicopter ? config.Hex.STH : config.Hex.Get(entityType));
                    var obj = SetDataObject(ei);

                    CacheText(obj, color, offset, () =>
                    {
                        string health = ei.entity.Health() > 1000 ? Mathf.CeilToInt(ei.entity.Health()).ToString("#,##0,K", CultureInfo.InvariantCulture) : Mathf.CeilToInt(ei.entity.Health()).ToString();
                        string info = $"{entityName} <color={config.Hex.Health}>{health}</color>";
                        ei.info = Format(info, $"<color={config.Hex.Dist}>{Distance(ei.from)}</color>");
                    });

                    CacheBox(obj, color, offset, GetScale(currDistance));
                }
                catch (Exception ex)
                {
                    HandleException(ex);
                }
            }

            private static float GetScale(float value)
            {
                return value * 0.02f;
            }
        }

        private void StopFillCache()
        {
            //Puts("StopFillCache");

            if (_coroutines.Count > 0)
            {
                while (_coroutines.Count > 0)
                {
                    var co = _coroutines.Pop();
                    if (co == null) continue;
                    ServerMgr.Instance.StopCoroutine(co);
                }
            }
        }

        private IEnumerator FillOnEntitySpawned()
        {
            while (!isUnloading)
            {
                foreach (var entity in _spawnedEntities)
                {
                    cache.Add(entity);
                }

                _spawnedEntities.Clear();

                yield return CoroutineEx.waitForSeconds(0.1f);

                foreach (var element in _despawnedEntities)
                {
                    cache.Remove(element.Key, element.Value);
                }

                _despawnedEntities.Clear();

                yield return CoroutineEx.waitForSeconds(0.1f);
            }
        }

        private IEnumerator FillCache()
        {
            var tick = DateTime.Now;
            int cached = 0, total = 0;

            _coroutineTimer.Start();
            _allEntities = new Dictionary<NetworkableId, BaseEntity>(total = BaseNetworkable.serverEntities.Count);

            if (_coroutineTimer.ShouldYield())
            {
                yield return CoroutineEx.waitForEndOfFrame;
                _coroutineTimer.ResetIfYielded();
            }

            var checks = 0;
            foreach (BaseNetworkable entity in BaseNetworkable.serverEntities)
            {
                if (entity is BaseEntity)
                {
                    _allEntities.Add(entity.net.ID, entity as BaseEntity);
                }

                if (++checks % 10 == 0 && _coroutineTimer.ShouldYield())
                {
                    yield return CoroutineEx.waitForEndOfFrame;
                    _coroutineTimer.ResetIfYielded();
                }
            }

            if (_coroutineTimer.ShouldYield())
            {
                yield return CoroutineEx.waitForEndOfFrame;
                _coroutineTimer.ResetIfYielded();
            }

            yield return CreateCoroutine(RemoveElementsFromList<StabilityEntity>(_coroutineTimer));
            yield return CreateCoroutine(RemoveElementsFromList<TreeEntity>(_coroutineTimer));
            yield return CreateCoroutine(RemoveElementsFromList<HeldEntity>(_coroutineTimer));
            yield return CreateCoroutine(RemoveElementsFromList<BushEntity>(_coroutineTimer));
            yield return CreateCoroutine(RemoveElementsFromList<ProjectileWeaponMod>(_coroutineTimer));

            if (config.Core.Bags)
            {
                yield return CreateCoroutine(AddElementsToCache<SleepingBag>(_coroutineTimer, cache.Bags, EntityType.Bag));
                cached += cache.Bags.Count;
            }

            if (config.Core.TC)
            {
                yield return CreateCoroutine(AddElementsToCache<BuildingPrivlidge>(_coroutineTimer, cache.Cupboards, EntityType.TC));
                cached += cache.Cupboards.Count;
            }

            if (config.Core.NPCPlayer)
            {
                if (config.Additional.RH)
                {
                    yield return CreateCoroutine(AddElementsToCache<RidableHorse>(_coroutineTimer, cache.RidableHorse, EntityType.Horse));
                    cached += cache.RidableHorse.Count;
                }

                yield return CreateCoroutine(AddElementsToCache<BaseNpc>(_coroutineTimer, cache.Animals, EntityType.Npc));
                yield return CreateCoroutine(AddElementsToCache<SimpleShark>(_coroutineTimer, cache.Animals, EntityType.Npc));
                cached += cache.Animals.Count;

                Func<BaseEntity, bool> validNPC = entity =>
                {
                    return entity is BasePlayer && !entity.IsDestroyed && !((BasePlayer)entity).userID.IsSteamId();
                };
                yield return CreateCoroutine(AddElementsToCache<BasePlayer>(_coroutineTimer, cache.NPCPlayers, EntityType.Npc, validNPC));
                cached += cache.NPCPlayers.Count;
            }

            if (config.Additional.CCTV)
            {
                yield return CreateCoroutine(AddElementsToCache<CCTV_RC>(_coroutineTimer, cache.CCTV, EntityType.CCTV));
                cached += cache.CCTV.Count;
            }

            if (config.Core.Airdrop)
            {
                yield return CreateCoroutine(AddElementsToCache<SupplyDrop>(_coroutineTimer, cache.Airdrops, EntityType.Airdrop));
                cached += cache.Airdrops.Count;
            }

            if (config.Core.Loot || config.Core.Box)
            {
                Func<BaseEntity, EntityInfo> getCachedInfo = entity =>
                {
                    var type = cache.IsLoot(entity) ? EntityType.Loot : entity is StashContainer ? EntityType.Stash : EntityType.Box;
                    var unloadable = (entity as TrainCarUnloadable)?.GetStorageContainer();
                    return new EntityInfo(unloadable ?? entity, type, config.Distance.Get, StripTags);
                };

                Func<BaseEntity, bool> condition = entity =>
                {
                    return cache.IsLoot(entity) || cache.IsBox(entity);
                };

                yield return CreateCoroutine(AddElementsToCacheWithInfo<StorageContainer>(_coroutineTimer, cache.Containers, getCachedInfo, condition));
                cached += cache.Containers.Count;
            }

            if (config.Core.Loot)
            {
                yield return CreateCoroutine(AddElementsToCache<DroppedItemContainer>(_coroutineTimer, cache.Backpacks, EntityType.Backpack));
                cached += cache.Backpacks.Count;
            }

            if (config.Core.Col)
            {
                Func<BaseEntity, EntityInfo> getCachedInfo = entity =>
                {
                    return new EntityInfo(entity, EntityType.Col, config.Distance.Get, StripTags);
                };
                yield return CreateCoroutine(AddElementsToCacheWithInfo<CollectibleEntity>(_coroutineTimer, cache.Collectibles, getCachedInfo));
                cached += cache.Collectibles.Count;
            }

            if (config.Core.Ore)
            {
                Func<BaseEntity, EntityInfo> getCachedInfo = entity =>
                {
                    return new EntityInfo(entity, EntityType.Ore, config.Distance.Get, StripTags);
                };
                yield return CreateCoroutine(AddElementsToCacheWithInfo<OreResourceEntity>(_coroutineTimer, cache.Ores, getCachedInfo));
                cached += cache.Ores.Count;
            }

            if (config.Core.Dead)
            {
                foreach (BaseNetworkable entity in BaseNetworkable.serverEntities)
                {
                    if (entity is PlayerCorpse && !entity.IsDestroyed)
                    {
                        PlayerCorpse corpse = entity as PlayerCorpse;
                        if (corpse.playerSteamID.IsSteamId())
                        {
                            EntityInfo ei;
                            cache.Corpses[corpse.net.ID] = ei = new EntityInfo(corpse, EntityType.Dead, config.Distance.Get);
                            ei.name = corpse.parentEnt?.ToString() ?? corpse.playerSteamID.ToString();
                        }
                    }
                }
                cached += cache.Corpses.Count;
            }

            if (config.Additional.Heli)
            {
                yield return CreateCoroutine(AddElementsToCache<PatrolHelicopter>(_coroutineTimer, cache.Helicopters, EntityType.Heli));
                cached += cache.Helicopters.Count;
            }

            if (config.Additional.Bradley)
            {
                yield return CreateCoroutine(AddElementsToCache<BradleyAPC>(_coroutineTimer, cache.BradleyAPCs, EntityType.Bradley));
                cached += cache.BradleyAPCs.Count;
            }

            if (config.Additional.RHIB)
            {
                yield return CreateCoroutine(AddElementsToCache<RHIB>(_coroutineTimer, cache.RHIB, EntityType.RHIB));
                yield return CreateCoroutine(AddElementsToCache<BaseSubmarine>(_coroutineTimer, cache.RHIB, EntityType.RHIB));
                cached += cache.RHIB.Count;
            }

            if (config.Additional.Boats)
            {
                yield return CreateCoroutine(AddElementsToCache<BaseBoat>(_coroutineTimer, cache.Boats, EntityType.Boat));
                cached += cache.Boats.Count;
            }

            if (config.Additional.MC)
            {
                yield return CreateCoroutine(AddElementsToCache<Minicopter>(_coroutineTimer, cache.MiniCopter, EntityType.Mini));
                yield return CreateCoroutine(AddElementsToCache<Drone>(_coroutineTimer, cache.MiniCopter, EntityType.Mini));
                cached += cache.MiniCopter.Count;
            }

            if (config.Additional.CH47)
            {
                yield return CreateCoroutine(AddElementsToCache<CH47Helicopter>(_coroutineTimer, cache.CH47, EntityType.CH47));
                cached += cache.CH47.Count;
            }

            if (config.Additional.CS)
            {
                yield return CreateCoroutine(AddElementsToCache<CargoShip>(_coroutineTimer, cache.CargoShips, EntityType.CargoShip));
                cached += cache.CargoShips.Count;
            }

            if (config.Additional.Cars)
            {
                yield return CreateCoroutine(AddElementsToCache<BasicCar>(_coroutineTimer, cache.Cars, EntityType.Car));
                yield return CreateCoroutine(AddElementsToCache<ModularCar>(_coroutineTimer, cache.Cars, EntityType.Car));
                cached += cache.Cars.Count;
            }

            if (config.Core.Turrets)
            {
                yield return CreateCoroutine(AddElementsToCache<AutoTurret>(_coroutineTimer, cache.Turrets, EntityType.Turret));
                cached += cache.Turrets.Count;
            }

            if (config.Additional.Traps)
            {
                Func<BaseEntity, bool> condition = entity =>
                {
                    return cache.IsTrap(entity);
                };

                yield return CreateCoroutine(AddElementsToCache<BaseEntity>(_coroutineTimer, cache.Traps, EntityType.Trap, condition));
                cached += cache.Traps.Count;
            }

            if (config.Additional.MLRS)
            {
                yield return CreateCoroutine(AddElementsToCache<MLRSRocket>(_coroutineTimer, cache.MLRS, EntityType.MLRS));
                cached += cache.MLRS.Count;
            }

            if (config.Additional.CP)
            {
                Func<BaseEntity, bool> condition = entity =>
                {
                    return entity.prefabID == 2383782438;
                };
                yield return CreateCoroutine(AddElementsToCache<CargoPlane>(_coroutineTimer, cache.CargoPlanes, EntityType.CargoPlane, condition));
                cached += cache.CargoPlanes.Count;
            }
#if DEBUG
            cache.Print();
#else
            Puts("Cached {0}/{1} entities in {2} seconds!", cached, total, (DateTime.Now - tick).TotalSeconds);
#endif
            _isPopulatingCache = False;
            _allEntities.Clear();
            //Puts("FillCache");
            _coroutines.Pop();
            _coroutines.Push(ServerMgr.Instance.StartCoroutine(FillOnEntitySpawned()));
        }

        private Coroutine CreateCoroutine(IEnumerator operation)
        {
            Coroutine tmp = ServerMgr.Instance.StartCoroutine(operation);

            _coroutines.Push(tmp);
            return tmp;
        }

        private IEnumerator RemoveElementsFromList<TType>(CoroutineTimer timer)
        {
            if (timer.ShouldYield())
            {
                yield return CoroutineEx.waitForEndOfFrame;
                timer.ResetIfYielded();
            }

            if (timer.ShouldYield())
            {
                yield return CoroutineEx.waitForEndOfFrame;
                timer.ResetIfYielded();
            }

#if DEBUG
            Puts($"Start Remove {typeof(TType)}");
#endif
            List<NetworkableId> toRemove = Pool.GetList<NetworkableId>();
            var checks = 0;
            foreach (var pair in _allEntities)
            {
                if (pair.Value.IsKilled() || pair.Value is TType)
                {
                    toRemove.Add(pair.Key);
                }
                if (checks % 10 == 0 && timer.ShouldYield())
                {
                    yield return CoroutineEx.waitForEndOfFrame;
                    timer.ResetIfYielded();
                }
                checks++;
            }

            foreach (var id in toRemove)
            {
                _allEntities.Remove(id);

                if (checks % 10 == 0 && timer.ShouldYield())
                {
                    yield return CoroutineEx.waitForEndOfFrame;
                    timer.ResetIfYielded();
                }
                checks++;
            }

#if DEBUG
            Puts($"End Remove {typeof(TType)}");
#endif
            Pool.FreeList(ref toRemove);
            //Puts("RemoveElementsFromList");
            _coroutines.Pop();
        }

        private IEnumerator AddElementsToCacheWithInfo<TType>(CoroutineTimer timer, Dictionary<NetworkableId, EntityInfo> cachedList, Func<BaseEntity, EntityInfo> getCacheInfoFunc, Func<BaseEntity, bool> condition = null)
        {
            if (timer.ShouldYield())
            {
                yield return CoroutineEx.waitForEndOfFrame;
                timer.ResetIfYielded();
            }

#if DEBUG
            Puts($"Start Caching {typeof(TType)}");
#endif

            List<NetworkableId> idsToRemove = Pool.GetList<NetworkableId>();
            var checks = 0;
            foreach (var pair in _allEntities)
            {
                if (pair.Value.IsKilled() || !pair.Value.IsValid())
                {
                    idsToRemove.Add(pair.Key);
                }
                else if (pair.Value is TType && !cachedList.ContainsKey(pair.Key) && (condition == null || condition(pair.Value)))
                {
                    var ei = getCacheInfoFunc(pair.Value);
                    cachedList.Add(pair.Key, ei);
                    idsToRemove.Add(pair.Key);
                    _radars.ForEach(radar => radar.TryCacheByType(ei.type, ei));
                }
                if (checks % 10 == 0 && timer.ShouldYield())
                {
                    yield return CoroutineEx.waitForEndOfFrame;
                    timer.ResetIfYielded();
                }
                checks++;
            }

            foreach (var key in idsToRemove)
            {
                _allEntities.Remove(key);
                if (checks % 10 == 0 && timer.ShouldYield())
                {
                    yield return CoroutineEx.waitForEndOfFrame;
                    timer.ResetIfYielded();
                }
                checks++;
            }

#if DEBUG
            Puts($"End Caching {typeof(TType)}");
#endif
            Pool.FreeList(ref idsToRemove);
            //Puts("AddElementsToCacheWithInfo");
            _coroutines.Pop();
        }

        private IEnumerator AddElementsToCache<TLookFor>(CoroutineTimer timer, Dictionary<NetworkableId, EntityInfo> cachedList, EntityType type, Func<BaseEntity, bool> condition = null) where TLookFor : BaseEntity
        {
            if (timer.ShouldYield())
            {
                yield return CoroutineEx.waitForEndOfFrame;
                timer.ResetIfYielded();
            }

#if DEBUG
            Puts($"Start Caching {typeof(TLookFor)}");
#endif
            List<NetworkableId> idsToRemove = Pool.GetList<NetworkableId>();
            var checks = 0;
            foreach (var pair in _allEntities)
            {
                if (pair.Value.IsKilled())
                {
                    idsToRemove.Add(pair.Key);
                }
                else if (pair.Value is TLookFor && !cachedList.ContainsKey(pair.Key) && (condition == null || condition(pair.Value)))
                {
                    var ei = new EntityInfo(pair.Value, type, config.Distance.Get, StripTags);
                    cachedList.Add(pair.Key, ei);
                    idsToRemove.Add(pair.Key);
                    _radars.ForEach(radar => radar.TryCacheByType(ei.type, ei));
                }
                if (checks % 10 == 0 && timer.ShouldYield())
                {
                    yield return CoroutineEx.waitForEndOfFrame;
                    timer.ResetIfYielded();
                }
                checks++;
            }

            foreach (var key in idsToRemove)
            {
                _allEntities.Remove(key);
                if (checks % 10 == 0 && timer.ShouldYield())
                {
                    yield return CoroutineEx.waitForEndOfFrame;
                    timer.ResetIfYielded();
                }
                checks++;
            }

#if DEBUG
            Puts($"End Caching {typeof(TLookFor)}");
#endif
            Pool.FreeList(ref idsToRemove);
            //Puts("AddElementsToCache");
            _coroutines.Pop();
        }

        [ConsoleCommand("espgui")]
        private void ccmdESPGUI(ConsoleSystem.Arg arg)
        {
            if (!arg.HasArgs())
                return;

            var player = arg.Player();

            if (!player || !HasAccess(player))
                return;

            if (arg.Args.Contains(config.GUI.Arrow) || arg.Args.Contains("move"))
            {
                ccmdMovePosition(player, "espgui", arg.Args);
                return;
            }

            RadarCommandX(player, "espgui", arg.Args);
        }

        private void ccmdMovePosition(BasePlayer player, string command, string[] args)
        {
            var radar = _radars.Find(x => x.player == player);
            if (args.Length == 1)
            {
                ShowRadarUi(player, radar, False);
                ShowMoveUi(player, True);
                return;
            }
            UiOffsets offsets;
            if (!data.Offsets.TryGetValue(player.userID, out offsets))
            {
                return;
            }
            string[] offsetMin = offsets.Min.Split(' ');
            string[] offsetMax = offsets.Max.Split(' ');
            int n = player.serverInput.IsDown(BUTTON.DUCK) ? 1 : player.serverInput.IsDown(BUTTON.SPRINT) ? 50 : 15;
            switch (args[1])
            {
                case "left":
                    offsets.Min = $"{Convert.ToSingle(offsetMin[0]) - n} {offsetMin[1]}";
                    offsets.Max = $"{Convert.ToSingle(offsetMax[0]) - n} {offsetMax[1]}";
                    break;
                case "right":
                    offsets.Min = $"{Convert.ToSingle(offsetMin[0]) + n} {offsetMin[1]}";
                    offsets.Max = $"{Convert.ToSingle(offsetMax[0]) + n} {offsetMax[1]}";
                    break;
                case "up":
                    offsets.Min = $"{offsetMin[0]} {Convert.ToSingle(offsetMin[1]) + n}";
                    offsets.Max = $"{offsetMax[0]} {Convert.ToSingle(offsetMax[1]) + n}";
                    break;
                case "down":
                    offsets.Min = $"{offsetMin[0]} {Convert.ToSingle(offsetMin[1]) - n}";
                    offsets.Max = $"{offsetMax[0]} {Convert.ToSingle(offsetMax[1]) - n}";
                    break;
            }
            offsets.changed = True;
            data.Offsets[player.userID] = offsets;
            ShowRadarUi(player, radar, True);
        }

        private void RadarCommand(IPlayer user, string command, string[] args)
        {
            var player = user.Object as BasePlayer;

            if (!player)
            {
                user.Message("Not a player!");
                return;
            }

            RadarCommandX(player, command, args);
        }

        private void RadarCommandX(BasePlayer player, string command, string[] args)
        {
            if (args.Contains("list") && permission.UserHasPermission(player.UserIDString, "adminradar.list"))
            {
                Message(player, "ActiveRadars", string.Join(", ", _radars.Select(x => x.username)));
                return;
            }

            if (!HasAccess(player))
            {
                Message(player, player.Connection.authLevel > 0 ? "NotAllowed" : $"Unknown command: {command}");
                return;
            }

            args = args.ToLower(x => x != "True");

            List<string> filters;
            if (!data.Filters.TryGetValue(player.UserIDString, out filters))
            {
                data.Filters.Add(player.UserIDString, filters = new List<string>());
            }

            if (args.Length == 0)
            {
                if (DestroyRadar(player))
                {
                    return;
                }
            }
            else
            {
                switch (args[0])
                {
                    case "move":
                        {
                            var offsets = GetOffsets(player);
                            offsets.Mover = !offsets.Mover;
                            offsets.changed = True;
                            args = Array.FindAll(args, x => x != args[0]);
                        }
                        break;
                    case "reset":
                        {
                            data.Offsets.Remove(player.userID);
                            args = Array.FindAll(args, x => x != args[0]);
                        }
                        break;

                    case "buildings":
                        {
                            if (config.Options.BuildingsDrawTime > 0)
                            {
                                DrawBuildings(player, args.Contains("raid"), args.Contains("twig"));
                            }
                        }
                        return;
                    case "drops":
                        {
                            if (config.Options.DropsDrawTime > 0)
                            {
                                _coroutines.Push(ServerMgr.Instance.StartCoroutine(DrawDropsRoutine(player)));
                            }
                        }
                        return;
                    case "findbyid":
                        {
                            if (config.Options.FindByIDDrawTime > 0)
                            {
                                if (args.Length != 2)
                                {
                                    Player.Message(player, $"{command} findbyid id");
                                    return;
                                }
                                ulong userid;
                                if (!ulong.TryParse(args[1], out userid))
                                {
                                    Player.Message(player, $"Invalid steam id: {userid}");
                                    return;
                                }
                                _coroutines.Push(ServerMgr.Instance.StartCoroutine(FindByIDRoutine(player, userid)));
                            }
                        }
                        return;
                    case "find":
                        if (args.Length > 1 && config.Options.FindDrawTime > 0)
                        {
                            _coroutines.Push(ServerMgr.Instance.StartCoroutine(DrawObjectsRoutine(player, args[1])));
                        }
                        return;
                    case "online":
                        {
                            if (!data.OnlineBoxes.Remove(player.UserIDString)) data.OnlineBoxes.Add(player.UserIDString);

                            Message(player, data.OnlineBoxes.Contains(player.UserIDString) ? "BoxesOnlineOnly" : "BoxesAll");
                        }
                        return;
                    case "vision":
                        {
                            if (!data.Visions.Remove(player.UserIDString)) data.Visions.Add(player.UserIDString);

                            Message(player, data.Visions.Contains(player.UserIDString) ? "VisionOn" : "VisionOff");
                        }
                        return;
                    case "ext":
                        {
                            if (!data.Extended.Remove(player.UserIDString)) data.Extended.Add(player.UserIDString);

                            Message(player, data.Extended.Contains(player.UserIDString) ? "ExtendedPlayersOn" : "ExtendedPlayersOff");
                        }
                        return;
                    case "help":
                        {
                            Message(player, "Help1", string.Join(", ", GetButtonNames().Keys) + ", HT");
                            Message(player, "Help2", command, "online");
                            Message(player, "Help3", command, "ui");
                            Message(player, "Help7", command, "vision");
                            Message(player, "Help8", command, "ext");
                            Message(player, "Help9", command, config.Distance.Loot);
                            Message(player, "Help5", command);
                            Message(player, "Help6", command);
                            Message(player, "PreviousFilter", command);
                        }
                        return;
                    case "ui":
                        {
                            if (!data.Hidden.Remove(player.UserIDString))
                            {
                                data.Hidden.Add(player.UserIDString);

                                DestroyUI(player);
                            }

                            Message(player, data.Hidden.Contains(player.UserIDString) ? "GUIHidden" : "GUIShown");

                            args = filters.Where(x => x != args[0]);
                        }
                        break;
                    case "f":
                        {
                            args = filters.ToArray();
                        }
                        break;
                }
            }

            if (command == "espgui")
            {
                foreach (var filter in args)
                {
                    if (!filters.Remove(filter))
                    {
                        filters.Add(filter);
                    }
                }
                args = filters.ToArray();
            }
            else
            {
                if (config.Settings.Cooldown > 0f && _cooldowns.ContainsKey(player.UserIDString))
                {
                    float cooldown = _cooldowns[player.UserIDString] - Time.realtimeSinceStartup;

                    if (cooldown > 0)
                    {
                        Message(player, "WaitCooldown", cooldown);
                        return;
                    }

                    _cooldowns.Remove(player.UserIDString);
                }

                if (args.Length == 0) data.Filters.Remove(player.UserIDString);
                else data.Filters[player.UserIDString] = args.ToList();
            }

            Radar radar = player.GetComponent<Radar>();

            if (radar == null)
            {
                radar = player.gameObject.AddComponent<Radar>();

                radar.Init(this);
            }

            float invokeTime, maxDistance, outTime, outDistance;

            if (args.Length > 0 && float.TryParse(args[0], NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture, out outTime))
            {
                invokeTime = outTime < 0.1f ? 0.1f : outTime;
            }
            else invokeTime = config.Settings.DefaultInvokeTime;

            if (args.Length > 1 && float.TryParse(args[1], NumberStyles.AllowDecimalPoint, CultureInfo.InvariantCulture, out outDistance))
            {
                maxDistance = outDistance <= 0f ? config.Settings.DefaultMaxDistance : outDistance;
            }
            else maxDistance = config.Settings.DefaultMaxDistance;

            radar.showAll = config.GUI.All && isArg(args, "all");
            radar.showHT = isArg(args, "ht");
            radar.entityTypes.Clear();

            int limit = config.Settings.GetLimit(player);

            if (limit > 0)
            {
                if (radar.showAll)
                {
                    args = Array.FindAll(args, x => x != "all");

                    radar.showAll = false;
                }

                if (args.Length > limit)
                {
                    args = args.Take(limit);
                }

                data.Filters[player.UserIDString] = args.ToList();
            }

            foreach (EntityType type in _allEntityTypes)
            {
                if (_errorTypes.Contains(type))
                {
                    continue;
                }
                if (radar.showAll || isArg(args, type.ToString().ToLower()))
                {
                    radar.Add(type);
                }
                else if (config.Additional.Get(type) && !config.GUI.Get(type))
                {
                    radar.Add(type);
                }
            }

            if (config.Limit.Enabled)
            {
                radar.Add(EntityType.Limit);
            }

            if (config.Core.Active)
            {
                radar.Add(EntityType.Active);
            }

            if (config.Settings.UI && !data.Hidden.Contains(player.UserIDString))
            {
                ShowRadarUi(player, radar, False);
            }

            if (!data.Active.Contains(player.UserIDString))
            {
                data.Active.Add(player.UserIDString);
            }

            if (config.Settings.ShowToggle && command != "espgui")
            {
                Message(player, "Activated", invokeTime, maxDistance, command);
            }

            if (radar.maxDistance != maxDistance)
            {
                radar.maxDistance = maxDistance;
                radar.group = null;
            }

            radar.invokeTime = Mathf.Max(0.1f, invokeTime, config.Settings.MinInvokeTime);

            radar.SetupFilters(config.Settings.Barebones);
        }

        private void Init()
        {
            isUnloading = False;
            _isPopulatingCache = True;
            cache = new Cache(this);
            Unsubscribe(nameof(OnPlayerRespawned));
            Unsubscribe(nameof(OnEntitySpawned));
            Unsubscribe(nameof(OnPlayerVoice));
            Unsubscribe(nameof(OnPlayerSleepEnded));
            Unsubscribe(nameof(OnRadarActivated));
            Unsubscribe(nameof(OnRadarDeactivated));
            permission.RegisterPermission("adminradar.allowed", this);
            permission.RegisterPermission("adminradar.bypass", this);
            permission.RegisterPermission("adminradar.auto", this);
            permission.RegisterPermission("adminradar.bypass.override", this);
            permission.RegisterPermission("adminradar.list", this);
            LoadData();
            RegisterCommands();
        }

        private void Unload()
        {
            isUnloading = True;
            StopFillCache();
            foreach (var radar in _radars.ToList())
            {
                radar.StopAll();
                _radars.Remove(radar);
                UnityEngine.Object.Destroy(radar);
            }
            StringBuilderCache.Clear();
            SaveData();
        }

        private void OnServerInitialized()
        {
            RemoveNonAuthorizedOffsetData();

            if (!config.Methods.Box && !config.Methods.Text && !config.Methods.Arrow)
            {
                Puts("Configuration does not have a chosen drawing method. Setting drawing method to text.");
                config.Methods.Text = True;
            }

            if (config.Voice.Enabled)
            {
                Subscribe(nameof(OnPlayerVoice));
            }

            if (config.Settings.Barebones)
            {
                return;
            }

            _coroutines.Push(ServerMgr.Instance.StartCoroutine(FillCache()));

            if (data.Active.Count > 0)
            {
                foreach (var player in BasePlayer.activePlayerList)
                {
                    if (HasAccess(player) && data.Active.Contains(player.UserIDString))
                    {
                        DelayedInvoke(player);
                    }
                }
            }

            if (permission.GetPermissionUsers("adminradar.auto").Length > 0)
            {
                Subscribe(nameof(OnPlayerSleepEnded));
            }

            if (_sendDiscordMessages)
            {
                Subscribe(nameof(OnRadarActivated));
                Subscribe(nameof(OnRadarDeactivated));
            }

            Subscribe(nameof(OnEntitySpawned));
            SetupClanTeamColors();
        }

        private void OnPlayerRespawned(BasePlayer player)
        {
            if (config.Settings.Barebones)
            {
                _radars.ForEach(radar => radar.TryCacheOnlinePlayer(player));
            }
            else
            {
                _spawnedEntities.Add(player);
            }
        }

        private void OnPlayerSleepEnded(BasePlayer player)
        {
            if (HasAccess(player) && permission.UserHasPermission(player.UserIDString, "adminradar.auto"))
            {
                DelayedInvoke(player);
            }
        }

        private void OnPlayerVoice(BasePlayer player, byte[] data)
        {
            Timer voice;
            if (!_voices.TryGetValue(player.userID, out voice))
            {
                float max = config.Settings.DefaultInvokeTime;

                foreach (var radar in _radars)
                {
                    max = Mathf.Max(radar.invokeTime, max);
                }

                ulong userid = player.userID;

                _voices.Add(userid, timer.Once(config.Voice.Interval + max, () => _voices.Remove(userid)));
            }
            else voice.Reset();
        }

        private void OnPlayerTrackStarted(BasePlayer player, ulong targetId)
        {
            if (player.userID != targetId)
            {
                _radars.Find(x => x.userid == player.UserIDString)?.exclude?.Add(targetId);
            }
        }

        private void OnPlayerTrackEnded(BasePlayer player, ulong targetId)
        {
            if (player.userID != targetId)
            {
                _radars.Find(x => x.userid == player.UserIDString)?.exclude?.Remove(targetId);
            }
        }

        private void OnRadarActivated(BasePlayer player, string playerName, string playerId, Vector3 lastPosition)
        {
            AdminRadarDiscordMessage(playerName, playerId, True, lastPosition);
        }

        private void OnRadarDeactivated(BasePlayer player, string playerName, string playerId, Vector3 lastPosition)
        {
            AdminRadarDiscordMessage(playerName, playerId, False, lastPosition);
        }

        private void OnEntitySpawned(BaseEntity entity)
        {
            _spawnedEntities.Add(entity);
        }

        private void OnEntityDeath(BaseEntity entity, HitInfo info)
        {
            if (entity.IsValid())
            {
                _despawnedEntities[entity.net.ID] = entity.transform.position;
            }
        }

        private void OnEntityKill(BaseEntity entity)
        {
            if (entity.IsValid())
            {
                _despawnedEntities[entity.net.ID] = entity.transform.position;
            }
        }

        private void OnTeamCreated(BasePlayer player, RelationshipManager.PlayerTeam team)
        {
            string hex = $"#{Core.Random.Range(0x1000000):X6}";
            _teamColors[team.teamID] = hex;
            Interface.CallHook("OnTeamCreatedColor", team.teamID, hex);
        }

        private void OnClanCreate(string tag)
        {
            string hex = $"#{Core.Random.Range(0x1000000):X6}";
            _clanColors[tag] = hex;
            Interface.CallHook("OnClanCreateColor", tag, hex);
        }

        private string GetClanColor(ulong targetId)
        {
            string clan = GetClanOf(targetId);

            if (string.IsNullOrEmpty(clan) || !_clanColors.ContainsKey(clan))
            {
                return null;
            }

            return _clanColors[clan];
        }

        private Dictionary<string, string> GetAllClanColors() => _clanColors;

        private Dictionary<ulong, string> GetAllTeamColors() => _teamColors;

        private string GetTeamColor(ulong id)
        {
            if (id.IsSteamId())
            {
                RelationshipManager.PlayerTeam team;
                if (!RelationshipManager.ServerInstance.playerToTeam.TryGetValue(id, out team))
                {
                    return null;
                }

                id = team.teamID;
            }

            if (!_teamColors.ContainsKey(id))
            {
                return null;
            }

            return _teamColors[id];
        }

        private string GetClanOf(ulong playerId)
        {
            string clan;
            if (!_clans.TryGetValue(playerId, out clan))
            {
                _clans[playerId] = clan = Clans?.Call("GetClanOf", playerId) as string ?? string.Empty;
                timer.Once(30f, () => _clans.Remove(playerId));
            }

            return clan;
        }

        private void SetupClanTeamColors()
        {
            foreach (var team in RelationshipManager.ServerInstance.teams)
            {
                _teamColors[team.Key] = $"#{Core.Random.Range(0x1000000):X6}";
            }

            Interface.CallHook("OnTeamColorsInitialized", _teamColors);

            var clans = Clans?.Call("GetAllClans");

            if (clans is JArray)
            {
                foreach (var token in (JArray)clans)
                {
                    _clanColors[token.ToString()] = $"#{Core.Random.Range(0x1000000):X6}";
                }
            }

            Interface.CallHook("OnClanColorsInitialized", _clanColors);
        }

        private bool DestroyRadar(BasePlayer player)
        {
            foreach (var x in _radars)
            {
                if (x.player == player)
                {
                    data.Active.Remove(player.UserIDString);
                    UnityEngine.Object.Destroy(x);
                    _radars.Remove(x);
                    return True;
                }
            }
            return False;
        }

        private bool IsRadar(string id)
        {
            return _radars.Exists(radar => radar.userid == id) ? True : False;
        }

        public void AdminCommand(BasePlayer player, Action action)
        {
            bool isAdmin = player.IsAdmin;
            if (!isAdmin && !player.IsDeveloper && player.IsFlying)
            {
                return;
            }
            if (!isAdmin)
            {
                player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, True);
                player.SendNetworkUpdateImmediate();
            }
            try
            {
                action();
            }
            finally
            {
                if (!isAdmin)
                {
                    player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, False);
                    player.SendNetworkUpdateImmediate();
                }
            }
        }

        private static Color __(string value)
        {
            Color color;
            return ColorUtility.TryParseHtmlString(value.StartsWith("#") ? value : $"#{value}", out color) ? color : Color.white;
        }

        private string StripTags(string value)
        {
            var sb = StringBuilderCache.Acquire(value);

            foreach (string str in _tags)
            {
                sb.Replace(str, string.Empty);
            }

            return StringBuilderCache.GetStringAndRelease(sb);
        }

        private bool HasAccess(BasePlayer player)
        {
            if ((object)player == null)
                return False;

            if (DeveloperList.Contains(player.userID))
                return True;

            if (config.Settings.Authorized.Count > 0)
                return config.Settings.Authorized.Contains(player.UserIDString);

            if (permission.UserHasPermission(player.UserIDString, "adminradar.allowed"))
                return True;

            if (player.IsConnected && player.net.connection.authLevel >= config.Settings.authLevel)
                return True;

            return False;
        }

        private bool isArg(string[] args, string val, bool equalTo = True)
        {
            if (equalTo)
            {
                return Array.Exists(args, arg => arg.Equals(val));
            }
            return Array.Exists(args, arg => arg.Contains(val) || val.Contains(arg));
        }

        private void DrawBuildings(BasePlayer player, bool showNonPlayerBases, bool showTwigOnly)
        {
            var objects = Pool.GetList<object[]>();
            foreach (var building in BuildingManager.server.buildingDictionary.Values)
            {
                if (!building.HasBuildingBlocks()) continue;
                foreach (var block in building.buildingBlocks)
                {
                    if (block.IsKilled()) continue;
                    if (showNonPlayerBases && block.OwnerID.IsSteamId()) continue;
                    if (!showNonPlayerBases && !block.OwnerID.IsSteamId()) continue;
                    if (showTwigOnly && block.grade != BuildingGrade.Enum.Twigs) continue;
                    var targetName = covalence.Players.FindPlayerById(block.OwnerID.ToString())?.Name;
                    if (string.IsNullOrEmpty(targetName)) targetName = block.OwnerID.IsSteamId() ? block.OwnerID.ToString() : "No owner";
                    objects.Add(new object[2] { block.transform.position, $"<size={config.Settings.PlayerTextSize}>{targetName}</size>" });
                    break;
                }
            }
            if (objects.Count > 0)
            {
                AdminCommand(player, () =>
                {
                    foreach (var obj in objects)
                    {
                        player.SendConsoleCommand("ddraw.text", config.Options.BuildingsDrawTime, Color.red, obj[0], obj[1]);
                    }
                });
            }
            Message(player, "ProcessRequestFinished", objects.Count);
            Pool.FreeList(ref objects);
        }

        private IEnumerator FindByIDRoutine(BasePlayer player, ulong userID)
        {
            Message(player, "ProcessRequest");
            int checks = 0;
            var objects = Pool.GetList<object[]>();
            foreach (BaseEntity entity in BaseNetworkable.serverEntities.OfType<BaseEntity>())
            {
                if (entity is BuildingPrivlidge && (entity as BuildingPrivlidge).IsAuthed(userID))
                {
                    objects.Add(new object[2] { Color.cyan, entity.transform.position });
                }
                else if (entity?.OwnerID == userID || entity is CodeLock && (entity as CodeLock).whitelistPlayers.Contains(userID))
                {
                    objects.Add(new object[2] { Color.red, entity.transform.position });
                }
                else if (entity is SleepingBag && (entity as SleepingBag).deployerUserID == userID)
                {
                    objects.Add(new object[2] { Color.green, entity.transform.position });
                }
                else if (entity is AutoTurret && (entity as AutoTurret).IsAuthed(userID))
                {
                    objects.Add(new object[2] { Color.blue, entity.transform.position });
                }
                if (++checks % 200 == 0)
                {
                    yield return CoroutineEx.waitForSeconds(0.0025f);
                }
            }
            AdminCommand(player, () =>
            {
                foreach (var obj in objects)
                {
                    player.SendConsoleCommand("ddraw.text", config.Options.FindByIDDrawTime, obj[0], obj[1], userID);
                }
            });
            Message(player, "ProcessRequestFinished", objects.Count);
            Pool.FreeList(ref objects);
        }

        private IEnumerator DrawObjectsRoutine(BasePlayer player, string value)
        {
            Message(player, "ProcessRequest");
            int checks = 0;
            var objects = Pool.GetList<object[]>();
            foreach (var e in BaseNetworkable.serverEntities)
            {
                if (e.ShortPrefabName.Contains(value, CompareOptions.OrdinalIgnoreCase) || value == "electrical" && e is IOEntity)
                {
                    objects.Add(new object[3] { e.transform.position, e.ShortPrefabName, Mathf.CeilToInt(Vector3.Distance(e.transform.position, player.transform.position)) });
                }
                if (++checks % 200 == 0)
                {
                    yield return CoroutineEx.waitForSeconds(0.0025f);
                }
            }
            AdminCommand(player, () =>
            {
                foreach (var obj in objects)
                {
                    player.SendConsoleCommand("ddraw.text", config.Options.FindDrawTime, Color.red, obj[0], $"<size={config.Settings.PlayerTextSize}>{obj[1]} {obj[2]}</size>");
                }
            });
            Message(player, "ProcessRequestFinished", objects.Count);
            Pool.FreeList(ref objects);
        }

        private IEnumerator DrawDropsRoutine(BasePlayer player)
        {
            Message(player, "ProcessRequest");
            int checks = 0;
            var objects = Pool.GetList<object[]>();
            foreach (var entity in BaseNetworkable.serverEntities)
            {
                if (entity is DroppedItem || entity is Landmine || entity is BearTrap || entity is DroppedItemContainer || entity is RFTimedExplosive)
                {
                    if (config.Settings.DropExceptions.Exists(entity.ShortPrefabName.Contains))
                    {
                        continue;
                    }
                    var currDistance = Mathf.CeilToInt(Vector3.Distance(entity.transform.position, player.transform.position));
                    if (currDistance <= config.Distance.Drops)
                    {
                        var shortname = entity is DroppedItem ? (entity as DroppedItem)?.item?.info.shortname ?? entity.ShortPrefabName : entity.ShortPrefabName;
                        objects.Add(new object[2] { entity.transform.position, $"{shortname} <color=#FFFF00>{currDistance}</color>" });
                    }
                }
                if (++checks % 200 == 0)
                {
                    yield return CoroutineEx.waitForSeconds(0.0025f);
                }
            }
            AdminCommand(player, () =>
            {
                foreach (var obj in objects)
                {
                    if (config.Methods.Text) player.SendConsoleCommand("ddraw.text", config.Options.DropsDrawTime, Color.red, obj[0], obj[1]);
                    if (config.Methods.Box) player.SendConsoleCommand("ddraw.box", config.Options.DropsDrawTime, Color.red, obj[0], 0.25f);
                }
            });
            Message(player, "ProcessRequestFinished", objects.Count);
            Pool.FreeList(ref objects);
        }

        private void LoadData()
        {
            try
            {
                data = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
            }
            catch (Exception ex) { UnityEngine.Debug.LogException(ex); }

            if (data == null)
            {
                data = new StoredData();
            }
        }

        private void RemoveNonAuthorizedOffsetData()
        {
            foreach (ulong userid in data.Offsets.Keys.ToList())
            {
                if (permission.UserHasPermission(userid.ToString(), "adminradar.allowed"))
                {
                    continue;
                }
                if (DeveloperList.Contains(userid.ToString()))
                {
                    continue;
                }
                var user = ServerUsers.Get(userid);
                if (user?.group == ServerUsers.UserGroup.Owner)
                {
                    continue;
                }
                if (user?.group == ServerUsers.UserGroup.Moderator)
                {
                    continue;
                }
                data.Offsets.Remove(userid);
            }
        }

        private void SaveOffsetData()
        {
            bool changed = False;
            foreach (var obj in data.Offsets.ToList())
            {
                if (obj.Value.Equals(DefaultOffset) && obj.Value.Mover)
                {
                    data.Offsets.Remove(obj.Key);
                }
                if (obj.Value.changed)
                {
                    obj.Value.changed = False;
                    changed = True;
                }
            }
            if (changed && saveTimer == null)
            {
                saveTimer = timer.Once(300f, SaveData);
            }
        }

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(Name, data);
        }

        private void DelayedInvoke(BasePlayer player)
        {
            player.Invoke(() =>
            {
                if (!player.IsDestroyed && !IsRadar(player.UserIDString))
                {
                    RadarCommandX(player, "radar", data.Filters.ContainsKey(player.UserIDString) ? data.Filters[player.UserIDString].ToArray() : new string[0]);
                }
            }, UnityEngine.Random.Range(0.1f, 1f));
        }

        private Timer saveTimer;

        #region UI

        private List<ulong> isMovingUi = new List<ulong>();
        private List<string> radarUI = new List<string>();
        private const string RadarPanelName = "AdminRadar_UI";
        private const double S_X = 49.14;
        private const double S_Y = 22.03;
        private UiOffsets DefaultOffset;

        public void DestroyUI(BasePlayer player)
        {
            if (radarUI.Remove(player.UserIDString))
            {
                CuiHelper.DestroyUi(player, RadarPanelName);
            }
        }

        public static void AddCuiPanel(CuiElementContainer container, bool cursor, string color, string amin, string amax, string omin, string omax, string parent, string name)
        {
            container.Add(new CuiPanel
            {
                CursorEnabled = cursor,
                Image = { Color = color },
                RectTransform = { AnchorMin = amin, AnchorMax = amax, OffsetMin = omin, OffsetMax = omax }
            }, parent, name, name);
        }

        public static void AddCuiButton(CuiElementContainer container, string buttonColor, string command, string text, string textColor, int fontSize, TextAnchor align, string amin, string amax, string omin, string omax, string parent, string name, string font = "robotocondensed-regular.ttf")
        {
            container.Add(new CuiButton
            {
                Button = { Color = buttonColor, Command = command },
                Text = { Text = text, Font = font, FontSize = fontSize, Align = align, Color = textColor },
                RectTransform = { AnchorMin = amin, AnchorMax = amax, OffsetMin = omin, OffsetMax = omax }
            }, parent, name, name);
        }

        private UiOffsets GetOffsets(BasePlayer player)
        {
            UiOffsets offsets;
            if (!data.Offsets.TryGetValue(player.userID, out offsets))
            {
                if (!string.IsNullOrEmpty(config.GUI.Arrow))
                {
                    Message(player, "Radar UI Help", $"{radarCommand} move|reset");
                }

                data.Offsets[player.userID] = offsets = new UiOffsets(DefaultOffset.Min, DefaultOffset.Max);
            }
            return offsets;
        }

        private void ShowRadarUi(BasePlayer player, Radar radar, bool showMoveUi)
        {
            var container = new CuiElementContainer();
            var buttons = GetButtonNames().ToList();
            var offsets = GetOffsets(player);
            var rowLeftToRight = 0;
            var colTopToBottom = 0;

            if (config.GUI.All)
            {
                buttons.Insert(0, new KeyValuePair<string, EntityType>(m("All", player.UserIDString), (EntityType)0));
            }

            if (offsets.Mover && !string.IsNullOrEmpty(config.GUI.Arrow))
            {
                buttons.Insert(buttons.Count, new KeyValuePair<string, EntityType>(config.GUI.Arrow, (EntityType)0));
            }

            AddCuiPanel(container, False, "0 0 0 0", "0.5 0", "0.5 0", offsets.Min, offsets.Max, "Overlay", RadarPanelName);

            foreach (var obj in buttons)
            {
                var color = obj.Key == config.GUI.Arrow ? config.GUI.Off : obj.Key == "All" ? (radar.showAll ? config.GUI.On : config.GUI.Off) : (radar.GetBool(obj.Value) ? config.GUI.On : config.GUI.Off);
                var offsetMin = $"{-22.956 + (rowLeftToRight * S_X)} {-9.571 - (colTopToBottom * S_Y)}";
                var offsetMax = $"{22.956 + (rowLeftToRight * S_X)} {9.571 - (colTopToBottom * S_Y)}";
                var text = m(obj.Key, player.UserIDString);
                var command = $"espgui {obj.Key}";

                AddCuiButton(container, color, command, text, "1 1 1 1", 8, TextAnchor.MiddleCenter, "0.5 0.5", "0.5 0.5", offsetMin, offsetMax, RadarPanelName, $"BTN_{rowLeftToRight}_{colTopToBottom}");

                if (++rowLeftToRight >= 5)
                {
                    rowLeftToRight = 0;
                    colTopToBottom++;
                }
            }

            if (!radarUI.Contains(player.UserIDString))
            {
                radarUI.Add(player.UserIDString);
            }

            CuiHelper.AddUi(player, container);

            if (showMoveUi)
            {
                ShowMoveUi(player, False);
            }
        }

        public void ShowMoveUi(BasePlayer player, bool destroyUi)
        {
            string name = $"{RadarPanelName}_MOVE";

            if (destroyUi && isMovingUi.Remove(player.userID))
            {
                CuiHelper.DestroyUi(player, name);
                SaveOffsetData();
                return;
            }
            else if (!isMovingUi.Contains(player.userID))
            {
                isMovingUi.Add(player.userID);
            }

            ulong userid = player.userID;
            var container = new CuiElementContainer();

            AddCuiPanel(container, True, "0 0 1 0.6", "0.5 1", "0.5 1", "58.804 -16.298", "137.604 7.102", RadarPanelName, name);
            AddCuiButton(container, "0 0 0.75 0.6", $"espgui move left", "←", "1 1 1 1", 10, TextAnchor.MiddleCenter, "0.5 0.5", "0.5 0.5", "-35.484 -7.548", "-17.742 7.548", name, $"{name}_L");
            AddCuiButton(container, "0 0 0.75 0.6", $"espgui move up", "↑", "1 1 1 1", 10, TextAnchor.MiddleCenter, "0.5 0.5", "0.5 0.5", "-17.743 -7.548", "0 7.548", name, $"{name}_T");
            AddCuiButton(container, "0 0 0.75 0.6", $"espgui move down", "↓", "1 1 1 1", 10, TextAnchor.MiddleCenter, "0.5 0.5", "0.5 0.5", "-0.001 -7.548", "17.742 7.548", name, $"{name}_B");
            AddCuiButton(container, "0 0 0.75 0.6", $"espgui move right", "→", "1 1 1 1", 10, TextAnchor.MiddleCenter, "0.5 0.5", "0.5 0.5", "17.742 -7.548", "35.485 7.548", name, $"{name}_R");

            CuiHelper.AddUi(player, container);
        }

        public SortedDictionary<string, EntityType> GetButtonNames()
        {
            var buttons = new SortedDictionary<string, EntityType>();

            foreach (EntityType type in _allEntityTypes)
            {
                if (config.GUI.Get(type))
                {
                    buttons.Add(type.ToString(), type);
                }
            }

            return buttons;
        }

        public class UiOffsets
        {
            [JsonIgnore]
            public bool changed;
            public bool Mover = True;
            public string Min;
            public string Max;
            public UiOffsets() { }
            public UiOffsets(string min, string max)
            {
                Min = min;
                Max = max;
            }
            public bool Equals(UiOffsets other)
            {
                if (other != null && other.Min == Min)
                {
                    return other.Max == Max;
                }
                return False;
            }
        }

        #endregion

        #region Config

        public bool _sendDiscordMessages;

        private void AdminRadarDiscordMessage(string playerName, string playerId, bool state, Vector3 position)
        {
            if (isUnloading || DiscordMessages == null)
            {
                return;
            }

            var text = state ? config.Discord.On : config.Discord.Off;
            var grid = PhoneController.PositionToGridCoord(position);
            var message = $"[{DateTime.Now}] {playerName} ({playerId} @ {grid}): {text}";
            var chatEntry = new ConVar.Chat.ChatEntry { Message = message, UserId = playerId, Username = playerName, Time = Facepunch.Math.Epoch.Current };
            var steam = $"[{playerName}](https://steamcommunity.com/profiles/{playerId})";
            var server = $"steam://connect/{ConVar.Server.ip}:{ConVar.Server.port}";

            object fields = new[]
            {
                new { name = config.Discord.Player, value = steam, inline = True },
                new { name = config.Discord.Message, value = text, inline = False },
                new { name = config.Discord.Server, value = server, inline = False },
                new { name = config.Discord.Location, value = grid, inline = False }
            };

            LogToFile("toggles", message, this, False);
            RCon.Broadcast(RCon.LogType.Chat, chatEntry);
            Interface.CallHook("API_SendFancyMessage", config.Discord.Webhook, config.Discord.Title, config.Discord.Color, JsonConvert.SerializeObject(fields), null, this);
        }

        private static List<string> ItemExceptions
        {
            get
            {
                return new List<string> { "bottle", "planner", "rock", "torch", "can.", "arrow." };
            }
        }

        private Configuration config;

        private string GetGroupColor(int index)
        {
            if (config.Limit.ColorsEnabled)
            {
                string color;
                if (config.Limit.Colors.TryGetValue(index.ToString(), out color))
                {
                    return color;
                }
            }

            return config.Limit.Basic;
        }

        private static Dictionary<string, string> DefaultColors
        {
            get
            {
                return new Dictionary<string, string>
                {
                    ["0"] = "#FF00FF", // magenta
                    ["1"] = "#008000", // green
                    ["2"] = "#0000FF", // blue
                    ["3"] = "#FFA500", // orange
                    ["4"] = "#FFFF00" // yellow
                };
            }
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NotAllowed"] = "You are not allowed to use this command.",
                ["PreviousFilter"] = "To use your previous filter type <color=#FFA500>/{0} f</color>",
                ["Activated"] = "ESP Activated - {0}s refresh - {1}m distance. Use <color=#FFA500>/{2} help</color> for help.",
                ["Deactivated"] = "ESP Deactivated.",
                ["Exception"] = "ESP Tool: An error occured. Please check the server console.",
                ["GUIShown"] = "GUI will be shown",
                ["GUIHidden"] = "GUI will now be hidden",
                ["InvalidID"] = "{0} is not a valid steam id. Entry removed.",
                ["BoxesAll"] = "Now showing all boxes.",
                ["BoxesOnlineOnly"] = "Now showing online player boxes only.",
                ["Help1"] = "<color=#FFA500>Available Filters</color>: {0}",
                ["Help2"] = "<color=#FFA500>/{0} {1}</color> - Toggles showing online players boxes only when using the <color=#FF0000>box</color> filter.",
                ["Help3"] = "<color=#FFA500>/{0} {1}</color> - Toggles quick toggle UI on/off",
                ["Help5"] = "e.g: <color=#FFA500>/{0} 1 1000 box loot stash</color>",
                ["Help6"] = "e.g: <color=#FFA500>/{0} 0.5 400 all</color>",
                ["VisionOn"] = "You will now see where players are looking.",
                ["VisionOff"] = "You will no longer see where players are looking.",
                ["ExtendedPlayersOn"] = "Extended information for players is now on.",
                ["ExtendedPlayersOff"] = "Extended information for players is now off.",
                ["Help7"] = "<color=#FFA500>/{0} {1}</color> - Toggles showing where players are looking.",
                ["Help8"] = "<color=#FFA500>/{0} {1}</color> - Toggles extended information for players.",
                ["backpack"] = "backpack",
                ["scientist"] = "scientist",
                ["Help9"] = "<color=#FFA500>/{0} drops</color> - Show all dropped items within {1}m.",
                ["NoActiveRadars"] = "No one is using Radar at the moment.",
                ["ActiveRadars"] = "Active radar users: {0}",
                ["All"] = "All",
                ["Bags"] = "Bags",
                ["Box"] = "Box",
                ["Collectibles"] = "Collectibles",
                ["Dead"] = "Dead",
                ["Loot"] = "Loot",
                ["Ore"] = "Ore",
                ["Sleepers"] = "Sleepers",
                ["Stash"] = "Stash",
                ["TC"] = "TC",
                ["Turrets"] = "Turrets",
                ["Bear"] = "Bear",
                ["Boar"] = "Boar",
                ["Chicken"] = "Chicken",
                ["Wolf"] = "Wolf",
                ["Stag"] = "Stag",
                ["Horse"] = "Horse",
                ["My Base"] = "My Base",
                ["scarecrow"] = "scarecrow",
                ["murderer"] = "murderer",
                ["WaitCooldown"] = "You must wait {0} seconds to use this command again.",
                ["missionprovider_stables_a"] = "missions",
                ["missionprovider_stables_b"] = "missions",
                ["missionprovider_outpost_a"] = "missions",
                ["missionprovider_outpost_b"] = "missions",
                ["missionprovider_fishing_a"] = "missions",
                ["missionprovider_fishing_b"] = "missions",
                ["missionprovider_bandit_a"] = "missions",
                ["missionprovider_bandit_b"] = "missions",
                ["simpleshark"] = "shark",
                ["stables_shopkeeper"] = "shopkeeper",
                ["npc_underwaterdweller"] = "dweller",
                ["boat_shopkeeper"] = "shopkeeper",
                ["bandit_shopkeeper"] = "shopkeeper",
                ["outpost_shopkeeper"] = "shopkeeper",
                ["npc_bandit_guard"] = "guard",
                ["bandit_conversationalist"] = "vendor",
                ["npc_tunneldweller"] = "dweller",
                ["ProcessRequest"] = "Processing request; this will take several seconds...",
                ["ProcessRequestFinished"] = "{0} entities were found.",
                ["Radar UI Help"] = "You can toggle the move button/reset the UI using: {0}",
                ["AT"] = "AT",
                ["bag"] = "bag",
                ["LR300AR"] = "LR300",
                ["AR"] = "AK47",
                ["ARICE"] = "AK47",
                ["M92P"] = "M92",
                ["M39P"] = "M39",
            }, this, "en");

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NotAllowed"] = "No tienes permitido usar este comando.",
                ["PreviousFilter"] = "Para usar tu filtro anterior, escribe <color=#FFA500>/{0} f</color>",
                ["Activated"] = "ESP Activado - Actualización cada {0}s - Distancia {1}m. Usa <color=#FFA500>/{2} help</color> para obtener ayuda.",
                ["Deactivated"] = "ESP Desactivado.",
                ["Exception"] = "Herramienta ESP: Se produjo un error. Por favor, revisa la consola del servidor.",
                ["GUIShown"] = "Se mostrará la interfaz gráfica",
                ["GUIHidden"] = "La interfaz gráfica ahora estará oculta",
                ["InvalidID"] = "{0} no es una ID de Steam válida. Entrada eliminada.",
                ["BoxesAll"] = "Mostrando todas las cajas ahora.",
                ["BoxesOnlineOnly"] = "Mostrando solo cajas de jugadores en línea ahora.",
                ["Help1"] = "<color=#FFA500>Filtros disponibles</color>: {0}",
                ["Help2"] = "<color=#FFA500>/{0} {1}</color> - Alterna mostrar solo las cajas de jugadores en línea cuando se usa el filtro <color=#FF0000>box</color>.",
                ["Help3"] = "<color=#FFA500>/{0} {1}</color> - Activa o desactiva rápidamente la interfaz de alternancia.",
                ["Help5"] = "p. ej.: <color=#FFA500>/{0} 1 1000 box loot stash</color>",
                ["Help6"] = "p. ej.: <color=#FFA500>/{0} 0.5 400 all</color>",
                ["VisionOn"] = "Ahora podrás ver hacia dónde miran los jugadores.",
                ["VisionOff"] = "Ya no podrás ver hacia dónde miran los jugadores.",
                ["ExtendedPlayersOn"] = "La información extendida de los jugadores está activada ahora.",
                ["ExtendedPlayersOff"] = "La información extendida de los jugadores está desactivada ahora.",
                ["Help7"] = "<color=#FFA500>/{0} {1}</color> - Alterna mostrar hacia dónde miran los jugadores.",
                ["Help8"] = "<color=#FFA500>/{0} {1}</color> - Alterna la información extendida de los jugadores.",
                ["backpack"] = "mochila",
                ["scientist"] = "científico",
                ["Help9"] = "<color=#FFA500>/{0} drops</color> - Muestra todos los objetos caídos dentro de {1}m.",
                ["NoActiveRadars"] = "Nadie está utilizando el Radar en este momento.",
                ["ActiveRadars"] = "Usuarios de radar activos: {0}",
                ["All"] = "Todos",
                ["Bags"] = "Bolsas",
                ["Box"] = "Caja",
                ["Collectibles"] = "Objetos coleccionables",
                ["Dead"] = "Muertos",
                ["Loot"] = "Botín",
                ["Ore"] = "Minerales",
                ["Sleepers"] = "Durmientes",
                ["Stash"] = "Escondite",
                ["TC"] = "TC",
                ["Turrets"] = "Torretas",
                ["Bear"] = "Oso",
                ["Boar"] = "Jabalí",
                ["Chicken"] = "Pollo",
                ["Wolf"] = "Lobo",
                ["Stag"] = "Ciervo",
                ["Horse"] = "Caballo",
                ["My Base"] = "Mi Base",
                ["scarecrow"] = "espantapájaros",
                ["murderer"] = "asesino",
                ["WaitCooldown"] = "Debes esperar {0} segundos para usar este comando nuevamente.",
                ["missionprovider_stables_a"] = "misiones",
                ["missionprovider_stables_b"] = "misiones",
                ["missionprovider_outpost_a"] = "misiones",
                ["missionprovider_outpost_b"] = "misiones",
                ["missionprovider_fishing_a"] = "misiones",
                ["missionprovider_fishing_b"] = "misiones",
                ["missionprovider_bandit_a"] = "misiones",
                ["missionprovider_bandit_b"] = "misiones",
                ["simpleshark"] = "tiburón",
                ["stables_shopkeeper"] = "dependiente",
                ["npc_underwaterdweller"] = "morador",
                ["boat_shopkeeper"] = "dependiente",
                ["bandit_shopkeeper"] = "dependiente",
                ["outpost_shopkeeper"] = "dependiente",
                ["npc_bandit_guard"] = "guardia",
                ["bandit_conversationalist"] = "vendedor",
                ["npc_tunneldweller"] = "morador",
                ["ProcessRequest"] = "Procesando la solicitud; esto llevará varios segundos...",
                ["ProcessRequestFinished"] = "Se encontraron {0} entidades.",
                ["Radar UI Help"] = "Puedes alternar el botón de movimiento/restablecer la interfaz usando: {0}",
                ["AT"] = "AT",
                ["bag"] = "bolsa",
                ["LR300AR"] = "LR300",
                ["AR"] = "AK47",
                ["ARICE"] = "AK47",
                ["M92P"] = "M92",
                ["M39P"] = "M39",
            }, this, "es");
        }

        public class ConfigurationSettings
        {
            public int GetLimit(BasePlayer player)
            {
                if (player.Connection.authLevel >= 2) return Owner;
                if (player.Connection.authLevel == 1) return Moderator;
                return Allowed;
            }

            [JsonProperty(PropertyName = "Barebones Performance Mode")]
            public bool Barebones;

            [JsonProperty(PropertyName = "Restrict Access To Steam64 IDs", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> Authorized = new List<string>();

            [JsonProperty(PropertyName = "Restrict Access To Auth Level")]
            public int authLevel = 1;

            [JsonProperty(PropertyName = "Max Active Filters (OWNERID)")]
            public int Owner = 0;

            [JsonProperty(PropertyName = "Max Active Filters (MODERATORID)")]
            public int Moderator = 4;

            [JsonProperty(PropertyName = "Max Active Filters (ADMINRADAR.ALLOWED)")]
            public int Allowed = 2;

            [JsonProperty(PropertyName = "Default Distance")]
            public float DefaultMaxDistance = 500f;

            [JsonProperty(PropertyName = "Default Refresh Time")]
            public float DefaultInvokeTime = 5f;

            [JsonProperty(PropertyName = "Minimum Refresh Time")]
            public float MinInvokeTime = 1.0f;

            [JsonProperty(PropertyName = "Dropped Item Exceptions", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> DropExceptions;

            [JsonProperty(PropertyName = "Deactivate Radar After X Seconds Inactive")]
            public float InactiveSeconds = 300;

            [JsonProperty(PropertyName = "Deactivate Radar After X Seconds Activated")]
            public float DeactivateSeconds;

            [JsonProperty(PropertyName = "User Interface Enabled")]
            public bool UI = True;

            [JsonProperty(PropertyName = "Show Average Ping Every X Seconds [0 = disabled]")]
            public float AveragePingInterval;

            [JsonProperty(PropertyName = "Re-use Cooldown, Seconds")]
            public float Cooldown;

            [JsonProperty(PropertyName = "Show Radar Activated/Deactivated Messages")]
            public bool ShowToggle = True;

            [JsonProperty(PropertyName = "Player Name Text Size")]
            public int PlayerNameSize = 24;

            [JsonProperty(PropertyName = "Player Information Text Size")]
            public int PlayerTextSize = 24;

            [JsonProperty(PropertyName = "Entity Name Text Size")]
            public int EntityNameSize = 24;

            [JsonProperty(PropertyName = "Entity Information Text Size")]
            public int EntityTextSize = 24;

            [JsonProperty(PropertyName = "Unique Clan/Team Color Applies To Entire Player Text")]
            public bool ApplySameColor;

            [JsonProperty(PropertyName = "Track Group Name")]
            public string New = "";

            [JsonProperty(PropertyName = "Tracked Group Name Text")]
            public string NewText = "<color=#00FF00>*</color>";

            [JsonProperty(PropertyName = "Chat Command")]
            public string Primary = "radar";

            [JsonProperty(PropertyName = "Second Command")]
            public string Secondary = "radar";
        }

        public class ConfigurationOptions
        {
            [JsonProperty(PropertyName = "Additional Traps", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> AdditionalTraps = new List<string> { "barricade.metal", "barricade.stone", "barricade.wood", "barricade.woodwire", "spikes.floor", "guntrap", "sam_site_turret_deployed", "flameturret" };

            [JsonProperty(PropertyName = "Draw Distant Players With X")]
            public bool DrawX;

            [JsonProperty(PropertyName = "Draw Empty Containers")]
            public bool DrawEmptyContainers = True;

            [JsonProperty(PropertyName = "Abbreviate Item Names")]
            public bool Abbr = True;

            [JsonProperty(PropertyName = "Show Resource Amounts")]
            public bool ResourceAmounts = True;

            [JsonProperty(PropertyName = "Show X Items From Barrel And Crate")]
            public int LootContentAmount;

            [JsonProperty(PropertyName = "Show X Items From Airdrop")]
            public int AirdropContentAmount;

            [JsonProperty(PropertyName = "Show X Items From Stash")]
            public int StashContentAmount;

            [JsonProperty(PropertyName = "Show X Items From Backpacks")]
            public int BackpackContentAmount = 3;

            [JsonProperty(PropertyName = "Show X Items From Corpses")]
            public int CorpseContentAmount = 3;

            [JsonProperty(PropertyName = "Show NPC At World View")]
            public bool WorldView = True;

            [JsonProperty(PropertyName = "Show Authed Count On Cupboards")]
            public bool TCAuthed = True;

            [JsonProperty(PropertyName = "Show Bag Count On Cupboards")]
            public bool TCBags = True;

            [JsonProperty(PropertyName = "Show Npc Player Target")]
            public bool DrawTargetsVictim;

            [JsonProperty(PropertyName = "Radar Buildings Draw Time")]
            public float BuildingsDrawTime = 60f;

            [JsonProperty(PropertyName = "Radar Drops Draw Time")]
            public float DropsDrawTime = 60f;

            [JsonProperty(PropertyName = "Radar Find Draw Time")]
            public float FindDrawTime = 60f;

            [JsonProperty(PropertyName = "Radar FindByID Draw Time")]
            public float FindByIDDrawTime = 60f;

            public int Get(EntityType type)
            {
                switch (type)
                {
                    case EntityType.Backpack: return BackpackContentAmount;
                    case EntityType.Dead: return CorpseContentAmount;
                    case EntityType.Airdrop: return AirdropContentAmount;
                    case EntityType.Stash: return StashContentAmount;
                    case EntityType.Ore: return ResourceAmounts ? 1 : 0;
                    case EntityType.Col: return ResourceAmounts ? 1 : 0;
                    case EntityType.Loot: return LootContentAmount;
                    default: return 0;
                }
            }
        }

        public class ConfigurationDrawMethods
        {
            [JsonProperty(PropertyName = "Draw Arrows On Players")]
            public bool Arrow;

            [JsonProperty(PropertyName = "Draw Boxes")]
            public bool Box;

            [JsonProperty(PropertyName = "Draw Text")]
            public bool Text = True;
        }

        public class ConfigurationLimits
        {
            [JsonProperty(PropertyName = "Enabled")]
            public bool Enabled;

            [JsonProperty(PropertyName = "Limit")]
            public int Amount = 4;

            [JsonProperty(PropertyName = "Range")]
            public float Range = 50f;

            [JsonProperty(PropertyName = "Height Offset [0.0 = disabled]")]
            public float Height = 40f;

            [JsonProperty(PropertyName = "Use Group Colors Configuration")]
            public bool ColorsEnabled = True;

            [JsonProperty(PropertyName = "Dead Color")]
            public string Dead = "#ff0000";

            [JsonProperty(PropertyName = "Group Color Basic")]
            public string Basic = "#ffff00";

            [JsonProperty(PropertyName = "Group Limit Colors", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, string> Colors = DefaultColors;
        }

        public class ConfigurationDrawDistances
        {
            [JsonProperty(PropertyName = "Sleepers Min Y")]
            public float MinY = 0f;

            [JsonProperty(PropertyName = "Player Corpses")]
            public float Corpse = 200;

            [JsonProperty(PropertyName = "Players")]
            public float Players = 500;

            [JsonProperty(PropertyName = "Airdrop Crates")]
            public float Airdrop = 400f;

            [JsonProperty(PropertyName = "Animals")]
            public float Animal = 200;

            [JsonProperty(PropertyName = "Boats")]
            public float Boat = 150f;

            [JsonProperty(PropertyName = "Boxes")]
            public float Box = 100;

            [JsonProperty(PropertyName = "Cars")]
            public float Car = 500f;

            [JsonProperty(PropertyName = "CCTV")]
            public float CCTV = 500;

            [JsonProperty(PropertyName = "Collectibles")]
            public float Col = 100;

            [JsonProperty(PropertyName = "Loot Containers")]
            public float Loot = 150;

            [JsonProperty(PropertyName = "MiniCopter")]
            public float MC = 200f;

            [JsonProperty(PropertyName = "MLRS")]
            public float MLRS = 5000f;

            [JsonProperty(PropertyName = "NPC Players")]
            public float NPC = 300;

            [JsonProperty(PropertyName = "Resources (Ore)")]
            public float Ore = 200;

            [JsonProperty(PropertyName = "Ridable Horses")]
            public float RH = 250;

            [JsonProperty(PropertyName = "Sleeping Bags")]
            public float Bag = 250;

            [JsonProperty(PropertyName = "Stashes")]
            public float Stash = 250;

            [JsonProperty(PropertyName = "Tool Cupboards")]
            public float TC = 150;

            [JsonProperty(PropertyName = "Tool Cupboard Arrows")]
            public float TCArrows = 250;

            [JsonProperty(PropertyName = "Traps")]
            public float Traps = 100;

            [JsonProperty(PropertyName = "Turrets")]
            public float Turret = 100;

            [JsonProperty(PropertyName = "Vending Machines")]
            public float VendingMachine = 250;

            [JsonProperty(PropertyName = "Radar Drops Command")]
            public float Drops = 150;

            public float Get(EntityType type, BaseEntity entity)
            {
                switch (type)
                {
                    case EntityType.Active: return Players;
                    case EntityType.Sleeper: return Players;
                    case EntityType.Dead: return Corpse;
                    case EntityType.Airdrop: return Airdrop;
                    case EntityType.Backpack: return Loot;
                    case EntityType.Boat: return Boat;
                    case EntityType.Bag: return Bag;
                    case EntityType.Car: return Car;
                    case EntityType.CCTV: return CCTV;
                    case EntityType.Col: return Col;
                    case EntityType.Loot: return Loot;
                    case EntityType.Mini: return MC;
                    case EntityType.MLRS: return MLRS;
                    case EntityType.Ore: return Ore;
                    case EntityType.Horse: return RH;
                    case EntityType.RHIB: return Boat;
                    case EntityType.Stash: return Stash;
                    case EntityType.TC: return TC;
                    case EntityType.TCArrow: return TCArrows;
                    case EntityType.Trap: return Traps;
                    case EntityType.Turret: return Turret;
                    case EntityType.Bradley:
                    case EntityType.CargoPlane:
                    case EntityType.CargoShip:
                    case EntityType.CH47:
                    case EntityType.Limit:
                    default:
                        {
                            if (entity is VendingMachine) return VendingMachine;
                            if (type == EntityType.Box) return Box;
                            if (entity is BaseNpc) return Animal;
                            if (type == EntityType.Npc) return NPC;
                            return 9999f;
                        }
                }
            }
        }

        public class ConfigurationCoreTracking
        {
            [JsonProperty(PropertyName = "Players")]
            public bool Active = True;

            [JsonProperty(PropertyName = "Sleepers")]
            public bool Sleepers = True;

            [JsonProperty(PropertyName = "Animals")]
            public bool Animals = True;

            [JsonProperty(PropertyName = "Bags")]
            public bool Bags = True;

            [JsonProperty(PropertyName = "Box")]
            public bool Box = True;

            [JsonProperty(PropertyName = "Collectibles")]
            public bool Col = True;

            [JsonProperty(PropertyName = "Dead")]
            public bool Dead = True;

            [JsonProperty(PropertyName = "Loot")]
            public bool Loot = True;

            [JsonProperty(PropertyName = "NPC")]
            public bool NPCPlayer = True;

            [JsonProperty(PropertyName = "Ore")]
            public bool Ore = True;

            [JsonProperty(PropertyName = "Stash")]
            public bool Stash = True;

            [JsonProperty(PropertyName = "SupplyDrops")]
            public bool Airdrop = True;

            [JsonProperty(PropertyName = "TC")]
            public bool TC = True;

            [JsonProperty(PropertyName = "Turrets")]
            public bool Turrets = True;
        }

        public class ConfigurationAdditionalTracking
        {
            [JsonProperty(PropertyName = "Backpacks Plugin")]
            public bool BackpackPlugin { get; set; }

            [JsonProperty(PropertyName = "Boats")]
            public bool Boats;

            [JsonProperty(PropertyName = "Bradley APC")]
            public bool Bradley = True;

            [JsonProperty(PropertyName = "Cars")]
            public bool Cars;

            [JsonProperty(PropertyName = "CargoPlanes")]
            public bool CP;

            [JsonProperty(PropertyName = "CargoShips")]
            public bool CS;

            [JsonProperty(PropertyName = "CCTV")]
            public bool CCTV;

            [JsonProperty(PropertyName = "CH47")]
            public bool CH47;

            [JsonProperty(PropertyName = "Helicopters")]
            public bool Heli = True;

            [JsonProperty(PropertyName = "Helicopter Rotor Health")]
            public bool RotorHealth;

            [JsonProperty(PropertyName = "MiniCopter")]
            public bool MC;

            [JsonProperty(PropertyName = "MLRS")]
            public bool MLRS = True;

            [JsonProperty(PropertyName = "Ridable Horses")]
            public bool RH;

            [JsonProperty(PropertyName = "RHIB")]
            public bool RHIB;

            [JsonProperty(PropertyName = "Traps")]
            public bool Traps;

            public bool Get(EntityType type)
            {
                switch (type)
                {
                    case EntityType.Boat: return Boats;
                    case EntityType.Bradley: return Bradley;
                    case EntityType.CargoPlane: return CP;
                    case EntityType.CargoShip: return CS;
                    case EntityType.Car: return Cars;
                    case EntityType.CCTV: return CCTV;
                    case EntityType.CH47: return CH47;
                    case EntityType.Heli: return Heli;
                    case EntityType.Horse: return RH;
                    case EntityType.Mini: return MC;
                    case EntityType.MLRS: return MLRS;
                    case EntityType.RHIB: return RHIB;
                    case EntityType.Trap: return Traps;
                    default: return False;
                }
            }
        }

        public class ConfigurationHex
        {
            [JsonProperty(PropertyName = "Player Arrows")]
            public string Arrows = "#000000";

            [JsonProperty(PropertyName = "Distance")]
            public string Dist = "#ffa500";

            [JsonProperty(PropertyName = "Helicopters")]
            public string Heli = "#ff00ff";

            [JsonProperty(PropertyName = "Bradley")]
            public string Bradley = "#ff00ff";

            [JsonProperty(PropertyName = "MiniCopter")]
            public string MC = "#ff00ff";

            [JsonProperty(PropertyName = "MiniCopter (ScrapTransportHelicopter)")]
            public string STH = "#ff00ff";

            [JsonProperty(PropertyName = "Online Player")]
            public string Online = "#ffffff";

            [JsonProperty(PropertyName = "Online Player (Underground)")]
            public string Underground = "#ffffff";

            [JsonProperty(PropertyName = "Online Player (Flying)")]
            public string Flying = "#ffffff";

            [JsonProperty(PropertyName = "Online Dead Player")]
            public string OnlineDead = "#ff0000";

            [JsonProperty(PropertyName = "Dead Player")]
            public string Dead = "#ff0000";

            [JsonProperty(PropertyName = "Sleeping Player")]
            public string Sleeper = "#00ffff";

            [JsonProperty(PropertyName = "Sleeping Dead Player")]
            public string SleeperDead = "#ff0000";

            [JsonProperty(PropertyName = "Health")]
            public string Health = "#ff0000";

            [JsonProperty(PropertyName = "Backpacks")]
            public string Backpack = "#c0c0c0";

            [JsonProperty(PropertyName = "Scientists")]
            public string Scientist = "#ffff00";

            [JsonProperty(PropertyName = "Scientist Peacekeeper")]
            public string Peacekeeper = "#ffff00";

            [JsonProperty(PropertyName = "Murderers")]
            public string Murderer = "#000000";

            [JsonProperty(PropertyName = "Animals")]
            public string Animal = "#0000ff";

            [JsonProperty(PropertyName = "Resources")]
            public string Resource = "#ffff00";

            [JsonProperty(PropertyName = "Collectibles")]
            public string Col = "#ffff00";

            [JsonProperty(PropertyName = "Tool Cupboards")]
            public string TC = "#000000";

            [JsonProperty(PropertyName = "Sleeping Bags")]
            public string Bag = "#ff00ff";

            [JsonProperty(PropertyName = "Airdrops")]
            public string AD = "#ff00ff";

            [JsonProperty(PropertyName = "AutoTurrets")]
            public string AT = "#ffff00";

            [JsonProperty(PropertyName = "Corpses")]
            public string Corpse = "#ffff00";

            [JsonProperty(PropertyName = "Box")]
            public string Box = "#ff00ff";

            [JsonProperty(PropertyName = "Loot")]
            public string Loot = "#ffff00";

            [JsonProperty(PropertyName = "Stash")]
            public string Stash = "#ffffff";

            [JsonProperty(PropertyName = "Boat")]
            public string Boat = "#ff00ff";

            [JsonProperty(PropertyName = "CargoPlane")]
            public string CP = "#ff00ff";

            [JsonProperty(PropertyName = "CargoShip")]
            public string CS = "#ff00ff";

            [JsonProperty(PropertyName = "Car")]
            public string Cars = "#ff00ff";

            [JsonProperty(PropertyName = "CCTV")]
            public string CCTV = "#ff00ff";

            [JsonProperty(PropertyName = "CH47")]
            public string CH47 = "#ff00ff";

            [JsonProperty(PropertyName = "RidableHorse")]
            public string RH = "#ff00ff";

            [JsonProperty(PropertyName = "MLRS")]
            public string MLRS = "#ff00ff";

            [JsonProperty(PropertyName = "NPC")]
            public string NPC = "#ff00ff";

            [JsonProperty(PropertyName = "RHIB")]
            public string RHIB = "#ff00ff";

            [JsonProperty(PropertyName = "Traps")]
            public string Traps = "#ff00ff";

            public string Get(EntityType type)
            {
                switch (type)
                {
                    case EntityType.Active: return Online;
                    case EntityType.Airdrop: return Box;
                    case EntityType.Backpack: return Backpack;
                    case EntityType.Bag: return Bag;
                    case EntityType.Boat: return Boat;
                    case EntityType.Box: return Box;
                    case EntityType.Bradley: return Bradley;
                    case EntityType.CargoPlane: return CP;
                    case EntityType.CargoShip: return CS;
                    case EntityType.Car: return Cars;
                    case EntityType.CCTV: return CCTV;
                    case EntityType.CH47: return CH47;
                    case EntityType.Col: return Col;
                    case EntityType.Dead: return Dead;
                    case EntityType.Heli: return Heli;
                    case EntityType.Horse: return RH;
                    case EntityType.Loot: return Loot;
                    case EntityType.Mini: return MC;
                    case EntityType.MLRS: return MLRS;
                    case EntityType.Npc: return NPC;
                    case EntityType.Ore: return Resource;
                    case EntityType.RHIB: return RHIB;
                    case EntityType.Sleeper: return Sleeper;
                    case EntityType.Stash: return Stash;
                    case EntityType.TC: return TC;
                    case EntityType.Turret: return AT;
                    case EntityType.Trap: return Traps;
                    default: return "#ff00ff";
                }
            }
        }

        public class ConfigurationGUI
        {
            [JsonProperty(PropertyName = "Move Arrow Text")]
            public string Arrow = "↕";

            [JsonProperty(PropertyName = "Offset Min")]
            public string OffsetMin = "185.044 91.429";

            [JsonProperty(PropertyName = "Offset Max")]
            public string OffsetMax = "230.956 110.571";

            [JsonProperty(PropertyName = "Color On")]
            public string On = "0.69 0.49 0.29 0.5";

            [JsonProperty(PropertyName = "Color Off")]
            public string Off = "0.29 0.49 0.69 0.5";

            [JsonProperty(PropertyName = "Show Button - All")]
            public bool All = True;

            [JsonProperty(PropertyName = "Show Button - Bags")]
            public bool Bags = True;

            [JsonProperty(PropertyName = "Show Button - Boats")]
            public bool Boats;

            [JsonProperty(PropertyName = "Show Button - Bradley")]
            public bool Bradley;

            [JsonProperty(PropertyName = "Show Button - Box")]
            public bool Box = True;

            [JsonProperty(PropertyName = "Show Button - Cars")]
            public bool Cars;

            [JsonProperty(PropertyName = "Show Button - CCTV")]
            public bool CCTV = True;

            [JsonProperty(PropertyName = "Show Button - CargoPlanes")]
            public bool CP;

            [JsonProperty(PropertyName = "Show Button - CargoShips")]
            public bool CS;

            [JsonProperty(PropertyName = "Show Button - CH47")]
            public bool CH47;

            [JsonProperty(PropertyName = "Show Button - Collectibles")]
            public bool Col = True;

            [JsonProperty(PropertyName = "Show Button - Dead")]
            public bool Dead = True;

            [JsonProperty(PropertyName = "Show Button - Heli")]
            public bool Heli;

            [JsonProperty(PropertyName = "Show Button - Loot")]
            public bool Loot = True;

            [JsonProperty(PropertyName = "Show Button - MiniCopter")]
            public bool MC;

            [JsonProperty(PropertyName = "Show Button - MLRS")]
            public bool MLRS = True;

            [JsonProperty(PropertyName = "Show Button - NPC")]
            public bool NPC = True;

            [JsonProperty(PropertyName = "Show Button - Ore")]
            public bool Ore = True;

            [JsonProperty(PropertyName = "Show Button - Ridable Horses")]
            public bool Horse;

            [JsonProperty(PropertyName = "Show Button - RigidHullInflatableBoats")]
            public bool RHIB;

            [JsonProperty(PropertyName = "Show Button - Sleepers")]
            public bool Sleepers = True;

            [JsonProperty(PropertyName = "Show Button - Stash")]
            public bool Stash = True;

            [JsonProperty(PropertyName = "Show Button - TC")]
            public bool TC = True;

            [JsonProperty(PropertyName = "Show Button - TC Arrow")]
            public bool TCArrow = True;

            [JsonProperty(PropertyName = "Show Button - TC Turrets")]
            public bool Turrets = True;

            [JsonProperty(PropertyName = "Show Button - Traps")]
            public bool Traps = True;

            public bool Get(EntityType type)
            {
                switch (type)
                {
                    case EntityType.Airdrop: return Box;
                    case EntityType.Bag: return Bags;
                    case EntityType.Boat: return Boats;
                    case EntityType.Box: return Box;
                    case EntityType.Bradley: return Bradley;
                    case EntityType.CargoPlane: return CP;
                    case EntityType.CargoShip: return CS;
                    case EntityType.Car: return Cars;
                    case EntityType.CCTV: return CCTV;
                    case EntityType.CH47: return CH47;
                    case EntityType.Col: return Col;
                    case EntityType.Dead: return Dead;
                    case EntityType.Heli: return Heli;
                    case EntityType.Horse: return Horse;
                    case EntityType.Loot: return Loot;
                    case EntityType.Mini: return MC;
                    case EntityType.MLRS: return MLRS;
                    case EntityType.Npc: return NPC;
                    case EntityType.Ore: return Ore;
                    case EntityType.RHIB: return RHIB;
                    case EntityType.Sleeper: return Sleepers;
                    case EntityType.Stash: return Stash;
                    case EntityType.TC: return TC;
                    case EntityType.TCArrow: return TCArrow;
                    case EntityType.Turret: return Turrets;
                    case EntityType.Trap: return Traps;
                    default: return False;
                }
            }
        }

        public class ConfigurationVoiceDetection
        {
            [JsonProperty(PropertyName = "Enabled")]
            public bool Enabled = True;

            [JsonProperty(PropertyName = "Timeout After X Seconds")]
            public int Interval = 3;

            [JsonProperty(PropertyName = "Detection Radius")]
            public float Distance = 30f;
        }

        public class ConfigurationDiscord
        {
            [JsonProperty(PropertyName = "Message - Embed Color (DECIMAL)")]
            public int Color = 3329330;

            [JsonProperty(PropertyName = "Message - Webhook URL")]
            public string Webhook = "https://support.discordapp.com/hc/en-us/articles/228383668-Intro-to-Webhooks";

            [JsonProperty(PropertyName = "Embed_MessageServer")]
            public string Server = "Server";

            [JsonProperty(PropertyName = "Embed_MessageLocation")]
            public string Location = "Location";

            [JsonProperty(PropertyName = "Embed_MessageTitle")]
            public string Title = "Player Message";

            [JsonProperty(PropertyName = "Embed_MessagePlayer")]
            public string Player = "Player";

            [JsonProperty(PropertyName = "Embed_MessageMessage")]
            public string Message = "Message";

            [JsonProperty(PropertyName = "Off")]
            public string Off = "Radar turned off.";

            [JsonProperty(PropertyName = "On")]
            public string On = "Radar turned on.";
        }

        public class ConfigurationTrack
        {
            [JsonProperty(PropertyName = "Radar")]
            public bool Radar;

            [JsonProperty(PropertyName = "Radar Text")]
            public string RadarText = "<color=#00FF00>R</color>";

            [JsonProperty(PropertyName = "Console Godmode")]
            public bool God;

            [JsonProperty(PropertyName = "Console Godmode Text")]
            public string GodText = "<color=#89CFF0>G</color>";

            [JsonProperty(PropertyName = "Plugin Godmode")]
            public bool GodPlugin;

            [JsonProperty(PropertyName = "Plugin Godmode Text")]
            public string GodPluginText = "<color=#0000CD>G</color>";

            [JsonProperty(PropertyName = "Vanish")]
            public bool Vanish = True;

            [JsonProperty(PropertyName = "Vanish Text")]
            public string VanishText = "<color=#FF00FF>V</color>";

            [JsonProperty(PropertyName = "NOCLIP")]
            public bool NoClip;

            [JsonProperty(PropertyName = "NOCLIP Text")]
            public string NoClipText = "<color=#FFFF00>F</color>";
        }

        public class Configuration
        {
            [JsonProperty(PropertyName = "Core Tracking")]
            public ConfigurationCoreTracking Core { get; set; } = new ConfigurationCoreTracking();

            [JsonProperty(PropertyName = "Additional Tracking")]
            public ConfigurationAdditionalTracking Additional { get; set; } = new ConfigurationAdditionalTracking();

            [JsonProperty(PropertyName = "Color-Hex Codes")]
            public ConfigurationHex Hex { get; set; } = new ConfigurationHex();

            [JsonProperty(PropertyName = "DiscordMessages")]
            public ConfigurationDiscord Discord { get; set; } = new ConfigurationDiscord();

            [JsonProperty(PropertyName = "Drawing Distances")]
            public ConfigurationDrawDistances Distance { get; set; } = new ConfigurationDrawDistances();

            [JsonProperty(PropertyName = "Drawing Methods")]
            public ConfigurationDrawMethods Methods { get; set; } = new ConfigurationDrawMethods();

            [JsonProperty(PropertyName = "Group Limit")]
            public ConfigurationLimits Limit { get; set; } = new ConfigurationLimits();

            [JsonProperty(PropertyName = "GUI")]
            public ConfigurationGUI GUI { get; set; } = new ConfigurationGUI();

            [JsonProperty(PropertyName = "Options")]
            public ConfigurationOptions Options { get; set; } = new ConfigurationOptions();

            [JsonProperty(PropertyName = "Settings")]
            public ConfigurationSettings Settings { get; set; } = new ConfigurationSettings();

            [JsonProperty(PropertyName = "Track Admin Status")]
            public ConfigurationTrack Track { get; set; } = new ConfigurationTrack();

            [JsonProperty(PropertyName = "Voice Detection")]
            public ConfigurationVoiceDetection Voice { get; set; } = new ConfigurationVoiceDetection();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
                if (config.Settings.DropExceptions == null) config.Settings.DropExceptions = ItemExceptions;
                SaveConfig();
            }
            catch (Exception ex)
            {
                UnityEngine.Debug.LogException(ex);
                LoadDefaultConfig();
            }

            if (config.GUI.Boats) config.Additional.Boats = True;
            if (config.GUI.Bradley) config.Additional.Bradley = True;
            if (config.GUI.Cars) config.Additional.Cars = True;
            if (config.GUI.CCTV) config.Additional.CCTV = True;
            if (config.GUI.CP) config.Additional.CP = True;
            if (config.GUI.CS) config.Additional.CS = True;
            if (config.GUI.CH47) config.Additional.CH47 = True;
            if (config.GUI.Heli) config.Additional.Heli = True;
            if (config.GUI.MC) config.Additional.MC = True;
            if (config.GUI.MLRS) config.Additional.MLRS = True;
            if (config.GUI.Horse) config.Additional.RH = True;
            if (config.GUI.RHIB) config.Additional.RHIB = True;
            if (config.Voice.Interval < 3) config.Voice.Interval = 3;

            DefaultOffset = new UiOffsets(config.GUI.OffsetMin, config.GUI.OffsetMax);

            _sendDiscordMessages = !string.IsNullOrEmpty(config.Discord.Webhook) && config.Discord.Webhook != "https://support.discordapp.com/hc/en-us/articles/228383668-Intro-to-Webhooks";
        }

        private void RegisterCommands()
        {
            if (!string.IsNullOrEmpty(config.Settings.Primary))
            {
                radarCommand = config.Settings.Primary;
                AddCovalenceCommand(config.Settings.Primary, nameof(RadarCommand));
            }
            if (!string.IsNullOrEmpty(config.Settings.Secondary) && config.Settings.Primary != config.Settings.Secondary)
            {
                if (string.IsNullOrEmpty(radarCommand))
                {
                    radarCommand = config.Settings.Secondary;
                }
                AddCovalenceCommand(config.Settings.Secondary, nameof(RadarCommand));
            }
        }

        private string radarCommand;

        protected override void SaveConfig() => Config.WriteObject(config);

        protected override void LoadDefaultConfig() => config = new Configuration();

        private string m(string key, string id, params object[] args)
        {
            return args.Length > 0 ? string.Format(lang.GetMessage(key, this, id), args) : lang.GetMessage(key, this, id);
        }

        private static string r(string source)
        {
            return source.Contains(">") ? Regex.Replace(source, "<.*?>", string.Empty) : source;
        }

        private void Message(BasePlayer target, string key, params object[] args)
        {
            if (target.IsValid())
            {
                Player.Message(target, m(key, target.UserIDString, args), 0uL);
            }
        }

        #endregion
    }
}

namespace Oxide.Plugins.AdminRadarExtensionMethods
{
    public static class ExtensionMethods
    {
        public static T ElementAt<T>(this IEnumerable<T> a, int b) { using (var c = a.GetEnumerator()) { while (c.MoveNext()) { if (b == 0) { return c.Current; } b--; } } return default(T); }
        public static T FirstOrDefault<T>(this IEnumerable<T> a, Func<T, bool> b = null) { using (var c = a.GetEnumerator()) { while (c.MoveNext()) { if (b == null || b(c.Current)) { return c.Current; } } } return default(T); }
        public static List<T> ToList<T>(this IEnumerable<T> a, Func<T, bool> b = null) { var c = new List<T>(); using (var d = a.GetEnumerator()) { while (d.MoveNext()) { if (b == null || b(d.Current)) { c.Add(d.Current); } } } return c; }
        public static string[] ToLower(this IEnumerable<string> a, Func<string, bool> b = null) { var c = new List<string>(); using (var d = a.GetEnumerator()) { while (d.MoveNext()) { if (b == null || b(d.Current)) { c.Add(d.Current.ToLower()); } } } return c.ToArray(); }
        public static T[] Take<T>(this IList<T> a, int b) { var c = new List<T>(); for (int i = 0; i < a.Count; i++) { if (c.Count == b) { break; } c.Add(a[i]); } return c.ToArray(); }
        public static IEnumerable<V> Select<T, V>(this IEnumerable<T> a, Func<T, V> b) { var c = new List<V>(); using (var d = a.GetEnumerator()) { while (d.MoveNext()) { c.Add(b(d.Current)); } } return c; }
        public static T[] Where<T>(this IEnumerable<T> a, Func<T, bool> b) { var c = new List<T>(); using (var d = a.GetEnumerator()) { while (d.MoveNext()) { if (b(d.Current)) { c.Add(d.Current); } } } return c.ToArray(); }
        public static IEnumerable<T> OfType<T>(this IEnumerable<object> a) { foreach (object b in a) { if (b is T) { yield return (T)b; } } }
        public static float Sum<T>(this IEnumerable<T> a, Func<T, float> b) { float c = 0; if (a == null) return c; foreach (T d in a) { if (d == null) continue; c = checked(c + b(d)); } return c; }
        public static int Sum<T>(this IEnumerable<T> a, Func<T, int> b) { int c = 0; if (a == null) return c; foreach (T d in a) { if (d == null) continue; c = checked(c + b(d)); } return c; }
        public static bool IsKilled(this BaseNetworkable a) { return (object)a == null || a.IsDestroyed; }
        public static void ResetToPool<K, V>(this Dictionary<K, V> collection) { collection.Clear(); Pool.Free(ref collection); }
        public static void ResetToPool<T>(this HashSet<T> collection) { collection.Clear(); Pool.Free(ref collection); }
        public static void ResetToPool<T>(this List<T> collection) { collection.Clear(); Pool.Free(ref collection); }
    }
}

// --- End of file: AdminRadar.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/QuarryRefiner.cs ---
// --- Original Local Path: BeeRust/QuarryRefiner.cs ---

using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("QuarryRefiner", "Vlad-00003", "1.1.1")]
    [Description("Automatically smelts ores gathers by quarries and excavator")]
    /*
     * Author info:
     *   E-mail: Vlad-00003@mail.ru
     *   Vk: vk.com/vlad_00003
     */
    class QuarryRefiner : RustPlugin
    {
        #region Vars ‌﻿‌‍‍​‍

        private PluginConfig _config;
        private PluginData _data;
        private readonly Dictionary<ItemDefinition, ItemModCookable> _itemToCookable = new Dictionary<ItemDefinition, ItemModCookable>();
        private ItemDefinition _coal;

        #endregion

        #region Configuration ‌﻿‌‍‍​‍

        private class BaseConfig
        {
            [JsonProperty("Переплавлять ресурсы")]
            public bool Use;
            [JsonProperty("Привилегия, необходимая для автоматической переплавки")]
            public string Permission;

            [JsonIgnore]
            private Permission _permission;

            #region Default Config ‌﻿‌‍‍​‍

            public static BaseConfig DefaultConfig => new BaseConfig
            {
                Use = true,
                Permission = nameof(QuarryRefiner) + ".Excavator"
            };

            #endregion

            public void Register(QuarryRefiner plugin)
            {
                _permission = plugin.permission;
                _permission.RegisterPermission(Permission, plugin);
            }

            public bool ShouldTransmute(string userId)
            {
                return Use && (string.IsNullOrEmpty(Permission) || _permission.UserHasPermission(userId, Permission));
            }
        }

        private class QuarryConfig : BaseConfig
        {
            [JsonProperty("Определять наличие привилегии по владельцу (false - последний запустивший)")]
            public bool DefineByOwner;

            #region Default Config ‌﻿‌‍‍​‍

            public new static QuarryConfig DefaultConfig => new QuarryConfig
            {
                Use = true,
                Permission = nameof(QuarryRefiner) + ".Quarry",
                DefineByOwner = false
            };

            public static QuarryConfig DefaultOil => new QuarryConfig
            {
                Use = false,
                Permission = nameof(QuarryRefiner) + ".Oil",
                DefineByOwner = false
            };

            #endregion
        }

        private class PluginConfig
        {
            [JsonProperty("Настройки экскаваторов")]
            public BaseConfig ExcavatorConfig;
            [JsonProperty("Настройки карьеров")]
            public QuarryConfig QuarryConfig;
            [JsonProperty("Настройка нефтекачек")]
            public QuarryConfig OilConfig;

            #region Default Config ‌﻿‌‍‍​‍

            public static PluginConfig DefaultConfig => new PluginConfig
            {
                ExcavatorConfig = BaseConfig.DefaultConfig,
                QuarryConfig = QuarryConfig.DefaultConfig,
                OilConfig = QuarryConfig.DefaultOil
            };

            #endregion

            public void Register(QuarryRefiner plugin)
            {
                ExcavatorConfig.Register(plugin);
                QuarryConfig.Register(plugin);
                OilConfig.Register(plugin);
            }

        }

        #endregion

        #region Data ‌﻿‌‍‍​‍

        private class PluginData
        {
            [JsonProperty("Последние запускавшие")]
            public readonly Dictionary<ulong, string> QuarryOwners = new Dictionary<ulong, string>();

            public void Cleanup()
            {
                foreach (var quarry in QuarryOwners.Keys.ToArray())
                {
                    if (BaseNetworkable.serverEntities.Find(new NetworkableId(quarry)) == null)
                        QuarryOwners.Remove(quarry);
                }
            }
        }

        #endregion

        #region Config and Data Initialization ‌﻿‌‍‍​‍

        #region Data ‌﻿‌‍‍​‍

        private void LoadData()
        {
            try
            {
                _data = Interface.Oxide.DataFileSystem.ReadObject<PluginData>(Title);
            }
            catch (Exception ex)
            {
                PrintError($"Failed to load data (is the file corrupt?) - no previously created recycles would work ({ex.Message})");
                _data = new PluginData();
            }
            _data.Cleanup();
        }
        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(Title, _data);
        }

        #endregion

        #region Config ‌﻿‌‍‍​‍

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<PluginConfig>();
            }
            catch (Exception ex)
            {
                PrintError("Failed to load config file(is the config file corrupt ?)(" + ex.Message + ")");
            }
            if (ShouldUpdateConfig())
                SaveConfig();
            LoadData();
        }

        protected override void LoadDefaultConfig()
        {
            _config = PluginConfig.DefaultConfig;
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }

        private bool ShouldUpdateConfig()
        {
            if (Config["Настройка нефтекачек"] == null)
            {
                _config.OilConfig = QuarryConfig.DefaultOil;
                PrintWarning("New option was added, check your config file");
                return true;
            }

            return false;
        }

        #endregion

        #endregion

        #region Initialization and quitting ‌﻿‌‍‍​‍

        private void Init()
        {
            _config.Register(this);
        }


        private void OnServerInitialized(bool initial)
        {
            foreach (var itemDefinition in ItemManager.GetItemDefinitions())
            {
                var cookable = itemDefinition.GetComponent<ItemModCookable>();
                if (cookable)
                    _itemToCookable[itemDefinition] = cookable;
            }

            _coal = ItemManager.FindItemDefinition("charcoal");
        }
        private void Unload() => OnServerSave();

        private void OnServerSave() => SaveData();

        private void Loaded()
        {
            if (!_config.QuarryConfig.Use && !_config.OilConfig.Use)
            {
                Unsubscribe(nameof(OnQuarryGather));
                Unsubscribe(nameof(OnQuarryToggled));
            }

            if (!_config.ExcavatorConfig.Use)
            {
                Unsubscribe(nameof(OnExcavatorGather));
                Unsubscribe(nameof(OnExcavatorResourceSet));
            }
        }

        #endregion

        #region Oxide Hooks ‌﻿‌‍‍​‍
        void OnQuarryToggled(MiningQuarry quarry, BasePlayer player)
        {
            if (!player || !quarry || !quarry.IsOn())
                return;
            _data.QuarryOwners[quarry.net.ID.Value] = player.UserIDString;
        }
        void OnExcavatorResourceSet(ExcavatorArm arm, string resource, BasePlayer player)
        {
            if (!player || !arm)
                return;
            _data.QuarryOwners[arm.net.ID.Value] = player.UserIDString;
        }
        void OnQuarryGather(MiningQuarry quarry, Item item)
        {
            if (!quarry.canExtractLiquid)
            {
                if (_config.QuarryConfig.ShouldTransmute(GetQuarryOwner(quarry)))
                    Transmute(item);
                return;
            }

            if (_config.OilConfig.ShouldTransmute(GetQuarryOwner(quarry)))
                Transmute(item);
        }

        void OnExcavatorGather(ExcavatorArm arm, Item item)
        {
            if (_config.ExcavatorConfig.ShouldTransmute(GetQuarryOwner(arm)))
                Transmute(item);
        }

        #endregion

        #region Helpers‌﻿‌‍‍​‍
        public string GetQuarryOwner(BaseEntity quarry)
        {
            string owner;
            if (quarry is MiningQuarry)
            {
                if (!_config.QuarryConfig.DefineByOwner)
                    return _data.QuarryOwners.TryGetValue(quarry.net.ID.Value, out owner) ? owner : "0";
                if (quarry.OwnerID != 0)
                    return quarry.OwnerID.ToString();
                return _data.QuarryOwners.TryGetValue(quarry.net.ID.Value, out owner) ? owner : "0";
            }

            if (quarry.OwnerID != 0 || !_data.QuarryOwners.TryGetValue(quarry.net.ID.Value, out owner))
                owner = quarry.OwnerID.ToString();
            return owner;
        }

        private void Transmute(Item item)
        {
            if (item.info.shortname == "wood")
            {
                item.info = _coal;
                return;
            }

            if (!_itemToCookable.ContainsKey(item.info))
                return;
            var cookable = _itemToCookable[item.info];
            item.info = cookable.becomeOnCooked;
            item.amount *= cookable.amountOfBecome;
        }
        #endregion
    }
}


// --- End of file: QuarryRefiner.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/PreferredEnvironment.cs ---
// --- Original Local Path: BeeRust/PreferredEnvironment.cs ---

﻿using Facepunch;
using Network;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Globalization;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("PreferredEnvironment", "Discord.gg/TrqrzFZzRf", "2.0.12")]
    [Description("Allows players to customize their environment settings, or create presets that apply to specified zones")]
    public class PreferredEnvironment : RustPlugin
    {
        private const string PERMISSION_USE = "preferredenvironment.use";
        private const string PERMISSION_ADMIN = "preferredenvironment.admin";

        private const string WEATHER_VAR_FILTER = "weather.";

        private Dictionary<ulong, EnvironmentInfo> userEnvironmentInfo = new Dictionary<ulong, EnvironmentInfo>();
        private DynamicConfigFile userData;

        private static Hash<string, ConsoleSystem.Command> weatherConvars;

        private bool initialized = false;

        #region Oxide
        private void Init()
        {
            permission.RegisterPermission(PERMISSION_USE, this);
            permission.RegisterPermission(PERMISSION_ADMIN, this);

            if (!permission.PermissionExists(configData.TimePermission))
                permission.RegisterPermission(configData.TimePermission, this);

            if (!permission.PermissionExists(configData.WeatherPermission))
                permission.RegisterPermission(configData.WeatherPermission, this);

            SetWeatherVars();

            ConsoleSystem.OnReplicatedVarChanged += OnReplicatedVarChanged;
            
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Error.NoPermission"] = "You are not allowed to use this command",
                ["Error.NoTimeVar"] = "You must enter a number between 0.0 and 24.0 (-1 to disable)",
                ["Notification.WeatherDisabled"] = "Custom weather has been disabled",
                ["Notification.TimeDisabled"] = "Custom time has been disabled",
                ["Notification.HasZoneOverride"] = "You currently can not edit time/weather settings as you are in a zone override",
                ["Notification.AdminOverride"] = "A admin has set your environment variable \"{0}\" to \"{1}\"",
                ["Notification.SetTime"] = "You have set the time to {0}",
                ["Weather.Fog"] = "Fog",
                ["Weather.Rain"] = "Rain",
                ["Weather.Rainbow"] = "Rainbow",
                ["Weather.Thunder"] = "Thunder",
                ["Weather.Wind"] = "Wind",
                ["Weather.AtmosphereBrightness"] = "Atmosphere Brightness",
                ["Weather.AtmosphereContrast"] = "Atmosphere Contrast",
                ["Weather.AtmosphereDirectionality"] = "Atmosphere Directionality",
                ["Weather.AtmosphereMie"] = "Atmosphere Mie",
                ["Weather.AtmosphereRayleigh"] = "Atmosphere Rayleigh",
                ["Weather.CloudAttenuation"] = "Cloud Attenuation",
                ["Weather.CloudBrightness"] = "Cloud Brightness",
                ["Weather.CloudColoring"] = "Cloud Coloring",
                ["Weather.CloudCoverage"] = "Cloud Coverage",
                ["Weather.CloudOpacity"] = "Cloud Opacity",
                ["Weather.CloudSaturation"] = "Cloud Saturation",
                ["Weather.CloudScattering"] = "Cloud Scattering",
                ["Weather.CloudSharpness"] = "Cloud Sharpness",
                ["Weather.CloudSize"] = "Cloud Size",
                ["Weather.ClearChance"] = "Clear Chance",
                ["Weather.DustChance"] = "Dust Chance",
                ["Weather.FogChance"] = "Fog Chance",
                ["Weather.OvercastChance"] = "Overcast Chance",
                ["Weather.RainChance"] = "Rain Chance",
                ["Weather.StormChance"] = "Storm Chance",
                ["Weather.ProgressTime"] = "Progress Time",
                ["Menu.EnviromentEditor"] = "Environment Editor",
                ["Menu.TimeEditor"] = "Time Editor",
                ["Menu.ServerEnviromentEditor"] = "Server Environment Editor",
                ["Menu.ServerTimeEditor"] = "Server Time Editor",
                ["Menu.Reset"] = "Reset",
                ["Menu.ServerSet"] = "Use Server Value",
                ["Menu.Automated"] = "Automated"
            },
            this);

            if (configData.EnableSaving)
                LoadData();
            else Unsubscribe(nameof(OnServerSave));
        }

        private void OnServerInitialized()
        {
            initialized = true;

            LoadServerVars();

            foreach (BasePlayer player in BasePlayer.activePlayerList)
                OnPlayerConnected(player);
        }

        private void OnServerSave() => userData.WriteObject(userEnvironmentInfo);

        private void OnPlayerConnected(BasePlayer player) => player.Invoke(()=> DelayedEnvironmentUpdate(player), 1f);

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            EnvironmentInfo environmentInfo;
            if (userEnvironmentInfo.TryGetValue(player.userID, out environmentInfo))
            {
                if (environmentInfo.ShouldRemove())
                    userEnvironmentInfo.Remove(player.userID);
            }         
        }

        private void OnUserPermissionRevoked(string id, string permission)
        {
            if (permission.Equals(PERMISSION_USE))
            {
                ulong playerId = ulong.Parse(id);

                EnvironmentInfo environmentInfo;
                if (userEnvironmentInfo.TryGetValue(playerId, out environmentInfo))
                {
                    if (!environmentInfo.HasZoneOverride())
                    {                        
                        SendServerReplicatedVars(FindPlayer(id));                         
                        userEnvironmentInfo.Remove(playerId);
                    }
                }
            }
        }

        private object CanNetworkTo(EnvSync env, BasePlayer player)
        {
            EnvironmentInfo environmentInfo;
            if (!userEnvironmentInfo.TryGetValue(player.userID, out environmentInfo) || environmentInfo.GetDesiredTime < 0f)
                return null;

            NetWrite netWrite = Net.sv.StartWrite();

            Connection connection = player.net.connection;
            connection.validate.entityUpdates = connection.validate.entityUpdates + 1;
            BaseNetworkable.SaveInfo saveInfo = new BaseNetworkable.SaveInfo
            {
                forConnection = player.net.connection,
                forDisk = false
            };

            netWrite.PacketID(Message.Type.Entities);
            netWrite.UInt32(player.net.connection.validate.entityUpdates);

            using (saveInfo.msg = Pool.Get<ProtoBuf.Entity>())
            {
                env.Save(saveInfo);

                float desiredTime = environmentInfo.GetDesiredTime;

                TOD_CycleParameters time = TOD_Sky.Instance.Cycle;

                DateTime dateTime = new DateTime(0L, DateTimeKind.Utc);

                dateTime = dateTime.AddYears(time.Year - 1);
                dateTime = dateTime.AddMonths(time.Month - 1);
                dateTime = dateTime.AddDays(time.Day - 1);

                int hours = Mathf.FloorToInt(desiredTime);
                dateTime = dateTime.AddHours(hours);
                dateTime = dateTime.AddMinutes(((Mathf.Round(desiredTime * 100) / 100) - hours) * 60);

                saveInfo.msg.environment.dateTime = dateTime.ToBinary();

                saveInfo.msg.ToProto(netWrite);
                netWrite.Send(new SendInfo(player.net.connection));
            }

            return false;
        }

        private void OnServerCommand(string cmd, string[] args)
        {
            if (cmd.StartsWith(WEATHER_VAR_FILTER, StringComparison.OrdinalIgnoreCase))
                SendReplicatedVarsAll();            
        }

        private void Unload()
        {
            ConsoleSystem.OnReplicatedVarChanged -= OnReplicatedVarChanged;

            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, UI_MENU);
                CuiHelper.DestroyUi(player, UI_DUMMY);
            }

            weatherConvars = null;

            if (initialized)
                ServerMgr.SendReplicatedVars(WEATHER_VAR_FILTER);
        }
        #endregion

        #region Functions        
        private void LoadData()
        {
            userData = Interface.Oxide.DataFileSystem.GetFile("preferred_environment");

            userEnvironmentInfo = userData.ReadObject<Dictionary<ulong, EnvironmentInfo>>();            
        }

        private void LoadServerVars()
        {
            if (configData.Server._clearChance != -1)
                ConVar.Weather.clear_chance = configData.Server._clearChance;

            if (configData.Server._dustChance != -1)
                ConVar.Weather.dust_chance = configData.Server._dustChance;

            if (configData.Server._fogChance != -1)
                ConVar.Weather.fog_chance = configData.Server._fogChance;

            if (configData.Server._overcastChance != -1)
                ConVar.Weather.overcast_chance = configData.Server._overcastChance;

            if (configData.Server._rainChance != -1)
                ConVar.Weather.rain_chance = configData.Server._rainChance;

            if (configData.Server._stormChance != -1)
                ConVar.Weather.storm_chance = configData.Server._stormChance;

            if (configData.Server._atmosphere_brightness != -1)
                ConVar.Weather.atmosphere_brightness = configData.Server._atmosphere_brightness;

            if (configData.Server._atmosphere_contrast != -1)
                ConVar.Weather.atmosphere_contrast = configData.Server._atmosphere_contrast;

            if (configData.Server._atmosphere_directionality != -1)
                ConVar.Weather.atmosphere_directionality = configData.Server._atmosphere_directionality;

            if (configData.Server._atmosphere_mie != -1)
                ConVar.Weather.atmosphere_mie = configData.Server._atmosphere_mie;

            if (configData.Server._atmosphere_rayleigh != -1)
                ConVar.Weather.atmosphere_rayleigh = configData.Server._atmosphere_rayleigh;

            if (configData.Server._cloud_attenuation != -1)
                ConVar.Weather.cloud_attenuation = configData.Server._cloud_attenuation;

            if (configData.Server._cloud_brightness != -1)
                ConVar.Weather.cloud_brightness = configData.Server._cloud_brightness;

            if (configData.Server._cloud_coloring != -1)
                ConVar.Weather.cloud_coloring = configData.Server._cloud_coloring;

            if (configData.Server._cloud_coverage != -1)
                ConVar.Weather.cloud_coverage = configData.Server._cloud_coverage;

            if (configData.Server._cloud_opacity != -1)
                ConVar.Weather.cloud_opacity = configData.Server._cloud_opacity;

            if (configData.Server._cloud_saturation != -1)
                ConVar.Weather.cloud_saturation = configData.Server._cloud_saturation;

            if (configData.Server._cloud_scattering != -1)
                ConVar.Weather.cloud_scattering = configData.Server._cloud_scattering;

            if (configData.Server._cloud_sharpness != -1)
                ConVar.Weather.cloud_sharpness = configData.Server._cloud_sharpness;

            if (configData.Server._cloud_size != -1)
                ConVar.Weather.cloud_size = configData.Server._cloud_size;

            ConVar.Env.progresstime = configData.Server._progressTime;
        }

        private void SetWeatherVars()
        {
            weatherConvars = new Hash<string, ConsoleSystem.Command>();

            foreach (ConsoleSystem.Command replicated in ConsoleSystem.Index.Server.Replicated)
            {
                if (replicated.FullName.StartsWith(WEATHER_VAR_FILTER))
                    weatherConvars.Add(replicated.FullName, replicated);
            }
        }

        private void DelayedEnvironmentUpdate(BasePlayer player)
        {
            if (player != null && player.IsConnected)
            {
                EnvironmentInfo environmentInfo;
                if (userEnvironmentInfo.TryGetValue(player.userID, out environmentInfo))
                {
                    environmentInfo.BuildReplicatedConvarList();

                    if (!permission.UserHasPermission(player.UserIDString, PERMISSION_USE) || environmentInfo.ShouldRemove())
                    {
                        SendServerReplicatedVars(player);
                        userEnvironmentInfo.Remove(player.userID);
                    }
                    else environmentInfo.SendCustomReplicatedVars(player);
                }
            }
        }

        private void OnReplicatedVarChanged(string command, string value)
        {
            if (command.StartsWith(WEATHER_VAR_FILTER, StringComparison.OrdinalIgnoreCase))            
                SendReplicatedVarsAll();            
        }

        private void SendReplicatedVarsAll()
        {
            if (initialized)
                ServerMgr.Instance.StartCoroutine(SendReplicatedVarsAllEnumerator());
        }
        
        private IEnumerator SendReplicatedVarsAllEnumerator()
        {
            List<BasePlayer> list = Pool.GetList<BasePlayer>();
            list.AddRange(BasePlayer.activePlayerList);

            for (int i = 0; i < list.Count; i++)
            {
                BasePlayer player = list[i];

                if (player == null || !player.IsConnected)
                    continue;

                EnvironmentInfo environmentInfo;
                if (userEnvironmentInfo.TryGetValue(player.userID, out environmentInfo))
                    environmentInfo.SendCustomReplicatedVars(player);
                else SendServerReplicatedVars(player);
                
                yield return null;
                yield return null;
            }

            Pool.FreeList(ref list);
        }

        public void SendServerReplicatedVars(BasePlayer player)
        {
            if (!player || !player.IsConnected)
                return;

            NetWrite netWrite = Net.sv.StartWrite();
            netWrite.PacketID(Message.Type.ConsoleReplicatedVars);
            netWrite.Int32(weatherConvars.Count);

            foreach (KeyValuePair<string, ConsoleSystem.Command> kvp in weatherConvars)
            {
                netWrite.String(kvp.Key);
                netWrite.String(kvp.Value.String);
            }

            netWrite.Send(new SendInfo(player.net.connection));
        }

        #endregion

        #region Console Commands
        [ConsoleCommand("setenv")]
        private void ccmdSetEnvironment(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null)
            {
                if (!permission.UserHasPermission(arg.Connection.userid.ToString(), PERMISSION_ADMIN))
                {
                    SendReply(arg, "You do not have permission to use this command");
                    return;
                }
            }

            if (arg.Args == null || arg.Args.Length < 3)
            {
                SendReply(arg, "\n\nsetenv <name or id> <variable> <value> - Manually set an environment variable for the target player\n\nEnvironment variables;\nfog (0.0 - 1.0)\nrain (0.0 - 1.0)\nrainbow  (0.0 - 1.0)\nthunder (0.0 - 1.0)\nwind (0.0 - 1.0)\natmosphere_brightness (0.0 - 1.0)\natmosphere_contrast (0.0 - 1.0)\natmosphere_directionality (0.0 - 1.0)\natmosphere_mie (0.0 - 1.0)\natmosphere_rayleigh (0.0 - 1.0)\ncloud_attenuation (0.0 - 1.0)\ncloud_brightness (0.0 - 1.0)\ncloud_coloring (0.0 - 1.0)\ncloud_coverage (0.0 - 1.0)\ncloud_opacity (0.0 - 1.0)\ncloud_saturation (0.0 - 1.0)\ncloud_scattering (0.0 - 1.0)\ncloud_sharpness (0.0 - 1.0)\ncloud_size\n\ntime (0.0-24.0)\n\nTo disable any of these variables set the value to '-1'");
                return;
            }

            BasePlayer player = FindPlayer(arg.GetString(0));
            if (player == null)
            {
                SendReply(arg, $"Unable to find a player with the name or ID \"{arg.GetString(0)}\"");
                return;
            }

            string variable = arg.GetString(1);
            float value = arg.GetFloat(2);

            EnvironmentInfo environmentInfo;
            if (!userEnvironmentInfo.TryGetValue(player.userID, out environmentInfo))
            {
                userEnvironmentInfo.Add(player.userID, new EnvironmentInfo());
            }

            switch (variable)
            {
                case "fog":
                    environmentInfo.Fog = value;
                    break;
                case "rain":
                    environmentInfo.Rain = value;
                    break;
                case "rainbow":
                    environmentInfo.Rainbow = value;
                    break;
                case "thunder":
                    environmentInfo.Thunder = value;
                    break;
                case "wind":
                    environmentInfo.Wind = value;
                    break;
                case "atmosphere_brightness":
                    environmentInfo.AtmosphereBrightness = value;
                    break;
                case "atmosphere_contrast":
                    environmentInfo.AtmosphereContrast = value;
                    break;
                case "atmosphere_directionality":
                    environmentInfo.AtmosphereDirectionality = value;
                    break;
                case "atmosphere_mie":
                    environmentInfo.AtmosphereMie = value;
                    break;
                case "atmosphere_rayleigh":
                    environmentInfo.AtmosphereRayleigh = value;
                    break;
                case "cloud_attenuation":
                    environmentInfo.CloudAttenuation = value;
                    break;
                case "cloud_brightness":
                    environmentInfo.CloudBrightness = value;
                    break;
                case "cloud_coloring":
                    environmentInfo.CloudColoring = value;
                    break;
                case "cloud_coverage":
                    environmentInfo.CloudCoverage = value;
                    break;
                case "cloud_opacity":
                    environmentInfo.CloudOpacity = value;
                    break;
                case "cloud_saturation":
                    environmentInfo.CloudSaturation = value;
                    break;
                case "cloud_scattering":
                    environmentInfo.CloudScattering = value;
                    break;
                case "cloud_sharpness":
                    environmentInfo.CloudSharpness = value;
                    break;
                case "cloud_size":
                    environmentInfo.CloudSize = value;
                    break;
                case "time":
                    environmentInfo.Time = value;
                    break;
                default:
                    SendReply(arg, "Invalid variable selected!");
                    return;
            }

            SendReply(arg, $"Set environment variable \"{variable}\" to \"{value}\" for player {player.displayName}");

            SendReply(player, string.Format(_msg("Notification.AdminOverride", player.UserIDString), variable, value));

            environmentInfo.BuildReplicatedConvarList();

            if (environmentInfo.ShouldRemove())
            {
                SendServerReplicatedVars(player);
                userEnvironmentInfo.Remove(player.userID);
            }
            else environmentInfo.SendCustomReplicatedVars(player);
        }

        private BasePlayer FindPlayer(string partialNameOrID) => BasePlayer.allPlayerList.FirstOrDefault<BasePlayer>((BasePlayer x) => x.displayName.Equals(partialNameOrID, StringComparison.OrdinalIgnoreCase)) ??
                                                                 BasePlayer.allPlayerList.FirstOrDefault<BasePlayer>((BasePlayer x) => x.displayName.Contains(partialNameOrID, CompareOptions.OrdinalIgnoreCase)) ??
                                                                 BasePlayer.allPlayerList.FirstOrDefault<BasePlayer>((BasePlayer x) => x.UserIDString == partialNameOrID);
        #endregion

        private string _msg(string key, string id = null)
        {
            return lang.GetMessage(key, this, id);
        }

        #region ZoneManager
        private void OnEnterZone(string zoneID, BasePlayer player)
        {
            EnvironmentInfo zoneEnvironmentInfo;

            if (!configData.Zones.TryGetValue(zoneID, out zoneEnvironmentInfo))
                return;

            EnvironmentInfo environmentInfo;
            if (!userEnvironmentInfo.TryGetValue(player.userID, out environmentInfo))
            {
                userEnvironmentInfo.Add(player.userID, environmentInfo = new EnvironmentInfo());
            }

            environmentInfo.OnEnterZone(zoneID, zoneEnvironmentInfo);
            zoneEnvironmentInfo.SendCustomReplicatedVars(player);
        }

        private void OnExitZone(string zoneID, BasePlayer player)
        {
            if (!configData.Zones.ContainsKey(zoneID))
                return;

            EnvironmentInfo environmentInfo;
            if (userEnvironmentInfo.TryGetValue(player.userID, out environmentInfo))
            {
                environmentInfo.OnExitZone(zoneID, player);

                if (environmentInfo.ShouldRemove() || (!environmentInfo.HasZoneOverride() && !permission.UserHasPermission(player.UserIDString, PERMISSION_USE)))
                {
                    SendServerReplicatedVars(player);
                    userEnvironmentInfo.Remove(player.userID);
                }
                else environmentInfo.SendCustomReplicatedVars(player);
            }
        }
        #endregion

        #region UI         
        public static class UI
        {
            public static CuiElementContainer Container(string panelName, string color, UI4 dimensions, bool useCursor = false, string parent = "Overlay")
            {
                CuiElementContainer container = new CuiElementContainer()
                {
                    {
                        new CuiPanel
                        {
                            Image = {Color = color},
                            RectTransform = {AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax()},
                            CursorEnabled = useCursor
                        },
                        new CuiElement().Parent = parent,
                        panelName.ToString()
                    }
                };
                return container;
            }

            public static CuiElementContainer BlurContainer(string panelName, UI4 dimensions, string color = "0 0 0 0.55", string parent = "Overlay")
            {
                CuiElementContainer container = new CuiElementContainer()
                {
                    {
                        new CuiPanel
                        {
                            Image = {Color = color, Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat"},
                            RectTransform = {AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax()},
                            CursorEnabled = true
                        },
                        new CuiElement().Parent = parent,
                        panelName.ToString()
                    }
                };
                return container;
            }

            public static void Panel(ref CuiElementContainer container, string panel, string color, UI4 dimensions, bool cursor = false)
            {
                container.Add(new CuiPanel
                {
                    Image = { Color = color },
                    RectTransform = { AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() },
                    CursorEnabled = cursor
                },
                panel.ToString());
            }

            public static void BlurPanel(ref CuiElementContainer container, string panel, UI4 dimensions, string color = "0 0 0 0.5")
            {
                container.Add(new CuiPanel
                {
                    Image = { Color = color, Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                    RectTransform = { AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() },
                    CursorEnabled = false
                },
                panel, CuiHelper.GetGuid());
            }

            public static void Label(ref CuiElementContainer container, string panel, string text, int size, UI4 dimensions, TextAnchor align = TextAnchor.MiddleCenter, FontStyle fontStyle = FontStyle.RobotoCondensed)
            {
                container.Add(new CuiLabel
                {
                    Text = { FontSize = size, Align = align, Text = text, Font = ToFontString(fontStyle) },
                    RectTransform = { AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() }
                },
                panel.ToString());

            }

            public static void Button(ref CuiElementContainer container, string panel, string color, string text, int size, UI4 dimensions, string command, TextAnchor align = TextAnchor.MiddleCenter, FontStyle fontStyle = FontStyle.RobotoCondensed)
            {
                container.Add(new CuiButton
                {
                    Button = { Color = color, Command = command, FadeIn = 0f },
                    RectTransform = { AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() },
                    Text = { Text = text, FontSize = size, Align = align, Font = ToFontString(fontStyle) }
                },
                panel.ToString());
            }

            internal static void Toggle(ref CuiElementContainer container, string panel, string color, int fontSize, UI4 dimensions, string command, bool isOn)
            {
                UI.Panel(ref container, panel, color, dimensions);

                if (isOn)
                    UI.Label(ref container, panel, "✔", fontSize, dimensions);

                UI.Button(ref container, panel, "0 0 0 0", string.Empty, 0, dimensions, command);
            }

            public static void Image(ref CuiElementContainer container, string panel, string png, UI4 dimensions)
            {
                container.Add(new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = panel,
                    Components =
                    {
                        new CuiRawImageComponent { Png = png },
                        new CuiRectTransformComponent { AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() }
                    }
                });
            }

            public static void Input(ref CuiElementContainer container, string panel, string text, int size, string command, UI4 dimensions)
            {
                container.Add(new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = panel,
                    Components =
                    {
                        new CuiInputFieldComponent
                        {
                            Align = TextAnchor.MiddleLeft,
                            CharsLimit = 300,
                            Command = command,
                            FontSize = size,
                            IsPassword = false,
                            Text = text
                        },
                        new CuiRectTransformComponent {AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() }
                    }
                });
            }

            public static string Color(string hexColor, float alpha)
            {
                if (hexColor.StartsWith("#"))
                    hexColor = hexColor.Substring(1);
                int red = int.Parse(hexColor.Substring(0, 2), NumberStyles.AllowHexSpecifier);
                int green = int.Parse(hexColor.Substring(2, 2), NumberStyles.AllowHexSpecifier);
                int blue = int.Parse(hexColor.Substring(4, 2), NumberStyles.AllowHexSpecifier);
                return $"{(double)red / 255} {(double)green / 255} {(double)blue / 255} {alpha}";
            }

            public enum FontStyle { DroidSansMono, RobotoCondensed, RobotoCondensedBold, PermanantMarker }

            private static string ToFontString(FontStyle fontStyle)
            {
                switch (fontStyle)
                {
                    case FontStyle.DroidSansMono:
                        return "droidsansmono.ttf";
                    case FontStyle.PermanantMarker:
                        return "permanentmarker.ttf";
                    case FontStyle.RobotoCondensed:
                        return "robotocondensed-regular.ttf";
                    case FontStyle.RobotoCondensedBold:
                    default:
                        return "robotocondensed-bold.ttf";
                }
            }
        }

        public class UI4
        {
            [JsonProperty(PropertyName = "Left (0.0 - 1.0)")]
            public float xMin;

            [JsonProperty(PropertyName = "Bottom (0.0 - 1.0)")]
            public float yMin;

            [JsonProperty(PropertyName = "Right (0.0 - 1.0)")]
            public float xMax;

            [JsonProperty(PropertyName = "Top (0.0 - 1.0)")]
            public float yMax;

            public UI4(float xMin, float yMin, float xMax, float yMax)
            {
                this.xMin = xMin;
                this.yMin = yMin;
                this.xMax = xMax;
                this.yMax = yMax;
            }

            public string GetMin() => $"{xMin} {yMin}";
            public string GetMax() => $"{xMax} {yMax}";

            public static UI4 zero = new UI4(0f, 0f, 0f, 0f);
        }
        #endregion

        #region UI Creation
        private const string UI_MENU = "pe.menu";
        private const string UI_DUMMY = "pe.dummy";

        private void OpenDummyContainer(BasePlayer player)
        {
            CuiElementContainer container = UI.BlurContainer(UI_DUMMY, UI4.zero);
            CuiHelper.DestroyUi(player, UI_DUMMY);
            CuiHelper.AddUi(player, container);
        }

        private void OpenEnvironmentEditor(BasePlayer player, EnvironmentInfo environmentInfo)
        {
            bool hasWeatherPerm = permission.UserHasPermission(player.UserIDString, configData.WeatherPermission);
            bool hasTimePerm = permission.UserHasPermission(player.UserIDString, configData.TimePermission);

            if (!hasWeatherPerm && hasTimePerm)
            {
                CuiElementContainer container = UI.BlurContainer(UI_MENU, new UI4(0.35f, 0.53f, 0.65f, 0.6f));
                UI.BlurPanel(ref container, UI_MENU, new UI4(0f, 0.5f, 1f, 1f), UI.Color("000000", 0.7f));
                UI.Label(ref container, UI_MENU, _msg("Menu.TimeEditor", player.UserIDString), 16, new UI4(0.01f, 0.55f, 0.95f, 0.95f), TextAnchor.MiddleLeft, UI.FontStyle.RobotoCondensedBold);
                UI.Button(ref container, UI_MENU, UI.Color("d85540", 1f), _msg("Menu.Reset", player.UserIDString), 12, new UI4(0.85f, 0.55f, 0.95f, 0.95f), "pe.reset");
                UI.Button(ref container, UI_MENU, UI.Color("d85540", 1f), "✘", 12, new UI4(0.955f, 0.55f, 0.995f, 0.95f), "pe.closeui");

                UI.BlurPanel(ref container, UI_MENU, new UI4(0f, 0.05f, 1f, 0.45f), UI.Color("000000", 0.7f));
                UI.Button(ref container, UI_MENU, UI.Color("6a8b38", 1f), "-", 14, new UI4(0.015f, 0.05f, 0.055f, 0.45f), $"pe.editvalue time {(environmentInfo.Time <= 0 ? -1f : Mathf.Clamp(environmentInfo.Time - 0.5f, 0f, 24f))}");

                if (environmentInfo.Time > 0f)
                    UI.Panel(ref container, UI_MENU, UI.Color("387097", 1f), new UI4(0.06f, 0.05f, 0.06f + ((0.95f - 0.06f) * (environmentInfo.Time / 24f)), 0.45f));

                if (environmentInfo.Time < 0f)
                    UI.Label(ref container, UI_MENU, _msg("Menu.ServerSet", player.UserIDString), 12, new UI4(0.06f, 0.05f, 0.95f, 0.45f), TextAnchor.MiddleCenter);
                else UI.Label(ref container, UI_MENU, $"{environmentInfo.Time}", 12, new UI4(0.06f, 0.05f, 0.95f, 0.45f), TextAnchor.MiddleCenter);

                float progressWidth = (0.95f - 0.06f) * 0.05f;

                for (int i = 0; i < 20; i++)
                {
                    float left = 0.06f + (progressWidth * i);
                    float right = left + progressWidth;

                    UI.Button(ref container, UI_MENU, "0 0 0 0", string.Empty, 0, new UI4(left, 0.05f, right, 0.45f), $"pe.editvalue time {(i + 1) * 1.2f}");
                }

                UI.Button(ref container, UI_MENU, UI.Color("6a8b38", 1f), "+", 14, new UI4(0.955f, 0.05f, 0.995f, 0.45f), $"pe.editvalue time {(environmentInfo.Time < 0f ? 0f : Mathf.Clamp(0.5f + environmentInfo.Time, 0f, 24f))}");

                CuiHelper.DestroyUi(player, UI_MENU);
                CuiHelper.AddUi(player, container);
            }
            else if (hasWeatherPerm)
            {
                float totalSize = hasWeatherPerm && hasTimePerm ? 22f : hasWeatherPerm ? 20f : hasTimePerm ? 2f : 22f;

                CuiElementContainer container = UI.BlurContainer(UI_MENU, new UI4(0.35f, 0.19f, 0.65f, 0.8f));

                float size = 1f / totalSize;
                int count = 0;

                UI.BlurPanel(ref container, UI_MENU, new UI4(0f, 1f - (count * size) - size, 1f, 1f - (count * size)), UI.Color("000000", 0.7f));
                UI.Label(ref container, UI_MENU, _msg("Menu.EnviromentEditor", player.UserIDString), 16, new UI4(0.01f, 1f - (count * size) - size, 0.95f, 1f - (count * size)), TextAnchor.MiddleLeft, UI.FontStyle.RobotoCondensedBold);
                UI.Button(ref container, UI_MENU, UI.Color("d85540", 1f), _msg("Menu.Reset", player.UserIDString), 12, new UI4(0.85f, (1f - (count * size) - size) + 0.005f, 0.95f, 1f - (count * size) - 0.005f), "pe.reset");
                UI.Button(ref container, UI_MENU, UI.Color("d85540", 1f), "✘", 12, new UI4(0.955f, (1f - (count * size) - size) + 0.005f, 0.995f, 1f - (count * size) - 0.005f), "pe.closeui");
                count++;

                UI.BlurPanel(ref container, UI_MENU, new UI4(0f, 1f - (20 * size), 0.4f, 1f - (count * size) - 0.005f), UI.Color("000000", 0.7f));

                UI.BlurPanel(ref container, UI_MENU, new UI4(0.405f, 1f - (20 * size), 1f, 1f - (count * size) - 0.005f), UI.Color("000000", 0.7f));

                AddMenuOption(ref container, _msg("Weather.Fog", player.UserIDString), "fog", environmentInfo.Fog, count, size, player.UserIDString);
                count++;

                AddMenuOption(ref container, _msg("Weather.Rain", player.UserIDString), "rain", environmentInfo.Rain, count, size, player.UserIDString);
                count++;

                AddMenuOption(ref container, _msg("Weather.Rainbow", player.UserIDString), "rainbow", environmentInfo.Rainbow, count, size, player.UserIDString);
                count++;

                AddMenuOption(ref container, _msg("Weather.Thunder", player.UserIDString), "thunder", environmentInfo.Thunder, count, size, player.UserIDString);
                count++;

                AddMenuOption(ref container, _msg("Weather.Wind", player.UserIDString), "wind", environmentInfo.Wind, count, size, player.UserIDString);
                count++;

                AddMenuOption(ref container, _msg("Weather.AtmosphereBrightness", player.UserIDString), "atmosphere_brightness", environmentInfo.AtmosphereBrightness, count, size, player.UserIDString);
                count++;

                AddMenuOption(ref container, _msg("Weather.AtmosphereContrast", player.UserIDString), "atmosphere_contrast", environmentInfo.AtmosphereContrast, count, size, player.UserIDString);
                count++;

                AddMenuOption(ref container, _msg("Weather.AtmosphereDirectionality", player.UserIDString), "atmosphere_directionality", environmentInfo.AtmosphereDirectionality, count, size, player.UserIDString);
                count++;

                AddMenuOption(ref container, _msg("Weather.AtmosphereMie", player.UserIDString), "atmosphere_mie", environmentInfo.AtmosphereMie, count, size, player.UserIDString);
                count++;

                AddMenuOption(ref container, _msg("Weather.AtmosphereRayleigh", player.UserIDString), "atmosphere_rayleigh", environmentInfo.AtmosphereRayleigh, count, size, player.UserIDString);
                count++;

                AddMenuOption(ref container, _msg("Weather.CloudAttenuation", player.UserIDString), "cloud_attenuation", environmentInfo.CloudAttenuation, count, size, player.UserIDString);
                count++;

                AddMenuOption(ref container, _msg("Weather.CloudBrightness", player.UserIDString), "cloud_brightness", environmentInfo.CloudBrightness, count, size, player.UserIDString);
                count++;

                AddMenuOption(ref container, _msg("Weather.CloudColoring", player.UserIDString), "cloud_coloring", environmentInfo.CloudColoring, count, size, player.UserIDString);
                count++;

                AddMenuOption(ref container, _msg("Weather.CloudCoverage", player.UserIDString), "cloud_coverage", environmentInfo.CloudCoverage, count, size, player.UserIDString);
                count++;

                AddMenuOption(ref container, _msg("Weather.CloudOpacity", player.UserIDString), "cloud_opacity", environmentInfo.CloudOpacity, count, size, player.UserIDString);
                count++;

                AddMenuOption(ref container, _msg("Weather.CloudSaturation", player.UserIDString), "cloud_saturation", environmentInfo.CloudSaturation, count, size, player.UserIDString);
                count++;

                AddMenuOption(ref container, _msg("Weather.CloudScattering", player.UserIDString), "cloud_scattering", environmentInfo.CloudScattering, count, size, player.UserIDString);
                count++;

                AddMenuOption(ref container, _msg("Weather.CloudSharpness", player.UserIDString), "cloud_sharpness", environmentInfo.CloudSharpness, count, size, player.UserIDString);
                count++;

                AddMenuOption(ref container, _msg("Weather.CloudSize", player.UserIDString), "cloud_size", environmentInfo.CloudSize, count, size, player.UserIDString);
                count++;

                if (hasTimePerm)
                {
                    UI.BlurPanel(ref container, UI_MENU, new UI4(0f, 1f - (count * size) - size, 1f, 1f - (count * size) - 0.005f), UI.Color("000000", 0.7f));
                    UI.Label(ref container, UI_MENU, _msg("Menu.TimeEditor", player.UserIDString), 16, new UI4(0.01f, 1f - (count * size) - size, 0.95f, 1f - (count * size)), TextAnchor.MiddleLeft, UI.FontStyle.RobotoCondensedBold);
                    count++;

                    UI.BlurPanel(ref container, UI_MENU, new UI4(0f, 1f - (count * size) - size, 1f, 1f - (count * size) - 0.005f), UI.Color("000000", 0.7f));
                    AddTimeOption(ref container, environmentInfo.Time, count, size, player.UserIDString);
                    count++;
                }

                CuiHelper.DestroyUi(player, UI_MENU);
                CuiHelper.AddUi(player, container);
            }           
        }

        private void OpenServerEnvironmentEditor(BasePlayer player)
        {
            CuiElementContainer container = UI.BlurContainer(UI_MENU, new UI4(0.35f, 0.02f, 0.65f, 0.96f));

            float size = 1f / 29f;
            int count = 0;

            UI.BlurPanel(ref container, UI_MENU, new UI4(0f, 1f - (count * size) - size, 1f, 1f - (count * size)), UI.Color("000000", 0.7f));
            UI.Label(ref container, UI_MENU, _msg("Menu.ServerEnviromentEditor", player.UserIDString), 16, new UI4(0.01f, 1f - (count * size) - size, 0.95f, 1f - (count * size)), TextAnchor.MiddleLeft, UI.FontStyle.RobotoCondensedBold);

            UI.Button(ref container, UI_MENU, UI.Color("d85540", 1f), _msg("Menu.Reset", player.UserIDString), 12, new UI4(0.85f, (1f - (count * size) - size) + 0.005f, 0.95f, 1f - (count * size) - 0.005f), "pe.servreset");
            UI.Button(ref container, UI_MENU, UI.Color("d85540", 1f), "✘", 12, new UI4(0.955f, (1f - (count * size) - size) + 0.005f, 0.995f, 1f - (count * size) - 0.005f), "pe.closeui");
            count++;

            UI.BlurPanel(ref container, UI_MENU, new UI4(0f, 1f - (26 * size), 0.4f, 1f - (count * size) - 0.005f), UI.Color("000000", 0.7f));

            UI.BlurPanel(ref container, UI_MENU, new UI4(0.405f, 1f - (26 * size), 1f, 1f - (count * size) - 0.005f), UI.Color("000000", 0.7f));

            AddMenuOption(ref container, _msg("Weather.Fog", player.UserIDString), "fog", ConVar.Weather.fog, count, size, player.UserIDString, true);
            count++;

            AddMenuOption(ref container, _msg("Weather.Rain", player.UserIDString), "rain", ConVar.Weather.rain, count, size, player.UserIDString, true);
            count++;

            AddMenuOption(ref container, _msg("Weather.Rainbow", player.UserIDString), "rainbow", ConVar.Weather.rainbow, count, size, player.UserIDString, true);
            count++;

            AddMenuOption(ref container, _msg("Weather.Thunder", player.UserIDString), "thunder", ConVar.Weather.thunder, count, size, player.UserIDString, true);
            count++;

            AddMenuOption(ref container, _msg("Weather.Wind", player.UserIDString), "wind", ConVar.Weather.wind, count, size, player.UserIDString, true);
            count++;

            AddMenuOption(ref container, _msg("Weather.AtmosphereBrightness", player.UserIDString), "atmosphere_brightness", ConVar.Weather.atmosphere_brightness, count, size, player.UserIDString, true);
            count++;

            AddMenuOption(ref container, _msg("Weather.AtmosphereContrast", player.UserIDString), "atmosphere_contrast", ConVar.Weather.atmosphere_contrast, count, size, player.UserIDString, true);
            count++;

            AddMenuOption(ref container, _msg("Weather.AtmosphereDirectionality", player.UserIDString), "atmosphere_directionality", ConVar.Weather.atmosphere_directionality, count, size, player.UserIDString, true);
            count++;

            AddMenuOption(ref container, _msg("Weather.AtmosphereMie", player.UserIDString), "atmosphere_mie", ConVar.Weather.atmosphere_mie, count, size, player.UserIDString, true);
            count++;

            AddMenuOption(ref container, _msg("Weather.AtmosphereRayleigh", player.UserIDString), "atmosphere_rayleigh", ConVar.Weather.atmosphere_rayleigh, count, size, player.UserIDString, true);
            count++;

            AddMenuOption(ref container, _msg("Weather.CloudAttenuation", player.UserIDString), "cloud_attenuation", ConVar.Weather.cloud_attenuation, count, size, player.UserIDString, true);
            count++;

            AddMenuOption(ref container, _msg("Weather.CloudBrightness", player.UserIDString), "cloud_brightness", ConVar.Weather.cloud_brightness, count, size, player.UserIDString, true);
            count++;

            AddMenuOption(ref container, _msg("Weather.CloudColoring", player.UserIDString), "cloud_coloring", ConVar.Weather.cloud_coloring, count, size, player.UserIDString, true);
            count++;

            AddMenuOption(ref container, _msg("Weather.CloudCoverage", player.UserIDString), "cloud_coverage", ConVar.Weather.cloud_coverage, count, size, player.UserIDString, true);
            count++;

            AddMenuOption(ref container, _msg("Weather.CloudOpacity", player.UserIDString), "cloud_opacity", ConVar.Weather.cloud_opacity, count, size, player.UserIDString, true);
            count++;

            AddMenuOption(ref container, _msg("Weather.CloudSaturation", player.UserIDString), "cloud_saturation", ConVar.Weather.cloud_saturation, count, size, player.UserIDString, true);
            count++;

            AddMenuOption(ref container, _msg("Weather.CloudScattering", player.UserIDString), "cloud_scattering", ConVar.Weather.cloud_scattering, count, size, player.UserIDString, true);
            count++;

            AddMenuOption(ref container, _msg("Weather.CloudSharpness", player.UserIDString), "cloud_sharpness", ConVar.Weather.cloud_sharpness, count, size, player.UserIDString, true);
            count++;

            AddMenuOption(ref container, _msg("Weather.CloudSize", player.UserIDString), "cloud_size", ConVar.Weather.cloud_size, count, size, player.UserIDString, true);
            count++;

            AddMenuOption(ref container, _msg("Weather.ClearChance", player.UserIDString), "clear_chance", ConVar.Weather.clear_chance, count, size, player.UserIDString, true);
            count++;

            AddMenuOption(ref container, _msg("Weather.DustChance", player.UserIDString), "dust_chance", ConVar.Weather.dust_chance, count, size, player.UserIDString, true);
            count++;

            AddMenuOption(ref container, _msg("Weather.FogChance", player.UserIDString), "fog_chance", ConVar.Weather.fog_chance, count, size, player.UserIDString, true);
            count++;

            AddMenuOption(ref container, _msg("Weather.OvercastChance", player.UserIDString), "overcast_chance", ConVar.Weather.overcast_chance, count, size, player.UserIDString, true);
            count++;

            AddMenuOption(ref container, _msg("Weather.RainChance", player.UserIDString), "rain_chance", ConVar.Weather.rain_chance, count, size, player.UserIDString, true);
            count++;

            AddMenuOption(ref container, _msg("Weather.StormChance", player.UserIDString), "storm_chance", ConVar.Weather.storm_chance, count, size, player.UserIDString, true);
            count++;

            UI.BlurPanel(ref container, UI_MENU, new UI4(0f, 1f - (count * size) - size, 1f, 1f - (count * size) - 0.005f), UI.Color("000000", 0.7f));
            UI.Label(ref container, UI_MENU, _msg("Menu.ServerTimeEditor", player.UserIDString), 16, new UI4(0.01f, 1f - (count * size) - size, 0.95f, 1f - (count * size)), TextAnchor.MiddleLeft, UI.FontStyle.RobotoCondensedBold);
            count++;

            UI.BlurPanel(ref container, UI_MENU, new UI4(0f, 1f - ((count + 1) * size) - size, 1f, 1f - (count * size) - 0.005f), UI.Color("000000", 0.7f));
            AddTimeOption(ref container, ConVar.Env.time, count, size, player.UserIDString, true);
            count++;

            AddMenuToggle(ref container, _msg("Weather.ProgressTime", player.UserIDString), "progress_time", ConVar.Env.progresstime, count, size, player.UserIDString, true);
            count++;

            CuiHelper.DestroyUi(player, UI_MENU);
            CuiHelper.AddUi(player, container);
        }

        private void AddMenuOption(ref CuiElementContainer container, string title, string variable, float currentValue, int position, float size, string playerId, bool isServer = false)
        {
            float top = 1f - (position * size);
            float bottom = top - size;
            
            UI.Label(ref container, UI_MENU, title, 14, new UI4(0.015f, bottom, 0.5f, top), TextAnchor.MiddleLeft);

            UI.Button(ref container, UI_MENU, UI.Color("6a8b38", 1f), "-", 14, new UI4(0.415f, bottom + 0.005f, 0.455f, top - 0.0075f), $"{(isServer ? "pe.server.editvalue" : "pe.editvalue")} {variable} {(currentValue <= 0f ? -1f : Mathf.Clamp01(currentValue - 0.1f))}");
           
            if (currentValue >= 0f)
            {
                if (currentValue > 0f)
                    UI.Panel(ref container, UI_MENU, UI.Color("387097", 1f), new UI4(0.46f, bottom + 0.015f, 0.46f + ((0.95f - 0.46f) * currentValue), top - 0.0175f));

                UI.Label(ref container, UI_MENU, $"{Mathf.RoundToInt(currentValue * 100f)}%", 12, new UI4(0.46f, bottom + 0.005f, 0.95f, top - 0.0075f), TextAnchor.MiddleCenter);
            }
            else
            {
                UI.Label(ref container, UI_MENU, isServer ? _msg("Menu.Automated", playerId) : _msg("Menu.ServerSet", playerId), 12, new UI4(0.46f, bottom + 0.005f, 0.95f, top - 0.0075f), TextAnchor.MiddleCenter);
            }

            float progressWidth = (0.95f - 0.46f) * 0.1f;

            for (int i = 0; i < 10; i++)
            {
                float left = 0.46f + (progressWidth * i);
                float right = left + progressWidth;

                UI.Button(ref container, UI_MENU, "0 0 0 0", string.Empty, 0, new UI4(left, bottom + 0.005f, right, top - 0.0075f), $"{(isServer ? "pe.server.editvalue" : "pe.editvalue")} {variable} {(i + 1) * 0.1f}");
            }

            UI.Button(ref container, UI_MENU, UI.Color("6a8b38", 1f), "+", 14, new UI4(0.955f, bottom + 0.005f, 0.995f, top - 0.0075f), $"{(isServer ? "pe.server.editvalue" : "pe.editvalue")} {variable} {(currentValue < 0f ? 0f : Mathf.Clamp01(currentValue + 0.05f))}");
        }

        private void AddTimeOption(ref CuiElementContainer container, float currentValue, int position, float size, string playerId, bool isServer = false)
        {
            float top = 1f - (position * size);
            float bottom = top - size;

            UI.Button(ref container, UI_MENU, UI.Color("6a8b38", 1f), "-", 14, new UI4(0.015f, bottom + 0.005f, 0.055f, top - 0.0075f), $"{(isServer ? "pe.server.editvalue" : "pe.editvalue")} time {(currentValue <= 0 ? -1f : Mathf.Clamp(currentValue - 0.5f, 0f, 24f))}");

            if (currentValue > 0f)
                UI.Panel(ref container, UI_MENU, UI.Color("387097", 1f), new UI4(0.06f, bottom + 0.015f, 0.06f + ((0.95f - 0.06f) * (currentValue / 24f)), top - 0.0175f));

            if (currentValue < 0f)
                UI.Label(ref container, UI_MENU, isServer ? _msg("Menu.Automated", playerId) : _msg("Menu.ServerSet", playerId), 12, new UI4(0.06f, bottom + 0.005f, 0.95f, top - 0.0075f), TextAnchor.MiddleCenter);
            else UI.Label(ref container, UI_MENU, $"{currentValue}", 12, new UI4(0.06f, bottom + 0.005f, 0.95f, top - 0.0075f), TextAnchor.MiddleCenter);

            float progressWidth = (0.95f - 0.06f) * 0.05f;

            for (int i = 0; i < 20; i++)
            {
                float left = 0.06f + (progressWidth * i);
                float right = left + progressWidth;

                UI.Button(ref container, UI_MENU, "0 0 0 0", string.Empty, 0, new UI4(left, bottom + 0.005f, right, top - 0.0075f), $"{(isServer ? "pe.server.editvalue" : "pe.editvalue")} time {(i + 1) * 1.2f}");
            }

            UI.Button(ref container, UI_MENU, UI.Color("6a8b38", 1f), "+", 14, new UI4(0.955f, bottom + 0.005f, 0.995f, top - 0.0075f), $"{(isServer ? "pe.server.editvalue" : "pe.editvalue")} time {(currentValue < 0f ? 0f : Mathf.Clamp(0.5f + currentValue, 0f, 24f))}");
        }

        private void AddMenuToggle(ref CuiElementContainer container, string title, string variable, bool currentValue, int position, float size, string playerId, bool isServer = false)
        {
            float top = 1f - (position * size);
            float bottom = top - size;

            UI.Label(ref container, UI_MENU, title, 14, new UI4(0.015f, bottom, 0.5f, top), TextAnchor.MiddleLeft);

            UI.Toggle(ref container, UI_MENU, UI.Color("6a8b38", 1f), 12, new UI4(0.415f, bottom + 0.005f, 0.455f, top - 0.0075f), $"{(isServer ? "pe.server.editvalue" : "pe.editvalue")} {variable} {(currentValue ? 0f : 1f)}", currentValue);
            
        }
        #endregion

        #region UI Commands        
        [ConsoleCommand("pe.closeui")]
        private void ccmdCloseUI(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            CuiHelper.DestroyUi(player, UI_MENU);
            CuiHelper.DestroyUi(player, UI_DUMMY);

            EnvironmentInfo environmentInfo;
            if (userEnvironmentInfo.TryGetValue(player.userID, out environmentInfo))
            {
                if (environmentInfo.ShouldRemove())
                {
                    SendServerReplicatedVars(player);
                    userEnvironmentInfo.Remove(player.userID);
                }
            }
        }

        [ConsoleCommand("pe.reset")]
        private void ccmdReset(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            if (!userEnvironmentInfo.ContainsKey(player.userID))
                return;

            EnvironmentInfo environmentInfo = userEnvironmentInfo[player.userID] = new EnvironmentInfo();

            environmentInfo.SendCustomReplicatedVars(player);

            OpenEnvironmentEditor(player, environmentInfo);
        }

        [ConsoleCommand("pe.servreset")]
        private void ccmdServerReset(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            if (!permission.UserHasPermission(player.UserIDString, PERMISSION_ADMIN))
            {
                player.ChatMessage(_msg("Error.NoPermission", player.UserIDString));
                return;
            }

            ConVar.Weather.fog = configData.Server.Fog = -1;
            ConVar.Weather.rain = configData.Server.Rain = -1;
            ConVar.Weather.rainbow = configData.Server.Rainbow = -1;
            ConVar.Weather.thunder = configData.Server.Thunder = -1;
            ConVar.Weather.wind = configData.Server.Wind = -1;
            ConVar.Weather.atmosphere_brightness = configData.Server.AtmosphereBrightness = -1;
            ConVar.Weather.atmosphere_contrast = configData.Server.AtmosphereContrast = -1;
            ConVar.Weather.atmosphere_directionality = configData.Server.AtmosphereDirectionality = -1;
            ConVar.Weather.atmosphere_mie = configData.Server.AtmosphereMie = -1;
            ConVar.Weather.atmosphere_rayleigh = configData.Server.AtmosphereRayleigh = -1;
            ConVar.Weather.cloud_attenuation = configData.Server.CloudAttenuation = -1;
            ConVar.Weather.cloud_brightness = configData.Server.CloudBrightness = -1;
            ConVar.Weather.cloud_coloring = configData.Server.CloudColoring = -1;
            ConVar.Weather.cloud_coverage = configData.Server.CloudCoverage = -1;
            ConVar.Weather.cloud_opacity = configData.Server.CloudOpacity = -1;
            ConVar.Weather.cloud_saturation = configData.Server.CloudSaturation = -1;
            ConVar.Weather.cloud_scattering = configData.Server.CloudScattering = -1;
            ConVar.Weather.cloud_sharpness = configData.Server.CloudSharpness = -1;
            ConVar.Weather.cloud_size = configData.Server.CloudSize = -1;
            ConVar.Weather.clear_chance = configData.Server._clearChance = -1;
            ConVar.Weather.dust_chance = configData.Server._dustChance = -1;
            ConVar.Weather.fog_chance = configData.Server._fogChance = -1;
            ConVar.Weather.overcast_chance = configData.Server._overcastChance = -1;
            ConVar.Weather.rain_chance = configData.Server._rainChance = -1;
            ConVar.Weather.storm_chance = configData.Server._stormChance = -1;
            ConVar.Env.progresstime = configData.Server._progressTime = true;
        
            SaveConfig();
            SendReplicatedVarsAll();
            OpenServerEnvironmentEditor(player);
        }

        [ConsoleCommand("pe.editvalue")]
        private void ccmdEditValue(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            EnvironmentInfo environmentInfo;
            if (!userEnvironmentInfo.TryGetValue(player.userID, out environmentInfo))
                return;

            string propertyName = arg.GetString(0);
            float value = arg.GetFloat(1);

            switch (propertyName)
            {
                case "fog":
                    environmentInfo.Fog = value;
                    break;
                case "rain":
                    environmentInfo.Rain = value;
                    break;
                case "rainbow":
                    environmentInfo.Rainbow = value;
                    break;
                case "thunder":
                    environmentInfo.Thunder = value;
                    break;
                case "wind":
                    environmentInfo.Wind = value;
                    break;
                case "atmosphere_brightness":
                    environmentInfo.AtmosphereBrightness = value;
                    break;
                case "atmosphere_contrast":
                    environmentInfo.AtmosphereContrast = value;
                    break;
                case "atmosphere_directionality":
                    environmentInfo.AtmosphereDirectionality = value;
                    break;
                case "atmosphere_mie":
                    environmentInfo.AtmosphereMie = value;
                    break;
                case "atmosphere_rayleigh":
                    environmentInfo.AtmosphereRayleigh = value;
                    break;
                case "cloud_attenuation":
                    environmentInfo.CloudAttenuation = value;
                    break;
                case "cloud_brightness":
                    environmentInfo.CloudBrightness = value;
                    break;
                case "cloud_coloring":
                    environmentInfo.CloudColoring = value;
                    break;
                case "cloud_coverage":
                    environmentInfo.CloudCoverage = value;
                    break;
                case "cloud_opacity":
                    environmentInfo.CloudOpacity = value;
                    break;
                case "cloud_saturation":
                    environmentInfo.CloudSaturation = value;
                    break;
                case "cloud_scattering":
                    environmentInfo.CloudScattering = value;
                    break;
                case "cloud_sharpness":
                    environmentInfo.CloudSharpness = value;
                    break;
                case "cloud_size":
                    environmentInfo.CloudSize = value;
                    break;
                case "time":
                    environmentInfo.Time = value;
                    break;
                default:
                    break;
            }

            environmentInfo.SendCustomReplicatedVars(player);

            OpenEnvironmentEditor(player, environmentInfo);
        }

        [ConsoleCommand("pe.server.editvalue")]
        private void ccmdEditServerValue(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            if (!permission.UserHasPermission(player.UserIDString, PERMISSION_ADMIN))
            {
                player.ChatMessage(_msg("Error.NoPermission", player.UserIDString));
                return;
            }

            string propertyName = arg.GetString(0);
            float value = arg.GetFloat(1);

            switch (propertyName)
            {
                case "fog":
                    ConVar.Weather.fog = configData.Server.Fog = value;                    
                    break;
                case "rain":
                    ConVar.Weather.rain = configData.Server.Rain = value;
                    break;
                case "rainbow":
                    ConVar.Weather.rainbow = configData.Server.Rainbow = value;
                    break;
                case "thunder":
                    ConVar.Weather.thunder = configData.Server.Thunder = value;
                    break;
                case "wind":
                    ConVar.Weather.wind = configData.Server.Wind = value;
                    break;
                case "atmosphere_brightness":
                    ConVar.Weather.atmosphere_brightness = configData.Server.AtmosphereBrightness = value;
                    break;
                case "atmosphere_contrast":
                    ConVar.Weather.atmosphere_contrast = configData.Server.AtmosphereContrast = value;
                    break;
                case "atmosphere_directionality":
                    ConVar.Weather.atmosphere_directionality = configData.Server.AtmosphereDirectionality = value;
                    break;
                case "atmosphere_mie":
                    ConVar.Weather.atmosphere_mie = configData.Server.AtmosphereMie = value;
                    break;
                case "atmosphere_rayleigh":
                    ConVar.Weather.atmosphere_rayleigh = configData.Server.AtmosphereRayleigh = value;
                    break;
                case "cloud_attenuation":
                    ConVar.Weather.cloud_attenuation = configData.Server.CloudAttenuation = value;
                    break;
                case "cloud_brightness":
                    ConVar.Weather.cloud_brightness = configData.Server.CloudBrightness = value;
                    break;
                case "cloud_coloring":
                    ConVar.Weather.cloud_coloring = configData.Server.CloudColoring = value;
                    break;
                case "cloud_coverage":
                    ConVar.Weather.cloud_coverage = configData.Server.CloudCoverage = value;
                    break;
                case "cloud_opacity":
                    ConVar.Weather.cloud_opacity = configData.Server.CloudOpacity = value;
                    break;
                case "cloud_saturation":
                    ConVar.Weather.cloud_saturation = configData.Server.CloudSaturation = value;
                    break;
                case "cloud_scattering":
                    ConVar.Weather.cloud_scattering = configData.Server.CloudScattering = value;
                    break;
                case "cloud_sharpness":
                    ConVar.Weather.cloud_sharpness = configData.Server.CloudSharpness = value;
                    break;
                case "cloud_size":
                    ConVar.Weather.cloud_size = configData.Server.CloudSize = value;
                    break;
                case "time":
                    ConVar.Env.time = configData.Server.Time = value;
                    break;
                case "clear_chance":
                    ConVar.Weather.clear_chance = configData.Server._clearChance = Mathf.Clamp01(value);
                    break;
                case "dust_chance":
                    ConVar.Weather.dust_chance = configData.Server._dustChance = Mathf.Clamp01(value);
                    break;
                case "fog_chance":
                    ConVar.Weather.fog_chance = configData.Server._fogChance = Mathf.Clamp01(value);
                    break;
                case "overcast_chance":
                    ConVar.Weather.overcast_chance = configData.Server._overcastChance = Mathf.Clamp01(value);
                    break;
                case "rain_chance":
                    ConVar.Weather.rain_chance = configData.Server._rainChance = Mathf.Clamp01(value);
                    break;
                case "storm_chance":
                    ConVar.Weather.storm_chance = configData.Server._stormChance = Mathf.Clamp01(value);
                    break;
                case "progress_time":
                    ConVar.Env.progresstime = configData.Server._progressTime = value < 0.5f ? false : true;
                    break;
                default:
                    break;
            }

            SaveConfig();
            SendReplicatedVarsAll();
            OpenServerEnvironmentEditor(player);
        }
        #endregion

        #region Commands
        [ChatCommand("env")]
        private void cmdEnv(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, configData.TimePermission) && !permission.UserHasPermission(player.UserIDString, configData.WeatherPermission))
            {
                player.ChatMessage(_msg("Error.NoPermission", player.UserIDString));
                return;
            }

            EnvironmentInfo environmentInfo;

            if (!userEnvironmentInfo.TryGetValue(player.userID, out environmentInfo))
                userEnvironmentInfo[player.userID] = environmentInfo = new EnvironmentInfo();

            if (environmentInfo.HasZoneOverride())
            {
                player.ChatMessage(_msg("Notification.HasZoneOverride", player.UserIDString));
                return;
            }

            OpenDummyContainer(player);
            OpenEnvironmentEditor(player, environmentInfo);
        }

        [ChatCommand("senv")]
        private void cmdServerEnv(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, PERMISSION_ADMIN))
            {
                player.ChatMessage(_msg("Error.NoPermission", player.UserIDString));
                return;
            }

            OpenDummyContainer(player);
            OpenServerEnvironmentEditor(player);
        }

        [ChatCommand("mytime")]
        private void cmdMyTime(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, configData.TimePermission))
            {
                player.ChatMessage(_msg("Error.NoPermission", player.UserIDString));
                return;
            }

            float time;
            if (args.Length != 1 || !float.TryParse(args[0], out time))
            {
                player.ChatMessage(_msg("Error.NoTimeVar", player.UserIDString));
                return;
            }

            EnvironmentInfo environmentInfo;

            if (!userEnvironmentInfo.TryGetValue(player.userID, out environmentInfo))
                userEnvironmentInfo[player.userID] = environmentInfo = new EnvironmentInfo();

            if (environmentInfo.HasZoneOverride())
            {
                player.ChatMessage(_msg("Notification.HasZoneOverride", player.UserIDString));
                return;
            }

            environmentInfo.Time = Mathf.Clamp(time, -1, 24);
            player.ChatMessage(string.Format(_msg("Notification.SetTime", player.UserIDString), environmentInfo.Time));
        }
        #endregion

        #region Config        
        private ConfigData configData;
        private class ConfigData
        {
            [JsonProperty("Save players custom environment settings and apply after restart/relog")]
            public bool EnableSaving { get; set; }

            [JsonProperty("Custom permission to change time")]
            public string TimePermission { get; set; }

            [JsonProperty("Custom permission to change weather")]
            public string WeatherPermission { get; set; }

            [JsonProperty("Zone Environment Profiles. (To disable a variable and use the value set on the server, set the option to -1)")]
            public Dictionary<string, EnvironmentInfo> Zones { get; set; }

            [JsonProperty("Server Environment Profile")]
            public ServerEnvironmentInfo Server { get; set; }

            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();

            if (configData.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                EnableSaving = true,
                TimePermission = "preferredenvironment.use",
                WeatherPermission = "preferredenvironment.use",

                Zones = new Dictionary<string, EnvironmentInfo>
                {
                    ["ExampleZoneID"] = new EnvironmentInfo
                    {
                        _fog = -1f,
                        _rain = -1f,
                        _time = -1f,
                        _wind = -1f,
                        _atmosphere_brightness = -1f,
                        _atmosphere_contrast = -1f,
                        _atmosphere_directionality = -1f,
                        _atmosphere_mie = -1f,
                        _atmosphere_rayleigh = -1f,
                        _cloud_attenuation = -1f,
                        _cloud_brightness = -1f,
                        _cloud_coloring = -1f,
                        _cloud_coverage = -1f,
                        _cloud_opacity = -1f,
                        _cloud_saturation = -1f,
                        _cloud_scattering = -1f,
                        _cloud_sharpness = -1f,
                        _cloud_size = -1f,
                        _rainbow = -1f,
                        _thunder = -1f,                        
                    }
                },
                Server = new ServerEnvironmentInfo()
                {
                    _fog = -1f,
                    _rain = -1f,
                    _time = -1f,
                    _wind = -1f,
                    _atmosphere_brightness = -1f,
                    _atmosphere_contrast = -1f,
                    _atmosphere_directionality = -1f,
                    _atmosphere_mie = -1f,
                    _atmosphere_rayleigh = -1f,
                    _cloud_attenuation = -1f,
                    _cloud_brightness = -1f,
                    _cloud_coloring = -1f,
                    _cloud_coverage = -1f,
                    _cloud_opacity = -1f,
                    _cloud_saturation = -1f,
                    _cloud_scattering = -1f,
                    _cloud_sharpness = -1f,
                    _cloud_size = -1f,
                    _rainbow = -1f,
                    _thunder = -1f,
                    _clearChance = -1,
                    _dustChance = -1,
                    _fogChance = -1,
                    _overcastChance = -1,
                    _progressTime = true,
                    _rainChance = -1,
                    _stormChance = -1
                },
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();

            if (configData.Version < new VersionNumber(2, 0, 0))
                configData = baseConfig;

            if (configData.Version < new VersionNumber(2, 0, 6) || configData.Server == null)
                configData.Server = baseConfig.Server;

            if (configData.Version < new VersionNumber(2, 0, 9))
            {
                configData.TimePermission = configData.WeatherPermission = baseConfig.TimePermission;
            }

            configData.Version = Version;
            PrintWarning("Config update completed!");
        }

        #endregion

        private class ServerEnvironmentInfo : EnvironmentInfo
        {
            [JsonProperty("Progress Time")]
            public bool _progressTime = true;

            [JsonProperty("Storm Chance")]
            public float _stormChance = -1f;

            [JsonProperty("Rain Chance")]
            public float _rainChance = -1f;

            [JsonProperty("Overcast Chance")]
            public float _overcastChance = -1f;

            [JsonProperty("Fog Chance")]
            public float _fogChance = -1f;

            [JsonProperty("Dust Chance")]
            public float _dustChance = -1f;

            [JsonProperty("Clear Chance")]
            public float _clearChance = -1f;
        }

        private class EnvironmentInfo
        {
            [JsonProperty("Time (0.0 - 24.0)")]
            public float _time = -1f;

            [JsonProperty("Rain (0.0 - 1.0)")]
            public float _rain = -1f;

            [JsonProperty("Wind (0.0 - 1.0)")]
            public float _wind = -1f;

            [JsonProperty("Fog (0.0 - 1.0)")]
            public float _fog = -1f;

            [JsonProperty("Rainbow (0.0 - 1.0)")]
            public float _rainbow = -1f;

            [JsonProperty("Thunder (0.0 - 1.0)")]
            public float _thunder = -1f;

            [JsonProperty("Atmosphere Brightness (0.0 - 1.0)")]
            public float _atmosphere_brightness = -1f;

            [JsonProperty("Atmosphere Contrast (0.0 - 1.0)")]
            public float _atmosphere_contrast = -1f;

            [JsonProperty("Atmosphere Directionality (0.0 - 1.0)")]
            public float _atmosphere_directionality = -1f;

            [JsonProperty("Atmosphere Mie (0.0 - 1.0)")]
            public float _atmosphere_mie = -1f;

            [JsonProperty("Atmosphere Rayleigh (0.0 - 1.0)")]
            public float _atmosphere_rayleigh = -1f;

            [JsonProperty("Cloud Attenuation (0.0 - 1.0)")]
            public float _cloud_attenuation = -1f;

            [JsonProperty("Cloud Brightness (0.0 - 1.0)")]
            public float _cloud_brightness = -1f;

            [JsonProperty("Cloud Coloring (0.0 - 1.0)")]
            public float _cloud_coloring = -1f;

            [JsonProperty("Cloud Coverage (0.0 - 1.0)")]
            public float _cloud_coverage = -1f;

            [JsonProperty("Cloud Opacity (0.0 - 1.0)")]
            public float _cloud_opacity = -1f;

            [JsonProperty("Cloud Saturation (0.0 - 1.0)")]
            public float _cloud_saturation = -1f;

            [JsonProperty("Cloud Scattering (0.0 - 1.0)")]
            public float _cloud_scattering = -1f;

            [JsonProperty("Cloud Sharpness (0.0 - 1.0)")]
            public float _cloud_sharpness = -1f;

            [JsonProperty("Cloud Size (0.0 - 1.0)")]
            public float _cloud_size = -1f;

            [JsonIgnore]
            public float Rain
            {
                get { return _rain; }
                set { _rain = value >= 0f ? Mathf.Clamp(value, 0, 1f) : -1f; VarsDirty = true; }
            }

            [JsonIgnore]
            public float Wind
            {
                get { return _wind; }
                set { _wind = value >= 0f ? Mathf.Clamp(value, 0, 1f) : -1f; VarsDirty = true; }
            }

            [JsonIgnore]
            public float Fog
            {
                get { return _fog; }
                set { _fog = value >= 0f ? Mathf.Clamp(value, 0, 1f) : -1f; VarsDirty = true; }
            }

            [JsonIgnore]
            public float AtmosphereBrightness
            {
                get { return _atmosphere_brightness; }
                set { _atmosphere_brightness = value >= 0f ? Mathf.Clamp(value, 0, 1f) : -1f; VarsDirty = true; }
            }

            [JsonIgnore]
            public float AtmosphereContrast
            {
                get { return _atmosphere_contrast; }
                set { _atmosphere_contrast = value >= 0f ? Mathf.Clamp(value, 0, 1f) : -1f; VarsDirty = true; }
            }
            [JsonIgnore]
            public float AtmosphereDirectionality
            {
                get { return _atmosphere_directionality; }
                set { _atmosphere_directionality = value >= 0f ? Mathf.Clamp(value, 0, 1f) : -1f; VarsDirty = true; }
            }

            [JsonIgnore]
            public float AtmosphereMie
            {
                get { return _atmosphere_mie; }
                set { _atmosphere_mie = value >= 0f ? Mathf.Clamp(value, 0, 1f) : -1f; VarsDirty = true; }
            }

            [JsonIgnore]
            public float AtmosphereRayleigh
            {
                get { return _atmosphere_rayleigh; }
                set { _atmosphere_rayleigh = value >= 0f ? Mathf.Clamp(value, 0, 1f) : -1f; VarsDirty = true; }
            }

            [JsonIgnore]
            public float CloudAttenuation
            {
                get { return _cloud_attenuation; }
                set { _cloud_attenuation = value >= 0f ? Mathf.Clamp(value, 0, 1f) : -1f; VarsDirty = true; }
            }

            [JsonIgnore]
            public float CloudBrightness
            {
                get { return _cloud_brightness; }
                set { _cloud_brightness = value >= 0f ? Mathf.Clamp(value, 0, 1f) : -1f; VarsDirty = true; }
            }

            [JsonIgnore]
            public float CloudColoring
            {
                get { return _cloud_coloring; }
                set { _cloud_coloring = value >= 0f ? Mathf.Clamp(value, 0, 1f) : -1f; VarsDirty = true; }
            }

            [JsonIgnore]
            public float CloudCoverage
            {
                get { return _cloud_coverage; }
                set { _cloud_coverage = value >= 0f ? Mathf.Clamp(value, 0, 1f) : -1f; VarsDirty = true; }
            }

            [JsonIgnore]
            public float CloudOpacity
            {
                get { return _cloud_opacity; }
                set { _cloud_opacity = value >= 0f ? Mathf.Clamp(value, 0, 1f) : -1f; VarsDirty = true; }
            }

            [JsonIgnore]
            public float CloudSaturation
            {
                get { return _cloud_saturation; }
                set { _cloud_saturation = value >= 0f ? Mathf.Clamp(value, 0, 1f) : -1f; VarsDirty = true; }
            }

            [JsonIgnore]
            public float CloudScattering
            {
                get { return _cloud_scattering; }
                set { _cloud_scattering = value >= 0f ? Mathf.Clamp(value, 0, 1f) : -1f; VarsDirty = true; }
            }

            [JsonIgnore]
            public float CloudSharpness
            {
                get { return _cloud_sharpness; }
                set { _cloud_sharpness = value >= 0f ? Mathf.Clamp(value, 0, 1f) : -1f; VarsDirty = true; }
            }

            [JsonIgnore]
            public float CloudSize
            {
                get { return _cloud_size; }
                set { _cloud_size = value >= 0f ? Mathf.Clamp(value, 0, 1f) : -1f; VarsDirty = true; }
            }

            [JsonIgnore]
            public float Rainbow
            {
                get { return _rainbow; }
                set { _rainbow = value >= 0f ? Mathf.Clamp(value, 0, 1f) : -1f; VarsDirty = true; }
            }

            [JsonIgnore]
            public float Thunder
            {
                get { return _thunder; }
                set { _thunder = value >= 0f ? Mathf.Clamp(value, 0, 1f) : -1f; VarsDirty = true; }
            }

            [JsonIgnore]
            public float Time
            {
                get { return _time; }
                set { _time = value >= 0f ? Mathf.Clamp(value, 0, 24f) : -1f; }
            }

            [JsonIgnore]
            private Hash<string, EnvironmentInfo> zoneOverrides;

            [JsonIgnore]
            private string currentZoneId = string.Empty;

            public bool HasZoneOverride()
            {
                if (zoneOverrides == null || currentZoneId == string.Empty || zoneOverrides.Count == 0)                
                    return false;
                
                return true;
            }

            public bool GetZoneOverride(out EnvironmentInfo environmentInfo)
            {
                if (zoneOverrides == null || currentZoneId == string.Empty || zoneOverrides.Count == 0)
                {
                    environmentInfo = null;
                    return false;
                }

                environmentInfo = zoneOverrides[currentZoneId];
                return true;
            }

            public void OnEnterZone(string zoneId, EnvironmentInfo environmentInfo)
            {
                if (zoneOverrides == null)
                    zoneOverrides = new Hash<string, EnvironmentInfo>();

                currentZoneId = zoneId;
                zoneOverrides[zoneId] = environmentInfo;
            }

            public void OnExitZone(string zoneId, BasePlayer player)
            {
                if (zoneOverrides != null)
                {
                    zoneOverrides.Remove(zoneId);
                    if (currentZoneId == zoneId)
                    {
                        if (zoneOverrides.Count > 0)
                        {
                            foreach (KeyValuePair<string, EnvironmentInfo> kvp in zoneOverrides)
                            {
                                currentZoneId = kvp.Key;
                                return;
                            }
                        }
                        else currentZoneId = string.Empty;
                    }
                }
            }

            [JsonIgnore]
            public bool HasReplicatedVars => replicatedVars?.Count > 0;

            [JsonIgnore]
            public bool VarsDirty = true;

            [JsonIgnore]
            private Hash<string, string> replicatedVars;
            
            [JsonIgnore]
            public float GetDesiredTime => HasZoneOverride() ? zoneOverrides[currentZoneId].Time : Time;

            public bool ShouldRemove()
            {
                if (HasZoneOverride())
                    return false;

                if (VarsDirty)
                    BuildReplicatedConvarList();

                if (replicatedVars?.Count > 0 || Time >= 0f)
                    return false;

                return true;                
            }

            public void SendCustomReplicatedVars(BasePlayer player)
            {
                if (HasZoneOverride())
                {
                    zoneOverrides[currentZoneId].SendCustomReplicatedVars(player);
                    return;
                }

                if (VarsDirty)
                    BuildReplicatedConvarList();

                NetWrite netWrite = Net.sv.StartWrite();
                netWrite.PacketID(Message.Type.ConsoleReplicatedVars);
                netWrite.Int32(weatherConvars.Count);

                foreach (KeyValuePair<string, ConsoleSystem.Command> kvp in weatherConvars)
                {
                    netWrite.String(kvp.Key);
                    netWrite.String(replicatedVars.ContainsKey(kvp.Key) ? replicatedVars[kvp.Key] : kvp.Value.String);
                }

                netWrite.Send(new SendInfo(player.net.connection));
            }

            public void BuildReplicatedConvarList()
            {
                if (replicatedVars == null)
                    replicatedVars = new Hash<string, string>();

                replicatedVars.Clear();

                if (_atmosphere_brightness >= 0)
                    replicatedVars["weather.atmosphere_brightness"] = _atmosphere_brightness.ToString();

                if (_atmosphere_contrast >= 0)
                    replicatedVars["weather.atmosphere_contrast"] = _atmosphere_contrast.ToString();

                if (_atmosphere_directionality >= 0)
                    replicatedVars["weather.atmosphere_directionality"] = _atmosphere_directionality.ToString();

                if (_atmosphere_directionality >= 0)
                    replicatedVars["weather.atmosphere_directionality"] = _atmosphere_directionality.ToString();

                if (_atmosphere_mie >= 0)
                    replicatedVars["weather.atmosphere_mie"] = _atmosphere_mie.ToString();

                if (_atmosphere_rayleigh >= 0)
                    replicatedVars["weather.atmosphere_rayleigh"] = _atmosphere_rayleigh.ToString();

                if (_cloud_attenuation >= 0)
                    replicatedVars["weather.cloud_attenuation"] = _cloud_attenuation.ToString();

                if (_cloud_brightness >= 0)
                    replicatedVars["weather.cloud_brightness"] = _cloud_brightness.ToString();

                if (_cloud_coloring >= 0)
                    replicatedVars["weather.cloud_coloring"] = _cloud_coloring.ToString();

                if (_cloud_coverage >= 0)
                    replicatedVars["weather.cloud_coverage"] = _cloud_coverage.ToString();

                if (_cloud_opacity >= 0)
                    replicatedVars["weather.cloud_opacity"] = _cloud_opacity.ToString();

                if (_cloud_saturation >= 0)
                    replicatedVars["weather.cloud_saturation"] = _cloud_saturation.ToString();

                if (_cloud_scattering >= 0)
                    replicatedVars["weather.cloud_scattering"] = _cloud_scattering.ToString();

                if (_cloud_sharpness >= 0)
                    replicatedVars["weather.cloud_sharpness"] = _cloud_sharpness.ToString();

                if (_cloud_size >= 0)
                    replicatedVars["weather.cloud_size"] = _cloud_size.ToString();

                if (_fog >= 0)
                    replicatedVars["weather.fog"] = _fog.ToString();

                if (_rain >= 0)
                    replicatedVars["weather.rain"] = _rain.ToString();

                if (_rainbow >= 0)
                    replicatedVars["weather.rainbow"] = _rainbow.ToString();

                if (_thunder >= 0)
                    replicatedVars["weather.thunder"] = _thunder.ToString();

                if (_wind >= 0)
                    replicatedVars["weather.wind"] = _wind.ToString();

                if (replicatedVars.Count > 0)
                {
                    replicatedVars["weather.clear_chance"] = "0";
                    replicatedVars["weather.dust_chance"] = "0";
                    replicatedVars["weather.fog_chance"] = "0";
                    replicatedVars["weather.overcast_chance"] = "0";
                    replicatedVars["weather.rain_chance"] = "0";
                    replicatedVars["weather.storm_chance"] = "0";
                }

                VarsDirty = false;
            }
        }

    }
}


// --- End of file: PreferredEnvironment.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/RecycleManager.cs ---
// --- Original Local Path: BeeRust/RecycleManager.cs ---

﻿// #define ENABLE_TESTS

using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Libraries;
using UnityEngine;

#if ENABLE_TESTS
using System.Collections;
using System.Reflection;
using Oxide.Core.Plugins;
#endif

namespace Oxide.Plugins
{
    [Info("Recycle Manager", "WhiteThunder", "2.0.3")]
    [Description("Allows customizing recycler speed, input, and output")]
    internal class RecycleManager : CovalencePlugin
    {
        #region Fields

        private Configuration _config;

        private const string PermissionAdmin = "recyclemanager.admin";

        private const int ScrapItemId = -932201673;
        private const float RecycleEfficiency = 0.5f;

        private readonly object True = true;
        private readonly object False = false;

        private const int NumInputSlots = 6;
        private const int NumOutputSlots = 6;

        private readonly RecycleComponentManager _recycleComponentManager = new RecycleComponentManager();
        private readonly RecycleEditManager _recycleEditManager;
        private readonly float[] _recycleTime = new float[1];

        private bool IsEditUIEnabled => !_config.UsingDefaults && _config.EditUISettings.Enabled;

        #if ENABLE_TESTS
        private readonly RecycleManagerTests _testRunner;
        #endif

        public RecycleManager()
        {
            #if ENABLE_TESTS
            _testRunner = new RecycleManagerTests(this);
            #endif

            _recycleEditManager = new RecycleEditManager(this);
        }

        #endregion

        #region Hooks

        private void Init()
        {
            _config.Init(this);
            _recycleComponentManager.Init(this);

            permission.RegisterPermission(PermissionAdmin, this);

            if (!_config.RecycleSpeed.Enabled)
            {
                Unsubscribe(nameof(OnRecyclerToggle));
            }

            if (!IsEditUIEnabled)
            {
                Unsubscribe(nameof(OnLootEntity));
            }
        }

        private void OnServerInitialized()
        {
            #if ENABLE_TESTS
            _testRunner.Run();
            #endif

            if (IsEditUIEnabled)
            {
                foreach (var player in BasePlayer.activePlayerList)
                {
                    var container = player.inventory.loot.containers.FirstOrDefault();
                    if (container == null)
                        continue;

                    var recycler = container.entityOwner as Recycler;
                    if ((object)recycler == null)
                        continue;

                    OnLootEntity(player, recycler);
                }
            }
        }

        private void Unload()
        {
            #if ENABLE_TESTS
            _testRunner.Interrupt();
            #endif

            _recycleComponentManager.Unload();
            _recycleEditManager.Unload();
        }

        // This hook is primarily used to determine whether an item can be placed into the recycler input,
        // but it's also called when processing each item.
        private object CanBeRecycled(Item item, Recycler recycler)
        {
            if (item == null)
                return null;

            if (_config.RestrictedInputItems.IsDisallowed(item))
            {
                // Defensively return null if vanilla would *disallow* recycling, to avoid hook conflicts.
                return IsVanillaRecyclable(item) && !RecyclableWasBlocked(item, recycler)
                    ? False
                    : null;
            }

            if (_config.OverrideOutput.GetBestOverride(item) != null)
            {
                // Defensively return null if vanilla would *allow* recycling, to avoid hook conflicts.
                return IsVanillaRecyclable(item) || RecyclableWasBlocked(item, recycler)
                    ? null
                    : True;
            }

            return null;
        }

        private object CanRecycle(Recycler recycler, Item item)
        {
            return CanBeRecycled(item, recycler);
        }

        private void OnRecyclerToggle(Recycler recycler, BasePlayer player)
        {
            _recycleComponentManager.HandleRecyclerToggle(recycler, player);
        }

        private object OnItemRecycle(Item item, Recycler recycler)
        {
            if (RecycleItemWasBlocked(item, recycler))
                return null;

            var recycleAmount = DetermineConsumptionAmount(recycler, item);
            if (recycleAmount <= 0)
                return False;

            var customIngredientList = _config.OverrideOutput.GetBestOverride(item);
            if (customIngredientList != null)
            {
                item.UseItem(recycleAmount);

                // Overrides already account for standard recycle efficiency, so only calculate based on item condition.
                if (PopulateOutputWithOverride(recycler, customIngredientList, recycleAmount, DetermineRecycleEfficiency(item)))
                {
                    recycler.StopRecycling();
                }

                return False;
            }

            // If the item is not vanilla recyclable, and this plugin doesn't have an override,
            // that probably means another plugin is going to handle recycling it.
            if (!IsVanillaRecyclable(item))
                return null;

            item.UseItem(recycleAmount);

            var outputIsFull = PopulateOutputVanilla(_config, recycler, item, recycleAmount, DetermineRecycleEfficiency(item, recycler.recycleEfficiency));
            if (outputIsFull || !recycler.HasRecyclable())
            {
                recycler.StopRecycling();
            }

            return False;
        }

        private void OnLootEntity(BasePlayer player, Recycler recycler)
        {
            if (!recycler.onlyOneUser)
                return;

            if (permission.UserHasPermission(player.UserIDString, PermissionAdmin))
            {
                var player2 = player;
                var recycler2 = recycler;
                NextTick(() =>
                {
                    var lootingContainer = player2.inventory.loot.containers.FirstOrDefault();
                    if (lootingContainer == null || lootingContainer != recycler2.inventory)
                        return;

                    _recycleEditManager.HandlePlayerStartedLooting(player2, recycler2);
                });
            }
        }

        #endregion

        #region Exposed Hooks

        private static class ExposedHooks
        {
            public static object OnRecycleManagerItemRecyclable(Item item, Recycler recycler)
            {
                return Interface.CallHook("OnRecycleManagerItemRecyclable", item, recycler);
            }

            public static object OnRecycleManagerSpeed(Recycler recycler, BasePlayer player, float[] recycleTime)
            {
                return Interface.CallHook("OnRecycleManagerSpeed", recycler, player, recycleTime);
            }

            public static object OnRecycleManagerRecycle(Item item, Recycler recycler)
            {
                return Interface.CallHook("OnRecycleManagerRecycle", item, recycler);
            }
        }

        #endregion

        #region Commands

        [Command("recyclemanager.add", "recman.add")]
        private void CommandAddItem(IPlayer player, string cmd, string[] args)
        {
            if (!VerifyHasPermission(player, PermissionAdmin)
                || !VerifyConfigLoaded(player))
                return;

            ItemDefinition itemDefinition;
            if (!VerifyValidItemIdOrShortName(player, args.ElementAtOrDefault(0), out itemDefinition, cmd))
                return;

            if (!_config.OverrideOutput.AddOverride(this, itemDefinition))
            {
                ReplyToPlayer(player, LangEntry.AddExists, itemDefinition.shortname);
                return;
            }

            SaveConfig();
            ReplyToPlayer(player, LangEntry.AddSuccess, itemDefinition.shortname);
        }

        [Command("recyclemanager.reset", "recman.reset")]
        private void CommandResetItem(IPlayer player, string cmd, string[] args)
        {
            if (!VerifyHasPermission(player, PermissionAdmin)
                || !VerifyConfigLoaded(player))
                return;

            ItemDefinition itemDefinition;
            if (!VerifyValidItemIdOrShortName(player, args.ElementAtOrDefault(0), out itemDefinition, cmd))
                return;

            _config.OverrideOutput.ResetOverride(this, itemDefinition);
            SaveConfig();
            ReplyToPlayer(player, LangEntry.ResetSuccess, itemDefinition.shortname);
        }

        [Command("recyclemanager.ui")]
        private void CommandEdit(IPlayer player, string cmd, string[] args)
        {
            if (player.IsServer || !player.HasPermission(PermissionAdmin))
                return;

            var basePlayer = player.Object as BasePlayer;
            _recycleEditManager.GetController(basePlayer)?.HandleUICommand(basePlayer, args);
        }

        #endregion

        #region Helper Methods - Instance

        private bool VerifyHasPermission(IPlayer player, string perm)
        {
            if (player.HasPermission(perm))
                return true;

            ReplyToPlayer(player, LangEntry.ErrorNoPermission);
            return false;
        }

        private bool VerifyConfigLoaded(IPlayer player)
        {
            if (!_config.UsingDefaults)
                return true;

            ReplyToPlayer(player, LangEntry.ErrorConfig);
            return false;
        }

        private bool VerifyValidItemIdOrShortName(IPlayer player, string itemArg, out ItemDefinition itemDefinition, string command)
        {
            if (itemArg == null)
            {
                itemDefinition = (player.Object as BasePlayer)?.GetActiveItem()?.info;
                if (itemDefinition != null)
                    return true;

                ReplyToPlayer(player, LangEntry.ItemSyntax, command);
                return false;
            }

            int itemId;
            if (int.TryParse(itemArg, out itemId))
            {
                itemDefinition = ItemManager.FindItemDefinition(itemId);
                if (itemDefinition != null)
                    return true;
            }

            itemDefinition = ItemManager.FindItemDefinition(itemArg);
            if (itemDefinition != null)
                return true;

            ReplyToPlayer(player, LangEntry.ErrorInvalidItem, itemArg);
            return false;
        }

        private bool TryDetermineRecycleTime(Recycler recycler, BasePlayer player, out float recycleTime)
        {
            _recycleTime[0] = _config.RecycleSpeed.DefaultRecycleTime
                              * _config.RecycleSpeed.GetTimeMultiplierForPlayer(player);

            if (_config.RecycleSpeed.SafeZoneTimeMultiplier != 1 && player.InSafeZone())
            {
                _recycleTime[0] *= _config.RecycleSpeed.SafeZoneTimeMultiplier;
            }

            var hookResult = ExposedHooks.OnRecycleManagerSpeed(recycler, player, _recycleTime);
            if (hookResult is bool && !(bool)hookResult)
            {
                recycleTime = 0;
                return false;
            }

            recycleTime = Math.Max(0, _recycleTime[0]);
            return true;
        }

        private object CallCanBeRecycled(Item item, Recycler recycler)
        {
            Unsubscribe(nameof(CanBeRecycled));
            var hookResult = Interface.CallHook(nameof(CanBeRecycled), item, recycler);
            Subscribe(nameof(CanBeRecycled));
            return hookResult;
        }

        private IngredientInfo[] GetVanillaOutput(ItemDefinition itemDefinition)
        {
            if (itemDefinition.Blueprint?.ingredients == null)
                return new IngredientInfo[0];

            var ingredientList = new List<IngredientInfo>();

            if (itemDefinition.Blueprint.scrapFromRecycle > 0)
            {
                var ingredientInfo = new IngredientInfo
                {
                    ShortName = "scrap",
                    Amount = itemDefinition.Blueprint.scrapFromRecycle,
                };
                ingredientInfo.Init();
                ingredientList.Add(ingredientInfo);
            }

            foreach (var blueprintIngredient in itemDefinition.Blueprint.ingredients)
            {
                if (blueprintIngredient.itemid == ScrapItemId)
                    continue;

                var amount = blueprintIngredient.amount / itemDefinition.Blueprint.amountToCreate * RecycleEfficiency;
                if (amount > 1)
                {
                    amount = Mathf.CeilToInt(amount);
                }

                var ingredientInfo = new IngredientInfo
                {
                    ShortName = blueprintIngredient.itemDef.shortname,
                    Amount = amount,
                };

                ingredientInfo.Init();
                ingredientList.Add(ingredientInfo);
            }

            return ingredientList.ToArray();
        }

        private float DetermineRecycleEfficiency(Item item, float recycleEfficiency = 1)
        {
            return item.hasCondition
                ? Mathf.Clamp01(recycleEfficiency * Mathf.Clamp(item.conditionNormalized * item.maxConditionNormalized, 0.1f, 1f))
                : recycleEfficiency;
        }

        private int DetermineConsumptionAmount(Recycler recycler, Item item)
        {
            var recycleAmount = 1;

            if (item.amount > 1)
            {
                var consumeMultiplier = _config.MaxItemsPerRecycle.GetPercent(item) / 100f;
                recycleAmount = Mathf.CeilToInt(Mathf.Min(item.amount, (float)item.info.stackable * consumeMultiplier));

                // In case the configured multiplier is 0, ensure at least 1 item is recycled.
                recycleAmount = Math.Max(recycleAmount, 1);
            }

            // Call standard Oxide hook for compatibility.
            var amountOverride = Interface.CallHook("OnItemRecycleAmount", item, recycleAmount, recycler);
            if (amountOverride is int)
            {
                return (int)amountOverride;
            }

            return recycleAmount;
        }

        private bool PopulateOutputWithOverride(Recycler recycler, IngredientInfo[] customIngredientList, int recycleAmount, float recycleEfficiency = 1, bool forEditor = false)
        {
            var outputIsFull = false;

            foreach (var ingredientInfo in customIngredientList)
            {
                if (ingredientInfo.ItemDefinition == null)
                    continue;

                var ingredientAmount = ingredientInfo.Amount * recycleEfficiency;
                if (ingredientAmount <= 0)
                    continue;

                var outputAmount = CalculateOutputAmount(recycleAmount, ingredientAmount, forEditor: forEditor);
                if (outputAmount <= 0)
                    continue;

                if (AddItemToRecyclerOutput(recycler, ingredientInfo.ItemDefinition, outputAmount, ingredientInfo.SkinId, ingredientInfo.DisplayName))
                {
                    outputIsFull = true;
                }
            }

            return outputIsFull;
        }

        private static bool PopulateOutputVanilla(Configuration config, Recycler recycler, Item item, int recycleAmount, float recycleEfficiency = RecycleEfficiency, bool forEditor = false)
        {
            var outputIsFull = false;

            if (item.info.Blueprint.scrapFromRecycle > 0)
            {
                var scrapOutputMultiplier = config.OutputMultipliers.GetOutputMultiplier(ScrapItemId);

                var scrapAmount = Mathf.CeilToInt(item.info.Blueprint.scrapFromRecycle * recycleAmount);
                scrapAmount = Mathf.CeilToInt(scrapAmount * scrapOutputMultiplier);

                if (!forEditor && item.info.stackable == 1 && item.hasCondition)
                {
                    scrapAmount = Mathf.CeilToInt(scrapAmount * item.conditionNormalized);
                }

                if (scrapAmount >= 1)
                {
                    var scrapItem = ItemManager.CreateByItemID(ScrapItemId, scrapAmount);
                    recycler.MoveItemToOutput(scrapItem);
                }
            }

            foreach (var ingredient in item.info.Blueprint.ingredients)
            {
                // Skip scrap since it's handled separately.
                if (ingredient.itemDef.itemid == ScrapItemId)
                    continue;

                var ingredientAmount = ingredient.amount
                    * recycleEfficiency
                    / item.info.Blueprint.amountToCreate;

                if (ingredientAmount <= 0)
                    continue;

                var outputAmount = CalculateOutputAmount(
                    recycleAmount,
                    ingredientAmount,
                    config.OutputMultipliers.GetOutputMultiplier(ingredient.itemid),
                    forEditor
                );

                if (outputAmount <= 0)
                    continue;

                if (AddItemToRecyclerOutput(recycler, ingredient.itemDef, outputAmount))
                {
                    outputIsFull = true;
                }
            }

            return outputIsFull;
        }

        #endregion

        #region Helper Methods - Static

        public static void LogInfo(string message) => Interface.Oxide.LogInfo($"[Recycle Manager] {message}");
        public static void LogError(string message) => Interface.Oxide.LogError($"[Recycle Manager] {message}");
        public static void LogWarning(string message) => Interface.Oxide.LogWarning($"[Recycle Manager] {message}");

        private static void Swap<T>(ref T a, ref T b)
        {
            T temp = a;
            a = b;
            b = temp;
        }

        private static bool IsVanillaRecyclable(Item item)
        {
            return item.info.Blueprint != null;
        }

        private static bool RecyclableWasBlocked(Item item, Recycler recycler)
        {
            var hookResult = ExposedHooks.OnRecycleManagerItemRecyclable(item, recycler);
            return hookResult is bool && (bool)hookResult == false;
        }

        private static bool RecycleItemWasBlocked(Item item, Recycler recycler)
        {
            var hookResult = ExposedHooks.OnRecycleManagerRecycle(item, recycler);
            return hookResult is bool && (bool)hookResult == false;
        }

        private static Item CreateItem(ItemDefinition itemDefinition, int amount, ulong skinId, string displayName = null)
        {
            var item = ItemManager.Create(itemDefinition, amount, skinId);

            if (!string.IsNullOrWhiteSpace(displayName))
            {
                item.name = displayName;
            }

            return item;
        }

        private static int CalculateOutputAmountVanillaRandom(int recycleAmount, float ingredientChance)
        {
            var outputAmount = 0;

            // Roll a random number for every item to consume.
            for (var i = 0; i < recycleAmount; i++)
            {
                if (UnityEngine.Random.Range(0f, 1f) <= ingredientChance)
                {
                    outputAmount++;
                }
            }

            return outputAmount;
        }

        private static int CalculateOutputAmountFast(int recycleAmount, float ingredientAmount)
        {
            // To save on performance, don't generate hundreds/thousands/millions of random numbers.
            var fractionalOutputAmount = ingredientAmount * recycleAmount;

            var integerOutputAmount = (int)fractionalOutputAmount;

            // Roll a random number to see if the the remainder should be given.
            var remainderFractionalOutputAmount = fractionalOutputAmount - integerOutputAmount;
            if (remainderFractionalOutputAmount > 0 && UnityEngine.Random.Range(0f, 1f) <= remainderFractionalOutputAmount)
            {
                integerOutputAmount++;
            }

            return integerOutputAmount;
        }

        private static int CalculateOutputAmount(int recycleAmount, float ingredientAmount, float outputMultiplier = 1, bool forEditor = false)
        {
            // Adjust using vanilla rounding behavior before applying multipliers, to match user expectations.
            var adjustedIngredientAmount = ingredientAmount > 1
                ? Mathf.Ceil(ingredientAmount)
                : ingredientAmount;

            adjustedIngredientAmount *= outputMultiplier;

            // Use more optimized RNG for stacks larger than 100, because players probably don't care at that point.
            var outputAmount = adjustedIngredientAmount < 1 && recycleAmount <= 100
                ? CalculateOutputAmountVanillaRandom(recycleAmount, adjustedIngredientAmount)
                : CalculateOutputAmountFast(recycleAmount, adjustedIngredientAmount);

            return forEditor ? Math.Max(1, outputAmount) : outputAmount;
        }

        private static bool AddItemToRecyclerOutput(Recycler recycler, ItemDefinition itemDefinition, int ingredientAmount, ulong skinId = 0, string displayName = null)
        {
            var outputIsFull = false;
            var numStacks = Mathf.CeilToInt(ingredientAmount / (float)itemDefinition.stackable);

            for (var i = 0; i < numStacks; i++)
            {
                var amountForStack = Math.Min(ingredientAmount, itemDefinition.stackable);
                var outputItem = CreateItem(itemDefinition, amountForStack, skinId, displayName);

                if (!recycler.MoveItemToOutput(outputItem))
                {
                    outputIsFull = true;
                }

                ingredientAmount -= amountForStack;

                if (ingredientAmount <= 0)
                    break;
            }

            return outputIsFull;
        }

        #endregion

        #region UI

        private enum IdentificationType
        {
            Item,
            Skin,
            DisplayName,
        }

        private enum OutputType
        {
            NotRecyclable,
            Default,
            Custom,
        }

        private enum UICommand
        {
            Edit,
            Reset,
            Save,
            Cancel,
            InputPercentage,
            ChangeIdentificationType,
            ChangeOutputType,
        }

        [Flags]
        private enum LayoutOptions
        {
            AnchorBottom = 1 << 0,
            AnchorRight = 1 << 1,
            Vertical = 1 << 2,
        }

        private class LayoutProvider
        {
            public const string AnchorBottomLeft = "0 0";
            public const string AnchorBottomRight = "1 0";
            public const string AnchorTopLeft = "0 1";
            public const string AnchorTopRight = "1 1";

            public static LayoutProvider Once(float width = 0, float height = 0) =>
                _reusable.WithOffset().WithDimensions(width, height).WithOptions(0).WithSpacing(0);

            private static LayoutProvider _reusable = new LayoutProvider(0, 0);

            private LayoutOptions _options;
            private string _anchor;
            private float _x, _y;
            private float _xSpacing, _ySpacing;
            private float _width, _height;

            private bool _isVertical => (_options & LayoutOptions.Vertical) != 0;
            private bool _isLeftToRight => (_options & LayoutOptions.AnchorRight) == 0;
            private bool _isTopToBottom => (_options & LayoutOptions.AnchorBottom) == 0;
            private int _xSign => _isLeftToRight ? 1 : -1;
            private int _ySign => _isTopToBottom ? -1 : 1;
            private float XMin, XMax, YMin, YMax;

            public string AnchorMin => _anchor;
            public string AnchorMax => _anchor;
            public string OffsetMin => $"{XMin.ToString()} {YMin.ToString()}";
            public string OffsetMax => $"{XMax.ToString()} {YMax.ToString()}";

            public LayoutProvider(float width, float height)
            {
                WithDimensions(width, height);
                WithOptions(0);
            }

            public LayoutProvider WithDimensions(float width, float height)
            {
                _width = width;
                _height = height;
                return this;
            }

            public LayoutProvider WithOptions(LayoutOptions options)
            {
                _options = options;
                _anchor = DetermineAnchor();
                return this;
            }

            public LayoutProvider WithSpacing(float x, float y = float.MaxValue)
            {
                _xSpacing = x;
                _ySpacing = y != float.MaxValue ? y : x;
                return this;
            }

            public LayoutProvider WithOffset(float x = 0, float y = 0)
            {
                _x = x * _xSign;
                _y = y * _ySign;
                return this;
            }

            public LayoutProvider Next()
            {
                XMin = _x + _xSpacing * _xSign;
                YMin = _y + _ySpacing * _ySign;
                XMax = XMin + _width * _xSign;
                YMax = YMin + _height * _ySign;

                if (_isVertical)
                {
                    _y = YMax;
                }
                else
                {
                    _x = XMax;
                }

                if (YMin > YMax)
                {
                    Swap(ref YMin, ref YMax);
                }

                if (XMin > XMax)
                {
                    Swap(ref XMin, ref XMax);
                }

                return this;
            }

            public CuiRectTransformComponent GetRectTransform()
            {
                return new CuiRectTransformComponent
                {
                    AnchorMin = _anchor,
                    AnchorMax = _anchor,
                    OffsetMin = OffsetMin,
                    OffsetMax = OffsetMax,
                };
            }

            private string DetermineAnchor()
            {
                return _isTopToBottom
                    ? _isLeftToRight ? AnchorTopLeft : AnchorTopRight
                    : _isLeftToRight ? AnchorBottomLeft : AnchorBottomRight;
            }
        }

        private class ButtonColor
        {
            public readonly string Color;
            public readonly string TextColor;

            public ButtonColor(string color, string textColor)
            {
                Color = color;
                TextColor = textColor;
            }
        }

        private class ButtonColorScheme
        {
            public ButtonColor Active;
            public ButtonColor Enabled;
            public ButtonColor Disabled;

            public ButtonColor Get(bool active = false, bool enabled = false)
            {
                return active
                    ? Active
                    : enabled
                        ? Enabled
                        : Disabled;
            }
        }

        private class CuiInputFieldComponentHud : CuiInputFieldComponent
        {
            [JsonProperty("hudMenuInput", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public bool HudMenuInput { get; set; }
        }

        private class CuiElementRecreate : CuiElement
        {
            [JsonProperty("destroyUi", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public string DestroyUi { get; set; }
        }

        private static class EditUI
        {
            private const string UIName = "RecycleManager.UI";
            private const string EditPanelUIName = "RecycleManager.UI.EditPanel";
            private const string PercentagePanelUIName = "RecycleManager.UI.EditPanel.Percentages";

            private const string AnchorMin = "0.5 0";
            private const string AnchorMax = "0.5 0";

            private const float PanelWidth = 380.5f;
            private const float PanelHeight = 93f;
            private const float HeaderHeight = 21;

            private const int ItemPaddingLeft = 6;
            private const int ItemSize = 58;
            private const int ItemSpacing = 4;

            private const string BaseUICommand = "recyclemanager.ui";

            private const string TextColor = "0.8 0.8 0.8 1";
            private const string BackgroundColor = "0.25 0.25 0.25 1";

            private static ButtonColorScheme DefaultButtonColorScheme = new ButtonColorScheme
            {
                Active = new ButtonColor("0.25 0.5 0.75 1", "0.75 0.85 1 1"),
                Enabled = new ButtonColor("0.4 0.4 0.4 1", "0.71 0.71 0.71 1"),
                Disabled = new ButtonColor("0.4 0.4 0.4 0.5", "0.71 0.71 0.71 0.5"),
            };

            private static ButtonColorScheme SaveButtonColorScheme = new ButtonColorScheme
            {
                Enabled = new ButtonColor("0.451 0.553 0.271 1", "0.659 0.918 0.2 1"),
                Disabled = new ButtonColor("0.451 0.553 0.271 0.5", "0.659 0.918 0.2 0.5"),
            };

            private static ButtonColorScheme ResetButtonColorScheme = new ButtonColorScheme
            {
                Enabled = new ButtonColor("0.9 0.5 0.2 1", "1 0.9 0.7 1"),
                Disabled = new ButtonColor("0.9 0.5 0.2 0.25", "1 0.9 0.7 0.25"),
            };

            public static void DestroyUI(BasePlayer player)
            {
                CuiHelper.DestroyUi(player, UIName);
            }

            public static void DrawUI(RecycleManager plugin, BasePlayer player, EditState state)
            {
                if (state == null)
                {
                    DrawDefaultUI(plugin, player);
                }
                else
                {
                    DrawEditUI(plugin, player, state);
                }
            }

            private static void DrawDefaultUI(RecycleManager plugin, BasePlayer player)
            {
                var elements = CreateContainer();
                AddEditButton(elements, plugin, player);

                CuiHelper.AddUi(player, elements);
            }

            private static void DrawEditUI(RecycleManager plugin, BasePlayer player, EditState state)
            {
                var elements = CreateContainer();
                AddEditPanel(elements, plugin, player, state);

                CuiHelper.AddUi(player, elements);
            }

            private static CuiElementContainer CreateContainer()
            {
                var offsetY = 108f;
                var offsetX = 192f;

                return new CuiElementContainer
                {
                    {
                        new CuiElementRecreate
                        {
                            Parent = "Hud.Menu",
                            Name = UIName,
                            DestroyUi = UIName,
                            Components =
                            {
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = AnchorMin,
                                    AnchorMax = AnchorMax,
                                    OffsetMin = $"{offsetX} {offsetY}",
                                    OffsetMax = $"{offsetX} {offsetY}",
                                }
                            }
                        }
                    }
                };
            }

            private static void AddEditButton(CuiElementContainer elements, RecycleManager plugin, BasePlayer player)
            {
                var buttonWidth = 80f;
                var offsetX = PanelWidth - buttonWidth;
                var offsetY = 266f;

                elements.Add(new CuiButton
                {
                    Text =
                    {
                        Text = plugin.GetMessage(player.UserIDString, LangEntry.UIButtonAdmin),
                        Color = SaveButtonColorScheme.Enabled.TextColor,
                        Align = TextAnchor.MiddleCenter,
                        FontSize = 15,
                    },
                    Button =
                    {
                        Color = SaveButtonColorScheme.Enabled.Color,
                        Command = $"{BaseUICommand} {UICommand.Edit}",
                        FadeIn = 0.1f,
                    },
                    RectTransform =
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "0 0",
                        OffsetMin = $"{offsetX} {offsetY}",
                        OffsetMax = $"{offsetX + buttonWidth} {offsetY + HeaderHeight}",
                    },
                }, UIName);
            }

            private static void AddEditHeader(CuiElementContainer elements, RecycleManager plugin, BasePlayer player)
            {
                var offsetY = 266f;

                elements.Add(new CuiElement
                {
                    Parent = EditPanelUIName,
                    Components =
                    {
                        new CuiRawImageComponent
                        {
                            Color = BackgroundColor,
                            Sprite = "assets/content/ui/ui.background.tiletex.psd",
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "0 0",
                            OffsetMin = $"0 {offsetY}",
                            OffsetMax = $"{PanelWidth} {offsetY + HeaderHeight}",
                        },
                    },
                });

                elements.Add(new CuiElement
                {
                    Parent = EditPanelUIName,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = plugin.GetMessage(player.UserIDString, LangEntry.UIHeader),
                            Align = TextAnchor.MiddleLeft,
                            FontSize = 14,
                            Color = TextColor,
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "0 0",
                            OffsetMin = $"5 {offsetY}",
                            OffsetMax = $"{5 + PanelWidth} {offsetY + HeaderHeight}",
                        },
                    }
                });

                var buttonWidth = 80f;
                var offsetX = PanelWidth - buttonWidth;

                elements.Add(new CuiButton
                {
                    Text =
                    {
                        Text = plugin.GetMessage(player.UserIDString, LangEntry.UIButtonClose),
                        Color = DefaultButtonColorScheme.Enabled.TextColor,
                        Align = TextAnchor.MiddleCenter,
                        FontSize = 15,
                    },
                    Button =
                    {
                        Color = DefaultButtonColorScheme.Enabled.Color,
                        Command = $"{BaseUICommand} {UICommand.Cancel}",
                    },
                    RectTransform =
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "0 0",
                        OffsetMin = $"{offsetX} {offsetY}",
                        OffsetMax = $"{offsetX + buttonWidth} {offsetY + HeaderHeight}",
                    },
                }, UIName);
            }

            private static void AddEditPanel(CuiElementContainer elements, RecycleManager plugin, BasePlayer player, EditState state)
            {
                elements.Add(new CuiElement
                {
                    Parent = UIName,
                    Name = EditPanelUIName,
                    Components =
                    {
                        new CuiRawImageComponent
                        {
                            Color = BackgroundColor,
                            Sprite = "assets/content/ui/ui.background.tiletex.psd",
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = AnchorMin,
                            AnchorMax = AnchorMax,
                            OffsetMin = "0 0",
                            OffsetMax = $"{PanelWidth} {PanelHeight}",
                        },
                    },
                });

                AddEditHeader(elements, plugin, player);

                if (state.BlockedByAnotherPlugin)
                {
                    elements.Add(new CuiElement
                    {
                        Parent = EditPanelUIName,
                        Components =
                        {
                            new CuiTextComponent
                            {
                                Text = plugin.GetMessage(player.UserIDString, LangEntry.UIItemBlocked),
                                Align = TextAnchor.MiddleCenter,
                                FontSize = 12,
                                Color = TextColor,
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0 0",
                                AnchorMax = "1 1",
                            },
                        }
                    });
                    return;
                }

                AddPercentageControllers(elements, state);

                if (state.InputItem == null)
                {
                    elements.Add(new CuiElement
                    {
                        Parent = EditPanelUIName,
                        Components =
                        {
                            new CuiTextComponent
                            {
                                Text = plugin.GetMessage(player.UserIDString, LangEntry.UIEmptyState),
                                Align = TextAnchor.MiddleCenter,
                                FontSize = 12,
                                Color = TextColor,
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0 0",
                                AnchorMax = "1 1",
                            },
                        }
                    });
                    return;
                }

                AddItemIdentificationControls(elements, plugin, player, state);
                AddItemAllowedControls(elements, plugin, player, state);
                AddPrimaryControls(elements, plugin, player, state);
            }

            private static void AddPercentageControllers(CuiElementContainer elements, EditState state)
            {
                var offsetY = 169;

                elements.Add(new CuiElement
                {
                    Name = PercentagePanelUIName,
                    Parent = EditPanelUIName,
                    Components =
                    {
                        new CuiRawImageComponent
                        {
                            Color = BackgroundColor,
                            Sprite = "assets/content/ui/ui.background.tiletex.psd",
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "0 0",
                            OffsetMin = $"0 {offsetY}",
                            OffsetMax = $"{PanelWidth} {offsetY + HeaderHeight}",
                        },
                    },
                });

                if (state.InputItem == null)
                    return;

                for (var i = 0; i < 6; i++)
                {
                    if (state.Chances[i] <= 0)
                        continue;

                    var offsetX = ItemPaddingLeft + i * (ItemSize + ItemSpacing);

                    elements.Add(new CuiElement
                    {
                        Parent = PercentagePanelUIName,
                        Components =
                        {
                            new CuiInputFieldComponentHud
                            {
                                Align = TextAnchor.MiddleCenter,
                                HudMenuInput = true,
                                Text = $"{state.Chances[i]:0.##}%",
                                Color = TextColor,
                                CharsLimit = 6,
                                Command = $"{BaseUICommand} {UICommand.InputPercentage} {i}",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0 0",
                                AnchorMax = "0 0",
                                OffsetMin = $"{offsetX} 0",
                                OffsetMax = $"{offsetX + ItemSize} {HeaderHeight}",
                            },
                        },
                    });
                }
            }

            private static void AddButton(CuiElementContainer elements,
                LayoutProvider layoutProvider,
                ButtonColorScheme buttonColorScheme,
                string parent,
                string text,
                string command,
                bool active = false,
                bool enabled = true)
            {
                var buttonColor = buttonColorScheme.Get(active, enabled);

                elements.Add(new CuiButton
                {
                    Text =
                    {
                        Text = text,
                        Color = buttonColor.TextColor,
                        Align = TextAnchor.MiddleCenter,
                        FontSize = 12,
                    },
                    Button =
                    {
                        Color = buttonColor.Color,
                        Command = enabled && !active ? command : null,
                    },
                    RectTransform =
                    {
                        AnchorMin = layoutProvider.AnchorMin,
                        AnchorMax = layoutProvider.AnchorMax,
                        OffsetMin = layoutProvider.OffsetMin,
                        OffsetMax = layoutProvider.OffsetMax,
                    }
                }, parent);
            }

            private static void AddItemIdentificationControls(CuiElementContainer elements, RecycleManager plugin, BasePlayer player, EditState state)
            {
                var spacingX = 5;
                var spacingY = 2;
                var paddingY = 5;
                var numElements = 4;

                var columnWidth = PanelWidth / 3f;
                var elementHeight = (PanelHeight - 2 * paddingY - (numElements - 1) * spacingY) / numElements;

                var layoutProvider = LayoutProvider.Once(columnWidth - 2 * spacingX, elementHeight)
                    .WithOffset(0, paddingY - spacingY)
                    .WithSpacing(spacingX, spacingY)
                    .WithOptions(LayoutOptions.Vertical);

                elements.Add(new CuiElement
                {
                    Parent = EditPanelUIName,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = plugin.GetMessage(player.UserIDString, LangEntry.UILabelConfigureBy),
                            Align = TextAnchor.MiddleCenter,
                            FontSize = 12,
                            Color = TextColor,
                        },
                        layoutProvider.Next().GetRectTransform(),
                    }
                });

                AddButton(elements,
                    layoutProvider.Next(),
                    DefaultButtonColorScheme,
                    EditPanelUIName,
                    plugin.GetMessage(player.UserIDString, LangEntry.UIButtonItem),
                    $"{BaseUICommand} {UICommand.ChangeIdentificationType} {IdentificationType.Item}",
                    state.IdentificationType == IdentificationType.Item,
                    state.InputItem.skin != 0);

                AddButton(elements,
                    layoutProvider.Next(),
                    DefaultButtonColorScheme,
                    EditPanelUIName,
                    plugin.GetMessage(player.UserIDString, LangEntry.UIButtonSkin),
                    $"{BaseUICommand} {UICommand.ChangeIdentificationType} {IdentificationType.Skin}",
                    state.IdentificationType == IdentificationType.Skin,
                    state.InputItem.skin != 0);

                AddButton(elements,
                    layoutProvider.Next(),
                    DefaultButtonColorScheme,
                    EditPanelUIName,
                    plugin.GetMessage(player.UserIDString, LangEntry.UIButtonDisplayName),
                    $"{BaseUICommand} {UICommand.ChangeIdentificationType} {IdentificationType.DisplayName}",
                    state.IdentificationType == IdentificationType.DisplayName,
                    !string.IsNullOrWhiteSpace(state.InputItem.name));
            }

            private static void AddItemAllowedControls(CuiElementContainer elements, RecycleManager plugin, BasePlayer player, EditState state)
            {
                var spacingX = 5;
                var spacingY = 2;
                var paddingY = 5;
                var numElements = 4;

                var columnWidth = PanelWidth / 3f;
                var elementHeight = (PanelHeight - 2 * paddingY - (numElements - 1) * spacingY) / numElements;

                var layoutProvider = LayoutProvider.Once(columnWidth - 2 * spacingX, elementHeight)
                    .WithOffset(columnWidth, paddingY - spacingY)
                    .WithSpacing(spacingX, spacingY)
                    .WithOptions(LayoutOptions.Vertical);

                elements.Add(new CuiElement
                {
                    Parent = EditPanelUIName,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = plugin.GetMessage(player.UserIDString, LangEntry.UILabelOutput),
                            Align = TextAnchor.MiddleCenter,
                            FontSize = 12,
                            Color = TextColor,
                        },
                        layoutProvider.Next().GetRectTransform(),
                    }
                });

                AddButton(elements,
                    layoutProvider.Next(),
                    DefaultButtonColorScheme,
                    EditPanelUIName,
                    plugin.GetMessage(player.UserIDString, LangEntry.UIButtonNotRecyclable),
                    $"{BaseUICommand} {UICommand.ChangeOutputType} {OutputType.NotRecyclable}",
                    state.OutputType == OutputType.NotRecyclable);

                AddButton(elements,
                    layoutProvider.Next(),
                    DefaultButtonColorScheme,
                    EditPanelUIName,
                    plugin.GetMessage(player.UserIDString, LangEntry.UIButtonDefaultOutput),
                    $"{BaseUICommand} {UICommand.ChangeOutputType} {OutputType.Default}",
                    state.OutputType == OutputType.Default,
                    state.IdentificationType != IdentificationType.Item || IsVanillaRecyclable(state.InputItem));

                AddButton(elements,
                    layoutProvider.Next(),
                    DefaultButtonColorScheme,
                    EditPanelUIName,
                    plugin.GetMessage(player.UserIDString, LangEntry.UIButtonCustomOutput),
                    $"{BaseUICommand} {UICommand.ChangeOutputType} {OutputType.Custom}",
                    state.OutputType == OutputType.Custom);
            }

            private static void AddPrimaryControls(CuiElementContainer elements, RecycleManager plugin, BasePlayer player, EditState state)
            {
                var spacingX = 5;
                var spacingY = 2;
                var paddingY = 5;
                var numElements = 4;

                var columnWidth = PanelWidth / 3f;
                var elementHeight = (PanelHeight - 2 * paddingY - (numElements - 1) * spacingY) / numElements;

                var layoutProvider = LayoutProvider.Once(columnWidth - 2 * spacingX, elementHeight)
                    .WithOffset(2 * columnWidth, paddingY - spacingY)
                    .WithSpacing(spacingX, spacingY)
                    .WithOptions(LayoutOptions.Vertical);

                elements.Add(new CuiElement
                {
                    Parent = EditPanelUIName,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = plugin.GetMessage(player.UserIDString, LangEntry.UILabelActions),
                            Align = TextAnchor.MiddleCenter,
                            FontSize = 12,
                            Color = TextColor,
                        },
                        layoutProvider.Next().GetRectTransform(),
                    }
                });

                AddButton(elements,
                    layoutProvider.Next(),
                    SaveButtonColorScheme,
                    EditPanelUIName,
                    plugin.GetMessage(player.UserIDString, LangEntry.UIButtonSave),
                    $"{BaseUICommand} {UICommand.Save}",
                    enabled: state.CanSave);

                AddButton(elements,
                    layoutProvider.Next(),
                    ResetButtonColorScheme,
                    EditPanelUIName,
                    plugin.GetMessage(player.UserIDString, LangEntry.UIButtonReset),
                    $"{BaseUICommand} {UICommand.Reset}",
                    enabled: state.CanReset);

                AddButton(elements,
                    layoutProvider.Next(),
                    DefaultButtonColorScheme,
                    EditPanelUIName,
                    plugin.GetMessage(player.UserIDString, LangEntry.UIButtonCancel),
                    $"{BaseUICommand} {UICommand.Cancel}");
            }
        }

        #endregion

        #region Edit Controller

        private class EditState
        {
            public Item InputItem;
            public IdentificationType IdentificationType;
            public OutputType OutputType;

            public float[] Chances = new float[NumOutputSlots];

            public bool BlockedByAnotherPlugin;
            public bool CanSave;
            public bool CanReset;
        }

        private class EditController : FacepunchBehaviour
        {
            public static EditController AddToRecycler(RecycleManager plugin, RecycleEditManager recycleEditManager, Recycler recycler)
            {
                var component = recycler.gameObject.AddComponent<EditController>();
                component._plugin = plugin;
