        {
            return DateTime.Now.ToString("HH:mm:ss");
        }

        // From RustCore Class, thank you Rust/Oxide.
        private static string FormatBytes(long bytes)
        {
            if (bytes < 1024L)
                return $"{bytes} B";
            if (bytes < 1048576L)
                return $"{bytes / 1024.0} KB";
            return bytes < 1073741824L ? $"{Math.Round(bytes / 1048576.0, 3)} MB" : $"{Math.Round(bytes / 1073741824.0, 3)} GB";
        }

        private static string FormatBytes(double bytes)
        {
            if (bytes < 1024L)
                return $"{bytes} B";
            if (bytes < 1048576L)
                return $"{bytes / 1024.0} KB";
            return bytes < 1073741824L ? $"{Math.Round(bytes / 1048576.0, 3)} MB" : $"{Math.Round(bytes / 1073741824.0, 3)} GB";
        }

        #endregion

        #region Configuration | 2.0.0

        private static ConfigData config = new ConfigData();

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Save file dates in European Format 27-06-2023 (other format is North American 06-27-2023)")]
            public bool EuropeanTimeSave = false;

            [JsonProperty(PropertyName = "Create reports every (seconds)")]
            public int checkTime = 0;

            [JsonProperty(PropertyName = "Create plugins report")]
            public bool runPluginsReport = true;

            [JsonProperty(PropertyName = "Sort Plugins By Hook Time (If set false, sorts by Memory Usage)")]
            public bool sortByHookTime = true;

            [JsonProperty(PropertyName = "Create entities report")]
            public bool runEntitiesReport = true;

            [JsonProperty(PropertyName = "Excluded entities")]
            public string[] excludedEntities =
            {
                "shortname here",
                "another here"
            };

            [JsonProperty(PropertyName = "Excluded plugins")]
            public string[] excludedPlugins =
            {
                "name here",
                "another name"
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigData>();

                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                PrintError("Configuration file is corrupt! Check your config file at https://jsonlint.com/");

                timer.Every(10f,
                    () =>
                    {
                        PrintError("Configuration file is corrupt! Check your config file at https://jsonlint.com/");
                    });
                LoadDefaultConfig();
                return;
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            config = new ConfigData();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion

        #region Classes

        private class PerformanceDump
        {
            [JsonProperty(PropertyName = "Online Players")]
            public int onlinePlayers = BasePlayer.activePlayerList.Count;

            [JsonProperty(PropertyName = "Offline Players")]
            public int offlinePlayers = BasePlayer.sleepingPlayerList.Count;

            [JsonProperty(PropertyName = "Entities Report")]
            public EntitiesReport entities = new EntitiesReport();

            [JsonProperty(PropertyName = "Plugins Report")]
            public string[] plugins;

            [JsonProperty(PropertyName = "Performance Report")]
            public Performance.Tick performance = Performance.current;

            [JsonIgnore]
            public int statusBar;

            [JsonIgnore]
            public int entitiesChecked;

            [JsonIgnore]
            public int entitiesTotal;
        }

        private class EntitiesReport
        {
            [JsonProperty(PropertyName = "Total")]
            public int countGlobal;

            [JsonProperty(PropertyName = "Owned")]
            public int countOwned;

            [JsonProperty(PropertyName = "Unowned")]
            public int countUnowned;

            [JsonProperty(PropertyName = "List")]
            public Dictionary<string, EntityInfo> list = new Dictionary<string, EntityInfo>();

            [JsonIgnore]
            public bool completed;
        }

        private class EntityInfo
        {
            [JsonProperty(PropertyName = "Total")]
            public int countGlobal;

            [JsonProperty(PropertyName = "Owned")]
            public int countOwned;

            [JsonProperty(PropertyName = "Unowned")]
            public int countUnowned;
        }

        #endregion
    }
}

// --- End of file: PerformanceMonitor.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/CustomCraft.cs ---
// --- Original Local Path: CustomCraft.cs ---

﻿using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using ConVar;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Rust;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("CustomCraft", "CASHR", "1.0.0")]
    public class CustomCraft : RustPlugin
    {
        [PluginReference] private Plugin ImageLibrary;

        public string Layer = "UI_CustomCraft.Craft";
        public string LayerBlur = "UI.CustomCraft.Blur";

        public Dictionary<ulong, int> playerModifity = new Dictionary<ulong, int>();
        #region Config       
        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<Configuration>();
        }


        protected override void LoadDefaultConfig()
        {
            _config = new Configuration()
            {
                items = new List<ItemInfo>()
            };
        }

        public Configuration _config;

        public class Configuration
        {
            [JsonProperty("Новые предметы")] public List<ItemInfo> items = new List<ItemInfo>();
        }

        public class ItemInfo
        {
            [JsonProperty("Название предмета")] public string name = "";
            [JsonProperty("Текст кнопки")] public string textBtn = "";
            [JsonProperty("Шортнейм предмета")] public string shortname = "";
            [JsonProperty("Айди предмета")] public int idItem = 0;
            [JsonProperty("Верстак для крафта")] public int WorkBench = 1;
            [JsonProperty("Время крафта( в секундках) ")] public float timeCraft = 60f;
            [JsonProperty("Крафтить шт")] public int countCraft = 1;
            [JsonProperty("СкинИД предмета[Не менять]")] public ulong skinID = 0U;
            [JsonProperty("Ссылка на иконку")] public string png = null;
            [JsonProperty("Отображать крафт предмета")] public bool isCrafted = true;
            [JsonProperty("Описание для крафта")] public string descriptionCraft = "Тестовый предмет";
            [JsonProperty("Предметы для крафта")] public List<CraftInfo> craftItems = new List<CraftInfo>();
        }

        public class CraftInfo
        {
            [JsonProperty("Шортнейм предмета")] public string shortname = "";
            [JsonProperty("Иконка предмета")] public string icons = null;
            [JsonProperty("Количество предмета")] public int amount = 0;
            [JsonProperty("СкинИД предмета")] public ulong skinID = 0U;
            [JsonProperty("АйтемИД предмета")] public int itemID = 0;
        }

        #endregion

        #region Command
        [ChatCommand("craft")]
        void chatCmdCraft(BasePlayer player, string command, string[] args)
        {
            CraftGUI(player);


        }
        [ConsoleCommand("UI_CustomCraft")]
        void consoleCmdCustomCraft(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection?.player as BasePlayer;

            if (player == null) return;

            ItemInfo craftItem = null;

            var name = "";
            var amount = 0;

            foreach (var args in arg.Args)
            {
                if (args == "choicecraft" || args == "close" || args == "craftitem" || args == "addmodifity" ||
                    args == "removemodifity") continue;
                if (name.Length == 0)
                {
                    name += args;
                }
                else name += $" {args}";
            }

            if (arg.GetString(0).Equals("close") || arg.GetString(0).Equals("giveitems"))
            {

            }
            else
            {
                craftItem = _config.items.Find(x => x.name.Contains(name));
                if (craftItem == null) return;
            }

            CuiElementContainer container = new CuiElementContainer();

            switch (arg.GetString(0))
            {
                case "giveitems":

                    foreach (var item in _config.items)
                    {
                        Item newItem = ItemManager.CreateByItemID(item.idItem, item.countCraft, item.skinID);

                        newItem.name = item.name;

                        player.GiveItem(newItem);
                    }

                    break;

                case "craftitem":

                    var success = true;

                    Dictionary<Item, int> items = new Dictionary<Item, int>();

                    foreach (var craftedItem in craftItem.craftItems)
                    {

                        var haveItem = HaveItem(player, craftedItem.itemID, craftedItem.skinID, craftedItem.amount);
                        if (!haveItem)
                        {
                            success = false;
                            SendReply(player,
                                "<color=#afafaf>Вы не можете скрафтить предмет! Не хватает ингредиента!</color>");
                            return;
                        }
                        var item = FindItem(player, craftedItem.itemID, craftedItem.skinID, craftedItem.amount);

                        items.Add(item, craftedItem.amount * playerModifity[player.userID]);
                    }

                    foreach (var item in items)
                    {
                        item.Key.UseItem(item.Value);
                    }

                    if (success)
                    {
                        player.SendConsoleCommand("UI_Craft close");
                        Item craft = ItemManager.CreateByName(craftItem.shortname, craftItem.countCraft * playerModifity[player.userID], craftItem.skinID);

                        craft.name = craftItem.name;


                        player.GiveItem(craft);
                    }

                    break;

                case "addmodifity":

                    playerModifity[player.userID] += 1;

                    CuiHelper.DestroyUi(player, Layer + ".CountPanel.Text");

                    amount = craftItem.countCraft * playerModifity[player.userID];

                    container.Add(new CuiLabel()
                    {
                        RectTransform = { AnchorMin = "0.1 0", AnchorMax = "0.9 1" },
                        Text =
                            {
                                Align = TextAnchor.MiddleCenter, Text = $"{amount} шт.",
                                FontSize = 28
                            }
                    }, Layer + ".CountPanel", Layer + ".CountPanel.Text");

                    CuiHelper.AddUi(player, container);

                    UpdateItemsInfo(player, name);

                    break;

                case "removemodifity":

                    if (playerModifity[player.userID] == craftItem.countCraft) return;
                    playerModifity[player.userID] -= 1;

                    CuiHelper.DestroyUi(player, Layer + ".CountPanel.Text");

                    amount = craftItem.countCraft * playerModifity[player.userID];

                    container.Add(new CuiLabel()
                    {
                        RectTransform = { AnchorMin = "0.1 0", AnchorMax = "0.9 1" },
                        Text =
                            {
                                Align = TextAnchor.MiddleCenter, Text = $"{amount} шт.",
                                FontSize = 28
                            }
                    }, Layer + ".CountPanel", Layer + ".CountPanel.Text");

                    container.Add(new CuiButton()
                    {
                        RectTransform =
                            {
                                AnchorMin = $"0.463021 {0.246296 - 0.093519}",
                                AnchorMax = $"0.504688 {0.32037 - 0.093519}"
                            },
                        Button =
                            {
                                Color = "0 0 0 0.8",
                                Command = $"UI_CustomCraft removemodifity {craftItem.name}",

                            },
                        Text =
                            {
                                Align = TextAnchor.MiddleCenter, Color = "1 1 1 1", Text = "<b>-</b>", FontSize = 24
                            }
                    }, Layer, Layer + ".Btn1");

                    container.Add(new CuiButton()
                    {
                        RectTransform =
                            {
                                AnchorMin = $"0.615106 {0.246296 - 0.093519}",
                                AnchorMax = $"0.656772 {0.32037 - 0.093519}"
                            },
                        Button =
                            {
                                Color = "0 0 0 0.8",
                                Command = $"UI_CustomCraft addmodifity {craftItem.name}",

                            },
                        Text =
                            {
                                Align = TextAnchor.MiddleCenter, Color = "1 1 1 1", Text = "<b>+</b>", FontSize = 24
                            }
                    }, Layer, Layer + ".Btn2");

                    CuiHelper.AddUi(player, container);

                    UpdateItemsInfo(player, name);

                    break;

                case "close":

                    CuiHelper.DestroyUi(player, Layer);
                    CuiHelper.DestroyUi(player, LayerBlur);

                    break;

                case "choicecraft":

                    CuiHelper.DestroyUi(player, Layer + ".Items");
                    CuiHelper.DestroyUi(player, Layer + ".TextBox");
                    CuiHelper.DestroyUi(player, Layer + ".Menu.MainImage");
                    CuiHelper.DestroyUi(player, Layer + ".Btn1");
                    CuiHelper.DestroyUi(player, Layer + ".Btn2");
                    CuiHelper.DestroyUi(player, Layer + ".Btn3");
                    CuiHelper.DestroyUi(player, Layer + ".CountPanel.Text");

                    playerModifity[player.userID] = 1;

                    container.Add(new CuiLabel()
                    {
                        RectTransform = { AnchorMin = "0.1 0", AnchorMax = "0.9 1" },
                        Text =
                            {
                                Align = TextAnchor.MiddleCenter, Text = $"{craftItem.countCraft * playerModifity[player.userID]} шт.",
                                FontSize = 28
                            }
                    }, Layer + ".CountPanel", Layer + ".CountPanel.Text");

                    container.Add(new CuiButton()
                    {
                        RectTransform =
                            {
                                AnchorMin = $"0.6635427 {0.246296 - 0.093519}",
                                AnchorMax = $"0.8380209 {0.32037 - 0.093519}"
                            },
                        Button =
                            {
                                Color = "0 0 0 0.8",
                                Command = $"UI_CustomCraft craftitem {craftItem.name}"
                            },
                        Text =
                            {
                                Align = TextAnchor.MiddleCenter, Color = "1 1 1 1", Text = "<b>СКРАФТИТЬ</b>",
                                FontSize = 24
                            }
                    }, Layer, Layer + ".Btn3");

                    container.Add(new CuiButton()
                    {
                        RectTransform =
                            {
                                AnchorMin = $"0.463021 {0.246296 - 0.093519}",
                                AnchorMax = $"0.504688 {0.32037 - 0.093519}"
                            },
                        Button =
                            {
                                Color = "0 0 0 0.8",
                                Command = $"UI_CustomCraft removemodifity {craftItem.name}",

                            },
                        Text =
                            {
                                Align = TextAnchor.MiddleCenter, Color = "1 1 1 1", Text = "<b>-</b>", FontSize = 24
                            }
                    }, Layer, Layer + ".Btn1");

                    container.Add(new CuiButton()
                    {
                        RectTransform =
                            {
                                AnchorMin = $"0.615106 {0.246296 - 0.093519}",
                                AnchorMax = $"0.656772 {0.32037 - 0.093519}"
                            },
                        Button =
                            {
                                Color = "0 0 0 0.8",
                                Command = $"UI_CustomCraft addmodifity {craftItem.name}",

                            },
                        Text =
                            {
                                Align = TextAnchor.MiddleCenter, Color = "1 1 1 1", Text = "<b>+</b>", FontSize = 24
                            }
                    }, Layer, Layer + ".Btn2");

                    container.Add(new CuiPanel()
                    {
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                        Image = { Color = "0 0 0 0" }
                    }, Layer + ".Menu", Layer + ".Items");

                    container.Add(new CuiPanel()
                    {
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                        Image = { Color = "0 0 0 0" }
                    }, Layer + ".Menu", Layer + ".TextBox");

                    container.Add(new CuiElement()
                    {
                        Parent = Layer + ".Menu",
                        Name = Layer + ".Menu.MainImage",
                        Components =
                        {
                            new CuiRawImageComponent()
                            {
                                Color = "1 1 1 1",
                                Png = craftItem.png == null
                                    ? GetImage(craftItem.shortname) : GetImage(craftItem.png),

                            },
                            new CuiRectTransformComponent()
                            {
                                AnchorMin = $"0.422221 0.453911",
                                AnchorMax = $"0.83889 0.933911"
                            },
                        }
                    });

                    container.Add(new CuiLabel()
                    {
                        RectTransform = { AnchorMin = $"0.184722 0.9184", AnchorMax = "0.773611 0.9952" },
                        Text =
                            {
                                Align = TextAnchor.MiddleCenter, Color = HexToRGB("#FFFFFFD6"),
                                Text = $"<b>{craftItem.name}</b>", FontSize = 20
                            }
                    }, Layer + ".TextBox");

                    container.Add(new CuiLabel()
                    {
                        RectTransform = { AnchorMin = $"0.020833 0.435201", AnchorMax = "0.405555 0.904" },
                        Text =
                            {
                                Align = TextAnchor.UpperCenter, Color = HexToRGB("#FFFFFFD6"),
                                Text = $"<size=20>Описание предмета:</size>\n <color=#00bfff>{craftItem.descriptionCraft}</color>",
                                FontSize = 16
                            }
                    }, Layer + ".TextBox");

                    float minPosition = 0f;
                    var itemWidth = (0.193633f - 0.054745f);
                    var itemHeight = 0.421575f - 0.261575f;
                    var itemCount = craftItem.craftItems.Count;
                    var itemMargin = 0.019399f;

                    if (itemCount >= 5)
                        minPosition = 0.5f - 5 / 2f * itemWidth - (5 - 1) / 2f * itemMargin;
                    else minPosition = 0.5f - itemCount / 2f * itemWidth - (itemCount - 1) / 2f * itemMargin;
                    itemCount -= 5;

                    var minHeight = 0.238401f;
                    var modifity = 1;

                    var countItem = 0;
                    foreach (var item in craftItem.craftItems)
                    {
                        countItem += 1;

                        var haveItem = HaveItem(player, item.itemID, item.skinID, item.amount * modifity);
                        container.Add(new CuiElement()
                        {
                            Parent = Layer + ".Items",
                            Name = Layer + $".Item{item.shortname}",
                            Components =
                            {
                                new CuiImageComponent()
                                {
                                    Color = haveItem ? HexToRGB("#80A47DFF") : HexToRGB("#A47D7DFF"),

                                },
                                new CuiOutlineComponent()
                                {
                                    Color = haveItem ? HexToRGB("#A0D29CFF") : HexToRGB("#C29494FF"),
                                    Distance = "2 2",
                                },
                                new CuiRectTransformComponent()
                                {
                                    AnchorMin = $"{minPosition} {minHeight}",
                                    AnchorMax = $"{minPosition + itemWidth} {minHeight + itemHeight}"
                                },
                            }
                        });
                        string png;
                        if (item.icons != null)
                        {
                            png = GetImage(item.icons);
                        }
                        else
                        {
                            png = GetImage(item.shortname);
                        }
                        container.Add(new CuiElement()
                        {
                            Parent = Layer + $".Item{item.shortname}",
                            Name = Layer + $".Item{item.shortname}.Image",
                            Components =
                            {
                                new CuiRawImageComponent()
                                {
                                    Color = "1 1 1 1",
                                    Png = png,

                                },
                                new CuiRectTransformComponent()
                                {
                                    AnchorMin = "0 0", AnchorMax = "1 1"
                                },
                            }
                        });

                        container.Add(new CuiLabel()
                        {
                            Text =
                                {
                                    Text = $"x{item.amount * modifity}", Align = TextAnchor.LowerRight, FontSize = 12
                                },
                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "-3 -3" }
                        }, Layer + $".Item{item.shortname}.Image");

                        if (countItem % 5 == 0)
                        {
                            if (itemCount > 5)
                            {
                                minPosition = 0.5f - 5 / 2f * itemWidth - (5 - 1) / 2f * itemMargin;
                                itemCount -= 5;
                            }
                            else
                            {
                                minPosition = 0.5f - itemCount / 2f * itemWidth - (itemCount - 1) / 2f * itemMargin;
                            }

                            minHeight -= ((itemMargin * 2) + itemHeight);
                        }
                        else
                        {
                            minPosition += (itemWidth + itemMargin);
                        }
                    }

                    CuiHelper.AddUi(player, container);

                    break;
            }
        }

        #endregion

        #region OxideHooks
       
        private void OnServerInitialized()
        {

            LoadConfig();
            SaveConfig();

            Dictionary<string, string> images = new Dictionary<string, string>();

            foreach (var craftItem in _config.items)
            {
                if (craftItem.png != null)
                {
                    ImageLibrary.Call("AddImage", craftItem.png, craftItem.png);
                }

                foreach (var item in craftItem.craftItems)
                {
                    ImageLibrary.Call("AddImage", $"https://rustlabs.com/img/items180/{item.shortname}.png",
                        item.shortname);
                    if (item.icons != null)
                    {
                        ImageLibrary.Call("AddImage", $"{item.icons}",
                            item.icons);
                    }
                }
            }
        }        

        #endregion

        #region Function
        public void ReplyWithHelper(BasePlayer player, string message, string[] args = null)
        {
            if (args != null)
                message = string.Format(message, args);
            player.SendConsoleCommand("chat.add 0", new object[2]
            {
                76561198090669418,
                string.Format("<size=16><color={2}>{0}</color>:</size>\n{1}", "Виртуальный помощник:", message, "#00bfff")
            });
        }       
        private static string HexToRGB(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);
            return $"{color.r:F2} {color.g:F2} {color.b:F2} {color.a:F2}";
        }
        public Item FindItem(BasePlayer player, int itemID, ulong skinID, int amount)
        {
            Item item = null;

            if (skinID == 0U)
            {
                if (player.inventory.FindItemID(itemID) != null && player.inventory.FindItemID(itemID).amount >= amount)
                    return player.inventory.FindItemID(itemID);
            }
            else
            {

                List<Item> items = new List<Item>();

                items.AddRange(player.inventory.FindItemIDs(itemID));

                foreach (var findItem in items)
                {
                    if (findItem.skin == skinID && findItem.amount >= amount)
                    {
                        return findItem;
                    }
                }
            }

            return item;
        }
        public bool HaveItem(BasePlayer player, int itemID, ulong skinID, int amount)
        {
            if (skinID == 0U)
            {
                if (player.inventory.FindItemID(itemID) != null &&
                    player.inventory.FindItemID(itemID).amount >= amount) return true;
                return false;
            }
            else
            {

                List<Item> items = new List<Item>();

                items.AddRange(player.inventory.FindItemIDs(itemID));

                foreach (var item in items)
                {
                    if (item.skin == skinID && item.amount >= amount)
                    {
                        return true;
                    }
                }
            }

            return false;
        }
        private string GetImage(string fileName, ulong skin = 0)
        {
            var imageId = (string)plugins.Find("ImageLibrary").CallHook("GetImage", fileName, skin);
            if (!string.IsNullOrEmpty(imageId))
                return imageId;
            return string.Empty;
        }
        #endregion

        #region GUI
        public void UpdateItemsInfo(BasePlayer player, string name)
        {
            CuiHelper.DestroyUi(player, Layer + ".Items");

            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiPanel()
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Image = { Color = "0 0 0 0" }
            }, Layer + ".Menu", Layer + ".Items");

            var craftItem = _config.items.Find(x => x.name.Contains(name));

            float minPosition = 0f;
            var itemWidth = (0.193633f - 0.054745f);
            var itemHeight = 0.421575f - 0.261575f;
            var itemCount = craftItem.craftItems.Count;
            var itemMargin = 0.019399f;

            if (itemCount >= 5)
                minPosition = 0.5f - 5 / 2f * itemWidth - (5 - 1) / 2f * itemMargin;
            else minPosition = 0.5f - itemCount / 2f * itemWidth - (itemCount - 1) / 2f * itemMargin;
            itemCount -= 5;

            var minHeight = 0.238401f;
            var modifity = playerModifity[player.userID];

            var countItem = 0;
            foreach (var item in craftItem.craftItems)
            {
                countItem += 1;

                var haveItem = HaveItem(player, item.itemID, item.skinID, item.amount * modifity);

                container.Add(new CuiElement()
                {
                    Parent = Layer + ".Items",
                    Name = Layer + $".Item{item.shortname}",
                    Components =
                    {
                        new CuiImageComponent()
                        {
                            Color = haveItem ? HexToRGB("#80A47DFF") : HexToRGB("#A47D7DFF"),
                            Sprite = "Assets/Content/UI/UI.Background.Tile.psd"
                        },
                        new CuiOutlineComponent()
                        {
                            Color = haveItem ? HexToRGB("#A0D29CFF") : HexToRGB("#C29494FF"),
                            Distance = "2 2",
                        },
                        new CuiRectTransformComponent()
                        {
                            AnchorMin = $"{minPosition} {minHeight}",
                            AnchorMax = $"{minPosition + itemWidth} {minHeight + itemHeight}"
                        },
                    }
                });
                string png;
                if (item.icons != null)
                {
                    png = GetImage(item.icons);
                }
                else
                {
                    png = GetImage(item.shortname);
                }
                container.Add(new CuiElement()
                {
                    Parent = Layer + $".Item{item.shortname}",
                    Name = Layer + $".Item{item.shortname}.Image",
                    Components =
                    {
                        new CuiRawImageComponent()
                        {
                            Color = "1 1 1 1",
                            Png = png,
                        },
                        new CuiRectTransformComponent()
                        {
                            AnchorMin = "0 0", AnchorMax = "1 1"
                        },
                    }
                });

                container.Add(new CuiLabel()
                {
                    Text =
                        {
                            Text = $"x{item.amount * modifity}", Align = TextAnchor.LowerRight, FontSize = 12
                        },
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "-3 -3" }
                }, Layer + $".Item{item.shortname}.Image");

                if (countItem % 5 == 0)
                {
                    if (itemCount > 5)
                    {
                        minPosition = 0.5f - 5 / 2f * itemWidth - (5 - 1) / 2f * itemMargin;
                        itemCount -= 5;
                    }
                    else
                    {
                        minPosition = 0.5f - itemCount / 2f * itemWidth - (itemCount - 1) / 2f * itemMargin;
                    }

                    minHeight -= ((itemMargin * 2) + itemHeight);
                }
                else
                {
                    minPosition += (itemWidth + itemMargin);
                }
            }

            CuiHelper.AddUi(player, container);
        }
        private void CraftGUI(BasePlayer player)
        {            
            CuiHelper.DestroyUi(player, Layer);
            CuiHelper.DestroyUi(player, LayerBlur);

            playerModifity[player.userID] = 1;

            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiPanel()
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0.8", Material = "assets/content/ui/uibackgroundblur.mat" }
            }, "Overlay", LayerBlur);

            container.Add(new CuiButton()
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Button = { Command = "UI_CustomCraft close", Color = "0 0 0 0" },
                Text = { Text = "" }
            }, "Overlay", Layer);

            container.Add(new CuiLabel()
            {
                RectTransform = { AnchorMin = "0.2942708 0.9148148", AnchorMax = "0.6432291 0.9898146" },
                Text = { Align = TextAnchor.MiddleCenter, Text = "<b>СИСТЕМА УНИКАЛЬНЫХ ПРЕДМЕТОВ</b>", FontSize = 28 }
            }, Layer);

            var buttonHeight = (0.926852f - 0.873148f);
            var buttonMargin = (0.873148f - 0.853706f);
            var buttonCount = _config.items.Count;

            var buttonMinHeight = 0.45f + buttonCount / 2f * buttonHeight + (buttonCount - 1) / 2f * buttonMargin;

            foreach (var craftItem in _config.items)
            {
                container.Add(new CuiButton()
                {
                    RectTransform =
                    {
                        AnchorMin = $"{0.008854} {buttonMinHeight}",
                        AnchorMax = $"{0.225521} {buttonMinHeight + buttonHeight}"
                    },
                    Button = { Color = "0 191 255 0.5", Command = $"UI_CustomCraft choicecraft {craftItem.name}", },
                    Text = { Align = TextAnchor.MiddleCenter, Color = "1 1 1 1", Text = craftItem.textBtn, FontSize = 18 }
                }, Layer);

                buttonMinHeight -= (buttonHeight + buttonMargin);
            }           
                
            var currentCraft = _config.items.ElementAt(0);

            container.Add(new CuiPanel()
            {
                RectTransform =
                        {AnchorMin = $"0.463021 {0.332407 - 0.093519}", AnchorMax = $"0.838021 {0.911111 - 0.093519}"},
                Image = { Color = "0 0 0 0.8", }
            }, Layer, Layer + ".Menu");

            container.Add(new CuiPanel()
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Image = { Color = "0 0 0 0" }
            }, Layer + ".Menu", Layer + ".Items");

            container.Add(new CuiElement()
            {
                Parent = Layer + ".Menu",
                Name = Layer + ".Menu.MainImage",
                Components =
                {
                    new CuiRawImageComponent()
                    {
                        Color = "1 1 1 1",
                        Png = currentCraft.png == null
                            ? GetImage(currentCraft.shortname) : GetImage(currentCraft.png),

                    },
                    new CuiRectTransformComponent()
                    {
                        AnchorMin = $"0.422221 0.453911",
                        AnchorMax = $"0.83889 0.933911"
                    },
                }
            });

            container.Add(new CuiPanel()
            {
                RectTransform =
                        {AnchorMin = $"0.510417 {0.246296 - 0.093519}", AnchorMax = $"0.609375 {0.32037 - 0.093519}"},
                Image = { Color = "0 0 0 0.8", },
            }, Layer, Layer + ".CountPanel");

            var modifity = 1;

            container.Add(new CuiLabel()
            {
                RectTransform = { AnchorMin = "0.1 0", AnchorMax = "0.9 1" },
                Text =
                    {
                        Align = TextAnchor.MiddleCenter, Text = $"{currentCraft.countCraft * modifity} шт.",
                        FontSize = 28
                    }
            }, Layer + ".CountPanel", Layer + ".CountPanel.Text");

            container.Add(new CuiButton()
            {
                RectTransform =
                    {AnchorMin = $"0.463021 {0.246296 - 0.093519}", AnchorMax = $"0.504688 {0.32037 - 0.093519}"},
                Button = { Color = "0 0 0 0.8", Command = $"UI_CustomCraft removemodifity {currentCraft.name}", },
                Text = { Align = TextAnchor.MiddleCenter, Color = "1 1 1 1", Text = "<b>-</b>", FontSize = 24 }
            }, Layer, Layer + ".Btn1");

            container.Add(new CuiButton()
            {
                RectTransform =
                    {AnchorMin = $"0.615106 {0.246296 - 0.093519}", AnchorMax = $"0.656772 {0.32037 - 0.093519}"},
                Button = { Color = "0 0 0 0.8", Command = $"UI_CustomCraft addmodifity {currentCraft.name}", },
                Text = { Align = TextAnchor.MiddleCenter, Color = "1 1 1 1", Text = "<b>+</b>", FontSize = 24 }
            }, Layer, Layer + ".Btn2");

            container.Add(new CuiButton()
            {
                RectTransform =
                    {AnchorMin = $"0.6635427 {0.246296 - 0.093519}", AnchorMax = $"0.8380209 {0.32037 - 0.093519}"},
                Button = { Color = "0 0 0 0.8", Command = $"UI_CustomCraft craftitem {currentCraft.name}" },
                Text = { Align = TextAnchor.MiddleCenter, Color = "1 1 1 1", Text = "<b>СКРАФТИТЬ</b>", FontSize = 24 }
            }, Layer, Layer + ".Btn3");

            container.Add(new CuiPanel()
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Image = { Color = "0 0 0 0" }
            }, Layer + ".Menu", Layer + ".TextBox");

            container.Add(new CuiLabel()
            {
                RectTransform = { AnchorMin = $"0.184722 0.9184", AnchorMax = "0.773611 0.9952" },
                Text = { Align = TextAnchor.MiddleCenter, Color = HexToRGB("#FFFFFFD6"), Text = $"<b>{currentCraft.name}</b>", FontSize = 20 }
            }, Layer + ".TextBox");

            container.Add(new CuiLabel()
            {
                RectTransform = { AnchorMin = $"0.020833 0.435201", AnchorMax = "0.405555 0.904" },
                Text = { Align = TextAnchor.UpperCenter, Color = HexToRGB("#FFFFFFD6"), Text = $"<size=20>Описание предмета:</size>\n{currentCraft.descriptionCraft}", FontSize = 16 }
            }, Layer + ".TextBox");

            float minPosition = 0f;
            var itemWidth = (0.193633f - 0.054745f);
            var itemHeight = 0.421575f - 0.261575f;
            var itemCount = currentCraft.craftItems.Count;
            var itemMargin = 0.019399f;

            if (itemCount >= 5)
                minPosition = 0.5f - 5 / 2f * itemWidth - (5 - 1) / 2f * itemMargin;
            else minPosition = 0.5f - itemCount / 2f * itemWidth - (itemCount - 1) / 2f * itemMargin;
            itemCount -= 5;

            var minHeight = 0.238401f;

            var countItem = 0;
            foreach (var item in currentCraft.craftItems)
            {
                countItem += 1;

                var haveItem = HaveItem(player, item.itemID, item.skinID, item.amount * modifity);

                container.Add(new CuiElement()
                {
                    Parent = Layer + ".Items",
                    Name = Layer + $".Item{item.shortname}",
                    Components =
                    {
                        new CuiImageComponent()
                        {
                            Color = haveItem ? HexToRGB("#80A47DFF") : HexToRGB("#A47D7DFF"),
                            Sprite = "Assets/Content/UI/UI.Background.Tile.psd"
                        },
                        new CuiOutlineComponent()
                        {
                            Color = haveItem ? HexToRGB("#A0D29CFF") : HexToRGB("#C29494FF"),
                            Distance = "2 2",
                        },
                        new CuiRectTransformComponent()
                        {
                            AnchorMin = $"{minPosition} {minHeight}",
                            AnchorMax = $"{minPosition + itemWidth} {minHeight + itemHeight}"
                        },
                    }
                });
                string png;
                if (item.icons != null)
                {
                    png = GetImage(item.icons);
                }
                else
                {
                    png = GetImage(item.shortname);
                }
                container.Add(new CuiElement()
                {
                    Parent = Layer + $".Item{item.shortname}",
                    Name = Layer + $".Item{item.shortname}.Image",
                    Components =
                    {
                        new CuiRawImageComponent()
                        {
                            Color = "1 1 1 1",
                            Png = png,

                        },
                        new CuiRectTransformComponent()
                        {
                            AnchorMin = "0 0", AnchorMax = "1 1"
                        },
                    }
                });

                container.Add(new CuiLabel()
                {
                    Text = { Text = $"x{item.amount * modifity}", Align = TextAnchor.LowerRight, FontSize = 12 },
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "-3 -3" }
                }, Layer + $".Item{item.shortname}.Image");

                if (countItem % 5 == 0)
                {
                    if (itemCount > 5)
                    {
                        minPosition = 0.5f - 5 / 2f * itemWidth - (5 - 1) / 2f * itemMargin;
                        itemCount -= 5;
                    }
                    else
                    {
                        minPosition = 0.5f - itemCount / 2f * itemWidth - (itemCount - 1) / 2f * itemMargin;
                    }

                    minHeight -= ((itemMargin * 2) + itemHeight);
                }
                else
                {
                    minPosition += (itemWidth + itemMargin);
                }

            }

            CuiHelper.AddUi(player, container);
        }
        #endregion
    }
}

// --- End of file: CustomCraft.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Kits (1).cs ---
// --- Original Local Path: Kits (1).cs ---

﻿using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using System.Globalization;
using Oxide.Core;
using System.IO;

namespace Oxide.Plugins
{
    [Info("Kits", "RustPlugin.ru", "3.2.51")]
    class Kits : RustPlugin
    {
        private PluginConfig _config;
        private ImagesCache _imagesCache = new ImagesCache();
        private List<Kit> _kits;
        private Dictionary<ulong, Dictionary<string, KitData>> _kitsData;
        private Dictionary<BasePlayer, List<string>> _kitsGUI = new Dictionary<BasePlayer, List<string>>();

        #region Classes

        class PluginConfig
        {
            public Position Position { get; set; }
            public Position CloseButtonPosition { get; set; }
            public Position CloseButtonPositionNext1 { get; set; }
            public Position CloseButtonPositionNext2 { get; set; }
            public Position CloseButtonPositionNext3 { get; set; }
            public string CloseButtonColor { get; set; }
            public string MainBackgroundColor { get; set; }

            public string DefaultKitImage { get; set; }
            public float MarginTop { get; set; }
            public float MarginBottom { get; set; }
            public float MarginBetween { get; set; }
            public float KitWidth { get; set; }
            public string DisableMaskColor { get; set; }
            public string KitBackgroundColor { get; set; }
            public List<string> CustomAutoKits;
            public ImageConfig Image { get; set; }
            public LabelConfig Label { get; set; }
            public LabelConfig Amount { get; set; }
            public LabelConfig Time { get; set; }

            public static PluginConfig CreateDefault()
            {
                return new PluginConfig
                {
                    CustomAutoKits = new List<string>()
                    {
                        "autokit1",
                        "autokit2"
                    },
                    MainBackgroundColor = "#00000088",
                    Position = new Position
                    {
                        AnchorMin = "0 0.35",
                        AnchorMax = "1 0.65"
                    },
                    CloseButtonPosition = new Position
                    {
                        AnchorMin = "0.95 0.8",
                        AnchorMax = "0.997 0.98"
                    },
                    CloseButtonPositionNext1 = new Position
                    {
                        AnchorMin = "0.95 0.6",
                        AnchorMax = "0.997 0.78"
                    },
                    CloseButtonPositionNext2 = new Position
                    {
                        AnchorMin = "0.95 0.4",
                        AnchorMax = "0.997 0.58"
                    },
                    CloseButtonPositionNext3 = new Position
                    {
                        AnchorMin = "0.95 0.1",
                        AnchorMax = "0.997 0.38"
                    },
                    CloseButtonColor = "0 0 0 0.70",

                    DefaultKitImage = "file://" + Interface.Oxide.DataDirectory + Path.DirectorySeparatorChar + "Kits" + Path.DirectorySeparatorChar + "home.png",
                    KitWidth = 0.12f,
                    MarginTop = 0.04f,
                    MarginBottom = 0.03f,
                    DisableMaskColor = "#000000DD",
                    MarginBetween = 0.01f,
                    KitBackgroundColor = "#00000088",

                    Image = new ImageConfig
                    {
                        Color = "#FFFFFFFF",
                        Position = new Position
                        {
                            AnchorMin = "0.05 0.15",
                            AnchorMax = "0.95 0.95"
                        },
                        Png = ""
                    },
                    Label = new LabelConfig
                    {
                        Position = new Position
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "1 0.15"
                        },
                        FontSize = 14,
                        ForegroundColor = "#FFFFFFFF",
                        BackgroundColor = "#00000000",
                        TextAnchor = TextAnchor.MiddleCenter
                    },
                    Amount = new LabelConfig
                    {
                        Position = new Position
                        {
                            AnchorMin = "0.05 0.85",
                            AnchorMax = "0.95 0.95"
                        },
                        FontSize = 14,
                        ForegroundColor = "#FFFFFFFF",
                        BackgroundColor = "#00000000",
                        TextAnchor = TextAnchor.MiddleCenter
                    },
                    Time = new LabelConfig
                    {
                        Position = new Position
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "1 1"
                        },
                        FontSize = 14,
                        ForegroundColor = "#FFFFFFFF",
                        BackgroundColor = "#00000000",
                        TextAnchor = TextAnchor.MiddleCenter
                    }
                };
            }

            public class LabelConfig
            {
                public Position Position { get; set; }
                public string ForegroundColor { get; set; }
                public string BackgroundColor { get; set; }
                public int FontSize { get; set; }
                public TextAnchor TextAnchor { get; set; }
            }

            public class ImageConfig
            {
                public Position Position { get; set; }
                public string Color { get; set; }
                public string Png { get; set; }
            }
        }

        public class Kit
        {
            public string Name { get; set; }
            public string DisplayName { get; set; }
            public int Amount { get; set; }
            public double Cooldown { get; set; }
            public bool Hide { get; set; }
            public string Permission { get; set; }
            public List<KitItem> Items { get; set; }

            public string Png { get; set; }
        }

        public class KitItem
        {
            public string ShortName { get; set; }
            public int Amount { get; set; }
            public int Blueprint { get; set; }
            public ulong SkinID { get; set; }
            public string Container { get; set; }
            public float Condition { get; set; }
            public Weapon Weapon { get; set; }
            public List<ItemContent> Content { get; set; }

        }
        public class Weapon
        {
            public string ammoType { get; set; }
            public int ammoAmount { get; set; }
        }
        public class ItemContent
        {
            public string ShortName { get; set; }
            public float Condition { get; set; }
            public int Amount { get; set; }
        }

        public class KitData
        {
            public int Amount { get; set; }
            public double Cooldown { get; set; }
        }

        public class Position
        {
            public string AnchorMin { get; set; }
            public string AnchorMax { get; set; }
        }

        public class ImagesCache : MonoBehaviour
        {
            private Dictionary<string, string> _images = new Dictionary<string, string>();

            public void Add(string name, string url)
            {
                if (_images.ContainsKey(name))
                    return;

                using (var www = new WWW(url))
                {
                    if (www.error != null)
                    {
                        print(string.Format("Image loading fail! Error: {0}", www.error));
                    }
                    else
                    {
                        if (www.bytes == null || www.bytes.Count() == 0)
                        {
                            Interface.Oxide.LogError($"Failed to add image for {name}. File address possibly invalide\n {url}");
                            return;
                        }

                        _images[name] = FileStorage.server.Store(www.bytes, FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID).ToString();
                    }
                }
            }
            public string Get(string name)
            {
                if (_images.ContainsKey(name))
                    return _images[name];

                return string.Empty;
            }
        }

        #endregion

        #region Oxide hooks

        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            Config.WriteObject(PluginConfig.CreateDefault(), true);
            PrintWarning("Благодарим за приобритение плагина на сайте RustPlugin.ru. Если вы приобрели этот плагин на другом ресурсе знайте - это лишает вас гарантированных обновлений!");
        }

        void OnPlayerRespawned(BasePlayer player)
        {
            foreach (var kits in _config.CustomAutoKits)
            {
                if (_kits.Exists(x => x.Name == kits))
                {
                    var kit1 = _kits.First(x => x.Name == kits);
                    if (permission.UserHasPermission(player.UserIDString, kit1.Permission))
                    {
                        player.inventory.Strip();
                        GiveItems(player, kit1);
                        return;
                    }
                }
            }
            if (_kits.Exists(x => x.Name == "autokit"))
            {
                player.inventory.Strip();
                var kit = _kits.First(x => x.Name == "autokit");
                GiveItems(player, kit);
            }

        }
        private void SaveKits()
        {
            Interface.Oxide.DataFileSystem.WriteObject("Kits", _kits);
        }

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject("Kits_Data", _kitsData);
        }

        void OnServerSave()
        {
            SaveData();
            SaveKits();
        }


        private void LoadMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Kit Was Removed"] = "<color=#008B8B>[Сервер]:</color> Kit {kitname} was removed",
                ["Kit Doesn't Exist"] = "<color=#008B8B>[Сервер]:</color> This kit doesn't exist",
                ["Not Found Player"] = "<color=#008B8B>[Сервер]:</color> Player not found",
                ["To Many Player"] = "<color=#008B8B>[Сервер]:</color> Found multipy players",
                ["Permission Denied"] = "<color=#008B8B>[Сервер]:</color> Access denied",
                ["Limite Denied"] = "<color=#008B8B>[Сервер]:</color> Useage limite reached",
                ["Cooldown Denied"] = "<color=#008B8B>[Сервер]:</color> You will be able to use this kit after {time}",
                ["Reset"] = "<color=#008B8B>[Сервер]:</color> Kits data wiped",
                ["Kit Already Exist"] = "<color=#008B8B>[Сервер]:</color> Kit with the same name already exist",
                ["Kit Created"] = "<color=#008B8B>[Сервер]:</color> You have created a new kit - {name}",
                ["Kit Extradited"] = "<color=#008B8B>[Сервер]:</color> You have claimed kit - {kitname}",
                ["Kit Cloned"] = "<color=#008B8B>[Сервер]:</color> You inventory was copyed to the kit",
                ["UI Amount"] = "Timeleft: {amount}",
                ["Help"] = "/kit name|add|clone|remove|list|reset",
                ["Help Add"] = "/kit add <kitname>",
                ["Help Clone"] = "/kit clone <kitname>",
                ["Help Remove"] = "/kit remove <kitname>",
                ["Help Give"] = "/kit give <kitname> <playerName|steamID>",
                ["Give Succes"] = "You have successfully given the player {0} a set {1}",
                ["No Space"] = "Can't redeem kit. Not enought space"
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Kit Was Removed"] = "<color=#008B8B>[Сервер]:</color> {kitname} был удалён",
                ["Kit Doesn't Exist"] = "<color=#008B8B>[Сервер]:</color> Этого комплекта не существует",
                ["Not Found Player"] = "<color=#008B8B>[Сервер]:</color> Игрок не найден",
                ["To Many Player"] = "<color=#008B8B>[Сервер]:</color> Найдено несколько игроков",
                ["Permission Denied"] = "<color=#008B8B>[Сервер]:</color> У вас нет полномочий использовать этот комплект",
                ["Limite Denied"] = "<color=#008B8B>[Сервер]:</color> Вы уже использовали этот комплект максимальное количество раз",
                ["Cooldown Denied"] = "<color=#008B8B>[Сервер]:</color> Вы сможете использовать этот комплект через {time}",
                ["Reset"] = "<color=#008B8B>[Сервер]:</color> Вы обнулили все данные о использовании комплектов игроков",
                ["Kit Already Exist"] = "<color=#008B8B>[Сервер]:</color> Этот набор уже существует",
                ["Kit Created"] = "<color=#008B8B>[Сервер]:</color> Вы создали новый набор - {name}",
                ["Kit Extradited"] = "<color=#008B8B>[Сервер]:</color> Вы получили комплект {kitname}",
                ["Kit Cloned"] = "<color=#008B8B>[Сервер]:</color> Предметы были скопированы из инвентаря в набор",
                ["UI Amount"] = "Осталось: {amount}",
                ["Help"] = "/kit name|add|clone|remove|list|reset",
                ["Help Add"] = "/kit add <kitname>",
                ["Help Clone"] = "/kit clone <kitname>",
                ["Help Remove"] = "/kit remove <kitname>",
                ["Help Give"] = "/kit give <kitname> <playerName|steamID>",
                ["Give Succes"] = "Вы успешно выдали игрок {0} набор {1}",
                ["No Space"] = "Невозможно получить набор - недостаточно места в инвентаре"
            }, this, "ru");
        }

        private void Loaded()
        {
            _config = Config.ReadObject<PluginConfig>();
            _kits = Interface.Oxide.DataFileSystem.ReadObject<List<Kit>>("Kits");
            _kitsData = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, Dictionary<string, KitData>>>("Kits_Data");

            LoadMessages();
        }

        private void Unload()
        {
            SaveData();

            foreach (var player in BasePlayer.activePlayerList)
            {
                DestroyUI(player);
            }
        }

        private void OnServerInitialized()
        {
            foreach (var kit in _kits)
            {
                _imagesCache.Add(kit.Name, kit.Png);
                if (!permission.PermissionExists(kit.Permission))
                    permission.RegisterPermission(kit.Permission, this);
            }

            timer.Repeat(1, 0, RefreshCooldownKitsUI);
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            _kitsGUI.Remove(player);
        }

        #endregion

        #region Commands

        [ConsoleCommand("kit")]
        private void CommandConsoleKit(ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null)
                return;

            var player = arg.Player();

            if (!arg.HasArgs())
                return;

            var value = arg.Args[0].ToLower();

            if (value == "ui")
            {
                TriggerUI(player);
                return;
            }

            if (value == "next1")
            {
                TriggerUI(player);
                TriggerUI1(player);
                return;
            }

            if (value == "next2")
            {
                TriggerUI(player);
                TriggerUI2(player);
                return;
            }

            if (value == "next3")
            {
                TriggerUI(player);
                TriggerUI3(player);
                return;
            }


            if (!_kitsGUI.ContainsKey(player))
                return;

            if (!_kitsGUI[player].Contains(value))
                return;

            GiveKit(player, value);

            var container = new CuiElementContainer();
            var kit = _kits.First(x => x.Name == value);
            var playerData = GetPlayerData(player.userID, value);

            if (kit.Amount > 0)
            {
                if (playerData.Amount >= kit.Amount)
                {
                    foreach (var kitname in _kitsGUI[player])
                    {
                        CuiHelper.DestroyUi(player, $"ui.kits.{kitname}.button");
                        CuiHelper.DestroyUi(player, $"ui.kits.{kitname}.amount");
                        CuiHelper.DestroyUi(player, $"ui.kits.{kitname}");
                    }

                    InitilizeKitsUI(ref container, player);
                    CuiHelper.AddUi(player, container);
                    return;
                }

                CuiHelper.DestroyUi(player, $"ui.kits.{value}.amount");
                InitilizeAmountLabelUI(ref container, value, GetMsg("UI Amount", player).Replace("{amount}", (kit.Amount - playerData.Amount).ToString()));
            }

            if (kit.Cooldown > 0)
            {
                var currentTime = GetCurrentTime();
                if (playerData.Cooldown > currentTime)
                {
                    CuiHelper.DestroyUi(player, $"ui.kits.{value}.button");

                    InitilizeMaskUI(ref container, kit.Name);
                    InitilizeCooldownLabelUI(ref container, value, TimeSpan.FromSeconds(playerData.Cooldown - currentTime));
                }
            }

            CuiHelper.AddUi(player, container);

            return;
        }

        [ChatCommand("kit")]
        private void CommandChatKit(BasePlayer player, string command, string[] args)
        {
            if (player == null)
                return;

            if (args.Length == 0)
            {
                TriggerUI(player);
                return;
            }

            if (!player.IsAdmin)
            {
                GiveKit(player, args[0].ToLower());
                return;
            }

            switch (args[0].ToLower())
            {
                case "help":
                    SendReply(player, GetMsg("Help", player));
                    return;
                case "add":
                    if (args.Length < 2)
                        SendReply(player, GetMsg("Help Add", player));
                    else
                        KitCommandAdd(player, args[1].ToLower());
                    return;
                case "clone":
                    if (args.Length < 2)
                        SendReply(player, GetMsg("Help Clone", player));
                    else
                        KitCommandClone(player, args[1].ToLower());
                    return;
                case "remove":
                    if (args.Length < 2)
                        SendReply(player, GetMsg("Help Remove", player));
                    else
                        KitCommandRemove(player, args[1].ToLower());
                    return;
                case "list":
                    KitCommandList(player);
                    return;
                case "reset":
                    KitCommandReset(player);
                    return;
                case "give":
                    if (args.Length < 3)
                    {
                        SendReply(player, GetMsg("Help Give", player));
                    }
                    else
                    {
                        var foundPlayer = FindPlayer(player, args[1].ToLower());
                        if (foundPlayer == null)
                            return;
                        SendReply(player, GetMsg("Give Succes", player), foundPlayer.displayName, args[2]);
                        KitCommandGive(player, foundPlayer, args[2].ToLower());
                    }
                    return;
                default:
                    GiveKit(player, args[0].ToLower());
                    return;
            }
        }

        #endregion

        #region Kits

        private bool GiveKit(BasePlayer player, string kitname)
        {
            if (string.IsNullOrEmpty(kitname))
                return false;

            if (Interface.Oxide.CallHook("canRedeemKit", player) != null)
            {
                return false;
            }
            if (!_kits.Exists(x => x.Name == kitname))
            {
                SendReply(player, GetMsg("Kit Doesn't Exist", player));
                return false;
            }

            var kit = _kits.First(x => x.Name == kitname);

            if (!string.IsNullOrEmpty(kit.Permission) && !permission.UserHasPermission(player.UserIDString, kit.Permission))
            {
                SendReply(player, GetMsg("Permission Denied", player));
                return false;
            }

            var playerData = GetPlayerData(player.userID, kitname);

            if (kit.Amount > 0 && playerData.Amount >= kit.Amount)
            {
                SendReply(player, GetMsg("Limite Denied", player));
                return false;
            }

            if (kit.Cooldown > 0)
            {
                var currentTime = GetCurrentTime();
                if (playerData.Cooldown > currentTime)
                {
                    SendReply(player, GetMsg("Cooldown Denied", player).Replace("{time}", TimeExtensions.FormatTime(TimeSpan.FromSeconds(playerData.Cooldown - currentTime))));
                    return false;
                }
            }

            //foreach (var item in kit.Items)
            //    player.GiveItem(ItemManager.CreateByName(item.ShortName, item.Amount, item.Skin));
            int beltcount = kit.Items.Where(i => i.Container == "belt").Count();
            int wearcount = kit.Items.Where(i => i.Container == "wear").Count();
            int maincount = kit.Items.Where(i => i.Container == "main").Count();
            int totalcount = beltcount + wearcount + maincount;
            if ((player.inventory.containerBelt.capacity - player.inventory.containerBelt.itemList.Count) < beltcount || (player.inventory.containerWear.capacity - player.inventory.containerWear.itemList.Count) < wearcount || (player.inventory.containerMain.capacity - player.inventory.containerMain.itemList.Count) < maincount)
                if (totalcount > (player.inventory.containerMain.capacity - player.inventory.containerMain.itemList.Count))
                {
                    player.ChatMessage(GetMsg("No Space", player));
                    return false;
                }
            GiveItems(player, kit);

            if (kit.Amount > 0)
                playerData.Amount += 1;

            if (kit.Cooldown > 0)
                playerData.Cooldown = GetCurrentTime() + kit.Cooldown;

            SendReply(player, GetMsg("Kit Extradited", player).Replace("{kitname}", kit.DisplayName));
            return true;
        }

        private void KitCommandAdd(BasePlayer player, string kitname)
        {
            if (_kits.Exists(x => x.Name == kitname))
            {
                SendReply(player, GetMsg("Kit Already Exist", player));
                return;
            }

            _kits.Add(new Kit
            {
                Name = kitname,
                DisplayName = kitname,
                Cooldown = 600,
                Hide = true,
                Permission = "kits.default",
                Amount = 0,
                Png = _config.DefaultKitImage,
                Items = GetPlayerItems(player)
            });
            permission.RegisterPermission($"kits.default", this);
            SendReply(player, GetMsg("Kit Created", player).Replace("{name}", kitname));

            SaveKits();
            SaveData();
        }

        private void KitCommandClone(BasePlayer player, string kitname)
        {
            if (!_kits.Exists(x => x.Name == kitname))
            {
                SendReply(player, GetMsg("Kit Doesn't Exist", player));
                return;
            }

            _kits.First(x => x.Name == kitname).Items = GetPlayerItems(player);

            SendReply(player, GetMsg("Kit Cloned", player).Replace("{name}", kitname));

            SaveKits();
        }

        private void KitCommandRemove(BasePlayer player, string kitname)
        {
            if (_kits.RemoveAll(x => x.Name == kitname) <= 0)
            {
                SendReply(player, GetMsg("Kit Doesn't Exist", player));
                return;
            }

            SendReply(player, GetMsg("Kit Was Removed", player).Replace("{kitname}", kitname));

            SaveKits();
        }

        private void KitCommandList(BasePlayer player)
        {
            foreach (var kit in _kits)
                SendReply(player, $"{kit.Name} - {kit.DisplayName}");
        }

        private void KitCommandReset(BasePlayer player)
        {
            _kitsData.Clear();

            SendReply(player, GetMsg("Reset", player));
        }

        private void KitCommandGive(BasePlayer player, BasePlayer foundPlayer, string kitname)
        {
            var reply = 1;
            if (reply == 0) { }
            if (!_kits.Exists(x => x.Name == reply.ToString())) { }

            if (!_kits.Exists(x => x.Name == kitname))
            {
                SendReply(player, GetMsg("Kit Doesn't Exist", player));
                return;
            }

            GiveItems(foundPlayer, _kits.First(x => x.Name == kitname));
        }
        private void GiveItems(BasePlayer player, Kit kit)
        {
            foreach (var kitem in kit.Items)
            {
                GiveItem(player,
                    BuildItem(kitem.ShortName, kitem.Amount, kitem.SkinID, kitem.Condition, kitem.Blueprint,
                        kitem.Weapon, kitem.Content),
                    kitem.Container == "belt" ? player.inventory.containerBelt :
                    kitem.Container == "wear" ? player.inventory.containerWear : player.inventory.containerMain);
            }
        }
        private void GiveItem(BasePlayer player, Item item, ItemContainer cont = null)
        {
            if (item == null) return;
            var inv = player.inventory;

            var moved = item.MoveToContainer(cont) || item.MoveToContainer(inv.containerMain);
            if (!moved)
            {
                if (cont == inv.containerBelt)
                    moved = item.MoveToContainer(inv.containerWear);
                if (cont == inv.containerWear)
                    moved = item.MoveToContainer(inv.containerBelt);
            }

            if (!moved)
                item.Drop(player.GetCenter(),player.GetDropVelocity());
        }
        private Item BuildItem(string ShortName, int Amount, ulong SkinID, float Condition, int blueprintTarget, Weapon weapon, List<ItemContent> Content)
        {
            Item item = ItemManager.CreateByName(ShortName, Amount > 1 ? Amount : 1, SkinID);
            item.condition = Condition;

            if (blueprintTarget != 0)
                item.blueprintTarget = blueprintTarget;

            if (weapon != null)
            {
                (item.GetHeldEntity() as BaseProjectile).primaryMagazine.contents = weapon.ammoAmount;
                (item.GetHeldEntity() as BaseProjectile).primaryMagazine.ammoType = ItemManager.FindItemDefinition(weapon.ammoType);
            }
            if (Content != null)
            {
                foreach (var cont in Content)
                {
                    Item new_cont = ItemManager.CreateByName(cont.ShortName, cont.Amount);
                    new_cont.condition = cont.Condition;
                    new_cont.MoveToContainer(item.contents);
                }
            }
            return item;
        }
        #endregion

        #region UI

        private void TriggerUI(BasePlayer player)
        {
            if (_kitsGUI.ContainsKey(player))
                DestroyUI(player);
            else
                InitilizeUI(player);
        }

        private void TriggerUI2(BasePlayer player)
        {
            InitilizeUI2(player);
        }

        private void TriggerUI3(BasePlayer player)
        {
            InitilizeUI3(player);
        }

        private void TriggerUI1(BasePlayer player)
        {
            InitilizeUI(player);
        }

        private void InitilizeUI(BasePlayer player)
        {
            var kits = GetKitsForPlayer(player).ToList();
            var container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                Image = { Color = HexToRustFormat(_config.MainBackgroundColor) },
                RectTransform = { AnchorMin = _config.Position.AnchorMin, AnchorMax = _config.Position.AnchorMax },
                CursorEnabled = true
            }, name: "ui.kits");
            container.Add(new CuiButton
            {
                Button = { Command = "kit ui", Color = _config.CloseButtonColor },
                RectTransform = { AnchorMin = _config.CloseButtonPosition.AnchorMin, AnchorMax = _config.CloseButtonPosition.AnchorMax },
                Text = { Text = "X", FontSize = 20, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter }
            }, "ui.kits");
            foreach (var kit in kits)
            {
                if (kits.Count > 7)
                {
                    container.Add(new CuiButton
                    {
                        Button = { Command = "kit next2", Color = "0 0 0 0.15" },
                        RectTransform = { AnchorMin = "0.965 0.3", AnchorMax = "0.997 0.7" },
                        Text = { Text = ">", FontSize = 20, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter }
                    }, "ui.kits");
                }
            }

            InitilizeKitsUI(ref container, player);

            CuiHelper.AddUi(player, container);
        }
        private void InitilizeUI2(BasePlayer player)
        {
            var kits = GetKitsForPlayer(player).ToList();
            var container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                Image = { Color = HexToRustFormat(_config.MainBackgroundColor) },
                RectTransform = { AnchorMin = _config.Position.AnchorMin, AnchorMax = _config.Position.AnchorMax },
                CursorEnabled = true
            }, name: "ui.kits");
            container.Add(new CuiButton
            {
                Button = { Command = "kit ui", Color = _config.CloseButtonColor },
                RectTransform = { AnchorMin = _config.CloseButtonPosition.AnchorMin, AnchorMax = _config.CloseButtonPosition.AnchorMax },
                Text = { Text = "X", FontSize = 20, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter }
            }, "ui.kits");

            foreach (var kit in kits)
            {
                if (kits.Count > 14)
                {
                    container.Add(new CuiButton
                    {
                        Button = { Command = "kit next1", Color = "0 0 0 0.15" },
                        RectTransform = { AnchorMin = "0.002 0.3", AnchorMax = "0.035 0.7" },
                        Text = { Text = "<", FontSize = 20, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter }
                    }, "ui.kits");

                    container.Add(new CuiButton
                    {
                        Button = { Command = "kit next3", Color = "0 0 0 0.15" },
                        RectTransform = { AnchorMin = "0.965 0.3", AnchorMax = "0.997 0.7" },
                        Text = { Text = ">", FontSize = 20, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter }
                    }, "ui.kits");
                }
                else if (kits.Count > 7)
                {
                    container.Add(new CuiButton
                    {
                        Button = { Command = "kit next1", Color = "0 0 0 0.15" },
                        RectTransform = { AnchorMin = "0.002 0.3", AnchorMax = "0.035 0.7" },
                        Text = { Text = "<", FontSize = 20, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter }
                    }, "ui.kits");

                }
            }


            if (kits.Count < 7)
            {
                InitilizeKitsUI(ref container, player);
            }
            else
            {
                InitilizeKitsUINext(ref container, player);
            }

            CuiHelper.AddUi(player, container);
        }

        private void InitilizeUI3(BasePlayer player)
        {
            var kits = GetKitsForPlayer(player).ToList();
            var container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                Image = { Color = HexToRustFormat(_config.MainBackgroundColor) },
                RectTransform = { AnchorMin = _config.Position.AnchorMin, AnchorMax = _config.Position.AnchorMax },
                CursorEnabled = true
            }, name: "ui.kits");
            container.Add(new CuiButton
            {
                Button = { Command = "kit ui", Color = _config.CloseButtonColor },
                RectTransform = { AnchorMin = _config.CloseButtonPosition.AnchorMin, AnchorMax = _config.CloseButtonPosition.AnchorMax },
                Text = { Text = "X", FontSize = 20, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter }
            }, "ui.kits");

            foreach (var kit in kits)
            {
                if (kits.Count > 14)
                {
                    container.Add(new CuiButton
                    {
                        Button = { Command = "kit next2", Color = "0 0 0 0.15" },
                        RectTransform = { AnchorMin = "0.002 0.3", AnchorMax = "0.035 0.7" },
                        Text = { Text = "<", FontSize = 20, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter }
                    }, "ui.kits");


                }
                else if (kits.Count > 7)
                {
                    container.Add(new CuiButton
                    {
                        Button = { Command = "kit next1", Color = _config.CloseButtonColor },
                        RectTransform = { AnchorMin = _config.CloseButtonPositionNext1.AnchorMin, AnchorMax = _config.CloseButtonPositionNext1.AnchorMax },
                        Text = { Text = "1", FontSize = 20, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter }
                    }, "ui.kits");
                    container.Add(new CuiButton
                    {
                        Button = { Command = "kit next2", Color = _config.CloseButtonColor },
                        RectTransform = { AnchorMin = _config.CloseButtonPositionNext2.AnchorMin, AnchorMax = _config.CloseButtonPositionNext2.AnchorMax },
                        Text = { Text = "2", FontSize = 20, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter }
                    }, "ui.kits");
                }
            }


            if (kits.Count < 14)
            {
                InitilizeKitsUINext(ref container, player);
            }
            else if (kits.Count < 7)
            {
                InitilizeKitsUI(ref container, player);
            }
            else
            {
                InitilizeKitsUI2(ref container, player);
            }

            CuiHelper.AddUi(player, container);
        }

        private void DestroyUI(BasePlayer player)
        {
            if (!_kitsGUI.ContainsKey(player))
                return;

            foreach (var kitname in _kitsGUI[player])
            {
                CuiHelper.DestroyUi(player, $"ui.kits.{kitname}.time");
                CuiHelper.DestroyUi(player, $"ui.kits.{kitname}.mask");
                CuiHelper.DestroyUi(player, $"ui.kits.{kitname}.button");
                CuiHelper.DestroyUi(player, $"ui.kits.{kitname}.amount");
                CuiHelper.DestroyUi(player, $"ui.kits.{kitname}");
            }
            CuiHelper.DestroyUi(player, "ui.kits");

            _kitsGUI.Remove(player);
        }

        private void RefreshCooldownKitsUI()
        {
            var currentTime = GetCurrentTime();
            foreach (var playerGUIData in _kitsGUI)
            {
                var container = new CuiElementContainer();
                if (!_kitsData.ContainsKey(playerGUIData.Key.userID)) continue;
                var playerKitsData = _kitsData[playerGUIData.Key.userID];
                foreach (var kitname in playerGUIData.Value)
                {
                    var playerKitData = playerKitsData[kitname];
                    if (playerKitData.Cooldown > 0)
                    {
                        CuiHelper.DestroyUi(playerGUIData.Key, $"ui.kits.{kitname}.time");
                        if (playerKitData.Cooldown < currentTime)
                        {
                            CuiHelper.DestroyUi(playerGUIData.Key, $"ui.kits.{kitname}.mask");
                            InitilizeButtonUI(ref container, kitname);
                        }
                        else
                        {
                            InitilizeCooldownLabelUI(ref container, kitname, TimeSpan.FromSeconds(playerKitData.Cooldown - currentTime));
                        }
                    }
                }
                CuiHelper.AddUi(playerGUIData.Key, container);
            }
        }

        private void InitilizeKitsUI(ref CuiElementContainer container, BasePlayer player)
        {
            _kitsGUI[player] = new List<string>();
            var currentTime = GetCurrentTime();
            var kits = GetKitsForPlayer(player).Take((int)(1.0f / (_config.KitWidth + _config.MarginBetween))).ToList();
            var pos = 0.490f - (kits.Count * _config.KitWidth + (kits.Count - 1) * _config.MarginBetween) / 2;

            foreach (var kit in kits)
            {
                _kitsGUI[player].Add(kit.Name);

                var playerData = GetPlayerData(player.userID, kit.Name);

                // Kit panel
                container.Add(new CuiPanel
                {
                    Image = { Color = HexToRustFormat(_config.KitBackgroundColor) },
                    RectTransform = { AnchorMin = $"{pos} {_config.MarginBottom}", AnchorMax = $"{pos + _config.KitWidth} {1.0f - _config.MarginTop}" }
                }, "ui.kits", $"ui.kits.{kit.Name}");

                pos += _config.KitWidth + _config.MarginBetween;

                InitilizeNameLabelUI(ref container, kit.Name, kit.DisplayName);

                InitilizeKitImageUI(ref container, kit.Name);

                if (kit.Amount > 0)
                {
                    InitilizeAmountLabelUI(ref container, kit.Name, GetMsg("UI Amount", player).Replace("{amount}", (kit.Amount - playerData.Amount).ToString()));
                }

                if (kit.Cooldown > 0 && (playerData.Cooldown > currentTime))
                {
                    InitilizeMaskUI(ref container, kit.Name);
                    InitilizeCooldownLabelUI(ref container, kit.Name, TimeSpan.FromSeconds(playerData.Cooldown - currentTime));
                }
                else
                {
                    InitilizeButtonUI(ref container, kit.Name);
                }
            }
        }

        private void InitilizeKitsUINext(ref CuiElementContainer container, BasePlayer player)
        {
            _kitsGUI[player] = new List<string>();
            var currentTime = GetCurrentTime();
            var kits = GetKitsForPlayer(player).Take((int)(1.0f / (_config.KitWidth + _config.MarginBetween)) + 7).ToList();
            var pos = 0.525f - ((kits.Count - 7) * _config.KitWidth + (kits.Count - 1) * _config.MarginBetween) / 2;
            var kitsAmount = kits.Skip(7);
            foreach (var kit in kitsAmount)
            {
                _kitsGUI[player].Add(kit.Name);

                var playerData = GetPlayerData(player.userID, kit.Name);

                // Kit panel
                container.Add(new CuiPanel
                {
                    Image = { Color = HexToRustFormat(_config.KitBackgroundColor) },
                    RectTransform = { AnchorMin = $"{pos} {_config.MarginBottom}", AnchorMax = $"{pos + _config.KitWidth} {1.0f - _config.MarginTop}" }
                }, "ui.kits", $"ui.kits.{kit.Name}");

                pos += _config.KitWidth + _config.MarginBetween;

                InitilizeNameLabelUI(ref container, kit.Name, kit.DisplayName);

                InitilizeKitImageUI(ref container, kit.Name);

                if (kit.Amount > 0)
                {
                    InitilizeAmountLabelUI(ref container, kit.Name, GetMsg("UI Amount", player).Replace("{amount}", (kit.Amount - playerData.Amount).ToString()));
                }

                if (kit.Cooldown > 0 && (playerData.Cooldown > currentTime))
                {
                    InitilizeMaskUI(ref container, kit.Name);
                    InitilizeCooldownLabelUI(ref container, kit.Name, TimeSpan.FromSeconds(playerData.Cooldown - currentTime));
                }
                else
                {
                    InitilizeButtonUI(ref container, kit.Name);
                }
            }
        }

        private void InitilizeKitsUI2(ref CuiElementContainer container, BasePlayer player)
        {
            _kitsGUI[player] = new List<string>();
            var currentTime = GetCurrentTime();
            var kits = GetKitsForPlayer(player).ToList();
            var pos = 0.56f - ((kits.Count - 14) * _config.KitWidth + (kits.Count - 1) * _config.MarginBetween) / 2;
            var kitsAmount = kits.Skip(14);
            foreach (var kit in kitsAmount)
            {
                _kitsGUI[player].Add(kit.Name);

                var playerData = GetPlayerData(player.userID, kit.Name);

                // Kit panel
                container.Add(new CuiPanel
                {
                    Image = { Color = HexToRustFormat(_config.KitBackgroundColor) },
                    RectTransform = { AnchorMin = $"{pos} {_config.MarginBottom}", AnchorMax = $"{pos + _config.KitWidth} {1.0f - _config.MarginTop}" }
                }, "ui.kits", $"ui.kits.{kit.Name}");

                pos += _config.KitWidth + _config.MarginBetween;

                InitilizeNameLabelUI(ref container, kit.Name, kit.DisplayName);

                InitilizeKitImageUI(ref container, kit.Name);

                if (kit.Amount > 0)
                {
                    InitilizeAmountLabelUI(ref container, kit.Name, GetMsg("UI Amount", player).Replace("{amount}", (kit.Amount - playerData.Amount).ToString()));
                }

                if (kit.Cooldown > 0 && (playerData.Cooldown > currentTime))
                {
                    InitilizeMaskUI(ref container, kit.Name);
                    InitilizeCooldownLabelUI(ref container, kit.Name, TimeSpan.FromSeconds(playerData.Cooldown - currentTime));
                }
                else
                {
                    InitilizeButtonUI(ref container, kit.Name);
                }
            }
        }

        private void InitilizeKitImageUI(ref CuiElementContainer container, string kitname)
        {
            string image = _imagesCache.Get(kitname);
            CuiRawImageComponent imageComp = new CuiRawImageComponent
            {
                Sprite = "assets/content/textures/generic/fulltransparent.tga",
                Color = HexToRustFormat(_config.Image.Color)
            };
            if (image != string.Empty)
            {
                imageComp.Png = image;
            }
            container.Add(new CuiElement
            {
                Parent = $"ui.kits.{kitname}",
                Components =
                {
                    imageComp,
                    new CuiRectTransformComponent {AnchorMin = _config.Image.Position.AnchorMin, AnchorMax = _config.Image.Position.AnchorMax }
                }
            });
        }

        private void InitilizeNameLabelUI(ref CuiElementContainer container, string kitname, string text)
        {
            var name = container.Add(new CuiPanel
            {
                Image = { Color = HexToRustFormat(_config.Label.BackgroundColor) },
                RectTransform = { AnchorMin = _config.Label.Position.AnchorMin, AnchorMax = _config.Label.Position.AnchorMax }
            }, $"ui.kits.{kitname}");

            container.Add(new CuiLabel
            {
                Text = { Color = HexToRustFormat(_config.Label.ForegroundColor), FontSize = _config.Label.FontSize, Align = _config.Label.TextAnchor, Text = text }
            }, name);
        }

        private void InitilizeMaskUI(ref CuiElementContainer container, string kitname)
        {
            var name = container.Add(new CuiPanel
            {
                Image = { Color = HexToRustFormat(_config.DisableMaskColor) }
            }, $"ui.kits.{kitname}", $"ui.kits.{kitname}.mask");
        }

        private void InitilizeAmountLabelUI(ref CuiElementContainer container, string kitname, string text)
        {
            container.Add(new CuiPanel
            {
                Image = { Color = HexToRustFormat(_config.Amount.BackgroundColor) },
                RectTransform = { AnchorMin = _config.Amount.Position.AnchorMin, AnchorMax = _config.Amount.Position.AnchorMax }
            }, $"ui.kits.{kitname}", $"ui.kits.{kitname}.amount");

            container.Add(new CuiLabel
            {
                Text = { Color = HexToRustFormat(_config.Amount.ForegroundColor), FontSize = _config.Amount.FontSize, Align = _config.Amount.TextAnchor, Text = text }
            }, $"ui.kits.{kitname}.amount");
        }

        private void InitilizeButtonUI(ref CuiElementContainer container, string kitname)
        {
            container.Add(new CuiButton
            {
                Button = { Color = "0 0 0 0", Command = $"kit {kitname}" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Text = { Text = "" }
            }, $"ui.kits.{kitname}", $"ui.kits.{kitname}.button");
        }

        private void InitilizeCooldownLabelUI(ref CuiElementContainer container, string kitname, TimeSpan time)
        {
            container.Add(new CuiPanel
            {
                Image = { Color = HexToRustFormat(_config.Time.BackgroundColor) },
                RectTransform = { AnchorMin = _config.Time.Position.AnchorMin, AnchorMax = _config.Time.Position.AnchorMax }
            }, $"ui.kits.{kitname}", $"ui.kits.{kitname}.time");

            container.Add(new CuiLabel
            {
                Text = { Color = HexToRustFormat(_config.Time.ForegroundColor), FontSize = _config.Time.FontSize, Align = _config.Time.TextAnchor, Text = TimeExtensions.FormatShortTime(time) }
            }, $"ui.kits.{kitname}.time");
        }

        #endregion

        #region Helpers 

        private KitData GetPlayerData(ulong userID, string name)
        {
            if (!_kitsData.ContainsKey(userID))
                _kitsData[userID] = new Dictionary<string, KitData>();

            if (!_kitsData[userID].ContainsKey(name))
                _kitsData[userID][name] = new KitData();

            return _kitsData[userID][name];
        }

        private List<KitItem> GetPlayerItems(BasePlayer player)
        {
            List<KitItem> kititems = new List<KitItem>();
            foreach (Item item in player.inventory.containerWear.itemList)
            {
                if (item != null)
                {
                    var iteminfo = ItemToKit(item, "wear");
                    kititems.Add(iteminfo);
                }
            }
            foreach (Item item in player.inventory.containerMain.itemList)
            {
                if (item != null)
                {
                    var iteminfo = ItemToKit(item, "main");
                    kititems.Add(iteminfo);
                }
            }
            foreach (Item item in player.inventory.containerBelt.itemList)
            {
                if (item != null)
                {
                    var iteminfo = ItemToKit(item, "belt");
                    kititems.Add(iteminfo);
                }
            }
            return kititems;
        }

        string GetMsg(string key, BasePlayer player = null) => lang.GetMessage(key, this, player == null ? null : player.UserIDString);

        private KitItem ItemToKit(Item item, string container)
        {
            KitItem kitem = new KitItem();
            kitem.Amount = item.amount;
            kitem.Container = container;
            kitem.SkinID = item.skin;
            kitem.Blueprint = item.blueprintTarget;
            kitem.ShortName = item.info.shortname;
            kitem.Condition = item.condition;
            kitem.Weapon = null;
            kitem.Content = null;
            if (item.info.category == ItemCategory.Weapon)
            {
                BaseProjectile weapon = item.GetHeldEntity() as BaseProjectile;
                if (weapon != null)
                {
                    kitem.Weapon = new Weapon();
                    kitem.Weapon.ammoType = weapon.primaryMagazine.ammoType.shortname;
                    kitem.Weapon.ammoAmount = weapon.primaryMagazine.contents;
                }
            }
            if (item.contents != null)
            {
                kitem.Content = new List<ItemContent>();
                foreach (var cont in item.contents.itemList)
                {
                    kitem.Content.Add(new ItemContent()
                    {
                        Amount = cont.amount,
                        Condition = cont.condition,
                        ShortName = cont.info.shortname
                    });
                }
            }
            return kitem;
        }

        private List<Kit> GetKitsForPlayer(BasePlayer player)
        {
            return _kits.Where(kit => kit.Hide == false && (string.IsNullOrEmpty(kit.Permission) || permission.UserHasPermission(player.UserIDString, kit.Permission)) && (kit.Amount == 0 || (kit.Amount > 0 && GetPlayerData(player.userID, kit.Name).Amount < kit.Amount))).ToList();
        }

        private BasePlayer FindPlayer(BasePlayer player, string nameOrID)
        {
            ulong id;
            if (ulong.TryParse(nameOrID, out id) && nameOrID.StartsWith("7656119") && nameOrID.Length == 17)
            {
                var findedPlayer = BasePlayer.FindByID(id);
                if (findedPlayer == null || !findedPlayer.IsConnected)
                {
                    SendReply(player, GetMsg("Not Found Player", player));
                    return null;
                }

                return findedPlayer;
            }

            var foundPlayers = BasePlayer.activePlayerList.Where(x => x.displayName.ToLower().Contains(nameOrID.ToLower()));

            if (foundPlayers.Count() == 0)
            {
                SendReply(player, GetMsg("Not Found Player", player));
                return null;
            }

            if (foundPlayers.Count() > 1)
            {
                SendReply(player, GetMsg("To Many Player", player));
                return null;
            }

            return foundPlayers.First();
        }

        private double GetCurrentTime() => new TimeSpan(DateTime.UtcNow.Ticks).TotalSeconds;

        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);

            return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
        }

        private static class TimeExtensions
        {
            public static string FormatShortTime(TimeSpan time)
            {
                string result = string.Empty;
                if (time.Days != 0)
                    result += $"{time.Days} д. ";

                if (time.Hours != 0)
                    result += $"{time.Hours} ч. ";

                if (time.Minutes != 0)
                    result += $"{time.Minutes} м. ";

                if (time.Seconds != 0)
                    result += $"{time.Seconds} с. ";

                return result;
            }

            public static string FormatTime(TimeSpan time)
            {
                string result = string.Empty;
                if (time.Days != 0)
                    result += $"{Format(time.Days, "дней", "дня", "день")} ";

                if (time.Hours != 0)
                    result += $"{Format(time.Hours, "часов", "часа", "час")} ";

                if (time.Minutes != 0)
                    result += $"{Format(time.Minutes, "минут", "минуты", "минута")} ";

                if (time.Seconds != 0)
                    result += $"{Format(time.Seconds, "секунд", "секунды", "секунда")} ";

                return result;
            }

            private static string Format(int units, string form1, string form2, string form3)
            {
                var tmp = units % 10;

                if (units >= 5 && units <= 20 || tmp >= 5 && tmp <= 9)
                    return $"{units} {form1}";

                if (tmp >= 2 && tmp <= 4)
                    return $"{units} {form2}";

                return $"{units} {form3}";
            }
        }

        #endregion
    }
}
                             

// --- End of file: Kits (1).cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/EasyBroadcast.cs ---
// --- Original Local Path: EasyBroadcast.cs ---

using System.Collections.Generic;
using System.Linq;
using System;

namespace Oxide.Plugins
{
    [Info("Easy Broadcast", "LaserHydra", "2.1.0", ResourceId = 863)]
    [Description("Broadcast a message to the server")]
    class EasyBroadcast : RustPlugin
    {
        ////////////////////////////////////////
        ///     On Plugin Loaded
        ////////////////////////////////////////

        void Loaded()
        {
            permission.RegisterPermission("broadcast.use", this);

            LoadConfig();
        }

        ////////////////////////////////////////
        ///     Config Handling
        ////////////////////////////////////////

        void LoadConfig()
        {
            SetConfig("Display", "<color=blue>{title}</color>: {message}");
            SetConfig("Title", "Server");

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Generating new config file...");
        }

        ////////////////////////////////////////
        ///     Commands
        ////////////////////////////////////////

        [ChatCommand("bcast")]
        void cmdBroadcast(BasePlayer player, string cmd, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, "broadcast.use"))
            {
                SendChatMessage(player, "Broadcast", "You have no permission to use this command!");
                return;
            }
            if (args.Length < 1)
            {
                SendChatMessage(player, "Broadcast", "Syntax: /bcast <message>");
            }

            string message = Config["Display"] as string;
            message = message.Replace("{title}", Config["Title"] as string).Replace("{message}", ListToString(args.ToList(), 0, " "));

            BroadcastChat(message);
        }

        ////////////////////////////////////////
        ///     Converting
        ////////////////////////////////////////

        string ListToString(List<string> list, int first, string seperator)
        {
            return String.Join(seperator, list.Skip(first).ToArray());
        }

        ////////////////////////////////////////
        ///     Config Setup
        ////////////////////////////////////////

        void SetConfig(params object[] args)
        {
            List<string> stringArgs = (from arg in args select arg.ToString()).ToList<string>();
            stringArgs.RemoveAt(args.Length - 1);

            if (Config.Get(stringArgs.ToArray()) == null) Config.Set(args);
        }

        ////////////////////////////////////////
        ///     Chat Handling
        ////////////////////////////////////////

        void BroadcastChat(string prefix, string msg = null) => PrintToChat(msg == null ? prefix : "<color=#00FF8D>" + prefix + "</color>: " + msg);

        void SendChatMessage(BasePlayer player, string prefix, string msg = null) => SendReply(player, msg == null ? prefix : "<color=#00FF8D>" + prefix + "</color>: " + msg);
    }
}


// --- End of file: EasyBroadcast.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/RespawnMessages.cs ---
// --- Original Local Path: RespawnMessages.cs ---

using Oxide.Core.Plugins;
namespace Oxide.Plugins
{
    [Info("RespawnMessages", "Kappasaurus", 0.1)]
    [Description("Make customized notes players view on respawn!")]

    class RespawnMessages : RustPlugin
    {
        [PluginReference]
        Plugin PopupNotifications;
        void LoadDefaultConfig()
        {
            Config.Clear();
            Config["RespawnMessagePopup"] = "<size=20>Hey, <color=#cd422b>try not to die</color> this time!</size>";
            Config["RespawnMessageChat"] = "Hey, <color=#cd422b>try not to die</color> this time!";
            Config["Prefix"] = "[ <color=#cd422b>RespawnNotes</color> ]";
            Config["PopupEnabled"] = false;
            Config["ChatEnabled"] = true;
            Config["PrefixEnabled"] = true;
            Config.Save();
        }
        void OnPlayerRespawn(BasePlayer player)
        {
            if ((bool)Config["PrefixEnabled"] == true)
            {
                if ((bool)Config["PopupEnabled"] == true)
					{
						PopupNotifications?.Call("CreatePopupNotification", Config["RespawnMessagePopup"].ToString());
					}
                if ((bool)Config["ChatEnabled"] == true)
					{
						SendReply(player, Config["Prefix"].ToString() + " " + Config["RespawnMessageChat"].ToString());
					}
            }
            else

            {
                if ((bool)Config["PopupEnabled"] == true)
					{
						PopupNotifications?.Call("CreatePopupNotification", Config["RespawnMessagePopup"].ToString());
					}
                if ((bool)Config["ChatEnabled"] == true)
					{
							SendReply(player, Config["RespawnMessageChat"].ToString());
					}
            }
        }
    }
}
 

// --- End of file: RespawnMessages.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/MagicDescription.cs ---
// --- Original Local Path: MagicDescription.cs ---

using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;

namespace Oxide.Plugins
{
    [Info("MagicDescription", "Wulf/lukespragg", "1.2.3", ResourceId = 1447)]
    [Description("Adds dynamic information in the server description")]

    class MagicDescription : RustPlugin
    {
        #region Initialization

        readonly Regex varRegex = new Regex(@"\{([^\}]+)\}");
        List<object> exclusions;
        bool listPlugins;
        bool serverInitialized;
        int updateInterval;
        string description;

        protected override void LoadDefaultConfig()
        {
            Config["Description"] = description = GetConfig("Description", "Powered by {oxide.version}\n\n{version}\n\n{server.pve}");
            Config["ListPlugins"] = listPlugins = GetConfig("ListPlugins", true);
            Config["PluginExclusions"] = exclusions = GetConfig("PluginExclusions", new List<object> { "PrivateStuff", "OtherName" });
            Config["UpdateInterval"] = updateInterval = GetConfig("UpdateInterval", 300);
            SaveConfig();
        }

        void OnServerInitialized()
        {
            LoadDefaultConfig();
            serverInitialized = true;
            UpdateDescription();
            timer.Every(updateInterval, () => UpdateDescription());
        }

        #endregion

        #region Description Updating

        void OnPluginLoaded()
        {
            if (serverInitialized) UpdateDescription();
        }

        void OnPluginUnloaded() => UpdateDescription();

        void UpdateDescription(string text = "")
        {
            if (!string.IsNullOrEmpty(text))
            {
                Config["Description"] = text;
                description = text;
                SaveConfig();
            }

            var newDescription = new StringBuilder(description);
            var matches = varRegex.Matches(description);
            foreach (var match in matches)
            {
                if (match == null) continue;
                var matchString = match.ToString();
                var reply = ConsoleSystem.Run.Server.Quiet(matchString.Replace("{", "").Replace("}", ""));
                newDescription.Replace(matchString, reply ?? "");
            }

            if (listPlugins)
            {
                var loaded = plugins.GetAll();
                if (loaded.Length == 0) return;

                string pluginList = null;
                var count = 0;
                foreach (var plugin in loaded)
                {
                    if (plugin.IsCorePlugin || exclusions.Contains(plugin.Title)) continue;
                    pluginList += plugin.Title + ", ";
                    count++;
                }
                if (pluginList != null)
                {
                    if (pluginList.EndsWith(", ")) pluginList = pluginList.Remove(pluginList.Length - 2);
                    newDescription.Append($"\n\nPlugins ({count}): {pluginList}");
                }
            }

            if (newDescription.ToString() == ConVar.Server.description) return;
            ConVar.Server.description = newDescription.ToString();
            Puts("Server description updated!");
        }

        #endregion

        #region Command Handling

        object OnServerCommand(ConsoleSystem.Arg arg)
        {
            if (!serverInitialized) return null;

            var command = arg.cmd.namefull;
            if (command != "server.description" || !arg.isAdmin) return null;
            if (!arg.HasArgs() || arg.Args.GetValue(0) == null) return null;

            var newDescription = string.Join(" ", arg.Args.ToArray());
            UpdateDescription(newDescription);
            UnityEngine.Debug.Log($"server.description: {newDescription}");
            return true;
        }

        #endregion

        T GetConfig<T>(string name, T value) => Config[name] == null ? value : (T)System.Convert.ChangeType(Config[name], typeof(T));
    }
}


// --- End of file: MagicDescription.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BoostSystem.cs ---
// --- Original Local Path: BoostSystem.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Text;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("BoostSystem", "Fanatey", "0.0.4")]
    class BoostSystem : RustPlugin
    {
        [PluginReference] Plugin IQEconomic, ImageLibrary;
        #region зависимости
        public void apiremovebalance(ulong userID, int Balance) => IQEconomic?.CallHook("API_REMOVE_BALANCE", userID, Balance);
        public bool apiisremoved(ulong userID, int Amount) => (bool)IQEconomic?.CallHook("API_IS_REMOVED_BALANCE", userID, Amount);
        #endregion зависимости
        private List<string> ListGold = new List<string>() // Выпадение золота!
        {
            {"codelockedhackablecrate"},
            {"crate_basic"},
            {"crate_elite"},
            {"crate_normal"},
            {"supply_drop"},
            {"loot-barrel-1"},
            {"loot-barrel-2"},
            {"bradley_crate"},
        };
        int ammounttoupgrade1;
        int ammounttoupgrade2;
        int ammounttoupgrade3;
        float healbost1;
        float healbost2;
        float healbost3;
        float damagebost1;
        float damagebost2;
        float damagebost3;
        float protectdamage1;
        float protectdamage2;
        float protectdamage3;
        bool wipedData;
        bool Economic;
        int itemid;
        int dropchance;
        string projectname;
        
        Timer heall;
        Timer damagee;
        Timer takedamagee;

        private string NameGold = "Золото";
        int skinid;
        string shortname;
        protected override void LoadDefaultConfig()
        {
            GetVariable(Config, "Колличество коинов для апгрейда до уровня 1", out ammounttoupgrade1, 7);
            GetVariable(Config, "Колличество коинов для апгрейда до уровня 2", out ammounttoupgrade2, 13);
            GetVariable(Config, "Колличество коинов для апгрейда до уровня 3", out ammounttoupgrade3, 19);
            GetVariable(Config, "Множитель хила на уровень 1", out healbost1, 1f);
            GetVariable(Config, "Множитель хила на уровень 2", out healbost2, 2f);
            GetVariable(Config, "Множитель хила на уровень 3", out healbost3, 4f);
            GetVariable(Config, "Множитель буста дамага на уровень 1", out damagebost1, 1.1f);
            GetVariable(Config, "Множитель буста дамага на уровень 2", out damagebost2, 1.4f);
            GetVariable(Config, "Множитель буста дамага на уровень 3", out damagebost3, 1.6f);
            GetVariable(Config, "Множитель защиты на уровень 1", out protectdamage1, 0.8f);
            GetVariable(Config, "Множитель защиты на уровень 2", out protectdamage2, 0.5f);
            GetVariable(Config, "Множитель защиты на уровень 3", out protectdamage3, 0.3f);
            GetVariable(Config, "Поддержка плагина IQEconomic", out Economic, false);
            GetVariable(Config, "Название проекта", out projectname, "CaseRust");
            GetVariable(Config, "Шанс выпадения монеты из контейнера", out dropchance, 3);
            GetVariable(Config, "ID предмета", out itemid, -1899491405);
            GetVariable(Config, "skinid предмета", out skinid, 1707233455);
            GetVariable(Config, "shortname предмета", out shortname, "glue");
            SaveConfig();
        }
        Dictionary<ulong, Dictionary<string, string>> boost;
        private List<LootContainer> handledContainers = new List<LootContainer>();
        void OnLootEntity(BasePlayer player, BaseEntity entity, Item item)
        {
            if (!(entity is LootContainer)) return;
            var container = (LootContainer)entity;
            if (handledContainers.Contains(container) || container.ShortPrefabName == "stocking_large_deployed" ||
               container.ShortPrefabName == "stocking_small_deployed") return;
            handledContainers.Add(container);
            List<int> ItemsList = new List<int>();
            if (ListGold.Contains(container.ShortPrefabName))
            {
                if (UnityEngine.Random.Range(0f, 100f) < dropchance)
                {
                    var itemContainer = container.inventory;
                    foreach (var i1 in itemContainer.itemList)
                    {
                        ItemsList.Add(i1.info.itemid);
                    }

                    if (!ItemsList.Contains(-1899491405))
                    {
                        if (container.inventory.itemList.Count == container.inventory.capacity)
                            container.inventory.capacity++;
                        var count = UnityEngine.Random.Range(1, 3 + 1);
                        item = ItemManager.CreateByName("glue");
                        item.name = NameGold;
                        item.MoveToContainer(itemContainer);
                    }
                }
            }
        }
        void OnEntityDeath(BaseCombatEntity entity, HitInfo info, Item item)
        {
            if (info == null) return;
            if (entity?.net?.ID == null) return;
            var container = entity as LootContainer;
            var player = info?.InitiatorPlayer;
            if (player == null || container == null) return;
            List<int> ItemsList = new List<int>();
            if (ListGold.Contains(container.ShortPrefabName))
            {
                if (UnityEngine.Random.Range(0f, 100f) < dropchance)
                {
                    var itemContainer = container.inventory;
                    foreach (var i1 in itemContainer.itemList)
                    {
                        ItemsList.Add(i1.info.itemid);
                    }

                    if (!ItemsList.Contains(-1899491405))
                    {
                        if (container.inventory.itemList.Count == container.inventory.capacity)
                            container.inventory.capacity++;
                        var count = UnityEngine.Random.Range(1, 3 + 1);
                        item = ItemManager.CreateByName("glue");
                        item.name = NameGold;
                        item.MarkDirty();
                        item.MoveToContainer(itemContainer);
                    }
                }
            }
            handledContainers.Remove(container);
        }
        void OnItemAddedToContainer(ItemContainer container, Item item)
        {
            if (item == null || item.info == null) return;
            var iname = item.info.shortname.ToLower();
            if (iname == shortname)
            {
                ulong result = Convert.ToUInt64(skinid);
                item.name = NameGold;
                item.skin = result;
            }
        }
        #region cui
        void cuimenu(BasePlayer player)
        {
            CuiElementContainer boot = new CuiElementContainer();
            healbar(player);
            takedamagebar(player);
            damagebar(player);
            CuiHelper.DestroyUi(player, Layer);
            boot.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.3098958 0.3870371", AnchorMax = "0.6776037 0.7462963" },
                Image = { Color = "0.142171 0.1008802 0.2442628 0.7720931" },
                CursorEnabled = true
            }, "Hud", Layer); 
            boot.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.8696894 0.9020619", AnchorMax = "0.9957519 0.9922678" },
                Button = { Color = "0.8509278 0.4762424 0.4762328 0.7092233", Close = Layer, Command = "cmddestroutimer" },//
                Text = { Text = "Закрыть", Align = TextAnchor.MiddleCenter }
            }, Layer);
            boot.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.03541084 0.6262889", AnchorMax = "0.2138813 0.9484539"},
                Image = { Color = "0.4784049 0 0.9803424 0.3647059" }
            }, Layer);
            boot.Add(new CuiElement
            {
                Parent = Layer,
                Components =
                        {
                        new CuiRawImageComponent
                        {
                             Url = "http://rust.skyplugins.ru/getimage/largemedkit/512",
                        },
                        new CuiRectTransformComponent
                        {
                             AnchorMin = "0.03541084 0.6262889",
                             AnchorMax = "0.2138813 0.9484539"
                        }
                        }
            });
            boot.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.2705384 0.6262889", AnchorMax = "0.449009 0.9484537"},
                Image = { Color = "0.4784049 0 0.9803424 0.3647059" }
            }, Layer);
            boot.Add(new CuiElement
            {
                Parent = Layer,
                Components =
                        {
                        new CuiRawImageComponent
                        {
                             Url = "http://rust.skyplugins.ru/getimage/ammo.rifle/512",//ammo.rifle
                        },
                        new CuiRectTransformComponent
                        {
                             AnchorMin = "0.2705384 0.6262889",
                             AnchorMax = "0.449009 0.9484537"
                        }
                        }
            });
            boot.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5028335 0.6262889", AnchorMax = "0.6813042 0.9484539"},
                Image = { Color = "0.4784049 0 0.9803424 0.3647059" }
            }, Layer);
            boot.Add(new CuiElement
            {
                Parent = Layer,
                Components =
                        {
                        new CuiRawImageComponent
                        {
                             Url = "http://rust.skyplugins.ru/getimage/heavy.plate.jacket/512" //
                        },
                        new CuiRectTransformComponent
                        {
                             AnchorMin = "0.5028335 0.6262889",
                             AnchorMax = "0.6813042 0.9484539"
                        }
                        }
            });
            boot.Add(new CuiLabel
            { 
            RectTransform = {AnchorMin = "0.6926354 0.5567008", AnchorMax = "0.9886697 0.8788658" },
            Text = { Text = $"Добро пожаловать\n на проект\n <color=orange>{projectname}</color>,\n<color=orange>{player.displayName}</color>!\nИграй и побеждай!\n\n", Align = TextAnchor.UpperCenter }           
            }, Layer);
            boot.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.02549576 0.154639", AnchorMax = "0.2209635 0.533505" },
                Text = { Align = TextAnchor.UpperCenter, Text = "Прокачивая этот скилл вы будете регениться в разы быстрее!" }
            }, Layer);//healtext
            boot.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.2577906 0.162371", AnchorMax = "0.4603405 0.5309277" },
                Text = { Align = TextAnchor.UpperCenter, Text = "Прокачивая этот скилл вы будете наносить больше урона!" }
            }, Layer);//boosttext
            boot.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.4943349 0.1572161", AnchorMax = "0.6883861 0.5309273" },
                Text = { Align = TextAnchor.UpperCenter, Text = "Прокачивая этот скилл вы будете получать меньше урона!" }
            }, Layer);//bostfix damage
            boot.Add(new CuiElement
            {
                Parent = Layer,
                Components =
                        {
                        new CuiRawImageComponent
                        {
                             Png = (string)ImageLibrary?.Call("GetImage", player.UserIDString)
                        },
                        new CuiRectTransformComponent
                        {
                             AnchorMin = "0.7152982 0.05154641",
                             AnchorMax = "0.963174 0.5025772"
                        }
                        }
            });
            boot.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.03541092 0.05154641", AnchorMax = "0.2138814 0.1546392" },
                Button = { Color = "0.8509278 0.4762328 0.4762328 0.7092233", Command = "cmdbostheal" },//
                Text = { Text = "Вкачать", Align = TextAnchor.MiddleCenter }
            }, Layer);
            boot.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.2691222 0.05154641", AnchorMax = "0.4475926 0.1546392"},
                Button = { Color = "0.8509278 0.4762328 0.4762328 0.7092233", Command = "cmdbostdamage" },//
                Text = { Text = "Вкачать", Align = TextAnchor.MiddleCenter }
            }, Layer);
            boot.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.5028335 0.05154641", AnchorMax = "0.6813039 0.1546392" },
                Button = { Color = "0.8509278 0.4762328 0.4762328 0.7092233", Command = "cmdbosttakedamage" },//
                Text = { Text = "Вкачать", Align = TextAnchor.MiddleCenter }
            }, Layer);
            boot.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.03541084 0.5360824", AnchorMax = "0.09206813 0.6185565" },
                Image = { Color = "0 0 0 0.75" }
            }, Layer, "heal1");
            boot.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.03541084 0.5360824", AnchorMax = "0.09206813 0.6185565" },
                Text = { Text = ammounttoupgrade1.ToString() , Align = TextAnchor.MiddleCenter, Color = "1 0.6431373 0 1" }
            }, Layer);
            boot.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.09631741 0.5360821", AnchorMax = "0.1529747 0.6185562" },
                Image = { Color = "0 0 0 0.75" }
            }, Layer, "heal2");
            boot.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.09631741 0.5360821", AnchorMax = "0.1529747 0.6185562" },
                Text = { Text = ammounttoupgrade2.ToString(), Align = TextAnchor.MiddleCenter, Color = "1 0.6431373 0 1" }
            }, Layer);
            boot.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.157224 0.5360821", AnchorMax = "0.2138813 0.6185563"},
                Image = { Color = "0 0 0 0.75" }
            }, Layer, "heal3");
            boot.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.157224 0.5360821", AnchorMax = "0.2138813 0.6185563" },
                Text = { Text = ammounttoupgrade3.ToString(), Align = TextAnchor.MiddleCenter, Color = "1 0.6431373 0 1" }
            }, Layer);
            boot.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.2705386 0.5360825", AnchorMax = "0.3271959 0.6185563"},
                Image = { Color = "0 0 0 0.75" }
            }, Layer, "boost1");
            boot.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.2705386 0.5360825", AnchorMax = "0.3271959 0.6185563" },
                Text = { Text = ammounttoupgrade1.ToString(), Align = TextAnchor.MiddleCenter, Color = "1 0.6431373 0 1" }
            }, Layer);
            boot.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.3314451 0.5360821", AnchorMax = "0.3881024 0.6185563"},
                Image = { Color = "0 0 0 0.75" }
            }, Layer, "boost2");
            boot.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.3314451 0.5360821", AnchorMax = "0.3881024 0.6185563" },
                Text = { Text = ammounttoupgrade2.ToString(), Align = TextAnchor.MiddleCenter, Color = "1 0.6431373 0 1" }
            }, Layer);
            boot.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.3923517 0.536082", AnchorMax = "0.449009 0.6185561"},
                Image = { Color = "0 0 0 0.75" }//424
            }, Layer, "boost3");
            boot.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.3923517 0.536082", AnchorMax = "0.449009 0.6185561" },
                Text = { Text = ammounttoupgrade3.ToString(), Align = TextAnchor.MiddleCenter, Color = "1 0.6431373 0 1" }
            }, Layer);
            boot.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5028337 0.536082", AnchorMax = "0.5594907 0.6185561"},
                Image = { Color = "0 0 0 0.75" }//424
            }, Layer, "damage1");
            boot.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.5028337 0.536082", AnchorMax = "0.5594907 0.6185561" },
                Text = { Text = ammounttoupgrade1.ToString(), Align = TextAnchor.MiddleCenter, Color = "1 0.6431373 0 1" }
            }, Layer);
            boot.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5637401 0.536082", AnchorMax = "0.6203976 0.6185561"},
                Image = { Color = "0 0 0 0.75" }//424
            }, Layer, "damage2");
            boot.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.5637401 0.536082", AnchorMax = "0.6203976 0.6185561" },
                Text = { Text = ammounttoupgrade2.ToString(), Align = TextAnchor.MiddleCenter, Color = "1 0.6431373 0 1" }
            }, Layer);
            boot.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.6246464 0.5360821", AnchorMax = "0.6813039 0.6185563" },
                Image = { Color = "0 0 0 0.75" }
            }, Layer, "damage3");
            boot.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.6246464 0.5360821", AnchorMax = "0.6813039 0.6185563" },
                Text = { Text = ammounttoupgrade3.ToString(), Align = TextAnchor.MiddleCenter, Color = "1 0.6431373 0 1" }
            }, Layer);
            CuiHelper.AddUi(player, boot);
        }
        void healbar(BasePlayer player)
        {
            var boostbox = boost[player.userID];
            CuiElementContainer bot = new CuiElementContainer();
            if (boostbox.ContainsKey("HealBoost"))
            {
                var hbox = boostbox["HealBoost"];
                if (hbox == "Heal1")
                {
                    bot.Add(new CuiPanel
                    {
                        RectTransform = { AnchorMin = "0.02499963 0.03124986", AnchorMax = "0.9749994 0.937501"},
                        Image = { Color = "0.621307 0 1 0.35"}
                    }, "heal1");
                }
                else
                if (hbox == "Heal2")
                {
                    bot.Add(new CuiPanel
                    {
                        RectTransform = { AnchorMin = "0.02499965 0.03124986", AnchorMax = "0.9750003 0.9375014"},
                        Image = { Color = "0.621307 0 1 0.35" }
                    }, "heal2");
                }
                else
                if (hbox == "Heal3")
                {
                    bot.Add(new CuiPanel
                    {
                        RectTransform = { AnchorMin = "0.02499965 0.03124986", AnchorMax = "0.9750004 0.9375001"},
                        Image = { Color = "0.621307 0 1 0.35" }
                    }, "heal3");
                }
            }
            CuiHelper.AddUi(player, bot);          
        }
        void damagebar(BasePlayer player)
        {
            var boostbox = boost[player.userID];
            CuiElementContainer dmg = new CuiElementContainer();
            if (boostbox.ContainsKey("DamageBoost"))
            {
                var hbox = boostbox["DamageBoost"];
                if (hbox == "Dast1")
                {
                    dmg.Add(new CuiPanel
                    {
                        RectTransform = { AnchorMin = "0.02475003 0.03093767", AnchorMax = "0.9747511 0.9371914" },
                        Image = { Color = "0.621307 0 1 0.35" }
                    }, "boost1");
                }
                else
                if (hbox == "Dast2")
                {
                    dmg.Add(new CuiPanel
                    {
                        RectTransform = { AnchorMin = "0.02475306 0.03094125", AnchorMax = "0.9747525 0.9371917" },
                        Image = { Color = "0.621307 0 1 0.35" }
                    }, "boost2");
                }
                else
                if (hbox == "Dast3")
                {
                    dmg.Add(new CuiPanel
                    {
                        RectTransform = { AnchorMin = "0.02474999 0.03093755", AnchorMax = "0.974749 0.9371879" },
                        Image = { Color = "0.621307 0 1 0.35" }
                    }, "boost3");
                }
            }
            CuiHelper.AddUi(player, dmg);
        }
        void takedamagebar(BasePlayer player)
        {
            var boostbox = boost[player.userID];
            CuiElementContainer tdmg = new CuiElementContainer();
            if (boostbox.ContainsKey("TakeDamageBoost"))
            {
                var hbox = boostbox["TakeDamageBoost"];
                if (hbox == "takeboos1")
                {
                    tdmg.Add(new CuiPanel
                    {
                        RectTransform = { AnchorMin = "0.02475009 0.03093755", AnchorMax = "0.974753 0.937188" },
                        Image = { Color = "0.621307 0 1 0.35" }//424
                    }, "damage1");
                }
                else
                if (hbox == "takeboos2")
                {
                    tdmg.Add(new CuiPanel
                    {
                        RectTransform = { AnchorMin = "0.02474994 0.03093755", AnchorMax = "0.9747475 0.9371886" },
                        Image = { Color = "0.621307 0 1 0.35" }//424
                    }, "damage2");
                }
                else
                if (hbox == "takeboos3")
                {
                    tdmg.Add(new CuiPanel
                    {
                        RectTransform = { AnchorMin = "0.02474994 0.03093755", AnchorMax = "0.9747475 0.9371886" },
                        Image = { Color = "0.621307 0 1 0.35" }
                    }, "damage3");
                }
            }
            CuiHelper.AddUi(player, tdmg);
        }
#endregion cui
        void DestroyTimer(Timer timer)
        {
            timer.DestroyToPool();
            timer = null;
        }
        [JsonProperty("Системный слой")]
        private string Layer = "Boost_UI";
        [ConsoleCommand("wp")]
        void cmdvp(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player.net.connection.authLevel == 2)
            {
                WipeData();
                PrintWarning("Dataremove!");
            }
        }
        object OnRunPlayerMetabolism(PlayerMetabolism metabolism, BaseCombatEntity entity)
        {
            var player = entity as BasePlayer;
            if (player != null)
            {
                if (!boost.ContainsKey(player.userID))
                {
                    return null;
                }
                else
                {
                    var boostbox = boost[player.userID];
                    if (boostbox.ContainsKey("HealBoost"))
                    {
                        var hbox = boostbox["HealBoost"];
                        if (hbox == "Heal1")
                        {
                            player.health += healbost2;
                            return null;
                        }
                        if (hbox == "Heal2")
                        {
                            player.health += healbost2;
                            return null;
                        }
                        if (hbox == "Heal3")
                        {
                            player.health += healbost3;
                            return null;
                        }
                    }
                    else
                    { return null; }
                }
            }
            return null;
        }
        
        [ChatCommand("boost")]
        void Bosst(BasePlayer player)
        {
            Dictionary<string, string> boostbox;
            if (!boost.TryGetValue(player.userID, out boostbox)) boostbox = (boost[player.userID] = new Dictionary<string, string>());
            cuimenu(player);
            SaveData();
        }
        [ConsoleCommand("cmdbostheal")]
        void cmdboostheal(ConsoleSystem.Arg arg)
        {        
            var player = arg.Player();
            heall = timer.Once(0.09f, () => healbar(player));
            string value1 = "Heal1";
            string value2 = "Heal2";
            string value3 = "Heal3";     
            var boostbox = boost[player.userID];
            var name = "HealBoost";
            if (!boostbox.ContainsKey(name))
            {
                if (Economic)
                {
                    if (!IQEconomic) return;
                    else
                    {
                        if (apiisremoved(player.userID, ammounttoupgrade1))
                        {
                            apiremovebalance(player.userID, ammounttoupgrade1);
                            if(boostbox.ContainsKey(name))
                            {
                                boostbox.Remove(name);
                            }
                            boostbox.Add(name, value1);
                            SendReply(player, "Вы получили первый уровень регена!");
                        }
                        else
                        {
                            SendReply(player, "Не достаточно коинов для улучшения уровня!");
                            return;
                        }
                    }
                }
                if (player.inventory.GetAmount(itemid) - ammounttoupgrade1 >= 0)
                {
                    if (boostbox.ContainsKey(name))
                    {
                        boostbox.Remove(name);
                    }
                    boostbox.Add(name, value1);
                    player.inventory.Take(null, itemid, ammounttoupgrade1);
                    SendReply(player, "Вы получили первый уровень регена!");
                    SaveData();
                    return;
                }
                else
                {
                    SendReply(player, "Не достаточно коинов для улучшения уровня!");
                    return;
                }
            }
            else
            if (boostbox.ContainsKey(name))
            {
                if (boostbox.ContainsValue(value1))
                {
                    if (Economic)
                    {
                        if (!IQEconomic) return;
                        else
                        {

                            if (apiisremoved(player.userID, ammounttoupgrade2))
                            {
                                apiremovebalance(player.userID, ammounttoupgrade2);
                                boostbox.Remove(name);
                                boostbox.Add(name, value1);
                                SendReply(player, "Вы получили второй уровень регена!");

                            }
                            else
                            {
                                SendReply(player, "Не достаточно коинов для улучшения уровня!");
                                return;
                            }
                        }
                    }
                    if (player.inventory.GetAmount(itemid) - ammounttoupgrade2 >= 0)
                    {
                        boostbox.Remove(name);
                        boostbox.Add(name, value2);
                        player.inventory.Take(null, itemid, ammounttoupgrade2);
                        SendReply(player, "Вы получили второй уровень регена!");
                        SaveData();
                        return;
                    }
                    else
                    {
                        SendReply(player, "Не достаточно коинов для улучшения уровня!");
                        return;
                    }
                }
                else
                if (boostbox.ContainsValue(value2))
                {
                    if (Economic)
                    {
                        if (!IQEconomic) return;
                        else
                        {

                            if (apiisremoved(player.userID, ammounttoupgrade3))
                            {
                                apiremovebalance(player.userID, ammounttoupgrade3);
                                boostbox.Remove(name);
                                boostbox.Add(name, value1);
                                SendReply(player, "Вы достигли максимального уровня регена!");
                            }
                            else
                            {
                                SendReply(player, "Не достаточно коинов для улучшения уровня!");
                                return;
                            }
                        }
                    }
                    if (player.inventory.GetAmount(itemid) - ammounttoupgrade3 >= 0)
                    {
                        boostbox.Remove(name);
                        boostbox.Add(name, value3);
                        player.inventory.Take(null, itemid, ammounttoupgrade3);
                        SendReply(player, "Вы достигли максимального уровня регена!");
                        SaveData();
                        return;
                    }
                    else
                    {
                        SendReply(player, "Не достаточно коинов для улучшения уровня!");
                        return;
                    }
                }
                else
                if (boostbox.ContainsValue(value3))
                {
                    if (Economic)
                    {
                        if (!IQEconomic) return;
                        else
                        {
                            SendReply(player, "Вы уже достигли максимального уровня регена!");
                            DestroyTimer(heall);
                            return;
                        }
                    }
                    SendReply(player, "Вы уже достигли максимального уровня регена!");
                    DestroyTimer(heall);
                    SaveData();
                    return;
                }            
            }
        }
        [ConsoleCommand("cmdbostdamage")]
        void cmdbostdamage(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            damagee = timer.Once(0.09f, () => damagebar(player));
            string value1 = "Dast1";
            string value2 = "Dast2";
            string value3 = "Dast3";
            var boostbox = boost[player.userID];
            var name = "DamageBoost";
            if (!boostbox.ContainsKey(name))
            {
                if (Economic)
                {
                    if (!IQEconomic) return;
                    else
                    {
                        if (apiisremoved(player.userID, ammounttoupgrade1))
                        {
                            apiremovebalance(player.userID, ammounttoupgrade1);
                            boostbox.Remove(name);
                            boostbox.Add(name, value1);
                            SendReply(player, "Вы получили первый уровень буста дамага!");
                        }
                        else
                        {
                            SendReply(player, "Не достаточно коинов для улучшения уровня!");
                            return;
                        }
                    }
                }
                if (player.inventory.GetAmount(itemid) - ammounttoupgrade1 >= 0)
                {
                    boostbox.Remove(name);
                    boostbox.Add(name, value1);                  
                    SendReply(player, "Вы получили первый уровень буста дамага!");
                    player.inventory.Take(null, itemid, ammounttoupgrade1);
                    SaveData();
                    return;
                }
                else
                {
                    SendReply(player, "Не достаточно коинов для улучшения уровня!");
                    return;
                }
            }
            else
            if (boostbox.ContainsKey(name))
            {
                if (boostbox.ContainsValue(value1))
                {
                    if (Economic)
                    {
                        if (!IQEconomic) return;
                        else
                        {

                            if (apiisremoved(player.userID, ammounttoupgrade2))
                            {
                                apiremovebalance(player.userID, ammounttoupgrade2);
                                if (boostbox.ContainsKey(name))
                                {
                                    boostbox.Remove(name);
                                }
                                boostbox.Add(name, value1);
                                SendReply(player, "Вы получили второй уровень буста дамага!");
                            }
                            else
                            {
                                SendReply(player, "Не достаточно коинов для улучшения уровня!");
                                return;
                            }
                        }
                    }
                    if (player.inventory.GetAmount(itemid) - ammounttoupgrade2 >= 0)
                    {
                        if (boostbox.ContainsKey(name))
                        {
                            boostbox.Remove(name);
                        }
                        boostbox.Add(name, value2);
                        player.inventory.Take(null, itemid, ammounttoupgrade2);
                        SendReply(player, "Вы получили второй уровень буста дамага!");
                        SaveData();
                        return;
                    }
                    else
                    {
                        SendReply(player, "Не достаточно коинов для улучшения уровня!");
                        return;
                    }
                }
                else
                if (boostbox.ContainsValue(value2))
                {
                    if (Economic)
                    {
                        if (!IQEconomic) return;
                        else
                        {
                            if (apiisremoved(player.userID, ammounttoupgrade3))
                            {
                                apiremovebalance(player.userID, ammounttoupgrade3);
                                boostbox.Remove(name);
                                boostbox.Add(name, value1);
                                SendReply(player, "Вы достигли максимального уровня буста дамага!");
                            }
                            else
                            {
                                SendReply(player, "Не достаточно коинов для улучшения уровня!");
                                return;
                            }
                        }
                    }
                    if (player.inventory.GetAmount(itemid) - ammounttoupgrade3 >= 0)
                    {
                        boostbox.Remove(name);
                        boostbox.Add(name, value3);
                        player.inventory.Take(null, itemid, ammounttoupgrade3);
                        SendReply(player, "Вы достигли максимального уровня буста дамага!");
                        SaveData();
                        return;
                    }
                    else
                    {
                        SendReply(player, "Не достаточно коинов для улучшения уровня!");

                        return;
                    }
                }
                else
                if (boostbox.ContainsValue(value3))
                {
                    if (Economic)
                    {
                        if (!IQEconomic) return;
                        else
                        {
                            SendReply(player, "Вы уже достигли максимального уровня буста дамага!");
                            DestroyTimer(damagee);
                            return;
                        }
                    }
                    SendReply(player, "Вы уже достигли максимального уровня буста дамага!");
                    DestroyTimer(damagee);
                    SaveData();
                    return;
                }
            }
        }    
        [ConsoleCommand("cmdbosttakedamage")]
        void cmdbosttakedamage(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            takedamagee = timer.Once(0.09f, () => takedamagebar(player));
            string value1 = "takeboos1";
            string value2 = "takeboos2";
            string value3 = "takeboos3";
            var boostbox = boost[player.userID];
            var name = "TakeDamageBoost";
            if (!boostbox.ContainsKey(name))
            {
                if (Economic)
                {
                    if (!IQEconomic) return;
                    else
                    {

                        if (apiisremoved(player.userID, ammounttoupgrade1))
                        {
                            if (boostbox.ContainsKey(name))
                            {
                                boostbox.Remove(name);
                            }
                            apiremovebalance(player.userID, ammounttoupgrade1);
                            boostbox.Add(name, value1);
                            SendReply(player, "Вы получили первый уровень уменьшения получаемого урона!");
                        }
                        else
                        {
                            SendReply(player, "Не достаточно коинов для улучшения уровня!");
                            return;
                        }
                    }
                }
                if (player.inventory.GetAmount(itemid) - ammounttoupgrade1 >= 0)
                {
                    if (boostbox.ContainsKey(name))
                    {
                        boostbox.Remove(name);
                    }
                    boostbox.Add(name, value1);
                    SendReply(player, "Вы получили первый уровень уменьшения получаемого урона!");
                    player.inventory.Take(null, itemid, ammounttoupgrade1);
                    SaveData();
                    return;
                }
                else
                {
                    SendReply(player, "Не достаточно коинов для улучшения уровня!");
                    return;
                }
            }
            else
            if (boostbox.ContainsKey(name))
            {
                if (boostbox.ContainsValue(value1))
                {
                    if (Economic)
                    {
                        if (!IQEconomic) return;
                        else
                        {
                            if (apiisremoved(player.userID, ammounttoupgrade2))
                            {
                                apiremovebalance(player.userID, ammounttoupgrade2);
                                boostbox.Remove(name);
                                boostbox.Add(name, value1);
                                SendReply(player, "Вы получили второй уровень уменьшения получаемого урона!");
                            }
                            else
                            {
                                SendReply(player, "Не достаточно коинов для улучшения уровня!");
                                return;
                            }
                        }
                    }
                    else
                    if (player.inventory.GetAmount(itemid) - ammounttoupgrade2 >= 0)
                    {
                        boostbox.Remove(name);
                        boostbox.Add(name, value2);
                        player.inventory.Take(null, itemid, ammounttoupgrade2);
                        SendReply(player, "Вы получили второй уровень уменьшения получаемого урона!");
                        SaveData();
                        return;
                    }
                    else
                    {
                        SendReply(player, "Не достаточно коинов для улучшения уровня!");
                        return;
                    }
                }
                if (boostbox.ContainsValue(value2))
                {
                    if (Economic)
                    {
                        if (!IQEconomic) return;
                        else
                        {

                            if (apiisremoved(player.userID, ammounttoupgrade3))
                            {
                                apiremovebalance(player.userID, ammounttoupgrade3);
                                boostbox.Remove(name);
                                boostbox.Add(name, value1);
                                SendReply(player, "Вы достигли максимального уровня уменьшения получаемого урона!");
                            }
                            else
                            {
                                SendReply(player, "Не достаточно коинов для улучшения уровня!");
                                return;
                            }
                        }
                    }
                    else
                    if (player.inventory.GetAmount(itemid) - ammounttoupgrade3 >= 0)
                    {
                        boostbox.Remove(name);
                        boostbox.Add(name, value3);
                        player.inventory.Take(null, itemid, ammounttoupgrade3);
                        SendReply(player, "Вы достигли максимального уровня уменьшения получаемого урона!");
                        SaveData();
                        return;
                    }
                    else
                    {
                        SendReply(player, "Не достаточно коинов для улучшения уровня!");
                        return;
                    }
                }
                else
                if (boostbox.ContainsValue(value3))
                {
                    if (Economic)
                    {
                        if (!IQEconomic) return;
                        else
                        {
                            SendReply(player, "Вы уже достигли максимального уровня уменьшения получаемого урона!");
                            DestroyTimer(takedamagee);
                            return;
                        }
                    }
                    SendReply(player, "Вы уже достигли максимального уровня уменьшения получаемого урона!");
                    DestroyTimer(takedamagee);
                    SaveData();
                    return;
                }
            }
        }
        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
        {
            BasePlayer Initiator = hitInfo.InitiatorPlayer;
            BasePlayer Target = entity as BasePlayer;
            if (hitInfo != null && Initiator != null && entity != null)
            {
                if (entity.GetComponent<BasePlayer>())
                {
                    if (!boost.ContainsKey(Initiator.userID))
                    {
                        return;
                    }
                    else
                    {
                        var name = "DamageBoost";
                        var boostbox = boost[Initiator.userID];
                        var mtotal = hitInfo.damageTypes.Total();

                        if (boostbox.ContainsKey(name))
                        {
                            var bbox = boostbox[name];
                            if (bbox == "Dast1")
                            {
                                if (hitInfo != null && hitInfo.InitiatorPlayer != null && entity != null)
                                {
                                    hitInfo.damageTypes.ScaleAll(damagebost1);
                                }
                            }
                            if (bbox == "Dast2")
                            {
                                if (hitInfo != null && hitInfo.InitiatorPlayer != null && entity != null)
                                {
                                    hitInfo.damageTypes.ScaleAll(damagebost2);

                                }
                            }
                            if (bbox == "Dast3")
                            {
                                if (hitInfo != null && hitInfo.InitiatorPlayer != null && entity != null)
                                {
                                    hitInfo.damageTypes.ScaleAll(damagebost3);
                                }
                            }
                        }
                        else
                        { return; }
                    }
                }
            }
            if (entity == Target)
            {
                if (entity.GetComponent<BasePlayer>())
                {
                    if (hitInfo != null && entity != null)
                    {
                        if (!boost.ContainsKey(Target.userID))
                        {
                            return;
                        }
                        else
                        {
                            var boostbox = boost[Target.userID];
                            var name = "TakeDamageBoost";
                            var damage = hitInfo.damageTypes.Total();
                            if (boostbox.ContainsKey(name))
                            {
                                var btbox = boostbox[name];
                                if (btbox == "takeboos1")
                                {
                                    hitInfo.damageTypes.ScaleAll(protectdamage1);
                                }
                                if (btbox == "takeboos2")
                                {
                                    hitInfo.damageTypes.ScaleAll(protectdamage2);
                                }
                                if (btbox == "takeboos3")
                                {
                                    hitInfo.damageTypes.ScaleAll(protectdamage3);
                                }
                            }
                        }
                    }
                }
               
            }
        }

        T GetConfig<T>(string name, T defaultValue) => Config[name] == null ? defaultValue : (T)Convert.ChangeType(Config[name], typeof(T));
        public static void GetVariable<T>(DynamicConfigFile config, string name, out T value, T defaultValue)
        {
            config[name] = value = config[name] == null ? defaultValue : (T)Convert.ChangeType(config[name], typeof(T));
        }
        DynamicConfigFile boostfile = Interface.Oxide.DataFileSystem.GetFile("BoostSystem/playerslvl");
        void LoadData()
        {
            try
            {
                    boost = boostfile.ReadObject<Dictionary<ulong, Dictionary<string, string>>>();
                
                if (boost == null)
                {
                    PrintError("File Homes is null! Create new data files");
                        boost = new Dictionary<ulong, Dictionary<string, string>>();                   
                }
            }
            catch
            {

                    boost = new Dictionary<ulong, Dictionary<string, string>>();
            }
        }
        void SaveData()
        {
                if (boost != null) boostfile.WriteObject(boost);           
        }
        void OnServerInitialized()
        {
            LoadData();
            LoadDefaultConfig();
        }
        void Unload() => SaveData();
        private void GetNewSave()
        {
            if (wipedData)
            {
                PrintWarning("Обнаружен вайп. Очищаем данные с BoostSystem/playerslvl");
                WipeData();
            }
        }
        void WipeData()
        {
            LoadData();
                boost = new Dictionary<ulong, Dictionary<string, string>>();
            SaveData();
        }
    }
}


// --- End of file: BoostSystem.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Exchanger.cs ---
// --- Original Local Path: Exchanger.cs ---

using ConVar;

using Newtonsoft.Json;

using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;

using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Exchanger", "Sempai#3239", "2.0.0")]
    public class Exchanger : RustPlugin
    {
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Exchanger"] = "<size=16>Exchanger:</size>",
                ["Exchanger_not_enough"] = "You do not have enough {0} to share!",
                ["Exchanger_perfect"] = "Exchange completed successfully",
                ["Exchanger_no_auth"] = "In order to get a balance you must be logged in to the store!",
                ["Exchanger_UI_ex"] = "INTERNAL EXCHANGER",
                ["Exchanger_UI_yes"] = "EXCHANGE",
                ["Exchanger_UI_no"] = "NOT AVAILABLE",
                ["Exchanger_UI_course"] = "<b>EXCHANGE RATE</b>\n",

            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Exchanger"] = "<size=16>Обменник:</size>",
                ["Exchanger_not_enough"] = "У вас недостаточно {0} для обмена!",
                ["Exchanger_perfect"] = "Обмен совершен успешно",
                ["Exchanger_no_auth"] = "Для того чтобы получить баланс вы должны быть авторизованы в магазине!",
                ["Exchanger_UI_ex"] = "ВНУТРЕННИЙ ОБМЕННИК",
                ["Exchanger_UI_yes"] = "ОБМЕНЯТЬ",
                ["Exchanger_UI_no"] = "НЕДОСТУПНО",
                ["Exchanger_UI_course"] = "<b>КУРС ОБМЕНА</b>\n",

            }, this, "ru");
        }

        #region Configuration

        private static Configuration config = new Configuration();
        private class Configuration
        {

            [JsonProperty("Использовать магазин GameStore (Если OVH то ставим False)")]
            public bool UseGameStore;
            [JsonProperty("[GameStores] ID магазина")]
            public string ShopID = "ShopID";
            [JsonProperty("[GameStores] ID сервера")]
            public string ServerID = "";
            [JsonProperty("[GameStores] Секретный ключ")]
            public string SecretKey = "SecretKey";
            [JsonProperty("Команда для открытия обменника")]
            public string OpenEX;


            [JsonProperty("Настройка обменника")]
            public Dictionary<string, CustomItem> customs;


            public static Configuration GetNewConfiguration()
            {
                return new Configuration
                {
                    UseGameStore = false,
                    ServerID = "",
                    ShopID = "ShopID",
                    SecretKey = "SecretKey",
                    OpenEX = "emerald",

                    customs = new Dictionary<string, CustomItem>
                    {
                        ["Радужная+пыль"] = new CustomItem
                        {
                            DisplayName = "Радужная пыль",
                            ReplaceShortName = "glue",
                            DropAmount = 1,
                            ReplaceID = 1757726873,
                            PictureURL = "https://i.imgur.com/NtpIRnf.png",
                            containerList = new Dictionary<string, int>()
                            {
                                { "codelockedhackablecrate", 30 },
                                { "crate_elite", 25 },
                                { "loot_barrel_2", 20 },
                                { "crate_normal", 10 },
                                { "heli_crate", 40 },
                            },

                            ExchangeOptions = new CustomItem.Exchange
                            {
                                SecondItemName = "Радужный+осколок",
                                FirstAmount = 10,
                            }
                        },
                        ["Радужный+осколок"] = new CustomItem
                        {
                            DisplayName = "Радужный осколок",
                            ReplaceShortName = "ducttape",
                            DropAmount = 1,
                            ReplaceID = 1757727611,
                            PictureURL = "https://i.imgur.com/EIBMNK1.png",
                            containerList = new Dictionary<string, int>()
                            {
                                { "codelockedhackablecrate", 30 },
                                { "crate_elite", 25 },
                                { "loot_barrel_2", 20 },
                                { "crate_normal", 10 },
                                { "heli_crate", 40 },
                            },

                            ExchangeOptions = new CustomItem.Exchange
                            {
                                SecondItemName = "Радужный+кристалл",
                                FirstAmount = 5,
                            }
                        },
                        ["Радужный+кристалл"] = new CustomItem
                        {
                            DisplayName = "Радужный кристалл",
                            ReplaceShortName = "bleach",
                            DropAmount = 1,
                            ReplaceID = 1757728373,
                            PictureURL = "https://i.imgur.com/ePSDZQ2.png",
                            containerList = new Dictionary<string, int>()
                            {
                                { "codelockedhackablecrate", 30 },
                                { "crate_elite", 25 },
                                { "loot_barrel_2", 20 },
                                { "crate_normal", 10 },
                                { "heli_crate", 40 },
                            },

                            ExchangeOptions = new CustomItem.Exchange
                            {
                                SecondItemName = "Рубли",
                                FirstAmount = 2,
                            }
                        },
                        ["Рубли"] = new CustomItem
                        {
                            DisplayName = "Рубли",
                            ReplaceShortName = "rock",
                            DropAmount = 1,
                            ReplaceID = 0,
                            PictureURL = "https://i.imgur.com/s0qdh7c.png",
                            containerList = null,

                            ExchangeOptions = null
                        }
                    }
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                PrintWarning("Ошибка139" + $"чтения конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!!");
                LoadDefaultConfig();
            }
            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig()
        {
            config = Configuration.GetNewConfiguration();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion

        #region Classes

        private class CustomItem
        {
            internal class Exchange
            {
                [JsonProperty("Обмен на какой предмет")]
                public string SecondItemName;
                [JsonProperty("Необходимое количество для обмена")]
                public int FirstAmount;
            }

            [JsonProperty("Отображаемое имя")]
            public string DisplayName;
            [JsonProperty("Название предмета который он будет заменять")]
            public string ReplaceShortName;

            [JsonProperty(PropertyName = "Контейнер тз которого может выпасть этот предмет и процент выпадения")]
            public Dictionary<string, int> containerList;
            [JsonProperty("Кол-вл выпадения")]
            public int DropAmount;

            [JsonProperty("Ссылка на изображение")]
            public string PictureURL;
            [JsonProperty("Скин ID предмета")]
            public ulong ReplaceID;

            [JsonProperty("Курс обмена предмета")]
            public Exchange ExchangeOptions = new Exchange();

            public int GetItemId()
            {
                return ItemManager.FindItemDefinition(ReplaceShortName).itemid;
            }

            public int GetItemAmount(BasePlayer player)
            {
                return player.inventory.GetAmount(GetItemId());
            }

            public Item Copy(int amount = 1)
            {
                Item x = ItemManager.CreateByPartialName(ReplaceShortName, amount);
                x.skin = ReplaceID;
                x.name = DisplayName;

                return x;
            }
            public void CreateItem(BasePlayer player, Vector3 position, int amount)
            {
                Item x = ItemManager.CreateByPartialName(ReplaceShortName, amount);
                x.skin = ReplaceID;
                x.name = DisplayName;

                if (player != null)
                {
                    if (player.inventory.containerMain.itemList.Count < 24)
                    {
                        x.MoveToContainer(player.inventory.containerMain);
                    }
                    else
                    {
                        x.Drop(player.transform.position, Vector3.zero);
                    }

                    return;
                }

                if (position != Vector3.zero)
                {
                    x.Drop(position, Vector3.down);
                    return;
                }
            }

            public bool CanExchange(BasePlayer player)
            {
                return GetItemAmount(player) >= ExchangeOptions.FirstAmount;
            }
        }

        #endregion

        #region Variables

        [PluginReference] private readonly Plugin ImageLibrary, IQChat;
        private static readonly System.Random Rnd = new System.Random();

        #endregion

        #region Initialization
        private void OnServerInitialized()
        {
            if (!ImageLibrary)
            {
                PrintError($"ERROR! Plugin ImageLibrary not found!");
                return;
            }

            foreach (KeyValuePair<string, CustomItem> check in config.customs)
            {
                ImageLibrary.Call("AddImage", check.Value.PictureURL, check.Key);
            }

            cmd.AddChatCommand(config.OpenEX, this, nameof(cmdChatEmerald));
            if (config.UseGameStore)
            {
                if (config.ShopID == "ShopID" || config.SecretKey == "SecretKey")
                {
                    PrintError("Вы не настроили ShopID И SecretKey от магазина GameStores");
                    return;
                }
            }
        }

        #endregion

        #region Hooks
        private void AddEmeralds(LootContainer cont)
        {
            if (cont == null)
            {
                return;
            }

            Dictionary<string, int> spawnItems = new Dictionary<string, int>();

            foreach (KeyValuePair<string, CustomItem> emeralds in config.customs.Where(x => x.Value.ExchangeOptions != null))
            {
                foreach (KeyValuePair<string, int> em in emeralds.Value.containerList)
                {
                    if (cont.PrefabName.Contains(em.Key))
                    {
                        spawnItems.Add(emeralds.Key, em.Value);
                    }
                }
            }

            if (spawnItems.Count == 0)
            {
                return;
            }

            cont.minSecondsBetweenRefresh = -1;
            cont.maxSecondsBetweenRefresh = 0;
            cont.GetComponent<FacepunchBehaviour>().CancelInvoke(new Action(cont.SpawnLoot));

            KeyValuePair<string, int> rndItem = spawnItems.OrderBy(x => Rnd.Next()).FirstOrDefault();
            string emeraldKey = string.Empty;

            bool isGoodChance = Rnd.Next(0, 1000) / 10f <= rndItem.Value;
            if (isGoodChance)
            {
                emeraldKey = rndItem.Key;
            }

            if (string.IsNullOrEmpty(emeraldKey))
            {
                return;
            }

            CustomItem cfgItem = config.customs[rndItem.Key];
            Item item = cfgItem.Copy(cfgItem.DropAmount);

            if (cont.inventory.capacity < cont.inventory.itemList.Count() + 1)
            {
                cont.inventory.capacity++;
            }

            item.MoveToContainer(cont.inventory, -1, true);
        }
        private void OnLootSpawn(LootContainer container)
        {
            if (container == null)
            {
                return;
            }

            AddEmeralds(container);
        }

        private object CanCombineDroppedItem(DroppedItem item, DroppedItem targetItem)
        {
            if (item.GetItem().skin != targetItem.GetItem().skin)
            {
                return false;
            }

            return null;
        }

        private object CanStackItem(Item item, Item targetItem)
        {
            if (item.skin != targetItem.skin)
            {
                return false;
            }

            return null;
        }
        #endregion

        #region Commands

        [ConsoleCommand("emerald.give")]
        private void CmdConsoleGive(ConsoleSystem.Arg args)
        {
            if (args.Player() != null || !args.HasArgs(3))
            {
                return;
            }

            ulong targetId;
            string name = args.Args[1];
            int amount;
            if (ulong.TryParse(args.Args[0], out targetId) && int.TryParse(args.Args[2], out amount))
            {
                if (config.customs.ContainsKey(name))
                {
                    BasePlayer target = BasePlayer.FindByID(targetId);
                    if (target != null && target.IsConnected)
                    {
                        config.customs[name].CreateItem(target, Vector3.zero, amount);
                    }
                }
            }
        }

        [ConsoleCommand("exchangeUI")]
        private void cmdConsoleHandler(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Player();
            if (player != null && args.HasArgs(1))
            {
                switch (args.Args[0].ToLower())
                {
                    case "exchange":
                        {
                            if (args.HasArgs(3))
                            {
                                if (config.customs.ContainsKey(args.Args[1]) && config.customs.ContainsKey(args.Args[2]))
                                {
                                    CustomItem firstItem = config.customs[args.Args[1]];
                                    CustomItem secondItem = config.customs[args.Args[2]];
                                    int firstAmount = firstItem.GetItemAmount(player);
                                    int secondAmount = (int)Math.Floor((double)firstAmount / firstItem.ExchangeOptions.FirstAmount);

                                    if (firstAmount < firstItem.ExchangeOptions.FirstAmount)
                                    {
                                        SendChat(lang.GetMessage("Exchanger", this, player.UserIDString), string.Format(lang.GetMessage("Exchanger_not_enough", this, player.UserIDString), firstItem.DisplayName), player);
                                        return;
                                    }

                                    if (secondItem.ExchangeOptions != null)
                                    {
                                        player.inventory.Take(null, firstItem.GetItemId(), (int)Math.Floor((double)firstAmount / firstItem.ExchangeOptions.FirstAmount) * firstItem.ExchangeOptions.FirstAmount);
                                        secondItem.CreateItem(player, Vector3.zero, secondAmount);
                                        SendChat(lang.GetMessage("Exchanger", this, player.UserIDString), lang.GetMessage("Exchanger_perfect", this, player.UserIDString), player);
                                    }
                                    else
                                    {
                                        if (config.UseGameStore)
                                        {
                                            string uri = $"https://gamestores.ru/api?shop_id={config.ShopID}&secret={config.SecretKey}&server={config.ServerID}&action=moneys&type=plus&steam_id={player.userID}&amount={secondAmount}&mess=Обменник";
                                            webrequest.Enqueue(uri, null, (i, s) =>
                                            {
                                                if (i != 200) { }
                                                if (s.Contains("success"))
                                                {
                                                    SendChat(lang.GetMessage("Exchanger", this, player.UserIDString), lang.GetMessage("Exchanger_perfect", this, player.UserIDString), player);
                                                    player.inventory.Take(null, firstItem.GetItemId(), (int)Math.Floor((double)firstAmount / firstItem.ExchangeOptions.FirstAmount) * firstItem.ExchangeOptions.FirstAmount);
                                                    CuiHelper.DestroyUi(player, Layer);
                                                }
                                                else
                                                {
                                                    SendChat(lang.GetMessage("Exchanger", this, player.UserIDString), lang.GetMessage("Exchanger_no_auth", this, player.UserIDString), player);
                                                    CuiHelper.DestroyUi(player, Layer);
                                                }
                                            }, this);
                                        }
                                        else
                                        {
                                            plugins.Find("RustStore")?.CallHook("APIChangeUserBalance", player.userID, secondAmount, new Action<string>((result) =>
                                            {
                                                if (result == "SUCCESS")
                                                {
                                                    SendChat(lang.GetMessage("Exchanger", this, player.UserIDString), lang.GetMessage("Exchanger_perfect", this, player.UserIDString), player);
                                                    player.inventory.Take(null, firstItem.GetItemId(), (int)Math.Floor((double)firstAmount / firstItem.ExchangeOptions.FirstAmount) * firstItem.ExchangeOptions.FirstAmount);
                                                    CuiHelper.DestroyUi(player, Layer);
                                                    return;
                                                }
                                                Interface.Oxide.LogDebug($"Баланс не был изменен, ошибка: {result}");
                                                SendChat(lang.GetMessage("Exchanger", this, player.UserIDString), lang.GetMessage("Exchanger_no_auth", this, player.UserIDString), player);
                                                CuiHelper.DestroyUi(player, Layer);
                                            }));
                                        }
                                    }

                                    UI_DrawExchange(player);
                                }
                            }
                            break;
                        }
                }
            }
        }

        [ConsoleCommand("emeralds")]
        private void ConsoleOpenMenu(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            UI_DrawExchange(player);
        }

        private void cmdChatEmerald(BasePlayer player, string command, string[] args)
        {
            if (args.Length != 0 && args[0] == "secrettest" && player.IsAdmin)
            {
                foreach (KeyValuePair<string, CustomItem> check in config.customs)
                {
                    check.Value.CreateItem(player, Vector3.zero, 1000000);
                }
            }
            UI_DrawExchange(player);
        }

        #endregion

        #region Interface

        private const string Layer = "UI_Emerald";
        private void UI_DrawExchange(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, Layer);
            CuiElementContainer container = new CuiElementContainer
            {
                {
                    new CuiPanel
                    {
                        CursorEnabled = true,
                        RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-229 -143", OffsetMax = "229 143" },
                        Image = { Color = "0 0 0 0" }
                    },
                    "Hud",
                    Layer
                },

                {
                    new CuiButton
                    {
                        RectTransform = { AnchorMin = "-1000 -1000", AnchorMax = "1000 1000", OffsetMax = "0 0" },
                        Button = { Close = Layer, Material = "assets/content/ui/uibackgroundblur.mat", Color = "0 0 0 0.9" },
                        Text = { Text = "" }
                    },
                    Layer
                },

                new CuiElement
                {
                    Parent = Layer,
                    Components =
                {
                    new CuiImageComponent { Color = HexToRustFormat("#FFFFFF0E"), Material = "assets/content/ui/scope_2.mat" },
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" }
                }
                },
                {
                    new CuiLabel
                    {
                        RectTransform = { AnchorMin = "0.00509456 0.8319815", AnchorMax = "0.9992717 0.9965037", OffsetMax = "0 0" },
                        Text = { Text = lang.GetMessage("Exchanger_UI_ex", this, player.UserIDString), Font = "robotocondensed-bold.ttf", FontSize = 20, Align = TextAnchor.MiddleCenter }
                    },
                    Layer
                }
            };

            foreach (var check in config.customs.Select((i, t) => new { A = i, B = t }).Where(p => p.A.Value.ExchangeOptions != null))
            {
                #region FirstItem

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"0.1084428 {0.5722611 - check.B * 0.25}", AnchorMax = $"0.2540031 {0.8053614 - check.B * 0.25}", OffsetMax = "0 0" },
                    Button = { Color = HexToRustFormat("#7777773C"), Material = "assets/icons/iconmaterial.mat" },
                    Text = { Text = "x" + check.A.Value.ExchangeOptions.FirstAmount + " ", Align = TextAnchor.LowerRight, FontSize = 12, Font = "robotocondensed-regular.ttf" }
                }, Layer, "EmeraldFirst" + check.A.Key);

                container.Add(new CuiElement
                {
                    Parent = "EmeraldFirst" + check.A.Key,
                    Components =
                    {
                        new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", check.A.Key) },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 5", OffsetMax = "-5 -5" }
                    }
                });

                #endregion

                #region Button Change

                string btnColor = check.A.Value.CanExchange(player) ? "#77A16DFF" : "#A16D6DFF";
                string btnText = check.A.Value.CanExchange(player) ? lang.GetMessage("Exchanger_UI_yes", this, player.UserIDString) : lang.GetMessage("Exchanger_UI_no", this, player.UserIDString);

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"0.3 {0.5722611 - check.B * 0.25}", AnchorMax = $"0.7 {0.6857343 - check.B * 0.25}", OffsetMax = "0 0" },
                    Button = { Color = HexToRustFormat(btnColor), Command = $"exchangeUI exchange {check.A.Key} {check.A.Value.ExchangeOptions.SecondItemName}", Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                    Text = { Text = btnText, Font = "robotocondensed-regular.ttf", FontSize = 24, Align = TextAnchor.MiddleCenter }
                }, Layer, "ExchangeButton" + check.A.Key);

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 1.1", AnchorMax = "1 2.1" },
                    Text = { FontSize = 14, Text =lang.GetMessage("Exchanger_UI_course", this, player.UserIDString) +
                                    $"{check.A.Value.DisplayName} x{check.A.Value.ExchangeOptions.FirstAmount} -> {check.A.Value.ExchangeOptions.SecondItemName} x1", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf",
                        Color = HexToRustFormat("#BEBEBE94") }
                }, "ExchangeButton" + check.A.Key);

                #endregion

                #region SecondItem

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"0.7620094 {0.5722611 - check.B * 0.25}", AnchorMax = $"0.9075698 {0.8053614 - check.B * 0.25}", OffsetMax = "0 0" },
                    Button = { Color = HexToRustFormat("#7777773C"), Material = "assets/icons/iconmaterial.mat" },
                    Text = { Text = "x1 ", Align = TextAnchor.LowerRight, FontSize = 12, Font = "robotocondensed-regular.ttf" }
                }, Layer, "EmeraldSecond" + check.A.Key);

                container.Add(new CuiElement
                {
                    Parent = "EmeraldSecond" + check.A.Key,
                    Components =
                    {
                        new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", check.A.Value.ExchangeOptions.SecondItemName) },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 5", OffsetMax = "-5 -5" }
                    }
                });

                #endregion
            }

            CuiHelper.AddUi(player, container);
        }

        public void SendChat(string Descrip, string Message, BasePlayer player, Chat.ChatChannel channel = Chat.ChatChannel.Global)
        {
            if (IQChat)
            {
                IQChat?.Call("API_ALERT_PLAYER", player, Message, Descrip);
            }
            else
            {
                player.SendConsoleCommand("chat.add", channel, 0, Message);
            }
        }

        #endregion

        #region Utils

        private string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            string str = hex.Trim('#');

            if (str.Length == 6)
            {
                str += "FF";
            }

            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            byte r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            byte g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            byte b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            byte a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);

            return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
        }

        #endregion
    }
}

// --- End of file: Exchanger.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/SSNNotifier.cs ---
// --- Original Local Path: SSNNotifier.cs ---

using System.Collections.Generic;
using System;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries;
using System.Security.Cryptography;
using System.Text;

namespace Oxide.Plugins
{
    [Info("SSNNotifier", "Umlaut", "0.0.5")]
    class SSNNotifier : RustPlugin
    {
        // Types defenition

        enum TimeRange
        {
            Hour = 0,
            Day = 1,
            Week = 2,
            Month = 3,
            Year = 4
        }

        class BanItem
        {
            public string timestamp;
            public string reason;

            public BanItem()
            {
                timestamp = "";
                reason = "";
            }
        }

        class MuteItem
        {
            public string timestamp = "";
            public string reason = "";
            public TimeRange level = TimeRange.Hour;

            public DateTime untilDatetime()
            {
                return DateTime.ParseExact(timestamp, "yyyy-MM-dd HH:mm:ss", System.Globalization.CultureInfo.CurrentCulture) + timeSpan();
            }

            TimeSpan timeSpan()
            {
                switch (level)
                {
                    case TimeRange.Hour: return new TimeSpan(0, 1, 0, 0);
                    case TimeRange.Day: return new TimeSpan(1, 0, 0, 0);
                    case TimeRange.Week: return new TimeSpan(7, 1, 0, 0);
                    case TimeRange.Month: return new TimeSpan(28, 1, 0, 0);
                    case TimeRange.Year: return new TimeSpan(365, 1, 0, 0);
                    default: return new TimeSpan();
                }
            }
        }

        class ConfigData
        {
            public bool print_errors = true;
            public string server_name = "insert here name of your server";
            public string server_password = "insert here password of your server";

            public Dictionary<string, string> Messages = new Dictionary<string, string>();

            public Dictionary<ulong, BanItem> BannedPlayers = new Dictionary<ulong, BanItem>();
            public Dictionary<ulong, MuteItem> MutedPlayers = new Dictionary<ulong, MuteItem>();
        }

        // Object vars

        ConfigData m_configData;
        WebRequests m_webRequests = Interface.GetMod().GetLibrary<WebRequests>("WebRequests");

        public string m_host = "survival-servers-network.com";
        public string m_port = "1024";

        Dictionary<ulong, string> m_playersNames;
        Dictionary<ulong, List<ulong>> m_contextPlayers = new Dictionary<ulong, List<ulong>>();

        //

        void LoadConfig()
        {
            try
            {
                m_configData = Config.ReadObject<ConfigData>();
                InsertDefaultMessages();
            }
            catch
            {
                LoadDefaultConfig();
            }
        }

        void SaveConfig()
        {
            Config.WriteObject<ConfigData>(m_configData, true);
        }

        void LoadDynamic()
        {
            try
            {
                m_playersNames = Interface.GetMod().DataFileSystem.ReadObject<Dictionary<ulong, string>>("PlayersNames");
            }
            catch
            {
                m_playersNames = new Dictionary<ulong, string>();
            }
        }

        void SaveDynamic()
        {
            Interface.GetMod().DataFileSystem.WriteObject("PlayersNames", m_playersNames);
        }

        public void InsertDefaultMessage(string key, string message)
        {
            if (!m_configData.Messages.ContainsKey(key))
            {
                m_configData.Messages.Add(key, message);
            }
        }

        void InsertDefaultMessages()
        {
            InsertDefaultMessage("all_online_players_count", "All online players <color=cyan>%count</color>.");
            InsertDefaultMessage("invalid_arguments", "Invalid arguments.");
            InsertDefaultMessage("player_not_found", "Player not found.");
            InsertDefaultMessage("players_line", "<color=cyan>%number)</color> %player");
            InsertDefaultMessage("wellcome", "");

            InsertDefaultMessage("invalid_arguments", "Invalid arguments.");
            InsertDefaultMessage("player_not_found", "Player not found.");

            InsertDefaultMessage("player_was_not_banned", "Player <color=cyan>%player_name</color>(<color=cyan>%player_steamid</color>) was not banned.");
            InsertDefaultMessage("player_is_banned_already", "Player <color=cyan>%player_name</color>(<color=cyan>%player_steamid</color>) is banned already by reason \"<color=cyan>%reason</color>\".");
            InsertDefaultMessage("player_was_banned", "Player <color=cyan>%player_name</color>(<color=cyan>%player_steamid</color>) was banned by reason \"<color=cyan>%reason</color>\".");
            InsertDefaultMessage("player_was_unbanned", "Player <color=cyan>%player_name</color>(<color=cyan>%player_steamid</color>) was unbanned.");

            InsertDefaultMessage("player_was_not_muted", "Player <color=cyan>%player_name</color>(<color=cyan>%player_steamid</color>) was not muted.");
            InsertDefaultMessage("player_is_muted_already", "Player <color=cyan>%player_name</color>(<color=cyan>%player_steamid</color>) is muted already by reason \"<color=cyan>%reason</color> until <color=cyan>%until_datetime</color>(for <color=cyan>%level</color>)");
            InsertDefaultMessage("player_was_muted", "Player <color=cyan>%player_name</color>(<color=cyan>%player_steamid</color>) was muted by reason \"<color=cyan>%reason</color>\" until <color=cyan>%until_datetime</color>(for <color=cyan>%level</color>)");
            InsertDefaultMessage("player_was_unmuted", "Player <color=cyan>%player_name</color>(<color=cyan>%player_steamid</color>) was unmuted.");

            foreach (var timeRange in Enum.GetValues(typeof(TimeRange)))
            {
                InsertDefaultMessage(timeRange.ToString(), timeRange.ToString());
            }

            /*
            InsertDefaultMessage(TimeRange.Hour.ToString(), TimeRange.Hour.ToString());
            InsertDefaultMessage(TimeRange.Day.ToString(), TimeRange.Day.ToString());
            InsertDefaultMessage(TimeRange.Week.ToString(), TimeRange.Week.ToString());
            InsertDefaultMessage(TimeRange.Month.ToString(), TimeRange.Month.ToString());
            InsertDefaultMessage(TimeRange.Year.ToString(), TimeRange.Year.ToString());
            */

        }

        // Hooks

        void Loaded()
        {
            LoadConfig();
            LoadDynamic();

            NotifyServerOn();

            timer.Repeat(60, 0, () => SaveDynamic());
            timer.Repeat(60*5, 0, () => NotifyServerOn());

            checkPermission("SSNNotifier.mute");
            checkPermission("SSNNotifier.unmute");
            checkPermission("SSNNotifier.ban");
            checkPermission("SSNNotifier.unban");
        }

        void checkPermission(string _permission)
        {
            if (!permission.PermissionExists(_permission))
            {
                permission.RegisterPermission(_permission, this);
            }
        }

        private void Unload()
        {
            NotifyServerOff();
            SaveDynamic();
        }

        void LoadDefaultConfig()
        {
            m_configData = new ConfigData();
            InsertDefaultMessages();
            Config.WriteObject(m_configData, true);
        }

        // Players hooks

        object CanClientLogin(Network.Connection connection)
        {
            ulong userID = connection.userid;
            if (m_configData.BannedPlayers.ContainsKey(userID))
            {
                string playerName = PlayerName(userID);

                string message = m_configData.Messages["player_was_banned"];
                message = message.Replace("%player_name", playerName);
                message = message.Replace("%player_steamid", userID.ToString());
                message = message.Replace("%reason", m_configData.BannedPlayers[userID].reason);

                return message;
            }

            return true;
        }

        void OnPlayerInit(BasePlayer player)
        {
            NotifyPlayerConnected(player.userID, player.displayName, player.net.connection.ipaddress.Split(':')[0]);

            m_playersNames[player.userID] = player.displayName;
            if (m_configData.Messages["wellcome"].Length != 0)
                player.ChatMessage(m_configData.Messages["wellcome"]);
        }

        void OnPlayerDisconnected(BasePlayer player)
        {
            NotifyPlayerDisconnected(player.userID, player.displayName);
        }

        void OnEntityDeath(BaseCombatEntity entity, HitInfo hitInfo)
        {
            if (entity == null || hitInfo == null || hitInfo.Initiator == null)
            {
                return;
            }

            BasePlayer playerVictim = entity as BasePlayer;
            BasePlayer playerKiller = hitInfo.Initiator as BasePlayer;

            if (playerVictim == null || playerKiller == null || playerVictim == playerKiller)
            {
                return;
            }

            double distance = Math.Sqrt(
                Math.Pow(playerVictim.transform.position.x - playerKiller.transform.position.x, 2) +
                Math.Pow(playerVictim.transform.position.y - playerKiller.transform.position.y, 2) +
                Math.Pow(playerVictim.transform.position.z - playerKiller.transform.position.z, 2));

            NotifyMurder(playerVictim.userID, playerVictim.displayName, playerKiller.userID, playerKiller.displayName, hitInfo.Weapon.GetItem().info.itemid, distance, hitInfo.isHeadshot, playerVictim.IsSleeping());
        }

        object OnPlayerChat(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();

            string message = "";
            foreach (string line in arg.Args)
            {
                message += line + " ";
            }
            message = message.Trim();

            if (m_configData.MutedPlayers.ContainsKey(player.userID))
            {
                MuteItem muteItem = m_configData.MutedPlayers[player.userID];

                if (muteItem.untilDatetime() > DateTime.Now)
                {
                    message = m_configData.Messages["player_was_muted"];
                    message = message.Replace("%player_name", player.displayName);
                    message = message.Replace("%player_steamid", player.userID.ToString());
                    message = message.Replace("%reason", muteItem.reason);
                    message = message.Replace("%until_datetime", muteItem.untilDatetime().ToString("yyyy-MM-dd HH:mm:ss"));
                    message = message.Replace("%level", m_configData.Messages[muteItem.level.ToString()]);

                    player.ChatMessage(message);
                    return "handled";
                }
            }

            if (message != "" && message[0] != '/')
            {
                NotifyPlayerChatMessage(player.userID, player.displayName, message);
            }

            return null;
        }

        // Chat commands

        [ChatCommand("players")]
        void cmdChatPlayers(BasePlayer player, string command, string[] args)
        {
            string filter = "";
            int linesCount = 0;

            // 

            if (args.Length == 1)
            {
                if (!int.TryParse(args[0], out linesCount))
                {
                    filter = args[0];
                }
            }
            else if(args.Length == 2)
            {
                filter = args[0];
                if (!int.TryParse(args[1], out linesCount))
                {
                    player.ChatMessage(m_configData.Messages["invalid_arguments"]);
                }
            }
            else if (args.Length != 0)
            {
                player.ChatMessage(m_configData.Messages["invalid_arguments"]);
            }


            // Filtering by name

            List<BasePlayer> players = new List<BasePlayer>();
            foreach (BasePlayer currentPlayer in BasePlayer.activePlayerList)
            {
                if (filter != "" && !currentPlayer.displayName.Contains(filter, System.Globalization.CompareOptions.IgnoreCase))
                {
                    continue;
                }
                players.Add(currentPlayer);
            }

            // Sorting by name

            for (int f = 0; f < players.Count - 1; ++f)
            {
                for (int j = f + 1; j < players.Count; ++j)
                {
                    if (players[f].displayName.CompareTo(players[j].displayName) > 0)
                    {
                        BasePlayer tmpPlayer = players[f];
                        players[f] = players[j];
                        players[j] = tmpPlayer;
                    }
                }
            }

            // Context list

            int i = 0;
            List<ulong> contextPlayers = new List<ulong>();

            if (linesCount == 0)
            {
                foreach (BasePlayer currentPlayer in players)
                {
                    contextPlayers.Add(currentPlayer.userID);
                    player.ChatMessage(m_configData.Messages["players_line"].Replace("%number", (++i).ToString()).Replace("%player", currentPlayer.displayName) );
                }
            }
            else
            {
                List<BasePlayer> cPlayers = new List<BasePlayer>(players);
                int playerPerLine = (int)Math.Ceiling((double)players.Count/(double)linesCount);
                int index = 0;
                while (cPlayers.Count != 0)
                {
                    string line = "";
                    for (int z = 0; z < playerPerLine && cPlayers.Count != 0; ++z)
                    {
                        contextPlayers.Add(cPlayers[0].userID);
                        line += m_configData.Messages["players_line"].Replace("%number", (++index).ToString()).Replace("%player", cPlayers[0].displayName);
                        line += " ";
                        cPlayers.RemoveAt(0);
                    }
                    player.ChatMessage(line);
                }
            }
            player.ChatMessage(m_configData.Messages["all_online_players_count"].Replace("%count", BasePlayer.activePlayerList.Count.ToString()));
            SetContextPlayers(player.userID, contextPlayers);
        }

        [ChatCommand("ban")]
        void cmdBan(BasePlayer player, string command, string[] args)
        {
            if (player.net.connection.authLevel == 0 && !permission.UserHasPermission(player.userID.ToString(), "SSNBans.ban"))
            {
                return;
            }

            if (args.Length < 2)
            {
                player.ChatMessage(m_configData.Messages["invalid_arguments"]);
                return;
            }

            ulong userId = UserIdByAlias(player.userID, args[0]);
            if (userId == 0)
            {
                player.ChatMessage(m_configData.Messages["player_not_found"]);
                return;
            }

            string playerName = PlayerName(userId);

            string reason = "";
            for (int i = 1; i < args.Length; ++i)
            {
                reason += args[i];
                if (i < args.Length - 1)
                {
                    reason += " ";
                }
            }

            if (m_configData.BannedPlayers.ContainsKey(userId))
            {

                BanItem banItem = m_configData.BannedPlayers[userId];
                string message = m_configData.Messages["player_is_banned_already"];
                message = message.Replace("%player_name", playerName);
                message = message.Replace("%player_steamid", userId.ToString());
                message = message.Replace("%reason", banItem.reason);
                player.ChatMessage(message);
            }
            else
            {
                BanItem banItem = new BanItem();
                banItem.reason = reason;
                banItem.timestamp = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss");
                m_configData.BannedPlayers[userId] = banItem;

                ConsoleSystem.Run.Server.Quiet(string.Format("banid {0} \"{1}\" \"{2}\"", userId.ToString(), playerName, reason).ToString(), true);
                ConsoleSystem.Run.Server.Quiet("server.writecfg", true);

                SaveConfig();

                string message = m_configData.Messages["player_was_banned"];
                message = message.Replace("%player_name", playerName);
                message = message.Replace("%player_steamid", userId.ToString());
                message = message.Replace("%reason", banItem.reason);
                ConsoleSystem.Broadcast("chat.add", 0, message, 1.0);

                BasePlayer targetPlayer = BasePlayer.FindByID(userId);
                if (targetPlayer != null)
                {
                    targetPlayer.Kick(message);
                }

                NotifyPlayerBan(userId, playerName, reason);
            }
        }

        [ChatCommand("unban")]
        void cmdUnban(BasePlayer player, string command, string[] args)
        {
            if (player.net.connection.authLevel == 0 && !permission.UserHasPermission(player.userID.ToString(), "SSNBans.unban"))
            {
                return;
            }

            if (args.Length != 1)
            {
                player.ChatMessage(m_configData.Messages["invalid_arguments"]);
                return;
            }

            ulong userID = UserIdByAlias(player.userID, args[0]);
            if (userID == 0)
            {
                player.ChatMessage(m_configData.Messages["player_not_found"]);
                return;
            }

            string playerName = PlayerName(userID);

            if (m_configData.BannedPlayers.ContainsKey(userID))
            {
                ConsoleSystem.Run.Server.Quiet(string.Format("unban {0}", userID.ToString()).ToString(), true);
                ConsoleSystem.Run.Server.Quiet("server.writecfg", true);

                m_configData.BannedPlayers.Remove(userID);
                SaveConfig();

                string message = m_configData.Messages["player_was_unbanned"];
                message = message.Replace("%player_name", playerName);
                message = message.Replace("%player_steamid", userID.ToString());
                ConsoleSystem.Broadcast("chat.add", 0, message, 1.0);
            }
            else
            {
                string message = m_configData.Messages["player_was_not_banned"];
                message = message.Replace("%player_name", playerName);
                message = message.Replace("%player_steamid", userID.ToString());
                player.ChatMessage(message);
            }
        }

        [ChatCommand("bans")]
        void cmdChatBans(BasePlayer player, string command, string[] args)
        {
            if (args.Length > 1)
            {
                player.ChatMessage(m_configData.Messages["invalid_arguments"]);
                return;
            }

            List<ulong> contextPlayers = new List<ulong>();
            foreach (ulong userID in m_configData.BannedPlayers.Keys)
            {
                string playerName = PlayerName(userID);
                if (args.Length == 1 && !playerName.Contains(args[0], System.Globalization.CompareOptions.IgnoreCase))
                {
                    continue;
                }

                BanItem banItem = m_configData.BannedPlayers[userID];
                contextPlayers.Add(userID);

                string message = m_configData.Messages["player_was_banned"];
                message = message.Replace("%player_name", playerName);
                message = message.Replace("%player_steamid", userID.ToString());
                message = message.Replace("%reason", banItem.reason);

                player.ChatMessage(contextPlayers.Count.ToString() + ") " + banItem.timestamp + " " + message);
            }
            SetContextPlayers(player.userID, contextPlayers);
        }

        [ChatCommand("mute")]
        void cmdChatMute(BasePlayer player, string command, string[] args)
        {
            string message;
            if (player.net.connection.authLevel == 0 && !permission.UserHasPermission(player.userID.ToString(), "SSNMutes.mute"))
            {
                return;
            }

            if (args.Length < 2)
            {
                player.ChatMessage(m_configData.Messages["invalid_arguments"]);
                return;
            }

            ulong userID = UserIdByAlias(player.userID, args[0]);
            if (userID == 0)
            {
                player.ChatMessage(m_configData.Messages["player_not_found"]);
                return;
            }

            string playerName = PlayerName(userID);

            string reason = "";
            for (int i = 1; i < args.Length; ++i)
            {
                reason += args[i];
                if (i < args.Length - 1)
                {
                    reason += " ";
                }
            }

            MuteItem muteItem;
            if (m_configData.MutedPlayers.ContainsKey(userID))
            {
                muteItem = m_configData.MutedPlayers[userID];
                if (muteItem.untilDatetime() > DateTime.Now)
                {
                    message = m_configData.Messages["player_is_muted_already"];
                    message = message.Replace("%player_name", playerName);
                    message = message.Replace("%player_steamid", userID.ToString());
                    message = message.Replace("%reason", muteItem.reason);
                    message = message.Replace("%until_datetime", muteItem.untilDatetime().ToString("yyyy-MM-dd HH:mm:ss"));
                    message = message.Replace("%level", m_configData.Messages[muteItem.level.ToString()]);

                    player.ChatMessage(message);
                    return;
                }

                int intLevel = (int)muteItem.level + 1;
                if (intLevel > (int)TimeRange.Year)
                {
                    intLevel = (int)TimeRange.Year;
                }
                muteItem.level = (TimeRange)intLevel;
            }
            else
            {
                muteItem = new MuteItem();
            }

            muteItem.reason = reason;
            muteItem.timestamp = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss");
            m_configData.MutedPlayers[userID] = muteItem;
            SaveConfig();

            message = m_configData.Messages["player_was_muted"];
            message = message.Replace("%player_name", playerName);
            message = message.Replace("%player_steamid", userID.ToString());
            message = message.Replace("%reason", muteItem.reason);
            message = message.Replace("%until_datetime", muteItem.untilDatetime().ToString("yyyy-MM-dd HH:mm:ss"));
            message = message.Replace("%level", m_configData.Messages[muteItem.level.ToString()]);

            ConsoleSystem.Broadcast("chat.add", 0, message, 1.0);
            
            NotifyPlayerMute(userID, playerName, reason);
        }

        [ChatCommand("unmute")]
        void cmdChatUnnute(BasePlayer player, string command, string[] args)
        {
            if (player.net.connection.authLevel == 0 && !permission.UserHasPermission(player.userID.ToString(), "SSNMutes.unmute"))
            {
                return;
            }

            if (args.Length != 1)
            {
                player.ChatMessage(m_configData.Messages["invalid_arguments"]);
                return;
            }

            ulong userID = UserIdByAlias(player.userID, args[0]);
            if (userID == 0)
            {
                player.ChatMessage(m_configData.Messages["player_not_found"]);
                return;
            }

            string playerName = PlayerName(userID);

            if (m_configData.MutedPlayers.ContainsKey(userID))
            {
                MuteItem muteItem = m_configData.MutedPlayers[userID];
                if (muteItem.level == TimeRange.Hour)
                {
                    m_configData.MutedPlayers.Remove(userID);
                }
                else
                {
                    muteItem.level = (TimeRange)((int)muteItem.level - 1);
                }
                SaveConfig();

                string message = m_configData.Messages["player_was_unmuted"];
                message = message.Replace("%player_name", playerName);
                message = message.Replace("%player_steamid", userID.ToString());

                ConsoleSystem.Broadcast("chat.add", 0, message, 1.0);
            }
            else
            {
                string message = m_configData.Messages["player_was_not_muted"];
                message = message.Replace("%player_name", playerName);
                message = message.Replace("%player_steamid", userID.ToString());

                player.ChatMessage(message);
            }
        }

        [ChatCommand("mutes")]
        void cmdChatMutes(BasePlayer player, string command, string[] args)
        {
            if (args.Length > 1)
            {
                player.ChatMessage(m_configData.Messages["invalid_arguments"]);
                return;
            }

            List<ulong> contextPlayers = new List<ulong>();
            foreach (ulong userID in m_configData.MutedPlayers.Keys)
            {
                string playerName = PlayerName(userID);
                if (args.Length == 1 && !playerName.Contains(args[0], System.Globalization.CompareOptions.IgnoreCase))
                {
                    continue;
                }

                MuteItem muteItem = m_configData.MutedPlayers[userID];
                contextPlayers.Add(userID);

                string message = m_configData.Messages["player_was_muted"];
                message = message.Replace("%player_name", playerName);
                message = message.Replace("%player_steamid", userID.ToString());
                message = message.Replace("%reason", muteItem.reason);
                message = message.Replace("%until_datetime", muteItem.untilDatetime().ToString("yyyy-MM-dd HH:mm:ss"));
                message = message.Replace("%level", m_configData.Messages[muteItem.level.ToString()]);

                player.ChatMessage(contextPlayers.Count.ToString() + ") " + muteItem.timestamp + " " + message);
            }
            SetContextPlayers(player.userID, contextPlayers);
        }

        //

        private ulong UserIdByAlias(ulong contextId, string alias)
        {
            if (alias.Length == 17)
            {
                ulong userId;
                if (ulong.TryParse(alias, out userId))
                {
                    return userId;
                }
            }
            int index;
            if (int.TryParse(alias, out index))
            {
                if (m_contextPlayers.ContainsKey(contextId) && (index - 1) < m_contextPlayers[contextId].Count)
                {
                    return m_contextPlayers[contextId][index - 1];
                }
            }
            return 0;
        }

        private void SetContextPlayers(ulong context, List<ulong> players)
        {
            m_contextPlayers[context] = players;
        }

        private string PlayerName(ulong userID)
        {
            if (m_playersNames.ContainsKey(userID))
            {
                return m_playersNames[userID];
            }
            else
            {
                return "unknown";
            }
        }

        // Web request/response

        private void SendWebRequest(string subUrl, List<string> values)
        {
            string requestUrl = "http://%host:%port/%suburl".Replace("%host", m_host).Replace("%port", m_port).Replace("%suburl", subUrl);

            Dictionary<string, string> headers = new Dictionary<string, string>();
            headers.Add("server_name", m_configData.server_name);

            string body = "";
            foreach (string line in values)
            {
                body += line;
                body += "\n";
            }

            byte[] data = MD5.Create().ComputeHash(Encoding.UTF8.GetBytes(body + m_configData.server_password));
            StringBuilder sBuilder = new StringBuilder();
            for (int i = 0; i < data.Length; i++)
            {
                sBuilder.Append(data[i].ToString("x2"));
            }

            headers.Add("salt", sBuilder.ToString());
            m_webRequests.EnqueuePost(requestUrl, body, (code, response) => ReceiveWebResponse(code, response), this, headers);
        }

        private void ReceiveWebResponse(int code, string response)
        {
            if (response == null)
            {
                if (m_configData.print_errors)
                {
                    Puts("Couldn't get an answer from SSN service.");
                }
            }
            else if (code != 200)
            {
                if (m_configData.print_errors)
                {
                    Puts("SSN error (%code): %text".Replace("%code", code.ToString()).Replace("%text", response));
                }
            }
        }

        // Notifiers

        private void NotifyMurder(ulong victimSteamId, string victimDisplayName, ulong killerSteamId, string killerDisplayName, int weaponRustItemId, double distance, bool isHeadshot, bool isSleeping)
        {
            List<string> values = new List<string>();
            values.Add(victimSteamId.ToString());
            values.Add(victimDisplayName);
            values.Add(killerSteamId.ToString());
            values.Add(killerDisplayName);
            values.Add(weaponRustItemId.ToString());
            values.Add(ItemManager.CreateByItemID(weaponRustItemId).info.displayName.english);
            values.Add(distance.ToString());
            values.Add(isHeadshot ? "true" : "false");
            values.Add(isSleeping ? "true" : "false");

            SendWebRequest("murder/create", values);
        }

        private void NotifyPlayerConnected(ulong steamid, string displayName, string ipAddress)
        {
            List<string> values = new List<string>();
            values.Add(steamid.ToString());
            values.Add(displayName);
            values.Add(ipAddress);

            SendWebRequest("player/connect", values);
        }

        private void NotifyPlayerDisconnected(ulong steamid, string displayName)
        {
            List<string> values = new List<string>();
            values.Add(steamid.ToString());
            values.Add(displayName);
            SendWebRequest("player/disconnect", values);
        }

        private void NotifyPlayerChatMessage(ulong steamid, string displayName, string messageText)
        {
            List<string> values = new List<string>();
            values.Add(steamid.ToString());
            values.Add(displayName);
            values.Add(messageText);

            SendWebRequest("player/chat_message", values);
        }

        private void NotifyPlayerBan(ulong steamid, string displayName, string reason)
        {
            List<string> values = new List<string>();
            values.Add(steamid.ToString());
            values.Add(displayName);
            values.Add(reason);
            SendWebRequest("player/ban", values);
        }

        private void NotifyPlayerMute(ulong steamid, string displayName, string reason)
        {
            List<string> values = new List<string>();
            values.Add(steamid.ToString());
            values.Add(displayName);
            values.Add(reason);
            SendWebRequest("player/mute", values);
        }

        private void NotifyServerOn()
        {
            List<string> values = new List<string>();
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                values.Add(player.userID.ToString());
            }
            SendWebRequest("server/on", values);
        }

        private void NotifyServerOff()
        {
            SendWebRequest("server/off", new List<string>());
        }
    }
}


// --- End of file: SSNNotifier.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TimedEvents.cs ---
// --- Original Local Path: TimedEvents.cs ---

using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Timed Events", "Orange", "1.1.5")]
    [Description("Triggers various types of events like Airdrops, Helicopters and same")]
    public class TimedEvents : RustPlugin
    {
        #region Vars

        private const string prefabCH47 = "assets/prefabs/npc/ch47/ch47scientists.entity.prefab";
        private const string prefabPlane = "assets/prefabs/npc/cargo plane/cargo_plane.prefab";
        private const string prefabShip = "assets/content/vehicles/boats/cargoship/cargoshiptest.prefab";
        private const string prefabPatrol = "assets/prefabs/npc/patrol helicopter/patrolhelicopter.prefab";

        #endregion
        
        #region Oxide Hooks

        private void OnServerInitialized()
        {
            SpawnTank(true);
            SpawnShip(true);
            SpawnPatrol(true);
            SpawnPlane(true);
            SpawnCH47(true);
        }
        
        private object OnEventTrigger(TriggeredEventPrefab info)
        {
            var prefabs = UnityEngine.Object.FindObjectsOfType<TriggeredEventPrefab>();
            foreach (var obj in prefabs)
            {
                var name = obj.targetPrefab.resourcePath;
                if (name.Contains("patrol") && config.patrol.disableDefault == true)
                {
                    return true;
                }

                if (name.Contains("ship") && config.ship.disableDefault == true)
                {
                    return true;
                }

                if (name.Contains("plane") && config.plane.disableDefault == true)
                {
                    return true;
                }

                if (name.Contains("ch47") && config.ch47.disableDefault == true)
                {
                    return true;
                }
            }

            return null;
        }
        #endregion

        #region Core

        private void SpawnTank(bool skipSpawn = false)
        {
            if (Online() >= config.tank.playersMin && skipSpawn == false)
            {
                BradleySpawner.singleton?.SpawnBradley();
            }

            var time = Core.Random.Range(config.tank.timerMin, config.tank.timerMax);
            timer.Once(time, () => SpawnTank());
        }

        private void SpawnShip(bool skipSpawn = false)
        {
            if (Online() >= config.ship.playersMin && skipSpawn == false)
            {
                var amount = Core.Random.Range(config.ship.spawnMin, config.ship.spawnMax);

                for (var i = 0; i < amount; i++)
                {
                    var x = TerrainMeta.Size.x;
                    var vector3 = Vector3Ex.Range(-1f, 1f);
                    vector3.y = 0.0f;
                    vector3.Normalize();
                    var worldPos = vector3 * (x * 1f);
                    worldPos.y = TerrainMeta.WaterMap.GetHeight(worldPos);
                    var entity = GameManager.server.CreateEntity(prefabShip, worldPos);
                    entity?.Spawn();
                }
            }

            var time = Core.Random.Range(config.ship.timerMin, config.ship.timerMax);
            timer.Once(time, () => SpawnShip());
        }

        private void SpawnPatrol(bool skipSpawn = false)
        {
            if (Online() >= config.patrol.playersMin && skipSpawn == false)
            {
                var amount = Core.Random.Range(config.patrol.spawnMin, config.patrol.spawnMax);
            
                for (var i = 0; i < amount; i++)
                {
                    var position = new Vector3(ConVar.Server.worldsize, 100, ConVar.Server.worldsize) - new Vector3(50f, 0f, 50f);
                    var entity = GameManager.server.CreateEntity(prefabPatrol, position);
                    entity?.Spawn();
                }
            }
            
            var time = Core.Random.Range(config.patrol.timerMin, config.patrol.timerMax);
            timer.Once(time, () => SpawnPatrol());
        }

        private void SpawnPlane(bool skipSpawn = false)
        {
            if (Online() >= config.plane.playersMin && skipSpawn == false)
            {
                var amount = Core.Random.Range(config.plane.spawnMin, config.plane.spawnMax);
            
                for (var i = 0; i < amount; i++)
                {
                    var position = new Vector3(ConVar.Server.worldsize, 100, ConVar.Server.worldsize) - new Vector3(50f, 0f, 50f);
                    var entity = GameManager.server.CreateEntity(prefabPlane, position);
                    entity?.Spawn();
                }
            }
            
            var time = Core.Random.Range(config.plane.timerMin, config.plane.timerMax);
            timer.Once(time, () => SpawnPlane());
        }
        
        private void SpawnCH47(bool skipSpawn = false)
        {
            if (Online() >= config.ch47.playersMin && skipSpawn == false)
            {
                var amount = Core.Random.Range(config.ch47.spawnMin, config.ch47.spawnMax);
            
                for (var i = 0; i < amount; i++)
                {
                    var position = new Vector3(ConVar.Server.worldsize, 100, ConVar.Server.worldsize) - new Vector3(50f, 0f, 50f);
                    var entity = GameManager.server.CreateEntity(prefabCH47, position) as CH47HelicopterAIController;
                    entity?.TriggeredEventSpawn();
                    entity?.Spawn();
                }
            }
            
            var time = Core.Random.Range(config.ch47.timerMin, config.ch47.timerMax);
            timer.Once(time, () => SpawnCH47());
        }

        private int Online()
        {
            return BasePlayer.activePlayerList.Count;
        }

        #endregion

        #region Configuration

        private static ConfigData config;
        
        private class ConfigData
        {    
            [JsonProperty(PropertyName = "1. Cargo plane settings:")]
            public EventSettings plane;
            
            [JsonProperty(PropertyName = "2. Patrol Helicopter settings:")]
            public EventSettings patrol;
            
            [JsonProperty(PropertyName = "3. Bradley APC settings:")]
            public EventSettings tank;
            
            [JsonProperty(PropertyName = "4. CH47 settings:")]
            public EventSettings ch47;
            
            [JsonProperty(PropertyName = "5. Cargo ship settings:")]
            public EventSettings ship;
        }
        
        private class EventSettings
        {
            [JsonProperty(PropertyName = "1. Disable default spawns")]
            public bool disableDefault;
                
            [JsonProperty(PropertyName = "2. Minimal respawn time (in seconds)")]
            public int timerMin;
                
            [JsonProperty(PropertyName = "3. Maximal respawn time (in seconds)")]
            public int timerMax;
                
            [JsonProperty(PropertyName = "4. Minimal amount that spawned by once")]
            public int spawnMin;
                
            [JsonProperty(PropertyName = "5. Maximal amount that spawned by once")]
            public int spawnMax;
                
            [JsonProperty(PropertyName = "6. Minimal players to start event")]
            public int playersMin;
        }
        
        private ConfigData GetDefaultConfig()
        {
            return new ConfigData
            {
                plane = new EventSettings
                {
                    disableDefault = false,
                    playersMin = 0,
                    timerMax = 7200,
                    timerMin = 3600,
                    spawnMax = 1,
                    spawnMin = 1
                },
                patrol = new EventSettings
                {
                    disableDefault = false,
                    playersMin = 0,
                    timerMax = 7200,
                    timerMin = 3600,
                    spawnMax = 1,
                    spawnMin = 1
                },
                tank = new EventSettings
                {
                    disableDefault = false,
                    playersMin = 0,
                    timerMax = 7200,
                    timerMin = 3600,
                    spawnMax = 1,
                    spawnMin = 1
                },
                ch47 = new EventSettings
                {
                    disableDefault = false,
                    playersMin = 0,
                    timerMax = 7200,
                    timerMin = 3600,
                    spawnMax = 1,
                    spawnMin = 1
                },
                ship = new EventSettings
                {
                    disableDefault = false,
                    playersMin = 0,
                    timerMax = 7200,
                    timerMin = 3600,
                    spawnMax = 1,
                    spawnMin = 1
                }
            };
        }
        
        protected override void LoadConfig()
        {
            base.LoadConfig();
   
            try
            {
                config = Config.ReadObject<ConfigData>();
            }
            catch
            {
                LoadDefaultConfig();
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintError("Configuration file is corrupt(or not exists), creating new one!");
            config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion
    }
}

// --- End of file: TimedEvents.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/IQWipeBlock.cs ---
// --- Original Local Path: IQWipeBlock.cs ---

using System.Linq;
using Oxide.Game.Rust.Cui;
using ConVar;
using Oxide.Core;
using UnityEngine;
using System.Text;
using Object = System.Object;
using System.Collections.Generic;
using System;
using Oxide.Core.Plugins;
using Newtonsoft.Json;
using Network;

namespace Oxide.Plugins
{
    [Info("IQWipeBlock", "Mercury", "1.11.10")]
    [Description("Блокируй по умному с IQWipeBlock")]
    class IQWipeBlock : RustPlugin
    {
        
                private String GetImage(String fileName, UInt64 skin = 0)
        {
            var imageId = (String)plugins.Find("ImageLibrary").CallHook("GetImage", fileName, skin);
            if (!string.IsNullOrEmpty(imageId))
                return imageId;
            return String.Empty;
        }
        static Double CurrentTime => Facepunch.Math.Epoch.Current;
		   		 		  						  	   		  	  			  			 		  						  		  
        
                private static string HexToRustFormat(String hex)
        {
            UnityEngine.Color color;
            ColorUtility.TryParseHtmlString(hex, out color);
            return String.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
        }

        private bool? CanEquipItem(PlayerInventory inventory, Item item) => CanWearItem(inventory, item);
        Boolean Interface_UI_Block(BasePlayer player, String Shortname, String ShortnameModule = "", UInt64 SkinID = 0, List<Connection> playerList = null, Boolean IsCheckConnect = false)
        {
            if (Shortname == null || String.IsNullOrWhiteSpace(Shortname)) return true;
            Shortname = ShortnameValidation(Shortname);
             
            if (playerList == null)
            {
                if (player != null)
                {
                    CuiHelper.DestroyUi(player, "ALERT_UI_BLOCK");
                    if (permission.UserHasPermission(player.UserIDString, PermissionIgnoreBlock)) return true;
                }
            }
            else CommunityEntity.ServerInstance.ClientRPCEx(new SendInfo(playerList), null, "DestroyUI", "ALERT_UI_BLOCK");
            String LangID = player == null ? null : player.UserIDString;
            Single FadeIn = 0f;
            Single FadeOut = 0f;
            var Interface = config.Interface;
            var Block = config.Block;
            Dictionary<String, Configuration.Blocks.BlockElement> BlockAll = (Dictionary<String, Configuration.Blocks.BlockElement>)Block.BlockArmory.Concat(Block.BlockWeaponAndTools).Concat(Block.BlockBoom).ToDictionary(x => x.Key, x => x.Value);
            if (!BlockAll.ContainsKey(Shortname)) return true;
            if (!String.IsNullOrWhiteSpace(ShortnameModule) && !BlockAll[Shortname].BlockMoreList.ContainsKey(ShortnameModule)) return true;

            String ColorBackground = Block_Skin_Controller(BlockAll[Shortname], BlockAll, TimeUnblock(BlockAll[Shortname].TimeBlock) > 0, SkinID) 
                                   ? Interface.BlockedPanel : BlockAll[Shortname].BlockMoreList.Count > 0 && !String.IsNullOrWhiteSpace(ShortnameModule) && TimeUnblock(Block.VaribleUnlockMore 
                                   ? BlockAll[Shortname].TimeBlock + BlockAll[Shortname].BlockMoreList[ShortnameModule] : BlockAll[Shortname].BlockMoreList[ShortnameModule]) > 0 
                                   ? Interface.UnblockedMorePanel : "";
		   		 		  						  	   		  	  			  			 		  						  		  
            String LineColor = Block_Skin_Controller(BlockAll[Shortname], BlockAll, TimeUnblock(BlockAll[Shortname].TimeBlock) > 0, SkinID) ? Interface.Lines : BlockAll[Shortname].BlockMoreList.Count > 0 && !String.IsNullOrWhiteSpace(ShortnameModule) && TimeUnblock(Block.VaribleUnlockMore ? BlockAll[Shortname].TimeBlock + BlockAll[Shortname].BlockMoreList[ShortnameModule] : BlockAll[Shortname].BlockMoreList[ShortnameModule]) > 0 ? Interface.PreBlockedMoreLine : "";
            String LangVaribles = Block_Skin_Controller(BlockAll[Shortname], BlockAll, TimeUnblock(BlockAll[Shortname].TimeBlock) > 0, SkinID) ? GetLang("UI_BLOCK_DESCRIPTION_TWO", LangID, FormatTime(TimeSpan.FromSeconds(TimeUnblock(BlockAll[Shortname].TimeBlock)), LangID ?? "0")) : BlockAll[Shortname].BlockMoreList.Count > 0 && !String.IsNullOrWhiteSpace(ShortnameModule) && TimeUnblock(Block.VaribleUnlockMore ? BlockAll[Shortname].TimeBlock + BlockAll[Shortname].BlockMoreList[ShortnameModule] : BlockAll[Shortname].BlockMoreList[ShortnameModule]) > 0 && !String.IsNullOrEmpty(ShortnameModule) ? GetLang("UI_BLOCK_DESCRIPTION_ONE", LangID, FormatTime(TimeSpan.FromSeconds(TimeUnblock(BlockAll[Shortname].BlockMoreList[ShortnameModule])), LangID ?? "0")) : "";
            if (String.IsNullOrWhiteSpace(ColorBackground) || String.IsNullOrWhiteSpace(LineColor) || String.IsNullOrWhiteSpace(LangVaribles)) return true;

            if (!IsCheckConnect)
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    FadeOut = FadeOut,
                    Parent = "Overlay",
                    Name = "ALERT_UI_BLOCK",
                    Components =
                    {
                        new CuiImageComponent
                        {
                            FadeIn = FadeIn, Color = HexToRustFormat(ColorBackground),
                            Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat"
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-199 -265",
                            OffsetMax = "180 -225"
                        },
                        new CuiOutlineComponent
                            { Color = HexToRustFormat(LineColor), Distance = "-1.32 1.32", UseGraphicAlpha = true }
                    }
                });

                container.Add(new CuiLabel
                {
                    FadeOut = FadeOut,
                    RectTransform = { AnchorMin = "0.1125769 0.4749999", AnchorMax = "1 0.9833333" },
                    Text =
                    {
                        FadeIn = FadeIn, Text = GetLang("UI_BLOCK_TITLE", LangID), FontSize = 18,
                        Color = HexToRustFormat(Interface.Labels), Font = "robotocondensed-bold.ttf",
                        Align = TextAnchor.MiddleCenter
                    }
                }, "ALERT_UI_BLOCK", "ALERT_UI_BLOCK_TITLE_ONE");

                container.Add(new CuiLabel
                {
                    FadeOut = FadeOut,
                    RectTransform = { AnchorMin = "0.1125769 0.041450043", AnchorMax = "1 0.5445009" },
                    Text =
                    {
                        FadeIn = FadeIn, Text = LangVaribles, FontSize = 12, Color = HexToRustFormat(Interface.Labels),
                        Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter
                    }
                }, "ALERT_UI_BLOCK", "ALERT_UI_BLOCK_TITLE_TWO");
		   		 		  						  	   		  	  			  			 		  						  		  
                container.Add(new CuiElement
                {
                    FadeOut = FadeOut + 0.2f,
                    Parent = "ALERT_UI_BLOCK",
                    Name = "ALERT_UI_BLOCK_SPRITE",
                    Components =
                    {
                        new CuiImageComponent
                        {
                            FadeIn = FadeIn - 0.8f, Sprite = "assets/icons/connection.png",
                            Color = HexToRustFormat(Interface.Labels)
                        },
                        new CuiRectTransformComponent
                            { AnchorMin = "0 1", AnchorMax = $"0 1", OffsetMin = "-20 -48", OffsetMax = "40 10" },
                    }
                });

                if (playerList == null)
                {
                    if (player != null)
                        CuiHelper.AddUi(player, container);

                    timer.Once(3f, () =>
                    {
                        if (player != null)
                        {
                            CuiHelper.DestroyUi(player, "ALERT_UI_BLOCK");
                            CuiHelper.DestroyUi(player, "ALERT_UI_BLOCK_TITLE_ONE");
                            CuiHelper.DestroyUi(player, "ALERT_UI_BLOCK_TITLE_TWO");
                            CuiHelper.DestroyUi(player, "ALERT_UI_BLOCK_SPRITE");
                        }
                    });
                }
                else
                {
                    CommunityEntity.ServerInstance.ClientRPCEx(new SendInfo(playerList), null, "AddUI",
                        container.ToJson());
                    timer.Once(3f, () =>
                    {
                        CommunityEntity.ServerInstance.ClientRPCEx(new SendInfo(playerList), null, "DestroyUI",
                            "ALERT_UI_BLOCK");
                        CommunityEntity.ServerInstance.ClientRPCEx(new SendInfo(playerList), null, "DestroyUI",
                            "ALERT_UI_BLOCK_TITLE_ONE");
                        CommunityEntity.ServerInstance.ClientRPCEx(new SendInfo(playerList), null, "DestroyUI",
                            "ALERT_UI_BLOCK_TITLE_TWO");
                        CommunityEntity.ServerInstance.ClientRPCEx(new SendInfo(playerList), null, "DestroyUI",
                            "ALERT_UI_BLOCK_SPRITE");
                    });
                }
            }
		   		 		  						  	   		  	  			  			 		  						  		  
            return false;
        }
        public enum TypeLock
        {
            Locked,
            Fire,
            Flash
        }
        
        object CanMountEntity(BasePlayer player, MLRS entity)
        {
            if (player == null || entity == null) return null;
            
            if (Interface_UI_Block(player, "ammo.rocket.mlrs"))
                return null;
            else return false;
        }

        object OnLootNetworkUpdate(PlayerLoot loot)
        {
            if (loot == null)
                return null;
            BasePlayer player = loot.GetComponent<BasePlayer>();
            if (player == null)
                return null;
            if (loot.entitySource == null || loot.entitySource.net == null)
                return null;
            UInt64 NetID = loot.entitySource.net.ID.Value;
            NetworkIDGetSet(NetID, true, player);
            return null;
        }
        public void SendImage(BasePlayer player, String imageName, UInt64 imageId = 0) => ImageLibrary?.Call("SendImage", player, imageName, imageId);
        void WriteData()
        {
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQWipeBlock/HideStatus", BlockHideInfo);
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQWipeBlock/SkipTimeBlocked", SkipTimeBlocked);
        }

        void OnPlayerLootEnd(PlayerLoot inventory)
        {
            if (inventory.entitySource == null || inventory.entitySource.net == null)
                return;
            BasePlayer player = inventory.GetComponent<BasePlayer>();
            if (player == null)
                return;

            UInt64 NetID = inventory.entitySource.net.ID.Value;
            NetworkIDGetSet(NetID, false, player);
        }
        
        private void ValidsItemTurret(AutoTurret Turret, Item item, Boolean AddedOrRemove)
        {
            if (!AddedOrRemove) return;
            if (item.parent == null)
                return;
            if(item.parent.uid.Value == 384258468)
                return;
            
            BasePlayer player = BasePlayer.FindByID(Turret.OwnerID);
            
            if (Interface_UI_Block(player, item.info.shortname, "", item.skin))
            {
                if (Turret.inventory.itemList.Count == 0 || Turret.inventory.itemList[0] == null) return;
                if (Interface_UI_Block(player, Turret.inventory.itemList[0].info.shortname, item.info.shortname))
                    return;
            }

            if (player != null)
            {
                if (item.MoveToContainer(player.inventory.containerMain)) 
                    return;
            }

            item.Drop(Turret.transform.position + new Vector3(0f, 1f, 0f), Turret.GetDropVelocity());
        }
        
                [ConsoleCommand("skip.wb")]
        void ConsoleSkipWipeBlock(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player != null && !player.IsAdmin) return;
            if (!arg.HasArgs(1)) return;

            Int32 SkipTime = 0;
            if(!Int32.TryParse(arg.Args[0], out SkipTime))
            {
                PrintWarning(LanguageEn ? "Syntax error! Syntax : skip.wb Time" :  "Ошибка синтаксиса! Синтаксис : skip.wb Time");
                return;
            }
            if(SkipTime < 0)  
            {
                PrintWarning(LanguageEn ? "The time cannot be lower than 0!" : "Время не может быть ниже 0!");
                return;
            }
            SkipTimeBlocked = SkipTime;
            PrintWarning(LanguageEn ? $"You have successfully set the time {SkipTime}" : $"Вы успешно установили время {SkipTime}");
        }

                [PluginReference] Plugin IQChat, ImageLibrary, Battles, Duel, Duelist, ArenaTournament, AimTraining, XFarmRoom, OneVSOne, EventHelper, IQBackpack, IQRecycler; // https://umod.org/plugins/duelist

        void HideButtonIsMenu(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, IQWIPE_PARENT + "HIDE_BTN");
            CuiElementContainer container = new CuiElementContainer();
            Single FadeIn = 0.2f;
            var Interface = config.Interface;
            String LangKey = BlockHideInfo[player.userID] ? GetLang("UI_PANEL_BUTTON_HIDE_ISMENU_ON", player.UserIDString) : GetLang("UI_PANEL_BUTTON_HIDE_ISMENU_OFF", player.UserIDString);

            container.Add(new CuiButton 
            {
                RectTransform = { AnchorMin = "0.1557295 0.9037", AnchorMax = "0.8375002 0.9351" }, 
                Button = { Command = "iqwb hide.panel.btn true", Color = "0 0 0 0" },
                Text = { FadeIn = FadeIn, Text = LangKey, Color = HexToRustFormat(Interface.Labels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            }, IQWIPE_PARENT, IQWIPE_PARENT + "HIDE_BTN");

            CuiHelper.AddUi(player, container);
        }

        void HideOrUnHigePanel(BasePlayer player, Boolean IsMenu)
        {
            if (BlockHideInfo[player.userID])
            {
                BlockHideInfo[player.userID] = false;
                if (IsMenu)
                    HideButtonIsMenu(player);
                Interface_Button_Panel(player);
            }
            else
            {
                BlockHideInfo[player.userID] = true;
                if (IsMenu)
                    HideButtonIsMenu(player);
                CuiHelper.DestroyUi(player, IQWIPE_PARENT_PANEL_BTN);
            }
        }

        
        
        [JsonProperty(LanguageEn ? "" :"Сдвиг времени в секундах")]
        public Int32 SkipTimeBlocked = 0;
        
       
        // private void OnPluginLoaded(Plugin plugin)
        // {
        //     if (plugin == null)
        //         return;
        //     
        //     NextTick(TogglePickUpHook);
        // }
        //
        // private void TogglePickUpHook()
        // {
        //     Unsubscribe(nameof(CanAcceptItem));
        //     Subscribe(nameof(OnItemAddedToContainer));
        // }

        void OnItemAddedToContainer(ItemContainer container, Item item)
        {
            if (container == null || item == null) return;
            
            BasePlayer player = container.playerOwner;

            if (player == null || !player.userID.IsSteamId() || player.IsNpc)
                return;
            
            if (IsDuel(player.userID))
                return;
            
            if (IQBackpack && (Boolean)IQBackpack.CallHook("IsSaveItemBackpack", player, item))
                return;

            Boolean Status = !Interface_UI_Block(player, item.info.shortname, "", item.skin);
            
            if (IQRecycler && IQRecycler.Call<Boolean>("IsBlackList", player.userID, item) && item.HasFlag(global::Item.Flag.IsLocked) && !Status)
                return;
            
            if (Status)
            {
                if (container == player.inventory.containerWear)
                {
                    if (player.inventory.containerMain.itemList.Count >= 24)
                        item.DropAndTossUpwards(player.transform.position);
                    else item.MoveToContainer(player.inventory.containerMain);
                }
                else if (container == player.inventory.containerBelt)
                {
                    if (player.inventory.containerMain.itemList.Count > 24)
                        item.DropAndTossUpwards(player.transform.position);
                    else item.MoveToContainer(player.inventory.containerMain);
                }
                else
                {
                    if (player.inventory.containerMain.itemList.Count > 24)
                        item.DropAndTossUpwards(player.transform.position);
                }
            }
		   		 		  						  	   		  	  			  			 		  						  		  
            SetFlagItem(item, Status);
        }

        
                

        
        public Double TimeUnblock(Int32 BlockTime) => (SaveRestore.SaveCreatedTime.ToUniversalTime().Subtract(epoch).TotalSeconds + BlockTime) - (CurrentTime + SkipTimeBlocked);

        private Vector3 GetDropVelocity(StorageContainer container)
        {
            return container switch
            {
                AttackHelicopterTurret turret => turret.GetDropVelocity(),
                AttackHelicopterRockets rockets => rockets.GetDropVelocity(),
                _ => new Vector3(0f, 0f, 0f)
            };
        }
        void Unload()
        {
            WriteData();
            ServerMgr.Instance.CancelInvoke(CheckAllUnlock);

            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, IQWIPE_PARENT);
                CuiHelper.DestroyUi(player, IQWIPE_PARENT_PANEL_BTN);
            }
        }
        public Boolean HasImage(String imageName) => (Boolean)ImageLibrary?.Call("HasImage", imageName);
        
        private void ValidsItemAttackHelicopter(StorageContainer container, Item item, Boolean AddedOrRemove)
        {
            if (!AddedOrRemove || item.parent == null || item.parent.uid.Value == 384258468)
                return;

            BasePlayer player = BasePlayer.FindByID(container.OwnerID);

            if (Interface_UI_Block(player, item.info.shortname, "", item.skin))
            {
                if (container.inventory.itemList.Count == 0 || container.inventory.itemList[0] == null)
                    return;
                if (Interface_UI_Block(player, container.inventory.itemList[0].info.shortname, item.info.shortname))
                    return;
            }

            if (player != null && item.MoveToContainer(player.inventory.containerMain)) 
                return;
            
            item.Drop(container.transform.position + new Vector3(0f, 1f, 0f), GetDropVelocity(container));
        }

        
        
        void UI_Category_More_Popup(BasePlayer player, Configuration.Blocks.BlockElement BlockElement)
        {
            CuiHelper.DestroyUi(player, IQWIPE_PARENT + "POPUP");
            CuiElementContainer container = new CuiElementContainer();
            Single FadeIn = 0.2f;
            var Interface = config.Interface;
            var BlockMore = BlockElement.BlockMoreList;
            var Block = config.Block;

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Image = { FadeIn = FadeIn, Color = HexToRustFormat(Interface.BackgroundMoreBlurColor), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
            }, IQWIPE_PARENT, IQWIPE_PARENT + "POPUP");

            container.Add(new CuiButton
            {
                FadeOut = 0.2f,
                RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1" },
                Button = { Close = IQWIPE_PARENT + "POPUP", Color = "0 0 0 0" },
                Text = { Text = "" }
            }, IQWIPE_PARENT + "POPUP", IQWIPE_PARENT + "POPUP" + "BUTTON_CLOSE");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.3281249 0.6796", AnchorMax = "0.6927 0.7268518" },  ///
                Text = { FadeIn = FadeIn, Text = GetLang("TITLE_BLOCK_MORE", player.UserIDString), Color = HexToRustFormat(Interface.Labels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            }, IQWIPE_PARENT + "POPUP", IQWIPE_PARENT + "POPUP_TITLE");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.4036451 0.6824123", AnchorMax = "0.5916615 0.6829678" },
                Image = { FadeIn = FadeIn, Color = HexToRustFormat(Interface.Lines) }
            }, IQWIPE_PARENT + "POPUP", IQWIPE_PARENT + "POPUP_TITLE_LINE");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.2432292 0.06944448", AnchorMax = "0.7546 0.6583334" },  ///
                Image = { FadeIn = FadeIn, Color = "0 0 0 0" }
            }, IQWIPE_PARENT + "POPUP", IQWIPE_PARENT + "POPUP" + "ITEMS_PANEL");

                        Int32 ItemCount = 0;
            Single itemMinPosition = 219f;
            Single itemWidth = 0.1f; /// Ширина
            Single itemMargin = 0.062f; /// Расстояние между 
            Int32 itemCount = BlockMore.Count;
            Single itemMinHeight = 0.85f; // Сдвиг по вертикали
            Single itemHeight = 0.15f; /// Высота
            Int32 ItemTarget = 4;

            if (itemCount > ItemTarget)
            {
                itemMinPosition = 0.5f - ItemTarget / 2f * itemWidth - (ItemTarget - 1) / 2f * itemMargin;
                itemCount -= ItemTarget;
            }
            else itemMinPosition = 0.5f - itemCount / 2f * itemWidth - (itemCount - 1) / 2f * itemMargin;

            
            Int32 Count = 0;
            Int32 Items = BlockMore.Count;
            Boolean SkipElement = (Boolean)(BlockMore.Count(x => TimeUnblock(Block.VaribleUnlockMore ? x.Value + BlockElement.TimeBlock : x.Value) > 0) >= 1);

            foreach (var Item in BlockMore.OrderBy(i => i.Value).Take(28))
            {
                Int32 ItemValue = Block.VaribleUnlockMore ? Item.Value + BlockElement.TimeBlock : Item.Value;
                String ColorBackground = SkipElement && TimeUnblock(ItemValue) > 0 ? Interface.NextBlockedPanel : TimeUnblock(ItemValue) > 0 ? Interface.BlockedPanel : Interface.UnblockedPanel;
                String LineColor = TimeUnblock(ItemValue) > 0 ? Interface.Lines : Interface.LinesUnblock;

                container.Add(new CuiElement
                {
                    Parent = IQWIPE_PARENT + "POPUP" + "ITEMS_PANEL",
                    Name = IQWIPE_PARENT + $"PANEL_ITEM_{ItemCount}",
                    Components =
                    {
                        new CuiImageComponent { FadeIn = FadeIn, Color = HexToRustFormat(ColorBackground), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                        new CuiRectTransformComponent{ AnchorMin = $"{itemMinPosition} {itemMinHeight}", AnchorMax = $"{itemMinPosition + itemWidth} {itemMinHeight + itemHeight}", OffsetMax = "0 1", OffsetMin = "0 1" },
                        new CuiOutlineComponent { Color = HexToRustFormat(LineColor), Distance = "-1.35 1.35", UseGraphicAlpha = true }
                    }
                });

                if (SkipElement && TimeUnblock(ItemValue) > 0)
                {
                    if (Interface.UseProgressiveBackground)
                    {
                        Single ProgressiveX = (Single)((ItemValue - TimeUnblock(ItemValue)) / ItemValue * 1f) >= 1 ? 1 : (Single)((ItemValue - TimeUnblock(ItemValue)) / ItemValue * 1f);
                        container.Add(new CuiPanel
                        {
                            RectTransform = { AnchorMin = "0 0", AnchorMax = $"{ProgressiveX} 1", OffsetMin = "0 0", OffsetMax = "0 -0.03" },
                            Image = { FadeIn = FadeIn, Color = HexToRustFormat(Interface.UnblockedPanel), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
                        }, IQWIPE_PARENT + $"PANEL_ITEM_{ItemCount}");
                    }
                }

                // container.Add(new CuiElement
                // {
                //     Parent = IQWIPE_PARENT + $"PANEL_ITEM_{ItemCount}",
                //     Name = IQWIPE_PARENT + $"IMG_{ItemCount}",
                //     Components =
                //     {
                //         new CuiRawImageComponent { FadeIn = FadeIn, Png = GetImage($"{Item.Key}_128px") },
                //         new CuiRectTransformComponent{ AnchorMin = "0.03992017 0.04031476", AnchorMax = $"0.9481039 0.9574757"},
                //     }
                // });
                
                container.Add(new CuiElement
                {
                    Parent = IQWIPE_PARENT + $"PANEL_ITEM_{ItemCount}",
                    Name = IQWIPE_PARENT + $"IMG_{ItemCount}",
                    Components = {
                        new CuiImageComponent() {FadeIn = FadeIn, Color = "1 1 1 1", ItemId = ItemManager.FindItemDefinition(Item.Key).itemid },
                        new CuiRectTransformComponent{ AnchorMin = "0.03992017 0.04031476", AnchorMax = $"0.9481039 0.9574757"},
                    }
                });

                if (!config.GeneralSetting.UseShowAllTime)
                {
                    if (SkipElement && TimeUnblock(ItemValue) > 0)
                    {
                        String TimeLeft = FormatTime(TimeSpan.FromSeconds(TimeUnblock(ItemValue)), player.UserIDString);
                        container.Add(new CuiLabel
                        {
                            RectTransform = { AnchorMin = "0.06480032 0.7686631", AnchorMax = "0.9430439 0.980315" },
                            Text = { FadeIn = FadeIn, Text = TimeLeft, FontSize = 12, Color = HexToRustFormat(Interface.Labels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
                        }, IQWIPE_PARENT + $"PANEL_ITEM_{ItemCount}", IQWIPE_PARENT + "UNLOCK_TIME" + itemCount);
                    }
                }
                else
                {
                    if (TimeUnblock(ItemValue) > 0)
                    {
                        String TimeLeft = FormatTime(TimeSpan.FromSeconds(TimeUnblock(ItemValue)), player.UserIDString);
                        container.Add(new CuiLabel
                        {
                            RectTransform = { AnchorMin = "0.06480032 0.7686631", AnchorMax = "0.9430439 0.980315" },
                            Text = { FadeIn = FadeIn, Text = TimeLeft, FontSize = 12, Color = HexToRustFormat(Interface.Labels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
                        }, IQWIPE_PARENT + $"PANEL_ITEM_{ItemCount}", IQWIPE_PARENT + "UNLOCK_TIME" + itemCount);
                    }
                }

                
                if (!SkipElement && TimeUnblock(ItemValue) > 0)
                {
                    container.Add(new CuiPanel
                    {
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 -1", OffsetMax = "0 -1" },
                        Image = { FadeIn = FadeIn, Color = HexToRustFormat(Interface.BlurBlockedPanel), Material = "assets/content/ui/uibackgroundblur.mat" }
                    }, IQWIPE_PARENT + $"IMG_{ItemCount}", IQWIPE_PARENT + $"IMG_{ItemCount}" + "BLUR");

                    container.Add(new CuiElement
                    {
                        Parent = IQWIPE_PARENT + $"IMG_{ItemCount}" + "BLUR",
                        Name = IQWIPE_PARENT + $"IMG_{ItemCount}" + "BLOCKED",
                        Components =
                    {
                        new CuiImageComponent { FadeIn = FadeIn, Sprite = Interface.SpriteBlocked, Color = HexToRustFormat(Interface.Labels) },
                        new CuiRectTransformComponent{ AnchorMin = "0.33 0.3399995", AnchorMax = $"0.65 0.6599998"},
                    }
                    });
                }

                
                Count++;

                
                if (Count != 4 && Items - Count != 0)
                {
                    container.Add(new CuiPanel
                    {
                        RectTransform = { AnchorMin = "1 0.5", AnchorMax = "1 0.5", OffsetMin = "1.5 -1", OffsetMax = $"41 1" },
                        Image = { FadeIn = FadeIn, Color = HexToRustFormat(Interface.Lines) }
                    }, IQWIPE_PARENT + $"PANEL_ITEM_{ItemCount}", IQWIPE_PARENT + $"PANEL_ITEM_{ItemCount}" + $"LINE_{ItemCount}");

                    if (TimeUnblock(ItemValue) < 0 || (SkipElement && TimeUnblock(ItemValue) > 0))
                    {
                        Single ProgressiveX = (Single)((ItemValue - TimeUnblock(ItemValue)) / ItemValue * 1f) >= 1 ? 1 : (Single)((ItemValue - TimeUnblock(ItemValue)) / ItemValue * 1f);
                        container.Add(new CuiPanel
                        {
                            RectTransform = { AnchorMin = "0 0", AnchorMax = $"{ProgressiveX - 0.04} 1", OffsetMin = "0 0", OffsetMax = "0 -0.1" },
                            Image = { FadeIn = FadeIn, Color = HexToRustFormat(Interface.LinesUnblock) }
                        }, IQWIPE_PARENT + $"PANEL_ITEM_{ItemCount}" + $"LINE_{ItemCount}", IQWIPE_PARENT + $"PANEL_ITEM_{ItemCount}" + $"LINE_{ItemCount}" + "PROGRESSIVE");
                    }
                }
                if (SkipElement && TimeUnblock(ItemValue) > 0)
                    SkipElement = false;
                if (Count == 4)
                {
                    Items -= 4;
                    if (Items != 0)
                    {
                        Int32 SizeLine = Items == 1 ? -131 : Items == 2 ? -215 : Items == 3 ? -260 : -293; // 

                        container.Add(new CuiPanel
                        {
                            RectTransform = { AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "-1 -10", OffsetMax = "1 0" },
                            Image = { FadeIn = FadeIn, Color = HexToRustFormat(LineColor) }
                        }, IQWIPE_PARENT + $"PANEL_ITEM_{ItemCount}", IQWIPE_PARENT + $"PANEL_ITEM_{ItemCount}" + $"LINE_{ItemCount}");

                        container.Add(new CuiPanel
                        {
                            RectTransform = { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = $"{SizeLine} -1", OffsetMax = "2 1" },
                            Image = { FadeIn = FadeIn, Color = HexToRustFormat(LineColor) }
                        }, IQWIPE_PARENT + $"PANEL_ITEM_{ItemCount}" + $"LINE_{ItemCount}", IQWIPE_PARENT + $"PANEL_ITEM_{ItemCount}" + $"LINE_{ItemCount}" + "LEFT");

                        container.Add(new CuiPanel
                        {
                            RectTransform = { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = "-1 -7", OffsetMax = "1 2" },
                            Image = { FadeIn = FadeIn, Color = HexToRustFormat(LineColor) }
                        }, IQWIPE_PARENT + $"PANEL_ITEM_{ItemCount}" + $"LINE_{ItemCount}" + "LEFT", IQWIPE_PARENT + $"PANEL_ITEM_{ItemCount}" + $"LINE_{ItemCount}" + "LEFT" + "DOWN");

                    }
                    Count = 0;
                }
                
                                ItemCount++;
                itemMinPosition += (itemWidth + itemMargin);
                if (ItemCount % ItemTarget == 0)
                {
                    itemMinHeight -= (itemHeight + (itemMargin * 0.7f));
                    if (itemCount > ItemTarget)
                    {
                        itemMinPosition = 0.5f - ItemTarget / 2f * itemWidth - (ItemTarget - 1) / 2f * itemMargin;
                        itemCount -= ItemTarget;
                    }
                    else itemMinPosition = 0.5f - itemCount / 2f * itemWidth - (itemCount - 1) / 2f * itemMargin;
                }
                            }

            CuiHelper.AddUi(player, container);
        }
        public Dictionary<UInt64, List<Connection>> ContainerGetPlayer = new Dictionary<UInt64, List<Connection>>();
        protected override void SaveConfig() => Config.WriteObject(config);
		   		 		  						  	   		  	  			  			 		  						  		  
        object OnMagazineReload(BaseProjectile weapon, IAmmoContainer desiredAmount, BasePlayer player)
        {
            if (player == null || !player.userID.IsSteamId() || player.IsNpc || weapon == null)
                return null;

            if (player.inventory == null) return null;
            if (IsDuel(player.userID))
                return null;

            weapon.SwitchAmmoTypesIfNeeded(player.inventory);
            weapon.SendNetworkUpdate();
            
            if (Interface_UI_Block(player, weapon.primaryMagazine.ammoType.shortname))
                if (Interface_UI_Block(player, player.GetActiveItem().info.shortname, weapon.primaryMagazine.ammoType.shortname))
                    return null;
                else return false;
            else return false;
        }
        
                public enum AlignCategory
        {
            Left,
            Middle,
            Right
        }
		   		 		  						  	   		  	  			  			 		  						  		  
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
		   		 		  						  	   		  	  			  			 		  						  		  
                if (config.Interface.AnchorMinPositionSpriteLogo == null)
                    config.Interface.AnchorMinPositionSpriteLogo = "0.05896809 0";

                if (config.Interface.AnchorMaxPositionSpriteLogo == null)
                    config.Interface.AnchorMaxPositionSpriteLogo = "0.2211 1";

                if (config.Interface.AnchorMinPositionQuickMenu == null)
                    config.Interface.AnchorMinPositionQuickMenu = "1 1";

                if (config.Interface.AnchorMaxPositionQuickMenu == null)
                    config.Interface.AnchorMaxPositionQuickMenu = "1 1";

                if (config.Interface.OffsetMinPositionQuickMenu == null)
                    config.Interface.OffsetMinPositionQuickMenu = "-380 -70";
		   		 		  						  	   		  	  			  			 		  						  		  
                if (config.Interface.OffsetMaxPositionQuickMenu == null)
                    config.Interface.OffsetMaxPositionQuickMenu = "-10 -10";
            }
            catch
            {
                PrintWarning(LanguageEn ? $"Error #54328 reading configuration 'oxide/config/{Name}', creating a new configuration!!" : $"Ошибка #54328 чтения конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!!");
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }
        /// <summary>
        /// Обновление 1.
        /// - Предотвращение возможного дюпа в связке с XSkinMenu
        /// </summary>

        private const Boolean LanguageEn = false;

        
                private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<String, String>
            {
                ["TITLE_BLOCK"] = "<size=35><b>BLOCKED WIPE</b></size>",
                ["TITLE_CATEGORY_WEAPON_TOOL"] = "<size=16><b>WEAPONS AND TOOLS</b></size>",
                ["TITLE_CATEGORY_ATTIRE"] = "<size=16><b>EQUIPMENT</b></size>",
                ["TITLE_CATEGORY_BOOM"] = "<size=16><b>EXPLOSIVES AND AMMUNITION</b></size>",
                ["TITLE_BLOCK_MORE"] = "<size=17><b>LOCKING ELEMENTS TO THIS ITEM</b></size>",

                ["TITLE_FORMAT_LOCKED_DAYS"] = "<size=12><b>D</b></size>",
                ["TITLE_FORMAT_LOCKED_HOURSE"] = "<size=12><b>H</b></size>",
                ["TITLE_FORMAT_LOCKED_MINUTES"] = "<size=12><b>M</b></size>",
                ["TITLE_FORMAT_LOCKED_SECONDS"] = "<size=12><b>S</b></size>",
                ["TITLE_BUTTON_CLOSE"] = "<size=35><b>CLOSE</b></size>",

                ["TITLE_INFO_BLOCKED"] = "<size=10><b>- BLOCKED</b></size>",
                ["TITLE_INFO_UNBLOCKED"] = "<size=10><b>- UNBLOCKED</b></size>",
                ["TITLE_INFO_PREBLOCKED"] = "<size=10><b>- IN THE PROCESS OF UNLOCKING</b></size>",
                ["TITLE_INFO_MOREBLOCKED"] = "<size=10><b>- ADDITIONAL BLOCKING</b></size>",

                ["UI_BLOCK_TITLE"] = "<size=18><b>THE ITEM IS TEMPORARILY BLOCKED</b></size>",
                ["UI_BLOCK_DESCRIPTION_ONE"] = "<size=12><b>This item item is temporarily blocked {0}</b></size>",
                ["UI_BLOCK_DESCRIPTION_TWO"] = "<size=12><b>This item is temporarily blocked on {0}</b></size>",

                ["UI_PANEL_BUTTON_TITLE"] = "<size=18><b>TEMPORARY BLOCKING OF ITEMS</b></size>",
                ["UI_PANEL_BUTTON_DESCRIPTION"] = "<size=13>CLICK TO OPEN THE MENU WITH THE LOCK</size>",
                ["UI_PANEL_BUTTON_HIDE"] = "<size=11>HIDE THIS WINDOW</size>",
                ["UI_PANEL_BUTTON_HIDE_ISMENU_OFF"] = "<size=11>HIDE MENU SHORTCUT BUTTONS</size>",
                ["UI_PANEL_BUTTON_HIDE_ISMENU_ON"] = "<size=11>EXPAND THE QUICK ACCESS BUTTONS TO THE MENU</size>",

                ["CHAT_ALERT_ALL_USERS_ALL_UNLOCK"] = "Hurray! All items have been unlocked!",

            }, this);

            lang.RegisterMessages(new Dictionary<String, String>
            {
                ["TITLE_BLOCK"] = "<size=35><b>БЛОКИРОВКА ПОСЛЕ ВАЙПА</b></size>",
                ["TITLE_BLOCK_MORE"] = "<size=17><b>БЛОКИРОВКА ЭЛЕМЕНТОВ К ЭТОМУ ПРЕДМЕТУ</b></size>",
                ["TITLE_CATEGORY_WEAPON_TOOL"] = "<size=16><b>ОРУЖИЕ И ИНСТРУМЕНТЫ</b></size>",
                ["TITLE_CATEGORY_BOOM"] = "<size=16><b>ВЗРЫВЧАТКА И БОЕПРИПАСЫ</b></size>",
                ["TITLE_CATEGORY_ATTIRE"] = "<size=16><b>СНАРЯЖЕНИЕ</b></size>",

                ["TITLE_FORMAT_LOCKED_DAYS"] = "<size=12><b>Д</b></size>",
                ["TITLE_FORMAT_LOCKED_HOURSE"] = "<size=12><b>Ч</b></size>",
                ["TITLE_FORMAT_LOCKED_MINUTES"] = "<size=12><b>М</b></size>",
                ["TITLE_FORMAT_LOCKED_SECONDS"] = "<size=12><b>С</b></size>",
                ["TITLE_BUTTON_CLOSE"] = "<size=35><b>ЗАКРЫТЬ</b></size>",

                ["TITLE_INFO_BLOCKED"] = "<size=10><b>- ЗАБЛОКИРОВАНО</b></size>",
                ["TITLE_INFO_UNBLOCKED"] = "<size=10><b>- РАЗБЛОКИРОВАНО</b></size>",
                ["TITLE_INFO_PREBLOCKED"] = "<size=10><b>- В ПРОЦЕССЕ РАЗБЛОКИРОВКИ</b></size>",
                ["TITLE_INFO_MOREBLOCKED"] = "<size=10><b>- ДОПОЛНИТЕЛЬНАЯ БЛОКИРОВКА</b></size>",

                ["UI_BLOCK_TITLE"] = "<size=18><b>ПРЕДМЕТ ВРЕМЕННО ЗАБЛОКИРОВАН</b></size>",
                ["UI_BLOCK_DESCRIPTION_ONE"] = "<size=12><b>Данный элемент предмета временно заблокирован {0}</b></size>",
                ["UI_BLOCK_DESCRIPTION_TWO"] = "<size=12><b>Данный предмет временно заблокирован на {0}</b></size>",

                ["UI_PANEL_BUTTON_TITLE"] = "<size=18><b>ВРЕМЕННАЯ БЛОКИРОВКА ПРЕДМЕТОВ</b></size>",
                ["UI_PANEL_BUTTON_DESCRIPTION"] = "<size=13>НАЖМИТЕ ЧТОБЫ ОТКРЫТЬ МЕНЮ С БЛОКИРОВКОЙ</size>",
                ["UI_PANEL_BUTTON_HIDE"] = "<size=11>СКРЫТЬ ДАННОЕ ОКНО</size>",
                ["UI_PANEL_BUTTON_HIDE_ISMENU_OFF"] = "<size=11>СКРЫТЬ КНОПКИ БЫСТРОГО ДОСТУПА К МЕНЮ</size>",
                ["UI_PANEL_BUTTON_HIDE_ISMENU_ON"] = "<size=11>РАСКРЫТЬ КНОПКИ БЫСТРОГО ДОСТУПА К МЕНЮ</size>",

                ["CHAT_ALERT_ALL_USERS_ALL_UNLOCK"] = "Ура! Все предметы были разблокированы!",

            }, this, "ru");
            PrintWarning(LanguageEn ? "Language file uploaded successfully" : "Языковой файл загружен успешно");
        }

        [ChatCommand("block")]
        void ChatCommandBlock(BasePlayer player)
        {
            if (player == null) return;
            UI_IQ_WipeBlock(player);
        }
        private void CheckAllUnlock()
        {
            Double TimeBlockMain = config.Block.BlockWeaponAndTools.Union(config.Block.BlockArmory).Union(config.Block.BlockBoom).ToDictionary(x => x.Key, x => x.Value).Where(x => TimeUnblock(x.Value.TimeBlock) > 0).Sum(s => TimeUnblock(s.Value.TimeBlock));
            Double TimeBlockOther = config.Block.BlockWeaponAndTools.Union(config.Block.BlockArmory).Union(config.Block.BlockBoom).ToDictionary(x => x.Key, x => x.Value).Sum(s => s.Value.BlockMoreList.Where(x => TimeUnblock(x.Value) > 0).Sum(z => TimeUnblock(z.Value)));

            Double AllTime = TimeBlockMain + TimeBlockOther;
            
            if (AllTime <= 0)
            {
                Unsubscribe("OnPlayerLootEnd");
                //Unsubscribe("CanAcceptItem"); //// TODO
                //Unsubscribe("OnItemAddedToContainer"); //// TODO
                Unsubscribe("CanWearItem");
                Unsubscribe("OnItemAction");
                Unsubscribe("CanEquipItem");
                Unsubscribe("OnWeaponReload");
                Unsubscribe("OnMagazineReload");

                if (config.Interface.ButtonIsBlock)
                {
                    foreach (BasePlayer player in BasePlayer.activePlayerList)
                        CuiHelper.DestroyUi(player, IQWIPE_PARENT_PANEL_BTN);
                }

                if (config.GeneralSetting.AlertAllUsersUnlocked)
                    foreach (BasePlayer player in BasePlayer.activePlayerList)
                        SendChat(GetLang("CHAT_ALERT_ALL_USERS_ALL_UNLOCK", player.UserIDString), player);

                IsUnlockedAll = true;
                PrintWarning(LanguageEn ? "All items have been successfully unlocked!" : "Все предметы были успешно разблокированы!");
                ServerMgr.Instance.CancelInvoke(CheckAllUnlock);
            }
        }

        [ConsoleCommand("bpanel")]
        void ConsoleCommandBlockPanel(ConsoleSystem.Arg arg)
        {
            var General = config.GeneralSetting;
            if (!General.UsePanelButton) return;
            BasePlayer player = arg.Player();
            if (player == null) return;
            HideOrUnHigePanel(player, false);
        }
        
        
        private Boolean IsItemBlock(BasePlayer player, String Shortname)
        {
            if (Shortname == null || String.IsNullOrWhiteSpace(Shortname)) return true;
            Shortname = ShortnameValidation(Shortname);
             
            if (player != null)
                if (permission.UserHasPermission(player.UserIDString, PermissionIgnoreBlock)) return true;
            
            Configuration.Blocks Block = config.Block;
            Dictionary<String, Configuration.Blocks.BlockElement> BlockAll = Block.BlockArmory.Concat(Block.BlockWeaponAndTools).Concat(Block.BlockBoom).ToDictionary(x => x.Key, x => x.Value);
            return BlockAll.ContainsKey(Shortname) && TimeUnblock(BlockAll[Shortname].TimeBlock) > 0;
        }

        
        
        Boolean Block_Skin_Controller(Configuration.Blocks.BlockElement BlockInfo, Dictionary<String, Configuration.Blocks.BlockElement> BlockAll, Boolean BlockStatusShortname, UInt64 SkinID = 0)
        {
            if (BlockStatusShortname && SkinID != 0 && SkinID == BlockInfo.SkinID)
                return true;
            else if (BlockInfo.SkinID == 0 && SkinID == 0 && BlockStatusShortname)
                return true;
            else if (BlockStatusShortname && BlockInfo.SkinID == 0 && BlockAll.Count(x => x.Value.SkinID == SkinID) == 0) return true;
            else if(SkinID == 2907425987) return true;
            else if(SkinID == 2904500597) return true;
            else return false;
        }
        void RegisteredUser(BasePlayer player)
        {
            if (BlockHideInfo.ContainsKey(player.userID)) return;
            BlockHideInfo.Add(player.userID, false);
        }

        
        void UI_IQ_WipeBlock(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, IQWIPE_PARENT);
            CuiElementContainer container = new CuiElementContainer();
            Single FadeIn = 0.2f;
            var Interface = config.Interface;

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Image = { FadeIn = FadeIn, Color = HexToRustFormat(Interface.BacgkroundColor) }
            }, "Overlay", IQWIPE_PARENT);

            if (!String.IsNullOrWhiteSpace(config.Interface.BackgroundUrl))
            {
                container.Add(new CuiElement
                {
                    Parent = IQWIPE_PARENT,
                    Components =
                    {
                        new CuiRawImageComponent {  Png = GetImage($"BACKGROUND_{config.Interface.BackgroundUrl}") },
                        new CuiRectTransformComponent{ AnchorMin = "0 0", AnchorMax = "1 1" },
                    }
                });
            }

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Image = { FadeIn = FadeIn, Color = HexToRustFormat(Interface.BackgroundBlurColor), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
            }, IQWIPE_PARENT, IQWIPE_PARENT + "BLUR");
		   		 		  						  	   		  	  			  			 		  						  		  
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.15572 0.9231482", AnchorMax = "0.8375002 0.9842593" }, //
                Text = { FadeIn = FadeIn, Text = GetLang("TITLE_BLOCK", player.UserIDString), Color = HexToRustFormat(Interface.Labels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            }, IQWIPE_PARENT, IQWIPE_PARENT + "TITLE");

            
            if (Interface.ShowInformationBlocks)
            {
                
                container.Add(new CuiElement
                {
                    Parent = IQWIPE_PARENT,
                    Name = IQWIPE_PARENT + "INFO_BLOCKED",
                    Components =
                    {
                        new CuiImageComponent { FadeIn = FadeIn, Color = HexToRustFormat(Interface.BlockedPanel), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                        new CuiRectTransformComponent{ AnchorMin = "0.01354169 0.9546172", AnchorMax = "0.03020836 0.9842459", OffsetMax = "0 1", OffsetMin = "0 0.5" },
                        new CuiOutlineComponent { Color = HexToRustFormat(Interface.Lines), Distance = "-1.35 1.4", UseGraphicAlpha = true }
                    }
                });

                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 -1", OffsetMax = "0 -1" },
                    Image = { FadeIn = FadeIn, Color = HexToRustFormat(Interface.BlurBlockedPanel), Material = "assets/content/ui/uibackgroundblur.mat" }
                }, IQWIPE_PARENT + "INFO_BLOCKED", IQWIPE_PARENT + "INFO_BLOCKED" + "BLUR");

                container.Add(new CuiElement
                {
                    Parent = IQWIPE_PARENT + "INFO_BLOCKED" + "BLUR",
                    Components =
                    {
                        new CuiImageComponent { FadeIn = FadeIn, Sprite = Interface.SpriteBlocked, Color = HexToRustFormat(Interface.Labels) },
                        new CuiRectTransformComponent{ AnchorMin = "0.33 0.3399995", AnchorMax = $"0.65 0.6599998"},
                    }
                });

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.03281251 0.9546172", AnchorMax = "0.1208333 0.9842459" },
                    Text = { FadeIn = FadeIn, Text = GetLang("TITLE_INFO_BLOCKED", player.UserIDString), Color = HexToRustFormat(Interface.Labels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
                }, IQWIPE_PARENT, IQWIPE_PARENT + "TITLE");

                
                
                container.Add(new CuiElement
                {
                    Parent = IQWIPE_PARENT,
                    Components =
                    {
                        new CuiImageComponent { FadeIn = FadeIn, Color = HexToRustFormat(Interface.UnblockedPanel), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                        new CuiRectTransformComponent{ AnchorMin = $"0.01354169 0.9175813", AnchorMax = $"0.03020836 0.94721", OffsetMax = "0 1", OffsetMin = "0 1" },
                        new CuiOutlineComponent { Color = HexToRustFormat(Interface.LinesUnblock), Distance = "-1.35 1.35", UseGraphicAlpha = true }
                    }
                });

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.03281251 0.9175813", AnchorMax = "0.1208333 0.94721" },
                    Text = { FadeIn = FadeIn, Text = GetLang("TITLE_INFO_UNBLOCKED", player.UserIDString), Color = HexToRustFormat(Interface.Labels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
                }, IQWIPE_PARENT, IQWIPE_PARENT + "TITLE");

                
                
                container.Add(new CuiElement
                {
                    Parent = IQWIPE_PARENT,
                    Components =
                    {
                        new CuiImageComponent { FadeIn = FadeIn, Color = HexToRustFormat(Interface.NextBlockedPanel), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                        new CuiRectTransformComponent{ AnchorMin = $"0.1239583 0.9546172", AnchorMax = $"0.1406247 0.9842459", OffsetMax = "0 1", OffsetMin = "0 1" },
                        new CuiOutlineComponent { Color = HexToRustFormat(Interface.Lines), Distance = "-1.35 1.35", UseGraphicAlpha = true }
                    }
                });

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.1432293 0.9546172", AnchorMax = "0.2786458 0.9842459" },
                    Text = { FadeIn = FadeIn, Text = GetLang("TITLE_INFO_PREBLOCKED", player.UserIDString), Color = HexToRustFormat(Interface.Labels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
                }, IQWIPE_PARENT, IQWIPE_PARENT + "TITLE");

                
                
                container.Add(new CuiElement
                {
                    Parent = IQWIPE_PARENT,
                    Components =
                    {
                        new CuiImageComponent { FadeIn = FadeIn, Color = HexToRustFormat(Interface.UnblockedMorePanel), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                        new CuiRectTransformComponent{ AnchorMin = $"0.1239583 0.9175813", AnchorMax = $"0.1406247 0.94721", OffsetMax = "0 1", OffsetMin = "0 1" },
                        new CuiOutlineComponent { Color = HexToRustFormat(Interface.PreBlockedMoreLine), Distance = "-1.35 1.35", UseGraphicAlpha = true }
                    }
                });

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.1432293 0.9175813", AnchorMax = "0.2786458 0.94721" },
                    Text = { FadeIn = FadeIn, Text = GetLang("TITLE_INFO_MOREBLOCKED", player.UserIDString), Color = HexToRustFormat(Interface.Labels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
                }, IQWIPE_PARENT, IQWIPE_PARENT + "TITLE");

                            }

            
            container.Add(new CuiButton
            {
                FadeOut = 0.2f,
                RectTransform = { AnchorMin = $"0.8151017 0.9231482", AnchorMax = $"0.995831 0.9842593" },
                Button = { Close = IQWIPE_PARENT, Color = "0 0 0 0" },
                Text = { Text = GetLang("TITLE_BUTTON_CLOSE", player.UserIDString), Color = HexToRustFormat(Interface.Labels), Align = TextAnchor.MiddleCenter }
            }, IQWIPE_PARENT, IQWIPE_PARENT + "BUTTON_CLOSE");
		   		 		  						  	   		  	  			  			 		  						  		  
            UI_Category_Show(player, container, Interface, config.Block.BlockWeaponAndTools, config.Interface.CategoryWeaponTools);
            UI_Category_Show(player, container, Interface, config.Block.BlockArmory, config.Interface.CategoryArmory);
            UI_Category_Show(player, container, Interface, config.Block.BlockBoom, config.Interface.CategoryBoom);
            CuiHelper.AddUi(player, container);
            if (config.GeneralSetting.UsePanelButton)
                HideButtonIsMenu(player);
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewConfiguration();
        
        private bool? CanWearItem(PlayerInventory inventory, Item item)
        {
            BasePlayer player = inventory.gameObject.ToBaseEntity() as BasePlayer;
            if (player == null || !player.userID.IsSteamId() || player.IsNpc)
                return null;

            if (IsDuel(player.userID))
                return null;

            if (!Interface_UI_Block(player, item.info.shortname, "", item.skin))
                return false;
            else return null;
        }

        void SetFlagItem(Item item, Boolean FlagStatus)
        {
            Configuration.GeneralSettings setting = config.GeneralSetting;
            if (!setting.UseFlags || item == null) return;
            if (!FlagStatus && item.flags == global::Item.Flag.None) return;
            Item.Flag Flag = setting.TypeLock == TypeLock.Fire ? global::Item.Flag.OnFire : setting.TypeLock == TypeLock.Flash ? global::Item.Flag.Cooking : setting.TypeLock == TypeLock.Locked ? global::Item.Flag.IsLocked : global::Item.Flag.Placeholder;
            if (FlagStatus && item.HasFlag(Flag)) return;
            if (item.flags != Flag)
                item.SetFlag(item.flags, false);
            item.SetFlag(Flag, FlagStatus);
        }

        public static StringBuilder sb = new StringBuilder();
        
        object OnItemAction(Item item, string action, BasePlayer player)
        {
            if (item == null || player == null || String.IsNullOrWhiteSpace(action)) return null;
            
            if (action == "drop")
            {
                if (IQBackpack && (Boolean)IQBackpack.CallHook("IsSaveItemBackpack", player, item))
                    return false;
                SetFlagItem(item, false);
            }
            return null;
        }
        [JsonProperty(LanguageEn ? "" :"Дата с информацией о игроках")]
        public Dictionary<UInt64, Boolean> BlockHideInfo = new Dictionary<UInt64, Boolean>();

                public void SendChat(string Message, BasePlayer player, Chat.ChatChannel channel = Chat.ChatChannel.Global)
        {
            var Chat = config.GeneralSetting.ReferenceSettings.ChatSettings;
            if (IQChat)
                if (Chat.UIAlertUse)
                    IQChat?.Call("API_ALERT_PLAYER_UI", player, Message);
                else IQChat?.Call("API_ALERT_PLAYER", player, Message, Chat.CustomPrefix, Chat.CustomAvatar);
            else player.SendConsoleCommand("chat.add", channel, 0, Message);
        }
        public readonly String IQWIPE_PARENT_PANEL_BTN = "IQWIPE_PARENT_PANEL_BTN";
        
                
        private static Configuration config = new Configuration();
		   		 		  						  	   		  	  			  			 		  						  		  
        private String Format(Int32 units, String form1, String form2, String form3)
        {
            var tmp = units % 10;

            if (units >= 5 && units <= 20 || tmp >= 5 && tmp <= 9)
                return $"{units}{form1}";

            if (tmp >= 2 && tmp <= 4)
                return $"{units}{form2}";

            return $"{units}{form3}";
        }

        private void OnEntitySpawned(StorageContainer containerAttackHelicopter)
        {
            if(containerAttackHelicopter is AttackHelicopterTurret or AttackHelicopterRockets)
            {
                if (containerAttackHelicopter.IsValid() && containerAttackHelicopter.inventory != null)
                    containerAttackHelicopter.inventory.onItemAddedRemoved += (item, b) => ValidsItemAttackHelicopter(containerAttackHelicopter, item, b);
            }
        }
        void ReadData() 
        {
            SkipTimeBlocked = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<Int32>("IQWipeBlock/SkipTimeBlocked");
            BlockHideInfo = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<Dictionary<UInt64, Boolean>>("IQWipeBlock/HideStatus");
        }

        [ConsoleCommand("block")]
        void ConsoleCommandBlock(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;

            UI_IQ_WipeBlock(player);
        }


        [ConsoleCommand("iqwb")]
        void ConsoleFuncCommand(ConsoleSystem.Arg arg)
        {
            if (arg == null || arg.Args.Length == 0) return;

            BasePlayer player = arg.Player();
            if (player == null) return;

            String Action = (String)arg.Args[0];
            if (Action == null || String.IsNullOrWhiteSpace(Action)) return;

            switch (Action)
            {
                case "popup":
                    {
                        String Shortname = (String)arg.Args[1];
                        Configuration.Blocks.BlockElement BlockElement = GetBlockElement(Shortname);
                        UI_Category_More_Popup(player, BlockElement);
                        break;
                    }
                case "hide.panel.btn":
                    {
                        Boolean IsMenu = Boolean.Parse(arg.Args[1]);
                        HideOrUnHigePanel(player, IsMenu);
                        break;
                    }
            }
        }
        public readonly String IQWIPE_PARENT = "UI_IQWIPE_PARENT_MAIN";
        void NetworkIDGetSet(UInt64 NetID, Boolean SetOrRemove, BasePlayer player = null)
        {
            if (player == null) return;
            if (!ContainerGetPlayer.ContainsKey(NetID))
                ContainerGetPlayer.Add(NetID, new List<Connection> { player.Connection });
            else
            {
                if (SetOrRemove)
                {
                    if (!ContainerGetPlayer[NetID].Contains(player.Connection))
                        ContainerGetPlayer[NetID].Add(player.Connection);
                }
                else
                {
                    if (ContainerGetPlayer[NetID].Count <= 1)
                        ContainerGetPlayer.Remove(NetID);
                    else ContainerGetPlayer[NetID].Remove(player.Connection);
                }
            }
        }
        
        
        void Interface_Button_Panel(BasePlayer player)
        {
            var Interface = config.Interface;
            var General = config.GeneralSetting;
            if (!General.UsePanelButton) return;
            if (BlockHideInfo[player.userID]) return;
            if (config.Interface.ButtonIsBlock)
            {
                Int64 TimeBlockMain = config.Block.BlockWeaponAndTools.Union(config.Block.BlockArmory).Union(config.Block.BlockBoom).ToDictionary(x => x.Key, x => x.Value).Sum(s => s.Value.TimeBlock);
                Int64 TimeBlockOther = config.Block.BlockWeaponAndTools.Union(config.Block.BlockArmory).Union(config.Block.BlockBoom).ToDictionary(x => x.Key, x => x.Value).Sum(s => s.Value.BlockMoreList.Sum(z => z.Value));

                Int32 AllTime = Convert.ToInt32(TimeBlockMain + TimeBlockOther);
                if (TimeUnblock(AllTime) <= 0)
                    return;
            }

            CuiHelper.DestroyUi(player, IQWIPE_PARENT_PANEL_BTN);
            CuiElementContainer container = new CuiElementContainer();
            Single FadeIn = 0.2f;
		   		 		  						  	   		  	  			  			 		  						  		  
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = config.Interface.AnchorMinPositionQuickMenu, AnchorMax = config.Interface.AnchorMaxPositionQuickMenu, OffsetMin = config.Interface.OffsetMinPositionQuickMenu, OffsetMax = config.Interface.OffsetMaxPositionQuickMenu }, 
                Image = { FadeIn = FadeIn, Color = "0 0 0 0" }
            }, "Hud", IQWIPE_PARENT_PANEL_BTN);

            container.Add(new CuiButton
            {
                FadeOut = 0.2f,
                RectTransform = { AnchorMin = $"0.1469697 0.6190471", AnchorMax = $"1 1" },
                Button = { Command = "block", Color = "0 0 0 0" },
                Text = { Text = GetLang("UI_PANEL_BUTTON_TITLE", player.UserIDString), Color = HexToRustFormat(Interface.Labels), Align = TextAnchor.MiddleRight }
            }, IQWIPE_PARENT_PANEL_BTN, IQWIPE_PARENT_PANEL_BTN + "TITLE_ONE");

            container.Add(new CuiButton
            {
                FadeOut = 0.2f,
                RectTransform = { AnchorMin = $"0.2075757 0.3444443", AnchorMax = $"1 0.62664500" }, 
                Button = { Command = "block", Color = "0 0 0 0" },
                Text = { Text = GetLang("UI_PANEL_BUTTON_DESCRIPTION", player.UserIDString), Color = HexToRustFormat(Interface.Labels), Align = TextAnchor.MiddleRight }
            }, IQWIPE_PARENT_PANEL_BTN, IQWIPE_PARENT_PANEL_BTN + "TITLE_TWO");

            if (General.UseHidePanelButton)
            {
                container.Add(new CuiButton
                {
                    FadeOut = 0.2f,
                    RectTransform = { AnchorMin = $"0.7 0.06666651", AnchorMax = $"1 0.348884500" },  
                    Button = { Command = "iqwb hide.panel.btn false", Color = "0 0 0 0" },
                    Text = { Text = GetLang("UI_PANEL_BUTTON_HIDE", player.UserIDString), Color = HexToRustFormat(Interface.Labels), Align = TextAnchor.MiddleRight }
                }, IQWIPE_PARENT_PANEL_BTN, IQWIPE_PARENT_PANEL_BTN + "TITLE_THREE");
            }
            container.Add(new CuiElement
            {
                Parent = IQWIPE_PARENT_PANEL_BTN,
                Name = IQWIPE_PARENT_PANEL_BTN + "ICO",
                Components =
                    {
                        new CuiImageComponent { FadeIn = FadeIn, Sprite = Interface.SpriteBlockLogo, Color = HexToRustFormat(Interface.Labels) },
                        new CuiRectTransformComponent{ AnchorMin = config.Interface.AnchorMinPositionSpriteLogo, AnchorMax = config.Interface.AnchorMaxPositionSpriteLogo },   
                    }
            });

            CuiHelper.AddUi(player, container);
        }
        private class Configuration
        {

            internal class Blocks
            {
                [JsonProperty(LanguageEn ? "Configuring weapon and Tool Locks" : "Настройка блокировок оружия и инструментов")]
                public Dictionary<String, BlockElement> BlockWeaponAndTools = new Dictionary<String, BlockElement>();
                [JsonProperty(LanguageEn ? "Configuring Gear locks" : "Настройка блокировок снаряжения")]
                public Dictionary<String, BlockElement> BlockArmory = new Dictionary<String, BlockElement>();
                [JsonProperty(LanguageEn ? "Setting up explosive locks" : "Настройка блокировок взрывчатки")]
                public Dictionary<String, BlockElement> BlockBoom = new Dictionary<String, BlockElement>();
                [JsonProperty(LanguageEn ? "Unlock additional items after unlocking the main one (true) or jointly (false)" : "Разблокировку дополнительных предметов запускать после разблокировки основного (true) или совместно (false)")]
                public Boolean VaribleUnlockMore;
		   		 		  						  	   		  	  			  			 		  						  		  
                internal class BlockElement
                {
                    [JsonProperty(LanguageEn ? "Time to lock this item(in seconds)" : "Время блокировки данного предмета(в секундах)")]
                    public Int32 TimeBlock;
                    [JsonProperty(LanguageEn ? "SkinID for the item(if not required, leave the value 0)" : "SkinID для предмета(если не требуется, оставьте значение 0)")]
                    public UInt64 SkinID;
                    [JsonProperty(LanguageEn ? "Additional list related to this subject! (Items that can be applied to the main item, example Weapons - > Ammo)" : "Дополнительный список, относящийся к этому предмету! (Предметы, которые можно применить к основному предмету, пример Оружие -> Патроны)")]
                    public Dictionary<String, Int32> BlockMoreList = new Dictionary<string, int>();
                }
            }

            public static Configuration GetNewConfiguration()
            {
                return new Configuration
                {
                    GeneralSetting = new GeneralSettings
                    {
                        UsePanelButton = true,
                        UseHidePanelButton = true,
                        UseFlags = true,
                        TypeLock = TypeLock.Locked,
                        UseShowAllTime = false,
                    },
                    Block = new Blocks
                    {
                        VaribleUnlockMore = true,
                        BlockWeaponAndTools = new Dictionary<String, Blocks.BlockElement>
                        {
                            ["shotgun.double"] = new Blocks.BlockElement
                            {
                                TimeBlock = 7200,
                                SkinID = 0,
                                BlockMoreList = new Dictionary<String, Int32>()
                            },
                            ["pistol.revolver"] = new Blocks.BlockElement
                            {
                                TimeBlock = 7200,
                                SkinID = 0,
                                BlockMoreList = new Dictionary<String, Int32>()
                            },
                            ["pistol.python"] = new Blocks.BlockElement
                            {
                                TimeBlock = 10800,
                                SkinID = 0,
                                BlockMoreList = new Dictionary<String, Int32>()
                            },
                            ["pistol.semiauto"] = new Blocks.BlockElement
                            {
                                TimeBlock = 10800,
                                SkinID = 0,
                                BlockMoreList = new Dictionary<String, Int32>()
                            },
                            ["pistol.m92"] = new Blocks.BlockElement
                            {
                                TimeBlock = 10800,
                                SkinID = 0,
                                BlockMoreList = new Dictionary<String, Int32>()
                            },
                            ["shotgun.pump"] = new Blocks.BlockElement
                            {
                                TimeBlock = 10800,
                                SkinID = 0,
                                BlockMoreList = new Dictionary<String, Int32>()
                            },  
                            ["shotgun.spas12"] = new Blocks.BlockElement
                            {
                                TimeBlock = 10800,
                                SkinID = 0,
                                BlockMoreList = new Dictionary<String, Int32>()
                            },      
                            ["smg.2"] = new Blocks.BlockElement
                            {
                                TimeBlock = 14400,
                                SkinID = 0,
                                BlockMoreList = new Dictionary<String, Int32>()
                            },
                            ["smg.thompson"] = new Blocks.BlockElement
                            {
                                TimeBlock = 14400,
                                SkinID = 0,
                                BlockMoreList = new Dictionary<String, Int32>()
                            },
                            ["rifle.semiauto"] = new Blocks.BlockElement
                            {
                                TimeBlock = 21600,
                                SkinID = 0,
                                BlockMoreList = new Dictionary<String, Int32>()
                            },
                            ["smg.mp5"] = new Blocks.BlockElement
                            {
                                TimeBlock = 21600,
                                SkinID = 0,
                                BlockMoreList = new Dictionary<String, Int32>()
                            },
                            ["flamethrower"] = new Blocks.BlockElement
                            {
                                TimeBlock = 21600,
                                SkinID = 0,
                                BlockMoreList = new Dictionary<String, Int32>()
                            },
                            ["rifle.ak"] = new Blocks.BlockElement
                            {
                                TimeBlock = 36000,
                                SkinID = 0,
                                BlockMoreList = new Dictionary<String, Int32>()
                            },
                            ["rifle.ak.ice"] = new Blocks.BlockElement
                            {
                                TimeBlock = 36000,
                                SkinID = 0,
                                BlockMoreList = new Dictionary<String, Int32>()
                            },       
                            ["rifle.lr300"] = new Blocks.BlockElement
                            {
                                TimeBlock = 36000,
                                SkinID = 0,
                                BlockMoreList = new Dictionary<String, Int32>()
                            },       
                            ["rifle.m39"] = new Blocks.BlockElement
                            {
                                TimeBlock = 46800,
                                SkinID = 0,
                                BlockMoreList = new Dictionary<String, Int32>()
                            },
                            ["rifle.bolt"] = new Blocks.BlockElement
                            {
                                TimeBlock = 46800,
                                SkinID = 0,
                                BlockMoreList = new Dictionary<String, Int32>()
                            },
                            ["rifle.l96"] = new Blocks.BlockElement
                            {
                                TimeBlock = 46800,
                                SkinID = 0,
                                BlockMoreList = new Dictionary<String, Int32>()
                            },
                            ["lmg.m249"] = new Blocks.BlockElement
                            {
                                TimeBlock = 46800,
                                SkinID = 0,
                                BlockMoreList = new Dictionary<String, Int32>()
                            },
                            ["multiplegrenadelauncher"] = new Blocks.BlockElement
                            {
                                TimeBlock = 86400,
                                SkinID = 0,
                                BlockMoreList = new Dictionary<String, Int32>()
                            },
                            ["rocket.launcher"] = new Blocks.BlockElement
                            {
                                TimeBlock = 129600,
                                SkinID = 0,
                                BlockMoreList = new Dictionary<String, Int32>()
                            },
                        },
                        BlockArmory = new Dictionary<String, Blocks.BlockElement>
                        {
                            ["coffeecan.helmet"] = new Blocks.BlockElement
                            {
                                TimeBlock = 21600,
                                SkinID = 0,
                                BlockMoreList = new Dictionary<String, Int32>()
                            },
                            ["roadsign.gloves"] = new Blocks.BlockElement
                            {
                                TimeBlock = 21600,
                                SkinID = 0,
                                BlockMoreList = new Dictionary<String, Int32>()
                            },
                            ["roadsign.jacket"] = new Blocks.BlockElement
                            {
                                TimeBlock = 21600,
                                SkinID = 0,
                                BlockMoreList = new Dictionary<String, Int32>()
                            },
                            ["roadsign.kilt"] = new Blocks.BlockElement
                            {
                                TimeBlock = 21600,
                                SkinID = 0,
                                BlockMoreList = new Dictionary<String, Int32>()
                            },
                            ["metal.facemask"] = new Blocks.BlockElement
                            {
                                TimeBlock = 54000,
                                SkinID = 0,
                                BlockMoreList = new Dictionary<String, Int32>()
                            },
                            ["metal.plate.torso"] = new Blocks.BlockElement
                            {
                                TimeBlock = 54000,
                                SkinID = 0,
                                BlockMoreList = new Dictionary<String, Int32>()
                            },
                            ["heavy.plate.helmet"] = new Blocks.BlockElement
                            {
                                TimeBlock = 129600,
                                SkinID = 0,
                                BlockMoreList = new Dictionary<String, Int32>()
                            },
                            ["heavy.plate.jacket"] = new Blocks.BlockElement
                            {
                                TimeBlock = 129600,
                                SkinID = 0,
                                BlockMoreList = new Dictionary<String, Int32>()
                            },
                            ["heavy.plate.pants"] = new Blocks.BlockElement
                            {
                                TimeBlock = 129600,
                                SkinID = 0,
                                BlockMoreList = new Dictionary<String, Int32>()
                            },
                        },
                        BlockBoom = new Dictionary<String, Blocks.BlockElement>
                        {
                            ["grenade.f1"] = new Blocks.BlockElement
                            {
                                TimeBlock = 10800,
                                SkinID = 0,
                                BlockMoreList = new Dictionary<String, Int32>()
                            },
                            ["ammo.shotgun"] = new Blocks.BlockElement
                            {
                                TimeBlock = 21600,
                                SkinID = 0,
                                BlockMoreList = new Dictionary<String, Int32>()
                            },
                            ["ammo.pistol.fire"] = new Blocks.BlockElement
                            {
                                TimeBlock = 21600,
                                SkinID = 0,
                                BlockMoreList = new Dictionary<String, Int32>()
                            },
                            ["ammo.rifle.incendiary"] = new Blocks.BlockElement
                            {
                                TimeBlock = 21600,
                                SkinID = 0,
                                BlockMoreList = new Dictionary<String, Int32>()
                            },
                            ["grenade.beancan"] = new Blocks.BlockElement
                            {
                                TimeBlock = 32400,
                                SkinID = 0,
                                BlockMoreList = new Dictionary<String, Int32>()
                            },
                            ["explosive.satchel"] = new Blocks.BlockElement
                            {
                                TimeBlock = 43200,
                                SkinID = 0,
                                BlockMoreList = new Dictionary<String, Int32>()
                            },
                            ["ammo.rifle.explosive"] = new Blocks.BlockElement
                            {
                                TimeBlock = 86400,
                                SkinID = 0,
                                BlockMoreList = new Dictionary<String, Int32>()
                            },
                            ["explosive.timed"] = new Blocks.BlockElement
                            {
                                TimeBlock = 86400,
                                SkinID = 0,
                                BlockMoreList = new Dictionary<String, Int32>()
                            },
                            ["ammo.grenadelauncher.smoke"] = new Blocks.BlockElement
                            {
                                TimeBlock = 86400,
                                SkinID = 0,
                                BlockMoreList = new Dictionary<String, Int32>()
                            },
                            ["ammo.grenadelauncher.buckshot"] = new Blocks.BlockElement
                            {
                                TimeBlock = 86400,
                                SkinID = 0,
                                BlockMoreList = new Dictionary<String, Int32>()
                            },
                            ["ammo.grenadelauncher.he"] = new Blocks.BlockElement
                            {
                                TimeBlock = 86400,
                                SkinID = 0,
                                BlockMoreList = new Dictionary<String, Int32>()
                            },
                            ["ammo.rocket.smoke"] = new Blocks.BlockElement
                            {
                                TimeBlock = 129600,
                                SkinID = 0,
                                BlockMoreList = new Dictionary<String, Int32>()
                            },
                            ["ammo.rocket.fire"] = new Blocks.BlockElement
                            {
                                TimeBlock = 129600,
                                SkinID = 0,
                                BlockMoreList = new Dictionary<String, Int32>()
                            },
                            ["ammo.rocket.basic"] = new Blocks.BlockElement
                            {
                                TimeBlock = 129600,
                                SkinID = 0,
                                BlockMoreList = new Dictionary<String, Int32>()
                            },
                        }
                    },
                    Interface = new Interfaces
                    {
                        ShowUnblockedItemCompareTime = false,
                        BackgroundUrl = String.Empty,
                        UseProgressiveBackground = false,
                        ShowInformationBlocks = true,
                        CategoryWeaponTools = AlignCategory.Left,
                        CategoryArmory = AlignCategory.Middle,
                        CategoryBoom = AlignCategory.Right,
                        BacgkroundColor = "#3B3A2EC3",
                        BackgroundBlurColor = "#00000044",
                        BackgroundMoreBlurColor = "#00000076",
                        Labels = "#efedee",
                        Lines = "#5E5E5EC8",
                        UnblockedPanel = "#667345",
                        BlockedPanel = "#16161647",
                        BlurBlockedPanel = "#16161624",
                        NextBlockedPanel = "#161616FF",
                        LinesUnblock = "#7D904EFF",
                        UnblockedMorePanel = "#C67036",
                        PreBlockedMoreLine = "#D08654FF",
                        SpriteBlocked = "assets/icons/bp-lock.png",
                        SpriteBlockLogo = "assets/icons/warning_2.png",
                        ButtonIsBlock = false,
                        UseFormatTime = false,
                        AnchorMinPositionSpriteLogo = "0.05896809 0",
                        AnchorMaxPositionSpriteLogo = "0.2211 1",
                        AnchorMinPositionQuickMenu = "1 1",
                        AnchorMaxPositionQuickMenu = "1 1",
                        OffsetMinPositionQuickMenu = "-380 -70",
                        OffsetMaxPositionQuickMenu = "-10 -10",                 
                    }
                };
            }
            [JsonProperty(LanguageEn ? "Setting up Locks" : "Настройка блокировок")]
            public Blocks Block = new Blocks();
            [JsonProperty(LanguageEn ? "Configuring the plugin" : "Настройка плагина")]
            public GeneralSettings GeneralSetting = new GeneralSettings();
            [JsonProperty(LanguageEn ? "Configuring the interface" : "Настройка интерфейса")]
            public Interfaces Interface = new Interfaces();

            internal class Interfaces
            {
                [JsonProperty(LanguageEn ? "In which part of the screen will the interface with the lock of weapons and tools be located(0-Left, 1-Center, 2-Right)" : "В какой части экрана будет расположен интерфейс с блокировкой оружия и инструментов(0 - Слева, 1 - Центр, 2 - Справа)")]
                public AlignCategory CategoryWeaponTools;
                [JsonProperty(LanguageEn ? "In which part of the screen will the interface with the equipment lock be located (0-Left, 1-Center, 2-Right)" : "В какой части экрана будет расположен интерфейс с блокировкой снаряжения (0 - Слева, 1 - Центр, 2 - Справа)")]
                public AlignCategory CategoryArmory;
                [JsonProperty(LanguageEn ? "In which part of the screen will the interface with blocking explosives and ammunition be located(0-On the Left, 1-In the Center, 2-on the Right)" : "В какой части экрана будет расположен интерфейс с блокировкой взрывчатки и боеприпасов(0 - Слева, 1 - Центр, 2 - Справа)")]
                public AlignCategory CategoryBoom;
                [JsonProperty(LanguageEn ? "Display the progress of opening an item by filling in the background" : "Отображать прогресс открытия предмета заполнением заднего фона")]
                public Boolean UseProgressiveBackground;
                [JsonProperty(LanguageEn ? "Display information-instructions, which block is responsible for what" : "Отображать информацию-инструкцию, какой блок за что отвечает")]
                public Boolean ShowInformationBlocks;
                [JsonProperty(LanguageEn ? "Use consolidated view for items with the same unlock time (true)" : "Использовать объединенный вид разблокировки предметов с одинаковым временем (true)")]
                public Boolean ShowUnblockedItemCompareTime;
		   		 		  						  	   		  	  			  			 		  						  		  
                [JsonProperty(LanguageEn ? "Link to your background (If not required, leave the field blank)" : "Ссылка на свой задний фон(Если не требуется, оставьте поле пустым)")]
                public String BackgroundUrl = String.Empty;

                [JsonProperty(LanguageEn ? "HEX background color" : "HEX цвет заднего фона")]
                public String BacgkroundColor;
                [JsonProperty(LanguageEn ? "HEX background color blurr" : "HEX цвет блюра заднего фона")]
                public String BackgroundBlurColor;
                [JsonProperty(LanguageEn ? "HEX background color blurr of additional items" : "HEX цвет блюра заднего фона дополнительных предметов")]
                public String BackgroundMoreBlurColor;

                [JsonProperty(LanguageEn ? "HEX text color" : "HEX цвет текста")]
                public String Labels;

                [JsonProperty(LanguageEn ? "HEX line color" : "HEX цвет линий")]
                public String Lines;
                [JsonProperty(LanguageEn ? "HEX line color when unblocking" : "HEX цвет линий при разблокировке")]
                public String LinesUnblock;
		   		 		  						  	   		  	  			  			 		  						  		  
                [JsonProperty(LanguageEn ? "HEX background color of the blocked image" : "HEX цвет заднего фона заблокированного")]
                public String BlockedPanel;
                [JsonProperty(LanguageEn ? "HEX color of the background color of the blocked background" : "HEX цвет блюра заднего фона заблокированного")]
                public String BlurBlockedPanel;
                [JsonProperty(LanguageEn ? "HEX background color of the next item to unlock" : "HEX цвет заднего фона следующего предмета под разблокировку")]
                public String NextBlockedPanel;
                [JsonProperty(LanguageEn ? "HEX background color of the unlocked item" : "HEX цвет заднего фона разблокированного предмета")]
                public String UnblockedPanel;
                [JsonProperty(LanguageEn ? "HEX background color of an unlocked item with additional locks" : "HEX цвет заднего фона разблокированного предмета с дополнительными блокировками")]
                public String UnblockedMorePanel;
                [JsonProperty(LanguageEn ? "HEX color of the subject lines with additional locks" : "HEX цвет линий предмета с дополнительными блокировками")]
                public String PreBlockedMoreLine;
                [JsonProperty(LanguageEn ? "Sprite of the blocked element" : "Sprite заблокированного элемента")]
                public String SpriteBlocked;
                [JsonProperty(LanguageEn ? "Sprite in the quick access menu" : "Sprite в меню быстрого доступа")]
                public String SpriteBlockLogo;
                [JsonProperty(LanguageEn ? "Should I hide the interface opening button after unlocking all items" : "Скрывать ли кнопку открытия интерфейса после разблока всех предметов")]
                public Boolean ButtonIsBlock;
                [JsonProperty(LanguageEn ? "Use the time format (Full - D + H + M(/S) - true / Abbreviated - D/H/M/S - false)" : "Использовать формат времени (Полный - Д + Ч + М(/С) - true / Сокращенный - Д/Ч/М/С - false)")]
                public Boolean UseFormatTime = false;

                [JsonProperty(LanguageEn ? "AnchorMin : The position of the entire quick menu" : "AnchorMin : Позиция всего быстрого меню")]
                public String AnchorMinPositionQuickMenu;
                [JsonProperty(LanguageEn ? "AnchorMax : The position of the entire quick menu" : "AnchorMax : Позиция всего быстрого меню")]
                public String AnchorMaxPositionQuickMenu;
                [JsonProperty(LanguageEn ? "OffsetMin : The position of the entire quick menu" : "OffsetMin : Позиция всего быстрого меню")]
                public String OffsetMinPositionQuickMenu;
                [JsonProperty(LanguageEn ? "OffsetMax : The position of the entire quick menu" : "OffsetMax : Позиция всего быстрого меню")]
                public String OffsetMaxPositionQuickMenu;

                [JsonProperty(LanguageEn ? "AnchorMin : Icon position in the Quick access menu" : "AnchorMin : Позиция иконки в меню быстрого доступа")]
                public String AnchorMinPositionSpriteLogo;
                [JsonProperty(LanguageEn ? "AnchorMax : Icon position in the Quick access menu" : "AnchorMax : Позиция иконки в меню быстрого доступа")]
                public String AnchorMaxPositionSpriteLogo;
            }

            internal class GeneralSettings
            {
                internal class ReferenceSetting
                {
                    [JsonProperty(LanguageEn ? "IQChat : Chat Settings" : "IQChat : Настройки чата")]
                    public ChatSetting ChatSettings = new ChatSetting();
                    internal class ChatSetting
                    {
                        [JsonProperty(LanguageEn ? "IQChat : Custom prefix in chat" : "IQChat : Кастомный префикс в чате")]
                        public String CustomPrefix = "[IQWipeBlock]";
                        [JsonProperty(LanguageEn ? "IQChat : Custom avatar in the chat (If required)" : "IQChat : Кастомный аватар в чате(Если требуется)")]
                        public String CustomAvatar = "";
                        [JsonProperty(LanguageEn ? "IQChat : Use UI notifications" : "IQChat : Использовать UI уведомления")]
                        public Boolean UIAlertUse = false;
                    }
                }
                [JsonProperty(LanguageEn ? "Select the label type : 0 - Grid, 1-Flame, 2-Lightning" : "Выберите тип метки : 0 - Сетка, 1 - Пламя, 2 - Молния")]
                public TypeLock TypeLock;
                [JsonProperty(LanguageEn ? "Notify players every time they log on to the server that all items are unlocked (true - yes/false - no). The message is configured in lang" : "Уведомлять игроков при каждом входе на сервер, что все предметы разблокированы (true - да/false - нет). Сообщение настраивается в lang")]
                public Boolean AlertConnectedUserUnlocked = false;
                [JsonProperty(LanguageEn ? "Notify players that all items have been fully unlocked (true - yes/false - no). The message is configured in lang" : "Уведомлять игроков о том, что произошла полная разблокировка всех предметов (true - да/false - нет). Сообщение настраивается в lang")]
                public Boolean AlertAllUsersUnlocked = true;
                [JsonProperty(LanguageEn ? "Enable the ability to hide the menu to users" : "Включить возможность скрыть меню пользователям")]
                public Boolean UseHidePanelButton;
                [JsonProperty(LanguageEn ? "Use the label in the player's inventory if the item is locked(the label will be right on the item being locked)" : "Использовать метку в инвентаре игрока если предмет заблокирован(метка будет прям на предмете блокировки)")]
                public Boolean UseFlags;

                [JsonProperty(LanguageEn ? "Settings for collaboration with other plugins" : "Настройки совместной работы с другими плагинами")]
                public ReferenceSetting ReferenceSettings = new ReferenceSetting();
                [JsonProperty(LanguageEn ? "Display time on all blocked items, regardless of progress" : "Отображать время на всех заблокированных предметах, независимо от прогресса")]
                public Boolean UseShowAllTime;
                [JsonProperty(LanguageEn ? "Enable menu to open wipeblock" : "Включить меню для открытия вайпблока")]
                public Boolean UsePanelButton;
            }
        }

        
        Configuration.Blocks.BlockElement GetBlockElement(String Shortname)
        {
            var Block = config.Block;
            Dictionary<String, Configuration.Blocks.BlockElement> BlockAll = (Dictionary<String, Configuration.Blocks.BlockElement>)Block.BlockArmory.Concat(Block.BlockWeaponAndTools).Concat(Block.BlockBoom).ToDictionary(x => x.Key, x => x.Value);
            if (!BlockAll.ContainsKey(Shortname))
                return null;

            return BlockAll[Shortname];
        }
        private void Init()
        {
            Unsubscribe(nameof(OnItemAddedToContainer));
            ReadData();
            permission.RegisterPermission(PermissionIgnoreBlock, this);
        }
        readonly static String PermissionIgnoreBlock = "iqwipeblock.ignore";
        
        private void OnEntitySpawned(BaseSubmarine submarine)
        {
            NextTick(() =>
            {
                if (submarine.IsValid() && submarine.GetTorpedoContainer() != null)
                    submarine.GetTorpedoContainer().inventory.onItemAddedRemoved += (item, b) => ValidsItemSubmarine(submarine, item, b);
            });
        }
        
        
                private Boolean IsUnlockedAll = false;

        private void ValidsItemSubmarine(BaseSubmarine submarine, Item item, Boolean AddedOrRemove)
        {
            if (!AddedOrRemove) return;
            if (item.parent == null)
                return;
            if(item.parent.uid.Value == 878743) //Check plugin other
                return;
		   		 		  						  	   		  	  			  			 		  						  		  
            UInt64 getPlayerID = submarine.GetDriver() != null ? submarine.GetDriver().userID : 0;
            BasePlayer player = BasePlayer.FindByID(getPlayerID);
            if (Interface_UI_Block(player, item.info.shortname, "", item.skin)) return;
            
            if (player != null)
            {
                if (item.MoveToContainer(player.inventory.containerMain)) 
                    return;
            }
        
            item.Drop(submarine.transform.position + new Vector3(0f, 1f, 0f), submarine.GetDropVelocity());
        }
        public Boolean AddImage(String url, String shortname, UInt64 skin = 0) => (Boolean)ImageLibrary?.Call("AddImage", url, shortname, skin);
        
        private void OnEntitySpawned(AutoTurret turret)
        {
            if (turret is NPCAutoTurret || !turret.OwnerID.IsSteamId()) return;
            
            NextTick(() =>
            {
                if (turret.IsValid() && turret.inventory != null)
                    turret.inventory.onItemAddedRemoved += (item, b) => ValidsItemTurret(turret, item, b);
            });
        }

        private String ShortnameValidation(String Shortname)
        {
            if (Shortname.Equals("wall.external.high.ice"))
                Shortname = Shortname.Replace("ice", "stone");
            else
            {
                Int32 IndexIce = Shortname.IndexOf(".ice", StringComparison.Ordinal);
                if (IndexIce > 0)
                    Shortname = Shortname.Substring(0, IndexIce);
                     
                Int32 IndexDiving = Shortname.IndexOf(".diver", StringComparison.Ordinal);
                if (IndexDiving > 0)
                    Shortname = Shortname.Substring(0, IndexDiving);
            }

            return Shortname;
        }
        public String GetLang(String LangKey, String userID = null, params object[] args)
        {
            sb.Clear();
            if (args != null)
            {
                sb.AppendFormat(lang.GetMessage(LangKey, this, userID), args);
                return sb.ToString();
            }
            return lang.GetMessage(LangKey, this, userID);
        }

        [ChatCommand("bpanel")]
        void ChatCommandBlockPanel(BasePlayer player, string cmd, string[] arg)
        {
            var General = config.GeneralSetting;
            if (!General.UsePanelButton) return;
            HideOrUnHigePanel(player, false);
        }


        public String FormatTime(TimeSpan time, String UserID)
        {
            Boolean UseFullTime = config.Interface.UseFormatTime;
            String Result = String.Empty;
            String Days = GetLang("TITLE_FORMAT_LOCKED_DAYS", UserID);
            String Hourse = GetLang("TITLE_FORMAT_LOCKED_HOURSE", UserID);
            String Minutes = GetLang("TITLE_FORMAT_LOCKED_MINUTES", UserID);
            String Seconds = GetLang("TITLE_FORMAT_LOCKED_SECONDS", UserID);

            if (!UseFullTime)
            {
                if (time.Seconds != 0)
                    Result = $"{Format(time.Seconds, Seconds, Seconds, Seconds)}";

                if (time.Minutes != 0)
                    Result = $"{Format(time.Minutes, Minutes, Minutes, Minutes)}";

                if (time.Hours != 0)
                    Result = $"{Format(time.Hours, Hourse, Hourse, Hourse)}";

                if (time.Days != 0)
                    Result = $"{Format(time.Days, Days, Days, Days)}";
            }
            else
            {
                if (time.Days != 0)
                    Result += $"{Format(time.Days, Days, Days, Days)} ";

                if (time.Hours != 0)
                    Result += $"{Format(time.Hours, Hourse, Hourse, Hourse)} ";

                if (time.Minutes != 0)
                    Result += $"{Format(time.Minutes, Minutes, Minutes, Minutes)} ";
                
                if (time.Days == 0 && time.Hours == 0 && time.Minutes == 0 && time.Seconds != 0)
                    Result = $"{Format(time.Seconds, Seconds, Seconds, Seconds)} ";
            }

            return Result;
        }
        
                public Boolean IsDuel(UInt64 userID)
        {
            Object obj = Interface.Oxide.RootPluginManager.GetPlugin("AimTraining")?.CallHook("IsArenaPlayer", userID);
            if (obj is Boolean)
                return (Boolean)obj;
            
            if (EventHelper)
            {
                if ((Boolean)EventHelper.CallHook("EMAtEvent", userID))
                    return true;
            }

            if (OneVSOne)
                if ((Boolean)OneVSOne.Call("IsEventPlayer", BasePlayer.FindByID(userID))) return true;

            if (Battles)
                if ((Boolean)Battles.Call("IsPlayerOnBattle", userID)) return true;
            
            if (Duel)
                 if ((Boolean)Duel.Call("IsPlayerOnActiveDuel", BasePlayer.FindByID(userID))) return true;
                 
            if (Duelist)
                 if ((Boolean)Duelist.Call("inEvent", BasePlayer.FindByID(userID))) return true;
             
            if (ArenaTournament)
                 if (ArenaTournament.Call<Boolean>("IsOnTournament", userID)) return true;
             
            if (XFarmRoom)
                 if (XFarmRoom.Call<Boolean>("API_PlayerInRoom", userID)) return true;
                     
            return false;
        }
        static readonly DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);

        private object OnWeaponReload(BaseProjectile weapon, BasePlayer player) => OnMagazineReload(weapon, player.inventory, player);
        
        
                private void OnServerInitialized()
        {
            if(!ImageLibrary)
            {
                PrintWarning("ImageLibrary не установлен! Плагин выгружен... ( https://umod.org/plugins/image-library )");
                Interface.Oxide.UnloadPlugin(this.Name);
                return;
            }
            
            if (!String.IsNullOrWhiteSpace(config.Interface.BackgroundUrl))
                if (!HasImage($"BACKGROUND_{config.Interface.BackgroundUrl}"))
                    AddImage(config.Interface.BackgroundUrl, $"BACKGROUND_{config.Interface.BackgroundUrl}");
            
            ServerMgr.Instance.InvokeRepeating(CheckAllUnlock, 0f, 60f);
            
            foreach (AutoTurret turrets in BaseNetworkable.serverEntities.Where(t => t is AutoTurret && !(t is NPCAutoTurret)))
                OnEntitySpawned(turrets);
		   		 		  						  	   		  	  			  			 		  						  		  
            foreach (StorageContainer turrets in BaseNetworkable.serverEntities.Where(t => t is AttackHelicopterTurret or AttackHelicopterRockets))
                OnEntitySpawned(turrets);
            
            foreach (BaseSubmarine submarine in BaseNetworkable.serverEntities.Where(t => t is BaseSubmarine))
                OnEntitySpawned(submarine);

            NextTick(() =>
            {
                foreach (BasePlayer player in BasePlayer.activePlayerList)
                    OnPlayerConnected(player);

                Subscribe(nameof(OnItemAddedToContainer));
            });
        }
        
        ItemContainer.CanAcceptResult? CanAcceptItem(ItemContainer container, Item item, int targetPos)
        {
            if (item == null || item.info == null || container == null) return null;
            
            if (container.availableSlots.Count != 0)
            {
                if (item.parent != null && item.parent.entityOwner != null)
                {
                    UInt64 NetID = item.parent.entityOwner.net.ID.Value;

                    if (ContainerGetPlayer.ContainsKey(NetID))
                    {
                        if (Interface_UI_Block(null, container.parent.info.shortname, item.info.shortname, 0, ContainerGetPlayer[NetID]))
                            return null;
                        else return ItemContainer.CanAcceptResult.CannotAccept;
                    }
                }

                BasePlayer ContainerPlayer = item.GetRootContainer() == null ? null : item.GetRootContainer().playerOwner;
                if (ContainerPlayer != null && ContainerPlayer.userID.IsSteamId() && !ContainerPlayer.IsNpc)
                {
                    if (IsDuel(ContainerPlayer.userID))
                        return null;
        
                    if (Interface_UI_Block(ContainerPlayer, container.parent.info.shortname, item.info.shortname))
                        return null;
                    else return ItemContainer.CanAcceptResult.CannotAccept;
                }
            }
        
            BasePlayer player = item.GetOwnerPlayer();
            if (player == null || !player.userID.IsSteamId() || player.IsNpc)
                return null;
            
            if(IQRecycler && container.entityOwner is Recycler && IQRecycler.Call<Boolean>("IsBlackList", container.entityOwner.OwnerID, item))
                return ItemContainer.CanAcceptResult.CannotAccept;
            
            if (IQBackpack && (Boolean)IQBackpack.CallHook("IsSaveItemBackpack", player, item))
                return null;
      
            if (container.availableSlots.Count == 0) return null;
            if (IsDuel(player.userID))
                return null;
           
            if (Interface_UI_Block(player, container.parent.info.shortname, item.info.shortname))
                return null;
            return ItemContainer.CanAcceptResult.CannotAccept;
        }
        
        
        void UI_Category_Show(BasePlayer player, CuiElementContainer container, Configuration.Interfaces Interface, Dictionary<String, Configuration.Blocks.BlockElement> CategoryList, AlignCategory Align)
        {
            if (CategoryList == null || CategoryList.Count == 0) return;
            var Block = config.Block;
            Single FadeIn = 0.2f;
            String TitleX = Align == AlignCategory.Left ? "0.08593746 0.8481482" : Align == AlignCategory.Middle ? "0.4072909 0.8481482" : "0.7161464 0.8481482";
            String TitleY = Align == AlignCategory.Left ? "0.273958 0.8851852" : Align == AlignCategory.Middle ? "0.5859324 0.8851852" : "0.9192606 0.8851852";
            String TitleText = Align == Interface.CategoryWeaponTools ? "TITLE_CATEGORY_WEAPON_TOOL" : Align == Interface.CategoryArmory ? "TITLE_CATEGORY_ATTIRE" : "TITLE_CATEGORY_BOOM";
            String PanelX = Align == AlignCategory.Left ? "0.05208334 0" : Align == AlignCategory.Middle ? "0.3687498 0" : "0.6864532 0";
            String PanelY = Align == AlignCategory.Left ? "0.3130208 0.8351786" : Align == AlignCategory.Middle ? "0.6296868 0.8351786" : "0.9473904 0.8351786";
            String LineX = Align == AlignCategory.Left ? "0.08593746 0.8444445" : Align == AlignCategory.Middle ? "0.4026018 0.8444445" : "0.7244719 0.8444445";
            String LineY = Align == AlignCategory.Left ? "0.273958 0.845" : Align == AlignCategory.Middle ? "0.5906243 0.845" : "0.9124945 0.845";

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = TitleX, AnchorMax = TitleY },
                Text = { FadeIn = FadeIn, Text = GetLang(TitleText, player.UserIDString), Color = HexToRustFormat(Interface.Labels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            }, IQWIPE_PARENT, IQWIPE_PARENT + "TITLE");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = LineX, AnchorMax = LineY },
                Image = { FadeIn = FadeIn, Color = HexToRustFormat(Interface.Lines) }
            }, IQWIPE_PARENT, IQWIPE_PARENT + "LINE");
		   		 		  						  	   		  	  			  			 		  						  		  
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = PanelX, AnchorMax = PanelY },
                Image = { FadeIn = FadeIn, Color = "0 0 0 0" }
            }, IQWIPE_PARENT, IQWIPE_PARENT + "BLOCK_PANEL");

                        Int32 ItemCount = 0;
            Single itemMinPosition = 219f;
            Single itemWidth = 0.2f; /// Ширина
            Single itemMargin = 0.062f; /// Расстояние между 
            Int32 itemCount = CategoryList.Count;
            Single itemMinHeight = 0.87f; // Сдвиг по вертикали
            Single itemHeight = 0.11f; /// Высота
            Int32 ItemTarget = 4;

            if (itemCount > ItemTarget)
            {
                itemMinPosition = 0.5f - ItemTarget / 2f * itemWidth - (ItemTarget - 1) / 2f * itemMargin;
                itemCount -= ItemTarget;
            }
            else itemMinPosition = 0.5f - itemCount / 2f * itemWidth - (itemCount - 1) / 2f * itemMargin;

            
            Int32 OldUnblockTime = 0;
            Int32 Count = 0;
            Int32 Items = CategoryList.Count;
            Boolean SkipElement = (Boolean)(CategoryList.Count(x => TimeUnblock(x.Value.TimeBlock) > 0) >= 1);
            foreach (var Item in CategoryList.OrderBy(i => i.Value.TimeBlock).Take(28))
            {
                String ColorBackground = ((SkipElement && TimeUnblock(Item.Value.TimeBlock) > 0) || (OldUnblockTime == Item.Value.TimeBlock)) ? Interface.NextBlockedPanel : TimeUnblock(Item.Value.TimeBlock) > 0 ? Interface.BlockedPanel : Item.Value.BlockMoreList.Count > 0 && TimeUnblock(Item.Value.BlockMoreList.Sum(i => Block.VaribleUnlockMore ? (i.Value + Item.Value.TimeBlock) : i.Value)) > 0 ? Interface.UnblockedMorePanel : Interface.UnblockedPanel;
                String LineColor = TimeUnblock(Item.Value.TimeBlock) > 0 ? Interface.Lines : Item.Value.BlockMoreList.Count > 0 && TimeUnblock(Item.Value.BlockMoreList.Sum(i => Block.VaribleUnlockMore ? (i.Value + Item.Value.TimeBlock) : i.Value)) > 0 ? Interface.PreBlockedMoreLine : Interface.LinesUnblock;
                container.Add(new CuiElement
                {
                    Parent = IQWIPE_PARENT + "BLOCK_PANEL",
                    Name = IQWIPE_PARENT + $"PANEL_ITEM_{ItemCount}",
                    Components =
                    {
                        new CuiImageComponent { FadeIn = FadeIn, Color = HexToRustFormat(ColorBackground), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                        new CuiRectTransformComponent{ AnchorMin = $"{itemMinPosition} {itemMinHeight}", AnchorMax = $"{itemMinPosition + itemWidth} {itemMinHeight + itemHeight}", OffsetMax = "0 1", OffsetMin = "0 1" },
                        new CuiOutlineComponent { Color = HexToRustFormat(LineColor), Distance = "-1.35 1.35", UseGraphicAlpha = true }
                    }
                });

                if ((SkipElement && TimeUnblock(Item.Value.TimeBlock) > 0) || (OldUnblockTime == Item.Value.TimeBlock))
                {
                    if (Interface.UseProgressiveBackground)
                    {
                        if (Interface.ShowUnblockedItemCompareTime)
                            OldUnblockTime = Item.Value.TimeBlock;
                        Single ProgressiveX = (Single)((Item.Value.TimeBlock - TimeUnblock(Item.Value.TimeBlock)) / Item.Value.TimeBlock * 1f) >= 1 ? 1 : (Single)((Item.Value.TimeBlock - TimeUnblock(Item.Value.TimeBlock)) / Item.Value.TimeBlock * 1f);
                        container.Add(new CuiPanel
                        {
                            RectTransform = { AnchorMin = "0 0", AnchorMax = $"{ProgressiveX} 1", OffsetMin = "0 0", OffsetMax = "0 -0.03" },
                            Image = { FadeIn = FadeIn, Color = HexToRustFormat(Interface.UnblockedPanel), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
                        }, IQWIPE_PARENT + $"PANEL_ITEM_{ItemCount}");
                    }
                }

                // String PNG = Item.Value.SkinID == 0 ? GetImage($"{Item.Key}_128px") : GetImage($"{Item.Key}_128px_{Item.Value.SkinID}", Item.Value.SkinID);
                // container.Add(new CuiElement
                // {
                //     Parent = IQWIPE_PARENT + $"PANEL_ITEM_{ItemCount}",
                //     Name = IQWIPE_PARENT + $"IMG_{ItemCount}",
                //     Components =
                //     {
                //         new CuiRawImageComponent { FadeIn = FadeIn, Png = PNG },
                //         new CuiRectTransformComponent{ AnchorMin = "0.0343017 0.04031476", AnchorMax = $"0.9481039 0.9574757"},
                //     }
                // });
                
                container.Add(new CuiElement
                {
                    Parent = IQWIPE_PARENT + $"PANEL_ITEM_{ItemCount}",
                    Name = IQWIPE_PARENT + $"IMG_{ItemCount}",
                    Components = {
                        new CuiImageComponent() {FadeIn = FadeIn, Color = "1 1 1 1", ItemId = ItemManager.FindItemDefinition(Item.Key).itemid, SkinId = Item.Value.SkinID},
                        new CuiRectTransformComponent{ AnchorMin = "0.03992017 0.04031476", AnchorMax = $"0.9481039 0.95732"},
                    }
                });

                if (!config.GeneralSetting.UseShowAllTime)
                {
                    if ((SkipElement && TimeUnblock(Item.Value.TimeBlock) > 0) || (OldUnblockTime == Item.Value.TimeBlock))
                    {
                        if (Interface.ShowUnblockedItemCompareTime)
                            OldUnblockTime = Item.Value.TimeBlock;
                        String TimeLeft = FormatTime(TimeSpan.FromSeconds(TimeUnblock(Item.Value.TimeBlock)), player.UserIDString);
                        container.Add(new CuiLabel
                        {
                            RectTransform = { AnchorMin = "0.06480032 0.7686631", AnchorMax = "0.9430439 0.980315" },
                            Text = { FadeIn = FadeIn, Text = TimeLeft, FontSize = 12, Color = HexToRustFormat(Interface.Labels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
                        }, IQWIPE_PARENT + $"PANEL_ITEM_{ItemCount}", IQWIPE_PARENT + "UNLOCK_TIME" + itemCount);
                    }
                }
                else
                {
                    if (TimeUnblock(Item.Value.TimeBlock) > 0)
                    {
                        String TimeLeft = FormatTime(TimeSpan.FromSeconds(TimeUnblock(Item.Value.TimeBlock)), player.UserIDString);
                        container.Add(new CuiLabel
                        {
                            RectTransform = { AnchorMin = "0.06480032 0.7686631", AnchorMax = "0.9430439 0.980315" },
                            Text = { FadeIn = FadeIn, Text = TimeLeft, FontSize = 12, Color = HexToRustFormat(Interface.Labels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
                        }, IQWIPE_PARENT + $"PANEL_ITEM_{ItemCount}", IQWIPE_PARENT + "UNLOCK_TIME" + itemCount);
                    }
                }

                
                if ((OldUnblockTime != Item.Value.TimeBlock) && (!SkipElement && TimeUnblock(Item.Value.TimeBlock) > 0))
                {
                    container.Add(new CuiPanel
                    {
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 -1", OffsetMax = "0 -1" },
                        Image = { FadeIn = FadeIn, Color = HexToRustFormat(Interface.BlurBlockedPanel), Material = "assets/content/ui/uibackgroundblur.mat" }
                    }, IQWIPE_PARENT + $"IMG_{ItemCount}", IQWIPE_PARENT + $"IMG_{ItemCount}" + "BLUR");

                    container.Add(new CuiElement
                    {
                        Parent = IQWIPE_PARENT + $"IMG_{ItemCount}" + "BLUR",
                        Name = IQWIPE_PARENT + $"IMG_{ItemCount}" + "BLOCKED",
                        Components =
                    {
                        new CuiImageComponent { FadeIn = FadeIn, Sprite = Interface.SpriteBlocked, Color = HexToRustFormat(Interface.Labels) },
                        new CuiRectTransformComponent{ AnchorMin = "0.33 0.3399995", AnchorMax = $"0.65 0.6599998"},
                    }
                    });
                }
                else if (Item.Value.BlockMoreList != null && Item.Value.BlockMoreList.Count != 0 && TimeUnblock(Item.Value.BlockMoreList.Sum(i => Block.VaribleUnlockMore ? (i.Value + Item.Value.TimeBlock) : i.Value)) > 0)
                {
                    container.Add(new CuiButton
                    {
                        FadeOut = 0.2f,
                        RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1" },
                        Button = { Command = $"iqwb popup {Item.Key}", Color = "0 0 0 0" },
                        Text = { Text = "" }
                    }, IQWIPE_PARENT + $"PANEL_ITEM_{ItemCount}", IQWIPE_PARENT + $"PANEL_ITEM_{ItemCount}" + "BUTTON");
                }
		   		 		  						  	   		  	  			  			 		  						  		  
                
                Count++;

                
                if (Count != 4 && Items - Count != 0)
                {
                    container.Add(new CuiPanel
                    {
                        RectTransform = { AnchorMin = "1 0.5", AnchorMax = "1 0.5", OffsetMin = "1.5 -1", OffsetMax = $"20 1" },
                        Image = { FadeIn = FadeIn, Color = HexToRustFormat(Interface.Lines) }
                    }, IQWIPE_PARENT + $"PANEL_ITEM_{ItemCount}", IQWIPE_PARENT + $"PANEL_ITEM_{ItemCount}" + $"LINE_{ItemCount}");

                    if (TimeUnblock(Item.Value.TimeBlock) < 0 || (SkipElement && TimeUnblock(Item.Value.TimeBlock) > 0) || (OldUnblockTime == Item.Value.TimeBlock))
                    {
                        Single ProgressiveX = (Single)((Item.Value.TimeBlock - TimeUnblock(Item.Value.TimeBlock)) / Item.Value.TimeBlock * 1f) >= 1 ? 1 : (Single)((Item.Value.TimeBlock - TimeUnblock(Item.Value.TimeBlock)) / Item.Value.TimeBlock * 1f);
                        container.Add(new CuiPanel
                        {
                            RectTransform = { AnchorMin = "0 0", AnchorMax = $"{ProgressiveX - 0.04} 1", OffsetMin = "0 0", OffsetMax = "0 -0.1" },
                            Image = { FadeIn = FadeIn, Color = HexToRustFormat(Interface.LinesUnblock) }
                        }, IQWIPE_PARENT + $"PANEL_ITEM_{ItemCount}" + $"LINE_{ItemCount}", IQWIPE_PARENT + $"PANEL_ITEM_{ItemCount}" + $"LINE_{ItemCount}" + "PROGRESSIVE");
                    }
                }
                if (SkipElement && TimeUnblock(Item.Value.TimeBlock) > 0)
                    SkipElement = false;
                if (Count == 4)
                {
                    Items -= 4;
                    if (Items != 0)
                    {
                        Int32 SizeLine = Items == 1 ? -131 : Items == 2 ? -161 : Items == 3 ? -220 : -243; // 

                        container.Add(new CuiPanel
                        {
                            RectTransform = { AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "-1 -10", OffsetMax = "1 0" },
                            Image = { FadeIn = FadeIn, Color = HexToRustFormat(LineColor) }
                        }, IQWIPE_PARENT + $"PANEL_ITEM_{ItemCount}", IQWIPE_PARENT + $"PANEL_ITEM_{ItemCount}" + $"LINE_{ItemCount}");

                        container.Add(new CuiPanel
                        {
                            RectTransform = { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = $"{SizeLine} -1", OffsetMax = "2 1" },
                            Image = { FadeIn = FadeIn, Color = HexToRustFormat(LineColor) }
                        }, IQWIPE_PARENT + $"PANEL_ITEM_{ItemCount}" + $"LINE_{ItemCount}", IQWIPE_PARENT + $"PANEL_ITEM_{ItemCount}" + $"LINE_{ItemCount}" + "LEFT");

                        container.Add(new CuiPanel
                        {
                            RectTransform = { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = "-1 -20", OffsetMax = "1 2" },
                            Image = { FadeIn = FadeIn, Color = HexToRustFormat(LineColor) }
                        }, IQWIPE_PARENT + $"PANEL_ITEM_{ItemCount}" + $"LINE_{ItemCount}" + "LEFT", IQWIPE_PARENT + $"PANEL_ITEM_{ItemCount}" + $"LINE_{ItemCount}" + "LEFT" + "DOWN");

                    }
                    Count = 0;
                }
                
                                ItemCount++;
                itemMinPosition += (itemWidth + itemMargin);
                if (ItemCount % ItemTarget == 0)
                {
                    itemMinHeight -= (itemHeight + (itemMargin * 0.5f));
                    if (itemCount > ItemTarget)
                    {
                        itemMinPosition = 0.5f - ItemTarget / 2f * itemWidth - (ItemTarget - 1) / 2f * itemMargin;
                        itemCount -= ItemTarget;
                    }
                    else itemMinPosition = 0.5f - itemCount / 2f * itemWidth - (itemCount - 1) / 2f * itemMargin;
                }
                            }
        }
        void OnPlayerConnected(BasePlayer player)
        {
            RegisteredUser(player);

            if (config.Interface.ButtonIsBlock)
            {
                if (!IsUnlockedAll)
                    Interface_Button_Panel(player);
                else if (config.GeneralSetting.AlertConnectedUserUnlocked)
                    SendChat(GetLang("CHAT_ALERT_ALL_USERS_ALL_UNLOCK", player.UserIDString), player);
            }
            else
            {
                Interface_Button_Panel(player);
                if (config.GeneralSetting.AlertConnectedUserUnlocked && IsUnlockedAll)
                    SendChat(GetLang("CHAT_ALERT_ALL_USERS_ALL_UNLOCK", player.UserIDString), player);
            }
        }

                
    }
}

// --- End of file: IQWipeBlock.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/RadStorm.cs ---
// --- Original Local Path: RadStorm.cs ---

// Plugin formatted by redBDGR's Plugin Formatting Tool
 using ConVar; using Network; using Oxide.Core.Plugins; using Rust; using System; using System.Collections; using System.Collections.Generic; using UnityEngine; namespace Oxide.Plugins { [Info("RadStorm", "redBDGR", "1.0.8")] [Description("Dynamic radiation storm events")] class RadStorm : RustPlugin { private static RadStorm plugin; private bool Changed; [PluginReference] Plugin GUIAnnouncements; private const string permissionNameADMIN = "radstorm.admin"; private const string permissionNameEXEMPT = "radstorm.exempt"; private float stormLength = 120f; private float radiationAmount = 50f; private bool hurtSleepers = true; private float minStormTime = 3600; private float maxStormTime = 7200; private bool randomEventEnabled = true; private bool deathAnnouncementsEnabled = true; private float stormChargeTime = 100; private bool scaleRadiationBasedOnClothing; private bool useChatAnnouncements = true; private bool useGUIAnnouncements = false; private string GUIBannerColour = "Grey"; private string GUITextColour = "Yellow"; private bool announceDeaths = true; private float weatherRainAmount = 1f; private float weatherFogAmount = 1f; private float weatherWindAmount = 1f; private float gatherRateBonus = 1f; private float pickupRateBonus = 1f; private float bonusRateBonus = 1f; RadiationStorm storm = null; protected override void LoadDefaultConfig() { Config.Clear(); LoadVariables(); } private void LoadVariables() { stormLength = Convert.ToSingle(GetConfig("Storm Settings", "Storm Length", 300f)); radiationAmount = Convert.ToSingle(GetConfig("Storm Settings", "Radiation Amount", 50f)); hurtSleepers = Convert.ToBoolean(GetConfig("Storm Settings", "Hurt Sleepers", true)); minStormTime = Convert.ToSingle(GetConfig("Storm Settings", "Min Storm Inbound Time", 3600f)); maxStormTime = Convert.ToSingle(GetConfig("Storm Settings", "Max Storm Inbound Time", 7200f)); randomEventEnabled = Convert.ToBoolean(GetConfig("Storm Settings", "Random Event Enabled", true)); deathAnnouncementsEnabled = Convert.ToBoolean(GetConfig("Storm Settings", "Death Announcements Enabled", true)); stormChargeTime = Convert.ToSingle(GetConfig("Storm Settings", "Storm Buildup Time", 100f)); scaleRadiationBasedOnClothing = Convert.ToBoolean(GetConfig("Storm Settings", "Scale Radiation Based On Radiation Protection", true)); useChatAnnouncements = Convert.ToBoolean(GetConfig("Notification Settings", "Use chat announcements", true)); useGUIAnnouncements = Convert.ToBoolean(GetConfig("Notification Settings", "Use GUI announcements", false)); GUIBannerColour = Convert.ToString(GetConfig("Notification Settings", "GUIAnnouncements Banner Colour", "Grey")); GUITextColour = Convert.ToString(GetConfig("Notification Settings", "GUIAnnouncements Text Colour", "Yellow")); weatherRainAmount = Convert.ToSingle(GetConfig("Storm Settings", "Maximum rain amount", 1f)); weatherFogAmount = Convert.ToSingle(GetConfig("Storm Settings", "Maximum fog amount", 1f)); weatherWindAmount = Convert.ToSingle(GetConfig("Storm Settings", "Maximum wind amount", 1f)); gatherRateBonus = Convert.ToSingle(GetConfig("Bonus Settings", "Gather Rate Bonus", 1f)); pickupRateBonus = Convert.ToSingle(GetConfig("Bonus Settings", "Collectibles Rate Bonus", 1f)); bonusRateBonus = Convert.ToSingle(GetConfig("Bonus Settings", "Gather Finish Bonus Rate Bonus", 1f)); if (!Changed) return; SaveConfig(); Changed = false; } private void LoadLang() { lang.RegisterMessages(new Dictionary<string, string> { ["Killed by storm"] = "{0} got caught in the storm", ["RadStorm building"] = "A radiation storm is building!", ["RadStorm fullstrength"] = "The storm is at full strength... Players stuck outside will be riddled with radiation", ["RadStorm receding"] = "The radiation storm is receeding", ["RadStorm receded"] = "The radiation storm has receded", ["5 minute warning"] = "Weather forcasts have predicted a radiation storm. Its ETA is 5 minutes", ["60 second warning"] = "A radiation storm will be hitting the island in 60 seconds, make sure you're inside or wearing a hazmat suit!", }, this); } private void Init() { plugin = this; permission.RegisterPermission(permissionNameADMIN, this); permission.RegisterPermission(permissionNameEXEMPT, this); LoadVariables(); LoadLang(); if (randomEventEnabled) if (maxStormTime > 0) RandomStorm(); } private void Loaded() { if (!GUIAnnouncements) { PrintError("GUIAnnouncements.cs was not found... disabling features"); useGUIAnnouncements = false; } } private void Unload() { if (storm) storm.DestroyThis(); } private object OnPlayerDie(BasePlayer player, HitInfo info) { if (!deathAnnouncementsEnabled) return null; if (player == null || info == null || info.damageTypes == null) return null; if (!storm) return null; if (info.damageTypes.GetMajorityDamageType() != DamageType.Radiation) return null; rust.BroadcastChat(string.Format(msg("Killed by storm"), player.displayName)); return null; } private void OnPlayerMetabolize(PlayerMetabolism metabolism, BaseCombatEntity entity, float delta) { if (storm == null) return; if (storm.isFullStrength == false) return; BasePlayer player = entity.GetComponent<BasePlayer>(); if (player == null) return; if (!storm.outsidePlayerCache.Contains(player.UserIDString)) return; float radAmount = radiationAmount; if (scaleRadiationBasedOnClothing) radAmount = Mathf.Clamp(radAmount - player.RadiationProtection(), 0f, radAmount); metabolism.radiation_level.MoveTowards(radAmount, 0.2f); metabolism.radiation_poison.MoveTowards(radAmount, 0.2f); } private object OnCollectiblePickup(Item item, BasePlayer player) { if (!storm) return null; item.amount = Mathf.RoundToInt(item.amount * pickupRateBonus); return null; } private object OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item) { if (!storm) return null; item.amount = Mathf.RoundToInt(item.amount * bonusRateBonus); return null; } private object OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item) { if (!storm) return null; item.amount = Mathf.RoundToInt(item.amount * gatherRateBonus); return null; } private class RadiationStorm : FacepunchBehaviour { public GameObject parentObj; public List<string> outsidePlayerCache = new List<string>(); private bool radiationWasFalse = false; public bool isFullStrength = false; private float originalRainAmount = 0f; private float originalFogAmount = 0f; private float originalWindAmount = 0f; public float rainAmount = 0f; private float fogAmount = 0f; private float windAmount = 0f; private float maxRain = plugin.weatherRainAmount; private float maxFog = plugin.weatherFogAmount; private float maxWind = plugin.weatherWindAmount; Coroutine onlineDamage; Coroutine offlineDamage; private void Awake() { parentObj = gameObject; rainAmount = Climate.Instance.Overrides.Rain; if (rainAmount < 0) { originalRainAmount = -1f; rainAmount = 0f; } else originalFogAmount = rainAmount; fogAmount = Climate.Instance.Overrides.Fog; if (fogAmount < 0) { originalFogAmount = -1f; fogAmount = 0f; } else originalFogAmount = fogAmount; windAmount = Climate.Instance.Overrides.Wind; if (windAmount < 0) { originalWindAmount = -1f; windAmount = 0f; } else originalWindAmount = windAmount; StartStorm(); } private void OnDestroy() { if (radiationWasFalse) ConVar.Server.radiation = false; } public void DestroyThis() { CancelInvoke(StormCycle); CancelInvoke(IncreaseStormSeverity); CancelInvoke(DecreaseStormSeverity); StopCoroutine(onlineDamage); StopCoroutine(offlineDamage); ConsoleSystem.Run(ConsoleSystem.Option.Server.Quiet(), $"weather.rain {originalRainAmount}"); ConsoleSystem.Run(ConsoleSystem.Option.Server.Quiet(), $"weather.fog {originalFogAmount}"); ConsoleSystem.Run(ConsoleSystem.Option.Server.Quiet(), $"weather.wind {originalWindAmount}"); Destroy(parentObj); } public void StartStorm() { plugin.SendNotificaion(plugin.msg("RadStorm building")); float buildTimePeriod = plugin.stormChargeTime / 20.0f; if (ConVar.Server.radiation == false) { ConVar.Server.radiation = true; radiationWasFalse = true; } InvokeRepeating(IncreaseStormSeverity, buildTimePeriod, buildTimePeriod); Invoke(StormCycle, 5f); } public void StopStorm() { StopCoroutine(offlineDamage); StopCoroutine(onlineDamage); CancelInvoke(IncreaseStormSeverity); InvokeRepeating(DecreaseStormSeverity, 5f, 5f); if (radiationWasFalse) { ConVar.Server.radiation = false; } } private void StormCycle() { onlineDamage = StartCoroutine(CacheOutdoorPlayers()); if (plugin.hurtSleepers) offlineDamage = StartCoroutine(DamageOfflinePlayers()); } private void IncreaseStormSeverity() { if (rainAmount < maxRain) rainAmount += 0.05f * maxRain; if (fogAmount < maxFog) fogAmount += 0.05f * maxFog; if (windAmount < maxWind) windAmount += 0.05f * maxWind; ConsoleSystem.Run(ConsoleSystem.Option.Server.Quiet(), $"weather.rain {rainAmount}"); ConsoleSystem.Run(ConsoleSystem.Option.Server.Quiet(), $"weather.fog {fogAmount}"); ConsoleSystem.Run(ConsoleSystem.Option.Server.Quiet(), $"weather.wind {windAmount}"); if (rainAmount >= maxRain && fogAmount >= maxFog && windAmount >= maxWind) { rainAmount = maxRain; fogAmount = maxFog; windAmount = maxWind; plugin.SendNotificaion(plugin.msg("RadStorm fullstrength")); this.isFullStrength = true; InvokeRepeating(DecreaseStormSeverity, plugin.stormLength, 5f); CancelInvoke(IncreaseStormSeverity); } } private void DecreaseStormSeverity() { if (rainAmount == maxRain) { plugin.SendNotificaion(plugin.msg("RadStorm receding")); this.isFullStrength = false; } if (rainAmount > 0f) rainAmount -= 0.05f * maxRain; if (fogAmount > 0f) fogAmount -= 0.05f * maxFog; if (windAmount > 0f) windAmount -= 0.05f * maxWind; ConsoleSystem.Run(ConsoleSystem.Option.Server.Quiet(), $"weather.rain {rainAmount}"); ConsoleSystem.Run(ConsoleSystem.Option.Server.Quiet(), $"weather.fog {fogAmount}"); ConsoleSystem.Run(ConsoleSystem.Option.Server.Quiet(), $"weather.wind {windAmount}"); if (rainAmount <= 0f && fogAmount <= 0f && windAmount <= 0f) { plugin.SendNotificaion(plugin.msg("RadStorm receded")); CancelInvoke(DecreaseStormSeverity); DestroyThis(); } } private IEnumerator CacheOutdoorPlayers() { while (true) { yield return new WaitForSeconds(2f); foreach (BasePlayer player in BasePlayer.activePlayerList) { yield return new WaitForSeconds(0.1f); /* if (TerrainMeta.BiomeMap.GetBiome(player.transform.position, 1) >= 0.5f) { UnCachePlayer(player.UserIDString); yield return new WaitForSeconds(0.1f); continue; } */ if (plugin.permission.UserHasPermission(player.UserIDString, permissionNameEXEMPT)) { UnCachePlayer(player.UserIDString); continue; } if (player.inventory.containerWear.FindItemsByItemName("hazmatsuit") != null) { UnCachePlayer(player.UserIDString); continue; } if (player.IsHeadUnderwater()) { UnCachePlayer(player.UserIDString); continue; } if (!player.IsOutside()) { UnCachePlayer(player.UserIDString); continue; } CachePlayer(player.UserIDString); } } } private IEnumerator DamageOfflinePlayers() { while (true) { yield return new WaitForSeconds(2f); List<string> hurtList = new List<string>(); foreach (BasePlayer player in BasePlayer.sleepingPlayerList) { /* if (TerrainMeta.BiomeMap.GetBiome(player.transform.position, 1) >= 0.5f) { UnCachePlayer(player.UserIDString); yield return new WaitForSeconds(0.1f); continue; } */ if (plugin.permission.UserHasPermission(player.UserIDString, permissionNameEXEMPT)) { UnCachePlayer(player.UserIDString); continue; } if (player.inventory.containerWear.FindItemsByItemName("hazmatsuit") != null) { yield return new WaitForSeconds(0.05f); continue; } if (!player.IsOutside()) { yield return new WaitForSeconds(0.05f); continue; } player.metabolism.radiation_level.value = 25f; player.metabolism.radiation_poison.value = 25f; player.UpdateRadiation(25f); hurtList.Add(player.UserIDString); yield return new WaitForSeconds(0.1f); } for (int i = 0; i < hurtList.Count; i++) { BasePlayer player = BasePlayer.Find(hurtList[i]); if (player == null) { yield return new WaitForSeconds(0.05f); continue; } player.Hurt(2.5f, DamageType.Radiation); yield return new WaitForSeconds(0.05f); } } } private void UnCachePlayer(string id) { if (outsidePlayerCache.Contains(id)) outsidePlayerCache.Remove(id); } private void CachePlayer(string id) { if (!outsidePlayerCache.Contains(id)) outsidePlayerCache.Add(id); } } [ChatCommand("radstorm")] private void RadstormChatCMD(BasePlayer player, string command, string[] args) { if (!permission.UserHasPermission(player.UserIDString, permissionNameADMIN)) { player.ChatMessage("You are not allowed to use this comand"); return; } if (args.Length < 1) { player.ChatMessage("Invalid Syntax! /radstorm <start/stop/forcestop>"); return; } switch (args[0]) { case "start": if (storm) storm.DestroyThis(); StartStorm(); break; case "stop": if (storm) storm.StopStorm(); break; case "forcestop": if (storm) storm.DestroyThis(); break; default: player.ChatMessage("Invalid Syntax! /radstorm <start/stop/forcestop>"); break; } } [ConsoleCommand("radstorm")] private void RadStormCMD(ConsoleSystem.Arg arg) { if (arg.Connection != null) { BasePlayer player = arg.Player(); if (player) { if (!permission.UserHasPermission(player.UserIDString, permissionNameADMIN)) return; } } if (arg.Args.Length < 1) { arg.ReplyWith("Invalid Syntax! radstorm <start/stop/forcestop>"); return; } switch (arg.Args[0]) { case "start": if (storm) storm.DestroyThis(); StartStorm(); break; case "stop": if (storm) storm.StopStorm(); break; case "forcestop": if (storm) storm.DestroyThis(); break; default: arg.ReplyWith("Invalid Syntax! radstorm <start/stop/forcestop>"); break; } } private void StartStorm() { GameObject stormObj = new GameObject(); storm = stormObj.AddComponent<RadiationStorm>(); } private void StopStorm() { if (storm == null) return; storm.StopStorm(); } private void RandomStorm() { float randomTime = UnityEngine.Random.Range(minStormTime, maxStormTime); timer.Once(randomTime - 300f, () => { SendNotificaion(msg("5 minute warning")); timer.Once(240f, () => { SendNotificaion(msg("60 second warning")); timer.Once(60, () => { StartStorm(); timer.Once(stormLength + 200f, () => { RandomStorm(); }); }); }); }); } private void SendNotificaion(string text, BasePlayer player = null) { if (useChatAnnouncements) Server.Broadcast(text); if (useGUIAnnouncements) { if (player != null) GUIAnnouncements?.Call("CreateAnnouncement", text, GUIBannerColour, GUITextColour, player); else foreach (BasePlayer _player in BasePlayer.activePlayerList) if (_player.IsConnected) GUIAnnouncements?.Call("CreateAnnouncement", text, GUIBannerColour, GUITextColour, _player); } } private object GetConfig(string menu, string datavalue, object defaultValue) { var data = Config[menu] as Dictionary<string, object>; if (data == null) { data = new Dictionary<string, object>(); Config[menu] = data; Changed = true; } object value; if (!data.TryGetValue(datavalue, out value)) { value = defaultValue; data[datavalue] = value; Changed = true; } return value; } private string msg(string key, string id = null) => lang.GetMessage(key, this, id); } } 
// If you wish to view this code in a formatted state, please contact redBDGR on discord @ redBDGR #0001


// --- End of file: RadStorm.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/InventoryGuardian.cs ---
// --- Original Local Path: InventoryGuardian.cs ---

using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Configuration;

namespace Oxide.Plugins
{
    [Info("InventoryGuardian", "k1lly0u", "0.2.3", ResourceId = 773)]
    class InventoryGuardian : RustPlugin
    {
        #region Fields
        IGData igData;
        private DynamicConfigFile Inventory_Data;

        private Dictionary<ulong, PlayerInfo> cachedInventories = new Dictionary<ulong, PlayerInfo>();
        private bool isNewSave;
        #endregion

        #region Oxide Hooks
        void Loaded() => Inventory_Data = Interface.Oxide.DataFileSystem.GetFile("Inventory-Guardian");
        void OnServerInitialized()
        {
            LoadVariables();
            LoadData();
            RegisterPermisions();
            CheckProtocol();
            SaveLoop();
            foreach (var player in BasePlayer.activePlayerList)
                OnPlayerInit(player);
        }
        void OnNewSave(string filename) => isNewSave = true;
        void OnPlayerInit(BasePlayer player)
        {
            if (igData.IsActivated)
                if (cachedInventories.ContainsKey(player.userID))
                    if (cachedInventories[player.userID].RestoreOnce)
                    {
                        RestoreInventory(player);
                        RemoveInventory(player);
                    }
        }       
        
        void OnPlayerDisconnected(BasePlayer player)
        {
            if (igData.IsActivated)
                SaveInventory(player);
        }
        void Unload() => SaveData();

        #endregion

        #region Functions
        private void CheckProtocol()
        {
            if (igData.AutoRestore && isNewSave)
            {
                foreach (var entry in cachedInventories)
                    entry.Value.RestoreOnce = true;
                Puts("Map wipe detected! Activating Auto Restore for all saved inventories");
            }
        }
        private void RestoreAll()
        {
            foreach (var player in BasePlayer.activePlayerList)
                RestoreInventory(player);
            foreach (var player in BasePlayer.sleepingPlayerList)
                RestoreInventory(player);
            SaveData();
        }
        private void SaveAll()
        {
            foreach (var player in BasePlayer.activePlayerList)
                SaveInventory(player);
            foreach (var player in BasePlayer.sleepingPlayerList)
                SaveInventory(player);
            SaveData();
        }
        private void RemoveAll()
        {
            cachedInventories.Clear();
            SaveData();
        }
        private BasePlayer FindPlayer(BasePlayer player, string arg)
        {
            var foundPlayers = new List<BasePlayer>();
            ulong steamid;
            ulong.TryParse(arg, out steamid);
            string lowerarg = arg.ToLower();

            foreach (var p in BasePlayer.activePlayerList)
            {
                if (p != null)
                {
                    if (steamid != 0L)
                        if (p.userID == steamid) return p;
                    string lowername = p.displayName.ToLower();
                    if (lowername.Contains(lowerarg))
                    {
                        foundPlayers.Add(p);
                    }
                }
            }
            if (foundPlayers.Count == 0)
            {
                foreach (var sleeper in BasePlayer.sleepingPlayerList)
                {
                    if (sleeper != null)
                    {
                        if (steamid != 0L)
                            if (sleeper.userID == steamid)
                            {
                                foundPlayers.Clear();
                                foundPlayers.Add(sleeper);
                                return foundPlayers[0];
                            }
                        string lowername = player.displayName.ToLower();
                        if (lowername.Contains(lowerarg))
                        {
                            foundPlayers.Add(sleeper);
                        }
                    }
                }
            }
            if (foundPlayers.Count == 0)
            {
                if (player != null)
                    SendReply(player, configData.Messages_MainColor + "No players found.</color>");
                return null;
            }
            if (foundPlayers.Count > 1)
            {
                if (player != null)
                    SendReply(player, configData.Messages_MainColor + "Multiple players found with that name.</color>");
                return null;
            }

            return foundPlayers[0];
        }
        #endregion

        #region Messaging
        private void MSG(BasePlayer player, string message, string key = "", bool title = false)
        {
            message = configData.Messages_MainColor + key + "</color>" + configData.Messages_MsgColor + message + "</color>";
            if (title)
                message = configData.Messages_MainColor + Title + ": </color>" + message;
            SendReply(player, message);
        }
        #endregion

        #region Class Saving
        private bool SaveInventory(BasePlayer player)
        {
            List<SavedItem> items = GetPlayerItems(player);
            if (!cachedInventories.ContainsKey(player.userID))
                cachedInventories.Add(player.userID, new PlayerInfo {  });
            cachedInventories[player.userID].Items = items;
            return true;  
        }
        private List<SavedItem> GetPlayerItems(BasePlayer player)
        {
            List<SavedItem> kititems = new List<SavedItem>();
            foreach (Item item in player.inventory.containerBelt.itemList)
            {
                if (item != null)
                {
                    var iteminfo = ProcessItem(item, "belt");
                    kititems.Add(iteminfo);
                }
            }
            foreach (Item item in player.inventory.containerWear.itemList)
            {
                if (item != null)
                {
                    var iteminfo = ProcessItem(item, "wear");
                    kititems.Add(iteminfo);
                }
            }
            foreach (Item item in player.inventory.containerMain.itemList)
            {
                if (item != null)
                {
                    var iteminfo = ProcessItem(item, "main");
                    kititems.Add(iteminfo);
                }
            }
            return kititems;
        }
        private SavedItem ProcessItem(Item item, string container)
        {
            SavedItem iItem = new SavedItem();
            iItem.shortname = item.info?.shortname;
            iItem.amount = item.amount;
            iItem.mods = new List<SavedItem>();
            iItem.container = container;
            iItem.skinid = item.skin;
            iItem.itemid = item.info.itemid;
            iItem.weapon = false;
            if (item.hasCondition)
                iItem.condition = item.condition;
            if (item.info.category.ToString() == "Weapon")
            {
                BaseProjectile weapon = item.GetHeldEntity() as BaseProjectile;
                if (weapon != null)
                {
                    if (weapon.primaryMagazine != null)
                    {
                        iItem.ammoamount = weapon.primaryMagazine.contents;
                        iItem.ammotype = weapon.primaryMagazine.ammoType.shortname;                        
                        iItem.weapon = true;
                        if (item.contents != null)
                            foreach (var mod in item.contents.itemList)
                                if (mod.info.itemid != 0)
                                    iItem.mods.Add(ProcessItem(mod, "none"));
                    }
                }
            }
            return iItem;
        }
        private bool RemoveInventory(BasePlayer player)
        {
            if (cachedInventories.ContainsKey(player.userID))
            {
                cachedInventories.Remove(player.userID);
                return true;
            }
            return false;
        }
        #endregion        

        #region Give
        private bool RestoreInventory(BasePlayer player)
        {
            if (!cachedInventories.ContainsKey(player.userID))
                return false;
            
            player.inventory.Strip();
            foreach (SavedItem kitem in cachedInventories[player.userID].Items)
            {
                if (kitem.weapon)
                    GiveItem(player, BuildWeapon(kitem), kitem.container);
                else GiveItem(player, BuildItem(kitem), kitem.container);
            }
            return true;
        }
        private void GiveItem(BasePlayer player, Item item, string container)
        {
            if (item == null) return;
            ItemContainer cont;
            switch (container)
            {
                case "wear":
                    cont = player.inventory.containerWear;
                    break;
                case "belt":
                    cont = player.inventory.containerBelt;
                    break;
                default:
                    cont = player.inventory.containerMain;
                    break;
            }
            player.inventory.GiveItem(item, cont);
        }
        private Item BuildItem(SavedItem sItem)
        {
            if (sItem.amount < 1) sItem.amount = 1;
            Item item = ItemManager.CreateByItemID(sItem.itemid, sItem.amount, sItem.skinid);
            if (igData.KeepCondition && item.hasCondition)
                item.condition = sItem.condition;
            return item;
        }
        private Item BuildWeapon(SavedItem sItem)
        {
            Item item = ItemManager.CreateByItemID(sItem.itemid, 1, sItem.skinid);
            if (igData.KeepCondition && item.hasCondition)
                item.condition = sItem.condition;
            var weapon = item.GetHeldEntity() as BaseProjectile;
            if (weapon != null)
            {
                var def = ItemManager.FindItemDefinition(sItem.ammotype);
                weapon.primaryMagazine.ammoType = def;
                weapon.primaryMagazine.contents = sItem.ammoamount;
            }
            if (sItem.mods != null)
                foreach (var mod in sItem.mods)
                    item.contents.AddItem(BuildItem(mod).info, 1);
            return item;
        }
        #endregion

        #region Permissions
        private void RegisterPermisions()
        {
            permission.RegisterPermission("inventoryguardian.admin", this);
            permission.RegisterPermission("inventoryguardian.use", this);
        }
        private bool IsAdmin(BasePlayer player)
        {
            if (permission.UserHasPermission(player.UserIDString, "inventoryguardian.admin") || player.net.connection.authLevel >= igData.AuthLevel)
                return true;            
            return false;
        }
        private bool IsUser(BasePlayer player)
        {
            if (permission.UserHasPermission(player.UserIDString, "inventoryguardian.use") || IsAdmin(player))
                return true;
            return false;
        }
        #endregion

        #region Chat Commands
        [ChatCommand("ig")]
        private void cmdInvGuard(BasePlayer player, string command, string[] args)
        {
            if (args == null || args.Length == 0)
            {
                if (IsUser(player))
                {
                    MSG(player, " - Save your inventory", "/ig save");
                    MSG(player, " - Restore your inventory", "/ig restore");
                    MSG(player, " - Delete your saved inventory", "/ig delsaved");
                    MSG(player, " - Strip your current inventory", "/ig strip");
                }
                if (IsAdmin(player))
                {
                    MSG(player, " - Save <playername>'s inventory", "/ig save <playername>");
                    MSG(player, " - Restore <playername>'s inventory", "/ig restore <playername>");
                    MSG(player, " - Delete <playername>'s saved inventory", "/ig delsaved <playername>");
                    MSG(player, " - Strip <playername>'s current inventory", "/ig strip <playername>");
                    MSG(player, " - Change the minimum authlevel required to use admin commands", "/ig authlevel <1/2>");                    
                    MSG(player, " - Toggles InventoryGuardian on/off", "/ig toggle");
                    MSG(player, " - Toggles the auto restore funtion", "/ig autorestore");                    
                    MSG(player, " - Toggles the restoration of item condition", "/ig keepcondition");
                }
                return;
            }
            if (args.Length >= 1)
            { 
                if (!igData.IsActivated)
                {
                    if (args[0].ToLower() == "toggle")
                        if (IsAdmin(player))
                        {
                            igData.IsActivated = true;
                            SaveData();
                            MSG(player, "", "You have enabled Inventory Guardian");
                            return;
                        }
                    MSG(player, "", "Inventory Guardian is currently disabled");
                    return;
                }
            else if (igData.IsActivated)
                    switch (args[0].ToLower())
                    {
                        case "save":
                            if (IsAdmin(player))
                            {
                                if (args.Length == 2)
                                {
                                    BasePlayer target = FindPlayer(player, args[1]);
                                    if (target != null)
                                    {
                                        if (SaveInventory(target))
                                        {
                                            MSG(player, "", $"You have successfully saved {target.displayName}'s inventory");
                                            return;
                                        }
                                        MSG(player, "", $"The was a error saving {target.displayName}'s inventory");
                                    }
                                    return;
                                }
                            }
                            else if (IsUser(player))
                            {
                                if (SaveInventory(player))
                                {
                                    MSG(player, "", "You have successfully saved your inventory");
                                    return;
                                }
                                MSG(player, "", "The was a error saving your inventory");
                            }
                            else MSG(player, "You do not have permission to use this command", "", true);
                            return;
                        case "restore":
                            if (IsAdmin(player))
                            {
                                if (args.Length == 2)
                                {
                                    BasePlayer target = FindPlayer(player, args[1]);
                                    if (target != null)
                                    {
                                        if (RestoreInventory(target))
                                        {
                                            MSG(player, "", $"You have successfully restored {target.displayName}'s inventory");
                                            return;
                                        }
                                        MSG(player, "", $"{target.displayName} does not have a saved inventory");
                                    }
                                    return;
                                }
                            }
                            else if (IsUser(player))
                            {
                                if (RestoreInventory(player))
                                {
                                    MSG(player, "", "You have successfully restored your inventory");
                                    return;
                                }
                                MSG(player, "", "You do not have a saved inventory");
                            }
                            else MSG(player, "You do not have permission to use this command", "", true);
                            return;
                        case "delsaved":
                            if (IsAdmin(player))
                            {
                                if (args.Length == 2)
                                {
                                    BasePlayer target = FindPlayer(player, args[1]);
                                    if (target != null)
                                    {
                                        if (RemoveInventory(target))
                                        {
                                            MSG(player, "", $"You have successfully removed {target.displayName}'s inventory");
                                            return;
                                        }
                                        MSG(player, "", $"{target.displayName} does not have a saved inventory");
                                    }
                                    return;
                                }
                            }
                            else if (IsUser(player))
                            {
                                if (RemoveInventory(player))
                                {
                                    MSG(player, "", "You have successfully removed your saved inventory");
                                    return;
                                }
                                MSG(player, "", "You do not have a saved inventory");
                            }
                            else MSG(player, "You do not have permission to use this command", "", true);
                            return;                       
                        case "toggle":
                            if (IsAdmin(player))
                            {
                                if (igData.IsActivated)
                                {
                                    igData.IsActivated = false;
                                    SaveData();
                                    MSG(player, "", "You have disabled Inventory Guardian");
                                    return;
                                }
                            }
                            return;
                        case "autorestore":
                            if (IsAdmin(player))
                            {
                                if (igData.AutoRestore)
                                {
                                    igData.AutoRestore = false;
                                    SaveData();
                                    MSG(player, "You have disabled Auto-Restore", "", true);
                                    return;
                                }
                                else
                                {
                                    igData.AutoRestore = true;
                                    SaveData();
                                    MSG(player, "You have enabled Auto-Restore", "", true);
                                    return;
                                }
                            }
                            return;
                        case "authlevel":
                            if (IsAdmin(player))
                                if (args.Length == 2)
                                {
                                    int i;
                                    if (!int.TryParse(args[1], out i))
                                    {
                                        MSG(player, "", "To set the auth level you must enter either 1/2");
                                        return;
                                    }
                                    igData.AuthLevel = i;
                                    SaveData();
                                    MSG(player, "", $"You have successfully set the required auth level to {i}");
                                }
                            return;
                        case "strip":
                            if (IsAdmin(player))
                            {
                                if (args.Length == 2)
                                {
                                    BasePlayer target = FindPlayer(player, args[1]);
                                    if (target != null)
                                    {
                                        target.inventory.Strip();
                                        MSG(player, "", $"You have successfully stripped {target.displayName}'s inventory");
                                    }
                                    return;
                                }
                            }
                            else if (IsUser(player))
                            {
                                player.inventory.Strip();
                                MSG(player, "", $"You have successfully stripped your inventory");
                            }
                            else MSG(player, "You do not have permission to use this command", "", true);
                            return;
                        case "keepcondition":
                            if (IsAdmin(player))
                            {
                                if (igData.KeepCondition)
                                {
                                    igData.KeepCondition = false;
                                    SaveData();
                                    MSG(player, "You have disabled condition restoration", "", true);
                                    return;
                                }
                                else
                                {
                                    igData.KeepCondition = true;
                                    SaveData();
                                    MSG(player, "You have enabled condition restoration", "", true);
                                    return;
                                }
                            }
                            return;
                    }                    
                }
        }
        #endregion

        #region Console Commands
        [ConsoleCommand("ig")]
        private void ccmdInvGuard(ConsoleSystem.Arg arg)
        {
            if (arg.connection == null)
            { 
            if (arg.Args == null || arg.Args.Length == 0)
            {
                SendReply(arg, "ig save <playername> - Save <playername>'s inventory");
                SendReply(arg, "ig restore <playername> - Restore <playername>'s inventory");
                SendReply(arg, "ig delsaved <playername> - Delete <playername>'s saved inventory");
                SendReply(arg, "ig strip <playername> - Strip <playername>'s current inventory");
                SendReply(arg, "ig save all - Save all inventories");
                SendReply(arg, "ig restore all - Restore all inventories");
                SendReply(arg, "ig delete all - Delete all saved inventories");
                SendReply(arg, "ig strip all - Strip all player inventories");
                SendReply(arg, "ig authlevel <1/2> - Change the minimum authlevel required to use admin commands");
                SendReply(arg, "ig toggle - Toggles InventoryGuardian on/off");
                SendReply(arg, "ig autorestore - Toggles the auto restore funtion");
                SendReply(arg, "ig keepcondition - Toggles the restoration of item condition");
                return;
            }
            if (arg.Args.Length >= 1)
                switch (arg.Args[0].ToLower())
                {
                    case "save":
                        if (arg.Args.Length == 2)
                        {
                            if (arg.Args[1].ToLower() == "all")
                            {
                                SaveAll();
                                SendReply(arg, "You have successfully saved all player inventories");
                                return;
                            }
                            BasePlayer target = FindPlayer(null, arg.Args[1]);
                            if (target != null)
                            {
                                if (SaveInventory(target))
                                {
                                    SendReply(arg, $"You have successfully saved {target.displayName}'s inventory");
                                    return;
                                }
                                SendReply(arg, $"The was a error saving {target.displayName}'s inventory");
                            }
                        }
                        return;
                    case "restore":
                        if (arg.Args.Length == 2)
                        {
                            if (arg.Args[1].ToLower() == "all")
                            {
                                RestoreAll();
                                SendReply(arg, "You have successfully restored all player inventories");
                                return;
                            }
                            BasePlayer target = FindPlayer(null, arg.Args[1]);
                            if (target != null)
                            {
                                if (RestoreInventory(target))
                                {
                                    SendReply(arg, $"You have successfully restored {target.displayName}'s inventory");
                                    return;
                                }
                                SendReply(arg, $"{target.displayName} does not have a saved inventory");
                            }
                            return;
                        }
                        return;
                    case "delsaved":
                        if (arg.Args.Length == 2)
                        {
                            BasePlayer target = FindPlayer(null, arg.Args[1]);
                            if (target != null)
                            {
                                if (RemoveInventory(target))
                                {
                                    SendReply(arg, $"You have successfully removed {target.displayName}'s inventory");
                                    return;
                                }
                                SendReply(arg, $"{target.displayName} does not have a saved inventory");
                            }
                            return;
                        }
                        return;
                    case "delete":
                        if (arg.Args.Length == 2)
                            if (arg.Args[1].ToLower() == "all")
                            {
                                RemoveAll();
                                SendReply(arg, "You have successfully removed all player inventories");
                            }
                        return;                    
                    case "toggle":
                        if (igData.IsActivated)
                        {
                            igData.IsActivated = false;
                            SaveData();
                            SendReply(arg, "You have disabled Inventory Guardian", true);
                            return;
                        }
                        else
                        {
                            igData.IsActivated = true;
                            SaveData();
                            SendReply(arg, "You have enabled Inventory Guardian", true);
                        }
                        return;
                    case "autorestore":
                        if (igData.AutoRestore)
                        {
                            igData.AutoRestore = false;
                            SaveData();
                            SendReply(arg, "You have disabled Auto-Restore", true);
                            return;
                        }
                        else
                        {
                            igData.AutoRestore = true;
                            SaveData();
                            SendReply(arg, "You have enabled Auto-Restore", true);
                            return;
                        }
                    case "authlevel":
                        if (arg.Args.Length == 2)
                        {
                            int i;
                            if (!int.TryParse(arg.Args[1], out i))
                            {
                                SendReply(arg, "", "To set the auth level you must enter either 1/2");
                                return;
                            }
                            igData.AuthLevel = i;
                            SaveData();
                            SendReply(arg, "", $"You have successfully set the required auth level to {i}");
                        }
                        return;
                    case "strip":
                        if (arg.Args.Length == 2)
                        {
                            if (arg.Args[1].ToLower() == "all")
                            {
                                foreach (var player in BasePlayer.activePlayerList)
                                    player.inventory.Strip();
                                foreach (var player in BasePlayer.sleepingPlayerList)
                                    player.inventory.Strip();
                                SendReply(arg, "You have successfully stripped all player inventories");
                                return;
                            }
                            BasePlayer target = FindPlayer(null, arg.Args[1]);
                            if (target != null)
                            {
                                target.inventory.Strip();
                                SendReply(arg, "", $"You have successfully stripped {target.displayName}'s inventory");
                            }
                        }
                        return;
                    case "keepcondition":
                        if (igData.KeepCondition)
                        {
                            igData.KeepCondition = false;
                            SaveData();
                            SendReply(arg, "", "You have disabled condition restoration", true);
                            return;
                        }
                        else
                        {
                            igData.KeepCondition = true;
                            SaveData();
                            SendReply(arg, "", "You have enabled condition restoration", true);
                            return;
                        }
                }
            }
        }
        #endregion

        #region Classes
        class IGData
        {
            public bool IsActivated = true;
            public bool AutoRestore = true;
            public bool KeepCondition = true;
            public int AuthLevel = 2;
            public Dictionary<ulong, PlayerInfo> Inventories = new Dictionary<ulong, PlayerInfo>();
        }        
        class PlayerInfo
        {
            public bool RestoreOnce = false;
            public List<SavedItem> Items;
        }
        class SavedItem
        {
            public string shortname;
            public int itemid;
            public string container;
            public float condition;
            public int amount;
            public int ammoamount;
            public string ammotype;
            public ulong skinid;
            public bool weapon;
            public List<SavedItem> mods;
        }
        #endregion

        #region Data Management
        void SaveData()
        {
            igData.Inventories = cachedInventories;
            Inventory_Data.WriteObject(igData);
            Puts("Saved data");
        }
        void SaveLoop() => timer.Once(900, () => { SaveData(); SaveLoop(); });
        void LoadData()
        {
            try
            {
                igData = Inventory_Data.ReadObject<IGData>();
                cachedInventories = igData.Inventories;
            }
            catch
            {
                Puts("Couldn't load player data, creating new datafile");
                igData = new IGData();
            }           
        }
        #endregion

        #region Config        
        private ConfigData configData;
        class ConfigData
        {
            public string Messages_MainColor { get; set; }
            public string Messages_MsgColor { get; set; }           
        }
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                Messages_MainColor = "<color=#FF8C00>",
                Messages_MsgColor = "<color=#939393>"
            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion

    }
}


// --- End of file: InventoryGuardian.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/PlayerDatabase.cs ---
// --- Original Local Path: PlayerDatabase.cs ---

using System.Collections.Generic;
using System;
using System.Reflection;
using System.Data;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Logging;
using Oxide.Core.Plugins;
using Rust; 

namespace Oxide.Plugins
{
    [Info("PlayerDatabase", "Reneb", "1.0.5")]
    class PlayerDatabase : RustPlugin
    {
        public static DataFileSystem datafile;

        string subDirectory = "playerdatabase/";
        Hash<string, Dictionary<string, Dictionary<string, object>>> playersData = new Hash<string, Dictionary<string, Dictionary<string, object>>>();
        List<string> changedPlayersData = new List<string>();

        ////////////////////////////////////////////////////////////
        // Known Players
        ////////////////////////////////////////////////////////////

        StoredData storedData;

        class StoredData
        {
            public HashSet<string> knownPlayers = new HashSet<string>();

            public StoredData() { }
        }

        void OnServerSave() { SaveData(); SavePlayerDatabase(); }

        void SaveData() { Interface.GetMod().DataFileSystem.WriteObject("PlayerDatabase", storedData); }

        void LoadData()
        {
            try { storedData = Interface.GetMod().DataFileSystem.ReadObject<StoredData>("PlayerDatabase"); }
            catch { storedData = new StoredData(); }
        }

        bool isKnownPlayer(BasePlayer player) { return isKnownPlayer(player.userID.ToString()); }
        bool isKnownPlayer(string userid) { return storedData.knownPlayers.Contains(userid); }

        void Loaded()
        {
            datafile = Interface.GetMod().DataFileSystem;
            LoadData();
            foreach (string userid in storedData.knownPlayers)
            {
                LoadPlayer(userid);
            }
        }

        void SavePlayerDatabase()
        {
            foreach (string userid in changedPlayersData)
            {
                string path = subDirectory + userid;
                datafile.WriteObject<Dictionary<string, Dictionary<string, object>>>(path, playersData[userid]);
            }
            changedPlayersData.Clear();
        }
        void Unload()
        {
            SavePlayerDatabase();
            SaveData();
        }

        void OnPlayerInit(BasePlayer player)
        {
            if (!isKnownPlayer(player)) { LoadPlayer(player); }
            if (!playersData[player.userID.ToString()].ContainsKey("default"))
                playersData[player.userID.ToString()].Add("default", new Dictionary<string, object>());
            if (playersData[player.userID.ToString()]["default"].ContainsKey("name"))
                playersData[player.userID.ToString()]["default"]["name"] = player.displayName;
            else
                playersData[player.userID.ToString()]["default"].Add("name", player.displayName);
            if (playersData[player.userID.ToString()]["default"].ContainsKey("steamid"))
                playersData[player.userID.ToString()]["default"]["steamid"] = player.userID.ToString();
            else
                playersData[player.userID.ToString()]["default"].Add("steamid", player.userID.ToString());

        }

        HashSet<string> GetAllKnownPlayers()
        {
            return storedData.knownPlayers;
        }

        object FindPlayer(string arg)
        {
            ulong steamid = 0L;
            ulong.TryParse(arg, out steamid);
            string lowerarg = arg.ToLower();

            if (steamid != 0L && arg.Length == 17)
            {
                if (playersData[arg] == null) return "No players found with this steamid";
                else return arg;
            }

            Dictionary<string, string> foundPlayers = new Dictionary<string, string>();
            foreach (KeyValuePair<string, Dictionary<string, Dictionary<string, object>>> pair in playersData)
            {
                if (pair.Value.ContainsKey("default"))
                    if (pair.Value["default"].ContainsKey("name"))
                    {
                        string lowname = pair.Value["default"]["name"].ToString().ToLower();
                        if (lowname.Contains(lowerarg))
                            if(!foundPlayers.ContainsKey(pair.Key))
                                foundPlayers.Add(pair.Key, pair.Value["default"]["name"].ToString());
                    }
            }
            if(foundPlayers.Count > 1)
            {
                string msg = string.Empty;
                foreach (KeyValuePair<string,string> pair in foundPlayers) { msg += string.Format("{0} {1}\n", pair.Key, pair.Value); }
                return msg;
            }
            foreach(string key in foundPlayers.Keys)
            {
                return key;
            }
            return "Couldn't find any player with this name";
        }
         
        void LoadPlayer(BasePlayer player) { LoadPlayer(player.userID.ToString()); }
        void LoadPlayer(string userid)
        {
            if (!storedData.knownPlayers.Contains(userid))
                storedData.knownPlayers.Add(userid);
            string path = subDirectory + userid;

            if (datafile.ExistsDatafile(path)) { }

            object profile;
            try 
            {
                profile = datafile.ReadObject<Dictionary<string, Dictionary<string, object>>>(path);
            }
            catch (Exception exception) {
                profile = new Dictionary<string, object>();
                datafile.WriteObject<Dictionary<string, Dictionary<string, object>>>(path, new Dictionary<string, Dictionary<string, object>>());
            }

            playersData[userid] = profile as Dictionary<string, Dictionary<string, object>>;
        }
          
        void SetPlayerData(string userid, string key, Dictionary<string, object> data)
        { 
            if (!playersData.ContainsKey(userid)) LoadPlayer(userid);
            Dictionary<string, Dictionary<string, object>> profile = playersData[userid];
              
            if (!profile.ContainsKey(key)) profile.Add(key, data);
            else profile[key] = data;
            playersData[userid] = profile;

            if (!changedPlayersData.Contains(userid))
                changedPlayersData.Add(userid);
        } 
        object GetPlayerData(string userid, string key)
        {
            if (!playersData.ContainsKey(userid)) return null;
            Dictionary<string, Dictionary<string,object>> profile =  playersData[userid];
            if (!profile.ContainsKey(key))
            {
                return null;
            }
            else
            {
                return profile[key];
            }
        }
    }
}


// --- End of file: PlayerDatabase.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/XStashLogs.cs ---
// --- Original Local Path: XStashLogs.cs ---

using Newtonsoft.Json;
using System;
using Oxide.Core.Plugins;
		   		 		  						  	   		  		 			  	  			  						  		  
namespace Oxide.Plugins
{
    [Info("XStashLogs", "Sempai#3239", "1.0.201")]
    class XStashLogs : RustPlugin
	{
        protected override void SaveConfig() => Config.WriteObject(config);
	
				
				
		private void OnServerInitialized()
		{		
			PrintWarning("\n-----------------------------\n" +
			"     Author - Sempai\n" +
			"     VK - vk.com/rustnastroika\n" +
			"     Discord - Sempai#3239\n" +
			"     Config - v.916\n" +
			"-----------------------------");
		}
		
		object CanSeeStash(BasePlayer player, StashContainer stash)
		{
			if (player == null || stash == null) return null;
			
			DateTime time = DateTime.Now;
			
			if (stash.OwnerID == player.userID)
			{
				string oss = $"```[{time}] | Игрок: {player.displayName} | {player.userID} - выкопал свой тайник. Координаты: {stash.transform.position}```";
				
				if (config.See.ConsoleSeeStashOwner) PrintWarning(oss);
				if (config.See.LogSeeStashOwner) LogToFile($"StashLogsSee", oss, this);
				
				if (config.See.DiscordSeeStashOwner)
				{
				    if (DiscordMessages) DiscordMessages?.Call("API_SendTextMessage", config.Discord.WebHook, oss);
				        else PrintWarning(error);
				}
			}
			else if (player.currentTeam != 0 && player.Team.members.Contains(stash.OwnerID))
			{
				string fss = $"```[{time}] | Игрок: {player.displayName} | {player.userID} - выкопал тайник друга. Тайник игрока: ({stash.OwnerID}). Координаты: {stash.transform.position}```";
				
				if (config.See.ConsoleSeeStashFriend) PrintWarning(fss);
				if (config.See.LogSeeStashFriend) LogToFile($"StashLogsSee", fss, this);
				
				if (config.See.DiscordSeeStashFriend)
				{
				    if (DiscordMessages) DiscordMessages?.Call("API_SendTextMessage", config.Discord.WebHook, fss);
				        else PrintWarning(error);
				}
			}
			else
			{
				string ss = $"```[{time}] | Игрок: {player.displayName} | {player.userID} - выкопал чужой тайник. Тайник игрока: ({stash.OwnerID}). Координаты: {stash.transform.position}```";
				
				if (config.See.ConsoleSeeStash) PrintWarning(ss);
				if (config.See.LogSeeStash) LogToFile($"StashLogsSee", ss, this);
				
				if (config.See.DiscordSeeStash)
				{
				    if (DiscordMessages) DiscordMessages?.Call("API_SendTextMessage", config.Discord.WebHook, ss);
				        else PrintWarning(error);
				}
			}				
			
			return null;
		}
		   		 		  						  	   		  		 			  	  			  						  		  
        private class StashConfig
        {		
			[JsonProperty("Настройка сообщений/логов закопанных тайников")]
            public SeeSetting See;						
			
			public static StashConfig GetNewConfiguration()
            {
                return new StashConfig
                {
					Discord = new DiscordSetting
					{
						WebHook = "$WEBHOOK-916"
						
					},
					Hide = new HideSetting
					{
						ConsoleHideStashOwner = true,
						ConsoleHideStashFriend = true,
						ConsoleHideStash = true,						
						DiscordHideStashOwner = false,
						DiscordHideStashFriend = false,
						DiscordHideStash = false,
						LogHideStashOwner = true,
						LogHideStashFriend = true,
						LogHideStash = true
					},
					See = new SeeSetting
					{
						ConsoleSeeStashOwner = true,
						ConsoleSeeStashFriend = true,
						ConsoleSeeStash = true,						
						DiscordSeeStashOwner = false,
						DiscordSeeStashFriend = false,
						DiscordSeeStash = false,
						LogSeeStashOwner = true,
						LogSeeStashFriend = true,
						LogSeeStash = true
					}
				};
			}
			internal class DiscordSetting
            {
                [JsonProperty("WebHook канала для сообщений")] public string WebHook;	
            }	
             
			internal class SeeSetting
			{
				[JsonProperty("Включить сообщения в консоль закопанных своих тайников")] public bool ConsoleSeeStashOwner;				
				[JsonProperty("Включить сообщения в консоль закопанных тайников друзей")] public bool ConsoleSeeStashFriend;				
				[JsonProperty("Включить сообщения в консоль закопанных чужих тайников")] public bool ConsoleSeeStash;					
				[JsonProperty("Включить сообщения в Discord закопанных своих тайников")] public bool DiscordSeeStashOwner;				
				[JsonProperty("Включить сообщения в Discord закопанных тайников друзей")] public bool DiscordSeeStashFriend;				
				[JsonProperty("Включить сообщения в Discord закопанных чужих тайников")] public bool DiscordSeeStash;				
				[JsonProperty("Включить логирование закопанных своих тайников")] public bool LogSeeStashOwner;				
				[JsonProperty("Включить логирование закопанных тайников друзей")] public bool LogSeeStashFriend;				
				[JsonProperty("Включить логирование закопанных чужих тайников")] public bool LogSeeStash;
			}
			[JsonProperty("Настройка сообщений/логов выкопанных тайников")]
            public HideSetting Hide;			
		   		 		  						  	   		  		 			  	  			  						  		  
            internal class HideSetting
			{
				[JsonProperty("Включить сообщения в консоль выкопанных своих тайников")] public bool ConsoleHideStashOwner;				
				[JsonProperty("Включить сообщения в консоль выкопанных тайников друзей")] public bool ConsoleHideStashFriend;				
				[JsonProperty("Включить сообщения в консоль выкопанных чужих тайников")] public bool ConsoleHideStash;								
				[JsonProperty("Включить сообщения в Discord выкопанных своих тайников")] public bool DiscordHideStashOwner;				
				[JsonProperty("Включить сообщения в Discord выкопанных тайников друзей")] public bool DiscordHideStashFriend;				
				[JsonProperty("Включить сообщения в Discord выкопанных чужих тайников")] public bool DiscordHideStash;				
				[JsonProperty("Включить логирование выкопанных своих тайников")] public bool LogHideStashOwner;				
				[JsonProperty("Включить логирование выкопанных тайников друзей")] public bool LogHideStashFriend;				
				[JsonProperty("Включить логирование выкопанных чужих тайников")] public bool LogHideStash;
			}			
			
			[JsonProperty("Настройка Discord")]
            public DiscordSetting Discord;			
        }
				
		[PluginReference] private Plugin DiscordMessages;

		protected override void LoadConfig() 
        {
            base.LoadConfig(); 
			 
			try
			{
				config = Config.ReadObject<StashConfig>();
			}
			catch  
			{
				PrintWarning("Ошибка чтения конфигурации! Создание дефолтной конфигурации!");
				LoadDefaultConfig();
			}
			 
			SaveConfig();
        }
		protected override void LoadDefaultConfig() => config = StashConfig.GetNewConfiguration();
		
				
				
		private StashConfig config;
		
				
				
		public string error = "Ошибка отправки логов в Discord. Плагин - DiscordMessages не установлен!";
		
		object CanHideStash(BasePlayer player, StashContainer stash)
		{
			if (player == null || stash == null) return null;
			
			DateTime time = DateTime.Now;
			
			if (stash.OwnerID == player.userID)
			{
				string osh = $"```[{time}] | Игрок: {player.displayName} | {player.userID} - закопал свой тайник. Координаты: {stash.transform.position}```";
				
				if (config.Hide.ConsoleHideStashOwner) PrintWarning(osh);
				if (config.Hide.LogHideStashOwner) LogToFile($"StashLogsHide", osh, this);
				
				if (config.Hide.DiscordHideStashOwner)
				{
				    if (DiscordMessages) DiscordMessages?.Call("API_SendTextMessage", config.Discord.WebHook, osh); 
				        else PrintWarning(error);
				}
			}
			else if (player.currentTeam != 0 && player.Team.members.Contains(stash.OwnerID))
			{
				string fsh = $"```[{time}] | Игрок: {player.displayName} | {player.userID} - закопал тайник друга. Тайник игрока: ({stash.OwnerID}). Координаты: {stash.transform.position}```";
				
				if (config.Hide.ConsoleHideStashFriend) PrintWarning(fsh);
				if (config.Hide.LogHideStashFriend) LogToFile($"StashLogsHide", fsh, this);
				
				if (config.Hide.DiscordHideStashFriend)
				{
				    if (DiscordMessages) DiscordMessages?.Call("API_SendTextMessage", config.Discord.WebHook, fsh);
				        else PrintWarning(error);
				}
			}
			else
			{
				string sh = $"```[{time}] | Игрок: {player.displayName} | {player.userID} - закопал чужой тайник. Тайник игрока: ({stash.OwnerID}). Координаты: {stash.transform.position}```";
				
				if (config.Hide.ConsoleHideStash) PrintWarning(sh);
				if (config.Hide.LogHideStash) LogToFile($"StashLogsHide", sh, this);
				
				if (config.Hide.DiscordHideStash)
				{
				    if (DiscordMessages) DiscordMessages?.Call("API_SendTextMessage", config.Discord.WebHook, sh);
				        else PrintWarning(error);
				}
			}				
			
			return null;
		}		
		
			}
}


// --- End of file: XStashLogs.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/DeepWater.cs ---
// --- Original Local Path: DeepWater.cs ---

using System;
using System.Linq;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Configuration;
using Rust;
using Network;
using System.Runtime.CompilerServices;
using System.Collections.Generic;
using System.Resources;
using Facepunch;

namespace Oxide.Plugins
{
    [Info("DeepWater", "Colon Blow", "1.0.22")]
    class DeepWater : RustPlugin
    {
        // fix for grid location

        #region Load

        private bool initialized;

        void Loaded()
        {
            LoadVariables();
            lang.RegisterMessages(messages, this);
            permission.RegisterPermission("deepwater.spawn", this);
        }

        private void OnServerInitialized()
        {
            LoadDataFile();
            initialized = true;
            timer.In(5, RestoreSavedRigs);
            if (SpawnRandomOnLoad) timer.In(30, SetAutoSpawnEnabled);
        }

        void LoadDefaultConfig()
        {
            Puts("No configuration file found, generating...");
            Config.Clear();
            LoadVariables();
        }

        private void RestoreSavedRigs()
        {
            if (storedData.saveRigData.Count > 0)
            {
                BaseEntity[] objects = BaseEntity.saveList.Where(x => x is BaseEntity).ToArray();
                if (objects != null)
                {
                    foreach (var obj in objects)
                    {
                        if (storedData.saveRigData.ContainsKey(obj.net.ID))
                        {
                            var getent = obj.GetComponent<BaseEntity>();
                            if (getent) getent.Invoke("KillMessage", 0.1f);

                            var signownerid = storedData.saveRigData[obj.net.ID].ownerid;
                            var signpos = StringToVector3(storedData.saveRigData[obj.net.ID].pos);
                            var signrot = StringToQuaternion(storedData.saveRigData[obj.net.ID].rot);
                            var signangle = StringToVector3(storedData.saveRigData[obj.net.ID].eangles);
                            var rigcompound = storedData.saveRigData[obj.net.ID].iscompound;
                            timer.Once(2f, () => SpawnRig(signownerid, signpos, signrot, signangle, rigcompound));

                            storedData.saveRigData.Remove(obj.net.ID);
                            SaveData();
                        }
                    }
                }
            }
        }

        #endregion

        #region Configuration

        private string gridLocation;

        static bool SpawnRandomOnLoad = false;

        static bool EnableAutoZoneOnRandom = false;
        static bool EnableAutoZoneOnLocal = false;
        static bool EnableAutoZoneOnCompound = false;
        static bool EnableAutoZoneOnRigEvent = true;

        static bool useStaticRandomID = false;
        static bool useStaticLocalID = false;
        static bool useStaticComoundID = false;
        static bool useStaticEventID = false;

        static string randomRigZoneID = "123456";
        static string localRigZoneID = "223344";
        static string compoundRigZoneID = "555555";
        static string eventRigZoneID = "999999";

        static string randomzoneargs = @"radius,50,enter_message,You have entered a Random Rig Area";
        static string localzoneargs = @"radius,50,enter_message,You have entered a Rig Area";
        static string compoundzoneargs = @"radius,50,enter_message,You have entered a Compound Rig Area";
        static string eventzoneargs = @"radius,50,enter_message,You have entered a Event Rig Area";

        static int PumpStartingFuel = 100;

        static uint HeliPadRugLogo1 = 1371746398;
        static uint HeliPadRugLogo2 = 1371746398;

        static bool UseSentryOnCompound = false;

        bool CanDamageRig = false;

        bool DestroyRandomOnReload = false;
        bool DestroyLocalOnReload = false;

        float RigSpawnHeight = 16f;

        static bool UseDespawnOnRandom = true;
        static bool UseDespawnOnLocal = false;

        static bool AutoMoveLiftBucket = true;
        static bool StandardRigHasLiftBucket = true;
        static bool StandardRigHasBarrels = false;
        static bool StandardRigHasLadders = true;
        static bool StandardRigHasLootSpawn = true;

        static float DespawnTime = 60000f;
        static float LootRespawnTime = 1000f;

        static int EventMinRestartTime = 10000;
        static int EventMaxRestartTime = 30000;
        static int MinPlayersForEventSpawn = 5;
        static bool EventRigHasLiftBucket = true;
        static bool EventRigHasBarrels = true;
        static bool EventRigHasLadders = true;
        static bool EventRigHasHackCrate = true;
        static bool EventRigHasLootSpawn = true;
        static bool AddFullDivingKit = true;
        static int Stage1Duration = 6000;
        static int Stage2Duration = 4000;
        static float Stage2HackDuration = 200f;
        static int Stage3Duration = 1000;
        static int Stage3TimeBetweenBarrels = 100;
        static float Stage3BarrelDamage = 50f;
        static int Stage4Duration = 2000;
        static float Stage4HackDefaultReset = 900f;


        static int MaxLootCratesToSpawn = 2;
        static string LootPrefab1 = "assets/bundled/prefabs/radtown/crate_basic.prefab";
        static string LootPrefab2 = "assets/bundled/prefabs/radtown/crate_elite.prefab";
        static string LootPrefab3 = "assets/bundled/prefabs/radtown/crate_mine.prefab";
        static string LootPrefab4 = "assets/bundled/prefabs/radtown/crate_normal.prefab";
        static string LootPrefab5 = "assets/bundled/prefabs/radtown/crate_normal_2.prefab";

        static bool HasOilDeposit = true;
        static bool HasHQMetalDeposit = true;
        static bool HasSulfurDeposit = true;
        static bool HasMetalDeposit = true;

        static int OilDepositTickRate = 1;
        static int HQMetalTickRate = 1;
        static int SulfurOreTickRate = 1;
        static int MetalOreTickRate = 1;

        static bool BroadcastSpawn = true;
        static bool BroadcastEventSpawn = true;
        static bool BroadcastEventEnd = true;
        static bool BroadCastEventStages = true;
        int eventcounter = 0;
        int eventrespawntime = EventMaxRestartTime;

        bool Changed;
        static bool DoRandomRespawn = false;
        bool EventCountDown = false;

        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }

        private void LoadConfigVariables()
        {
            CheckCfg("Spawn - Starting Low Grade Fuel amount for engine when Deepwater spawns : ", ref PumpStartingFuel);
            CheckCfg("Spawn - Broadcast to chat when Deepwater spawns and its coords ? ", ref BroadcastSpawn);

            CheckCfg("ZoneManager - Automatic Zone Options - Local Zone Creation Arguments (except zone id, no space after commas) ", ref localzoneargs);
            CheckCfg("ZoneManager - Automatic Zone Options - Random Zone Creation Arguments (except zone id, no space after commas) ", ref randomzoneargs);
            CheckCfg("ZoneManager - Automatic Zone Options - Compound Zone Creation Arguments (except zone id, no space after commas) ", ref compoundzoneargs);
            CheckCfg("ZoneManager - Automatic Zone Options - Event Rig Zone Creation Arguments (except zone id, no space after commas) ", ref eventzoneargs);

            CheckCfg("ZoneManager - Automatic Zone - Autmatically spawn a zone when Random Rig Spawns ? ", ref EnableAutoZoneOnRandom);
            CheckCfg("ZoneManager - Automatic Zone - Autmatically spawn a zone when Local Rig Spawns ? ", ref EnableAutoZoneOnLocal);
            CheckCfg("ZoneManager - Automatic Zone - Autmatically spawn a zone when Compound Rig Spawns ? ", ref EnableAutoZoneOnCompound);
            CheckCfg("ZoneManager - Automatic Zone - Autmatically spawn a zone when Event Rig Spawns ? ", ref EnableAutoZoneOnRigEvent);

            CheckCfg("ZoneManager - Enable Predefined Zone ID - Turn this on for Event Rigs (otherwise, it autogenerates one from entity ID) ? ", ref useStaticEventID);
            CheckCfg("ZoneManager - Enable Predefined Zone ID - Turn this on for Compound Rigs (otherwise, it autogenerates one from entity ID) ? ", ref useStaticComoundID);
            CheckCfg("ZoneManager - Enable Predefined Zone ID - Turn this on for Random Rigs (otherwise, it autogenerates one from entity ID) ? ", ref useStaticRandomID);
            CheckCfg("ZoneManager - Enable Predefined Zone ID - Turn this on for Local Rigs (otherwise, it autogenerates one from entity ID) ? ", ref useStaticLocalID);

            CheckCfg("ZoneManager - Zone ID - Use This Predefined Event Rig Zone ID (if enabled) ", ref eventRigZoneID);
            CheckCfg("ZoneManager - Zone ID - Use This Predefined Compound Rig Zone ID (if enabled) ", ref compoundRigZoneID);
            CheckCfg("ZoneManager - Zone ID - Use This Predefined Random Rig Zone ID (if enabled) ", ref randomRigZoneID);
            CheckCfg("ZoneManager - Zone ID - Use This Predefined Local Rig Zone ID (if enabled) ", ref localRigZoneID);


            CheckCfg("Spawn - Helipad H logo Half 1 (H) rug skind ID ? ", ref HeliPadRugLogo1);
            CheckCfg("Spawn - Helipad H logo Half 2 (H) rug skind ID ? ", ref HeliPadRugLogo2);

            CheckCfg("Compound - Spawn the Sentry Guns if rig is a compound ? ", ref UseSentryOnCompound);

            CheckCfg("_Event - AutoSpawn - Spawn Event at random Intervals between Min and Max Respawn time ? ", ref SpawnRandomOnLoad);
            CheckCfg("_Event - Minimum Player Count needed to AutoSpawn Event Rig ? ", ref MinPlayersForEventSpawn);
            CheckCfg("_Event - Spawn Bucket Lift for Event Rigs ? ", ref EventRigHasLiftBucket);
            CheckCfg("_Event - Spawn Barrels (and explosions) for Event Rigs ? ", ref EventRigHasBarrels);
            CheckCfg("_Event - Spawn Ladders for Event Rigs ? ", ref EventRigHasLadders);
            CheckCfg("_Event - Spawn Hack Crate for Stage 2 ? ", ref EventRigHasHackCrate);
            CheckCfg("_Event - Hack Crate will always have a full Diving Kit (wetsuit, tank, fins and mask) ? ", ref AddFullDivingKit);
            CheckCfg("_Event - Spawn Loots crates for Event Rigs ? ", ref EventRigHasLootSpawn);
            CheckCfg("_Event - Broadcast Event stages to all players ? ", ref BroadCastEventStages);
            CheckCfg("_Event - Broadcast Event spawn to all players ?  ", ref BroadcastEventSpawn);
            CheckCfg("_Event - Broadcast Event ending to all players ?  ", ref BroadcastEventEnd);
            CheckCfg("_Event - AutoSpawn - Minimum Respawn Time for event  (Every 1000 is approx 1 min) : ", ref EventMinRestartTime);
            CheckCfg("_Event - AutoSpawn - Maximum Respawn Time for event  (Every 1000 is approx 1 min) : ", ref EventMaxRestartTime);
            CheckCfg("_Event - Duration - Rig Spawn to Stage 1 Wait Time : ", ref Stage1Duration);
            CheckCfg("_Event - Duration - Stage 1 to Stage 2 Wait Time (MAX is 4500) : ", ref Stage2Duration);
            CheckCfg("_Event - Duration - Stage 2 Duration to Stage 3 Wait Time : ", ref Stage3Duration);
            CheckCfg("_Event - Duration - Stage 3 Time between Barrel Explosions : ", ref Stage3TimeBetweenBarrels);
            CheckCfgFloat("_Event - Damage - Stage 3 Barrel Explosion Damage : ", ref Stage3BarrelDamage);
            CheckCfg("_Event - Duration - Stage 4 Countdown Time (Every 1000 is approx 1 min) : ", ref Stage4Duration);

            CheckCfgFloat("_Event - Hack time for Hack crate during event : ", ref Stage2HackDuration);
            CheckCfgFloat("_Event - Reset global Hack Crate time back to (900 is default) after event : ", ref Stage4HackDefaultReset);


            CheckCfgFloat("Spawn - Height of rig off water. 13 to 19 works best : ", ref RigSpawnHeight);
            CheckCfg("Spawn - Spawn Bucket Lift for Standard Rigs (non Event) ? ", ref StandardRigHasLiftBucket);
            CheckCfg("Spawn - Spawn Barrels for Standard Rigs (non Event) ? ", ref StandardRigHasBarrels);
            CheckCfg("Spawn - Spawn Ladders for Standard Rigs (non Event) ? ", ref StandardRigHasLadders);
            CheckCfg("Spawn - Spawn Loots Crates for Standard Rigs (non Event) ? ", ref StandardRigHasLootSpawn);

            CheckCfg("Allow Damage to Deepwater Rig ? ", ref CanDamageRig);

            CheckCfg("Destroy all Random Spawned Deepwater Rigs when plugin reloads or server restarts ? ", ref DestroyRandomOnReload);
            CheckCfg("Destroy all Manually Spawned Deepwater Rigs when plugin reloads or server restarts ? ", ref DestroyLocalOnReload);

            CheckCfg("Automatically have lift bucket go up and down periodically ? ", ref AutoMoveLiftBucket);

            CheckCfg("Despawn - Enable despawn timer on Randomly Spawned Deepwater Rigs ? ", ref UseDespawnOnRandom);
            CheckCfg("Despawn - Enable despawn timer on Manually placed Deepwater Rigs ? ", ref UseDespawnOnLocal);
            CheckCfgFloat("Despawn - Time before Deepwater Rig will despawn itself : ", ref DespawnTime);

            CheckCfgFloat("Loot Spawn - amount of time to respawn loot spawns on rig : ", ref LootRespawnTime);
            CheckCfg("Loot Spawn - maximum number of loot crates spawn locations (max 8) : ", ref MaxLootCratesToSpawn);
            CheckCfg("Loot Spawn - Random Loot prefab 1 : ", ref LootPrefab1);
            CheckCfg("Loot Spawn - Random Loot prefab 2 : ", ref LootPrefab2);
            CheckCfg("Loot Spawn - Random Loot prefab 3 : ", ref LootPrefab3);
            CheckCfg("Loot Spawn - Random Loot prefab 4 : ", ref LootPrefab4);
            CheckCfg("Loot Spawn - Random Loot prefab 5 : ", ref LootPrefab5);

            CheckCfg("Resource Deposit - Enable Crude Oil as a resource : ", ref HasOilDeposit);
            CheckCfg("Resource Deposit - Enable High Quality Metal Ore as a resource : ", ref HasHQMetalDeposit);
            CheckCfg("Resource Deposit - Enable Sulfur Ore as a resource : ", ref HasSulfurDeposit);
            CheckCfg("Resource Deposit - Enable Metal Ore as a resource : ", ref HasMetalDeposit);

            CheckCfg("Resource Deposit - Tick Rate - Get 1 Crude Oil every : (if enabled) : ", ref OilDepositTickRate);
            CheckCfg("Resource Deposit - Tick Rate - Get 1 HQ Metal every (if enabled) : ", ref HQMetalTickRate);
            CheckCfg("Resource Deposit - Tick Rate - Get 1 Sulfur Ore every (if enabled) : ", ref SulfurOreTickRate);
            CheckCfg("Resource Deposit - Tick Rate - Get 1 Metal Ore every (if enabled) : ", ref MetalOreTickRate);

        }

        private void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T)
                var = (T)Config[Key];
            else
                Config[Key] = var;
        }

        private void CheckCfgFloat(string Key, ref float var)
        {

            if (Config[Key] != null)
                var = System.Convert.ToSingle(Config[Key]);
            else
                Config[Key] = var;
        }

        #endregion

        #region Localization

        string msg(string key, string playerId = null) => lang.GetMessage(key, this, playerId);

        Dictionary<string, string> messages = new Dictionary<string, string>()
        {
            ["notauthorized"] = "You are not authorized to use that command!",
            ["rigspawn"] = "DeepWater Rig Event at grid : ",
            ["rigdespawn"] = "Deepwater Rig Event has Ended !!"
        };

        #endregion

        #region Commands

        // Spawns a Random Deepwater Rig

        [ChatCommand("spawnrandomrig")]
        void cmdSpawnRandomRig(BasePlayer player, string command, string[] args)
        {
            if (!IsAllowed(player, "deepwater.spawn")) return;
            BuildRandomDeepWater(false);
        }

        [ConsoleCommand("spawnrandomrig")]
        void cmdConsoleSpawnRandomRig(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player != null && !IsAllowed(player, "deepwater.spawn")) return;
            BuildRandomDeepWater(false);
        }

        // Spawns Random Deepwater Rig with Event started

        [ChatCommand("spawnrandomrigevent")]
        void cmdSpawnRandomRigEvent(BasePlayer player, string command, string[] args)
        {
            if (!IsAllowed(player, "deepwater.spawn")) return;
            BuildRandomDeepWater(true);
        }

        [ConsoleCommand("spawnrandomrigevent")]
        void cmdConsoleSpawnRandomRigEvent(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player != null && !IsAllowed(player, "deepwater.spawn")) return;
            BuildRandomDeepWater(true);
        }


        // Spawns a Deepwater rig on players location

        [ChatCommand("spawnrig")]
        void cmdSpawnRig(BasePlayer player, string command, string[] args)
        {
            if (!IsAllowed(player, "deepwater.spawn")) return;
            BuildLocalDeepWater(player, false);
        }

        // Spawns a Deepwater rig with Event Started on players location

        [ChatCommand("spawnrigevent")]
        void cmdSpawnRigEvent(BasePlayer player, string command, string[] args)
        {
            if (!IsAllowed(player, "deepwater.spawn")) return;
            BuildLocalDeepWater(player, true);
        }

        [ChatCommand("destroyrig")]
        void cmdDestroyRig(BasePlayer player, string command, string[] args)
        {
            if (!IsAllowed(player, "deepwater.spawn")) return;
            RaycastHit hit;
            BaseEntity hitentity = new BaseEntity();
            if (Physics.Raycast(player.eyes.HeadRay(), out hit, 50f)) hitentity = hit.GetTransform().gameObject.ToBaseEntity();
            if (hitentity == null) return;
            var isdeepwater = hitentity.GetComponentInParent<DeepWaterEntity>() ?? null;
            if (isdeepwater) isdeepwater.OnDestroy();
        }

        [ChatCommand("clearrigdatabase")]
        void cmdChatClearRigDataBase(BasePlayer player, string command, string[] args)
        {
            if (player.net?.connection?.authLevel > 1)
            {
                storedData.saveRigData.Clear();
                SaveData();
            }
            return;
        }

        #endregion

        #region RigAntihack check

        static List<BasePlayer> rigantihack = new List<BasePlayer>();

        object OnPlayerViolation(BasePlayer player, AntiHackType type, float amount)
        {
            if (player == null) return null;
            if (rigantihack.Contains(player)) return false;
            return null;
        }

        #endregion

        #region Data 

        static Dictionary<ulong, PlayerRigCount> loadplayer = new Dictionary<ulong, PlayerRigCount>();

        public class PlayerRigCount
        {
            public BasePlayer player;
            public int rigcount;
        }

        static StoredData storedData = new StoredData();
        DynamicConfigFile dataFile;

        public class StoredData
        {
            public Dictionary<uint, StoredRigData> saveRigData = new Dictionary<uint, StoredRigData>();
            public StoredData() { }
        }

        public class StoredRigData
        {
            public ulong ownerid;
            public string pos;
            public string eangles;
            public string rot;
            public int iscompound;
        }

        void LoadDataFile()
        {
            dataFile = Interface.Oxide.DataFileSystem.GetFile(Title);

            try
            {
                storedData = dataFile.ReadObject<StoredData>();
            }
            catch { }

            if (storedData == null)
                storedData = new StoredData();
        }

        void AddData(uint entnetid, ulong sownerid, string spos, string seangles, string srot, int compound = 0)
        {
            if (storedData.saveRigData.ContainsKey(entnetid)) storedData.saveRigData.Remove(entnetid);

            storedData.saveRigData.Add(entnetid, new StoredRigData
            {
                ownerid = sownerid,
                pos = spos,
                eangles = seangles,
                rot = srot,
                iscompound = compound,
            });
            SaveData();
        }

        void RemoveData(uint entnetid)
        {
            if (storedData.saveRigData.ContainsKey(entnetid)) storedData.saveRigData.Remove(entnetid);
        }

        void SaveData()
        {
            if (dataFile != null && storedData != null)
            {
                dataFile.WriteObject(storedData);
            }
        }

        public static Vector3 StringToVector3(string sVector)
        {
            if (sVector.StartsWith("(") && sVector.EndsWith(")"))
            {
                sVector = sVector.Substring(1, sVector.Length - 2);
            }
            string[] sArray = sVector.Split(',');
            Vector3 result = new Vector3(
                float.Parse(sArray[0]),
                float.Parse(sArray[1]),
             float.Parse(sArray[2]));
            return result;
        }

        public static Quaternion StringToQuaternion(string sVector)
        {
            if (sVector.StartsWith("(") && sVector.EndsWith(")"))
            {
                sVector = sVector.Substring(1, sVector.Length - 2);
            }
            string[] sArray = sVector.Split(',');
            Quaternion result = new Quaternion(
                float.Parse(sArray[0]),
                float.Parse(sArray[1]),
                float.Parse(sArray[2]),
             float.Parse(sArray[3]));
            return result;
        }


        #endregion

        #region Hooks

        public void CreateZone(BaseEntity entity, string zoneidstr, string[] zoneargs)
        {
            var spawnpos = entity.transform.position;
            var ZoneManager = plugins.Find("ZoneManager");
            if (!Convert.ToBoolean(ZoneManager?.Call("CreateOrUpdateZone", zoneidstr, zoneargs, spawnpos)))
            {
                return;
            }
        }

        public void EraseZone(string zoneid)
        {
            var ZoneManager = plugins.Find("ZoneManager");

            if (!Convert.ToBoolean(ZoneManager?.Call("EraseZone", zoneid)))
            {
                return;
            }
        }

        private int GetRandomTime()
        {
            var respawnroll = EventMaxRestartTime;
            var randomroll = UnityEngine.Random.Range(EventMinRestartTime, EventMaxRestartTime);
            respawnroll = randomroll;
            EventCountDown = true;
            return respawnroll;
        }

        void OnTick()
        {
            if (DoRandomRespawn)
            {
                DoRandomRespawn = false;
                eventrespawntime = GetRandomTime();
                return;
            }
            if (!DoRandomRespawn && EventCountDown)
            {
                if (eventcounter == eventrespawntime)
                { SpawnRandom(); EventCountDown = false; eventcounter = 0; return; }
                eventcounter = eventcounter + 1;
                return;
            }
        }

        void SetAutoSpawnEnabled()
        {
            DoRandomRespawn = true;
        }

        void SpawnRandom()
        {
            var onlineplayers = BasePlayer.activePlayerList.Count;
            if (onlineplayers < MinPlayersForEventSpawn)
            {
                PrintWarning("Minimum Player count not reached, Deepwater Event did not spawn !!!");
                DoRandomRespawn = true;
                return;
            }
            BuildRandomDeepWater(true, true);
        }

        bool IsAllowed(BasePlayer player, string perm)
        {
            if (permission.UserHasPermission(player.userID.ToString(), perm)) return true;
            return false;
        }

        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
        {
            if (CanDamageRig) return;
            if (entity == null || hitInfo == null) return;
            var isdeepwater = entity.GetComponentInParent<DeepWaterEntity>();
            if (isdeepwater) hitInfo.damageTypes.ScaleAll(0);
            return;
        }

        void OnEntityDeath(BaseCombatEntity target, HitInfo info)
        {
            if (target == null || target.net == null || info == null) return;
            if (storedData.saveRigData.ContainsKey(target.net.ID))
            {
                storedData.saveRigData.Remove(target.net.ID);
                SaveData();
            }
        }

        private object OnEntityGroundMissing(BaseEntity entity)
        {
            var onship = entity.GetComponentInParent<DeepWaterEntity>();
            if (onship != null) return false;
            return null;
        }

        private object CanBuild(Planner plan, Construction prefab, object obj)
        {
            if (plan == null || prefab == null || obj == null) return null;
            if (obj is Construction.Target)
            {
                var target = (Construction.Target)obj;
                var targetent = target.entity as BaseEntity;
                var isdeepwater = targetent?.GetComponentInParent<DeepWaterEntity>();
                if (isdeepwater) return false;
                return null;
            }
            else return null;
        }

        private object CanPickupEntity(BasePlayer player, BaseCombatEntity entity)
        {
            if (entity == null || player == null) return null;
            if (entity.GetComponentInParent<DeepWaterEntity>()) return false;
            return null;
        }

        Vector3 FindSpawnPoint()
        {
            Vector3 spawnpoint = new Vector3();
            float mapoffset = 75f;
            float spawnline = ((ConVar.Server.worldsize) / 2) - 75f;

            float sidepicked = UnityEngine.Random.Range(1, 5);
            if (sidepicked == 1) spawnpoint = new Vector3(UnityEngine.Random.Range(-spawnline, spawnline), RigSpawnHeight, -spawnline);
            else if (sidepicked == 2) spawnpoint = new Vector3(UnityEngine.Random.Range(-spawnline, spawnline), RigSpawnHeight, spawnline);
            else if (sidepicked == 3) spawnpoint = new Vector3(spawnline, RigSpawnHeight, UnityEngine.Random.Range(-spawnline, spawnline));
            else if (sidepicked == 4) spawnpoint = new Vector3(-spawnline, RigSpawnHeight, UnityEngine.Random.Range(-spawnline, spawnline));
            return spawnpoint;
        }

        string GetGridLocation(Vector3 position)
        {
            Vector2 offsetPos = new Vector2((World.Size / 2 - 6) + position.x, (World.Size / 2 - 56) - position.z);
            string gridstring = $"{Convert.ToChar(65 + (int)offsetPos.x / 146)}{(int)(offsetPos.y / 146)}";
            return gridstring;
        }

        public void BuildRandomDeepWater(bool eventstarted, bool autospawned = false)
        {
            string prefabpumpjack = "assets/prefabs/deployable/large wood storage/box.wooden.large.prefab";
            var spawnpos = FindSpawnPoint();
            BaseEntity newrig = GameManager.server.CreateEntity(prefabpumpjack, new Vector3(spawnpos.x, spawnpos.y, spawnpos.z), Quaternion.identity, true);
            newrig.OwnerID = 0;
            newrig?.Spawn();
            var addrigstructure = newrig.gameObject.AddComponent<DeepWaterEntity>();
            newrig.transform.hasChanged = true;
            newrig.SendNetworkUpdateImmediate();
            newrig.UpdateNetworkGroup();
            if (!eventstarted) AddData(newrig.net.ID, newrig.OwnerID, newrig.transform.position.ToString(), newrig.transform.eulerAngles.ToString(), newrig.transform.rotation.ToString());

            addrigstructure.israndom = true;
            if (eventstarted == true) { addrigstructure.stage1 = true; addrigstructure.isevent = true; }
            if (autospawned == true) { addrigstructure.isautospawn = true; }
            string getgrid = GetGridLocation(newrig.transform.position);
            if ((!eventstarted && BroadcastSpawn) || (eventstarted && BroadcastEventSpawn))
            {
                if (eventstarted) PrintWarning(TOD_Sky.Instance.Cycle.Hour + " : DeepWater Event Started at Grid : " + getgrid);
                if (eventstarted) { ConVar.Chat.Broadcast("Rig Event has Spawned at Grid : " + getgrid, "DeepWater", "#4286f4"); return; }
                ConVar.Chat.Broadcast("Rig has Spawned at Grid : " + getgrid, "DeepWater", "#4286f4");
            }
        }

        public void BuildLocalDeepWater(BasePlayer player, bool eventstarted, int compound = 0)
        {
            string prefabpumpjack = "assets/prefabs/deployable/large wood storage/box.wooden.large.prefab";
            var spawnpos = new Vector3(player.transform.position.x, RigSpawnHeight, player.transform.position.z);
            BaseEntity newrig = GameManager.server.CreateEntity(prefabpumpjack, spawnpos, new Quaternion(), true);
            newrig.OwnerID = 0;
            newrig?.Spawn();
            var addrigstructure = newrig.gameObject.AddComponent<DeepWaterEntity>();
            if (!eventstarted) AddData(newrig.net.ID, newrig.OwnerID, newrig.transform.position.ToString(), newrig.transform.eulerAngles.ToString(), newrig.transform.rotation.ToString(), compound);
            addrigstructure.israndom = false;
            if (compound == 1) addrigstructure.iscompound = true;
            if (eventstarted == true) { addrigstructure.stage1 = true; addrigstructure.isevent = true; }
            string getgrid = GetGridLocation(newrig.transform.position);
            if ((!eventstarted && BroadcastSpawn) || (eventstarted && BroadcastEventSpawn))
            {
                if (eventstarted) PrintWarning(TOD_Sky.Instance.Cycle.Hour + " : DeepWater Event Started at Grid : " + getgrid);

                if (compound == 1) { ConVar.Chat.Broadcast("Rig Compound has Spawned at Grid : " + getgrid, "DeepWater", "#4286f4"); return; }
                if (eventstarted) { ConVar.Chat.Broadcast("Rig Event has Spawned at Grid : " + getgrid, "DeepWater", "#4286f4"); return; }
                ConVar.Chat.Broadcast("Rig has Spawned at Grid : " + getgrid, "DeepWater", "#4286f4");
            }
        }

        void SpawnRig(ulong ownerid, Vector3 pos, Quaternion rot, Vector3 angle, int compound = 0)
        {
            string prefabpumpjack = "assets/prefabs/deployable/large wood storage/box.wooden.large.prefab";
            BaseEntity newrig = GameManager.server.CreateEntity(prefabpumpjack, pos, rot, true);
            newrig.OwnerID = ownerid;
            newrig?.Spawn();
            var addrigstructure = newrig.gameObject.AddComponent<DeepWaterEntity>();
            if (compound == 1) addrigstructure.iscompound = true;
            AddData(newrig.net.ID, ownerid, pos.ToString(), angle.ToString(), rot.ToString(), compound);
        }

        void DestroyAll()
        {
            var objects = GameObject.FindObjectsOfType<DeepWaterEntity>();
            if (objects != null)
                foreach (var gameObj in objects)
                {
                    if (gameObj.GetComponent<DeepWaterEntity>().isevent) GameObject.Destroy(gameObj);
                    if (DestroyRandomOnReload && gameObj.GetComponent<DeepWaterEntity>().israndom) GameObject.Destroy(gameObj);
                    if (DestroyLocalOnReload && !gameObj.GetComponent<DeepWaterEntity>().israndom) GameObject.Destroy(gameObj);
                    break;
                }
        }

        void Unload()
        {
            SaveData();
            DestroyAll();
        }

        #endregion

        #region DeepWater Entity

        public class DeepWaterEntity : BaseEntity
        {
            DeepWater deepwater;
            public MiningQuarry pumpjackentity;
            BaseEntity entity;
            Vector3 entitypos;
            Quaternion entityrot;

            BaseEntity spawnEntity;

            BaseEntity refinerysmall;
            BaseEntity furnacelarge;
            BaseEntity windmill;

            BaseEntity lootspawn1; BaseEntity lootspawn2; BaseEntity lootspawn3; BaseEntity lootspawn4;
            BaseEntity lootspawn5; BaseEntity lootspawn6; BaseEntity lootspawn7; BaseEntity lootspawn8;

            BaseEntity leg1floorbase;
            BaseEntity leg1floor5wall1; BaseEntity leg1floor5wall2; BaseEntity leg1floor5wall3; BaseEntity leg1floor5wall4;
            BaseEntity leg1floor4wall1; BaseEntity leg1floor4wall2; BaseEntity leg1floor4wall3; BaseEntity leg1floor4wall4;
            BaseEntity leg1floor1wall1; BaseEntity leg1floor1wall2; BaseEntity leg1floor1wall3; BaseEntity leg1floor1wall4;
            BaseEntity leg1floor2wall1; BaseEntity leg1floor2wall2; BaseEntity leg1floor2wall3; BaseEntity leg1floor2wall4;
            BaseEntity leg1floor3wall1; BaseEntity leg1floor3wall2; BaseEntity leg1floor3wall3; BaseEntity leg1floor3wall4;

            BaseEntity leg2floorbase;
            BaseEntity leg2floor5wall1; BaseEntity leg2floor5wall2; BaseEntity leg2floor5wall3; BaseEntity leg2floor5wall4;
            BaseEntity leg2floor4wall1; BaseEntity leg2floor4wall2; BaseEntity leg2floor4wall3; BaseEntity leg2floor4wall4;
            BaseEntity leg2floor1wall1; BaseEntity leg2floor1wall2; BaseEntity leg2floor1wall3; BaseEntity leg2floor1wall4;
            BaseEntity leg2floor2wall1; BaseEntity leg2floor2wall2; BaseEntity leg2floor2wall3; BaseEntity leg2floor2wall4;
            BaseEntity leg2floor3wall1; BaseEntity leg2floor3wall2; BaseEntity leg2floor3wall3; BaseEntity leg2floor3wall4;

            BaseEntity leg3floorbase;
            BaseEntity leg3floor5wall1; BaseEntity leg3floor5wall2; BaseEntity leg3floor5wall3; BaseEntity leg3floor5wall4;
            BaseEntity leg3floor4wall1; BaseEntity leg3floor4wall2; BaseEntity leg3floor4wall3; BaseEntity leg3floor4wall4;
            BaseEntity leg3floor1wall1; BaseEntity leg3floor1wall2; BaseEntity leg3floor1wall3; BaseEntity leg3floor1wall4;
            BaseEntity leg3floor2wall1; BaseEntity leg3floor2wall2; BaseEntity leg3floor2wall3; BaseEntity leg3floor2wall4;
            BaseEntity leg3floor3wall1; BaseEntity leg3floor3wall2; BaseEntity leg3floor3wall3; BaseEntity leg3floor3wall4;

            BaseEntity leg4floorbase;
            BaseEntity leg4floor5wall1; BaseEntity leg4floor5wall2; BaseEntity leg4floor5wall3; BaseEntity leg4floor5wall4;
            BaseEntity leg4floor4wall1; BaseEntity leg4floor4wall2; BaseEntity leg4floor4wall3; BaseEntity leg4floor4wall4;
            BaseEntity leg4floor1wall1; BaseEntity leg4floor1wall2; BaseEntity leg4floor1wall3; BaseEntity leg4floor1wall4;
            BaseEntity leg4floor2wall1; BaseEntity leg4floor2wall2; BaseEntity leg4floor2wall3; BaseEntity leg4floor2wall4;
            BaseEntity leg4floor3wall1; BaseEntity leg4floor3wall2; BaseEntity leg4floor3wall3; BaseEntity leg4floor3wall4;

            BaseEntity deck1row1floor1; BaseEntity deck1row1floor2; BaseEntity deck1row1floor3; BaseEntity deck1row1floor4; BaseEntity deck1row1floor5; BaseEntity deck1row1floor6; BaseEntity deck1row1floor7;
            BaseEntity deck1row2floor1; BaseEntity deck1row2floor2; BaseEntity deck1row2floor3; BaseEntity deck1row2floor4; BaseEntity deck1row2floor5; BaseEntity deck1row2floor6; BaseEntity deck1row2floor7;
            BaseEntity deck1row3floor1; BaseEntity deck1row3floor2; BaseEntity deck1row3floor3; BaseEntity deck1row3floor4; BaseEntity deck1row3floor5;
            BaseEntity deck1row4floor1; BaseEntity deck1row4floor2; BaseEntity deck1row4floor3; BaseEntity deck1row4floor4; BaseEntity deck1row4floor5;
            BaseEntity helipadsupport1; BaseEntity helipadsupport2; BaseEntity helipadsupport3; BaseEntity helipadsupport4; BaseEntity helipadsupport5;
            BaseEntity deck1row2lowwall1; BaseEntity deck1row2lowwall2; BaseEntity deck1row2lowwall3; BaseEntity deck1row2lowwall4; BaseEntity deck1row2lowwall5;
            BaseEntity deck1row3lowwall1; BaseEntity deck1row3lowwall2; BaseEntity deck1row3lowwall3; BaseEntity deck1row3lowwall4; BaseEntity deck1row3lowwall5;
            BaseEntity deck1row4lowwall1; BaseEntity deck1row4lowwall2; BaseEntity deck1row4lowwall3; BaseEntity deck1row4lowwall4; BaseEntity deck1row4lowwall5;
            BaseEntity deck1row1wallframe1; BaseEntity deck1row1wallframe2; BaseEntity deck1row1wallframe3; BaseEntity deck1row1wallframe4; BaseEntity deck1row1wallframe5;
            BaseEntity deck1row2wallframe1; BaseEntity deck1row2wallframe2; BaseEntity deck1row2wallframe3; BaseEntity deck1row2wallframe4; BaseEntity deck1row2wallframe5;
            BaseEntity deck1row3wallframe1; BaseEntity deck1row3wallframe2; BaseEntity deck1row3wallframe3; BaseEntity deck1row3wallframe4; BaseEntity deck1row3wallframe5;
            BaseEntity deck1row4wallframe1; BaseEntity deck1row4wallframe2; BaseEntity deck1row4wallframe3; BaseEntity deck1row4wallframe4; BaseEntity deck1row4wallframe5;
            BaseEntity deck1row1floorframe1; BaseEntity deck1row1floorframe2; BaseEntity deck1row1floorframe3; BaseEntity deck1row1floorframe4; BaseEntity deck1row1floorframe5;
            BaseEntity deck1row1floorgrill1; BaseEntity deck1row1floorgrill2; BaseEntity deck1row1floorgrill3; BaseEntity deck1row1floorgrill4; BaseEntity deck1row1floorgrill5;
            BaseEntity deck1row2floorframe1; BaseEntity deck1row2floorframe2; BaseEntity deck1row2floorframe3; BaseEntity deck1row2floorframe4; BaseEntity deck1row2floorframe5;
            BaseEntity deck1row2floorgrill1; BaseEntity deck1row2floorgrill2; BaseEntity BucketLift; BaseEntity deck1row2floorgrill4; BaseEntity deck1row2floorgrill5;
            BaseEntity deck1row3floorframe1; BaseEntity deck1row3floorframe2; BaseEntity deck1row3floorframe3;
            BaseEntity deck1row3floorgrill1; BaseEntity deck1row3floorgrill2; BaseEntity deck1row3floorgrill3;
            BaseEntity deck1row4floorframe1; BaseEntity deck1row4floorframe2; BaseEntity deck1row4floorframe3;
            BaseEntity deck1row4floorgrill1; BaseEntity deck1row4floorgrill2; BaseEntity deck1row4floorgrill3;

            BaseEntity deck2frontrowfloor1; BaseEntity deck2frontrowfloor2; BaseEntity deck2frontrowfloor3; BaseEntity deck2frontrowfloor4; BaseEntity deck2frontrowfloor5;
            BaseEntity deck2row1floor1; BaseEntity deck2row1floor2; BaseEntity deck2row1floor3; BaseEntity deck2row1floor4; BaseEntity deck2row1floor5;
            BaseEntity deck2row2floor1; BaseEntity deck2row2floor2; BaseEntity deck2row2floor3; BaseEntity deck2row2floor4; BaseEntity deck2row2floor5;
            BaseEntity deck2row3floor1; BaseEntity deck2row3floor2; BaseEntity deck2row3floor3;
            BaseEntity deck2row4floor1; BaseEntity deck2row4floor2; BaseEntity deck2row4floor3;
            BaseEntity deck2center1; BaseEntity deck2center2; BaseEntity deck2center3; BaseEntity deck2center4; BaseEntity deck2center5; BaseEntity deck2center6; BaseEntity deck2center7; BaseEntity deck2center8; BaseEntity deck2center9;
            BaseEntity deck2backrowfloor1; BaseEntity deck2backrowfloor2; BaseEntity deck2backrowfloor3; BaseEntity deck2backrowfloor4; BaseEntity deck2backrowfloor5;
            BaseEntity helipadsupportframe1; BaseEntity helipadsupportframe2; BaseEntity helipadsupportframe3; BaseEntity helipadsupportframe4; BaseEntity helipadsupportframe5;
            BaseEntity deck2row2lowwall1; BaseEntity deck2row2lowwall2; BaseEntity deck2row2lowwall3; BaseEntity deck2row2lowwall4; BaseEntity deck2row2lowwall5;
            BaseEntity deck2row3lowwall1; BaseEntity deck2row3lowwall2; BaseEntity deck2row3lowwall3; BaseEntity deck2row3lowwall3U; BaseEntity deck2row3lowwall4; BaseEntity deck2row3lowwall5;
            BaseEntity deck2row4lowwall1; BaseEntity deck2row4lowwall2; BaseEntity deck2row4lowwall3; BaseEntity deck2row4lowwall3U; BaseEntity deck2row4lowwall4; BaseEntity deck2row4lowwall5;
            BaseEntity ladder1leg1; BaseEntity ladder2leg1; BaseEntity ladder3leg1; BaseEntity ladder4leg1; BaseEntity ladder5leg1; BaseEntity ladder6leg1;
            BaseEntity ladder1leg2; BaseEntity ladder2leg2; BaseEntity ladder3leg2; BaseEntity ladder4leg2; BaseEntity ladder5leg2; BaseEntity ladder6leg2;
            BaseEntity ladder1leg3; BaseEntity ladder2leg3; BaseEntity ladder3leg3; BaseEntity ladder4leg3; BaseEntity ladder5leg3; BaseEntity ladder6leg3;
            BaseEntity ladder1leg4; BaseEntity ladder2leg4; BaseEntity ladder3leg4; BaseEntity ladder4leg4; BaseEntity ladder5leg4; BaseEntity ladder6leg4;

            BaseEntity lowerlight1; BaseEntity lowerlight2; BaseEntity lowerlight3; BaseEntity lowerlight4;
            BaseEntity lowerlight5; BaseEntity lowerlight6; BaseEntity lowerlight7; BaseEntity lowerlight8;

            BaseEntity upperlight1; BaseEntity upperlight2; BaseEntity upperlight3; BaseEntity upperlight4; BaseEntity upperlight5; BaseEntity upperlight6; BaseEntity upperlight7;

            BaseEntity helipadfloor1; BaseEntity helipadfloor2; BaseEntity helipadfloor3; BaseEntity helipadfloor4; BaseEntity helipadfloor5;
            BaseEntity helipadfloor6; BaseEntity helipadfloor7; BaseEntity helipadfloor8; BaseEntity helipadfloor9; BaseEntity helipadfloor10;
            BaseEntity helipadfence1; BaseEntity helipadfence2; BaseEntity helipadfence3; BaseEntity helipadfence4; BaseEntity helipadfence5;
            BaseEntity helilogo1; BaseEntity helilogo2;

            BaseEntity helicopter; BaseEntity helicrate;

            BaseEntity explosivecrate1; BaseEntity explosivecrate2; BaseEntity explosivecrate3; BaseEntity explosivecrate4; BaseEntity explosivecrate5;
            BaseEntity explosivecrate6; BaseEntity explosivecrate7; BaseEntity explosivecrate8; BaseEntity explosivecrate9; BaseEntity explosivecrate10;

            BaseEntity vendattire; BaseEntity vendbuilding; BaseEntity vendcomponents; BaseEntity vendresources; BaseEntity vendtools; BaseEntity vendweapons;
            BaseEntity peacekeeper1; BaseEntity peacekeeper2; BaseEntity peacekeeper3; BaseEntity peacekeeper4; BaseEntity peacekeeper5;
            BaseEntity recycler1; BaseEntity recycler2; BaseEntity workbench; BaseEntity researchtable; BaseEntity waterwell;

            BoxCollider boxcollider;
            bool didspawnvariables;
            bool setactive;
            bool isrepairing;
            public bool iscompound;
            public bool israndom;
            public bool isevent;
            public bool isautospawn;
            public bool stage1;
            public int stage1time;
            int stage1counter;
            public bool stage2;
            public int stage2time;
            int stage2counter;
            public bool stage3;
            bool stage3startfire;
            public int stage3time;
            public int stage3barreltime;
            int stage3barrelcounter;
            int stage3counter;
            public bool stage4;
            public int stage4time;
            int stage4counter;
            float F1HeightOffset;
            float F2HeightOffset;
            float F3HeightOffset;
            float F4HeightOffset;
            float F5HeightOffset;
            float ShiftOffset;
            float UDHeightOffset;
            float LDHeightOffSet;
            int count;
            int despawncount;
            int liftcount;
            int maxlootcrates;
            public int currentlootcrates;
            BaseEntity mapmarker;
            uint entitynetid;
            string zoneid;
            bool dorigdestroy;

            string prefabfoundation = "assets/prefabs/building core/foundation/foundation.prefab";
            string prefabfoundationsteps = "assets/prefabs/building core/foundation.steps/foundation.steps.prefab";
            string prefabfloor = "assets/prefabs/building core/floor/floor.prefab";
            string prefabfloorframe = "assets/prefabs/building core/floor/floor.prefab";
            //string prefabfloorframe = "assets/prefabs/building core/floor.frame/floor.frame.prefab";
            string prefabfloorgrill = "assets/prefabs/building/floor.grill/floor.grill.prefab";
            string prefabwall = "assets/prefabs/building core/wall/wall.prefab";
            string prefabwallframe = "assets/prefabs/building core/wall.frame/wall.frame.prefab";
            string prefabwallhalf = "assets/prefabs/building core/wall.half/wall.half.prefab";
            string prefablowwall = "assets/prefabs/building core/wall.low/wall.low.prefab";
            string prefabstairsl = "assets/prefabs/building core/stairs.l/block.stair.lshape.prefab";
            string prefabdoorway = "assets/prefabs/building core/wall.doorway/wall.doorway.prefab";
            string prefabpumpjack = "assets/prefabs/deployable/oil jack/mining.pumpjack.prefab";
            string prefabladder = "assets/prefabs/building/ladder.wall.wood/ladder.wooden.wall.prefab";
            string prefabrefinerysmall = "assets/prefabs/deployable/oil refinery/refinery_small_deployed.prefab";
            string prefabfurnacelarge = "assets/prefabs/deployable/furnace.large/furnace.large.prefab";
            string prefabwindmill = "assets/prefabs/deployable/windmill/generator.wind.scrap.prefab";
            string prefabnpc = "assets/prefabs/npc/scientist/scientist.prefab";
            string prefabrowboat = "assets/content/vehicles/boats/rowboat/rowboat.prefab";
            string prefabceilinglight = "assets/prefabs/deployable/ceiling light/ceilinglight.deployed.prefab";
            string prefabrug = "assets/prefabs/deployable/rug/rug.deployed.prefab";         //1371746398
            string prefabfence = "assets/prefabs/building/wall.frame.fence/wall.frame.fence.prefab";
            string prefabheli = "assets/prefabs/npc/ch47/ch47scientists.entity.prefab";
            string prefabexplosivecrate = "assets/bundled/prefabs/radtown/oil_barrel.prefab";
            string prefabfireball = "assets/bundled/prefabs/fireball.prefab";

            string prefabattirevending = "assets/prefabs/deployable/vendingmachine/npcvendingmachines/npcvendingmachine_attire.prefab";
            string prefabbuildingvending = "assets/prefabs/deployable/vendingmachine/npcvendingmachines/npcvendingmachine_building.prefab";
            string prefabcomponentsvending = "assets/prefabs/deployable/vendingmachine/npcvendingmachines/npcvendingmachine_components.prefab";
            string prefabresourcesvending = "assets/prefabs/deployable/vendingmachine/npcvendingmachines/npcvendingmachine_resources.prefab";
            string prefabtoolsvending = "assets/prefabs/deployable/vendingmachine/npcvendingmachines/npcvendingmachine_tools.prefab";
            string prefabweaponsvending = "assets/prefabs/deployable/vendingmachine/npcvendingmachines/npcvendingmachine_weapons.prefab";
            string prefabpeacekeeper = "assets/content/props/sentry_scientists/sentry.scientist.static.prefab";

            string prefabrecycler = "assets/bundled/prefabs/static/recycler_static.prefab";
            string prefabworkbench = "assets/prefabs/deployable/tier 3 workbench/workbench3.deployed.prefab";
            string prefabresearchtable = "assets/prefabs/deployable/research table/researchtable_deployed.prefab";
            string prefabwaterwell = "assets/prefabs/deployable/water well/waterwellstatic.prefab";

            void Awake()
            {
                entity = GetComponentInParent<BaseEntity>();
                pumpjackentity = GetComponent<MiningQuarry>();
                entitypos = entity.transform.position;
                entityrot = Quaternion.identity;
                gameObject.name = "DeepWater";
                deepwater = new DeepWater();
                entitynetid = entity.net.ID;
                setactive = true;
                dorigdestroy = false;
                didspawnvariables = false;
                isrepairing = false;
                iscompound = false;
                israndom = false;
                isevent = false;
                isautospawn = false;
                stage1 = false;
                stage1time = Stage1Duration;
                stage1counter = 0;
                stage2 = false;
                stage2time = Stage2Duration;
                stage2counter = 0;
                stage3 = false;
                stage3startfire = false;
                stage3time = Stage3Duration;
                stage3barreltime = Stage3TimeBetweenBarrels;
                stage3barrelcounter = 0;
                stage3counter = 0;
                stage4 = false;
                stage4time = Stage4Duration;
                stage4counter = 0;
                F1HeightOffset = -13f;
                F2HeightOffset = -10f;
                F3HeightOffset = -7f;
                F4HeightOffset = -16f;
                F5HeightOffset = -19f;
                ShiftOffset = 0f;
                UDHeightOffset = -1f;
                LDHeightOffSet = -4f;
                count = 0;
                despawncount = 0;
                liftcount = 0;
                currentlootcrates = 0;
                maxlootcrates = MaxLootCratesToSpawn;
                zoneid = entitynetid.ToString();

                boxcollider = entity.gameObject.AddComponent<BoxCollider>();
                boxcollider.gameObject.layer = (int)Layer.Reserved1;
                boxcollider.isTrigger = true;
                boxcollider.center = new Vector3(0.5f, 5f, 0f);
                // left/right   up/down   front/back
                boxcollider.size = new Vector3(35, 20, 35);

                SpawnPumpJack();
                AddOilDeposit();
                SpawnRefinery();
                SpawnLeg1();
                SpawnLeg2();
                SpawnLeg3();
                SpawnLeg4();
                SpawnLowerDeck();
                SpawnLowerDeckGrid();
                SpawnUpperDeck();
                SpawnHelipad();
                SpawnLowerLights();
                SpawnUpperLights();
            }

            string GetZoneID()
            {
                string zoneidstr = entitynetid.ToString();
                if (isevent && useStaticEventID) { zoneidstr = eventRigZoneID; return zoneidstr; }
                if (iscompound && useStaticComoundID) { zoneidstr = compoundRigZoneID; return zoneidstr; }
                if (israndom && useStaticRandomID) { zoneidstr = randomRigZoneID; return zoneidstr; }
                if (useStaticLocalID) { zoneidstr = localRigZoneID; return zoneidstr; }
                return zoneidstr;
            }

            void AddZone()
            {
                if (entity == null) return;
                zoneid = GetZoneID();
                string[] randomArray = randomzoneargs.Split(',');
                string[] localArray = localzoneargs.Split(',');
                string[] compoundArray = compoundzoneargs.Split(',');
                string[] eventArray = eventzoneargs.Split(',');
                if (isevent && EnableAutoZoneOnRigEvent) { deepwater.CreateZone(entity, zoneid, eventArray); return; }
                if (iscompound && EnableAutoZoneOnCompound) { deepwater.CreateZone(entity, zoneid, compoundArray); return; }
                if (israndom && EnableAutoZoneOnRandom) { deepwater.CreateZone(entity, zoneid, randomArray); return; }
                if (!iscompound && !israndom && EnableAutoZoneOnLocal) { deepwater.CreateZone(entity, zoneid, localArray); return; }
            }

            void DespawnRig()
            {
                dorigdestroy = true;
                OnDestroy();
            }
            private void OnTriggerEnter(Collider col)
            {
                if (col.name.Contains("/player/player.prefab"))
                {
                    var player = col.GetComponentInParent<BasePlayer>() ?? null;
                    if (player != null && player.isMounted)
                    {
                        return;
                    }
                    if (player != null && player.IsSleeping())
                    {
                        return;
                    }
                    if (player.GetParentEntity() == base.gameObject.ToBaseEntity())
                    {
                        return;
                    }
                    if (player != null)
                    {
                        BaseEntity getpar = player.GetParentEntity() ?? null;
                        if (getpar == null)
                        {
                            //player.SetParent(entity, true, true);
                            player.PauseFlyHackDetection(99999f);
                            player.PauseSpeedHackDetection(99999f);
                            player.PauseVehicleNoClipDetection(99999f);
                        }
                    }
                }
            }

            private void OnTriggerExit(Collider col)
            {
                if (col.name.Contains("/player/player.prefab"))
                {
                    var player = col.GetComponentInParent<BasePlayer>() ?? null;
                    if (player != null)
                    {
                        if (player != null && player.IsSleeping())
                        {
                            return;
                        }
                        if (player.GetParentEntity() != base.gameObject.ToBaseEntity())
                        {
                            return;
                        }
                        //player.SetParent(null, true, true);
                        player.PauseFlyHackDetection(5f);
                        player.PauseSpeedHackDetection(5f);
                        player.PauseVehicleNoClipDetection(5f);
                    }
                }
            }

            void CheckVariables()
            {
                SpawnRadBarrels();
                SpawnLadders();
                SpawnLift();
                SpawnRigLoot();
                AddMarker();
                if (iscompound) SpawnCompound();
                AddZone();
                RefreshAll();
                didspawnvariables = true;
            }

            void AddMarker()
            {
                string prefabmarker = "assets/prefabs/tools/map/explosionmarker.prefab";
                mapmarker = GameManager.server.CreateEntity(prefabmarker, entity.transform.position, Quaternion.identity, true);
                mapmarker.Spawn();
            }

            void AddOilDeposit()
            {
                if (HasOilDeposit)
                {
                    var newresourece1 = new ResourceDepositManager.ResourceDeposit();
                    newresourece1 = ResourceDepositManager.GetOrCreate(entity.transform.position);
                    newresourece1.Add(ItemManager.FindItemDefinition("crude.oil"), 1f, 999999, OilDepositTickRate, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM, true);
                    Interface.CallHook("OnResourceDepositCreated", newresourece1);
                }

                if (HasHQMetalDeposit)
                {
                    var newresourece2 = new ResourceDepositManager.ResourceDeposit();
                    newresourece2 = ResourceDepositManager.GetOrCreate(entity.transform.position);
                    newresourece2.Add(ItemManager.FindItemDefinition("hq.metal.ore"), 1f, 999999, HQMetalTickRate, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM, true);
                    Interface.CallHook("OnResourceDepositCreated", newresourece2);
                }

                if (HasSulfurDeposit)
                {
                    var newresourece4 = new ResourceDepositManager.ResourceDeposit();
                    newresourece4 = ResourceDepositManager.GetOrCreate(entity.transform.position);
                    newresourece4.Add(ItemManager.FindItemDefinition("sulfur.ore"), 1f, 999999, SulfurOreTickRate, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM, true);
                    Interface.CallHook("OnResourceDepositCreated", newresourece4);
                }

                if (HasMetalDeposit)
                {
                    var newresourece5 = new ResourceDepositManager.ResourceDeposit();
                    newresourece5 = ResourceDepositManager.GetOrCreate(entity.transform.position);
                    newresourece5.Add(ItemManager.FindItemDefinition("metal.ore"), 1f, 999999, MetalOreTickRate, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM, true);
                    Interface.CallHook("OnResourceDepositCreated", newresourece5);
                }

            }

            private BaseEntity SpawnPart(string prefab, BaseEntity entitypart, bool setactive, int eulangx, int eulangy, int eulangz, float locposx, float locposy, float locposz, uint skinid = 0)
            {
                if (entitypart == null)
                {
                    entitypart = GameManager.server.CreateEntity(prefab, entity.transform.position, entity.transform.rotation, setactive);
                    if (skinid > 0) entitypart.skinID = skinid;
                    entitypart?.Spawn();
                    entitypart.SetParent(entity);
                    entitypart.transform.localEulerAngles = new Vector3(eulangx, eulangy, eulangz);
                    entitypart.transform.localPosition = new Vector3(locposx, locposy, locposz);
                    SpawnRefresh(entitypart);
                }
                if (entitypart != null)
                {
                    return entitypart;
                }
                return null;
            }

            void SpawnRefresh(BaseNetworkable entity1)
            {
                var hasstab = entity1.GetComponent<StabilityEntity>() ?? null;
                if (hasstab != null)
                {
                    hasstab.grounded = true;
                }
                var isladder = entity1.GetComponent<BaseLadder>() ?? null;
                if (isladder != null)
                {
                    isladder.SetFlag(BaseEntity.Flags.Busy, true, true);
                }
                var hasdecay = entity1.GetComponent<DecayEntity>() ?? null;
                if (hasdecay != null)
                {
                    hasdecay.decay = null;
                }
                var hasblock = entity1.GetComponent<BuildingBlock>() ?? null;
                if (hasblock != null)
                {
                    hasblock.SetGrade(BuildingGrade.Enum.TopTier);
                    hasblock.SetHealthToMax();
                    hasblock.UpdateSkin();
                    hasblock.ClientRPC(null, "RefreshSkin");
                }
                var isvending = entity1.GetComponent<NPCVendingMachine>() ?? null;
                if (isvending != null)
                {
                    Invoke(new Action(isvending.InstallFromVendingOrders), 1f);
                }
            }

            public void RefreshAll()
            {
                return;
                if (entity == null) return;
                entity.transform.hasChanged = true;
                entity.SendNetworkUpdateImmediate();
                entity.UpdateNetworkGroup();

                if (entity.children != null)
                    for (int i = 0; i < entity.children.Count; i++)
                    {
                        entity.children[i].transform.hasChanged = true;
                        var isblock = entity.children[i].GetComponent<BuildingBlock>() ?? null;
                        if (isblock != null)
                        {
                            isblock.UpdateSkin();
                            isblock.ClientRPC(null, "RefreshSkin");
                        }
                        entity.children[i].SendNetworkUpdateImmediate(false);
                        entity.children[i].UpdateNetworkGroup();
                    }
            }

            void SpawnPumpJack()
            {
                pumpjackentity = GameManager.server.CreateEntity(prefabpumpjack, entity.transform.position, entity.transform.rotation, true) as MiningQuarry;
                pumpjackentity?.Spawn();
                pumpjackentity.SetParent(entity);
                pumpjackentity.transform.localEulerAngles = new Vector3(0, 0, 0);
                pumpjackentity.transform.localPosition = new Vector3(0f, 0f, 0f);
                if (pumpjackentity != null)
                {
                    ItemContainer component1 = pumpjackentity.GetComponent<MiningQuarry>().fuelStoragePrefab.instance.GetComponent<StorageContainer>().inventory;
                    Item addfuel = ItemManager.CreateByItemID(-946369541, PumpStartingFuel);
                    component1.itemList.Add(addfuel);
                    addfuel.parent = component1;
                    addfuel.MarkDirty();
                    pumpjackentity.EngineSwitch(true);
                }
            }

            void SpawnRefinery()
            {
                refinerysmall = SpawnPart(prefabrefinerysmall, refinerysmall, setactive, 0, 0, 0, 4.3f, 1.2f, 4.5f);
                furnacelarge = SpawnPart(prefabfurnacelarge, furnacelarge, setactive, 0, 0, 0, -7f, 2f, -4f);
                if (furnacelarge != null) furnacelarge.SetFlag(BaseEntity.Flags.On, true, true);
            }

            void SpawnLeg1()
            {
                leg1floorbase = SpawnPart(prefabfoundation, leg1floorbase, setactive, 0, 0, 0, 9f + ShiftOffset, F5HeightOffset, 9f);

                leg1floor5wall1 = SpawnPart(prefabwall, leg1floor5wall1, setactive, 0, 90, 0, 9f + ShiftOffset, F5HeightOffset, 7.5f);
                leg1floor5wall2 = SpawnPart(prefabwall, leg1floor5wall2, setactive, 0, 270, 0, 9f + ShiftOffset, F5HeightOffset, 10.5f);
                leg1floor5wall3 = SpawnPart(prefabwall, leg1floor5wall3, setactive, 0, 180, 0, 7.5f + ShiftOffset, F5HeightOffset, 9f);
                leg1floor5wall4 = SpawnPart(prefabwall, leg1floor5wall4, setactive, 0, 0, 0, 10.5f + ShiftOffset, F5HeightOffset, 9f);

                leg1floor4wall1 = SpawnPart(prefabwall, leg1floor4wall1, setactive, 0, 90, 0, 9f + ShiftOffset, F4HeightOffset, 7.5f);
                leg1floor4wall2 = SpawnPart(prefabwall, leg1floor4wall2, setactive, 0, 270, 0, 9f + ShiftOffset, F4HeightOffset, 10.5f);
                leg1floor4wall3 = SpawnPart(prefabwall, leg1floor4wall3, setactive, 0, 180, 0, 7.5f + ShiftOffset, F4HeightOffset, 9f);
                leg1floor4wall4 = SpawnPart(prefabwall, leg1floor4wall4, setactive, 0, 0, 0, 10.5f + ShiftOffset, F4HeightOffset, 9f);

                leg1floor1wall1 = SpawnPart(prefabwall, leg1floor1wall1, setactive, 0, 90, 0, 9f + ShiftOffset, F1HeightOffset, 7.5f);
                leg1floor1wall2 = SpawnPart(prefabwall, leg1floor1wall2, setactive, 0, 270, 0, 9f + ShiftOffset, F1HeightOffset, 10.5f);
                leg1floor1wall3 = SpawnPart(prefabwall, leg1floor1wall3, setactive, 0, 180, 0, 7.5f + ShiftOffset, F1HeightOffset, 9f);
                leg1floor1wall4 = SpawnPart(prefabwall, leg1floor1wall4, setactive, 0, 0, 0, 10.5f + ShiftOffset, F1HeightOffset, 9f);

                leg1floor2wall1 = SpawnPart(prefabwall, leg1floor2wall1, setactive, 0, 90, 0, 9f + ShiftOffset, F2HeightOffset, 7.5f);
                leg1floor2wall2 = SpawnPart(prefabwall, leg1floor2wall2, setactive, 0, 270, 0, 9f + ShiftOffset, F2HeightOffset, 10.5f);
                leg1floor2wall3 = SpawnPart(prefabwall, leg1floor2wall3, setactive, 0, 180, 0, 7.5f + ShiftOffset, F2HeightOffset, 9f);
                leg1floor2wall4 = SpawnPart(prefabwall, leg1floor2wall4, setactive, 0, 0, 0, 10.5f + ShiftOffset, F2HeightOffset, 9f);

                leg1floor3wall1 = SpawnPart(prefabwall, leg1floor3wall1, setactive, 0, 90, 0, 9f + ShiftOffset, F3HeightOffset, 7.5f);
                leg1floor3wall2 = SpawnPart(prefabwall, leg1floor3wall2, setactive, 0, 270, 0, 9f + ShiftOffset, F3HeightOffset, 10.5f);
                leg1floor3wall3 = SpawnPart(prefabwall, leg1floor3wall3, setactive, 0, 180, 0, 7.5f + ShiftOffset, F3HeightOffset, 9f);
                leg1floor3wall4 = SpawnPart(prefabwall, leg1floor3wall4, setactive, 0, 0, 0, 10.5f + ShiftOffset, F3HeightOffset, 9f);
            }

            void SpawnLeg2()
            {
                leg2floorbase = SpawnPart(prefabfoundation, leg2floorbase, setactive, 0, 0, 0, -9f + ShiftOffset, F5HeightOffset, -9f);

                leg2floor5wall1 = SpawnPart(prefabwall, leg2floor5wall1, setactive, 0, 90, 0, -9f + ShiftOffset, F5HeightOffset, -10.5f);
                leg2floor5wall2 = SpawnPart(prefabwall, leg2floor5wall2, setactive, 0, 270, 0, -9f + ShiftOffset, F5HeightOffset, -7.5f);
                leg2floor5wall3 = SpawnPart(prefabwall, leg2floor5wall3, setactive, 0, 180, 0, -10.5f + ShiftOffset, F5HeightOffset, -9f);
                leg2floor5wall4 = SpawnPart(prefabwall, leg2floor5wall4, setactive, 0, 0, 0, -7.5f + ShiftOffset, F5HeightOffset, -9f);

                leg2floor4wall1 = SpawnPart(prefabwall, leg2floor4wall1, setactive, 0, 90, 0, -9f + ShiftOffset, F4HeightOffset, -10.5f);
                leg2floor4wall2 = SpawnPart(prefabwall, leg2floor4wall2, setactive, 0, 270, 0, -9f + ShiftOffset, F4HeightOffset, -7.5f);
                leg2floor4wall3 = SpawnPart(prefabwall, leg2floor4wall3, setactive, 0, 180, 0, -10.5f + ShiftOffset, F4HeightOffset, -9f);
                leg2floor4wall4 = SpawnPart(prefabwall, leg2floor4wall4, setactive, 0, 0, 0, -7.5f + ShiftOffset, F4HeightOffset, -9f);

                leg2floor1wall1 = SpawnPart(prefabwall, leg2floor1wall1, setactive, 0, 90, 0, -9f + ShiftOffset, F1HeightOffset, -10.5f);
                leg2floor1wall2 = SpawnPart(prefabwall, leg2floor1wall2, setactive, 0, 270, 0, -9f + ShiftOffset, F1HeightOffset, -7.5f);
                leg2floor1wall3 = SpawnPart(prefabwall, leg2floor1wall3, setactive, 0, 180, 0, -10.5f + ShiftOffset, F1HeightOffset, -9f);
                leg2floor1wall4 = SpawnPart(prefabwall, leg2floor1wall4, setactive, 0, 0, 0, -7.5f + ShiftOffset, F1HeightOffset, -9f);

                leg2floor2wall1 = SpawnPart(prefabwall, leg2floor2wall1, setactive, 0, 90, 0, -9f + ShiftOffset, F2HeightOffset, -10.5f);
                leg2floor2wall2 = SpawnPart(prefabwall, leg2floor2wall2, setactive, 0, 270, 0, -9f + ShiftOffset, F2HeightOffset, -7.5f);
                leg2floor2wall3 = SpawnPart(prefabwall, leg2floor2wall3, setactive, 0, 180, 0, -10.5f + ShiftOffset, F2HeightOffset, -9f);
                leg2floor2wall4 = SpawnPart(prefabwall, leg2floor2wall4, setactive, 0, 0, 0, -7.5f + ShiftOffset, F2HeightOffset, -9f);

                leg2floor3wall1 = SpawnPart(prefabwall, leg2floor3wall1, setactive, 0, 90, 0, -9f + ShiftOffset, F3HeightOffset, -10.5f);
                leg2floor3wall2 = SpawnPart(prefabwall, leg2floor3wall2, setactive, 0, 270, 0, -9f + ShiftOffset, F3HeightOffset, -7.5f);
                leg2floor3wall3 = SpawnPart(prefabwall, leg2floor3wall3, setactive, 0, 180, 0, -10.5f + ShiftOffset, F3HeightOffset, -9f);
                leg2floor3wall4 = SpawnPart(prefabwall, leg2floor3wall4, setactive, 0, 0, 0, -7.5f + ShiftOffset, F3HeightOffset, -9f);
            }

            void SpawnLeg3()
            {
                leg3floorbase = SpawnPart(prefabfoundation, leg3floorbase, setactive, 0, 0, 0, 9f + ShiftOffset, F5HeightOffset, -9f);

                leg3floor5wall1 = SpawnPart(prefabwall, leg3floor5wall1, setactive, 0, 90, 0, 9f + ShiftOffset, F5HeightOffset, -10.5f);
                leg3floor5wall2 = SpawnPart(prefabwall, leg3floor5wall2, setactive, 0, 270, 0, 9f + ShiftOffset, F5HeightOffset, -7.5f);
                leg3floor5wall3 = SpawnPart(prefabwall, leg3floor5wall3, setactive, 0, 180, 0, 7.5f + ShiftOffset, F5HeightOffset, -9f);
                leg3floor5wall4 = SpawnPart(prefabwall, leg3floor5wall4, setactive, 0, 0, 0, 10.5f + ShiftOffset, F5HeightOffset, -9f);

                leg3floor4wall1 = SpawnPart(prefabwall, leg3floor4wall1, setactive, 0, 90, 0, 9f + ShiftOffset, F4HeightOffset, -10.5f);
                leg3floor4wall2 = SpawnPart(prefabwall, leg3floor4wall2, setactive, 0, 270, 0, 9f + ShiftOffset, F4HeightOffset, -7.5f);
                leg3floor4wall3 = SpawnPart(prefabwall, leg3floor4wall3, setactive, 0, 180, 0, 7.5f + ShiftOffset, F4HeightOffset, -9f);
                leg3floor4wall4 = SpawnPart(prefabwall, leg3floor4wall4, setactive, 0, 0, 0, 10.5f + ShiftOffset, F4HeightOffset, -9f);

                leg3floor1wall1 = SpawnPart(prefabwall, leg3floor1wall1, setactive, 0, 90, 0, 9f + ShiftOffset, F1HeightOffset, -10.5f);
                leg3floor1wall2 = SpawnPart(prefabwall, leg3floor1wall2, setactive, 0, 270, 0, 9f + ShiftOffset, F1HeightOffset, -7.5f);
                leg3floor1wall3 = SpawnPart(prefabwall, leg3floor1wall3, setactive, 0, 180, 0, 7.5f + ShiftOffset, F1HeightOffset, -9f);
                leg3floor1wall4 = SpawnPart(prefabwall, leg3floor1wall4, setactive, 0, 0, 0, 10.5f + ShiftOffset, F1HeightOffset, -9f);

                leg3floor2wall1 = SpawnPart(prefabwall, leg3floor2wall1, setactive, 0, 90, 0, 9f + ShiftOffset, F2HeightOffset, -10.5f);
                leg3floor2wall2 = SpawnPart(prefabwall, leg3floor2wall2, setactive, 0, 270, 0, 9f + ShiftOffset, F2HeightOffset, -7.5f);
                leg3floor2wall3 = SpawnPart(prefabwall, leg3floor2wall3, setactive, 0, 180, 0, 7.5f + ShiftOffset, F2HeightOffset, -9f);
                leg3floor2wall4 = SpawnPart(prefabwall, leg3floor2wall4, setactive, 0, 0, 0, 10.5f + ShiftOffset, F2HeightOffset, -9f);

                leg3floor3wall1 = SpawnPart(prefabwall, leg3floor3wall1, setactive, 0, 90, 0, 9f + ShiftOffset, F3HeightOffset, -10.5f);
                leg3floor3wall2 = SpawnPart(prefabwall, leg3floor3wall2, setactive, 0, 270, 0, 9f + ShiftOffset, F3HeightOffset, -7.5f);
                leg3floor3wall3 = SpawnPart(prefabwall, leg3floor3wall3, setactive, 0, 180, 0, 7.5f + ShiftOffset, F3HeightOffset, -9f);
                leg3floor3wall4 = SpawnPart(prefabwall, leg3floor3wall4, setactive, 0, 0, 0, 10.5f + ShiftOffset, F3HeightOffset, -9f);
            }

            void SpawnLeg4()
            {
                leg4floorbase = SpawnPart(prefabfoundation, leg4floorbase, setactive, 0, 0, 0, -9f + ShiftOffset, F5HeightOffset, 9f);

                leg4floor5wall1 = SpawnPart(prefabwall, leg4floor5wall1, setactive, 0, 90, 0, -9f + ShiftOffset, F5HeightOffset, 7.5f);
                leg4floor5wall2 = SpawnPart(prefabwall, leg4floor5wall2, setactive, 0, 270, 0, -9f + ShiftOffset, F5HeightOffset, 10.5f);
                leg4floor5wall3 = SpawnPart(prefabwall, leg4floor5wall3, setactive, 0, 180, 0, -10.5f + ShiftOffset, F5HeightOffset, 9f);
                leg4floor5wall4 = SpawnPart(prefabwall, leg4floor5wall4, setactive, 0, 0, 0, -7.5f + ShiftOffset, F5HeightOffset, 9f);

                leg4floor4wall1 = SpawnPart(prefabwall, leg4floor4wall1, setactive, 0, 90, 0, -9f + ShiftOffset, F4HeightOffset, 7.5f);
                leg4floor4wall2 = SpawnPart(prefabwall, leg4floor4wall2, setactive, 0, 270, 0, -9f + ShiftOffset, F4HeightOffset, 10.5f);
                leg4floor4wall3 = SpawnPart(prefabwall, leg4floor4wall3, setactive, 0, 180, 0, -10.5f + ShiftOffset, F4HeightOffset, 9f);
                leg4floor4wall4 = SpawnPart(prefabwall, leg4floor4wall4, setactive, 0, 0, 0, -7.5f + ShiftOffset, F4HeightOffset, 9f);

                leg4floor1wall1 = SpawnPart(prefabwall, leg4floor1wall1, setactive, 0, 90, 0, -9f + ShiftOffset, F1HeightOffset, 7.5f);
                leg4floor1wall2 = SpawnPart(prefabwall, leg4floor1wall2, setactive, 0, 270, 0, -9f + ShiftOffset, F1HeightOffset, 10.5f);
                leg4floor1wall3 = SpawnPart(prefabwall, leg4floor1wall3, setactive, 0, 180, 0, -10.5f + ShiftOffset, F1HeightOffset, 9f);
                leg4floor1wall4 = SpawnPart(prefabwall, leg4floor1wall4, setactive, 0, 0, 0, -7.5f + ShiftOffset, F1HeightOffset, 9f);

                leg4floor2wall1 = SpawnPart(prefabwall, leg4floor2wall1, setactive, 0, 90, 0, -9f + ShiftOffset, F2HeightOffset, 7.5f);
                leg4floor2wall2 = SpawnPart(prefabwall, leg4floor2wall2, setactive, 0, 270, 0, -9f + ShiftOffset, F2HeightOffset, 10.5f);
                leg4floor2wall3 = SpawnPart(prefabwall, leg4floor2wall3, setactive, 0, 180, 0, -10.5f + ShiftOffset, F2HeightOffset, 9f);
                leg4floor2wall4 = SpawnPart(prefabwall, leg4floor2wall4, setactive, 0, 0, 0, -7.5f + ShiftOffset, F2HeightOffset, 9f);

                leg4floor3wall1 = SpawnPart(prefabwall, leg4floor3wall1, setactive, 0, 90, 0, -9f + ShiftOffset, F3HeightOffset, 7.5f);
                leg4floor3wall2 = SpawnPart(prefabwall, leg4floor3wall2, setactive, 0, 270, 0, -9f + ShiftOffset, F3HeightOffset, 10.5f);
                leg4floor3wall3 = SpawnPart(prefabwall, leg4floor3wall3, setactive, 0, 180, 0, -10.5f + ShiftOffset, F3HeightOffset, 9f);
                leg4floor3wall4 = SpawnPart(prefabwall, leg4floor3wall4, setactive, 0, 0, 0, -7.5f + ShiftOffset, F3HeightOffset, 9f);
            }

            void SpawnLowerDeck()
            {
                deck1row1floor1 = SpawnPart(prefabfloor, deck1row1floor1, setactive, 0, 0, 0, 9f + ShiftOffset, LDHeightOffSet, 9f);
                deck1row1floor2 = SpawnPart(prefabfloor, deck1row1floor2, setactive, 0, 0, 0, 9f + ShiftOffset, LDHeightOffSet, 6f);
                deck1row1floor3 = SpawnPart(prefabfloor, deck1row1floor3, setactive, 0, 0, 0, 9f + ShiftOffset, LDHeightOffSet, 3f);
                deck1row1floor4 = SpawnPart(prefabfloor, deck1row1floor4, setactive, 0, 0, 0, 9f + ShiftOffset, LDHeightOffSet, 0f);
                deck1row1floor5 = SpawnPart(prefabfloor, deck1row1floor5, setactive, 0, 0, 0, 9f + ShiftOffset, LDHeightOffSet, -3f);
                deck1row1floor6 = SpawnPart(prefabfloor, deck1row1floor6, setactive, 0, 0, 0, 9f + ShiftOffset, LDHeightOffSet, -6f);
                deck1row1floor7 = SpawnPart(prefabfloor, deck1row1floor7, setactive, 0, 0, 0, 9f + ShiftOffset, LDHeightOffSet, -9f);

                deck1row2floor1 = SpawnPart(prefabfloor, deck1row2floor1, setactive, 0, 0, 0, -9f + ShiftOffset, LDHeightOffSet, 9f);
                deck1row2floor2 = SpawnPart(prefabfloor, deck1row2floor2, setactive, 0, 0, 0, -9f + ShiftOffset, LDHeightOffSet, 6f);
                deck1row2floor3 = SpawnPart(prefabfloor, deck1row2floor3, setactive, 0, 0, 0, -9f + ShiftOffset, LDHeightOffSet, 3f);
                deck1row2floor4 = SpawnPart(prefabfloor, deck1row2floor4, setactive, 0, 0, 0, -9f + ShiftOffset, LDHeightOffSet, 0f);
                deck1row2floor5 = SpawnPart(prefabfloor, deck1row2floor5, setactive, 0, 0, 0, -9f + ShiftOffset, LDHeightOffSet, -3f);
                deck1row2floor6 = SpawnPart(prefabfloor, deck1row2floor6, setactive, 0, 0, 0, -9f + ShiftOffset, LDHeightOffSet, -6f);
                deck1row2floor7 = SpawnPart(prefabfloor, deck1row2floor7, setactive, 0, 0, 0, -9f + ShiftOffset, LDHeightOffSet, -9f);

                deck1row3floor1 = SpawnPart(prefabfloor, deck1row3floor1, setactive, 0, 0, 0, 6f + ShiftOffset, LDHeightOffSet, -9f);
                deck1row3floor2 = SpawnPart(prefabfloor, deck1row3floor2, setactive, 0, 0, 0, 3f + ShiftOffset, LDHeightOffSet, -9f);
                deck1row3floor3 = SpawnPart(prefabfloor, deck1row3floor3, setactive, 0, 0, 0, 0f + ShiftOffset, LDHeightOffSet, -9f);
                deck1row3floor4 = SpawnPart(prefabfloor, deck1row3floor4, setactive, 0, 0, 0, -3f + ShiftOffset, LDHeightOffSet, -9f);
                deck1row3floor5 = SpawnPart(prefabfloor, deck1row3floor5, setactive, 0, 0, 0, -6f + ShiftOffset, LDHeightOffSet, -9f);

                deck1row4floor1 = SpawnPart(prefabfloor, deck1row4floor1, setactive, 0, 0, 0, 6f + ShiftOffset, LDHeightOffSet, 9f);
                deck1row4floor2 = SpawnPart(prefabfloor, deck1row4floor2, setactive, 0, 0, 0, 3f + ShiftOffset, LDHeightOffSet, 9f);
                deck1row4floor3 = SpawnPart(prefabfloor, deck1row4floor3, setactive, 0, 0, 0, 0f + ShiftOffset, LDHeightOffSet, 9f);
                deck1row4floor4 = SpawnPart(prefabfloor, deck1row4floor4, setactive, 0, 0, 0, -3f + ShiftOffset, LDHeightOffSet, 9f);
                deck1row4floor5 = SpawnPart(prefabfloor, deck1row4floor5, setactive, 0, 0, 0, -6f + ShiftOffset, LDHeightOffSet, 9f);

                deck1row1wallframe1 = SpawnPart(prefabwallframe, deck1row1wallframe1, setactive, 0, 180, 0, 7.5f + ShiftOffset, LDHeightOffSet, 6f);
                deck1row1wallframe2 = SpawnPart(prefabwall, deck1row1wallframe2, setactive, 0, 180, 0, 4.5f + ShiftOffset, LDHeightOffSet, 3f);
                deck1row1wallframe3 = SpawnPart(prefabwall, deck1row1wallframe3, setactive, 0, 180, 0, 4.5f + ShiftOffset, LDHeightOffSet, 0f);
                deck1row1wallframe4 = SpawnPart(prefabwall, deck1row1wallframe4, setactive, 0, 180, 0, 4.5f + ShiftOffset, LDHeightOffSet, -3f);
                deck1row1wallframe5 = SpawnPart(prefabwallframe, deck1row1wallframe5, setactive, 0, 180, 0, 7.5f + ShiftOffset, LDHeightOffSet, -6f);

                deck1row2wallframe1 = SpawnPart(prefabwallframe, deck1row2wallframe1, setactive, 0, 0, 0, -7.5f + ShiftOffset, LDHeightOffSet, 6f);
                deck1row2wallframe2 = SpawnPart(prefabwall, deck1row2wallframe2, setactive, 0, 0, 0, -4.5f + ShiftOffset, LDHeightOffSet, 3f);
                deck1row2wallframe3 = SpawnPart(prefabwall, deck1row2wallframe3, setactive, 0, 0, 0, -4.5f + ShiftOffset, LDHeightOffSet, 0f);
                deck1row2wallframe4 = SpawnPart(prefabwall, deck1row2wallframe4, setactive, 0, 0, 0, -4.5f + ShiftOffset, LDHeightOffSet, -3f);
                deck1row2wallframe5 = SpawnPart(prefabwallframe, deck1row2wallframe5, setactive, 0, 0, 0, -7.5f + ShiftOffset, LDHeightOffSet, -6f);

                deck1row3wallframe1 = SpawnPart(prefabwallframe, deck1row3wallframe1, setactive, 0, 90, 0, 6f + ShiftOffset, LDHeightOffSet, -7.5f);
                deck1row3wallframe2 = SpawnPart(prefabwall, deck1row3wallframe2, setactive, 0, 90, 0, 3f + ShiftOffset, LDHeightOffSet, -4.5f);
                deck1row3wallframe3 = SpawnPart(prefabwall, deck1row3wallframe3, setactive, 0, 90, 0, 0f + ShiftOffset, LDHeightOffSet, -4.5f);
                deck1row3wallframe4 = SpawnPart(prefabwall, deck1row3wallframe4, setactive, 0, 90, 0, -3f + ShiftOffset, LDHeightOffSet, -4.5f);
                deck1row3wallframe5 = SpawnPart(prefabwallframe, deck1row3wallframe5, setactive, 0, 90, 0, -6f + ShiftOffset, LDHeightOffSet, -7.5f);

                deck1row4wallframe1 = SpawnPart(prefabwallframe, deck1row4wallframe1, setactive, 0, 270, 0, 6f + ShiftOffset, LDHeightOffSet, 7.5f);
                deck1row4wallframe2 = SpawnPart(prefabwall, deck1row4wallframe2, setactive, 0, 270, 0, 3f + ShiftOffset, LDHeightOffSet, 4.5f);
                deck1row4wallframe3 = SpawnPart(prefabwall, deck1row4wallframe3, setactive, 0, 270, 0, 0f + ShiftOffset, LDHeightOffSet, 4.5f);
                deck1row4wallframe4 = SpawnPart(prefabwall, deck1row4wallframe4, setactive, 0, 270, 0, -3f + ShiftOffset, LDHeightOffSet, 4.5f);
                deck1row4wallframe5 = SpawnPart(prefabwallframe, deck1row4wallframe5, setactive, 0, 270, 0, -6f + ShiftOffset, LDHeightOffSet, 7.5f);

                deck1row2lowwall1 = SpawnPart(prefablowwall, deck1row2lowwall1, setactive, 0, 0, 0, -10.5f + ShiftOffset, LDHeightOffSet, 6f);
                deck1row2lowwall2 = SpawnPart(prefablowwall, deck1row2lowwall2, setactive, 0, 0, 0, -10.5f + ShiftOffset, LDHeightOffSet, 3f);
                deck1row2lowwall3 = SpawnPart(prefablowwall, deck1row2lowwall3, setactive, 0, 0, 0, -10.5f + ShiftOffset, LDHeightOffSet, 0f);
                deck1row2lowwall4 = SpawnPart(prefablowwall, deck1row2lowwall4, setactive, 0, 0, 0, -10.5f + ShiftOffset, LDHeightOffSet, -3f);
                deck1row2lowwall5 = SpawnPart(prefablowwall, deck1row2lowwall5, setactive, 0, 0, 0, -10.5f + ShiftOffset, LDHeightOffSet, -6f);

                deck1row3lowwall1 = SpawnPart(prefablowwall, deck1row3lowwall1, setactive, 0, 90, 0, 6f + ShiftOffset, LDHeightOffSet, -10.5f);
                deck1row3lowwall2 = SpawnPart(prefablowwall, deck1row3lowwall2, setactive, 0, 90, 0, 3f + ShiftOffset, LDHeightOffSet, -10.5f);
                deck1row3lowwall3 = SpawnPart(prefablowwall, deck1row3lowwall3, setactive, 0, 90, 0, 0f + ShiftOffset, LDHeightOffSet, -10.5f);
                deck1row3lowwall4 = SpawnPart(prefablowwall, deck1row3lowwall4, setactive, 0, 90, 0, -3f + ShiftOffset, LDHeightOffSet, -10.5f);
                deck1row3lowwall5 = SpawnPart(prefablowwall, deck1row3lowwall5, setactive, 0, 90, 0, -6f + ShiftOffset, LDHeightOffSet, -10.5f);

                deck1row4lowwall1 = SpawnPart(prefablowwall, deck1row4lowwall1, setactive, 0, 270, 0, 6f + ShiftOffset, LDHeightOffSet, 10.5f);
                deck1row4lowwall2 = SpawnPart(prefablowwall, deck1row4lowwall2, setactive, 0, 270, 0, 3f + ShiftOffset, LDHeightOffSet, 10.5f);
                deck1row4lowwall3 = SpawnPart(prefablowwall, deck1row4lowwall3, setactive, 0, 270, 0, 0f + ShiftOffset, LDHeightOffSet, 10.5f);
                deck1row4lowwall4 = SpawnPart(prefablowwall, deck1row4lowwall4, setactive, 0, 270, 0, -3f + ShiftOffset, LDHeightOffSet, 10.5f);
                deck1row4lowwall5 = SpawnPart(prefablowwall, deck1row4lowwall5, setactive, 0, 270, 0, -6f + ShiftOffset, LDHeightOffSet, 10.5f);
            }

            void SpawnLowerDeckGrid()
            {
                deck1row1floorframe1 = SpawnPart(prefabfloorframe, deck1row1floorframe1, setactive, 0, 0, 0, 6f + ShiftOffset, LDHeightOffSet, 6f);
                deck1row1floorframe2 = SpawnPart(prefabfloorframe, deck1row1floorframe2, setactive, 0, 0, 0, 6f + ShiftOffset, LDHeightOffSet, 3f);
                deck1row1floorframe3 = SpawnPart(prefabfloorframe, deck1row1floorframe3, setactive, 0, 0, 0, 6f + ShiftOffset, LDHeightOffSet, 0f);
                deck1row1floorframe4 = SpawnPart(prefabfloorframe, deck1row1floorframe4, setactive, 0, 0, 0, 6f + ShiftOffset, LDHeightOffSet, -3f);
                deck1row1floorframe5 = SpawnPart(prefabfloorframe, deck1row1floorframe5, setactive, 0, 0, 0, 6f + ShiftOffset, LDHeightOffSet, -6f);

                deck1row2floorframe1 = SpawnPart(prefabfloorframe, deck1row2floorframe1, setactive, 0, 0, 0, -6f + ShiftOffset, LDHeightOffSet, 6f);
                deck1row2floorframe2 = SpawnPart(prefabfloorframe, deck1row2floorframe2, setactive, 0, 0, 0, -6f + ShiftOffset, LDHeightOffSet, 3f);
                //deck1row2floorframe3 = SpawnPart(prefabfloorframe, deck1row2floorframe3, setactive, 0, 0, 0, -6f + ShiftOffset, LDHeightOffSet, 0f);
                deck1row2floorframe4 = SpawnPart(prefabfloorframe, deck1row2floorframe4, setactive, 0, 0, 0, -6f + ShiftOffset, LDHeightOffSet, -3f);
                deck1row2floorframe5 = SpawnPart(prefabfloorframe, deck1row2floorframe5, setactive, 0, 0, 0, -6f + ShiftOffset, LDHeightOffSet, -6f);

                deck1row3floorframe1 = SpawnPart(prefabfloorframe, deck1row3floorframe1, setactive, 0, 0, 0, 3f + ShiftOffset, LDHeightOffSet, -6f);
                deck1row3floorframe2 = SpawnPart(prefabfloorframe, deck1row3floorframe2, setactive, 0, 0, 0, 0f + ShiftOffset, LDHeightOffSet, -6f);
                deck1row3floorframe3 = SpawnPart(prefabfloorframe, deck1row3floorframe3, setactive, 0, 0, 0, -3f + ShiftOffset, LDHeightOffSet, -6f);

                deck1row4floorframe1 = SpawnPart(prefabfloorframe, deck1row4floorframe1, setactive, 0, 0, 0, 3f + ShiftOffset, LDHeightOffSet, 6f);
                deck1row4floorframe2 = SpawnPart(prefabfloorframe, deck1row4floorframe2, setactive, 0, 0, 0, 0f + ShiftOffset, LDHeightOffSet, 6f);
                deck1row4floorframe3 = SpawnPart(prefabfloorframe, deck1row4floorframe3, setactive, 0, 0, 0, -3f + ShiftOffset, LDHeightOffSet, 6f);
            }


            void SpawnUpperDeck()
            {

                deck2frontrowfloor1 = SpawnPart(prefabfloor, deck2frontrowfloor1, setactive, 0, 0, 0, 9f + ShiftOffset, UDHeightOffset, 6f);
                deck2frontrowfloor2 = SpawnPart(prefabfloor, deck2frontrowfloor2, setactive, 0, 0, 0, 9f + ShiftOffset, UDHeightOffset, 3f);
                deck2frontrowfloor3 = SpawnPart(prefabfloor, deck2frontrowfloor3, setactive, 0, 0, 0, 9f + ShiftOffset, UDHeightOffset, 0f);
                deck2frontrowfloor4 = SpawnPart(prefabfloor, deck2frontrowfloor4, setactive, 0, 0, 0, 9f + ShiftOffset, UDHeightOffset, -3f);
                deck2frontrowfloor5 = SpawnPart(prefabfloor, deck2frontrowfloor5, setactive, 0, 0, 0, 9f + ShiftOffset, UDHeightOffset, -6f);

                deck2row1floor1 = SpawnPart(prefabfloor, deck2row1floor1, setactive, 0, 0, 0, 6f + ShiftOffset, UDHeightOffset, 6f);
                deck2row1floor2 = SpawnPart(prefabfloor, deck2row1floor2, setactive, 0, 0, 0, 6f + ShiftOffset, UDHeightOffset, 3f);
                deck2row1floor3 = SpawnPart(prefabfloor, deck2row1floor3, setactive, 0, 0, 0, 6f + ShiftOffset, UDHeightOffset, 0f);
                deck2row1floor4 = SpawnPart(prefabfloor, deck2row1floor4, setactive, 0, 0, 0, 6f + ShiftOffset, UDHeightOffset, -3f);
                deck2row1floor5 = SpawnPart(prefabfloor, deck2row1floor5, setactive, 0, 0, 0, 6f + ShiftOffset, UDHeightOffset, -6f);

                deck2row2floor1 = SpawnPart(prefabfloor, deck2row2floor1, setactive, 0, 0, 0, -6f + ShiftOffset, UDHeightOffset, 6f);
                deck2row2floor2 = SpawnPart(prefabfloor, deck2row2floor2, setactive, 0, 0, 0, -6f + ShiftOffset, UDHeightOffset, 3f);
                deck2row2floor3 = SpawnPart(prefabfloor, deck2row2floor3, setactive, 0, 0, 0, -6f + ShiftOffset, UDHeightOffset, 0f);
                deck2row2floor4 = SpawnPart(prefabfloor, deck2row2floor4, setactive, 0, 0, 0, -6f + ShiftOffset, UDHeightOffset, -3f);
                deck2row2floor5 = SpawnPart(prefabfloor, deck2row2floor5, setactive, 0, 0, 0, -6f + ShiftOffset, UDHeightOffset, -6f);

                deck2row3floor1 = SpawnPart(prefabfloor, deck2row3floor1, setactive, 0, 0, 0, 3f + ShiftOffset, UDHeightOffset, -6f);
                deck2row3floor2 = SpawnPart(prefabfloor, deck2row3floor2, setactive, 0, 0, 0, 0f + ShiftOffset, UDHeightOffset, -6f);
                deck2row3floor3 = SpawnPart(prefabfloor, deck2row3floor3, setactive, 0, 0, 0, -3f + ShiftOffset, UDHeightOffset, -6f);

                deck2row4floor1 = SpawnPart(prefabfloor, deck2row4floor1, setactive, 0, 0, 0, 3f + ShiftOffset, UDHeightOffset, 6f);
                deck2row4floor2 = SpawnPart(prefabfloor, deck2row4floor2, setactive, 0, 0, 0, 0f + ShiftOffset, UDHeightOffset, 6f);
                deck2row4floor3 = SpawnPart(prefabfloor, deck2row4floor3, setactive, 0, 0, 0, -3f + ShiftOffset, UDHeightOffset, 6f);

                deck2center1 = SpawnPart(prefabfloor, deck2center1, setactive, 0, 0, 0, 3f + ShiftOffset, UDHeightOffset, 3f);
                deck2center2 = SpawnPart(prefabfloor, deck2center2, setactive, 0, 0, 0, 0f + ShiftOffset, UDHeightOffset, 3f);
                deck2center3 = SpawnPart(prefabfloor, deck2center3, setactive, 0, 0, 0, -3f + ShiftOffset, UDHeightOffset, 3f);
                deck2center4 = SpawnPart(prefabfloor, deck2center4, setactive, 0, 0, 0, 3f + ShiftOffset, UDHeightOffset, 0f);
                deck2center5 = SpawnPart(prefabfloor, deck2center5, setactive, 0, 0, 0, 0f + ShiftOffset, UDHeightOffset, 0f);
                deck2center6 = SpawnPart(prefabfloor, deck2center6, setactive, 0, 0, 0, -3f + ShiftOffset, UDHeightOffset, 0f);
                deck2center7 = SpawnPart(prefabfloor, deck2center7, setactive, 0, 0, 0, 3f + ShiftOffset, UDHeightOffset, -3f);
                deck2center8 = SpawnPart(prefabfloor, deck2center8, setactive, 0, 0, 0, 0f + ShiftOffset, UDHeightOffset, -3f);
                deck2center9 = SpawnPart(prefabfloor, deck2center9, setactive, 0, 0, 0, -3f + ShiftOffset, UDHeightOffset, -3f);

                deck2backrowfloor1 = SpawnPart(prefabfloor, deck2backrowfloor1, setactive, 0, 0, 0, -9f + ShiftOffset, UDHeightOffset, 6f);
                deck2backrowfloor2 = SpawnPart(prefabfloor, deck2backrowfloor2, setactive, 0, 0, 0, -9f + ShiftOffset, UDHeightOffset, 3f);
                deck2backrowfloor3 = SpawnPart(prefabfloor, deck2backrowfloor3, setactive, 0, 0, 0, -9f + ShiftOffset, UDHeightOffset, 0f);
                deck2backrowfloor4 = SpawnPart(prefabfloor, deck2backrowfloor4, setactive, 0, 0, 0, -9f + ShiftOffset, UDHeightOffset, -3f);
                deck2backrowfloor5 = SpawnPart(prefabfloor, deck2backrowfloor5, setactive, 0, 0, 0, -9f + ShiftOffset, UDHeightOffset, -6f); ;

                deck2row2lowwall1 = SpawnPart(prefablowwall, deck2row2lowwall1, setactive, 0, 0, 0, -10.5f + ShiftOffset, UDHeightOffset, 6f);
                deck2row2lowwall2 = SpawnPart(prefablowwall, deck2row2lowwall2, setactive, 0, 0, 0, -10.5f + ShiftOffset, UDHeightOffset, 3f);
                deck2row2lowwall3 = SpawnPart(prefablowwall, deck2row2lowwall3, setactive, 0, 0, 0, -10.5f + ShiftOffset, UDHeightOffset, 0f);
                deck2row2lowwall4 = SpawnPart(prefablowwall, deck2row2lowwall4, setactive, 0, 0, 0, -10.5f + ShiftOffset, UDHeightOffset, -3f);
                deck2row2lowwall5 = SpawnPart(prefablowwall, deck2row2lowwall5, setactive, 0, 0, 0, -10.5f + ShiftOffset, UDHeightOffset, -6f);

                deck2row3lowwall1 = SpawnPart(prefablowwall, deck2row3lowwall1, setactive, 0, 90, 0, 6f + ShiftOffset, UDHeightOffset, -7.5f);
                deck2row3lowwall2 = SpawnPart(prefablowwall, deck2row3lowwall2, setactive, 0, 90, 0, 3f + ShiftOffset, UDHeightOffset, -7.5f);
                deck2row3lowwall3 = SpawnPart(prefabstairsl, deck2row3lowwall3, setactive, 0, 90, 0, 0f + ShiftOffset, UDHeightOffset - 3f, -9f);
                deck2row3lowwall3U = SpawnPart(prefabstairsl, deck2row3lowwall3U, setactive, 0, 90, 0, -3.5f + ShiftOffset, UDHeightOffset, -6f);
                deck2row3lowwall4 = SpawnPart(prefablowwall, deck2row3lowwall4, setactive, 0, 90, 0, -3f + ShiftOffset, UDHeightOffset, -7.5f);
                deck2row3lowwall5 = SpawnPart(prefablowwall, deck2row3lowwall5, setactive, 0, 90, 0, -6f + ShiftOffset, UDHeightOffset, -7.5f);

                deck2row4lowwall1 = SpawnPart(prefablowwall, deck2row4lowwall1, setactive, 0, 270, 0, 6f + ShiftOffset, UDHeightOffset, 7.5f);
                deck2row4lowwall2 = SpawnPart(prefablowwall, deck2row4lowwall2, setactive, 0, 270, 0, 3f + ShiftOffset, UDHeightOffset, 7.5f);
                deck2row4lowwall3 = SpawnPart(prefabstairsl, deck2row4lowwall3, setactive, 0, 270, 0, 0f + ShiftOffset, UDHeightOffset - 3f, 9f);
                deck2row4lowwall3U = SpawnPart(prefabstairsl, deck2row4lowwall3U, setactive, 0, 0, 0, 0f + ShiftOffset, UDHeightOffset, 4.7f);
                deck2row4lowwall4 = SpawnPart(prefablowwall, deck2row4lowwall4, setactive, 0, 270, 0, -3f + ShiftOffset, UDHeightOffset, 7.5f);
                deck2row4lowwall5 = SpawnPart(prefablowwall, deck2row4lowwall5, setactive, 0, 270, 0, -6f + ShiftOffset, UDHeightOffset, 7.5f);
            }

            void SpawnHelipad()
            {
                helipadfloor1 = SpawnPart(prefabfloor, helipadfloor1, setactive, 0, 0, 0, 12f + ShiftOffset, UDHeightOffset, 6f);
                helipadfloor2 = SpawnPart(prefabfloor, helipadfloor2, setactive, 0, 0, 0, 12f + ShiftOffset, UDHeightOffset, 3f);
                helipadfloor3 = SpawnPart(prefabfloor, helipadfloor3, setactive, 0, 0, 0, 12f + ShiftOffset, UDHeightOffset, 0f);
                helipadfloor4 = SpawnPart(prefabfloor, helipadfloor4, setactive, 0, 0, 0, 12f + ShiftOffset, UDHeightOffset, -3f);
                helipadfloor5 = SpawnPart(prefabfloor, helipadfloor5, setactive, 0, 0, 0, 12f + ShiftOffset, UDHeightOffset, -6f);

                helipadfloor6 = SpawnPart(prefabfloor, helipadfloor6, setactive, 0, 0, 0, 15f + ShiftOffset, UDHeightOffset, 6f);
                helipadfloor7 = SpawnPart(prefabfloor, helipadfloor7, setactive, 0, 0, 0, 15f + ShiftOffset, UDHeightOffset, 3f);
                helipadfloor8 = SpawnPart(prefabfloor, helipadfloor8, setactive, 0, 0, 0, 15f + ShiftOffset, UDHeightOffset, 0f);
                helipadfloor9 = SpawnPart(prefabfloor, helipadfloor9, setactive, 0, 0, 0, 15f + ShiftOffset, UDHeightOffset, -3f);
                helipadfloor10 = SpawnPart(prefabfloor, helipadfloor10, setactive, 0, 0, 0, 15f + ShiftOffset, UDHeightOffset, -6f);

                helipadsupportframe1 = SpawnPart(prefabwallframe, helipadsupportframe1, setactive, 0, 0, 315, 11.1f + ShiftOffset, UDHeightOffset - 2.15f, 6f);
                helipadsupportframe2 = SpawnPart(prefabwallframe, helipadsupportframe2, setactive, 0, 0, 315, 11.1f + ShiftOffset, UDHeightOffset - 2.15f, 3f);
                helipadsupportframe3 = SpawnPart(prefabwallframe, helipadsupportframe3, setactive, 0, 0, 315, 11.1f + ShiftOffset, UDHeightOffset - 2.15f, 0f);
                helipadsupportframe4 = SpawnPart(prefabwallframe, helipadsupportframe4, setactive, 0, 0, 315, 11.1f + ShiftOffset, UDHeightOffset - 2.15f, -3f);
                helipadsupportframe5 = SpawnPart(prefabwallframe, helipadsupportframe5, setactive, 0, 0, 315, 11.1f + ShiftOffset, UDHeightOffset - 2.15f, -6f);

                helipadsupport1 = SpawnPart(prefablowwall, helipadsupport1, setactive, 0, 180, 45, 10.4f + ShiftOffset, LDHeightOffSet + 0.1f, 6f);
                helipadsupport2 = SpawnPart(prefablowwall, helipadsupport2, setactive, 0, 180, 45, 10.4f + ShiftOffset, LDHeightOffSet + 0.1f, 3f);
                helipadsupport3 = SpawnPart(prefablowwall, helipadsupport3, setactive, 0, 180, 45, 10.4f + ShiftOffset, LDHeightOffSet + 0.1f, 0f);
                helipadsupport4 = SpawnPart(prefablowwall, helipadsupport4, setactive, 0, 180, 45, 10.4f + ShiftOffset, LDHeightOffSet + 0.1f, -3f);
                helipadsupport5 = SpawnPart(prefablowwall, helipadsupport5, setactive, 0, 180, 45, 10.4f + ShiftOffset, LDHeightOffSet + 0.1f, -6f);

                helipadfence1 = SpawnPart(prefabfence, helipadfence1, setactive, 0, 0, 315, 11.1f + ShiftOffset, UDHeightOffset - 2.15f, 6f);
                helipadfence2 = SpawnPart(prefabfence, helipadfence2, setactive, 0, 0, 315, 11.1f + ShiftOffset, UDHeightOffset - 2.15f, 3f);
                helipadfence3 = SpawnPart(prefabfence, helipadfence3, setactive, 0, 0, 315, 11.1f + ShiftOffset, UDHeightOffset - 2.15f, 0f);
                helipadfence4 = SpawnPart(prefabfence, helipadfence4, setactive, 0, 0, 315, 11.1f + ShiftOffset, UDHeightOffset - 2.15f, -3f);
                helipadfence5 = SpawnPart(prefabfence, helipadfence5, setactive, 0, 0, 315, 11.1f + ShiftOffset, UDHeightOffset - 2.15f, -6f);

                helilogo1 = SpawnPart(prefabrug, helilogo1, setactive, 0, 0, 180, 12.65f + ShiftOffset, UDHeightOffset + 0.1f, 0f, HeliPadRugLogo1);
                helilogo2 = SpawnPart(prefabrug, helilogo2, setactive, 0, 0, 0, 14.35f + ShiftOffset, UDHeightOffset + 0.09f, 0f, HeliPadRugLogo2);

            }

            void SpawnLowerLights()
            {
                lowerlight1 = SpawnPart(prefabceilinglight, lowerlight1, setactive, 0, 0, 0, 9f + ShiftOffset, LDHeightOffSet, 6f);
                lowerlight2 = SpawnPart(prefabceilinglight, lowerlight2, setactive, 0, 0, 0, 9f + ShiftOffset, LDHeightOffSet, -6f);
                lowerlight3 = SpawnPart(prefabceilinglight, lowerlight3, setactive, 0, 0, 0, -9f + ShiftOffset, LDHeightOffSet, 6f);
                lowerlight4 = SpawnPart(prefabceilinglight, lowerlight4, setactive, 0, 0, 0, -9f + ShiftOffset, LDHeightOffSet, -6f);
                lowerlight5 = SpawnPart(prefabceilinglight, lowerlight5, setactive, 0, 0, 0, 6f + ShiftOffset, LDHeightOffSet, 9f);
                lowerlight6 = SpawnPart(prefabceilinglight, lowerlight6, setactive, 0, 0, 0, 6f + ShiftOffset, LDHeightOffSet, -9f);
                lowerlight7 = SpawnPart(prefabceilinglight, lowerlight7, setactive, 0, 0, 0, -6f + ShiftOffset, LDHeightOffSet, 9f);
                lowerlight8 = SpawnPart(prefabceilinglight, lowerlight8, setactive, 0, 0, 0, -6f + ShiftOffset, LDHeightOffSet, -9f);
                lowerlight1.SetFlag(BaseEntity.Flags.On, true, true);
                lowerlight2.SetFlag(BaseEntity.Flags.On, true, true);
                lowerlight3.SetFlag(BaseEntity.Flags.On, true, true);
                lowerlight4.SetFlag(BaseEntity.Flags.On, true, true);
                lowerlight5.SetFlag(BaseEntity.Flags.On, true, true);
                lowerlight6.SetFlag(BaseEntity.Flags.On, true, true);
                lowerlight7.SetFlag(BaseEntity.Flags.On, true, true);
                lowerlight8.SetFlag(BaseEntity.Flags.On, true, true);
                lowerlight1.SetFlag(BaseEntity.Flags.Busy, true, true);
                lowerlight2.SetFlag(BaseEntity.Flags.Busy, true, true);
                lowerlight3.SetFlag(BaseEntity.Flags.Busy, true, true);
                lowerlight4.SetFlag(BaseEntity.Flags.Busy, true, true);
                lowerlight5.SetFlag(BaseEntity.Flags.Busy, true, true);
                lowerlight6.SetFlag(BaseEntity.Flags.Busy, true, true);
                lowerlight7.SetFlag(BaseEntity.Flags.Busy, true, true);
                lowerlight8.SetFlag(BaseEntity.Flags.Busy, true, true);
            }

            void SpawnUpperLights()
            {
                upperlight1 = SpawnPart(prefabceilinglight, upperlight1, setactive, 0, 0, 0, -6f + ShiftOffset, UDHeightOffset, 6f);
                upperlight2 = SpawnPart(prefabceilinglight, upperlight2, setactive, 0, 0, 0, -6f + ShiftOffset, UDHeightOffset, -6f);
                upperlight3 = SpawnPart(prefabceilinglight, upperlight3, setactive, 0, 0, 0, 6f + ShiftOffset, UDHeightOffset, -6f);
                upperlight4 = SpawnPart(prefabceilinglight, upperlight4, setactive, 0, 0, 0, 6f + ShiftOffset, UDHeightOffset, 6f);

                upperlight5 = SpawnPart(prefabceilinglight, upperlight5, setactive, 0, 0, 0, 0f + ShiftOffset, UDHeightOffset, -6f);
                upperlight6 = SpawnPart(prefabceilinglight, upperlight6, setactive, 0, 0, 0, 0f + ShiftOffset, UDHeightOffset, 6f);
                upperlight7 = SpawnPart(prefabceilinglight, upperlight7, setactive, 0, 0, 0, 6f + ShiftOffset, UDHeightOffset, 0f);
                upperlight1.SetFlag(BaseEntity.Flags.On, true, true);
                upperlight2.SetFlag(BaseEntity.Flags.On, true, true);
                upperlight3.SetFlag(BaseEntity.Flags.On, true, true);
                upperlight4.SetFlag(BaseEntity.Flags.On, true, true);
                upperlight5.SetFlag(BaseEntity.Flags.On, true, true);
                upperlight6.SetFlag(BaseEntity.Flags.On, true, true);
                upperlight7.SetFlag(BaseEntity.Flags.On, true, true);
                upperlight1.SetFlag(BaseEntity.Flags.Busy, true, true);
                upperlight2.SetFlag(BaseEntity.Flags.Busy, true, true);
                upperlight3.SetFlag(BaseEntity.Flags.Busy, true, true);
                upperlight4.SetFlag(BaseEntity.Flags.Busy, true, true);
                upperlight5.SetFlag(BaseEntity.Flags.Busy, true, true);
                upperlight6.SetFlag(BaseEntity.Flags.Busy, true, true);
                upperlight7.SetFlag(BaseEntity.Flags.Busy, true, true);
            }

            void SpawnLift()
            {
                if (BucketLift == null)
                {
                    if (isevent && !EventRigHasLiftBucket) return;
                    if (!isevent && !StandardRigHasLiftBucket) return;
                    BucketLift = SpawnPart("assets/content/structures/lift_shaft/cave_lift.prefab", BucketLift, setactive, 0, 0, 0, -6f + ShiftOffset, -16f, 0f);
                }
            }

            void SpawnLadders()
            {
                if (isevent && !EventRigHasLadders) return;
                if (!isevent && !StandardRigHasLadders) return;

                ladder6leg1 = SpawnPart(prefabladder, ladder6leg1, setactive, 0, 0, 0, 9f + ShiftOffset, F5HeightOffset, 10.7f);
                ladder5leg1 = SpawnPart(prefabladder, ladder5leg1, setactive, 0, 0, 0, 9f + ShiftOffset, F4HeightOffset, 10.7f);
                ladder1leg1 = SpawnPart(prefabladder, ladder1leg1, setactive, 0, 0, 0, 9f + ShiftOffset, F1HeightOffset, 10.7f);
                ladder2leg1 = SpawnPart(prefabladder, ladder2leg1, setactive, 0, 0, 0, 9f + ShiftOffset, F2HeightOffset, 10.7f);
                ladder3leg1 = SpawnPart(prefabladder, ladder3leg1, setactive, 0, 0, 0, 9f + ShiftOffset, F3HeightOffset, 10.7f);
                ladder4leg1 = SpawnPart(prefabladder, ladder4leg1, setactive, 0, 0, 0, 9f + ShiftOffset, F3HeightOffset + 1.5f, 10.7f);

                ladder6leg2 = SpawnPart(prefabladder, ladder6leg2, setactive, 0, 0, 0, -9f + ShiftOffset, F5HeightOffset, 10.7f);
                ladder5leg2 = SpawnPart(prefabladder, ladder5leg2, setactive, 0, 0, 0, -9f + ShiftOffset, F4HeightOffset, 10.7f);
                ladder1leg2 = SpawnPart(prefabladder, ladder1leg2, setactive, 0, 0, 0, -9f + ShiftOffset, F1HeightOffset, 10.7f);
                ladder2leg2 = SpawnPart(prefabladder, ladder2leg2, setactive, 0, 0, 0, -9f + ShiftOffset, F2HeightOffset, 10.7f);
                ladder3leg2 = SpawnPart(prefabladder, ladder3leg2, setactive, 0, 0, 0, -9f + ShiftOffset, F3HeightOffset, 10.7f);
                ladder4leg2 = SpawnPart(prefabladder, ladder4leg2, setactive, 0, 0, 0, -9f + ShiftOffset, F3HeightOffset + 1.5f, 10.7f);

                ladder6leg3 = SpawnPart(prefabladder, ladder6leg3, setactive, 0, 0, 0, 9f + ShiftOffset, F5HeightOffset, -10.7f);
                ladder5leg3 = SpawnPart(prefabladder, ladder5leg3, setactive, 0, 0, 0, 9f + ShiftOffset, F4HeightOffset, -10.7f);
                ladder1leg3 = SpawnPart(prefabladder, ladder1leg3, setactive, 0, 0, 0, 9f + ShiftOffset, F1HeightOffset, -10.7f);
                ladder2leg3 = SpawnPart(prefabladder, ladder2leg3, setactive, 0, 0, 0, 9f + ShiftOffset, F2HeightOffset, -10.7f);
                ladder3leg3 = SpawnPart(prefabladder, ladder3leg3, setactive, 0, 0, 0, 9f + ShiftOffset, F3HeightOffset, -10.7f);
                ladder4leg3 = SpawnPart(prefabladder, ladder4leg3, setactive, 0, 0, 0, 9f + ShiftOffset, F3HeightOffset + 1.5f, -10.7f);

                ladder6leg4 = SpawnPart(prefabladder, ladder6leg4, setactive, 0, 0, 0, -9f + ShiftOffset, F5HeightOffset, -10.7f);
                ladder5leg4 = SpawnPart(prefabladder, ladder5leg4, setactive, 0, 0, 0, -9f + ShiftOffset, F4HeightOffset, -10.7f);
                ladder1leg4 = SpawnPart(prefabladder, ladder1leg4, setactive, 0, 0, 0, -9f + ShiftOffset, F1HeightOffset, -10.7f);
                ladder2leg4 = SpawnPart(prefabladder, ladder2leg4, setactive, 0, 0, 0, -9f + ShiftOffset, F2HeightOffset, -10.7f);
                ladder3leg4 = SpawnPart(prefabladder, ladder3leg4, setactive, 0, 0, 0, -9f + ShiftOffset, F3HeightOffset, -10.7f);
                ladder4leg4 = SpawnPart(prefabladder, ladder4leg4, setactive, 0, 0, 0, -9f + ShiftOffset, F3HeightOffset + 1.5f, -10.7f);
            }

            void SpawnCompound()
            {
                iscompound = false;
                return;

                windmill = SpawnPart(prefabwindmill, windmill, setactive, 0, 270, 0, -7f, 1f, 0f);
                vendattire = SpawnPart(prefabattirevending, vendattire, setactive, 0, 0, 0, 3f + ShiftOffset, LDHeightOffSet, 5f);
                vendbuilding = SpawnPart(prefabbuildingvending, vendbuilding, setactive, 0, 0, 0, 0f + ShiftOffset, LDHeightOffSet, 5f);
                vendcomponents = SpawnPart(prefabcomponentsvending, vendcomponents, setactive, 0, 0, 0, -3f + ShiftOffset, LDHeightOffSet, 5f);
                vendresources = SpawnPart(prefabresourcesvending, vendresources, setactive, 0, 180, 0, 3f + ShiftOffset, LDHeightOffSet, -5f);
                vendtools = SpawnPart(prefabtoolsvending, vendtools, setactive, 0, 180, 0, 0f + ShiftOffset, LDHeightOffSet, -5f);
                vendweapons = SpawnPart(prefabweaponsvending, vendweapons, setactive, 0, 180, 0, -3f + ShiftOffset, LDHeightOffSet, -5f);

                recycler1 = SpawnPart(prefabrecycler, recycler1, setactive, 0, 90, 0, 6f + ShiftOffset, LDHeightOffSet, -3f);
                recycler2 = SpawnPart(prefabrecycler, recycler2, setactive, 0, 270, 0, -6f + ShiftOffset, LDHeightOffSet, 3f);
                waterwell = SpawnPart(prefabwaterwell, waterwell, setactive, 0, 90, 0, 6f + ShiftOffset, LDHeightOffSet, 0f);
                researchtable = SpawnPart(prefabresearchtable, researchtable, setactive, 0, 270, 0, -6f + ShiftOffset, LDHeightOffSet, -3f);
                workbench = SpawnPart(prefabworkbench, workbench, setactive, 0, 90, 0, 6f + ShiftOffset, LDHeightOffSet, 3f);

                if (UseSentryOnCompound)
                {
                    peacekeeper1 = SpawnPart(prefabpeacekeeper, peacekeeper1, setactive, 0, 0, 0, 15f + ShiftOffset, UDHeightOffset, 6f);
                    peacekeeper2 = SpawnPart(prefabpeacekeeper, peacekeeper2, setactive, 0, 180, 0, -9f + ShiftOffset, UDHeightOffset, -6f);
                    peacekeeper3 = SpawnPart(prefabpeacekeeper, peacekeeper3, setactive, 0, 0, 0, -9f + ShiftOffset, LDHeightOffSet, 9f);
                    peacekeeper4 = SpawnPart(prefabpeacekeeper, peacekeeper4, setactive, 0, 0, 0, 9f + ShiftOffset, LDHeightOffSet, -9f);
                }

                if (waterwell != null)
                {
                    ItemContainer component1 = waterwell.GetComponent<StorageContainer>().inventory;
                    Item addwater = ItemManager.CreateByItemID(-1779180711, 6000);
                    component1.itemList.Add(addwater);
                    addwater.parent = component1;
                    addwater.MarkDirty();
                }
            }

            void DeepWaterStage1()
            {
                helicopter = GameManager.server.CreateEntity(prefabheli, entity.transform.position + new Vector3(12f + ShiftOffset, UDHeightOffset + 20f, 2f), new Quaternion(), true);
                var getai = helicopter.GetComponent<CH47HelicopterAIController>() ?? null;
                if (getai != null)
                {
                    getai.enabled = false;
                }
                helicopter?.Spawn();
                RefreshAll();
            }

            void DeepWaterStage2()
            {
                if (helicopter == null) { stage3 = true; return; }
                var getai = helicopter.GetComponent<CH47HelicopterAIController>() ?? null;
                if (getai == null) return;
                getai.numCrates = 0;
                HitInfo info = new HitInfo();
                getai.OnKilled(info);
                if (helipadfloor3 != null) helipadfloor3.Invoke("KillMessage", 0.1f);
                stage3 = true;

                if (EventRigHasHackCrate)
                {
                    helicrate = GameManager.server.CreateEntity(getai.lockedCratePrefab.resourcePath, deck1row1floor4.transform.position + Vector3.up, Quaternion.identity, true);
                    if (helicrate)
                    {
                        Interface.CallHook("OnHelicopterDropCrate", getai);
                        helicrate.SendMessage("SetWasDropped");
                        HackableLockedCrate.requiredHackSeconds = Stage2HackDuration;
                        helicrate.Spawn();
                        if (AddFullDivingKit) AddWetSuitKit(helicrate);
                    }
                }
                RefreshAll();
            }

            void AddWetSuitKit(BaseEntity entity)
            {
                ItemContainer hackcrateinv = entity.GetComponent<StorageContainer>().inventory;
                if (hackcrateinv == null) return;

                Item addsuit = ItemManager.CreateByItemID(-1101924344, 1);
                hackcrateinv.itemList.Add(addsuit);
                addsuit.parent = hackcrateinv;
                addsuit.MarkDirty();

                Item addmask = ItemManager.CreateByItemID(-113413047, 1);
                hackcrateinv.itemList.Add(addmask);
                addmask.parent = hackcrateinv;
                addmask.MarkDirty();

                Item addfins = ItemManager.CreateByItemID(296519935, 1);
                hackcrateinv.itemList.Add(addfins);
                addfins.parent = hackcrateinv;
                addfins.MarkDirty();

                Item addtank = ItemManager.CreateByItemID(-2022172587, 1);
                hackcrateinv.itemList.Add(addtank);
                addtank.parent = hackcrateinv;
                addtank.MarkDirty();
            }

            void SpawnRadBarrels()
            {
                if (isevent && !EventRigHasBarrels) return;
                if (!isevent && !StandardRigHasBarrels) return;
                if (iscompound) return;
                prefabexplosivecrate = "assets/prefabs/deployable/woodenbox/woodbox_deployed.prefab";

                explosivecrate1 = SpawnPart(prefabexplosivecrate, explosivecrate1, setactive, 0, 0, 0, 6f + ShiftOffset, UDHeightOffset - 1f, -7f);
                explosivecrate2 = SpawnPart(prefabexplosivecrate, explosivecrate2, setactive, 0, 0, 0, 3f + ShiftOffset, LDHeightOffSet - 1f, -9f);
                explosivecrate3 = SpawnPart(prefabexplosivecrate, explosivecrate3, setactive, 0, 0, 0, -1f + ShiftOffset, UDHeightOffset - 1f, -5.5f);
                explosivecrate4 = SpawnPart(prefabexplosivecrate, explosivecrate4, setactive, 0, 0, 0, -3f + ShiftOffset, LDHeightOffSet - 1f, -9f);
                explosivecrate5 = SpawnPart(prefabexplosivecrate, explosivecrate5, setactive, 0, 0, 0, -9f + ShiftOffset, LDHeightOffSet - 1f, -6f);
                explosivecrate6 = SpawnPart(prefabexplosivecrate, explosivecrate6, setactive, 0, 0, 0, 6f + ShiftOffset, UDHeightOffset - 1f, 7f);
                explosivecrate7 = SpawnPart(prefabexplosivecrate, explosivecrate7, setactive, 0, 0, 0, 3f + ShiftOffset, LDHeightOffSet - 1f, 9f);
                explosivecrate8 = SpawnPart(prefabexplosivecrate, explosivecrate8, setactive, 0, 0, 0, 2f + ShiftOffset, UDHeightOffset - 1f, 4.5f);
                explosivecrate9 = SpawnPart(prefabexplosivecrate, explosivecrate9, setactive, 0, 0, 0, -3f + ShiftOffset, LDHeightOffSet - 1f, 9f);
                explosivecrate10 = SpawnPart(prefabexplosivecrate, explosivecrate10, setactive, 0, 0, 0, -9f + ShiftOffset, LDHeightOffSet - 1f, 6f);

                explosivecrate1.SetFlag(BaseEntity.Flags.Busy, true, true);
                explosivecrate2.SetFlag(BaseEntity.Flags.Busy, true, true);
                explosivecrate3.SetFlag(BaseEntity.Flags.Busy, true, true);
                explosivecrate4.SetFlag(BaseEntity.Flags.Busy, true, true);
                explosivecrate5.SetFlag(BaseEntity.Flags.Busy, true, true);
                explosivecrate6.SetFlag(BaseEntity.Flags.Busy, true, true);
                explosivecrate7.SetFlag(BaseEntity.Flags.Busy, true, true);
                explosivecrate8.SetFlag(BaseEntity.Flags.Busy, true, true);
                explosivecrate9.SetFlag(BaseEntity.Flags.Busy, true, true);
                explosivecrate10.SetFlag(BaseEntity.Flags.Busy, true, true);

                explosivecrate1.skinID = 1627825383;
                explosivecrate2.skinID = 1627825383;
                explosivecrate3.skinID = 1627825383;
                explosivecrate4.skinID = 1627825383;
                explosivecrate5.skinID = 1627825383;
                explosivecrate6.skinID = 1627825383;
                explosivecrate7.skinID = 1627825383;
                explosivecrate8.skinID = 1627825383;
                explosivecrate9.skinID = 1627825383;
                explosivecrate10.skinID = 1627825383;
            }

            bool HasBarrels()
            {
                var barrelcount = 0;
                if (explosivecrate1) barrelcount = barrelcount + 1;
                if (explosivecrate2) barrelcount = barrelcount + 1;
                if (explosivecrate3) barrelcount = barrelcount + 1;
                if (explosivecrate4) barrelcount = barrelcount + 1;
                if (explosivecrate5) barrelcount = barrelcount + 1;
                if (explosivecrate6) barrelcount = barrelcount + 1;
                if (explosivecrate7) barrelcount = barrelcount + 1;
                if (explosivecrate8) barrelcount = barrelcount + 1;
                if (explosivecrate9) barrelcount = barrelcount + 1;
                if (explosivecrate10) barrelcount = barrelcount + 1;
                if (barrelcount > 0) return true;
                else return false;
            }

            void DeepWaterStage3()
            {
                if (HasBarrels())
                {
                    int choosebarrel = UnityEngine.Random.Range(1, 11);
                    if ((choosebarrel == 1) && (explosivecrate1 != null)) { DoBarrelExplosion(explosivecrate1); return; }
                    if ((choosebarrel == 2) && (explosivecrate2 != null)) { DoBarrelExplosion(explosivecrate2); return; }
                    if ((choosebarrel == 3) && (explosivecrate3 != null)) { DoBarrelExplosion(explosivecrate3); return; }
                    if ((choosebarrel == 4) && (explosivecrate4 != null)) { DoBarrelExplosion(explosivecrate4); return; }
                    if ((choosebarrel == 5) && (explosivecrate5 != null)) { DoBarrelExplosion(explosivecrate5); return; }
                    if ((choosebarrel == 6) && (explosivecrate6 != null)) { DoBarrelExplosion(explosivecrate6); return; }
                    if ((choosebarrel == 7) && (explosivecrate7 != null)) { DoBarrelExplosion(explosivecrate7); return; }
                    if ((choosebarrel == 8) && (explosivecrate8 != null)) { DoBarrelExplosion(explosivecrate8); refinerysmall.Invoke("KillMessage", 0.1f); return; }
                    if ((choosebarrel == 9) && (explosivecrate9 != null)) { DoBarrelExplosion(explosivecrate9); return; }
                    if ((choosebarrel == 10) && (explosivecrate10 != null)) { DoBarrelExplosion(explosivecrate10); return; }
                }
                else
                {
                    stage3 = false;
                    stage4 = true;
                }
            }

            void DoBarrelExplosion(BaseEntity barrel)
            {
                if (barrel == null) return;
                string prefabexplosion = "assets/prefabs/npc/m2bradley/effects/bradley_explosion.prefab";
                BaseEntity fireentity = GameManager.server.CreateEntity("assets/prefabs/npc/m2bradley/oilfireball2.prefab", barrel.transform.position + new Vector3(0f, 1f, 0f), new Quaternion(), true);
                fireentity?.Spawn();
                BarrelExplosionDamage(barrel.transform.position);
                Effect.server.Run(prefabexplosion, barrel.transform.position);
                barrel.Invoke("KillMessage", 0.1f);
            }

            void BarrelExplosionDamage(Vector3 location)
            {
                List<BaseCombatEntity> playerlist = new List<BaseCombatEntity>();
                Vis.Entities<BaseCombatEntity>(location, 5f, playerlist);
                foreach (BaseCombatEntity p in playerlist)
                {
                    if (!(p is BuildingPrivlidge))
                    {
                        p.Hurt(Stage3BarrelDamage, Rust.DamageType.Explosion, null, false);
                    }
                }
            }

            void DeepWaterStage4()
            {
                HackableLockedCrate.requiredHackSeconds = Stage4HackDefaultReset;
                if (helicrate != null) helicrate.Invoke("KillMessage", 0.1f);
                SendDespawnMessage();
                string prefabexplosion = "assets/prefabs/npc/patrol helicopter/effects/heli_explosion.prefab";
                Effect.server.Run(prefabexplosion, entity.transform.position);
                Effect.server.Run(prefabexplosion, entity.transform.position + (Vector3.right * 5f));
                Effect.server.Run(prefabexplosion, entity.transform.position - (Vector3.right * 5f));
                Effect.server.Run(prefabexplosion, entity.transform.position + (Vector3.forward * 5f));
                Effect.server.Run(prefabexplosion, entity.transform.position - (Vector3.forward * 5f));
                entity.Invoke("KillMessage", 0.1f);
            }

            void SpawnRigLoot()
            {
                if (iscompound) return;
                if (isevent && !EventRigHasLootSpawn) return;
                if (!isevent && !StandardRigHasLootSpawn) return;



                if (DoLootCrateCount() < maxlootcrates) DoLootSpawn();
                else return;
            }

            int DoLootCrateCount()
            {
                currentlootcrates = 0;
                if (lootspawn1 != null) currentlootcrates = currentlootcrates + 1;
                if (lootspawn2 != null) currentlootcrates = currentlootcrates + 1;
                if (lootspawn3 != null) currentlootcrates = currentlootcrates + 1;
                if (lootspawn4 != null) currentlootcrates = currentlootcrates + 1;
                if (lootspawn5 != null) currentlootcrates = currentlootcrates + 1;
                if (lootspawn6 != null) currentlootcrates = currentlootcrates + 1;
                if (lootspawn7 != null) currentlootcrates = currentlootcrates + 1;
                if (lootspawn8 != null) currentlootcrates = currentlootcrates + 1;
                return currentlootcrates;
            }

            void DoLootSpawn()
            {
                int cratesroll = UnityEngine.Random.Range(1, 9);
                if (cratesroll == 1 && lootspawn1 == null) { lootspawn1 = SpawnLootBox(lootspawn1, deck1row3floorframe2.transform.position); return; }
                if (cratesroll == 2 && lootspawn2 == null) { lootspawn2 = SpawnLootBox(lootspawn2, deck1row1floorframe3.transform.position); return; }
                if (cratesroll == 3 && lootspawn3 == null) { lootspawn3 = SpawnLootBox(lootspawn3, deck2frontrowfloor1.transform.position); return; }
                if (cratesroll == 4 && lootspawn4 == null) { lootspawn4 = SpawnLootBox(lootspawn4, deck2frontrowfloor5.transform.position); return; }
                if (cratesroll == 5 && lootspawn5 == null) { lootspawn5 = SpawnLootBox(lootspawn5, deck2backrowfloor1.transform.position); return; }
                if (cratesroll == 6 && lootspawn6 == null) { lootspawn6 = SpawnLootBox(lootspawn6, deck1row4floorframe2.transform.position); return; }
                if (cratesroll == 7 && lootspawn7 == null) { lootspawn7 = SpawnLootBox(lootspawn7, entity.transform.position + new Vector3(-6f, 3f, 4f)); return; }
                if (cratesroll == 8 && lootspawn8 == null) { lootspawn8 = SpawnLootBox(lootspawn8, entity.transform.position + new Vector3(6.5f, 3f, -2f)); return; }
                else SpawnRigLoot();
            }

            BaseEntity SpawnLootBox(BaseEntity treasurebox, Vector3 spawnloc)
            {
                var randomlootprefab = "assets/bundled/prefabs/radtown/crate_basic.prefab";
                int rlroll = UnityEngine.Random.Range(1, 6);
                if (rlroll == 1) randomlootprefab = "assets/bundled/prefabs/radtown/crate_basic.prefab";
                if (rlroll == 2) randomlootprefab = "assets/bundled/prefabs/radtown/crate_elite.prefab";
                if (rlroll == 3) randomlootprefab = "assets/bundled/prefabs/radtown/crate_mine.prefab";
                if (rlroll == 4) randomlootprefab = "assets/bundled/prefabs/radtown/crate_normal.prefab";
                if (rlroll == 5) randomlootprefab = "assets/bundled/prefabs/radtown/crate_normal_2.prefab";
                var createdPrefab = GameManager.server.CreateEntity(randomlootprefab, spawnloc);
                treasurebox = createdPrefab?.GetComponent<BaseEntity>();
                treasurebox?.Spawn();
                return treasurebox;
            }

            public void MoveBucket()
            {
                if (BucketLift == null) return;
                if (!BucketLift.IsOpen() && !BucketLift.IsBusy())
                {
                    BucketLift.SetFlag(BaseEntity.Flags.Open, true, true);
                    BucketLift.SendNetworkUpdateImmediate();
                }
            }

            void BroadcastMessage(string str)
            {
                if (!BroadCastEventStages) return;
                string getgrid = deepwater.GetGridLocation(entity.transform.position);
                ConVar.Chat.Broadcast(str + getgrid, "DeepWater", "#4286f4");
            }



            void FixedUpdate()
            {
                if (dorigdestroy) return;
                if (!didspawnvariables)
                {
                    count++;
                    if (count >= 25) { CheckVariables(); count = 0; didspawnvariables = true; }
                    return;
                }
                if ((isevent && EventRigHasLiftBucket) || (!isevent && StandardRigHasLiftBucket))
                {
                    if (AutoMoveLiftBucket)
                    {
                        if (liftcount == 200) { MoveBucket(); liftcount = 0; }
                        liftcount++;
                    }
                }
                if ((isevent && EventRigHasLootSpawn) || (!isevent && StandardRigHasLootSpawn))
                {
                    if (count == LootRespawnTime) { SpawnRigLoot(); count = 0; }
                    count++;
                }
                if (stage1)
                {
                    if (stage1counter == stage1time) { DeepWaterStage1(); stage2 = true; stage1 = false; stage3 = false; stage4 = false; BroadcastMessage("Rig Event Stage 1 (CH47 Landing) started at grid : "); }
                    stage1counter++;
                    despawncount = 0;

                }
                if (stage2)
                {
                    if (stage2counter == stage2time) { DeepWaterStage2(); stage3 = true; stage1 = false; stage2 = false; stage4 = false; BroadcastMessage("Rig Event Stage 2 (CH47 Crash) started at grid : "); }
                    stage2counter = stage2counter + 1;
                    despawncount = 0;
                }
                if (stage3)
                {
                    if (stage3counter == stage3time) { BroadcastMessage("Rig Event Stage 3 (Rig Fire Started) started at grid : "); stage3startfire = true; }
                    if (stage3startfire)
                    {
                        if (stage3barrelcounter == stage3barreltime) { DeepWaterStage3(); stage3barrelcounter = 0; }
                        stage3barrelcounter = stage3barrelcounter + 1;
                    }
                    stage3counter = stage3counter + 1;
                    despawncount = 0;
                }
                if (stage4)
                {
                    stage1 = false; stage2 = false; stage3 = false;
                    if (stage4counter == 0) BroadcastMessage("Rig Event Stage 4 (Final Countdown) started at grid : ");
                    if (stage4counter >= stage4time) { DeepWaterStage4(); stage1 = false; stage2 = false; stage3 = false; stage4 = false; return; }
                    stage4counter = stage4counter + 1;
                    despawncount = 0;
                }
                if ((UseDespawnOnLocal && !israndom) || (UseDespawnOnRandom && israndom))
                {
                    despawncount = despawncount + 1;
                    if (despawncount == DespawnTime) DespawnRig();
                }
            }

            void DestroyLootBoxs()
            {
                if (lootspawn1 != null) lootspawn1.Invoke("KillMessage", 0.1f);
                if (lootspawn2 != null) lootspawn2.Invoke("KillMessage", 0.1f);
                if (lootspawn3 != null) lootspawn3.Invoke("KillMessage", 0.1f);
                if (lootspawn4 != null) lootspawn4.Invoke("KillMessage", 0.1f);
                if (lootspawn5 != null) lootspawn5.Invoke("KillMessage", 0.1f);
                if (lootspawn6 != null) lootspawn6.Invoke("KillMessage", 0.1f);
                if (lootspawn7 != null) lootspawn7.Invoke("KillMessage", 0.1f);
                if (lootspawn8 != null) lootspawn8.Invoke("KillMessage", 0.1f);
            }

            void SendDespawnMessage()
            {
                if (isevent && BroadcastEventEnd)
                {
                    ConVar.Chat.Broadcast("Rig Event has Ended at Grid", "DeepWater", "#4286f4");
                }
                else return;
            }

            public void OnDestroy()
            {
                DestroyLootBoxs();
                if (helicopter != null) helicopter.Invoke("KillMessage", 0.1f);
                if (helicrate != null) helicrate.Invoke("KillMessage", 0.1f);
                if (boxcollider != null) GameObject.Destroy(boxcollider);
                if (isautospawn && SpawnRandomOnLoad) DoRandomRespawn = true;
                if (mapmarker != null) mapmarker.Invoke("KillMessage", 0.1f);
                deepwater.EraseZone(zoneid);
                if (entity != null || !entity.IsDestroyed) { entity.Invoke("KillMessage", 0.1f); }
            }
        }

        #endregion

    }
}

// --- End of file: DeepWater.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/PaiNAFK.cs ---
// --- Original Local Path: PaiNAFK.cs ---

using System.Collections.Generic;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("PaiN AFK", "PaiN", "0.1", ResourceId = 0)]
    class PaiNAFK : RustPlugin
    {
        class Data { public List<ulong> AfkPlayers = new List<ulong>(); }
        Data data;

        void LoadMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"AFK Enabled", "You are now afk!"},
                {"AFK Disabled", "You are no longer afk!" }
            }, this);
        }

        void Loaded() { ReadData(); LoadMessages(); }

        void Unloaded()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
                if (IsAfk(player.userID))
                {
                    data.AfkPlayers.Remove(player.userID);
                    player.EndSleeping();
                }
            SaveData();
        }

        [ChatCommand("afk")]
        void cmdAfk(BasePlayer player, string cmd, string[] args)
        {
            if (IsAfk(player.userID))
                StartAFK(player);
            else
                StartAFK(player, true);
        }

        void OnPlayerSleepEnded(BasePlayer player)
        {
            if (IsAfk(player.userID))
                StartAFK(player, false);
        }

        void OnServerSave() => SaveData();

        bool IsAfk(ulong userid)
        {
            if (data.AfkPlayers.Contains(userid))
                return true;
            else return false;
        }

        private void StartAFK(BasePlayer player, bool enable = true)
        {
            if(enable == true)
            {
                SendReply(player, GetLang("AFK Enabled", player.userID.ToString()));
                data.AfkPlayers.Add(player.userID);
                player.StartSleeping();
            }
            else
            {
                SendReply(player, GetLang("AFK Disabled", player.userID.ToString()));
                data.AfkPlayers.Remove(player.userID);           
            }
        }

        void SaveData() => Interface.Oxide.DataFileSystem.WriteObject("AfkPlayers", data);
        void ReadData() => data = Interface.Oxide.DataFileSystem.ReadObject<Data>("AfkPlayers");
        string GetLang(string msg, string userID) => lang.GetMessage(msg, this, userID);
    }
}


// --- End of file: PaiNAFK.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/StructureWhitelist.cs ---
// --- Original Local Path: StructureWhitelist.cs ---

using System.Collections.Generic;
using System;
namespace Oxide.Plugins
{
    [Info("StructureWhitelist", "Norn", 0.2, ResourceId = 1511)]
    [Description("Choose which grades players can build.")]
    public class StructureWhitelist : RustPlugin
    {
        void OnServerInitialized()
        {
            Puts("Wood: " + Config["Grade", "Wood"].ToString() + " | Stone: " + Config["Grade", "Stone"].ToString() + " | Metal: " + Config["Grade", "Metal"].ToString() + " | TopTier: " + Config["Grade", "TopTier"].ToString());
        }
        void Loaded()
        {
            LoadDefaultMessages();
        }

        protected override void LoadDefaultConfig()
        {
            Puts("No configuration file found, generating..."); Config.Clear();
            Config["Grade", "Wood"] = true;
            Config["Grade", "Stone"] = true;
            Config["Grade", "Metal"] = true;
            Config["Grade", "TopTier"] = true;
        }

        #region Localization

        void LoadDefaultMessages()
        {
            var messages = new Dictionary<string, string>
            {
                {"NotAllowed", "Structure grade: <color=yellow>{grade}</color> has been <color=red>disabled</color> on this server."},
            };
            lang.RegisterMessages(messages, this);
        }
        string GetMessage(string key, string steamId = null) => lang.GetMessage(key, this, steamId);

        #endregion

        object OnStructureUpgrade(BuildingBlock block, BasePlayer player, BuildingGrade.Enum grade)
        {
            string gradestring = grade.ToString();
            switch (gradestring)
            {
                case "Wood":
                    {
                        if (!Convert.ToBoolean(Config["Grade", "Wood"])) { PrintToChat(player, GetMessage("NotAllowed", player.UserIDString).Replace("{grade}", gradestring)); return false; }
                        break;
                    }
                case "Stone":
                    {
                        if (!Convert.ToBoolean(Config["Grade", "Stone"])) { PrintToChat(player, GetMessage("NotAllowed", player.UserIDString).Replace("{grade}", gradestring)); return false; }
                        break;
                    }
                case "Metal":
                    {
                        if (!Convert.ToBoolean(Config["Grade", "Metal"])) { PrintToChat(player, GetMessage("NotAllowed", player.UserIDString).Replace("{grade}", gradestring)); return false; }
                        break;
                    }
                case "TopTier":
                    {
                        if (!Convert.ToBoolean(Config["Grade", "TopTier"])) { PrintToChat(player, GetMessage("NotAllowed", player.UserIDString).Replace("{grade}", gradestring)); return false; }
                        break;
                    }
            }
            return null;
        }
    }
}

// --- End of file: StructureWhitelist.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BanSystem1.0.8.cs ---
// --- Original Local Path: BanSystem1.0.8.cs ---

﻿using Oxide.Core.Configuration;
using Oxide.Core;
using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using System.Linq;
using UnityEngine;
using MySql.Data.MySqlClient;
using Newtonsoft.Json;
using System.Text;
using Oxide.Core.Database;
using System.Net;
using static Oxide.Plugins.BanSystem;

namespace Oxide.Plugins
{
    [Info("BanSystem", "MaltrzD", "1.0.8")]
    class BanSystem : RustPlugin
    {
        public static DateTime unixEpoch { get; private set; } = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);
        private static BanSystem _ins;
        Effect banEffect = new Effect();

		private Connection _mySqlConnection = null;
		private readonly Core.MySql.Libraries.MySql _mySql = new Core.MySql.Libraries.MySql();

		private const string PERM_BAN = "bansystem.ban";
        private const string PERM_KICK = "bansystem.kick";
        private const string PERM_UNBAN = "bansystem.unban";

        private const string DISCORD_BAN_MESSAGE = @"{
                    ""avatar_url"": ""https://sun9-41.userapi.com/impg/XG4lWeqt5KHP7Sss_58bLFzDGNAjbf3Gb3D-Tw/mLipoINPLJ8.jpg?size=96x96&quality=96&sign=97b16e2cb2729ebb02f39fbe0ac3620e&type=album"",
                    ""embeds"": [
                        {
                            ""title"": ""Игрок был забанен!"",
                            ""color"": 16728345,
                            ""url"": """",
                            ""fields"": [
                                { 
                                ""name"": ""Игрок"",
                                ""value"": ""[{0}](https://steamcommunity.com/profiles/{0}) / {1}"" 
                                },  
                                { 
                                ""name"": ""Забанил"",
                                ""value"": ""{2}"" 
                                },
                                { 
                                ""name"": ""Время"",
                                ""value"": ""{3}"" 
                                },
                                { 
                                ""name"": ""Причина"",
                                ""value"": ""{4}"" 
                                }
                            ],
                            ""footer"": {}
                        }
                    ]
                    }";
        private const string DISCORD_UNBAN_MESSAGE = @"{
                    ""avatar_url"": ""https://sun9-41.userapi.com/impg/XG4lWeqt5KHP7Sss_58bLFzDGNAjbf3Gb3D-Tw/mLipoINPLJ8.jpg?size=96x96&quality=96&sign=97b16e2cb2729ebb02f39fbe0ac3620e&type=album"",
                    ""embeds"": [
                        {
                            ""title"": ""Игрок был разбанен!"",
                            ""color"": 2227982,
                            ""url"": """",
                            ""fields"": [
                                { 
                                ""name"": ""Игрок"",
                                ""value"": ""[{0}](https://steamcommunity.com/profiles/{0}) / {1}"" 
                                },  
                                { 
                                ""name"": ""Разбанил"",
                                ""value"": ""{2}"" 
                                }
                            ],
                            ""footer"": { }
                        }
                    ]
                    }";

		#region [ OXIDE HOOK ]
		private void Loaded()
        {
            _ins = this;

            ReadConfig();
            LoadPlayerNickNames();

            PermissionService.RegisterPermissions(new List<string>() { PERM_BAN, PERM_KICK, PERM_UNBAN } );

            timer.Every(300f, () => Save());

			_mySqlConnection = _mySql.OpenDb($"Server={_config.DataBase.server};Port={_config.DataBase.port};Database={_config.DataBase.database};User={_config.DataBase.username};Password={_config.DataBase.password};Pooling=false;default command timeout=120;Allow Zero Datetime=true;charset=utf8;", this);

			_mySql.Insert(Sql.Builder.Append("CREATE TABLE IF NOT EXISTS banneds ("
                + "banID INT AUTO_INCREMENT PRIMARY KEY, "
                + "steamID BIGINT UNSIGNED, "
                + "name TEXT COLLATE utf8_general_ci, "
                + "ip TEXT COLLATE utf8_general_ci, "
                + "actor TEXT COLLATE utf8_general_ci, "
                + "reason TEXT COLLATE utf8_general_ci, "
                + "banTime DATETIME, "
                + "expiredTime BIGINT, "
                + "UNIQUE (steamID)"
                + ")"), _mySqlConnection,
                (_) =>
                {
                    Puts($"[BD] Подключение завершено!");
                });
        }
        private void Unload() => SavePlayerNickNames();

		private void CanUserLogin(string name, string id, string ipAddress)
		{
            timer.Once(1f, () =>
            {
                CheckUser(Convert.ToUInt64(id), ipAddress);
            });
        }
        private void OnPlayerConnected(BasePlayer player) => UpdatePlayerData(player);
		private void CheckUser(ulong id, string ipAddress)
        {
            ulong userId = Convert.ToUInt64(id);
            ipAddress = ipAddress.Split(':')[0];
            foreach (var con in Network.Net.sv.connections.ToList())
            {
                if(con.userid == id)
                {
					GetBanBySteamID(userId, (ban) =>
					{
						if (ban != null)
						{
							DateTime futureTime = ConvertUnixTimeToDateTime(ban.ExpiredTime);
							if (DateTime.Now > futureTime && ban.ExpiredTime != 0)
							{
								UnbanBySteamID(Convert.ToUInt64(userId), null);
							}
							else
							{
								string banReason = ban.ExpiredTime == 0 ? "навсегда" : futureTime.ToString();
								//player.Kick(_config.Lang.ReplaceArgs(_config.Lang.BannedMessage, ban.Reason, banReason));
                                Network.Net.sv.Kick(con, _config.Lang.ReplaceArgs(_config.Lang.BannedMessage, ban.Reason, banReason));
								return;
							}
						}
						else
						{
							if (_config.BanEvade.IsEnable == false) return;

							GetBanByIP(ipAddress, (ipBan) =>
							{
								if (ipBan != null)
								{
									long time = 0;
									if (string.IsNullOrEmpty(_config.BanEvade.BanTime) == false && IsTime(_config.BanEvade.BanTime))
										time = GetTimeFromString(DateTime.Now, _config.BanEvade.BanTime);


									Ban newBan = BanPlayer(userId, null, "SERVER", _config.BanEvade.Reason, time, ipAddress);
									string banReason = ban.ExpiredTime == 0 ? "навсегда" : ConvertUnixTimeToDateTime(ban.ExpiredTime).ToString("dd:MM:dd hh:mm:ss");

									Network.Net.sv.Kick(con, _config.Lang.ReplaceArgs(_config.Lang.BannedMessage, newBan.Reason, banReason));
									return;
								}
							});
						}
					});

                    return;
				}
            }
        }
        #endregion

        #region [ MAIN ]
        private void Save() => SavePlayerNickNames();
        #endregion

        #region [ CHAT COMMAND ]
        [ChatCommand("ban")]
        private void BanPlayer_ChatCommand(BasePlayer player, string cmd, string[] args)
        {
            if(PermissionService.HasPermission(player.UserIDString, PERM_BAN) == false)
            {
                player.ChatMessage("У вас нет прав чтобы использовать эту команду!");
                return;
            }

            if(args.Length == 0)
            {
                player.ChatMessage("Не все аргументы указаны!");
                return;
            }

            ulong targetUserId = 0;
            if (IsSteamID(args[0]) == false)
            {
                BasePlayer targetPlayer = FindPlayer(args[0]);
                if(targetPlayer == null)
                {
                    player.ChatMessage("Такого игрока нет на сервере!");
                    return;
                }
                else
                {
                    targetUserId = targetPlayer.userID;
                }
            }
            else
            {
                targetUserId = Convert.ToUInt64(args[0]);
            }

            long time = 0;
            if(args.Length >= 2)
            {
                if (IsTime(args[1]))
                {
                    time = GetTimeFromString(DateTime.Now, args[1]);
                }
            }

            string reason = "";
            if(args.Length >= 2)
            {
                if(time != 0)
                {
                    for (int i = 2; i < args.Length; i++)
                    {
                        reason += args[i] + " ";
                    }
                }
                else
                {
                    for (int i = 1; i < args.Length; i++)
                    {
                        reason += args[i] + " ";
                    }
                }
            }
            if(string.IsNullOrEmpty(reason)) { reason = _config.Main.defaultBanReason; }

            BanPlayer(targetUserId, player, player.displayName, reason, time, formattedTime: time != 0 ? GetFormattedTime(args[1]) : null);
        }
        [ChatCommand("unban")]
        private void UnbanPlayer_ChatCommand(BasePlayer player, string cmd, string[] args)
        {
            if (PermissionService.HasPermission(player.UserIDString, PERM_UNBAN) == false)
            {
                player.ChatMessage("У вас нет прав чтобы использовать эту команду!");
                return;
            }

            if (args.Length == 0) { player.ChatMessage("Недостаточно аргументов!\nСинтаксис: /unban <SteamID>"); return; }

            ulong uid = 0;
            try
            {
                uid = Convert.ToUInt64(args[0]);
            }
            catch
            {
                player.ChatMessage("Вы указали неверный SteamID");
                return;
            }

            UnbanBySteamID(uid, (unban) =>
            {
                if(unban) player.ChatMessage($"Запись успешно удалена!");
				else player.ChatMessage($"Запись не найдена!");
			}, player.displayName, true);
        }

        [ChatCommand("kick")]
        private void KickPlayer_ChatCommand(BasePlayer player, string cmd, string[] args)
        {
            if (PermissionService.HasPermission(player.UserIDString, PERM_KICK) == false)
            {
                player.ChatMessage("У вас нет прав чтобы использовать эту команду!");
                return;
            }

            if (args.Length == 0)
                player.ChatMessage(KickPlayer(null, null));
            else if (args.Length == 1)
                player.ChatMessage(KickPlayer(args[0], null));
            else
            {
                string reason = string.Empty;

                for (int i = 1; i < args.Length; i++)
                {
                    reason += args[i] + " ";
                }

                player.ChatMessage(KickPlayer(args[0], reason));
            }
        }
        #endregion

        #region [ CONSOLE COMMAND ]
        [ConsoleCommand("banp")]
        private void BanPlayer_ConsoleCommand(ConsoleSystem.Arg arg)
        {
            if (arg.IsAdmin == false) return;
            if (arg.Args == null || arg.Args.Length == 0)
            {
                Debug.LogWarning("Не все аргументы указаны!");
                return;
            }
            ulong steamId = Convert.ToUInt64(arg.Args[0]);

            long time = 0;
            if (arg.Args.Length >= 2)
            {
                if (IsTime(arg.Args[1]))
                {
                    time = GetTimeFromString(DateTime.Now, arg.Args[1]);
                }
            }

            string reason = "";
            if (arg.Args.Length >= 2)
            {
                if (time != 0)
                {
                    for (int i = 2; i < arg.Args.Length; i++)
                    {
                        reason += arg.Args[i] + " ";
                    }
                }
                else
                {
                    for (int i = 1; i < arg.Args.Length; i++)
                    {
                        reason += arg.Args[i] + " ";
                    }
                }
            }
            if (string.IsNullOrEmpty(reason)) { reason = _config.Main.defaultBanReason; }


            string ip = "";
            PlayerData data = GetPlayerData(steamId);
            if (data != null)
            {
                ip = data.Ip;
            }

            BanPlayer(steamId, null, "CONSOLE", reason, time, playerIp: ip, formattedTime: time != 0? GetFormattedTime(arg.Args[1]) : null);
        }
        [ConsoleCommand("unbanp")]
        private void Unban_ConsoleCommand(ConsoleSystem.Arg arg)
        {
            if (arg.IsAdmin == false) return;

            if (arg.Args == null || arg.Args.Length == 0)
            {
                Puts("Вы не указали SteamID!");
                return;
            }
            if (IsSteamID(arg.Args[0]) == false)
            {
                Puts($"Неверный SteamID!");
                return;
            }

            UnbanBySteamID(Convert.ToUInt64(arg.Args[0]), (unban) =>
            {
                if (unban) Puts("Запись успешно удалена!");
                else Puts("Запись не найдена!");
            }, "CONSOLE", true);
        }

        [ConsoleCommand("checkban")]
        private void CheckBanBySteamId_ConsoleCommand(ConsoleSystem.Arg arg)
        {
            if (arg.IsAdmin == false) return;

            ulong steamId = 0;

            try
            {
                steamId = Convert.ToUInt64(arg.Args[0]);
            }
            catch
            {
                Puts("Вы ввели неверный SteamID или не указали его!");
                return;
            }

            GetBanBySteamID(steamId, (ban) =>
            {
                if(ban == null)
                {
                    Puts($"Игрок [{steamId}] не забанен!");
                    return;
                }

                string unbanTime = ban.ExpiredTime == 0 ? "навсегда" : ConvertUnixTimeToDateTime(ban.ExpiredTime).ToString("dd/MM/dd hh:mm:ss");

				Puts(
                    $"\nИгрок: {ban.SteamID}/{ban.Name}\n" +
                    $"IP: {ban.Ip}\n" +
                    $"Причина: {ban.Reason}\n" +
                    $"Время блокировки: {ban.BanTime.ToString("dd/MM/dd hh:mm:ss")}\n" +
                    $"Время разблокировки: {unbanTime}"
                    );
            });
        }
		[ConsoleCommand("checkbanip")]
		private void CheckBansIp_ConsoleCommand(ConsoleSystem.Arg arg)
		{
			if (arg.IsAdmin == false) return;

			string ip = arg.Args[0];

            GetBansByIP(ip, (bans) =>
            {
                if(bans == null)
                {
                    Puts("Баны не найдены!");
                    return;
                }

                StringBuilder sb = new StringBuilder();
                sb.Append($"Баны по IP: {ip}\n");
				foreach (var ban in bans)
				{
				    string unbanTime = ban.ExpiredTime == 0 ? "навсегда" : ConvertUnixTimeToDateTime(ban.ExpiredTime).ToString("dd/MM/dd hh:mm:ss");

                    sb.AppendLine($"\nИгрок: {ban.SteamID}/{ban.Name}\n" +
                    $"IP: {ban.Ip}\n" +
                    $"Причина: {ban.Reason}\n" +
                    $"Время блокировки: {ban.BanTime.ToString("dd/MM/dd hh:mm:ss")}\n" +
                    $"Время разблокировки: {unbanTime}\n");

                    sb.AppendLine("-----");
                }

                Puts(sb.ToString());
            });
		}


		[ConsoleCommand("kick")]
        private void KickPlayer_ConsoleCommand(ConsoleSystem.Arg arg)
        {
            if (arg.IsAdmin == false) return;

            if (arg.Args?.Length == 0)
                Puts(KickPlayer(null, null));
            else if (arg.Args.Length == 1)
                Puts(KickPlayer(arg.Args[0], null));
            else
            {
                string reason = string.Empty;

                for (int i = 1; i < arg.Args.Length; i++)
                {
                    reason += arg.Args[i] + " ";
                }

                Puts(KickPlayer(arg.Args[0], reason));
            }
        }
        #endregion

        #region [ EXT ]
        private string GetFormattedTime(string time)
        {
            string result = "";
            if (time.EndsWith("d"))
            {
                result = time.Replace("d", "д");
            }
            else if (time.EndsWith("s"))
            {
                result = time.Replace("s", "с");
            }
            else if (time.EndsWith("m"))
            {
                result = time.Replace("m", "м");
            }
            else if (time.EndsWith("h"))
            {
                result = time.Replace("h", "ч");
            }
            else if (time.EndsWith("y"))
            {
                result = time.Replace("y", "г");
            }
            return result;
        }
        private DateTime ConvertUnixTimeToDateTime(long unixTime)
            => unixEpoch.AddSeconds(unixTime);
        private long GetTimeFromString(DateTime currentTime, string timeString)
        {
            int time = Convert.ToInt32(timeString.Substring(0, timeString.Length - 1));
            string timeType = timeString.Substring(timeString.Length - 1, 1);

            DateTime expiredTime = DateTime.Now;

            switch(timeType)
            {
                case "s":
                    expiredTime = expiredTime.AddSeconds(time);
                    break;
                case "m":
                    expiredTime = expiredTime.AddMinutes(time);
                    break;
                case "h":
                    expiredTime = expiredTime.AddHours(time);
                    break;
                case "d":
                    expiredTime = expiredTime.AddDays(time);
                    break;
                case "y":
                    expiredTime = expiredTime.AddYears(time);
                    break;
            }

            TimeSpan interval = expiredTime - unixEpoch;
            long expiredUnixTime = (long)interval.TotalSeconds;


            return expiredUnixTime;
        }
        private bool IsTime(string input)
        {
            string pattern = @"\b\d+[sdhmy]\b";
            return Regex.IsMatch(input, pattern);
        }
        private BasePlayer FindPlayer(string filter)
        {
            return BasePlayer.activePlayerList.Where(x => x.displayName.Contains(filter, System.Globalization.CompareOptions.IgnoreCase) || x.UserIDString == filter).FirstOrDefault();
        }
        private BasePlayer FindPlayer(ulong steamId) => BasePlayer.FindByID(steamId);


        public static class PermissionService
        {
            public static void RegisterPermissions(List<string> perms)
            {
                foreach (var perm in perms)
                    if (_ins.permission.PermissionExists(perm, _ins) == false)
                        _ins.permission.RegisterPermission(perm, _ins);
            }
            public static void RegisterPermission(string perm)
            {
                if (_ins.permission.PermissionExists(perm, _ins) == false)
                    _ins.permission.RegisterPermission(perm, _ins);
            }
            public static bool HasPermission(string uid, string perm)
                => _ins.permission.UserHasPermission(uid, perm);

        }

        private void Dlog(string discordWebHook, string message)
        {
            if(string.IsNullOrEmpty(discordWebHook) || discordWebHook.Contains("http") == false) { return; }

            try
            {
                webrequest.Enqueue(discordWebHook, message, (code, response) =>
                {
                    Puts($"{code} : {response}");
                }, this, Core.Libraries.RequestMethod.POST, new Dictionary<string, string>() { { "Content-Type", "application/json" } }, 5000);
            }
            catch(Exception ex) { Debug.LogError($"Ошибка при отправке сообщения [Discord]: {ex.Message}"); }
        }
        private string GetMessage(string key, params object[] args)
        {
            string msg = key;
            for (int i = 0; i < args.Length; i++)
            {
                msg = msg.Replace($"{{{i}}}", args[i].ToString());
            }
            return msg;
        }
        public bool IsSteamID(string input)
        {
            if (string.IsNullOrEmpty(input))
            {
                return false;
            }
            if (input.Length == 17)
            {
                foreach (char c in input)
                {
                    if (!char.IsDigit(c))
                    {
                        return false;
                    }
                }
                return true;
            }

            return false;
        }
        #endregion

        #region [ DATA ] 
        private DynamicConfigFile PlayerData_File = Interface.Oxide.DataFileSystem.GetFile("BanSystem/PlayerData");
        private Dictionary<ulong, PlayerData> PlayerDatas;
        private ConfigData _config;

        private PlayerData? GetPlayerData(ulong userId)
        {
            if(PlayerDatas.TryGetValue(userId, out PlayerData nickname))
            {
                return nickname;
            }

            return null;
        }
        private string? GetPlayerNameById(ulong userId)
        {
            PlayerData data = GetPlayerData(userId);
            if(data != null)
                return data.Name;
            

            return null;
        }
        private string? GetPlayerIpById(ulong userId)
        {
            PlayerData data = GetPlayerData(userId);
            if (data != null)
                return data.Ip;


            return null;
        }
        private void UpdatePlayerData(BasePlayer player)
        {
            PlayerData data = GetPlayerData(player.userID);
            if(data != null)
            {
                data.Ip = player.Connection.IPAddressWithoutPort();
                data.Name = player.displayName;
            }
            else
            {
                PlayerDatas.Add(player.userID, new PlayerData() { Ip = player.Connection.IPAddressWithoutPort(), Name = player.displayName });
            }
        }


        private void LoadPlayerNickNames()
        {
            if (PlayerData_File.Exists() == false)
                SavePlayerNickNames();


            PlayerDatas = PlayerData_File.ReadObject<Dictionary<ulong, PlayerData>>();

            if (PlayerDatas == null)
                PlayerDatas = new Dictionary<ulong, PlayerData>();
        }
        private void SavePlayerNickNames() => PlayerData_File.WriteObject(PlayerDatas);
        #endregion

        #region [ CONFIG ]
        public class ConfigData
        {
            [JsonProperty("Основные настройки")] public MainSettings Main;
            [JsonProperty("Настройка MySql")] public DataBaseSettings DataBase;
            [JsonProperty("Настройка дискорд")] public DiscordSettings Discord;
            [JsonProperty("Настройки обхода блокировки")] public BanEvadeSetting BanEvade;
            [JsonProperty("Настройка звука при блокировке")] public SoundSetting Sound = new SoundSetting();
            [JsonProperty("Сообщения")] public Language Lang;
            public class MainSettings
            {
                [JsonProperty("Дефолтная причина блокировки (если не будет указана)")] public string defaultBanReason = "причина не указана";
                [JsonProperty("Сообщение при бане в чат [true/да | false/нет]")] public bool alertOnBan = true;
                [JsonProperty("Сообщение при кике в чат [true/да | false/нет]")] public bool alertOnKick = true;
                [JsonProperty("Сообщение при разбане в чат [true/да | false/нет]")] public bool alertOnUnban = false;
            }
            public class DiscordSettings
            {
                [JsonProperty("Вебхук банов")] public string discordWebHook_Bans = "123";
                [JsonProperty("Вебхук разбанов")] public string discordWebHook_UnBans = "123";
            }
            public class DataBaseSettings
            {
                [JsonProperty("Хост")] public string server = "localhost";
                [JsonProperty("Порт")] public string port = "3306";
                [JsonProperty("Пользователь")] public string username = "root";
                [JsonProperty("Пароль")] public string password = "root";
                [JsonProperty("Название бд")] public string database = "rusttest";
            }
            public class BanEvadeSetting
            {
                [JsonProperty("Включить блокировку обхода бана")] public bool IsEnable = true;
                [JsonProperty("Время блокировки")] public string BanTime = "30d";
                [JsonProperty("Причина блокировки")] public string Reason = "обход";
            }
            public class Language
            {
                [JsonProperty("Сообщение при бане")] public string BanMessage = "Игрок {0} был заблокирован!\nПричина: {1}";
                [JsonProperty("Сообщение при кике")] public string KickMessage = "Игрок {0} был кикнут!\nПричина {1}";
                [JsonProperty("Сообщение при разбане")] public string UnbanMessage = "Игрок {0} был разбанен!";
                [JsonProperty("Сообщение при заходе на сервер")] public string BannedMessage = "Вы заблокированы, причина: {0}\nДата разблокировки: {1}";
                [JsonProperty("Сообщение игроку при бане")] public string KickbannedMessage = "Вы были заблокированы, причина: {0}\nДата разблокировки: {1}\nЗаявка на разбан: vk.com/rust";

                public string ReplaceArgs(string msg, params object[] args)
                {
                    for (int i = 0; i < args.Length; i++)
                    {
                        msg = msg.Replace($"{{{i}}}", args[i].ToString());
                    }

                    return msg;
                }
            }
            public class SoundSetting
            {
                [JsonProperty("Проигрывать звук всем игрокам при блокировке")] public bool Play = false;
                [JsonProperty("Путь до префаба звука")] public string Prefab = "assets/prefabs/missions/portal/proceduraldungeon/effects/disappear.prefab";
            }
        }
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData();

            config.Main = new ConfigData.MainSettings();
            config.Discord = new ConfigData.DiscordSettings();
            config.DataBase = new ConfigData.DataBaseSettings();
            config.BanEvade = new ConfigData.BanEvadeSetting();
            config.Sound = new ConfigData.SoundSetting();
            config.Lang = new ConfigData.Language();

            SaveConfig(config);
        }
        void SaveConfig(object config)
        {
            Config.WriteObject(config, true);
        }
        void ReadConfig()
        {
            base.Config.Settings.ObjectCreationHandling = ObjectCreationHandling.Replace;
            _config = Config.ReadObject<ConfigData>();
            SaveConfig(_config);
        }
        #endregion

        private Ban BanPlayer(ulong userId, BasePlayer actorPlayer, string actor, string reason, long time = 0, string playerIp = "", string formattedTime = null)
        {
            string nickname = "Undefiend";
            string ip = "";

            BasePlayer player = BasePlayer.FindByID(userId);
            if(player != null)
            {
                nickname = player.displayName;
                ip = player.Connection.IPAddressWithoutPort();
            }
            else
            {
                string nn = GetPlayerNameById(userId);
                if(string.IsNullOrEmpty(nn) == false) { nickname = nn; }

                if(string.IsNullOrEmpty(playerIp) == false) { ip = playerIp; }
            }

            if(nickname.Contains("'"))
                nickname = nickname.Replace("'", " ");

            Ban ban = new Ban(userId, nickname, ip, actor, reason, DateTime.Now, time);



            _mySql.Update(Sql.Builder.Append($@"UPDATE banneds 
                SET name = '{ban.Name}', ip = '{ban.Ip}', actor = '{ban.Actor}', reason = '{ban.Reason}', banTime = '{ban.BanTime.ToString("yyyy-MM-dd HH:mm:ss")}', expiredTime = '{ban.ExpiredTime}'
                WHERE steamID = {ban.SteamID}"), _mySqlConnection, (i) =>
                {
                    if(i == 0) 
                    {
						string insertQuery = $@"INSERT INTO banneds (steamID, name, ip, actor, reason, banTime, expiredTime)
                                VALUES ({ban.SteamID}, '{ban.Name}', '{ban.Ip}', '{ban.Actor}', '{ban.Reason}', '{ban.BanTime.ToString("yyyy-MM-dd HH:mm:ss")}', '{ban.ExpiredTime}')";

                        _mySql.Query(Sql.Builder.Append(insertQuery), _mySqlConnection, (_) => { });
					}
                });

            string stringTime = time == 0 ? "Навсегда" : formattedTime;
            string msg =
                $"Игрок {nickname} заблокирован!\n" +
                $"Время: {stringTime}\n" +
                $"Администратор: {actor}\n" +
                $"Причина: {reason}";

            if(_config.Main.alertOnBan)
                Server.Broadcast(_config.Lang.ReplaceArgs(_config.Lang.BanMessage, nickname, stringTime, reason));

            if (actorPlayer != null)
            {
                actorPlayer.ChatMessage(msg);
            }
            else
            {
                Debug.LogWarning(msg);
            }

            BasePlayer targetPlayer = BasePlayer.FindByID(userId);
            if(targetPlayer != null)
            {
                DateTime futureTime = ConvertUnixTimeToDateTime(time);
                string banReason = time == 0 ? "навсегда" : futureTime.ToString();
                targetPlayer.Kick(_config.Lang.ReplaceArgs(_config.Lang.KickbannedMessage, reason, banReason));
                //targetPlayer.Kick("Вы были заблокированы!");
            }

            Interface.Call("OnPlayerBanned", userId);
            Dlog(_config.Discord.discordWebHook_Bans, GetMessage(DISCORD_BAN_MESSAGE, userId, nickname, actor, stringTime, reason));

            if (_config.Sound.Play)
            {
                foreach (var item in BasePlayer.activePlayerList)
                {
                    if (item == null) continue;

                    banEffect.Init(Effect.Type.Generic, item, 0, Vector3.zero, Vector3.forward, item.limitNetworking ? item.Connection : null);
                    banEffect.pooledString = _config.Sound.Prefab;

                    if (item.limitNetworking)
                    {
                        EffectNetwork.Send(banEffect, item.Connection);
                    }
                    else EffectNetwork.Send(banEffect);
                }
            }

            return ban;
        }
        private string KickPlayer(string filter = null, string reason = null)
        {
            if (filter == null)
                return "Не все аргументы указаны!\n" +
                    "Синтаксис: kick <никнейм> <причина (необязательно)>";

            BasePlayer player = FindPlayer(filter);
            if(player == null) return "Игрок не найден!";

            if (reason == null) reason = _config.Main.defaultBanReason;


            player.Kick(reason);
            Server.Broadcast(_config.Lang.ReplaceArgs(_config.Lang.KickMessage, player.displayName, reason));

            return $"Игрок успешно кикнут по причине {reason}";
        }
        private void GetBanBySteamID(ulong steamID, Action<Ban> callback)
        {
            string selectQuery = $"SELECT * FROM banneds WHERE steamID = {steamID}";

            _mySql.Query(Sql.Builder.Append(selectQuery), _mySqlConnection, (row) => 
            {
                if (row.Count == 0) 
                {
					callback?.Invoke(null);
                    return;
				}
                else
                {
                    Dictionary<string, object> banRecord = row.ElementAt(0);
					Ban ban = new Ban
                    (
                    	Convert.ToUInt64(banRecord["steamID"]),
                    	banRecord["name"].ToString(),
                    	banRecord["ip"].ToString(),
                    	banRecord["actor"].ToString(),
                    	banRecord["reason"].ToString(),
                    	Convert.ToDateTime(banRecord["banTime"]),
                    	Convert.ToInt64(banRecord["expiredTime"])
                    );

                    callback?.Invoke(ban);
                    return;
				}
            });
        }

        private void GetBansByIP(string ip, Action<List<Ban>> callback)
        {
			if (string.IsNullOrEmpty(ip))
			{
				callback?.Invoke(null);
				return;
			}

			string selectQuery = $"SELECT * FROM banneds WHERE ip = '{ip}' AND ip IS NOT NULL AND ip <> ''";

			_mySql.Query(Sql.Builder.Append(selectQuery), _mySqlConnection, (row) =>
			{
				if (row.Count == 0)
				{
					callback?.Invoke(null);
				}
				else
				{

                    List<Ban> bans = new List<Ban>();
                    foreach (var banRows in row)
                    {
                        bans.Add(new Ban
                        (
                            Convert.ToUInt64(banRows["steamID"]),
                            banRows["name"].ToString(),
                            banRows["ip"].ToString(),
                            banRows["actor"].ToString(),
                            banRows["reason"].ToString(),
                            Convert.ToDateTime(banRows["banTime"]),
                            Convert.ToInt64(banRows["expiredTime"])
                        ));
                    }

                    if(bans.Count == 0)
                    {
                        callback.Invoke(null);
                        return;
                    }
                    else
                    {
					    callback.Invoke(bans);
                    }
				}
			});
		}
        private void GetBanByIP(string ip, Action<Ban> callback)
        {
            if (string.IsNullOrEmpty(ip))
            {
                callback?.Invoke(null);
                return;
            }

            string selectQuery = $"SELECT * FROM banneds WHERE ip = '{ip}' AND ip IS NOT NULL AND ip <> ''";

			_mySql.Query(Sql.Builder.Append(selectQuery), _mySqlConnection, (row) =>
			{
                if (row.Count == 0) 
                {
					callback?.Invoke(null);
				}
                else
                {
                    Dictionary<string, object> banRows = row.ElementAt(0);
					Ban ban = new Ban
                    (
                        Convert.ToUInt64(banRows["steamID"]),
						banRows["name"].ToString(),
						banRows["ip"].ToString(),
						banRows["actor"].ToString(),
						banRows["reason"].ToString(),
                        Convert.ToDateTime(banRows["banTime"]),
                        Convert.ToInt64(banRows["expiredTime"])
                    );

                    callback.Invoke(ban);
                    return;
                }
			});
        }
        private void UnbanBySteamID(ulong steamID, Action<bool> callback, string actor = "Undefiend", bool notify = false)
        {
            string deleteQuery = $"DELETE FROM banneds WHERE steamID = {steamID}";

			_mySql.Delete(Sql.Builder.Append(deleteQuery), _mySqlConnection, (i) =>
			{
                if (i == 0) callback?.Invoke(false);
                else
                {
                    callback?.Invoke(true);

					if (notify)
					{
						string nname = GetPlayerNameById(steamID);
						string name = nname != null ? nname : "Undefiend";
						Dlog(_config.Discord.discordWebHook_UnBans, GetMessage(DISCORD_UNBAN_MESSAGE, steamID, name, actor));
						if (_config.Main.alertOnUnban)
							Server.Broadcast(_config.Lang.ReplaceArgs(_config.Lang.UnbanMessage, name));
					}
				}
			});
        }


        public class Ban
        {
            public ulong SteamID = 0;
            public string Name = "Undefiend";
            public string Ip = "127.0.0.1";

            public string Actor = "Undefiend";
            public string Reason = "No given";

            public DateTime BanTime = DateTime.Now;
            public long ExpiredTime;
            public Ban(ulong steamId, string name, string ip, string actor, string reason, DateTime banTime, long expiredTime)
            {
                SteamID = steamId;
                Name = name;
                Ip = ip;
                    
                Actor = actor;
                Reason = reason;

                BanTime = banTime;
                ExpiredTime = expiredTime;
            }
        }
        public class PlayerData
        {
            public string Name;
            public string Ip;
        }
    }
}

// --- End of file: BanSystem1.0.8.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/NoWaterBuild.cs ---
// --- Original Local Path: NoWaterBuild.cs ---

using System;
using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("NoWaterBuild", "Jakkee", "0.1", ResourceId = 000)]
    class NoWaterBuild : RustPlugin
    {

        #region Variables
        
        private string PermBypass = "nowaterbuild.bypass";
        private double Depth = 0.5;
        private bool Refund = true;

        #endregion

        #region Initialization

        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            Config["Give Refund"] = true;
            Config["Entity Depth"] = 0.5;
            Config.Save();
        }

        void Loaded()
        {
            CheckConfig();
            Depth = GetConfig("Entity Depth", 0.5);
            Refund = GetConfig("Give Refund", true);
            permission.RegisterPermission(PermBypass, this);
            lang.RegisterMessages(messages, this);
        }

        void CheckConfig()
        {
            if (Config["VERSION"] == null)
            {
                ReloadConfig();
            }
            else if (GetConfig<string>("VERSION", "") != Version.ToString())
            {
                ReloadConfig();
            }
        }

        protected void ReloadConfig()
        {
            Config["VERSION"] = Version.ToString();
            SaveConfig();
        }

        Dictionary<string, string> messages = new Dictionary<string, string>()
        {
            {"Placement: Water", "You are not allowed to build in water"},
        };

        #endregion

        #region Oxide Hooks / Core

        void OnEntityBuilt(Planner planner, GameObject gameobject)
        {
            BasePlayer player = planner.GetOwnerPlayer();
            if (!HasPermission(player.UserIDString, PermBypass))
            {
                BaseEntity entity = UnityEngine.GameObjectEx.ToBaseEntity(gameobject);
                if (entity.WaterFactor() >= Depth)
                {
                    if (Refund)
                    {
                        var buildingBlock = entity.GetComponent<BuildingBlock>();
                        if (buildingBlock != null)
                        {
                            foreach (ItemAmount item in buildingBlock.blockDefinition.grades[(int)buildingBlock.grade].costToBuild)
                            {
                                player.inventory.GiveItem(ItemManager.CreateByItemID(item.itemid, (int)item.amount));
                            }
                        }
                    }
                    entity.Kill();
                    SendReply(player, Lang("Placement: Water"), player);
                }
            }
        }

        #endregion

        #region Helper Methods

        private T GetConfig<T>(string name, T defaultValue)
        {
            if (Config[name] == null)
            {
                Config[name] = defaultValue;
                Config.Save();
                return defaultValue;
            }

            return (T)Convert.ChangeType(Config[name], typeof(T));
        }

        string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        bool HasPermission(string id, string perm) => permission.UserHasPermission(id, perm);

        #endregion
    }
}


// --- End of file: NoWaterBuild.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TPSkillSystem.cs ---
// --- Original Local Path: TPSkillSystem.cs ---

﻿namespace Oxide.Plugins
{
    using System;
    using System.Reflection;
    using System.Collections.Generic;
    using System.Collections;
    using System.Linq;
    using UnityEngine;
    using Oxide.Core;
    using Oxide.Core.Plugins;
    using Newtonsoft.Json;
    using Oxide.Game.Rust.Cui;
    using System.Globalization;
    using Random = UnityEngine.Random;

    [Info("TPSkillSystem", "Sempai#3239", "5.0.0")]
    public class TPSkillSystem : RustPlugin
    {

        #region Определение переменных
        public class classSkillParameters
        {
            [JsonProperty("Количество XP(%)")]
            public double countXP;
            [JsonProperty("Количество DNK")]
            public float countDNK;
        }

        public class PlayerSkillData
        {
            [JsonProperty("Название")]
            public string Name;
            [JsonProperty("Описание")]
            public string Description;
            [JsonProperty("Shortname на который будет действовать увеличенный рейтинг скилла")]
            public List<string> ShortnameList;
            [JsonProperty("Рейты игрока ( ПРИБАВЛЯЮТСЯ % ОТ ДОБЫТОГО ИМ РЕСУРСА)")]
            public int Rate;
            [JsonProperty("Сколько % прибавлять за уровень")]
            public int PercentIncrement;
            [JsonProperty("Сколько количество жизней будет увеличиваться на XRate")]
            public double HPIncrementInRate;
            [JsonProperty("Сколько максимум хп игрок получит от регенерации")]
            public int MaxRegen;
            [JsonProperty("Максимальная защита от способности")]
            public int MaxProtection;
            [JsonProperty("Максимальный урон от способности")]
            public int MaxAtack;
            [JsonProperty("Уровень способности")]
            public int Level;
            [JsonProperty("Сколько возвращать DNK при откате способности(0-100%)")]
            public int ReturnPercent;
        }

        public static string CUILayerName = "PERCENT_LAYER_UI";
        public static string DescLayerName = "DESCRIPTION_LAYER_UI";
        public static string MessageUILayerName = "MESSAGE_LAYER_UI";
        public static string UIName = "lay";

        private Dictionary<NetworkableId, BasePlayer> BradleyAtackerList = new Dictionary<NetworkableId, BasePlayer>();
        private Dictionary<NetworkableId, BasePlayer> HeliAtackerList = new Dictionary<NetworkableId, BasePlayer>();
        public Dictionary<ulong, classSkillParameters> PlayersSkillParameters = new Dictionary<ulong, classSkillParameters>();
        public Dictionary<ulong, List<PlayerSkillData>> PlayersSkillDataMassiv = new Dictionary<ulong, List<PlayerSkillData>>();


        private static DefaultSettings MainGUISettings = new DefaultSettings();

        #endregion Определение переменных

        #region CONFIGS

        //Подготавливает данные по умолчанию
        List<PlayerSkillData> DefaultPlayersSkillData()
        {
            List<PlayerSkillData> PlayersSkillDataList = new List<PlayerSkillData>();
            foreach (var skill in MainGUISettings.configSkillSettings)
            {
                PlayersSkillDataList.Add(new PlayerSkillData()
                {
                    Name = skill.Name,
                    Description = skill.Description,
                    ShortnameList = new List<string> { },
                    Level = 0,
                    HPIncrementInRate = 0.0,
                    MaxRegen = 0,
                    MaxAtack = 0,
                    MaxProtection = 0,
                    ReturnPercent = skill.ReturnPercent,
                    Rate = skill.Rate,
                    PercentIncrement = skill.PercentIncrement
                });
            }
            return PlayersSkillDataList;
        }
        //ВЫСТАВЛЯЕМ НАСТРОЙКИ ПО УМОЛЧАНИЮ (КОНФИГ)
        private class DefaultSettings
        {

            public class classSkill
            {
                [JsonProperty("Название", Order = 0)] public string Name;
                [JsonProperty("Описание", Order = 1)] public string Description;
                [JsonProperty("Shortname на который будет действовать увеличенный рейтинг скилла", Order = 2)] public List<string> ShortnameList;
                [JsonProperty("Рейты игрока ( ПРИБАВЛЯЮТСЯ % ОТ ДОБЫТОГО ИМ РЕСУРСА)", Order = 3)] public int Rate;
                [JsonProperty("Сколько % прибавлять за уровень", Order = 4)] public int PercentIncrement;
                [JsonProperty("Сколько количество жизней будет увеличиваться на XRate", Order = 5)] public double HPIncrementInRate;
                [JsonProperty("Сколько максимум хп игрок получит от регенерации", Order = 6)] public int MaxRegen;
                [JsonProperty("Максимальная защита от способности", Order = 7)] public int MaxProtection;
                [JsonProperty("Максимальный урон от способности", Order = 8)] public int MaxAtack;
                [JsonProperty("Максимальный уровень", Order = 9)] public int MaxLevel;
                [JsonProperty("Сколько возвращать DNK при откате способности(0-100%)", Order = 10)] public int ReturnPercent;
            }
            [JsonProperty("Влючить поддержку кейсов (для отображения прогресс бара выше кейсов)", Order = 1)] public bool Enabled = true;
            [JsonProperty("Описание плагина скилов", Order = 1)] public string Desc = "Ахуенный плагин скилов всем советую, а кто не купит, тот гомосек";
            [JsonProperty("Очищать ли очки игроков после вайпа", Order = 1)] public bool ClearPoint = false;
            [JsonProperty("Очищать ли скилы игроков после вайпа", Order = 1)] public bool ClearSkill = false;
            [JsonProperty("Предметы-исключения(если игрок добаывает этим предметом , опыт не зачисляется)", Order = 3)] public List<string> ItemExceptionList;
            [JsonProperty("Настройка способностей", Order = 2)] public List<classSkill> configSkillSettings = new List<classSkill>();
            internal class classSkillSettings
            {
                [JsonProperty("Сколько опыта давать за убийство животных", Order = 5)] public double xpForKillAnimal;
                [JsonProperty("Сколько опыта давать за убийство NPC", Order = 2)] public double xpForKillNPC;
                [JsonProperty("Сколько опыта давать за убийство игрока в голову", Order = 4)] public double xpForKillHeadshot;
                [JsonProperty("Сколько опыта давать за убийство игрока", Order = 3)] public double xpForKillPlayer;
                [JsonProperty("Сколько опыта давать за добычу ресурсов", Order = 0)] public double xpForResourceExtraction;
                [JsonProperty("Сколько опыта давать за сбитие чинука", Order = 8)] public double xpForKillChinuk;
                [JsonProperty("Сколько опыта давать за разбитие бочек", Order = 1)] public double xpForBreakBarrels;
                [JsonProperty("Сколько опыта давать за взрыв танка", Order = 7)] public double xpForKillBredley;
                [JsonProperty("Сколько опыта давать за сбитие вертолета", Order = 6)] public double xpForKillHely;
            }
            [JsonProperty("Настройка опыта за действия", Order = 0)]
            public classSkillSettings xpSkillSettingsConfig = new classSkillSettings();
            [JsonProperty("Сколько DNK давать за новый уровень", Order = 0)] public int countDNKForNewLevel = 1;

            public static DefaultSettings SetDefaultSettings()
            {
                return new DefaultSettings
                {
                    countDNKForNewLevel = 1,
                    ItemExceptionList = new List<string> {
                                "jackhammer",
                                "shotgun.double",
                            },
                    xpSkillSettingsConfig = new classSkillSettings
                    {
                        xpForResourceExtraction = 1,
                        xpForBreakBarrels = 0.3,
                        xpForKillNPC = 5,
                        xpForKillPlayer = 4,
                        xpForKillHeadshot = 6,
                        xpForKillAnimal = 3,
                        xpForKillHely = 15,
                        xpForKillBredley = 12,
                        xpForKillChinuk = 20,
                    },
                    GUISettings = new classGUISettings
                    {
                        BackgroundColor = "0 0 0 0.5",
                        SkillBackgroundColor = "0 0 0 0.3"
                    },
                    configSkillSettings = new List<classSkill> {
                                new classSkill {
                                    Name = "Добытчик",
                                        Description = "Каждый уровень повышает количество добываемых ресурсов на 10%, всего можно прокачать на х1, в итоге у вас будет рейты сервера х2.",
                                        ShortnameList = new List < string > {
                                            "wood",
                                            "stones",
                                            "sulfur.ore",
                                            "metal.ore",
                                            "meat.boar",
                                            "bearmeat",
                                            "fat.animal",
                                            "chicken.raw",
                                            "deermeat.raw",
                                            "horsemeat.raw",
                                            "fish.minnows",
                                            "fish.raw",
                                            "fish.troutsmall",
                                            "wolfmeat.raw",
                                            "leather",
                                            "bone.fragments"
                                        },
                                        Rate = 0,
                                        PercentIncrement = 10,
                                        MaxLevel = 10,
                                        ReturnPercent = 50,
                                },
                                new classSkill {
                                    Name = "Защитник",
                                        Description = "Повышает защиту вашего дома",
                                        ShortnameList = new List < string > {
                                        },
                                        Rate = 0,
                                        PercentIncrement = 50,
                                        MaxLevel = 10,
                                        ReturnPercent = 50,
                                },
                                new classSkill {
                                    Name = "Ученый",
                                        Description = "Увеличивает выпадение серной руды",
                                        ShortnameList = new List < string > {
                                            "sulfur.ore"
                                        },
                                        Rate = 0,
                                        PercentIncrement = 10,
                                        MaxLevel = 10,
                                        ReturnPercent = 50,
                                },
                                new classSkill {
                                    Name = "Мясник",
                                        Description = "Увеличивает количество ресурсов за разделку животных",
                                        ShortnameList = new List < string > {
                                        },
                                        Rate = 0,
                                        PercentIncrement = 20,
                                        MaxLevel = 5,
                                        ReturnPercent = 50,
                                },
                                new classSkill {
                                    Name = "Метаболизм",
                                        Description = "При возраждении у вас будет больше здоровья",
                                        ShortnameList = new List < string > {},
                                        HPIncrementInRate = 1,
                                        PercentIncrement = 6,
                                        Rate = 0,
                                        MaxLevel = 5,
                                        ReturnPercent = 50,
                                },
                                new classSkill {
                                    Name = "Вампиризм",
                                        Description = "При нанесении урона вы будете лечиться!",
                                        ShortnameList = new List < string > {},
                                        Rate = 0,
                                        PercentIncrement = 1,
                                        MaxRegen = 50,
                                        MaxLevel = 5,
                                        ReturnPercent = 50,
                                },
                                new classSkill {
                                    Name = "Защита",
                                        Description = "Вы будете получать меньше урона!",
                                        ShortnameList = new List < string > {},
                                        MaxProtection = 1000,
                                        PercentIncrement = 8,
                                        Rate = 0,
                                        MaxLevel = 5,
                                        ReturnPercent = 50,
                                },
                                new classSkill {
                                    Name = "Нападение",
                                        Description = "Вы будете наносить больше урона!",
                                        ShortnameList = new List < string > {},
                                        MaxAtack = 500,
                                        Rate = 0,
                                        PercentIncrement = 8,
                                        MaxLevel = 5,
                                        ReturnPercent = 50

                                },
                            },
                };
            }
            [JsonProperty("Настройка UI", Order = 1)]
            public classGUISettings GUISettings = new classGUISettings();
            internal class classGUISettings
            {
                [JsonProperty("Цвет заднего фона в меню способностей", Order = 4)] public string BackgroundColor;
                [JsonProperty("Цвет заднего фона способности", Order = 6)] public string SkillBackgroundColor;
            }
            [JsonProperty("Сообщение при 100% опыта", Order = 2)] public string LevelupText = "Вы получили очки ДНК за новый уровень! /skill";
        }

        protected override void SaveConfig() => Config.WriteObject(MainGUISettings);


        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                MainGUISettings = Config.ReadObject<DefaultSettings>();
                if (MainGUISettings?.countDNKForNewLevel == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning($"Ошибка чтения конфигурации 'oxide/config/{Name }', создаём новую конфигурацию!!");
                LoadDefaultConfig();
            }
            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => MainGUISettings = DefaultSettings.SetDefaultSettings();

        #endregion CONFIG

        #region СОБЫТИЯ


        #region ДОБЫЧА РЕСОВ (ДРОВОСЕК, ШАХТЕР, СЕРА)
        //СОБЫТИЕ ДО СБОРА ИГРОКОМ РЕСУРСОВ
        [Oxide.Core.Plugins.HookMethod("OnDispenserGather")]
        void HookOnDisoenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            DispenserGatherFunc(dispenser, entity, item);
        }

        //ФУНКЦИЯ СРАБАТЫВАЕТ ДО НАЧАЛА ПОДНЯТИЯ РЕСУРСА
        void DispenserGatherFunc(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            BasePlayer player = entity as BasePlayer;
            foreach (var Data in PlayersSkillDataMassiv[player.userID])
            {
                //Цикл по элементам списка shortname
                foreach (var DataList in Data.ShortnameList)
                {
                    if (item.info.shortname == DataList)
                    {
                        int Amount = item.amount * (100 + Data.Rate) / 100;
                        item.amount = Amount;
                    }
                }
            }
        }
        #endregion ДОБЫЧА РЕСОВ (ДРОВОСЕК, ШАХТЕР, СЕРА)

        #region ПОВЫШЕНИЕ ОПЫТА ЗА ОКОНЧАНИЕ СБОРА РЕСОВ
        //ХУК НА ОКОНЧАНИЕ СБОРА РЕСУРСА
        [Oxide.Core.Plugins.HookMethod("OnDispenserBonus")]
        object MyHookDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            object TotalObject = null;
            object ObjectBonus = null;
            ObjectBonus = DispenserBonusFunc(dispenser, player, item);
            if (ObjectBonus != null) TotalObject = ObjectBonus;
            return TotalObject;
        }

        //ПОВЫШАЕМ ОПЫТ ЗА ОКНЧАНИЕ СБОРА РЕСУРСА
        object DispenserBonusFunc(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            foreach (var Data in PlayersSkillDataMassiv[player.userID])
            {
                foreach (var DataList in Data.ShortnameList)
                {
                    if (item.info.shortname == DataList)
                    {
                        int Amount = item.amount * (100 + Data.Rate) / 100;
                        item.amount = Amount;
                    }
                }
            }
            var shortName = player.GetActiveItem().info.shortname;
            if (shortName == null) return null;
            if (MainGUISettings.ItemExceptionList.Contains(shortName)) return null;
            //ДАЕМ ОПЫТ ЗА ДОБЫЧУ РЕСУРСА
            GetXP(player, MainGUISettings.xpSkillSettingsConfig.xpForResourceExtraction);
            return null;
        }

        //При собирании руды
        void OnCollectiblePickup(Item item, BasePlayer player, CollectibleEntity entity)
        {
            foreach (var Data in PlayersSkillDataMassiv[player.userID])
            {
                foreach (var DataList in Data.ShortnameList)
                {
                    if (item.info.shortname == DataList)
                    {
                        int Amount = item.amount * (100 + Data.Rate) / 100;
                        item.amount = Amount;
                    }

                }

            }
        }

        #endregion ПОВЫШЕНИЕ ОПЫТА ЗА ОКОНЧАНИЕ СБОРА РЕСОВ

        #region Протект
		List<string> Prefabs = new List<string>()
		{
			"cupboard.tool.deployed",
			"wall.frame.shopfront.metal"
        };

        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
		{
			if (entity == null || info?.InitiatorPlayer == null) return;
            bool ent = entity is BuildingBlock;

            if (ent) {
                foreach (var check in PlayersSkillDataMassiv[entity.OwnerID]) {
                    if (check.Name == "Защитник") {
                        float procent = (float) check.Level * check.PercentIncrement / 1000;
                        Puts(procent.ToString());
                        Protection(entity, info, procent);	
                    }
                }	
            }

		}

        void Protection(BaseCombatEntity entity, HitInfo info, float damage)
		{
			BasePlayer player = info.InitiatorPlayer;
			bool ent = entity is BuildingBlock;
				
			if(ent)
				if((entity as BuildingBlock).grade == BuildingGrade.Enum.Twigs)
					return;
				
		    if (ent || entity is Door || entity is SimpleBuildingBlock || Prefabs.Contains(entity.ShortPrefabName))
		    {
				info.damageTypes.ScaleAll(1.0f - damage);
                PrintWarning($"Debug: {info.damageTypes}");
			}
		}
        #endregion

        #region МЕТАБОЛИЗМ
        //ХУК срабатывает когда игрок возраждается 
        [Oxide.Core.Plugins.HookMethod("OnPlayerRespawned")]
        void myHookOnPlayerRespawn(BasePlayer player)
        {
            AddHealth(player);
        }
        //Добавление жизней игроку при возрождении (Цепляется на хук)
        private void AddHealth(BasePlayer player)
        {
            if (!PlayersSkillDataMassiv.ContainsKey(player.userID)) return;
            foreach (var Data in PlayersSkillDataMassiv[player.userID])
            {
                if (Data.HPIncrementInRate > 0)
                {
                    double HPValue = Data.HPIncrementInRate * Data.Rate + Data.HPIncrementInRate;
                    double hydrValue = 5 * (Data.HPIncrementInRate * Data.Rate) + Data.HPIncrementInRate;
                    double eatValue = 10 * Data.HPIncrementInRate * Data.Rate + Data.HPIncrementInRate;
                    player.health += (float)HPValue;
                    player.metabolism.hydration.value += (float)hydrValue;
                    player.metabolism.calories.value += (float)eatValue;
                    player.metabolism.calories.value += (float)eatValue;
                }
            }
        }

        object OnPlayerHealthChange(BasePlayer player, float oldValue, float newValue)
        {

            if (!PlayersSkillDataMassiv.ContainsKey(player.userID)) return null;
            if (oldValue < newValue) return null;
            if ((oldValue - newValue) < 5) return null;
            foreach (var Data in PlayersSkillDataMassiv[player.userID])
            {
                if (Data.HPIncrementInRate > 0)
                {
                    if ((newValue < 30) && (newValue > 0))
                    {
                        int r = Random.Range(1, 8 - Data.Level);
                        if (r == 1)
                        {
                            player.health += 18 + (Data.Level) * 2;
                        }
                    }
                }
            }

            return null;
        }

        #endregion МЕТАБОЛИЗМ

        #region ОПЫТ ЗА УБИЙСТВА
        //При смерти сущности
        [Oxide.Core.Plugins.HookMethod("OnEntityDeath")]
        void OnDeadEntity(BaseCombatEntity entity, HitInfo info)
        {
			if (entity==null || info==null) return;
            EntityDeathFunc(entity, info);
        }

        //ДОБАВЛЕНИЕ ОПЫТА ЗА УБИЙСТВА
        void EntityDeathFunc(BaseCombatEntity entity, HitInfo info)
        {
            if (entity as BaseHelicopter)
            {
                if (HeliAtackerList.ContainsKey(entity.net.ID))
                {
                    var HeliKiller = HeliAtackerList[entity.net.ID];
                    GetXP(HeliKiller, MainGUISettings.xpSkillSettingsConfig.xpForKillHely);
                }
            }
            if (entity as BradleyAPC)
            {
                if (BradleyAtackerList.ContainsKey(entity.net.ID))
                {
                    var BradleyKiller = BradleyAtackerList[entity.net.ID];
                    GetXP(BradleyKiller, MainGUISettings.xpSkillSettingsConfig.xpForKillBredley);
                }
            }
            if (entity == null || info == null || info.Initiator is BaseNpc || info.Initiator is ScientistNPC || info.InitiatorPlayer == null || info.InitiatorPlayer.GetComponent<NPCPlayer>()) return;
            if (info?.InitiatorPlayer == null) return;
            BasePlayer atacker = info.InitiatorPlayer;
            if (atacker as BasePlayer)
            {
                if (entity as BaseAnimalNPC)
                {
                    GetXP(atacker, MainGUISettings.xpSkillSettingsConfig.xpForKillAnimal);
                }
                if (entity as BasePlayer)
                {
                    if (atacker.userID == (entity as BasePlayer).userID) return;
                    if (info.isHeadshot) GetXP(atacker, MainGUISettings.xpSkillSettingsConfig.xpForKillHeadshot);
                    else GetXP(atacker, MainGUISettings.xpSkillSettingsConfig.xpForKillPlayer);
                }
                if (entity as CH47Helicopter)
                {
                    GetXP(atacker, MainGUISettings.xpSkillSettingsConfig.xpForKillChinuk);
                }
                if (entity as ScientistNPC)
                {
                    GetXP(atacker, MainGUISettings.xpSkillSettingsConfig.xpForKillNPC);
                }
                if (entity.ShortPrefabName.Contains("barrel"))
                {
                    GetXP(atacker, MainGUISettings.xpSkillSettingsConfig.xpForBreakBarrels);
                }
            }
        }

        #endregion

        //ХУК на получение дамага
        [Oxide.Core.Plugins.HookMethod("OnEntityTakeDamage")]
        void MyHookTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            TakeDamageFunc(entity, info);
        }
		
        //СОБЫТИЕ ПРИ НАНЕСЕНИИ УРОНА ПО СУЩНОСТИ
        void TakeDamageFunc(BaseCombatEntity entity, HitInfo info)
        {
			if (entity==null || info==null) return;
			
			bool atackerNPC=false;
			bool entityNPC=false;
            if (info.Initiator is BaseNpc || info.Initiator is ScientistNPC  || info.InitiatorPlayer == null) atackerNPC=true;
            if (entity is BaseNpc || entity is ScientistNPC || entity == null) entityNPC=true;            
			if (atackerNPC==false && (info.InitiatorPlayer is BasePlayer)==false) return;
			if (entityNPC==false && (entity is BasePlayer)==false) return;
			
  		    if (entity is BaseHelicopter && !atackerNPC && info.InitiatorPlayer != null) HeliAtackerList[entity.net.ID] = info.InitiatorPlayer;
            if (entity is BradleyAPC && !atackerNPC && info.InitiatorPlayer != null) BradleyAtackerList[entity.net.ID] = info.InitiatorPlayer;
            if (atackerNPC && entityNPC) return;
			
			//если урон нанес сам себе
			if (!entityNPC && !atackerNPC) if (info.InitiatorPlayer.userID == (entity as BasePlayer).userID) return;
			//Находим рейты для атакующего и повышаем атаку + подрегениваем
			if (!atackerNPC){
				BasePlayer atacker = info.InitiatorPlayer;
				if (!PlayersSkillDataMassiv.ContainsKey(atacker.userID)) return;
				//double atackerRate=0;
				foreach (var Data in PlayersSkillDataMassiv[atacker.userID])
				{
					if (Data.MaxAtack != 0 && info.damageTypes.Total() > 5)
					{
						//РАСЧЕТЫ УСИЛЕНИЯ АТАКИ				
						double DamageValue = 1 + (0.01f * Data.Rate);
						if (DamageValue <= Data.MaxAtack) info.damageTypes.ScaleAll((float)DamageValue);
					}
					//Нужно ли регенить
					if (Data.MaxRegen > 0)
					{
						//Формула отхила
						double RegenValue = info.damageTypes.Total() * 0.01f * Data.Rate;
						if (RegenValue > Data.MaxRegen) RegenValue = Data.MaxRegen;
						atacker.Heal((float)RegenValue);
					}
				}
			}
			//Работаем с защитой жертвы смотрим рейты и снижаем атаку
			if (entity is BasePlayer) {
				BasePlayer enemy = entity as BasePlayer;
				if (!entityNPC){
					if (!PlayersSkillDataMassiv.ContainsKey(enemy.userID)) return;
					//Вычитаем защиту
					foreach (var DataTarget in PlayersSkillDataMassiv[enemy.userID]){
						if (DataTarget.MaxProtection > 0)
						{
							//Уменьшаем текущий дамаг на рейты
							double DamageTotal = 1 - (0.007 * DataTarget.Rate);
							info.damageTypes.ScaleAll((float)DamageTotal);
						}
					}	
				}
			}
        }

        //ПРИ ИНИЦИАЛИЗАЦИИ
        [Oxide.Core.Plugins.HookMethod("OnServerInitialized")]
        void MyHookServerInit()
        {
            AddImage("https://i.imgur.com/pRc32Vx.png", "FullGui");
            AddImage("https://i.imgur.com/kKhxfm0.png", "fonSkill");
            AddImage("https://gspics.org/images/2023/11/29/07ZMCi.png", "fonUI");
            AddImage("https://i.imgur.com/BeBP63b.png", "fonDescription");
            AddImage("https://imgur.com/XXbnZU4.png", "imageskillxp");
            InitSkillSystem();
        }


        //ИНИЦИАЛИЗАЦИЯ
        private void InitSkillSystem()
        {
            PlayersSkillParameters = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, classSkillParameters>>("SkillSystem/ProgressPlayer");
            PlayersSkillDataMassiv = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, List<PlayerSkillData>>>("SkillSystem/PlayerSkills");
			
            foreach (BasePlayer player in BasePlayer.activePlayerList) PlayerInitFunc(player);
        }


        //ХУК ПРИ ВЫГРУЗКИ ПЛАГИНА
        [Oxide.Core.Plugins.HookMethod("Unload")]
        void MyHookUnload()
        {
            UnloadFunc();
			MyHookOnServerSave();
        }

        void OnNewSave() 
        {
            if (MainGUISettings.ClearPoint)
            {
                PlayersSkillParameters?.Clear();
                PrintWarning("Замечен вайп! Очещаем очки игроков!");
            }
            if (MainGUISettings.ClearSkill)
            {
                PrintWarning("Замечен вайп! Очищаем скилы игроков!");
                PlayersSkillDataMassiv?.Clear();
            }
        }
        //ПРИ ВЫГРУЗКИ ПЛАГИНА
        void UnloadFunc()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList) CuiHelper.DestroyUi(player, CUILayerName);

        }

        //При сохранении данных
        [Oxide.Core.Plugins.HookMethod("OnServerSave")]
        void MyHookOnServerSave()
        {
            ServerSaveFunc();
        }

        //ФУНКЦИЯ ПРИ СОХРАНЕНИИ ДАННЫХ НА СЕРВЕРЕ
        void ServerSaveFunc()
        {
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("SkillSystem/ProgressPlayer", PlayersSkillParameters);
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("SkillSystem/PlayerSkills", PlayersSkillDataMassiv);
        }


        //При инициализации игрока
        [Oxide.Core.Plugins.HookMethod("OnPlayerConnected")]
        void MyHookPlayerInit(BasePlayer player)
        {
            PlayerInitFunc(player);
        }
        //ПРИ ИНИЦИАЛИЗАЦИИ ИГРОКА
        public void PlayerInitFunc(BasePlayer player)
        {
            if (player.IsReceivingSnapshot)
            {
                NextTick(() => PlayerInitFunc(player));
                return;
            }
            if (!PlayersSkillParameters.ContainsKey(player.userID))
            {
                classSkillParameters SkillParametersPlayer = new classSkillParameters()
                {
                    countXP = 0,
                    countDNK = 3
                };
                PlayersSkillParameters.Add(player.userID, SkillParametersPlayer);
            }
            if (!PlayersSkillDataMassiv.ContainsKey(player.userID))
            {
                PlayersSkillDataMassiv.Add(player.userID, DefaultPlayersSkillData());
            }
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("SkillSystem/ProgressPlayer", PlayersSkillParameters);
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("SkillSystem/PlayerSkills", PlayersSkillDataMassiv);

            InterfaceXP(player);
        }


        #endregion СОБЫТИЯ
        #region GUI
        void ShowMainUI(BasePlayer player)
        {
            CuiElementContainer UIContainer = new CuiElementContainer();

            UIContainer.Add(new CuiElement
            {
                Name = UIName + ".Main",
                Parent = ".Mains",
                Components = {
                    new CuiRawImageComponent { Png = GetImage("fonUI"), Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "-0.315 -0.27", AnchorMax = "1.3 1.275", OffsetMax = "0 0" },
                }
            });

            UIContainer.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.78 0.805", AnchorMax = "0.795 0.833", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Command = "descs" },
                Text = { Text = "?", Color = "1 1 1 0.7", Align = TextAnchor.MiddleCenter, FontSize = 16, Font = "robotocondensed-regular.ttf" }
            }, UIName + ".Main");

            UIContainer.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.8 0.804", AnchorMax = "0.817 0.832" },
                Button = { Close = "Menu_UI", Color = "0 0 0 0" },
                Text = { Text = "" }
            }, UIName + ".Main");

            UIContainer.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.425 0.29", AnchorMax = "0.6 0.32" },
                Text = { Text = "Очки прокачки", FontSize = 15, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" }
            }, UIName + ".Main", UIName + ".Main" + ".ScoreText");

            UIContainer.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.558 0.285", AnchorMax = "0.578 0.32" },
                Text = { Text = String.Format("{0:00.0}", PlayersSkillParameters[player.userID].countDNK), FontSize = 13, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" }
            }, UIName + ".Main", UIName + ".Main" + ".Score");

            for (int x = 0, y = 0, i = 0; i < MainGUISettings.configSkillSettings.Count; i++)
            {
                var SkillSetting = MainGUISettings.configSkillSettings[i];
                int currentLevel = PlayersSkillDataMassiv[player.userID][i].Level;
                CuiHelper.DestroyUi(player, $"PanelSkill_{i}");
                UIContainer.Add(new CuiPanel
                {
                    RectTransform = {
                        AnchorMin = $"{0.211 + (x * 0.38)} {0.623 - (y * 0.08)}",
                        AnchorMax = $"{0.411 + (x * 0.38)} {0.675 - (y * 0.08)}"
                    },
                    Image = {
                        Color = "0 0 0 0"
                    }
                }, UIName + ".Main", UIName + ".Main" + $"Skill{i}");

                UIContainer.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.01252624 0.1219493", AnchorMax = "0.6346555 0.9024402" },
                    Text = { Text = SkillSetting.Name, FontSize = 14, Color = "1 1 1 0.65",Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                }, UIName + ".Main" + $"Skill{i}");

                UIContainer.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.7 0", AnchorMax = "0.89 1" },
                    Text = { Text = $"{currentLevel}/{SkillSetting .MaxLevel}", Color = "1 1 1 0.65",FontSize = 12, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                }, UIName + ".Main" + $"Skill{i}");
        
                UIContainer.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.02 0.1", AnchorMax = "0.13 0.81" },
                    Button = { Command = $"opendescription {i}", Color = "1 1 1 0" },
                    Text = { Text = "" }
                }, UIName + ".Main" + $"Skill{i}");

                UIContainer.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.875 0.1", AnchorMax = "0.98 0.81" },
                    Button = { Command = $"plussbtn {i}", Color = "1 1 1 0" },
                    Text = { Text = "" }
                }, UIName + ".Main" + $"Skill{i}");

                UIContainer.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.62 0.1", AnchorMax = "0.72 0.81" },
                    Button = { Command = $"minusbtn {i}", Color = "1 1 1 0" },
                    Text = { Text = "" }
                }, UIName + ".Main" + $"Skill{i}");

                y++;
                if (y >= 4)
                {
                    y = 0;
                    x++;
                }
            }

            CuiHelper.AddUi(player, UIContainer);
        }

        [ConsoleCommand("descs")]
        void DescUI(ConsoleSystem.Arg args) {
            var player = args.Player();
            CuiHelper.DestroyUi(player, UIName + ".Main" + ".Description");
            var container = new CuiElementContainer();

            container.Add(new CuiElement
            {
                Name = UIName + ".Main" + ".Description",
                Parent = UIName + ".Main",
                Components = {
                    new CuiRawImageComponent { Png = (string)ImageLibrary.Call("GetImage", "fonDescription") },
                    new CuiRectTransformComponent { AnchorMin = $"0.58 0.6", AnchorMax = $"0.8 0.8" },
                }
            });

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.05 0.8", AnchorMax = "0.9 1" },
                Text = { Text = $"Описание скилов", Color = "1 1 1 0.65",FontSize = 14, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, UIName + ".Main" + ".Description");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.05 0", AnchorMax = "1 0.7" },
                Text = { Text = $"{MainGUISettings.Desc}", Color = "1 1 1 0.65",FontSize = 12, Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperLeft }
            }, UIName + ".Main" + ".Description");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.9 0.82", AnchorMax = "0.98 0.98" },
                Button = { Close = UIName + ".Main" + ".Description", Color = "1 1 1 0" },
                Text = { Text = "" }
            }, UIName + ".Main" + ".Description");

            CuiHelper.AddUi(player, container);
        }

        private void DescriptionUi(BasePlayer player, float element)
        {
            CuiHelper.DestroyUi(player, UIName + ".Main" + $"Skill{element}" + ".Description");
            CuiElementContainer UIContainer = new CuiElementContainer();

            var CurrentSkillSettings = MainGUISettings.configSkillSettings[(int)element];
            float CurrentLevel = PlayersSkillDataMassiv[player.userID][(int)element].Level;
            float x = element >= 4 ? 1 : 0.3f;
            float y = element >= 4 ? element - 4 : element;

            UIContainer.Add(new CuiElement
            {
                Name = UIName + ".Main" + $"Skill{element}" + ".Description",
                Parent = UIName + ".Main",
                Components = {
                    new CuiRawImageComponent { Png = GetImage("fonDescription") },
                    new CuiRectTransformComponent { AnchorMin = $"{0.078 + (x * 0.4)} {0.512 - (y * 0.08)}", AnchorMax = $"{0.28 + (x * 0.4)} {0.694 - (y * 0.08)}" },
                }
            });

            UIContainer.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.05 0.8", AnchorMax = "0.9 1" },
                Text = { Text = $"Описание скила '{CurrentSkillSettings.Name}'", Color = "1 1 1 0.65",FontSize = 14, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, UIName + ".Main" + $"Skill{element}" + ".Description");

            UIContainer.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.05 0", AnchorMax = "1 0.7" },
                Text = { Text = $"{CurrentSkillSettings.Description}", Color = "1 1 1 0.65",FontSize = 12, Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperLeft }
            }, UIName + ".Main" + $"Skill{element}" + ".Description");

            UIContainer.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.9 0.82", AnchorMax = "0.98 0.98" },
                Button = { Close = UIName + ".Main" + $"Skill{element}" + ".Description", Color = "1 1 1 0" },
                Text = { Text = "" }
            }, UIName + ".Main" + $"Skill{element}" + ".Description");

            CuiHelper.AddUi(player, UIContainer);
        }

        //Добавление опыта и обновление GUI
        public void GetXP(BasePlayer player, double param)
        {
			if (player==null) return;
			if (!PlayersSkillParameters.ContainsKey(player.userID)) return;
            var SkillParametrs = PlayersSkillParameters[player.userID];
            SkillParametrs.countXP += param;
            if (SkillParametrs.countXP >= 100)
            {
                SkillParametrs.countXP = 0;
                SkillParametrs.countDNK += MainGUISettings.countDNKForNewLevel;
                Log("log", $"{player.displayName} заработал очко ДНК");
                SendReply(player, MainGUISettings.LevelupText);
                TPCases?.Call("LevelUp", player);
            }
            InterfaceXP(player);
        }

        //ВЫГРУЗКА UI
        private IEnumerator UnloadUI(BasePlayer player, CuiElementContainer container, int element)
        {
            CuiHelper.DestroyUi(player, DescLayerName);
            CuiHelper.DestroyUi(player, $"Description{element }");
            var CurrentSkillSettings = MainGUISettings.configSkillSettings[element];
            int CurrentLevel = PlayersSkillDataMassiv[player.userID][element].Level;
            container.Add(new CuiPanel
            {
                RectTransform = {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1",
                        OffsetMin = "0 -77",
                        OffsetMax = "0 -30"
                    },
                Image = {
                        Color = MainGUISettings.GUISettings.SkillBackgroundColor,
                        Sprite = "assets/content/ui/ui.background.transparent.radial.psd"
                    }
            }, $"PanelSkill_{element }", $"Description{element }");
            container.Add(new CuiLabel
            {
                RectTransform = {
                        AnchorMin = "0 0",
                        AnchorMax = "1 1"
                    },
                Text = {
                        Text = CurrentSkillSettings.Description,
                        FontSize = 15,
                        Font = "robotocondensed-regular.ttf",
                        Align = TextAnchor.MiddleCenter
                    }
            }, $"Description{element }");
            return null; //u9340

        }

        [ConsoleCommand("enableskill")]
        void Console_EnableCase(ConsoleSystem.Arg args) {
            var player = args.Player();
            var enable = EnableUI[player.userID] == true ? false : true;
            EnableUI[player.userID] = enable;
            InterfaceXP(player);
        }

        Dictionary<ulong, bool> EnableUI = new Dictionary<ulong, bool>();

        void InterfaceXP(BasePlayer player) {
            if (!EnableUI.ContainsKey(player.userID)) {
                EnableUI[player.userID] = true;
            }
            CuiHelper.DestroyUi(player, "LayerSkill_xp");
            var container = new CuiElementContainer();

            var anchormin = MainGUISettings.Enabled == true ? "44" : "16";
            var anchormax = MainGUISettings.Enabled == true ? "70" : "42.5";
            var anchor = EnableUI[player.userID] == true ? $"-430 {anchormin}" : $"-250 {anchormin}";
            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = anchor, OffsetMax = $"-210 {anchormax}" },
                Image = { Color = "0 0 0 0"}
            }, "Overlay", "LayerSkill_xp");

            var text = EnableUI[player.userID] == true ? ">" : "<";
            var anchortext = EnableUI[player.userID] == true ? "0.2 1" : "0.3 1";
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = anchortext, OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Command = "enableskill" },
                Text = { Text = text, Color = "1 1 1 0.7", Align = TextAnchor.MiddleCenter, FontSize = 16, Font = "robotocondensed-regular.ttf" }
            }, "LayerSkill_xp");

            var anchorblock = EnableUI[player.userID] == true ? "0.15 0" : "0.3 0";
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = anchorblock, AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Color = "1 1 1 0.15"}
            }, "LayerSkill_xp", "Image");

            var anchorimage = EnableUI[player.userID] == true ? "0.15 1" : "1 1";
            container.Add(new CuiElement
            {
                Parent = "Image",
                Components =
                    {
                        new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", "imageskillxp"), Color = "1 1 1 0.6" },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = anchorimage, OffsetMin = "6 6", OffsetMax = "-6 -6" }
                    }
            });

            if (EnableUI[player.userID]) {
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = "0.16 0.15", AnchorMax = $"1 0.85", OffsetMax = "-4 0" },
                    Image = { Color = "0 0 0 0"}
                }, "Image", "Progress");
                
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = $"{(float)PlayersSkillParameters[player.userID].countXP / 100} 1", OffsetMax = "0 0" },
                    Image = { Color = "0.29 0.50 0.80 0.9"}
                }, "Progress");

                container.Add(new CuiLabel
                {  
                    RectTransform = { AnchorMin = "0.18 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                    Text = { Text = $"{PlayersSkillParameters[player.userID].countXP}%", Color = "1 1 1 1", Align = TextAnchor.MiddleLeft, FontSize = 14, Font = "robotocondensed-regular.ttf" }
                }, "Image");

                container.Add(new CuiLabel
                {  
                    RectTransform = { AnchorMin = "0.35 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                    Text = { Text = $"({PlayersSkillParameters[player.userID].countDNK}) Очки прокачки", Color = "1 1 1 0.7", Align = TextAnchor.MiddleLeft, FontSize = 8, Font = "robotocondensed-regular.ttf" }
                }, "Image");
            }

            CuiHelper.AddUi(player, container);
        }


        #endregion GUI

        #region COMMANDS

        //Функция с ImageLibrary
        Plugin ImageLibrary => Interface.Oxide.RootPluginManager.GetPlugin("ImageLibrary");
        public bool AddImage(string url, string shortname, ulong skin = 0) => (bool)ImageLibrary?.Call("AddImage", url, shortname, skin);
        public string GetImage(string Name, ulong l = 0) => (string)ImageLibrary?.Call("GetImage", Name, l);

        [PluginReference] private Plugin TPCases;


        //Конвертация цвета HEX
        private static string getHEXColor(string colorValue)
        {
            if (string.IsNullOrEmpty(colorValue))
            {
                colorValue = "#FFFFFFFF";
            }
            var trimedColor = colorValue.Trim('#');
            if (trimedColor.Length == 6) trimedColor += "FF";
            if (trimedColor.Length != 8)
            {
                throw new Exception(colorValue);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }
            var RedValue = byte.Parse(trimedColor.Substring(0, 2), NumberStyles.HexNumber);
            var GreenValue = byte.Parse(trimedColor.Substring(2, 2), NumberStyles.HexNumber);
            var BlueValue = byte.Parse(trimedColor.Substring(4, 2), NumberStyles.HexNumber);
            var OpacityValue = byte.Parse(trimedColor.Substring(6, 2), NumberStyles.HexNumber);
            UnityEngine.Color UColor = new Color32(RedValue, GreenValue, BlueValue, OpacityValue);
            return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", UColor.r, UColor.g, UColor.b, UColor.a);
        }

        //УВЕЛИЧЕНИЕ УРОВНЯ (НАЖАТИЕ НА ПЛЮС)        

        [ConsoleCommand("plussbtn")]
        void cmdPlusBtnPress(ConsoleSystem.Arg Argum)
        {
            BasePlayer player = Argum.Player();
            int element = Convert.ToInt32(Argum.Args[0]);
            cmdPlusLevel(player, element);
        }

        public void cmdPlusLevel(BasePlayer player, int element)
        {
            var CurrentSkillSettings = MainGUISettings.configSkillSettings[element];
            var CurrentPlayerSkillData = PlayersSkillDataMassiv[player.userID][element];
            var CurrentParam = PlayersSkillParameters[player.userID];
            if (CurrentParam.countDNK >= 1)
            {
                //Проверка потолка
                if (CurrentPlayerSkillData.Level >= CurrentSkillSettings.MaxLevel) return;
                //Увеличиваем уровень
                CurrentPlayerSkillData.Level++;
                //Расчитываем рейты
                CurrentPlayerSkillData.Rate += CurrentSkillSettings.PercentIncrement;

                if (CurrentSkillSettings.HPIncrementInRate > 0) CurrentPlayerSkillData.HPIncrementInRate = CurrentSkillSettings.HPIncrementInRate;
                if (CurrentSkillSettings.MaxProtection > 0) CurrentPlayerSkillData.MaxProtection = CurrentSkillSettings.MaxProtection;
                if (CurrentSkillSettings.MaxRegen > 0) CurrentPlayerSkillData.MaxRegen = CurrentSkillSettings.MaxRegen;
                if (CurrentSkillSettings.MaxAtack > 0) CurrentPlayerSkillData.MaxAtack = CurrentSkillSettings.MaxAtack;
                for (int a = 0; a < CurrentSkillSettings.ShortnameList.Count; a++)
                    if (CurrentPlayerSkillData.ShortnameList == null || !CurrentPlayerSkillData.ShortnameList.Contains(CurrentSkillSettings.ShortnameList[a])) CurrentPlayerSkillData.ShortnameList.Add(CurrentSkillSettings.ShortnameList[a]);
                CurrentParam.countDNK -= 1;
                Log("log", $"{player.displayName} потратил очко ДНК на улучшение {CurrentPlayerSkillData.Name}. Уровень способности {CurrentPlayerSkillData.Level}");
                CuiElementContainer container = new CuiElementContainer();
                ShowMainUI(player);
                CuiHelper.AddUi(player, container);
            }
        }

        [ConsoleCommand("skillpoint")]
        void GiveSkillPointConsoleCommand(ConsoleSystem.Arg arg)
        {
			var cplayer = arg?.Player();
			if (cplayer!=null) {
				if (!cplayer.IsAdmin)
				{
					SendReply(cplayer, "Команда доступна только администраторам");
					return;
				}
			}
            if (arg == null || arg.FullString.Length == 0)
            {
                PrintError("Не указаны параметры для выполнения команды skillpoint");
                return;
            }
		    BasePlayer player = BasePlayer.Find(arg.Args[0]);
		    if (player == null)
		    {
			    PrintError($"[Ошибка] Не удается найти игрока {arg.Args[0]}");
			    return;
		    }
			if (!PlayersSkillParameters.ContainsKey(player.userID)) return;
			int count=1;
			if (arg.Args.Length == 2) if (!int.TryParse(arg.Args[1], out count)){ 
				count = 1;
		    }
			//Получаем данные по игроку
			var CurrentParam = PlayersSkillParameters[player.userID];
			CurrentParam.countDNK += count;
			Puts($"{count} skillpoint gived to {player}");
			Log("log", $"{player.displayName} получил очки ДНК в количестве {count}");
			SendReply(player,$"Вы получили очки ДНК: {count}");
			
        }
        //ПРИ НАЖАТИИ НА МИНУС
        [ConsoleCommand("minusbtn")]
        void cmdMinusBtnPress(ConsoleSystem.Arg Argum)
        {
            BasePlayer player = Argum.Player();
            int element = Convert.ToInt32(Argum.Args[0]);
            cmdMinusLevel(player, element);
        }

        public void cmdMinusLevel(BasePlayer player, int element)
        {
            var CurrentSkillSettings = MainGUISettings.configSkillSettings[element];
            var CurrentPlayerSkillData = PlayersSkillDataMassiv[player.userID][element];
            var CurrentParam = PlayersSkillParameters[player.userID];
            if (CurrentPlayerSkillData.Level <= 0) return;
            CurrentPlayerSkillData.Level--;
            if (CurrentPlayerSkillData.Level == 0)
                for (int a = 0; a < CurrentSkillSettings.ShortnameList.Count; a++)
                    if (CurrentPlayerSkillData.ShortnameList.Contains(CurrentSkillSettings.ShortnameList[a]))
                    {
                        CurrentPlayerSkillData.ShortnameList.Remove(CurrentSkillSettings.ShortnameList[a]);
                        CurrentPlayerSkillData.HPIncrementInRate = 0;
                        CurrentPlayerSkillData.MaxProtection = 0;
                        CurrentPlayerSkillData.MaxAtack = 0;
                        CurrentPlayerSkillData.MaxRegen = 0;
                    }
            float DNKRefuse = (float)0.01 * (float)CurrentSkillSettings.ReturnPercent;
            CurrentPlayerSkillData.Rate -= CurrentSkillSettings.PercentIncrement;
            CurrentParam.countDNK += DNKRefuse;
            Log("log", $"{player.displayName} откатил навык {CurrentPlayerSkillData.Name} и вернул {DNKRefuse} ДНК на улучшение. Уровень способности {CurrentPlayerSkillData.Level}");
            CuiElementContainer container = new CuiElementContainer();
            ShowMainUI(player);
            CuiHelper.AddUi(player, container);
        }

        //РАЗВЕРНУТЬ ОПИСАНИЕ
        [ConsoleCommand("opendescription")]
        void cmdOpenDescription(ConsoleSystem.Arg Args)
        {
            BasePlayer player = Args.Player();
            DescriptionUi(player, Convert.ToInt32(Args.Args[0]));
        }

        //ПОКАЗАТЬ ГЛАВНОЕ ОКНО ПРОКАЧКИ
        [ConsoleCommand("open_dnk_system")]
        void cmdOpenDNKPanel(ConsoleSystem.Arg Argum)
        {
            ShowMainUI(Argum.Player());
        }


        #endregion COMMAND		

        void Log(string filename, string text) => LogToFile(filename, $"[{DateTime.Now}] {text}", this);
    }
}

// --- End of file: TPSkillSystem.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TankCommander.cs ---
// --- Original Local Path: TankCommander.cs ---

﻿using System;
using System.Collections.Generic;
using UnityEngine;
using System.Linq;
using System.Globalization;
using Rust;
using Facepunch;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;

namespace Oxide.Plugins
{
    [Info("Tank Commander", "k1lly0u", "0.2.3")]
    [Description("Drive tanks, shoot stuff")]
    class TankCommander : RustPlugin
    {
        #region Fields
        [PluginReference]
        private Plugin Friends, Clans, Godmode;
       
        private static TankCommander ins;

        private List<APCController> controllers = new List<APCController>();
        
        private Dictionary<CommandType, BUTTON> controlButtons;

        private int rocketId;
        private int mgId;

        private const string APC_PREFAB = "assets/prefabs/npc/m2bradley/bradleyapc.prefab";
        private const string CHAIR_PREFAB = "assets/prefabs/vehicle/seats/miniheliseat.prefab";
        private const string UI_HEALTH = "TCUI_Health";
        private const string UI_AMMO_MG = "TCUI_Ammo_MG";
        private const string UI_AMMO_ROCKET = "TCUI_Ammo_Rocket";

        private const int TARGET_LAYERS = ~(1 << 10 | 1 << 13 | 1 << 17 | 1 << 18 | 1 << 20 | 1 << 28 | 1 << 29);
        #endregion

        #region Oxide Hooks
        private void Loaded()
        {
            lang.RegisterMessages(Messages, this);
            permission.RegisterPermission("tankcommander.admin", this);
            permission.RegisterPermission("tankcommander.use", this);
        }

        private void OnServerInitialized()
        {
            ins = this;

            ConvertControlButtons();

            rocketId = ItemManager.itemList.Find(x => x.shortname == configData.Weapons.Cannon.Type)?.itemid ?? 0;
            mgId = ItemManager.itemList.Find(x => x.shortname == configData.Weapons.MG.Type)?.itemid ?? 0;
        }

        private object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (entity is BradleyAPC)
            {
                APCController controller = entity.GetComponent<APCController>();
                if (controller != null)
                {
                    controller.ManageDamage(info);
                    return null;
                }
            }

            if (entity is BasePlayer)
            {
                if (IsOnboardAPC(entity as BasePlayer))
                    return true;

                if (info.Initiator is BradleyAPC)
                {
                    APCController controller = (info.Initiator as BradleyAPC).GetComponent<APCController>();
                    if (controller != null)
                    {
                        if (!controller.HasCommander)
                            return true;
                    }
                }
            }
            else if (entity is BaseMountable)
            {
                if (entity.GetComponentInParent<APCController>())
                    return true;
            }

            return null;
        }

        private void OnPlayerInput(BasePlayer player, InputState input)
        {
            if (player == null || IsOnboardAPC(player) || !HasPermission(player, "tankcommander.use"))
                return;

            if (configData.Inventory.Enabled && input.WasJustPressed(controlButtons[CommandType.Inventory]))
            {
                RaycastHit hit;
                if (Physics.SphereCast(player.eyes.position, 0.5f, Quaternion.Euler(player.serverInput.current.aimAngles) * Vector3.forward, out hit, 3f))
                {
                    APCController controller = hit.GetEntity()?.GetComponent<APCController>();
                    if (controller != null && !controller.HasCommander)
                        OpenTankInventory(player, controller);
                }
                return;
            }

            if (input.WasJustPressed(controlButtons[CommandType.EnterExit]))
            {
                RaycastHit hit;
                if (Physics.SphereCast(player.eyes.position, 0.5f, Quaternion.Euler(player.serverInput.current.aimAngles) * Vector3.forward, out hit, 3f))
                {
                    APCController controller = hit.GetEntity()?.GetComponent<APCController>();
                    if (controller != null)
                    {                        
                        if (!controller.HasCommander)
                        {
                            controller.MountPlayer(player);
                        }
                        else
                        {
                            if (configData.Passengers.Enabled && controller.CanMountPlayer())
                            {
                                BasePlayer commander = controller.Commander;

                                if (!configData.Passengers.UseFriends && !configData.Passengers.UseClans)
                                {
                                    controller.MountPlayer(player);
                                    return;
                                }

                                if (configData.Passengers.UseFriends && AreFriends(commander.userID, player.userID))
                                {
                                    controller.MountPlayer(player);
                                    return;
                                }

                                if (configData.Passengers.UseClans && IsClanmate(commander.userID, player.userID))
                                {
                                    controller.MountPlayer(player);
                                    return;
                                }

                                player.ChatMessage(msg("not_friend", player.UserIDString));
                            }
                            else player.ChatMessage(msg("in_use", player.UserIDString));
                        }
                    }
                }
            }
        }

        private object CanDismountEntity(BasePlayer player, BaseMountable mountable)
        {
            APCController controller = mountable?.GetComponentInParent<APCController>();
            if (controller != null)
            {
                controller.DismountPlayer(player);
                return false;
            }

            return null;
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            APCController controller;
            if (IsOnboardAPC(player, out controller))
            {
                controller.DismountPlayer(player);
            }
        }

        private object OnRunPlayerMetabolism(PlayerMetabolism metabolism, BaseCombatEntity entity)
        {
            BasePlayer player = entity.ToPlayer();
            if (player == null || !IsOnboardAPC(player))
                return null;

            if (Godmode && (bool)Godmode.Call("IsGod", player.UserIDString))
                return null;

            return true;
        }

        private void Unload()
        {
            foreach (APCController controller in controllers)
                UnityEngine.Object.Destroy(controller);

            APCController[] objects = UnityEngine.Object.FindObjectsOfType<APCController>();
            if (objects != null)
            {
                foreach(APCController obj in objects)
                    UnityEngine.Object.Destroy(obj);
            }

            controllers.Clear();

            configData = null;
            ins = null;
        }
        #endregion

        #region Functions
        private bool IsOnboardAPC(BasePlayer player) => player?.GetMounted()?.GetComponentInParent<APCController>() != null;

        private bool IsOnboardAPC(BasePlayer player, out APCController controller)
        {
            controller = player?.GetMounted()?.GetComponentInParent<APCController>();
            return controller != null;
        }

        private T ParseType<T>(string type) => (T)Enum.Parse(typeof(T), type, true);

        private bool HasPermission(BasePlayer player, string perm) => permission.UserHasPermission(player.UserIDString, perm) || permission.UserHasPermission(player.UserIDString, "tankcommander.admin");

        private void ConvertControlButtons()
        {
            controlButtons = new Dictionary<CommandType, BUTTON>
            {
                [CommandType.EnterExit] = ParseType<BUTTON>(configData.Buttons.Enter),
                [CommandType.Lights] = ParseType<BUTTON>(configData.Buttons.Lights),
                [CommandType.Inventory] = ParseType<BUTTON>(configData.Buttons.Inventory),
                [CommandType.Boost] = ParseType<BUTTON>(configData.Buttons.Boost),
                [CommandType.Cannon] = ParseType<BUTTON>(configData.Buttons.Cannon),
                [CommandType.Coax] = ParseType<BUTTON>(configData.Buttons.Coax),
                [CommandType.MG] = ParseType<BUTTON>(configData.Buttons.MG)
            };
        }

        private void OpenTankInventory(BasePlayer player, APCController controller)
        {
            player.inventory.loot.Clear();
            player.inventory.loot.entitySource = controller.entity;
            player.inventory.loot.itemSource = null;
            player.inventory.loot.AddContainer(controller.inventory);
            player.inventory.loot.SendImmediate();
            player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel", "generic");
            player.SendNetworkUpdate();
        }
        #endregion

        #region Component
        private enum CommandType { EnterExit, Lights, Inventory, Boost, Cannon, Coax, MG }
        
        private class APCController : MonoBehaviour
        {
            public BradleyAPC entity;
            private Rigidbody rigidBody;
            private BaseMountable[] mountables;

            private WheelCollider[] leftWheels;
            private WheelCollider[] rightWheels;

            public ItemContainer inventory;

            private float accelTimeTaken;
            private float accelTimeToTake = 3f;

            private float forwardTorque = 2000f;
            private float maxBrakeTorque = 50f;
            private float turnTorque = 2000f;

            private float lastFireCannon;
            private float lastFireMG;
            private float lastFireCoax;

            private bool isDying = false;
            private RaycastHit eyeRay;

            private Vector3 mouseInput = Vector3.zero;
            private Vector3 aimVector = Vector3.forward;
            private Vector3 aimVectorTop = Vector3.forward;

            private Dictionary<CommandType, BUTTON> controlButtons;
            private ConfigData.WeaponOptions.WeaponSystem cannon;
            private ConfigData.WeaponOptions.WeaponSystem mg;
            private ConfigData.WeaponOptions.WeaponSystem coax;
            private ConfigData.CrushableTypes crushables;

            public bool HasCommander
            {
                get
                {
                    return mountables[0].GetMounted() != null;
                }
            }

            public BasePlayer Commander { get; private set; }

            private void Awake()
            {
                entity = GetComponent<BradleyAPC>();

                entity.enabled = false;

                entity.CancelInvoke(entity.UpdateTargetList);
                entity.CancelInvoke(entity.UpdateTargetVisibilities);

                rigidBody = entity.myRigidBody;
                leftWheels = entity.leftWheels;
                rightWheels = entity.rightWheels;

                forwardTorque = configData.Movement.ForwardTorque;
                turnTorque = configData.Movement.TurnTorque;
                maxBrakeTorque = configData.Movement.BrakeTorque;
                accelTimeToTake = configData.Movement.Acceleration;

                controlButtons = ins.controlButtons;
                cannon = configData.Weapons.Cannon;
                mg = configData.Weapons.MG;
                coax = configData.Weapons.Coax;
                crushables = configData.Crushables;

                if (configData.Inventory.Enabled)
                {
                    inventory = new ItemContainer();
                    inventory.ServerInitialize(null, configData.Inventory.Size);
                    if (!inventory.uid.IsValid)
                        inventory.GiveUID();
                }
                
                CreateMountPoints();
                SetInitialAimDirection();
            }

            private void OnDestroy()
            {
                DismountAll();

                for (int i = 0; i < mountables.Length; i++)
                {
                    BaseMountable mountable = mountables[i];
                    if (mountable != null && !mountable.IsDestroyed)
                        mountable.Kill();
                }                

                if (entity != null && !entity.IsDestroyed)
                    entity.Kill();
            }

            private void Update()
            {
                if (Commander != null)
                {                   
                    DoMovementControls();
                    AdjustAiming();
                    DoWeaponControls();

                    entity.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                }
            }

            private void LateUpdate()
            {
                mouseInput = Commander?.serverInput?.current?.mouseDelta ?? Vector2.zero;
            }

            private void OnCollisionEnter(Collision collision)
            {
                if (!HasCommander) return;

                GameObject gObject = collision.gameObject;
                if (gObject == null)
                    return;

                if (crushables.Players)
                {
                    BasePlayer triggerPlayer = gObject.GetComponentInParent<BasePlayer>();
                    if (triggerPlayer != null && !IsPassenger(triggerPlayer))
                    {
                        triggerPlayer.Die(new HitInfo(Commander, triggerPlayer, DamageType.Blunt, 200f));
                        return;
                    }
                }

                if (crushables.Animals)
                {
                    BaseNpc npc = gObject.GetComponentInParent<BaseNpc>();
                    if (npc != null)
                    {
                        npc.Die(new HitInfo(Commander, npc, DamageType.Blunt, 200f));
                        return;
                    }
                }

                float impactForce = CalculateImpactForce(collision);

                if (crushables.Buildings)
                {
                    BuildingBlock buildingBlock = gObject.GetComponentInParent<BuildingBlock>();
                    if (buildingBlock != null && impactForce >= crushables.GradeForce[buildingBlock.grade.ToString()])
                    {
                        buildingBlock.Die(new HitInfo(Commander, buildingBlock, DamageType.Blunt, 1000f));
                        return;
                    }

                    SimpleBuildingBlock simpleBlock = gObject.GetComponentInParent<SimpleBuildingBlock>();
                    if (simpleBlock != null && impactForce >= crushables.WallForce)
                    {
                        simpleBlock.Die(new HitInfo(Commander, simpleBlock, DamageType.Blunt, 1500));
                        return;
                    }
                }

                if (crushables.Loot)
                {
                    LootContainer loot = gObject.GetComponentInParent<LootContainer>();
                    if (loot != null)
                    {
                        loot.Die(new HitInfo(Commander, loot, DamageType.Blunt, 200f));
                        return;
                    }
                }

                if (crushables.Resources)
                {
                    ResourceEntity resource = gObject.GetComponentInParent<ResourceEntity>();
                    if (resource != null && impactForce >= crushables.ResourceForce)
                    {
                        resource.Kill(BaseNetworkable.DestroyMode.None);
                        return;
                    }
                }
            }

            private float CalculateImpactForce(Collision col)
            {
                float impactVelocityX = rigidBody.velocity.x;
                impactVelocityX *= Mathf.Sign(impactVelocityX);

                float impactVelocityY = rigidBody.velocity.y;
                impactVelocityY *= Mathf.Sign(impactVelocityY);

                float impactVelocity = impactVelocityX + impactVelocityY;
                float impactForce = impactVelocity * rigidBody.mass;
                impactForce *= Mathf.Sign(impactForce);

                return impactForce;
            }

            private bool IsPassenger(BasePlayer player)
            {
                BaseMountable mountable = player.GetMounted();
                if (mountable == null)
                    return false;

                return mountables.Contains(mountable);
            }

            #region Mounting
            private List<KeyValuePair<Vector3, Vector3>> mountOffsets = new List<KeyValuePair<Vector3, Vector3>>()
            {
                new KeyValuePair<Vector3, Vector3>(new Vector3(0.6f, 1.9f, -0.6f), Vector3.zero),
                new KeyValuePair<Vector3, Vector3>(new Vector3(-0.6f, 0.4f, -1.3f), new Vector3(0f, 90f, 0f)),
                new KeyValuePair<Vector3, Vector3>(new Vector3(-0.6f, 0.4f, -2f), new Vector3(0f, 90f, 0f)),
                new KeyValuePair<Vector3, Vector3>(new Vector3(0.5f, 0.4f, -1.3f), new Vector3(0f, -90f, 0f)),
                new KeyValuePair<Vector3, Vector3>(new Vector3(0.5f, 0.4f, -2f), new Vector3(0f, -90f, 0f)),
            };

            private void CreateMountPoints()
            {
                int passengers = Mathf.Clamp(configData.Passengers.Max, 0, 4) + 1;
                mountables = new BaseMountable[passengers];

                for (int i = 0; i < passengers; i++)
                {
                    CreateMountPoint(i);
                }
            }

            private void CreateMountPoint(int index)
            {
                KeyValuePair<Vector3, Vector3> offset = mountOffsets[index];

                BaseMountable mountable = GameManager.server.CreateEntity(CHAIR_PREFAB, entity.transform.position) as BaseMountable;
                mountable.enableSaving = false;                
                mountable.Spawn();

                Destroy(mountable.GetComponent<DestroyOnGroundMissing>());
                Destroy(mountable.GetComponent<GroundWatch>());

                mountable.SetParent(entity, index == 0 ? (uint)4239370974 : (uint)0, false, true);
                mountable.transform.localPosition = offset.Key;
                mountable.transform.localRotation = Quaternion.Euler(offset.Value);
                
                GameObject tr = new GameObject("Seat Transform");
                tr.transform.SetParent(mountable.transform);
                tr.transform.localPosition = index > 0 ? new Vector3(0, 0, -3f) : new Vector3(3f, 0, 0);

                mountable.dismountPositions = new Transform[] { tr.transform };

                mountables[index] = mountable;
            }

            public bool CanMountPlayer()
            {
                for (int i = 0; i < mountables.Length; i++)
                {
                    BaseMountable mountable = mountables[i];
                    if (!mountable.IsMounted())
                        return true;
                }

                return false;
            }

            public void MountPlayer(BasePlayer player)
            {
                for (int i = 0; i < mountables.Length; i++)
                {                    
                    BaseMountable mountable = mountables[i];
                    if (mountable.IsMounted())
                        continue;

                    player.EnsureDismounted();
                    mountable._mounted = player;
                    player.MountObject(mountable, 0);
                    player.MovePosition(mountable.mountAnchor.transform.position);
                    player.transform.rotation = mountable.mountAnchor.transform.rotation;
                    player.ServerRotation = mountable.mountAnchor.transform.rotation;
                    player.OverrideViewAngles(mountable.mountAnchor.transform.rotation.eulerAngles);
                    player.eyes.NetworkUpdate(mountable.mountAnchor.transform.rotation);
                    player.ClientRPCPlayer(null, player, "ForcePositionTo", player.transform.position);
                    mountable.SetFlag(BaseEntity.Flags.Busy, true, false);

                    if (i > 0)
                        player.SetPlayerFlag(BasePlayer.PlayerFlags.ThirdPersonViewmode, true);

                    OnEntityMounted(player, i == 0);
                    return;
                }
            }

            public void DismountPlayer(BasePlayer player)
            {
                if (player == null)
                    return;

                BaseMountable mountable = player.GetMounted();
                if (mountable == null)
                    return;

                player.PauseFlyHackDetection(1f);

                Vector3 dismountPosition = mountable.dismountPositions[0].position;
               
                if (TerrainMeta.HeightMap.GetHeight(dismountPosition) > dismountPosition.y)
                    dismountPosition.y = TerrainMeta.HeightMap.GetHeight(dismountPosition) + 0.5f;

                player.DismountObject();
                player.transform.rotation = Quaternion.identity;
                player.MovePosition(dismountPosition);
                player.eyes.NetworkUpdate(Quaternion.identity);

                player.SetPlayerFlag(BasePlayer.PlayerFlags.ThirdPersonViewmode, false);

                player.SendNetworkUpdateImmediate(false);
                player.ClientRPCPlayer(null, player, "ForcePositionTo", dismountPosition);
                mountable._mounted = null;

                if (player == Commander)
                {
                    entity.CancelInvoke(DrawTargeting);
                    Commander = null;
                }

                DestroyAllUI(player);
            }

            private void DismountAll()
            {
                for (int i = 0; i < mountables.Length; i++)
                {
                    BasePlayer player = mountables[i].GetMounted();
                    if (player != null)
                        DismountPlayer(player);
                }

                Commander = null;
            }

            private void OnEntityMounted(BasePlayer player, bool isOperator)
            {
                if (isOperator)
                {
                    string ctrlStr = msg("controls", player.UserIDString);
                    if (configData.Weapons.Cannon.Enabled)
                        ctrlStr += $"\n{string.Format(msg("fire_cannon", player.UserIDString), configData.Buttons.Cannon)}";
                    if (configData.Weapons.Coax.Enabled)
                        ctrlStr += $"\n{string.Format(msg("fire_coax", player.UserIDString), configData.Buttons.Coax)}";
                    if (configData.Weapons.MG.Enabled)
                        ctrlStr += $"\n{string.Format(msg("fire_mg", player.UserIDString), configData.Buttons.MG)}";
                    ctrlStr += $"\n{string.Format(msg("speed_boost", player.UserIDString), configData.Buttons.Boost)}";
                    ctrlStr += $"\n{string.Format(msg("enter_exit", player.UserIDString), configData.Buttons.Enter)}";
                    ctrlStr += $"\n{string.Format(msg("toggle_lights", player.UserIDString), configData.Buttons.Lights)}";
                    if (configData.Inventory.Enabled)
                        ctrlStr += $"\n{string.Format(msg("access_inventory", player.UserIDString), configData.Buttons.Inventory)}";
                    player.ChatMessage(ctrlStr);

                    CreateHealthUI(player, this);
                    CreateMGAmmoUI(player, this);
                    CreateRocketAmmoUI(player, this);

                    Commander = player;
                    entity.InvokeRepeating(DrawTargeting, DDRAW_UPDATE_TIME, DDRAW_UPDATE_TIME);
                }
                else
                {
                    player.ChatMessage(string.Format(msg("enter_exit", player.UserIDString), configData.Buttons.Enter));
                    if (configData.Inventory.Enabled)
                        player.ChatMessage(string.Format(msg("access_inventory", player.UserIDString), configData.Buttons.Inventory));
                    CreateHealthUI(player, this);
                }
            }
            #endregion

            #region Weapons
            private void SetInitialAimDirection()
            {
                aimVector = aimVectorTop = entity.transform.forward.normalized;

                entity.AimWeaponAt(entity.mainTurret, entity.coaxPitch, aimVector, -90f, 7f, 360f, null);
                entity.AimWeaponAt(entity.mainTurret, entity.CannonPitch, aimVector, -90f, 7f, 360f, null);
                entity.AimWeaponAt(entity.topTurretYaw, entity.topTurretPitch, aimVectorTop, -360f, 360f, 360f, entity.mainTurret);

                entity.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
            }

            private void DoWeaponControls()
            {                
                if (Commander.serverInput.WasJustPressed(controlButtons[CommandType.Lights]))
                    ToggleLights();

                if (Commander.serverInput.WasJustPressed(controlButtons[CommandType.Cannon]))
                    FireCannon();

                if (Commander.serverInput.IsDown(controlButtons[CommandType.MG]) || Commander.serverInput.WasJustPressed(controlButtons[CommandType.MG]))
                    FireMG();

                if (Commander.serverInput.IsDown(controlButtons[CommandType.Coax]) || Commander.serverInput.WasJustPressed(controlButtons[CommandType.Coax]))
                    FireCoax();
            }

            private void AdjustAiming()
            {                
                if (Mathf.Abs(mouseInput.x) < 0.5f)
                    mouseInput.x = 0;

                if (Mathf.Abs(mouseInput.y) < 0.5f)
                    mouseInput.y = 0;

                if (mouseInput == Vector3.zero)
                    return;

                Vector3 direction = Quaternion.Euler(entity.mainTurret.transform.eulerAngles + (new Vector3(-mouseInput.y, mouseInput.x, 0f) * 5f)) * Vector3.forward;
                
                Ray ray = new Ray(Commander.eyes.transform.position, direction);

                Vector3 hitPoint;

                if (Physics.Raycast(ray, out eyeRay, 5000f, TARGET_LAYERS))
                    hitPoint = eyeRay.point;                
                else hitPoint = ray.GetPoint(100);
                
                Vector3 desiredAim = (hitPoint - Commander.eyes.transform.position).normalized;
                Vector3 desiredAimTop = (hitPoint - entity.topTurretEyePos.transform.position).normalized;

                aimVector = entity.turretAimVector = Vector3.Lerp(aimVector, desiredAim, Time.deltaTime * 3f);
                aimVectorTop = entity.topTurretAimVector = Vector3.Lerp(aimVectorTop, desiredAimTop, Time.deltaTime * 3f);

                entity.AimWeaponAt(entity.mainTurret, entity.coaxPitch, aimVector, -90f, 7f, 360f, null);
                entity.AimWeaponAt(entity.mainTurret, entity.CannonPitch, aimVector, -90f, 7f, 360f, null);

                entity.AimWeaponAt(entity.topTurretYaw, entity.topTurretPitch, aimVectorTop, -360f, 360f, 360f, entity.mainTurret);
            }

            private const float DDRAW_UPDATE_TIME = 0.02f;

            private void DrawTargeting()
            {
                if (!configData.Weapons.EnableCrosshair || Commander == null)
                    return;

                Vector3 start = entity.CannonMuzzle.transform.position;
                Vector3 end = Vector3.zero;                  

                RaycastHit rayHit;
                if (Physics.Raycast(start, entity.CannonMuzzle.forward, out rayHit, 300, 1219701521, QueryTriggerInteraction.Ignore))                
                    end = rayHit.point;                
                else end = start + (entity.CannonMuzzle.forward * 300);
                
                if (Commander.IsAdmin)
                {
                    Commander.SendConsoleCommand("ddraw.text", DDRAW_UPDATE_TIME + 0.01f, configData.Weapons.CrosshairColor.Color, end, $"<size={configData.Weapons.CrosshairSize}>⊕</size>");
                }
                else
                {
                    Commander.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, true);
                    Commander.SendNetworkUpdateImmediate();
                    Commander.SendConsoleCommand("ddraw.text", DDRAW_UPDATE_TIME + 0.01f, configData.Weapons.CrosshairColor.Color, end, $"<size={configData.Weapons.CrosshairSize}>⊕</size>");
                    Commander.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, false);
                }            
            }

            private void FireCannon()
            {
                if (cannon.RequireAmmo)
                {
                    if (inventory.itemList.Find(x => x.info.shortname == cannon.Type) == null)
                    {
                        if (ItemManager.itemDictionaryByName.ContainsKey(cannon.Type))
                            Commander.ChatMessage(string.Format(msg("no_ammo_cannon", Commander.UserIDString), ItemManager.itemDictionaryByName[cannon.Type].displayName.english));
                        else print($"Invalid ammo type for the cannon set in config: {cannon.Type}");
                        return;
                    }
                }
                if (Time.realtimeSinceStartup >= lastFireCannon)
                {
                    Vector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(cannon.Accuracy, entity.CannonMuzzle.rotation * Vector3.forward, true);
                    Vector3 cannonPitch = (entity.CannonPitch.transform.rotation * Vector3.back) + (entity.transform.up * -1f);

                    entity.myRigidBody.AddForceAtPosition(cannonPitch.normalized * entity.recoilScale, entity.CannonPitch.transform.position, ForceMode.Impulse);

                    Effect.server.Run(entity.mainCannonMuzzleFlash.resourcePath, entity, StringPool.Get(entity.CannonMuzzle.gameObject.name), Vector3.zero, Vector3.zero, null, false);

                    BaseEntity rocket = GameManager.server.CreateEntity(entity.mainCannonProjectile.resourcePath, entity.CannonMuzzle.transform.position, Quaternion.LookRotation(modifiedAimConeDirection), true);
                    ServerProjectile projectile = rocket.GetComponent<ServerProjectile>();
                    projectile.InitializeVelocity(modifiedAimConeDirection.normalized * projectile.speed);
                    rocket.Spawn();

                    TimedExplosive explosive = rocket.GetComponent<TimedExplosive>();
                    if (explosive != null)
                        explosive.damageTypes.Add(new DamageTypeEntry { amount = cannon.Damage, type = DamageType.Explosion });

                    lastFireCannon = Time.realtimeSinceStartup + cannon.Interval;

                    if (cannon.RequireAmmo)
                        inventory.itemList.Find(x => x.info.shortname == cannon.Type)?.UseItem(1);
                    CreateRocketAmmoUI(Commander, this);
                }
            }

            private void FireCoax()
            {
                if (coax.RequireAmmo)
                {
                    if (inventory.itemList.Find(x => x.info.shortname == coax.Type) == null)
                    {
                        if (ItemManager.itemDictionaryByName.ContainsKey(coax.Type))
                            Commander.ChatMessage(string.Format(msg("no_ammo_coax", Commander.UserIDString), ItemManager.itemDictionaryByName[coax.Type].displayName.english));
                        else print($"Invalid ammo type for the coaxial gun set in config: {coax.Type}");
                        return;
                    }
                }
                if (Time.realtimeSinceStartup >= lastFireCoax)
                {
                    Vector3 vector3 = entity.coaxMuzzle.transform.position - (entity.coaxMuzzle.forward * 0.25f);

                    Vector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(coax.Accuracy, entity.coaxMuzzle.transform.forward, true);
                    Vector3 targetPos = vector3 + (modifiedAimConeDirection * 300f);

                    List<RaycastHit> list = Pool.GetList<RaycastHit>();
                    GamePhysics.TraceAll(new Ray(vector3, modifiedAimConeDirection), 0f, list, 300f, 1219701521, QueryTriggerInteraction.UseGlobal);
                    for (int i = 0; i < list.Count; i++)
                    {
                        RaycastHit hit = list[i];
                        BaseEntity hitEntity = hit.GetEntity();
                        if (hitEntity != null && hitEntity != this.entity)
                        {
                            BaseCombatEntity baseCombatEntity = hitEntity as BaseCombatEntity;
                            if (baseCombatEntity != null)
                                ApplyDamage(baseCombatEntity, coax.Damage, hit.point, modifiedAimConeDirection);

                            if (hitEntity.ShouldBlockProjectiles())
                            {
                                targetPos = hit.point;
                                break;
                            }
                        }
                    }

                    entity.ClientRPC(null, "CLIENT_FireGun", true, targetPos);
                    Pool.FreeList<RaycastHit>(ref list);

                    lastFireCoax = Time.realtimeSinceStartup + coax.Interval;

                    if (coax.RequireAmmo)
                        inventory.itemList.Find(x => x.info.shortname == coax.Type)?.UseItem(1);
                    CreateMGAmmoUI(Commander, this);
                }
            }

            private void FireMG()
            {
                if (mg.RequireAmmo)
                {
                    if (inventory.itemList.Find(x => x.info.shortname == mg.Type) == null)
                    {
                        if (ItemManager.itemDictionaryByName.ContainsKey(mg.Type))
                            Commander.ChatMessage(string.Format(msg("no_ammo_mg", Commander.UserIDString), ItemManager.itemDictionaryByName[mg.Type].displayName.english));
                        else print($"Invalid ammo type for the machine gun set in config: {mg.Type}");
                        return;
                    }
                }
                if (Time.realtimeSinceStartup >= lastFireMG)
                {
                    Vector3 firePosition = entity.topTurretMuzzle.transform.position - (entity.topTurretMuzzle.forward * 0.25f);

                    Vector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(mg.Accuracy, entity.topTurretMuzzle.transform.forward, true);
                    Vector3 targetPos = firePosition + modifiedAimConeDirection;

                    List<RaycastHit> list = Pool.GetList<RaycastHit>();
                    GamePhysics.TraceAll(new Ray(firePosition, modifiedAimConeDirection), 0f, list, 300f, 1219701521, QueryTriggerInteraction.UseGlobal);
                    for (int i = 0; i < list.Count; i++)
                    {
                        RaycastHit hit = list[i];
                        BaseEntity hitEntity = hit.GetEntity();
                        if (hitEntity != null && !hitEntity == this.entity)
                        {
                            BaseCombatEntity baseCombatEntity = hitEntity as BaseCombatEntity;
                            if (baseCombatEntity != null)
                                ApplyDamage(baseCombatEntity, mg.Damage, hit.point, modifiedAimConeDirection);

                            if (hitEntity.ShouldBlockProjectiles())
                            {
                                targetPos = hit.point;
                                break;
                            }
                        }
                    }

                    entity.ClientRPC(null, "CLIENT_FireGun", false, targetPos);
                    Pool.FreeList<RaycastHit>(ref list);

                    lastFireMG = Time.realtimeSinceStartup + mg.Interval;

                    if (mg.RequireAmmo)
                        inventory.itemList.Find(x => x.info.shortname == mg.Type)?.UseItem(1);
                    CreateMGAmmoUI(Commander, this);
                }
            }

            private void FireSideGuns()
            {

            }

            private void ApplyDamage(BaseCombatEntity hitEntity, float damage, Vector3 point, Vector3 normal)
            {
                float single = damage * UnityEngine.Random.Range(0.9f, 1.1f);
                hitEntity.OnAttacked(new HitInfo(this.entity, hitEntity, DamageType.Bullet, single, point));
                if (hitEntity is BasePlayer || hitEntity is BaseNpc)
                {
                    HitInfo hitInfo = new HitInfo()
                    {
                        HitPositionWorld = point,
                        HitNormalWorld = -normal,
                        HitMaterial = StringPool.Get("Flesh")
                    };
                    Effect.server.ImpactEffect(hitInfo);
                }
            }
            #endregion

            #region Movement
            private void DoMovementControls()
            {
                float accelerate = Commander.serverInput.IsDown(BUTTON.FORWARD) ? 1f : Commander.serverInput.IsDown(BUTTON.BACKWARD) ? -1f : 0f;
                float steer = Commander.serverInput.IsDown(BUTTON.RIGHT) ? 1f : Commander.serverInput.IsDown(BUTTON.LEFT) ? -1f : 0f;

                bool boost = Commander.serverInput.IsDown(controlButtons[CommandType.Boost]);

                SetThrottleSpeed(accelerate, steer, boost);
            }

            private void SetThrottleSpeed(float acceleration, float steering, bool boost)
            {
                if (acceleration == 0 && steering == 0)
                {
                    ApplyBrakes(0.5f);

                    if (accelTimeTaken > 0)
                        accelTimeTaken = Mathf.Clamp(accelTimeTaken -= (Time.deltaTime * 2), 0, accelTimeToTake);
                }
                else
                {
                    ApplyBrakes(0f);

                    accelTimeTaken += Time.deltaTime;
                    float engineRpm = Mathf.InverseLerp(0f, accelTimeToTake, accelTimeTaken);

                    float throttle = Mathf.InverseLerp(0f, 1f, engineRpm);

                    float leftTrack = 0;
                    float rightTrack = 0;
                    float torque = 0;

                    if (acceleration > 0)
                    {
                        torque = forwardTorque;
                        leftTrack = 1f;
                        rightTrack = 1f;
                    }
                    else if (acceleration < 0)
                    {
                        torque = forwardTorque;
                        leftTrack = -1f;
                        rightTrack = -1f;
                    }
                    if (steering > 0)
                    {
                        if (acceleration == 0)
                        {
                            torque = turnTorque;
                            leftTrack = 1f;
                            rightTrack = -1f;
                        }
                        else
                        {
                            torque = (forwardTorque + turnTorque) * 0.75f;
                            rightTrack *= 0.5f;
                        }
                    }
                    else if (steering < 0)
                    {
                        if (acceleration == 0)
                        {
                            torque = turnTorque;
                            leftTrack = -1f;
                            rightTrack = 1f;
                        }
                        else
                        {
                            torque = (forwardTorque + turnTorque) * 0.75f;
                            leftTrack *= 0.5f;
                        }
                    }

                    if (boost)
                    {
                        if (torque > 0)
                            torque += configData.Movement.BoostTorque;
                        if (torque < 0)
                            torque -= configData.Movement.BoostTorque;
                    }

                    float sidewaysVelocity = Mathf.InverseLerp(5f, 1.5f, rigidBody.velocity.magnitude * Mathf.Abs(Vector3.Dot(rigidBody.velocity.normalized, entity.transform.forward)));
                    entity.ScaleSidewaysFriction(1f - sidewaysVelocity);

                    ApplyMotorTorque(Mathf.Clamp(leftTrack * throttle, -1f, 1f) * torque, false);
                    ApplyMotorTorque(Mathf.Clamp(rightTrack * throttle, -1f, 1f) * torque, true);
                }
            }

            private void ApplyBrakes(float amount)
            {
                amount = Mathf.Clamp(maxBrakeTorque * amount, 0, maxBrakeTorque);
                ApplyBrakeTorque(amount, true);
                ApplyBrakeTorque(amount, false);
            }

            private void ApplyBrakeTorque(float amount, bool rightSide)
            {
                WheelCollider[] wheelColliderArray = (!rightSide ? leftWheels : rightWheels);

                for (int i = 0; i < wheelColliderArray.Length; i++)
                    wheelColliderArray[i].brakeTorque = maxBrakeTorque * amount;
            }

            private void ApplyMotorTorque(float torque, bool rightSide)
            {
                WheelCollider[] wheelColliderArray = (!rightSide ? leftWheels : rightWheels);

                for (int i = 0; i < wheelColliderArray.Length; i++)
                    wheelColliderArray[i].motorTorque = torque;
            }
            #endregion
            
            private void ToggleLights() => entity.SetFlag(BaseEntity.Flags.Reserved5, !entity.HasFlag(BaseEntity.Flags.Reserved5), false);

            public void ManageDamage(HitInfo info)
            {
                if (isDying)
                    return;

                if (info.damageTypes.Total() >= entity.health)
                {
                    info.damageTypes = new DamageTypeList();
                    info.HitEntity = null;
                    info.HitMaterial = 0;
                    info.PointStart = Vector3.zero;

                    OnDeath();
                }
                else
                {
                    ins.NextTick(() =>
                    {
                        if (Commander != null)
                            CreateHealthUI(Commander, this);

                        for (int i = 1; i < mountables.Length; i++)
                        {
                            BasePlayer player = mountables[i]?.GetMounted();
                            if (player != null)
                                CreateHealthUI(player, this);
                        }
                    });
                }
            }

            private void OnDeath()
            {
                isDying = true;

                DismountAll();

                Effect.server.Run(entity.explosionEffect.resourcePath, entity.transform.position, Vector3.up, null, true);

                List<ServerGib> serverGibs = ServerGib.CreateGibs(entity.servergibs.resourcePath, entity.gameObject, entity.servergibs.Get().GetComponent<ServerGib>()._gibSource, Vector3.zero, 3f);
                for (int i = 0; i < 12 - entity.maxCratesToSpawn; i++)
                {
                    BaseEntity fireBall = GameManager.server.CreateEntity(entity.fireBall.resourcePath, entity.transform.position, entity.transform.rotation, true);
                    if (fireBall)
                    {
                        Vector3 onSphere = UnityEngine.Random.onUnitSphere;
                        fireBall.transform.position = (entity.transform.position + new Vector3(0f, 1.5f, 0f)) + (onSphere * UnityEngine.Random.Range(-4f, 4f));
                        Collider collider = fireBall.GetComponent<Collider>();
                        fireBall.Spawn();
                        fireBall.SetVelocity(Vector3.zero + (onSphere * UnityEngine.Random.Range(3, 10)));
                        foreach (ServerGib serverGib in serverGibs)
                            Physics.IgnoreCollision(collider, serverGib.GetCollider(), true);
                    }
                }

                if (configData.Inventory.DropInv)
                {
                    inventory.Drop("assets/prefabs/misc/item drop/item_drop.prefab", (entity.transform.position + new Vector3(0f, 1.5f, 0f)) + (UnityEngine.Random.onUnitSphere * UnityEngine.Random.Range(2f, 3f)), Quaternion.identity, 0f);
                }

                if (configData.Inventory.DropLoot)
                {
                    for (int j = 0; j < entity.maxCratesToSpawn; j++)
                    {
                        Vector3 onSphere = UnityEngine.Random.onUnitSphere;
                        BaseEntity lootCrate = GameManager.server.CreateEntity(entity.crateToDrop.resourcePath, (entity.transform.position + new Vector3(0f, 1.5f, 0f)) + (onSphere * UnityEngine.Random.Range(2f, 3f)), Quaternion.LookRotation(onSphere), true);
                        lootCrate.Spawn();

                        LootContainer lootContainer = lootCrate as LootContainer;
                        if (lootContainer)
                            lootContainer.Invoke(new Action(lootContainer.RemoveMe), 1800f);

                        Collider collider = lootCrate.GetComponent<Collider>();
                        Rigidbody rigidbody = lootCrate.gameObject.AddComponent<Rigidbody>();
                        rigidbody.useGravity = true;
                        rigidbody.collisionDetectionMode = CollisionDetectionMode.ContinuousDynamic;
                        rigidbody.mass = 2f;
                        rigidbody.interpolation = RigidbodyInterpolation.Interpolate;
                        rigidbody.velocity = Vector3.zero + (onSphere * UnityEngine.Random.Range(1f, 3f));
                        rigidbody.angularVelocity = Vector3Ex.Range(-1.75f, 1.75f);
                        rigidbody.drag = 0.5f * (rigidbody.mass / 5f);
                        rigidbody.angularDrag = 0.2f * (rigidbody.mass / 5f);

                        FireBall fireBall = GameManager.server.CreateEntity(entity.fireBall.resourcePath, lootCrate.transform.position, new Quaternion(), true) as FireBall;
                        if (fireBall)
                        {
                            fireBall.transform.position = lootCrate.transform.position;
                            fireBall.Spawn();
                            fireBall.GetComponent<Rigidbody>().isKinematic = true;
                            fireBall.GetComponent<Collider>().enabled = false;
                            fireBall.transform.parent = lootCrate.transform;
                        }
                        lootCrate.SendMessage("SetLockingEnt", fireBall.gameObject, SendMessageOptions.DontRequireReceiver);

                        foreach (ServerGib serverGib1 in serverGibs)
                            Physics.IgnoreCollision(collider, serverGib1.GetCollider(), true);
                    }
                }
                if (entity != null && !entity.IsDestroyed)
                    entity.Kill(BaseNetworkable.DestroyMode.Gib);
            }
        }
        #endregion

        #region Commands
        [ChatCommand("spawntank")]
        void cmdTank(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, "tankcommander.admin")) return;

            Vector3 position = player.eyes.position + (player.eyes.MovementForward() * 5f);

            BaseEntity entity = GameManager.server.CreateEntity(APC_PREFAB, position, Quaternion.Euler(0, player.eyes.rotation.eulerAngles.y - 90f, 0));
            entity.enableSaving = false;
            entity.Spawn();

            controllers.Add(entity.gameObject.AddComponent<APCController>());
        }

        [ConsoleCommand("spawntank")]
        void ccmdSpawnTank(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null || arg.Args == null)
                return;

            if (arg.Args.Length == 1)
            {
                BasePlayer player = covalence.Players.Connected.FirstOrDefault(x => x.Id == arg.GetString(0))?.Object as BasePlayer;
                if (player != null)
                {
                    Vector3 position = player.eyes.position + (player.eyes.MovementForward() * 5f);

                    BaseEntity entity = GameManager.server.CreateEntity(APC_PREFAB, position, Quaternion.Euler(0, player.eyes.rotation.eulerAngles.y - 90f, 0));
                    entity.enableSaving = false;
                    entity.Spawn();

                    controllers.Add(entity.gameObject.AddComponent<APCController>());
                }
                return;
            }
            if (arg.Args.Length == 3)
            {
                float x;
                float y;
                float z;

                if (float.TryParse(arg.GetString(0), out x))
                {
                    if (float.TryParse(arg.GetString(1), out y))
                    {
                        if (float.TryParse(arg.GetString(2), out z))
                        {
                            BaseEntity entity = GameManager.server.CreateEntity(APC_PREFAB, new Vector3(x, y, z));
                            entity.enableSaving = false;
                            entity.Spawn();

                            controllers.Add(entity.gameObject.AddComponent<APCController>());
                            return;
                        }
                    }
                }
                PrintError($"Invalid arguments supplied to spawn a tank at position : (x = {arg.GetString(0)}, y = {arg.GetString(1)}, z = {arg.GetString(2)})");
            }
        }
        #endregion

        #region Friends
        private bool AreFriends(ulong playerId, ulong friendId)
        {
            if (Friends && configData.Passengers.UseFriends)
                return (bool)Friends?.Call("AreFriendsS", playerId.ToString(), friendId.ToString());
            return true;
        }
        private bool IsClanmate(ulong playerId, ulong friendId)
        {
            if (Clans && configData.Passengers.UseClans)
            {
                object playerTag = Clans?.Call("GetClanOf", playerId);
                object friendTag = Clans?.Call("GetClanOf", friendId);
                if (playerTag is string && friendTag is string)
                {
                    if (!string.IsNullOrEmpty((string)playerTag) && !string.IsNullOrEmpty((string)friendTag) && (playerTag == friendTag))
                        return true;
                }
                return false;
            }
            return true;
        }
        #endregion

        #region UI
        #region UI Elements
        public static class UI
        {
            static public CuiElementContainer ElementContainer(string panelName, string color, UI4 dimensions, bool useCursor = false, string parent = "Overlay")
            {
                CuiElementContainer NewElement = new CuiElementContainer()
                {
                    {
                        new CuiPanel
                        {
                            Image = {Color = color},
                            RectTransform = {AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax()},
                            CursorEnabled = useCursor
                        },
                        new CuiElement().Parent = parent,
                        panelName
                    }
                };
                return NewElement;
            }
            static public void Panel(ref CuiElementContainer container, string panel, string color, UI4 dimensions, bool cursor = false)
            {
                container.Add(new CuiPanel
                {
                    Image = { Color = color },
                    RectTransform = { AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() },
                    CursorEnabled = cursor
                },
                panel);
            }
            static public void Label(ref CuiElementContainer container, string panel, string text, int size, UI4 dimensions, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiLabel
                {
                    Text = { FontSize = size, Align = align, Text = text, Font = "droidsansmono.ttf" },
                    RectTransform = { AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() }
                },
                panel);

            }
            public static string Color(string hexColor, float alpha)
            {
                if (hexColor.StartsWith("#"))
                    hexColor = hexColor.Substring(1);
                int red = int.Parse(hexColor.Substring(0, 2), NumberStyles.AllowHexSpecifier);
                int green = int.Parse(hexColor.Substring(2, 2), NumberStyles.AllowHexSpecifier);
                int blue = int.Parse(hexColor.Substring(4, 2), NumberStyles.AllowHexSpecifier);
                return $"{(double)red / 255} {(double)green / 255} {(double)blue / 255} {alpha}";
            }
        }
        public class UI4
        {
            public float xMin, yMin, xMax, yMax;
            public UI4(float xMin, float yMin, float xMax, float yMax)
            {
                this.xMin = xMin;
                this.yMin = yMin;
                this.xMax = xMax;
                this.yMax = yMax;
            }
            public string GetMin() => $"{xMin} {yMin}";
            public string GetMax() => $"{xMax} {yMax}";
        }
        #endregion

        #region UI Creation
        private static void CreateHealthUI(BasePlayer player, APCController controller)
        {
            if (player == null)
                return;

            CuiElementContainer container = UI.ElementContainer(UI_HEALTH, "0.95 0.95 0.95 0.05", new UI4(0.69f, 0.1f, 0.83f, 0.135f));
            UI.Label(ref container, UI_HEALTH, $"HLTH: ", 12, new UI4(0.03f, 0, 1, 1), TextAnchor.MiddleLeft);
            double percentHealth = System.Convert.ToDouble((float)controller.entity.health / (float)controller.entity.MaxHealth());
            float yMaxHealth = 0.25f + (0.73f * (float)percentHealth);
            UI.Panel(ref container, UI_HEALTH, UI.Color("#ce422b", 0.6f), new UI4(0.25f, 0.1f, yMaxHealth, 0.9f));
            DestroyUI(player, UI_HEALTH);
            CuiHelper.AddUi(player, container);
        }

        private static void CreateMGAmmoUI(BasePlayer player, APCController controller)
        {
            if (player == null)
                return;

            if (configData.Weapons.MG.Enabled && configData.Weapons.MG.RequireAmmo)
            {
                CuiElementContainer container = UI.ElementContainer(UI_AMMO_MG, "0.95 0.95 0.95 0.05", new UI4(0.69f, 0.060f, 0.83f, 0.096f));
                UI.Label(ref container, UI_AMMO_MG, $"MGUN: <color=#ce422b>{controller.inventory.GetAmount(ins.mgId, false)}</color>", 12, new UI4(0.03f, 0, 1, 1), TextAnchor.MiddleLeft);
                DestroyUI(player, UI_AMMO_MG);
                CuiHelper.AddUi(player, container);
            }
        }

        private static void CreateRocketAmmoUI(BasePlayer player, APCController controller)
        {
            if (player == null)
                return;

            if (configData.Weapons.Cannon.Enabled && configData.Weapons.Cannon.RequireAmmo)
            {
                CuiElementContainer container = UI.ElementContainer(UI_AMMO_ROCKET, "0.95 0.95 0.95 0.05", new UI4(0.69f, 0.021f, 0.83f, 0.056f));
                UI.Label(ref container, UI_AMMO_ROCKET, $"CNON: <color=#ce422b>{controller.inventory.GetAmount(ins.rocketId, false)}</color>", 12, new UI4(0.03f, 0, 1, 1), TextAnchor.MiddleLeft);
                DestroyUI(player, UI_AMMO_ROCKET);
                CuiHelper.AddUi(player, container);
            }
        }

        private static void DestroyUI(BasePlayer player, string panel) => CuiHelper.DestroyUi(player, panel);

        private static void DestroyAllUI(BasePlayer player)
        {
            DestroyUI(player, UI_HEALTH);
            DestroyUI(player, UI_AMMO_MG);
            DestroyUI(player, UI_AMMO_ROCKET);
        }
        #endregion
        #endregion

        #region Config
        private static ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Movement Settings")]
            public MovementSettings Movement { get; set; }

            [JsonProperty(PropertyName = "Button Configuration")]
            public ButtonConfiguration Buttons { get; set; }

            [JsonProperty(PropertyName = "Crushable Types")]
            public CrushableTypes Crushables { get; set; }

            [JsonProperty(PropertyName = "Passenger Options")]
            public PassengerOptions Passengers { get; set; }

            [JsonProperty(PropertyName = "Inventory Options")]
            public InventoryOptions Inventory { get; set; }

            [JsonProperty(PropertyName = "Weapon Options")]
            public WeaponOptions Weapons { get; set; }

            public class CrushableTypes
            {
                [JsonProperty(PropertyName = "Can crush buildings")]
                public bool Buildings { get; set; }

                [JsonProperty(PropertyName = "Can crush resources")]
                public bool Resources { get; set; }

                [JsonProperty(PropertyName = "Can crush loot containers")]
                public bool Loot { get; set; }

                [JsonProperty(PropertyName = "Can crush animals")]
                public bool Animals { get; set; }

                [JsonProperty(PropertyName = "Can crush players")]
                public bool Players { get; set; }

                [JsonProperty(PropertyName = "Amount of force required to crush various building grades")]
                public Dictionary<string, float> GradeForce { get; set; }

                [JsonProperty(PropertyName = "Amount of force required to crush external walls")]
                public float WallForce { get; set; }

                [JsonProperty(PropertyName = "Amount of force required to crush resources")]
                public float ResourceForce { get; set; }
            }

            public class ButtonConfiguration
            {
                [JsonProperty(PropertyName = "Enter/Exit vehicle")]
                public string Enter { get; set; }

                [JsonProperty(PropertyName = "Toggle light")]
                public string Lights { get; set; }

                [JsonProperty(PropertyName = "Open inventory")]
                public string Inventory { get; set; }

                [JsonProperty(PropertyName = "Speed boost")]
                public string Boost { get; set; }

                [JsonProperty(PropertyName = "Fire Cannon")]
                public string Cannon { get; set; }

                [JsonProperty(PropertyName = "Fire Coaxial Gun")]
                public string Coax { get; set; }

                [JsonProperty(PropertyName = "Fire MG")]
                public string MG { get; set; }
            }

            public class MovementSettings
            {
                [JsonProperty(PropertyName = "Forward torque (nm)")]
                public float ForwardTorque { get; set; }

                [JsonProperty(PropertyName = "Rotation torque (nm)")]
                public float TurnTorque { get; set; }

                [JsonProperty(PropertyName = "Brake torque (nm)")]
                public float BrakeTorque { get; set; }

                [JsonProperty(PropertyName = "Time to reach maximum acceleration (seconds)")]
                public float Acceleration { get; set; }

                [JsonProperty(PropertyName = "Boost torque (nm)")]
                public float BoostTorque { get; set; }
            }
            public class PassengerOptions
            {
                [JsonProperty(PropertyName = "Allow passengers")]
                public bool Enabled { get; set; }

                [JsonProperty(PropertyName = "Number of allowed passengers (Max 4)")]
                public int Max { get; set; }

                [JsonProperty(PropertyName = "Require passenger to be a friend (FriendsAPI)")]
                public bool UseFriends { get; set; }

                [JsonProperty(PropertyName = "Require passenger to be a clan mate (Clans)")]
                public bool UseClans { get; set; }
            }

            public class InventoryOptions
            {
                [JsonProperty(PropertyName = "Enable inventory system")]
                public bool Enabled { get; set; }

                [JsonProperty(PropertyName = "Drop inventory on death")]
                public bool DropInv { get; set; }

                [JsonProperty(PropertyName = "Drop loot on death")]
                public bool DropLoot { get; set; }

                [JsonProperty(PropertyName = "Inventory size (max 36)")]
                public int Size { get; set; }
            }

            public class WeaponOptions
            {
                [JsonProperty(PropertyName = "Cannon")]
                public WeaponSystem Cannon { get; set; }

                [JsonProperty(PropertyName = "Coaxial")]
                public WeaponSystem Coax { get; set; }

                [JsonProperty(PropertyName = "Machine Gun")]
                public WeaponSystem MG { get; set; }

                [JsonProperty(PropertyName = "Enable Crosshair")]
                public bool EnableCrosshair { get; set; }

                [JsonProperty(PropertyName = "Crosshair Color")]
                public SerializedColor CrosshairColor { get; set; }

                [JsonProperty(PropertyName = "Crosshair Size")]
                public int CrosshairSize { get; set; }

                public class SerializedColor
                {
                    public float R { get; set; }
                    public float G { get; set; }
                    public float B { get; set; }
                    public float A { get; set; }

                    private Color _color;
                    private bool _isInit;

                    public SerializedColor(float r, float g, float b, float a)
                    {
                        R = r;
                        G = g;
                        B = b;
                        A = a;
                    }

                    [JsonIgnore]
                    public Color Color
                    {
                        get
                        {
                            if (!_isInit)
                            {
                                _color = new Color(R, G, B, A);
                                _isInit = true;
                            }
                            return _color;
                        }
                    }
                }

                public class WeaponSystem
                {
                    [JsonProperty(PropertyName = "Enable weapon system")]
                    public bool Enabled { get; set; }

                    [JsonProperty(PropertyName = "Require ammunition in inventory")]
                    public bool RequireAmmo { get; set; }

                    [JsonProperty(PropertyName = "Ammunition type (item shortname)")]
                    public string Type { get; set; }

                    [JsonProperty(PropertyName = "Fire rate (seconds)")]
                    public float Interval { get; set; }

                    [JsonProperty(PropertyName = "Aim cone (smaller number is more accurate)")]
                    public float Accuracy { get; set; }

                    [JsonProperty(PropertyName = "Damage")]
                    public float Damage { get; set; }
                }
            }

            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();

            if (configData.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                Buttons = new ConfigData.ButtonConfiguration
                {
                    Enter = "USE",
                    Lights = "RELOAD",
                    Inventory = "RELOAD",
                    Boost = "SPRINT",
                    Cannon = "FIRE_PRIMARY",
                    Coax = "FIRE_SECONDARY",
                    MG = "FIRE_THIRD"
                },
                Crushables = new ConfigData.CrushableTypes
                {
                    Animals = true,
                    Buildings = true,
                    Loot = true,
                    Players = true,
                    Resources = true,
                    GradeForce = new Dictionary<string, float>
                    {
                        [BuildingGrade.Enum.Twigs.ToString()] = 1000f,
                        [BuildingGrade.Enum.Wood.ToString()] = 2000f,
                        [BuildingGrade.Enum.Stone.ToString()] = 3000f,
                        [BuildingGrade.Enum.Metal.ToString()] = 5000f,
                        [BuildingGrade.Enum.TopTier.ToString()] = 7000f,
                    },
                    ResourceForce = 1500f,
                    WallForce = 3000f
                },
                Movement = new ConfigData.MovementSettings
                {
                    Acceleration = 3f,
                    BrakeTorque = 50f,
                    ForwardTorque = 1500f,
                    TurnTorque = 1800f,
                    BoostTorque = 300f
                },
                Passengers = new ConfigData.PassengerOptions
                {
                    Enabled = true,
                    Max = 4,
                    UseClans = true,
                    UseFriends = true
                },
                Inventory = new ConfigData.InventoryOptions
                {
                    Enabled = true,
                    Size = 36,
                    DropInv = true,
                    DropLoot = false
                },
                Weapons = new ConfigData.WeaponOptions
                {
                    EnableCrosshair = true,
                    CrosshairColor = new ConfigData.WeaponOptions.SerializedColor(0.75f, 0.75f, 0.75f, 0.75f),
                    CrosshairSize = 40,
                    Cannon = new ConfigData.WeaponOptions.WeaponSystem
                    {
                        Accuracy = 0.025f,
                        Damage = 90f,
                        Enabled = true,
                        Interval = 1.75f,
                        RequireAmmo = false,
                        Type = "ammo.rocket.hv"
                    },
                    Coax = new ConfigData.WeaponOptions.WeaponSystem
                    {
                        Accuracy = 0.75f,
                        Damage = 10f,
                        Enabled = true,
                        Interval = 0.06667f,
                        RequireAmmo = false,
                        Type = "ammo.rifle.hv"
                    },
                    MG = new ConfigData.WeaponOptions.WeaponSystem
                    {
                        Accuracy = 1.25f,
                        Damage = 10f,
                        Enabled = true,
                        Interval = 0.1f,
                        RequireAmmo = false,
                        Type = "ammo.rifle.hv"
                    }
                },
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();

            if (configData.Version < new VersionNumber(0, 2, 0))
                configData = baseConfig;

            if (configData.Version < new VersionNumber(0, 2, 2))
            {
                configData.Weapons.EnableCrosshair = true;
                configData.Weapons.CrosshairColor = new ConfigData.WeaponOptions.SerializedColor(0.75f, 0.75f, 0.75f, 0.75f);
                configData.Weapons.CrosshairSize = 40;
            }

            configData.Version = Version;
            PrintWarning("Config update completed!");
        }
        #endregion

        #region Localization
        private static string msg(string key, string playerId = null) => ins.lang.GetMessage(key, ins, playerId);

        private Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            ["in_use"] = "<color=#D3D3D3>This tank is already in use</color>",
            ["not_friend"] = "<color=#D3D3D3>You must be a friend or clanmate with the operator</color>",
            ["passenger_enter"] = "<color=#D3D3D3>You have entered the tank as a passenger</color>",
            ["controls"] = "<color=#ce422b>Tank Controls:</color>",
            ["fire_cannon"] = "<color=#D3D3D3>Fire Cannon </color><color=#ce422b>{0}</color>",
            ["fire_coax"] = "<color=#D3D3D3>Fire Coaxial Gun </color><color=#ce422b>{0}</color>",
            ["fire_mg"] = "<color=#D3D3D3>Fire MG </color><color=#ce422b>{0}</color>",
            ["speed_boost"] = "<color=#D3D3D3>Speed Boost </color><color=#ce422b>{0}</color>",
            ["enter_exit"] = "<color=#D3D3D3>Enter/Exit Vehicle </color><color=#ce422b>{0}</color>",
            ["toggle_lights"] = "<color=#D3D3D3>Toggle Lights </color><color=#ce422b>{0}</color>",
            ["access_inventory"] = "<color=#D3D3D3>Access Inventory (from outside of the vehicle) </color><color=#ce422b>{0}</color>",
            ["no_ammo_cannon"] = "<color=#D3D3D3>You do not have ammunition to fire the cannon. It requires </color><color=#ce422b>{0}</color>",
            ["no_ammo_mg"] = "<color=#D3D3D3>You do not have ammunition to fire the machine gun. It requires </color><color=#ce422b>{0}</color>",
            ["no_ammo_coax"] = "<color=#D3D3D3>You do not have ammunition to fire the coaxial gun. It requires </color><color=#ce422b>{0}</color>",
        };
        #endregion
    }
}

// --- End of file: TankCommander.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/SleeperAnimalProtection.cs ---
// --- Original Local Path: SleeperAnimalProtection.cs ---

using System;
using System.Collections.Generic;
using UnityEngine;

using Facepunch;

namespace Oxide.Plugins
{
    [Info("SleeperAnimalProtection", "Fujikura", "0.2.1")]
	[Description("Protects sleeping players from being killed by animals")]
    class SleeperAnimalProtection : RustPlugin
    {
		private bool Changed = false;
		private bool usePermission;
		private string permissionName;
		private bool checkForFoundation;
        private readonly int buildingLayer = LayerMask.GetMask("Terrain", "World", "Construction", "Deployed");
		
		private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }
		
		void LoadVariables()
        {
			usePermission = Convert.ToBoolean(GetConfig("Settings", "Use permissions", false));
			permissionName = Convert.ToString(GetConfig("Settings", "Permission name", "sleeperanimalprotection.active"));
			checkForFoundation = Convert.ToBoolean(GetConfig("Settings", "Required to sleep ON foundation", false));

            if (!Changed) return;
            SaveConfig();
            Changed = false;
        }
		
		protected override void LoadDefaultConfig()
        {
            Config.Clear();
            LoadVariables();
        }
		
		void Loaded()
		{
			LoadVariables();
			if (!permission.PermissionExists(permissionName)) permission.RegisterPermission(permissionName, this);
		}
	
        private List<BuildingBlock> GetFoundation(Vector3 positionCoordinates)
        {
            var position = positionCoordinates;
            var entities = new List<BuildingBlock>();
            var hits = Pool.GetList<BuildingBlock>();
            Vis.Entities(position, 2.5f, hits, buildingLayer);
            for (var i = 0; i < hits.Count; i++)
            {
                var entity = hits[i];
                if (!entity.ShortPrefabName.Contains("foundation") || positionCoordinates.y < entity.WorldSpaceBounds().ToBounds().max.y) continue;
                entities.Add(entity);
            }
            Pool.FreeList(ref hits);
            return entities;
        }	
	
		object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
			if (entity as BasePlayer != null && (entity as BasePlayer).IsSleeping() && info.Initiator is BaseNPC) 
			{
				if(usePermission && !permission.UserHasPermission((entity as BasePlayer).userID.ToString(), permissionName)) return null;
				if(checkForFoundation && GetFoundation(entity.transform.position).Count == 0) return null;
				info.Initiator.Kill();
				return true;
			}
            return null;
        }
    }
}


// --- End of file: SleeperAnimalProtection.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/AntiAdminAbuse.cs ---
// --- Original Local Path: AntiAdminAbuse.cs ---

using System;
namespace Oxide.Plugins
{
    [Info("AntiAdminAbuse", "Norn", 0.2, ResourceId = 12693)]
    [Description("Prevent moderator abuse.")]
    public class AntiAdminAbuse : RustPlugin
    {
        object OnRunCommand(ConsoleSystem.Arg arg)
        {
            try
            {
                if (arg.cmd.isCommand && arg.cmd.namefull == "global.setinfo")
                {
                    if(arg.ArgsStr.Contains("global.god") && arg.ArgsStr.Contains("True"))
                    {
                        if (!Convert.ToBoolean(Config["Admin", "GodEnabled"]))
                        {
                            if ((BasePlayer.FindByID(arg.connection.userid).IsConnected()))
                            {
                                BasePlayer player = BasePlayer.FindByID(arg.connection.userid);
                                if (player != null)
                                {
                                    if (player.net.connection.authLevel >= Convert.ToInt32(Config["Admin", "MinLevel"]))
                                    {
                                        PrintToChat(player, Config["Messages", "NoGod"].ToString());
                                        if (Convert.ToBoolean(Config["Admin", "KickAdmin"])) { player.Kick(Config["Messages", "NoGodAllowed"].ToString()); }
                                        if (Convert.ToBoolean(Config["Admin", "PrintToConsole"])) { Puts(arg.connection.username + " [ " + arg.connection.userid + " ] has tried to enable GodMode via F1. [GOD]"); }
                                    }
                                }
                            }
                        }
                        return false;
                    }
                }
                if (arg.cmd.isAdmin && arg.cmd.isCommand)
                {
                    string command = arg.cmd.name.ToString().ToLower();
                    int authlevel = arg.connection.authLevel;
                    switch (command)
                    {

                            case "givearm":
                            {
                                if (authlevel >= Convert.ToInt32(Config["Admin", "MinLevel"]) && authlevel <= Convert.ToInt32(Config["Admin", "MaxLevel"]))
                                {
                                    if (Convert.ToBoolean(Config["Admin", "OnlyMaxCanSpawn"]))
                                    {
                                        if (authlevel != Convert.ToInt32(Config["Admin", "MaxLevel"]))
                                        {
                                            PrintToChat(BasePlayer.FindByID(arg.connection.userid), Config["Messages", "Disabled"].ToString());
                                            if (Convert.ToBoolean(Config["Admin", "PrintToConsole"]))
                                            {
                                                Puts(arg.connection.username + " [ " + arg.connection.userid + " ] has tried to spawn an item via F1. [ARM]");
                                            }
                                            return false;
                                        }
                                    }
                                }
                                break;
                            }
                            case "giveid":
                            {
                                if (authlevel >= Convert.ToInt32(Config["Admin", "MinLevel"]) && authlevel <= Convert.ToInt32(Config["Admin", "MaxLevel"]))
                                {
                                    if (Convert.ToBoolean(Config["Admin", "OnlyMaxCanSpawn"]))
                                    {
                                        if (authlevel != Convert.ToInt32(Config["Admin", "MaxLevel"]))
                                        {
                                            PrintToChat(BasePlayer.FindByID(arg.connection.userid), Config["Messages", "Disabled"].ToString());
                                            if (Convert.ToBoolean(Config["Admin", "PrintToConsole"]))
                                            {
                                                Puts(arg.connection.username + " [ " + arg.connection.userid + " ] has tried to spawn an item via F1. [ID]");
                                            }
                                            return false;
                                        }
                                    }
                                }
                                break;
                            }
                            case "givebp":
                            {
                                if (authlevel >= Convert.ToInt32(Config["Admin", "MinLevel"]) && authlevel <= Convert.ToInt32(Config["Admin", "MaxLevel"]))
                                {
                                    if (Convert.ToBoolean(Config["Admin", "OnlyMaxCanSpawn"]))
                                    {
                                        if (authlevel != Convert.ToInt32(Config["Admin", "MaxLevel"]))
                                        {
                                            PrintToChat(BasePlayer.FindByID(arg.connection.userid), Config["Messages", "Disabled"].ToString());
                                            if (Convert.ToBoolean(Config["Admin", "PrintToConsole"]))
                                            {
                                                Puts(arg.connection.username + " [ " + arg.connection.userid + " ] has tried to spawn an item via F1. [BP]");
                                            }
                                            return false;
                                        }
                                    }
                                }
                                break;
                        }
                    }
                }
            }
            catch { }
            return null;
        }
        protected override void LoadDefaultConfig()
        {
            Puts("No configuration file found, generating...");
            Config.Clear();

            // --- [ MESSAGES ] ---

            Config["Messages", "Disabled"] = "Spawning items has been <color=red>disabled</color> by the server owner.";
            Config["Messages", "NoGod"] = "God Mode has been <color=red>disabled</color> by the server owner.";
            Config["Messages", "NoGodAllowed"] = "God Mode is not allowed, even for administrators.";

            // --- [ ADMIN ] ---
            Config["Admin", "KickAdmin"] = false;
            Config["Admin", "PrintToConsole"] = true;
            Config["Admin", "MinLevel"] = 1;
            Config["Admin", "MaxLevel"] = 2;
            Config["Admin", "OnlyMaxCanSpawn"] = true;
            Config["Admin", "GodEnabled"] = false;
        }
    }
}

// --- End of file: AntiAdminAbuse.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/FauxAdmin.cs ---
// --- Original Local Path: FauxAdmin.cs ---

using System;
using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
     	[Info("FauxAdmin", "Colon Blow", "1.0.4", ResourceId = 1933)]
    	class FauxAdmin : RustPlugin
     	{

	public bool DisableFlyHackProtection => Config.Get<bool>("DisableFlyHackProtection");
	public bool DisableNoclipProtection => Config.Get<bool>("DisableNoclipProtection");
	public bool DisableFauxAdminDemolish => Config.Get<bool>("DisableFauxAdminDemolish");
	public bool DisableFauxAdminRotate => Config.Get<bool>("DisableFauxAdminRotate");
	public bool DisableFauxAdminUpgrade => Config.Get<bool>("DisableFauxAdminUpgrade");
	public bool AllowGodModeToggle => Config.Get<bool>("AllowGodModeToggle");
	public bool DisableNoclipOnNoBuild => Config.Get<bool>("DisableNoclipOnNoBuild");

	Dictionary<ulong, RestrictedData> _restricted = new Dictionary<ulong, RestrictedData>();

        class RestrictedData
        {
             public BasePlayer player;
        }

        protected override void LoadDefaultConfig()
        	{
			Config["DisableFlyHackProtection"] = true;
			Config["DisableNoclipProtection"] = true;
			Config["DisableFauxAdminDemolish"] = true;
			Config["DisableFauxAdminRotate"] = true;
			Config["DisableFauxAdminUpgrade"] = true;
			Config["AllowGodModeToggle"] = false;
			Config["DisableNoclipOnNoBuild"] = true;
            		SaveConfig();
        	}

        void Loaded()
        	{
		if (DisableFlyHackProtection) ConVar.AntiHack.flyhack_protection = 0;
		if (DisableNoclipProtection) ConVar.AntiHack.noclip_protection = 0;
		lang.RegisterMessages(messages, this);
        	permission.RegisterPermission("fauxadmin.allowed", this);
		permission.RegisterPermission("fauxadmin.bypass", this);
		permission.RegisterPermission("fauxadmin.blocked", this);
		permission.RegisterPermission("fauxadmin.god", this);
		}

	////////////////////////////////////////////////////////////////////////////////////////////////////////

        Dictionary<string, string> messages = new Dictionary<string, string>()
        	{
			{"restricted", "You are not allowed to noclip here." },
			{"notallowed", "You are not worthy yet!" }
        	};

	////////////////////////////////////////////////////////////////////////////////////////////////////////

		[ChatCommand("noclip")]
        void cmdChatnoclip(BasePlayer player, string command, string[] args)
        	{
			if (player.net?.connection?.authLevel > 0)
			{
				rust.RunClientCommand(player, "noclip");
				return;
			}
			if (!isAllowed(player, "fauxadmin.allowed"))
            		{
                		SendReply(player, lang.GetMessage("notallowed", this));
                		return;
            		}
			if (isAllowed(player, "fauxadmin.allowed"))
        		{	
				rust.RunClientCommand(player, "noclip");
				return;
			}
		return;
         	}

	void OnPlayerTick(BasePlayer player)
		{
			if (player.net?.connection?.authLevel > 0) return;

			if (!AllowGodModeToggle)
			{
				if (isAllowed(player, "fauxadmin.god")) return;
				if (player.net.connection.info.GetBool("global.god", true) || player.IsImmortal())
				{
				rust.RunClientCommand(player, "global.god false");
				}
			}
			if (!DisableNoclipOnNoBuild) return;
			if (DisableNoclipOnNoBuild)
			{
				if (_restricted.ContainsKey(player.userID)) return;

				if (player.CanBuild()) return;
				if (!player.CanBuild())
				{
					if (!player.IsFlying()) return;
					if (isAllowed(player, "fauxadmin.bypass")) return;
			   		if (player.IsFlying() && isAllowed(player, "fauxadmin.allowed"))
			   		{
						player.violationLevel = 0;
						
						var newPos = player.transform.position;
						DeactivateNoClip(player, newPos);
						return;
					}
				}
			}
		return;
		}

	private void DeactivateNoClip(BasePlayer player, Vector3 newPos)
		{
			if (player == null) return;
			if (_restricted.ContainsKey(player.userID)) return;
			timer.Repeat(0.1f, 10,() => ForcePlayerPosition(player, newPos));

			_restricted.Add(player.userID, new RestrictedData
			{
			player = player
			});
			SendReply(player, lang.GetMessage("restricted", this));
			rust.RunClientCommand(player, "noclip");
			timer.Once(1, () => _restricted.Remove(player.userID));
			return;
		}

	////////////////////////////////////////////////////////////////////////////////////////////////////////

        object OnStructureDemolish(BuildingBlock block, BasePlayer player)
        {
            	if (block.OwnerID == 0 || player.userID == 0) return null;
		if (block.OwnerID == player.userID) return null;
            	if (block.OwnerID != player.userID && DisableFauxAdminDemolish)
            	{
                	return true;
            	}
            	return null;
        }

        object OnStructureRotate(BuildingBlock block, BasePlayer player)
        {
            	if (block.OwnerID == 0 || player.userID == 0) return null;
		if (block.OwnerID == player.userID) return null;
            	if (block.OwnerID != player.userID && DisableFauxAdminRotate)
            	{
                	return true;
            	}
        
            	return null;
        }

        object OnStructureUpgrade(BuildingBlock block, BasePlayer player)
        {
            	if (block.OwnerID == 0 || player.userID == 0) return null;
		if (block.OwnerID == player.userID) return null;
            	if (block.OwnerID != player.userID && DisableFauxAdminUpgrade)
            	{
                	return true;
            	}
        
            	return null;
        }

	////////////////////////////////////////////////////////////////////////////////////////////////////////

	void OnPlayerSleepEnded(BasePlayer player)
		{

			if (isAllowed(player, "fauxadmin.blocked"))
            		{
				player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, false);
                		return;
            		}

			if (player.net?.connection?.authLevel > 0) return;

			if (!isAllowed(player, "fauxadmin.allowed"))
            		{
				player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, false);
                		return;
            		}
			if (isAllowed(player, "fauxadmin.allowed"))
        		{
				player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, true);
				return;
			}
		return;
		}

	////////////////////////////////////////////////////////////////////////////////////////////////////////

	bool isAllowed(BasePlayer player, string perm) => permission.UserHasPermission(player.UserIDString, perm);

	}
}

// --- End of file: FauxAdmin.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/InfoTabs.cs ---
// --- Original Local Path: InfoTabs.cs ---

﻿using Newtonsoft.Json.Linq;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("InfoTabs", "VooDoo", "1.0.0")]
    [Description("Rules and Commands for XMenu")]
    public class InfoTabs : RustPlugin
    {
        [PluginReference] Plugin XMenu;


        #region Config
        private PluginConfig config;
        private class PluginConfig
        {
            public ColorConfig colorConfig;
            public class ColorConfig
            {
                public string menuContentHighlighting;
                public string menuContentHighlightingalternative;

                public string menuContentText;
                public string menuContentTextAlternative;

                public string gradientColor;
            }

            public Dictionary<string, string> commandsTab;
            public Dictionary<string, string> bindsTab;

            public List<string> rulesTab;
        }

        private void Init()
        {
            config = Config.ReadObject<PluginConfig>();
        }

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(GetDefaultConfig(), true);
        }

        private PluginConfig GetDefaultConfig()
        {
            return new PluginConfig
            {
                colorConfig = new PluginConfig.ColorConfig()
                {
                    menuContentHighlighting = "#0000007f",
                    menuContentHighlightingalternative = "#FFFFFF10",
                    menuContentTextAlternative = "#90BD47",
                    menuContentText = "#FFFFFFAA",
                    gradientColor = "#00000099",
                },
                commandsTab = new Dictionary<string, string>()
                {
                    ["custommenu"] = "Открыть это меню",
                },
                bindsTab = new Dictionary<string, string>()
                {
                    ["bind z custommenu"] = "Открыть это меню",
                },
                rulesTab = new List<string>()
                {
                    "Текст",
                },
            };
        }
        #endregion

        #region Layers
        public const string MenuLayer = "XMenu";
        public const string MenuItemsLayer = "XMenu.MenuItems";
        public const string MenuSubItemsLayer = "XMenu.MenuSubItems";
        public const string MenuContent = "XMenu.Content";
        #endregion

        Timer TimerInitialize;
        private void OnServerInitialized()
        {
            TimerInitialize = timer.Every(5f, () =>
            {
                if (XMenu.IsLoaded)
                {
                    XMenu.Call("API_RegisterSubMenu", this.Name, "Main", "Правила", "RenderRules", null);
                    XMenu.Call("API_RegisterSubMenu", this.Name, "Main", "Команды", "RenderCommands", null);
                    XMenu.Call("API_RegisterSubMenu", this.Name, "Main", "Бинды", "RenderBinds", null);

                    int RulesID = (int)XMenu.Call("API_GetSubMenuID", "Main", "Информация");
                    cmd.AddChatCommand("help", this, (p, cmd, args) => rust.RunClientCommand(p, $"custommenu true Main {RulesID}"));

                    TimerInitialize.Destroy();
                }
            });
        }

        private void RenderCommands(ulong userID, object[] objects)
        {
            CuiElementContainer Container = (CuiElementContainer)objects[0];
            bool FullRender = (bool)objects[1];
            string Name = (string)objects[2];
            int ID = (int)objects[3];
            int Page = (int)objects[4];

            Container.Add(new CuiElement
            {
                Name = MenuContent,
                Parent = MenuLayer,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = "0 0 0 0",
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5",
                            AnchorMax = "0.5 0.5",
                            OffsetMin = "-215 -230",
                            OffsetMax = "500 270"
                        },
                    }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Info",
                Parent = MenuContent,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "0 1",
                            OffsetMin = "80 -460",
                            OffsetMax = "630 -10"
                        }
                    }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Info" + ".Title",
                Parent = MenuContent + ".Info",
                Components =
                        {
                            new CuiTextComponent
                            {
                                Text = $"<color={config.colorConfig.menuContentTextAlternative}>Команда</color>",
                                Align = TextAnchor.MiddleLeft,
                                FontSize = 24,
                                Font = "robotocondensed-regular.ttf",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.05 0.9",
                                AnchorMax = "0.975 0.975",
                            },
                            new CuiOutlineComponent()
                            {
                                 Color = "0 0 0 1",
                                 Distance = "0.5 -0.5"
                            }
                        }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Info" + ".Title",
                Parent = MenuContent + ".Info",
                Components =
                        {
                            new CuiTextComponent
                            {
                                Text = $"<color={config.colorConfig.menuContentText}>Описание</color>",
                                Align = TextAnchor.MiddleLeft,
                                FontSize = 24,
                                Font = "robotocondensed-regular.ttf",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.4 0.9",
                                AnchorMax = "0.95 0.975",
                            },
                            new CuiOutlineComponent()
                            {
                                 Color = "0 0 0 1",
                                 Distance = "0.5 -0.5"
                            }
                        }
            });

            string Commands = $"<color={config.colorConfig.menuContentTextAlternative}>";
            string Info = $"<color={config.colorConfig.menuContentText}>";
            for (int i = 0, x = 0; i < config.commandsTab.Count; i++)
            {
                if(Page * 27 > i)
                    continue;

                if (x > 26)
                    continue;

                Commands += $"{config.commandsTab.ElementAt(i).Key}\n";
                Info += $"{config.commandsTab.ElementAt(i).Value}\n";

                x++;
            }

            Commands += "</color>";
            Info += "</color>";

            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Info" + ".Text",
                Parent = MenuContent + ".Info",
                Components =
                        {
                            new CuiTextComponent
                            {
                                Text = Commands,
                                Align = TextAnchor.UpperLeft,
                                FontSize = 12,
                                Font = "robotocondensed-regular.ttf",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.05 0",
                                AnchorMax = "0.375 0.88",
                            },
                            new CuiOutlineComponent()
                            {
                                 Color = "0 0 0 1",
                                 Distance = "0.5 -0.5"
                            }
                        }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Info" + ".Text",
                Parent = MenuContent + ".Info",
                Components =
                        {
                            new CuiTextComponent
                            {
                                Text = Info,
                                Align = TextAnchor.UpperLeft,
                                FontSize = 12,
                                Font = "robotocondensed-regular.ttf",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.4 0",
                                AnchorMax = "0.95 0.88",
                            },
                            new CuiOutlineComponent()
                            {
                                 Color = "0 0 0 1",
                                 Distance = "0.5 -0.5"
                            }
                        }
            });

            if ((int)Page > 0)
            {
                Container.Add(new CuiElement
                {
                    Name = MenuContent + ".BackTitle",
                    Parent = MenuContent,
                    Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "0 1",
                            OffsetMin = "80 -500",
                            OffsetMax = "110 -470"
                        }
                    }
                });
                Container.Add(new CuiButton
                {
                    Button = { Color = "0 0 0 0", Command = $"custommenu false Main {ID} {(int)Page - 1}", },
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Text = { Text = "<", Align = TextAnchor.MiddleCenter, FontSize = 20 }
                }, MenuContent + ".BackTitle", MenuContent + ".BackTitleBtn");
            }
            if ((int)(Page * 27) + 27 < config.commandsTab.Count)
            {
                Container.Add(new CuiElement
                {
                    Name = MenuContent + ".NextTitle",
                    Parent = MenuContent,
                    Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "0 1",
                            OffsetMin = "600 -500",
                            OffsetMax = "630 -470"
                        }
                    }
                });
                Container.Add(new CuiButton
                {
                    Button = { Color = "0 0 0 0", Command = $"custommenu false Main {ID} {(int)Page + 1}", },
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Text = { Text = ">", Align = TextAnchor.MiddleCenter, FontSize = 20 }
                }, MenuContent + ".NextTitle", MenuContent + ".NextTitleBtn");
            }
        }

        private void RenderBinds(ulong userID, object[] objects)
        {
            CuiElementContainer Container = (CuiElementContainer)objects[0];
            bool FullRender = (bool)objects[1];
            string Name = (string)objects[2];
            int ID = (int)objects[3];
            int Page = (int)objects[4];

            Container.Add(new CuiElement
            {
                Name = MenuContent,
                Parent = MenuLayer,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = "0 0 0 0",
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5",
                            AnchorMax = "0.5 0.5",
                            OffsetMin = "-215 -230",
                            OffsetMax = "500 270"
                        },
                    }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Info",
                Parent = MenuContent,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "0 1",
                            OffsetMin = "80 -460",
                            OffsetMax = "630 -10"
                        }
                    }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Info" + ".Title",
                Parent = MenuContent + ".Info",
                Components =
                        {
                            new CuiTextComponent
                            {
                                Text = $"<color={config.colorConfig.menuContentTextAlternative}>Бинд</color>",
                                Align = TextAnchor.MiddleLeft,
                                FontSize = 24,
                                Font = "robotocondensed-regular.ttf",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.05 0.9",
                                AnchorMax = "0.975 0.975",
                            },
                            new CuiOutlineComponent()
                            {
                                 Color = "0 0 0 1",
                                 Distance = "0.5 -0.5"
                            }
                        }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Info" + ".Title",
                Parent = MenuContent + ".Info",
                Components =
                        {
                            new CuiTextComponent
                            {
                                Text = $"<color={config.colorConfig.menuContentText}>Описание</color>",
                                Align = TextAnchor.MiddleLeft,
                                FontSize = 24,
                                Font = "robotocondensed-regular.ttf",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.4 0.9",
                                AnchorMax = "0.95 0.975",
                            },
                            new CuiOutlineComponent()
                            {
                                 Color = "0 0 0 1",
                                 Distance = "0.5 -0.5"
                            }
                        }
            });

            string Commands = $"<color={config.colorConfig.menuContentTextAlternative}>";
            string Info = $"<color={config.colorConfig.menuContentText}>";
            for (int i = 0, x = 0; i < config.bindsTab.Count; i++)
            {
                if (Page * 27 > i)
                    continue;

                if (x > 26)
                    continue;

                Commands += $"{config.bindsTab.ElementAt(i).Key}\n";
                Info += $"{config.bindsTab.ElementAt(i).Value}\n";

                x++;
            }

            Commands += "</color>";
            Info += "</color>";

            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Info" + ".Text",
                Parent = MenuContent + ".Info",
                Components =
                        {
                            new CuiTextComponent
                            {
                                Text = Commands,
                                Align = TextAnchor.UpperLeft,
                                FontSize = 12,
                                Font = "robotocondensed-regular.ttf",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.05 0",
                                AnchorMax = "0.375 0.88",
                            },
                            new CuiOutlineComponent()
                            {
                                 Color = "0 0 0 1",
                                 Distance = "0.5 -0.5"
                            }
                        }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Info" + ".Text",
                Parent = MenuContent + ".Info",
                Components =
                        {
                            new CuiTextComponent
                            {
                                Text = Info,
                                Align = TextAnchor.UpperLeft,
                                FontSize = 12,
                                Font = "robotocondensed-regular.ttf",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.4 0",
                                AnchorMax = "0.95 0.88",
                            },
                            new CuiOutlineComponent()
                            {
                                 Color = "0 0 0 1",
                                 Distance = "0.5 -0.5"
                            }
                        }
            });

            if ((int)Page > 0)
            {
                Container.Add(new CuiElement
                {
                    Name = MenuContent + ".BackTitle",
                    Parent = MenuContent,
                    Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "0 1",
                            OffsetMin = "80 -500",
                            OffsetMax = "110 -470"
                        }
                    }
                });
                Container.Add(new CuiButton
                {
                    Button = { Color = "0 0 0 0", Command = $"custommenu false Main {ID} {(int)Page - 1}", },
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Text = { Text = "<", Align = TextAnchor.MiddleCenter, FontSize = 20 }
                }, MenuContent + ".BackTitle", MenuContent + ".BackTitleBtn");
            }
            if ((int)(Page * 27) + 27 < config.bindsTab.Count)
            {
                Container.Add(new CuiElement
                {
                    Name = MenuContent + ".NextTitle",
                    Parent = MenuContent,
                    Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "0 1",
                            OffsetMin = "600 -550",
                            OffsetMax = "630 -520"
                        }
                    }
                });
                Container.Add(new CuiButton
                {
                    Button = { Color = "0 0 0 0", Command = $"custommenu false Main {ID} {(int)Page + 1}", },
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Text = { Text = ">", Align = TextAnchor.MiddleCenter, FontSize = 20 }
                }, MenuContent + ".NextTitle", MenuContent + ".NextTitleBtn");
            }
        }

        private void RenderRules(ulong userID, object[] objects)
        {
            CuiElementContainer Container = (CuiElementContainer)objects[0];
            bool FullRender = (bool)objects[1];
            string Name = (string)objects[2];
            int ID = (int)objects[3];
            int Page = (int)objects[4];

            Container.Add(new CuiElement
            {
                Name = MenuContent,
                Parent = MenuLayer,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = "0 0 0 0",
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5",
                            AnchorMax = "0.5 0.5",
                            OffsetMin = "-215 -230",
                            OffsetMax = "500 270"
                        },
                    }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Info",
                Parent = MenuContent,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "0 1",
                            OffsetMin = "80 -460",
                            OffsetMax = "630 -10"
                        }
                    }
            });

            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Info" + ".Title",
                Parent = MenuContent + ".Info",
                Components =
                        {
                            new CuiTextComponent
                            {
                                Text = $"<color={config.colorConfig.menuContentText}>Информация и правила | Страница №{Page+1}</color>",
                                Align = TextAnchor.MiddleCenter,
                                FontSize = 24,
                                Font = "robotocondensed-regular.ttf",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.05 0.9",
                                AnchorMax = "0.95 0.975",
                            }
                        }
            });

            string Info = $"<color={config.colorConfig.menuContentText}>";
            for (int i = 0, x = 0; i < config.rulesTab.Count; i++)
            {
                if (Page * 27 > i)
                    continue;

                if (x > 26)
                    continue;

                Info += $"{config.rulesTab.ElementAt(i)}\n";

                x++;
            }
            Info += "</color>";

            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Info" + ".Text",
                Parent = MenuContent + ".Info",
                Components =
                        {
                            new CuiTextComponent
                            {
                                Text = Info,
                                Align = TextAnchor.UpperLeft,
                                FontSize = 12,
                                Font = "robotocondensed-regular.ttf",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.05 0",
                                AnchorMax = "0.95 0.88",
                            }
                        }
            });

            if ((int)Page > 0)
            {
                Container.Add(new CuiElement
                {
                    Name = MenuContent + ".BackTitle",
                    Parent = MenuContent,
                    Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "0 1",
                            OffsetMin = "80 -500",
                            OffsetMax = "110 -470"
                        }
                    }
                });
                Container.Add(new CuiButton
                {
                    Button = { Color = "0 0 0 0", Command = $"custommenu false Main {ID} {(int)Page - 1}", },
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Text = { Text = "<", Align = TextAnchor.MiddleCenter, FontSize = 20 }
                }, MenuContent + ".BackTitle", MenuContent + ".BackTitleBtn");
            }
            if ((int)(Page * 27) + 27 < config.rulesTab.Count)
            {
                Container.Add(new CuiElement
                {
                    Name = MenuContent + ".NextTitle",
                    Parent = MenuContent,
                    Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "0 1",
                            OffsetMin = "600 -500",
                            OffsetMax = "630 -470"
                        }
                    }
                });
                Container.Add(new CuiButton
                {
                    Button = { Color = "0 0 0 0", Command = $"custommenu false Main {ID} {(int)Page + 1}", },
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Text = { Text = ">", Align = TextAnchor.MiddleCenter, FontSize = 20 }
                }, MenuContent + ".NextTitle", MenuContent + ".NextTitleBtn");
            }
        }




        #region Utils
        public static DateTime UnixTimeStampToDateTime(double unixTimeStamp)
        {
            System.DateTime dtDateTime = new DateTime(1970, 1, 1, 0, 0, 0, 0, System.DateTimeKind.Utc);
            dtDateTime = dtDateTime.AddSeconds(unixTimeStamp).ToLocalTime();
            return dtDateTime;
        }

        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);

            return $"{color.r:F2} {color.g:F2} {color.b:F2} {color.a:F2}";
        }
        #endregion
    }
}

// --- End of file: InfoTabs.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/XScan.cs ---
// --- Original Local Path: XScan.cs ---

using System;
using System.Collections.Generic;
using Oxide.Core.Plugins;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("XScan", "Я", "1.0.1")]
    class XScan : RustPlugin
    {
		[PluginReference] private Plugin ImageLibrary;	

	    #region Configuration

        private ScanConfig config;

        private class ScanConfig
        {		
			internal class Settings
            {		
				[JsonProperty("Включить GUI сообщения")] public bool GUIMessage;
				[JsonProperty("Включить ЧАТ сообщения")] public bool ChatMessage;
				[JsonProperty("Хранить логи в дате")] public bool SaveData;				
				[JsonProperty("Автоматически очищать дату после вайпа")] public bool WipeData;				
				[JsonProperty("Хранить логи установленных шкафов и доступ к просмотру информации о шкафе")] public bool CupboardData;
				[JsonProperty("Перезарядка скана в сек.")]  public int CooldownScan;          			    
				[JsonProperty("Перезарядка сообщений в сек.")] public int CooldownMessage;					
				[JsonProperty("Список префабов. Отсканировав их можно узнать владельца шкафа и список авторизованных игроков")] public List<string> PrefabList;					
			}

			internal class GUISettings
            {	
				[JsonProperty("Время активности GUI")] public float GUIActive;					
				[JsonProperty("Максимальное кол-во отображаемых игроков")] public int MaxCount;					
				[JsonProperty("Максимальное кол-во отображаемых игроков в строке")] public int MaxCountString;					
			}			            		
			
			[JsonProperty("Общие настройки")]
            public Settings Setting = new Settings();
			[JsonProperty("Настройки GUI")]
            public GUISettings GUISetting = new GUISettings();						
			
			public static ScanConfig GetNewConfiguration()
            {
                return new ScanConfig
                {
					Setting = new Settings()
					{
						GUIMessage = true,
						ChatMessage = false,
						SaveData = true,
						WipeData = true,
						CupboardData = true,
						CooldownScan = 60,
						CooldownMessage = 5,
						PrefabList = new List<string>
						{
							"foundation"
						}
					},
					GUISetting = new GUISettings()
					{
                        GUIActive = 10.0f,
						MaxCount = 10,
						MaxCountString = 5
					}
				};
			}
        }

		protected override void LoadConfig()
        {
            base.LoadConfig();
			
			try
			{
				config = Config.ReadObject<ScanConfig>();
			}
			catch
			{
				PrintWarning("Ошибка чтения конфигурации! Создание дефолтной конфигурации!");
				LoadDefaultConfig();
			}
			
			SaveConfig();
        }
		protected override void LoadDefaultConfig() => config = ScanConfig.GetNewConfiguration();
        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion
		
		private Dictionary<BasePlayer, DateTime> CooldownsScan = new Dictionary<BasePlayer, DateTime>();
		private Dictionary<BasePlayer, DateTime> CooldownsMessage = new Dictionary<BasePlayer, DateTime>();

		#region Commands 

		[ChatCommand("scan")]
		private void cmdScan(BasePlayer player)
		{
			if (CooldownsScan.ContainsKey(player))
                if (CooldownsScan[player].Subtract(DateTime.Now).TotalSeconds >= 0)
				{
                    if (CooldownsMessage.ContainsKey(player))
                        if (CooldownsMessage[player].Subtract(DateTime.Now).TotalSeconds >= 0) return;
							
                    SendReply(player, string.Format(lang.GetMessage("CHATCD", this, player.UserIDString), TimeSpan.FromSeconds(Convert.ToInt32(CooldownsScan[player].Subtract(DateTime.Now).TotalSeconds))));
					CooldownsMessage[player] = DateTime.Now.AddSeconds(config.Setting.CooldownMessage);
					return;
				}
				
			if (!permission.UserHasPermission(player.UserIDString, "xscan.use"))
			{
				SendReply(player, lang.GetMessage("CHATNP", this, player.UserIDString));
				return;
			}

			if (permission.UserHasPermission(player.UserIDString, "xscan.unlimit")) 
				Scan(player);
			else if (StoredDataS.ContainsKey(player.userID))
			{
				StoredDataS[player.userID] -= 1; 
				Scan(player);
				
				SendReply(player, string.Format(lang.GetMessage("CHATSC", this, player.UserIDString), StoredDataS[player.userID]));
				
				if (StoredDataS[player.userID] == 0)
					StoredDataS.Remove(player.userID);
				
				Interface.Oxide.DataFileSystem.WriteObject("XScan/ScanCount", StoredDataS);
			}
			else
				SendReply(player, lang.GetMessage("CHATNSC", this, player.UserIDString));							

			if (!player.IsAdmin) 
				CooldownsScan[player] = DateTime.Now.AddSeconds(config.Setting.CooldownScan);
			else
				CooldownsScan[player] = DateTime.Now.AddSeconds(5);
			
		}
		
		[ConsoleCommand("scan_give")]
		void ccmdGiveSC(ConsoleSystem.Arg arg)
		{
			if (arg.Player() != null) return;
			
			ulong steamID = ulong.Parse(arg.Args[0]);
			
		    if (!StoredDataS.ContainsKey(steamID))
				StoredDataS.Add(steamID, 0);
			
			StoredDataS[steamID] += int.Parse(arg.Args[1]);
			Interface.Oxide.DataFileSystem.WriteObject("XScan/ScanCount", StoredDataS);
		}

		#endregion

		#region Data
		
		private Dictionary<string, string> StoredData = new Dictionary<string, string>();
		private Dictionary<ulong, string> StoredDataT = new Dictionary<ulong, string>();
		private Dictionary<ulong, int> StoredDataS = new Dictionary<ulong, int>();
		
		#endregion

		#region Hooks

		private void OnServerInitialized()
		{		
			
			if (Interface.Oxide.DataFileSystem.ExistsDatafile("XScan/ScanUSE"))
                StoredData = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<string, string>>("XScan/ScanUSE");
			if (Interface.Oxide.DataFileSystem.ExistsDatafile("XScan/CupboardList"))
                StoredDataT = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, string>>("XScan/CupboardList");			
			if (Interface.Oxide.DataFileSystem.ExistsDatafile("XScan/ScanCount"))
                StoredDataS = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, int>>("XScan/ScanCount"); 

			permission.RegisterPermission("xscan.use", this);
			permission.RegisterPermission("xscan.unlimit", this);
			permission.RegisterPermission("xscan.cupboardhome", this);
			permission.RegisterPermission("xscan.cupboardlist", this);
			permission.RegisterPermission("xscan.cupboard", this);
			permission.RegisterPermission("xscan.codelock", this);
			permission.RegisterPermission("xscan.autoturret", this);
			
			InitializeLang();
		}
		
		private int AuthorizedCount(int count)
		{
			int maxcount = config.GUISetting.MaxCount;
			
			if (count > maxcount) count = maxcount;
			int x = 0;

			while(count > 0)
			{
				count -= config.GUISetting.MaxCountString;
				x++;
			}
			
			return x;
		}
		
		private void OnEntityBuilt(Planner plan, GameObject go)
        {
            if (!config.Setting.CupboardData) return;
			
			var entity = go.ToBaseEntity();
			
			if (entity is BuildingPrivlidge)
			{
				StoredDataT.Add(entity.net.ID, $"{entity.OwnerID} | {entity.transform.position} | {DateTime.Now}");
				
				Interface.Oxide.DataFileSystem.WriteObject("XScan/CupboardList", StoredDataT);
			}
        }
		
		private object OnHammerHit(BasePlayer player, HitInfo info)
		{
			if (!config.Setting.CupboardData) return null;
			if (!permission.UserHasPermission(player.UserIDString, "xscan.cupboardlist")) return null;
			
			var entity = info?.HitEntity;
			
			if (entity is BuildingPrivlidge)
			{
				if (StoredDataT.ContainsKey(entity.net.ID))
					SendReply(player, string.Format(lang.GetMessage("CupboardInfo", this), StoredDataT[entity.net.ID]));
			}
			
			return null;
		}

        private void OnNewSave()
		{
			if (config.Setting.WipeData)
			{
			    StoredData.Clear();
			    StoredDataT.Clear();
				
				Interface.Oxide.DataFileSystem.WriteObject("XScan/ScanUSE", StoredData);
				Interface.Oxide.DataFileSystem.WriteObject("XScan/CupboardList", StoredDataT);
			}
		}

		#endregion
		
		#region Scan
		
		private void Scan(BasePlayer player)
		{
			RaycastHit rhit;
			
			if (!Physics.Raycast(player.eyes.HeadRay(), out rhit, 3f, LayerMask.GetMask("Construction", "Deployed"))) return;
			var entity = rhit.GetEntity();
			
			if (entity.OwnerID == 0) return;
			
			List<ulong> ListPlayers = new List<ulong>();
			
			if (permission.UserHasPermission(player.UserIDString, "xscan.cupboard") && entity is BuildingPrivlidge)
			{
				var Cupboard = entity as BuildingPrivlidge;

				foreach (var rplayer in Cupboard.authorizedPlayers)
					ListPlayers.Add(rplayer.userid);

                if (ListPlayers.Count != 0)
				{					
					if (config.Setting.GUIMessage) GUI(player, entity.OwnerID, ListPlayers, lang.GetMessage("GUICupboard", this, player.UserIDString));	
				    if (config.Setting.ChatMessage) ChatMessage(player, entity.OwnerID, ListPlayers, lang.GetMessage("CHATCupboard", this, player.UserIDString));
				}				
			}		
			else if (permission.UserHasPermission(player.UserIDString, "xscan.cupboardhome") && entity.GetBuildingPrivilege() && config.Setting.PrefabList.Contains(entity.ShortPrefabName))
			{
				var Cupboard = entity.GetBuildingPrivilege();
				
				foreach (var rplayer in Cupboard.authorizedPlayers)
					ListPlayers.Add(rplayer.userid);
					
				if (ListPlayers.Count != 0)
				{
					if (config.Setting.GUIMessage) GUI(player, entity.OwnerID, ListPlayers, lang.GetMessage("GUICupboard", this, player.UserIDString));
				    if (config.Setting.ChatMessage) ChatMessage(player, entity.OwnerID, ListPlayers, lang.GetMessage("CHATCupboard", this, player.UserIDString));
				}
			}
			else if (permission.UserHasPermission(player.UserIDString, "xscan.codelock") && entity is Door)
			{
				if (entity.GetSlot(BaseEntity.Slot.Lock) is CodeLock)
				{
					var CodeLock = (CodeLock)entity.GetSlot(BaseEntity.Slot.Lock);
				
				    foreach (var rplayer in CodeLock.whitelistPlayers)
						ListPlayers.Add(rplayer);								

				    foreach (var rplayer in CodeLock.guestPlayers)
						if(!ListPlayers.Contains(rplayer))
						    ListPlayers.Add(rplayer);
					
					if (ListPlayers.Count != 0)
					{
						if (config.Setting.GUIMessage) GUI(player, entity.OwnerID, ListPlayers, lang.GetMessage("GUICodelock", this, player.UserIDString));
					    if (config.Setting.ChatMessage) ChatMessage(player, entity.OwnerID, ListPlayers, lang.GetMessage("CHATCodelock", this, player.UserIDString));
					}
				}
			}
			else if (permission.UserHasPermission(player.UserIDString, "xscan.autoturret") && entity is AutoTurret)
			{
				var AutoTurret = entity as AutoTurret;
				
				foreach (var rplayer in AutoTurret.authorizedPlayers)
					ListPlayers.Add(rplayer.userid);

				if (ListPlayers.Count != 0) 
				{
					if (config.Setting.GUIMessage) GUI(player, entity.OwnerID, ListPlayers, lang.GetMessage("GUIAutoturret", this, player.UserIDString));
				    if (config.Setting.ChatMessage) ChatMessage(player, entity.OwnerID, ListPlayers, lang.GetMessage("CHATAutoturret", this, player.UserIDString));
				}
			}
			else
				if (config.Setting.ChatMessage) ChatMessageOwner(player, entity.OwnerID);
				
				 
			if (config.Setting.GUIMessage) GUIOwner(player, entity.OwnerID);

            if (config.Setting.SaveData)
			{
			    StoredData.Add($"{DateTime.Now}", $"{player.displayName} | {player.userID}");	
			    Interface.Oxide.DataFileSystem.WriteObject("XScan/ScanUSE", StoredData);
			}
		}

        private string Player_GetNameID(ulong id)
		{
			var player = covalence.Players.FindPlayerById(id.ToString());
			
			return $"{player.Name} | {player.Id} - {player.IsConnected ? lang.GetMessage("CHATOnline", this, player.Id) : lang.GetMessage("CHATOffline", this, player.Id)}";
		}

		private void ChatMessage(BasePlayer player, ulong ownerid, List<ulong> ListPlayers, string message)
		{
            var owner = covalence.Players.FindPlayerById(ownerid.ToString());

			SendReply(player, string.Format(lang.GetMessage("CHATOwner", this, player.UserIDString), owner.Name, owner.Id, owner.IsConnected ? lang.GetMessage("CHATOnline", this, player.UserIDString) : lang.GetMessage("CHATOffline", this, player.UserIDString)));

            if (ListPlayers.Count != 0)
			{
                SendReply(player, message);

			    foreach (var rplayer in ListPlayers)
				    SendReply(player, $"[ {Player_GetNameID(rplayer)} ]");
			}
		}
		
		private void ChatMessageOwner(BasePlayer player, ulong ownerid)
		{
			var owner = covalence.Players.FindPlayerById(ownerid.ToString());

			SendReply(player, string.Format(lang.GetMessage("CHATOwner", this, player.UserIDString), owner.Name, owner.Id, owner.IsConnected ? lang.GetMessage("CHATOnline", this, player.UserIDString) : lang.GetMessage("CHATOffline", this, player.UserIDString)));
		}
        
        #endregion			
		 
		#region GUI

		private void GUI(BasePlayer player, ulong ownerid, List<ulong> ListPlayers, string message)
		{		
			CuiHelper.DestroyUi(player, ".Overlay");
            CuiElementContainer container = new CuiElementContainer();
			
			int maxcountstring = config.GUISetting.MaxCountString;
			int maxcount = config.GUISetting.MaxCount;
			int count1 = ListPlayers.Count > maxcount ? maxcount : ListPlayers.Count;
			int count = count1 < maxcountstring ? count1 : maxcountstring;
			int autcount = AuthorizedCount(count1);
			
			container.Add(new CuiPanel
            {
				RectTransform = { AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = $"{-105 * count - ((1 + (0.5 * (count - 1))) * 5)} 230", OffsetMax = $"{105 * count + ((1 + (0.5 * (count - 1))) * 5)} {230 + (70 * autcount) - (--autcount * 5)}" },
                Image = { FadeIn = 0.75f, Color = "0.317 0.321 0.309 0.95", Material = "assets/content/ui/uibackgroundblur.mat" }
            }, "Hud", ".Overlay");
			
			container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-325 0", OffsetMax = "325 25" },
                Text = { FadeIn = 0.75f, Text = message, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 13, Color = "1 1 1 0.75" }
            }, ".Overlay");
			
			int x = 0, y = 0;
			
			foreach(var players in ListPlayers.Take(maxcount))
			{
				var targetplayers = covalence.Players.FindPlayerById(players.ToString());
				
				container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = $"{-105 - (105 * (count + (count * 0.025 - 0.025) - 1)) + (x * 215)} {-65 - (y * 65)}", OffsetMax = $"{105 - (105 * (count + (count * 0.025 - 0.025) - 1)) + (x * 215)} {-5 - (y * 65)}" },
                    Image = { FadeIn = 0.75f, Color = "0.55 0.55 0.55 0.75" }
                }, ".Overlay", ".GUI");
				
			    container.Add(new CuiElement
            	{
                    Parent = ".GUI",
                    Components =
                    {
					    new CuiRawImageComponent { FadeIn = 0.75f, Png = (string) ImageLibrary.Call("GetImage", targetplayers.Id) },
                    	new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 5", OffsetMax = "-155 -5" }
                	}
            	});
			
				container.Add(new CuiLabel
            	{
                	RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "60 0", OffsetMax = "0 -5" },
                	Text = { FadeIn = 0.75f, Text = string.Format(lang.GetMessage("GUIInfoPlayer", this, player.UserIDString), targetplayers.Name, targetplayers.Id), Align = TextAnchor.UpperLeft, Font = "robotocondensed-regular.ttf", FontSize = 12, Color = "1 1 1 0.75" }
            	}, ".GUI");			
			
				container.Add(new CuiLabel
            	{
                	RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "60 5", OffsetMax = "0 -5" },
                	Text = { FadeIn = 0.75f, Text = targetplayers.Id == ownerid.ToString() ? lang.GetMessage("GUIOwner", this, player.UserIDString) : "", Align = TextAnchor.LowerLeft, Font = "robotocondensed-regular.ttf", FontSize = 12, Color = "1 1 1 0.75" }
            	}, ".GUI");			
			
				container.Add(new CuiLabel
            	{
                	RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "60 5", OffsetMax = "-5 0" },
                	Text = { FadeIn = 0.75f, Text = targetplayers.IsConnected ? lang.GetMessage("GUIOnline", this, player.UserIDString) : lang.GetMessage("GUIOffline", this, player.UserIDString), Align = TextAnchor.LowerRight, Font = "robotocondensed-regular.ttf", FontSize = 12, Color = "1 1 1 0.75" }
            	}, ".GUI");
				
				x++;
                if (x == maxcountstring)
                {
                    x = 0;
                    y++;
					
					count = count1 - (count * y);
					
					if (count > maxcountstring)
					    count = maxcountstring;
                }
			}		
			
			CuiHelper.AddUi(player, container);
			
			timer.Once(config.GUISetting.GUIActive, () => { CuiHelper.DestroyUi(player, ".Overlay"); });
		}

        private void GUIOwner(BasePlayer player, ulong ownerid)
		{
			var owner = covalence.Players.FindPlayerById(ownerid.ToString());
			
			CuiHelper.DestroyUi(player, ".OverlayOwner");
            CuiElementContainer container = new CuiElementContainer();
			
			container.Add(new CuiPanel
            {
				RectTransform = { AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "-110 130", OffsetMax = "110 200" },
                Image = { FadeIn = 0.75f, Color = "0.317 0.321 0.309 0.95", Material = "assets/content/ui/uibackgroundblur.mat" }
            }, "Hud", ".OverlayOwner");
			
			container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 5", OffsetMax = "-5 -5" },
                Image = { FadeIn = 0.75f, Color = "0.55 0.55 0.55 0.75" }
            }, ".OverlayOwner", ".GUIOwner");
			
			container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-325 0", OffsetMax = "325 25" },
                Text = { FadeIn = 0.75f, Text = lang.GetMessage("GUIOwnerC", this, player.UserIDString), Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 13, Color = "1 1 1 0.75" }
            }, ".OverlayOwner");
			
			container.Add(new CuiElement
            {
                Parent = ".GUIOwner",
                Components =
                {
					new CuiRawImageComponent { FadeIn = 0.75f, Png = (string) ImageLibrary.Call("GetImage", owner.Id) },
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 5", OffsetMax = "-155 -5" }
                }
            });
			
			container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "60 0", OffsetMax = "0 -5" },
                Text = { FadeIn = 0.75f, Text = string.Format(lang.GetMessage("GUIInfoPlayer", this, player.UserIDString), owner.Name, owner.Id), Align = TextAnchor.UpperLeft, Font = "robotocondensed-regular.ttf", FontSize = 12, Color = "1 1 1 0.75" }
            }, ".GUIOwner");			
			
			container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "60 5", OffsetMax = "0 -5" },
                Text = { FadeIn = 0.75f, Text = owner.Id == ownerid.ToString() ? lang.GetMessage("GUIOwner", this, player.UserIDString) : "", Align = TextAnchor.LowerLeft, Font = "robotocondensed-regular.ttf", FontSize = 12, Color = "1 1 1 0.75" }
            }, ".GUIOwner");			
			
			container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "60 5", OffsetMax = "-5 0" },
                Text = { FadeIn = 0.75f, Text = owner.IsConnected ? lang.GetMessage("GUIOnline", this, player.UserIDString) : lang.GetMessage("GUIOffline", this, player.UserIDString), Align = TextAnchor.LowerRight, Font = "robotocondensed-regular.ttf", FontSize = 12, Color = "1 1 1 0.75" }
            }, ".GUIOwner");
			
			CuiHelper.AddUi(player, container);
			
			timer.Once(config.GUISetting.GUIActive, () => { CuiHelper.DestroyUi(player, ".OverlayOwner"); });
		}

        #endregion

		#region Lang

        void InitializeLang()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["GUIOwner"] = "OWNER",									
                ["GUIOwnerC"] = "OWNER CONSTRUCTION",									
                ["GUIOnline"] = "<color=#7CFC00>ONLINE</color>",									
                ["GUIOffline"] = "<color=#FF0000>OFFLINE</color>",									
                ["GUIInfoPlayer"] = "NAME: {0}\nID: {1}",									
                ["GUICupboard"] = "LIST OF AUTHORIZED PLAYERS IN CUPBOARD",									
                ["GUICodelock"] = "LIST OF AUTHORIZED PLAYERS IN CODE LOCK",									
                ["GUIAutoturret"] = "LIST OF AUTHORIZED PLAYERS IN AUTO TURRET",									
                ["CHATOwner"] = "<color=#00BFFF>Owner construction:</color>\n[ {0} | {1} - {2} ]",																		
                ["CHATOnline"] = "<color=#7CFC0090>ONLINE</color>",																		
                ["CHATOffline"] = "<color=#FF000090>OFFLINE</color>",																		
                ["CHATCupboard"] = "<color=#7FFF00>List of authorized players in cupboard</color>",																		
                ["CHATCodelock"] = "<color=#7FFF00>List of authorized players in code lock</color>",																		
                ["CHATAutoturret"] = "<color=#7FFF00>List of authorized players in auto turret</color>",																	
                ["CHATCD"] = "Will be available through - {0}",																		
                ["CHATNP"] = "No permission!",
				["CHATSC"] = "Scans left - {0}!",	
				["CHATNSC"] = "No scans!",
                ["CupboardInfo"] = "<color=#FFFF0095>{0}</color>"			
            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["GUIOwner"] = "ВЛАДЕЛЕЦ",									
                ["GUIOwnerC"] = "ВЛАДЕЛЕЦ КОСТРУКЦИИ",									
                ["GUIOnline"] = "<color=#7CFC00>В СЕТИ</color>",									
                ["GUIOffline"] = "<color=#FF0000>НЕ В СЕТИ</color>",									
                ["GUIInfoPlayer"] = "ИМЯ: {0}\nID: {1}",									
                ["GUICupboard"] = "СПИСОК АВТОРИЗОВАННЫХ ИГРОКОВ В ШКАФУ",									
                ["GUICodelock"] = "СПИСОК АВТОРИЗОВАННЫХ ИГРОКОВ В ЗАМКЕ",									
                ["GUIAutoturret"] = "СПИСОК АВТОРИЗОВАННЫХ ИГРОКОВ В ТУРЕЛИ",									
                ["CHATOwner"] = "<color=#00BFFF>Владелец конструкции:</color>\n[ {0} | {1} - {2} ]",																		
                ["CHATOnline"] = "<color=#7CFC0090>В СЕТИ</color>",																		
                ["CHATOffline"] = "<color=#FF000090>НЕ В СЕТИ</color>",																		
                ["CHATCupboard"] = "<color=#7FFF00>Список авторизованных игроков в шкафу</color>",																		
                ["CHATCodelock"] = "<color=#7FFF00>Список авторизованных игроков в замке</color>",																		
                ["CHATAutoturret"] = "<color=#7FFF00>Список авторизованных игроков в турели</color>",																		
                ["CHATCD"] = "Будет доступно через - {0}",																		
                ["CHATNP"] = "Недостаточно прав!",	
                ["CHATSC"] = "Осталось сканов - {0}!",	
                ["CHATNSC"] = "Недостаточно сканов!",	
                ["CupboardInfo"] = "<color=#FFFF0095>{0}</color>"		
            }, this, "ru");
        }

        #endregion		
	}
}

// --- End of file: XScan.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HelicopterInstantTakeoff.cs ---
// --- Original Local Path: HelicopterInstantTakeoff.cs ---

using Oxide.Core;
using System;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Helicopter Instant Takeoff", "bsdinis", "0.0.9")]
    [Description("Allows helicopters to takeoff instantly when the engine starts.")]
    class HelicopterInstantTakeoff : RustPlugin
    {
        void Init()
        {
            try
            {
                config = Config.ReadObject<ConfigData>();
                if (config == null)
                {
                    throw new Exception();
                }
                else
                {
                    SaveConfig();
                }
            }
            catch
            {
                PrintError("CONFIG FILE IS INVALID!\nCheck config file and reload HelicopterInstantTakeoff.");
                Interface.Oxide.UnloadPlugin(Name);
                return;
            }

            if (!string.IsNullOrWhiteSpace(config.AirPermission) && !permission.PermissionExists(config.AirPermission))
            {
                permission.RegisterPermission(config.AirPermission, this);
            }
            if (!string.IsNullOrWhiteSpace(config.GroundPermission) && !permission.PermissionExists(config.GroundPermission))
            {
                permission.RegisterPermission(config.GroundPermission, this);
            }
        }

        ConfigData config;
        class ConfigData
        {
            public string AirPermission;
            public string GroundPermission;
        }

        protected override void LoadDefaultConfig()
        {
            config = new ConfigData
            {
                AirPermission = "helicopterinstanttakeoff.air",
                GroundPermission = "helicopterinstanttakeoff.ground"
            };
        }

        protected override void SaveConfig() => Config.WriteObject(config, true);

        bool DriverHasPermission(PlayerHelicopter heli, string perm)
        {
            List<BaseVehicle.MountPointInfo> mountPoints = heli.mountPoints;
            if (mountPoints == null || mountPoints.Count < 1)
            {
                return false;
            }
            BaseMountable mountable = mountPoints[0].mountable;
            if (mountable == null)
            {
                return false;
            }
            BasePlayer player = mountable._mounted;
            if (player == null || (!string.IsNullOrWhiteSpace(perm) && !permission.UserHasPermission(player.UserIDString, perm)))
            {
                return false;
            }
            return true;
        }

        object OnEngineStart(PlayerHelicopter heli)
        {
            if (!DriverHasPermission(heli, (!heli.Grounded() ? config.AirPermission : config.GroundPermission)))
            {
                return null;
            }
            heli.engineController.FinishStartingEngine();
            return false;
        }
    }
}

// --- End of file: HelicopterInstantTakeoff.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/AnimalRemover.cs ---
// --- Original Local Path: AnimalRemover.cs ---

using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("AnimalRemover", "Ankawi", "1.0.2")]
    [Description("Allows you to disable specific animals from spawning on the server")]
    public class AnimalRemover : RustPlugin
    {
        const string BearPrefab = "assets/bundled/prefabs/autospawn/animals/bear.prefab";
        const string BoarPrefab = "assets/bundled/prefabs/autospawn/animals/boar.prefab";
        const string ChickenPrefab = "assets/bundled/prefabs/autospawn/animals/chicken.prefab";
        const string HorsePrefab = "assets/bundled/prefabs/autospawn/animals/horse.prefab";
        const string StagPrefab = "assets/bundled/prefabs/autospawn/animals/stag.prefab";
        const string WolfPrefab = "assets/bundled/prefabs/autospawn/animals/wolf.prefab";

        new void LoadConfig()
        {
            SetConfig("Disable Bear Spawning", false);
            SetConfig("Disable Boar Spawning", false);
            SetConfig("Disable Chicken Spawning", false);
            SetConfig("Disable Horse Spawning", false);
            SetConfig("Disable Stag Spawning", false);
            SetConfig("Disable Wolf Spawning", false);

            SaveConfig();
        }
        protected override void LoadDefaultConfig() => PrintWarning("Creating a new configuration file...");

        void OnServerInitialized()
        {
            LoadConfig();
            KillAnimals();
        }

        Dictionary<string, IGrouping<string, BaseEntity>> GetAnimals()
        {
            return Resources.FindObjectsOfTypeAll<BaseNPC>()
                .Where(c => c.isActiveAndEnabled)
                .Cast<BaseEntity>()
                .GroupBy(c => c.ShortPrefabName).ToDictionary(c => c.Key, c => c);
        }

        void KillAnimals()
        {
            var animalList = GetAnimals();
            foreach (var g in animalList)
            {
                foreach (var animal in g.Value)
                {
                    if ((bool)Config["Disable Bear Spawning"])
                    {
                        if (animal.PrefabName.Contains(BearPrefab))
                        {
                            animal.Kill();
                        }
                    }
                    if ((bool)Config["Disable Boar Spawning"])
                    {
                        if (animal.PrefabName.Contains(BoarPrefab))
                        {
                            animal.Kill();
                        }
                    }
                    if ((bool)Config["Disable Chicken Spawning"])
                    {
                        if (animal.PrefabName.Contains(ChickenPrefab))
                        {
                            animal.Kill();
                        }
                    }
                    if ((bool)Config["Disable Horse Spawning"])
                    {
                        if (animal.PrefabName.Contains(HorsePrefab))
                        {
                            animal.Kill();
                        }
                    }
                    if ((bool)Config["Disable Stag Spawning"])
                    {
                        if (animal.PrefabName.Contains(StagPrefab))
                        {
                            animal.Kill();
                        }
                    }
                    if ((bool)Config["Disable Wolf Spawning"])
                    {
                        if (animal.PrefabName.Contains(WolfPrefab))
                        {
                            animal.Kill();
                        }
                    }
                }
            }
        }
        void OnEntitySpawned(BaseNetworkable entity)
        {
            KillAnimals();
        }
        void SetConfig(params object[] args)
        {
            List<string> stringArgs = (from arg in args select arg.ToString()).ToList<string>();
            stringArgs.RemoveAt(args.Length - 1);

            if (Config.Get(stringArgs.ToArray()) == null) Config.Set(args);
        }
    }
}

// --- End of file: AnimalRemover.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/CraftMenu.cs ---
// --- Original Local Path: CraftMenu.cs ---

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Globalization;
using System.Linq;
using System.Text;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using UnityEngine;
using Oxide.Game.Rust.Cui;
using Facepunch;
using Network;
using VLB;

namespace Oxide.Plugins
{
    [Info("CraftMenu", "David", "1.0.91")]
    [Description("Simple craft menu for uncraftable items.")]

    public class CraftMenu : RustPlugin
    {   
        #region [Fields]

        int _bpsTotal = 0;
        int _bpsDefault = 0;
        string click = "assets/bundled/prefabs/fx/notice/item.select.fx.prefab";
        string pageChange = "assets/bundled/prefabs/fx/notice/loot.copy.fx.prefab";
        string research = "assets/prefabs/deployable/research table/effects/research-success.prefab";
        string craft = "assets/bundled/prefabs/fx/notice/loot.start.fx.prefab";


        //category button anchors
        string[] ca = {
            "0.01 0", "0.075 1", //default all cat
            "0.09 0", "0.19 1",
            "0.19 0", "0.29 1",
            "0.29 0", "0.39 1",
            "0.39 0", "0.49 1",
            "0.49 0", "0.59 1",
            "0.59 0", "0.69 1" 
        };
        //assets img anchors
        string[] ia = {
            "0.22 0.17", "0.78 0.83",   // default
            "0.22 0.17", "0.78 0.83",   // assets/icons/construction.png = 0 1
            "0.24 0.14", "0.76 0.82",   // assets/icons/clothing.png = 2 3 
            "0.24 0.14", "0.76 0.82",   // assets/icons/bullet.png = 4 5
            "0.24 0.14", "0.76 0.82"    // assets/icons/medical.png = 6 7
        };
        //blueprint anchors
        private string[] ba = {
            "indexing",
            "0.0 0.85", "1 1",
            "0.0 0.69", "1 0.84",
            "0.0 0.53", "1 0.68",
            "0.0 0.36", "1 0.52",
            "0.0 0.2", "1 0.35",
            "0.0 0.04", "1 0.19"
        };

        #endregion

        #region [Hooks]

        private void OnServerInitialized()
        {   
            LoadConfig();
            LoadData();
            LoadPlayerData();  
            LoadNamesData(); 
            DownloadImages();
            ImageQueCheck();
            //update config for 1.0.4
            if (config.main.perms == null)
            {
                config.main.perms = false;
                SaveConfig();
            }
            //check config
            if (config.ct == null)
            {   
                Puts($"\n*******************************************************************\nConfig update is required. Make backup of your old one, delete it from config folder and reload plugin again.\n*******************************************************************");
                Interface.Oxide.UnloadPlugin("CraftMenu");
                return;
            }

            RegisterPerms();

            permission.RegisterPermission($"craftmenu.use", this); 

            //count bps
            _bpsTotal = bps.Count(); 
            foreach (string bp in bps.Keys)
            {
                if (bps[bp].ResearchCost == 0)
                _bpsDefault++;
            }

            AddMonoComponent();
        }

        void Unload() 
        { 
            foreach (var _player in BasePlayer.activePlayerList)
                DestroyCui(_player); 

            DestroyMonoComponent();
        }

        void OnNewSave()
        {   
            if (config.main.wipe)
                playerBps.Clear();

            SavePlayerData();
        }

        void OnPlayerDisconnected(BasePlayer player)
        {   
            if (!config.ct.craftQue) return;
            var run = player.GetComponent<CraftingQue>(); 
            if (run == null) 
                return;
            else
                run.CancelAll(player);
         
            UnityEngine.Object.Destroy(run);
        }

        void OnPlayerConnected(BasePlayer player) 
        {   
            if (config.ct.craftQue)
                player.gameObject.GetOrAddComponent<CraftingQue>();   
        }
        

        void OnEntityDeath(BasePlayer player, HitInfo info)
        {   
            if (player == null) return;
            if (!config.ct.craftQue) return;

            var run = player.GetComponent<CraftingQue>(); 
            if (run == null) 
                return;
            else
                run.CancelAll(player);
        }
    
        private void OnLootEntity(BasePlayer player, Workbench bench)
        {     
            
            if (!permission.UserHasPermission(player.UserIDString, "craftmenu.use")) return;

            if (!config.ct.craftQue)
                player.gameObject.GetOrAddComponent<CraftingQue>();

            if (!playerBps.ContainsKey(player.userID))
            {
                playerBps.Add(player.userID, new PlayerBps());  
                SavePlayerData();
            }
            if (bench.PrefabName.Contains("1"))  {
                CreateBaseCui(player, 1);   
                ShowBps(player, 1, "all");
            }   
            if (bench.PrefabName.Contains("2"))   {
                CreateBaseCui(player, 2);
                ShowBps(player, 2, "all"); 
            }
            if (bench.PrefabName.Contains("3"))   {  
                CreateBaseCui(player, 3);
                ShowBps(player, 3, "all");
            }
        }

        private void OnLootEntityEnd(BasePlayer player, Workbench bench)
        {      
            DestroyCui(player); 
        }

        #endregion

        #region [Functions/Methods]

        private void RegisterPerms()
        {   
            if (config.main.perms)
            {
                foreach (string item in config.main.cat.Keys)
                    permission.RegisterPermission($"craftmenu.{item}", this);   
            }
        }

        [ConsoleCommand("craftmenu_admin")]
        private void craftmenu_admin(ConsoleSystem.Arg arg)
        {
            var player = arg?.Player();
            var args = arg.Args;
            if (arg.Player() != null) 
            {
                if (!player.IsAdmin)
                    return;   
            }
            
            if (args[0] == "wipe")
            {
                if (args.Length > 1) 
                {   
                    if (!playerBps.ContainsKey(Convert.ToUInt64(args[1])))
                    {
                        Puts($"Player {args[1]} have no blueprints to wipe.");
                        return;
                    }

                    playerBps.Remove(Convert.ToUInt64(args[1]));
                    Puts($"BPs for player {args[1]} wiped.");
                    return;
                }

                Puts($"Blueprints has been wiped.");
                playerBps.Clear();
                SavePlayerData();
                return;
            } 
        }

        [ConsoleCommand("craftmenu_cmd")]
        private void craftmenu_cmd(ConsoleSystem.Arg arg)
        {
            var player = arg?.Player();
            var args = arg.Args;
            if (arg.Player() == null) return;
            if (args == null) return;

            if (args[0] == "select")
            {                      //tier selection     //shortname   //position index        //selection highlight
                CreateBp(player, Convert.ToInt32(args[1]), args[2], Convert.ToInt32(args[3]), true);
                PlayFx(player, click);
                return;
            }
            if (args[0] == "category")
            {
                ShowBps(player, Convert.ToInt32(args[2]), args[1]);
                PlayFx(player, pageChange);
                return;
            }
            if (args[0] == "pageup")
            {   
                if (Convert.ToInt32(args[3]) < 0) return;
                               //tier                //category   //page
                ShowBps(player, Convert.ToInt32(args[2]), args[1], Convert.ToInt32(args[3]));
                PlayFx(player, pageChange);
                return;  
            }
            if (args[0] == "pagedown")
            {                   //tier                //category   //page
                ShowBps(player, Convert.ToInt32(args[2]), args[1], Convert.ToInt32(args[3]));
                PlayFx(player, pageChange);
                return;
            }
            if (args[0] == "craft")
            {                       //tier                  //shortname         //index      
                CraftItem(player, Convert.ToInt32(args[1]), args[2], Convert.ToInt32(args[3]));
                return;
            }

            if (args[0] == "research")
            {                                   //tier          //shortname         //index      
                ResearchItem(player, Convert.ToInt32(args[1]), args[2], Convert.ToInt32(args[3]));
                return;                
            }
        }
        
        private List<string> CreateBpOrder(BasePlayer player, int tier, string category)
        {   
            List<string> bpOrder = new List<string>();
            List<string> lockedBps = new List<string>();
            //add available blueprints
            foreach (string item in bps.Keys)
            {   
                if (category == "all")
                {
                    if (playerBps[player.userID].bp.Contains(item))
                    {   
                        if (bps[item].Tier <= tier)
                        {
                            //bpOrder.Add(item);
                            bpOrder.Insert(0, item);
                        }
                        else 
                        {
                            bpOrder.Add(item);
                        }
                        continue;
                    }
                    else
                    {
                        lockedBps.Add(item);
                        continue;
                    }
                }
                if (bps[item].Category == category)
                {
                    if (playerBps[player.userID].bp.Contains(item))
                    {   
                        if (bps[item].Tier <= tier)
                        {
                            //bpOrder.Add(item);
                            bpOrder.Insert(0, item);
                        }
                        else 
                        {
                            bpOrder.Add(item);
                        }
                    }
                    else
                    {
                        lockedBps.Add(item);
                        continue;
                    }
                }
            }
            //add locked blueprints at last
            foreach (string item in lockedBps)
            {
                bpOrder.Add(item);
            }
            //insert index string
            bpOrder.Insert(0, "null");

            return bpOrder;
        }

        private bool CheckInv(BasePlayer player, string shortName, int amount)
        {
            var itemDef = ItemManager.FindItemDefinition(shortName);
            if (itemDef == null) return false;
           
            int invAmount = player.inventory.GetAmount(itemDef.itemid);
            if (invAmount < amount) return false;
            
            return true;
        }

        private bool _CanCraft(BasePlayer player, string shortName)
        {
            foreach (string item in bps[shortName].Resources.Keys)
            {   
                var itemDef = ItemManager.FindItemDefinition(item);
                int invAmount = player.inventory.GetAmount(itemDef.itemid);
                if (invAmount < bps[shortName].Resources[item]) 
                    return false;
            }
            return true;
        }
    
        private void CraftItem(BasePlayer player, int tier, string shortName, int index)
        {   
            string _shortname = shortName;
            if (shortName.Contains("{"))
            {
                int charsToRemove = shortName.Length - shortName.IndexOf("{");
                _shortname = shortName.Remove(shortName.Length - charsToRemove);
            }

            if (!_CanCraft(player, shortName))
            {//check resources
                //refresh craft button
                CreateBp(player, tier, shortName, index, true);
                PlayFx(player, click);
                return;
            }
            else
            {
                foreach (string _item in bps[shortName].Resources.Keys)
                {//take resources 
                    var itemDef = ItemManager.FindItemDefinition(_item);
                    if (itemDef == null)
                    {
                        SendReply(player, $" <color=#C2291D>!</color> '{_item}' <color=#C2291D>is not correct shortname.</color>");
                        return;
                    }
                    player.inventory.Take(null, itemDef.itemid, bps[shortName].Resources[_item]);
                }

                var item = ItemManager.CreateByName(_shortname, 1, bps[shortName].SkinID);
                if (item != null)
                {//give crafted item

                    if (config.ct.craftQue) 
                    {
                        var run = player.GetComponent<CraftingQue>(); 
                        if (run != null)
                            run.AddToQue(player, shortName); 
                        else
                            RefundItem(player, shortName);

                        PlayFx(player, craft);
                    }
                    else
                    {   
                        item.name = bps[shortName].Name;
                        player.GiveItem(item);
                        CreateBp(player, tier, shortName, index, true);
                        PlayFx(player, craft);
                        return;
                    }
                }
                else
                {
                    SendReply(player, $" <color=#C2291D>!</color> '{item}' <color=#C2291D>is not correct shortname.</color>");
                    return;
                }
            }
        }

        private void ResearchItem(BasePlayer player, int tier, string shortName, int index)
        {  
            if (!CheckInv(player, "scrap", bps[shortName].ResearchCost))
            {//check resources
                //refresh craft button
                CreateBp(player, tier, shortName, index, true);
                PlayFx(player, click);
                return;
            }
            else
            { 
                var itemDef = ItemManager.FindItemDefinition("scrap");
                if (itemDef == null)
                {
                    SendReply(player, $" <color=#C2291D>!</color> Error, please contact developer.</color>");
                    return;
                }
                player.inventory.Take(null, itemDef.itemid, bps[shortName].ResearchCost);
                playerBps[player.userID].bp.Add(shortName);
                SavePlayerData();
                CreateBp(player, tier, shortName, index, true);
                PlayFx(player, research);
            }
            
        }

        private void RefundItem(BasePlayer player, string shortName)
        {
            foreach (string item in bps[shortName].Resources.Keys)
            {   
                var _item = ItemManager.CreateByName($"{item}", bps[shortName].Resources[item]);
                player.GiveItem(_item);
            }
        }

        private void CreateItemMono(BasePlayer player, string shortName)
        {   
            string _shortname = shortName;
            if (shortName.Contains("{"))
            {
                int charsToRemove = shortName.Length - shortName.IndexOf("{");
                _shortname = shortName.Remove(shortName.Length - charsToRemove);
            }

            var item = ItemManager.CreateByName(_shortname, 1, bps[shortName].SkinID);
            if (item != null)
            {
                item.name = bps[shortName].Name;
                player.GiveItem(item);
            }
            
        }

        [ConsoleCommand("craftmenu_cancel")]
        private void craftmenu_cancel(ConsoleSystem.Arg arg)
        {
            var player = arg?.Player();
            if (arg.Player() == null) return;
            var args = arg.Args;
            if (args[0] == null) return;
            int index = Convert.ToInt32(args[0]);

            var run = player.GetComponent<CraftingQue>(); 
            if (run == null) player.gameObject.GetOrAddComponent<CraftingQue>();
            if (run != null) { 
                run.CancelCraft(player, index);
            }
        }

        [ConsoleCommand("craftmenu_addtoque")]
        private void craftmenu_addtoque(ConsoleSystem.Arg arg)
        {   
            
            var player = arg?.Player();
            if (arg.Player() == null) return;
            if (!player.IsAdmin) return;
            var args = arg.Args;
            if (args[0] == null) return;

            var run = player.GetComponent<CraftingQue>(); 
            if (run == null) player.gameObject.GetOrAddComponent<CraftingQue>();
            if (run != null) run.AddToQue(player, args[0]);
        
        }


        [ConsoleCommand("craftmenu_openquepanel")]
        private void craftmenu_openquepanel(ConsoleSystem.Arg arg)
        {   
            var player = arg?.Player();
            if (arg.Player() == null) return;
            
            var run = player.GetComponent<CraftingQue>(); 
            if (run == null) player.gameObject.GetOrAddComponent<CraftingQue>();
            if (run != null) run.OpenQuePanel(player);
        }

        private void PlayFx(BasePlayer player, string fx)
        {   
            if (!config.main.fx) return;     
            if (player == null) return;
            var EffectInstance = new Effect();
            EffectInstance.Init(Effect.Type.Generic, player, 0, Vector3.up, Vector3.zero);
            EffectInstance.pooledstringid = StringPool.Get(fx);
            Network.Net.sv.write.Start();
            Network.Net.sv.write.PacketID(Message.Type.Effect);
            EffectInstance.WriteToStream(Network.Net.sv.write);
            Network.Net.sv.write.Send(new SendInfo(player.net.connection));
            EffectInstance.Clear();
        }

        #endregion

        #region [MonoBehaviour]

        static CraftMenu plugin;

        private void Init() => plugin = this; 

        private void AddMonoComponent()
        {
            foreach (var _player in BasePlayer.activePlayerList) 
                _player.gameObject.GetOrAddComponent<CraftingQue>();      
        }

        private void DestroyMonoComponent()
        {
            foreach (var _player in BasePlayer.activePlayerList)
            {   
                var run = _player.GetComponent<CraftingQue>(); 
                if (run == null) 
                    return;
                else
                    run.CancelAll(_player);
         
               
               UnityEngine.Object.Destroy(run);
            }   
        }

        private class CraftingQue : MonoBehaviour
		{
			BasePlayer player;
            List<string> craftOrder = new List<string>();
            bool craftPanelOpen = false;
            int progress;

			void Awake() => player = GetComponent<BasePlayer>();

            public void CancelAll(BasePlayer player)
            {   
                if (craftOrder.Count != 0) {
                    foreach (string item in craftOrder)
                    {   
                        plugin.RefundItem(player, item);
                    }
                    CuiHelper.DestroyUi(player, "ql_base"); 
                    CancelInvoke(nameof(CraftProgress));
                }
                craftOrder.Clear();
            }

            public void OpenQuePanel(BasePlayer player)
            {   
                if (!craftPanelOpen)
                {
                    plugin.CreateQuePanel(player, craftOrder);
                    craftPanelOpen = true;
                }
                else
                {
                    CuiHelper.DestroyUi(player, "qPanel_panel");
                    craftPanelOpen = false;
                }
            }

            public void CancelCraft(BasePlayer player, int index)
            {   
                plugin.RefundItem(player, craftOrder[index]);
                craftOrder.RemoveAt(index);
                plugin.CreateQueButton(player, craftOrder.Count);
                if (craftOrder.Count <= 0)
                {   
                    CuiHelper.DestroyUi(player, "ql_base"); 
                    CancelInvoke(nameof(CraftProgress));
                }
                else
                {   
                    if (craftPanelOpen)
                        plugin.CreateQuePanel(player, craftOrder);

                    if (craftOrder.Count <= 1)
                    {   
                        CuiHelper.DestroyUi(player, "qPanel_panel");
                    }
                    

                    if (index == 0)
                    {   
                        CancelInvoke(nameof(CraftProgress));
            
                        if (plugin.config.ct.excp.ContainsKey(craftOrder[0]))
                            progress = plugin.config.ct.excp[craftOrder[0]];
                        else
                            progress = plugin.config.ct.defaultTime;

                        InvokeRepeating(nameof(CraftProgress), 1f, 1f);
                    }
                }
                
            }
            
            void CraftProgress()
            {   

                progress -= 1;
                plugin.CreateTimer(player, craftOrder[0], progress);

                if (progress <= 0)
                {   
                    plugin.CreateItemMono(player, craftOrder[0]);
                    craftOrder.RemoveAt(0);
                    int itemsLeft = craftOrder.Count();

                    if (itemsLeft <= 1) {
                        CuiHelper.DestroyUi(player, "ql_base_quetext_btn");
                        CuiHelper.DestroyUi(player, "qPanel_panel");
                    }
                    else {
                        plugin.CreateQueButton(player, itemsLeft);
                        if (craftPanelOpen)
                            plugin.CreateQuePanel(player, craftOrder);
                    }

                    if(itemsLeft <= 0) {
                        CancelInvoke(nameof(CraftProgress));
                        CuiHelper.DestroyUi(player, "ql_base"); 
                    }
                    else 
                    {   
                        CuiHelper.DestroyUi(player, "qTimer");
                        CuiHelper.DestroyUi(player, "qTimerName");
                        if (plugin.config.ct.excp.ContainsKey(craftOrder[0]))
                            progress = plugin.config.ct.excp[craftOrder[0]];
                        else
                            progress = plugin.config.ct.defaultTime;
                    }
                        
                }  
            }
            
            public void AddToQue(BasePlayer player, string itemName)
			{   
                if (player == null) return;

                
                if (craftOrder == null)
                {
                    //ignore
                }
                craftOrder.Add(itemName);
               
                if (IsInvoking(nameof(CraftProgress)) == false) 
                {   
                    if (plugin.config.ct.excp.ContainsKey(craftOrder[0]))
                            progress = plugin.config.ct.excp[craftOrder[0]];
                        else
                            progress = plugin.config.ct.defaultTime;
                    InvokeRepeating(nameof(CraftProgress), 0.1f, 1f);
                    

                        plugin.CreateCraftQueLayout(player);
                }
                if (craftOrder.Count > 1)
                {
                    plugin.CreateQueButton(player, craftOrder.Count);

                    if (craftPanelOpen)
                        plugin.CreateQuePanel(player, craftOrder);
                }

			}

        }
        
        #endregion

        #region [UI]

        private void CreateBaseCui(BasePlayer player, int tier = 1)
        {   
            var _baseCraftCui = CUIClass.CreateOverlay("empty", "0 0 0 0", "0 0", "0 0", false, 0.0f, "assets/icons/iconmaterial.mat"); //assets/content/ui/uibackgroundblur.mat
            //offset
            CUIClass.CreatePanel(ref _baseCraftCui, "baseCraft_main", "Overlay", "0 0 0 0", "0.5 0.5", "0.5 0.5", false, 0.1f, 0f, "assets/icons/iconmaterial.mat", "193 -104", "573 266");
                //title
                CUIClass.CreateText(ref _baseCraftCui, "baseCraft_title_text", "baseCraft_main", "1 1 1 0.6", $"<size=21><b>BLUEPRINTS</b></size>", 12, "0.00 1", "1 1.2", TextAnchor.LowerLeft, $"robotocondensed-regular.ttf", 0.1f);  
                CUIClass.CreateText(ref _baseCraftCui, "baseCraft_title_count", "baseCraft_main", "1 1 1 0.6", $"UNLOCKED {playerBps[player.userID].bp.Count() + _bpsDefault}/{_bpsTotal}", 12, "0.00 1.01", "0.99 1.2", TextAnchor.LowerRight, $"robotocondensed-regular.ttf", 0.1f);  
                //categories
                CUIClass.CreatePanel(ref _baseCraftCui, "baseCraft_category_panel", "baseCraft_main", "0.70 0.67 0.65 0.17", "0.0 0.93", "1 1", true, 0.1f, 0f, "assets/content/ui/uibackgroundblur.mat"); 
                    //all default
                    CUIClass.CreateButton(ref _baseCraftCui, "baseCraft_category_btnAll", "baseCraft_category_panel", "0.70 0.67 0.65 0.0", "", 11, ca[0], ca[1], $"craftmenu_cmd category all {tier}", "", "1 1 1 0.7", 0.1f, TextAnchor.MiddleCenter, $"robotocondensed-bold.ttf", "assets/icons/iconmaterial.mat");
                        CUIClass.PullFromAssets(ref _baseCraftCui, "bc_ci_all", "baseCraft_category_btnAll", "1 1 1 0.5", "assets/icons/community_servers.png", 0.1f, 0f, "0.1 0.15", "0.96 0.83");
                    //optional
                    int index = 1;
                    foreach (string category in config.main.cat.Keys)
                    {   
                        int a1 = 0 + index;
                        int a2 = 1 + index;
                        if (index == 1) { a1 = 2; a2 = 3; }
                        if (index == 2) { a1 = 4; a2 = 5; }
                        if (index == 3) { a1 = 6; a2 = 7; }
                        if (index == 4) { a1 = 8; a2 = 9; }
                        if (index == 5) { a1 = 10; a2 = 11; }
                        if (index == 6) { a1 = 12; a2 = 13; }

                        CUIClass.CreateButton(ref _baseCraftCui, $"baseCraft_category_btn{index}", "baseCraft_category_panel", "0.70 0.67 0.65 0.0", "", 11, ca[a1], ca[a2], $"craftmenu_cmd category {category} {tier}", "", "1 1 1 0.7", 0.1f, TextAnchor.MiddleCenter, $"robotocondensed-bold.ttf", "assets/icons/iconmaterial.mat");
                        
                        if (config.main.cat[category].StartsWith("assets"))
                        {   
                            int b1 = 0; int b2 = 1;
                            if (config.main.cat[category] == "assets/icons/construction.png") {b1 = 2; b2 = 3;}
                            if (config.main.cat[category] == "assets/icons/clothing.png") {b1 = 4; b2 = 5;}
                            if (config.main.cat[category] == "assets/icons/bullet.png") {b1 = 6; b2 = 7;}
                            if (config.main.cat[category] == "assets/icons/medical.png") {b1 = 8; b2 = 9;}
                            
                            CUIClass.PullFromAssets(ref _baseCraftCui, $"category_btn_asset{index}", $"baseCraft_category_btn{index}", "1 1 1 0.4", config.main.cat[category], 0.1f, 0f, ia[b1], ia[b2]);
                        }
                        else
                            CUIClass.CreateImage(ref _baseCraftCui, $"category_btn_asset{index}", $"baseCraft_category_btn{index}", Img($"{config.main.cat[category]}"), "0 0", "1 1", 0.1f);
                
                        index++;
                    }
                //blueprint container
                CUIClass.CreatePanel(ref _baseCraftCui, "baseCraft_blueprints_panel", "baseCraft_main", "0.70 0.67 0.65 0.0", "0.0 0.0", "1 0.92", false, 0.1f, 0f, "assets/icons/iconmaterial.mat"); 
           
            DestroyCui(player); 
            CuiHelper.AddUi(player, _baseCraftCui);
            CuiHelper.DestroyUi(player, "empty");  
        }
        
        private void DestroyCui(BasePlayer player)
        {   
            CuiHelper.DestroyUi(player, "empty"); 
            CuiHelper.DestroyUi(player, "baseCraft_main");
        }

        private void CreatePageBtns(BasePlayer player, string category, int tier, int currentPage)
        {   
            var _pageBtns = CUIClass.CreateOverlay("empty", "0 0 0 0", "0 0", "0 0", false, 0.0f, "assets/icons/iconmaterial.mat"); //assets/content/ui/uibackgroundblur.mat
            int pageup = currentPage - 1;
            int pagedown = 1 + currentPage;

            CUIClass.CreateButton(ref _pageBtns, "craft_page_up", "baseCraft_category_panel", "0.80 0.25 0.16 0.0", "▲", 11, "0.86 0.16", $"0.89 0.84", $"craftmenu_cmd pageup {category} {tier} {pageup}", "", "1 1 1 0.4", 0.1f, TextAnchor.MiddleCenter, $"robotocondensed-bold.ttf", "assets/icons/iconmaterial.mat");
            CUIClass.CreateButton(ref _pageBtns, "craft_page_down", "baseCraft_category_panel", "0.80 0.25 0.16 0.0", "▼", 11, "0.89 0.16", $"0.94 0.84", $"craftmenu_cmd pageup {category} {tier} {pagedown}", "", "1 1 1 0.4", 0.1f, TextAnchor.MiddleCenter, $"robotocondensed-bold.ttf", "assets/icons/iconmaterial.mat");
            CUIClass.CreateText(ref _pageBtns, "bp_page_count", "baseCraft_category_panel", "1 1 1 0.4", $"{currentPage + 1}", 11, "0.94 0.0", "0.98 1", TextAnchor.MiddleCenter, $"robotocondensed-regular.ttf", 0.1f);  
            
            CuiHelper.DestroyUi(player, "craft_page_up"); 
            CuiHelper.DestroyUi(player, "craft_page_down");  
            CuiHelper.DestroyUi(player, "bp_page_count");
            CuiHelper.AddUi(player, _pageBtns); 
            CuiHelper.DestroyUi(player, "empty"); 
        }
    
        private void ShowBps(BasePlayer player, int tier, string category, int page = 0)
        {
            List<string> bpOrder = CreateBpOrder(player, tier, category);
            int index = 6 * page;
            
            for (int i = 1; i < 7; i++)
                CuiHelper.DestroyUi(player, $"baseCraft_bp_{i}");
            
            int totalItems = bpOrder.Count() - 1;

            for (int i = 1; i < 7; i++)
            {   
                if (totalItems < index + i) 
                    break;

                CreateBp(player, tier, bpOrder[index + i], i);
            }

            if (bpOrder.Count() > 7)
                CreatePageBtns(player, category, tier, page);
            else
            {
                CuiHelper.DestroyUi(player, "craft_page_up"); 
                CuiHelper.DestroyUi(player, "craft_page_down"); 
                CuiHelper.DestroyUi(player, "bp_page_count");
            }
        }
        
        private void CreateBp(BasePlayer player, int tier, string shortName, int index, bool selected = false)
        {  
            string bpUi = $"baseCraft_bp_{index}"; 
            string anchorMin = ba[1];
            string anchorMax = ba[2];
            if (index == 2) { anchorMin = ba[3]; anchorMax = ba[4]; }
            if (index == 3) { anchorMin = ba[5]; anchorMax = ba[6]; }
            if (index == 4) { anchorMin = ba[7]; anchorMax = ba[8]; }
            if (index == 5) { anchorMin = ba[9]; anchorMax = ba[10]; }
            if (index == 6) { anchorMin = ba[11]; anchorMax = ba[12]; }
            //rustlabs image
            string img = $"{bps[shortName].Image}";
            if (!img.StartsWith("http"))
                img = "https://rustlabs.com/img/items180/" + img;
            //resources
            string resource = "";
            foreach (string item in bps[shortName].Resources.Keys)
            {    
                var itemDef = ItemManager.FindItemDefinition(item);
                if (itemDef == null) 
                {
                    SendReply(player, $" <color=#C2291D>!</color> '{item}' <color=#C2291D>is not correct shortname.</color>");
                    return;
                }
                string itemDisplayName = itemDef.displayName.translated;
           
                if (nameReplace.ContainsKey(item))
                    itemDisplayName = nameReplace[item];

                if (CheckInv(player, item, bps[shortName].Resources[item]))
                    resource = resource + $"{bps[shortName].Resources[item]} {itemDisplayName}, ";
                else
                    resource = resource + $"<color=#d0b255>{bps[shortName].Resources[item]} {itemDisplayName}</color>, ";   
            }
            resource = resource.Remove(resource.Length-2);
            //UI
            var _createBps = CUIClass.CreateOverlay("empty", "0 0 0 0", "0 0", "0 0", false, 0.0f, "assets/icons/iconmaterial.mat"); //assets/content/ui/uibackgroundblur.mat
            if (selected)
            {
                if (bps[shortName].Tier > tier)
                {//if tier required
                    if (config.main.perms && !permission.UserHasPermission(player.UserIDString, $"craftmenu.{bps[shortName].Category}"))
                    {
                        CUIClass.CreateText(ref _createBps, "selected_btn", bpUi, "1 1 1 0.25", $"<size=10>YOU CAN'T CRAFT THIS ITEM</size>", 12, "0.8 0.19", $"0.98 0.83", TextAnchor.MiddleCenter, $"robotocondensed-regular.ttf", 0.1f);  
                    }
                    else
                    {
                        CUIClass.CreateText(ref _createBps, "selected_btn", bpUi, "1 1 1 0.25", $"<b><size=15>TIER {bps[shortName].Tier}</size></b>\nREQUIRED", 12, "0.8 0.19", $"0.98 0.83", TextAnchor.MiddleCenter, $"robotocondensed-regular.ttf", 0.1f);      
                    }
                }    
                else
                {   


                    if (bps[shortName].ResearchCost != 0)
                    {//if needs to be reseached
                        if (playerBps[player.userID].bp.Contains(shortName))
                        {// if player own blueprint
                            if (_CanCraft(player, shortName))
                            {// if player has enough resources
                                //craft button
                                CUIClass.CreateButton(ref _createBps, "selected_btn", bpUi, "0.38 0.51 0.16 0.85", "     CRAFT", 11, "0.8 0.19", $"0.98 0.83", $"craftmenu_cmd craft {tier} {shortName} {index}", "", "1 1 1 0.6", 0.1f, TextAnchor.MiddleCenter, $"robotocondensed-bold.ttf", "assets/content/ui/uibackgroundblur.mat");
                                CUIClass.PullFromAssets(ref _createBps, "bp_craftBtn_icon", "selected_btn", "1 1 1 0.65", "assets/icons/tools.png", 0.1f, 0f, "0.14 0.34", "0.32 0.67");   
                            }
                            else
                            {// not enough resources
                                CUIClass.CreateButton(ref _createBps, "selected_btn", bpUi, "0.70 0.67 0.65 0.17", "NOT ENOUGH\nRESOURCES", 11, "0.8 0.19", $"0.98 0.83", $"", "", "1 1 1 0.4", 0.1f, TextAnchor.MiddleCenter, $"robotocondensed-bold.ttf", "assets/content/ui/uibackgroundblur.mat");
                            }
                        }
                        else
                        {//research button
                            if (config.main.perms && !permission.UserHasPermission(player.UserIDString, $"craftmenu.{bps[shortName].Category}"))
                            {
                                CUIClass.CreateText(ref _createBps, "selected_btn", bpUi, "1 1 1 0.25", $"<size=10>YOU CAN'T CRAFT THIS ITEM</size>", 12, "0.8 0.19", $"0.98 0.83", TextAnchor.MiddleCenter, $"robotocondensed-regular.ttf", 0.1f);  
                            }
                            else
                            {
                                CUIClass.CreateButton(ref _createBps, "selected_btn", bpUi, "0.70 0.67 0.65 0.17", "RESEARCH\n", 11, "0.8 0.19", $"0.98 0.83", $"craftmenu_cmd research {tier} {shortName} {index}", "", "1 1 1 0.6", 0.1f, TextAnchor.MiddleCenter, $"robotocondensed-regular.ttf", "assets/content/ui/uibackgroundblur.mat");
                                CUIClass.CreateImage(ref _createBps, "btn_research_scrapImg", "selected_btn", Img("https://rustlabs.com/img/items180/scrap.png"), "0.16 0.12", "0.43 0.48", 0.1f);
                                CUIClass.CreateText(ref _createBps, "btn_research_cost", "selected_btn", "1 1 1 0.4", $"{bps[shortName].ResearchCost}", 12, "0.3 0.0", "0.80 0.5", TextAnchor.UpperRight, $"robotocondensed-bold.ttf", 0.1f);      
                            }
                        }
                    }
                    else
                    {
                        if (_CanCraft(player, shortName))
                        {// if player has enough resources
                            //craft button
                            CUIClass.CreateButton(ref _createBps, "selected_btn", bpUi, "0.38 0.51 0.16 0.85", "     CRAFT", 11, "0.8 0.19", $"0.98 0.83", $"craftmenu_cmd craft {tier} {shortName} {index}", "", "1 1 1 0.6", 0.1f, TextAnchor.MiddleCenter, $"robotocondensed-bold.ttf", "assets/content/ui/uibackgroundblur.mat");
                            CUIClass.PullFromAssets(ref _createBps, "bp_craftBtn_icon", "selected_btn", "1 1 1 0.65", "assets/icons/tools.png", 0.1f, 0f, "0.14 0.34", "0.32 0.67");   
                        }
                        else
                        {// not enough resources
                            CUIClass.CreateButton(ref _createBps, "selected_btn", bpUi, "0.70 0.67 0.65 0.17", "NOT ENOUGH\nRESOURCES", 11, "0.8 0.19", $"0.98 0.83", $"", "", "1 1 1 0.4", 0.1f, TextAnchor.MiddleCenter, $"robotocondensed-bold.ttf", "assets/content/ui/uibackgroundblur.mat");
                        }
                    }
                }         
            }  
            else
            {//BASE
                CUIClass.CreatePanel(ref _createBps, bpUi, "baseCraft_blueprints_panel", "0.70 0.67 0.65 0.07", anchorMin, anchorMax, false, 0.1f, 0f, "assets/content/ui/uibackgroundblur.mat"); 
                //data
                CUIClass.CreateImage(ref _createBps, "bp_image", bpUi, Img($"{img}"), "0.02 0.12", "0.14 0.88", 0.1f);
                CUIClass.CreateText(ref _createBps, "bp_name", bpUi, "1 1 1 0.4", $"{bps[shortName].Name}", 17, "0.17 0.45", "0.80 0.88", TextAnchor.MiddleLeft, $"robotocondensed-bold.ttf", 0.1f);  
                CUIClass.CreateText(ref _createBps, "bp_resource", bpUi, "1 1 1 0.4", resource, 11, "0.17 0.14", "0.80 0.46", TextAnchor.UpperLeft, $"robotocondensed-regular.ttf", 0.1f);  
            
                if (bps[shortName].ResearchCost != 0)
                {//if needs to be reseached
                    if (playerBps[player.userID].bp.Contains(shortName))
                    {//bp available
                        CUIClass.PullFromAssets(ref _createBps, "bp_available", bpUi, "1 1 1 0.18", "assets/icons/check.png", 0.1f, 0f, "0.85 0.22", "0.945 0.87");      
                    }
                    else
                    {//locked
                         CUIClass.PullFromAssets(ref _createBps, "bp_lock", bpUi, "1 1 1 0.18", "assets/icons/bp-lock.png", 0.1f, 0f, "0.85 0.22", "0.945 0.87");
                    }
                }
                else
                {//bp available
                    CUIClass.PullFromAssets(ref _createBps, "bp_available", bpUi, "1 1 1 0.18", "assets/icons/check.png", 0.1f, 0f, "0.85 0.22", "0.945 0.87");
                }
                
                //select btn
                CUIClass.CreateButton(ref _createBps, "select_btn", bpUi, "0 0 0 0", "", 11, "0 0", $"1 1", $"craftmenu_cmd select {tier} {shortName} {index}", "", "1 1 1 0.4", 1f, TextAnchor.MiddleCenter, $"robotocondensed-bold.ttf", "assets/icons/iconmaterial.mat");
            }      
            
            if (!selected)
                CuiHelper.DestroyUi(player, bpUi);
            else
                CuiHelper.DestroyUi(player, "selected_btn");

            CuiHelper.AddUi(player, _createBps);
            CuiHelper.DestroyUi(player, "empty");
        }

        private void DestroyBps(BasePlayer player)
        {   
            CuiHelper.DestroyUi(player, "empty"); 
            CuiHelper.DestroyUi(player, "baseCraft_main");
        }

        string[] anchors = {
            "index",
            "0.86 0.0-0.98 1",
            "0.72 0.0-0.84 1",
            "0.58 0.0-0.70 1",
            "0.44 0.0-0.56 1",
            "0.30 0.0-0.42 1",
            "0.16 0.0-0.28 1",
            "0.02 0.0-0.14 1",
        
        };

        private void CreateCraftQueLayout(BasePlayer player, string itemName = "default")
        {   
          
            var qL = CUIClass.CreateOverlay("empty", "0 0 0 0", "0 0", "0 0", false, 0.0f, "assets/icons/iconmaterial.mat"); //assets/content/ui/uibackgroundblur.mat
         
            CUIClass.CreatePanel(ref qL, "ql_base", "Overlay", "0.10 0.40 0.60 1", "0.5 0.5", "0.5 0.5", false, 0.3f, 0f, "assets/content/ui/uibackgroundblur.mat", "245 -344", "423 -317");
            CUIClass.PullFromAssets(ref qL, "ql_base_gearicon", "ql_base", "0.20 0.6 0.8 1", "assets/icons/gear.png", 0.3f, 0f, "0.02 0.25", "0.11 0.75");
         
            CUIClass.CreateButton(ref qL, "ql_base_btn_cancel_current", "ql_base", "0.70 0.67 0.65 0.17", "", 11, "-0.15 0.02", $"-0.01 0.98", $"craftmenu_cancel 0", "", "1 1 1 0.7", 1f, TextAnchor.MiddleCenter, $"robotocondensed-bold.ttf", "assets/content/ui/uibackgroundblur.mat");
                CUIClass.PullFromAssets(ref qL, "ql_base_crossicon1", "ql_base_btn_cancel_current", "1 1 1 0.45", "assets/icons/vote_down.png", 0.1f, 0f, "0.0 0", "1 1");
            
            CuiHelper.DestroyUi(player, "empty");
            CuiHelper.DestroyUi(player, "ql_base");
            CuiHelper.AddUi(player, qL); 
            CuiHelper.DestroyUi(player, "empty");
        }
                    
        private void CreateTimer(BasePlayer player, string itemName, int seconds)
        {   
            string displayName = bps[itemName].Name;
            if (displayName.Length > 16)
            {
                displayName = displayName.Remove(16);
                displayName += "."; 
            }
            string s = "king";
            string result = s.Remove(s.Length-1);
            var qTimer = CUIClass.CreateOverlay("empty", "0 0 0 0", "0 0", "0 0", false, 0.0f, "assets/icons/iconmaterial.mat"); //assets/content/ui/uibackgroundblur.mat
            CUIClass.CreateText(ref qTimer, "qTimer", "ql_base", "1 1 1 0.6", $"{seconds}s", 13, "0.13 0.00", "0.96 1", TextAnchor.MiddleRight, $"robotocondensed-regular.ttf", 0.0f);  
            CUIClass.CreateText(ref qTimer, "qTimerName", "ql_base", "1 1 1 0.8", $"{displayName.ToUpper()}", 13, "0.13 0.00", "1 1", TextAnchor.MiddleLeft, $"robotocondensed-bold.ttf", 0.0f);  
            
            CuiHelper.DestroyUi(player, "qTimer");
            CuiHelper.DestroyUi(player, "qTimerName");
            CuiHelper.AddUi(player, qTimer); 
            CuiHelper.DestroyUi(player, "empty");
        }

        private void CreateQueButton(BasePlayer player, int count)
        {
            var qBtn = CUIClass.CreateOverlay("empty", "0 0 0 0", "0 0", "0 0", false, 0.0f, "assets/icons/iconmaterial.mat"); //assets/content/ui/uibackgroundblur.mat
            if (count > 1)
                CUIClass.CreateButton(ref qBtn, "ql_base_quetext_btn", "ql_base", "0 0 0 0", $"  {count - 1} more items in queue, click to cancel", 9, "0 -0.4", "1.3 3.0", $"craftmenu_openquepanel", "", "1 1 1 0.9", 0.2f, TextAnchor.LowerLeft, $"robotocondensed-regular.ttf", "assets/icons/iconmaterial.mat");
            
            CuiHelper.DestroyUi(player, "ql_base_quetext_btn");
            CuiHelper.AddUi(player, qBtn); 
            CuiHelper.DestroyUi(player, "empty");
        }

        private void CreateQuePanel(BasePlayer player, List<string> craftingQue)
        {   
            var qPanel = CUIClass.CreateOverlay("empty", "0 0 0 0", "0 0", "0 0", false, 0.0f, "assets/icons/iconmaterial.mat"); //assets/content/ui/uibackgroundblur.mat
            if (craftingQue.Count > 1)
            {
                int forLenght = craftingQue.Count;
                if (forLenght > 8)
                    forLenght = 8;

                CUIClass.CreatePanel(ref qPanel, "qPanel_panel", "ql_base", "0.70 0.67 0.65 0.17", "-0.155 1.1", "1 2.2", false, 0.1f, 0f, "assets/content/ui/uibackgroundblur.mat");
                for (var i = 1; i < forLenght; i++)
                {   
                    string img = $"{bps[craftingQue[i]].Image}";
                    if (!img.StartsWith("http"))
                    img = "https://rustlabs.com/img/items180/" + img;


                    string[] splitA = anchors[i].Split('-');
                    CUIClass.CreateButton(ref qPanel, $"ql_quebtn{i}", "qPanel_panel", "0 0 0 0", "", 11, splitA[0], splitA[1], $"craftmenu_cancel {i}", "", "1 1 1 0.7", 0.2f, TextAnchor.MiddleCenter, $"robotocondensed-bold.ttf", "assets/icons/iconmaterial.mat");
                    CUIClass.CreateImage(ref qPanel, $"ql_base_que_img{i}", $"ql_quebtn{i}", $"{Img(img)}", "0 0.1", "1 0.9", 0.2f);
                
                }
            }
            
            CuiHelper.DestroyUi(player, "qPanel_panel");
            CuiHelper.AddUi(player, qPanel); 
            CuiHelper.DestroyUi(player, "empty");
        }
        


        #endregion
        
        #region [CUI Class]

        public class CUIClass
        {
            public static CuiElementContainer CreateOverlay(string _name, string _color, string _anchorMin, string _anchorMax, bool _cursorOn = false, float _fade = 0f, string _mat ="")
            {   
                var _element = new CuiElementContainer()
                {
                    {
                        new CuiPanel
                        {
                            Image = { Color = _color, Material = _mat, FadeIn = _fade},
                            RectTransform = { AnchorMin = _anchorMin, AnchorMax = _anchorMax },
                            CursorEnabled = _cursorOn
                        },
                        new CuiElement().Parent = "Overlay",
                        _name
                    }
                };
                return _element;
            }

            public static void CreatePanel(ref CuiElementContainer _container, string _name, string _parent, string _color, string _anchorMin, string _anchorMax, bool _cursorOn = false, float _fadeIn = 0f, float _fadeOut = 0f, string _mat2 ="", string _OffsetMin = "", string _OffsetMax = "" )
            {
                _container.Add(new CuiPanel
                {
                    Image = { Color = _color, Material = _mat2, FadeIn = _fadeIn },
                    RectTransform = { AnchorMin = _anchorMin, AnchorMax = _anchorMax, OffsetMin = _OffsetMin, OffsetMax = _OffsetMax },
                    FadeOut = _fadeOut, CursorEnabled = _cursorOn
                },
                _parent,
                _name);
            }

            public static void CreateImage(ref CuiElementContainer _container, string _name, string _parent, string _image, string _anchorMin, string _anchorMax, float _fadeIn = 0f, float _fadeOut = 0f, string _OffsetMin = "", string _OffsetMax = "")
            {
                if (_image.StartsWith("http") || _image.StartsWith("www"))
                {
                    _container.Add(new CuiElement
                    {   
                        Name = _name,
                        Parent = _parent,
                        FadeOut = _fadeOut,
                        Components =
                        {
                            new CuiRawImageComponent { Url = _image, Sprite = "assets/content/textures/generic/fulltransparent.tga", FadeIn = _fadeIn},
                            new CuiRectTransformComponent { AnchorMin = _anchorMin, AnchorMax = _anchorMax, OffsetMin = _OffsetMin, OffsetMax = _OffsetMax }
                        }
                        
                    });
                }
                else
                {
                    _container.Add(new CuiElement
                    {
                        Parent = _parent,
                        Components =
                        {
                            new CuiRawImageComponent { Png = _image, Sprite = "assets/content/textures/generic/fulltransparent.tga", FadeIn = _fadeIn},
                            new CuiRectTransformComponent { AnchorMin = _anchorMin, AnchorMax = _anchorMax }
                        }
                    });
                }
            }

            public static void PullFromAssets(ref CuiElementContainer _container, string _name, string _parent, string _color, string _sprite, float _fadeIn = 0f, float _fadeOut = 0f, string _anchorMin = "0 0", string _anchorMax = "1 1", string _material = "assets/icons/iconmaterial.mat")
            { 
                //assets/content/textures/generic/fulltransparent.tga MAT
                _container.Add(new CuiElement
                {   
                    Parent = _parent,
                    Name = _name,
                    Components =
                            {
                                new CuiImageComponent { Material = _material, Sprite = _sprite, Color = _color, FadeIn = _fadeIn},
                                new CuiRectTransformComponent {AnchorMin = _anchorMin, AnchorMax = _anchorMax}
                            },
                    FadeOut = _fadeOut
                });
            }

            public static void CreateInput(ref CuiElementContainer _container, string _name, string _parent, string _color, int _size, string _anchorMin, string _anchorMax, string _font = "permanentmarker.ttf", string _command = "command.processinput", TextAnchor _align = TextAnchor.MiddleCenter)
            {
                _container.Add(new CuiElement
                {
                    Parent = _parent,
                    Name = _name,

                    Components =
                    {
                        new CuiInputFieldComponent
                        {

                            Text = "0",
                            CharsLimit = 250,
                            Color = _color,
                            IsPassword = false,
                            Command = _command,
                            Font = _font,
                            FontSize = _size,
                            Align = _align
                        },

                        new CuiRectTransformComponent
                        {
                            AnchorMin = _anchorMin,
                            AnchorMax = _anchorMax

                        }

                    },
                });
            }

            public static void CreateText(ref CuiElementContainer _container, string _name, string _parent, string _color, string _text, int _size, string _anchorMin, string _anchorMax, TextAnchor _align = TextAnchor.MiddleCenter, string _font = "robotocondensed-bold.ttf", float _fadeIn = 0f, float _fadeOut = 0f, string _outlineColor = "0 0 0 0", string _outlineScale ="0 0")
            {   
                _container.Add(new CuiElement
                {
                    Parent = _parent,
                    Name = _name,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = _text,
                            FontSize = _size,
                            Font = _font,
                            Align = _align,
                            Color = _color,
                            FadeIn = _fadeIn,
                        },

                        new CuiOutlineComponent
                        {
                            
                            Color = _outlineColor,
                            Distance = _outlineScale
                            
                        },

                        new CuiRectTransformComponent
                        {
                             AnchorMin = _anchorMin,
                             AnchorMax = _anchorMax
                        }
                    },
                    FadeOut = _fadeOut
                });
            }

            public static void CreateButton(ref CuiElementContainer _container, string _name, string _parent, string _color, string _text, int _size, string _anchorMin, string _anchorMax, string _command = "", string _close = "", string _textColor = "0.843 0.816 0.78 1", float _fade = 1f, TextAnchor _align = TextAnchor.MiddleCenter, string _font = "", string _material = "assets/content/ui/uibackgroundblur-ingamemenu.mat")
            {       
               
                _container.Add(new CuiButton
                {
                    Button = { Close = _close, Command = _command, Color = _color, Material = _material, FadeIn = _fade},
                    RectTransform = { AnchorMin = _anchorMin, AnchorMax = _anchorMax },
                    Text = { Text = _text, FontSize = _size, Align = _align, Color = _textColor, Font = _font, FadeIn = _fade}
                },
                _parent,
                _name);
            }
        }
        #endregion
        
        #region [Blueprint Data]
        
        private void SaveData()
        {
            if (bps != null)
            Interface.Oxide.DataFileSystem.WriteObject($"{Name}/Blueprints", bps);
        }
        
        private Dictionary<string, Bps> bps;
        
        private class Bps
        {   
            public string Name;
            public string Image;
            public ulong SkinID;
            public string Category;
            public int Tier;
            public int ResearchCost;
            public Dictionary<string, int> Resources = new Dictionary<string, int>{}; 
        }
        
        private void LoadData()
        {
            if (Interface.Oxide.DataFileSystem.ExistsDatafile($"{Name}/Blueprints"))
            {
                bps = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<string, Bps>>($"{Name}/Blueprints");
            }
            else
            {
                bps = new Dictionary<string, Bps>();
        
                CreateExamples();
                SaveData();
            }
        }
        
        private void CreateExamples()
        {   
            bps.Add("multiplegrenadelauncher", new Bps());
            bps["multiplegrenadelauncher"].Name = "Grenade Launcher";
            bps["multiplegrenadelauncher"].Image = "multiplegrenadelauncher.png";
            bps["multiplegrenadelauncher"].SkinID = 0;
            bps["multiplegrenadelauncher"].Category = "weapons";
            bps["multiplegrenadelauncher"].Tier = 3;
            bps["multiplegrenadelauncher"].Resources.Add("metal.fragments", 750);
            bps["multiplegrenadelauncher"].Resources.Add("metalpipe", 6);
            bps["multiplegrenadelauncher"].Resources.Add("metal.refined", 150);

            SaveData();
        }   
        
        #endregion

        #region [Player Data]
        
        private void SavePlayerData()
        {
            if (playerBps != null)
            Interface.Oxide.DataFileSystem.WriteObject($"{Name}/PlayerBlueprints", playerBps);
        }
        
        private Dictionary<ulong, PlayerBps> playerBps;
        
        private class PlayerBps
        {   
            public List<string> bp = new List<string>{};  
        }
        
        private void LoadPlayerData()
        {
            if (Interface.Oxide.DataFileSystem.ExistsDatafile($"{Name}/PlayerBlueprints"))
            {
                playerBps = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, PlayerBps>>($"{Name}/PlayerBlueprints");
            }
            else
            {
                playerBps = new Dictionary<ulong, PlayerBps>();
        
                CreatePlayerExamples();
                SavePlayerData();
            }
        }
        
        private void CreatePlayerExamples()
        {   
            playerBps.Add(76561198207548749, new PlayerBps());  
            playerBps[76561198207548749].bp.Add("rifle.lr300");
            playerBps[76561198207548749].bp.Add("fun.boomboxportable");
            SavePlayerData();
        }
        
        #endregion

        #region [Names Data]
        
        private void SaveNamesData()
        {
            if (nameReplace != null)
            Interface.Oxide.DataFileSystem.WriteObject($"{Name}/CustomNames_Resources", nameReplace);
        }
        
        private Dictionary<string, string> nameReplace;
        
        
        
        private void LoadNamesData()
        {
            if (Interface.Oxide.DataFileSystem.ExistsDatafile($"{Name}/CustomNames_Resources"))
            {
                nameReplace = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<string, string>>($"{Name}/CustomNames_Resources");
            }
            else
            {
                nameReplace = new Dictionary<string, string>();
        
                CreateNameReplacements();
                SaveNamesData();
            }
        }
        
        private void CreateNameReplacements()
        {   
                nameReplace.Add("metal.refined", "HQM");
                nameReplace.Add("propanetank", "Propane Tank");
                nameReplace.Add("metalpipe", "Pipes");
                nameReplace.Add("wiretool", "Wires");
        }
        
        #endregion

        #region [Image Handling]

        [PluginReference] Plugin ImageLibrary;

        //list for load order
        private List<string> imgList = new List<string>();

        private void DownloadImages()
        {   
            if (ImageLibrary == null) 
            { Puts($"(! MISSING) ImageLibrary not found, image load speed will be significantly slower."); return; }
            
            //add to load order
            imgList.Add("https://rustlabs.com/img/items180/rifle.lr300.png");
            imgList.Add("https://rustplugins.net/products/craftmenu/blueprint.png");
            imgList.Add("https://rustplugins.net/products/craftmenu/mini.png");
            ImageLibrary.Call("AddImage", "https://rustplugins.net/products/craftmenu/blueprint.png", "https://rustplugins.net/products/craftmenu/blueprint.png");
            ImageLibrary.Call("AddImage", "https://rustlabs.com/img/items180/rifle.lr300.png", "https://rustlabs.com/img/items180/rifle.lr300.png");
            
            string prefix = "https://rustlabs.com/img/items180/";
            //add item images
            foreach (string item in bps.Keys) 
            {   
                if (!bps[item].Image.StartsWith("http"))
                {
                    ImageLibrary.Call("AddImage", prefix + bps[item].Image, prefix + bps[item].Image);
                    if (!imgList.Contains(bps[item].Image))
                        imgList.Add(prefix + bps[item].Image);
                }
                else
                {
                    ImageLibrary.Call("AddImage", bps[item].Image, bps[item].Image);
                    if (!imgList.Contains(bps[item].Image))
                        imgList.Add(bps[item].Image);
                }
            }
            //add category images
            foreach (string category in config.main.cat.Keys) 
            { 
                if (!config.main.cat[category].StartsWith("assets"))
                {
                    ImageLibrary.Call("AddImage", config.main.cat[category], config.main.cat[category]);
                    imgList.Add(config.main.cat[category]);
                }
            }
            //call load order
            ImageLibrary.Call("ImportImageList", "CraftMenu", imgList);
        }

        private void ImageQueCheck()
        {   
            int imgCount = imgList.Count();
            int downloaded = 0;
            foreach (string img in imgList)
            {
                if ((bool) ImageLibrary.Call("HasImage", img))
                    downloaded++; 
            }

            if (imgCount > downloaded)
                Puts($"(!) Stored Images ({downloaded}/{imgCount}). Reload ImageLibrary and then CraftMenu plugin to start download order.");
            
            if (imgCount == downloaded)
                Puts($"Stored Images ({downloaded}). All images has been successfully stored in image library.");
        }

        private string Img(string url)
        {   //img url been used as image names
            if (ImageLibrary != null) 
            {   
                if (!(bool) ImageLibrary.Call("HasImage", url))
                    return url;
                else
                    return (string) ImageLibrary?.Call("GetImage", url);
            }
            else 
                return url;
        }

        #endregion
        
        #region [Config] 
        
        private Configuration config;
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<Configuration>();
            SaveConfig();
        }
        
        protected override void LoadDefaultConfig()
        {
            config = Configuration.CreateConfig();
        }
        
        protected override void SaveConfig() => Config.WriteObject(config);     
        
        class Configuration
        {   
            [JsonProperty(PropertyName = "Main Settings")]
            public MainSet main { get; set; }
        
            public class MainSet
            {
                [JsonProperty("Wipe Blueprints at Map Wipe")]
                public bool wipe {get; set;}

                [JsonProperty("Sound Effects")]
                public bool fx {get; set;}
        
                [JsonProperty("Categories (Max 6)")]
                public Dictionary<string, string> cat { get; set; }

                [JsonProperty("Permissions required for each category")]
                public bool perms { get; set; }
            } 

            [JsonProperty(PropertyName = "Crafting Time")]
            public CT ct { get; set; }
        
            public class CT
            {
                [JsonProperty("Enabled")]
                public bool craftQue {get; set;}

                [JsonProperty("Default Craft Time for all items (in seconds)")]
                public int defaultTime {get; set;}
        
                [JsonProperty("Specific Craft Time (in seconds)")]
                public Dictionary<string, int> excp { get; set; }
            }

            public static Configuration CreateConfig()
            {
                return new Configuration
                {   
                    main = new CraftMenu.Configuration.MainSet
                    {       
                        wipe = false,
                        fx = true,
                        cat = new Dictionary<string, string>
                        { 
                            { "construction", "assets/icons/construction.png" },
                            { "weapons", "assets/icons/bullet.png" },
                            { "clothing", "assets/icons/clothing.png" },
                            { "electrical", "assets/icons/electric.png" },
                            { "vehicles", "assets/icons/horse_ride.png" },
                            { "dlc", "assets/icons/download.png" },
                        }, 
                        perms = false,
                    },

                    ct = new CraftMenu.Configuration.CT
                    {        
                        craftQue = false,
                        defaultTime = 5,
                        excp = new Dictionary<string, int>
                        { 
                            { "rifle.m39", 60 },
                            { "pistol.m92", 45 },
                            { "rifle.lr300", 80 },
                            { "rifle.l96", 120 },
                            { "lmg.m249", 200 },
                            { "multiplegrenadelauncher", 200 },
                        }
                    },
                };
            }
        }
        #endregion
        
    }
}

// --- End of file: CraftMenu.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/StalkerLite.cs ---
// --- Original Local Path: StalkerLite.cs ---

﻿using System;
using System.Collections.Generic;
using UnityEngine;
using Random = System.Random;

namespace Oxide.Plugins
{
    [Info("Stalker Emission", "Unknown", "1.0.17")]
    [Description("На всей карте появляется радиация, что сопровождается ужудшением погоды, звуками и визуальными эфектами")]
    public class StalkerLite : RustPlugin
    { 
		#region Config

        private bool active;

        private double last = Now();

        private const int
            shockNum = 30, explosionsNum = 15, fireNum = 3, // Количество эффектов
            shockMin = -100, shockMax = 100, explosionMin = -100, explosionMax = 100, fireMin = -30, fireMax = 60;

        private float
            cooldown = 3600f, duration = 180f, delay = 15f, // Общие задержи: Интервал, Длительность, Задержка перед выбросом
            radDelay = 2.5f, shockDelay = 1.5f, explosionDelay = 2.5f, fireDelay = 4.5f, // Задежка между повторным появлением эффекта
            radAmount = 10f; // Интенсивность радиации

        private const string
            firePrefab = "assets/bundled/prefabs/fireball.prefab",
            electricPrefab = "assets/prefabs/locks/keypad/effects/lock.code.shock.prefab",
            explosionPrefab = "assets/prefabs/weapons/rocketlauncher/effects/rocket_explosion_incendiary.prefab",
            preMessage = "<size=15>Через <color=#BEF781>{0} сек.</color> будет выброс радиации!\nНайдите костюм или укрытие!</size>",
            emission = "<size=15><color=#FFA500>!!! НАЧАЛСЯ ВЫБРОС РАДИАЦИИ !!!</color>\nНайдите костюм или укрытие!</size>",
			endemission = "<size=15><color=#FFA500>ВЫБРОС РАДИАЦИИ ЗАВЕРШЕН!</color>\nВы в безопасности!</size>",
            safe = "<size=15><color=#32CD32>Вы в безопасности!</color></size>",
            nonsafe = "<size=15><color=#ce422b>Вы в опасности!</color>\nНайдите костюм или укрытие!</size>",
            permRad = "stalkerlite.use",
			prefix = "<color=#66ff66>[Stalker]</color>";

		protected override void LoadDefaultConfig()
        {
            PrintWarning("Создание нового файла конфигурации...");
        }

		private void LoadConfigValues()
        {
            GetConfig("Интервал между выбросами (в секундах)", ref cooldown);
			GetConfig("Длительность выброса (в секундах)", ref duration);
			GetConfig("Задержка перед выбросом (в секундах)", ref delay);
			GetConfig("Интенсивность радиации", ref radAmount);
			GetConfig("Частота появления эфекта радиации", ref radDelay);
			GetConfig("Частота появления эфекта молнии", ref shockDelay);
			GetConfig("Частота появления эфекта взрыва", ref explosionDelay);
			GetConfig("Частота появления эфекта огня", ref fireDelay);

			SaveConfig();
		}

        private void GetConfig<T>(string Key, ref T var)
        {
            if (Config[Key] != null)
            {
                var = (T)Convert.ChangeType(Config[Key], typeof(T));
            }
            Config[Key] = var;
        }

        #endregion

        #region Commands

        [ChatCommand("rad")]
        private void CmdRad(BasePlayer player)
        {
            if (active)
            {
                player.ChatMessage($"<size=15>Выброс завершится через <color=#BEF781>{Math.Round(duration-(Now() - last))} сек.</color></size>");
                return;
            }
            
            player.ChatMessage($"<size=15>До следующего выброса осталось <color=#BEF781>{Math.Round(cooldown - (Now() - last))} сек.</color></size>");
        }

        [ChatCommand("stalker")]
        private void ChatCmd(BasePlayer player)
        {
            if (!player.IsAdmin && !permission.UserHasPermission(player.UserIDString, permRad))
            {
                player.ChatMessage("[Управление] У вас нет прав на использование данной команды!");
                return;
            }

            if (active)
            {
                player.ChatMessage($"{prefix} Выброс прекращён!");
                StopEmission();
                return;
            }

            player.ChatMessage($"{prefix} Выброс запущен!");
            StartEmission();
        }

        #endregion

        #region Oxide Hooks

		private void Loaded()
        {
            LoadConfigValues();
        }	

        private void OnServerInitialized()
        {
            timer.Once(cooldown, () => { StartEmission(); });
            permission.RegisterPermission(permRad, this);
        }

        private void Unload()
        {
            StopEmission();
        }

        #endregion

        #region Core

        private List<ulong> Protected = new List<ulong>();

        public Timer Radiation, Explosion, Fire, Shock, CheckProtection;

        private void DestroyTimers()
        {
            if (Radiation != null) timer.Destroy(ref Radiation);
            if (Explosion != null) timer.Destroy(ref Explosion);
            if (Fire != null) timer.Destroy(ref Fire);
            if (Shock != null) timer.Destroy(ref Shock);
            if (CheckProtection != null) timer.Destroy(ref CheckProtection);
        }

        private Random rand = new Random();

        private void StartEmission()
        {
            if (active)
            {
                StopEmission();
                return;
            }

			Server.Command("weather.fog 1");
			Server.Command("weather.wind 1");
			Server.Command("weather.rain 1");
			Server.Command("weather.clouds 1");
            Server.Broadcast(string.Format(preMessage, delay));
            active = true;
            timer.Once(delay, () =>{Emission();});
        }

        private void StopEmission()
        {
            if (!active) return;

            DestroyTimers();
            active = false;
            Server.Command("weather.fog 0");
			Server.Command("weather.wind 0");
			Server.Command("weather.rain 0");
			Server.Command("weather.clouds 0");			
            foreach (var player in BasePlayer.activePlayerList) player.metabolism.radiation_level.value = 0;
			Server.Broadcast(endemission);
            timer.Once(cooldown, () => { StartEmission(); });
        }

        private void Emission()
        {
            if(!active) return;

            last = Now();
            timer.Once(duration, () =>{ StopEmission(); });

            Server.Broadcast(emission);

            CheckProtection = timer.Every(1f, () =>
            {
                foreach (var player in BasePlayer.activePlayerList)
                {
                    player.metabolism.radiation_level.value = 100; // TODO: Radiation Zone?
                    
                    if (bProtected(player))
                    {
                        if (!Protected.Contains(player.userID))
                        {
                            player.ChatMessage(safe);
                            Protected.Add(player.userID);
                        }
                    }
                    else
                    {
                        if (Protected.Contains(player.userID))
                        {
                            player.ChatMessage(nonsafe);
                            Protected.Remove(player.userID);
                        }
                    }
                }
            });

            Radiation = timer.Every(radDelay, () =>
            {
                foreach (var player in BasePlayer.activePlayerList) 
                {
                    if(Protected.Contains(player.userID)) continue;

                    player.metabolism.radiation_poison.value += radAmount;
                }
            });

            Explosion = timer.Every(explosionDelay, () =>
            {
                foreach (var player in BasePlayer.activePlayerList)
                {
                    for (int i = 1; i < explosionsNum + 1; i++)
                    {
                        Effect.server.Run(explosionPrefab, 
                            new Vector3(player.transform.position.x + rand.Next(explosionMin, explosionMin), 
                                player.transform.position.y - 150, player.transform.position.z + rand.Next(explosionMin, explosionMax)));
                    }
                }
            });

            Shock =  timer.Every(shockDelay, () => 
            {
                foreach (var player in BasePlayer.activePlayerList)
                {
                    for (var i = 1; i < shockNum + 1; i++)
                    {
                        Effect.server.Run(electricPrefab, 
                            new Vector3(player.transform.position.x + rand.Next(shockMin, shockMax), 
                                player.transform.position.y + rand.Next(0, 10), player.transform.position.z + rand.Next(shockMin, shockMax)));
                    }
                }
            });

            Fire = timer.Every(fireDelay, () =>
            {
                foreach (var player in BasePlayer.activePlayerList)
                {
                    for (var i = 1; i < fireNum + 1; i++)
                    {
                        GameManager.server.CreateEntity(firePrefab, 
                            new Vector3(
                                player.transform.position.x + rand.Next(fireMin, fireMax), 
                                player.transform.position.y + rand.Next(0, 10), 
                                player.transform.position.z + rand.Next(fireMin, fireMax)))
                            .Spawn();
                    }
                }
            });
        }

        private bool bProtected(BasePlayer player)
        {
            foreach (var item in player.inventory.containerWear.itemList) if (item.info.shortname.Contains("hazmat")) return true;

            RaycastHit rHit;
            if (Physics.Raycast(player.transform.position , Vector3.up, out rHit, 4f,LayerMask.GetMask("Construction")) && rHit.GetEntity() != null)
            {
                var item = rHit.GetEntity() as BuildingBlock;
                if (item == null) return false;

                return item.grade != BuildingGrade.Enum.Wood && item.grade != BuildingGrade.Enum.Twigs;
            }

            return false;
        }

        private static double Now() {return DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds;}

        #endregion
    }
}


// --- End of file: StalkerLite.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/XNickController.cs ---
// --- Original Local Path: XNickController.cs ---

using Oxide.Game.Rust.Cui;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;
using System;
using Oxide.Core.Plugins;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("XNickController", "Monster", "1.0.0")]
    public class XNickController : RustPlugin
    {
		#region Configuration

        private NickConfig config;

        private class NickConfig
        {		
			internal class SymbolSetting
            {
                [JsonProperty("?_?")]
                public List<string> SymbolList = new List<string>();           				
            }			
            
			[JsonProperty("Список символов/слов которые нужно удалять из ника")]
            public SymbolSetting Symbol = new SymbolSetting();										
			
			public static NickConfig GetNewConfiguration()
            {
                return new NickConfig
                {
					Symbol = new SymbolSetting
					{
						SymbolList = new List<string>
						{
							"#XRUST",
							"#LALARUST",
							"#XRUST RUST",
							".ua",
							".ru",
							".com"
						}
					},
				};
			}
        }

        protected override void LoadDefaultConfig()
        {
            config = NickConfig.GetNewConfiguration();

            PrintWarning("Создание начальной конфигурации плагина!!!");
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();

            config = Config.ReadObject<NickConfig>();
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion
		
		#region Hooks
		
		private void OnServerInitialized()
		{
			PrintWarning("\n-----------------------------\n" +
			"     Author - Monster\n" +
			"     VK - vk.com/idannopol\n" +
			"     Discord - Monster#4837\n" +
			"     Config - v.2867\n" +
			"-----------------------------");
			
			foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
				foreach (var symbol in config.Symbol.SymbolList)
			    {
				    if (player.displayName.Contains(symbol))
				    {
					    player.displayName = player.displayName.Replace(symbol, "");
				    }
			    }
            }
		}
		
		void OnPlayerConnected(BasePlayer player)
		{
			if (player.IsReceivingSnapshot)
            {
                NextTick(() => OnPlayerConnected(player));
                return;
            }
			
			foreach (var symbol in config.Symbol.SymbolList)
			{
				if (player.displayName.Contains(symbol))
				{
					player.displayName = player.displayName.Replace(symbol, "");
				}
			}
		}
		
		#endregion
	}
}

// --- End of file: XNickController.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/PilotEject.cs ---
// --- Original Local Path: PilotEject.cs ---

﻿using Facepunch;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core.Plugins;
using Rust;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("PilotEject", "k1lly0u", "3.1.2")]
    [Description("A mini event where a helicopter malfunctions and the pilot has to eject")]
    class PilotEject : RustPlugin
    {
        #region Fields
        [PluginReference] Plugin CustomNPC, Kits, HeliRefuel;

        private List<ScientistNPC> scientistNPCs = new List<ScientistNPC>();

        private Hash<ulong, ItemContainer[]> scientistInventory = new Hash<ulong, ItemContainer[]>();

        public static PilotEject Instance { get; private set; }

        private const string ADMIN_PERM = "piloteject.admin";

        private const string HELICOPTER_PREFAB = "assets/prefabs/npc/patrol helicopter/patrolhelicopter.prefab";
        private const string PARACHUTE_PREFAB = "assets/prefabs/misc/parachute/parachute.prefab";
        private const string SMOKE_EFFECT = "assets/bundled/prefabs/fx/smoke_signal_full.prefab";

        private const int LAND_LAYERS = 1 << 4 | 1 << 8 | 1 << 16 | 1 << 21 | 1 << 23;
        #endregion

        #region Oxide Hooks
        private void Loaded()
        {
            Instance = this;

            lang.RegisterMessages(Messages, this);
            permission.RegisterPermission(ADMIN_PERM, this);
        }

        private void OnServerInitialized()
        {
            if (configData.NPC.LootType == "Default")
            {
                Unsubscribe(nameof(OnCorpsePopulate));
                Unsubscribe(nameof(CanPopulateLoot));
            }

            if (configData.Automation.AutoSpawn)
                RunAutomatedEvent();
        }

        private void OnEntitySpawned(BaseHelicopter baseHelicopter)
        {
            timer.In(1f, () =>
            {
                if (baseHelicopter == null || baseHelicopter.GetComponent<EjectionComponent>())
                    return;

                if (HeliRefuel && (bool)HeliRefuel.Call("IsRefuelHelicopter", baseHelicopter))
                    return;

                if (Mathf.Approximately(configData.Automation.Chance, 100) || Random.Range(0, 100) < configData.Automation.Chance)
                    baseHelicopter.gameObject.AddComponent<EjectionComponent>();
            });
        }

        private void OnEntityTakeDamage(BaseHelicopter baseHelicopter, HitInfo hitInfo)
        {
            if (baseHelicopter == null || hitInfo == null)
                return;

            EjectionComponent refuelHelicopter = baseHelicopter.GetComponent<EjectionComponent>();
            if (refuelHelicopter != null)
                refuelHelicopter.OnTakeDamage(hitInfo); 
        }

        private void OnEntityKill(BaseHelicopter baseHelicopter)
        {
            if (baseHelicopter == null)
                return;

            EjectionComponent ejectionHelictoper = baseHelicopter.GetComponent<EjectionComponent>();
            if (ejectionHelictoper != null)
            {
                if (!ejectionHelictoper.hasEjected)
                {
                    if (configData.Ejection.EjectOnDeath)
                        ejectionHelictoper.EjectPilot();
                    return;
                }

                UnityEngine.Object.Destroy(ejectionHelictoper);
            }

            for (int i = 0; i < ParachutePhysics._allParachutes.Count; i++)
            {
                ParachutePhysics parachutePhysics = ParachutePhysics._allParachutes[i];
                if (parachutePhysics != null && parachutePhysics.Helicopter == baseHelicopter)                
                    parachutePhysics.crashSite = baseHelicopter.transform.position;                
            }
        }

        private void OnEntityKill(ScientistNPC scientist) => scientistNPCs.Remove(scientist);


        private void OnHelicopterRetire(PatrolHelicopterAI patrolHelicopterAI) => UnityEngine.Object.Destroy(patrolHelicopterAI?.helicopterBase?.GetComponent<EjectionComponent>());

        private object CanBeTargeted(BaseCombatEntity player, MonoBehaviour behaviour)
        {
            ParachutePhysics npcParachute = player?.GetComponent<ParachutePhysics>();
            if (npcParachute != null)
            {
                if (((behaviour is AutoTurret) || (behaviour is GunTrap) || (behaviour is FlameTurret)) && configData.NPC.TargetedByTurrets)
                    return null;
                return false;
            }

            return null;
        }

        private void OnEntityDeath(ScientistNPC scientistNpc, HitInfo hitInfo)
        {
            if (scientistNpc == null || !scientistNPCs.Contains(scientistNpc))
                return;

            if (configData.NPC.LootType == "Inventory")
                StoreInventory(scientistNpc);

            if (hitInfo.InitiatorPlayer != null && configData.Notifications.NPCDeath)
                Broadcast("Notification.PilotKilled", hitInfo.InitiatorPlayer.displayName);

        }

        private object CanPopulateLoot(ScientistNPC scientistNpc, NPCPlayerCorpse corpse) => scientistNPCs.Contains(scientistNpc) ? (object)false : null;

        private object OnCorpsePopulate(ScientistNPC scientistNpc, NPCPlayerCorpse corpse)
        {
            if (scientistNpc == null || !scientistNPCs.Contains(scientistNpc))
                return null;

            if (configData.NPC.LootType == "Inventory")
            {
                MoveInventoryTo(scientistNpc.userID, corpse);
                return corpse;
            }

            PopulateLoot(corpse.containers[0], configData.NPC.RandomItems);
            return corpse;
        }

        private object CanLootPlayer(ScientistNPC scientistNpc, BasePlayer player)
        {
            if (scientistNPCs.Contains(scientistNpc) && scientistNpc.IsWounded())
                return false;
            return null;
        }

        private object OnPlayerAssist(ScientistNPC scientistNpc, BasePlayer player)
        {
            if (scientistNPCs.Contains(scientistNpc))
                return false;
            return null;
        }

        private void Unload()
        {
            for (int i = 0; i < EjectionComponent.allHelicopters.Count; i++)
                UnityEngine.Object.Destroy(EjectionComponent.allHelicopters[i]);

            for (int i = 0; i < ParachutePhysics._allParachutes.Count; i++)
                UnityEngine.Object.Destroy(ParachutePhysics._allParachutes[i]);

            configData = null;
            Instance = null;
        }
        #endregion

        #region Functions
        private void RunAutomatedEvent()
        {
            timer.In(Random.Range(configData.Automation.Min, configData.Automation.Max), () =>
            {
                if (BasePlayer.activePlayerList.Count >= configData.Automation.RequiredPlayers)
                    SpawnEntity();

                RunAutomatedEvent();
            });
        }

        private EjectionComponent SpawnEntity()
        {
            BaseHelicopter baseHelicopter = GameManager.server.CreateEntity(HELICOPTER_PREFAB) as BaseHelicopter;
            baseHelicopter.enableSaving = false;
            baseHelicopter.Spawn();

            return baseHelicopter.gameObject.AddComponent<EjectionComponent>(); 
        }

        private static string GetGridString(Vector3 position)
        {
            Vector2 adjPosition = new Vector2((World.Size / 2) + position.x, (World.Size / 2) - position.z);
            return $"{NumberToString((int)(adjPosition.x / 145))}{((int)(adjPosition.y / 145)) - 1}";
        }

        private static string NumberToString(int number)
        {
            bool a = number > 26;
            System.Char c = (System.Char)(65 + (a ? number - 26 : number));
            return a ? "A" + c : c.ToString();
        }

        private static void StripInventory(BasePlayer player)
        {
            Item[] allItems = player.inventory.AllItems();

            for (int i = allItems.Length - 1; i >= 0; i--)
            {
                Item item = allItems[i];
                item.RemoveFromContainer();
                item.Remove();
            }
        }

        private static void ClearContainer(ItemContainer container)
        {
            if (container == null || container.itemList == null)
                return;

            while (container.itemList.Count > 0)
            {
                Item item = container.itemList[0];
                item.RemoveFromContainer();
                item.Remove(0f);
            }
        }

        private static void PopulateLoot(ItemContainer container, ConfigData.LootContainer loot)
        {
            if (container == null || loot == null)
                return;

            ClearContainer(container);

            int amount = Random.Range(loot.Minimum, loot.Maximum);

            List<ConfigData.LootItem> list = Pool.GetList<ConfigData.LootItem>();
            list.AddRange(loot.Items);

            int itemCount = 0;
            while (itemCount < amount)
            {
                int totalWeight = list.Sum((ConfigData.LootItem x) => Mathf.Max(1, x.Weight));
                int random = Random.Range(0, totalWeight);

                for (int i = list.Count - 1; i >= 0; i--)
                {
                    ConfigData.LootItem lootItem = list[i];

                    totalWeight -= Mathf.Max(1, lootItem.Weight);

                    if (random >= totalWeight)
                    {
                        list.Remove(lootItem);

                        Item item = ItemManager.CreateByName(lootItem.Name, Random.Range(lootItem.Minimum, lootItem.Maximum), lootItem.Skin);
                        item?.MoveToContainer(container);

                        itemCount++;
                        break;
                    }
                }

                if (list.Count == 0)
                    list.AddRange(loot.Items);
            }

            Pool.FreeList(ref list);            
        }
        #endregion

        #region Inventory Copy
        private void StoreInventory(ScientistNPC scientistNpc)
        {
            ItemContainer[] source = new ItemContainer[] { scientistNpc.inventory.containerMain, scientistNpc.inventory.containerWear, scientistNpc.inventory.containerBelt };

            ItemContainer[] containers = new ItemContainer[3];

            for (int i = 0; i < containers.Length; i++)
            {
                containers[i] = new ItemContainer();
                containers[i].ServerInitialize(null, source[i].capacity);
                containers[i].GiveUID();
                Item[] array = source[i].itemList.ToArray();
                for (int j = 0; j < array.Length; j++)
                {
                    Item item = array[j];
                    if (i == 1)
                    {
                        Item newItem = ItemManager.CreateByItemID(item.info.itemid, item.amount, item.skin);
                        if (!newItem.MoveToContainer(containers[i], -1, true))
                            newItem.Remove(0f);
                    }
                    else
                    {
                        if (!item.MoveToContainer(containers[i], -1, true))
                            item.Remove(0f);
                    }
                }
            }

            scientistInventory[scientistNpc.userID] = containers;
        }

        private void MoveInventoryTo(ulong scientistId, LootableCorpse corpse)
        {
            ItemContainer[] containers;
            if (scientistInventory.TryGetValue(scientistId, out containers))
            {
                for (int i = 0; i < containers.Length; i++)
                {
                    Item[] array = containers[i].itemList.ToArray();
                    for (int j = 0; j < array.Length; j++)
                    {
                        Item item = array[j];
                        if (!item.MoveToContainer(corpse.containers[i], -1, true))
                        {
                            item.Remove(0f);
                        }
                    }

                    containers[i].Kill();
                }

                scientistInventory.Remove(scientistId);

                corpse.ResetRemovalTime();
            }
        }
        #endregion

        #region Component        
        private class EjectionComponent : MonoBehaviour
        {
            internal static List<EjectionComponent> allHelicopters = new List<EjectionComponent>();

            internal BaseHelicopter Helicopter { get; private set; }

            internal PatrolHelicopterAI AI { get; private set; }
            
            private float actualHealth;

            internal bool ejectOverride = false;

            internal bool hasEjected = false;

            private void Awake()
            {
                allHelicopters.Add(this);

                Helicopter = GetComponent<BaseHelicopter>();
                AI = Helicopter.myAI;

                if (configData.Helicopter.DamageEffects)
                {
                    BaseHelicopter.weakspot weakspot = Helicopter.weakspots[1];
                    weakspot.healthFractionOnDestroyed = 0f;
                    weakspot.Hurt(weakspot.health, null);
                }

                actualHealth = Helicopter.health = configData.Helicopter.Health;
                Helicopter.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);

                if (configData.Ejection.EjectRandom)
                    InvokeHandler.Invoke(this, TryAutoEjection, Random.Range(configData.Ejection.Min, configData.Ejection.Max));
            }

            private void OnDestroy() => allHelicopters.Remove(this);

            internal void OnTakeDamage(HitInfo hitInfo)
            {
                if (!configData.Ejection.EjectOnKilled || hasEjected)
                    return;

                actualHealth -= hitInfo.damageTypes.Total();

                if (actualHealth < 0f)
                    EjectPilot();                
            }

            private void TryAutoEjection()
            {
                if (TerrainMeta.HeightMap.GetHeight(transform.position) < 0 || BasePlayer.activePlayerList.Count < configData.Automation.RequiredPlayers)
                {
                    InvokeHandler.Invoke(this, TryAutoEjection, Random.Range(30, 60));
                    return;
                }

                EjectPilot();
            }

            internal void EjectPilot()
            {
                if ((BasePlayer.activePlayerList.Count < configData.Automation.RequiredPlayers && !ejectOverride) || hasEjected)
                {
                    Destroy(this);
                    return;
                }

                InvokeHandler.CancelInvoke(this, EjectPilot);

                if (Instance.CustomNPC)
                    ServerMgr.Instance.StartCoroutine(SpawnNPCs(Helicopter));
                else Debug.LogWarning($"[PilotEject] - PilotEject requires the 'CustomNPC' plugin available at https://chaoscode.io to spawn NPC's!");

                DropLoot();

                hasEjected = true;

                if (actualHealth < 0f)
                {
                    if (configData.Notifications.Death)
                        Broadcast("Notification.OnDeath", GetGridString(transform.position));
                }
                else
                {
                    if (configData.Notifications.Malfunction)
                        Broadcast("Notification.Malfunction", GetGridString(transform.position));
                }

                if (!AI.isDead)
                    AI.CriticalDamage();

                Destroy(this);
            }

            private IEnumerator SpawnNPCs(BaseHelicopter baseHelicopter)
            {                
                Vector3 position = transform.position + (transform.up + (transform.forward * 2f));
                Quaternion rotation = transform.rotation;

                for (int i = 0; i < configData.NPC.Amount; i++)
                {
                    JObject settings = new JObject()
                    {
                        ["DisplayName"] = configData.NPC.Names?.Length > 0 ? configData.NPC.Names.GetRandom() : "ScientistNPC",
                        ["Health"] = configData.NPC.Health,
                        ["NPCType"] = "Scientist",
                        ["SightRange"] = configData.NPC.SightRange,
                        ["RoamRange"] = 25f,
                        ["ChaseRange"] = 90f,
                        ["Kit"] = configData.NPC.Kits.Length > 0 ? configData.NPC.Kits.GetRandom() : string.Empty,
                        ["KillInSafeZone"] = true,
                        ["DespawnTime"] = configData.NPC.Lifetime,
                        ["StartWounded"] = Random.Range(0, 100) <= configData.NPC.WoundedChance,
                        ["WoundedDuration"] = Random.Range(300f, 600f),
                        ["WoundedRecoveryChance"] = configData.NPC.RecoveryChance,
                        ["EnableNavMesh"] = false,
                        ["EquipWeapon"] = false,
                        ["States"] = new JArray { "IdleState", "RoamState", "ChaseState", "CombatState", "FallingState" }
                    };

                    ScientistNPC scientistNPC = Instance.CustomNPC?.Call<ScientistNPC>("SpawnNPC", Instance, position, settings);
                    if (scientistNPC != null)
                    {
                        Instance.scientistNPCs.Add(scientistNPC);
                        scientistNPC.gameObject.AddComponent<ParachutePhysics>().Helicopter = baseHelicopter;
                    }
                    
                    yield return CoroutineEx.waitForSeconds(0.5f);
                }
            }

            private void DropLoot()
            {
                if (configData.LootBoxes.Amount <= 0)
                    return;

                for (int i = 0; i < configData.LootBoxes.Amount; i++)
                {
                    LootContainer container = GameManager.server.CreateEntity(Helicopter.crateToDrop.resourcePath, transform.position) as LootContainer;
                    container.enableSaving = false;
                    container.Spawn();

                    Vector3 velocity = Random.onUnitSphere;
                    velocity.y = 1;

                    Rigidbody rb = container.gameObject.AddComponent<Rigidbody>();
                    rb.useGravity = true;
                    rb.collisionDetectionMode = CollisionDetectionMode.ContinuousDynamic;
                    rb.mass = 2f;
                    rb.interpolation = RigidbodyInterpolation.Interpolate;
                    rb.angularVelocity = Vector3Ex.Range(-1.75f, 1.75f);
                    rb.drag = 0.5f * (rb.mass / 5f);
                    rb.angularDrag = 0.2f * (rb.mass / 5f);

                    rb.AddForce(velocity * 5f, ForceMode.Impulse);

                    ClearContainer(container.inventory);
                    PopulateLoot(container.inventory, configData.LootBoxes.RandomItems);
                }
            }
        }

        internal class ParachutePhysics : MonoBehaviour
        {
            internal static List<ParachutePhysics> _allParachutes = new List<ParachutePhysics>();

            internal ScientistNPC Entity { get; private set; }

            internal BaseHelicopter Helicopter { get; set; }

            private Transform tr;

            private Rigidbody rb;

            private BaseEntity parachute;

            private Vector3 currentWindVector = Vector3.zero;

            internal Vector3 crashSite;

            private bool isFalling;

            private bool wasWounded = false;

            private Vector3 DirectionTowardsCrash2D
            {
                get
                {
                    if (Helicopter != null && !Helicopter.IsDestroyed)
                        return (Helicopter.transform.position.XZ3D() - tr.position.XZ3D()).normalized;
                    return (crashSite.XZ3D() - tr.position.XZ3D()).normalized;
                }
            }

            private void Awake()
            {
                Entity = GetComponent<ScientistNPC>();

                tr = Entity.transform;

                InitializeVelocity();

                _allParachutes.Add(this);

                wasWounded = Entity.HasPlayerFlag(BasePlayer.PlayerFlags.Wounded);
                Entity.SetPlayerFlag(BasePlayer.PlayerFlags.Wounded, false);
            }

            private void OnDestroy()
            {
                _allParachutes.Remove(this);

                if (parachute != null && !parachute.IsDestroyed)
                    parachute.Kill();
            }

            private void Update()
            {
                Entity.modelState.onground = false;
                Entity.modelState.flying = true;

                if (!isFalling)
                    return;
                else
                {
                    if (Physics.Raycast(tr.position, Vector3.down, 0.5f, LAND_LAYERS))
                    {
                        enabled = false;
                        isFalling = false;

                        rb.useGravity = false;
                        rb.isKinematic = true;
                        rb.drag = 0;

                        Entity.modelState.onground = true;
                        Entity.modelState.flying = false;

                        if (parachute != null && !parachute.IsDestroyed)
                            parachute.Kill();

                        if (TerrainMeta.WaterMap.GetDepth(tr.position) > 0.6f)
                        {
                            Entity.Die(new HitInfo(null, Entity, DamageType.Drowned, 1000f));
                            return;
                        }

                        OnParachuteLand();
                    }                    
                }
            }

            private void FixedUpdate()
            {
                if (!isFalling && rb.velocity.y < 0)
                    DeployParachute();

                if (isFalling)
                {
                    Vector3 windAtPosition = Vector3.Lerp(DirectionTowardsCrash2D, GetWindAtCurrentPos(), Helicopter != null && !Helicopter.IsDestroyed ? 0.25f : 0.75f);

                    float heightFromGround = Mathf.Max(TerrainMeta.HeightMap.GetHeight(tr.position), TerrainMeta.WaterMap.GetHeight(tr.position));
                    float force = Mathf.InverseLerp(heightFromGround + 20f, heightFromGround + 60f, tr.position.y);

                    Vector3 normalizedDir = (windAtPosition.normalized * force) * configData.Ejection.Wind;

                    currentWindVector = Vector3.Lerp(currentWindVector, normalizedDir, Time.fixedDeltaTime * 0.25f);

                    rb.AddForceAtPosition(normalizedDir * 0.1f, tr.position, ForceMode.Force);
                    rb.AddForce(normalizedDir * 0.9f, ForceMode.Force);

                    Quaternion rotation = Quaternion.LookRotation(rb.velocity);
                    tr.rotation = Entity.eyes.rotation = Entity.ServerRotation = rotation;
                    Entity.viewAngles = rotation.eulerAngles;

                    parachute.transform.localRotation = Quaternion.Euler(0f, rotation.eulerAngles.y, 0f);
                    parachute.SendNetworkUpdate();
                }
            }

            private void InitializeVelocity()
            {
                rb = Entity.GetComponent<Rigidbody>();
                rb.useGravity = true;
                rb.isKinematic = false;
                rb.AddForce((Vector3.up * 15) + (Random.onUnitSphere.XZ3D() * 5), ForceMode.Impulse);
            }

            private void DeployParachute()
            {
                parachute = GameManager.server.CreateEntity(PARACHUTE_PREFAB, tr.position);
                parachute.enableSaving = false;
                parachute.Spawn();

                parachute.SetParent(Entity, false);
                parachute.transform.localPosition = Vector3.up * 2f;
                parachute.transform.localRotation = Quaternion.Euler(0f, Entity.viewAngles.y, 0f);

                rb.drag = configData.Ejection.Drag;

                if (configData.Ejection.ShowSmoke)
                    Effect.server.Run(SMOKE_EFFECT, parachute, 0, Vector3.zero, Vector3.zero, null, true);

                Entity.Invoke(() =>
                {
                    Entity.modelState.onground = false;
                    Entity.modelState.flying = true;
                    Entity.SendNetworkUpdate();
                }, 1f);

                isFalling = true;
            }

            private Vector3 GetWindAtCurrentPos()
            {
                float single = tr.position.y * 6f;
                Vector3 force = new Vector3(Mathf.Sin(single * 0.0174532924f), 0f, Mathf.Cos(single * 0.0174532924f));
                return force.normalized * 1f;
            }

            private void OnParachuteLand()
            {
                Instance.CustomNPC?.Call("SetRoamHomePosition", Entity, Helicopter != null && !Helicopter.IsDestroyed ? Helicopter.transform.position : crashSite);

                if (wasWounded)
                    Entity.SetPlayerFlag(BasePlayer.PlayerFlags.Wounded, true);

                Destroy(this);
            }
        }        
        #endregion

        #region Commands
        [ChatCommand("pe")]
        private void cmdPilotEject(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, ADMIN_PERM) && !player.IsAdmin)
                return;

            if (args.Length == 0)
            {
                SendReply(player, "/pe call - Call a PilotEject helicopter");
                SendReply(player, "/pe eject - Force eject any active pilots");
                return;
            }

            switch (args[0].ToLower())
            {
                case "call":
                    SpawnEntity();
                    SendReply(player, "Spawned PilotEject helicopter");
                    return;
                case "c":
                    if (player.net.connection.authLevel == 2)
                    {
                        EjectionComponent ejectionComponent = SpawnEntity();
                        timer.In(1f, () => ejectionComponent.Helicopter.transform.position = player.transform.position);
                    }
                    return;
                case "s":
                    if (player.net.connection.authLevel == 2)
                    {
                        for (int i = 0; i < EjectionComponent.allHelicopters.Count; i++)
                        {
                            EjectionComponent ejectionComponent = EjectionComponent.allHelicopters[i];
                            ejectionComponent.Helicopter.Die(new HitInfo(ejectionComponent.Helicopter, ejectionComponent.Helicopter, Rust.DamageType.Explosion, 100000));
                        }
                    }
                    return;
                case "eject":
                    int count = 0;
                    for (int i = 0; i < EjectionComponent.allHelicopters.Count; i++)
                    {
                        EjectionComponent ejectionComponent = EjectionComponent.allHelicopters[i];
                        if (!ejectionComponent.hasEjected)
                        {
                            ejectionComponent.ejectOverride = true;
                            ejectionComponent.EjectPilot();
                            count++;
                        }
                    }
                    SendReply(player, $"Ejected {count * configData.NPC.Amount} pilots from {count} helicopters");
                    return;

                default:
                    SendReply(player, "Invalid syntax!");
                    break;
            }
        }

        [ConsoleCommand("pe")]
        private void ccmdPilotEject(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null)
            {
                if (!permission.UserHasPermission(arg.Connection.userid.ToString(), ADMIN_PERM))
                {
                    SendReply(arg, "You do not have permission to use this command");
                    return;
                }
            }

            if (arg.Args.Length == 0)
            {
                SendReply(arg, "pe call - Call a PilotEject helicopter");
                SendReply(arg, "pe eject - Force eject any active pilots");
                return;
            }

            switch (arg.Args[0].ToLower())
            {
                case "call":
                    SpawnEntity();
                    return;                
                case "eject":
                    int count = 0;
                    for (int i = 0; i < EjectionComponent.allHelicopters.Count; i++)
                    {
                        EjectionComponent ejectionComponent = EjectionComponent.allHelicopters[i];
                        if (!ejectionComponent.hasEjected)
                        {
                            ejectionComponent.ejectOverride = true;
                            ejectionComponent.EjectPilot();
                            count++;
                        }
                    }
                    SendReply(arg, $"Ejected {count * configData.NPC.Amount} pilots from {count} helicopters");
                    return;

                default:
                    SendReply(arg, "Invalid syntax!");
                    break;
            }
        }
        #endregion

        #region Config        
        private static ConfigData configData;
        private class ConfigData
        {
            [JsonProperty(PropertyName = "Event Automation")]
            public AutomationOptions Automation { get; set; }

            [JsonProperty(PropertyName = "Ejection Options")]
            public EjectionOptions Ejection { get; set; }

            [JsonProperty(PropertyName = "Helicopter Options")]
            public HelicopterOptions Helicopter { get; set; }

            [JsonProperty(PropertyName = "Notification Options")]
            public NotificationOptions Notifications { get; set; }

            [JsonProperty(PropertyName = "NPC Options")]
            public NPCOptions NPC { get; set; }

            [JsonProperty(PropertyName = "Loot Container Options")]
            public Loot LootBoxes { get; set; }

            public class AutomationOptions
            {
                [JsonProperty(PropertyName = "Automatically spawn helicopters on a timer")]
                public bool AutoSpawn { get; set; }

                [JsonProperty(PropertyName = "Auto-spawn time minimum (seconds)")]
                public float Min { get; set; }

                [JsonProperty(PropertyName = "Auto-spawn time maximum (seconds)")]
                public float Max { get; set; }

                [JsonProperty(PropertyName = "Minimum amount of online players to trigger the event")]
                public int RequiredPlayers { get; set; }

                [JsonProperty(PropertyName = "Chance of game spawned helicopter becoming a PilotEject helicopter (x / 100)")]
                public float Chance { get; set; }
            }

            public class EjectionOptions
            {
                [JsonProperty(PropertyName = "Eject the pilot when the helicopter has been shot down")]
                public bool EjectOnKilled { get; set; }

                [JsonProperty(PropertyName = "Eject the pilot when the helicopter has been destroyed mid-air")]
                public bool EjectOnDeath { get; set; }

                [JsonProperty(PropertyName = "Eject the pilot randomly")]
                public bool EjectRandom { get; set; }

                [JsonProperty(PropertyName = "Show smoke when parachuting")]
                public bool ShowSmoke { get; set; }

                [JsonProperty(PropertyName = "Random ejection time minimum (seconds)")]
                public float Min { get; set; }

                [JsonProperty(PropertyName = "Random ejection time maximum (seconds)")]
                public float Max { get; set; }

                [JsonProperty(PropertyName = "Parachute drag force")]
                public float Drag { get; set; }

                [JsonProperty(PropertyName = "Wind force")]
                public float Wind { get; set; }
            }

            public class HelicopterOptions
            {
                [JsonProperty(PropertyName = "Helicopter spawns with tail rotor on fire")]
                public bool DamageEffects { get; set; }

                [JsonProperty(PropertyName = "Start health")]
                public float Health { get; set; }
            }

            public class NotificationOptions
            {
                [JsonProperty(PropertyName = "Show notification when helicopter has been shot down")]
                public bool Death { get; set; }

                [JsonProperty(PropertyName = "Show notification when helicopter malfunctions")]
                public bool Malfunction { get; set; }

                [JsonProperty(PropertyName = "Show notification when a NPC has been killed")]
                public bool NPCDeath { get; set; }
            }

            public class NPCOptions
            {
                [JsonProperty(PropertyName = "Amount of NPCs to spawn")]
                public int Amount { get; set; }

                [JsonProperty(PropertyName = "NPC display name (chosen at random)")]
                public string[] Names { get; set; }

                [JsonProperty(PropertyName = "NPC kit (chosen at random)")]
                public string[] Kits { get; set; }

                [JsonProperty(PropertyName = "NPC health")]
                public int Health { get; set; }

                [JsonProperty(PropertyName = "Chance of being wounded when landing (x / 100)")]
                public int WoundedChance { get; set; }

                [JsonProperty(PropertyName = "Chance of recovery from being wounded(x / 100)")]
                public int RecoveryChance { get; set; }

                [JsonProperty(PropertyName = "Amount of time the NPCs will be alive before suiciding (seconds) (0 = disabled)")]
                public int Lifetime { get; set; }

                [JsonProperty(PropertyName = "Roam distance from landing position")]
                public float RoamDistance { get; set; }

                [JsonProperty(PropertyName = "Sight range")]
                public float SightRange { get; set; }

                [JsonProperty(PropertyName = "Loot type (Default, Inventory, Random)")]
                public string LootType { get; set; }

                [JsonProperty(PropertyName = "Random loot items")]
                public LootContainer RandomItems { get; set; }

                [JsonProperty(PropertyName = "Can be targeted by turrets")]
                public bool TargetedByTurrets { get; set; }
            }

            public class Loot
            {
                [JsonProperty(PropertyName = "Amount of loot boxes to drop when pilot ejects")]
                public int Amount { get; set; }

                [JsonProperty(PropertyName = "Loot container items")]
                public LootContainer RandomItems { get; set; }
            }

            public class LootContainer
            {
                [JsonProperty(PropertyName = "Minimum amount of items")]
                public int Minimum { get; set; }

                [JsonProperty(PropertyName = "Maximum amount of items")]
                public int Maximum { get; set; }

                [JsonProperty(PropertyName = "Items")]
                public LootItem[] Items { get; set; }
            }

            public class LootItem
            {
                [JsonProperty(PropertyName = "Item shortname")]
                public string Name { get; set; }

                [JsonProperty(PropertyName = "Item skin ID")]
                public ulong Skin { get; set; }

                [JsonProperty(PropertyName = "Minimum amount of item")]
                public int Minimum { get; set; }

                [JsonProperty(PropertyName = "Maximum amount of item")]
                public int Maximum { get; set; }

                [JsonProperty(PropertyName = "Item weight (a larger number has more chance of being selected)")]
                public int Weight { get; set; } = 1;
            }

            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();

            if (configData.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                Automation = new ConfigData.AutomationOptions
                {
                    AutoSpawn = false,
                    Chance = 100,
                    Min = 3600,
                    Max = 5400,
                    RequiredPlayers = 1,
                },
                Ejection = new ConfigData.EjectionOptions
                {
                    Drag = 2f,
                    EjectOnDeath = false,
                    EjectOnKilled = true,
                    EjectRandom = false,
                    ShowSmoke = false,
                    Min = 300,
                    Max = 600,
                    Wind = 10f
                },
                Helicopter = new ConfigData.HelicopterOptions
                {
                    DamageEffects = false,
                    Health = 10000
                },
                Notifications = new ConfigData.NotificationOptions
                {
                    Death = true,
                    Malfunction = true,
                    NPCDeath = true
                },
                NPC = new ConfigData.NPCOptions
                {
                    Amount = 1,
                    Names = new string[0],
                    Kits = new string[0],
                    LootType = "Random",
                    Health = 150,
                    Lifetime = 0,
                    RandomItems = new ConfigData.LootContainer
                    {
                        Minimum = 3,
                        Maximum = 5,
                        Items = new ConfigData.LootItem[]
                        {
                            new ConfigData.LootItem {Name = "apple", Skin = 0, Maximum = 6, Minimum = 2 },
                            new ConfigData.LootItem {Name = "bearmeat.cooked", Skin = 0, Maximum = 4, Minimum = 2 },
                            new ConfigData.LootItem {Name = "blueberries", Skin = 0, Maximum = 8, Minimum = 4 },
                            new ConfigData.LootItem {Name = "corn", Skin = 0, Maximum = 8, Minimum = 4 },
                            new ConfigData.LootItem {Name = "fish.raw", Skin = 0, Maximum = 4, Minimum = 2 },
                            new ConfigData.LootItem {Name = "granolabar", Skin = 0, Maximum = 4, Minimum = 1 },
                            new ConfigData.LootItem {Name = "meat.pork.cooked", Skin = 0, Maximum = 8, Minimum = 4 },
                            new ConfigData.LootItem {Name = "candycane", Skin = 0, Maximum = 2, Minimum = 1 }
                        }
                    },
                    RecoveryChance = 80,
                    SightRange = 60f,
                    RoamDistance = 50,
                    WoundedChance = 15
                },
                LootBoxes = new ConfigData.Loot
                {
                    Amount = 2,
                    RandomItems = new ConfigData.LootContainer
                    {
                        Minimum = 3,
                        Maximum = 5,
                        Items = new ConfigData.LootItem[]
                        {
                            new ConfigData.LootItem {Name = "apple", Skin = 0, Maximum = 6, Minimum = 2 },
                            new ConfigData.LootItem {Name = "bearmeat.cooked", Skin = 0, Maximum = 4, Minimum = 2 },
                            new ConfigData.LootItem {Name = "blueberries", Skin = 0, Maximum = 8, Minimum = 4 },
                            new ConfigData.LootItem {Name = "corn", Skin = 0, Maximum = 8, Minimum = 4 },
                            new ConfigData.LootItem {Name = "fish.raw", Skin = 0, Maximum = 4, Minimum = 2 },
                            new ConfigData.LootItem {Name = "granolabar", Skin = 0, Maximum = 4, Minimum = 1 },
                            new ConfigData.LootItem {Name = "meat.pork.cooked", Skin = 0, Maximum = 8, Minimum = 4 },
                            new ConfigData.LootItem {Name = "candycane", Skin = 0, Maximum = 2, Minimum = 1 }
                        }
                    }
                },
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();

            if (configData.Version < new Core.VersionNumber(3, 0, 0))
                configData = baseConfig;

            if (configData.Version < new Core.VersionNumber(3, 0, 1))            
                configData.NPC.Health = baseConfig.NPC.Health;            

            if (configData.Version < new Core.VersionNumber(3, 0, 2))
                configData.Helicopter = baseConfig.Helicopter;

            if (configData.Version < new Core.VersionNumber(3, 0, 3))
                configData.Notifications = baseConfig.Notifications;

            if (configData.Version < new Core.VersionNumber(3, 0, 4))
            {
                configData.NPC.Lifetime = 0;
                configData.Ejection.ShowSmoke = false;
            }

            if (configData.Version < new Core.VersionNumber(3, 0, 10))
            {
                configData.NPC.SightRange = 60f;
            }

            if (configData.Version < new Core.VersionNumber(3, 1, 2))
            {
                for (int i = 0; i < configData.LootBoxes.RandomItems.Items.Length; i++)                
                    configData.LootBoxes.RandomItems.Items[i].Weight = 1;
            }

            configData.Version = Version;
            PrintWarning("Config update completed!");
        }

        #endregion

        #region Localization
        private static void Broadcast(string key, params object[] args)
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
                player.ChatMessage(args?.Length > 0 ? string.Format(Instance.Message(key, player.userID), args) : Instance.Message(key, player.userID));
        }

        private string Message(string key, ulong playerId = 0UL) => lang.GetMessage(key, this, playerId == 0UL ? null : playerId.ToString());

        private Dictionary<string, string> Messages = new Dictionary<string, string>
        {           
            ["Notification.OnDeath"] = "<color=#ce422b>[Pilot Eject]</color> A <color=#aaff55>Patrol Helicopter</color> has been shot down and the pilot had to eject. He was last spotted near <color=#aaff55>{0}</color>",
            ["Notification.Malfunction"] = "<color=#ce422b>[Pilot Eject]</color> A <color=#aaff55>Patrol Helicopter</color> has malfunctioned and the pilot had to eject. He was last spotted near <color=#aaff55>{0}</color>",
            ["Notification.PilotKilled"] = "<color=#ce422b>[Pilot Eject]</color> A <color=#aaff55>Patrol Helicopter</color> pilot has been killed by <color=#aaff55>{0}</color>",
        };
        #endregion
    }
}


// --- End of file: PilotEject.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/DiscordWin.cs ---
// --- Original Local Path: DiscordWin.cs ---

using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("DiscordWin", "Visagalis", "1.1.0")]
    [Description("Starts event to win some stuff via Discord.")]
    class DiscordWin : RustPlugin
    {
        [PluginReference]
        Plugin DiscordMessages;
        [PluginReference] 
        Plugin ServerRewards;
        [PluginReference] 
        Plugin Economics;

        string secretCode = null;
        int reward = 0;

        List<ulong> claimedReward = new List<ulong>();

        public static class DWConfig
        {
            public static bool UseEconomics = true;
            public static bool UseServerRewards = true;
            public static string WebHookUrl = "";
            public static string DiscordChannel = "#events";
            public static int RewardBase = 100;
            public static int RewardMinPlusVariance = 50;
            public static int RewardMaxPlusVariance = 100;
            public static float RewardMultiplyBaseMinVariance = 1.0f;
            public static float RewardMultiplyBaseMaxVariance = 2.5f;
            public static int EventLengthMinVariance = 300;
            public static int EventLengthMaxVariance = 900;
            public static int EventOccurenceMinVariance = 3600;
            public static int EventOccurenceMaxVariance = 7200;
            public static int EventAnnounceMinVariance = 60;
            public static int EventAnnounceMaxVariance = 120;
            public static int MaximumWinners = 0;
        }

        void LoadDefaultConfig()
        {
            Puts("Generating new config file...");
            LoadConfig();
        }

        void InitConfig()
        {
            DWConfig.UseEconomics = int.Parse(Config["Settings", "Reward with Economics"].ToString()) == 1;
            DWConfig.UseServerRewards = int.Parse(Config["Settings", "Reward with ServerRewards"].ToString()) == 1;
            DWConfig.WebHookUrl =  Config["Settings", "Discord WebhookURL"].ToString();
            DWConfig.DiscordChannel =  Config["Settings", "Discord Channel"].ToString();
            DWConfig.RewardBase =  int.Parse(Config["Settings", "Reward Base"].ToString());
            DWConfig.RewardMinPlusVariance =  int.Parse(Config["Settings", "Reward Plus Min Variance"].ToString());
            DWConfig.RewardMaxPlusVariance =  int.Parse(Config["Settings", "Reward Plus Max Variance"].ToString());
            DWConfig.RewardMultiplyBaseMinVariance =  float.Parse(Config["Settings", "Reward Multiply Base Min Variance"].ToString());
            DWConfig.RewardMultiplyBaseMaxVariance =  float.Parse(Config["Settings", "Reward Multiply Base Max Variance"].ToString());
            DWConfig.EventLengthMinVariance =  int.Parse(Config["Settings", "Event Length Min Variance (seconds)"].ToString());
            DWConfig.EventLengthMaxVariance =  int.Parse(Config["Settings", "Event Length Max Variance (seconds)"].ToString());
            DWConfig.EventOccurenceMinVariance =  int.Parse(Config["Settings", "Event Occurence Min Variance (seconds)"].ToString());
            DWConfig.EventOccurenceMaxVariance =  int.Parse(Config["Settings", "Event Occurence Max Variance (seconds)"].ToString());
            DWConfig.EventAnnounceMinVariance =  int.Parse(Config["Settings", "Event Announce Min Variance (seconds)"].ToString());
            DWConfig.EventAnnounceMaxVariance =  int.Parse(Config["Settings", "Event Announce Max Variance (seconds)"].ToString());
            DWConfig.MaximumWinners =  int.Parse(Config["Settings", "Event Max Winners Count (0 for infinity)"].ToString());
        }

        void LoadConfig()
        {
            SetConfig("Settings", "Reward with Economics", "1"); // UseEconomics
            SetConfig("Settings", "Reward with ServerRewards", "1"); // UseServerRewards
            SetConfig("Settings", "Discord WebhookURL", ""); //WebHookUrl
            SetConfig("Settings", "Discord Channel", "#events"); //DiscordChannel
            SetConfig("Settings", "Reward Base", "100"); // RewardBase
            SetConfig("Settings", "Reward Plus Min Variance", "50"); // RewardMinPlusVariance
            SetConfig("Settings", "Reward Plus Max Variance", "100"); // RewardMaxPlusVariance
            SetConfig("Settings", "Reward Multiply Base Min Variance", "1.0"); // RewardMultiplyBaseMinVariance
            SetConfig("Settings", "Reward Multiply Base Max Variance", "2.5"); // RewardMultiplyBaseMaxVariance
            SetConfig("Settings", "Event Length Min Variance (seconds)", "300"); // EventLengthMinVariance
            SetConfig("Settings", "Event Length Max Variance (seconds)", "900"); // EventLengthMaxVariance
            SetConfig("Settings", "Event Occurence Min Variance (seconds)", "3600"); // EventOccurenceMinVariance
            SetConfig("Settings", "Event Occurence Max Variance (seconds)", "900"); // EventOccurenceMaxVariance
            SetConfig("Settings", "Event Announce Min Variance (seconds)", "60"); // EventAnnounceMinVariance
            SetConfig("Settings", "Event Announce Max Variance (seconds)", "90"); // EventAnnounceMaxVariance
            SetConfig("Settings", "Event Max Winners Count (0 for infinity)", "0"); // MaximumWinners
        }

        void SetConfig(params object[] args)
        {
            List<string> stringArgs = (from arg in args select arg.ToString()).ToList();
            stringArgs.RemoveAt(args.Length - 1);

            if (Config.Get(stringArgs.ToArray()) == null) Config.Set(args);
        }

        void OnServerInitialized()
        {
            LoadConfig();
            InitConfig();
            int minReward = (int)(DWConfig.RewardBase * DWConfig.RewardMultiplyBaseMinVariance + DWConfig.RewardMinPlusVariance);
            int maxReward = (int)(DWConfig.RewardBase * DWConfig.RewardMultiplyBaseMaxVariance + DWConfig.RewardMaxPlusVariance);

            Puts($"Event will happen every approx. {(DWConfig.EventOccurenceMinVariance + DWConfig.EventOccurenceMaxVariance)/2} seconds.");
            Puts($"Event will last for approx. {(DWConfig.EventLengthMinVariance + DWConfig.EventLengthMaxVariance)/2} seconds.");
            if(DWConfig.MaximumWinners > 0)
                Puts($"Or until {DWConfig.MaximumWinners} player claims reward.");
            Puts($"Event will announce every approx. {(DWConfig.EventAnnounceMinVariance + DWConfig.EventAnnounceMaxVariance)/2} seconds.");
            Puts($"Event will reward approx. {(minReward + maxReward)/2} points for Economics: {DWConfig.UseEconomics} and ServerRewards: {DWConfig.UseServerRewards}.");
            timer.Once(UnityEngine.Random.Range(DWConfig.EventOccurenceMinVariance, DWConfig.EventOccurenceMaxVariance), StartEvent);
        }

        void Unloaded()
        {
            EndEvent("\nPlugin unloaded!");
        }

        [ChatCommand("get")]
        void cmdTest(BasePlayer player, string command, string[] args)
        {
            if (string.IsNullOrEmpty(secretCode))
            {
                Tell(player, "¡El evento no ha comenzado todavía!");
                return;
            }
            if(args.Length != 1 || args[0] != secretCode)
            {
                Tell(player, "¡Has introducido un código secreto incorrecto!");
                return;
            }
            
            if(args[0] == secretCode)
            {
                if (claimedReward.Contains(player.userID))
                    Tell(player, "¡Ya has reclamado esta recompensa!");
                else
                {
                    claimedReward.Add(player.userID);
                    Tell(player, $"Has conseguido <color=orange>{reward}</color> Pesos!");
                    SendMessageToDiscord($"`{player.displayName}` ha conseguido `{reward}` Pesos!", ":information_source:");
                    if(DWConfig.UseServerRewards)
                        ServerRewards?.Call("AddPoints", player.userID, reward);
                    if(DWConfig.UseEconomics)
                        Economics?.Call("Deposit", player.userID, (double)reward);
                }

                if (DWConfig.MaximumWinners > 0 && DWConfig.MaximumWinners <= claimedReward.Count)
                    EndEvent($"\nCantidad máxima de jugadores ({DWConfig.MaximumWinners}) ha reclamado el premio!");
            }
        }

        void Tell(BasePlayer player, string message)
        {
            Player.Message(player, message);
        }

        void Broadcast(string message)
        {
            Server.Broadcast(message);
        }

        void StartEvent()
        {
            double finalMultiplyVariance = 1;
            if (DWConfig.RewardMultiplyBaseMinVariance > 1)
                finalMultiplyVariance = UnityEngine.Random.Range(DWConfig.RewardMultiplyBaseMinVariance, DWConfig.RewardMultiplyBaseMaxVariance);

            int finalPlusVariance = 0;
            if (DWConfig.RewardMaxPlusVariance > 1)
                finalPlusVariance = UnityEngine.Random.Range(DWConfig.RewardMinPlusVariance, DWConfig.RewardMaxPlusVariance);

            reward = (int)(DWConfig.RewardBase * finalMultiplyVariance + finalPlusVariance);
            secretCode = Guid.NewGuid().ToString().Replace("-", "").ToUpper();
            SendMessageToDiscord($"¡El evento del Servidor x20 ha empezado! Escribe `/get {secretCode}` en el juego para obtener `{reward}` Pesos!", ":star:");
            ContinueslyBroadcast();
            timer.Once(UnityEngine.Random.Range(DWConfig.EventLengthMinVariance, DWConfig.EventLengthMaxVariance), () => EndEvent());
        }

        void ContinueslyBroadcast()
        {
            if (string.IsNullOrEmpty(secretCode) || reward == 0)
                return;

            if (claimedReward.Count == 0)
            {
                Broadcast($"<color=red>ATENCIÓN -</color> ¡El evento para ganar <color=orange>{reward}</color> Pesos ha comenzado!" +
                $"\nÚnete a nuestro servidor de Discord, comprueba el canal <color=orange>{DWConfig.DiscordChannel}</color> para reclamar el premio");
            }
            else
            {
                Broadcast($"¡El evento para ganar <color=orange>{reward}</color> Pesos ha comenzado!" +
                    $"\nÚnete a nuestro servidor de Discord, comprueba el canal <color=orange>{DWConfig.DiscordChannel}</color> para reclamar el premio!");
            }

            timer.Once(UnityEngine.Random.Range(DWConfig.EventAnnounceMinVariance, DWConfig.EventAnnounceMaxVariance), ContinueslyBroadcast);
        }

        void EndEvent(string reason = "")
        {
            if (secretCode == null || reward == 0)
                return;

            secretCode = null;
            SendMessageToDiscord($"¡El evento del Servidor x20 para obtener `{reward}` Pesos ha finalizado!{reason}", ":checkered_flag:");
            Broadcast($"¡El evento del Servidor x20 para obtener <color=orange>{reward}</color> Pesos ha finalizado!{reason}");

            reward = 0;
            claimedReward.Clear();
            timer.Once(UnityEngine.Random.Range(DWConfig.EventOccurenceMinVariance, DWConfig.EventOccurenceMaxVariance), StartEvent);
        }

        void SendMessageToDiscord(string message, string icon = ":bulb:")
        {
            if (string.IsNullOrEmpty(DWConfig.WebHookUrl))
                Interface.Oxide.LogWarning(
                    $"WARNING! Discord webhook URL is not defined! Message which wasn't sent: {message}");
            else
                DiscordMessages?.Call("API_SendTextMessage", DWConfig.WebHookUrl, $"{icon} {message}");
        }
    }
}


// --- End of file: DiscordWin.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/XLevels.cs ---
// --- Original Local Path: XLevels.cs ---

using UnityEngine;
using Oxide.Core;
using System.Collections.Generic;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Plugins;
using ConVar;
using Oxide.Core.Libraries.Covalence;
using Newtonsoft.Json;
using System.Linq;
using System;
		   		 		  						  	   		  	   		  	   		   		 		  		  
namespace Oxide.Plugins
{
    [Info("XLevels", "MONSTER", "1.1.12")]
    class XLevels : RustPlugin
    {
		
		private void Message(BasePlayer player, string Messages)
        {
            CuiElementContainer container = new CuiElementContainer();
		   		 		  						  	   		  	   		  	   		   		 		  		  
            container.Add(new CuiLabel
            {
				FadeOut = 0.5f,
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-250 0", OffsetMax = "-200 26" },
                Text = { FadeIn = 0.5f, Text = $"{Messages}", Align = TextAnchor.MiddleRight, Font = "robotocondensed-regular.ttf", FontSize = 13, Color = "1 1 1 0.4" }
            }, ".GUIProgress", ".Message", ".Message");

            CuiHelper.AddUi(player, container);
		   		 		  						  	   		  	   		  	   		   		 		  		  
            timer.Once(2.5f, () => { CuiHelper.DestroyUi(player, ".Message"); });
        }
		
		private void OnPluginUnloaded(Plugin name)
		{
			if(name.Title == "Better Chat" && config.Setting.ChatPrefix)
				Subscribe(nameof(OnPlayerChat));
		}
		
		private void OnPluginLoaded(Plugin name)
		{
			if(name.Title == "Better Chat")
				Unsubscribe(nameof(OnPlayerChat));
		}
		
		[ConsoleCommand("level")]
		private void ccmdOpenMenu(ConsoleSystem.Arg arg)
		{
			BasePlayer player = arg.Player();
			
			Effect x = new Effect("assets/bundled/prefabs/fx/notice/loot.drag.grab.fx.prefab", player, 0, new Vector3(), new Vector3());
			
            switch (arg.Args[0].ToLower())
            {                
				case "page_lvl":
				{
					int Page = int.Parse(arg.Args[2]);
					
					switch (arg.Args[1])    
					{
						case "next": 
						{ 
							RewardMenu(player, Page + 1);
							break;
						}						
						case "back":
						{
							RewardMenu(player, Page - 1);
							break;
						}
					}
					break;
				}				
				case "page_inv":
				{
					int Page = int.Parse(arg.Args[2]);
					
					switch (arg.Args[1])
					{
						case "next":
						{
							InventoryRewardMenu(player, Page + 1);
							break;
						}						
						case "back":
						{
							InventoryRewardMenu(player, Page - 1);
							break;
						}
					}
					break;
				}
				case "exchangeinfo":
				{
					if(!config.Setting.CouponsValide) return;
					
					ExchangeInfo(player);
					break;
				}				
				case "exchange":
				{
					if(!config.Setting.CouponsValide) return;
					
					CouponExchange(player, int.Parse(arg.Args[1]));
					break;
				}				
				case "info":
				{
					Info(player);
					break;
				}				
				case "inventory":
				{
					InventoryRewardMenu(player);
					break;
				}				
				case "top":
				{
					if(permission.UserHasPermission(player.UserIDString, permTop)) Top(player);
					break;
				}
			}
			
			EffectNetwork.Send(x, player.Connection);
		}
		
		private void OnLootEntityEnd(BasePlayer player, NPCVendingMachine machine)
		{
			if(config.Vending.VendingUse)
			{
				CuiHelper.DestroyUi(player, ".Level_Overlay");
				CuiHelper.DestroyUi(player, ".Button");
			}
		}
		
		[ConsoleCommand("x_levels")]
		private void ccmdMenuOpen(ConsoleSystem.Arg arg)
		{
			BasePlayer player = arg.Player();
			
			GUIOpen(player);
		}
		
		private void RewardMenuFon(BasePlayer player)
		{
            CuiElementContainer container = new CuiElementContainer();
			
			bool couponsvalide = config.Setting.CouponsValide;
			bool vipvalide = config.Setting.VIPValide;
			
			var colorO = config.GUI.ColorBackgroundO;
			var colorT = config.GUI.ColorBackgroundT;
			
			container.Add(new CuiPanel
            {
                CursorEnabled = true,
				RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-532.5 -140", OffsetMax = "532.5 150" },
                Image = { Color = colorO, Material = "assets/icons/greyout.mat" }
            }, "Overlay", ".Level_Overlay", ".Level_Overlay");				
			
			container.Add(new CuiPanel
            {
				RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 5", OffsetMax = "-5 -5" },
                Image = { Color = colorT }
            }, ".Level_Overlay", ".LevelO_Overlay"); 

			container.Add(new CuiPanel
            {
				RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-532.5 -105", OffsetMax = "532.5 -100" },
                Image = { Color = colorO, Material = "assets/content/ui/uibackgroundblur.mat" }
            }, ".LevelO_Overlay");		
			
			container.Add(new CuiPanel
            {
				RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = vipvalide ? "-132.5 -140" : "-327.5 -140", OffsetMax = vipvalide ? "-127.5 -105" : "-322.5 -105" },
                Image = { Color = colorO, Material = "assets/content/ui/uibackgroundblur.mat" }
            }, ".LevelO_Overlay");			
			
			container.Add(new CuiPanel
            {
				RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "327.5 -140", OffsetMax = "332.5 -105" },
                Image = { Color = colorO, Material = "assets/content/ui/uibackgroundblur.mat" }
            }, ".LevelO_Overlay");	
 
			container.Add(new CuiButton 
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = "5 5", OffsetMax = "195 30" },
                Button = { Color = "0.35 0.45 0.25 1", Command = "level inventory" },
                Text = { Text = lang.GetMessage("OPENINV", this, player.UserIDString), Align = TextAnchor.MiddleCenter, FontSize = 16, Font = "robotocondensed-regular.ttf", Color = "0.75 0.95 0.41 1" }
            }, ".LevelO_Overlay");
			
			bool permvip = permission.UserHasPermission(player.UserIDString, permVip);
			bool permtop = permission.UserHasPermission(player.UserIDString, permTop);
			
			if(vipvalide)
				if(permvip)
					container.Add(new CuiButton 
					{    
						RectTransform = { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = "200 5", OffsetMax = "390 30" },
						Button = { Color = "0.35 0.45 0.25 1" },
						Text = { Text = lang.GetMessage("VIPYES", this, player.UserIDString), Align = TextAnchor.MiddleCenter, FontSize = 16, Font = "robotocondensed-regular.ttf", Color = "0.75 0.95 0.41 1" }
					}, ".LevelO_Overlay");	
				else	
					container.Add(new CuiButton 
					{    
						RectTransform = { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = "200 5", OffsetMax = "390 30" },
						Button = { Color = "0.65 0.29 0.24 1" },
						Text = { Text = lang.GetMessage("VIPNO", this, player.UserIDString), Align = TextAnchor.MiddleCenter, FontSize = 16, Font = "robotocondensed-regular.ttf", Color = "0.92 0.79 0.76 1" }
					}, ".LevelO_Overlay");
			
			container.Add(new CuiPanel
            {
				RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-375 150", OffsetMax = "375 210" },
                Image = { Color = colorO, Material = "assets/icons/greyout.mat" }
            }, ".Level_Overlay", ".Title");
			
			container.Add(new CuiPanel
            {
				RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 5", OffsetMax = "-5 -5" },
                Image = { Color = colorT }
            }, ".Title", ".T_Title");
			
			container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-365 -20", OffsetMax = "-325 20" },
                Button = { Color = "1 1 1 0.75", Sprite = "assets/icons/warning.png", Command = "level info" },
                Text = { Text = "" }
            }, ".T_Title");			
			
            container.Add(new CuiPanel
            {
				RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-320 -25", OffsetMax = "-315 25" },
                Image = { Color = colorO, Material = "assets/content/ui/uibackgroundblur.mat" }
            }, ".T_Title");			
			
			if(couponsvalide)
			{
				container.Add(new CuiButton
				{
					RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-310 -20", OffsetMax = "-270 20" },
					Button = { Color = "1 1 1 0.75", Sprite = "assets/icons/refresh.png", Command = "level exchangeinfo" },
					Text = { Text = "" }
				}, ".T_Title");
			
				container.Add(new CuiPanel
				{
					RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-265 -25", OffsetMax = "-260 25" },
					Image = { Color = colorO, Material = "assets/content/ui/uibackgroundblur.mat" }
				}, ".T_Title");
			} 
			
			container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "325 -20", OffsetMax = "365 20" },
                Button = { Color = "1 1 1 0.75", Sprite = "assets/icons/close.png", Close = ".Level_Overlay" },
                Text = { Text = "" }
            }, ".T_Title");
			
			container.Add(new CuiPanel
            {
				RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "315 -25", OffsetMax = "320 25" },
                Image = { Color = colorO, Material = "assets/content/ui/uibackgroundblur.mat" }
            }, ".T_Title");
			
			if(permtop)
			{
				container.Add(new CuiButton
				{
					RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "270 -20", OffsetMax = "310 20" },
					Button = { Color = "1 1 1 0.75", Sprite = "assets/icons/community_servers.png", Command = "level top" },
					Text = { Text = "" }
				}, ".T_Title");
			
				container.Add(new CuiPanel
				{
					RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "260 -25", OffsetMax = "265 25" },
					Image = { Color = colorO, Material = "assets/content/ui/uibackgroundblur.mat" }
				}, ".T_Title");
			}
			
			container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.5 0", AnchorMax = "0.5 1", OffsetMin = couponsvalide ? "-260 0" : "-315 0", OffsetMax = permtop ? "260 0" : "315 0" },
                Text = { Text = lang.GetMessage("LevelTitle", this, player.UserIDString), Align = TextAnchor.MiddleCenter, FontSize = 18, Color = "1 1 1 0.75" }
            }, ".T_Title");
			
			CuiHelper.AddUi(player, container);
			
			RewardMenu(player);
		}
        protected override void SaveConfig() => Config.WriteObject(config);
		
				
				
		private void OnServerInitialized()
		{	
			PrintWarning("\n-----------------------------\n" +
            "     Author - https://discord.gg/jPz48g7XXY\n" +
            "     VK - https://discord.gg/jPz48g7XXY\n" +
            "     Discord - https://discord.gg/jPz48g7XXY\n" +
			"     \n" +
			"-----------------------------");
			 
			InitializeLang();
			
			if(BetterChat || !config.Setting.ChatPrefix)
                Unsubscribe(nameof(OnPlayerChat));
			
			foreach(var i in config.Award)
			{
				var award = i.Value;
				string imgName = award.Shortname + award.SkinID;
				
				if(award.URLImage != String.Empty)
					ImageLibrary.Call("AddImage", award.URLImage, imgName + 151);
				else if(award.SkinID != 0)
					ImageLibrary.Call("AddImage", $"http://api.skyplugins.ru/api/getskin/{award.SkinID}/{150}", imgName + 150);
				else
					ImageLibrary.Call("AddImage", $"http://api.skyplugins.ru/api/getimage/{award.Shortname}/{150}", imgName + 150);
			}
			
			foreach(var i in config.AwardVip)
			{
				var award = i.Value;
				string imgName = award.Shortname + award.SkinID;
				
				if(award.URLImage != String.Empty)
					ImageLibrary.Call("AddImage", award.URLImage, imgName + 151);
				else if(award.SkinID != 0)
					ImageLibrary.Call("AddImage", $"http://api.skyplugins.ru/api/getskin/{award.SkinID}/{150}", imgName + 150);
				else
					ImageLibrary.Call("AddImage", $"http://api.skyplugins.ru/api/getimage/{award.Shortname}/{150}", imgName + 150);
			}
				
			foreach(var i in config.Coupon)
				ImageLibrary.Call("AddImage", $"http://api.skyplugins.ru/api/getskin/{i.SkinID}/{150}", i.SkinID.ToString());
			
			if(Interface.Oxide.DataFileSystem.ExistsDatafile("XDataSystem/XLevels/XLevels"))
                StoredData = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, XLevelsData>>("XDataSystem/XLevels/XLevels");
			
			BasePlayer.activePlayerList.ToList().ForEach(OnPlayerConnected);
			
			timer.Every(90, () =>  
			{ 
			    if(StoredData != null) Interface.Oxide.DataFileSystem.WriteObject("XDataSystem/XLevels/XLevels", StoredData);
				BasePlayer.activePlayerList.ToList().ForEach(SaveData); 
			}).Callback();
			
			foreach(string command in config.Setting.CommandList)
				cmd.AddChatCommand(command, this, cmdMenuOpen);
			
			permission.RegisterPermission(permVip, this);
			permission.RegisterPermission(permTop, this);
			
			foreach(var perm in config.XPRate.XPRatePermisssion)
				permission.RegisterPermission(perm.Key, this);
			foreach(var perm in config.Online.Permisssion)
                permission.RegisterPermission(perm.Key, this);
 
            if(config.Online.OnlineXP) 
				timer.Every(config.Online.TimeXP, () => BasePlayer.activePlayerList.ToList().ForEach(OGiveXP));		
		}
		
		private void Info(BasePlayer player)
        {
			CuiHelper.DestroyUi(player, ".ExchangeInfo");
			CuiHelper.DestroyUi(player, ".Top");
            CuiElementContainer container = new CuiElementContainer();

			container.Add(new CuiPanel
            {
				RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Color = "0.21 0.22 0.20 1", Material = "assets/content/ui/uibackgroundblur.mat" }
            }, ".LevelO_Overlay", ".Info", ".Info");
			
			container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Close = ".Info" },
                Text = { Text = "" }
            }, ".Info");
			
			container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-225 -75", OffsetMax = "225 75" },
                Text = { Text = lang.GetMessage("Info", this, player.UserIDString), Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 22, Color = "1 1 1 0.5" }
            }, ".Info");

            CuiHelper.AddUi(player, container);
        }		
		
		private string API_GetPlayerPrefix(BasePlayer player) => GetPlayerPrefix(player.userID);
		
		private object OnBetterChat(Dictionary<string, object> chat)
        {
			IPlayer player = chat["Player"] as IPlayer;
			
			string prefix = GetPlayerPrefix(Convert.ToUInt64(player.Id));
			
			if(!config.Setting.ChatPrefix || String.IsNullOrEmpty(prefix)) return chat;
			
			string name = $"{prefix} " + chat["Username"];
			chat["Username"] = name;

            return chat;
        }
		   		 		  						  	   		  	   		  	   		   		 		  		  
        private class LevelConfig 
        {
			
			[JsonProperty(LanguageEnglish ? "Coupons for XP" : "Купоны на ХР")]
			public List<Coupons> Coupon;	
			[JsonProperty(LanguageEnglish ? "VIP level reward" : "Вип награда за уровни")]
			public Dictionary<int, Awards> AwardVip;
			
			internal class OnlineSetting
			{
				[JsonProperty(LanguageEnglish ? "Enable issuing XP to online players" : "Включить выдачу XP онлайн игрокам")] public bool OnlineXP;
                [JsonProperty(LanguageEnglish ? "XP issue interval (in sec.)" : "Интервал выдачи XP (в сек.)")] public float TimeXP;	
			    [JsonProperty(LanguageEnglish ? "Setting up permissions. [ Permission | XP ]" : "Настройка пермишенов. [ Пермишен | XP ]")] public Dictionary<string, float> Permisssion;				
			}
			[JsonProperty(LanguageEnglish ? "Issuing XP for online" : "Выдача XP за онлайн")]
			public OnlineSetting Online = new OnlineSetting();
			
			internal class GUISetting
			{
				[JsonProperty("AnchorMin")] public string AnchorMin;
				[JsonProperty("AnchorMax")] public string AnchorMax;
				[JsonProperty("OffsetMin")] public string OffsetMin;
				[JsonProperty("OffsetMax")] public string OffsetMax;
				[JsonProperty(LanguageEnglish ? "Show mini-bar" : "Отображать мини-панель")] public bool EnablePanel;
				[JsonProperty(LanguageEnglish ? "Color background_1" : "Цвет фона_1")] public string ColorBackgroundO = "";
				[JsonProperty(LanguageEnglish ? "Color background_2" : "Цвет фона_2")] public string ColorBackgroundT = "";
				[JsonProperty(LanguageEnglish ? "Display reward container - [ True - Only when there is a reward in the level | False - Always ]" : "Отображать контейнер наград - [ True - Только когда есть награда на уровне | False - Всегда ]")] public bool ContainerReward;
				[JsonProperty(LanguageEnglish ? "Display required reward level" : "Отображать требуемый уровень наград")] public bool RewardNumber;
				[JsonProperty(LanguageEnglish ? "Display required VIP reward level" : "Отображать требуемый уровень ВИП наград")] public bool RewardNumberVIP;
			}			
			[JsonProperty(LanguageEnglish ? "XP multiplier" : "Множитель XP")]
			public XPRateSetting XPRate = new XPRateSetting();			
			[JsonProperty(LanguageEnglish ? "Vendings settings" : "Настройки магазинов")]
			public VendingSetting Vending = new VendingSetting();
			
			internal class XPSetting		
            {
				[JsonProperty(LanguageEnglish ? "XP for the pickup of resources" : "ХР за подбор ресурсов")] public Dictionary<string, float> PickupXP;				
				[JsonProperty(LanguageEnglish ? "XP for harvest" : "ХР за сбор урожая")] public Dictionary<string, float> HarvestXP;				
				[JsonProperty(LanguageEnglish ? "XP for bonus resources" : "ХР за бонусную добычу")] public Dictionary<string, float> GatherBonusXP;				
				[JsonProperty(LanguageEnglish ? "XP for kill / destroy barrel" : "ХР за убийство / разбитие бочек")] public Dictionary<string, float> KillXP;				
				[JsonProperty(LanguageEnglish ? "XP for opening crates" : "ХР за открытие ящиков")] public Dictionary<string, float> CrateXP;
			}
			[JsonProperty(LanguageEnglish ? "Settings levels" : "Настройка уровней")]
            public LevelSetting Level = new LevelSetting();

			internal class VendingSetting
			{
				[JsonProperty(LanguageEnglish ? "Open the level menu. [ True - Immediately after the opening of the NPC shop | False - UI button ]" : "Открывать меню уровней. [ True - Сразу после открытия НПС магазина | False - Через UI кнопку ]")] public bool VendingOpen;  
				[JsonProperty(LanguageEnglish ? "Access to the level menu is only through the NPC shops. [ True - NPC shop | False - Command ]" : "Доступ к меню уровней только через магазины НПС. [ True - Магазины НПС | False - Команда ]")] public bool VendingUse;
				[JsonProperty(LanguageEnglish ? "List of NPC shops in which you can open the level menu (shop name)" : "Список магазинов НПС в которых можно открыть меню уровней (Имя магазина)")] public List<string> ListNPCVending;				
			}
			
			internal class Coupons
			{
			    [JsonProperty(LanguageEnglish ? "Coupon name" : "Имя купона")] public string Name;
				[JsonProperty(LanguageEnglish ? "Coupon text" : "Текст купона")] public string Text;
				[JsonProperty(LanguageEnglish ? "Coupon skin" : "Скин купона")] public ulong SkinID;
				[JsonProperty(LanguageEnglish ? "XP amount" : "Кол-во ХР")] public int XP;

				[JsonProperty(LanguageEnglish ? "Setting the chance of falling out of crates/barrels" : "Настройка шанса выпадения из ящиков/бочек")]
                public List<Crates> Crate;

                public Coupons(string name, string text, ulong skinid, int xp, List<Crates> crates)
                {
                    Name = name; Text = text; SkinID = skinid; XP = xp; Crate = crates;
                }
			} 
			 
			[JsonProperty(LanguageEnglish ? "General settings" : "Общие настройки")]
			public GeneralSetting Setting = new GeneralSetting();
			internal class GeneralSetting
			{
				[JsonProperty(LanguageEnglish ? "List of commands to open the menu" : "Список команд для открытия меню")] public List<string> CommandList;
				[JsonProperty(LanguageEnglish ? "XP for the pickup of 