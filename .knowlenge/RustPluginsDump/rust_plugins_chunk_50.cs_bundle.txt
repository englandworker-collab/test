                component._recycleEditManager = recycleEditManager;
                component._recycler = recycler;
                return component;
            }

            private RecycleManager _plugin;
            private RecycleEditManager _recycleEditManager;
            private Recycler _recycler;
            private BasePlayer _player;
            private EditState _editState;
            private Func<Item, int, bool> _originalCanAcceptItem;
            private Action _onDirtyDelayed;
            private bool _pauseAutoChangeOutput;

            private Configuration _config => _plugin._config;

            private EditController()
            {
                _onDirtyDelayed = OnDirtyDelayed;
            }

            public void StartViewing(BasePlayer player)
            {
                _player = player;
                DrawUI();
            }

            public void DestroyImmediate()
            {
                DestroyImmediate(this);
            }

            private IngredientInfo[] GetSavedIngredients()
            {
                return GetOutput(_editState.IdentificationType, _editState.OutputType);
            }

            private bool CanSave()
            {
                if (_editState.InputItem == null)
                    return false;

                switch (_editState.OutputType)
                {
                    case OutputType.NotRecyclable:
                    {
                        if (IsDisallowed())
                            return false;

                        if (GetOverride() != null)
                            return true;

                        return _editState.IdentificationType == IdentificationType.Item && IsVanillaRecyclable(_editState.InputItem);
                    }

                    case OutputType.Default:
                    {
                        if (IsDisallowed())
                            return true;

                        if (GetOverride() != null)
                            return true;

                        return false;
                    }

                    case OutputType.Custom:
                        return GetOverride() == null
                               || !GetOutputIngredients().SequenceEqual(GetSavedIngredients());

                    default:
                        return true;
                }
            }

            private bool CanReset()
            {
                if (_editState.InputItem == null)
                    return false;

                return IsDisallowed() || GetOverride() != null;
            }

            private void DrawUI()
            {
                if (_editState != null)
                {
                    _editState.CanSave = CanSave();
                    _editState.CanReset = CanReset();

                }

                EditUI.DrawUI(_plugin, _player, _editState);
            }

            private List<IngredientInfo> GetOutputIngredients()
            {
                var customIngredientList = new List<IngredientInfo>();

                for (var i = NumInputSlots; i < NumInputSlots + NumOutputSlots; i++)
                {
                    var item = _recycler.inventory.GetSlot(i);
                    if (item == null)
                        continue;

                    var amount = (float)item.amount;
                    if (amount == 1)
                    {
                        if (_editState.Chances[i - NumInputSlots] == 0)
                        {
                            _editState.Chances[i - NumInputSlots] = 100;
                        }
                        else
                        {
                            amount = _editState.Chances[i - NumInputSlots] / 100f;
                        }
                    }

                    var ingredientInfo = new IngredientInfo
                    {
                        ShortName = item.info.shortname,
                        DisplayName = !string.IsNullOrWhiteSpace(item.name) ? item.name : null,
                        SkinId = item.skin,
                        Amount = amount,
                    };
                    ingredientInfo.Init();
                    customIngredientList.Add(ingredientInfo);
                }

                return customIngredientList;
            }

            public void HandleUICommand(BasePlayer player, string[] args)
            {
                var commandTypeArg = args.FirstOrDefault();
                if (commandTypeArg == null)
                    return;

                UICommand uiCommand;
                if (!Enum.TryParse(commandTypeArg, ignoreCase: true, result: out uiCommand))
                    return;

                switch (uiCommand)
                {
                    case UICommand.Edit:
                        StartEditing();
                        break;

                    case UICommand.Reset:
                    {
                        _editState.OutputType = OutputType.Default;

                        var changed = false;
                        changed |= _config.RestrictedInputItems.Allow(_editState.InputItem, _editState.IdentificationType);
                        changed |= _config.OverrideOutput.RemoveOverride(_editState.InputItem, _editState.IdentificationType);

                        if (changed)
                        {
                            _plugin.SaveConfig();
                        }

                        _editState.OutputType = DetermineBestOutputType();

                        RemoveOutputItems();
                        PopulateOutputItems();
                        DrawUI();
                        break;
                    }

                    case UICommand.Save:
                    {
                        if (_editState.OutputType == OutputType.Custom)
                        {
                            _config.RestrictedInputItems.Allow(_editState.InputItem, _editState.IdentificationType);
                            _config.OverrideOutput.SetOverride(_editState.InputItem, _editState.IdentificationType, GetOutputIngredients().ToArray());
                            _plugin.SaveConfig();
                        }
                        else
                        {
                            var changed = _config.OverrideOutput.RemoveOverride(_editState.InputItem, _editState.IdentificationType);

                            if (_editState.OutputType == OutputType.NotRecyclable)
                            {
                                if (_editState.IdentificationType != IdentificationType.Item || IsVanillaRecyclable(_editState.InputItem))
                                {
                                    changed |= _config.RestrictedInputItems.Disallow(_editState.InputItem, _editState.IdentificationType);
                                }
                            }
                            else
                            {
                                changed |= _config.RestrictedInputItems.Allow(_editState.InputItem, _editState.IdentificationType);
                            }

                            if (changed)
                            {
                                _plugin.SaveConfig();
                            }
                        }

                        RemoveOutputItems();
                        PopulateOutputItems();
                        DrawUI();
                        break;
                    }

                    case UICommand.Cancel:
                        StopEditing(redraw: true);
                        break;

                    case UICommand.InputPercentage:
                    {
                        var slotArg = args.ElementAtOrDefault(1);
                        var amountArg = args.ElementAtOrDefault(2)?.Replace("%", "");
                        if (slotArg == null || amountArg == null)
                            break;

                        int slot;
                        if (!int.TryParse(slotArg, out slot) || slot < 0 || slot > 5)
                            break;

                        float chance;
                        if (!float.TryParse(amountArg, out chance))
                        {
                            DrawUI();
                            break;
                        }

                        chance = Mathf.Clamp(chance, 0.01f, 100);
                        // Since we allow up to 2 decimal places, allow tolerance of half of 3rd decimal place.
                        // This makes it so if the original value is higher precision like 8.333334, clicking into the
                        // field without changing the input doesn't change the underlying value.
                        if (Math.Abs(chance - _editState.Chances[slot]) >= 0.005f)
                        {
                            _editState.Chances[slot] = chance;
                            _pauseAutoChangeOutput = false;
                            HandleChanges();
                        }

                        DrawUI();
                        break;
                    }

                    case UICommand.ChangeOutputType:
                    {
                        var allowedArg = args.ElementAtOrDefault(1);
                        if (allowedArg == null)
                            break;

                        OutputType outputType;
                        if (!Enum.TryParse(allowedArg, out outputType))
                            break;

                        if (outputType == _editState.OutputType)
                            break;

                        _editState.OutputType = outputType;

                        if (outputType == OutputType.NotRecyclable)
                        {
                            RemoveOutputItems();
                        }
                        else
                        {
                            RemoveOutputItems();
                            PopulateOutputItems();
                        }

                        DrawUI();
                        break;
                    }

                    case UICommand.ChangeIdentificationType:
                    {
                        var identifyTypeArg = args.ElementAtOrDefault(1);
                        if (identifyTypeArg == null)
                            break;

                        IdentificationType identificationType;
                        if (!Enum.TryParse(identifyTypeArg, ignoreCase: true, result: out identificationType))
                            break;

                        if (_editState.IdentificationType == identificationType)
                            break;

                        _editState.IdentificationType = identificationType;
                        _editState.OutputType = DetermineBestOutputType();

                        RemoveOutputItems();
                        PopulateOutputItems();
                        DrawUI();
                        break;
                    }
                }
            }

            private IngredientInfo[] GetOutput(IdentificationType identificationType, OutputType outputType)
            {
                if (outputType == OutputType.NotRecyclable)
                    return null;

                if (outputType == OutputType.Custom)
                {
                    var output = GetOverride(identificationType);
                    if (output != null)
                        return output;
                }

                if (identificationType == IdentificationType.DisplayName)
                    return GetOutput(IdentificationType.Skin, DetermineBestOutputType(IdentificationType.Skin));

                if (identificationType == IdentificationType.Skin)
                    return GetOutput(IdentificationType.Item, DetermineBestOutputType(IdentificationType.Item));

                if (IsVanillaRecyclable(_editState.InputItem))
                    return _plugin.GetVanillaOutput(_editState.InputItem.info);

                return null;
            }

            private void PopulateOutputItems()
            {
                var output = GetOutput(_editState.IdentificationType, _editState.OutputType);
                if (output == null)
                {
                    for (var i = 0; i < _editState.Chances.Length; i++)
                    {
                        _editState.Chances[i] = 0;
                    }
                    return;
                }

                _plugin.PopulateOutputWithOverride(_recycler, output, 1, forEditor: true);
                _pauseAutoChangeOutput = true;

                for (var i = 0; i < _editState.Chances.Length; i++)
                {
                    _editState.Chances[i] = 0;

                    var customIngredient = output.ElementAtOrDefault(i);
                    if (customIngredient != null && customIngredient.Amount <= 1)
                    {
                        _editState.Chances[i] = customIngredient.Amount * 100f;
                    }
                }
            }

            private void RemoveInputItems()
            {
                for (var i = 0; i < NumInputSlots; i++)
                {
                    var item = _recycler.inventory.GetSlot(i);
                    if (item == null)
                        continue;

                    _player.GiveItem(item);
                }
            }

            private void RemoveOutputItems(BasePlayer player = null)
            {
                for (var i = NumInputSlots; i < NumInputSlots + NumOutputSlots; i++)
                {
                    var item = _recycler.inventory.GetSlot(i);
                    if (item == null)
                        continue;

                    if (player != null)
                    {
                        player.GiveItem(item);
                    }
                    else
                    {
                        item.RemoveFromContainer();
                        item.Remove();
                    }
                }

                _pauseAutoChangeOutput = true;
            }

            private void StartEditing()
            {
                _recycler.StopRecycling();

                RemoveOutputItems(_player);

                _originalCanAcceptItem = _recycler.inventory.canAcceptItem;
                _recycler.inventory.canAcceptItem = (item, slot) => _editState?.InputItem != null
                    ? (slot == 0 || slot >= NumInputSlots)
                    : slot < NumInputSlots;

                _recycler.inventory.onDirty += OnDirty;

                _editState = new EditState();
                OnDirtyDelayed();
            }

            private bool CanAcceptItem(Item item)
            {
                if (IsDisallowed())
                    return false;

                var hookResult = _plugin.CallCanBeRecycled(item, _recycler);
                if (hookResult is bool)
                    return (bool)hookResult;

                if (GetOverride() != null)
                    return true;

                return IsVanillaRecyclable(_editState.InputItem);
            }

            private void StopEditing(bool redraw = false)
            {
                if (_editState == null || _recycler == null || _recycler.IsDestroyed)
                    return;

                _recycler.inventory.canAcceptItem = _originalCanAcceptItem;
                _recycler.inventory.onDirty -= OnDirty;

                if (_editState.InputItem != null && !CanAcceptItem(_editState.InputItem))
                {
                    RemoveInputItems();
                }

                RemoveOutputItems();

                _editState = null;

                if (redraw)
                {
                    DrawUI();
                }
            }

            private void StopViewing()
            {
                if (_player == null)
                    return;

                EditUI.DestroyUI(_player);

                _recycleEditManager.HandlePlayerStoppedLooting(_player);
                _player = null;
            }

            private Item TrimInputs()
            {
                Item firstItem = null;

                for (var i = 0; i < NumInputSlots; i++)
                {
                    var item = _recycler.inventory.GetSlot(i);
                    if (item == null)
                        continue;

                    if (firstItem == null)
                    {
                        firstItem = item;
                    }
                    else
                    {
                        item.RemoveFromContainer();
                        _player.GiveItem(item);
                    }
                }

                if (firstItem != null && firstItem.position != 0)
                {
                    firstItem.MoveToContainer(firstItem.parent, 0);
                }

                return firstItem;
            }

            private void RemoveExcessInput(Item item)
            {
                if (item.amount <= 1)
                    return;

                var splitItem = item.SplitItem(item.amount - 1);
                if (splitItem == null)
                    return;

                _player.GiveItem(splitItem);
            }

            private IngredientInfo[] GetOverride(IdentificationType identificationType)
            {
                return _config.OverrideOutput.GetOverride(_editState.InputItem, identificationType);
            }

            private IngredientInfo[] GetOverride()
            {
                return GetOverride(_editState.IdentificationType);
            }

            private bool IsDisallowed(IdentificationType identificationType)
            {
                if (_editState.InputItem == null)
                    return false;

                return _config.RestrictedInputItems.IsDisallowed(_editState.InputItem, identificationType);
            }

            private bool IsDisallowed()
            {
                return IsDisallowed(_editState.IdentificationType);
            }

            private OutputType DetermineBestOutputType(IdentificationType identificationType)
            {
                if (GetOverride(identificationType) != null)
                    return OutputType.Custom;

                if (IsDisallowed(identificationType))
                    return OutputType.NotRecyclable;

                if (identificationType == IdentificationType.Item && !IsVanillaRecyclable(_editState.InputItem))
                    return OutputType.NotRecyclable;

                return OutputType.Default;
            }

            private OutputType DetermineBestOutputType()
            {
                return DetermineBestOutputType(_editState.IdentificationType);
            }

            private IdentificationType DetermineBestIdentificationType()
            {
                if (GetOverride(IdentificationType.DisplayName) != null
                    || IsDisallowed(IdentificationType.DisplayName))
                    return IdentificationType.DisplayName;

                if (GetOverride(IdentificationType.Skin) != null
                    || IsDisallowed(IdentificationType.Skin))
                    return IdentificationType.Skin;

                return IdentificationType.Item;
            }

            private void HandleNewInputItem()
            {
                RemoveExcessInput(_editState.InputItem);
                RemoveOutputItems();

                var hookResult = _plugin.CallCanBeRecycled(_editState.InputItem, _recycler);
                if (hookResult is bool && !(bool)hookResult)
                {
                    _editState.BlockedByAnotherPlugin = true;
                    DrawUI();
                }
                else
                {
                    _editState.BlockedByAnotherPlugin = false;
                    _editState.IdentificationType = DetermineBestIdentificationType();
                    _editState.OutputType = DetermineBestOutputType();
                    PopulateOutputItems();
                }

                DrawUI();
            }

            private void HandleChanges()
            {
                var output = GetOutputIngredients();
                if (!_pauseAutoChangeOutput)
                {
                    var customOutput = GetOverride();
                    var defaultOutput = GetOutput(_editState.IdentificationType, OutputType.Default);
                    if (output.Count == 0)
                    {
                        _editState.OutputType = OutputType.NotRecyclable;
                    }
                    else if (customOutput != null && output.SequenceEqual(customOutput))
                    {
                        _editState.OutputType = OutputType.Custom;
                    }
                    else if (defaultOutput != null && output.SequenceEqual(defaultOutput))
                    {
                        _editState.OutputType = OutputType.Default;
                    }
                    else
                    {
                        _editState.OutputType = OutputType.Custom;
                    }
                }

                for (var i = 0; i < _editState.Chances.Length; i++)
                {
                    var outputItem = _recycler.inventory.GetSlot(NumInputSlots + i);
                    if (outputItem == null || outputItem.amount > 1)
                    {
                        _editState.Chances[i] = 0;
                    }
                }
            }

            private void OnDirtyDelayed()
            {
                if (_recycler == null)
                {
                    DestroyImmediate();
                    return;
                }

                var inputItem = TrimInputs();
                var previousInputItem = _editState.InputItem;
                _editState.InputItem = inputItem;

                if (inputItem != null && inputItem == previousInputItem)
                {
                    RemoveExcessInput(inputItem);
                    HandleChanges();
                    DrawUI();
                    return;
                }

                if (inputItem == null)
                {
                    _editState.BlockedByAnotherPlugin = false;
                    RemoveOutputItems(previousInputItem == null ? _player : null);
                    DrawUI();
                    return;
                }

                HandleNewInputItem();
            }

            private void OnDirty()
            {
                _pauseAutoChangeOutput = false;
                Invoke(_onDirtyDelayed, 0);
            }

            private void PlayerStoppedLooting(BasePlayer player)
            {
                if (_player == player)
                {
                    StopEditing();
                    StopViewing();
                }
            }

            private void OnDestroy()
            {
                StopEditing();
                StopViewing();
                _recycleEditManager.HandleControllerDestroyed(_recycler);
            }
        }

        #endregion

        #region Edit Manager

        private class RecycleEditManager
        {
            private RecycleManager _plugin;
            private Dictionary<Recycler, EditController> _controllers = new Dictionary<Recycler, EditController>();
            private Dictionary<BasePlayer, EditController> _playerControllers = new Dictionary<BasePlayer, EditController>();

            public RecycleEditManager(RecycleManager plugin)
            {
                _plugin = plugin;
            }

            public void HandlePlayerStartedLooting(BasePlayer player, Recycler recycler)
            {
                var controller = EnsureController(recycler);
                _playerControllers[player] = controller;
                controller.StartViewing(player);
            }

            public EditController GetController(BasePlayer player)
            {
                EditController editController;
                return _playerControllers.TryGetValue(player, out editController)
                    ? editController
                    : null;
            }

            public EditController EnsureController(Recycler recycler)
            {
                var editController = GetController(recycler);
                if (editController == null)
                {
                    editController = EditController.AddToRecycler(_plugin, this, recycler);
                }

                _controllers[recycler] = editController;
                return editController;
            }

            public void HandlePlayerStoppedLooting(BasePlayer player)
            {
                _playerControllers.Remove(player);
            }

            public void HandleControllerDestroyed(Recycler recycler)
            {
                _controllers.Remove(recycler);
            }

            public void Unload()
            {
                foreach (var controller in _controllers.Values.ToArray())
                {
                    controller.DestroyImmediate();
                }
            }

            private EditController GetController(Recycler recycler)
            {
                EditController editController;
                return _controllers.TryGetValue(recycler, out editController)
                    ? editController
                    : null;
            }
        }

        #endregion

        #region Recycler Component

        private class RecyclerComponent : FacepunchBehaviour
        {
            public static RecyclerComponent AddToRecycler(RecycleManager plugin, RecycleComponentManager recycleComponentManager, Recycler recycler)
            {
                var component = recycler.gameObject.AddComponent<RecyclerComponent>();
                component._plugin = plugin;
                component._recycleComponentManager = recycleComponentManager;
                component._recycler = recycler;
                component._vanillaRecycleThink = recycler.RecycleThink;
                return component;
            }

            private RecycleManager _plugin;
            private RecycleComponentManager _recycleComponentManager;
            private Recycler _recycler;
            private Action _vanillaRecycleThink;
            private Action _customRecycleThink;
            private float _recycleTime;

            private Configuration _config => _plugin._config;
            private bool _enableIncrementalRecycling => _config.RecycleSpeed.EnableIncrementalRecycling;

            private RecyclerComponent()
            {
                _customRecycleThink = CustomRecycleThink;
            }

            public void DestroyImmediate()
            {
                DestroyImmediate(this);
            }

            public void HandleRecyclerToggle(BasePlayer player)
            {
                // Delay for the following reasons.
                //   1. Allow other plugins to block toggle the recycler.
                //   2. Override other plugins after they start the recycler with custom speed.
                // If another plugin wants to alter the speed, they should use the hook that will be called on a delay.
                Invoke(() => HandleRecyclerToggleDelayed(player), 0);
            }

            private void HandleRecyclerToggleDelayed(BasePlayer player)
            {
                if (_recycler.IsOn())
                {
                    // Allow other plugins to block this, or to modify recycle time.
                    if (!_plugin.TryDetermineRecycleTime(_recycler, player, out _recycleTime))
                        return;

                    // Cancel the vanilla recycle invoke, in case another plugin started it.
                    // The custom recycle think method will also cancel it, since it may be started on a delay.
                    _recycler.CancelInvoke(_vanillaRecycleThink);

                    if (_enableIncrementalRecycling)
                    {
                        Invoke(_customRecycleThink, GetItemRecycleTime(GetNextItem()));
                    }
                    else
                    {
                        InvokeRepeating(_customRecycleThink, _recycleTime, _recycleTime);
                    }
                }
                else
                {
                    // The recycler is off, but vanilla doesn't know how to turn off custom recycling.
                    CancelInvoke(_customRecycleThink);
                }
            }

            private void CustomRecycleThink()
            {
                if (!_recycler.IsOn())
                {
                    // Vanilla or another plugin turned off the recycler, so don't process the next item.
                    if (!_enableIncrementalRecycling)
                    {
                        // Incremental recycling is disabled, so we must cancel the repeating custom invoke.
                        CancelInvoke(_customRecycleThink);
                    }
                    return;
                }

                // Stop the vanilla invokes if another plugin started them.
                // Necessary because some plugins will start the vanilla invokes on a delay to change recycler speed.
                // If another plugin wants to change recycler speed, they should use the hook designed for that.
                if (_recycler.IsInvoking(_vanillaRecycleThink))
                {
                    _recycler.CancelInvoke(_vanillaRecycleThink);
                }

                _recycler.RecycleThink();

                if (_enableIncrementalRecycling)
                {
                    var nextItem = GetNextItem();
                    if (nextItem != null)
                    {
                        Invoke(_customRecycleThink, GetItemRecycleTime(nextItem));
                    }
                }
            }

            private float GetItemRecycleTime(Item item)
            {
                if (_recycleTime == 0)
                    return _recycleTime;

                return _recycleTime * _config.RecycleSpeed.GetTimeMultiplierForItem(item);
            }

            private Item GetNextItem()
            {
                for (var i = 0; i < 6; i++)
                {
                    var item = _recycler.inventory.GetSlot(i);
                    if (item != null)
                        return item;
                }

                return null;
            }

            private void OnDestroy()
            {
                _recycleComponentManager.HandleRecyclerComponentDestroyed(_recycler);
            }
        }

        private class RecycleComponentManager
        {
            private RecycleManager _plugin;
            private readonly Dictionary<Recycler, RecyclerComponent> _recyclerComponents = new Dictionary<Recycler, RecyclerComponent>();

            public void Init(RecycleManager plugin)
            {
                _plugin = plugin;
            }

            public void Unload()
            {
                foreach (var recyclerComponent in _recyclerComponents.Values.ToArray())
                {
                    recyclerComponent.DestroyImmediate();
                }
            }

            public void HandleRecyclerToggle(Recycler recycler, BasePlayer player)
            {
                EnsureRecyclerComponent(recycler).HandleRecyclerToggle(player);
            }

            public void HandleRecyclerComponentDestroyed(Recycler recycler)
            {
                _recyclerComponents.Remove(recycler);
            }

            private RecyclerComponent EnsureRecyclerComponent(Recycler recycler)
            {
                RecyclerComponent recyclerComponent;
                if (!_recyclerComponents.TryGetValue(recycler, out recyclerComponent))
                {
                    recyclerComponent = RecyclerComponent.AddToRecycler(_plugin, this, recycler);
                    _recyclerComponents[recycler] = recyclerComponent;
                }
                return recyclerComponent;
            }
        }

        #endregion

        #region Configuration

        private class CaseInsensitiveDictionary<TValue> : Dictionary<string, TValue>
        {
            public CaseInsensitiveDictionary() : base(StringComparer.OrdinalIgnoreCase) {}
        }

        private class CaseInsensitiveHashSet : HashSet<string>
        {
            public CaseInsensitiveHashSet() : base(StringComparer.OrdinalIgnoreCase) {}
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class EditUISettings
        {
            [JsonProperty("Enabled")]
            public bool Enabled = true;
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class PermissionSpeedProfile
        {
            [JsonProperty("Permission suffix")]
            public string PermissionSuffix;

            [JsonProperty("Recycle time (seconds)")]
            private float RecycleTime { set { TimeMultiplier = value / 5f; } }

            [JsonProperty("Recycle time multiplier")]
            public float TimeMultiplier = 1;

            [JsonIgnore]
            public string Permission { get; private set; }

            public void Init(RecycleManager plugin)
            {
                if (!string.IsNullOrWhiteSpace(PermissionSuffix))
                {
                    Permission = $"{nameof(RecycleManager)}.speed.{PermissionSuffix}".ToLower();
                    plugin.permission.RegisterPermission(Permission, plugin);
                }
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class RecycleSpeed
        {
            [JsonProperty("Enabled")]
            public bool Enabled;

            [JsonProperty("Default recycle time (seconds)")]
            public float DefaultRecycleTime = 5;

            [JsonProperty("Recycle time (seconds)")]
            private float DeprecatedRecycleTime { set { DefaultRecycleTime = value; } }

            [JsonProperty("Recycle time multiplier while in safe zone")]
            public float SafeZoneTimeMultiplier = 1;

            [JsonProperty("Recycle time multiplier by item short name (item: multiplier)")]
            public Dictionary<string, float> TimeMultiplierByShortName = new Dictionary<string, float>();

            [JsonProperty("Recycle time multiplier by permission")]
            public PermissionSpeedProfile[] PermissionSpeedProfiles = new PermissionSpeedProfile[]
            {
                new PermissionSpeedProfile
                {
                    PermissionSuffix = "fast",
                    TimeMultiplier = 0.2f,
                },
                new PermissionSpeedProfile
                {
                    PermissionSuffix = "instant",
                    TimeMultiplier = 0,
                },
            };

            [JsonProperty("Speeds requiring permission")]
            private PermissionSpeedProfile[] DeprecatedSpeedsRequiringPermission
            { set { PermissionSpeedProfiles = value; } }

            [JsonIgnore]
            private Permission _permission;

            [JsonIgnore]
            private Dictionary<int, float> _timeMultiplierByItemId = new Dictionary<int, float>();

            [JsonIgnore]
            public bool EnableIncrementalRecycling;

            public void Init(RecycleManager plugin)
            {
                _permission = plugin.permission;

                foreach (var speedProfile in PermissionSpeedProfiles)
                {
                    speedProfile.Init(plugin);
                }

                foreach (var entry in TimeMultiplierByShortName)
                {
                    var itemShortName = entry.Key;
                    var itemDefinition = ItemManager.FindItemDefinition(itemShortName);
                    if (itemDefinition == null)
                    {
                        LogWarning($"Invalid item short name in config: {itemShortName}");
                        continue;
                    }

                    if (entry.Value == 1)
                        continue;

                    _timeMultiplierByItemId[itemDefinition.itemid] = entry.Value;
                    EnableIncrementalRecycling = true;
                }
            }

            public float GetTimeMultiplierForPlayer(BasePlayer player)
            {
                for (var i = PermissionSpeedProfiles.Length - 1; i >= 0; i--)
                {
                    var speedProfile = PermissionSpeedProfiles[i];
                    if (speedProfile.Permission != null
                        && _permission.UserHasPermission(player.UserIDString, speedProfile.Permission))
                    {
                        return speedProfile.TimeMultiplier;
                    }
                }

                return 1;
            }

            public float GetTimeMultiplierForItem(Item item)
            {
                float time;
                if (_timeMultiplierByItemId.TryGetValue(item.info.itemid, out time))
                    return time;

                return 1;
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class MaxItemsPerRecycle
        {
            [JsonProperty("Default percent")]
            public float DefaultPercent = 10f;

            [JsonProperty("Percent by input item short name")]
            public Dictionary<string, float> PercentByShortName = new Dictionary<string, float>();

            [JsonProperty("Percent by input item skin ID")]
            public Dictionary<ulong, float> PercentBySkinId = new Dictionary<ulong, float>();

            [JsonProperty("Percent by input item display name (custom items)")]
            public CaseInsensitiveDictionary<float> PercentByDisplayName = new CaseInsensitiveDictionary<float>();

            [JsonIgnore]
            private Dictionary<int, float> PercentByItemId = new Dictionary<int, float>();

            public void Init()
            {
                foreach (var entry in PercentByShortName)
                {
                    var shortName = entry.Key;
                    if (string.IsNullOrWhiteSpace(shortName))
                        continue;

                    var itemDefinition = ItemManager.FindItemDefinition(shortName);
                    if (itemDefinition == null)
                    {
                        LogWarning($"Invalid item short name in config: {shortName}");
                        continue;
                    }

                    PercentByItemId[itemDefinition.itemid] = entry.Value;
                }
            }

            public float GetPercent(Item item)
            {
                float multiplier;
                if (!string.IsNullOrWhiteSpace(item.name) && PercentByDisplayName.TryGetValue(item.name, out multiplier))
                    return multiplier;

                if (item.skin != 0 && PercentBySkinId.TryGetValue(item.skin, out multiplier))
                    return multiplier;

                if (PercentByItemId.TryGetValue(item.info.itemid, out multiplier))
                    return multiplier;

                return DefaultPercent;
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class OutputMultiplierSettings
        {
            [JsonProperty("Default multiplier")]
            public float DefaultMultiplier = 1f;

            [JsonProperty("Multiplier by output item short name")]
            public Dictionary<string, float> MultiplierByOutputShortName = new Dictionary<string, float>();

            [JsonIgnore]
            private Dictionary<int, float> MultiplierByOutputItemId = new Dictionary<int, float>();

            public void Init()
            {
                foreach (var entry in MultiplierByOutputShortName)
                {
                    var shortName = entry.Key;
                    if (string.IsNullOrWhiteSpace(shortName))
                        continue;

                    var itemDefinition = ItemManager.FindItemDefinition(shortName);
                    if (itemDefinition == null)
                    {
                        LogWarning($"Invalid item short name in config: {shortName}");
                        continue;
                    }

                    MultiplierByOutputItemId[itemDefinition.itemid] = entry.Value;
                }
            }

            public float GetOutputMultiplier(int itemId)
            {
                float multiplier;
                if (MultiplierByOutputItemId.TryGetValue(itemId, out multiplier))
                    return multiplier;

                return DefaultMultiplier;
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class IngredientInfo : IEquatable<IngredientInfo>
        {
            [JsonProperty("Item short name")]
            public string ShortName;

            [JsonProperty("Item skin ID", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public ulong SkinId;

            [JsonProperty("Display name", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public string DisplayName;

            [JsonProperty("Amount")]
            public float Amount;

            [JsonIgnore]
            public ItemDefinition ItemDefinition;

            public void Init()
            {
                ItemDefinition = ItemManager.FindItemDefinition(ShortName);
                if (ItemDefinition == null)
                {
                    LogWarning($"Invalid item short name in config: {ShortName}");
                }

                if (Amount < 0)
                {
                    Amount = 0;
                }
            }

            public bool Equals(IngredientInfo other)
            {
                if (ReferenceEquals(null, other))
                    return false;

                if (ReferenceEquals(this, other))
                    return true;

                return ItemDefinition == other.ItemDefinition
                       && SkinId == other.SkinId
                       && Amount.Equals(other.Amount)
                       && string.Compare(DisplayName, other.DisplayName, StringComparison.OrdinalIgnoreCase) == 0;
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class OverrideOutput
        {
            [JsonProperty("Override output by input item short name")]
            public Dictionary<string, IngredientInfo[]> OverrideOutputByShortName = new Dictionary<string, IngredientInfo[]>();

            [JsonProperty("Override output by input item skin ID")]
            public Dictionary<ulong, IngredientInfo[]> OverrideOutputBySkinId = new Dictionary<ulong, IngredientInfo[]>();

            [JsonProperty("Override output by input item display name (custom items)")]
            public CaseInsensitiveDictionary<IngredientInfo[]> OverrideOutputByDisplayName = new CaseInsensitiveDictionary<IngredientInfo[]>();

            [JsonIgnore]
            private Dictionary<int, IngredientInfo[]> OverrideOutputByItemId = new Dictionary<int, IngredientInfo[]>();

            public void Init()
            {
                foreach (var entry in OverrideOutputByShortName)
                {
                    var shortName = entry.Key;
                    if (string.IsNullOrWhiteSpace(shortName))
                        continue;

                    var itemDefinition = ItemManager.FindItemDefinition(shortName);
                    if (itemDefinition == null)
                    {
                        LogWarning($"Invalid item short name in config: {shortName}");
                        continue;
                    }

                    var ingredientInfoList = entry.Value;
                    foreach (var ingredientInfo in ingredientInfoList)
                    {
                        ingredientInfo.Init();
                    }

                    OverrideOutputByItemId[itemDefinition.itemid] = ingredientInfoList;
                }

                foreach (var ingredientInfoList in OverrideOutputBySkinId.Values)
                {
                    foreach (var ingredientInfo in ingredientInfoList)
                    {
                        ingredientInfo.Init();
                    }
                }

                foreach (var ingredientInfoList in OverrideOutputByDisplayName.Values)
                {
                    foreach (var ingredientInfo in ingredientInfoList)
                    {
                        ingredientInfo.Init();
                    }
                }
            }

            public IngredientInfo[] GetOverride(Item item, IdentificationType identificationType)
            {
                IngredientInfo[] customIngredientList;
                switch (identificationType)
                {
                    case IdentificationType.DisplayName:
                        return !string.IsNullOrWhiteSpace(item.name) && OverrideOutputByDisplayName.TryGetValue(item.name, out customIngredientList)
                            ? customIngredientList
                            : null;

                    case IdentificationType.Skin:
                        return item.skin != 0 && OverrideOutputBySkinId.TryGetValue(item.skin, out customIngredientList)
                            ? customIngredientList
                            : null;

                    case IdentificationType.Item:
                        return OverrideOutputByItemId.TryGetValue(item.info.itemid, out customIngredientList)
                            ? customIngredientList
                            : null;
                }

                return null;
            }

            public IngredientInfo[] GetBestOverride(Item item)
            {
                IngredientInfo[] ingredientInfoList;
                if (!string.IsNullOrWhiteSpace(item.name) && OverrideOutputByDisplayName.TryGetValue(item.name, out ingredientInfoList))
                    return ingredientInfoList;

                if (item.skin != 0 && OverrideOutputBySkinId.TryGetValue(item.skin, out ingredientInfoList))
                    return ingredientInfoList;

                if (OverrideOutputByItemId.TryGetValue(item.info.itemid, out ingredientInfoList))
                    return ingredientInfoList;

                return null;
            }

            public bool AddOverride(RecycleManager plugin,ItemDefinition itemDefinition)
            {
                if (OverrideOutputByShortName.ContainsKey(itemDefinition.shortname))
                    return false;

                ResetOverride(plugin, itemDefinition);
                return true;
            }

            public void SetOverride(Item item, IdentificationType identificationType, IngredientInfo[] customIngredientList)
            {
                switch (identificationType)
                {
                    case IdentificationType.DisplayName:
                        OverrideOutputByDisplayName[item.name] = customIngredientList;
                        break;

                    case IdentificationType.Skin:
                        OverrideOutputBySkinId[item.skin] = customIngredientList;
                        break;

                    case IdentificationType.Item:
                        OverrideOutputByShortName[item.info.shortname] = customIngredientList;
                        OverrideOutputByItemId[item.info.itemid] = customIngredientList;
                        break;
                }
            }

            public bool RemoveOverride(Item item, IdentificationType identificationType)
            {
                switch (identificationType)
                {
                    case IdentificationType.DisplayName:
                        return OverrideOutputByDisplayName.Remove(item.name);

                    case IdentificationType.Skin:
                        return OverrideOutputBySkinId.Remove(item.skin);

                    case IdentificationType.Item:
                        return OverrideOutputByShortName.Remove(item.info.shortname)
                               | OverrideOutputByItemId.Remove(item.info.itemid);
                }

                return false;
            }

            public void ResetOverride(RecycleManager plugin,ItemDefinition itemDefinition)
            {
                var ingredients = plugin.GetVanillaOutput(itemDefinition);

                OverrideOutputByShortName[itemDefinition.shortname] = ingredients;
                OverrideOutputByItemId[itemDefinition.itemid] = ingredients;
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class RestrictedInputItems
        {
            [JsonProperty("Item short names")]
            public CaseInsensitiveHashSet DisallowedInputShortNames = new CaseInsensitiveHashSet();

            [JsonProperty("Item skin IDs")]
            public HashSet<ulong> DisallowedInputSkinIds = new HashSet<ulong>();

            [JsonProperty("Item display names (custom items)")]
            public CaseInsensitiveHashSet DisallowedInputDisplayNames = new CaseInsensitiveHashSet();

            [JsonIgnore]
            private HashSet<int> DisallowedInputItemIds = new HashSet<int>();

            public void Init()
            {
                foreach (var shortName in DisallowedInputShortNames)
                {
                    if (string.IsNullOrWhiteSpace(shortName))
                        continue;

                    var itemDefinition = ItemManager.FindItemDefinition(shortName);
                    if (itemDefinition == null)
                    {
                        LogWarning($"Invalid item short name in config: {shortName}");
                        continue;
                    }

                    DisallowedInputItemIds.Add(itemDefinition.itemid);
                }
            }

            public bool IsDisallowed(Item item, IdentificationType identificationType)
            {
                switch (identificationType)
                {
                    case IdentificationType.DisplayName:
                        return DisallowedInputDisplayNames.Contains(item.name);

                    case IdentificationType.Skin:
                        return DisallowedInputSkinIds.Contains(item.skin);

                    case IdentificationType.Item:
                        return DisallowedInputItemIds.Contains(item.info.itemid);
                }

                return true;
            }

            public bool IsDisallowed(Item item)
            {
                if (!string.IsNullOrEmpty(item.name) && IsDisallowed(item, IdentificationType.DisplayName))
                    return true;

                if (item.skin != 0 && IsDisallowed(item, IdentificationType.Skin))
                    return true;

                return IsDisallowed(item, IdentificationType.Item);
            }

            public bool Allow(Item item, IdentificationType identificationType)
            {
                switch (identificationType)
                {
                    case IdentificationType.DisplayName:
                        return DisallowedInputDisplayNames.Remove(item.name);

                    case IdentificationType.Skin:
                        return DisallowedInputSkinIds.Remove(item.skin);

                    case IdentificationType.Item:
                        return DisallowedInputShortNames.Remove(item.info.shortname)
                               | DisallowedInputItemIds.Remove(item.info.itemid);
                }

                return false;
            }

            public bool Disallow(Item item, IdentificationType identificationType)
            {
                switch (identificationType)
                {
                    case IdentificationType.DisplayName:
                        return DisallowedInputDisplayNames.Add(item.name);

                    case IdentificationType.Skin:
                        return DisallowedInputSkinIds.Add(item.skin);

                    case IdentificationType.Item:
                        return DisallowedInputShortNames.Add(item.info.shortname)
                               | DisallowedInputItemIds.Add(item.info.itemid);
                }

                return false;
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class Configuration : BaseConfiguration
        {
            [JsonProperty("Edit UI")]
            public EditUISettings EditUISettings = new EditUISettings();

            [JsonProperty("Custom recycle speed")]
            public RecycleSpeed RecycleSpeed = new RecycleSpeed();

            [JsonProperty("Restricted input items")]
            public RestrictedInputItems RestrictedInputItems = new RestrictedInputItems();

            [JsonProperty("Max items in stack per recycle (% of max stack size)")]
            public MaxItemsPerRecycle MaxItemsPerRecycle = new MaxItemsPerRecycle();

            [JsonProperty("Output multipliers")]
            public OutputMultiplierSettings OutputMultipliers = new OutputMultiplierSettings();

            [JsonProperty("Override output")]
            public OverrideOutput OverrideOutput = new OverrideOutput();

            [JsonProperty("Override output (before efficiency factor)")]
            private OverrideOutput DeprecatedOverrideOutput
            {
                set
                {
                    if (value == null)
                        return;

                    foreach (var entry in value.OverrideOutputByShortName)
                    {
                        foreach (var ingredientInfo in entry.Value)
                        {
                            ingredientInfo.Amount *= 0.5f;
                        }

                        OverrideOutput.OverrideOutputByShortName[entry.Key] = entry.Value;
                    }

                    foreach (var entry in value.OverrideOutputBySkinId)
                    {
                        foreach (var ingredientInfo in entry.Value)
                        {
                            ingredientInfo.Amount *= 0.5f;
                        }

                        OverrideOutput.OverrideOutputBySkinId[entry.Key] = entry.Value;
                    }

                    foreach (var entry in value.OverrideOutputByDisplayName)
                    {
                        foreach (var ingredientInfo in entry.Value)
                        {
                            ingredientInfo.Amount *= 0.5f;
                        }

                        OverrideOutput.OverrideOutputByDisplayName[entry.Key] = entry.Value;
                    }
                }
            }

            public void Init(RecycleManager plugin)
            {
                RecycleSpeed.Init(plugin);
                RestrictedInputItems.Init();
                MaxItemsPerRecycle.Init();
                OutputMultipliers.Init();
                OverrideOutput.Init();
            }
        }

        private Configuration GetDefaultConfig() => new Configuration();

        #region Configuration Helpers

        [JsonObject(MemberSerialization.OptIn)]
        private class BaseConfiguration
        {
            [JsonIgnore]
            public bool UsingDefaults = false;

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(BaseConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigSection(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigSection(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            bool changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                object currentRawValue;
                if (currentRaw.TryGetValue(key, out currentRawValue))
                {
                    var defaultDictValue = currentWithDefaults[key] as Dictionary<string, object>;
                    var currentDictValue = currentRawValue as Dictionary<string, object>;

                    if (defaultDictValue != null)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigSection(defaultDictValue, currentDictValue))
                            changed = true;
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _config = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(_config))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                LogError(e.Message);
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
                _config.UsingDefaults = true;
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_config, true);
        }

        #endregion

        #endregion

        #region Localization

        private class LangEntry
        {
            public static List<LangEntry> AllLangEntries = new List<LangEntry>();

            public static readonly LangEntry ErrorNoPermission = new LangEntry("Error.NoPermission", "You don't have permission to do that.");
            public static readonly LangEntry ErrorConfig = new LangEntry("Error.Config", "Error: The config did not load correctly. Please fix the config and reload the plugin before running this command.");
            public static readonly LangEntry ErrorInvalidItem = new LangEntry("Error.InvalidItem", "Error: Invalid item: <color=#fe0>{0}</color>");

            public static readonly LangEntry ItemSyntax = new LangEntry("Item.Syntax", "Syntax: <color=#fe0>{0} <item id or short name></color>");

            public static readonly LangEntry AddExists = new LangEntry("Add.Exists", "Error: Item <color=#fe0>{0}</color> is already in the config. To reset that item to vanilla output, use <color=#fe0>recyclemanager.reset {0}</color>.");
            public static readonly LangEntry AddSuccess = new LangEntry("Add.Success", "Successfully added item <color=#fe0>{0}</color> to the config.");

            public static readonly LangEntry ResetSuccess = new LangEntry("Reset.Success", "Successfully reset item <color=#fe0>{0}</color> in the config.");

            public static readonly LangEntry UIButtonAdmin = new LangEntry("UI.Button.Admin", "Admin");
            public static readonly LangEntry UIHeader = new LangEntry("UI.Header", "Recycle Manager");
            public static readonly LangEntry UIButtonClose = new LangEntry("UI.Button.Close", "Close");
            public static readonly LangEntry UIEmptyState = new LangEntry("UI.EmptyState", "Place an item into the recycler to preview and edit its output");
            public static readonly LangEntry UIItemBlocked = new LangEntry("UI.ItemBlocked", "That item is blocked by another plugin");

            public static readonly LangEntry UILabelConfigureBy = new LangEntry("UI.Label.ConfigureBy", "Configure by:");
            public static readonly LangEntry UIButtonItem = new LangEntry("UI.Button.Item", "Item");
            public static readonly LangEntry UIButtonSkin = new LangEntry("UI.Button.Skin", "Skin");
            public static readonly LangEntry UIButtonDisplayName = new LangEntry("UI.Button.DisplayName", "Display name");

            public static readonly LangEntry UILabelOutput = new LangEntry("UI.Label.Output", "Output:");
            public static readonly LangEntry UIButtonNotRecyclable = new LangEntry("UI.Button.NotRecyclable", "Not recyclable");
            public static readonly LangEntry UIButtonDefaultOutput = new LangEntry("UI.Button.DefaultOutput", "Default output");
            public static readonly LangEntry UIButtonCustomOutput = new LangEntry("UI.Button.CustomOutput", "Custom output");

            public static readonly LangEntry UILabelActions = new LangEntry("UI.Label,Actions", "Actions:");
            public static readonly LangEntry UIButtonSave = new LangEntry("UI.Button.Save", "Save");
            public static readonly LangEntry UIButtonReset = new LangEntry("UI.Button.Reset", "Reset");
            public static readonly LangEntry UIButtonCancel = new LangEntry("UI.Button.Cancel", "Cancel");

            public string Name;
            public string English;

            public LangEntry(string name, string english)
            {
                Name = name;
                English = english;

                AllLangEntries.Add(this);
            }
        }


        private string GetMessage(string playerId, LangEntry langEntry) =>
            lang.GetMessage(langEntry.Name, this, playerId);

        private string GetMessage(string playerId, LangEntry langEntry, object arg1) =>
            string.Format(GetMessage(playerId, langEntry), arg1);

        private string GetMessage(string playerId, LangEntry langEntry, object arg1, object arg2) =>
            string.Format(GetMessage(playerId, langEntry), arg1, arg2);

        private string GetMessage(string playerId, LangEntry langEntry, object arg1, object arg2, string arg3) =>
            string.Format(GetMessage(playerId, langEntry), arg1, arg2, arg3);

        private string GetMessage(string playerId, LangEntry langEntry, params object[] args) =>
            string.Format(GetMessage(playerId, langEntry), args);


        private void ReplyToPlayer(IPlayer player, LangEntry langEntry) =>
            player.Reply(GetMessage(player.Id, langEntry));

        private void ReplyToPlayer(IPlayer player, LangEntry langEntry, object arg1) =>
            player.Reply(GetMessage(player.Id, langEntry, arg1));

        private void ReplyToPlayer(IPlayer player, LangEntry langEntry, object arg1, object arg2) =>
            player.Reply(GetMessage(player.Id, langEntry, arg1, arg2));

        private void ReplyToPlayer(IPlayer player, LangEntry langEntry, object arg1, object arg2, object arg3) =>
            player.Reply(GetMessage(player.Id, langEntry, arg1, arg2, arg3));

        private void ReplyToPlayer(IPlayer player, LangEntry langEntry, params object[] args) =>
            player.Reply(GetMessage(player.Id, langEntry, args));


        protected override void LoadDefaultMessages()
        {
            var englishLangKeys = new Dictionary<string, string>();

            foreach (var langEntry in LangEntry.AllLangEntries)
            {
                englishLangKeys[langEntry.Name] = langEntry.English;
            }

            lang.RegisterMessages(englishLangKeys, this, "en");
        }

        #endregion

        #region Tests

        #if ENABLE_TESTS

        private class RecycleManagerTests : BaseTestSuite
        {
            private static void Assert(bool value, string message = null)
            {
                if (!value)
                    throw new Exception($"Assertion failed: {message}");
            }

            private static void AssertItemInSlot(ItemContainer container, int slot, out Item item)
            {
                item = container.GetSlot(slot);
                Assert(item != null, $"Expected item in slot {slot}, but found none.");
            }

            private static void AssertItemShortName(Item item, string shortName)
            {
                Assert(item.info.shortname == shortName, $"Expected item '{shortName}', but found '{item.info.shortname}'.");
            }

            private static void AssertItemSkin(Item item, ulong skin)
            {
                Assert(item.skin == skin, $"Expected item {item.info.shortname} to have skin '{skin}', but found '{item.skin}'.");
            }

            private static void AssertItemDisplayName(Item item, string displayName)
            {
                Assert(item.name == displayName, $"Expected item {item.info.shortname} to have display name '{displayName}', but found '{item.name}'.");
            }

            private static void AssertItemAmount(Item item, int expectedAmount)
            {
                Assert(item.amount == expectedAmount, $"Expected item '{item.info.shortname}' to have amount {expectedAmount}, but found {item.amount}.");
            }

            private static void AssertItemInContainer(ItemContainer container, int slot, string shortName, int amount)
            {
                Item item;
                AssertItemInSlot(container, slot, out item);
                AssertItemShortName(item, shortName);
                AssertItemAmount(item, amount);
            }

            private static Item CreateItem(string shortName, int amount = 1, ulong skin = 0)
            {
                var item = ItemManager.CreateByName(shortName, amount, skin);
                Assert(item != null, $"Failed to create item with short name '{shortName}' and amount '{amount}' and skin '{skin}'.");
                return item;
            }

            private static Item AddItemToContainer(ItemContainer container, string shortName, int amount = 1, ulong skin = 0, int slot = -1)
            {
                var item = CreateItem(shortName, amount, skin);
                if (!item.MoveToContainer(container, slot))
                    throw new Exception($"Failed to move item '{shortName}' to container.");

                return item;
            }

            private static void AssertSubscribed(PluginManager pluginManager, Plugin plugin, string hookName, bool subscribed = true)
            {
                var hookSubscribers = GetHookSubscribers(pluginManager, hookName);
                if (hookSubscribers == null)
                    return;

                Assert(hookSubscribers.Contains(plugin) == subscribed);
            }

            private static Action SetMaxStackSize(string shortName, int amount)
            {
                var itemDefinition = ItemManager.FindItemDefinition(shortName);
                Assert(itemDefinition != null, $"Failed to find item definition for short name '{shortName}'.");
                var originalMaxStackSize = itemDefinition.stackable;
                itemDefinition.stackable = amount;
                return () => itemDefinition.stackable = originalMaxStackSize;
            }

            private RecycleManager _plugin;
            private Configuration _originalConfig;
            private Recycler _recycler;
            private BasePlayer _player;

            public RecycleManagerTests(RecycleManager plugin)
            {
                _plugin = plugin;
            }

            protected override void BeforeAll()
            {
                _originalConfig = _plugin._config;

                _recycler = (Recycler)GameManager.server.CreateEntity("assets/bundled/prefabs/static/recycler_static.prefab", new Vector3(0, -1000, 0));
                _recycler.limitNetworking = true;
                _recycler.Spawn();

                _player = (BasePlayer)GameManager.server.CreateEntity("assets/prefabs/player/player.prefab", new Vector3(0, -1000, 0));
                _player.limitNetworking = true;
                _player.modelState.flying = true;
                _player.Spawn();
            }

            protected override void BeforeEach()
            {
                _recycler.inventory.Clear();
                ItemManager.DoRemoves();
                SetupPlayer(123);
            }

            private HashSet<string> GetPluginPermissions()
            {
                var registeredPermissionsField = typeof(Permission).GetField("registeredPermissions", BindingFlags.Instance | BindingFlags.NonPublic);
                var permissionsMap = (Dictionary<Plugin, HashSet<string>>)registeredPermissionsField.GetValue(_plugin.permission);
                HashSet<string> permissionList;
                return permissionsMap.TryGetValue(_plugin, out permissionList)
                    ? permissionList
                    : null;
            }

            private void InitializePlugin(Configuration config)
            {
                _plugin._config = config;
                GetPluginPermissions()?.Clear();

                _recycler.StopRecycling();

                // Reset recycle components since they cache the config.
                _plugin._recycleComponentManager.Unload();

                _plugin.Init();
                _plugin.OnServerInitialized();
            }

            private void SetupPlayer(ulong userId)
            {
                _player.userID = userId;
                _player.UserIDString = userId.ToString();

                foreach (var perm in _plugin.permission.GetUserPermissions(_player.UserIDString).ToArray())
                {
                    _plugin.permission.RevokeUserPermission(_player.UserIDString, perm);
                }
            }

            private static IList<Plugin> GetHookSubscribers(PluginManager pluginManager, string hookName)
            {
                var hookSubscriptionsField = typeof(PluginManager).GetField("hookSubscriptions", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
                if (hookSubscriptionsField == null)
                    return null;

                var hookSubscriptions = hookSubscriptionsField.GetValue(pluginManager) as IDictionary<string, IList<Plugin>>;
                if (hookSubscriptions == null)
                    return null;

                IList<Plugin> pluginList;
                return hookSubscriptions.TryGetValue(hookName, out pluginList)
                    ? pluginList
                    : null;
            }

            [TestMethod("Given rope is restricted, it should not be allowed in recyclers")]
            public void Test_ItemRestrictions_ItemShortNames()
            {
                InitializePlugin(new Configuration
                {
                    RestrictedInputItems = new RestrictedInputItems
                    {
                        DisallowedInputShortNames = new CaseInsensitiveHashSet
                        {
                            "rope",
                        },
                    },
                });

                // Tarp is not restricted, should be allowed.
                var tarp = CreateItem("tarp");
                if (_recycler.inventory.CanAcceptItem(tarp, 0) != ItemContainer.CanAcceptResult.CanAccept)
                    throw new Exception($"Expected {tarp.info.shortname} to be allowed in recycler, but it was disallowed.");

                var rope = CreateItem("rope");
                if (_recycler.inventory.CanAcceptItem(rope, 0) != ItemContainer.CanAcceptResult.CannotAccept)
                    throw new Exception($"Expected {rope.info.shortname} to be disallowed in recycler, but it was allowed.");
            }

            [TestMethod("Given recycle speed disabled, items should recycle after 5 seconds")]
            public IEnumerator Test_RecycleSpeed_Disabled()
            {
                InitializePlugin(new Configuration
                {
                    RecycleSpeed = new RecycleSpeed
                    {
                        Enabled = false,
                        DefaultRecycleTime = 2,
                    },
                });

                AssertSubscribed(_plugin.plugins.PluginManager, _plugin, nameof(OnRecyclerToggle), subscribed: false);
                var gears = AddItemToContainer(_recycler.inventory, "gears");
                _recycler.StartRecycling();

                yield return new WaitForSeconds(4.9f);
                AssertItemAmount(gears, 1);
                yield return new WaitForSeconds(0.11f);
                AssertItemAmount(gears, 0);
            }

            [TestMethod("Given default recycle speed 0.1 seconds, items should recycle after 0.1 seconds")]
            public IEnumerator Test_RecycleSpeed_Enabled()
            {
                InitializePlugin(new Configuration
                {
                    RecycleSpeed = new RecycleSpeed
                    {
                        Enabled = true,
                        DefaultRecycleTime = 0.1f,
                    },
                });

                var gears = AddItemToContainer(_recycler.inventory, "gears");
                _plugin.CallHook(nameof(OnRecyclerToggle), _recycler, _player);
                _recycler.StartRecycling();

                yield return null;
                AssertItemAmount(gears, 1);
                yield return new WaitForSeconds(0.11f);
                AssertItemAmount(gears, 0);
            }

            [TestMethod("Given default recycle speed 3 seconds, player permission 0.1 multiplier, items should recycle after 0.3 seconds")]
            public IEnumerator Test_RecycleSpeed_Permission()
            {
                InitializePlugin(new Configuration
                {
                    RecycleSpeed = new RecycleSpeed
                    {
                        Enabled = true,
                        DefaultRecycleTime = 3,
                        PermissionSpeedProfiles = new PermissionSpeedProfile[]
                        {
                            new PermissionSpeedProfile { PermissionSuffix = "fast", TimeMultiplier = 0.1f },
                        },
                    },
                });

                _plugin.permission.GrantUserPermission(_player.UserIDString, "recyclemanager.speed.fast", _plugin);

                var gears = AddItemToContainer(_recycler.inventory, "gears");
                _plugin.CallHook(nameof(OnRecyclerToggle), _recycler, _player);
                _recycler.StartRecycling();

                yield return null;
                AssertItemAmount(gears, 1);
                yield return new WaitForSeconds(0.31f);
                AssertItemAmount(gears, 0);
            }

            [TestMethod("Given default recycle time 0.2 seconds, gears 0.5 multiplier, gears should recycle after 0.1 seconds, metalpipes after 0.2 seconds")]
            public IEnumerator Test_RecycleSpeed()
            {
                InitializePlugin(new Configuration
                {
                    RecycleSpeed = new RecycleSpeed
                    {
                        Enabled = true,
                        DefaultRecycleTime = 0.2f,
                        TimeMultiplierByShortName = new Dictionary<string, float>
                        {
                            ["gears"] = 0.5f,
                        },
                    },
                });

                var gears1 = AddItemToContainer(_recycler.inventory, "gears", slot: 0);
                var pipe1 = AddItemToContainer(_recycler.inventory, "metalpipe", slot: 1);
                var gears2 = AddItemToContainer(_recycler.inventory, "gears", slot: 2);
                var pipe2 = AddItemToContainer(_recycler.inventory, "metalpipe", slot: 3);

                _plugin.CallHook(nameof(OnRecyclerToggle), _recycler, _player);
                _recycler.StartRecycling();

                yield return null;
                yield return new WaitForSeconds(0.11f);
                AssertItemAmount(gears1, 0);
                AssertItemAmount(pipe1, 1);
                AssertItemAmount(gears2, 1);
                AssertItemAmount(pipe2, 1);

                yield return new WaitForSeconds(0.2f);
                AssertItemAmount(pipe1, 0);
                AssertItemAmount(gears2, 1);
                AssertItemAmount(pipe2, 1);

                yield return new WaitForSeconds(0.1f);
                AssertItemAmount(gears2, 0);
                AssertItemAmount(pipe2, 1);

                yield return new WaitForSeconds(0.2f);
                AssertItemAmount(pipe2, 0);
            }

            [TestMethod("Given gears max stack size 100, stack of 3 gears, with no override configured, should output 30 scrap and 39 metal fragments")]
            public IEnumerator Test_RecycleStacks_NoOverride(List<Action> cleanupActions)
            {
                InitializePlugin(new Configuration
                {
                    RecycleSpeed = new RecycleSpeed
                    {
                        Enabled = true,
                        DefaultRecycleTime = 0.1f,
                    },
                });

                cleanupActions.Add(SetMaxStackSize("gears", 100));

                var gears = AddItemToContainer(_recycler.inventory, "gears", 3);
                _plugin.CallHook(nameof(OnRecyclerToggle), _recycler, _player);
                _recycler.StartRecycling();

                yield return null;
                yield return new WaitForSeconds(0.11f);
                AssertItemAmount(gears, 0);
                AssertItemInContainer(_recycler.inventory, 6, "scrap", 30);
                AssertItemInContainer(_recycler.inventory, 7, "metal.fragments", 39);
            }

            [TestMethod("Given gears max stack size 100, stack of 75 gears, default stack percent 50%, should output 500 scrap & 975 metal fragments, then should output 750 scrap & 975 metal fragments")]
            public IEnumerator Test_RecycleStacks_DefaultPercent(List<Action> cleanupActions)
            {
                InitializePlugin(new Configuration
                {
                    RecycleSpeed = new RecycleSpeed
                    {
                        Enabled = true,
                        DefaultRecycleTime = 0.1f,
                    },
                    MaxItemsPerRecycle = new MaxItemsPerRecycle
                    {
                        DefaultPercent = 50f,
                    },
                });

                cleanupActions.Add(SetMaxStackSize("gears", 100));

                var gears = AddItemToContainer(_recycler.inventory, "gears", 75);
                _plugin.CallHook(nameof(OnRecyclerToggle), _recycler, _player);
                _recycler.StartRecycling();

                yield return null;
                yield return new WaitForSeconds(0.11f);
                AssertItemAmount(gears, 25);
                AssertItemInContainer(_recycler.inventory, 6, "scrap", 500);
                AssertItemInContainer(_recycler.inventory, 7, "metal.fragments", 650);

                yield return new WaitForSeconds(0.1f);
                AssertItemAmount(gears, 0);
                AssertItemInContainer(_recycler.inventory, 6, "scrap", 750);
                AssertItemInContainer(_recycler.inventory, 7, "metal.fragments", 975);
            }

            [TestMethod("Given gears max stack size 100, stack of 75 gears, gears stack percent 50%, should output 500 scrap & 975 metal fragments, then should output 750 scrap & 975 metal fragments")]
            public IEnumerator Test_RecycleStacks_ShortNamePercent(List<Action> cleanupActions)
            {
                InitializePlugin(new Configuration
                {
                    RecycleSpeed = new RecycleSpeed
                    {
                        Enabled = true,
                        DefaultRecycleTime = 0.1f,
                    },
                    MaxItemsPerRecycle = new MaxItemsPerRecycle
                    {
                        DefaultPercent = 10f,
                        PercentByShortName = new Dictionary<string, float>
                        {
                            ["gears"] = 50,
                        }
                    },
                });

                cleanupActions.Add(SetMaxStackSize("gears", 100));

                var gears = AddItemToContainer(_recycler.inventory, "gears", 75);
                _plugin.CallHook(nameof(OnRecyclerToggle), _recycler, _player);
                _recycler.StartRecycling();

                yield return null;
                yield return new WaitForSeconds(0.11f);
                AssertItemAmount(gears, 25);
                AssertItemInContainer(_recycler.inventory, 6, "scrap", 500);
                AssertItemInContainer(_recycler.inventory, 7, "metal.fragments", 650);

                yield return new WaitForSeconds(0.1f);
                AssertItemAmount(gears, 0);
                AssertItemInContainer(_recycler.inventory, 6, "scrap", 750);
                AssertItemInContainer(_recycler.inventory, 7, "metal.fragments", 975);
            }

            [TestMethod("Given 2.0 default multiplier, 3.0 scrap output multiplier, stack of 3 gears, should output 90 scrap & 78 metal fragments")]
            public IEnumerator Test_OutputMultipliers(List<Action> cleanupActions)
            {
                InitializePlugin(new Configuration
                {
                    RecycleSpeed = new RecycleSpeed
                    {
                        Enabled = true,
                        DefaultRecycleTime = 0.1f,
                    },
                    OutputMultipliers = new OutputMultiplierSettings
                    {
                        DefaultMultiplier = 2,
                        MultiplierByOutputShortName = new Dictionary<string, float>
                        {
                            ["scrap"] = 3f
                        },
                    },
                });

                cleanupActions.Add(SetMaxStackSize("gears", 100));

                var gears = AddItemToContainer(_recycler.inventory, "gears", 3);
                _plugin.CallHook(nameof(OnRecyclerToggle), _recycler, _player);
                _recycler.StartRecycling();

                yield return null;
                yield return new WaitForSeconds(0.11f);
                AssertItemAmount(gears, 0);
                AssertItemInContainer(_recycler.inventory, 6, "scrap", 90);
                AssertItemInContainer(_recycler.inventory, 7, "metal.fragments", 78);
            }

            [TestMethod("Given override for gears, stack of 3 gears, should output custom items")]
            public IEnumerator Test_OverrideOutput_ByItemShortName(List<Action> cleanupActions)
            {
                InitializePlugin(new Configuration
                {
                    RecycleSpeed = new RecycleSpeed
                    {
                        Enabled = true,
                        DefaultRecycleTime = 0.1f,
                    },
                    OutputMultipliers = new OutputMultiplierSettings
                    {
                        // Output multipliers should have no effect.
                        DefaultMultiplier = 2,
                    },
                    OverrideOutput = new OverrideOutput
                    {
                        OverrideOutputByShortName = new CaseInsensitiveDictionary<IngredientInfo[]>
                        {
                            ["gears"] = new IngredientInfo[]
                            {
                                new IngredientInfo
                                {
                                    ShortName = "wood",
                                    Amount = 50,
                                    SkinId = 123456,
                                    DisplayName = "Vood",
                                },
                            },
                        },
                    },
                });

                cleanupActions.Add(SetMaxStackSize("gears", 100));

                var gears = AddItemToContainer(_recycler.inventory, "gears", 3);
                _plugin.CallHook(nameof(OnRecyclerToggle), _recycler, _player);
                _recycler.StartRecycling();

                yield return null;
                yield return new WaitForSeconds(0.11f);
                AssertItemAmount(gears, 0);

                Item outputItem;
                AssertItemInSlot(_recycler.inventory, 6, out outputItem);
                AssertItemShortName(outputItem, "wood");
                AssertItemSkin(outputItem, 123456);
                AssertItemDisplayName(outputItem, "Vood");
                AssertItemAmount(outputItem, 150);
            }

            protected override void AfterAll(bool interrupted)
            {
                if (_recycler != null && !_recycler.IsDestroyed)
                {
                    _recycler.Kill();
                }

                if (_player != null && !_player.IsDestroyed)
                {
                    _player.Die();
                }

                if (!interrupted)
                {
                    InitializePlugin(_originalConfig);
                }
            }
        }

        #endif

        #endregion

        #region Test Runner

        #if ENABLE_TESTS

        [AttributeUsage(AttributeTargets.Method)]
        public class TestMethodAttribute : Attribute
        {
            public readonly string Name;
            public bool Skip;
            public bool Only;

            public TestMethodAttribute(string name = null)
            {
                Name = name;
            }
        }

        public abstract class BaseTestSuite
        {
            private enum TestStatus
            {
                Skipped,
                Running,
                Success,
                Error,
            }

            private class TestInfo
            {
                public string Name;
                public bool Async;
                public MethodInfo MethodInfo;
                public TestMethodAttribute Attribute;
                public TestStatus Status = TestStatus.Skipped;
                public bool ShouldSkip;
                public Exception Exception;
            }

            public bool IsRunning { get; private set; }

            private List<TestInfo> _testInfoList = new List<TestInfo>();
            private Coroutine _coroutine;

            protected virtual void BeforeAll() {}
            protected virtual void BeforeEach() {}
            protected virtual void AfterEach() {}
            protected virtual void AfterAll(bool interrupted) {}

            public void Run()
            {
                if (IsRunning)
                    return;

                if (!TryRunBeforeAll())
                    return;

                var hasOnly = false;

                foreach (var methodInfo in GetType().GetMethods())
                {
                    var testMethodAttribute = methodInfo.GetCustomAttributes(typeof(TestMethodAttribute), true).FirstOrDefault() as TestMethodAttribute;
                    if (testMethodAttribute == null)
                        continue;

                    var isAsync = methodInfo.ReturnType == typeof(IEnumerator);
                    if (!isAsync && methodInfo.ReturnType != typeof(void))
                    {
                        LogError($"Disallowed return type '{methodInfo.ReturnType.FullName}' for test '{testMethodAttribute.Name}'");
                        continue;
                    }

                    hasOnly |= testMethodAttribute.Only;

                    _testInfoList.Add(new TestInfo
                    {
                        Name = testMethodAttribute.Name,
                        Async = isAsync,
                        MethodInfo = methodInfo,
                        Attribute = testMethodAttribute,
                        ShouldSkip = testMethodAttribute.Skip,
                    });
                }

                if (hasOnly)
                {
                    foreach (var testInfo in _testInfoList)
                    {
                        testInfo.ShouldSkip = !testInfo.Attribute.Only;
                    }
                }

                var syncTestList = _testInfoList.Where(testInfo => !testInfo.Async).ToArray();
                var asyncTestList = _testInfoList.Where(testInfo => testInfo.Async).ToArray();

                var canKeepRunning = RunSyncTests(syncTestList);
                if (!canKeepRunning && asyncTestList.Length == 0)
                {
                    RunAfterAll();
                    return;
                }

                _coroutine = ServerMgr.Instance.StartCoroutine(RunAsyncTests(asyncTestList));
            }

            public void Interrupt()
            {
                if (!IsRunning)
                    return;

                if (_coroutine != null)
                {
                    ServerMgr.Instance.StopCoroutine(_coroutine);
                    LogWarning("Interrupted tests.");
                }

                RunAfterAll(true);
            }

            private bool TryRunBeforeAll()
            {
                IsRunning = true;

                try
                {
                    BeforeAll();
                    return true;
                }
                catch (Exception ex)
                {
                    LogError($"Failed to run BeforeAll() for test suite {GetType().FullName}:\n{ex}");
                    IsRunning = false;
                    return false;
                }
            }

            private bool TryRunBeforeEach()
            {
                try
                {
                    BeforeEach();
                    return true;
                }
                catch (Exception ex)
                {
                    LogError($"Failed to run BeforeEach() for test suite {GetType().FullName}:\n{ex}");
                    return false;
                }
            }

            private bool TryRunAfterEach()
            {
                try
                {
                    AfterEach();
                    return true;
                }
                catch (Exception ex)
                {
                    LogError($"Failed to run AfterEach() for test suite {GetType().FullName}:\n{ex}");
                    return false;
                }
            }

            private void RunAfterAll(bool interrupted = false)
            {
                try
                {
                    AfterAll(interrupted);
                }
                catch (Exception ex)
                {
                    LogError($"Failed to run AfterAll() method for test suite {GetType().FullName}:\n{ex}");
                }

                IsRunning = false;

                if (!interrupted)
                {
                    PrintResults();
                }
            }

            private bool HasParameter<T>(MethodInfo methodInfo, int parameterIndex = 0)
            {
                return methodInfo.GetParameters().ElementAtOrDefault(parameterIndex)?.ParameterType == typeof(T);
            }

            private object[] CreateTestArguments(MethodInfo methodInfo, out List<Action> cleanupActions)
            {
                if (HasParameter<List<Action>>(methodInfo))
                {
                    cleanupActions = new List<Action>();
                    return new object[] { cleanupActions };
                }

                cleanupActions = null;
                return null;
            }

            private void RunCleanupActions(List<Action> cleanupActions)
            {
                if (cleanupActions == null)
                    return;

                foreach (var action in cleanupActions)
                {
                    try
                    {
                        action.Invoke();
                    }
                    catch (Exception ex)
                    {
                        LogError($"Failed to run cleanup action:\n{ex}");
                    }
                }
            }

            private bool RunSyncTests(IEnumerable<TestInfo> syncTestList)
            {
                foreach (var testInfo in syncTestList)
                {
                    if (testInfo.ShouldSkip)
                        continue;

                    if (!TryRunBeforeEach())
                        return false;

                    List<Action> cleanupActions;
                    var args = CreateTestArguments(testInfo.MethodInfo, out cleanupActions);

                    try
                    {
                        testInfo.MethodInfo.Invoke(this, args);
                        testInfo.Status = TestStatus.Success;
                    }
                    catch (Exception ex)
                    {
                        testInfo.Exception = ex;
                        testInfo.Status = TestStatus.Error;
                    }

                    RunCleanupActions(cleanupActions);

                    if (!TryRunAfterEach())
                        return false;
                }

                return true;
            }

            private IEnumerator RunAsyncTests(IEnumerable<TestInfo> asyncTestList)
            {
                foreach (var testInfo in asyncTestList)
                {
                    if (testInfo.ShouldSkip)
                        continue;

                    if (!TryRunBeforeEach())
                        break;

                    List<Action> cleanupActions;
                    var args = CreateTestArguments(testInfo.MethodInfo, out cleanupActions);

                    IEnumerator enumerator;

                    try
                    {
                        enumerator = (IEnumerator)testInfo.MethodInfo.Invoke(this, args);
                    }
                    catch (Exception ex)
                    {
                        RunCleanupActions(cleanupActions);
                        testInfo.Exception = ex;
                        testInfo.Status = TestStatus.Error;
                        continue;
                    }

                    testInfo.Status = TestStatus.Running;

                    while (testInfo.Status == TestStatus.Running)
                    {
                        // This assumes Current is null or an instance of YieldInstruction.
                        yield return enumerator.Current;

                        try
                        {
                            if (!enumerator.MoveNext())
                            {
                                testInfo.Status = TestStatus.Success;
                                break;
                            }
                        }
                        catch (Exception ex)
                        {
                            RunCleanupActions(cleanupActions);
                            testInfo.Exception = ex;
                            testInfo.Status = TestStatus.Error;
                            break;
                        }
                    }

                    RunCleanupActions(cleanupActions);

                    if (!TryRunAfterEach())
                        break;
                }

                RunAfterAll();
            }

            private void PrintResults()
            {
                foreach (var testInfo in _testInfoList)
                {
                    switch (testInfo.Status)
                    {
                        case TestStatus.Success:
                            LogWarning($"[PASSED]  {testInfo.Name}");
                            break;

                        case TestStatus.Skipped:
                            LogWarning($"[SKIPPED] {testInfo.Name}");
                            break;

                        case TestStatus.Error:
                            LogError($"[FAILED]  {testInfo.Name}:\n{testInfo.Exception}");
                            break;

                        case TestStatus.Running:
                            LogError($"[RUNNING] {testInfo.Name}");
                            break;

                        default:
                            LogError($"[{testInfo.Status}] {testInfo.Name}");
                            break;
                    }
                }
            }
        }

        #endif

        #endregion
    }
}

// --- End of file: RecycleManager.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/BTeleportMenu.cs ---
// --- Original Local Path: BeeRust/BTeleportMenu.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
	[Info("BTeleportMenu", "King", "1.0.0")]
	public class BTeleportMenu : RustPlugin
	{
        #region [Vars]
        [PluginReference] Plugin Clans, NTeleportation, Teleportation;
        public string Layer = "BTeleportMenu.Layer";
        #endregion

        #region [Data]
        private void LoadData()
        {
            try
            {
                data = Interface.Oxide.DataFileSystem.ReadObject<PluginData>("BTeleportMenu");
            }
            catch (Exception e)
            {
                PrintError(e.ToString());
            }

            if (data == null) data = new PluginData();
        }

        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject("BTeleportMenu", data);

        private class PluginData
        {
            public Dictionary<ulong, PlayerData> PlayerData = new Dictionary<ulong, PlayerData>();
        }
    
        private static PluginData data;

        private class PlayerData
        {
            public bool AutoAccept;

            public static PlayerData GetOrAdd(BasePlayer player)
            {
                return GetOrAdd(player.userID);
            }

            public static PlayerData GetOrAdd(ulong userId)
            {
                if (!data.PlayerData.ContainsKey(userId))
                    data.PlayerData.Add(userId, new PlayerData
                    {
                        AutoAccept = true,
                    });

                return data.PlayerData[userId];
            }
        }
        #endregion

        #region [Oxide]
        private void OnServerInitialized()
        {
            cmd.AddChatCommand("tpmenu", this, "TeleportUi");
            cmd.AddChatCommand("atp", this, "cmdAutoTeleport");
            LoadData();
        }
        private void Unload()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList) 
                CuiHelper.DestroyUi(player, Layer);
            SaveData();
            data = null;
        }
        #endregion

        #region [AutoTeleport]
        private void CheckTeleport(BasePlayer receiver, BasePlayer caller)
        {
            var data = PlayerData.GetOrAdd(receiver);
            if(data.AutoAccept)
            {
                if (IsClanMember(caller.userID, receiver.userID))
                {
                    receiver.SendConsoleCommand("chat.say /tpa");
                    return;
                }
            }
        }
        private void OnTeleportRequested(BasePlayer receiver, BasePlayer caller) => CheckTeleport(receiver, caller);
        private void cmdAutoTeleport(BasePlayer player)
        {
            var data = PlayerData.GetOrAdd(player);
            if (data.AutoAccept)
            {
                data.AutoAccept = false;
                player.ChatMessage($"Вы включили автоматическое <color=#AAFF81FF>/tpa</color>");

            }
            else
            {
                data.AutoAccept = true;
                player.ChatMessage($"Вы отключили автоматическое <color=#AAFF81FF>/tpa</color>");
            }
            return;
        }
        #endregion

        #region [Main-Ui]
        private void TeleportUi(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, Layer);
            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Material = "assets/content/ui/uibackgroundblur.mat", Color = "0 0 0 0.85" },
            }, "Overlay", Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Button = { Color = "0.36 0.33 0.28 0.2", Material = "assets/icons/greyout.mat", Close = Layer },
                Text = { Text = "" }
            }, Layer);

            CuiHelper.AddUi(player, container);
            TeleportUiMain(player);
        }
        private void TeleportUiMain(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, Layer + ".Main");
            CuiElementContainer container = new CuiElementContainer();
            var data = PlayerData.GetOrAdd(player);

            container.Add(new CuiElement
            {
                Name = Layer + ".Main",
                Parent = Layer,
                Components =
                {
                    new CuiImageComponent { Color = "0.36 0.34 0.32 0.45", Material = "assets/icons/greyout.mat" },
                    new CuiRectTransformComponent {AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-345 -170", OffsetMax = "347 177"}
                }
            });

            #region [Text]
            container.Add(new CuiElement
            {
                Parent = Layer + ".Main",
                Components =
                {
                    new CuiTextComponent() { Color = "1 1 1 0.85", Text = "МЕНЮ ТЕЛЕПОРТАЦИИ", FontSize = 28, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf" },
                    new CuiRectTransformComponent {AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-345 177", OffsetMax = "345 227.5"},
                    new CuiOutlineComponent{Color = "0 0 0 1", Distance = "0.05 0.05"},
                }
            });

            container.Add(new CuiElement
            {
                Parent = Layer + ".Main",
                Components = {
                    new CuiTextComponent() { Color = "1 1 1 0.85", Text = "ТЕЛЕПОРТАЦИЯ К ДРУГУ", FontSize = 20, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf"  },
                    new CuiRectTransformComponent { AnchorMin = "0 0.4745", AnchorMax = "1 0.5625" },
                    new CuiOutlineComponent{ Color = "0 0 0 1", Distance = "0.01 0.01" },
                }
            });

            container.Add(new CuiElement
            {
                Parent = Layer + ".Main",
                Components = {
                    new CuiTextComponent() { Color = "1 1 1 0.85", Text = "ТЕЛЕПОРТАЦИЯ ДОМОЙ", FontSize = 20, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf"  },
                    new CuiRectTransformComponent { AnchorMin = "0 0.2435", AnchorMax = "1 0.3325" },
                    new CuiOutlineComponent{ Color = "0 0 0 1", Distance = "0.01 0.01" },
                }
            });
            #endregion

            #region [Buttons]
            var setHome = GetGridString(player.transform.position);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.1965 0.8525", AnchorMax = "0.49 0.965" },
                Button = { Close = Layer, Command = $"chat.say /outpost", Color = "0 0 0 0.85" },
                Text = { Text = $"Город NPC", FontSize = 18, Align = TextAnchor.MiddleCenter, Color = "1 1 1 0.5", Font = "robotocondensed-bold.ttf" }
            }, Layer + ".Main");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.507 0.8525", AnchorMax = "0.8025 0.965" },
                Button = { Close = Layer, Command = $"chat.say /outpost", Color = "0 0 0 0.85" },
                Text = { Text = $"Город Бандитов", FontSize = 18, Align = TextAnchor.MiddleCenter, Color = "1 1 1 0.5", Font = "robotocondensed-bold.ttf" }
            }, Layer + ".Main");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.1965 0.707", AnchorMax = "0.49 0.8185" },
                Button = { Close = Layer, Command = $"BTeleport_UI /sethome {setHome}", Color = "0.81 0.51 0.18 0.85" },
                Text = { Text = $"Сохранить Дом", FontSize = 18, Align = TextAnchor.MiddleCenter, Color = "1 1 1 0.5", Font = "robotocondensed-bold.ttf" }
            }, Layer + ".Main");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.507 0.707", AnchorMax = "0.8025 0.8185" },
                Button = { Close = Layer, Command = $"chat.say /atp", Color = data.AutoAccept == true ? "0.44 0.50 0.29 0.85" : "0.54 0.22 0.18 0.85" },
                Text = { Text = $"Автопринятия ТП", FontSize = 18, Align = TextAnchor.MiddleCenter, Color = "1 1 1 0.5", Font = "robotocondensed-bold.ttf" }
            }, Layer + ".Main");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.1965 0.5625", AnchorMax = "0.49 0.67515" },
                Button = { Close = Layer, Command = $"chat.say /tpa", Color = "0.44 0.50 0.29 0.85" },
                Text = { Text = $"Принять ТП", FontSize = 18, Align = TextAnchor.MiddleCenter, Color = "1 1 1 0.5", Font = "robotocondensed-bold.ttf" }
            }, Layer + ".Main");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.507 0.5625", AnchorMax = "0.8025 0.67515" },
                Button = { Close = Layer, Command = $"chat.say /tpc", Color = "0.54 0.22 0.18 0.85" },
                Text = { Text = $"Отклонить ТП", FontSize = 18, Align = TextAnchor.MiddleCenter, Color = "1 1 1 0.5", Font = "robotocondensed-bold.ttf" }
            }, Layer + ".Main");
            #endregion

            #region [Team]
            container.Add(new CuiElement
            {
                Name = Layer + ".Main" + ".TeamLayer",
                Parent = Layer + ".Main",
                Components =
                {
                    new CuiImageComponent { Color =  "0.2 0.2 0.2 0.45", Material = "assets/icons/greyout.mat" },
                    new CuiRectTransformComponent {AnchorMin = "0.01446 0.3325", AnchorMax = "0.9825 0.4745"}
                }
            });
 
            string clanTag = GetClan(player.userID);
            if (!string.IsNullOrEmpty(clanTag))
            {
                var clanMembers = GetClanMembers(player.userID);
                if (clanMembers != null && clanMembers.Count > 0)
                {
                    foreach (var check in clanMembers.Select((i, t) => new { A = i, B = t }))
                    {
                        var clanMember = covalence.Players.FindPlayerById(check.A.ToString());
                        if (clanMember == null) continue;
                        
                        container.Add(new CuiButton
                        {
                            RectTransform = { AnchorMin = $"{0.015 + check.B * 0.247 - Math.Floor((float) check.B / 4) * 5 * 0.247} {0.2 - Math.Floor((float) check.B/ 4) * 0}",
                                              AnchorMax = $"{0.245 + check.B * 0.247 - Math.Floor((float) check.B / 4) * 5 * 0.247} {0.78 - Math.Floor((float) check.B / 4) * 0}", },
                            Button = { Color = "0.52 0.47 0.48 0.75", Command = $"BTeleport_UI /tpr {clanMember.Id}", Close = Layer },
                            Text = { Text = $"{clanMember.Name}", FontSize = 15, Align = TextAnchor.MiddleCenter, Color = "1 1 1 0.7", Font = "robotocondensed-bold.ttf" }
                        }, Layer + ".Main" + ".TeamLayer",  Layer + ".Main" + ".TeamLayer" + $".{check.B}");
                    }
                }
            }
            #endregion

            #region [Home]
            var homeName = GetHomes(player);
            if (homeName.ContainsKey(setHome))
            {
                var count = homeName.Where(p => p.Key.Contains(setHome)).Count();
                setHome = setHome + $"({count})";
            }

            container.Add(new CuiElement
            {
                Name = Layer + ".Main" + ".HomeLayer",
                Parent = Layer + ".Main",
                Components =
                {
                    new CuiImageComponent { Color =  "0.2 0.2 0.2 0.45", Material = "assets/icons/greyout.mat" },
                    new CuiRectTransformComponent {AnchorMin = "0.01446 0.02786", AnchorMax = "0.9825 0.2435"}
                }
            });

            if (homeName != null && homeName.Count > 0)
            {
                foreach (var check in homeName.Select((i, t) => new { A = i, B = t }).Take(10))
                {
                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = $"{0.015 + check.B * 0.0985 - Math.Floor((float) check.B / 10) * 10 * 0.0985} {0.13 - Math.Floor((float) check.B/ 10) * 0.215}",
                                          AnchorMax = $"{0.097 + check.B * 0.0985 - Math.Floor((float) check.B / 10) * 10 * 0.0985} {0.85 - Math.Floor((float) check.B / 10) * 0.215}", },
                        Button = { Color = "0.52 0.47 0.48 0.75", Command = $"BTeleport_UI /home {check.A.Key}", Close = Layer },
                        Text = { Text = $"{check.A.Key}", FontSize = 20, Align = TextAnchor.MiddleCenter, Color = "1 1 1 0.7", Font = "robotocondensed-bold.ttf" }
                    }, Layer + ".Main" + ".HomeLayer",  Layer + ".Main" + ".HomeLayer" + $".{check.B}");

                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0.8 0.8", AnchorMax = "1 1" },
                        Button = { Command = $"BTeleport_UI /home remove {check.A.Key}", Color = "1.00 0.54 0.54 1.00", Sprite = "assets/icons/close.png", Close = Layer },
                        Text = { Text = "" }
                    }, Layer + ".Main" + ".HomeLayer" + $".{check.B}");
                }
            }
            #endregion

            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region [Func]
        [ConsoleCommand("BTeleport_UI")]
        private void cmdSendCommand(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            if (player == null) return;
            if (args.FullString.Contains("/"))
                player.Command("chat.say", args.FullString);
            else
                player.Command(args.FullString);
        }
        private string GetGridString(Vector3 position)
        {
            Vector2 adjPosition = new Vector2((World.Size / 2) + position.x, (World.Size / 2) - position.z);
            return $"{NumberToString((int)(adjPosition.x / 150))}{(int)(adjPosition.y / 150)}";
        }
        private string NumberToString(int number)
        {
            bool a = number > 26;
            Char c = (Char)(65 + (a ? number - 26 : number));
            return a ? "A" + c : c.ToString();
        }
        Dictionary<string, Vector3> GetHomes(BasePlayer player)
        {
            var a1 = (Dictionary<string, Vector3>)NTeleportation?.Call("API_GetHomes", player) ?? new Dictionary<string, Vector3>();
            var a2 = (Dictionary<string, Vector3>)Teleportation?.Call("GetHomes", player.userID) ?? new Dictionary<string, Vector3>();
            return a1.Concat(a2).GroupBy(p => p.Key).ToDictionary(p => p.Key, p => p.First().Value);
        }
        private string GetClan(ulong userID) => Clans?.Call<string>("GetClanTag", userID);
        bool IsClanMember(ulong playerid = 1, ulong targetID = 0) => (bool)(Clans?.Call("IsTeammates", playerid, targetID) ?? false);
        private List<ulong> GetClanMembers(ulong playerId)
        {
            if (Clans)
            {
                var clan = Clans?.Call("BTeleportMenuHook", playerId) as List<ulong>;
                return clan.ToList();
            }
            return new List<ulong>();
        }
        #endregion
    }
}

// --- End of file: BTeleportMenu.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/VendingInStock.cs ---
// --- Original Local Path: BeeRust/VendingInStock.cs ---

using Oxide.Core;
using System.Linq;
using System;

using System.Collections.Generic;
using UnityEngine;
using Newtonsoft.Json;
using Facepunch;

namespace Oxide.Plugins
{
    [Info("Vending In Stock", "AVOcoder / rostov114", "1.1.0")]
    [Description("VendingMachines sell-orders always in stock")]
    class VendingInStock : RustPlugin
    {
        #region Configuration
        private Configuration _config;
        private class Configuration
        {
            [JsonProperty(PropertyName = "Disable native refill")]
            public bool disableNativeRefill = false;

            [JsonProperty(PropertyName = "Do not refill items")]
            public string[] noRefillItems =
            { 
                "put item shortname here"
            };

            [JsonProperty(PropertyName = "Do not refill vendings")]
            public string[] noRefillVendings =
            {
                "put vending orders name here (see console command >>> vending_orders_name <<<)"
            };

            public bool NoRefillItem(Item item)
            {
                if (noRefillItems == null)
                    return false;

                return noRefillItems.Contains(item.info.shortname);
            }

            public bool NoRefillVending(NPCVendingMachine vm)
            {
                if (noRefillVendings == null || vm.vendingOrders == null || vm.vendingOrders.name == null)
                    return false;

                return noRefillVendings.Contains(vm.vendingOrders.name);
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                SaveConfig();
            }
            catch
            {
                PrintError("Error reading config, please check!");

                Unsubscribe(nameof(OnServerInitialized));
                Unsubscribe(nameof(Unload));
                Unsubscribe(nameof(CanPurchaseItem));
            }
        }

        protected override void LoadDefaultConfig()
        {
            _config = new Configuration();
            SaveConfig();
        }

        protected override void SaveConfig() => Config.WriteObject(_config);
        #endregion

        #region Oxide Hooks
        private void OnServerInitialized()
        {
            if (!_config.disableNativeRefill)
                return;

            foreach (NPCVendingMachine vm in BaseNetworkable.serverEntities.Where(e => e is NPCVendingMachine))
            {
                timer.Once(1f, () =>
                {
                    if (vm == null || vm.IsDestroyed || _config.NoRefillVending(vm)) 
                        return;

                    foreach (Item item in vm.inventory.itemList)
                    {
                        if (_config.NoRefillItem(item))
                            PrintWarning($"Native refill disabled and enabled not refill item! Please disable 'Disable native refill' OR add vending in 'Do not refill vendings'! Vending name: {vm.shopName}, Item: {item.info.shortname}");
                    }

                    vm.CancelInvoke(new Action(vm.Refill));
                });
            }
        }

        private void Unload()
        {
            if (!_config.disableNativeRefill)
                return;

            foreach (NPCVendingMachine vm in BaseNetworkable.serverEntities.Where(e => e is NPCVendingMachine))
            {
                if (_config.NoRefillVending(vm)) 
                    continue;

                vm.InvokeRandomized(new Action(vm.Refill), 1f, 1f, 0.1f);
            }
        }

        private void CanPurchaseItem(BasePlayer buyer, Item soldItem, Action<BasePlayer, Item> onItemPurchased, NPCVendingMachine vm)
        {
            if (vm == null || soldItem == null || soldItem.info == null)
                return;

            if (_config.NoRefillVending(vm))
                return; 

            if (_config.NoRefillItem(soldItem))
            {
                if (_config.disableNativeRefill)
                    PrintWarning($"Native refill disabled and enabled not refill item! Please disable 'Disable native refill' OR add vending in 'Do not refill vendings'! Vending name: {vm.shopName}, Item: {soldItem.info.shortname}");

                return;
            }

            if (Interface.CallHook("CanVendingStockRefill", vm, soldItem, buyer) != null)
                return;

            Item item = ItemManager.Create(soldItem.info, soldItem.amount, soldItem.skin);
            if (soldItem.blueprintTarget != 0)
                item.blueprintTarget = soldItem.blueprintTarget;

            if (soldItem.instanceData != null)
                item.instanceData.dataInt = soldItem.instanceData.dataInt;

            NextTick(() =>
            {
                if (item == null)
                    return;

                if (vm == null || vm.IsDestroyed) {
                    item.Remove(0f);
                    return;
                }

                vm.transactionActive = true;
                if (!item.MoveToContainer(vm.inventory, -1, true))
                    item.Remove(0f);

                vm.transactionActive = false;
                vm.FullUpdate();
            });
        }
        #endregion

        #region Console Commands
        [ConsoleCommand("vending_orders_name")]
        private void vending_orders_name(ConsoleSystem.Arg arg)
        {
            BasePlayer p = arg?.Player() ?? null; 
            if (p != null && !p.IsAdmin) 
                return;

            TextTable textTable = new TextTable();
            textTable.AddColumn("Vending name");
            textTable.AddColumn("Vending orders name (use plugin config)");

            List<string> _cache = Pool.GetList<string>();
            foreach (NPCVendingMachine vm in BaseNetworkable.serverEntities.Where(e => e is NPCVendingMachine))
            {
                if (vm == null || vm.vendingOrders == null || vm.vendingOrders.name == null || _cache.Contains(vm.vendingOrders.name))
                    continue;

                _cache.Add(vm.vendingOrders.name);
                textTable.AddRow(new string[]
                {
                    vm.shopName,
                    vm.vendingOrders.name
                });
            }

            Pool.FreeList<string>(ref _cache);
            arg.ReplyWith(textTable.ToString());
        }
        #endregion
    }
}

// --- End of file: VendingInStock.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/FProtection.cs ---
// --- Original Local Path: BeeRust/FProtection.cs ---

using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using System.Linq;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using Oxide.Core;
using System.Globalization;
using Newtonsoft.Json.Linq;
using ProtoBuf;
using Rust;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("FProtection", "King", "1.0.2")]
    class FProtection : RustPlugin
	{ 
        #region [Vars]
        private Dictionary<BasePlayer, DateTime> Cooldown = new Dictionary<BasePlayer, DateTime>();
        private Boolean _IsTime = false;
        private Single _DamageEntity = 0f;
        #endregion

        #region [Config]
        private PluginConfig config;

        protected override void LoadDefaultConfig()
        {
            config = PluginConfig.DefaultConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();

            if (config.PluginVersion < Version)
                UpdateConfigValues();

            Config.WriteObject(config, true);
        }

        private void UpdateConfigValues()
        {
            PluginConfig baseConfig = PluginConfig.DefaultConfig();
            if (config.PluginVersion < Version)
            {
                config.PluginVersion = Version;
                if (Version == new VersionNumber(1, 0, 2))
                {
                    config._MainSettings.ChatNotify = true;
                }

                PrintWarning("Config checked completed!");
            }
            config.PluginVersion = Version;
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        public class ProtectSettings
        {
			[JsonProperty("Начало защиты | Часы")]
            public int HourStart;

			[JsonProperty("Начало защиты | Минуты")]
            public int MinuteStart;

			[JsonProperty("Конец защиты | Часы")]
            public int HourEnd;

			[JsonProperty("Конец защиты | Минуты")]
            public int MinuteEnd;

            [JsonProperty("Процент защиты. 1.0 - 100%")]
            public float Damage;

            [JsonIgnore]
            public TimeSpan TimeOn,TimeOff;
        }

        public class MainSettings
        {
            [JsonProperty("Раз в сколько секунд проверять активность защиты ( Секунды )")] 
            public int Timer;

            [JsonProperty("Разрешить ломать солому во время защиты")] 
            public Boolean Twigs;

            [JsonProperty("Использовать чат оповещение при повреждении постройки ( При активной защите )")] 
            public Boolean ChatNotify;
        }

        private class PluginConfig
        {
            [JsonProperty("Основные настройки")]
            public MainSettings _MainSettings = new MainSettings();

            [JsonProperty("Настройки защиты")]
            public List<ProtectSettings> _ProtectSettings = new List<ProtectSettings>();

            [JsonProperty("Config version")]
            public VersionNumber PluginVersion = new VersionNumber();

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    _MainSettings = new MainSettings
                    {
                        Timer = 120,
                        Twigs = true,
                        ChatNotify = true,
                    }, 
                    _ProtectSettings = new List<ProtectSettings>()
                    {
                        new ProtectSettings()
                        {
                            HourStart = 22,
                            MinuteStart = 0,
                            HourEnd = 23,
                            MinuteEnd = 0,
                            Damage = 0.5f,
                        },
                        new ProtectSettings()
                        {
                            HourStart = 23,
                            MinuteStart = 15,
                            HourEnd = 12,
                            MinuteEnd = 0,
                            Damage = 1f,
                        },
                    },
                    PluginVersion = new VersionNumber()
                };
            }
        }
        #endregion

        #region [Oxide]
		private void OnServerInitialized()
		{
            FilingTime();

            Protection();
			timer.Every(config._MainSettings.Timer, () => Protection());
		}

        private void FilingTime()
        {
            foreach (var key in config._ProtectSettings)
            {
                TimeSpan TimeOn = new TimeSpan(key.HourStart, key.MinuteStart, 0);
                TimeSpan TimeOff = new TimeSpan(key.HourEnd, key.MinuteEnd, 0);

                key.TimeOn = TimeOn;
                key.TimeOff = TimeOff;
            }
        }
        #endregion

        #region [Functional]
        private void Protection() => _IsTime = CheckTime();

		private Boolean CheckTime()
		{
            var timeNow = DateTime.Now.TimeOfDay;
            var find = config._ProtectSettings.FirstOrDefault(time => (time.TimeOn <= time.TimeOff && time.TimeOn <= timeNow && timeNow <= time.TimeOff)
                                                            || (time.TimeOn > time.TimeOff && (time.TimeOn <= timeNow || timeNow  <= time.TimeOff)));
            if (find == null)
            {
                if (_DamageEntity != 0f)
                {
                    _DamageEntity = 0f;
                    Server.Broadcast($"Защита строений изменена, дополнительное сопротивление урону <color=#9ACD32>{_DamageEntity * 100}%</color>");
                }
                return false;
            }
            else if (_DamageEntity != find.Damage)
            {
                _DamageEntity = find.Damage;
                Server.Broadcast($"Защита строений изменена, дополнительное сопротивление урону <color=#9ACD32>{_DamageEntity * 100}%</color>");
            }

            return true;
        }

		private void Protection(BaseCombatEntity entity, HitInfo info)
		{
			if (_IsTime)
			{
				BasePlayer player = info.InitiatorPlayer;
				Boolean ent = entity is BuildingBlock;
				
				if(config._MainSettings.Twigs && ent)
					if((entity as BuildingBlock).grade == BuildingGrade.Enum.Twigs)
						return;
				
		        if (ent || entity is Door || entity is SimpleBuildingBlock || entity is SamSite || entity is AutoTurret)
			    {
                    info.damageTypes.ScaleAll(1.0f - _DamageEntity);

                    if (info.damageTypes.Total() >= 0.5)
                    {
						if (Cooldown.ContainsKey(player))
							if (Cooldown[player].Subtract(DateTime.Now).TotalSeconds >= 0) return;

                        player.ChatMessage($"Защита строений активна, дополнительное сопротивление урону <color=#9ACD32>{_DamageEntity * 100}%</color>");
                        Cooldown[player] = DateTime.Now.AddSeconds(5);
                    }
			    }
			}
		}
        #endregion

        #region [Rust]
		private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
		{
			if (entity == null || info?.InitiatorPlayer == null) return;
			
			Protection(entity, info);
		}
        #endregion

        #region [ChatCommand]
        [ChatCommand("bps")]
        private void cmdShowBPS(BasePlayer player, string command, string[] args)
        {
            String Text = string.Empty;
            String protectionText = string.Empty;
            int i = 1;
            if (_DamageEntity == 0f)
            {
                foreach (var protect in config._ProtectSettings)
                {
                    protectionText += string.Format("<color=#9ACD32>{0:00}:00</color> до <color=#9ACD32>{1:00}:00</color>{2:00}", protect.HourStart, protect.HourEnd, i != config._ProtectSettings.Count ? " а также с " : "!!");
                    i++;
                }
                Text += $"Ночная защита не активна! Она будет действовать с {protectionText}";
            }
            else
            {
                Text += $"Ночная защита активна! Дополнительное сопротивление урону <color=#9ACD32>{_DamageEntity * 100}%</color>";
            }

            player.ChatMessage(Text);
        }
        #endregion
    }
}

// --- End of file: FProtection.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/Stacks.cs ---
// --- Original Local Path: BeeRust/Stacks.cs ---

using System.Collections.Generic;
using System.Linq;
using System;
using UnityEngine;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Stacks", "Nimant", "2.0.4")]
    public class Stacks : RustPlugin
    {
        [PluginReference] private Plugin FurnaceSplitter;
        private static Dictionary<string, int> jXuGEdXFJIzIUWQOpYOZNIJ = new Dictionary<string, int>();

        private static Dictionary<string, int> XAXfVFPbfUI = new Dictionary<string, int>()
            {{"Attire", 2}, {"Tool", 1}, {"Weapon", 1}};

        private void Init()
        {
            MFbOuyfXAqPnQUkGOaKBezo();
            var yIhMaLVxgmbLicchecoXJfdGI = false;
            if (HGJfIWGOkTcdLbGIFiAb.RSjYaftfLwPnVesiMQltPxD == null)
            {
                HGJfIWGOkTcdLbGIFiAb.RSjYaftfLwPnVesiMQltPxD = new List<string>();
                yIhMaLVxgmbLicchecoXJfdGI = true;
            }

            if (HGJfIWGOkTcdLbGIFiAb.yBPzMbzsaiBVjicaXFqsmEjTwwvjd == null)
            {
                HGJfIWGOkTcdLbGIFiAb.yBPzMbzsaiBVjicaXFqsmEjTwwvjd = new List<string>()
                    {"Blue Keycard", "Green Keycard", "Red Keycard"};
                yIhMaLVxgmbLicchecoXJfdGI = true;
            }

            if (HGJfIWGOkTcdLbGIFiAb.eyEnBlUwiSVEbqTYsOoAWSlbYAKqY == null)
            {
                HGJfIWGOkTcdLbGIFiAb.eyEnBlUwiSVEbqTYsOoAWSlbYAKqY = new List<ulong>();
                yIhMaLVxgmbLicchecoXJfdGI = true;
            }

            if (HGJfIWGOkTcdLbGIFiAb.SUMgbOLYXEWqWGNauhbgEajpmt == null)
            {
                HGJfIWGOkTcdLbGIFiAb.SUMgbOLYXEWqWGNauhbgEajpmt = new List<string>();
                yIhMaLVxgmbLicchecoXJfdGI = true;
            }

            if (yIhMaLVxgmbLicchecoXJfdGI) qqOsjhDfbcTCbeFmh(HGJfIWGOkTcdLbGIFiAb);
        }

        private void OnServerInitialized()
        {
            var gnvHnEcTiZI = ItemManager.itemList.ToList();
            List<string> iYVmINDpHhehYOadREWmaW = new List<string>();
            List<string> CBVPeybAMYQDADFiPvmfOMFv = new List<string>();
            foreach (var mCDDdYSVLSWfHUkXrtG in gnvHnEcTiZI.OrderBy(r => r.category))
            {
                var lRpcAWHnInDrkWHzVhePfu = mCDDdYSVLSWfHUkXrtG.category.ToString();
                var YYvmAiPUeXEYGpFzwLxLNVypVAW = mCDDdYSVLSWfHUkXrtG.displayName.english;
                if (!HGJfIWGOkTcdLbGIFiAb.AqfUFopQwAbfNey.ContainsKey(lRpcAWHnInDrkWHzVhePfu))
                {
                    HGJfIWGOkTcdLbGIFiAb.AqfUFopQwAbfNey.Add(lRpcAWHnInDrkWHzVhePfu,
                        new Dictionary<string, int> { { YYvmAiPUeXEYGpFzwLxLNVypVAW, mCDDdYSVLSWfHUkXrtG.stackable } });
                    iYVmINDpHhehYOadREWmaW.Add(
                        $"'{YYvmAiPUeXEYGpFzwLxLNVypVAW}' в категории '{lRpcAWHnInDrkWHzVhePfu}'");
                }
                else if (!HGJfIWGOkTcdLbGIFiAb.AqfUFopQwAbfNey[lRpcAWHnInDrkWHzVhePfu]
                    .ContainsKey(YYvmAiPUeXEYGpFzwLxLNVypVAW))
                {
                    HGJfIWGOkTcdLbGIFiAb.AqfUFopQwAbfNey[lRpcAWHnInDrkWHzVhePfu]
                        .Add(YYvmAiPUeXEYGpFzwLxLNVypVAW, mCDDdYSVLSWfHUkXrtG.stackable);
                    iYVmINDpHhehYOadREWmaW.Add(
                        $"'{YYvmAiPUeXEYGpFzwLxLNVypVAW}' в категории '{lRpcAWHnInDrkWHzVhePfu}'");
                }

                if (!jXuGEdXFJIzIUWQOpYOZNIJ.ContainsKey(lRpcAWHnInDrkWHzVhePfu + "|" + YYvmAiPUeXEYGpFzwLxLNVypVAW))
                    jXuGEdXFJIzIUWQOpYOZNIJ.Add(lRpcAWHnInDrkWHzVhePfu + "|" + YYvmAiPUeXEYGpFzwLxLNVypVAW,
                        mCDDdYSVLSWfHUkXrtG.stackable);
                mCDDdYSVLSWfHUkXrtG.stackable =
                    HGJfIWGOkTcdLbGIFiAb.AqfUFopQwAbfNey[lRpcAWHnInDrkWHzVhePfu][YYvmAiPUeXEYGpFzwLxLNVypVAW];
            }

            foreach (var aDLTPabOlfgxA in HGJfIWGOkTcdLbGIFiAb.AqfUFopQwAbfNey.Keys)
            {
                foreach (var mCDDdYSVLSWfHUkXrtG in HGJfIWGOkTcdLbGIFiAb.AqfUFopQwAbfNey[aDLTPabOlfgxA]
                    .ToDictionary(x => x.Key, x => x.Value))
                {
                    if (!gnvHnEcTiZI.Exists(x =>
                        x.displayName.english == mCDDdYSVLSWfHUkXrtG.Key && x.category.ToString() == aDLTPabOlfgxA))
                    {
                        HGJfIWGOkTcdLbGIFiAb.AqfUFopQwAbfNey[aDLTPabOlfgxA].Remove(mCDDdYSVLSWfHUkXrtG.Key);
                        CBVPeybAMYQDADFiPvmfOMFv.Add($"'{mCDDdYSVLSWfHUkXrtG.Key}' из категории '{aDLTPabOlfgxA}'");
                    }
                }

                if (HGJfIWGOkTcdLbGIFiAb.AqfUFopQwAbfNey[aDLTPabOlfgxA].Count == 0)
                    HGJfIWGOkTcdLbGIFiAb.AqfUFopQwAbfNey.Remove(aDLTPabOlfgxA);
            }

            if (iYVmINDpHhehYOadREWmaW.Count == 0 && CBVPeybAMYQDADFiPvmfOMFv.Count == 0) return;
            qqOsjhDfbcTCbeFmh(HGJfIWGOkTcdLbGIFiAb);
            if (iYVmINDpHhehYOadREWmaW.Count > 0)
            {
                PrintWarning("В конфигурационный файл были добавлены новые предметы:");
                foreach (var mCDDdYSVLSWfHUkXrtG in iYVmINDpHhehYOadREWmaW) PrintWarning(mCDDdYSVLSWfHUkXrtG);
            }

            if (CBVPeybAMYQDADFiPvmfOMFv.Count > 0)
            {
                PrintWarning("Конфигурационный файл был очищен от устаревших предметов:");
                foreach (var mCDDdYSVLSWfHUkXrtG in CBVPeybAMYQDADFiPvmfOMFv) PrintWarning(mCDDdYSVLSWfHUkXrtG);
            }
        }

        private void Unload()
        {
            foreach (var mCDDdYSVLSWfHUkXrtG in ItemManager.itemList)
                mCDDdYSVLSWfHUkXrtG.stackable =
                    jXuGEdXFJIzIUWQOpYOZNIJ[
                        mCDDdYSVLSWfHUkXrtG.category.ToString() + "|" + mCDDdYSVLSWfHUkXrtG.displayName.english];
        }

        private ItemContainer.CanAcceptResult? CanAcceptItem(ItemContainer unsgxNVqXKqqECsXQrG,
            Item YjlEoVwLrCFlMZxGRUgOwaQjuF, int targetPos)
        {
            if (unsgxNVqXKqqECsXQrG == null || YjlEoVwLrCFlMZxGRUgOwaQjuF == null ||
                unsgxNVqXKqqECsXQrG.playerOwner == null) return null;
            if (HGJfIWGOkTcdLbGIFiAb.RSjYaftfLwPnVesiMQltPxD.Contains(YjlEoVwLrCFlMZxGRUgOwaQjuF.info.displayName
                    .english) ||
                HGJfIWGOkTcdLbGIFiAb.RSjYaftfLwPnVesiMQltPxD.Contains(YjlEoVwLrCFlMZxGRUgOwaQjuF.info.shortname))
                return null;
            if (unsgxNVqXKqqECsXQrG.playerOwner.inventory.containerBelt == unsgxNVqXKqqECsXQrG)
            {
                if (tcChzNBoJCMHBaBQGcpnAUGuamBU(YjlEoVwLrCFlMZxGRUgOwaQjuF.info) &&
                    ((HGJfIWGOkTcdLbGIFiAb.yBPzMbzsaiBVjicaXFqsmEjTwwvjd.Contains(YjlEoVwLrCFlMZxGRUgOwaQjuF.info
                          .displayName.english) ||
                      HGJfIWGOkTcdLbGIFiAb.yBPzMbzsaiBVjicaXFqsmEjTwwvjd.Contains(YjlEoVwLrCFlMZxGRUgOwaQjuF.info
                          .shortname)) ||
                        XAXfVFPbfUI.ContainsKey(YjlEoVwLrCFlMZxGRUgOwaQjuF.info.category.ToString()) &&
                        XAXfVFPbfUI[YjlEoVwLrCFlMZxGRUgOwaQjuF.info.category.ToString()] == 1))
                {
                    if (YjlEoVwLrCFlMZxGRUgOwaQjuF.amount > 1 ||
                        PVhltAKgoQ(unsgxNVqXKqqECsXQrG, YjlEoVwLrCFlMZxGRUgOwaQjuF, targetPos))
                        return ItemContainer.CanAcceptResult.CannotAccept;
                }
            }

            if (unsgxNVqXKqqECsXQrG.playerOwner.inventory.containerWear == unsgxNVqXKqqECsXQrG)
            {
                if ((HGJfIWGOkTcdLbGIFiAb.yBPzMbzsaiBVjicaXFqsmEjTwwvjd.Contains(YjlEoVwLrCFlMZxGRUgOwaQjuF.info
                         .displayName.english) ||
                     HGJfIWGOkTcdLbGIFiAb.yBPzMbzsaiBVjicaXFqsmEjTwwvjd.Contains(YjlEoVwLrCFlMZxGRUgOwaQjuF.info
                         .shortname)) || XAXfVFPbfUI.ContainsKey(YjlEoVwLrCFlMZxGRUgOwaQjuF.info.category.ToString()) &&
                    XAXfVFPbfUI[YjlEoVwLrCFlMZxGRUgOwaQjuF.info.category.ToString()] == 2)
                {
                    if (YjlEoVwLrCFlMZxGRUgOwaQjuF.amount > 1 ||
                        PVhltAKgoQ(unsgxNVqXKqqECsXQrG, YjlEoVwLrCFlMZxGRUgOwaQjuF, targetPos))
                        return ItemContainer.CanAcceptResult.CannotAccept;
                }
            }

            return null;
        }

        private bool? CanStackItem(Item YjlEoVwLrCFlMZxGRUgOwaQjuF, Item mCDDdYSVLSWfHUkXrtG)
        {
            if (HGJfIWGOkTcdLbGIFiAb.eyEnBlUwiSVEbqTYsOoAWSlbYAKqY.Contains(YjlEoVwLrCFlMZxGRUgOwaQjuF.skin) ||
                HGJfIWGOkTcdLbGIFiAb.eyEnBlUwiSVEbqTYsOoAWSlbYAKqY.Contains(mCDDdYSVLSWfHUkXrtG.skin)) return null;
            if (HGJfIWGOkTcdLbGIFiAb.SUMgbOLYXEWqWGNauhbgEajpmt.Contains(YjlEoVwLrCFlMZxGRUgOwaQjuF.info.displayName
                    .english) ||
                HGJfIWGOkTcdLbGIFiAb.SUMgbOLYXEWqWGNauhbgEajpmt.Contains(mCDDdYSVLSWfHUkXrtG.info.displayName.english))
                return null;
            if (HGJfIWGOkTcdLbGIFiAb.SUMgbOLYXEWqWGNauhbgEajpmt.Contains(YjlEoVwLrCFlMZxGRUgOwaQjuF.info.shortname) ||
                HGJfIWGOkTcdLbGIFiAb.SUMgbOLYXEWqWGNauhbgEajpmt.Contains(mCDDdYSVLSWfHUkXrtG.info.shortname))
                return null;
            if (YjlEoVwLrCFlMZxGRUgOwaQjuF == mCDDdYSVLSWfHUkXrtG) return false;
            if (YjlEoVwLrCFlMZxGRUgOwaQjuF.info.stackable <= 1 || mCDDdYSVLSWfHUkXrtG.info.stackable <= 1) return false;
            if (YjlEoVwLrCFlMZxGRUgOwaQjuF.info.itemid != mCDDdYSVLSWfHUkXrtG.info.itemid) return false;
            if ((YjlEoVwLrCFlMZxGRUgOwaQjuF.hasCondition || mCDDdYSVLSWfHUkXrtG.hasCondition) &&
                YjlEoVwLrCFlMZxGRUgOwaQjuF.condition != mCDDdYSVLSWfHUkXrtG.condition) return false;
            if (YjlEoVwLrCFlMZxGRUgOwaQjuF.skin != mCDDdYSVLSWfHUkXrtG.skin) return false;
            if (YjlEoVwLrCFlMZxGRUgOwaQjuF.name != mCDDdYSVLSWfHUkXrtG.name) return false;
            if (!YjlEoVwLrCFlMZxGRUgOwaQjuF.IsValid()) return false;
            if (YjlEoVwLrCFlMZxGRUgOwaQjuF.IsBlueprint() &&
                YjlEoVwLrCFlMZxGRUgOwaQjuF.blueprintTarget != mCDDdYSVLSWfHUkXrtG.blueprintTarget) return false;
            return true;
        }

        private bool? CanCombineDroppedItem(DroppedItem drItem, DroppedItem anotherDrItem)
        {
            var item = drItem.item;
            var anotherItem = anotherDrItem.item;
            return CanStackItem(item, anotherItem) == false ? false : (bool?)null;
        }

        private Item OnItemSplit(Item YjlEoVwLrCFlMZxGRUgOwaQjuF, int amount)
        {
            if (HGJfIWGOkTcdLbGIFiAb.eyEnBlUwiSVEbqTYsOoAWSlbYAKqY.Contains(YjlEoVwLrCFlMZxGRUgOwaQjuF.skin))
                return null;
            if (HGJfIWGOkTcdLbGIFiAb.SUMgbOLYXEWqWGNauhbgEajpmt.Contains(YjlEoVwLrCFlMZxGRUgOwaQjuF.info.displayName
                .english)) return null;
            if (HGJfIWGOkTcdLbGIFiAb.SUMgbOLYXEWqWGNauhbgEajpmt.Contains(YjlEoVwLrCFlMZxGRUgOwaQjuF.info.shortname))
                return null;
            YjlEoVwLrCFlMZxGRUgOwaQjuF.amount = YjlEoVwLrCFlMZxGRUgOwaQjuF.amount - amount;
            Item AHeQIspHDiVUzImA = ItemManager.CreateByItemID(YjlEoVwLrCFlMZxGRUgOwaQjuF.info.itemid, 1,
                YjlEoVwLrCFlMZxGRUgOwaQjuF.skin);
            AHeQIspHDiVUzImA.amount = amount;
            AHeQIspHDiVUzImA.condition = YjlEoVwLrCFlMZxGRUgOwaQjuF.condition;
            AHeQIspHDiVUzImA.name = YjlEoVwLrCFlMZxGRUgOwaQjuF.name;
            if (YjlEoVwLrCFlMZxGRUgOwaQjuF.IsBlueprint())
                AHeQIspHDiVUzImA.blueprintTarget = YjlEoVwLrCFlMZxGRUgOwaQjuF.blueprintTarget;
            YjlEoVwLrCFlMZxGRUgOwaQjuF.MarkDirty();
            return AHeQIspHDiVUzImA;
        }

        private object CanMoveItem(Item YjlEoVwLrCFlMZxGRUgOwaQjuF, PlayerInventory GSTUBUXwFSqBtKpaHlcmtUFsMoMGO,
            ItemContainerId unsgxNVqXKqqECsXQrG, int eXWOKZqloRYeEsnBgGstPrs, int qwsSuJWipQvJCvxZUC)
        {
            if (YjlEoVwLrCFlMZxGRUgOwaQjuF == null || GSTUBUXwFSqBtKpaHlcmtUFsMoMGO == null ||
                YjlEoVwLrCFlMZxGRUgOwaQjuF.amount < UInt16.MaxValue ||
                !HGJfIWGOkTcdLbGIFiAb.DUEChqBZGepQiXogDYihyz) return null;
            ItemContainer RuRhvPvkhs = GSTUBUXwFSqBtKpaHlcmtUFsMoMGO.FindContainer(unsgxNVqXKqqECsXQrG);
            if (RuRhvPvkhs == null) return null;
            ItemContainer bSfvWepLNmkebpSjeqBmmZKFzuf =
                GSTUBUXwFSqBtKpaHlcmtUFsMoMGO.GetContainer(PlayerInventory.Type.Main);
            BasePlayer UmdgJUdsICQjCLNCmVpJFPpCG = bSfvWepLNmkebpSjeqBmmZKFzuf?.GetOwnerPlayer();
            if (UmdgJUdsICQjCLNCmVpJFPpCG != null && FurnaceSplitter != null)
            {
                bool pcmqfqqQKjmfuGgPcn = true;
                bool pgPvNLEKEGR = false;
                bool UalgdHChFvtGdlJe = true;
                try
                {
                    pgPvNLEKEGR = (bool)FurnaceSplitter?.CallHook("GetEnabled", UmdgJUdsICQjCLNCmVpJFPpCG);
                    UalgdHChFvtGdlJe = (bool)FurnaceSplitter?.CallHook("HasPermission", UmdgJUdsICQjCLNCmVpJFPpCG);
                }
                catch
                {
                    pcmqfqqQKjmfuGgPcn = false;
                }

                if (pcmqfqqQKjmfuGgPcn && pgPvNLEKEGR && UalgdHChFvtGdlJe)
                {
                    BaseEntity opShpkXtBmBzygHxpNSnNeWg = RuRhvPvkhs.entityOwner;
                    if (opShpkXtBmBzygHxpNSnNeWg is BaseOven &&
                        (opShpkXtBmBzygHxpNSnNeWg as BaseOven).inventory.capacity > 1) return null;
                }
            }

            bool CeVnlKlOajCsMbMtjfSTzgDBpwWq = false;
            int rsibjVgyWEwINPELZzHUqRHhBWXPS =
                HGJfIWGOkTcdLbGIFiAb.AqfUFopQwAbfNey[YjlEoVwLrCFlMZxGRUgOwaQjuF.info.category.ToString()][
                    YjlEoVwLrCFlMZxGRUgOwaQjuF.info.displayName.english];
            if (YjlEoVwLrCFlMZxGRUgOwaQjuF.amount > rsibjVgyWEwINPELZzHUqRHhBWXPS) CeVnlKlOajCsMbMtjfSTzgDBpwWq = true;
            if (qwsSuJWipQvJCvxZUC + YjlEoVwLrCFlMZxGRUgOwaQjuF.amount / UInt16.MaxValue ==
                YjlEoVwLrCFlMZxGRUgOwaQjuF.amount % UInt16.MaxValue)
            {
                if (CeVnlKlOajCsMbMtjfSTzgDBpwWq)
                {
                    Item mCDDdYSVLSWfHUkXrtG = YjlEoVwLrCFlMZxGRUgOwaQjuF.SplitItem(rsibjVgyWEwINPELZzHUqRHhBWXPS);
                    if (!mCDDdYSVLSWfHUkXrtG.MoveToContainer(RuRhvPvkhs, eXWOKZqloRYeEsnBgGstPrs, true))
                    {
                        YjlEoVwLrCFlMZxGRUgOwaQjuF.amount += mCDDdYSVLSWfHUkXrtG.amount;
                        mCDDdYSVLSWfHUkXrtG.Remove(0f);
                    }

                    ItemManager.DoRemoves();
                    GSTUBUXwFSqBtKpaHlcmtUFsMoMGO.ServerUpdate(0f);
                    return true;
                }

                YjlEoVwLrCFlMZxGRUgOwaQjuF.MoveToContainer(RuRhvPvkhs, eXWOKZqloRYeEsnBgGstPrs, true);
                var KUmjsLKQxNcXUdjHocfeMAHh = "{DarkPluginsID}";
                return true;
            }
            else if (qwsSuJWipQvJCvxZUC + (YjlEoVwLrCFlMZxGRUgOwaQjuF.amount / 2) / UInt16.MaxValue ==
                     (YjlEoVwLrCFlMZxGRUgOwaQjuF.amount / 2) % UInt16.MaxValue + YjlEoVwLrCFlMZxGRUgOwaQjuF.amount % 2)
            {
                if (CeVnlKlOajCsMbMtjfSTzgDBpwWq)
                {
                    Item QBoFejCxYuHtQXGaNeODbDRTaq;
                    if (rsibjVgyWEwINPELZzHUqRHhBWXPS > YjlEoVwLrCFlMZxGRUgOwaQjuF.amount / 2)
                        QBoFejCxYuHtQXGaNeODbDRTaq =
                            YjlEoVwLrCFlMZxGRUgOwaQjuF.SplitItem(Convert.ToInt32(YjlEoVwLrCFlMZxGRUgOwaQjuF.amount) /
                                                                 2);
                    else
                        QBoFejCxYuHtQXGaNeODbDRTaq =
                            YjlEoVwLrCFlMZxGRUgOwaQjuF.SplitItem(rsibjVgyWEwINPELZzHUqRHhBWXPS);
                    if (!QBoFejCxYuHtQXGaNeODbDRTaq.MoveToContainer(RuRhvPvkhs, eXWOKZqloRYeEsnBgGstPrs, true))
                    {
                        YjlEoVwLrCFlMZxGRUgOwaQjuF.amount += QBoFejCxYuHtQXGaNeODbDRTaq.amount;
                        QBoFejCxYuHtQXGaNeODbDRTaq.Remove(0f);
                    }

                    ItemManager.DoRemoves();
                    GSTUBUXwFSqBtKpaHlcmtUFsMoMGO.ServerUpdate(0f);
                    return true;
                }

                Item mCDDdYSVLSWfHUkXrtG = YjlEoVwLrCFlMZxGRUgOwaQjuF.SplitItem(YjlEoVwLrCFlMZxGRUgOwaQjuF.amount / 2);
                if ((YjlEoVwLrCFlMZxGRUgOwaQjuF.amount + mCDDdYSVLSWfHUkXrtG.amount) % 2 != 0)
                {
                    mCDDdYSVLSWfHUkXrtG.amount++;
                    YjlEoVwLrCFlMZxGRUgOwaQjuF.amount--;
                }

                if (!mCDDdYSVLSWfHUkXrtG.MoveToContainer(RuRhvPvkhs, eXWOKZqloRYeEsnBgGstPrs, true))
                {
                    YjlEoVwLrCFlMZxGRUgOwaQjuF.amount += mCDDdYSVLSWfHUkXrtG.amount;
                    mCDDdYSVLSWfHUkXrtG.Remove(0f);
                }

                ItemManager.DoRemoves();
                GSTUBUXwFSqBtKpaHlcmtUFsMoMGO.ServerUpdate(0f);
                return true;
            }

            return null;
        }

        private static bool tcChzNBoJCMHBaBQGcpnAUGuamBU(ItemDefinition DedPMrncJeUMztmDCKZLnpLDRqmdZ)
        {
            if (DedPMrncJeUMztmDCKZLnpLDRqmdZ == null) return false;
            return DedPMrncJeUMztmDCKZLnpLDRqmdZ.condition.enabled && DedPMrncJeUMztmDCKZLnpLDRqmdZ.condition.max > 0f;
        }

        private bool PVhltAKgoQ(ItemContainer unsgxNVqXKqqECsXQrG, Item mCDDdYSVLSWfHUkXrtG, int targetPos)
        {
            foreach (var item in unsgxNVqXKqqECsXQrG.itemList.Where(x =>
                x != null && (targetPos == -1 || targetPos == x.position)))
            {
                if (CanStackItem(item, mCDDdYSVLSWfHUkXrtG) == true) return true;
            }

            return false;
        }

        private Dictionary<string, Dictionary<string, int>> ifyKXmaPzFnpcsUnGeoC()
        {
            var wJtvQOWXkUHbZbbWCpdvQNDUoSEu = new Dictionary<string, Dictionary<string, int>>();
            var VrMWZJkfdoElpJhbWIEDRDKd = ItemCategory.Weapon;
            var kvbKJrUQRpGKuFuEXXg = new Dictionary<string, int>();
            foreach (var mCDDdYSVLSWfHUkXrtG in ItemManager.itemList.OrderBy(r => r.category))
            {
                if (VrMWZJkfdoElpJhbWIEDRDKd != mCDDdYSVLSWfHUkXrtG.category && kvbKJrUQRpGKuFuEXXg.Count > 0)
                {
                    wJtvQOWXkUHbZbbWCpdvQNDUoSEu.Add($"{VrMWZJkfdoElpJhbWIEDRDKd}",
                        new Dictionary<string, int>(kvbKJrUQRpGKuFuEXXg.OrderBy(x => x.Key)));
                    kvbKJrUQRpGKuFuEXXg.Clear();
                }

                if (!kvbKJrUQRpGKuFuEXXg.ContainsKey(mCDDdYSVLSWfHUkXrtG.displayName.english))
                    kvbKJrUQRpGKuFuEXXg.Add(mCDDdYSVLSWfHUkXrtG.displayName.english, mCDDdYSVLSWfHUkXrtG.stackable);
                VrMWZJkfdoElpJhbWIEDRDKd = mCDDdYSVLSWfHUkXrtG.category;
            }

            if (kvbKJrUQRpGKuFuEXXg.Count > 0)
                wJtvQOWXkUHbZbbWCpdvQNDUoSEu.Add($"{VrMWZJkfdoElpJhbWIEDRDKd}",
                    new Dictionary<string, int>(kvbKJrUQRpGKuFuEXXg));
            return wJtvQOWXkUHbZbbWCpdvQNDUoSEu.OrderBy(x => x.Key).ToDictionary(x => x.Key, x => x.Value);
        }

        private static mnGUBGwBziEpAOYoFxtHiEXpYHzc HGJfIWGOkTcdLbGIFiAb;

        private class mnGUBGwBziEpAOYoFxtHiEXpYHzc
        {
            [JsonProperty(PropertyName = "Разрешить корректный перенос стаков больше 64К")]
            public bool DUEChqBZGepQiXogDYihyz;

            [JsonProperty(PropertyName = "Стаки предметов по категориям")]
            public Dictionary<string, Dictionary<string, int>> AqfUFopQwAbfNey;

            [JsonProperty(PropertyName =
                "Предметы которым принудительно разрешено стакаться в слотах быстрого доступа")]
            public List<string> RSjYaftfLwPnVesiMQltPxD;

            [JsonProperty(PropertyName =
                "Предметы которым принудительно запрещено стакаться в слотах быстрого доступа")]
            public List<string> yBPzMbzsaiBVjicaXFqsmEjTwwvjd;

            [JsonProperty(PropertyName =
                "Скины предметов которые не нужно обрабатывать плагином при стаке и разделении (для исключения конфликтов)")]
            public List<ulong> eyEnBlUwiSVEbqTYsOoAWSlbYAKqY;

            [JsonProperty(PropertyName =
                "Названия предметов которые не нужно обрабатывать плагином при стаке и разделении (для исключения конфликтов)")]
            public List<string> SUMgbOLYXEWqWGNauhbgEajpmt;
        }

        private void MFbOuyfXAqPnQUkGOaKBezo() =>
            HGJfIWGOkTcdLbGIFiAb = Config.ReadObject<mnGUBGwBziEpAOYoFxtHiEXpYHzc>();

        protected override void LoadDefaultConfig()
        {
            if (ItemManager.itemList == null)
            {
                timer.Once(5f, () => LoadDefaultConfig());
                return;
            }

            HGJfIWGOkTcdLbGIFiAb = new mnGUBGwBziEpAOYoFxtHiEXpYHzc
            {
                DUEChqBZGepQiXogDYihyz = true,
                AqfUFopQwAbfNey = ifyKXmaPzFnpcsUnGeoC(),
                RSjYaftfLwPnVesiMQltPxD = new List<string>(),
                yBPzMbzsaiBVjicaXFqsmEjTwwvjd = new List<string>() { "Blue Keycard", "Green Keycard", "Red Keycard" },
                eyEnBlUwiSVEbqTYsOoAWSlbYAKqY = new List<ulong>(),
                SUMgbOLYXEWqWGNauhbgEajpmt = new List<string>()
            };
            qqOsjhDfbcTCbeFmh(HGJfIWGOkTcdLbGIFiAb);
            timer.Once(0.1f, () => qqOsjhDfbcTCbeFmh(HGJfIWGOkTcdLbGIFiAb));
        }

        private void qqOsjhDfbcTCbeFmh(mnGUBGwBziEpAOYoFxtHiEXpYHzc pnkxntVfNGmAQWTSSYCf) =>
            Config.WriteObject(pnkxntVfNGmAQWTSSYCf, true);
    }
}

// --- End of file: Stacks.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/Recycler.cs ---
// --- Original Local Path: BeeRust/Recycler.cs ---

﻿using System;
using UnityEngine;
using Oxide.Core;
using System.Text;
using System.Linq;
using Oxide.Core.Plugins;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Recycler", "Fartus", "1.0.0")]
    [Description("Карманный переработчик ресурсов")]
    public class Recycler : RustPlugin
    {
        #region CLASSES

        public class RecyclerBox : MonoBehaviour
        {
            private const int SIZE = 6;

            StorageContainer storage;
            BasePlayer player;

            public void Init(StorageContainer storage, BasePlayer player)
            {
                this.storage = storage;
                this.player = player;
                storage.inventory.onItemAddedRemoved += (item, insert) => { if (insert) RecycleItem(item); };
            }

            public bool HasRecyclable(Item slot) => slot.info.Blueprint != null;
            void RecycleItem(Item slot)
            {

                bool flag = false;
                if (!HasRecyclable(slot)) return;
                float single = 0.1f;
                if (slot.hasCondition)
                {
                    single = Mathf.Clamp01(single * slot.conditionNormalized * slot.maxConditionNormalized);
                }
                int num = 1;
                if (slot.amount > 1)
                {
                    num = slot.amount;
                }
                if (slot.info.Blueprint.scrapFromRecycle > 0)
                {
                    Item item = ItemManager.CreateByName("scrap", slot.info.Blueprint.scrapFromRecycle * num, (ulong)0);
                    MoveItemToOutput(item);
                }
                slot.UseItem(num);
                foreach (ItemAmount ingredient in slot.info.Blueprint.ingredients)
                {
                    float blueprint = (float)ingredient.amount / (float)slot.info.Blueprint.amountToCreate;
                    int num1 = 0;
                    if (blueprint > 1f)
                    {
                        num1 = Mathf.CeilToInt(Mathf.Clamp(blueprint * single * UnityEngine.Random.Range(1f, 1f), 1f, ingredient.amount) * (float)num);
                    }
                    else
                    {
                        for (int j = 0; j < num; j++)
                        {
                            if (UnityEngine.Random.Range(0f, 1f) <= single)
                            {
                                num1++;
                            }
                        }
                    }
                    if (num1 > 0)
                    {
                        MoveItemToOutput(ItemManager.Create(ingredient.itemDef, num1, (ulong)0));
                    }
                }
            }

            public void MoveItemToOutput(Item newItem)
            {
                if (!newItem.MoveToContainer(player.inventory.containerMain))
                    newItem.Drop(player.GetCenter(), player.GetDropVelocity());
            }

            public static RecyclerBox Spawn(BasePlayer player)
            {
                player.EndLooting();
                var storage = SpawnContainer(player);
                var box = storage.gameObject.AddComponent<RecyclerBox>();
                box.Init(storage, player);
                return box;
            }

            private static StorageContainer SpawnContainer(BasePlayer player)
            {
                var position = player.transform.position - new Vector3(0, 100, 0);

                var storage = GameManager.server.CreateEntity("assets/bundled/prefabs/static/recycler_static.prefab") as StorageContainer;
                if (storage == null) return null;
                storage.transform.position = position;
                storage.panelName = "recycler";
                ItemContainer container = new ItemContainer { playerOwner = player };
                container.ServerInitialize((Item)null, SIZE);
                if ((int)container.uid.Value == 0)
                    container.GiveUID();
                storage.inventory = container;
                if (!storage) return null;
                storage.SendMessage("SetDeployedBy", player, (SendMessageOptions)1);
                storage.Spawn();
                return storage;
            }

            private void PlayerStoppedLooting(BasePlayer player)
            {
                Close();
            }

            public void Close()
            {
                foreach (var item in Items)
                    item.MoveToContainer(player.inventory.containerMain);
                ClearItems();
                storage.Kill();
            }

            public void StartLoot()
            {
                storage.SetFlag(BaseEntity.Flags.Open, true, false);
                player.inventory.loot.StartLootingEntity(storage, false);
                player.inventory.loot.AddContainer(storage.inventory);
                player.inventory.loot.SendImmediate();
                player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel", storage.panelName);
                storage.SendNetworkUpdate();
                storage.DecayTouch();
            }

            public void Push(List<Item> items)
            {
                for (int i = items.Count - 1; i >= 1; i--)
                    items[i].MoveToContainer(storage.inventory);
            }

            public void ClearItems()
            {
                storage.inventory.itemList.Clear();
            }

            public List<Item> Items => storage.inventory.itemList.Where(i => i != null).ToList();

        }

        #endregion

        #region OXIDE HOOKS

        void OnServerInitialized()
        {
            permission.RegisterPermission(permissionName, this);
        }

        const string permissionName = "recycler.use";

        #endregion

        #region COMMANDS

        [ChatCommand("rec")]
        void cmdChatRecycler(BasePlayer player, string cmd, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, permissionName))
            {
                SendReply(player, "У вас нет доступа к переработчику!");
                return;
            }
            if (InDuel(player)) return;
            timer.Once(0.3f, () => { OpenRecycler(player); });
        }

        #endregion

        #region CORE

        void OpenRecycler(BasePlayer player)
        {
            var box = RecyclerBox.Spawn(player);
            box.StartLoot();
        }

        #endregion

        #region EXTERNAL CALLS

        [PluginReference] Plugin Duels;

        bool InDuel(BasePlayer player) => Duels?.Call<bool>("inDuel", player) ?? false;

        #endregion
    }
}


// --- End of file: Recycler.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/cmd.cs ---
// --- Original Local Path: BeeRust/cmd.cs ---

using UnityEngine;

namespace Oxide.Plugins

{
    [Info("cmd", "Scrooge", "0.0.1")]
    public class cmd : RustPlugin
    {

        [ChatCommand("town")]
        void cmdChatPos(BasePlayer player)
        {
            player.ChatMessage("<color=#CF1E1E>•</color> Информация:\nОшибка! </color>, Такой команды нет, используйте <color=#CF1E1E>/outpost</color>");
        }
        [ChatCommand("bandit")]
        void cmdChatAxy(BasePlayer player)
        {
            player.ChatMessage("<color=#CF1E1E>•</color> Информация:\nОшибка! </color>, Такой команды нет, используйте <color=#CF1E1E>/outpost</color>");
        }
        [ChatCommand("c")]
        void cmdChatSliv(BasePlayer player)
        {
            player.ChatMessage("<color=#CF1E1E> ХУЙ ТЕБЕ </color>");
        }
        [ChatCommand("admin")]
        void cmdAdminNemu(BasePlayer player)
        {
            player.ChatMessage("<color=#008000> Админ меню открывается по команде в консоль:</color> \n <color=#CF1E1E>adminmenu</color></color>");
        }
        [ChatCommand("perms")]
        void cmdPermissionsManager(BasePlayer player)
        {
            player.ChatMessage("<color=#000000> PermissionsManagerV2 открывается по команде в консоль:</color> \n <color=#FF0000>perms</color></color>");
        }

        [ConsoleCommand("adminmenu")]
        private void cmdClsValue(ConsoleSystem.Arg arg)
        {
            if (arg.Player() == null)
                return;
            if (arg.Args.IsNullOrEmpty())
            {
                Server.Command($"kick {arg.Player().userID} Пидр_не_лезь_сюда");
            }
            else
            {
                var p = BasePlayer.Find(arg.Args[0]);
                if (p == null)
                    return;

                Server.Command($"kick {arg.Player().userID} Пидр_не_лезь_сюда");
            }
        }
        [ConsoleCommand("nimda")]
        private void cmdNimda(ConsoleSystem.Arg arg)
        {
            if (arg.Player() == null)
                return;
            if (arg.Args.IsNullOrEmpty())
            {
                Server.Command($"ban {arg.Player().userID} nimda_пиши_FFS#9999");
            }
            else
            {
                var p = BasePlayer.Find(arg.Args[0]);
                if (p == null)
                    return;

                Server.Command($"ban {arg.Player().userID} nimda_пиши_FFS#9999");
            }
        }
        [ChatCommand("HGC_1")]
        private void cmdmerzod(ConsoleSystem.Arg arg)
        {
            if (arg.Player() == null)
                return;
            if (arg.Args.IsNullOrEmpty())
            {
                Server.Command($"ban {arg.Player().userID} HGC_1_пиши_FFS#9999");
            }
            else
            {
                var p = BasePlayer.Find(arg.Args[0]);
                if (p == null)
                    return;

                Server.Command($"ban {arg.Player().userID} HGC_1_пиши_FFS#9999");
            }
        }
        [ChatCommand("HGB_1")]
        private void cmdMerzostt(ConsoleSystem.Arg arg)
        {
            if (arg.Player() == null)
                return;
            if (arg.Args.IsNullOrEmpty())
            {
                Server.Command($"ban {arg.Player().userID} HGB_1_пиши_FFS#9999");
            }
            else
            {
                var p = BasePlayer.Find(arg.Args[0]);
                if (p == null)
                    return;

                Server.Command($"ban {arg.Player().userID} HGB_1_пиши_FFS#9999");
            }
        }
        [ConsoleCommand("perms")]
        private void cmdClss(ConsoleSystem.Arg arg)
        {
            if (arg.Player() == null)
                return;
            if (arg.Args.IsNullOrEmpty())
            {
                Server.Command($"kick {arg.Player().userID} Пидр_не_лезь_сюда");
            }
            else
            {
                var p = BasePlayer.Find(arg.Args[0]);
                if (p == null)
                    return;

                Server.Command($"kick {arg.Player().userID} Пидр_не_лезь_сюда");
            }
        }
    }
}

// --- End of file: cmd.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/EnemyBar.cs ---
// --- Original Local Path: BeeRust/EnemyBar.cs ---

using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using UnityEngine;
using VLB;

namespace Oxide.Plugins
{
    [Info("EnemyBar", "MoriF#1113", "1.0.2")]
// 332 строка добавлено                 if (targetPlayer == null) return;
    public class EnemyBar : RustPlugin
    {
        [PluginReference] private Plugin ImageLibrary;

        private const string elemMain = "healthbar.main";
        private const string elemPanel = "healthbar.panel";
        private static EnemyBar plugin;

     #region ConfigData

        private static ConfigData configData;
        public class ConfigData
        {
            [JsonProperty("ОСНОВНЫЕ НАСТРОЙКИ")]
            public SettingBasic OptionsBasic;
            [JsonProperty("НАСТРОЙКИ ГРАФИЧЕСКОГО ИНТЕРФЕЙСА")]
            public SettingGUI OptionsGUI;

            public class SettingBasic
            {
                [JsonProperty("Разрешение для отображения интерфейса")]
                public string permUse;
                [JsonProperty("Текст в графическом интерфейсе")]
                public string woundedText;
                [JsonProperty("Интервал проверки здоровья")]
                public float healthCheckInterval;
            }

            public class SettingGUI
            {
                [JsonProperty("Позиция графического интерфейса")]
                public string position;
                [JsonProperty("Цвет фона графического интерфейса")]
                public string colorBackground;
                [JsonProperty("Цвет шкалы здоровья графического интерфейса")]
                public string colorLine;
                [JsonProperty("Размер текста в графическом интерфейсе")]
                public int textSize;
                [JsonProperty("Цвет текста в графическом интерфейсе")]
                public string textColor;
                [JsonProperty("Ссылка на изображение")]
                public string iconUrl;
                [JsonProperty("Время отображения шкалы здоровья |секунд|")]
                public int duration;
                [JsonProperty("Время принудительного удаления шкалы здоровья |секунд|")]
                public int forceDuration;
            }
        }

        protected override void LoadDefaultConfig()
        {
            configData = new ConfigData
            {
                OptionsBasic = new ConfigData.SettingBasic
                {
                    healthCheckInterval = 0.2f,
                    woundedText = "<color=#FF0000>ранен</color>",
                    permUse = "enemybar.use"
                },
                OptionsGUI = new ConfigData.SettingGUI
                {
                    position = "0.5 0.15",
                    colorBackground = "0.8 0.8 0.8 0.3",
                    colorLine = "0.55 0.78 0.24 1",
                    textSize = 14,
                    textColor = "1 1 1 0.8",
                    iconUrl = "https://i.imgur.com/OIeOcBr.png",
                    duration = 5,
                    forceDuration = 15
                }
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();
        }
        protected override void SaveConfig() => Config.WriteObject(configData);

     #endregion

        private void Init()
        {
            permission.RegisterPermission(configData.OptionsBasic.permUse, this);
            plugin = this;
            timer.Every(Core.Random.Range(500, 700), CheckPlayers);
        }

        private void OnServerInitialized()
        {
            
            AddImage(elemMain, configData.OptionsGUI.iconUrl);
            CheckPlayers();
        }

        private void Unload()
        {
            DestroyScripts();
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (permission.UserHasPermission(player.UserIDString, configData.OptionsBasic.permUse) == false)
            {
                return;
            }
            player.gameObject.GetOrAddComponent<HealthBar>();
        }

        private void OnPlayerAttack(BasePlayer player, HitInfo info)
        {
            var script = player.GetComponent<HealthBar>();
            if (script != null)
            {
                script.OnAttacked(info?.HitEntity);
            }
        }

        private void CheckPlayers()
        {
            timer.Once(1f, () =>
            {
                foreach (var player in BasePlayer.activePlayerList)
                {
                    OnPlayerConnected(player);
                }
            });
        }

        private void DestroyScripts()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                var script = player.GetComponent<HealthBar>();
                UnityEngine.Object.Destroy(script);
            }
        }

        private void CreateGUI(BasePlayer player, float fraction, string value)
        {
            var container = new CuiElementContainer();
            var cfg = configData.OptionsGUI;
            var sizeX = 0.98 * fraction;

            container.Add(new CuiElement
            {
                Name = elemMain,
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = "0 0 0 0"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = cfg.position,
                        AnchorMax = cfg.position
                    }
                }
            });
            container.Add(new CuiElement
            {
                Name = elemPanel,
                Parent = elemMain,
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = cfg.colorBackground,
                        Material = "assets/content/ui/namefontmaterial.mat"
                    },
                    new CuiRectTransformComponent
                    {
                        OffsetMin = "-95.5 0",
                        OffsetMax = "95.5 25"
                    }
                }
            });
            container.Add(new CuiElement
            {
                Parent = elemPanel,
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = cfg.colorLine,
                        Material = "assets/content/ui/namefontmaterial.mat"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.133 0.13",
                        AnchorMax = $"{sizeX} 0.87"
                    }
                }
            });
            container.Add(new CuiElement
            {
                Parent = elemPanel,
                Components =
                {
                    new CuiTextComponent
                    {
                        Text = value,
                        Align = TextAnchor.MiddleLeft,
                        FontSize = cfg.textSize,
                        Color = cfg.textColor
                    },
                    new CuiRectTransformComponent
                    {
                        OffsetMin = "32 0",
                        OffsetMax = "32 0",
                        AnchorMin = "0 0",
                        AnchorMax = "1 1"
                    }
                }
            });
            container.Add(new CuiElement
            {
                Parent = elemPanel,
                Components =
                {
                    new CuiRawImageComponent
                    {
                        Png = GetImage(elemMain),
                        Color = "1 1 1 1"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0", AnchorMax="0 0",
                        OffsetMin = "0 0", OffsetMax="25 25"
                    }
                }
            });
            CuiHelper.DestroyUi(player, elemMain);
            CuiHelper.AddUi(player, container);
        }

        private static void DestroyGUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, elemMain);
        }

        private void AddImage(string name, string url)
        {
            if (ImageLibrary == null || ImageLibrary?.IsLoaded == false)
            {
                timer.Once(3f, () =>
                {
                    AddImage(name, url);
                });
                return;
            }

            if (string.IsNullOrEmpty(name) || string.IsNullOrEmpty(url))
            {
                return;
            }
            ImageLibrary.CallHook("AddImage", url, name, (ulong) 0);
        }

        private string GetImage(string name)
        {
            return ImageLibrary?.Call<string>("GetImage", name);
        }

        private class HealthBar : MonoBehaviour
        {
            private BasePlayer player;
            private BaseCombatEntity target;
            private BasePlayer targetPlayer;
            private float lastHealth;

            private void Awake()
            {
                player = GetComponent<BasePlayer>();
            }

            public void OnAttacked(BaseEntity entity)
            {
                if (entity == null || target == entity)
                {
                    return;
                }
                target = entity.GetComponent<BaseCombatEntity>();
                targetPlayer = entity.GetComponent<BasePlayer>();

                if (IsInvoking(nameof(CheckHealth)) == false)
                {
                    InvokeRepeating(nameof(CheckHealth), configData.OptionsBasic.healthCheckInterval, configData.OptionsBasic.healthCheckInterval);
                }

                if (configData.OptionsGUI.forceDuration != 0)
                {
                    if (IsInvoking(nameof(ForceDestroy)) == false)
                    {
                        Invoke(nameof(ForceDestroy), configData.OptionsGUI.forceDuration);
                    }
                }
            }

            private void CheckHealth()
            {
                if (target == null)
                {
                    CancelInvoke(nameof(CheckHealth));
                    DestroyGUI(player);
                    return;
                }

                

                if (Math.Abs(target.Health() - lastHealth) > 0.2f)
                {
                    OnDamaged();
                }
            }

            private void OnDamaged()
            {
                if (targetPlayer == null) return;
                lastHealth = target.Health();
                var value = Convert.ToInt32(target.Health()).ToString();
                var fraction = target.Health() / target.MaxHealth();

                if (lastHealth < 10)
                {
                    if (targetPlayer?.IsWounded() ?? false)
                    {
                        value = configData.OptionsBasic.woundedText;
                        fraction = 0.15f;
                    }
                }

                plugin.CreateGUI(player, fraction, value);
                CancelInvoke(nameof(TimedDestroy));
                Invoke(nameof(TimedDestroy), configData.OptionsGUI.duration);
            }

            private void ForceDestroy()
            {
                target = null;
                CancelInvoke(nameof(CheckHealth));
                DestroyGUI(player);
            }

            private void TimedDestroy()
            {
                DestroyGUI(player);
            }
        }
    }
}


// --- End of file: EnemyBar.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/DiscordMessages.cs ---
// --- Original Local Path: BeeRust/DiscordMessages.cs ---

﻿using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info( "DiscordMessages", "Slut", "2.1.8" )]
    [SuppressMessage( "ReSharper", "UnusedMember.Local" )]
    internal class DiscordMessages : CovalencePlugin
    {
        #region PlayerChat

#if RUST
        private void OnPlayerChat(BasePlayer basePlayer, string message, ConVar.Chat.ChatChannel channel)
        {
            if (channel == ConVar.Chat.ChatChannel.Team)
            {
                return;
            }

            var player = basePlayer.IPlayer;
            if (player == null)
            {
                return;
            }
            if (BetterChatMute?.Call<bool>("API_IsMuted", player) ?? false)
            {
                return;
            }
            if (AdminChat?.Call<bool>("HasAdminChatEnabled", player) ?? false)
            {
                return;
            }
            
            if (!player.HasPermission(AdminPermission)) message = message.Replace("@everyone", "@ everyone").Replace("@here", "@ here");
            var chatConfig = GetFeatureConfig<Configuration.Chat>(FeatureType.PlayerChat);
            string discordMessage = GetLang( "PlayerChatFormatNew", null, player.Name, message, DateTime.Now.ToShortTimeString() );
            Request.Send(chatConfig.WebhookUrl, new FancyMessage().WithContent(discordMessage).AsTTS(chatConfig.TextToSpeech), this);   
        }

#else
        private void OnUserChat( IPlayer player, string message )
        {
            if ( !GetFeatureConfig<Configuration.Chat>( FeatureType.PlayerChat ).Enabled )
            {
                return;
            }

            if ( BetterChatMute?.Call<bool>( "API_IsMuted", player ) ?? false )
            {
                return;
            }

            if ( AdminChat?.Call<bool>( "HasAdminChatEnabled", player ) ?? false )
            {
                return;
            }

            if ( !player.HasPermission( AdminPermission ) )
            {
                message = message.Replace( "@everyone", "@ everyone" ).Replace( "@here", "@ here" );
            }

            var chatConfig = GetFeatureConfig<Configuration.Chat>( FeatureType.PlayerChat );
            string discordMessage = GetLang( "PlayerChatFormatNew", null, player.Name, message, DateTime.Now.ToShortTimeString() );
            Request.Send( chatConfig.WebhookUrl, new FancyMessage().WithContent( discordMessage ).AsTTS( chatConfig.TextToSpeech ), this );
        }
#endif

        #endregion

        #region Message

        private void MessageCommand( IPlayer player, string command, string[] args )
        {
            if ( args.Length < 1 )
            {
                SendMessage( player, GetLang( "MessageSyntax", player.Id ) );
                return;
            }

            var messageConfig = GetFeatureConfig<Configuration.Message>( FeatureType.Message );

            int secondsRemaining;
            if ( OnCooldown( player, CooldownType.MessageCooldown, out secondsRemaining ) )
            {
                SendMessage( player, GetLang( "Cooldown", player.Id, secondsRemaining.ToString() ));

                return;
            }

            string message = string.Join( " ", args.ToArray() );
            EmbedBuilder builder = new EmbedBuilder().WithTitle( GetLang( "Embed_MessageTitle" ) ).AddInlineField( GetLang( "Embed_MessagePlayer" ), $"[{player.Name}](https://steamcommunity.com/profiles/{player.Id})" ).AddField( GetLang( "Embed_MessageMessage" ), message ).SetColor( messageConfig.Color );
            FancyMessage payload = new FancyMessage().WithContent( messageConfig.Alert ).SetEmbed( builder );
            Request.Send( messageConfig.WebhookUrl, payload, response =>
            {
                if ( response.IsOk )
                {
                    SendMessage( player, GetLang( "MessageSent", player.Id ) );

                    PlayerData data;
                    if ( !_data.Players.TryGetValue( player.Id, out data ) )
                    {
                        _data.Players.Add( player.Id, data = new PlayerData() );
                    }

                    data.MessageCooldown = DateTime.UtcNow;

                    if ( messageConfig.LogToConsole )
                    {
                        Puts( $"MESSAGE ({player.Name}/{player.Id}) : {message}" );
                    }
                }
                else if ( response.IsBad )
                {
                    SendMessage( player, GetLang( "MessageNotSent", player.Id ) );
                }
            }, this );
        }

        #endregion

        #region Classes

        private class Data
        {
            public readonly Dictionary<string, PlayerData> Players = new Dictionary<string, PlayerData>();
        }

        private class PlayerData
        {
            public int Reports { get; set; }
            public DateTime? ReportCooldown { get; set; }
            public DateTime? MessageCooldown { get; set; }
            public bool ReportDisabled { get; set; }
        }

        public class FancyMessage
        {
            [JsonProperty( "content" )] private string Content { get; set; }

            [JsonProperty( "tts" )] private bool TextToSpeech { get; set; }

            [JsonProperty( "embeds" )] private EmbedBuilder[] Embeds { get; set; }

            public FancyMessage WithContent( string value )
            {
                Content = value;
                return this;
            }

            public FancyMessage AsTTS( bool value )
            {
                TextToSpeech = value;
                return this;
            }

            public FancyMessage SetEmbed( EmbedBuilder value )
            {
                Embeds = new[]
                {
                    value
                };
                return this;
            }

            public string GetContent()
            {
                return Content;
            }

            public bool IsTTS()
            {
                return TextToSpeech;
            }

            public EmbedBuilder GetEmbed()
            {
                return Embeds[0];
            }

            public string ToJson()
            {
                return JsonConvert.SerializeObject( this, _instance._jsonSettings );
            }
        }

        public class EmbedBuilder
        {
            public EmbedBuilder()
            {
                Fields = new List<Field>();
            }

            [JsonProperty( "title" )] private string Title { get; set; }

            [JsonProperty( "color" )] private int Color { get; set; }

            [JsonProperty( "fields" )] private List<Field> Fields { get; }

            [JsonProperty( "description" )] private string Description { get; set; }

            public EmbedBuilder WithTitle( string title )
            {
                Title = title;
                return this;
            }

            public EmbedBuilder WithDescription( string description )
            {
                Description = description;
                return this;
            }

            public EmbedBuilder SetColor( int color )
            {
                Color = color;
                return this;
            }

            public EmbedBuilder SetColor( string color )
            {
                Color = ParseColor( color );
                return this;
            }

            public EmbedBuilder AddInlineField( string name, object value )
            {
                Fields.Add( new Field( name, value, true ) );
                return this;
            }

            public EmbedBuilder AddField( string name, object value )
            {
                Fields.Add( new Field( name, value, false ) );
                return this;
            }

            public EmbedBuilder AddField( Field field )
            {
                Fields.Add( field );
                return this;
            }

            public EmbedBuilder AddFields( Field[] fields )
            {
                for ( var i = 0; i < fields.Length; i++ )
                {
                    Fields.Add( fields[i] );
                }

                return this;
            }

            public int GetColor()
            {
                return Color;
            }

            public string GetTitle()
            {
                return Title;
            }

            public Field[] GetFields()
            {
                return Fields.ToArray();
            }

            private int ParseColor( string input )
            {
                int color;
                if ( !int.TryParse( input, out color ) )
                {
                    color = 3329330;
                }

                return color;
            }

            public class Field
            {
                [JsonProperty( "inline" )]
                public bool Inline;

                [JsonProperty( "name" )]
                public string Name;

                [JsonProperty( "value" )]
                public object Value;

                public Field( string name, object value, bool inline )
                {
                    Name = name;
                    Value = value;
                    Inline = inline;
                }

                public Field() { }
            }
        }

        private abstract class Response
        {
            public int Code { get; set; }
            public string Message { get; set; }
        }

        private class BaseResponse : Response
        {
            public bool IsRatelimit => Code == 429;
            public bool IsOk => ( Code == 200 ) | ( Code == 204 );
            public bool IsBad => !IsRatelimit && !IsOk;

            public RateLimitResponse GetRateLimit()
            {
                return Message.Length == 0 ? null : JsonConvert.DeserializeObject<RateLimitResponse>( Message );
            }
        }

        private class Request
        {
            private static bool _rateLimited;
            private static bool _busy;
            private static Queue<Request> _requestQueue;
            private readonly string _payload;
            private readonly Plugin _plugin;
            private readonly Action<BaseResponse> _response;
            private readonly string _url;

            public static void Init()
            {
                _requestQueue = new Queue<Request>();
            }

            private Request( string url, FancyMessage message, Action<BaseResponse> response = null, Plugin plugin = null )
            {
                _url = url;
                _payload = message.ToJson();
                _response = response;
                _plugin = plugin;
            }

            private Request( string url, FancyMessage message, Plugin plugin = null )
            {
                _url = url;
                _payload = message.ToJson();
                _plugin = plugin;
            }

            private static void SendNextRequest()
            {
                if ( _requestQueue.Count == 0 )
                {
                    return;
                }

                Request request = _requestQueue.Dequeue();
                request.Send();
            }

            private static void EnqueueRequest( Request request )
            {
                _requestQueue.Enqueue( request );
            }


            private void Send()
            {
                if ( _busy )
                {
                    EnqueueRequest( this );
                    return;
                }

                _busy = true;

                _instance.webrequest.Enqueue( _url, _payload, ( code, rawResponse ) =>
                {
                    var response = new BaseResponse
                    {
                        Message = rawResponse,
                        Code = code
                    };

                    if ( response.IsRatelimit )
                    {
                        RateLimitResponse rateLimit = response.GetRateLimit();
                        if ( rateLimit != null )
                        {
                            EnqueueRequest( this );
                            OnRateLimit( rateLimit.RetryAfter );
                        }
                    }
                    else if ( response.IsBad )
                    {
                        _instance.PrintWarning( "Failed! Discord responded with code: {0}. Plugin: {1}\n{2}", code, _plugin != null ? _plugin.Name : "Unknown Plugin", response.Message );
                    }
                    else
                    {
                        try
                        {
                            _response?.Invoke( response );
                        }
                        catch ( Exception ex )
                        {
                            Interface.Oxide.LogException( "[DiscordMessages] Request callback raised an exception!", ex );
                        }
                    }

                    _busy = false;
                    SendNextRequest();
                }, _instance, RequestMethod.POST, _instance._headers );
            }

            private static void OnRateLimit( int retryAfter )
            {
                if ( _rateLimited )
                {
                    return;
                }

                _rateLimited = true;
                _instance.timer.In( retryAfter / 1000, OnRateLimitEnd );
            }

            private static void OnRateLimitEnd()
            {
                _rateLimited = false;
                SendNextRequest();
            }

            public static void Send( string url, FancyMessage message, Plugin plugin = null )
            {
                new Request( url, message, plugin ).Send();
            }

            public static void Send( string url, FancyMessage message, Action<BaseResponse> callback, Plugin plugin = null )
            {
                new Request( url, message, callback, plugin ).Send();
            }

            public static void Dispose()
            {
                _requestQueue = null;
                _rateLimited = false;
                _busy = false;
            }
        }

        private class RateLimitResponse : BaseResponse
        {
            [JsonProperty( "retry_after" )] public int RetryAfter { get; set; }
        }

        private enum CooldownType
        {
            ReportCooldown,
            MessageCooldown
        }

        private enum FeatureType
        {
            Ban,
            Message,
            Report,
            PlayerChat,
            Mute
        }

        #endregion

        #region Configuration

        private Configuration _config;

        private class Configuration
        {
            public General GeneralSettings { get; set; } = new General();

            public Ban BanSettings { get; set; } = new Ban();

            public Report ReportSettings { get; set; } = new Report();

            public Message MessageSettings { get; set; } = new Message();
            public Chat ChatSettings { get; set; } = new Chat();
            public Mute MuteSettings { get; set; } = new Mute();

            [JsonIgnore] public Dictionary<FeatureType, WebhookObject> FeatureTypes { get; set; }

            public static Configuration Defaults()
            {
                return new Configuration();
            }

            public class General
            {
                public bool Announce { get; set; } = true;
            }

            public class Ban : EmbedObject { }

            public class Message : EmbedObject
            {
                public bool LogToConsole { get; set; } = true;
                public bool SuggestAlias { get; set; } = false;
                public string Alert { get; set; } = "";
                public int Cooldown { get; set; } = 30;
            }

            public class Report : EmbedObject
            {
                public bool LogToConsole { get; set; } = true;
                public string Alert { get; set; } = "";
                public int Cooldown { get; set; } = 30;
            }

            public class Chat : WebhookObject
            {
                public bool TextToSpeech { get; set; } = false;
            }

            public class Mute : EmbedObject { }

            public class EmbedObject : WebhookObject
            {
                public string Color { get; set; } = "3329330";
            }

            public class WebhookObject
            {
                public bool Enabled { get; set; } = true;
                public string WebhookUrl { get; set; } = "https://support.discordapp.com/hc/en-us/articles/228383668-Intro-to-Webhooks";
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<Configuration>();
            _config.FeatureTypes = new Dictionary<FeatureType, Configuration.WebhookObject>
            {
                [FeatureType.Ban] = _config.BanSettings,
                [FeatureType.Report] = _config.ReportSettings,
                [FeatureType.Message] = _config.MessageSettings,
                [FeatureType.Mute] = _config.MuteSettings,
                [FeatureType.PlayerChat] = _config.ChatSettings
            };
        }

        protected override void SaveConfig()
        {
            base.SaveConfig();
            Config.WriteObject( _config );
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning( "Generating new config!" );
            _config = Configuration.Defaults();
        }

        private T GetFeatureConfig<T>( FeatureType type ) where T : Configuration.WebhookObject
        {
            return ( T ) _config.FeatureTypes[type];
        }

        #endregion

        #region Variables

        private Data _data;

        [PluginReference]
        private readonly Plugin BetterChatMute, AdminChat;

        private static DiscordMessages _instance;
        private readonly JsonSerializerSettings _jsonSettings = new JsonSerializerSettings();

        private readonly Dictionary<string, string> _headers = new Dictionary<string, string>
        {
            ["Content-Type"] = "application/json"
        };

        #endregion

        #region Hooks / Load

        private void Loaded()
        {
            _instance = this;
            Request.Init();
            _jsonSettings.NullValueHandling = NullValueHandling.Ignore;
            LoadData();
            RegisterPermissions();

            foreach ( var feature in _config.FeatureTypes )
            {
                Configuration.WebhookObject value = feature.Value;
                if ( !value.Enabled || value.WebhookUrl != null && value.WebhookUrl != "https://support.discordapp.com/hc/en-us/articles/228383668-Intro-to-Webhooks" )
                {
                    continue;
                }

                value.Enabled = false;
                PrintWarning( $"{feature.Key} was enabled however the Webhook is incorrect." );
            }

            RegisterCommands();
            CheckHooks();
        }

        private void CheckHooks()
        {
            if ( !GetFeatureConfig<Configuration.Chat>( FeatureType.PlayerChat ).Enabled )
            {
#if RUST
                Unsubscribe(nameof(OnPlayerChat));
#else
                Unsubscribe( nameof( OnUserChat ) );
#endif
            }

            if ( !GetFeatureConfig<Configuration.Mute>( FeatureType.Mute ).Enabled )
            {
                Unsubscribe( nameof( OnBetterChatMuted ) );
                Unsubscribe( nameof( OnBetterChatTimeMuted ) );
            }
        }

        private void Unload()
        {
            SaveData();
            Request.Dispose();
            _instance = null;
        }

        private void OnServerSave()
        {
            SaveData();
        }

        private void RegisterCommands()
        {
            if ( GetFeatureConfig<Configuration.Report>( FeatureType.Report ).Enabled )
            {
                AddCovalenceCommand( "report", "ReportCommand", ReportPermission );
                AddCovalenceCommand( new[]
                {
                    "reportadmin",
                    "ra"
                }, "ReportAdminCommand", AdminPermission );
            }

            if ( GetFeatureConfig<Configuration.Ban>( FeatureType.Ban ).Enabled )
            {
                AddCovalenceCommand( "ban", "BanCommand", BanPermission );
            }

            var messageConfig = GetFeatureConfig<Configuration.Message>( FeatureType.Message );
            if ( messageConfig.Enabled )
            {
                AddCovalenceCommand( messageConfig.SuggestAlias
                    ? new[]
                    {
                        "message",
                        "suggest"
                    }
                    : new[]
                    {
                        "message"
                    }, "MessageCommand", MessagePermission );
            }
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages( new Dictionary<string, string>
            {
                ["ReportSyntax"] = "Syntax error. Please use /report \"name/id\" \"reason\"",
                ["BanSyntax"] = "Syntax error. Please use /ban \"name/id\" \"reason\"",
                ["MessageSyntax"] = "Syntax error. Please use /message \"your message\"",
                ["Multiple"] = "Multiple players found:\n{0}",
                ["BanMessage"] = "{0} was banned for {1}",
                ["ReportSent"] = "Your report has been sent!",
                ["MessageSent"] = "Your message has been sent!",
                ["NotFound"] = "Unable to find player {0}",
                ["NoReports"] = "{0} has not been reported yet!",
                ["ReportDisallowed"] = "You have been blacklisted from reporting players.",
                ["ReportAccessChanged"] = "Report feature for {0} is now {1}",
                ["ReportReset"] = "You have reset the report count for {0}",
                ["Cooldown"] = "You must wait {0} seconds to use this command again.",
                ["AlreadyBanned"] = "{0} is already banned!",
                ["NoPermission"] = "You do not have permision for this command!",
                ["Disabled"] = "This feature is currently disabled.",
                ["Failed"] = "Your report failed to send, contact the server owner.",
                ["ToSelf"] = "You cannot perform this action on yourself.",
                ["ReportTooShort"] = "Your report was too short! Please be more descriptive.",
                ["PlayerChatFormatNew"] = "[{2}] **{0}:** {1}",
                ["BanPrefix"] = "Banned: {0}",
                ["Embed_ReportPlayer"] = "Reporter",
                ["Embed_ReportTarget"] = "Reported",
                ["Embed_ReportCount"] = "Times Reported",
                ["Embed_ReportReason"] = "Reason",
                ["Embed_Online"] = "Online",
                ["Embed_Offline"] = "Offline",
                ["Embed_ReportStatus"] = "Status",
                ["Embed_ReportTitle"] = "Player Report",
                ["Embed_MuteTitle"] = "Player Muted",
                ["Embed_MuteTarget"] = "Player",
                ["Embed_MutePlayer"] = "Muted by",
                ["Embed_BanPlayer"] = "Banned by",
                ["Embed_BanTarget"] = "Player",
                ["Embed_BanReason"] = "Reason",
                ["Embed_BanTitle"] = "Player Ban",
                ["Embed_MessageTitle"] = "Player Message",
                ["Embed_MessagePlayer"] = "Player",
                ["Embed_MessageMessage"] = "Message",
                ["Embed_MuteTime"] = "Time",
                ["Embed_MuteReason"] = "Reason"
            }, this );
        }

        #endregion

        #region Permissions

        private const string BanPermission = "discordmessages.ban";
        private const string ReportPermission = "discordmessages.report";
        private const string MessagePermission = "discordmessages.message";
        private const string AdminPermission = "discordmessages.admin";

        private void RegisterPermissions()
        {
            permission.RegisterPermission( BanPermission, this );
            permission.RegisterPermission( ReportPermission, this );
            permission.RegisterPermission( MessagePermission, this );
            permission.RegisterPermission( AdminPermission, this );
        }

        #endregion

        #region API

        private void API_SendFancyMessage( string webhookUrl, string content, string embedJsonString, Plugin plugin = null )
        {
            EmbedBuilder embed;
            try
            {
                embed = JsonConvert.DeserializeObject<EmbedBuilder>( embedJsonString );
            }
            catch ( JsonSerializationException )
            {
                PrintWarning( "Failed to deserialize json string: {0}", embedJsonString );
                return;
            }

            FancyMessage payload = new FancyMessage().SetEmbed( embed ).WithContent( content );
            Request.Send( webhookUrl, payload, plugin );
        }

        private void API_SendFancyMessage( string webhookUrl, string embedName, int embedColor, string json, string content = null, Plugin plugin = null )
        {
            EmbedBuilder builder = new EmbedBuilder().WithTitle( embedName ).SetColor( embedColor );


            EmbedBuilder.Field[] fields;
            try
            {
                fields = JsonConvert.DeserializeObject<EmbedBuilder.Field[]>( json );
            }
            catch ( JsonSerializationException )
            {
                PrintWarning( "Failed to deserialize json string: {0}", json );
                return;
            }

            builder.AddFields( fields );

            FancyMessage payload = new FancyMessage().SetEmbed( builder ).WithContent( content );
            Request.Send( webhookUrl, payload, plugin );
        }

        private void API_SendFancyMessage( string webhookUrl, string embedName, string json, string content = null, int embedColor = 3329330, Plugin plugin = null )
        {
            API_SendFancyMessage( webhookUrl, embedName, embedColor, json, content, plugin );
        }

        private void API_SendTextMessage( string webhookUrl, string content, bool tts = false, Plugin plugin = null )
        {
            Request.Send( webhookUrl, new FancyMessage().AsTTS( tts ).WithContent( content ), plugin );
        }

        #endregion

        #region Report

        private void ReportAdminCommand( IPlayer player, string command, string[] args )
        {
            IPlayer target = GetPlayer( args[1], player, false );
            if ( target == null )
            {
                player.Reply( GetLang( "NotFound", player.Id, args[1] ) );
                return;
            }

            PlayerData data;

            switch ( args[0] )
            {
                case "enable":

                    if ( _data.Players.TryGetValue( target.Id, out data ) )
                    {
                        data.ReportDisabled = false;
                    }

                    player.Reply( GetLang( "ReportAccessChanged", player.Id, target.Name, "enabled" ) );
                    return;
                case "disable":
                    if ( !_data.Players.TryGetValue( target.Id, out data ) )
                    {
                        _data.Players.Add( target.Id, data = new PlayerData() );
                    }

                    data.ReportDisabled = true;

                    player.Reply( GetLang( "ReportAccessChanged", player.Id, target.Name, "disabled" ) );
                    return;
                case "reset":
                    if ( _data.Players.TryGetValue( target.Id, out data ) && data.Reports > 0 )
                    {
                        data.Reports = 0;
                        player.Reply( GetLang( "ReportReset", player.Id, target.Name ) );
                        return;
                    }

                    player.Reply( GetLang( "NoReports", player.Id, target.Name ) );
                    return;
            }
        }

        private void ReportCommand( IPlayer player, string command, string[] args )
        {
            if ( ( player.Name == "Server Console" ) | !player.IsConnected )
            {
                return;
            }

            PlayerData data;
            if ( !_data.Players.TryGetValue( player.Id, out data ) )
            {
                _data.Players.Add( player.Id, data = new PlayerData() );
            }
            else if ( data.ReportDisabled )
            {
                SendMessage( player, GetLang( "ReportDisallowed", player.Id ) );
                return;
            }

            if ( args.Length < 2 )
            {
                SendMessage( player, GetLang( "ReportSyntax", player.Id ) );
                return;
            }

            var reportConfig = GetFeatureConfig<Configuration.Report>( FeatureType.Report );

            int secondsRemaining;
            if ( OnCooldown( player, CooldownType.ReportCooldown, out secondsRemaining ) )
            {
                SendMessage( player, GetLang( "Cooldown", player.Id, secondsRemaining.ToString() ) );
                return;
            }

            IPlayer target = GetPlayer( args[0], player, true );
            if ( target == null )
            {
                return;
            }

            var reason = args.Skip( 1 ).ToList();
            if ( player.Id == target.Id )
            {
                SendMessage( player, GetLang( "ToSelf", player.Id ) );
                return;
            }

            string[] targetName = target.Name.Split( ' ' );
            if ( targetName.Length > 1 )
            {
                for ( var x = 0; x < targetName.Length - 1; x++ )
                {
                    if ( reason[x].Equals( targetName[x + 1] ) )
                    {
                        reason.RemoveAt( x );
                    }
                    else
                    {
                        break;
                    }
                }
            }

            if ( reason.Count < 1 )
            {
                SendMessage( player, GetLang( "ReportTooShort", player.Id ) );
                return;
            }

            string cleanReason = string.Join( " ", reason.ToArray() );

            PlayerData targetData;
            if ( !_data.Players.TryGetValue( target.Id, out targetData ) )
            {
                _data.Players.Add( target.Id, targetData = new PlayerData() );
            }

            targetData.Reports++;

            string status = target.IsConnected ? lang.GetMessage( "Online", null ) : lang.GetMessage( "Offline", null );
            EmbedBuilder builder = new EmbedBuilder().WithTitle( GetLang( "Embed_ReportTitle" ) ).SetColor( reportConfig.Color ).AddInlineField( GetLang( "Embed_ReportTarget" ), $"[{target.Name}](https://steamcommunity.com/profiles/{target.Id})" ).AddInlineField( GetLang( "Embed_ReportPlayer" ), $"[{player.Name}](https://steamcommunity.com/profiles/{player.Id})" ).AddInlineField( GetLang( "Embed_ReportStatus" ), status ).AddField( GetLang( "Embed_ReportReason" ), cleanReason ).AddInlineField( GetLang( "Embed_ReportCount" ), targetData.Reports.ToString() );
            FancyMessage payload = new FancyMessage().WithContent( reportConfig.Alert ).SetEmbed( builder );
            Request.Send( reportConfig.WebhookUrl, payload, response =>
            {
                if ( response.IsOk )
                {
                    SendMessage( player, GetLang( "ReportSent", player.Id ) );
                    data.ReportCooldown = DateTime.UtcNow;

                    if ( reportConfig.LogToConsole )
                    {
                        Puts( $"REPORT ({player.Name}/{player.Id}) -> ({target.Name}/{target.Id}): {reason}" );
                    }
                }
                else if ( response.IsBad )
                {
                    SendMessage( player, GetLang( "ReportNotSent", player.Id ) );
                }
            }, this );
        }

        #endregion

        #region Mutes

        private static string FormatTime( TimeSpan time )
        {
            return $"{( time.Days == 0 ? string.Empty : $"{time.Days} day(s)" )}{( time.Days != 0 && time.Hours != 0 ? ", " : string.Empty )}{( time.Hours == 0 ? string.Empty : $"{time.Hours} hour(s)" )}{( time.Hours != 0 && time.Minutes != 0 ? ", " : string.Empty )}{( time.Minutes == 0 ? string.Empty : $"{time.Minutes} minute(s)" )}{( time.Minutes != 0 && time.Seconds != 0 ? ", " : string.Empty )}{( time.Seconds == 0 ? string.Empty : $"{time.Seconds} second(s)" )}";
        }

        private void OnBetterChatTimeMuted( IPlayer target, IPlayer player, TimeSpan expireDate, string reason )
        {
            SendMute( target, player, expireDate, true, reason );
        }

        private void OnBetterChatMuted( IPlayer target, IPlayer player, string reason )
        {
            SendMute( target, player, TimeSpan.Zero, false, reason );
        }

        private void SendMute( IPlayer target, IPlayer player, TimeSpan expireDate, bool timed, string reason )
        {
            if ( target == null || player == null )
            {
                return;
            }

            var muteConfig = GetFeatureConfig<Configuration.Mute>( FeatureType.Mute );
            EmbedBuilder builder = new EmbedBuilder().WithTitle( GetLang( "Embed_MuteTitle" ) ).AddInlineField( GetLang( "Embed_MuteTarget" ), $"[{target.Name}](https://steamcommunity.com/profiles/{target.Id})" ).AddInlineField( GetLang( "Embed_MutePlayer" ), !player.Id.Equals( "server_console" ) ? $"[{player.Name}](https://steamcommunity.com/profiles/{player.Id})" : player.Name ).AddInlineField( GetLang( "Embed_MuteTime" ), timed ? FormatTime( expireDate ) : "Permanent" ).SetColor( muteConfig.Color );
            if ( !string.IsNullOrEmpty( reason ) )
            {
                builder.AddField( GetLang( "Embed_MuteReason" ), reason );
            }

            FancyMessage message = new FancyMessage().SetEmbed( builder );
            Request.Send( muteConfig.WebhookUrl, message, this );
        }

        #endregion

        #region Bans

        private bool _banFromCommand;

        private void BanCommand( IPlayer player, string command, string[] args )
        {
            if ( args.Length == 0 )
            {
                SendMessage( player, GetLang( "BanSyntax", player.Id ) );
                return;
            }

            string reason = args.Length == 1 ? "Banned" : string.Join( " ", args.Skip( 1 ).ToArray() );
            IPlayer target = GetPlayer( args[0], player, false );
            if ( target != null )
            {
                if ( target.Id == player.Id )
                {
                    SendMessage( player, GetLang( "ToSelf", player.Id ) );
                    return;
                }

                ExecuteBan( target, player, reason );
            }
            else
            {
                player.Reply( GetLang( "NotFound", player.Id, args[0] ) );
            }
        }

        private void ExecuteBan( IPlayer target, IPlayer player, string reason )
        {
            if ( target.IsBanned )
            {
                SendMessage( player, GetLang( "AlreadyBanned", player.Id, target.Name ) );
                return;
            }

            _banFromCommand = true;
            OnUserBanned( target.Name, target.Id, target.Address, reason, -1, player );
            target.Ban( GetLang( "BanPrefix", target.Id ) + reason );
            if ( _config.GeneralSettings.Announce )
            {
                server.Broadcast( GetLang( "BanMessage", null, target.Name, reason ) );
            }
        }

        private void OnUserBanned( string name, string bannedId, string address, string reason, long expiry, IPlayer source = null )
        {
            var banConfig = GetFeatureConfig<Configuration.Ban>( FeatureType.Ban );
            if ( !banConfig.Enabled )
            {
                return;
            }

            EmbedBuilder builder = new EmbedBuilder().WithTitle( GetLang( "Embed_BanTitle" ) ).AddInlineField( GetLang( "Embed_BanTarget" ), $"[{name}](https://steamcommunity.com/profiles/{bannedId})" );
            if ( source == null )
            {
                if ( _banFromCommand )
                {
                    return;
                }
            }
            else
            {
                builder.AddInlineField( GetLang( "Embed_BanPlayer" ), !source.Id.Equals( "server_console" ) ? $"[{source.Name}](https://steamcommunity.com/profiles/{source.Id})" : source.Name );
            }

            builder.AddField( GetLang( "Embed_BanReason" ), reason );

            if ( expiry > 0 )
            {
                builder.AddField( "Expiry", DateTimeOffset.FromUnixTimeSeconds( expiry ).LocalDateTime.ToString( CultureInfo.CurrentCulture ) );
            }

            builder.SetColor( banConfig.Color );
            FancyMessage message = new FancyMessage().SetEmbed( builder );
            Request.Send( banConfig.WebhookUrl, message, this );
            _banFromCommand = false;
        }

        #endregion

        #region Helpers

        private string GetLang( string key, string id = null, params object[] args )
        {
            return args.Length > 0 ? string.Format( lang.GetMessage( key, this, id ), args ) : lang.GetMessage( key, this, id );
        }

        private void SendMessage( IPlayer player, string message )
        {
            player.Reply( message );
        }

        private bool OnCooldown( IPlayer player, CooldownType type, out int secondsRemaining )
        {
            secondsRemaining = 0;
            PlayerData data;
            if ( !_data.Players.TryGetValue( player.Id, out data ) )
            {
                return false;
            }

            switch ( type )
            {
                case CooldownType.MessageCooldown:
                {
                    if ( !data.MessageCooldown.HasValue )
                    {
                        return false;
                    }

                    secondsRemaining = (int)(DateTime.UtcNow - data.MessageCooldown.Value.AddSeconds( GetFeatureConfig<Configuration.Message>( FeatureType.Message ).Cooldown )).TotalSeconds;
                    return secondsRemaining > 0;

                }
                case CooldownType.ReportCooldown:
                {
                    if ( !data.ReportCooldown.HasValue )
                    {
                        return false;
                    }

                    secondsRemaining = (int)(DateTime.UtcNow - data.ReportCooldown.Value.AddSeconds( GetFeatureConfig<Configuration.Report>( FeatureType.Report ).Cooldown )).TotalSeconds;
                    return secondsRemaining > 0;

                }
                default:
                    return false;
            }
        }

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject( Name, _data );
        }

        private void LoadData()
        {
            _data = Interface.Oxide.DataFileSystem.ReadObject<Data>( Name );
        }

        private IPlayer GetPlayer( string nameOrId, IPlayer player, bool sendError )
        {
            if ( nameOrId.IsSteamId() )
            {
                IPlayer result = players.All.ToList().Find( p => p.Id == nameOrId );

                return result;
            }

            var foundPlayers = new List<IPlayer>();

            foreach ( IPlayer current in players.Connected )
            {
                if ( string.Equals( current.Name, nameOrId, StringComparison.CurrentCultureIgnoreCase ) )
                {
                    return current;
                }

                if ( current.Name.ToLower().Contains( nameOrId.ToLower() ) )
                {
                    foundPlayers.Add( current );
                }
            }

            if ( foundPlayers.Count == 0 )
            {
                foreach ( IPlayer all in players.All )
                {
                    if ( string.Equals( all.Name, nameOrId, StringComparison.CurrentCultureIgnoreCase ) )
                    {
                        return all;
                    }

                    if ( all.Name.ToLower().Contains( nameOrId.ToLower() ) )
                    {
                        foundPlayers.Add( all );
                    }
                }
            }

            switch ( foundPlayers.Count )
            {
                case 0:
                    if ( !nameOrId.IsSteamId() )
                    {
                        if ( sendError )
                        {
                            SendMessage( player, GetLang( "NotFound", player.Id, nameOrId ) );
                        }
                    }

                    break;

                case 1:
                    return foundPlayers[0];

                default:
                    string[] names = ( from current in foundPlayers
                        select current.Name ).ToArray();
                    SendMessage( player, GetLang( "Multiple", player.Id, string.Join( ", ", names ) ) );
                    break;
            }

            return null;
        }

        #endregion
    }
}

// --- End of file: DiscordMessages.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/ImageLibrary.cs ---
// --- Original Local Path: BeeRust/ImageLibrary.cs ---

//Reference: Facepunch.Sqlite
//Reference: UnityEngine.UnityWebRequestModule
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using Steamworks;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Networking;

namespace Oxide.Plugins
{
    [Info("Image Library", "Absolut & K1lly0u", "2.0.62")]
    [Description("Plugin API for downloading and managing images")]
    class ImageLibrary : RustPlugin
    {
        #region Fields

        private ImageIdentifiers imageIdentifiers;
        private ImageURLs imageUrls;
        private SkinInformation skinInformation;
        private DynamicConfigFile identifiers;
        private DynamicConfigFile urls;
        private DynamicConfigFile skininfo;

        private static ImageLibrary il;
        private ImageAssets assets;

        private Queue<LoadOrder> loadOrders = new Queue<LoadOrder>();
        private bool orderPending;
        private bool isInitialized;

        private JsonSerializerSettings errorHandling = new JsonSerializerSettings { Error = (se, ev) => { ev.ErrorContext.Handled = true; } };

        private const string STEAM_API_URL = "https://api.steampowered.com/ISteamRemoteStorage/GetPublishedFileDetails/v1/";
        private const string STEAM_AVATAR_URL = "https://api.steampowered.com/ISteamUser/GetPlayerSummaries/v0002/?key={0}&steamids={1}";

        private string[] itemShortNames;

        #endregion Fields

        #region Oxide Hooks

        private void Loaded()
        {
            identifiers = Interface.Oxide.DataFileSystem.GetFile("ImageLibrary/image_data");
            
            urls = Interface.Oxide.DataFileSystem.GetFile("ImageLibrary/image_urls");
            skininfo = Interface.Oxide.DataFileSystem.GetFile("ImageLibrary/skin_data");

            il = this;
            LoadData();
        }

        private void OnServerInitialized()
        {
            itemShortNames = ItemManager.itemList.Select(x => x.shortname).ToArray();

            foreach (ItemDefinition item in ItemManager.itemList)
            {
                string workshopName = item.displayName.english.ToLower().Replace("skin", "").Replace(" ", "").Replace("-", "");
                if (!workshopNameToShortname.ContainsKey(workshopName))
                    workshopNameToShortname.Add(workshopName, item.shortname);
            }

            AddDefaultUrls();

            CheckForRefresh();

            foreach (BasePlayer player in BasePlayer.activePlayerList)
                OnPlayerConnected(player);
        }
    
        private void OnPlayerConnected(BasePlayer player) => GetPlayerAvatar(player?.UserIDString);

        private void Unload()
        {
            SaveData();
            UnityEngine.Object.Destroy(assets);
            il = null;
        }

        #endregion Oxide Hooks

        #region Functions
        private IEnumerator ProcessLoadOrders()
        {
            yield return new WaitWhile(() => !isInitialized);

            if (loadOrders.Count > 0)
            {
                if (orderPending)
                    yield break;

                LoadOrder nextLoad = loadOrders.Dequeue();
                if (!nextLoad.loadSilent)
                    Puts("Starting order " + nextLoad.loadName);

                if (nextLoad.imageList != null && nextLoad.imageList.Count > 0)
                {
                    foreach (KeyValuePair<string, string> item in nextLoad.imageList)
                        assets.Add(item.Key, item.Value);
                }
                if (nextLoad.imageData != null && nextLoad.imageData.Count > 0)
                {
                    foreach (KeyValuePair<string, byte[]> item in nextLoad.imageData)
                        assets.Add(item.Key, null, item.Value);
                }

                orderPending = true;

                assets.RegisterCallback(nextLoad.callback);

                assets.BeginLoad(nextLoad.loadSilent ? string.Empty : nextLoad.loadName);
            }
        }

        private void GetPlayerAvatar(string userId)
        {
            if (!configData.StoreAvatars || string.IsNullOrEmpty(userId) || string.IsNullOrEmpty(configData.SteamAPIKey) || HasImage(userId, 0))
                return;

            webrequest.Enqueue(string.Format(STEAM_AVATAR_URL, configData.SteamAPIKey, userId), null, (code, response) =>
            {
                if (response != null && code == 200)
                {
                    try
                    {
                        AvatarRoot rootObject = JsonConvert.DeserializeObject<AvatarRoot>(response, errorHandling);
                        if (rootObject?.response?.players?.Length > 0)
                        {
                            string avatarUrl = rootObject.response.players[0].avatarmedium;
                            if (!string.IsNullOrEmpty(avatarUrl))                            
                                AddImage(avatarUrl, userId, 0);                               
                        }                        
                    }
                    catch { }
                }
            }, this);
        }

        private void RefreshImagery()
        {
            imageIdentifiers.imageIds.Clear();
            imageIdentifiers.lastCEID = CommunityEntity.ServerInstance.net.ID.Value;

            AddImage("http://i.imgur.com/sZepiWv.png", "NONE", 0);
            AddImage("http://i.imgur.com/lydxb0u.png", "LOADING", 0);
            foreach (KeyValuePair<string, string> image in configData.UserImages)
            {
                if (!string.IsNullOrEmpty(image.Value))
                    AddImage(image.Value, image.Key, 0);
            }

            if ((Steamworks.SteamInventory.Definitions?.Length ?? 0) == 0)
            {
                PrintWarning("Waiting for Steamworks to update item definitions....");
                Steamworks.SteamInventory.OnDefinitionsUpdated += GetItemSkins;
            }
            else GetItemSkins();
        }

        private void CheckForRefresh()
        {
            if (assets == null)
                assets = new GameObject("WebObject").AddComponent<ImageAssets>();

            isInitialized = true;

            if (imageIdentifiers.lastCEID != CommunityEntity.ServerInstance.net.ID.Value)
            {
                if (imageIdentifiers.imageIds.Count < 2)
                {
                    RefreshImagery();
                }
                else
                {
                    PrintWarning("The CommunityEntity instance ID has changed! Due to the way CUI works in Rust all previously stored images must be removed and re-stored using the new ID as reference so clients can find the images. These images will be added to a new load order. Interupting this process will result in being required to re-download these images from the web");
                    RestoreLoadedImages();
                }
            }
        }

        private void RestoreLoadedImages()
        {
            orderPending = true;

            try
            {
                Facepunch.Sqlite.Database db = new Facepunch.Sqlite.Database();
                db.Open(string.Concat(ConVar.Server.rootFolder, "/", "sv.files.", Rust.Protocol.save - 1, ".db"));                
                if (db.TableExists("data"))
                {
                    Dictionary<string, byte[]> oldFiles = new Dictionary<string, byte[]>();
                    int failed = 0;

                    for (int i = imageIdentifiers.imageIds.Count - 1; i >= 0; i--)
                    {
                        KeyValuePair<string, string> image = imageIdentifiers.imageIds.ElementAt(i);

                        uint imageId;
                        if (!uint.TryParse(image.Value, out imageId))
                            continue;

                        byte[] bytes = db.Query<byte[], int, int, int>("SELECT data FROM data WHERE crc = ? AND filetype = ? AND entid = ? LIMIT 1", (int)imageId, 0, (int)imageIdentifiers.lastCEID );
                        if (bytes != null)
                            oldFiles.Add(image.Key, bytes);
                        else
                        {
                            failed++;
                            imageIdentifiers.imageIds.Remove(image.Key);
                        }
                    }

                    if (oldFiles.Count > 0)
                    {
                        loadOrders.Enqueue(new LoadOrder("Image restoration from previous database", oldFiles));
                        PrintWarning($"{imageIdentifiers.imageIds.Count - failed} images queued for restoration from previous image db, {failed} images failed");
                    }

                }
                db.Close();
            }
            catch
            {
                PrintError("Failed to open previous image database. Unable to clone previous image data");
            }
            //Facepunch.Sqlite.Database db = new Facepunch.Sqlite.Database();
            //try
            //{
            //    db.Open($"{ConVar.Server.rootFolder}/sv.files.0.db");
            //    db.Execute("DELETE FROM data WHERE entid = ?", imageIdentifiers.lastCEID);
            //    db.Close();
            //}
            //catch { }

            //loadOrders.Enqueue(new LoadOrder("Image restoration from previous database", oldFiles));
            //PrintWarning($"{imageIdentifiers.imageIds.Count - failed} images queued for restoration, {failed} images failed");
            imageIdentifiers.lastCEID = CommunityEntity.ServerInstance.net.ID.Value;
            SaveData();

            orderPending = false;
            ServerMgr.Instance.StartCoroutine(ProcessLoadOrders());
        }

        #endregion Functions

        #region Workshop Names and Image URLs
        private void AddDefaultUrls()
        {
            foreach (ItemDefinition itemDefinition in ItemManager.itemList)
            {
                string identifier = $"{itemDefinition.shortname}_0";
                if (!imageUrls.URLs.ContainsKey(identifier))
                    imageUrls.URLs.Add(identifier, $"{configData.ImageURL}{itemDefinition.shortname}.png");
                else imageUrls.URLs[identifier] = $"{configData.ImageURL}{itemDefinition.shortname}.png";
            }
            
            SaveUrls();

            LoadInbuiltSkinLookup();
        }

        private void LoadInbuiltSkinLookup()
        {
            const string LOOKUP_TABLE = "https://raw.githubusercontent.com/k1lly0u/Oxide/master/il_inbuilt_skins.json";

            try
            {
                Debug.Log("Loading inbuilt skin manifest from GitHub...");
                webrequest.Enqueue(LOOKUP_TABLE, string.Empty, (int code, string response) =>
                {
                    Dictionary<string, string> collection = JsonConvert.DeserializeObject<Dictionary<string, string>>(response);

                    foreach (ItemSkinDirectory.Skin skin in ItemSkinDirectory.Instance.skins)
                    {
                        if (skin.invItem == null || string.IsNullOrEmpty(skin.invItem.itemname))
                            continue;

                        string filename;
                        if (collection.TryGetValue(skin.name, out filename))
                        {
                            string identifier = $"{skin.invItem.itemname}_{skin.id}";

                            if (!imageUrls.URLs.ContainsKey(identifier))
                                imageUrls.URLs.Add(identifier, $"{configData.ImageURL}{filename}.png");
                            else imageUrls.URLs[identifier] = $"{configData.ImageURL}{filename}.png";
                        }
                    }

                    Debug.Log("Skin manifest imported successfully");
                    SaveUrls();
                }, this);
            }
            catch
            {
                Debug.LogError("Failed to download inbuilt skin manifest from GitHub. Unable to gather inbuilt skin list");
            }
        }

        private readonly Dictionary<string, string> workshopNameToShortname = new Dictionary<string, string>
        {
            {"longtshirt", "tshirt.long" },
            {"cap", "hat.cap" },
            {"beenie", "hat.beenie" },
            {"boonie", "hat.boonie" },
            {"balaclava", "mask.balaclava" },
            {"pipeshotgun", "shotgun.waterpipe" },
            {"woodstorage", "box.wooden" },
            {"ak47", "rifle.ak" },
            {"bearrug", "rug.bear" },
            {"boltrifle", "rifle.bolt" },
            {"bandana", "mask.bandana" },
            {"hideshirt", "attire.hide.vest" },
            {"snowjacket", "jacket.snow" },
            {"buckethat", "bucket.helmet" },
            {"semiautopistol", "pistol.semiauto" },
            {"burlapgloves", "burlap.gloves" },
            {"roadsignvest", "roadsign.jacket" },
            {"roadsignpants", "roadsign.kilt" },
            {"burlappants", "burlap.trousers" },
            {"collaredshirt", "shirt.collared" },
            {"mp5", "smg.mp5" },
            {"sword", "salvaged.sword" },
            {"workboots", "shoes.boots" },
            {"vagabondjacket", "jacket" },
            {"hideshoes", "attire.hide.boots" },
            {"deerskullmask", "deer.skull.mask" },
            {"minerhat", "hat.miner" },
            {"lr300", "rifle.lr300" },
            {"lr300.item", "rifle.lr300" },
            {"burlap.gloves", "burlap.gloves.new"},
            {"leather.gloves", "burlap.gloves"},
            {"python", "pistol.python" },
            {"m39", "rifle.m39"},
            {"woodendoubledoor", "door.double.hinged.wood"}
        };

        #endregion Workshop Names and Image URLs

        #region API

        [HookMethod("AddImage")]
        public bool AddImage(string url, string imageName, ulong imageId, Action callback = null)
        {
            loadOrders.Enqueue(new LoadOrder(imageName, new Dictionary<string, string> { { $"{imageName}_{imageId}", url } }, true, callback));
            if (!orderPending)
                ServerMgr.Instance.StartCoroutine(ProcessLoadOrders());
            return true;
        }

        [HookMethod("AddImageData")]
        public bool AddImageData(string imageName, byte[] array, ulong imageId, Action callback = null)
        {
            loadOrders.Enqueue(new LoadOrder(imageName, new Dictionary<string, byte[]> { { $"{imageName}_{imageId}", array } }, true, callback));
            if (!orderPending)
                ServerMgr.Instance.StartCoroutine(ProcessLoadOrders());
            return true;
        }

        [HookMethod("GetImageURL")]
        public string GetImageURL(string imageName, ulong imageId = 0)
        {
            string identifier = $"{imageName}_{imageId}";
            string value;
            if (imageUrls.URLs.TryGetValue(identifier, out value))
                return value;
            return string.Empty;
        }

        [HookMethod("GetImage")]
        public string GetImage(string imageName, ulong imageId = 0, bool returnUrl = false)
        {
            string identifier = $"{imageName}_{imageId}";
            string value;
            if (imageIdentifiers.imageIds.TryGetValue(identifier, out value))
                return value;
            else
            {                
                if (imageUrls.URLs.TryGetValue(identifier, out value))
                {
                    AddImage(value, imageName, imageId);
                    return imageIdentifiers.imageIds["LOADING_0"];
                }
            }

            if (returnUrl && !string.IsNullOrEmpty(value))
                return value;

            return imageIdentifiers.imageIds["NONE_0"];
        }

        [HookMethod("GetImageList")]
        public List<ulong> GetImageList(string name)
        {
            List<ulong> skinIds = new List<ulong>();
            string[] matches = imageUrls.URLs.Keys.Where(x => x.StartsWith(name)).ToArray();
            for (int i = 0; i < matches.Length; i++)
            {
                int index = matches[i].IndexOf("_");
                if (matches[i].Substring(0, index) == name)
                {
                    ulong skinID;
                    if (ulong.TryParse(matches[i].Substring(index + 1), out skinID))
                        skinIds.Add(ulong.Parse(matches[i].Substring(index + 1)));
                }
            }
            return skinIds;
        }

        [HookMethod("GetSkinInfo")]
        public Dictionary<string, object> GetSkinInfo(string name, ulong id)
        {
            Dictionary<string, object> skinInfo;
            if (skinInformation.skinData.TryGetValue($"{name}_{id}", out skinInfo))
                return skinInfo;
            return null;
        }

        [HookMethod("HasImage")]
        public bool HasImage(string imageName, ulong imageId)
        {
            string key = $"{imageName}_{imageId}";
            string value;

            if (imageIdentifiers.imageIds.TryGetValue(key, out value) && IsInStorage(uint.Parse(value)))            
                return true;            

            return false;
        }

        public bool IsInStorage(uint crc) => FileStorage.server.Get(crc, FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID) != null;

        [HookMethod("IsReady")]
        public bool IsReady() => loadOrders.Count == 0 && !orderPending;

        [HookMethod("ImportImageList")]
        public void ImportImageList(string title, Dictionary<string, string> imageList, ulong imageId = 0, bool replace = false, Action callback = null)
        {
            Dictionary<string, string> newLoadOrder = new Dictionary<string, string>();
            foreach (KeyValuePair<string, string> image in imageList)
            {
                if (!replace && HasImage(image.Key, imageId))
                    continue;
                newLoadOrder[$"{image.Key}_{imageId}"] = image.Value;
            }
            if (newLoadOrder.Count > 0)
            {
                loadOrders.Enqueue(new LoadOrder(title, newLoadOrder, false, callback));
                if (!orderPending)
                    ServerMgr.Instance.StartCoroutine(ProcessLoadOrders());
            }
            else
            {
                if (callback != null)
                    callback.Invoke();
            }
        }

        [HookMethod("ImportItemList")]
        public void ImportItemList(string title, Dictionary<string, Dictionary<ulong, string>> itemList, bool replace = false, Action callback = null)
        {
            Dictionary<string, string> newLoadOrder = new Dictionary<string, string>();
            foreach (KeyValuePair<string, Dictionary<ulong, string>> image in itemList)
            {
                foreach (KeyValuePair<ulong, string> skin in image.Value)
                {
                    if (!replace && HasImage(image.Key, skin.Key))
                        continue;
                    newLoadOrder[$"{image.Key}_{skin.Key}"] = skin.Value;
                }
            }
            if (newLoadOrder.Count > 0)
            {
                loadOrders.Enqueue(new LoadOrder(title, newLoadOrder, false, callback));
                if (!orderPending)
                    ServerMgr.Instance.StartCoroutine(ProcessLoadOrders());
            }
            else
            {
                if (callback != null)
                    callback.Invoke();
            }
        }

        [HookMethod("ImportImageData")]
        public void ImportImageData(string title, Dictionary<string, byte[]> imageList, ulong imageId = 0, bool replace = false, Action callback = null)
        {
            Dictionary<string, byte[]> newLoadOrder = new Dictionary<string, byte[]>();
            foreach (KeyValuePair<string, byte[]> image in imageList)
            {
                if (!replace && HasImage(image.Key, imageId))
                    continue;
                newLoadOrder[$"{image.Key}_{imageId}"] = image.Value;
            }
            if (newLoadOrder.Count > 0)
            {
                loadOrders.Enqueue(new LoadOrder(title, newLoadOrder, false, callback));
                if (!orderPending)
                    ServerMgr.Instance.StartCoroutine(ProcessLoadOrders());
            }
            else
            {
                if (callback != null)
                    callback.Invoke();
            }
        }

        [HookMethod("LoadImageList")]
        public void LoadImageList(string title, List<KeyValuePair<string, ulong>> imageList, Action callback = null)
        {
            Dictionary<string, string> newLoadOrderURL = new Dictionary<string, string>();
            List<KeyValuePair<string, ulong>> workshopDownloads = new List<KeyValuePair<string, ulong>>();

            foreach (KeyValuePair<string, ulong> image in imageList)
            {
                if (HasImage(image.Key, image.Value))                
                    continue;

                string identifier = $"{image.Key}_{image.Value}";

                if (imageUrls.URLs.ContainsKey(identifier) && !newLoadOrderURL.ContainsKey(identifier))
                {
                    newLoadOrderURL.Add(identifier, imageUrls.URLs[identifier]);
                }
                else
                {
                    workshopDownloads.Add(new KeyValuePair<string, ulong>(image.Key, image.Value));
                }
            }

            if (workshopDownloads.Count > 0)
            {
                QueueWorkshopDownload(title, newLoadOrderURL, workshopDownloads, 0, callback);
                return;
            }

            if (newLoadOrderURL.Count > 0)
            {
                loadOrders.Enqueue(new LoadOrder(title, newLoadOrderURL, null, false, callback));
                if (!orderPending)
                    ServerMgr.Instance.StartCoroutine(ProcessLoadOrders());
            }
            else
            {
                if (callback != null)
                    callback.Invoke();
            }
        }

        [HookMethod("RemoveImage")]
        public void RemoveImage(string imageName, ulong imageId)
        {
            if (!HasImage(imageName, imageId))
                return;

            uint crc = uint.Parse(GetImage(imageName, imageId));
            FileStorage.server.Remove(crc, FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID);
        }

        [HookMethod("SendImage")]
        public void SendImage(BasePlayer player, string imageName, ulong imageId = 0)
        {
            if (!HasImage(imageName, imageId) || player?.net?.connection == null)
                return;

            uint crc = uint.Parse(GetImage(imageName, imageId));
            byte[] array = FileStorage.server.Get(crc, FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID);

            if (array == null)
                return;

            CommunityEntity.ServerInstance.ClientRPCEx<uint, uint, byte[]>(new Network.SendInfo(player.net.connection)
            {
                channel = 2,
                method = Network.SendMethod.Reliable
            }, null, "CL_ReceiveFilePng", crc, (uint)array.Length, array);
        }
        #endregion API

        #region Steam API
        private List<ulong> BuildApprovedItemList()
        {
            List<ulong> list = new List<ulong>();

            foreach (InventoryDef item in Steamworks.SteamInventory.Definitions)
            {
                string shortname = item.GetProperty("itemshortname");
                ulong workshopid;

                if (item == null || string.IsNullOrEmpty(shortname))
                    continue;

                if (workshopNameToShortname.ContainsKey(shortname))
                    shortname = workshopNameToShortname[shortname];

                if (item.Id < 100)
                    continue;

                if (!ulong.TryParse(item.GetProperty("workshopid"), out workshopid))
                    continue;

                if (HasImage(shortname, workshopid))
                    continue;

                list.Add(workshopid);
            }

            return list;
        }

        private string BuildDetailsString(List<ulong> list, int page)
        {            
            int totalPages = Mathf.CeilToInt((float)list.Count / 100f);
            int index = page * 100;
            int limit = Mathf.Min((page + 1) * 100, list.Count);
            string details = string.Format("?key={0}&itemcount={1}", configData.SteamAPIKey, (limit - index));

            for (int i = index; i < limit; i++)            
                details += string.Format("&publishedfileids[{0}]={1}", i - index, list[i]);
            
            return details;
        }

        private string BuildDetailsString(List<ulong> list)
        {            
            string details = string.Format("?key={0}&itemcount={1}", configData.SteamAPIKey, list.Count);

            for (int i = 0; i < list.Count; i++)
                details += string.Format("&publishedfileids[{0}]={1}", i, list[i]);

            return details;
        }

        private bool IsValid(PublishedFileDetails item)
        {
            if (string.IsNullOrEmpty(item.preview_url))
                return false;

            if (item.tags == null)
                return false;

            return true;
        }

        private void GetItemSkins()
        {
            Steamworks.SteamInventory.OnDefinitionsUpdated -= GetItemSkins;

            PrintWarning("Retrieving item skin lists...");

            GetApprovedItemSkins(BuildApprovedItemList(), 0);
        }

        private void QueueFileQueryRequest(string details, Action<PublishedFileDetails[]> callback)
        {
            webrequest.Enqueue(STEAM_API_URL, details, (code, response) =>
            {
                try
                {
                    QueryResponse query = JsonConvert.DeserializeObject<QueryResponse>(response, errorHandling);
                    if (query == null || query.response == null || query.response.publishedfiledetails.Length == 0)
                    {
                        if (code != 200)
                            PrintError($"There was a error querying Steam for workshop item data : Code ({code})\n{details}");
                        return;
                    }
                    else
                    {
                        if (query?.response?.publishedfiledetails?.Length > 0)
                            callback.Invoke(query.response.publishedfiledetails);
                    }
                }
                catch { }
            }, this, Core.Libraries.RequestMethod.POST);
        }

        private void GetApprovedItemSkins(List<ulong> itemsToDownload, int page)
        {
            if (itemsToDownload.Count < 1)
            {
                Puts("Approved skins loaded");

                SaveUrls();
                SaveSkinInfo();

                if (!orderPending)
                    ServerMgr.Instance.StartCoroutine(ProcessLoadOrders());
                return;
            }

            int totalPages = Mathf.CeilToInt((float)itemsToDownload.Count / 100f) - 1;

            string details = BuildDetailsString(itemsToDownload, page);

            QueueFileQueryRequest(details, (PublishedFileDetails[] items) =>
            {
                ServerMgr.Instance.StartCoroutine(ProcessApprovedBlock(itemsToDownload, items, page, totalPages));
            });
        }

        private IEnumerator ProcessApprovedBlock(List<ulong> itemsToDownload, PublishedFileDetails[] items, int page, int totalPages)
        {
            PrintWarning($"Processing approved skins; Page {page + 1}/{totalPages + 1}");

            Dictionary<string, Dictionary<ulong, string>> loadOrder = new Dictionary<string, Dictionary<ulong, string>>();

            foreach (PublishedFileDetails item in items)
            {
                if (!IsValid(item))
                    continue;

                foreach (PublishedFileDetails.Tag tag in item.tags)
                {
                    if (string.IsNullOrEmpty(tag.tag))
                        continue;

                    ulong workshopid = Convert.ToUInt64(item.publishedfileid);

                    string adjTag = tag.tag.ToLower().Replace("skin", "").Replace(" ", "").Replace("-", "").Replace(".item", "");
                    if (workshopNameToShortname.ContainsKey(adjTag))
                    {
                        string shortname = workshopNameToShortname[adjTag];

                        string identifier = $"{shortname}_{workshopid}";

                        if (!imageUrls.URLs.ContainsKey(identifier))
                            imageUrls.URLs.Add(identifier, item.preview_url.Replace("https", "http"));

                        skinInformation.skinData[identifier] = new Dictionary<string, object>
                                {
                                    {"title", item.title },
                                    {"votesup", 0 },
                                    {"votesdown", 0 },
                                    {"description", item.file_description },
                                    {"score", 0 },
                                    {"views", 0 },
                                    {"created", new DateTime() },
                                };
                    }
                }
            }

            yield return CoroutineEx.waitForEndOfFrame;
            yield return CoroutineEx.waitForEndOfFrame;

            if (page < totalPages)
                GetApprovedItemSkins(itemsToDownload, page + 1);
            else
            {
                itemsToDownload.Clear();

                Puts("Approved skins loaded");

                SaveUrls();
                SaveSkinInfo();

                if (!orderPending)
                    ServerMgr.Instance.StartCoroutine(ProcessLoadOrders());
            }
        }

        private void QueueWorkshopDownload(string title, Dictionary<string, string> newLoadOrderURL, List<KeyValuePair<string, ulong>> workshopDownloads, int page = 0, Action callback = null)
        {
            int rangeMin = page * 100;
            int rangeMax = (page + 1) * 100;

            if (rangeMax > workshopDownloads.Count)
                rangeMax = workshopDownloads.Count;

            List<ulong> requestedSkins = workshopDownloads.GetRange(rangeMin, rangeMax - rangeMin).Select(x => x.Value).ToList();

            int totalPages = Mathf.CeilToInt((float)workshopDownloads.Count / 100f) - 1;

            string details = BuildDetailsString(requestedSkins);

            try
            {
                webrequest.Enqueue(STEAM_API_URL, details, (code, response) =>
                {
                    QueryResponse query = JsonConvert.DeserializeObject<QueryResponse>(response, errorHandling);
                    if (query == null || query.response == null || query.response.publishedfiledetails.Length == 0)
                    {
                        if (code != 200)
                            PrintError($"There was a error querying Steam for workshop item data : Code ({code})");

                        if (page < totalPages)
                            QueueWorkshopDownload(title, newLoadOrderURL, workshopDownloads, page + 1, callback);
                        else
                        {
                            if (newLoadOrderURL.Count > 0)
                            {
                                loadOrders.Enqueue(new LoadOrder(title, newLoadOrderURL, null, false, page < totalPages ? null : callback));
                                if (!orderPending)
                                    ServerMgr.Instance.StartCoroutine(ProcessLoadOrders());
                            }
                            else
                            {
                                if (callback != null)
                                    callback.Invoke();
                            }
                        }
                        return;
                    }
                    else
                    {
                        if (query.response.publishedfiledetails.Length > 0)
                        {
                            Dictionary<string, Dictionary<ulong, string>> loadOrder = new Dictionary<string, Dictionary<ulong, string>>();

                            foreach (PublishedFileDetails item in query.response.publishedfiledetails)
                            {
                                if (!string.IsNullOrEmpty(item.preview_url))
                                {
                                    ulong skinId = Convert.ToUInt64(item.publishedfileid);

                                    KeyValuePair<string, ulong>? kvp = workshopDownloads.Find(x => x.Value == skinId);

                                    if (kvp.HasValue)
                                    {
                                        string identifier = $"{kvp.Value.Key}_{kvp.Value.Value}";

                                        if (!newLoadOrderURL.ContainsKey(identifier))
                                            newLoadOrderURL.Add(identifier, item.preview_url);

                                        if (!imageUrls.URLs.ContainsKey(identifier))
                                            imageUrls.URLs.Add(identifier, item.preview_url);

                                        skinInformation.skinData[identifier] = new Dictionary<string, object>
                                        {
                                            {"title", item.title },
                                            {"votesup",  0 },
                                            {"votesdown", 0 },
                                            {"description", item.file_description },
                                            {"score", 0 },
                                            {"views", item.views },
                                            {"created", new DateTime(item.time_created) },
                                        };

                                        requestedSkins.Remove(skinId);
                                    }
                                }
                            }

                            SaveUrls();
                            SaveSkinInfo();

                            if (requestedSkins.Count != 0)
                            {
                                Puts($"{requestedSkins.Count} workshop skin ID's for image batch ({title}) are invalid! They may have been removed from the workshop\nIDs: {requestedSkins.ToSentence()}");
                            }
                        }

                        if (page < totalPages)
                            QueueWorkshopDownload(title, newLoadOrderURL, workshopDownloads, page + 1, callback);
                        else
                        {
                            if (newLoadOrderURL.Count > 0)
                            {
                                loadOrders.Enqueue(new LoadOrder(title, newLoadOrderURL, null, false, page < totalPages ? null : callback));
                                if (!orderPending)
                                    ServerMgr.Instance.StartCoroutine(ProcessLoadOrders());
                            }
                            else
                            {
                                if (callback != null)
                                    callback.Invoke();
                            }
                        }
                    }
                },
                this,
                Core.Libraries.RequestMethod.POST);
            }
            catch { }
        }

        #region JSON Response Classes
        public class QueryResponse
        {
            public Response response;
        }

        public class Response
        {
            public int total;
            public PublishedFileDetails[] publishedfiledetails;
        }

        public class PublishedFileDetails
        {
            public int result;
            public string publishedfileid;
            public string creator;
            public int creator_appid;
            public int consumer_appid;
            public int consumer_shortcutid;
            public string filename;
            public string file_size;
            public string preview_file_size;
            public string file_url;
            public string preview_url;
            public string url;
            public string hcontent_file;
            public string hcontent_preview;
            public string title;
            public string file_description;
            public int time_created;
            public int time_updated;
            public int visibility;
            public int flags;
            public bool workshop_file;
            public bool workshop_accepted;
            public bool show_subscribe_all;
            public int num_comments_public;
            public bool banned;
            public string ban_reason;
            public string banner;
            public bool can_be_deleted;
            public string app_name;
            public int file_type;
            public bool can_subscribe;
            public int subscriptions;
            public int favorited;
            public int followers;
            public int lifetime_subscriptions;
            public int lifetime_favorited;
            public int lifetime_followers;
            public string lifetime_playtime;
            public string lifetime_playtime_sessions;
            public int views;
            public int num_children;
            public int num_reports;
            public Preview[] previews;
            public Tag[] tags;
            public int language;
            public bool maybe_inappropriate_sex;
            public bool maybe_inappropriate_violence;

            public class Tag
            {
                public string tag;
                public bool adminonly;
            }

        }

        public class Preview
        {
            public string previewid;
            public int sortorder;
            public string url;
            public int size;
            public string filename;
            public int preview_type;
            public string youtubevideoid;
            public string external_reference;
        }
        #endregion
        #endregion

        #region Commands

        [ConsoleCommand("cancelstorage")]
        private void cmdCancelStorage(ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null || arg.Connection.authLevel > 0)
            {
                if (!orderPending)
                    PrintWarning("No images are currently being downloaded");
                else
                {
                    assets.ClearList();
                    loadOrders.Clear();
                    PrintWarning("Pending image downloads have been cancelled!");
                }
            }
        }

        private List<ulong> pendingAnswers = new List<ulong>();

        [ConsoleCommand("refreshallimages")]
        private void cmdRefreshAllImages(ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null || arg.Connection.authLevel > 0)
            {
                SendReply(arg, "Running this command will wipe all of your ImageLibrary data, meaning every registered image will need to be re-downloaded. Are you sure you wish to continue? (type yes or no)");

                ulong userId = arg.Connection == null || arg.IsRcon ? 0U : arg.Connection.userid;
                if (!pendingAnswers.Contains(userId))
                {
                    pendingAnswers.Add(userId);
                    timer.In(5, () =>
                    {
                        if (pendingAnswers.Contains(userId))
                            pendingAnswers.Remove(userId);
                    });
                }
            }
        }

        [ConsoleCommand("yes")]
        private void cmdRefreshAllImagesYes(ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null || arg.Connection.authLevel > 0)
            {
                ulong userId = arg.Connection == null || arg.IsRcon ? 0U : arg.Connection.userid;
                if (pendingAnswers.Contains(userId))
                {
                    PrintWarning("Wiping ImageLibrary data and redownloading ImageLibrary specific images. All plugins that have registered images via ImageLibrary will need to be re-loaded!");
                    RefreshImagery();

                    pendingAnswers.Remove(userId);
                }
            }
        }

        [ConsoleCommand("no")]
        private void cmdRefreshAllImagesNo(ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null || arg.Connection.authLevel > 0)
            {
                ulong userId = arg.Connection == null || arg.IsRcon ? 0U : arg.Connection.userid;

                if (pendingAnswers.Contains(userId))
                {
                    SendReply(arg, "ImageLibrary data wipe aborted!");
                    pendingAnswers.Remove(userId);
                }
            }
        }

        #endregion Commands

        #region Image Storage

        private struct LoadOrder
        {
            public string loadName;
            public bool loadSilent;

            public Dictionary<string, string> imageList;
            public Dictionary<string, byte[]> imageData;

            public Action callback;

            public LoadOrder(string loadName, Dictionary<string, string> imageList, bool loadSilent = false, Action callback = null)
            {
                this.loadName = loadName;
                this.imageList = imageList;
                this.imageData = null;
                this.loadSilent = loadSilent;
                this.callback = callback;
            }
            public LoadOrder(string loadName, Dictionary<string, byte[]> imageData, bool loadSilent = false, Action callback = null)
            {
                this.loadName = loadName;
                this.imageList = null;
                this.imageData = imageData;
                this.loadSilent = loadSilent;
                this.callback = callback;
            }
            public LoadOrder(string loadName, Dictionary<string, string> imageList, Dictionary<string, byte[]> imageData, bool loadSilent = false, Action callback = null)
            {
                this.loadName = loadName;
                this.imageList = imageList;
                this.imageData = imageData;
                this.loadSilent = loadSilent;
                this.callback = callback;
            }
        }

        private class ImageAssets : MonoBehaviour
        {
            private Queue<QueueItem> queueList = new Queue<QueueItem>();
            private bool isLoading;
            private double nextUpdate;
            private int listCount;
            private string request;

            private Action callback;

            private void OnDestroy()
            {
                queueList.Clear();
            }

            public void Add(string name, string url = null, byte[] bytes = null)
            {
                queueList.Enqueue(new QueueItem(name, url, bytes));
            }

            public void RegisterCallback(Action callback) => this.callback = callback;

            public void BeginLoad(string request)
            {
                this.request = request;
                nextUpdate = UnityEngine.Time.time + il.configData.UpdateInterval;
                listCount = queueList.Count;
                Next();
            }

            public void ClearList()
            {
                queueList.Clear();
                il.orderPending = false;
            }

            private void Next()
            {
                if (queueList.Count == 0)
                {
                    il.orderPending = false;
                    il.SaveData();
                    if (!string.IsNullOrEmpty(request))
                        print($"Image batch ({request}) has been stored successfully");

                    request = string.Empty;
                    listCount = 0;

                    if (callback != null)
                        callback.Invoke();

                    StartCoroutine(il.ProcessLoadOrders());
                    return;
                }
                if (il.configData.ShowProgress && listCount > 1)
                {
                    float time = UnityEngine.Time.time;
                    if (time > nextUpdate)
                    {
                        int amountDone = listCount - queueList.Count;
                        print($"{request} storage process at {Math.Round((amountDone / (float)listCount) * 100, 0)}% ({amountDone}/{listCount})");
                        nextUpdate = time + il.configData.UpdateInterval;
                    }
                }
                isLoading = true;

                QueueItem queueItem = queueList.Dequeue();
                if (!string.IsNullOrEmpty(queueItem.url))
                    StartCoroutine(DownloadImage(queueItem));
                else StoreByteArray(queueItem.bytes, queueItem.name);
            }

            private IEnumerator DownloadImage(QueueItem info)
            {
                UnityWebRequest www = UnityWebRequest.Get(info.url);

                yield return www.SendWebRequest();
                if (il == null) yield break;
                if (www.isNetworkError || www.isHttpError)
                {
                    print(string.Format("Image failed to download! Error: {0} - Image Name: {1} - Image URL: {2}", www.error, info.name, info.url));
                    www.Dispose();
                    isLoading = false;
                    Next();
                    yield break;
                }

                if (www?.downloadHandler?.data != null)
                {
                    Texture2D texture = new Texture2D(2, 2);
                    texture.LoadImage(www.downloadHandler.data);
                    if (texture != null)
                    {
                        bool shouldStore = true;
                        byte[] bytes = texture.EncodeToPNG();

                        if (bytes.Length > 3145728)
                        {
                            Debug.Log($"[ImageLibrary] Failed to store image data for image : {info.name} for equest {request}\nURL: {info.url}\n{bytes.Length} bytes is larger then the allowed transferable size of 3145728 bytes");
                            shouldStore = false;
                        }

                        DestroyImmediate(texture);

                        if (shouldStore)
                            StoreByteArray(bytes, info.name);
                    }
                }
                www.Dispose();
            }

            private void StoreByteArray(byte[] bytes, string name)
            {
                if (bytes != null)
                    il.imageIdentifiers.imageIds[name] = FileStorage.server.Store(bytes, FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID).ToString();
                isLoading = false;
                Next();
            }

            private class QueueItem
            {
                public byte[] bytes;
                public string url;
                public string name;
                public QueueItem(string name, string url = null, byte[] bytes = null)
                {
                    this.bytes = bytes;
                    this.url = url;
                    this.name = name;
                }
            }
        }

        #endregion Image Storage

        #region Config

        private ConfigData configData;

        class ConfigData
        {
            [JsonProperty(PropertyName = "Avatars - Store player avatars")]
            public bool StoreAvatars { get; set; }

            [JsonProperty(PropertyName = "Steam API key (get one here https://steamcommunity.com/dev/apikey)")]
            public string SteamAPIKey { get; set; }

            [JsonProperty(PropertyName = "URL to web folder containing all item icons")]
            public string ImageURL { get; set; }

            [JsonProperty(PropertyName = "Progress - Show download progress in console")]
            public bool ShowProgress { get; set; }

            [JsonProperty(PropertyName = "Progress - Time between update notifications")]
            public int UpdateInterval { get; set; }
            
            [JsonProperty(PropertyName = "User Images - Manually define images to be loaded")]
            public Dictionary<string, string> UserImages { get; set; }

            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();

            if (configData.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                ShowProgress = true,
                SteamAPIKey = string.Empty,
                StoreAvatars = false,
                UpdateInterval = 20,
                ImageURL = "https://www.rustedit.io/images/imagelibrary/",
                UserImages = new Dictionary<string, string>(),
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();

            if (configData.Version < new VersionNumber(2, 0, 47))
                configData = baseConfig;

            if (configData.Version < new VersionNumber(2, 0, 53))
                configData.StoreAvatars = false;

            if (configData.Version < new VersionNumber(2, 0, 55))
                configData.ImageURL = baseConfig.ImageURL;

            configData.Version = Version;
            PrintWarning("Config update completed!");
        }

        #endregion Config

        #region Data Management

        private void SaveData() => identifiers.WriteObject(imageIdentifiers);

        private void SaveSkinInfo() => skininfo.WriteObject(skinInformation);

        private void SaveUrls() => urls.WriteObject(imageUrls);

        private void LoadData()
        {
            try
            {
                imageIdentifiers = identifiers.ReadObject<ImageIdentifiers>();
            }
            catch
            {
                imageIdentifiers = new ImageIdentifiers();
            }
            try
            {
                skinInformation = skininfo.ReadObject<SkinInformation>();
            }
            catch
            {
                skinInformation = new SkinInformation();
            }
            try
            {
                imageUrls = urls.ReadObject<ImageURLs>();
            }
            catch
            {
                imageUrls = new ImageURLs();
            }
            if (skinInformation == null)
                skinInformation = new SkinInformation();
            if (imageIdentifiers == null)
                imageIdentifiers = new ImageIdentifiers();
            if (imageUrls == null)
                imageUrls = new ImageURLs();
        }

        private class ImageIdentifiers
        {
            public ulong lastCEID;
            public Hash<string, string> imageIds = new Hash<string, string>();
        }

        private class SkinInformation
        {
            public Hash<string, Dictionary<string, object>> skinData = new Hash<string, Dictionary<string, object>>();
        }

        private class ImageURLs
        {
            public Hash<string, string> URLs = new Hash<string, string>();
        }


        public class AvatarRoot
        {
            public Response response { get; set; }

            public class Response
            {
                public Player[] players { get; set; }

                public class Player
                {
                    public string steamid { get; set; }
                    public int communityvisibilitystate { get; set; }
                    public int profilestate { get; set; }
                    public string personaname { get; set; }
                    public int lastlogoff { get; set; }
                    public string profileurl { get; set; }
                    public string avatar { get; set; }
                    public string avatarmedium { get; set; }
                    public string avatarfull { get; set; }
                    public int personastate { get; set; }
                    public string realname { get; set; }
                    public string primaryclanid { get; set; }
                    public int timecreated { get; set; }
                    public int personastateflags { get; set; }
                }
            }
        }
        #endregion Data Management
    }
}


// --- End of file: ImageLibrary.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/BStone.cs ---
// --- Original Local Path: BeeRust/BStone.cs ---

using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Oxide.Core;

namespace Oxide.Plugins
{
	[Info("BStone", "King", "1.0.0")]
	public class BStone : RustPlugin
	{
        #region [Oxide-Api]
        private void OnPluginLoaded(Plugin plugin)
        {
            NextTick(() =>
            {
                Unsubscribe("OnDispenserBonus");
                Subscribe("OnDispenserBonus");
            });
        }
        #endregion

        #region [Rust-Api]
        private void OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            if (player == null || item == null)  return;

            Boolean LuckyChance = Oxide.Core.Random.Range(0, 100) >= (100 - config._MainSettings.Rare);
            if (LuckyChance)
            {
                Item Stone = ItemManager.CreateByName(config._MainSettings._BolotoStone.ShortName, 1, config._MainSettings._BolotoStone.SkinID);
                if (Stone == null) return;
                Stone.name = config._MainSettings._BolotoStone.DisplayName;
                if (Stone.MoveToContainer(player.inventory.containerMain))
                    player.Command("note.inv", Stone.info.itemid, Stone.amount,
                        !string.IsNullOrEmpty(Stone.name) ? Stone.name : string.Empty,
                        (Int32)BaseEntity.GiveItemReason.PickedUp);
                else
                    Stone.Drop(player.inventory.containerMain.dropPosition,
                        player.inventory.containerMain.dropVelocity);
            }
        }

        private object OnItemRecycle(Item item, Recycler recycler)
        {
            if (recycler == null || item == null)  return null;

            if (item.info.shortname == config._MainSettings._BolotoStone.ShortName && item.skin == config._MainSettings._BolotoStone.SkinID)
            {
                Int32 RandomCount = Oxide.Core.Random.Range(1, config._MainSettings.ItemAmount);
                for (Int32 i = 0; i < RandomCount; i++)
                {
                    ItemSettings RandomItem = config.GetRandomReward();
                    Item newItem = ItemManager.CreateByName(RandomItem.ShortName, Oxide.Core.Random.Range(RandomItem.MinAmount, RandomItem.MaxAmount), RandomItem.SkinID);
                    if (newItem == null) continue;
                    recycler.MoveItemToOutput(newItem);
                }
                if (item.amount > 1) item.amount--;
                else item.RemoveFromContainer();
                return false;
            }

            return null;
        }
        #endregion

        #region [Config]
        private PluginConfig config;

        protected override void LoadDefaultConfig()
        {
            config = PluginConfig.DefaultConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();

            if (config.PluginVersion < Version)
                UpdateConfigValues();

            Config.WriteObject(config, true);
        }

        private void UpdateConfigValues()
        {
            PluginConfig baseConfig = PluginConfig.DefaultConfig();
            if (config.PluginVersion < Version)
            {
                if (Version == new VersionNumber(1, 0, 0))
                {
                    //
                }

                PrintWarning("Config checked completed!");
            }
            config.PluginVersion = Version;
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        public class ItemSettings
        {
            [JsonProperty("Shortname предмета")]
            public String ShortName;

            [JsonProperty("SkinID")]
            public UInt32 SkinID;

            [JsonProperty("Минимальное количество")]
            public Int32 MinAmount;

            [JsonProperty("Максимальное количество")]
            public Int32 MaxAmount;

            [JsonProperty("Шанс выпадения")]
            public Int32 Rare;
        }

        public class BolotoStone
        {
            [JsonProperty("Shortname предмета")]
            public String ShortName;

            [JsonProperty("Отображаемое имя предмета")]
            public String DisplayName;

            [JsonProperty("SkinID")]
            public UInt32 SkinID;
        }

        public class MainSettings
        {
            [JsonProperty("Настройки болотного камня")]
            public BolotoStone _BolotoStone = new BolotoStone();

            [JsonProperty("Количество предметов которое может выпасть при переработке болотного камня")]
            public Int32 ItemAmount;

            [JsonProperty("Шанс выпадения болотного камня при добывании")]
            public Int32 Rare;
        }

        private class PluginConfig
        {
            [JsonProperty("Настройки маркера")]
            public MainSettings _MainSettings = new MainSettings();

            [JsonProperty("Настройка предметов")]
            public List<ItemSettings> _ItemSettings = new List<ItemSettings>();

            [JsonProperty("Config version")]
            public VersionNumber PluginVersion = new VersionNumber();

			public ItemSettings GetRandomReward()
			{
				Int32 RandomIndex = Oxide.Core.Random.Range(0, 100);
				ItemSettings RandomItem = null;
				    
				foreach (ItemSettings itemSettings in _ItemSettings)
				{					    
					ItemSettings Item = _ItemSettings.GetRandom();
					if (RandomIndex >= Item.Rare) continue;
					    
					RandomItem = Item;
					break;
				}

				return RandomItem ?? (RandomItem = GetRandomReward());
			}

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    _MainSettings = new MainSettings()
                    {
                        _BolotoStone = new BolotoStone()
                        {
                            ShortName = "coal",
                            DisplayName = "Болотный камень",
                            SkinID = 9863321,
                        },
                        ItemAmount = 3,
                        Rare = 50
                    },
                    _ItemSettings = new List<ItemSettings>()
                    {
                        new ItemSettings()
                        {
                            ShortName = "wood",
                            SkinID = 0,
                            MinAmount = 2500,
                            MaxAmount = 5000,
                            Rare = 85
                        },
                        new ItemSettings()
                        {
                            ShortName = "stone",
                            SkinID = 0,
                            MinAmount = 2500,
                            MaxAmount = 3500,
                            Rare = 85
                        },
                        new ItemSettings()
                        {
                            ShortName = "sulfur",
                            SkinID = 0,
                            MinAmount = 1500,
                            MaxAmount = 2500,
                            Rare = 75
                        }
                    },
                    PluginVersion = new VersionNumber()
                };
            }
        }
        #endregion
    }
}

// --- End of file: BStone.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/CustomVendingSetup.cs ---
// --- Original Local Path: BeeRust/CustomVendingSetup.cs ---

﻿using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Globalization;
using System.Linq;
using System.Runtime.Serialization;
using Facepunch;
using UnityEngine;
using VLB;
using static ProtoBuf.VendingMachine;
using static VendingMachine;

using CustomGetDataCallback = System.Func<Newtonsoft.Json.Linq.JObject>;
using CustomSaveDataCallback = System.Action<Newtonsoft.Json.Linq.JObject>;

namespace Oxide.Plugins
{
    [Info("Custom Vending Setup", "WhiteThunder", "2.10.2")]
    [Description("Allows editing orders at NPC vending machines.")]
    internal class CustomVendingSetup : CovalencePlugin
    {
        #region Fields

        [PluginReference]
        private readonly Plugin BagOfHolding, Economics, ItemRetriever, MonumentFinder, ServerRewards;

        private SavedData _pluginData;
        private Configuration _config;

        private const string PermissionUse = "customvendingsetup.use";

        private const string StoragePrefab = "assets/prefabs/deployable/large wood storage/box.wooden.large.prefab";

        private const int ItemsPerRow = 6;
        private const int InventorySize = 24;

        // Going over 7 causes offers to get cut off regardless of resolution.
        private const int MaxVendingOffers = 7;

        private const int ShopNameNoteSlot = 29;
        private const int ContainerCapacity = 30;
        private const int MaxItemRows = ContainerCapacity / ItemsPerRow;
        private const int BlueprintItemId = -996920608;
        private const float MinCurrencyCondition = 0.5f;

        private readonly object True = true;
        private readonly object False = false;

        private ItemRetrieverAdapter _itemRetrieverAdapter;
        private DataProviderRegistry _dataProviderRegistry = new DataProviderRegistry();
        private ComponentTracker<NPCVendingMachine, VendingMachineComponent> _componentTracker = new ComponentTracker<NPCVendingMachine, VendingMachineComponent>();
        private ComponentFactory<NPCVendingMachine, VendingMachineComponent> _componentFactory;
        private MonumentFinderAdapter _monumentFinderAdapter;
        private VendingMachineManager _vendingMachineManager;
        private BagOfHoldingLimitManager _bagOfHoldingLimitManager;
        private DynamicHookSubscriber<BaseVendingController> _inaccessibleVendingMachines;
        private DynamicHookSubscriber<BasePlayer> _playersNeedingFakeInventory;
        private PaymentProviderResolver _paymentProviderResolver;

        private ItemDefinition _noteItemDefinition;
        private bool _isServerInitialized;
        private bool _performingInstantRestock;
        private VendingItem _itemBeingSold;
        private Dictionary<string, object> _itemRetrieverQuery = new Dictionary<string, object>();
        private List<Item> _reusableItemList = new List<Item>();
        private object[] _objectArray1 = new object[1];
        private object[] _objectArray2 = new object[2];

        public CustomVendingSetup()
        {
            _monumentFinderAdapter = new MonumentFinderAdapter(this);
            _itemRetrieverAdapter = new ItemRetrieverAdapter(this);
            _componentFactory = new ComponentFactory<NPCVendingMachine, VendingMachineComponent>(this, _componentTracker);
            _vendingMachineManager = new VendingMachineManager(this, _componentFactory, _dataProviderRegistry);
            _bagOfHoldingLimitManager = new BagOfHoldingLimitManager(this);
            _paymentProviderResolver = new PaymentProviderResolver(this);
            _inaccessibleVendingMachines = new DynamicHookSubscriber<BaseVendingController>(this, nameof(CanAccessVendingMachine));
            _playersNeedingFakeInventory = new DynamicHookSubscriber<BasePlayer>(this, nameof(OnEntitySaved), nameof(OnInventoryNetworkUpdate));
        }

        #endregion

        #region Hooks

        private void Init()
        {
            _config.Init();
            _pluginData = SavedData.Load();

            permission.RegisterPermission(PermissionUse, this);

            Unsubscribe(nameof(OnEntitySpawned));

            _inaccessibleVendingMachines.UnsubscribeAll();
            _playersNeedingFakeInventory.UnsubscribeAll();
        }

        private void OnServerInitialized()
        {
            _isServerInitialized = true;

            if (MonumentFinder == null)
            {
                LogError("MonumentFinder is not loaded, get it at http://umod.org.");
            }
            else
            {
                // Delay to allow Monument Finder to register monuments via its `OnServerInitialized()` hook.
                NextTick(() =>
                {
                    _vendingMachineManager.SetupAll();

                    foreach (var player in BasePlayer.activePlayerList)
                    {
                        var container = player.inventory.loot.containers.FirstOrDefault();
                        if (container == null)
                            continue;

                        var vendingMachine = container.entityOwner as NPCVendingMachine;
                        if (vendingMachine != null)
                        {
                            OnVendingShopOpened(vendingMachine, player);
                        }
                    }
                });
            }

            if (ItemRetriever != null)
            {
                _itemRetrieverAdapter.HandleItemRetrieverLoaded();
            }

            _bagOfHoldingLimitManager.OnServerInitialized();

            Subscribe(nameof(OnEntitySpawned));

            _noteItemDefinition = ItemManager.FindItemDefinition("note");
        }

        private void Unload()
        {
            _vendingMachineManager.ResetAll();
            ObjectCache.Clear<int>();
            ObjectCache.Clear<float>();
            ObjectCache.Clear<ulong>();
        }

        private void OnPluginLoaded(Plugin plugin)
        {
            switch (plugin.Name)
            {
                case nameof(MonumentFinder):
                {
                    // Check whether initialized to detect only late (re)loads.
                    // Note: We are not dynamically subscribing to OnPluginLoaded since that interferes with the PluginReference attribute.
                    if (_isServerInitialized)
                    {
                        // Delay to ensure MonumentFinder's `OnServerInitialized` method is called.
                        NextTick(_vendingMachineManager.SetupAll);
                    }
                    return;
                }

                case nameof(BagOfHolding):
                    _bagOfHoldingLimitManager.HandleBagOfHoldingLoadedChanged();
                    return;

                case nameof(ItemRetriever):
                    _itemRetrieverAdapter.HandleItemRetrieverLoaded();
                    return;
            }
        }

        private void OnPluginUnloaded(Plugin plugin)
        {
            switch (plugin.Name)
            {
                case nameof(ItemRetriever):
                    _itemRetrieverAdapter.HandleItemRetrieverUnloaded();
                    return;
            }
        }

        private void OnEntitySpawned(NPCVendingMachine vendingMachine)
        {
            // Delay to give other plugins a chance to save a reference so they can block setup.
            NextTick(() =>
            {
                if (vendingMachine == null || vendingMachine.IsDestroyed)
                    return;

                _vendingMachineManager.HandleVendingMachineSpawned(vendingMachine);
            });
        }

        private void OnEntityKill(NPCVendingMachine vendingMachine)
        {
            _vendingMachineManager.HandleVendingMachineKilled(vendingMachine);
        }

        private void OnVendingShopOpened(NPCVendingMachine vendingMachine, BasePlayer player)
        {
            var controller = _vendingMachineManager.GetController(vendingMachine);
            if (controller == null)
                return;

            var component = _componentTracker.GetComponent(vendingMachine);
            if (component == null)
                return;

            if (permission.UserHasPermission(player.UserIDString, PermissionUse))
            {
                component.ShowAdminUI(player);
            }

            var profile = controller.Profile;
            if (profile?.Offers == null)
                return;

            if (_config.ShopUISettings.EnableSkinOverlays)
            {
                component.ShowShopUI(player);
            }

            if ((_config.Economics.EnabledAndValid && profile.HasPaymentProviderCurrency(_config.Economics))
                || (_config.ServerRewards.EnabledAndValid && profile.HasPaymentProviderCurrency(_config.ServerRewards)))
            {
                // Make sure OnEntitySaved/OnInventoryNetworkUpdate are subscribed to modify network updates.
                _playersNeedingFakeInventory.Add(player);

                // Mark inventory dirty to send a network update, which will be modified by hooks.
                player.inventory.containerMain.MarkDirty();
            }
        }

        private object OnVendingTransaction(NPCVendingMachine vendingMachine, BasePlayer player, int sellOrderIndex, int numberOfTransactions, ItemContainer targetContainer)
        {
            var vendingProfile = _vendingMachineManager.GetController(vendingMachine)?.Profile;
            if (vendingProfile?.Offers == null)
            {
                // Don't override the transaction logic because the vending machine is not customized by this plugin.
                return null;
            }

            var component = _componentTracker.GetComponent(vendingMachine);
            if (component == null)
                return null;

            var offer = vendingProfile.GetOfferForSellOrderIndex(sellOrderIndex);
            if (offer == null)
            {
                // Something is wrong. No valid offer exists at the specified index.
                return null;
            }

            numberOfTransactions = Mathf.Clamp(numberOfTransactions, 1, HasCondition(offer.SellItem.ItemDefinition) ? 1 : 1000000);

            var sellAmount = offer.SellItem.Amount * numberOfTransactions;
            var sellItemQuery = ItemQuery.FromSellItem(offer.SellItem);
            if (ItemUtils.SumContainerItems(vendingMachine.inventory, ref sellItemQuery) < sellAmount)
            {
                // The vending machine has insufficient stock.
                return False;
            }

            var currencyAmount = offer.CurrencyItem.Amount * numberOfTransactions;
            var currencyProvider = _paymentProviderResolver.Resolve(offer.CurrencyItem);
            if (currencyProvider.GetBalance(player) < currencyAmount)
            {
                // The player has insufficient currency.
                return False;
            }

            _reusableItemList.Clear();
            currencyProvider.TakeBalance(player, currencyAmount, _reusableItemList);

            var onMarketplaceItemPurchase = (targetContainer?.entityOwner as MarketTerminal)?._onItemPurchasedCached;

            // Note: The list will be empty if Economics or Server Rewards currency were used.
            foreach (var currencyItem in _reusableItemList)
            {
                MaybeGiveWeaponAmmo(currencyItem, player);

                // Show a notice on the marketplace UI that the item was taken.
                onMarketplaceItemPurchase?.Invoke(player, currencyItem);

                // Instead of calling `vendingMachine.TakeCurrencyItem(itemToTake)`, just remove the item.
                // This fixes an "issue" where the item would go into the vending machine storage if there was a matching stack.
                // Note: The "OnTakeCurrencyItem" hook is not called because Item Retriever always takes the items.
                currencyItem.RemoveFromContainer();
                currencyItem.Remove();
            }

            _reusableItemList.Clear();

            if (offer.RefillDelay <= 0)
            {
                // Don't change the stock amount. Instead, we will just leave the items in the vending machine.
                // The "CanVendingStockRefill" hook will use this flag to skip all logic.
                _performingInstantRestock = true;
            }
            else
            {
                // The "CanVendingStockRefill" hook may use this to add stock.
                _itemBeingSold = offer.SellItem;
            }

            _paymentProviderResolver.Resolve(offer.SellItem).AddBalance(player, sellAmount, new TransactionContext
            {
                VendingMachine = vendingMachine,
                SellItem = offer.SellItem,
                TargetContainer = targetContainer,
                OnMarketplaceItemPurchase = onMarketplaceItemPurchase,
            });

            // These can now be unset since the "CanVendingStockRefill" hook can no longer be called after this point.
            _performingInstantRestock = false;
            _itemBeingSold = null;

            if (offer.RefillDelay > 0)
            {
                // Remove stock only after the items have been given to the player,
                // so that max stack size can be determined by an item in stock.
                ItemUtils.TakeContainerItems(vendingMachine.inventory, ref sellItemQuery, sellAmount);
            }

            vendingMachine.UpdateEmptyFlag();

            // Reopen the UI if it was closed due to a transaction delay.
            if (!component.HasUI(player) && IsLootingVendingMachine(player, vendingMachine))
            {
                OnVendingShopOpened(vendingMachine, player);
            }

            if (offer.CustomSettings?.Count > 0)
            {
                ExposedHooks.OnCustomVendingSetupTransactionWithCustomSettings(vendingMachine, offer.CustomSettings);
            }

            return True;
        }

        private void OnBuyVendingItem(NPCVendingMachine vendingMachine, BasePlayer player, int sellOrderID, int amount)
        {
            if (!IsCustomized(vendingMachine))
                return;

            var component = _componentTracker.GetComponent(vendingMachine);
            if (component == null)
                return;

            ScheduleRemoveUI(vendingMachine, player, component);
        }

        // This hook is exposed by plugin: Vending In Stock (VendingInStock).
        private object CanVendingStockRefill(NPCVendingMachine vendingMachine, Item soldItem, BasePlayer player)
        {
            if (!IsCustomized(vendingMachine))
            {
                // Allow VendingInStock to restock the item.
                return null;
            }

            if (_performingInstantRestock)
            {
                // Don't restock the item, since it was never removed from the vending machine in the first place.
                return False;
            }

            // Override VendingInStock behavior to prevent creating new items in the container.
            // This also ensures additional item attributes are preserved.
            var itemQuery = ItemQuery.FromSellItem(_itemBeingSold);
            var existingItem = ItemUtils.FindFirstContainerItem(vendingMachine.inventory, ref itemQuery);
            if (existingItem != null)
            {
                existingItem.amount += soldItem.amount;
                existingItem.MarkDirty();
                return False;
            }

            if (_itemBeingSold == null)
            {
                // Something is wrong. The "CanPurchaseItem" hook was not called via this plugin.
                return null;
            }

            var newItem = _itemBeingSold.Create(soldItem.amount);
            vendingMachine.transactionActive = true;
            if (!newItem.MoveToContainer(vendingMachine.inventory, allowStack: false))
            {
                newItem.Remove();
            }
            vendingMachine.transactionActive = false;

            return False;
        }

        private object CanAccessVendingMachine(DeliveryDroneConfig deliveryDroneConfig, NPCVendingMachine vendingMachine)
        {
            if (!vendingMachine.IsBroadcasting())
                return null;

            var controller = _vendingMachineManager.GetController(vendingMachine);
            if (controller == null)
                return null;

            if (_inaccessibleVendingMachines.Contains(controller))
                return False;

            return null;
        }

        private void OnEntitySaved(BasePlayer player, BaseNetworkable.SaveInfo saveInfo)
        {
            AddCurrencyToContainerSnapshot(player, saveInfo.msg.basePlayer.inventory.invMain);
        }

        private void OnInventoryNetworkUpdate(PlayerInventory inventory, ItemContainer container, ProtoBuf.UpdateItemContainer updatedItemContainer, PlayerInventory.Type inventoryType)
        {
            if (inventoryType != PlayerInventory.Type.Main)
                return;

            AddCurrencyToContainerSnapshot(inventory.baseEntity, updatedItemContainer.container[0]);
        }

        #endregion

        #region API

        private bool API_IsCustomized(NPCVendingMachine vendingMachine)
        {
            return IsCustomized(vendingMachine);
        }

        private void API_RefreshDataProvider(NPCVendingMachine vendingMachine)
        {
            _vendingMachineManager.HandleVendingMachineKilled(vendingMachine);
            _vendingMachineManager.HandleVendingMachineSpawned(vendingMachine);
        }

        // Undocumented. Intended for MonumentAddons migration to become a Data Provider.
        private JObject API_MigrateVendingProfile(NPCVendingMachine vendingMachine)
        {
            var location = MonumentRelativePosition.FromVendingMachine(_monumentFinderAdapter, vendingMachine);
            if (location == null)
            {
                // This can happen if a vending machine was moved outside a monument's bounds.
                return null;
            }

            var vendingProfile = _pluginData.FindProfile(location);
            if (vendingProfile == null)
            {
                return null;
            }

            JObject jObject;

            try
            {
                jObject = JObject.FromObject(vendingProfile);
            }
            catch (Exception e)
            {
                LogError($"Unable to migrate vending profile\n{e}");
                return null;
            }

            _pluginData.VendingProfiles.Remove(vendingProfile);
            _pluginData.Save();

            return jObject;
        }

        #endregion

        #region Dependencies

        private class MonumentAdapter
        {
            public string PrefabName => (string)_monumentInfo["PrefabName"];
            public string Alias => (string)_monumentInfo["Alias"];
            public Vector3 Position => (Vector3)_monumentInfo["Position"];

            private Dictionary<string, object> _monumentInfo;

            public MonumentAdapter(Dictionary<string, object> monumentInfo)
            {
                _monumentInfo = monumentInfo;
            }

            public Vector3 InverseTransformPoint(Vector3 worldPosition) =>
                ((Func<Vector3, Vector3>)_monumentInfo["InverseTransformPoint"]).Invoke(worldPosition);

            public bool IsInBounds(Vector3 position) =>
                ((Func<Vector3, bool>)_monumentInfo["IsInBounds"]).Invoke(position);
        }

        private class MonumentFinderAdapter
        {
            private CustomVendingSetup _plugin;
            private Plugin _monumentFinder => _plugin.MonumentFinder;

            public MonumentFinderAdapter(CustomVendingSetup plugin)
            {
                _plugin = plugin;
            }

            public MonumentAdapter GetMonumentAdapter(Vector3 position)
            {
                var dictResult = _monumentFinder?.Call("API_GetClosest", position) as Dictionary<string, object>;
                if (dictResult == null)
                    return null;

                var monument = new MonumentAdapter(dictResult);
                return monument.IsInBounds(position) ? monument : null;
            }

            public MonumentAdapter GetMonumentAdapter(BaseEntity entity)
            {
                return GetMonumentAdapter(entity.transform.position);
            }
        }

        private class BagOfHoldingLimitManager
        {
            private class CustomLimitProfile
            {
                [JsonProperty("Max total bags")]
                public int MaxTotalBags = -1;
            }

            private CustomVendingSetup _plugin;
            private object _limitProfile;

            public BagOfHoldingLimitManager(CustomVendingSetup plugin)
            {
                _plugin = plugin;
            }

            public void OnServerInitialized()
            {
                HandleBagOfHoldingLoadedChanged();
            }

            public void HandleBagOfHoldingLoadedChanged()
            {
                if (_plugin.BagOfHolding == null)
                    return;

                _limitProfile = _plugin.BagOfHolding.Call("API_CreateLimitProfile", JsonConvert.SerializeObject(new CustomLimitProfile()));

                if (_limitProfile == null)
                {
                    LogError("Failed to create limit profile.");
                }
            }

            public void SetLimitProfile(ItemContainer container)
            {
                if (_limitProfile == null || _plugin.BagOfHolding == null)
                    return;

                var result = _plugin.BagOfHolding.Call("API_SetLimitProfile", container, _limitProfile);
                if (!(result is bool) || (bool)result == false)
                {
                    LogError("Failed to set limit profile for vending container");
                }
            }

            public void RemoveLimitProfile(ItemContainer container)
            {
                if (_limitProfile == null || _plugin.BagOfHolding == null)
                    return;

                _plugin.BagOfHolding.Call("API_RemoveLimitProfile", container);
            }
        }

        private class ItemRetrieverApi
        {
            public Func<BasePlayer, Dictionary<string, object>, int> SumPlayerItems { get; }
            public Func<BasePlayer, Dictionary<string, object>, int, List<Item>, int> TakePlayerItems { get; }

            public ItemRetrieverApi(Dictionary<string, object> apiDict)
            {
                SumPlayerItems = apiDict[nameof(SumPlayerItems)] as Func<BasePlayer, Dictionary<string, object>, int>;
                TakePlayerItems = apiDict[nameof(TakePlayerItems)] as Func<BasePlayer, Dictionary<string, object>, int, List<Item>, int>;
            }
        }

        private class ItemRetrieverAdapter
        {
            public ItemRetrieverApi Api { get; private set; }

            private CustomVendingSetup _plugin;

            private Plugin ItemRetriever => _plugin.ItemRetriever;

            public ItemRetrieverAdapter(CustomVendingSetup plugin)
            {
                _plugin = plugin;
            }

            public void HandleItemRetrieverLoaded()
            {
                Api = new ItemRetrieverApi(ItemRetriever.Call("API_GetApi") as Dictionary<string, object>);
            }

            public void HandleItemRetrieverUnloaded()
            {
                Api = null;
            }
        }

        #endregion

        #region Exposed Hooks

        private static class ExposedHooks
        {
            public static object OnCustomVendingSetup(NPCVendingMachine vendingMachine)
            {
                return Interface.CallHook("OnCustomVendingSetup", vendingMachine);
            }

            public static object CanPurchaseItem(BasePlayer player, Item item, Action<BasePlayer, Item> onItemPurchased, NPCVendingMachine vendingMachine, ItemContainer targetContainer)
            {
                return Interface.CallHook("CanPurchaseItem", player, item, onItemPurchased, vendingMachine, targetContainer);
            }

            public static Dictionary<string, object> OnCustomVendingSetupDataProvider(NPCVendingMachine vendingMachine)
            {
                return Interface.CallHook("OnCustomVendingSetupDataProvider", vendingMachine) as Dictionary<string, object>;
            }

            public static void OnCustomVendingSetupOfferSettingsParse(CaseInsensitiveDictionary<string> localizedSettings, CaseInsensitiveDictionary<object> customSettings)
            {
                Interface.CallHook("OnCustomVendingSetupOfferSettingsParse", localizedSettings, customSettings);
            }

            public static void OnCustomVendingSetupOfferSettingsDisplay(CaseInsensitiveDictionary<object> customSettings, CaseInsensitiveDictionary<string> localizedSettings)
            {
                Interface.CallHook("OnCustomVendingSetupOfferSettingsDisplay", customSettings, localizedSettings);
            }

            public static void OnCustomVendingSetupTransactionWithCustomSettings(NPCVendingMachine vendingMachine, CaseInsensitiveDictionary<object> customSettings)
            {
                Interface.CallHook("OnCustomVendingSetupTransactionWithCustomSettings", vendingMachine, customSettings);
            }
        }

        #endregion

        #region Commands

        private static class UICommands
        {
            public const string Edit = "edit";
            public const string Reset = "reset";
            public const string Save = "save";
            public const string Cancel = "cancel";
            public const string ToggleBroadcast = "togglebroadcast";
            public const string ToggleDroneAccessible = "toggledroneaccessible";
        }

        [Command("customvendingsetup.ui")]
        private void CommandUI(IPlayer player, string cmd, string[] args)
        {
            if (args.Length < 2)
                return;

            NPCVendingMachine vendingMachine;
            BaseVendingController vendingController;
            if (!PassesUICommandChecks(player, args, out vendingMachine, out vendingController))
                return;

            var basePlayer = player.Object as BasePlayer;
            var subCommand = args[1];

            switch (subCommand)
            {
                case UICommands.Edit:
                    if (vendingController.EditController != null)
                    {
                        basePlayer.EndLooting();
                        ChatMessage(basePlayer, Lang.ErrorCurrentlyBeingEdited, vendingController.EditController.EditorPlayer.displayName);
                        return;
                    }

                    vendingController.StartEditing(basePlayer, vendingMachine);
                    break;

                case UICommands.Reset:
                    vendingController.HandleReset();
                    vendingMachine.FullUpdate();
                    basePlayer.EndLooting();
                    basePlayer.inventory.loot.SendImmediate();
                    OpenVendingMachineDelayed(basePlayer, vendingMachine);
                    break;

                case UICommands.ToggleBroadcast:
                    vendingController.EditController?.ToggleBroadcast();
                    break;

                case UICommands.ToggleDroneAccessible:
                    vendingController.EditController?.ToggleDroneAccessible();
                    break;

                case UICommands.Save:
                    vendingController.HandleSave(vendingMachine);
                    vendingMachine.FullUpdate();
                    OpenVendingMachine(basePlayer, vendingMachine);
                    break;

                case UICommands.Cancel:
                    OpenVendingMachine(basePlayer, vendingMachine);
                    break;
            }
        }

        #endregion

        #region Helper Methods

        public static void LogInfo(string message) => Interface.Oxide.LogInfo($"[Custom Vending Setup] {message}");
        public static void LogError(string message) => Interface.Oxide.LogError($"[Custom Vending Setup] {message}");
        public static void LogWarning(string message) => Interface.Oxide.LogWarning($"[Custom Vending Setup] {message}");

        private static bool IsLootingVendingMachine(BasePlayer player, NPCVendingMachine vendingMachine)
        {
            return player.inventory.loot.containers.FirstOrDefault()?.entityOwner == vendingMachine;
        }

        private static bool AreVectorsClose(Vector3 a, Vector3 b, float xZTolerance = 0.001f, float yTolerance = 10)
        {
            // Allow a generous amount of vertical distance given that plugins may snap entities to terrain.
            return Math.Abs(a.y - b.y) < yTolerance
                && Math.Abs(a.x - b.x) < xZTolerance
                && Math.Abs(a.z - b.z) < xZTolerance;
        }

        private static bool HasCondition(ItemDefinition itemDefinition)
        {
            return itemDefinition.condition.enabled && itemDefinition.condition.max > 0;
        }

        private static void OpenVendingMachine(BasePlayer player, NPCVendingMachine vendingMachine)
        {
            if (vendingMachine.OccupiedCheck(player) && Interface.CallHook("OnVendingShopOpen", vendingMachine, player) == null)
            {
                vendingMachine.SendSellOrders(player);
                vendingMachine.PlayerOpenLoot(player, vendingMachine.customerPanel);
                Interface.CallHook(nameof(OnVendingShopOpened), vendingMachine, player);
            }
        }

        private static VendingOffer[] GetOffersFromVendingMachine(NPCVendingMachine vendingMachine)
        {
            var vanillaOffers = vendingMachine.sellOrders.sellOrders;
            var offers = new VendingOffer[vanillaOffers.Count];

            for (var i = 0; i < offers.Length; i++)
            {
                var manifestEntry = vendingMachine.vendingOrders.orders.ElementAtOrDefault(i);
                offers[i] = VendingOffer.FromVanillaSellOrder(vanillaOffers[i], manifestEntry);
            }

            return offers;
        }

        private static VendingOffer[] GetOffersFromContainer(CustomVendingSetup plugin, BasePlayer player, ItemContainer container)
        {
            var offers = new List<VendingOffer>();

            for (var columnIndex = 0; columnIndex < 2; columnIndex++)
            {
                for (var rowIndex = 0; rowIndex < MaxItemRows; rowIndex++)
                {
                    var sellItemSlot = rowIndex * ItemsPerRow + columnIndex * 3;

                    var sellItem = container.GetSlot(sellItemSlot);
                    var currencyItem = container.GetSlot(sellItemSlot + 1);
                    var settingsItem = container.GetSlot(sellItemSlot + 2);
                    if (sellItem == null || currencyItem == null)
                        continue;

                    offers.Add(VendingOffer.FromItems(plugin, player, sellItem, currencyItem, settingsItem));
                }
            }

            return offers.ToArray();
        }

        private static StorageContainer CreateContainerEntity(string prefabPath)
        {
            var entity = GameManager.server.CreateEntity(prefabPath);
            if (entity == null)
                return null;

            var container = entity as StorageContainer;
            if (container == null)
            {
                UnityEngine.Object.Destroy(entity);
                return null;
            }

            UnityEngine.Object.DestroyImmediate(container.GetComponent<DestroyOnGroundMissing>());
            UnityEngine.Object.DestroyImmediate(container.GetComponent<GroundWatch>());

            container.limitNetworking = true;
            container.EnableSaving(false);
            container.Spawn();

            return container;
        }

        private static int OrderIndexToSlot(int orderIndex)
        {
            if (orderIndex < MaxItemRows)
                return orderIndex * ItemsPerRow;

            return (orderIndex % MaxItemRows) * ItemsPerRow + 3;
        }

        private static string CreateNoteContents(Dictionary<string, string> settingsMap)
        {
            var lines = new List<string>();
            foreach (var entry in settingsMap)
            {
                lines.Add($"{entry.Key}: {entry.Value}");
            }
            return string.Join("\n", lines);
        }

        private static StorageContainer CreateOrdersContainer(CustomVendingSetup plugin, BasePlayer player, VendingOffer[] vendingOffers, string shopName)
        {
            var containerEntity = CreateContainerEntity(StoragePrefab);

            var container = containerEntity.inventory;
            container.allowedContents = ItemContainer.ContentsType.Generic;
            container.capacity = ContainerCapacity;

            plugin._bagOfHoldingLimitManager.SetLimitProfile(container);

            for (var orderIndex = 0; orderIndex < vendingOffers.Length && orderIndex < 9; orderIndex++)
            {
                var offer = vendingOffers[orderIndex];
                var sellItem = offer.SellItem.Create();
                if (sellItem == null)
                    continue;

                var currencyItem = offer.CurrencyItem.Create();
                if (currencyItem == null)
                {
                    sellItem.Remove();
                    continue;
                }

                var destinationSlot = OrderIndexToSlot(orderIndex);

                if (!sellItem.MoveToContainer(container, destinationSlot))
                    sellItem.Remove();

                if (!currencyItem.MoveToContainer(container, destinationSlot + 1))
                    currencyItem.Remove();
            }

            // Add 7 note items, so the user doesn't have to make them.
            for (var orderIndex = 0; orderIndex < 7; orderIndex++)
            {
                var offer = vendingOffers.Length > orderIndex
                    ? vendingOffers[orderIndex]
                    : null;

                var settingsItem = ItemManager.Create(plugin._noteItemDefinition);
                if (settingsItem == null)
                    continue;

                var refillMaxLabel = plugin.GetMessage(player, Lang.SettingsRefillMax);
                var refillDelayLabel = plugin.GetMessage(player, Lang.SettingsRefillDelay);
                var refillAmountLabel = plugin.GetMessage(player, Lang.SettingsRefillAmount);

                var settingsMap = new CaseInsensitiveDictionary<string>
                {
                    [refillMaxLabel] = (offer?.RefillMax ?? VendingOffer.DefaultRefillMax).ToString(),
                    [refillDelayLabel] = (offer?.RefillDelay ?? VendingOffer.DefaultRefillDelay).ToString(),
                    [refillAmountLabel] = (offer?.RefillAmount ?? VendingOffer.DefaultRefillAmount).ToString(),
                };

                // Allow other plugins to parse the custom settings and display localized options.
                ExposedHooks.OnCustomVendingSetupOfferSettingsDisplay(
                    offer?.CustomSettings ?? new CaseInsensitiveDictionary<object>(), settingsMap);

                settingsItem.text = CreateNoteContents(settingsMap);

                var destinationSlot = OrderIndexToSlot(orderIndex);

                if (!settingsItem.MoveToContainer(container, destinationSlot + 2))
                    settingsItem.Remove();
            }

            var generalSettingsItem = ItemManager.Create(plugin._noteItemDefinition);
            if (generalSettingsItem != null)
            {
                generalSettingsItem.text = shopName;
                if (!generalSettingsItem.MoveToContainer(container, ShopNameNoteSlot))
                    generalSettingsItem.Remove();
            }

            return containerEntity;
        }

        private static void MaybeGiveWeaponAmmo(Item item, BasePlayer player)
        {
            var heldEntity = item.GetHeldEntity();
            if (heldEntity == null)
                return;

            if (heldEntity.creationFrame == Time.frameCount)
            {
                // The item was probably split off another item, so don't refund its ammo.
                return;
            }

            var baseProjectile = heldEntity as BaseProjectile;
            if ((object)baseProjectile != null)
            {
                var ammoType = baseProjectile.primaryMagazine?.ammoType;
                if (ammoType != null && baseProjectile.primaryMagazine.contents > 0)
                {
                    var ammoItem = ItemManager.Create(ammoType, baseProjectile.primaryMagazine.contents);
                    if (ammoItem != null)
                    {
                        player.GiveItem(ammoItem);
                    }
                }
                return;
            }

            var flameThrower = heldEntity as FlameThrower;
            if ((object)flameThrower != null)
            {
                if (flameThrower.fuelType != null && flameThrower.ammo > 0)
                {
                    var ammoItem = ItemManager.Create(flameThrower.fuelType, flameThrower.ammo);
                    if (ammoItem != null)
                    {
                        player.GiveItem(ammoItem);
                    }
                }
            }
        }

        private static void GiveSoldItem(Item item, BasePlayer player, ref TransactionContext transaction)
        {
            var vendingMachine = transaction.VendingMachine;
            var targetContainer = transaction.TargetContainer;

            // Unset the placeholder flag to allow Enchanted Items to transform the artifact.
            item.SetFlag(Item.Flag.Placeholder, false);

            if (targetContainer == null)
            {
                vendingMachine.GiveSoldItem(item, player);
            }
            else if (!item.MoveToContainer(targetContainer))
            {
                item.Drop(targetContainer.dropPosition, targetContainer.dropVelocity);
            }

            transaction.OnMarketplaceItemPurchase?.Invoke(player, item);
        }

        private static int GetHighestUsedSlot(ProtoBuf.ItemContainer containerData)
        {
            var highestUsedSlot = -1;

            for (var i = 0; i < containerData.contents.Count; i++)
            {
                var item = containerData.contents[i];
                if (item.slot > highestUsedSlot)
                {
                    highestUsedSlot = item.slot;
                }
            }

            return highestUsedSlot;
        }

        private static void AddItemForNetwork(ProtoBuf.ItemContainer containerData, int slot, int itemId, int amount, ItemId uid)
        {
            var itemData = Pool.Get<ProtoBuf.Item>();
            itemData.slot = slot;
            itemData.itemid = itemId;
            itemData.amount = amount;
            itemData.UID = uid;
            containerData.contents.Add(itemData);
        }

        private object CallPlugin<T1>(Plugin plugin, string methodName, T1 arg1)
        {
            _objectArray1[0] = ObjectCache.Get(arg1);
            return plugin.Call(methodName, _objectArray1);
        }

        private object CallPlugin<T1, T2>(Plugin plugin, string methodName, T1 arg1, T2 arg2)
        {
            _objectArray2[0] = ObjectCache.Get(arg1);
            _objectArray2[1] = ObjectCache.Get(arg2);
            return plugin.Call(methodName, _objectArray2);
        }

        private void ScheduleRemoveUI(NPCVendingMachine vendingMachine, BasePlayer player, VendingMachineComponent component)
        {
            component.Invoke(() =>
            {
                if (vendingMachine == null || vendingMachine.IsDestroyed)
                    return;

                if (IsLootingVendingMachine(player, vendingMachine) &&
                    !vendingMachine.IsInvoking(vendingMachine.CompletePendingOrder))
                    return;

                // Remove the UI because the player stopped viewing the vending machine or the transaction is pending.
                component.RemoveUI(player);
            }, 0);
        }

        private void AddCurrencyToContainerSnapshot(BasePlayer player, ProtoBuf.ItemContainer containerData)
        {
            if (containerData == null
                || containerData.slots < InventorySize
                || !_playersNeedingFakeInventory.Contains(player))
                return;

            var lootingContainer = player.inventory.loot.containers.FirstOrDefault();
            var vendingMachine = lootingContainer?.entityOwner as NPCVendingMachine;
            if ((object)vendingMachine == null)
                return;

            var profile = _componentTracker.GetComponent(vendingMachine)?.Profile;
            if (profile == null)
                return;

            var nextInvisibleSlot = Math.Max(containerData.slots, GetHighestUsedSlot(containerData) + 1);

            if (_config.Economics.EnabledAndValid && profile.HasPaymentProviderCurrency(_config.Economics))
            {
                AddItemForNetwork(
                    containerData,
                    slot: nextInvisibleSlot,
                    itemId: _config.Economics.ItemDefinition.itemid,
                    amount: _paymentProviderResolver.EconomicsPaymentProvider.GetBalance(player),
                    uid: new ItemId(ulong.MaxValue - (ulong)nextInvisibleSlot)
                );
                nextInvisibleSlot++;
            }

            if (_config.ServerRewards.EnabledAndValid && profile.HasPaymentProviderCurrency(_config.ServerRewards))
            {
                AddItemForNetwork(
                    containerData,
                    slot: nextInvisibleSlot,
                    itemId: _config.ServerRewards.ItemDefinition.itemid,
                    amount: _paymentProviderResolver.ServerRewardsPaymentProvider.GetBalance(player),
                    uid: new ItemId(ulong.MaxValue - (ulong)nextInvisibleSlot)
                );
                nextInvisibleSlot++;
            }

            containerData.slots = nextInvisibleSlot;
        }

        private Dictionary<string, object> SetupItemRetrieverQuery(ref ItemQuery itemQuery)
        {
            _itemRetrieverQuery.Clear();
            _itemRetrieverQuery["MinCondition"] = ObjectCache.Get(MinCurrencyCondition);
            _itemRetrieverQuery["RequireEmpty"] = True;

            if (itemQuery.BlueprintId != 0)
                _itemRetrieverQuery["BlueprintId"] = ObjectCache.Get(itemQuery.BlueprintId);

            if (itemQuery.DataInt != 0)
                _itemRetrieverQuery["DataInt"] = ObjectCache.Get(itemQuery.DataInt);

            if (itemQuery.ItemId != 0)
                _itemRetrieverQuery["ItemId"] = ObjectCache.Get(itemQuery.ItemId);

            if (itemQuery.SkinId.HasValue)
                _itemRetrieverQuery["SkinId"] = ObjectCache.Get(itemQuery.SkinId.Value);

            return _itemRetrieverQuery;
        }

        private int SumPlayerItems(BasePlayer player, ref ItemQuery itemQuery)
        {
            return _itemRetrieverAdapter?.Api?.SumPlayerItems.Invoke(player, SetupItemRetrieverQuery(ref itemQuery))
                   ?? ItemUtils.SumPlayerItems(player, ref itemQuery);
        }

        private int TakePlayerItems(BasePlayer player, ref ItemQuery itemQuery, int amount, List<Item> collect = null)
        {
            return _itemRetrieverAdapter?.Api?.TakePlayerItems.Invoke(player, SetupItemRetrieverQuery(ref itemQuery), amount, collect)
                   ?? ItemUtils.TakePlayerItems(player, ref itemQuery, amount, collect);
        }

        private bool PassesUICommandChecks(IPlayer player, string[] args, out NPCVendingMachine vendingMachine, out BaseVendingController controller)
        {
            vendingMachine = null;
            controller = null;

            if (player.IsServer || !player.HasPermission(PermissionUse))
                return false;

            ulong vendingMachineId;
            if (args.Length == 0 || !ulong.TryParse(args[0], out vendingMachineId))
                return false;

            vendingMachine = BaseNetworkable.serverEntities.Find(new NetworkableId(vendingMachineId)) as NPCVendingMachine;
            if (vendingMachine == null)
                return false;

            controller = _vendingMachineManager.GetController(vendingMachine);
            if (controller == null)
                return false;

            return true;
        }

        private void OpenVendingMachineDelayed(BasePlayer player, NPCVendingMachine vendingMachine, float delay = 0.1f)
        {
            timer.Once(delay, () =>
            {
                if (player == null || vendingMachine == null || vendingMachine.IsDestroyed)
                    return;

                OpenVendingMachine(player, vendingMachine);
            });
        }

        private bool IsCustomized(NPCVendingMachine vendingMachine) =>
            _vendingMachineManager.GetController(vendingMachine)?.Profile?.Offers != null;

        #endregion

        #region UI

        private static class UIConstants
        {
            public const string EditButtonColor = "0.451 0.553 0.271 1";
            public const string EditButtonTextColor = "0.659 0.918 0.2 1";

            public const string ResetButtonColor = "0.9 0.5 0.2 1";
            public const string ResetButtonTextColor = "1 0.9 0.7 1";

            public const string SaveButtonColor = EditButtonColor;
            public const string SaveButtonTextColor = EditButtonTextColor;

            public const string CancelButtonColor = "0.4 0.4 0.4 1";
            public const string CancelButtonTextColor = "0.71 0.71 0.71 1";

            public const float PanelWidth = 380.5f;
            public const float HeaderHeight = 23;
            public const float ItemSpacing = 4;
            public const float ItemBoxSize = 58;

            public const int ButtonHorizontalSpacing = 6;

            public const int ButtonHeight = 32;
            public const int ButtonWidth = 80;

            public const string TexturedBackgroundSprite = "assets/content/ui/ui.background.tiletex.psd";
            public const string BroadcastIcon = "assets/icons/broadcast.png";
            public const string DroneIcon = "assets/icons/drone.png";
            public const string IconMaterial = "assets/icons/iconmaterial.mat";
            public const string GreyOutMaterial = "assets/icons/greyout.mat";

            public const string AnchorMin = "0.5 0";
            public const string AnchorMax = "0.5 0";
        }

        private class EditFormState
        {
            public static EditFormState FromVendingMachine(BaseVendingController vendingController, NPCVendingMachine vendingMachine)
            {
                return new EditFormState
                {
                    Broadcast = vendingController.Profile?.Broadcast ?? vendingMachine.IsBroadcasting(),
                    DroneAccessible = vendingController.Profile?.DroneAccessible ?? true,
                };
            }

            public bool Broadcast;
            public bool DroneAccessible;
        }

        private static class ContainerUIRenderer
        {
            public const string UIName = "CustomVendingSetup.ContainerUI";

            public const string TipUIName = "CustomVendingSetup.ContainerUI.Tip";
            public const string BroadcastUIName = "CustomVendingSetup.ContainerUI.Broadcast";
            public const string DroneUIName = "CustomVendingSetup.ContainerUI.Drone";

            public static string RenderContainerUI(CustomVendingSetup plugin, BasePlayer player, NPCVendingMachine vendingMachine, EditFormState uiState)
            {
                var offsetX = 192;
                var offsetY = 141;

                var cuiElements = new CuiElementContainer
                {
                    {
                        new CuiPanel
                        {
                            RectTransform =
                            {
                                AnchorMin = UIConstants.AnchorMin,
                                AnchorMax = UIConstants.AnchorMax,
                                OffsetMin = $"{offsetX} {offsetY + MaxItemRows * (UIConstants.ItemBoxSize + UIConstants.ItemSpacing)}",
                                OffsetMax = $"{offsetX} {offsetY + MaxItemRows * (UIConstants.ItemBoxSize + UIConstants.ItemSpacing)}",
                            },
                        },
                        "Hud.Menu",
                        UIName
                    }
                };

                var saveButtonText = plugin.GetMessage(player, Lang.ButtonSave);
                var cancelButtonText = plugin.GetMessage(player, Lang.ButtonCancel);

                var vendingMachineId = vendingMachine.net.ID.Value;

                AddButton(
                    cuiElements,
                    vendingMachineId,
                    saveButtonText,
                    UICommands.Save,
                    UIConstants.PanelWidth - UIConstants.ButtonWidth - UIConstants.ButtonHorizontalSpacing,
                    UIConstants.SaveButtonColor,
                    UIConstants.SaveButtonTextColor
                );
                AddButton(
                    cuiElements,
                    vendingMachineId,
                    cancelButtonText,
                    UICommands.Cancel,
                    UIConstants.PanelWidth,
                    UIConstants.CancelButtonColor,
                    UIConstants.CancelButtonTextColor
                );
                AddBroadcastButton(cuiElements, vendingMachine, uiState);
                AddDroneButton(cuiElements, vendingMachine, uiState);

                var headerOffset = -6;

                cuiElements.Add(new CuiElement
                {
                    Parent = UIName,
                    Name = TipUIName,
                    Components =
                    {
                        new CuiRawImageComponent
                        {
                            Color = UIConstants.CancelButtonColor,
                            Sprite = UIConstants.TexturedBackgroundSprite,
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = UIConstants.AnchorMin,
                            AnchorMax = UIConstants.AnchorMax,
                            OffsetMin = $"0 {headerOffset - UIConstants.HeaderHeight}",
                            OffsetMax = $"{UIConstants.PanelWidth} {headerOffset}",
                        }
                    },
                });

                var forSaleText = plugin.GetMessage(player, Lang.InfoForSale);
                var costText = plugin.GetMessage(player, Lang.InfoCost);
                var settingsText = plugin.GetMessage(player, Lang.InfoSettings);

                AddHeaderLabel(cuiElements, 0, forSaleText);
                AddHeaderLabel(cuiElements, 1, costText);
                AddHeaderLabel(cuiElements, 2, settingsText);
                AddHeaderLabel(cuiElements, 3, forSaleText);
                AddHeaderLabel(cuiElements, 4, costText);
                AddHeaderLabel(cuiElements, 5, settingsText);

                return CuiHelper.ToJson(cuiElements);
            }

            private static void AddHeaderLabel(CuiElementContainer cuiElements, int index, string text)
            {
                var xMin = 6 + index * (UIConstants.ItemBoxSize + UIConstants.ItemSpacing);
                var xMax = xMin + UIConstants.ItemBoxSize;

                cuiElements.Add(
                    new CuiLabel
                    {
                        Text =
                        {
                            Text = text,
                            Color = UIConstants.CancelButtonTextColor,
                            Align = TextAnchor.MiddleCenter,
                            FontSize = 13,
                        },
                        RectTransform =
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "0 0",
                            OffsetMin = $"{xMin} 0",
                            OffsetMax = $"{xMax} {UIConstants.HeaderHeight}",
                        }
                    },
                    TipUIName
                );
            }

            private static void AddBroadcastButton(CuiElementContainer cuiElements, NPCVendingMachine vendingMachine, EditFormState uiState)
            {
                var iconSize = UIConstants.ButtonHeight;

                var xMax = UIConstants.PanelWidth - 2 * (UIConstants.ButtonWidth + UIConstants.ButtonHorizontalSpacing);
                var xMin = xMax - iconSize;

                cuiElements.Add(new CuiElement
                {
                    Parent = UIName,
                    Name = BroadcastUIName,
                    DestroyUi = BroadcastUIName,
                    Components =
                    {
                        new CuiButtonComponent
                        {
                            Color = "0 0 0 0",
                            Command = $"customvendingsetup.ui {vendingMachine.net.ID} {UICommands.ToggleBroadcast}",
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "0 0",
                            OffsetMin = $"{xMin} 0",
                            OffsetMax = $"{xMax} {UIConstants.ButtonHeight}",
                        },
                    },
                });

                cuiElements.Add(new CuiElement
                {
                    Parent = BroadcastUIName,
                    Components =
                    {
                        new CuiRawImageComponent
                        {
                            Color = uiState.Broadcast ? UIConstants.SaveButtonTextColor : UIConstants.CancelButtonTextColor,
                            Sprite = UIConstants.BroadcastIcon,
                            Material = UIConstants.IconMaterial,
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "0 0",
                            OffsetMin = "0 0",
                            OffsetMax = $"{iconSize} {iconSize}",
                        },
                    },
                });
            }

            private static void AddDroneButton(CuiElementContainer cuiElements, NPCVendingMachine vendingMachine, EditFormState uiState)
            {
                var iconSize = UIConstants.ButtonHeight;

                var xMax = - UIConstants.ButtonHorizontalSpacing;
                var xMin = xMax - iconSize;

                var droneAccessible = uiState.Broadcast && uiState.DroneAccessible;

                cuiElements.Add(new CuiElement
                {
                    Parent = BroadcastUIName,
                    Name = DroneUIName,
                    Components =
                    {
                        new CuiButtonComponent
                        {
                            Color = "0 0 0 0",
                            Command = $"customvendingsetup.ui {vendingMachine.net.ID} {UICommands.ToggleDroneAccessible}",
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "0 0",
                            OffsetMin = $"{xMin} 0",
                            OffsetMax = $"{xMax} {UIConstants.ButtonHeight}",
                        },
                    },
                });

                cuiElements.Add(new CuiElement
                {
                    Parent = DroneUIName,
                    Components =
                    {
                        new CuiImageComponent
                        {
                            Color = droneAccessible ? UIConstants.SaveButtonTextColor : UIConstants.CancelButtonTextColor,
                            Sprite = UIConstants.DroneIcon,
                            Material = UIConstants.GreyOutMaterial,
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "0 0",
                            OffsetMin = "0 0",
                            OffsetMax = $"{iconSize} {iconSize}",
                        },
                    },
                });
            }

            public static string RenderBroadcastUI(NPCVendingMachine vendingMachine, EditFormState uiState)
            {
                var cuiElements = new CuiElementContainer();
                AddBroadcastButton(cuiElements, vendingMachine, uiState);
                AddDroneButton(cuiElements, vendingMachine, uiState);
                return CuiHelper.ToJson(cuiElements);
            }

            private static void AddButton(CuiElementContainer cuiElements, ulong vendingMachineId, string text, string subCommand, float xMax, string color, string textColor)
            {
                var xMin = xMax - UIConstants.ButtonWidth;

                cuiElements.Add(
                    new CuiButton
                    {
                        Text =
                        {
                            Text = text,
                            Color = textColor,
                            Align = TextAnchor.MiddleCenter,
                            FontSize = 18,
                        },
                        Button =
                        {
                            Color = color,
                            FadeIn = 0.1f,
                            Command = $"customvendingsetup.ui {vendingMachineId} {subCommand}",
                        },
                        RectTransform =
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "0 0",
                            OffsetMin = $"{xMin} 0",
                            OffsetMax = $"{xMax} {UIConstants.ButtonHeight}",
                        },
                    },
                    UIName
                );
            }
        }

        private static class AdminUIRenderer
        {
            public const string UIName = "CustomVendingSetup.AdminUI";

            public static string RenderAdminUI(CustomVendingSetup plugin, BasePlayer player, NPCVendingMachine vendingMachine, VendingProfile profile)
            {
                var numSellOrders = vendingMachine.sellOrders?.sellOrders.Count ?? 0;
                var offsetY = 136 + 74 * numSellOrders;
                var offsetX = 192;

                var cuiElements = new CuiElementContainer
                {
                    new CuiElement
                    {
                        Parent = "Overlay",
                        Name = UIName,
                        DestroyUi = UIName,
                        Components =
                        {
                            new CuiRectTransformComponent
                            {
                                AnchorMin = UIConstants.AnchorMin,
                                AnchorMax = UIConstants.AnchorMax,
                                OffsetMin = $"{offsetX} {offsetY}",
                                OffsetMax = $"{offsetX} {offsetY}",
                            }
                        }
                    },
                };

                var buttonIndex = 0;
                var vendingMachineId = vendingMachine.net.ID.Value;

                if (profile != null)
                {
                    var resetButtonText = plugin.GetMessage(player, Lang.ButtonReset);
                    AddVendingButton(cuiElements, vendingMachineId, resetButtonText, UICommands.Reset, buttonIndex, UIConstants.ResetButtonColor, UIConstants.ResetButtonTextColor);
                    buttonIndex++;
                }

                var editButtonText = plugin.GetMessage(player, Lang.ButtonEdit);
                AddVendingButton(cuiElements, vendingMachineId, editButtonText, UICommands.Edit, buttonIndex, UIConstants.SaveButtonColor, UIConstants.SaveButtonTextColor);

                return CuiHelper.ToJson(cuiElements);
            }

            private static float GetButtonOffset(int reverseButtonIndex)
            {
                return UIConstants.PanelWidth - reverseButtonIndex * (UIConstants.ButtonWidth + UIConstants.ButtonHorizontalSpacing);
            }

            private static void AddVendingButton(CuiElementContainer cuiElements, ulong vendingMachineId, string text, string subCommand, int reverseButtonIndex, string color, string textColor)
            {
                var xMax = GetButtonOffset(reverseButtonIndex);
                var xMin = xMax - UIConstants.ButtonWidth;

                cuiElements.Add(
                    new CuiButton
                    {
                        Text =
                        {
                            Text = text,
                            Color = textColor,
                            Align = TextAnchor.MiddleCenter,
                            FontSize = 18,
                        },
                        Button =
                        {
                            Color = color,
                            FadeIn = 0.1f,
                            Command = $"customvendingsetup.ui {vendingMachineId} {subCommand}",
                        },
                        RectTransform =
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "0 0",
                            OffsetMin = $"{xMin} 0",
                            OffsetMax = $"{xMax} {UIConstants.ButtonHeight}",
                        },
                    },
                    UIName
                );
            }
        }

        private static class ShopUIRenderer
        {
            public const string UIName = "CustomVendingSetup.ShopUI";

            private const float OffsetXItem = 210;
            private const float OffsetXCurrency = 352;
            private const float OverlaySize = 60;

            private const float IconSize = 50;
            private const float PaddingLeft = 5.5f;
            private const float PaddingBottom = 8;

            public static string RenderShopUI(VendingProfile vendingProfile)
            {
                var cuiElements = new CuiElementContainer
                {
                    new CuiElement
                    {
                        Parent = "Hud.Menu",
                        Name = UIName,
                        DestroyUi = UIName,
                        Components =
                        {
                            new CuiRectTransformComponent
                            {
                                AnchorMin = UIConstants.AnchorMin,
                                AnchorMax = UIConstants.AnchorMax,
                            }
                        }
                    },
                };

                var skinsByItemShortName = new Dictionary<string, HashSet<ulong>>();
                var numValidOffers = 0;

                foreach (var offer in vendingProfile.Offers)
                {
                    if (!offer.IsValid)
                        continue;

                    numValidOffers++;

                    HashSet<ulong> skins;
                    if (!skinsByItemShortName.TryGetValue(offer.SellItem.ShortName, out skins))
                    {
                        skins = new HashSet<ulong>();
                        skinsByItemShortName[offer.SellItem.ShortName] = skins;
                    }

                    skins.Add(offer.SellItem.SkinId);
                }

                var offerIndex = 0;

                foreach (var offer in vendingProfile.Offers)
                {
                    if (!offer.IsValid)
                        continue;

                    if (skinsByItemShortName[offer.SellItem.ShortName].Count > 1)
                    {
                        AddItemOverlay(cuiElements, numValidOffers - offerIndex, offer, isCurrency: false);
                    }

                    if (offer.CurrencyItem.SkinId != 0)
                    {
                        AddItemOverlay(cuiElements, numValidOffers - offerIndex, offer, isCurrency: true);
                    }

                    offerIndex++;
                }

                if (cuiElements.Count == 1)
                    return string.Empty;

                return CuiHelper.ToJson(cuiElements);
            }

            private static void AddItemOverlay(CuiElementContainer cuiElements, int indexFromBottom, VendingOffer offer, bool isCurrency = false)
            {
                var offsetX = isCurrency ? OffsetXCurrency : OffsetXItem;
                var offsetY = 40 + 74 * indexFromBottom;

                var vendingItem = isCurrency ? offer.CurrencyItem : offer.SellItem;

                // Background
                cuiElements.Add(new CuiElement
                {
                    Parent = UIName,
                    Components =
                    {
                        new CuiRawImageComponent
                        {
                            Color = "0.35 0.35 0.35 1",
                            Sprite = UIConstants.TexturedBackgroundSprite,
                            FadeIn = 0.1f,
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = UIConstants.AnchorMin,
                            AnchorMax = UIConstants.AnchorMax,
                            OffsetMin = $"{offsetX} {offsetY}",
                            OffsetMax = $"{offsetX + OverlaySize} {offsetY + OverlaySize}",
                        }
                    },
                });

                // Skin icon
                cuiElements.Add(new CuiElement
                {
                    Name = $"{UIName}.Offer.{indexFromBottom}.Currency",
                    Parent = UIName,
                    Components =
                    {
                        new CuiImageComponent
                        {
                            Sprite = "assets/content/textures/generic/fulltransparent.tga",
                            ItemId = vendingItem.ItemId,
                            SkinId = vendingItem.SkinId,
                            FadeIn = 0.1f,
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "0 0",
                            OffsetMin = $"{offsetX + PaddingLeft} {offsetY + PaddingBottom}",
                            OffsetMax = $"{offsetX + PaddingLeft + IconSize} {offsetY + PaddingBottom + IconSize}"
                        },
                    }
                });

                if (vendingItem.Amount > 1)
                {
                    // Amount
                    cuiElements.Add(new CuiElement
                    {
                        Parent = UIName,
                        Components =
                        {
                            new CuiTextComponent
                            {
                                Text = $"x{vendingItem.Amount}",
                                Align = TextAnchor.LowerRight,
                                FontSize = 12,
                                Color = "0.65 0.65 0.65 1",
                                FadeIn = 0.1f,
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = UIConstants.AnchorMin,
                                AnchorMax = UIConstants.AnchorMax,
                                OffsetMin = $"{offsetX + 4} {offsetY + 1f}",
                                OffsetMax = $"{offsetX - 3f + OverlaySize} {offsetY + OverlaySize}",
                            }
                        },
                    });
                }
            }
        }

        #endregion

        #region Utilities

        private static class StringUtils
        {
            public static bool Equals(string a, string b) =>
                string.Compare(a, b, StringComparison.OrdinalIgnoreCase) == 0;

            public static bool Contains(string haystack, string needle) =>
                haystack.Contains(needle, CompareOptions.IgnoreCase);
        }

        private static class ObjectCache
        {
            private static class StaticObjectCache<T>
            {
                private static readonly Dictionary<T, object> _cacheByValue = new Dictionary<T, object>();

                public static object Get(T value)
                {
                    object cachedObject;
                    if (!_cacheByValue.TryGetValue(value, out cachedObject))
                    {
                        cachedObject = value;
                        _cacheByValue[value] = cachedObject;
                    }
                    return cachedObject;
                }

                public static void Clear()
                {
                    _cacheByValue.Clear();
                }
            }

            public static object Get<T>(T value)
            {
                return StaticObjectCache<T>.Get(value);
            }

            public static void Clear<T>()
            {
                StaticObjectCache<T>.Clear();
            }
        }

        private interface IMonumentRelativePosition
        {
            string GetMonumentPrefabName();
            string GetMonumentAlias();
            Vector3 GetPosition();
            Vector3 GetLegacyPosition();
        }

        private static bool LocationsMatch(IMonumentRelativePosition a, IMonumentRelativePosition b)
        {
            var monumentsMatch = a.GetMonumentAlias() != null && a.GetMonumentAlias() == b.GetMonumentAlias()
                || a.GetMonumentPrefabName() == b.GetMonumentPrefabName();

            if (!monumentsMatch)
                return false;

            return AreVectorsClose(a.GetPosition(), b.GetPosition())
                || AreVectorsClose(a.GetLegacyPosition(), b.GetLegacyPosition());
        }

        private class MonumentRelativePosition : IMonumentRelativePosition
        {
            public static MonumentRelativePosition FromVendingMachine(MonumentFinderAdapter monumentFinderAdapter, NPCVendingMachine vendingMachine)
            {
                var monument = monumentFinderAdapter.GetMonumentAdapter(vendingMachine);
                if (monument == null)
                    return null;

                return new MonumentRelativePosition
                {
                    _monument = monument,
                    _position = monument.InverseTransformPoint(vendingMachine.transform.position),
                    _legacyPosition = vendingMachine.transform.InverseTransformPoint(monument.Position),
                };
            }

            private MonumentAdapter _monument;
            private Vector3 _position;
            private Vector3 _legacyPosition;

            // IMonumentRelativePosition members.
            public string GetMonumentPrefabName() => _monument.PrefabName;
            public string GetMonumentAlias() => _monument.Alias;
            public Vector3 GetPosition() => _position;
            public Vector3 GetLegacyPosition() => _legacyPosition;
        }

        #endregion

        #region Payment Providers

        private struct TransactionContext
        {
            public NPCVendingMachine VendingMachine;
            public VendingItem SellItem;
            public ItemContainer TargetContainer;
            public Action<BasePlayer, Item> OnMarketplaceItemPurchase;
        }

        private interface IPaymentProvider
        {
            int GetBalance(BasePlayer player);
            bool AddBalance(BasePlayer player, int amount, TransactionContext transaction);
            bool TakeBalance(BasePlayer player, int amount, List<Item> collect);
        }

        private class ItemsPaymentProvider : IPaymentProvider
        {
            public VendingItem VendingItem;

            private CustomVendingSetup _plugin;

            public ItemsPaymentProvider(CustomVendingSetup plugin)
            {
                _plugin = plugin;
            }

            public int GetBalance(BasePlayer player)
            {
                var itemQuery = ItemQuery.FromCurrencyItem(VendingItem);
                return _plugin.SumPlayerItems(player, ref itemQuery);
            }

            public bool AddBalance(BasePlayer player, int amount, TransactionContext transaction)
            {
                var vendingMachine = transaction.VendingMachine;
                var sellItem = transaction.SellItem;

                var sellItemQuery = ItemQuery.FromSellItem(sellItem);
                var firstSellableItem = ItemUtils.FindFirstContainerItem(vendingMachine.inventory, ref sellItemQuery);
                var maxStackSize = _plugin._config.GetItemMaxStackSize(firstSellableItem);

                // Create new items and give them to the player.
                // This approach was chosen instead of transferring the items because in many cases new items would have to
                // be created anyway, since the vending machine maintains a single large stack of each item.
                while (amount > 0)
                {
                    var amountToGive = Math.Min(amount, maxStackSize);
                    var itemToGive = sellItem.Create(amountToGive);

                    amount -= amountToGive;

                    // The "CanPurchaseItem" hook may cause "CanVendingStockRefill" hook to be called.
                    var hookResult = ExposedHooks.CanPurchaseItem(player, itemToGive, transaction.OnMarketplaceItemPurchase, vendingMachine, transaction.TargetContainer);
                    if (hookResult is bool)
                    {
                        LogWarning($"A plugin returned {hookResult} in the CanPurchaseItem hook, which has been ignored.");
                    }

                    GiveSoldItem(itemToGive, player, ref transaction);
                }

                return true;
            }

            public bool TakeBalance(BasePlayer player, int amount, List<Item> collect)
            {
                if (amount <= 0)
                    return true;

                var itemQuery = ItemQuery.FromCurrencyItem(VendingItem);
                _plugin.TakePlayerItems(player, ref itemQuery, amount, collect);
                return true;
            }
        }

        private class EconomicsPaymentProvider : IPaymentProvider
        {
            private CustomVendingSetup _plugin;
            private Plugin _ownerPlugin => _plugin.Economics;

            public EconomicsPaymentProvider(CustomVendingSetup plugin)
            {
                _plugin = plugin;
            }

            public bool IsAvailable => _ownerPlugin != null;

            public int GetBalance(BasePlayer player)
            {
                return Convert.ToInt32(_plugin.CallPlugin(_ownerPlugin, "Balance", player.userID));
            }

            public bool AddBalance(BasePlayer player, int amount, TransactionContext transaction)
            {
                var result = _plugin.CallPlugin(_ownerPlugin, "Deposit", player.userID, Convert.ToDouble(amount));
                return result is bool && (bool)result;
            }

            public bool TakeBalance(BasePlayer player, int amount, List<Item> collect)
            {
                var result = _plugin.CallPlugin(_ownerPlugin, "Withdraw", player.userID, Convert.ToDouble(amount));
                return result is bool && (bool)result;
            }
        }

        private class ServerRewardsPaymentProvider : IPaymentProvider
        {
            private CustomVendingSetup _plugin;
            private Plugin _ownerPlugin => _plugin.ServerRewards;

            public ServerRewardsPaymentProvider(CustomVendingSetup plugin)
            {
                _plugin = plugin;
            }

            public bool IsAvailable => _ownerPlugin != null;

            public int GetBalance(BasePlayer player)
            {
                return Convert.ToInt32(_plugin.CallPlugin(_ownerPlugin, "CheckPoints", player.userID));
            }

            public bool AddBalance(BasePlayer player, int amount, TransactionContext transaction)
            {
                var result = _plugin.CallPlugin(_ownerPlugin, "AddPoints", player.userID, amount);
                return result is bool && (bool)result;
            }

            public bool TakeBalance(BasePlayer player, int amount, List<Item> collect)
            {
                var result = _plugin.CallPlugin(_ownerPlugin, "TakePoints", player.userID, amount);
                return result is bool && (bool)result;
            }
        }

        private class PaymentProviderResolver
        {
            public readonly EconomicsPaymentProvider EconomicsPaymentProvider;
            public readonly ServerRewardsPaymentProvider ServerRewardsPaymentProvider;

            private readonly CustomVendingSetup _plugin;
            private readonly ItemsPaymentProvider _itemsPaymentProvider;
            private Configuration _config => _plugin._config;

            public PaymentProviderResolver(CustomVendingSetup plugin)
            {
                _plugin = plugin;
                _itemsPaymentProvider = new ItemsPaymentProvider(plugin);
                EconomicsPaymentProvider = new EconomicsPaymentProvider(plugin);
                ServerRewardsPaymentProvider = new ServerRewardsPaymentProvider(plugin);
            }

            public IPaymentProvider Resolve(VendingItem vendingItem)
            {
                if (_config.Economics.MatchesItem(vendingItem) && EconomicsPaymentProvider.IsAvailable)
                    return EconomicsPaymentProvider;

                if (_config.ServerRewards.MatchesItem(vendingItem) && ServerRewardsPaymentProvider.IsAvailable)
                    return ServerRewardsPaymentProvider;

                _itemsPaymentProvider.VendingItem = vendingItem;
                return _itemsPaymentProvider;
            }
        }

        #endregion

        #region Item Query

        private struct ItemQuery
        {
            public static ItemQuery FromSellItem(VendingItem vendingItem)
            {
                return new ItemQuery
                {
                    BlueprintId = vendingItem.IsBlueprint ? vendingItem.ItemId : 0,
                    DataInt = vendingItem.DataInt,
                    DisplayName = vendingItem.DisplayName,
                    ItemId = vendingItem.IsBlueprint ? BlueprintItemId : vendingItem.ItemId,
                    SkinId = vendingItem.SkinId,
                };
            }

            public static ItemQuery FromCurrencyItem(VendingItem vendingItem)
            {
                var itemQuery = new ItemQuery
                {
                    BlueprintId = vendingItem.IsBlueprint ? vendingItem.ItemId : 0,
                    MinCondition = MinCurrencyCondition,
                    ItemId = vendingItem.IsBlueprint ? BlueprintItemId : vendingItem.ItemId,
                };

                if (vendingItem.SkinId != 0)
                {
                    itemQuery.SkinId = vendingItem.SkinId;
                }

                return itemQuery;
            }

            public int BlueprintId;
            public int DataInt;
            public string DisplayName;
            public Item.Flag Flags;
            public int ItemId;
            public float MinCondition;
            public bool RequireEmpty;
            public ulong? SkinId;

            public int GetUsableAmount(Item item)
            {
                if (ItemId != 0 && ItemId != item.info.itemid)
                    return 0;

                if (SkinId.HasValue && SkinId != item.skin)
                    return 0;

                if (BlueprintId != 0 && BlueprintId != item.blueprintTarget)
                    return 0;

                if (DataInt != 0 && DataInt != (item.instanceData?.dataInt ?? 0))
                    return 0;

                if (Flags != 0 && !item.flags.HasFlag(Flags))
                    return 0;

                if (MinCondition > 0 && item.hasCondition && (item.conditionNormalized < MinCondition || item.maxConditionNormalized < MinCondition))
                    return 0;

                if (!string.IsNullOrEmpty(DisplayName) && !StringUtils.Equals(DisplayName, item.name))
                    return 0;

                return RequireEmpty && item.contents?.itemList?.Count > 0
                    ? Math.Max(0, item.amount - 1)
                    : item.amount;
            }
        }

        #endregion

        #region Item Utils

        private static class ItemUtils
        {
            public static Item FindFirstContainerItem(ItemContainer container, ref ItemQuery itemQuery)
            {
                foreach (var item in container.itemList)
                {
                    if (itemQuery.GetUsableAmount(item) > 0)
                        return item;
                }

                return null;
            }

            public static int SumContainerItems(ItemContainer container, ref ItemQuery itemQuery)
            {
                var sum = 0;

                foreach (var item in container.itemList)
                {
                    sum += itemQuery.GetUsableAmount(item);
                }

                return sum;
            }

            public static int SumPlayerItems(BasePlayer player, ref ItemQuery itemQuery)
            {
                return SumContainerItems(player.inventory.containerMain, ref itemQuery)
                    + SumContainerItems(player.inventory.containerBelt, ref itemQuery);
            }

            public static int TakeContainerItems(ItemContainer container, ref ItemQuery itemQuery, int totalAmountToTake, List<Item> collect = null)
            {
                var totalAmountTaken = 0;

                for (var i = container.itemList.Count - 1; i >= 0; i--)
                {
                    var amountToTake = totalAmountToTake - totalAmountTaken;
                    if (amountToTake <= 0)
                        break;

                    var item = container.itemList[i];
                    var usableAmount = itemQuery.GetUsableAmount(item);
                    if (usableAmount > 0)
                    {
                        amountToTake = Math.Min(item.amount, amountToTake);

                        if (item.amount > amountToTake)
                        {
                            if (collect != null)
                            {
                                var splitItem = item.SplitItem(amountToTake);
                                var playerOwner = splitItem.GetOwnerPlayer();
                                if (playerOwner != null)
                                {
                                    splitItem.CollectedForCrafting(playerOwner);
                                }
                                collect.Add(splitItem);
                            }
                            else
                            {
                                item.amount -= amountToTake;
                                item.MarkDirty();
                            }
                        }
                        else
                        {
                            item.RemoveFromContainer();

                            if (collect != null)
                            {
                                collect.Add(item);
                            }
                            else
                            {
                                item.Remove();
                            }
                        }

                        totalAmountTaken += amountToTake;
                    }

                    if (totalAmountTaken >= totalAmountToTake)
                        return totalAmountTaken;
                }

                return totalAmountTaken;
            }

            public static int TakePlayerItems(BasePlayer player, ref ItemQuery itemQuery, int amountToTake, List<Item> collect = null)
            {
                var amountTaken = TakeContainerItems(player.inventory.containerMain, ref itemQuery, amountToTake, collect);
                if (amountTaken >= amountToTake)
                    return amountTaken;

                amountTaken += TakeContainerItems(player.inventory.containerBelt, ref itemQuery, amountToTake - amountTaken, collect);
                if (amountTaken >= amountToTake)
                    return amountTaken;

                amountTaken += TakeContainerItems(player.inventory.containerWear, ref itemQuery, amountToTake - amountTaken, collect);
                if (amountTaken >= amountToTake)
                    return amountTaken;

                return amountTaken;
            }
        }

        #endregion

        #region Dynamic Hook Subscriptions

        private class DynamicHookSubscriber<T>
        {
            private CustomVendingSetup _plugin;
            private HashSet<T> _list = new HashSet<T>();
            private string[] _hookNames;

            public DynamicHookSubscriber(CustomVendingSetup plugin, params string[] hookNames)
            {
                _plugin = plugin;
                _hookNames = hookNames;
            }

            public bool Contains(T item)
            {
                return _list.Contains(item);
            }

            public void Add(T item)
            {
                if (_list.Add(item) && _list.Count == 1)
                {
                    SubscribeAll();
                }
            }

            public void Remove(T item)
            {
                if (_list.Remove(item) && _list.Count == 0)
                {
                    UnsubscribeAll();
                }
            }

            public void SubscribeAll()
            {
                foreach (var hookName in _hookNames)
                {
                    _plugin.Subscribe(hookName);
                }
            }

            public void UnsubscribeAll()
            {
                foreach (var hookName in _hookNames)
                {
                    _plugin.Unsubscribe(hookName);
                }
            }
        }

        #endregion

        #region Data Provider

        private class DataProvider
        {
            public static DataProvider FromDictionary(Dictionary<string, object> spec)
            {
                var dataProvider = new DataProvider
                {
                    Spec = spec,
                };

                object getDataCallback, saveDataCallback;

                if (spec.TryGetValue("GetData", out getDataCallback))
                {
                    dataProvider.GetDataCallback = getDataCallback as CustomGetDataCallback;
                }

                if (spec.TryGetValue("SaveData", out saveDataCallback))
                {
                    dataProvider.SaveDataCallback = saveDataCallback as CustomSaveDataCallback;
                }

                if (dataProvider.GetDataCallback == null)
                {
                    LogError("Data provider missing GetData");
                    return null;
                }

                if (dataProvider.SaveDataCallback == null)
                {
                    LogError("Data provider missing SaveData");
                    return null;
                }

                return dataProvider;
            }

            public Dictionary<string, object> Spec { get; private set; }
            public CustomGetDataCallback GetDataCallback;
            public CustomSaveDataCallback SaveDataCallback;

            private VendingProfile _vendingProfile;
            private JObject _serializedData;

            public VendingProfile GetData(Configuration config)
            {
                if (_vendingProfile == null)
                {
                    _vendingProfile = GetDataCallback()?.ToObject<VendingProfile>();
                }

                if (_vendingProfile?.Offers == null)
                {
                    return null;
                }

                return _vendingProfile;
            }

            public void SaveData(VendingProfile vendingProfile)
            {
                _vendingProfile = vendingProfile;
                SaveDataCallback(vendingProfile != null ? JObject.FromObject(vendingProfile) : null);
            }
        }

        private class DataProviderRegistry
        {
            private Dictionary<Dictionary<string, object>, DataProvider> _dataProviderCache = new Dictionary<Dictionary<string, object>, DataProvider>();

            public DataProvider Register(Dictionary<string, object> dataProviderSpec)
            {
                DataProvider dataProvider;
                if (!_dataProviderCache.TryGetValue(dataProviderSpec, out dataProvider))
                {
                    dataProvider = DataProvider.FromDictionary(dataProviderSpec);
                    if (dataProvider == null)
                    {
                        return null;
                    }

                    _dataProviderCache[dataProviderSpec] = dataProvider;
                    return dataProvider;
                }

                return dataProvider;
            }

            public void Unregister(DataProvider dataProvider)
            {
                _dataProviderCache.Remove(dataProvider.Spec);
            }
        }

        #endregion

        #region Vending Machine Manager

        private class VendingMachineManager
        {
            private CustomVendingSetup _plugin;
            private ComponentFactory<NPCVendingMachine, VendingMachineComponent> _componentFactory;
            private DataProviderRegistry _dataProviderRegistry;

            private HashSet<BaseVendingController> _uniqueControllers = new HashSet<BaseVendingController>();

            // Controllers are also cached by vending machine, in case MonumentFinder is unloaded or becomes unstable.
            private Dictionary<NetworkableId, BaseVendingController> _controllersByVendingMachine = new Dictionary<NetworkableId, BaseVendingController>();

            private Dictionary<DataProvider, CustomVendingController> _controllersByDataProvider = new Dictionary<DataProvider, CustomVendingController>();

            public VendingMachineManager(CustomVendingSetup plugin, ComponentFactory<NPCVendingMachine, VendingMachineComponent> componentFactory, DataProviderRegistry dataProviderRegistry)
            {
                _plugin = plugin;
                _componentFactory = componentFactory;
                _dataProviderRegistry = dataProviderRegistry;
            }

            public void HandleVendingMachineSpawned(NPCVendingMachine vendingMachine)
            {
                if (GetController(vendingMachine) != null)
                {
                    // A controller may already exist if this was called when handling a reload of MonumentFinder.
                    return;
                }

                BaseVendingController controller;

                var dataProviderSpec = ExposedHooks.OnCustomVendingSetupDataProvider(vendingMachine);
                if (dataProviderSpec != null)
                {
                    var dataProvider = _dataProviderRegistry.Register(dataProviderSpec);
                    if (dataProvider == null)
                    {
                        // Data provider is invalid.
                        return;
                    }

                    var hookResult = ExposedHooks.OnCustomVendingSetup(vendingMachine);
                    if (hookResult is bool && !(bool)hookResult)
                        return;

                    controller = EnsureCustomController(dataProvider);
                }
                else
                {
                    var location = MonumentRelativePosition.FromVendingMachine(_plugin._monumentFinderAdapter, vendingMachine);
                    if (location == null)
                    {
                        // Not at a monument.
                        return;
                    }

                    var hookResult = ExposedHooks.OnCustomVendingSetup(vendingMachine);
                    if (hookResult is bool && !(bool)hookResult)
                        return;

                    controller = EnsureMonumentController(location);
                }

                controller.AddVendingMachine(vendingMachine);
                _controllersByVendingMachine[vendingMachine.net.ID] = controller;
            }

            public void HandleVendingMachineKilled(NPCVendingMachine vendingMachine)
            {
                var controller = GetController(vendingMachine);
                if (controller == null)
                    return;

                controller.RemoveVendingMachine(vendingMachine);
                _controllersByVendingMachine.Remove(vendingMachine.net.ID);

                if (!controller.HasVendingMachines)
                {
                    _uniqueControllers.Remove(controller);

                    var customController = controller as CustomVendingController;
                    if (customController != null)
                    {
                        _controllersByDataProvider.Remove(customController.DataProvider);
                        _dataProviderRegistry.Unregister(customController.DataProvider);
                    }
                }
            }

            public BaseVendingController GetController(NPCVendingMachine vendingMachine)
            {
                BaseVendingController controller;
                return _controllersByVendingMachine.TryGetValue(vendingMachine.net.ID, out controller)
                    ? controller
                    : null;
            }

            public void SetupAll()
            {
                foreach (var entity in BaseNetworkable.serverEntities)
                {
                    var vendingMachine = entity as NPCVendingMachine;
                    if (vendingMachine == null)
                        continue;

                    HandleVendingMachineSpawned(vendingMachine);
                }
            }

            public void ResetAll()
            {
                foreach (var controller in _controllersByVendingMachine.Values)
                {
                    controller.Destroy();
                }
            }

            private MonumentVendingController GetControllerByLocation(MonumentRelativePosition location)
            {
                foreach (var controller in _uniqueControllers)
                {
                    var locationBasedController = controller as MonumentVendingController;
                    if (locationBasedController == null)
                    {
                        continue;
                    }

                    if (LocationsMatch(locationBasedController.Location, location))
                        return locationBasedController;
                }

                return null;
            }

            private MonumentVendingController EnsureMonumentController(MonumentRelativePosition location)
            {
                var controller = GetControllerByLocation(location);
                if (controller != null)
                {
                    return controller;
                }

                controller = new MonumentVendingController(_plugin, _componentFactory, location);
                _uniqueControllers.Add(controller);

                return controller;
            }

            private CustomVendingController GetControllerByDataProvider(DataProvider dataProvider)
            {
                CustomVendingController controller;
                return _controllersByDataProvider.TryGetValue(dataProvider, out controller)
                    ? controller
                    : null;
            }

            private CustomVendingController EnsureCustomController(DataProvider dataProvider)
            {
                var controller = GetControllerByDataProvider(dataProvider);
                if (controller != null)
                {
                    return controller;
                }

                controller = new CustomVendingController(_plugin, _componentFactory, dataProvider);
                _controllersByDataProvider[dataProvider] = controller;
                _uniqueControllers.Add(controller);

                return controller;
            }
        }

        #endregion

        #region Edit Controller

        private class EditContainerComponent : FacepunchBehaviour
        {
            public static void AddToContainer(CustomVendingSetup plugin, StorageContainer container, EditController editController)
            {
                var component = container.GetOrAddComponent<EditContainerComponent>();
                component._plugin = plugin;
                component._editController = editController;
            }

            private CustomVendingSetup _plugin;
            private EditController _editController;

            private void PlayerStoppedLooting(BasePlayer player)
            {
                _plugin.TrackStart();
                _editController.HandlePlayerLootEnd(player);
                _plugin.TrackEnd();
            }
        }

        private class EditController
        {
            private static void OpenEditPanel(BasePlayer player, StorageContainer containerEntity)
            {
                var playerLoot = player.inventory.loot;
                playerLoot.Clear();
                playerLoot.PositionChecks = false;
                playerLoot.entitySource = containerEntity;
                playerLoot.itemSource = null;
                playerLoot.MarkDirty();
                playerLoot.AddContainer(containerEntity.inventory);
                playerLoot.SendImmediate();
                player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel", containerEntity.panelName);
            }

            public BasePlayer EditorPlayer { get; private set; }

            private CustomVendingSetup _plugin;
            private BaseVendingController _vendingController;
            private NPCVendingMachine _vendingMachine;
            private StorageContainer _container;
            private EditFormState _formState;

            public EditController(CustomVendingSetup plugin, BaseVendingController vendingController, NPCVendingMachine vendingMachine, BasePlayer editorPlayer)
            {
                _plugin = plugin;
                _vendingController = vendingController;
                _vendingMachine = vendingMachine;
                EditorPlayer = editorPlayer;

                var offers = vendingController.Profile?.Offers ?? GetOffersFromVendingMachine(vendingMachine);

                _container = CreateOrdersContainer(plugin, editorPlayer, offers, vendingMachine.shopName);
                _formState = EditFormState.FromVendingMachine(vendingController, vendingMachine);
                EditContainerComponent.AddToContainer(plugin, _container, this);
                _container.SendAsSnapshot(editorPlayer.Connection);
                OpenEditPanel(editorPlayer, _container);

                CuiHelper.AddUi(editorPlayer, ContainerUIRenderer.RenderContainerUI(plugin, editorPlayer, vendingMachine, _formState));
            }

            public void ToggleBroadcast()
            {
                _formState.Broadcast = !_formState.Broadcast;

                CuiHelper.AddUi(EditorPlayer, ContainerUIRenderer.RenderBroadcastUI(_vendingMachine, _formState));
            }

            public void ToggleDroneAccessible()
            {
                if (!_formState.Broadcast)
                {
                    _formState.DroneAccessible = true;
                    _formState.Broadcast = true;
                }
                else
                {
                    _formState.DroneAccessible = !_formState.DroneAccessible;
                }

                CuiHelper.AddUi(EditorPlayer, ContainerUIRenderer.RenderBroadcastUI(_vendingMachine, _formState));
            }

            public void ApplyStateTo(VendingProfile profile)
            {
                profile.Offers = GetOffersFromContainer(_plugin, EditorPlayer, _container.inventory);
                profile.Broadcast = _formState.Broadcast;
                profile.DroneAccessible = _formState.DroneAccessible;

                var updatedShopName = _container.inventory.GetSlot(ShopNameNoteSlot)?.text.Trim();
                if (!string.IsNullOrEmpty(updatedShopName))
                {
                    profile.ShopName = updatedShopName;
                }
            }

            public void HandlePlayerLootEnd(BasePlayer player)
            {
                Kill();
            }

            public void Kill()
            {
                DestroyUI();
                KillContainer();
                _vendingController.OnEditControllerKilled();
            }

            private void DestroyUI()
            {
                CuiHelper.DestroyUi(EditorPlayer, ContainerUIRenderer.UIName);
            }

            private void KillContainer()
            {
                if (_container == null || _container.IsDestroyed)
                {
                    return;
                }

                if (EditorPlayer != null && !EditorPlayer.IsDestroyed && EditorPlayer.IsConnected)
                {
                    _container.OnNetworkSubscribersLeave(new List<Network.Connection> { EditorPlayer.Connection });
                }

                _plugin._bagOfHoldingLimitManager.RemoveLimitProfile(_container.inventory);
                _container.Kill();
                _container = null;
            }
        }

        #endregion

        #region Vending Machine Controller

        private abstract class BaseVendingController
        {
            // While the Profile is null, the vending machines will be vanilla.
            public VendingProfile Profile { get; protected set; }

            // While the EditController is non-null, a player is editing the vending machine.
            public EditController EditController { get; protected set; }

            public bool HasVendingMachines => _vendingMachineList.Count > 0;

            protected CustomVendingSetup _plugin;

            // List of vending machines with a position matching this controller.
            private HashSet<NPCVendingMachine> _vendingMachineList = new HashSet<NPCVendingMachine>();

            private ComponentFactory<NPCVendingMachine, VendingMachineComponent> _componentFactory;

            private string _cachedShopUI;

            protected BaseVendingController(CustomVendingSetup plugin, ComponentFactory<NPCVendingMachine, VendingMachineComponent> componentFactory)
            {
                _plugin = plugin;
                _componentFactory = componentFactory;
            }

            protected abstract void SaveProfile(VendingProfile vendingProfile);

            protected abstract void DeleteProfile(VendingProfile vendingProfile);

            public void StartEditing(BasePlayer player, NPCVendingMachine vendingMachine)
            {
                if (EditController != null)
                    return;

                EditController = new EditController(_plugin, this, vendingMachine, player);
            }

            public void HandleReset()
            {
                DeleteProfile(Profile);
                Profile = null;
                SetupVendingMachines();
                EditController?.Kill();
                _plugin._inaccessibleVendingMachines.Remove(this);

                _cachedShopUI = null;
            }

            public void Destroy()
            {
                ResetVendingMachines();
                EditController?.Kill();
            }

            public void HandleSave(NPCVendingMachine vendingMachine)
            {
                CreateOrUpdateProfile(vendingMachine);

                EditController.ApplyStateTo(Profile);
                EditController.Kill();

                SaveProfile(Profile);
                SetupVendingMachines();

                _cachedShopUI = null;

                UpdateDroneAccessibility();
            }

            public void AddVendingMachine(NPCVendingMachine vendingMachine)
            {
                if (!_vendingMachineList.Add(vendingMachine))
                    return;

                var component = _componentFactory.GetOrAddTo(vendingMachine);
                component.SetController(this);
                component.SetProfile(Profile);
            }

            public void RemoveVendingMachine(NPCVendingMachine vendingMachine)
            {
                if (!_vendingMachineList.Remove(vendingMachine))
                    return;

                if (_vendingMachineList.Count == 0)
                {
                    EditController?.Kill();
                    _plugin._inaccessibleVendingMachines.Remove(this);
                }
            }

            public void OnEditControllerKilled()
            {
                EditController = null;
            }

            public string GetShopUI()
            {
                if (_cachedShopUI == null)
                {
                    _cachedShopUI = ShopUIRenderer.RenderShopUI(Profile);
                }

                return _cachedShopUI;
            }

            public void UpdateDroneAccessibility()
            {
                if (Profile == null)
                    return;

                if (Profile.Broadcast && !Profile.DroneAccessible)
                {
                    _plugin._inaccessibleVendingMachines.Add(this);
                }
                else
                {
                    _plugin._inaccessibleVendingMachines.Remove(this);
                }
            }

            protected virtual void CreateOrUpdateProfile(NPCVendingMachine vendingMachine)
            {
                if (Profile == null)
                {
                    Profile = VendingProfile.FromVendingMachine(vendingMachine);
                }
            }

            private void SetupVendingMachines()
            {
                foreach (var vendingMachine in _vendingMachineList)
                {
                    _componentFactory.GetOrAddTo(vendingMachine).SetProfile(Profile);
                }
            }

            private void ResetVendingMachines()
            {
                foreach (var vendingMachine in _vendingMachineList)
                {
                    VendingMachineComponent.RemoveFromVendingMachine(vendingMachine);
                }
            }
        }

        private class CustomVendingController : BaseVendingController
        {
            public DataProvider DataProvider { get; private set; }

            public CustomVendingController(CustomVendingSetup plugin, ComponentFactory<NPCVendingMachine, VendingMachineComponent> componentFactory, DataProvider dataProvider)
                : base(plugin, componentFactory)
            {
                DataProvider = dataProvider;
                Profile = dataProvider.GetData(plugin._config);
                UpdateDroneAccessibility();
            }

            protected override void SaveProfile(VendingProfile vendingProfile)
            {
                Profile = vendingProfile;
                DataProvider.SaveData(vendingProfile);
            }

            protected override void DeleteProfile(VendingProfile vendingProfile)
            {
                DataProvider.SaveData(null);
            }
        }

        private class MonumentVendingController : BaseVendingController
        {
            public MonumentRelativePosition Location { get; private set; }

            private SavedData _pluginData => _plugin._pluginData;

            public MonumentVendingController(CustomVendingSetup plugin, ComponentFactory<NPCVendingMachine, VendingMachineComponent> componentFactory, MonumentRelativePosition location)
                : base(plugin, componentFactory)
            {
                Location = location;
                Profile = _pluginData.FindProfile(location);
                UpdateDroneAccessibility();
            }

            protected override void SaveProfile(VendingProfile vendingProfile)
            {
                if (!_pluginData.VendingProfiles.Contains(vendingProfile))
                {
                    _pluginData.VendingProfiles.Add(vendingProfile);
                }

                _pluginData.Save();
            }

            protected override void DeleteProfile(VendingProfile vendingProfile)
            {
                _pluginData.VendingProfiles.Remove(vendingProfile);
                _pluginData.Save();
            }

            protected override void CreateOrUpdateProfile(NPCVendingMachine vendingMachine)
            {
                // Update the location, in case the vending machine has moved.
                Location = MonumentRelativePosition.FromVendingMachine(_plugin._monumentFinderAdapter, vendingMachine);

                if (Profile == null)
                {
                    Profile = VendingProfile.FromVendingMachine(vendingMachine, Location);
                }
                else
                {
                    Profile.Position = Location.GetPosition();
                }
            }
        }

        #endregion

        #region Component Tracker & Factory

        private class ComponentTracker<THost, TGuest>
            where THost : UnityEngine.Component
            where TGuest : UnityEngine.Component
        {
            private readonly Dictionary<THost, TGuest> _hostToGuest = new Dictionary<THost, TGuest>();

            public void RegisterComponent(THost host, TGuest guest)
            {
                _hostToGuest[host] = guest;
            }

            public TGuest GetComponent(THost host)
            {
                TGuest guest;
                return _hostToGuest.TryGetValue(host, out guest)
                    ? guest
                    : null;
            }

            public void UnregisterComponent(THost source)
            {
                _hostToGuest.Remove(source);
            }
        }

        private class TrackedComponent<THost, TGuest> : FacepunchBehaviour
            where THost : UnityEngine.Component
            where TGuest : TrackedComponent<THost, TGuest>
        {
            public CustomVendingSetup Plugin;
            public ComponentTracker<THost, TGuest> ComponentTracker;
            public THost Host;

            public virtual void OnCreated() {}

            protected virtual void OnDestroy()
            {
                ComponentTracker?.UnregisterComponent(Host);
            }
        }

        private class ComponentFactory<THost, TGuest>
            where THost : UnityEngine.Component
            where TGuest : TrackedComponent<THost, TGuest>
        {
            private CustomVendingSetup _plugin;
            private ComponentTracker<THost, TGuest> _componentTracker;

            public ComponentFactory(CustomVendingSetup plugin, ComponentTracker<THost, TGuest> componentTracker)
            {
                _plugin = plugin;
                _componentTracker = componentTracker;
            }

            public TGuest GetOrAddTo(THost host)
            {
                var guest = _componentTracker.GetComponent(host);
                if (guest == null)
                {
                    guest = host.gameObject.AddComponent<TGuest>();
                    guest.Plugin = _plugin;
                    guest.ComponentTracker = _componentTracker;
                    guest.Host = host;
                    guest.OnCreated();
                    _componentTracker.RegisterComponent(host, guest);
                }

                return guest;
            }
        }

        #endregion

        #region Vending Machine Component

        private class VendingMachineComponent : TrackedComponent<NPCVendingMachine, VendingMachineComponent>
        {
            public static void RemoveFromVendingMachine(NPCVendingMachine vendingMachine) =>
                DestroyImmediate(vendingMachine.GetComponent<VendingMachineComponent>());

            public VendingProfile Profile { get; private set; }

            private readonly List<BasePlayer> _adminUIViewers = new List<BasePlayer>();
            private readonly List<BasePlayer> _shopUIViewers = new List<BasePlayer>();
            private BaseVendingController _vendingController;
            private NPCVendingMachine _vendingMachine;
            private float[] _refillTimes;

            private string _originalShopName;
            private bool? _originalBroadcast;

            public override void OnCreated()
            {
                _vendingMachine = Host;
            }

            public bool HasUI(BasePlayer player)
            {
                return _adminUIViewers.Contains(player) || _shopUIViewers.Contains(player);
            }

            public void ShowAdminUI(BasePlayer player)
            {
                _adminUIViewers.Add(player);
                CuiHelper.AddUi(player, AdminUIRenderer.RenderAdminUI(Plugin, player, _vendingMachine, Profile));
            }

            public void ShowShopUI(BasePlayer player)
            {
                var json = _vendingController.GetShopUI();
                if (json == string.Empty)
                    return;

                _shopUIViewers.Add(player);
                CuiHelper.AddUi(player, json);
            }

            public void RemoveUI(BasePlayer player)
            {
                if (_adminUIViewers.Remove(player))
                {
                    DestroyAdminUI(player);
                }

                if (_shopUIViewers.Remove(player))
                {
                    DestroyShopUI(player);
                }

                // Make sure OnEntitySaved/OnInventoryNetworkUpdate are unsubscribed (when all players are removed).
                Plugin._playersNeedingFakeInventory.Remove(player);

                // Mark inventory dirty to send a network update, which will no longer be modified by hooks.
                player.inventory.containerMain.MarkDirty();
            }

            protected override void OnDestroy()
            {
                base.OnDestroy();

                DestroyUIs();

                if (Profile?.Offers != null && (_vendingMachine != null && !_vendingMachine.IsDestroyed))
                {
                    ResetToVanilla();
                }
            }

            private void PlayerStoppedLooting(BasePlayer player)
            {
                Plugin.TrackStart();
                RemoveUI(player);
                Plugin.TrackEnd();
            }

            public void SetController(BaseVendingController vendingController)
            {
                _vendingController = vendingController;
            }

            public void SetProfile(VendingProfile profile)
            {
                if (Profile == null && profile != null)
                {
                    DisableVanillaBehavior();
                }
                else if (Profile != null && profile == null)
                {
                    ResetToVanilla();
                }

                Profile = profile;

                if (profile?.Offers == null)
                    return;

                _refillTimes = new float[Profile.Offers.Length];

                for (var i = _vendingMachine.inventory.itemList.Count - 1; i >= 0; i--)
                {
                    var item = _vendingMachine.inventory.itemList[i];
                    item.RemoveFromContainer();
                    item.Remove();
                }

                _vendingMachine.ClearSellOrders();

                if (_originalShopName == null)
                    _originalShopName = _vendingMachine.shopName;

                if (_originalBroadcast == null)
                    _originalBroadcast = _vendingMachine.IsBroadcasting();

                if (!string.IsNullOrEmpty(profile.ShopName))
                {
                    _vendingMachine.shopName = profile.ShopName;
                }

                if (_vendingMachine.IsBroadcasting() != profile.Broadcast)
                {
                    _vendingMachine.SetFlag(VendingMachineFlags.Broadcasting, profile.Broadcast);
                    _vendingMachine.UpdateMapMarker();
                }

                for (var i = 0; i < profile.Offers.Length && i < MaxVendingOffers; i++)
                {
                    var offer = profile.Offers[i];
                    if (!offer.IsValid)
                        continue;

                    var vendingOffer = new ProtoBuf.VendingMachine.SellOrder
                    {
                        ShouldPool = false,
                        itemToSellID = offer.SellItem.ItemId,
                        itemToSellAmount = offer.SellItem.Amount,
                        itemToSellIsBP = offer.SellItem.IsBlueprint,
                        currencyID = offer.CurrencyItem.ItemId,
                        currencyAmountPerItem = offer.CurrencyItem.Amount,
                        currencyIsBP = offer.CurrencyItem.IsBlueprint,
                    };

                    Interface.CallHook("OnAddVendingOffer", _vendingMachine, vendingOffer);
                    _vendingMachine.sellOrders.sellOrders.Add(vendingOffer);
                }

                CustomRefill(maxRefill: true);
            }

            private void ScheduleRefill(int offerIndex, VendingOffer offer, int min = 0)
            {
                _refillTimes[offerIndex] = Time.realtimeSinceStartup + Math.Max(offer.RefillDelay, min);
            }

            private void ScheduleDelayedRefill(int offerIndex, VendingOffer offer)
            {
                ScheduleRefill(offerIndex, offer, 300);
            }

            private void StopRefilling(int offerIndex)
            {
                _refillTimes[offerIndex] = float.MaxValue;
            }

            private void CustomRefill(bool maxRefill = false)
            {
                if (_vendingMachine.IsDestroyed)
                {
                    return;
                }

                for (var offerIndex = 0; offerIndex < Profile.Offers.Length; offerIndex++)
                {
                    if (_refillTimes[offerIndex] > Time.realtimeSinceStartup)
                    {
                        continue;
                    }

                    var offer = Profile.Offers[offerIndex];
                    if (!offer.IsValid || offer.SellItem.Amount <= 0 || offer.CurrencyItem.Amount <= 0)
                    {
                        StopRefilling(offerIndex);
                        continue;
                    }

                    var itemQuery = ItemQuery.FromSellItem(offer.SellItem);
                    var numPurchasesInStock = ItemUtils.SumContainerItems(_vendingMachine.inventory, ref itemQuery) / offer.SellItem.Amount;
                    var refillNumberOfPurchases = offer.RefillMax - numPurchasesInStock;

                    if (!maxRefill)
                    {
                        refillNumberOfPurchases = Mathf.Min(refillNumberOfPurchases, offer.RefillAmount);
                    }

                    if (refillNumberOfPurchases <= 0)
                    {
                        ScheduleRefill(offerIndex, offer);
                        continue;
                    }

                    int refillAmount;

                    try
                    {
                        refillAmount = checked(refillNumberOfPurchases * offer.SellItem.Amount);
                    }
                    catch (OverflowException ex)
                    {
                        LogError($"Cannot multiply {refillNumberOfPurchases} by {offer.SellItem.Amount} because the result is too large. You have misconfigured the plugin. It is not necessary to stock that much of any item. Please reduce Max Stock or Refill Amount for item {offer.SellItem.ShortName}.\n" + ex.ToString());

                        // Prevent further refills to avoid spamming the console since this case cannot be fixed without editing the vending machine.
                        StopRefilling(offerIndex);
                        continue;
                    }

                    // Always increase the quantity of an existing item if present, rather than creating a new item.
                    // This is done to prevent ridiculous configurations from potentially filling up the vending machine with specific items.
                    var existingItem = ItemUtils.FindFirstContainerItem(_vendingMachine.inventory, ref itemQuery);
                    if (existingItem != null)
                    {
                        try
                        {
                            existingItem.amount = checked(existingItem.amount + refillAmount);
                            existingItem.MarkDirty();
                            ScheduleRefill(offerIndex, offer);
                        }
                        catch (OverflowException ex)
                        {
                            LogError($"Cannot add {refillAmount} to {existingItem.amount} because the result is too large. You have misconfigured the plugin. It is not necessary to stock that much of any item. Please reduce Max Stock or Refill Amount for item {offer.SellItem.ShortName}.\n" + ex.ToString());

                            // Reduce refill rate to avoid spamming the console.
                            ScheduleDelayedRefill(offerIndex, offer);
                        }
                        continue;
                    }

                    var item = offer.SellItem.Create(refillAmount);
                    if (item == null)
                    {
                        LogError($"Unable to create item '{offer.SellItem.ShortName}'. Does that item exist? Was it removed from the game?");

                        // Prevent further refills to avoid spamming the console since this case cannot be fixed without editing the vending machine.
                        StopRefilling(offerIndex);
                        continue;
                    }

                    _vendingMachine.transactionActive = true;

                    if (item.MoveToContainer(_vendingMachine.inventory, allowStack: false))
                    {
                        ScheduleRefill(offerIndex, offer);
                    }
                    else
                    {
                        LogError($"Unable to add {item.amount} '{item.info.shortname}' because the vending machine container rejected it.");

                        item.Remove();

                        // Reduce refill rate to avoid spamming the console.
                        ScheduleDelayedRefill(offerIndex, offer);
                    }

                    _vendingMachine.transactionActive = false;
                }
            }

            private void TimedRefill() => CustomRefill();

            private void DestroyAdminUI(BasePlayer player)
            {
                CuiHelper.DestroyUi(player, AdminUIRenderer.UIName);
            }

            private void DestroyShopUI(BasePlayer player)
            {
                CuiHelper.DestroyUi(player, ShopUIRenderer.UIName);
            }

            private void DestroyUIs()
            {
                foreach (var player in _adminUIViewers)
                {
                    DestroyAdminUI(player);
                }

                foreach (var player in _shopUIViewers)
                {
                    DestroyShopUI(player);
                }
            }

            private void DisableVanillaBehavior()
            {
                _vendingMachine.CancelInvoke(_vendingMachine.InstallFromVendingOrders);
                _vendingMachine.CancelInvoke(_vendingMachine.Refill);

                InvokeRandomized(TimedRefill, 1, 1, 0.1f);
            }

            private void ResetToVanilla()
            {
                CancelInvoke(TimedRefill);

                if (_originalShopName != null)
                {
                    _vendingMachine.shopName = _originalShopName;
                }

                if (_originalBroadcast != null && _originalBroadcast != _vendingMachine.IsBroadcasting())
                {
                    _vendingMachine.SetFlag(VendingMachineFlags.Broadcasting, _originalBroadcast.Value);
                    _vendingMachine.UpdateMapMarker();
                }

                _vendingMachine.InstallFromVendingOrders();
                _vendingMachine.InvokeRandomized(_vendingMachine.Refill, 1f, 1f, 0.1f);
            }
        }

        #endregion

        #region Legacy Saved Data

        private class LegacyVendingItem
        {
            public string Shortname = string.Empty;
            public string DisplayName = string.Empty;
            public int Amount = 1;
            public ulong Skin = 0;
            public bool IsBlueprint = false;
        }

        private class LegacyVendingOffer
        {
            public LegacyVendingItem Currency = new LegacyVendingItem();
            public LegacyVendingItem SellItem = new LegacyVendingItem();
        }

        private class LegacyVendingProfile
        {
            public string Id;
            public List<LegacyVendingOffer> Offers = new List<LegacyVendingOffer>();

            public string Shortname;
            public Vector3 WorldPosition;
            public Vector3 RelativePosition;
            public string RelativeMonument;

            public bool DetectByShortname = false;
        }

        #endregion

        #region Saved Data

        private class CaseInsensitiveDictionary<TValue> : Dictionary<string, TValue>
        {
            public CaseInsensitiveDictionary() : base(StringComparer.OrdinalIgnoreCase) {}

            public CaseInsensitiveDictionary(Dictionary<string, TValue> dict) : base(dict, StringComparer.OrdinalIgnoreCase) {}
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class VendingItem
        {
            public static VendingItem FromItem(Item item)
            {
                ItemDefinition ammoType;
                var ammoAmount = GetAmmoAmountAndType(item, out ammoType);

                return new VendingItem
                {
                    ShortName = item.IsBlueprint() ? item.blueprintTargetDef.shortname : item.info.shortname,
                    Amount = item.amount,
                    DisplayName = item.name,
                    SkinId = item.skin,
                    IsBlueprint = item.blueprintTarget != 0,
                    DataInt = item.instanceData?.dataInt ?? 0,
                    AmmoAmount = ammoAmount,
                    AmmoType = ammoType?.shortname,
                    Position = item.position,
                    Capacity = item.contents?.capacity ?? 0,
                    Contents = item.contents?.itemList?.Count > 0 ? SerializeContents(item.contents.itemList) : null,
                };
            }

            private static List<VendingItem> SerializeContents(List<Item> itemList)
            {
                var vendingItemList = new List<VendingItem>(itemList.Count);

                foreach (var item in itemList)
                {
                    vendingItemList.Add(FromItem(item));
                }

                return vendingItemList;
            }

            private static int GetAmmoAmountAndType(Item item, out ItemDefinition ammoType)
            {
                ammoType = null;

                var heldEntity = item.GetHeldEntity();
                if (heldEntity == null)
                    return -1;

                var baseProjectile = heldEntity as BaseProjectile;
                if ((object)baseProjectile != null)
                {
                    ammoType = baseProjectile.primaryMagazine?.ammoType;
                    return baseProjectile.primaryMagazine?.contents ?? 0;
                }

                var flameThrower = heldEntity as FlameThrower;
                if ((object)flameThrower != null)
                {
                    return flameThrower.ammo;
                }

                return -1;
            }

            [JsonProperty("ShortName")]
            public string ShortName;

            [JsonProperty("DisplayName", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public string DisplayName;

            [JsonProperty("Amount")]
            public int Amount = 1;

            [JsonProperty("Skin", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public ulong SkinId;

            [JsonProperty("IsBlueprint", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public bool IsBlueprint;

            [JsonProperty("DataInt", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public int DataInt;

            [JsonProperty("Position", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public int Position;

            [JsonProperty("Ammo", DefaultValueHandling = DefaultValueHandling.Ignore)]
            [DefaultValue(-1)]
            public int AmmoAmount = -1;

            [JsonProperty("AmmoType", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public string AmmoType;

            [JsonProperty("Capacity", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public int Capacity;

            [JsonProperty("Contents", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public List<VendingItem> Contents;

            private ItemDefinition _itemDefinition;
            public ItemDefinition ItemDefinition
            {
                get
                {
                    if ((object)_itemDefinition == null && ShortName != null)
                    {
                        _itemDefinition = ItemManager.FindItemDefinition(ShortName);
                    }

                    return _itemDefinition;
                }
            }

            private ItemDefinition _ammoTypeDefinition;
            public ItemDefinition AmmoTypeDefinition
            {
                get
                {
                    if ((object)_ammoTypeDefinition == null && AmmoType != null)
                    {
                        _ammoTypeDefinition = ItemManager.FindItemDefinition(AmmoType);
                    }

                    return _ammoTypeDefinition;
                }
            }

            public bool IsValid => (object)ItemDefinition != null;
            public int ItemId => ItemDefinition.itemid;

            public Item Create(int amount)
            {
                Item item;
                if (IsBlueprint)
                {
                    item = ItemManager.CreateByItemID(BlueprintItemId, amount, SkinId);
                    item.blueprintTarget = ItemDefinition.itemid;
                }
                else
                {
                    item = ItemManager.Create(ItemDefinition, amount, SkinId);
                }

                if (item == null)
                    return null;

                item.name = DisplayName;
                item.position = Position;

                if (DataInt != 0)
                {
                    if (item.instanceData == null)
                    {
                        item.instanceData = new ProtoBuf.Item.InstanceData();
                        item.instanceData.ShouldPool = false;
                    }

                    item.instanceData.dataInt = DataInt;
                }

                if (Contents != null && Contents.Count > 0)
                {
                    if (item.contents == null)
                    {
                        item.contents = new ItemContainer();
                        item.contents.ServerInitialize(null, Math.Max(Capacity, Contents.Count));
                        item.contents.GiveUID();
                        item.contents.parent = item;
                    }
                    else
                    {
                        item.contents.capacity = Math.Max(item.contents.capacity, Capacity);
                    }

                    foreach (var childItemSpec in Contents)
                    {
                        var childItem = childItemSpec.Create(childItemSpec.Amount);
                        if (!childItem.MoveToContainer(item.contents, childItemSpec.Position))
                        {
                            childItem.Remove();
                        }
                    }
                }

                var heldEntity = item.GetHeldEntity();
                if (heldEntity != null)
                {
                    var baseProjectile = heldEntity as BaseProjectile;
                    if ((object)baseProjectile != null)
                    {
                        var magazine = baseProjectile.primaryMagazine;
                        if (magazine != null)
                        {
                            if (AmmoAmount >= 0)
                            {
                                magazine.contents = AmmoAmount;
                            }

                            if (AmmoType != null)
                            {
                                magazine.ammoType = AmmoTypeDefinition;
                            }
                        }
                    }

                    var flameThrower = heldEntity as FlameThrower;
                    if ((object)flameThrower != null)
                    {
                        flameThrower.ammo = AmmoAmount;
                    }
                }

                // Set the placeholder flag so that Enchanted Items doesn't transform the artifact into an enchanted item yet.
                item.SetFlag(Item.Flag.Placeholder, true);

                return item;
            }

            public Item Create() => Create(Amount);

            public VendingItem Copy()
            {
                return new VendingItem
                {
                    ShortName = ShortName,
                    DisplayName = DisplayName,
                    Amount = Amount,
                    SkinId = SkinId,
                    IsBlueprint = IsBlueprint,
                    DataInt = DataInt,
                    Position = Position,
                    AmmoAmount = AmmoAmount,
                    AmmoType = AmmoType,
                    Capacity = Capacity,
                    Contents = Contents,
                };
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class VendingOffer
        {
            public const int DefaultRefillMax = 10;
            public const int DefaultRefillDelay = 10;
            public const int DefaultRefillAmount = 1;

            public static VendingOffer FromVanillaSellOrder(SellOrder sellOrder, NPCVendingOrder.Entry manifestEntry)
            {
                return new VendingOffer
                {
                    SellItem = new VendingItem
                    {
                        ShortName = ItemManager.FindItemDefinition(sellOrder.itemToSellID)?.shortname,
                        Amount = sellOrder.itemToSellAmount,
                        IsBlueprint = sellOrder.itemToSellIsBP,
                    },
                    CurrencyItem = new VendingItem
                    {
                        ShortName = ItemManager.FindItemDefinition(sellOrder.currencyID)?.shortname,
                        Amount = sellOrder.currencyAmountPerItem,
                        IsBlueprint = sellOrder.currencyIsBP,
                    },
                    RefillDelay = manifestEntry != null ? (int)manifestEntry.refillDelay : DefaultRefillDelay,
                };
            }

            public static VendingOffer FromItems(CustomVendingSetup plugin, BasePlayer player, Item sellItem, Item currencyItem, Item settingsItem)
            {
                var offer = new VendingOffer
                {
                    SellItem = VendingItem.FromItem(sellItem),
                    CurrencyItem = VendingItem.FromItem(currencyItem),
                };

                offer.SellItem.Position = 0;
                offer.CurrencyItem.Position = 0;

                if (settingsItem != null)
                {
                    var refillMaxLabel = plugin.GetMessage(player, Lang.SettingsRefillMax);
                    var refillDelayLabel = plugin.GetMessage(player, Lang.SettingsRefillDelay);
                    var refillAmountLabel = plugin.GetMessage(player, Lang.SettingsRefillAmount);

                    var localizedSettings = ParseSettingsItem(settingsItem);

                    int refillMax;
                    if (TryParseIntKey(localizedSettings, refillMaxLabel, out refillMax))
                        offer.RefillMax = refillMax;

                    int refillDelay;
                    if (TryParseIntKey(localizedSettings, refillDelayLabel, out refillDelay))
                        offer.RefillDelay = refillDelay;

                    int refillAmount;
                    if (TryParseIntKey(localizedSettings, refillAmountLabel, out refillAmount))
                        offer.RefillAmount = refillAmount;

                    // Allow other plugins to parse the settings and populate custom settings.
                    // Other plugins determine data file keys, as well as localized option names.
                    var customSettings = new CaseInsensitiveDictionary<object>();
                    ExposedHooks.OnCustomVendingSetupOfferSettingsParse(localizedSettings, customSettings);
                    if (customSettings.Count > 0)
                    {
                        offer.CustomSettings = customSettings;
                    }
                }

                return offer;
            }

            private static CaseInsensitiveDictionary<string> ParseSettingsItem(Item settingsItem)
            {
                var dict = new CaseInsensitiveDictionary<string>();
                if (string.IsNullOrEmpty(settingsItem.text))
                    return dict;

                foreach (var line in settingsItem.text.Split('\n'))
                {
                    var parts = line.Split(':');
                    if (parts.Length < 2)
                        continue;

                    dict[parts[0].Trim()] = parts[1].Trim();
                }

                return dict;
            }

            private static bool TryParseIntKey(Dictionary<string, string> dict, string key, out int result)
            {
                result = 0;
                string stringValue;
                return dict.TryGetValue(key, out stringValue)
                    && int.TryParse(stringValue, out result);
            }

            [JsonProperty("SellItem")]
            public VendingItem SellItem;

            [JsonProperty("CurrencyItem")]
            public VendingItem CurrencyItem;

            [JsonProperty("RefillMax", DefaultValueHandling = DefaultValueHandling.Ignore)]
            [DefaultValue(DefaultRefillMax)]
            public int RefillMax = DefaultRefillMax;

            [JsonProperty("RefillDelay", DefaultValueHandling = DefaultValueHandling.Ignore)]
            [DefaultValue(DefaultRefillDelay)]
            public int RefillDelay = DefaultRefillDelay;

            [JsonProperty("RefillAmount", DefaultValueHandling = DefaultValueHandling.Ignore)]
            [DefaultValue(DefaultRefillAmount)]
            public int RefillAmount = DefaultRefillAmount;

            [JsonProperty("CustomSettings", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public CaseInsensitiveDictionary<object> CustomSettings;

            public bool IsValid => SellItem.IsValid && CurrencyItem.IsValid;

            public VendingOffer Copy()
            {
                return new VendingOffer
                {
                    SellItem = SellItem.Copy(),
                    CurrencyItem = CurrencyItem.Copy(),
                    RefillMax = RefillMax,
                    RefillDelay = RefillDelay,
                    RefillAmount = RefillAmount,
                    CustomSettings = CustomSettings != null
                        ? new CaseInsensitiveDictionary<object>(CustomSettings)
                        : null,
                };
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class VendingProfile : IMonumentRelativePosition
        {
            public static VendingProfile FromVendingMachine(NPCVendingMachine vendingMachine, MonumentRelativePosition location = null)
            {
                return new VendingProfile
                {
                    ShopName = vendingMachine.shopName,
                    Broadcast = vendingMachine.IsBroadcasting(),
                    Monument = location?.GetMonumentPrefabName(),
                    MonumentAlias = location?.GetMonumentAlias(),
                    Position = location?.GetPosition() ?? Vector3.zero,
                };
            }

            [JsonProperty("ShopName", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public string ShopName;

            [JsonProperty("Broadcast", DefaultValueHandling = DefaultValueHandling.Ignore)]
            [DefaultValue(true)]
            public bool Broadcast = true;

            [JsonProperty("DroneAccessible", DefaultValueHandling = DefaultValueHandling.Ignore)]
            [DefaultValue(true)]
            public bool DroneAccessible = true;

            [JsonProperty("Monument", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public string Monument;

            [JsonProperty("MonumentAlias", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public string MonumentAlias;

            [JsonProperty("Position", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public Vector3 Position;

            [JsonProperty("LegacyPosition", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public Vector3 LegacyPosition;

            [JsonProperty("Offers")]
            public VendingOffer[] Offers;

            public VendingOffer GetOfferForSellOrderIndex(int index)
            {
                var sellOrderIndex = 0;

                for (var offerIndex = 0; offerIndex < Offers.Length; offerIndex++)
                {
                    var offer = Offers[offerIndex];
                    if (!offer.IsValid)
                        continue;

                    if (sellOrderIndex == index)
                        return offer;

                    sellOrderIndex++;
                }

                return null;
            }

            public bool HasPaymentProviderCurrency(PaymentProviderConfig paymentProviderConfig)
            {
                foreach (var offer in Offers)
                {
                    if (paymentProviderConfig.MatchesItem(offer.CurrencyItem))
                        return true;
                }

                return false;
            }

            // IMonumentRelativePosition members.
            public string GetMonumentPrefabName() => Monument;
            public string GetMonumentAlias() => MonumentAlias;
            public Vector3 GetPosition() => Position;
            public Vector3 GetLegacyPosition() => LegacyPosition;

            [OnDeserialized]
            private void OnDeserialized(StreamingContext context)
            {
                UpdateOldSaddleOffers();
            }

            private void UpdateOldSaddleOffers()
            {
                if (Offers == null)
                    return;

                VendingOffer singleSaddleOffer = null;
                var singleSaddleIndex = -1;

                for (var i = 0; i < Offers.Length; i++)
                {
                    var offer = Offers[i];
                    if (offer.SellItem.ShortName == "horse.saddle")
                    {
                        // Copy serialized fields, and change the short name. This will reset the cached ItemDefinition.
                        offer.SellItem = offer.SellItem.Copy();
                        offer.SellItem.ShortName = "horse.saddle.single";
                        singleSaddleOffer = offer;
                        singleSaddleIndex = i;
                        break;
                    }
                }

                if (singleSaddleOffer != null && singleSaddleIndex >= 0 && Offers.Length < MaxVendingOffers)
                {
                    var doubleSaddleOffer = singleSaddleOffer.Copy();
                    doubleSaddleOffer.SellItem.ShortName = "horse.saddle.double";
                    doubleSaddleOffer.CurrencyItem.Amount = Mathf.FloorToInt(doubleSaddleOffer.CurrencyItem.Amount * 1.2f);

                    var newOfferList = new List<VendingOffer>(Offers);
                    newOfferList.Insert(singleSaddleIndex + 1, doubleSaddleOffer);
                    Offers = newOfferList.ToArray();
                }
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class SavedData
        {
            // Legacy data for v1.
            [JsonProperty("Vendings", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public List<LegacyVendingProfile> Vendings;

            [JsonProperty("VendingProfiles")]
            public List<VendingProfile> VendingProfiles = new List<VendingProfile>();

            public static SavedData Load()
            {
                var data = Interface.Oxide.DataFileSystem.ReadObject<SavedData>(nameof(CustomVendingSetup)) ?? new SavedData();

                var dataMigrated = false;

                if (data.Vendings != null)
                {
                    foreach (var legacyProfile in data.Vendings)
                    {
                        var profile = new VendingProfile
                        {
                            Monument = legacyProfile.RelativeMonument,
                            LegacyPosition = legacyProfile.RelativePosition,
                            Offers = new VendingOffer[legacyProfile.Offers.Count],
                        };

                        for (var i = 0; i < legacyProfile.Offers.Count; i++)
                        {
                            var legacyOffer = legacyProfile.Offers[i];

                            profile.Offers[i] = new VendingOffer
                            {
                                SellItem = new VendingItem
                                {
                                    ShortName = legacyOffer.SellItem.Shortname,
                                    DisplayName = !string.IsNullOrEmpty(legacyOffer.SellItem.DisplayName) ? legacyOffer.SellItem.DisplayName : null,
                                    Amount = legacyOffer.SellItem.Amount,
                                    SkinId = legacyOffer.SellItem.Skin,
                                    IsBlueprint = legacyOffer.SellItem.IsBlueprint,
                                },
                                CurrencyItem = new VendingItem
                                {
                                    ShortName = legacyOffer.Currency.Shortname,
                                    DisplayName = !string.IsNullOrEmpty(legacyOffer.Currency.DisplayName) ? legacyOffer.Currency.DisplayName : null,
                                    Amount = legacyOffer.Currency.Amount,
                                    SkinId = legacyOffer.Currency.Skin,
                                    IsBlueprint = legacyOffer.Currency.IsBlueprint,
                                },
                            };
                        }

                        data.VendingProfiles.Add(profile);
                    }

                    dataMigrated = data.Vendings.Count > 0;
                    data.Vendings = null;
                    data.Save();
                    LogWarning($"Migrated data file to new format.");
                }

                return data;
            }

            public void Save() =>
                Interface.Oxide.DataFileSystem.WriteObject(nameof(CustomVendingSetup), this);

            public VendingProfile FindProfile(IMonumentRelativePosition location)
            {
                foreach (var profile in VendingProfiles)
                {
                    if (LocationsMatch(profile, location))
                    {
                        if (profile.LegacyPosition != Vector3.zero)
                        {
                            // Fix profile positioning.
                            profile.Position = location.GetPosition();
                            profile.LegacyPosition = Vector3.zero;
                        }
                        return profile;
                    }
                }

                return null;
            }
        }

        #endregion

        #region Configuration

        [JsonObject(MemberSerialization.OptIn)]
        private class ShopUISettings
        {
            [JsonProperty("Enable skin overlays")]
            public bool EnableSkinOverlays = false;
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class PaymentProviderConfig
        {
            [JsonProperty("Enabled")]
            public bool Enabled;

            [JsonProperty("Item short name")]
            public string ItemShortName;

            [JsonProperty("Item skin ID")]
            public ulong ItemSkinId;

            public ItemDefinition ItemDefinition { get; private set; }

            public bool EnabledAndValid => Enabled && (object)ItemDefinition != null;

            public void Init()
            {
                if (string.IsNullOrWhiteSpace(ItemShortName))
                    return;

                ItemDefinition = ItemManager.FindItemDefinition(ItemShortName);
                if (ItemDefinition == null)
                {
                    LogError($"Invalid item short name in config: {ItemShortName}");
                }
            }

            public bool MatchesItem(VendingItem vendingItem)
            {
                return Enabled && vendingItem.ItemDefinition == ItemDefinition && vendingItem.SkinId == ItemSkinId;
            }
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class Configuration : SerializableConfiguration
        {
            [JsonProperty("Shop UI settings")]
            public ShopUISettings ShopUISettings = new ShopUISettings();

            [JsonProperty("Economics integration")]
            public PaymentProviderConfig Economics = new PaymentProviderConfig();

            [JsonProperty("Server Rewards integration")]
            public PaymentProviderConfig ServerRewards = new PaymentProviderConfig();

            [JsonProperty("Override item max stack sizes (shortname: amount)")]
            public Dictionary<string, int> ItemStackSizeOverrides = new Dictionary<string, int>();

            public void Init()
            {
                Economics.Init();
                ServerRewards.Init();

                foreach (var entry in ItemStackSizeOverrides)
                {
                    if (ItemManager.FindItemDefinition(entry.Key) == null)
                    {
                        LogError($"Invalid item short name in config: {entry.Key}");
                    }
                }
            }

            public int GetItemMaxStackSize(Item item)
            {
                var maxStackSize = item.MaxStackable();

                int overrideMaxStackSize;
                if (ItemStackSizeOverrides.TryGetValue(item.info.shortname, out overrideMaxStackSize))
                {
                    maxStackSize = Math.Max(maxStackSize, overrideMaxStackSize);
                }

                return Math.Max(1, maxStackSize);
            }
        }

        private Configuration GetDefaultConfig() => new Configuration();

        #region Configuration Helpers

        private class SerializableConfiguration
        {
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(SerializableConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            bool changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                object currentRawValue;
                if (currentRaw.TryGetValue(key, out currentRawValue))
                {
                    var defaultDictValue = currentWithDefaults[key] as Dictionary<string, object>;
                    var currentDictValue = currentRawValue as Dictionary<string, object>;

                    if (defaultDictValue != null)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                            changed = true;
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _config = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(_config))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                LogError(e.Message);
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_config, true);
        }

        #endregion

        #endregion

        #region Localization

        private string GetMessage(string playerId, string messageName, params object[] args)
        {
            var message = lang.GetMessage(messageName, this, playerId);
            return args.Length > 0 ? string.Format(message, args) : message;
        }

        private string GetMessage(IPlayer player, string messageName, params object[] args) =>
            GetMessage(player.Id, messageName, args);

        private string GetMessage(BasePlayer player, string messageName, params object[] args) =>
            GetMessage(player.UserIDString, messageName, args);

        private void ReplyToPlayer(IPlayer player, string messageName, params object[] args) =>
            player.Reply(string.Format(GetMessage(player, messageName), args));

        private void ChatMessage(BasePlayer player, string messageName, params object[] args) =>
            player.ChatMessage(string.Format(GetMessage(player, messageName), args));

        private static class Lang
        {
            public const string ButtonEdit = "Button.Edit";
            public const string ButtonReset = "Button.Reset";
            public const string InfoForSale = "Info.ForSale";
            public const string ButtonSave = "Button.Save";
            public const string ButtonCancel = "Button.Cancel";
            public const string InfoCost = "Info.Cost";
            public const string InfoSettings = "Info.Settings";
            public const string SettingsRefillMax = "Settings.RefillMax";
            public const string SettingsRefillDelay = "Settings.RefillDelay";
            public const string SettingsRefillAmount = "Settings.RefillAmount";
            public const string ErrorCurrentlyBeingEdited = "Error.CurrentlyBeingEdited";
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [Lang.ButtonSave] = "SAVE",
                [Lang.ButtonCancel] = "CANCEL",
                [Lang.ButtonEdit] = "EDIT",
                [Lang.ButtonReset] = "RESET",
                [Lang.InfoForSale] = "FOR SALE",
                [Lang.InfoCost] = "COST",
                [Lang.InfoSettings] = "SETTINGS",
                [Lang.SettingsRefillMax] = "Max Stock",
                [Lang.SettingsRefillDelay] = "Seconds Between Refills",
                [Lang.SettingsRefillAmount] = "Refill Amount",
                [Lang.ErrorCurrentlyBeingEdited] = "That vending machine is currently being edited by {0}.",
            }, this, "en");
        }

        #endregion
    }
}


// --- End of file: CustomVendingSetup.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/Kitss.cs ---
// --- Original Local Path: BeeRust/Kitss.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using JetBrains.Annotations;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Rust.Workshop;
using Steamworks.ServerList;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Kits", "XAVIER", "1.0.5")]
    public class Kitss : RustPlugin
    {


        #region Class && Data

        bool HasPermission(string id, string perm) => permission.UserHasPermission(id, perm);
        const string permAllowed = "KITS.allowedCREATE";

        public class Kit
        {
            public string Name;
            public string DisplayName;
            public string DisplayNamePermission;
            public string CustomImage;
            public double Cooldown;
            public bool Hide;
            public string Permission;
            public List<KitItem> Items;
            public int UniversalNumber;
        }

        public class KitItem
        {
            public string ShortName;
            public int Amount;
            public int Blueprint;
            public ulong SkinID;
            public string Container;
            public float Condition;
            public Weapon Weapon;
            public List<ItemContent> Content;
        }

        public class Weapon
        {
            public string ammoType;
            public int ammoAmount;
        }

        public class ItemContent
        {
            public string ShortName;
            public float Condition;
            public int Amount;
        }

        public class KitsCooldown
        {
            public int Number;
            public double CoolDown;
        }


        public class CategoryKit
        {
            [JsonProperty("Название категории")] public string DisplayName;

            [JsonProperty("Картинка")] public string Image;

            [JsonProperty("Лист с китами")] public List<Kit> KitList = new List<Kit>();
        }


        public List<CategoryKit> KitLists = new List<CategoryKit>();

        public Dictionary<ulong, List<KitsCooldown>> CooldownData = new Dictionary<ulong, List<KitsCooldown>>();
        public List<ulong> OPENGUI = new List<ulong>();

        #endregion

        public string Layer = "UI_KitsLayer";
        [PluginReference] private Plugin ImageLibrary;

        public Dictionary<string, string> ImageDictionary = new Dictionary<string, string>()
        {
            ["osnova_kits"] =
                "https://cdn.discordapp.com/attachments/1089236980551929947/1177958084249915505/gfgh.png?ex=657465f4&is=6561f0f4&hm=b77ffb6f7046e53529161ab4daab5f49c3b2d140bb4a098b22547de2db46531e&",
            ["close_kits"] =
                "https://cdn.discordapp.com/attachments/1089236980551929947/1177961537051299851/213454.png?ex=6574692b&is=6561f42b&hm=e9cb740b308b225fd61a6ca6e76b03a8f82aaeca6a8412cf3f8450fe592acf0a&",
            ["kitgive"] =
                "https://cdn.discordapp.com/attachments/1089236980551929947/1178287920503853088/dfgs.png?ex=65759923&is=65632423&hm=6f54d772e9d3fdd4f9138647b0f0a033637f4d5f6a99e2a952d765ec9422a7e6&",
            ["perexodyes"] =
                "https://cdn.discordapp.com/attachments/1089236980551929947/1177966206003716226/497f179f53bee2b2.png?ex=65746d85&is=6561f885&hm=908d1ebcbc8b81dc695496ef5e2d45d940699929baf40e9d963bd2744db6ead7&",
            ["perexodno"] =
                "https://cdn.discordapp.com/attachments/1089236980551929947/1177966206003716226/497f179f53bee2b2.png?ex=65746d85&is=6561f885&hm=908d1ebcbc8b81dc695496ef5e2d45d940699929baf40e9d963bd2744db6ead7&",
            ["namekits"] =
                "https://cdn.discordapp.com/attachments/1089236980551929947/1177983357175480390/xcgdfg.png?ex=65747d7e&is=6562087e&hm=8bc0f1077d5d31fc961949618df2a75c81c27ffbb5e05c713dbe9b62cff2e4e2&",
            ["kitcooldown"] =
                "https://cdn.discordapp.com/attachments/1089236980551929947/1177984301137137804/0e9da6565e49afe8.png?ex=65747e5f&is=6562095f&hm=49d21c69d434f8ab8249c44b58519448cc31428aaa7f64eeda9f574110d860fa&",
            ["kitgivebutton"] =
                "https://cdn.discordapp.com/attachments/1089236980551929947/1177984182882930838/fcc106dabae3e41a.png?ex=65747e43&is=65620943&hm=1ae2e98c1078721e8b7f668f2fd43373113ad17816135517998eb475a4fbf04f&",
            ["back_kits"] =
                "https://cdn.discordapp.com/attachments/1089236980551929947/1177981376402833408/103a61caa3610102.png?ex=65747ba5&is=656206a5&hm=d4266620592fb6f8141d3b6f9b528ff964b4e0dad6d9f4ad09fe2e1b62f11019&",
            ["nedostupno"] =
                "https://cdn.discordapp.com/attachments/1089236980551929947/1177985346076684460/Frame_14.png?ex=65747f58&is=65620a58&hm=91d4ff1d5dde4a9b08cc231b084fa9debc6f04416a290b65b9167085c71247ba&",
            ["netmesta"] =
                "https://cdn.discordapp.com/attachments/1089236980551929947/1178287930620514374/sdgf.png?ex=65759926&is=65632426&hm=ba9a2843ecb00bee50416cc8d785d442c06eaeaa875cb2155fda92e62f676ac6&",
            ["prosmotr"] =
                "https://cdn.discordapp.com/attachments/1089236980551929947/1177986745468452974/ghdfgh.png?ex=657480a6&is=65620ba6&hm=fc95f3b1b15c6132098d86dc3a4c3b2d1d72cdbd7f4beb051b8669f6ceea7c45&",
            ["line"] =
                "https://cdn.discordapp.com/attachments/1061898344269627392/1172128567711252490/Rectangle_217.png",
        };

        void Init()
        {
            permission.RegisterPermission(permAllowed, this);
        }



        void OnServerInitialized()
        {
            try
            {
                KitLists = Interface.GetMod().DataFileSystem.ReadObject<List<CategoryKit>>("HKits/KitList");
                CooldownData = Interface.GetMod().DataFileSystem
                    .ReadObject<Dictionary<ulong, List<KitsCooldown>>>("HKits/CooldownPlayer");
            }
            catch
            {
                CooldownData = new Dictionary<ulong, List<KitsCooldown>>();
                KitLists = new List<CategoryKit>();
            }



            if (ImageLibrary == null || !ImageLibrary.IsLoaded)
            {
                PrintError("IMAGE LIBRARY IS NOT INSTALLED!");
            }
            else
            {
                var imagesList = new Dictionary<string, string>();


                KitLists.ForEach(kit =>
                {
                    if (!ImageLibrary.Call<bool>("HasImage", kit.Image))
                    {
                        if (!string.IsNullOrEmpty(kit.Image) && !imagesList.ContainsKey(kit.Image))
                        {
                            imagesList.Add(kit.Image, kit.Image);
                        }
                    }

                    kit.KitList.ForEach(img =>
                    {
                        if (!permission.PermissionExists(img.Permission, this))
                        {
                            permission.RegisterPermission(img.Permission, this);
                        }

                        if (!ImageLibrary.Call<bool>("HasImage", img.CustomImage) &&
                            !string.IsNullOrEmpty(img.CustomImage) && !imagesList.ContainsKey(img.CustomImage))
                            imagesList.Add(img.CustomImage, img.CustomImage);

                    });
                });
                ImageLibrary?.Call("ImportImageList", Title, imagesList, 0UL, true);

            }

            ImageDictionary.ToList().ForEach(img => { ImageLibrary?.Call("AddImage", img.Value, img.Key); });
            foreach (var basePlayer in BasePlayer.activePlayerList)
            {
                OnPlayerConnected(basePlayer);
            }

            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, Layer);
                CuiHelper.DestroyUi(player, LayerTest);
            }
        }



        void Unload()
        {
            Interface.Oxide.DataFileSystem.WriteObject("HKits/KitList", KitLists);
            Interface.Oxide.DataFileSystem.WriteObject("HKits/CooldownPlayer", CooldownData);
            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, Layer);
                CuiHelper.DestroyUi(player, LayerTest);
            }
        }



        void OnPlayerConnected(BasePlayer player)
        {
            if (!CooldownData.ContainsKey(player.userID))
            {
                CooldownData.Add(player.userID, new List<KitsCooldown>());
            }
        }

        void OnPlayerDisconnected(BasePlayer player)
        {
            if (OPENGUI.Contains(player.userID))
                OPENGUI.Remove(player.userID);
        }

        #region GiveItem

        private List<KitItem> GetItemPlayer(BasePlayer player)
        {
            List<KitItem> kititems = new List<KitItem>();
            foreach (Item item in player.inventory.containerWear.itemList)
            {
                if (item != null)
                {
                    var iteminfo = ItemAddToKit(item, "wear");
                    kititems.Add(iteminfo);
                }
            }

            foreach (Item item in player.inventory.containerMain.itemList)
            {
                if (item != null)
                {
                    var iteminfo = ItemAddToKit(item, "main");
                    kititems.Add(iteminfo);
                }
            }

            foreach (Item item in player.inventory.containerBelt.itemList)
            {
                if (item != null)
                {
                    var iteminfo = ItemAddToKit(item, "belt");
                    kititems.Add(iteminfo);
                }
            }

            return kititems;
        }

        private KitItem ItemAddToKit(Item item, string container)
        {
            KitItem kitem = new KitItem();
            kitem.Amount = item.amount;
            kitem.Container = container;
            kitem.SkinID = item.skin;
            kitem.Blueprint = item.blueprintTarget;
            kitem.ShortName = item.info.shortname;
            kitem.Condition = item.condition;
            kitem.Weapon = null;
            kitem.Content = null;
            if (item.info.category == ItemCategory.Weapon)
            {
                BaseProjectile weapon = item.GetHeldEntity() as BaseProjectile;
                if (weapon != null)
                {
                    kitem.Weapon = new Weapon();
                    kitem.Weapon.ammoType = weapon.primaryMagazine.ammoType.shortname;
                    kitem.Weapon.ammoAmount = weapon.primaryMagazine.contents;
                }
            }

            if (item.contents != null)
            {
                kitem.Content = new List<ItemContent>();
                foreach (var cont in item.contents.itemList)
                {
                    kitem.Content.Add(new ItemContent()
                        {
                            Amount = cont.amount,
                            Condition = cont.condition,
                            ShortName = cont.info.shortname
                        }
                    );
                }
            }

            return kitem;
        }
        
        
        
        public List<String> AutoKit = new List<String>()
        {
            "autokit1",
            "autokit2",
            "autokit3"
        };
        void OnPlayerRespawned(BasePlayer player)
        {
            foreach (var value in KitLists.Select(p => p.KitList))
            {
                foreach (var key in value)
                {
                    foreach (String kitName in AutoKit)
                    {
                        if (key.Name == kitName && permission.UserHasPermission(player.UserIDString, key.Permission))
                        {
                            player.inventory.Strip();
                            GiveItems(player, key);
                        }
                    }
                }
            }
        }


        private void GiveItems(BasePlayer player, Kit kit)
        {
            foreach (var kitem in kit.Items)
            {
                GiveItem(player,
                    BuildItem(kitem.ShortName, kitem.Amount, kitem.SkinID, kitem.Condition, kitem.Blueprint,
                        kitem.Weapon, kitem.Content),
                    kitem.Container == "belt" ? player.inventory.containerBelt :
                    kitem.Container == "wear" ? player.inventory.containerWear : player.inventory.containerMain);
            }
        }

        private void GiveItem(BasePlayer player, Item item, ItemContainer cont = null)
        {
            if (item == null) return;
            var iventory = player.inventory;
            var moved = item.MoveToContainer(cont) || item.MoveToContainer(iventory.containerMain);
            if (!moved)
            {
                if (cont == iventory.containerBelt) moved = item.MoveToContainer(iventory.containerWear);
                if (cont == iventory.containerWear) moved = item.MoveToContainer(iventory.containerBelt);
            }

            if (!moved) item.Drop(player.GetCenter(), player.GetDropVelocity());
        }

        private Item BuildItem(string ShortName, int Amount, ulong SkinID, float Condition, int blueprintTarget,
            Weapon weapon, List<ItemContent> Content)
        {
            Item item = ItemManager.CreateByName(ShortName, Amount, SkinID);
            item.condition = Condition;
            if (blueprintTarget != 0)
            {
                item.blueprintTarget = blueprintTarget;
            }

            if (weapon != null)
            {
                var getheld = item.GetHeldEntity() as BaseProjectile;
                if (getheld != null)
                {
                    getheld.primaryMagazine.contents = weapon.ammoAmount;
                    getheld.primaryMagazine.ammoType = ItemManager.FindItemDefinition(weapon.ammoType);
                }
            }

            if (Content != null)
            {
                foreach (var cont in Content)
                {
                    Item conts = ItemManager.CreateByName(cont.ShortName, cont.Amount);
                    conts.condition = cont.Condition;
                    conts.MoveToContainer(item.contents);
                }
            }

            return item;
        }

        #endregion



        [ChatCommand("kit")]
        void KitFunc(BasePlayer player, string command, string[] args)
        {
            if (args.Length == 0)
            {
                if (OPENGUI.Contains(player.userID))
                    return;

                OpenKitMenu(player);
                OPENGUI.Add(player.userID);
                return;
            }

            if (args.Length > 0)
            {
                if (args[0] == "create")
                {
                    if (HasPermission(player.UserIDString, permAllowed))
                    {
                        if (args.Length < 2)
                        {
                            player.ChatMessage("Ошибка: /kit create <NAME>");
                            return;
                        }

                        CreateCategory(player, args[1]);
                    }
                }

                if (args[0] == "add")
                {
                    if (!HasPermission(player.UserIDString, permAllowed))
                    {
                        return;
                    }

                    if (args.Length < 3)
                    {
                        player.ChatMessage("Ошибка: /kit add <NAME> <CATEGORY>");
                        return;
                    }

                    AddKits(player, args[1], args[2], "kits.default");
                }
            }
        }


        void CreateCategory(BasePlayer player, string category)
        {
            if (KitLists.FirstOrDefault(p => p.DisplayName == category) == null)
            {
                string Image =
                    "https://media.discordapp.net/attachments/1061898344269627392/1107331810075095060/EbpKAtY.png";
                KitLists.Add(new CategoryKit
                {
                    DisplayName = category,
                    Image = Image,
                    KitList = new List<Kit>()
                });
                player.ChatMessage($"Вы успешно создали категорию с названием - {category}");
                ImageLibrary?.Call("AddImage", Image, Image);
            }
            else
            {
                player.ChatMessage($"Категория {category} уже существует!");
            }
        }

        [ConsoleCommand("give.kit")]
        void GivToKit(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Player();
            if (!args.HasArgs())
            {
                player.ChatMessage("Произошла ошибка #1 при выдаче! Отпишитесь администрации!");
                return;
            }

            GiveKitCategory(player, args.Args[0], args.Args[1]);
        }

        public string LayerNotif = "UI_KitsNotif";

        void NotifUIGive(BasePlayer player, string nameImage)
        {
            CuiHelper.DestroyUi(player, LayerNotif);
            var container = new CuiElementContainer();
            var Panel = container.Add(new CuiPanel
            {
                Image = { Color = "0 0 0 0" },
                RectTransform = { AnchorMin = "0.8171875 0.9055555", AnchorMax = "0.9822917 0.9694445" },
                CursorEnabled = false,
            }, "Overlay", LayerNotif);


            container.Add(new CuiElement
            {
                FadeOut = 0.3f,
                Parent = LayerNotif,
                Components =
                {
                    new CuiRawImageComponent
                        { FadeIn = 0.3f, Png = (string)ImageLibrary?.Call("GetImage", nameImage) },
                    new CuiRectTransformComponent
                        { AnchorMin = "0 0", AnchorMax = "1 1" }
                }
            });

            CuiHelper.AddUi(player, container);
            timer.Once(5, () =>
            {
                if (player != null)
                {
                    CuiHelper.DestroyUi(player, LayerNotif);
                }
            });
        }

        object GiveKit(BasePlayer player, string nameKit)
        {
            var find = KitLists.Find(p => p.KitList.Find(x => x.Name == nameKit) != null);
            if (find != null)
            {
                var kit = find.KitList.Find(p => p.Name == nameKit);
                if (kit == null) return false;
                int beltcount = kit.Items.Where(i => i.Container == "belt").Count();
                int wearcount = kit.Items.Where(i => i.Container == "wear").Count();
                int maincount = kit.Items.Where(i => i.Container == "main").Count();
                int totalcount = beltcount + wearcount + maincount;
                if ((player.inventory.containerBelt.capacity - player.inventory.containerBelt.itemList.Count) <
                    beltcount ||
                    (player.inventory.containerWear.capacity - player.inventory.containerWear.itemList.Count) <
                    wearcount ||
                    (player.inventory.containerMain.capacity - player.inventory.containerMain.itemList.Count) <
                    maincount)
                    if (totalcount > (player.inventory.containerMain.capacity -
                                      player.inventory.containerMain.itemList.Count))
                    {
                        return false;
                    }

                GiveItems(player, kit);
                return true;
            }

            return false;
        }


        void GiveKitCategory(BasePlayer player, string category, string kitname)
        {
            var findCategoryKit = KitLists.FirstOrDefault(p => p.DisplayName.ToLower() == category.ToLower());
            if (findCategoryKit == null)
            {
                player.ChatMessage("Произошла ошибка #2 при выдаче! Отпишитесь администрации!");
                return;
            }

            var find = findCategoryKit.KitList.FirstOrDefault(p => p.Name.ToLower() == kitname.ToLower());
            if (find != null)
            {
                var cooldown = CooldownData[player.userID].FirstOrDefault(p => p.Number == find.UniversalNumber);
                if (cooldown != null)
                {
                    var time = cooldown.CoolDown - CurrentTime();
                    if (time > 0)
                    {
                        player.ChatMessage(
                            $"<color=#ff0000><b>[TIMERUST] </b></color><color=#efedee>Подожди</color><color=#4cfa00> {TimeExtensions.FormatShortTime(TimeSpan.FromSeconds(time))}</color><color=#efedee>и возмёшь свой кит</color>");
                        return;
                    }

                    if (time <= 0)
                    {
                        CooldownData[player.userID].Remove(cooldown);
                    }

                    int beltcount = find.Items.Where(i => i.Container == "belt").Count();
                    int wearcount = find.Items.Where(i => i.Container == "wear").Count();
                    int maincount = find.Items.Where(i => i.Container == "main").Count();
                    int totalcount = beltcount + wearcount + maincount;
                    if ((player.inventory.containerBelt.capacity - player.inventory.containerBelt.itemList.Count) <
                        beltcount ||
                        (player.inventory.containerWear.capacity - player.inventory.containerWear.itemList.Count) <
                        wearcount ||
                        (player.inventory.containerMain.capacity - player.inventory.containerMain.itemList.Count) <
                        maincount)
                        if (totalcount > (player.inventory.containerMain.capacity -
                                          player.inventory.containerMain.itemList.Count))
                        {
                            NotifUIGive(player, "netmesta");
                            return;
                        }

                    GiveItems(player, find);
                    CooldownData[player.userID].Add(new KitsCooldown
                    {
                        Number = find.UniversalNumber,
                        CoolDown = CurrentTime() + find.Cooldown
                    });

                    Interface.Oxide.DataFileSystem.WriteObject("HKits/CooldownPlayer", CooldownData);

                    NotifUIGive(player, "kitgive");
                    EffectNetwork.Send(new Effect("assets/prefabs/misc/xmas/presents/effects/unwrap.prefab", player, 0,
                            Vector3.up, Vector3.zero)
                        {
                            scale = UnityEngine.Random.Range(0f, 1f)
                        }
                    );
                }
                else
                {
                    int beltcount = find.Items.Where(i => i.Container == "belt").Count();
                    int wearcount = find.Items.Where(i => i.Container == "wear").Count();
                    int maincount = find.Items.Where(i => i.Container == "main").Count();
                    int totalcount = beltcount + wearcount + maincount;
                    if ((player.inventory.containerBelt.capacity - player.inventory.containerBelt.itemList.Count) <
                        beltcount ||
                        (player.inventory.containerWear.capacity - player.inventory.containerWear.itemList.Count) <
                        wearcount ||
                        (player.inventory.containerMain.capacity - player.inventory.containerMain.itemList.Count) <
                        maincount)
                        if (totalcount > (player.inventory.containerMain.capacity -
                                          player.inventory.containerMain.itemList.Count))
                        {
                            if (player.SecondsSinceAttacked > 15)
                            {
                                NotifUIGive(player, "netmesta");
                                player.lastAttackedTime = UnityEngine.Time.time;
                            }

                            return;
                        }

                    GiveItems(player, find);
                    CooldownData[player.userID].Add(new KitsCooldown
                    {
                        Number = find.UniversalNumber,
                        CoolDown = CurrentTime() + find.Cooldown
                    });
                    NotifUIGive(player, "kitgive");
                    EffectNetwork.Send(new Effect("assets/prefabs/misc/xmas/presents/effects/unwrap.prefab", player, 0,
                            Vector3.up, Vector3.zero)
                        {
                            scale = UnityEngine.Random.Range(0f, 1f)
                        }
                    );
                }
            }
        }

        public string GetImage(string shortname) => (string)ImageLibrary.Call("GetImage", shortname);
        private static class TimeExtensions
        {
            public static string FormatShortTime(TimeSpan time)
            {
                string result = string.Empty;
                if (time.Days != 0) result += $"{time.Days} д. ";
                if (time.Hours != 0) result += $"{time.Hours} ч. ";
                if (time.Minutes != 0) result += $"{time.Minutes} м. ";
                if (time.Seconds != 0) result += $"{time.Seconds} с. ";
                return result;
            }

            private static string Format(int units, string form1, string form2, string form3)
            {
                var tmp = units % 10;
                if (units >= 5 && units <= 20 || tmp >= 5 && tmp <= 9) return $"{units} {form1}";
                if (tmp >= 2 && tmp <= 4) return $"{units} {form2}";
                return $"{units} {form3}";
            }
        }

        static readonly DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);

        static double CurrentTime()
        {
            return DateTime.UtcNow.Subtract(epoch).TotalSeconds;
        }



        void AddKits(BasePlayer player, string name, string category, string permissions)
        {
            var find = KitLists.FirstOrDefault(p => p.DisplayName == category);
            if (find == null)
            {
                player.ChatMessage($"Категория {category} не найдена!");
                return;
            }

            if (!permission.PermissionExists(permissions, this))
            {
                permission.RegisterPermission(permissions, this);
            }

            find.KitList.Add(new Kit
            {
                Name = name,
                DisplayName = name,
                DisplayNamePermission = "DIAMOND",
                Cooldown = 600,
                Hide = false,
                Permission = permissions,
                CustomImage =
                    "https://media.discordapp.net/attachments/1061898344269627392/1107331810075095060/EbpKAtY.png",
                Items = GetItemPlayer(player),
                UniversalNumber = UnityEngine.Random.Range(0000, 9999)
            });
            player.ChatMessage($"В категорию {category} был добавлен кит с названием {name}");
        }


        List<Kit> GetKitPlayer(BasePlayer player, List<Kit> kitsList)
        {
            return kitsList.Where(p => !p.Hide && permission.UserHasPermission(player.UserIDString, p.Permission))
                .ToList();
        }


        [ConsoleCommand("close.kit")]
        void CloseKit(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Player();
            if (OPENGUI.Contains(player.userID))
            {
                CuiHelper.DestroyUi(player, Layer);
                OPENGUI.Remove(player.userID);
            }
        }


        public string LayerTest = "UI_LayerTesting";

        [ConsoleCommand("kits.open")]
        void OpenKitCategory(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Player();
            if (!args.HasArgs()) return;
            var find = KitLists.FirstOrDefault(p => p.DisplayName == args.Args[0]);
            if (find != null)
            {
                OpenCategoryKit(player, find);
            }
        }

        [ConsoleCommand("back.kits")]
        void BackKitCategory(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Player();
            OpenKitMenu(player);
        }

        private string GetFormatTime(TimeSpan timespan)
        {
            return string.Format(timespan.TotalHours >= 1 ? "{2:00}ч {0:00}м {1:00}с" : "{0:00}м {1:00} с",
                timespan.Minutes, timespan.Seconds, System.Math.Floor(timespan.TotalHours));
        }


        void OpenCategoryKit(BasePlayer player, CategoryKit kit)
        {
            CuiHelper.DestroyUi(player, Layer);
            var container = new CuiElementContainer();
            var Panel = container.Add(new CuiPanel
            {
                Image = { Color = "0 0 0 0" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                CursorEnabled = true,
            }, "Overlay", Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Button = { Color = "0 0 0 0", Command = "back.kits" }
            }, Layer);

            container.Add(new CuiElement
            {
                Parent = Layer,
                Name = Layer + ".CloseBack",
                Components =
                {
                    new CuiRawImageComponent
                        { Png = (string)ImageLibrary?.Call("GetImage", "back_kits") },
                    new CuiRectTransformComponent
                        { AnchorMin = "0.4796878 0.2351852", AnchorMax = "0.5208334 0.3092591" },
                }
            });
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Button = { Color = "0 0 0 0", Command = "back.kits" },
                Text = { Text = "" }
            }, Layer + ".CloseBack");


            var list = GetKitPlayer(player, kit.KitList);
            var page = list.Count;
            var height = 25f;
            var width = 165f;
            var margin = 15f;
            var switchs = -(width * page + (page - 1) * margin) / 2f;

            foreach (var check in list.Select((i, t) => new { A = i, B = t }))
            {
                container.Add(new CuiButton
                    {
                        RectTransform =
                        {
                            AnchorMin =
                                $"0.5 0.65",
                            AnchorMax =
                                $"0.5 0.65",
                            OffsetMin =
                                $"{switchs} -212",
                            OffsetMax =
                                $"{switchs + width} -3"
                        },
                        Button =
                        {
                            Color = "0 0 0 0",
                            Command = $""
                        },
                        Text =
                        {
                            Text = $"", Align = TextAnchor.LowerRight, Font = "robotocondensed-bold.ttf", FontSize = 15
                        }
                    }, Layer, Layer + $".{check.B}.ListItemKitCategory");
                container.Add(new CuiElement
                {
                    FadeOut = 0.3f,
                    Parent = Layer + $".{check.B}.ListItemKitCategory",
                    Name = Layer + $".{check.B}.ImgList",
                    Components =
                    {
                        new CuiRawImageComponent
                            { FadeIn = 0.3f, Png = (string)ImageLibrary?.Call("GetImage", "osnova_kits") },
                        new CuiRectTransformComponent
                            { AnchorMin = "0 0", AnchorMax = "1 1" }
                    }
                });
                container.Add(new CuiElement
                {
                    FadeOut = 0.3f,
                    Parent = Layer + $".{check.B}.ListItemKitCategory",
                    Name = Layer + $".{check.B}.ImgListNamePermission",
                    Components =
                    {
                        new CuiRawImageComponent
                            { FadeIn = 0.3f, Png = (string)ImageLibrary?.Call("GetImage", "namekits") },
                        new CuiRectTransformComponent
                            { AnchorMin = "0.266127 0.9460317", AnchorMax = "0.7217703 1.053968" }
                    }
                });
                container.Add(new CuiElement
                {
                    FadeOut = 0.3f,
                    Parent = Layer + $".{check.B}.ListItemKitCategory",
                    Name = Layer + $".{check.B}.NamePermission",
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = $"{check.A.DisplayNamePermission}", Align = TextAnchor.MiddleCenter,
                            Font = "robotocondensed-regular.ttf", Color = "0.30 0.98 0.00 1.00", FontSize = 12,
                        },
                        new CuiRectTransformComponent
                            { AnchorMin = "0.266127 0.9460317", AnchorMax = "0.7217703 1.053968" }
                    }
                });

                //container.Add(new CuiElement
                //{
                //    FadeOut = 0.3f,
                //    Parent = Layer + $".{check.B}.ListItemKitCategory",
                //    Components =
                //    {
                //        new CuiTextComponent
                //        {
                //            Text = "Подробнее 👁", Align = TextAnchor.MiddleCenter,
                //            Font = "robotocondensed-regular.ttf", Color = "0 0 0 1.00", FontSize = 12,
                //        },
                //        new CuiRectTransformComponent
                //            {AnchorMin = "0.266127 0.9460317", AnchorMax = "0.7217703 1.053968"}
                //    }
                //});

                container.Add(new CuiElement
                {
                    FadeOut = 0.3f,
                    Parent = Layer + $".{check.B}.ListItemKitCategory",
                    Name = Layer + $".{check.B}.ImgKitCategory",
                    Components =
                    {
                        new CuiRawImageComponent
                            { FadeIn = 0.3f, Png = (string)ImageLibrary?.Call("GetImage", check.A.CustomImage) },
                        new CuiRectTransformComponent
                            { AnchorMin = "0.2580646 0.4603175", AnchorMax = "0.7379035 0.8412699" }
                    }
                });
                container.Add(new CuiElement
                {
                    FadeOut = 0.3f,
                    Parent = Layer + $".{check.B}.ListItemKitCategory",
                    Name = Layer + $".{check.B}.TxtNameKit",
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = $"{check.A.DisplayName}", Align = TextAnchor.MiddleCenter,
                            Font = "robotocondensed-regular.ttf", Color = "0.972549 0.9764706 1 1", FontSize = 12,
                        },
                        new CuiRectTransformComponent
                            { AnchorMin = "0 0.3142858", AnchorMax = "1 0.3777778" }
                    }
                });

                string color = null;
                string text = null;
                string times = null;
                string image = null;
                var cooldown = CooldownData[player.userID].FirstOrDefault(p => p.Number == check.A.UniversalNumber);
                if (cooldown != null)
                {
                    double time = cooldown.CoolDown - CurrentTime();
                    if (time > 0)
                    {
                        image = "kitcooldown";
                        color = "0.4745098 0.4862745 0.5607843 1";
                        text = "Недоступно";
                        times = $"{GetFormatTime(TimeSpan.FromSeconds(time))}";
                    }
                    else
                    {
                        if (!permission.UserHasPermission(player.UserIDString, check.A.Permission))
                        {
                            image = "nedostupno";
                            color = "0.4745098 0.4862745 0.5607843 1";
                            text = "Недоступно";
                        }
                        else
                        {
                            image = "kitgivebutton";
                            color = "0.3921569 0.7490196 0.2705882 1";
                            text = "Доступно";
                        }
                    }
                }
                else
                {
                    if (!permission.UserHasPermission(player.UserIDString, check.A.Permission))
                    {
                        image = "nedostupno";
                        color = "0.4745098 0.4862745 0.5607843 1";
                        text = "Недоступно";
                    }
                    else
                    {
                        image = "kitgivebutton";
                        color = "0.3921569 0.7490196 0.2705882 1";
                        text = "Доступно";
                    }
                }



                container.Add(new CuiElement
                {
                    FadeOut = 0.3f,
                    Parent = Layer + $".{check.B}.ListItemKitCategory",
                    Name = Layer + $".{check.B}.TxtDostup",
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = text, Align = TextAnchor.MiddleCenter,
                            Font = "robotocondensed-regular.ttf", Color = color, FontSize = 10,
                        },
                        new CuiRectTransformComponent
                            { AnchorMin = "0 0.2476192", AnchorMax = "1 0.3111112" }
                    }
                });
                container.Add(new CuiElement
                {
                    FadeOut = 0.3f,
                    Parent = Layer + $".{check.B}.ListItemKitCategory",
                    Name = Layer + $".{check.B}.ImgListButtonImage",
                    Components =
                    {
                        new CuiRawImageComponent
                            { FadeIn = 0.3f, Png = (string)ImageLibrary?.Call("GetImage", image) },
                        new CuiRectTransformComponent
                            { AnchorMin = "0.05 0.05079359", AnchorMax = "0.7 0.2" }
                    }
                });





                container.Add(new CuiElement
                {
                    FadeOut = 0.3f,
                    Parent = Layer + $".{check.B}.ListItemKitCategory",
                    Name = Layer + $".{check.B}.prosmotr",
                    Components =
                    {
                        new CuiRawImageComponent
                            { FadeIn = 0.3f, Png = (string)ImageLibrary?.Call("GetImage", "prosmotr") },
                        new CuiRectTransformComponent
                            { AnchorMin = "0.72 0.05079359", AnchorMax = "0.95 0.2" }
                    }
                });

                container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                        Button = { Color = "0 0 0 0", Command = $"kit.drawkitinfo {check.A.Name} " },
                        Text = { Text = "" }
                    }, Layer + $".{check.B}.prosmotr");

                if (!string.IsNullOrEmpty(times))
                {
                    container.Add(new CuiElement
                    {
                        FadeOut = 0.3f,
                        Parent = Layer + $".{check.B}.ListItemKitCategory",
                        Name = Layer + $".{check.B}.TxtCoolDown",
                        Components =
                        {
                            new CuiTextComponent
                            {
                                Text = $"{times} м", Align = TextAnchor.MiddleCenter,
                                Font = "robotocondensed-regular.ttf", Color = "0.4745098 0.4862745 0.5607843 1",
                                FontSize = 10,
                            },
                            new CuiRectTransformComponent
                                { AnchorMin = "0.3 0.09841274", AnchorMax = "0.5 0.1619046" }
                        }       
                    });
                }
                else
                {
                    container.Add(new CuiButton
                        {
                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                            Button = { Color = "0 0 0 0", Command = $"give.kit {kit.DisplayName} {check.A.Name}" },
                            Text = { Text = "" }
                        }, Layer + $".{check.B}.ImgListButtonImage");
                }

                switchs += width + margin;
            }

            CuiHelper.AddUi(player, container);
        }



        [ConsoleCommand("kit.drawkitinfo")]
        void cmdDrawKitInfo([CanBeNull] ConsoleSystem.Arg args)
        {
            var player = args.Player();
            if (player == null || player.Connection == null) return;

            ViewInventoryKits(player, args.Args[0]);

        }
        
        private void ViewInventoryKits(BasePlayer player, string kit)
        {
            //CuiHelper.DestroyUi(player, Layer);
            
            var find = KitLists.Find(p => p.KitList.Find(x => x.Name == kit) != null);
            
            var kita = find.KitList.Find(p => p.Name == kit);
            
            var container = new CuiElementContainer();
            
            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = {AnchorMin = "0 0", AnchorMax = "1 1"},
                Image         = {Color     = "0.09 0.09 0.09 0.5", Material  = "assets/content/ui/uibackgroundblur.mat"}
            }, Layer, ".ViewInventory");
            
            container.Add(new CuiElement
            {
                Parent = ".ViewInventory",
                Components =
                {
                    new CuiImageComponent {  Color = "0 0 0 0.6", Material = "assets/icons/greyout.mat"},
                    new CuiRectTransformComponent { AnchorMin = $"0.3213542 0.8472222", AnchorMax = $"0.6177092 0.875" }
                }
            });
            
            container.Add(new CuiLabel
                {
                    Text          = {Text      = $"{kita.DisplayName}", Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter},
                    RectTransform = {AnchorMin = $"0.3213542 0.8472222", AnchorMax = $"0.6177092 0.875"},
                }, ".ViewInventory");
            
            
            container.Add(new CuiButton
            {
                RectTransform =
                {
                    AnchorMin = $"0.6208333 0.8472222", AnchorMax = $"0.6776041 0.875"
                },
                Button        =
                {
                    Color     = "0 0 0 0.6", Material = "assets/icons/greyout.mat", Close = ".ViewInventory"
                },
                Text          =
                {
                    Text      = "НАЗАД", Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "0.86 0.08 0.24 0.8"
                }
            }, ".ViewInventory");
            
            var findGDE = KitLists.Find(p => p.KitList.Find(x => x.Name == kit) != null);
            
            var kitGDE = find.KitList.Find(p => p.Name == kit);
            
            var allMain = kitGDE.Items.FindAll(p => p.Container == "main");


            for (int i = 0; i < 24; i++)
            {

                container.Add(new CuiPanel
                    {
                        RectTransform =
                        {
                            AnchorMin =
                                $"{0.3213542 + i * 0.0599 - Math.Floor((double)i / 6) * 6 * 0.0599} {0.7388889 - Math.Floor((double)i / 6) * 0.110}",
                            AnchorMax =
                                $"{0.378125 + i * 0.0599 - Math.Floor((double)i / 6) * 6 * 0.0599} {0.8416677 - Math.Floor((double)i / 6) * 0.110}",
                        },
                        Image = { Color = "0.09 0.09 0.09 0.8" },
                    }, ".ViewInventory", ".ViewInventory" + $"{i}.Main");
                
                if (allMain.Count <= i) continue;
                    
                var element = allMain[i];
                
                
                container.Add(new CuiElement
                {
                    Parent = ".ViewInventory" + $"{i}.Main",
                    Components =
                    {
                        new CuiImageComponent {ItemId = ItemManager.FindItemDefinition(element.ShortName).itemid, SkinId = element.SkinID},
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 5", OffsetMax = "-5 -5"}
                    }
                });
                
                container.Add(new CuiLabel
                    {
                        Text          = {Text      = $"x{element.Amount}", Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleRight},
                        RectTransform = {AnchorMin = $"0 0.01086909", AnchorMax = $"0.9239309 0.2934731" },
                    }, ".ViewInventory" + $"{i}.Main");
            }

            var kitGDEWear = find.KitList.Find(p => p.Name == kit);

            var allWear = kitGDEWear.Items.FindAll(p => p.Container == "wear");


            for (int i = 0; i < 7; i++)
            {
                container.Add(new CuiPanel
                    {
                        RectTransform =
                        {
                            AnchorMin = $"{0.2916672 + i * 0.0599 - Math.Floor((double)i / 7) * 7 * 0.0599} 0.2981547",
                            AnchorMax = $"{0.348438 + i * 0.0599 - Math.Floor((double)i / 7) * 7 * 0.0599} 0.4009368",
                        },
                        Image = { Color = "0.09 0.09 0.09 0.8" },
                    }, ".ViewInventory", ".ViewInventory" + $"{i}.Wear");
                
                if (allWear.Count <= i) continue;
                
                var element = allWear[i];
                
                container.Add(new CuiElement
                {
                    Parent = ".ViewInventory" + $"{i}.Wear",
                    Components =
                    {
                        new CuiImageComponent {ItemId = ItemManager.FindItemDefinition(element.ShortName).itemid, SkinId = element.SkinID},
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 5", OffsetMax = "-5 -5"}
                    }
                });
                
                container.Add(new CuiLabel
                    {
                        Text          = {Text      = $"x{element.Amount}", Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleRight},
                        RectTransform = {AnchorMin = $"0 0.01086909", AnchorMax = $"0.9239309 0.2934731" },
                    }, ".ViewInventory" + $"{i}.Wear");
            }
            
            var kitGDEBelt = find.KitList.Find(p => p.Name == kit);

            
            var allBelt = kitGDEBelt.Items.FindAll(p => p.Container == "belt");
            
            for (int i = 0; i < 6; i++)
            {
                container.Add(new CuiPanel
                    {
                        RectTransform =
                        {
                            AnchorMin = $"{0.3213542 + i * 0.0599 - Math.Floor((double)i / 7) * 7 * 0.0599} 0.1879692",
                            AnchorMax = $"{0.378125 + i * 0.0599 - Math.Floor((double)i / 7) * 7 * 0.0599} 0.2907513",
                        },
                        Image = { Color = "0.09 0.09 0.09 0.8" },
                    }, ".ViewInventory", ".ViewInventory" + $"{i}.Belt");
                
                if (allBelt.Count <= i) continue;
                
                var element = allBelt[i];
                
                container.Add(new CuiElement
                {
                    Parent = ".ViewInventory" + $"{i}.Belt",
                    Components =
                    {
                        new CuiImageComponent {ItemId = ItemManager.FindItemDefinition(element.ShortName).itemid, SkinId = element.SkinID},
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 5", OffsetMax = "-5 -5"}
                    }
                });
                
                container.Add(new CuiLabel
                    {
                        Text          = {Text      = $"x{element.Amount}", Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleRight},
                        RectTransform = {AnchorMin = $"0 0.01086909", AnchorMax = $"0.9239309 0.2934731" },
                    }, ".ViewInventory" + $"{i}.Belt");
            }


            CuiHelper.AddUi(player, container);
        }

        #region UI
            List<CategoryKit> GetCategory(BasePlayer player)
            {
                List<CategoryKit> categoryKits = new List<CategoryKit>();
                foreach (var value in KitLists)
                {
                    foreach (var kit in value.KitList)
                    {
                        if (permission.UserHasPermission(player.UserIDString, kit.Permission) &&
                            !categoryKits.Contains(value))
                        {
                            categoryKits.Add(value);
                        }
                    }
                }

                return categoryKits;
            }


            void OpenKitMenu(BasePlayer player)
            {
                CuiHelper.DestroyUi(player, Layer);
                var container = new CuiElementContainer();
                var Panel = container.Add(new CuiPanel
                {
                    Image = { Color = "0 0 0 0" },
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    CursorEnabled = true,
                }, "Overlay", Layer);

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Color = "0 0 0 0", Command = "close.kit" }
                }, Layer);

                container.Add(new CuiElement
                {
                    Parent = Layer,
                    Name = Layer + ".Close",
                    Components =
                    {
                        new CuiRawImageComponent
                            { Png = (string)ImageLibrary?.Call("GetImage", "close_kits") },
                        new CuiRectTransformComponent
                            { AnchorMin = "0.4796878 0.2351852", AnchorMax = "0.5208334 0.3092591" },
                    }
                });



                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Color = "0 0 0 0", Command = "close.kit" },
                    Text = { Text = "" }
                }, Layer + ".Close");
                var category = GetCategory(player);
                var page = category.Count;
                var height = 25f;
                var width = 165f;
                var margin = 15f;
                var switchs = -(width * page + (page - 1) * margin) / 2f;
                foreach (var check in category.Select((i, t) => new { A = i, B = t }))
                {
                    container.Add(new CuiButton
                        {
                            RectTransform =
                            {
                                AnchorMin =
                                    $"0.5 0.65",
                                AnchorMax =
                                    $"0.5 0.65",
                                OffsetMin =
                                    $"{switchs} -212",
                                OffsetMax =
                                    $"{switchs + width} -3"
                            },
                            Button =
                            {
                                Color = "0 0 0 0",
                                Command = $""
                            },
                            Text =
                            {
                                Text = $"", Align = TextAnchor.LowerRight, Font = "robotocondensed-bold.ttf",
                                FontSize = 15
                            }
                        }, Layer, Layer + $".{check.B}.ListItem");
                    container.Add(new CuiElement
                    {
                        FadeOut = 0.3f,
                        Parent = Layer + $".{check.B}.ListItem",
                        Name = Layer + $".{check.B}.ImgList",
                        Components =
                        {
                            new CuiRawImageComponent
                                { FadeIn = 0.3f, Png = (string)ImageLibrary?.Call("GetImage", "osnova_kits") },
                            new CuiRectTransformComponent
                                { AnchorMin = "0 0", AnchorMax = "1 1" }
                        }
                    });
                    container.Add(new CuiElement
                    {
                        FadeOut = 0.3f,
                        Parent = Layer + $".{check.B}.ListItem",
                        Name = Layer + $".{check.B}.ImgList",
                        Components =
                        {
                            new CuiRawImageComponent
                                { FadeIn = 0.3f, Png = (string)ImageLibrary?.Call("GetImage", check.A.Image) },
                            new CuiRectTransformComponent
                                { AnchorMin = "0.2580646 0.4603175", AnchorMax = "0.7379035 0.8412699" }
                        }
                    });
                    container.Add(new CuiElement
                    {
                        FadeOut = 0.3f,
                        Parent = Layer + $".{check.B}.ListItem",
                        Name = Layer + $".{check.B}.TxtNameCategory",
                        Components =
                        {
                            new CuiTextComponent
                            {
                                Text = $"{check.A.DisplayName}", Align = TextAnchor.MiddleCenter,
                                Font = "robotocondensed-regular.ttf", Color = "0.972549 0.9764706 1 1", FontSize = 12,
                            },
                            new CuiRectTransformComponent
                                { AnchorMin = "0 0.3142858", AnchorMax = "1 0.3777778" }
                        }
                    });
                    List<Kit> listKit = GetKitPlayer(player, check.A.KitList);
                    string color = listKit.Count > 0
                        ? "0.3921569 0.7490196 0.2705882 1"
                        : "0.4745098 0.4862745 0.5607843 1";
                    string text = listKit.Count > 0 ? "Есть доступные" : "Нет доступных";
                    container.Add(new CuiElement
                    {
                        FadeOut = 0.3f,
                        Parent = Layer + $".{check.B}.ListItem",
                        Name = Layer + $".{check.B}.TxtDostup",
                        Components =
                        {
                            new CuiTextComponent
                            {
                                Text = text, Align = TextAnchor.MiddleCenter,
                                Font = "robotocondensed-regular.ttf", Color = color, FontSize = 10,
                            },
                            new CuiRectTransformComponent
                                { AnchorMin = "0 0.2476192", AnchorMax = "1 0.3111112" }
                        }
                    });
                    if (listKit.Count > 0)
                    {
                        container.Add(new CuiElement
                        {
                            Parent = Layer + $".{check.B}.ListItem",
                            Name = Layer + $".Perexod.{check.B}",
                            Components =
                            {
                                new CuiRawImageComponent
                                    { Png = (string)ImageLibrary?.Call("GetImage", "perexodyes") },
                                new CuiRectTransformComponent
                                    { AnchorMin = "0.125 0.05079359", AnchorMax = "0.8790323 0.2031745" },
                            }
                        });
                        container.Add(new CuiButton
                            {
                                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                                Button = { Color = "0 0 0 0", Command = $"kits.open {check.A.DisplayName}" },
                                Text = { Text = "" }
                            }, Layer + $".Perexod.{check.B}");
                    }
                    else
                    {
                        container.Add(new CuiElement
                        {
                            Parent = Layer + $".{check.B}.ListItem",
                            Name = Layer + $".Perexod.{check.B}",
                            Components =
                            {
                                new CuiRawImageComponent
                                    { Png = (string)ImageLibrary?.Call("GetImage", "perexodno") },
                                new CuiRectTransformComponent
                                    { AnchorMin = "0.125 0.05079359", AnchorMax = "0.8790323 0.2031745" },
                            }
                        });
                    }

                    switchs += width + margin;
                }

                CuiHelper.AddUi(player, container);
            }





            #endregion

        }
    }

// --- End of file: Kitss.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/BCraftSystem.cs ---
// --- Original Local Path: BeeRust/BCraftSystem.cs ---

using System.Runtime.CompilerServices;
using System.Security;
using System.Data.Common;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using System.Collections;
using Facepunch;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Rust;
using Random = UnityEngine.Random;

namespace Oxide.Plugins
{
    [Info("BCraftSystem", "King", "1.0.0")]
    public class BCraftSystem : RustPlugin
    {
        #region [Vars]

        private static BCraftSystem plugin;
        private const string Layer = "BCraftSystem.Layer";

        #endregion

        #region [Config]
        private PluginConfig config;

        protected override void LoadDefaultConfig()
        {
            config = PluginConfig.DefaultConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();

            if (config.PluginVersion < Version)
                UpdateConfigValues();

            Config.WriteObject(config, true);
        }

        private void UpdateConfigValues()
        {
            PluginConfig baseConfig = PluginConfig.DefaultConfig();
            if (config.PluginVersion < Version)
            {
                config.PluginVersion = Version;
                if (Version == new VersionNumber(1, 0, 0))
                {
                    //
                }

                PrintWarning("Config checked completed!");
            }
            config.PluginVersion = Version;
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        private class CraftConf
        {
            [JsonProperty(PropertyName = "Название")]
            public string Title;

            [JsonProperty(PropertyName = "ID")] 
            public int ID;

            [JsonProperty(PropertyName = "Shortname")]
            public string ShortName;

            [JsonProperty(PropertyName = "Количество")]
            public int Amount;

            [JsonProperty(PropertyName = "Скин")] 
            public ulong SkinID;

            [JsonProperty(PropertyName = "Тип (Item/Vehicle/Recycler)")]
            public CraftType Type;

            [JsonProperty(PropertyName = "Префаб")]
            public string Prefab;

            [JsonProperty(PropertyName = "Уровень верстака")]
            public WorkbenchLevel Level;

            [JsonProperty(PropertyName = "Установка на землю")]
            public bool Ground;

            [JsonProperty(PropertyName = "Установка на строение")]
            public bool Structure;

            [JsonProperty(PropertyName = "Предметы для крафта", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<ItemForCraft> Items;

            [JsonIgnore]
            public int craftId
            {
                get
                {
                    while (ID == 0)
                    {
                        var val = Random.Range(int.MinValue, int.MaxValue);
                        if (plugin._craftsById.ContainsKey(val)) continue;

                        ID = val;
                    }

                    return ID;
                }
            }

            public Item ToItem()
            {
                var newItem = ItemManager.CreateByName(ShortName, 1, SkinID);
                if (newItem == null) return null;

                return newItem;
            }

            public void Give(BasePlayer player)
            {
                if (player == null) return;

                var item = ToItem();
                if (item == null) return;

                player.GiveItem(item, BaseEntity.GiveItemReason.PickedUp);
            }

            public void Spawn(BasePlayer player, Vector3 pos, Quaternion rot)
            {
                switch (Type)
                {
                    case CraftType.Vehicle:
                        {
                            var entity = GameManager.server.CreateEntity(Prefab, pos,Quaternion.Euler(0, player.GetNetworkRotation().eulerAngles.y - 90, 0));
                            if (entity == null) return;

                            entity.skinID = SkinID;
                            entity.OwnerID = player.userID;
                            entity.Spawn();
                            break;
                        }
                    default:
                        {
                            var entity = GameManager.server.CreateEntity(Prefab, pos, rot);
                            if (entity == null) return;

                            entity.skinID = SkinID;
                            entity.OwnerID = player.userID;
                            entity.Spawn();
                            break;
                        }
                }
            }
        }

        private readonly Dictionary<int, CraftConf> _craftsById = new Dictionary<int, CraftConf>();

        private enum WorkbenchLevel
        {
            None = 0,
            One = 1,
            Two = 2,
            Three = 3
        }

        private enum CraftType
        {
            Vehicle,
            Item,
            Recycler
        }

        private class ItemForCraft
        {
            [JsonProperty(PropertyName = "Изображение")]
            public string Image;

            [JsonProperty(PropertyName = "Shortname")]
            public string ShortName;

            [JsonProperty(PropertyName = "Количество")]
            public int Amount;

            [JsonProperty(PropertyName = "Скин")] 
            public ulong SkinID;
        }

        private class PluginConfig
        {
            [JsonProperty(PropertyName = "Настройки крафта")]
            public List<CraftConf> Crafts;

            [JsonProperty("Config version")]
            public VersionNumber PluginVersion = new VersionNumber();

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    Crafts = new List<CraftConf>
                    {
                        new CraftConf
                        {
                            Title = "Миникоптер",
                            ShortName = "electric.flasherlight",
                            Amount = 1,
                            SkinID = 2080145158,
                            Type = CraftType.Vehicle,
                            Prefab = "assets/content/vehicles/minicopter/minicopter.entity.prefab",
                            Level = WorkbenchLevel.None,
                            Ground = true,
                            Structure = false,
                            Items = new List<ItemForCraft>
                            {
                                new ItemForCraft
                                {
                                    Image = string.Empty,
                                    ShortName = "gears",
                                    Amount = 5,
                                    SkinID = 0,
                                },
                                new ItemForCraft
                                {
                                    Image = string.Empty,
                                    ShortName = "roadsigns",
                                    Amount = 5,
                                    SkinID = 0,
                                },
                                new ItemForCraft
                                {
                                    Image = string.Empty,
                                    ShortName = "metal.fragments",
                                    Amount = 2000,
                                    SkinID = 0,
                                },
                            },
                        },
                        new CraftConf
                        {
                            Title = "Мини лодка",
                            ShortName = "coffin.storage",
                            Amount = 1,
                            SkinID = 2080150023,
                            Type = CraftType.Vehicle,
                            Prefab = "assets/content/vehicles/boats/rowboat/rowboat.prefab",
                            Level = WorkbenchLevel.None,
                            Ground = false,
                            Structure = false,
                            Items = new List<ItemForCraft>
                            {
                                new ItemForCraft
                                {
                                    Image = string.Empty,
                                    ShortName = "gears",
                                    Amount = 5,
                                    SkinID = 0,
                                },
                                new ItemForCraft
                                {
                                    Image = string.Empty,
                                    ShortName = "roadsigns",
                                    Amount = 5,
                                    SkinID = 0,
                                },
                                new ItemForCraft
                                {
                                    Image = string.Empty,
                                    ShortName = "metal.fragments",
                                    Amount = 2000,
                                    SkinID = 0,
                                },
                            },
                        },
                        new CraftConf
                        {
                            Title = "Мега лодка",
                            ShortName = "electric.sirenlight",
                            Amount = 1,
                            SkinID = 2080150770,
                            Type = CraftType.Vehicle,
                            Prefab = "assets/content/vehicles/boats/rhib/rhib.prefab",
                            Level = WorkbenchLevel.None,
                            Ground = false,
                            Structure = false,
                            Items = new List<ItemForCraft>
                            {
                                new ItemForCraft
                                {
                                    Image = string.Empty,
                                    ShortName = "gears",
                                    Amount = 5,
                                    SkinID = 0,
                                },
                                new ItemForCraft
                                {
                                    Image = string.Empty,
                                    ShortName = "roadsigns",
                                    Amount = 5,
                                    SkinID = 0,
                                },
                                new ItemForCraft
                                {
                                    Image = string.Empty,
                                    ShortName = "metal.fragments",
                                    Amount = 2000,
                                    SkinID = 0,
                                },
                            },
                        },
                        new CraftConf
                        {
                            Title = "Мега коптер",
                            ShortName = "electric.sirenlight",
                            Amount = 1,
                            SkinID = 2080154394,
                            Type = CraftType.Vehicle,
                            Prefab = "assets/content/vehicles/scrap heli carrier/scraptransporthelicopter.prefab",
                            Level = WorkbenchLevel.None,
                            Ground = false,
                            Structure = false,
                            Items = new List<ItemForCraft>
                            {
                                new ItemForCraft
                                {
                                    Image = string.Empty,
                                    ShortName = "gears",
                                    Amount = 5,
                                    SkinID = 0,
                                },
                                new ItemForCraft
                                {
                                    Image = string.Empty,
                                    ShortName = "roadsigns",
                                    Amount = 5,
                                    SkinID = 0,
                                },
                                new ItemForCraft
                                {
                                    Image = string.Empty,
                                    ShortName = "metal.fragments",
                                    Amount = 2000,
                                    SkinID = 0,
                                },
                            },
                        },
                        new CraftConf
                        {
                            Title = "Снегоход",
                            ShortName = "electric.sirenlight",
                            Amount = 1,
                            SkinID = 2747934628,
                            Type = CraftType.Vehicle,
                            Prefab = "assets/content/vehicles/snowmobiles/snowmobile.prefab",
                            Level = WorkbenchLevel.None,
                            Ground = false,
                            Structure = false,
                            Items = new List<ItemForCraft>
                            {
                                new ItemForCraft
                                {
                                    Image = string.Empty,
                                    ShortName = "gears",
                                    Amount = 5,
                                    SkinID = 0,
                                },
                                new ItemForCraft
                                {
                                    Image = string.Empty,
                                    ShortName = "roadsigns",
                                    Amount = 5,
                                    SkinID = 0,
                                },
                                new ItemForCraft
                                {
                                    Image = string.Empty,
                                    ShortName = "metal.fragments",
                                    Amount = 2000,
                                    SkinID = 0,
                                },
                            },
                        },
                        new CraftConf
                        {
                            Title = "Переработчик",
                            ShortName = "research.table",
                            Amount = 1,
                            SkinID = 2186833264,
                            Type = CraftType.Recycler,
                            Prefab = "assets/bundled/prefabs/static/recycler_static.prefab",
                            Level = WorkbenchLevel.None,
                            Ground = false,
                            Structure = true,
                            Items = new List<ItemForCraft>
                            {
                                new ItemForCraft
                                {
                                    Image = string.Empty,
                                    ShortName = "gears",
                                    Amount = 5,
                                    SkinID = 0,
                                },
                                new ItemForCraft
                                {
                                    Image = string.Empty,
                                    ShortName = "roadsigns",
                                    Amount = 5,
                                    SkinID = 0,
                                },
                                new ItemForCraft
                                {
                                    Image = string.Empty,
                                    ShortName = "metal.fragments",
                                    Amount = 2000,
                                    SkinID = 0,
                                },
                            },
                        },
                        new CraftConf
                        {
                            Title = "LR 300",
                            ShortName = "rifle.lr300",
                            Amount = 1,
                            SkinID = 0,
                            Type = CraftType.Item,
                            Prefab = "",
                            Level = WorkbenchLevel.None,
                            Ground = false,
                            Structure = true,
                            Items = new List<ItemForCraft>
                            {
                                new ItemForCraft
                                {
                                    Image = string.Empty,
                                    ShortName = "gears",
                                    Amount = 5,
                                    SkinID = 0,
                                },
                                new ItemForCraft
                                {
                                    Image = string.Empty,
                                    ShortName = "roadsigns",
                                    Amount = 5,
                                    SkinID = 0,
                                },
                                new ItemForCraft
                                {
                                    Image = string.Empty,
                                    ShortName = "metal.fragments",
                                    Amount = 2000,
                                    SkinID = 0,
                                },
                            },
                        },
                    },
                    PluginVersion = new VersionNumber()
                };
            }
        }
        #endregion

        private void OnServerInitialized()
        {
            plugin = this;

            config.Crafts.ForEach(craft => _craftsById[craft.craftId] = craft);

            cmd.AddChatCommand("craft", this, "MainUi");
        }

        private void Unload()
        {
            plugin = null;
        }

        private void OnEntityBuilt(Planner held, GameObject go)
        {
            if (held == null || go == null) return;

            var player = held.GetOwnerPlayer();
            if (player == null) return;

            var entity = go.ToBaseEntity();
            if (entity == null || entity.skinID == 0) return;

            var craft = config.Crafts.Find(x => (x.Type == CraftType.Vehicle || x.Type == CraftType.Recycler) && x.SkinID == entity.skinID);
            if (craft == null) return;

            var transform = entity.transform;

            var itemName = craft.Title;

            NextTick(() =>
            {
                if (entity != null)
                    entity.Kill();
            });

            RaycastHit rHit;
            if (Physics.Raycast(transform.position + new Vector3(0, 0.1f, 0), Vector3.down, out rHit, 4f,LayerMask.GetMask("Construction")) && rHit.GetEntity() != null)
            {
                if (!craft.Structure)
                {
                    player.ChatMessage($"{itemName} нельзя установить на строениях!");
                    GiveCraft(player, craft);
                    return;
                }
            }
            else
            {
                if (!craft.Ground)
                {
                    player.ChatMessage($"{itemName} нельзя установить на землю!");
                    GiveCraft(player, craft);
                    return;
                }
            }

            craft.Spawn(player, transform.position, transform.rotation);
        }

        #region [Ui]

        private void MainUi(BasePlayer player)
        {
            var container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Material = "assets/content/ui/uibackgroundblur.mat", Color = "0 0 0 0.77" }
            }, "Overlay", Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Button = { Color = "0 0 0 0", Close = Layer }
            }, Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Button = { Color = "0.36 0.33 0.28 0.3", Material = "assets/icons/greyout.mat", Close = Layer }
            }, Layer);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-344 -50", OffsetMax = "347 260" },
                Image = { Color = "0.3773585 0.3755785 0.3755785 0.3407843", Material = "assets/icons/greyout.mat" }
            }, Layer, Layer + ".Main");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.99", },
                Text = { Text = "Список предметов для крафта", Align = TextAnchor.UpperCenter, Font = "robotocondensed-bold.ttf", FontSize = 24, Color = "1 1 1 0.65" }
            }, Layer + ".Main");

            foreach (var check in config.Crafts.Select((y, t) => new { A = y, B = t }).Take(10))
            {
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"{0.018 + check.B * 0.196 - Math.Floor((float) check.B / 5) * 5 * 0.196} {0.47 - Math.Floor((float) check.B/ 5) * 0.44}",
                                        AnchorMax = $"{0.197 + check.B * 0.196 - Math.Floor((float) check.B / 5) * 5 * 0.196} {0.873 - Math.Floor((float) check.B / 5) * 0.44}", },
                    Image = { Color = "0.09 0.09 0.09 0.45", Material = "assets/icons/greyout.mat" }
                }, Layer + ".Main", Layer + ".Main" + $".Craft({check.B})");

                container.Add(new CuiElement
                {
                    Parent = Layer + ".Main" + $".Craft({check.B})",
                    Components =
                    {
                        new CuiImageComponent { ItemId = FindItemID(check.A.ShortName), SkinId = check.A.SkinID },
                        new CuiRectTransformComponent { AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-36 -84", OffsetMax = "36 -12" }
                    }
                });

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.32" },
                    Text = { Text = $"{check.A.Title}", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 14, Color = "1 1 1 1" }
                }, Layer + ".Main" + $".Craft({check.B})");

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Color = "0 0 0 0", Command = $"UI_BCrafts craftUi {check.A.ID}" },
                    Text = { Text = "" }
                }, Layer + ".Main" + $".Craft({check.B})");
            }

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-344 -255", OffsetMax = "347 -55" },
                Image = { Color = "0.3773585 0.3755785 0.3755785 0.3407843", Material = "assets/icons/greyout.mat" }
            }, Layer, Layer + ".CraftPanel");

            CuiHelper.DestroyUi(player, Layer);
            CuiHelper.AddUi(player, container);
        }

        private void CraftUi(BasePlayer player, int ID)
        {
            var craft = config.Crafts.FirstOrDefault(p => p.ID == ID);
            if (craft == null) return;

            var allItems = player.inventory.AllItems();
            var container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Image = { Color = "0 0 0 0" },
            }, Layer + ".CraftPanel", Layer + ".CraftPanel" + ".Layer" );

            int itemsPage = 0;
            var width = 130f;
            var margin = -25f;
            var notItem = false;
            var maxAmount = 7;
            var items = craft.Items.Skip(itemsPage * maxAmount).Take(maxAmount).ToList();
            var xSwitch = - (items.Count * width + (items.Count - 1) * margin) / 2f;

            foreach (var check in items.Select((i, t) => new {A = i, B = t}))
            {
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"0.5 1", AnchorMax = $"0.5 1", OffsetMin = $"{xSwitch} -140", OffsetMax = $"{xSwitch + width} -15" },
                    Image = { Color = "0 0 0 0" }
                }, Layer + ".CraftPanel" + ".Layer", Layer + ".CraftPanel" + ".Layer" + $".Craft({check.B})");

                container.Add(new CuiElement
                {
                    Parent = Layer + ".CraftPanel" + ".Layer" + $".Craft({check.B})",
                    Components =
                    {
                        new CuiImageComponent { ItemId = FindItemID(check.A.ShortName), SkinId = check.A.SkinID },
                        new CuiRectTransformComponent { AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-44 -78", OffsetMax = "44 14" }
                    }
                });

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "0.95 0.55" },
                    Text = { Text = $"{ItemManager.FindItemDefinition(check.A.ShortName)?.displayName.translated}", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 12, Color = "1 1 1 1" }
                }, Layer + ".CraftPanel" + ".Layer" + $".Craft({check.B})");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "0.95 0.14" },
                    Text = { Text = $"{check.A.Amount} шт", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 12, Color = "1 1 1 1" }
                }, Layer + ".CraftPanel" + ".Layer" + $".Craft({check.B})");

                var hasAmount = HasAmount(allItems, check.A.ShortName, check.A.SkinID, check.A.Amount);

                if (!hasAmount)
                    notItem = true;
    
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "-40 20", OffsetMax = "40 22" },
                    Image = { Color = hasAmount ? "0.00 0.84 0.47 1.00" : "0.80 0.27 0.20 1.00", Material = "assets/icons/greyout.mat" }
                }, Layer + ".CraftPanel" + ".Layer" + $".Craft({check.B})");

                xSwitch += width + margin;
            }

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = $"-64 -195", OffsetMax = $"64 -150" },
                Text = { Text = "КРАФТ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 12, Color = notItem ? "1 1 1 0.7" : "1 1 1 1" },
                Button = { Color = notItem ? "0 0 0 0.40" : "0.00 0.84 0.47 0.65", Material = "assets/icons/greyout.mat", Command = notItem ? "" : $"UI_BCrafts trycraft {ID}" }
            }, Layer + ".CraftPanel" + ".Layer" );

            CuiHelper.DestroyUi(player, Layer + ".CraftPanel" + ".Layer");
            CuiHelper.AddUi(player, container);
        }

        #endregion

        #region [ConsoleCommand]

        [ConsoleCommand("UI_BCrafts")]
        private void CmdConsoleCrafts(ConsoleSystem.Arg arg)
        {
            var player = arg?.Player();
            if (player == null || !arg.HasArgs()) return;

            switch (arg.Args[0])
            {
                case "craftUi":
                {
                    int ID;
                    int.TryParse(arg.Args[1], out ID);

                    CraftUi(player, ID);
                    break;
                }
                case "trycraft":
                {
                    int ID; 
                    int.TryParse(arg.Args[1], out ID);

                    var craft = config.Crafts.FirstOrDefault(p => p.ID == ID);
                    if (craft == null) return;

                    if (!HasWorkbench(player, craft.Level))
                    {
                        player.ChatMessage("Не достаточный уровень верстака для крафта!");
                        return;
                    }

                    var allItems = player.inventory.AllItems();

                    if (craft.Items.Exists(item => !HasAmount(allItems, item.ShortName, item.SkinID, item.Amount)))
                    {
                        player.ChatMessage("Недостаточно ресурсов");
                        return;
                    }

                    ServerMgr.Instance.StartCoroutine(TakeAndGiveCraftItems(player, allItems, craft));

                    player.ChatMessage($"Вы успешно скрафтили <color=green>{craft.Title}</color>");

                    CraftUi(player, ID);
                    break;
                }
            }
        }

        #endregion

        #region [Func]

        private static bool HasAmount(Item[] items, string shortname, ulong skin, int amount)
        {
            return ItemCount(items, shortname, skin) >= amount;
        }

        private static int ItemCount(Item[] items, string shortname, ulong skin)
        {
            return Array.FindAll(items, item =>
                    item.info.shortname == shortname && !item.isBroken && (skin == 0 || item.skin == skin))
                .Sum(item => item.amount);
        }

        private static bool HasWorkbench(BasePlayer player, WorkbenchLevel level)
        {
            return level == WorkbenchLevel.Three ? player.HasPlayerFlag(BasePlayer.PlayerFlags.Workbench3)
                : level == WorkbenchLevel.Two ? player.HasPlayerFlag(BasePlayer.PlayerFlags.Workbench3) ||
                                                player.HasPlayerFlag(BasePlayer.PlayerFlags.Workbench2)
                : level == WorkbenchLevel.One ? player.HasPlayerFlag(BasePlayer.PlayerFlags.Workbench3) ||
                                                player.HasPlayerFlag(BasePlayer.PlayerFlags.Workbench2) ||
                                                player.HasPlayerFlag(BasePlayer.PlayerFlags.Workbench1)
                : level == WorkbenchLevel.None;
        }

		private Dictionary<string, int> _itemIds = new Dictionary<string, int>();

		private int FindItemID(string shortName)
		{
			int val;
			if (_itemIds.TryGetValue(shortName, out val))
				return val;

			var definition = ItemManager.FindItemDefinition(shortName);
			if (definition == null) return 0;

			val = definition.itemid;
			_itemIds[shortName] = val;
			return val;
		}

        private IEnumerator TakeAndGiveCraftItems(BasePlayer player, Item[] allItems, CraftConf craft)
        {
            craft.Items.ForEach(item => Take(allItems, item.ShortName, item.SkinID, item.Amount));

            for (var i = 0; i < craft.Amount; i++)
            {
                GiveCraft(player, craft);

                yield return CoroutineEx.waitForFixedUpdate;
            }
        }

        private static void Take(IEnumerable<Item> itemList, string shortname, ulong skinId, int iAmount)
        {
            var num1 = 0;
            if (iAmount == 0) return;

            var list = Pool.GetList<Item>();

            foreach (var item in itemList)
            {
                if (item.info.shortname != shortname ||
                    (skinId != 0 && item.skin != skinId) || item.isBroken) continue;

                var num2 = iAmount - num1;
                if (num2 <= 0) continue;
                if (item.amount > num2)
                {
                    item.MarkDirty();
                    item.amount -= num2;
                    break;
                }

                if (item.amount <= num2)
                {
                    num1 += item.amount;
                    list.Add(item);
                }

                if (num1 == iAmount)
                    break;
            }

            foreach (var obj in list)
                obj.RemoveFromContainer();

            Pool.FreeList(ref list);
        }

        private void GiveCraft(BasePlayer player, CraftConf cfg)
        {
            switch (cfg.Type)
            {
                default:
                {
                    cfg.Give(player);
                    break;
                }
            }
        }

        #endregion
    }
}

// --- End of file: BCraftSystem.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/MinicopterSeating.cs ---
// --- Original Local Path: BeeRust/MinicopterSeating.cs ---

using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Minicopter Seating", "Bazz3l", "1.1.6")]
    [Description("Spawn extra seats on each side of the minicopter.")]
    public class MinicopterSeating : CovalencePlugin
    {
        #region Fields

        private readonly GameObjectRef _gameObjectRef = new GameObjectRef { guid = "dc329880dec7ab343bc454fd969d5709" };
        private readonly Vector3 _seat1 = new Vector3(0.6f, 0.2f, -0.3f);
        private readonly Vector3 _seat2 = new Vector3(-0.6f, 0.2f, -0.3f);
	private readonly Vector3 _seat3 = new Vector3(0.0f, 0.5f, -2.0f);

        #endregion

        #region Oxide

        private void OnEntitySpawned(BaseVehicle mini)
        {
            if (mini.mountPoints.Count < 4 && mini.ShortPrefabName == "minicopter.entity")
                SetupSeating(mini);
        }

        #endregion

        #region Core

        private void SetupSeating(BaseVehicle vehicle)
        {
            vehicle.mountPoints.Add(CreateMount(vehicle.mountPoints, _seat1));
            vehicle.mountPoints.Add(CreateMount(vehicle.mountPoints, _seat2));
	    vehicle.mountPoints.Add(CreateMount(vehicle.mountPoints, _seat3));
        }

        private BaseVehicle.MountPointInfo CreateMount(List<BaseVehicle.MountPointInfo> mountPoints, Vector3 position)
        {
            return new BaseVehicle.MountPointInfo
            {
                pos = position,
                rot = mountPoints[1].rot,
                prefab = _gameObjectRef,
                mountable = mountPoints[1].mountable,
            };
        }

        #endregion
    }
}

// --- End of file: MinicopterSeating.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/SpawnMini.cs ---
// --- Original Local Path: BeeRust/SpawnMini.cs ---

using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Serialization;
using Oxide.Core;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Spawn Mini", "SpooksAU", "2.12.1")]
    [Description("Spawn a mini!")]
    class SpawnMini : RustPlugin
    {
        [PluginReference] private Plugin ImageLibrary;
        private SaveData _data;
        private PluginConfig _config;

        /* EDIT PERMISSIONS HERE */
        private readonly string _spawnMini = "spawnmini.minii";
        private readonly string _noCooldown = "spawnmini.nocdd";
        private readonly string _noMini = "spawnmini.nominii";
        private readonly string _fetchMini = "spawnmini.fminii";
        private readonly string _noFuel = "spawnmini.unlimitedfuell";
        private readonly string _noDecay = "spawnmini.nodecayy";
        private readonly string _permissionFuelFormat = "spawnmini.fuell.{0}";

        #region Hooks

        private void Init()
        {
            permission.RegisterPermission(_spawnMini, this);
            permission.RegisterPermission(_noCooldown, this);
            permission.RegisterPermission(_noMini, this);
            permission.RegisterPermission(_fetchMini, this);
            permission.RegisterPermission(_noFuel, this);
            permission.RegisterPermission(_noDecay, this);

            foreach (var perm in _config.spawnPermissionCooldowns)
                permission.RegisterPermission(perm.Key, this);

            foreach (var perm in _config.fetchPermissionCooldowns)
            {
                // Allow server owners to use the same permission for spawn and fetch.
                if (!permission.PermissionExists(perm.Key))
                {
                    permission.RegisterPermission(perm.Key, this);
                }
            }

            foreach (var fuelAmount in _config.fuelAmountsRequiringPermission)
                permission.RegisterPermission(GetFuelPermission(fuelAmount), this);

            if (!Interface.Oxide.DataFileSystem.ExistsDatafile(Name))
                Interface.Oxide.DataFileSystem.GetDatafile(Name).Save();

            LoadSaveData();

            if (!_config.ownerOnly)
                Unsubscribe(nameof(CanMountEntity));

            if (!_config.destroyOnDisconnect)
            {
                Unsubscribe(nameof(OnPlayerDisconnected));
                Unsubscribe(nameof(OnEntityDismounted));
            }
        }

        void OnServerInitialized()
        {
            foreach (var mini in BaseNetworkable.serverEntities.OfType<Minicopter>())
            {
                if (IsPlayerOwned(mini) && mini.OwnerID != 0 && permission.UserHasPermission(mini.OwnerID.ToString(), _noFuel))
                {
                    EnableUnlimitedFuel(mini);
                }
            }

            foreach (BasePlayer player in BasePlayer.activePlayerList)
                MyMiniUI(player);

            ImageLibrary?.Call("AddImage", "https://cdn.discordapp.com/attachments/1092142749035278414/1175690288610689125/free-icon-fighter-helicopter-11077710.png?ex=656c25e8&is=6559b0e8&hm=a1f4a0f06efa05f045b73ec45791aff3b6c437522c0f8e277e1e0d380484b936&", $"{Name}.CopterImage");
        }

        void Unload() => WriteSaveData();

        void OnServerSave() => WriteSaveData();

        void OnNewSave()
        {
            _data.playerMini.Clear();
            _data.spawnCooldowns.Clear();
            _data.fetchCooldowns.Clear();
            WriteSaveData();
        }

        void OnEntityKill(Minicopter mini)
        {
            if (_data.playerMini.ContainsValue(mini.net.ID.Value))
            {
                string key = _data.playerMini.FirstOrDefault(x => x.Value == mini.net.ID.Value).Key;

                ulong result;
                ulong.TryParse(key, out result);
                BasePlayer player = BasePlayer.FindByID(result);

                if (player != null)
                    player.ChatMessage(lang.GetMessage("mini_destroyed", this, player.UserIDString));

                _data.playerMini.Remove(key);
            }
        }

        object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (entity == null || info == null || entity.OwnerID == 0)
                return null;

            if (_data.playerMini.ContainsValue(entity.net.ID.Value))
                if (permission.UserHasPermission(entity.OwnerID.ToString(), _noDecay) && info.damageTypes.Has(Rust.DamageType.Decay))
                    return true;

            return null;
        }

        object CanMountEntity(BasePlayer player, BaseVehicleMountPoint entity)
        {
            if (player == null || entity == null)
                return null;

            var mini = entity.GetParentEntity() as Minicopter;
            if (mini == null || mini is ScrapTransportHelicopter || mini.OwnerID == 0 || !IsPlayerOwned(mini)) return null;

            if (mini.OwnerID != player.userID)
            {
                if (player.Team != null && player.Team.members.Contains(mini.OwnerID))
                    return null;

                player.ChatMessage(lang.GetMessage("mini_canmount", this, player.UserIDString));
                return false;
            }
            return null;
        }

        void OnPlayerConnected(BasePlayer player)
        {      
            if (player == null) return;

            MyMiniUI(player);
        }

        private string Layer = "SpawnMini.Layer";

        private void MyMiniUI(BasePlayer player)
        {
            var container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                Image = { Color = "1 0.96 0.88 0.15" },
                RectTransform = { AnchorMin = "0.5 0.0", AnchorMax = "0.5 0.0", OffsetMin = "-264.276 17.943", OffsetMax = "-203.724 78.087" },
                CursorEnabled = false
            }, "Overlay", Layer);

            container.Add(new CuiElement
            {
                Parent = Layer,
                Components =
                {
                    new CuiRawImageComponent { Png = (string)ImageLibrary?.Call("GetImage", $"{Name}.CopterImage") },
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                }
            });

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Button = { Color = "0 0 0 0", Command = "chat.say /copter" },
                Text = { Text = "" }
            }, Layer);

            CuiHelper.DestroyUi(player, Layer);
            CuiHelper.AddUi(player, container);
        }

        void OnPlayerDisconnected(BasePlayer player)
        {
            if (player == null)
                return;

            ulong miniNetId;
            if (!_data.playerMini.TryGetValue(player.UserIDString, out miniNetId))
                return;

            var mini = BaseNetworkable.serverEntities.Find(new NetworkableId(miniNetId)) as Minicopter;
            if (mini == null)
                return;

            NextTick(() =>
            {
                if (mini == null)
                    return;

                // Despawn Minicopter when the owner disconnects
                // If mounted, we will despawn it later when all players dismount
                if (!mini.AnyMounted())
                    mini.Kill();
            });
        }

        void OnEntityDismounted(BaseVehicleSeat seat)
        {
            if (seat == null)
                return;

            var mini = seat.GetParentEntity() as Minicopter;
            if (mini == null || mini.OwnerID == 0 || !IsPlayerOwned(mini) || mini.AnyMounted())
                return;

            // Despawn Minicopter when fully dismounted, if the owner player has disconnected
            var ownerPlayer = BasePlayer.FindByID(mini.OwnerID);
            if (ownerPlayer == null || !ownerPlayer.IsConnected)
                mini.Kill();
        }

        void CanLootEntity(BasePlayer player, StorageContainer container)
        {
            if (container == null || !container.IsLocked())
                return;

            var mini = container.GetParentEntity() as Minicopter;
            if (mini == null || !IsPlayerOwned(mini))
                return;

            if (permission.UserHasPermission(mini.OwnerID.ToString(), _noFuel))
                player.ChatMessage(lang.GetMessage("mini_unlimited_fuel", this, player.UserIDString));
        }

        #endregion

        #region Commands

        [ChatCommand("copter")]
        private void SyperSpawnCopter(BasePlayer player, string command, string[] args)
        {
            var mini = FindPlayerMini(player);
            if (mini != null)
            {
                DespawnCommand(player);
            }
            else
            {
                SpawnCommand(player);
            }
        }

        [ChatCommand("mymini")]
        private void SpawnCommand(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, _spawnMini))
            {
                player.ChatMessage(lang.GetMessage("mini_perm", this, player.UserIDString));
                return;
            }

            var mini = FindPlayerMini(player);
            if (mini != null)
            {
                if (_config.autoFetch && permission.UserHasPermission(player.UserIDString, _fetchMini))
                {
                    FetchInternal(player, mini);
                }
                else
                {
                    player.ChatMessage(lang.GetMessage("mini_current", this, player.UserIDString));
                }

                return;
            }

            if (SpawnWasBlocked(player))
                return;

            if (!VerifyOffCooldown(player, _config.spawnPermissionCooldowns, _config.defaultSpawnCooldown, _data.spawnCooldowns))
                return;

            SpawnMinicopter(player);
            player.ChatMessage($"Вы поставили миникоптер");
        }

        [ChatCommand("my")]
        private void SpawnCommandd(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, _spawnMini))
            {
                player.ChatMessage(lang.GetMessage("mini_perm", this, player.UserIDString));
                return;
            }

            var mini = FindPlayerMini(player);
            if (mini != null)
            {
                if (_config.autoFetch && permission.UserHasPermission(player.UserIDString, _fetchMini))
                {
                    FetchInternal(player, mini);
                }
                else
                {
                    player.ChatMessage(lang.GetMessage("mini_current", this, player.UserIDString));
                }

                return;
            }

            if (SpawnWasBlocked(player))
                return;

            if (!VerifyOffCooldown(player, _config.spawnPermissionCooldowns, _config.defaultSpawnCooldown, _data.spawnCooldowns))
                return;

            SpawnMinicopter(player);
        }

        [ChatCommand("fmini")]
        private void FetchCommand(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, _fetchMini))
            {
                player.ChatMessage(lang.GetMessage("mini_perm", this, player.UserIDString));
                return;
            }

            var mini = FindPlayerMini(player);
            if (mini == null)
            {
                player.ChatMessage(lang.GetMessage("mini_notcurrent", this, player.UserIDString));
                return;
            }

            FetchInternal(player, mini);
        }

        [ChatCommand("nomini")]
        private void DespawnCommand(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, _noMini))
            {
                player.ChatMessage(lang.GetMessage("mini_perm", this, player.UserIDString));
                return;
            }

            var mini = FindPlayerMini(player);
            if (mini == null)
            {
                player.ChatMessage(lang.GetMessage("mini_notcurrent", this, player.UserIDString));
                return;
            }

            if (mini.AnyMounted() && !_config.canDespawnWhileOccupied)
            {
                player.ChatMessage(lang.GetMessage("mini_mounted", this, player.UserIDString));
                return;
            }

            if (IsMiniBeyondMaxDistance(player, mini))
            {
                player.ChatMessage(lang.GetMessage("mini_current_distance", this, player.UserIDString));
                return;
            }

            if (DespawnWasBlocked(player, mini))
                return;

            BaseNetworkable.serverEntities.Find(new NetworkableId(_data.playerMini[player.UserIDString]))?.Kill();
        }

        [ChatCommand("no")]
        private void DespawnCommandd(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, _noMini))
            {
                player.ChatMessage(lang.GetMessage("mini_perm", this, player.UserIDString));
                return;
            }

            var mini = FindPlayerMini(player);
            if (mini == null)
            {
                player.ChatMessage(lang.GetMessage("mini_notcurrent", this, player.UserIDString));
                return;
            }

            if (mini.AnyMounted() && !_config.canDespawnWhileOccupied)
            {
                player.ChatMessage(lang.GetMessage("mini_mounted", this, player.UserIDString));
                return;
            }

            if (IsMiniBeyondMaxDistance(player, mini))
            {
                player.ChatMessage(lang.GetMessage("mini_current_distance", this, player.UserIDString));
                return;
            }

            if (DespawnWasBlocked(player, mini))
                return;

            BaseNetworkable.serverEntities.Find(new NetworkableId(_data.playerMini[player.UserIDString]))?.Kill();
        }

        [ConsoleCommand("spawnmini.give")]
        private void GiveMiniConsole(ConsoleSystem.Arg arg)
        {
            if (arg.IsClientside || !arg.IsRcon)
                return;

            var args = arg.Args;
            if (args == null || args.Length == 0)
            {
                Puts("Syntax: spawnmini.give <name or steamid>");
                return;
            }

            var player = BasePlayer.Find(args[0]);
            if (player == null)
            {
                PrintError($"No player found matching '{args[0]}'");
                return;
            }

            if (args.Length > 1)
            {
                float x, y, z;
                if (args.Length < 4 ||
                    !float.TryParse(args[1], out x) ||
                    !float.TryParse(args[2], out y) ||
                    !float.TryParse(args[3], out z))
                {
                    Puts($"Syntax: spawnmini.give <name or steamid> <x> <y> <z>");
                    return;
                }

                GiveMinicopter(player, new Vector3(x, y, z), useCustomPosition: true);
            }
            else
            {
                GiveMinicopter(player);
            }
        }

        #endregion

        #region Helpers/Functions

        private bool VerifyOffCooldown(BasePlayer player, Dictionary<string, float> cooldownPerms, float defaultCooldown, Dictionary<string, DateTime> cooldownMap)
        {
            DateTime cooldownStart;
            if (!cooldownMap.TryGetValue(player.UserIDString, out cooldownStart) || permission.UserHasPermission(player.UserIDString, _noCooldown))
            {
                return true;
            }

            DateTime lastSpawned = cooldownMap[player.UserIDString];
            TimeSpan timeRemaining = CeilingTimeSpan(lastSpawned.AddSeconds(GetPlayerCooldownSeconds(player, cooldownPerms, defaultCooldown)) - DateTime.Now);
            if (timeRemaining.TotalSeconds <= 0)
            {
                cooldownMap.Remove(player.UserIDString);
                return true;
            }

            player.ChatMessage(string.Format(lang.GetMessage("mini_timeleft_new", this, player.UserIDString), timeRemaining.ToString("g")));
            return false;
        }

        private bool SpawnWasBlocked(BasePlayer player)
        {
            object hookResult = Interface.CallHook("OnMyMiniSpawn", player);
            return hookResult is bool && (bool)hookResult == false;
        }

        private bool FetchWasBlocked(BasePlayer player, Minicopter mini)
        {
            object hookResult = Interface.CallHook("OnMyMiniFetch", player, mini);
            return hookResult is bool && (bool)hookResult == false;
        }

        private bool DespawnWasBlocked(BasePlayer player, Minicopter mini)
        {
            object hookResult = Interface.CallHook("OnMyMiniDespawn", player, mini);
            return hookResult is bool && (bool)hookResult == false;
        }

        private TimeSpan CeilingTimeSpan(TimeSpan timeSpan) =>
            new TimeSpan((long)Math.Ceiling(1.0 * timeSpan.Ticks / 10000000) * 10000000);

        private bool IsMiniBeyondMaxDistance(BasePlayer player, Minicopter mini) =>
            _config.noMiniDistance >= 0 && GetDistance(player, mini) > _config.noMiniDistance;

        private Vector3 GetFixedPositionForPlayer(BasePlayer player)
        {
            Vector3 forward = player.GetNetworkRotation() * Vector3.forward;
            forward.y = 0;
            return player.transform.position + forward.normalized * _config.fixedSpawnDistance + Vector3.up * 2f;
        }

        private Quaternion GetFixedRotationForPlayer(BasePlayer player) =>
            Quaternion.Euler(0, player.GetNetworkRotation().eulerAngles.y - _config.fixedSpawnRotationAngle, 0);

        private Minicopter FindPlayerMini(BasePlayer player)
        {
            ulong miniNetId;
            if (!_data.playerMini.TryGetValue(player.UserIDString, out miniNetId))
                return null;

            var mini = BaseNetworkable.serverEntities.Find(new NetworkableId(miniNetId)) as Minicopter;

            // Fix a potential data file desync where the mini doesn't exist anymore
            // Desyncs should be rare but are not possible to 100% prevent
            // They can happen if the mini is destroyed while the plugin is unloaded
            // Or if someone edits the data file manually
            if (mini == null)
                _data.playerMini.Remove(player.UserIDString);

            return mini;
        }

        private void FetchInternal(BasePlayer player, Minicopter mini)
        {
            if (!_config.canFetchBuildlingBlocked && player.IsBuildingBlocked())
            {
                player.ChatMessage(lang.GetMessage("mini_buildingblocked", this, player.UserIDString));
                return;
            }

            bool isMounted = mini.AnyMounted();
            if (isMounted && (!_config.canFetchWhileOccupied || player.GetMountedVehicle() == mini))
            {
                player.ChatMessage(lang.GetMessage("mini_mounted", this, player.UserIDString));
                return;
            }

            if (IsMiniBeyondMaxDistance(player, mini))
            {
                player.ChatMessage(lang.GetMessage("mini_current_distance", this, player.UserIDString));
                return;
            }

            if (FetchWasBlocked(player, mini))
                return;

            if (!VerifyOffCooldown(player, _config.fetchPermissionCooldowns, _config.defaultFetchCooldown, _data.fetchCooldowns))
                return;

            if (isMounted)
            {
                // mini.DismountAllPlayers() doesn't work so we have to enumerate the mount points
                foreach (var mountPoint in mini.mountPoints)
                    mountPoint.mountable?.DismountAllPlayers();
            }

            if (_config.repairOnFetch)
            {
                mini.SetHealth(Math.Max(mini.Health(), _config.spawnHealth));
            }

            mini.rigidBody.velocity = Vector3.zero;
            mini.transform.SetPositionAndRotation(GetFixedPositionForPlayer(player), GetFixedRotationForPlayer(player));
            mini.UpdateNetworkGroup();
            mini.SendNetworkUpdateImmediate();

            if (!permission.UserHasPermission(player.UserIDString, _noCooldown))
            {
                _data.fetchCooldowns[player.UserIDString] = DateTime.Now;
            }
        }

        private void SpawnMinicopter(BasePlayer player)
        {
            if (!_config.canSpawnBuildingBlocked && player.IsBuildingBlocked())
            {
                player.ChatMessage(lang.GetMessage("mini_buildingblocked", this, player.UserIDString));
                return;
            }

            Vector3 position;

            if (_config.useFixedSpawnDistance)
            {
                position = GetFixedPositionForPlayer(player);
            }
            else
            {
                RaycastHit hit;
                if (!Physics.Raycast(player.eyes.HeadRay(), out hit, Mathf.Infinity,
                    LayerMask.GetMask("Construction", "Default", "Deployed", "Resource", "Terrain", "Water", "World")))
                {
                    player.ChatMessage(lang.GetMessage("mini_terrain", this, player.UserIDString));
                    return;
                }

                if (hit.distance > _config.maxSpawnDistance)
                {
                    player.ChatMessage(lang.GetMessage("mini_sdistance", this, player.UserIDString));
                    return;
                }

                position = hit.point + Vector3.up * 2f;
            }

            Minicopter mini = GameManager.server.CreateEntity(_config.assetPrefab, position, GetFixedRotationForPlayer(player)) as Minicopter;
            if (mini == null) return;

            mini.OwnerID = player.userID;
            mini.startHealth = _config.spawnHealth;
            mini.Spawn();

            // Credit Original MyMinicopter Plugin
            if (permission.UserHasPermission(player.UserIDString, _noFuel))
                EnableUnlimitedFuel(mini);
            else
                AddInitialFuel(mini, player.UserIDString);

            _data.playerMini.Add(player.UserIDString, mini.net.ID.Value);

            if (!permission.UserHasPermission(player.UserIDString, _noCooldown))
            {
                _data.spawnCooldowns[player.UserIDString] = DateTime.Now;
            }
        }

        private void GiveMinicopter(BasePlayer player, Vector3 customPosition = default(Vector3), bool useCustomPosition = false)
        {
            if (FindPlayerMini(player) != null)
            {
                player.ChatMessage(lang.GetMessage("mini_current", this, player.UserIDString));
                return;
            }

            var position = useCustomPosition ? customPosition : GetFixedPositionForPlayer(player);
            var rotation = useCustomPosition ? Quaternion.identity : GetFixedRotationForPlayer(player);

            Minicopter mini = GameManager.server.CreateEntity(_config.assetPrefab, position, rotation) as Minicopter;
            if (mini == null) return;

            mini.OwnerID = player.userID;
            mini.Spawn();

            _data.playerMini.Add(player.UserIDString, mini.net.ID.Value);

            if (permission.UserHasPermission(player.UserIDString, _noFuel))
                EnableUnlimitedFuel(mini);
            else
                AddInitialFuel(mini, player.UserIDString);
        }

        private float GetPlayerCooldownSeconds(BasePlayer player, Dictionary<string, float> cooldownPerms, float defaultCooldown)
        {
            var grantedCooldownPerms = cooldownPerms
                .Where(entry => permission.UserHasPermission(player.UserIDString, entry.Key));

            return grantedCooldownPerms.Any()
                ? grantedCooldownPerms.Min(entry => entry.Value)
                : defaultCooldown;
        }

        private void AddInitialFuel(Minicopter Minicopter, string userId)
        {
            var fuelAmount = GetPlayerAllowedFuel(userId);
            if (fuelAmount == 0)
                return;

            StorageContainer fuelContainer = Minicopter.GetFuelSystem().GetFuelContainer();
            if (fuelAmount < 0)
            {
                // Value of -1 is documented to represent max stack size
                fuelAmount = fuelContainer.allowedItem.stackable;
            }
            fuelContainer.inventory.AddItem(fuelContainer.allowedItem, fuelAmount);
        }

        private void EnableUnlimitedFuel(Minicopter Minicopter)
        {
            var fuelSystem = Minicopter.GetFuelSystem();
            fuelSystem.cachedHasFuel = true;
            fuelSystem.nextFuelCheckTime = float.MaxValue;
            fuelSystem.GetFuelContainer().SetFlag(BaseEntity.Flags.Locked, true);
        }

        private float GetDistance(BasePlayer player, Minicopter mini)
        {
            float distance = Vector3.Distance(player.transform.position, mini.transform.position);
            return distance;
        }

        private bool IsPlayerOwned(Minicopter mini)
        {
            if (mini != null && _data.playerMini.ContainsValue(mini.net.ID.Value))
                return true;

            return false;
        }

        private string GetFuelPermission(int fuelAmount) => String.Format(_permissionFuelFormat, fuelAmount);

        #endregion

        #region Data & Configuration

        private int GetPlayerAllowedFuel(string userIdString)
        {
            if (_config.fuelAmountsRequiringPermission == null || _config.fuelAmountsRequiringPermission.Length == 0)
                return _config.fuelAmount;

            for (var i = _config.fuelAmountsRequiringPermission.Length - 1; i >= 0; i--)
            {
                var fuelAmount = _config.fuelAmountsRequiringPermission[i];
                if (permission.UserHasPermission(userIdString, String.Format(_permissionFuelFormat, fuelAmount)))
                    return fuelAmount;
            }

            return _config.fuelAmount;
        }

        private SaveData LoadSaveData()
        {
            _data = Interface.Oxide.DataFileSystem.ReadObject<SaveData>(Name);
            if (_data == null)
            {
                PrintWarning($"Data file {Name}.json is invalid. Creating new data file.");
                _data = new SaveData();
                WriteSaveData();
            }
            return _data;
        }

        private void WriteSaveData() =>
            Interface.Oxide.DataFileSystem.WriteObject(Name, _data);

        class SaveData
        {
            [JsonProperty("playerMini")]
            public Dictionary<string, ulong> playerMini = new Dictionary<string, ulong>();

            [JsonProperty("spawnCooldowns")]
            public Dictionary<string, DateTime> spawnCooldowns = new Dictionary<string, DateTime>();

            [JsonProperty("cooldown")]
            private Dictionary<string, DateTime> deprecatedCooldown
            {
                set { spawnCooldowns = value; }
            }

            [JsonProperty("fetchCooldowns")]
            public Dictionary<string, DateTime> fetchCooldowns = new Dictionary<string, DateTime>();
        }

        class PluginConfig : SerializableConfiguration
        {
            [JsonProperty("AssetPrefab")]
            public string assetPrefab = "assets/content/vehicles/Minicopter/Minicopter.entity.prefab";

            [JsonProperty("CanDespawnWhileOccupied")]
            public bool canDespawnWhileOccupied = false;

            [JsonProperty("CanFetchWhileOccupied")]
            public bool canFetchWhileOccupied = false;

            [JsonProperty("CanSpawnBuildingBlocked")]
            public bool canSpawnBuildingBlocked = false;

            [JsonProperty("CanFetchBuildingBlocked")]
            public bool canFetchBuildlingBlocked = true;

            [JsonProperty("AutoFetch")]
            public bool autoFetch = false;

            [JsonProperty("RepairOnFetch")]
            public bool repairOnFetch = false;

            [JsonProperty("FuelAmount")]
            public int fuelAmount = 0;

            [JsonProperty("FuelAmountsRequiringPermission")]
            public int[] fuelAmountsRequiringPermission = new int[0];

            [JsonProperty("MaxNoMiniDistance")]
            public float noMiniDistance = -1;

            [JsonProperty("MaxSpawnDistance")]
            public float maxSpawnDistance = 5f;

            [JsonProperty("UseFixedSpawnDistance")]
            public bool useFixedSpawnDistance = true;

            [JsonProperty("FixedSpawnDistance")]
            public float fixedSpawnDistance = 3;

            [JsonProperty("FixedSpawnRotationAngle")]
            public float fixedSpawnRotationAngle = 135;

            [JsonProperty("OwnerAndTeamCanMount")]
            public bool ownerOnly = false;

            [JsonProperty("DefaultSpawnCooldown")]
            public float defaultSpawnCooldown = 3600f;

            [JsonProperty("DefaultCooldown")]
            private float deprecatedDefaultSpawnCooldown
            {
                set { defaultSpawnCooldown = value; }
            }

            [JsonProperty("PermissionSpawnCooldowns", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, float> spawnPermissionCooldowns = new Dictionary<string, float>()
            {
                ["spawnmini.tier1"] = 600f,
                ["spawnmini.tier2"] = 300f,
                ["spawnmini.tier3"] = 60f,
            };

            [JsonProperty("PermissionCooldowns")]
            private Dictionary<string, float> deprecatedSpawnPermissionCooldowns
            {
                set { spawnPermissionCooldowns = value; }
            }

            [JsonProperty("DefaultFetchCooldown")]
            public float defaultFetchCooldown = 0;

            [JsonProperty("PermissionFetchCooldowns", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, float> fetchPermissionCooldowns = new Dictionary<string, float>()
            {
                ["spawnmini.fetch.tier1"] = 600f,
                ["spawnmini.fetch.tier2"] = 300f,
                ["spawnmini.fetch.tier3"] = 60f,
            };

            [JsonProperty("SpawnHealth")]
            public float spawnHealth = 750f;

            [JsonProperty("DestroyOnDisconnect")]
            public bool destroyOnDisconnect = false;
        }

        private PluginConfig GetDefaultConfig() => new PluginConfig();

        #endregion

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["mini_destroyed"] = "Your Minicopter has been destroyed!",
                ["mini_perm"] = "You do not have permission to use this command!",
                ["mini_current"] = "You already have a Minicopter!",
                ["mini_notcurrent"] = "You do not have a Minicopter!",
                ["mini_buildingblocked"] = "Cannot do that while building blocked!",
                ["mini_timeleft_new"] = "You have <color=red>{0}</color> until your cooldown ends",
                ["mini_sdistance"] = "You're trying to spawn the Minicopter too far away!",
                ["mini_terrain"] = "Trying to spawn Minicopter outside of terrain!",
                ["mini_mounted"] = "A player is currenty mounted on the Minicopter!",
                ["mini_current_distance"] = "The Minicopter is too far!",
                ["mini_canmount"] = "You are not the owner of this Minicopter or in the owner's team!",
                ["mini_unlimited_fuel"] = "That Minicopter doesn't need fuel!",
                ["mini_location_restricted"] = "You cannot do that here!",
            }, this, "en");
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["mini_destroyed"] = "Ваш миникоптер был уничтожен!",
                ["mini_perm"] = "/mymini доступен по привелегии а так есть /craft",
                ["mini_current"] = "У вас уже есть мини-вертолет!",
                ["mini_notcurrent"] = "У вас нет мини-вертолета!",
                ["mini_timeleft_new"] = "У вас есть <color=red>{0}</color>, пока ваше время восстановления не закончится.",
                ["mini_sdistance"] = "Вы пытаетесь породить миникоптер слишком далеко!",
                ["mini_terrain"] = "Попытка породить мини-вертолет вне местности!",
                ["mini_mounted"] = "Игрок в данный момент сидит на миникоптере или это слишком далеко!",
                ["mini_current_distance"] = "Мини-вертолет слишком далеко!",
                ["mini_canmount"] = "Вы не являетесь владельцем этого Minicopter или в команде владельца!"
            }, this, "ru");
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["mini_destroyed"] = "Ihr minikopter wurde zerstört!",
                ["mini_perm"] = "/mymini доступен по привелегии а так есть /craft",
                ["mini_current"] = "Du hast bereits einen minikopter!",
                ["mini_notcurrent"] = "Du hast keine minikopter!",
                ["mini_timeleft_new"] = "Du hast <color=red>{0}</color>, bis ihre abklingzeit ende",
                ["mini_sdistance"] = "Du bist versuchen den minikopter zu weit weg zu spawnen!",
                ["mini_terrain"] = "Du versucht laichen einen minikopter außerhalb des geländes!",
                ["mini_mounted"] = "Ein Spieler ist gerade am Minikopter montiert oder es ist zu weit!",
                ["mini_current_distance"] = "Der Minikopter ist zu weit!",
                ["mini_rcon"] = "Dieser Befehl kann nur von RCON ausgeführt werden!",
                ["mini_canmount"] = "Sie sind nicht der Besitzer dieses Minicopters oder im Team des Besitzers!"
            }, this, "de");
        }

        #endregion

        #region Configuration Boilerplate

        internal class SerializableConfiguration
        {
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        internal static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(SerializableConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            bool changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                object currentRawValue;
                if (currentRaw.TryGetValue(key, out currentRawValue))
                {
                    var defaultDictValue = currentWithDefaults[key] as Dictionary<string, object>;
                    var currentDictValue = currentRawValue as Dictionary<string, object>;

                    if (defaultDictValue != null)
                    {
                        // Don't update nested keys since the cooldown tiers might be customized
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _config = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<PluginConfig>();
                if (_config == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(_config))
                {
                    PrintWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                PrintError(e.Message);
                PrintWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Puts($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_config, true);
        }

        #endregion
    }
}

// --- End of file: SpawnMini.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/BHair.cs ---
// --- Original Local Path: BeeRust/BHair.cs ---

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
	[Info("BHair", "King", "1.0.0")]
	public class BHair : RustPlugin
	{
        #region [Vars]
        [PluginReference] Plugin ImageLibrary;
        private static BHair plugin;
        public string Layer = "BHair.Layer";
        public string NewLayer = "BHair.NewLayer";
        public string NewLineLayer = "BHair.NewLineLayer";
        public string HairLayer = "BHair.HairLayer";
        #endregion

        #region [Config]
        private PluginConfig config;

        protected override void LoadDefaultConfig()
        {
            config = PluginConfig.DefaultConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();

            if (config.PluginVersion < Version)
                UpdateConfigValues();

            Config.WriteObject(config, true);
        }

        private void UpdateConfigValues()
        {
            PluginConfig baseConfig = PluginConfig.DefaultConfig();
            if (config.PluginVersion < Version)
            {
                config.PluginVersion = Version;
                if (Version == new VersionNumber(1, 0, 0))
                {
                    //
                }

                PrintWarning("Config checked completed!");
            }
            config.PluginVersion = Version;
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        public class MainSettings
        {
            [JsonProperty("Команда для меню прицелов")]
            public string openMenu;

            [JsonProperty(PropertyName = "Минимальный размер прицелов")]
            public int MinHairSize;

            [JsonProperty(PropertyName = "Максимальный размер прицелов")]
            public int MaxHairSize;
        }

        public class SettingsDefaultHair
        {
            [JsonProperty("Айди стандартного прицела ( Первоначальный айди прицела )")]
            public int HairID;

            [JsonProperty("Размеры стандратного прицела ( Первоначальный размер прицела )")]
            public int SizeHair;
        }

        public class SettingsHair
        {
            [JsonProperty("Картинка - ( Прицел )")]
            public string Image;

            [JsonProperty("Айди прицела ( При создании новых прибавлять )")]
            public int HairID;
        }

        private class PluginConfig
        {
            [JsonProperty("Основные настройки")]
            public MainSettings _MainSettings = new MainSettings();

            [JsonProperty("Стандартные настройки игрока")]
            public SettingsDefaultHair _SettingsDefaultHair = new SettingsDefaultHair();

            [JsonProperty("Настройка выбора прицелов")]
            public List<SettingsHair> _SettingsHair = new List<SettingsHair>();

            [JsonProperty("Config version")]
            public VersionNumber PluginVersion = new VersionNumber();

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    _MainSettings = new MainSettings
                    {
                        openMenu = "hair",
                        MinHairSize = 5,
                        MaxHairSize = 20,
                    },
                    _SettingsDefaultHair = new SettingsDefaultHair
                    {
                        HairID = 14,
                        SizeHair = 7,
                    },
                    _SettingsHair = new List<SettingsHair>()
                    {
                        new SettingsHair()
                        {
                            Image = "https://imgur.com/O1T5M2S.png",
                            HairID = 1,
                        },
                        new SettingsHair()
                        {
                            Image = "https://i.imgur.com/62zrHBV.png",
                            HairID = 2,
                        },
                        new SettingsHair()
                        {
                            Image = "https://i.imgur.com/RACMuqg.png",
                            HairID = 3,
                        },
                        new SettingsHair()
                        {
                            Image = "https://i.imgur.com/tqtF73m.png",
                            HairID = 4,
                        },
                        new SettingsHair()
                        {
                            Image = "https://imgur.com/lBZ2Khj.png",
                            HairID = 5,
                        },
                        new SettingsHair()
                        {
                            Image = "https://imgur.com/7zs9aHt.png",
                            HairID = 6,
                        },
                        new SettingsHair()
                        {
                            Image = "https://imgur.com/udgZFcU.png",
                            HairID = 7,
                        },
                        new SettingsHair()
                        {
                            Image = "https://i.imgur.com/mIbPpj3.png",
                            HairID = 8,
                        },
                        new SettingsHair()
                        {
                            Image = "https://i.imgur.com/XCSkVNk.png",
                            HairID = 9,
                        },
                        new SettingsHair()
                        {
                            Image = "https://i.imgur.com/mIbPpj3.png",
                            HairID = 10,
                        },
                        new SettingsHair()
                        {
                            Image = "https://imgur.com/udgZFcU.png",
                            HairID = 11,
                        },
                        new SettingsHair()
                        {
                            Image = "https://imgur.com/7zs9aHt.png",
                            HairID = 12,
                        },
                        new SettingsHair()
                        {
                            Image = "https://imgur.com/lBZ2Khj.png",
                            HairID = 13,
                        },
                        new SettingsHair()
                        {
                            Image = "https://i.imgur.com/21Af6kF.png",
                            HairID = 14,
                        },
                    },
                    PluginVersion = new VersionNumber()
                };
            }
        }
        #endregion

        #region [Data]
        private void LoadData()
        {
            try
            {
                data = Interface.Oxide.DataFileSystem.ReadObject<PluginData>("BHair/playerData");
            }
            catch (Exception e)
            {
                PrintError(e.ToString());
            }

            if (data == null) data = new PluginData();
        }

        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject("BHair/playerData", data);

        private class PluginData
        {
            public Dictionary<ulong, PlayerData> PlayerData = new Dictionary<ulong, PlayerData>();
        }
    
        private static PluginData data;

        private class PlayerData
        {
            public int HairID;
            public int HairSize;

            public static PlayerData GetOrAdd(BasePlayer player)
            {
                return GetOrAdd(player.userID);
            }

            public static PlayerData GetOrAdd(ulong userId)
            {
                if (!data.PlayerData.ContainsKey(userId))
                    data.PlayerData.Add(userId, new PlayerData
                    {
                        HairID = plugin.config._SettingsDefaultHair.HairID,
                        HairSize = plugin.config._SettingsDefaultHair.SizeHair,
                    });

                return data.PlayerData[userId];
            }
        }
        #endregion

        #region [ImageLibrary]
        private bool HasImage(string imageName, ulong imageId = 0) => (bool)ImageLibrary.Call("HasImage", imageName, imageId);
        private bool AddImage(string url, string shortname, ulong skin = 0) => (bool)ImageLibrary?.Call("AddImage", url, shortname, skin);
        private string GetImage(string shortname, ulong skin = 0) => (string)ImageLibrary?.Call("GetImage", shortname, skin);
        #endregion

        #region [Oxide]
        private void OnServerInitialized()
        {
            plugin = this;
            LoadData();
            cmd.AddChatCommand(config._MainSettings.openMenu, this, "MainUi");
            foreach (var key in config._SettingsHair)
                AddImage(key.Image, key.Image);

            AddImage("https://i.postimg.cc/5t74ZzBr/C2g6QoA.png", $"{Name}.Background");
            AddImage("https://i.postimg.cc/V6rG9J5S/Group-11-1-1.png", $"ItemFon");
            AddImage("https://i.postimg.cc/Gt5jZ44x/uHTdwjY.png", $"{Name}.BlockFon");

            foreach (var player in BasePlayer.activePlayerList)
                OnPlayerConnected(player);
        }
        private void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, Layer);
                CuiHelper.DestroyUi(player, HairLayer);
            }

            SaveData();
            plugin = null;
            data = null;
        }
        #endregion

        #region [Rust-Api]
        private void OnPlayerConnected(BasePlayer player)
        {
            var data = PlayerData.GetOrAdd(player);
            if (data != null)
            {
                var find = config._SettingsHair.FirstOrDefault(p => p.HairID == data.HairID);
                if (find == null) return;

                HairUI(player, find.Image);
            }
        }
        #endregion

        #region [Ui]
        private void MainUi(BasePlayer player)
        {
            #region [Vars]
            CuiElementContainer container = new CuiElementContainer();
            #endregion

            #region [Parrent]
            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Image = { Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat", Color = "0 0 0 0.7" }
            }, "Overlay", Layer);

            container.Add(new CuiElement
            {
                Parent = Layer,
                Components =
                {
                    new CuiRawImageComponent { Png = GetImage($"{Name}.Background"), Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                }
            });

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Image = { Color = "0 0 0 0.35", Material = "assets/content/ui/uibackgroundblur.mat", Sprite = "assets/content/ui/ui.background.transparent.radial.psd" }
            }, Layer);
            #endregion

            #region [Main-Ui]
            container.Add(new CuiPanel
            {
                Image = { Color = "0.3773585 0.3755785 0.3755785 0.65" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-200 -185", OffsetMax = "203 186" },
            }, Layer, Layer + ".Main");

            container.Add(new CuiPanel
            {
                Image = { Color = "0.3773585 0.3755785 0.3755785 0.65" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-180 -223", OffsetMax = "183 -195" },
            }, Layer, Layer + ".ChangeSize");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-43 -263", OffsetMax = "46 -235" },
                Text = { Text = "ЗАКРЫТЬ", Font = "robotocondensed-bold.ttf", FontSize = 11, Align = TextAnchor.MiddleCenter, Color = "1 1 1 0.65" },
                Button = { Color = "0.3773585 0.3755785 0.3755785 0.65", Close = Layer }
            }, Layer);
            #endregion

            #region [Text]
            container.Add(new CuiLabel
            {
                Text = { Text = $"ВЫБЕРИТЕ ПРИЦЕЛ", Color = "1 1 1 0.85", FontSize = 32, Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperCenter },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-200 186", OffsetMax = "203 235" },
            }, Layer);
            #endregion

            CuiHelper.DestroyUi(player, Layer);
            CuiHelper.AddUi(player, container);
            HairList(player);
            SizeLine(player);
        }

        private void HairList(BasePlayer player, Int32 page = 0)
        {
            #region [Vars]
            CuiElementContainer container = new CuiElementContainer();

            var ItemList = config._SettingsHair.Skip(25 * page).Take(25).ToList();
            var data = PlayerData.GetOrAdd(player);
            #endregion

            #region [Parrent]
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Image = { Color = "0 0 0 0" }
            }, Layer + ".Main", Layer + ".Main" + ".LayerItem");
            #endregion

            #region [Items]
            for (Int32 i = 0, x = 0, y = 0; i < 25; i++)
            {
                if (ItemList.Count - 1 >= i)
                {
                    container.Add(new CuiPanel
                    {
                        RectTransform = { AnchorMin = $"{0.036 + x * 0.187} {0.775 - y * 0.185}", AnchorMax = $"{0.206 + x * 0.187} {0.945 - y * 0.185}" },
                        Image = { Color = "0 0 0 0" }
                    }, Layer + ".Main" + ".LayerItem", Layer + ".Main" + ".LayerItem" + $".Item{i}");

                    container.Add(new CuiElement
                    {
                        Parent = Layer + ".Main" + ".LayerItem" + $".Item{i}",
                        Components =
                        {
                            new CuiRawImageComponent { Png = GetImage(ItemList[i].Image) },
                            new CuiRectTransformComponent { AnchorMin = "0.2 0.2", AnchorMax = "0.8 0.8" }
                        }
                    });

                    if (data.HairID == ItemList[i].HairID)
                    {
                        container.Add(new CuiElement
                        {
                            Parent = Layer + ".Main" + ".LayerItem" + $".Item{i}",
                            Components =
                            {
                                new CuiRawImageComponent { Png = GetImage($"ItemFon"), Color = "1 1 1 1" },
                                new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                            }
                        });
                    }
                    else
                    {
                        container.Add(new CuiElement
                        {
                            Parent = Layer + ".Main" + ".LayerItem" + $".Item{i}",
                            Components =
                            {
                                new CuiRawImageComponent { Png = GetImage($"{Name}.BlockFon"), Color = "0 0 0 1" },
                                new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                            }
                        });

                        container.Add(new CuiPanel
                        {
                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                            Image = { Color = "0 0 0 0.5" }
                        }, Layer + ".Main" + ".LayerItem" + $".Item{i}");
                    }

                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                        Button = { Color = "0 0 0 0", Command = $"UI_BHAIR sethair {ItemList[i].HairID} {page}" },
                        Text = { Text = "" }
                    }, Layer + ".Main" + ".LayerItem" + $".Item{i}");
                }
                else
                {
                    container.Add(new CuiPanel
                    {
                        RectTransform = { AnchorMin = $"{0.036 + x * 0.187} {0.775 - y * 0.185}", AnchorMax = $"{0.206 + x * 0.187} {0.945 - y * 0.185}" },
                        Image = { Color = "0 0 0 0" }
                    }, Layer + ".Main" + ".LayerItem", Layer + ".Main" + ".LayerItem" + $".Item{i}");

                    container.Add(new CuiElement
                    {
                        Parent = Layer + ".Main" + ".LayerItem" + $".Item{i}",
                        Components =
                        {
                            new CuiRawImageComponent { Png = GetImage($"{Name}.BlockFon"), Color = "0 0 0 1" },
                            new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                        }
                    });

                    container.Add(new CuiPanel
                    {
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                        Image = { Color = "0 0 0 0.5" }
                    }, Layer + ".Main" + ".LayerItem" + $".Item{i}");
                }

                x++;
                if (x == 5)
                {
                    x = 0;
                    y++;
                }
            }
            #endregion

            #region [Page]
            container.Add(new CuiButton
            {
                Button = { Color = "0.3773585 0.3755785 0.3755785 0.65", Command = config._SettingsHair.Skip(25 * (page + 1)).Count() > 0 ? $"UI_BHAIR setpage {page + 1}" : "" },
                Text = { Text = ">", FontSize = 18, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter, Color = config._SettingsHair.Skip(25 * (page + 1)).Count() > 0 ? "1 1 1 0.65" : "1 1 1 0.15" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "207.5 -13", OffsetMax = "234 13" }
            }, Layer + ".Main" + ".LayerItem");

            container.Add(new CuiButton
            {
                Button = { Color = "0.3773585 0.3755785 0.3755785 0.65", Command = page >= 1 ? $"UI_BHAIR setpage {page - 1}" : "" },
                Text = { Text = "<", FontSize = 18, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter, Color = page >= 1 ? "1 1 1 0.65" : "1 1 1 0.15" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-234 -13", OffsetMax = "-207.5 13" }
            }, Layer + ".Main" + ".LayerItem");
            #endregion

            CuiHelper.DestroyUi(player, Layer + ".Main" + ".LayerItem");
            CuiHelper.AddUi(player, container);
        }

        private void SizeLine(BasePlayer player)
        {
            #region [Vars]
            CuiElementContainer container = new CuiElementContainer();

            var data = PlayerData.GetOrAdd(player);
            float width; float xSwitch; width = 250; xSwitch = 0;
            var steps = config._MainSettings.MaxHairSize - config._MainSettings.MinHairSize;
            var progress = (float)(data.HairSize - 5) / steps;
            var size = width / steps;
            #endregion

            #region [Parrent]
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Image = { Color = "0 0 0 0" }
            }, Layer + ".ChangeSize", Layer + ".ChangeSize" + ".Layer");
            #endregion

            #region [Main-Ui]
            container.Add(new CuiPanel
            {
                RectTransform = {AnchorMin = "0.1 0.385", AnchorMax = "0.896 0.56"},
                Image = { Color = "0.2 0.2 0.2 0.45", Material = "assets/icons/greyout.mat" }
            }, Layer + ".ChangeSize" + ".Layer", ".HairSize.Line");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = $"{progress} 0.95" },
                Image = { Color = "1 1 0.55", Material = "assets/icons/greyout.mat" }
            }, ".HairSize.Line", ".HairSize.Line.Finish");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "1 0.5", AnchorMax = "1 0.5", OffsetMin = "-5 -5", OffsetMax = "5 5" },
                Image = { Color = "0 0 0 1", Material = "assets/icons/greyout.mat" }
            }, ".HairSize.Line.Finish");

            for (var i = config._MainSettings.MinHairSize; i <= config._MainSettings.MaxHairSize; i++)
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "0 1", OffsetMin = $"{xSwitch} 0", OffsetMax = $"{xSwitch + size} 0" },
                    Text = { Text = "" },
                    Button = { Color = "0 0 0 0", Command = $"UI_BHAIR setsize {i}" }
                }, ".HairSize.Line");
                xSwitch += size;
            }
            #endregion

            CuiHelper.DestroyUi(player, Layer + ".ChangeSize" + ".Layer");
            CuiHelper.AddUi(player, container);
        }

        private void HairUI(BasePlayer player, string hair)
        {
            CuiHelper.DestroyUi(player, HairLayer);
            var container = new CuiElementContainer();
            var data = PlayerData.GetOrAdd(player);
            float margin = data.HairSize;
            if (data.HairID == config._SettingsHair.Count()) return;

            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0" }
            }, "Hud", HairLayer);

            container.Add(new CuiElement
            {
                Parent = HairLayer,
                Components =
                {
                    new CuiRawImageComponent { Png = GetImage($"{hair}"), Color = "1 1 1 0.8" },
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = $"-{margin} -{margin}", OffsetMax = $"{margin} {margin}" }
                }
            });

            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region [ConsoleCommand && ChatCommand]
        [ConsoleCommand("UI_BHAIR")]
        private void CmdConsoleMarkers(ConsoleSystem.Arg arg)
        {
            var player = arg?.Player();
            if (player == null || !arg.HasArgs()) return;

            switch (arg.Args[0])
            {
                case "setsize":
                {
                    int HairSize;
                    if (!arg.HasArgs(2) || !int.TryParse(arg.Args[1], out HairSize)) return;

                    var data = PlayerData.GetOrAdd(player);
                    if (data == null) return;

                    var find = config._SettingsHair.FirstOrDefault(p => p.HairID == data.HairID);
                    if (find == null) return;

                    data.HairSize = HairSize;

                    HairUI(player, find.Image);
                    SizeLine(player);
                    break;
                }
                case "sethair":
                {
                    int HairID;
                    if (!arg.HasArgs(2) || !int.TryParse(arg.Args[1], out HairID)) return;

                    var data = PlayerData.GetOrAdd(player);
                    if (data == null) return;

                    var find = config._SettingsHair.FirstOrDefault(p => p.HairID == HairID);
                    if (find == null) return;

                    data.HairID = HairID;

                    HairUI(player, find.Image);
                    HairList(player, int.Parse(arg.Args[2]));
                    break;
                }
                case "setpage":
                {
                    int Page;
                    if (!arg.HasArgs(2) || !int.TryParse(arg.Args[1], out Page)) return;

                    HairList(player, Page);
                    break;
                }
            }
        }
        #endregion
    }
}

// --- End of file: BHair.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/Vanish.cs ---
// --- Original Local Path: BeeRust/Vanish.cs ---

using Network;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Cui;
using Rust;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Vanish", "Whispers88", "1.8.0")]
    [Description("Allows players with permission to become invisible")]
    public class Vanish : CovalencePlugin
    {
        #region Configuration
        private readonly List<BasePlayer> _hiddenPlayers = new List<BasePlayer>();
        private List<ulong> _hiddenOffline = new List<ulong>();
        private static readonly List<string> _registeredhooks = new List<string> { "CanUseLockedEntity", "OnPlayerDisconnected", "OnEntityTakeDamage" };
        private static readonly DamageTypeList _EmptyDmgList = new DamageTypeList();
        CuiElementContainer cachedVanishUI = null;


        private Configuration config;

        public class Configuration
        {
            [JsonProperty("NoClip on Vanish (runs noclip command)")]
            public bool NoClipOnVanish = true;

            [JsonProperty("Use OnEntityTakeDamage hook (Set to true to enable use of vanish.damage perm. Set to false for better performance)")]
            public bool UseOnEntityTakeDamage = false;

            [JsonProperty("Use CanUseLockedEntity hook (Allows vanished players with the perm vanish.unlock to bypass locks. Set to false for better performance)")]
            public bool UseCanUseLockedEntity = true;

            [JsonProperty("Keep a vanished player hidden on disconnect")]
            public bool HideOnDisconnect = true;

            [JsonProperty("Turn off fly hack detection for players in vanish")]
            public bool AntiHack = true;

            [JsonProperty("Disable metabolism in vanish")]
            public bool Metabolism = true;

            [JsonProperty("Reset hydration and health on un-vanishing (resets to pre-vanished state)")]
            public bool MetabolismReset = true;

            [JsonProperty("Enable vanishing and reappearing sound effects")]
            public bool EnableSound = true;

            [JsonProperty("Make sound effects public")]
            public bool PublicSound = false;

            [JsonProperty("Enable chat notifications")]
            public bool EnableNotifications = true;

            [JsonProperty("Sound effect to use when vanishing")]
            public string VanishSoundEffect = "assets/prefabs/npc/patrol helicopter/effects/rocket_fire.prefab";

            [JsonProperty("Sound effect to use when reappearing")]
            public string ReappearSoundEffect = "assets/prefabs/npc/patrol helicopter/effects/rocket_fire.prefab";

            [JsonProperty("Enable GUI")]
            public bool EnableGUI = true;

            [JsonProperty("Icon URL (.png or .jpg)")]
            public string ImageUrlIcon = "https://i.imgur.com/yL9HNRy.png";

            [JsonProperty("Image Color")]
            public string ImageColor = "1 1 1 0.3";

            [JsonProperty("Image AnchorMin")]
            public string ImageAnchorMin = "0.175 0.017";

            [JsonProperty("Image AnchorMax")]
            public string ImageAnchorMax = "0.22 0.08";

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    throw new JsonException();
                }

                if (config.ImageUrlIcon == "http://i.imgur.com/Gr5G3YI.png")
                {
                    config.ImageUrlIcon = "https://i.imgur.com/yL9HNRy.png";
                    config.ImageColor = "1 1 1 0.8";
                    if (config.ImageAnchorMin == "0.175 0.017" && config.ImageAnchorMax == "0.22 0.08")
                    {
                        config.ImageAnchorMin = "0.18 0.017";
                        config.ImageAnchorMax = "0.22 0.09";
                    }
                    LogWarning("Updating image Icon URL");
                    SaveConfig();
                }

                if (!config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch
            {
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            LogWarning($"Configuration changes saved to {Name}.json");
            Config.WriteObject(config, true);
        }

        private void Loaded()
        {
            _hiddenOfflineData = Interface.Oxide.DataFileSystem.GetFile("VanishPlayers");
            LoadData();
        }

        #endregion Configuration

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["VanishCommand"] = "vanish",
                ["Vanished"] = "Vanish: <color=orange> Enabled </color>",
                ["Reappear"] = "Vanish: <color=orange> Disabled </color>",
                ["NoPerms"] = "You do not have permission to do this",
                ["PermanentVanish"] = "You are in a permanent vanish mode",

            }, this);
        }

        #endregion Localization

        #region Initialization

        private const string PermAllow = "vanish.allow";
        private const string PermUnlock = "vanish.unlock";
        private const string PermDamage = "vanish.damage";
        private const string PermVanish = "vanish.permanent";

        private void Init()
        {
            cachedVanishUI = CreateVanishUI();

            // Register universal chat/console commands
            AddLocalizedCommand(nameof(VanishCommand));

            // Register permissions for commands
            permission.RegisterPermission(PermAllow, this);
            permission.RegisterPermission(PermUnlock, this);
            permission.RegisterPermission(PermDamage, this);
            permission.RegisterPermission(PermVanish, this);

            //Unsubscribe from hooks
            UnSubscribeFromHooks();

            if (!config.UseOnEntityTakeDamage)
            {
                _registeredhooks.Remove("OnEntityTakeDamage");
            }

            if (!config.UseCanUseLockedEntity)
            {
                _registeredhooks.Remove("CanUseLockedEntity");
            }

            foreach (var player in BasePlayer.activePlayerList)
            {
                if (!HasPerm(player.UserIDString, PermVanish) || IsInvisible(player)) continue;
                Disappear(player);
            }

        }

        private void Unload()
        {
            foreach (var p in _hiddenPlayers)
            {
                if (!_hiddenOffline.Contains(p.userID))
                    _hiddenOffline.Add(p.userID);
            }

            SaveData();

            for (int i = _hiddenPlayers.Count - 1; i > -1; i--)
            {
                if (_hiddenPlayers[i] == null) continue;
                Reappear(_hiddenPlayers[i]);
            }
        }

        private DynamicConfigFile _hiddenOfflineData;

        private void LoadData()
        {
            try
            {
                _hiddenOffline = _hiddenOfflineData.ReadObject<List<ulong>>();
            }
            catch
            {
                _hiddenOffline = new List<ulong>();
            }

            foreach (var playerid in _hiddenOffline)
            {
                BasePlayer player = BasePlayer.FindByID(playerid);
                if (player == null) continue;
                if (IsInvisible(player))
                    continue;

                if (!player.IsConnected)
                {
                    List<Connection> connections = new List<Connection>();
                    foreach (var con in Net.sv.connections)
                    {
                        if (con.connected && con.isAuthenticated && con.player is BasePlayer && con.player != player)
                            connections.Add(con);
                    }
                    player.OnNetworkSubscribersLeave(connections);
                    player.DisablePlayerCollider();
                    player.syncPosition = false;
                    player.limitNetworking = true;
                }
                else
                {
                    Disappear(player);
                }
            }
        }

        private void SaveData()
        {
            _hiddenOfflineData.WriteObject(_hiddenOffline);
        }

        #endregion Initialization

        #region Commands
        private void VanishCommand(IPlayer iplayer, string command, string[] args)
        {
            BasePlayer player = (BasePlayer)iplayer.Object;
            if (player == null) return;
            if (!HasPerm(player.UserIDString, PermAllow))
            {
                if (config.EnableNotifications) Message(player.IPlayer, "NoPerms");
                return;
            }
            if (HasPerm(player.UserIDString, PermVanish))
            {
                if (config.EnableNotifications) Message(player.IPlayer, "PermanentVanish");
                return;
            }
            if (IsInvisible(player)) Reappear(player);
            else Disappear(player);
        }

        private void Reappear(BasePlayer player)
        {
            if (Interface.CallHook("OnVanishReappear", player) != null) return;
            if (config.AntiHack) player.ResetAntiHack();

            player.syncPosition = true;
            VanishPositionUpdate vanishPositionUpdate;

            if (player.TryGetComponent<VanishPositionUpdate>(out vanishPositionUpdate))
                UnityEngine.Object.Destroy(vanishPositionUpdate);


            //metabolism
            if (config.Metabolism)
            {
                player.metabolism.temperature.min = -100;
                player.metabolism.temperature.max = 100;
                player.metabolism.radiation_poison.max = 500;
                player.metabolism.oxygen.min = 0;
                player.metabolism.calories.min = 0;
                player.metabolism.wetness.max = 1;
            }
            if (config.MetabolismReset)
            {
                MetabolismValues value;

                if (_storedMetabolism.TryGetValue(player, out value))
                {
                    player.health = value.health;
                    player.metabolism.hydration.value = value.hydration;
                }
                _storedMetabolism.Remove(player);
            }

            player.metabolism.isDirty = true;
            player.metabolism.SendChangesToClient();

            player._limitedNetworking = false;

            _hiddenPlayers.Remove(player);
            player.EnablePlayerCollider();
            player.UpdateNetworkGroup();
            player.SendNetworkUpdate();
            player.GetHeldEntity()?.SendNetworkUpdate();

            //Un-Mute Player Effects
            player.drownEffect.guid = "28ad47c8e6d313742a7a2740674a25b5";
            player.fallDamageEffect.guid = "ca14ed027d5924003b1c5d9e523a5fce";

            if (_hiddenPlayers.Count == 0) UnSubscribeFromHooks();

            if (config.EnableSound)
            {
                if (config.PublicSound)
                {
                    Effect.server.Run(config.ReappearSoundEffect, player.transform.position);
                }
                else
                {
                    SendEffect(player, config.ReappearSoundEffect);
                }
            }
            CuiHelper.DestroyUi(player, "VanishUI");

            if (config.NoClipOnVanish && player.IsFlying) player.SendConsoleCommand("noclip");

            if (config.EnableNotifications) Message(player.IPlayer, "Reappear");
        }

        private class MetabolismValues
        {
            public float health;
            public float hydration;
        }

        private Dictionary<BasePlayer, MetabolismValues> _storedMetabolism = new Dictionary<BasePlayer, MetabolismValues>();
        private void Disappear(BasePlayer player)
        {
            if (!_hiddenPlayers.Contains(player))
                _hiddenPlayers.Add(player);

            if (Interface.CallHook("OnVanishDisappear", player) != null) return;

            if (config.AntiHack)
                player.PauseFlyHackDetection(float.MaxValue);

            VanishPositionUpdate vanishPositionUpdate;
            if (player.TryGetComponent<VanishPositionUpdate>(out vanishPositionUpdate))
                UnityEngine.Object.Destroy(vanishPositionUpdate);

            player.gameObject.AddComponent<VanishPositionUpdate>();

            //metabolism
            if (config.Metabolism)
            {
                player.metabolism.temperature.min = 20;
                player.metabolism.temperature.max = 20;
                player.metabolism.radiation_poison.max = 0;
                player.metabolism.oxygen.min = 1;
                player.metabolism.wetness.max = 0;
                player.metabolism.calories.min = player.metabolism.calories.value;
                player.metabolism.isDirty = true;
                player.metabolism.SendChangesToClient();
            }
            if (config.MetabolismReset && !player._limitedNetworking)
                _storedMetabolism[player] = new MetabolismValues() { health = player.health, hydration = player.metabolism.hydration.value };

            List<Connection> connections = new List<Connection>();
            foreach (var con in Net.sv.connections)
            {
                if (con.connected && con.isAuthenticated && con.player is BasePlayer && con.player != player)
                    connections.Add(con);
            }
            player.OnNetworkSubscribersLeave(connections);
            player.DisablePlayerCollider();
            player.syncPosition = false;

            player._limitedNetworking = true;

            //Mute Player Effects
            player.fallDamageEffect = new GameObjectRef();
            player.drownEffect = new GameObjectRef();

            if (_hiddenPlayers.Count == 1) SubscribeToHooks();

            if (config.EnableSound)
            {
                if (config.PublicSound)
                {
                    Effect.server.Run(config.VanishSoundEffect, player.transform.position);
                }
                else
                {
                    SendEffect(player, config.VanishSoundEffect);
                }
            }

            if (config.NoClipOnVanish && !player.IsFlying && !player.isMounted) player.SendConsoleCommand("noclip");

            if (config.EnableGUI)
            {
                CuiHelper.AddUi(player, cachedVanishUI);
            }

            if (config.EnableNotifications) Message(player.IPlayer, "Vanished");
        }

        #endregion Commands

        #region Hooks
        private void OnPlayerConnected(BasePlayer player)
        {
            if (_hiddenOffline.Contains(player.userID))
            {
                _hiddenOffline.Remove(player.userID);
                if (HasPerm(player.UserIDString, PermAllow))
                    Disappear(player);
                return;
            }
            if (HasPerm(player.UserIDString, PermVanish))
            {
                Disappear(player);
            }
        }

        private object CanUseLockedEntity(BasePlayer player, BaseLock baseLock)
        {
            if (!player.limitNetworking) return null;
            if (HasPerm(player.UserIDString, PermUnlock)) return true;
            if (config.EnableNotifications) Message(player.IPlayer, "NoPerms");
            return null;
        }

        private object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            BasePlayer attacker = info?.InitiatorPlayer;
            BasePlayer victim = entity?.ToPlayer();
            if (!IsInvisible(victim) && !IsInvisible(attacker)) return null;
            if (attacker == null) return null;
            if (IsInvisible(attacker) && HasPerm(attacker.UserIDString, PermDamage)) return null;
            info.damageTypes = _EmptyDmgList;
            info.HitMaterial = 0;
            info.PointStart = Vector3.zero;
            info.HitEntity = null;
            return true;
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (!IsInvisible(player)) return;

            if (!config.HideOnDisconnect && !HasPerm(player.UserIDString, PermVanish))
                Reappear(player);
            else
            {
                float terrainY = TerrainMeta.HeightMap.GetHeight(player.transform.position);
                if (player.transform.position.y > terrainY)
                    player.transform.position = new Vector3(player.transform.position.x, terrainY, player.transform.position.z);

                if (!_hiddenOffline.Contains(player.userID))
                    _hiddenOffline.Add(player.userID);

                _hiddenPlayers.Remove(player);
                VanishPositionUpdate t;
                if (player.TryGetComponent<VanishPositionUpdate>(out t))
                    UnityEngine.Object.Destroy(t);
            }
            if (_hiddenPlayers.Count == 0) UnSubscribeFromHooks();
            CuiHelper.DestroyUi(player, "VanishUI");
            CuiHelper.DestroyUi(player, "VanishColliderUI");
        }

        private void OnPlayerSpectate(BasePlayer player, string spectateFilter)
        {
            VanishPositionUpdate vanishPositionUpdate;
            if (!player.TryGetComponent<VanishPositionUpdate>(out vanishPositionUpdate)) return;
            UnityEngine.Object.Destroy(vanishPositionUpdate);
        }

        private void OnPlayerSpectateEnd(BasePlayer player, string spectateFilter)
        {
            if (!player._limitedNetworking) return;

            VanishPositionUpdate vanishPositionUpdate;
            if (!player.TryGetComponent<VanishPositionUpdate>(out vanishPositionUpdate))
                player.gameObject.AddComponent<VanishPositionUpdate>().EndSpectate();
        }

        private object OnPlayerColliderEnable(BasePlayer player, CapsuleCollider collider) => IsInvisible(player) ? (object)true : null;

        #endregion Hooks

        #region GUI
        private CuiElementContainer CreateVanishUI()
        {
            CuiElementContainer elements = new CuiElementContainer();
            string panel = elements.Add(new CuiPanel
            {
                Image = { Color = "0.5 0.5 0.5 0.0" },
                RectTransform = { AnchorMin = config.ImageAnchorMin, AnchorMax = config.ImageAnchorMax }
            }, "Hud.Menu", "VanishUI");
            elements.Add(new CuiElement
            {
                Parent = panel,
                Components =
                {
                    new CuiRawImageComponent {Color = config.ImageColor, Url = config.ImageUrlIcon},
                    new CuiRectTransformComponent {AnchorMin = "0 0", AnchorMax = "1 1"}
                }
            });
            return elements;
        }

        #endregion GUI

        #region Monobehaviour
        public class VanishPositionUpdate : FacepunchBehaviour
        {
            private BasePlayer player;
            private static int Layermask = LayerMask.GetMask(LayerMask.LayerToName((int)Layer.Construction), LayerMask.LayerToName((int)Layer.Deployed), LayerMask.LayerToName((int)Layer.Vehicle_World), LayerMask.LayerToName((int)Layer.Player_Server));
            LootableCorpse corpse;
            GameObject child;
            SphereCollider col;
            int LayerReserved1 = (int)Layer.Reserved1;

            private void Awake()
            {
                player = GetComponent<BasePlayer>();
                player.transform.localScale = Vector3.zero;
                BaseEntity.Query.Server.RemovePlayer(player);
                CreateChildGO();
            }

            private void FixedUpdate()
            {
                if (player == null) return;

                if (corpse != null && !player.inventory.loot.IsLooting())
                    corpse.Kill();

                if (!player.serverInput.WasJustReleased(BUTTON.RELOAD)) return;

                RaycastHit raycastHit;
                if (!Physics.Raycast(player.eyes.HeadRay(), out raycastHit, 5f, Layermask))
                    return;

                BaseEntity entity = raycastHit.GetEntity() as BaseEntity;

                if (entity == null) return;
                if (entity as StorageContainer != null)
                {
                    StorageContainer container = (StorageContainer)entity;
                    entity.SendAsSnapshot(player.Connection);
                    player.inventory.loot.AddContainer(container.inventory);
                    player.inventory.loot.entitySource = container;
                    player.inventory.loot.PositionChecks = false;
                    player.inventory.loot.MarkDirty();
                    player.inventory.loot.SendImmediate();
                    player.ClientRPCPlayer<string>(null, player, "RPC_OpenLootPanel", "generic_resizable");
                    return;
                }

                if (entity as BasePlayer != null)
                {
                    BasePlayer targetplayer = (BasePlayer)entity;
                    corpse = GameManager.server.CreateEntity(StringPool.Get(2604534927), Vector3.zero) as LootableCorpse;
                    corpse.CancelInvoke("RemoveCorpse");
                    corpse.syncPosition = false;
                    corpse.limitNetworking = true;
                    corpse.playerName = targetplayer.displayName;
                    corpse.playerSteamID = 0;
                    corpse.enableSaving = false;
                    corpse.Spawn();
                    corpse.SetFlag(BaseEntity.Flags.Locked, true);
                    Buoyancy bouyancy;
                    if (corpse.TryGetComponent<Buoyancy>(out bouyancy))
                    {
                        Destroy(bouyancy);
                    }
                    Rigidbody ridgidbody;
                    if (corpse.TryGetComponent<Rigidbody>(out ridgidbody))
                    {
                        Destroy(ridgidbody);
                    }

                    corpse.SendAsSnapshot(player.Connection);

                    player.inventory.loot.AddContainer(targetplayer.inventory.containerMain);
                    player.inventory.loot.AddContainer(targetplayer.inventory.containerWear);
                    player.inventory.loot.AddContainer(targetplayer.inventory.containerBelt);
                    player.inventory.loot.entitySource = corpse;
                    player.inventory.loot.PositionChecks = false;
                    player.inventory.loot.MarkDirty();
                    player.inventory.loot.SendImmediate();
                    player.ClientRPCPlayer<string>(null, player, "RPC_OpenLootPanel", "player_corpse");
                    return;
                }

                if (entity as Door != null)
                {
                    Door door = (Door)entity;
                    if (door.IsOpen())
                    {
                        door.SetOpen(false, true);
                    }
                    else
                    {
                        door.SetOpen(true, false);
                    }
                    return;
                }

                BaseMountable component = entity.GetComponent<BaseMountable>();
                if (!component)
                {
                    BaseVehicle componentInParent = entity.GetComponentInParent<BaseVehicle>();
                    if (componentInParent)
                    {
                        if (!componentInParent.isServer)
                        {
                            componentInParent = BaseNetworkable.serverEntities.Find(componentInParent.net.ID) as BaseVehicle;
                        }
                        componentInParent.AttemptMount(player, true);
                        return;
                    }
                }

                if (component && !component.isServer)
                {
                    component = BaseNetworkable.serverEntities.Find(component.net.ID) as BaseMountable;
                }
                if (component)
                {
                    component.AttemptMount(player, true);
                }

            }

            private void UpdatePos()
            {
                if (player == null || player.IsSpectating())
                    return;

                using (TimeWarning.New("UpdateVanishGroup"))
                    player.net.UpdateGroups(player.transform.position);
            }

            void OnTriggerEnter(Collider col)
            {
                TriggerParent triggerParent = col.GetComponentInParent<TriggerParent>();
                if (triggerParent != null)
                {
                    triggerParent.OnEntityEnter(player);
                    return;
                }
                TriggerWorkbench triggerWorkbench = col.GetComponentInParent<TriggerWorkbench>();
                if (triggerWorkbench != null)
                {
                    player.EnterTrigger(triggerWorkbench);
                    player.nextCheckTime = float.MaxValue;
                    player.cachedCraftLevel = triggerWorkbench.parentBench.Workbenchlevel;
                    player.SetPlayerFlag(BasePlayer.PlayerFlags.Workbench1, player.cachedCraftLevel == 1f);
                    player.SetPlayerFlag(BasePlayer.PlayerFlags.Workbench2, player.cachedCraftLevel == 2f);
                    player.SetPlayerFlag(BasePlayer.PlayerFlags.Workbench3, player.cachedCraftLevel == 3f);
                }
            }

            void OnTriggerExit(Collider col)
            {
                TriggerParent triggerParent = col.GetComponentInParent<TriggerParent>();
                if (triggerParent != null)
                {
                    triggerParent.OnEntityLeave(player);
                    return;
                }
                TriggerWorkbench triggerWorkbench = col.GetComponentInParent<TriggerWorkbench>();
                if (triggerWorkbench != null)
                {
                    player.LeaveTrigger(triggerWorkbench);
                    player.cachedCraftLevel = 0f;
                    player.SetPlayerFlag(BasePlayer.PlayerFlags.Workbench1, false);
                    player.SetPlayerFlag(BasePlayer.PlayerFlags.Workbench2, false);
                    player.SetPlayerFlag(BasePlayer.PlayerFlags.Workbench3, false);
                    player.nextCheckTime = Time.realtimeSinceStartup;
                    return;
                }
            }

            public void EndSpectate()
            {
                InvokeRepeating(RespawnCheck, 1f, 0.5f);
            }

            public void RespawnCheck()
            {
                if (player == null || !player.IsAlive()) return;
                CancelInvoke(RespawnCheck);
                player.SetPlayerFlag(BasePlayer.PlayerFlags.Spectating, false);
                player.SendNetworkUpdateImmediate();
                CreateChildGO();
            }

            public void CreateChildGO()
            {
                if (player == null || player.IsSpectating())
                    return;

                player.transform.localScale = Vector3.zero;
                child = gameObject.CreateChild();
                col = child.AddComponent<SphereCollider>();
                child.layer = LayerReserved1;
                child.transform.localScale = Vector3.zero;
                col.isTrigger = true;
                player.lastAdminCheatTime = float.MaxValue;
                InvokeRepeating("UpdatePos", 1f, 5f);
            }

            private void OnDestroy()
            {
                CancelInvoke(UpdatePos);

                if (corpse != null)
                    corpse.Kill();

                if (player != null)
                {
                    if (player.IsConnected)
                        player.Connection.active = true;

                    BaseEntity.Query.Server.AddPlayer(player);
                    player.lastAdminCheatTime = Time.realtimeSinceStartup;
                    player.transform.localScale = new Vector3(1, 1, 1);

                    //Reset Triggers
                    if (player?.triggers != null)
                    {
                        for (int i = player.triggers.Count - 1; i >= 0; i--)
                        {
                            if (player.triggers[i] is TriggerWorkbench)
                            {
                                player.triggers[i].OnEntityLeave(player);
                                player.triggers.RemoveAt(i);
                            }
                        }
                    }

                    //Rest Workbench Level
                    player.cachedCraftLevel = 0f;
                    player.SetPlayerFlag(BasePlayer.PlayerFlags.Workbench1, false);
                    player.SetPlayerFlag(BasePlayer.PlayerFlags.Workbench2, false);
                    player.SetPlayerFlag(BasePlayer.PlayerFlags.Workbench3, false);
                    player.nextCheckTime = Time.realtimeSinceStartup;
                }

                if (col != null)
                    Destroy(col);
                if (child != null)
                    Destroy(child);

                GameObject.Destroy(this);
            }

        }

        #endregion Monobehaviour

        #region Helpers

        private void AddLocalizedCommand(string command)
        {
            foreach (string language in lang.GetLanguages(this))
            {
                Dictionary<string, string> messages = lang.GetMessages(language, this);
                foreach (KeyValuePair<string, string> message in messages)
                {
                    if (!message.Key.Equals(command)) continue;

                    if (string.IsNullOrEmpty(message.Value)) continue;

                    AddCovalenceCommand(message.Value, command);
                }
            }
        }

        private bool HasPerm(string id, string perm) => permission.UserHasPermission(id, perm);

        private string GetLang(string langKey, string playerId = null, params object[] args) => string.Format(lang.GetMessage(langKey, this, playerId), args);

        private void Message(IPlayer player, string langKey, params object[] args)
        {
            if (player.IsConnected) player.Message(GetLang(langKey, player.Id, args));
        }

        private bool IsInvisible(BasePlayer player) => player?._limitedNetworking ?? false;

        private void UnSubscribeFromHooks()
        {
            foreach (var hook in _registeredhooks)
                Unsubscribe(hook);
        }

        private void SubscribeToHooks()
        {
            foreach (var hook in _registeredhooks)
                Subscribe(hook);
        }

        private static void SendEffect(BasePlayer player, string sound) => EffectNetwork.Send(new Effect(sound, player, 0, Vector3.zero, Vector3.forward), player.net.connection);


        #endregion Helpers

        #region Public Helpers
        public void _Disappear(BasePlayer basePlayer) => Disappear(basePlayer);
        public void _Reappear(BasePlayer basePlayer) => Reappear(basePlayer);
        public bool _IsInvisible(BasePlayer basePlayer) => IsInvisible(basePlayer);
        #endregion
    }
}

// --- End of file: Vanish.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/DontTargetMe.cs ---
// --- Original Local Path: BeeRust/DontTargetMe.cs ---

﻿using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Don't Target Me", "Quantum/Arainrr", "1.1.4")]
    [Description("Makes turrets, player npcs and normal npcs ignore you.")]
    public class DontTargetMe : RustPlugin
    {
        #region Fields

        private const string PERMISSION_ALL = "donttargetme.all";
        private const string PERMISSION_NPC = "donttargetme.npc";
        private const string PERMISSION_APC = "donttargetme.apc";
        private const string PERMISSION_SAM = "donttargetme.sam";
        private const string PERMISSION_HELI = "donttargetme.heli";
        private const string PERMISSION_TURRETS = "donttargetme.turrets";
        private const string PERMISSION_HBHF = "donttargetme.hbhf";

        //Reduce boxing
        private static object True, False;

        private readonly Dictionary<ulong, TargetFlags> playerFlags = new Dictionary<ulong, TargetFlags>();

        [Flags]
        private enum TargetFlags
        {
            None = 0,
            Npc = 1,
            Sam = 1 << 1,
            Turret = 1 << 2,
            Bradley = 1 << 3,
            Helicopter = 1 << 4,
            HBHF = 1 << 5,
        }

        #endregion Fields

        #region Oxide Hooks

        private void Init()
        {
            True = true;
            False = false;
            permission.RegisterPermission(PERMISSION_ALL, this);
            permission.RegisterPermission(PERMISSION_NPC, this);
            permission.RegisterPermission(PERMISSION_APC, this);
            permission.RegisterPermission(PERMISSION_SAM, this);
            permission.RegisterPermission(PERMISSION_HELI, this);
            permission.RegisterPermission(PERMISSION_TURRETS, this);
            permission.RegisterPermission(PERMISSION_HBHF, this);

            cmd.AddChatCommand(configData.chatS.command, this, nameof(CmdToggle));
        }

        private void OnServerInitialized()
        {
            if (!configData.disableWhenDis)
            {
                Unsubscribe(nameof(OnPlayerDisconnected));
            }
            if (!configData.enableWhenCon)
            {
                Unsubscribe(nameof(OnPlayerConnected));
            }
            foreach (var player in BasePlayer.activePlayerList)
            {
                PlayerFlagsInit(player);
            }
            CheckHooks();
        }

        private void Unload()
        {
            True = False = null;
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player == null || !player.userID.IsSteamId()) return;
            if (PlayerFlagsInit(player))
            {
                CheckHooks();
            }
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (player == null || !player.userID.IsSteamId()) return;
            if (playerFlags.Remove(player.userID))
            {
                CheckHooks();
            }
        }

        private object CanBeTargeted(BasePlayer player, MonoBehaviour behaviour) => HasTargetFlags(player, TargetFlags.Turret) ? False : null;

        private object OnNpcTarget(BaseEntity npc, BasePlayer player) => HasTargetFlags(player, TargetFlags.Npc) ? True : null;

        private object CanBradleyApcTarget(BradleyAPC apc, BasePlayer player) => HasTargetFlags(player, TargetFlags.Bradley) ? False : null;

        private object CanHelicopterTarget(PatrolHelicopterAI heli, BasePlayer player) => HasTargetFlags(player, TargetFlags.Helicopter) ? False : null;

        private object CanHelicopterStrafeTarget(PatrolHelicopterAI heli, BasePlayer player) => HasTargetFlags(player, TargetFlags.Helicopter) ? False : null;

        private object OnSamSiteTarget(SamSite samSite, BaseCombatEntity baseCombatEntity) => AnyHasTargetFlags(baseCombatEntity, TargetFlags.Sam) ? False : null;

        private object OnSensorDetect(HBHFSensor hbhf, BasePlayer player) => HasTargetFlags(player, TargetFlags.HBHF) ? False : null;

        #endregion Oxide Hooks

        #region Methods

        private bool AnyHasTargetFlags(BaseCombatEntity baseCombatEntity, TargetFlags flag)
        {
            var baseVehicle = baseCombatEntity as BaseVehicle;
            if (baseVehicle != null)
            {
                var mountedPlayers = GetMountedPlayers(baseVehicle);
                foreach (var mountedPlayer in mountedPlayers)
                {
                    if (HasTargetFlags(mountedPlayer, flag))
                    {
                        return true;
                    }
                }
                return false;
            }
            var children = baseCombatEntity.GetComponentsInChildren<BasePlayer>();
            if (children != null && children.Length > 0)
            {
                foreach (var child in children)
                {
                    if (HasTargetFlags(child, flag))
                    {
                        return true;
                    }
                }
            }
            return false;
        }

        private static IEnumerable<BasePlayer> GetMountedPlayers(BaseVehicle baseVehicle)
        {
            if (!baseVehicle.HasMountPoints())
            {
                var mountedPlayer = baseVehicle.GetMounted();
                if (mountedPlayer != null)
                {
                    yield return mountedPlayer;
                }
            }

            foreach (var mountPointInfo in baseVehicle.mountPoints)
            {
                if (mountPointInfo.mountable != null)
                {
                    var mountedPlayer = mountPointInfo.mountable.GetMounted();
                    if (mountedPlayer != null)
                    {
                        yield return mountedPlayer;
                    }
                }
            }
        }

        private bool HasTargetFlags(BasePlayer player, TargetFlags flag)
        {
            if (player == null || !player.userID.IsSteamId()) return false;
            TargetFlags flags;
            if (playerFlags.TryGetValue(player.userID, out flags))
            {
                return flags.HasFlag(flag);
            }
            return false;
        }

        private bool PlayerFlagsInit(BasePlayer player)
        {
            playerFlags.Remove(player.userID);
            TargetFlags flags = TargetFlags.None;
            if (permission.UserHasPermission(player.UserIDString, PERMISSION_ALL))
            {
                foreach (TargetFlags flag in Enum.GetValues(typeof(TargetFlags)))
                    flags |= flag;
            }
            else
            {
                if (permission.UserHasPermission(player.UserIDString, PERMISSION_TURRETS))
                    flags |= TargetFlags.Turret;
                if (permission.UserHasPermission(player.UserIDString, PERMISSION_APC))
                    flags |= TargetFlags.Bradley;
                if (permission.UserHasPermission(player.UserIDString, PERMISSION_NPC))
                    flags |= TargetFlags.Npc;
                if (permission.UserHasPermission(player.UserIDString, PERMISSION_SAM))
                    flags |= TargetFlags.Sam;
                if (permission.UserHasPermission(player.UserIDString, PERMISSION_HELI))
                    flags |= TargetFlags.Helicopter;
                if (permission.UserHasPermission(player.UserIDString, PERMISSION_HBHF))
                    flags |= TargetFlags.HBHF;
            }
            if (flags != TargetFlags.None)
            {
                playerFlags.Add(player.userID, flags);
                return true;
            }
            return false;
        }

        private void CheckHooks()
        {
            if (playerFlags.Count <= 0)
            {
                Unsubscribe(nameof(OnNpcTarget));
                Unsubscribe(nameof(CanBeTargeted));
                Unsubscribe(nameof(OnSamSiteTarget));
                Unsubscribe(nameof(CanBradleyApcTarget));
                Unsubscribe(nameof(CanHelicopterTarget));
                Unsubscribe(nameof(CanHelicopterStrafeTarget));
                Unsubscribe(nameof(OnSensorDetect));
                return;
            }

            bool turret = false, npc = false, apc = false, heli = false, sam = false, hbhf = false;
            foreach (var flags in playerFlags.Values)
            {
                if (flags.HasFlag(TargetFlags.Turret)) turret = true;
                if (flags.HasFlag(TargetFlags.Npc)) npc = true;
                if (flags.HasFlag(TargetFlags.Bradley)) apc = true;
                if (flags.HasFlag(TargetFlags.Helicopter)) heli = true;
                if (flags.HasFlag(TargetFlags.Sam)) sam = true;
                if (flags.HasFlag(TargetFlags.HBHF)) hbhf = true;
            }

            if (!turret) Unsubscribe(nameof(CanBeTargeted));
            else Subscribe(nameof(CanBeTargeted));

            if (!npc) Unsubscribe(nameof(OnNpcTarget));
            else Subscribe(nameof(OnNpcTarget));

            if (!apc) Unsubscribe(nameof(CanBradleyApcTarget));
            else Subscribe(nameof(CanBradleyApcTarget));

            if (!sam) Unsubscribe(nameof(OnSamSiteTarget));
            else Subscribe(nameof(OnSamSiteTarget));

            if (!heli)
            {
                Unsubscribe(nameof(CanHelicopterTarget));
                Unsubscribe(nameof(CanHelicopterStrafeTarget));
            }
            else
            {
                Subscribe(nameof(CanHelicopterTarget));
                Subscribe(nameof(CanHelicopterStrafeTarget));
            }

            if (!hbhf)
            {
                Unsubscribe(nameof(OnSensorDetect));
            }
            else
            {
                Subscribe(nameof(OnSensorDetect));
            }
        }

        #endregion Methods

        #region Commands

        private void CmdToggle(BasePlayer player, string command, string[] args)
        {
            if (player == null) return;
            if (playerFlags.Remove(player.userID))
            {
                Print(player, Lang("Toggle", player.UserIDString, Lang("Disabled", player.UserIDString)));
            }
            else
            {
                if (PlayerFlagsInit(player))
                {
                    Print(player, Lang("Toggle", player.UserIDString, Lang("Enabled", player.UserIDString)));
                }
                else
                {
                    Print(player, Lang("NotAllowed", player.UserIDString));
                    return;
                }
            }
            CheckHooks();
        }

        #endregion Commands

        #region ConfigurationFile

        private ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Disable when player disconnected")]
            public bool disableWhenDis = true;

            [JsonProperty(PropertyName = "Enable when player connected")]
            public bool enableWhenCon = false;

            [JsonProperty(PropertyName = "Chat Settings")]
            public ChatSettings chatS = new ChatSettings();

            public class ChatSettings
            {
                [JsonProperty(PropertyName = "Chat Command")]
                public string command = "dtm";

                [JsonProperty(PropertyName = "Chat Prefix")]
                public string prefix = "<color=#00FFFF>[DontTargetMe]</color>: ";

                [JsonProperty(PropertyName = "Chat SteamID Icon")]
                public ulong steamIDIcon = 0;
            }

            [JsonProperty(PropertyName = "Version")]
            public VersionNumber version;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                configData = Config.ReadObject<ConfigData>();
                if (configData == null)
                {
                    LoadDefaultConfig();
                }
                else
                {
                    UpdateConfigValues();
                }
            }
            catch (Exception ex)
            {
                PrintError($"The configuration file is corrupted. \n{ex}");
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            configData = new ConfigData();
            configData.version = Version;
        }

        protected override void SaveConfig() => Config.WriteObject(configData);

        private void UpdateConfigValues()
        {
            if (configData.version < Version)
            {
                if (configData.version <= default(VersionNumber))
                {
                    string prefix, prefixColor;
                    if (GetConfigValue(out prefix, "Chat Settings", "Chat Prefix") && GetConfigValue(out prefixColor, "Chat Settings", "Chat Prefix Color"))
                    {
                        configData.chatS.prefix = $"<color={prefixColor}>{prefix}</color>: ";
                    }
                }
                configData.version = Version;
            }
        }

        private bool GetConfigValue<T>(out T value, params string[] path)
        {
            var configValue = Config.Get(path);
            if (configValue == null)
            {
                value = default(T);
                return false;
            }
            value = Config.ConvertValue<T>(configValue);
            return true;
        }

        #endregion ConfigurationFile

        #region LanguageFile

        private void Print(BasePlayer player, string message) => Player.Message(player, message, configData.chatS.prefix, configData.chatS.steamIDIcon);

        private string Lang(string key, string id = null, params object[] args)
        {
            try
            {
                return string.Format(lang.GetMessage(key, this, id), args);
            }
            catch (Exception)
            {
                PrintError($"Error in the language formatting of '{key}'. (userid: {id}. args: {string.Join(" ,", args)})");
                throw;
            }
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NotAllowed"] = "You do not have permission to use this command",
                ["Toggle"] = "Don't Target Me is {0}",
                ["Enabled"] = "<color=#8ee700>Enabled</color>",
                ["Disabled"] = "<color=#ce422b>Disabled</color>",
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NotAllowed"] = "您没有使用该命令的权限",
                ["Toggle"] = "不要瞄准我 {0}",
                ["Enabled"] = "<color=#8ee700>已启用</color>",
                ["Disabled"] = "<color=#ce422b>已禁用</color>",
            }, this, "zh-CN");
        }

        #endregion LanguageFile
    }
}

// --- End of file: DontTargetMe.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/AdminLogger.cs ---
// --- Original Local Path: BeeRust/AdminLogger.cs ---

﻿using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Facepunch.Extend;
using CompanionServer.Handlers;
using System.Collections;
using UnityEngine.Networking;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Admin Logger", "AK", "2.4.1")]
    [Description("Logs admin commands usage in a file and console.")]
    internal class AdminLogger : CovalencePlugin
    {
        [PluginReference] private Plugin Vanish, AdminRadar, NightVision, ConvertStatus, InventoryViewer, PlayerAdministration, Freeze, Backpacks;

        #region Vars

        private Dictionary<ulong, bool> noclipState = new Dictionary<ulong, bool>();
        private Dictionary<ulong, bool> godmodeState = new Dictionary<ulong, bool>();
        private Dictionary<ulong, bool> spectateState = new Dictionary<ulong, bool>();
        private HashSet<BasePlayer> adminList = new HashSet<BasePlayer>();

        #endregion Vars

        #region Config       

        private ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Log to console (true/false)")]
            public bool LogToConsole { get; set; }

            [JsonProperty(PropertyName = "Update frequency (s)")]
            public float UpdateFreq { get; set; }

            [JsonProperty(PropertyName = "Log filename")]
            public string LogFileName { get; set; }

            [JsonProperty(PropertyName = "Enable Discord Messages (true/false)")]
            public bool DiscordLog { get; set; }

            [JsonProperty(PropertyName = "Discord Messages webhook")]
            public string DiscordWebhook { get; set; }

            [JsonProperty(PropertyName = "Exclude List")]
            public List<string> ExcludeList { get; set; }

            [JsonProperty(PropertyName = "Default admin commands")]
            public DefaultCommandsOptions DefaultCommands { get; set; }

            [JsonProperty(PropertyName = "Admin plugins")]
            public PluginsCommandsOptions PluginsCommands { get; set; }

            public class DefaultCommandsOptions
            {
                [JsonProperty(PropertyName = "Admin connections logging (true/false)")]
                public bool ConnectionLog { get; set; }

                [JsonProperty(PropertyName = "Noclip logging (true/false)")]
                public bool NoclipLog { get; set; }

                [JsonProperty(PropertyName = "GodMode logging (true/false)")]
                public bool GodmodeLog { get; set; }

                [JsonProperty(PropertyName = "Spectate logging (true/false)")]
                public bool SpectateLog { get; set; }

                [JsonProperty(PropertyName = "Kill player logging (true/false)")]
                public bool KillPlayerLog { get; set; }

                [JsonProperty(PropertyName = "Admin events logging (true/false)")]
                public bool EventsAllLog { get; set; }

                [JsonProperty(PropertyName = "Admin event commands")]
                public EventsLoggingOptions EventsLogging { get; set; }

                [JsonProperty(PropertyName = "Kick logging (true/false)")]
                public bool KickAllLog { get; set; }

                [JsonProperty(PropertyName = "Kick commands")]
                public KickLoggingOptions KickLogging { get; set; }

                [JsonProperty(PropertyName = "Ban logging (true/false)")]
                public bool BanAllLog { get; set; }

                [JsonProperty(PropertyName = "Ban commands")]
                public BanLoggingOptions BanLogging { get; set; }

                [JsonProperty(PropertyName = "Mute logging (true/false)")]
                public bool MuteAllLog { get; set; }

                [JsonProperty(PropertyName = "Mute commands")]
                public MuteLoggingOptions MuteLogging { get; set; }

                [JsonProperty(PropertyName = "Entity logging (true/false)")]
                public bool EntAllLog { get; set; }

                [JsonProperty(PropertyName = "Entity commands")]
                public EntityLoggingOptions EntityLogging { get; set; }

                [JsonProperty(PropertyName = "Teleport logging (true/false)")]
                public bool TeleportAllLog { get; set; }

                [JsonProperty(PropertyName = "Teleport commands")]
                public TeleportLoggingOptions TeleportLogging { get; set; }

                [JsonProperty(PropertyName = "Give items logging (true/false)")]
                public bool GiveAllLog { get; set; }

                [JsonProperty(PropertyName = "Give commands")]
                public GiveLoggingOptions GiveLogging { get; set; }

                [JsonProperty(PropertyName = "Spawn logging (true/false)")]
                public bool SpawnAllLog { get; set; }

                [JsonProperty(PropertyName = "Spawn commands")]
                public SpawnLoggingOptions SpawnLogging { get; set; }
            }

            public class PluginsCommandsOptions
            {
                [JsonProperty(PropertyName = "Vanish logging (true/false)")]
                public bool VanishLog { get; set; }

                [JsonProperty(PropertyName = "Admin Radar logging (true/false)")]
                public bool RadarLog { get; set; }

                [JsonProperty(PropertyName = "Night Vision logging (true/false)")]
                public bool NightLog { get; set; }

                [JsonProperty(PropertyName = "Convert Status logging (true/false)")]
                public bool ConvertLog { get; set; }

                [JsonProperty(PropertyName = "Inventory Viewer logging (true/false)")]
                public bool InventoryViewerLog { get; set; }

                [JsonProperty(PropertyName = "Backpacks logging (true/false)")]
                public bool BackpacksLog { get; set; }

                [JsonProperty(PropertyName = "Freeze logging (true/false)")]
                public bool FreezeAllLog { get; set; }

                [JsonProperty(PropertyName = "Freeze commands")]
                public FreezeLoggingOptions FreezeLogging { get; set; }

                [JsonProperty(PropertyName = "Player Administration logging (true/false)")]
                public bool PlayerAdministrationAllLog { get; set; }

                [JsonProperty(PropertyName = "Player Administration commands")]
                public PlayerAdministrationLoggingOptions PlayerAdministrationLogging { get; set; }
            }

            public class EventsLoggingOptions
            {
                [JsonProperty(PropertyName = "[Attack Heli] heli.call")]
                public bool HeliCallLog { get; set; }

                [JsonProperty(PropertyName = "[Attack Heli] heli.calltome")]
                public bool HeliCallToMeLog { get; set; }

                [JsonProperty(PropertyName = "[Attack Heli] drop")]
                public bool HeliDropLog { get; set; }

                [JsonProperty(PropertyName = "[Airdrop] supply.call")]
                public bool AirdropRandomLog { get; set; }

                [JsonProperty(PropertyName = "[Airdrop] supply.drop")]
                public bool AirdropPosLog { get; set; }
            }

            public class KickLoggingOptions
            {
                [JsonProperty(PropertyName = "kick")]
                public bool KickLog { get; set; }

                [JsonProperty(PropertyName = "kickall")]
                public bool KickEveryoneLog { get; set; }
            }

            public class BanLoggingOptions
            {
                [JsonProperty(PropertyName = "ban")]
                public bool BanLog { get; set; }

                [JsonProperty(PropertyName = "unban")]
                public bool UnbanLog { get; set; }
            }

            public class MuteLoggingOptions
            {
                [JsonProperty(PropertyName = "mute")]
                public bool MuteLog { get; set; }

                [JsonProperty(PropertyName = "unmute")]
                public bool UnmuteLog { get; set; }
            }

            public class EntityLoggingOptions
            {
                [JsonProperty(PropertyName = "ent kill")]
                public bool EntKillLog { get; set; }

                [JsonProperty(PropertyName = "ent who")]
                public bool EntWhoLog { get; set; }

                [JsonProperty(PropertyName = "ent lock")]
                public bool EntLockLog { get; set; }

                [JsonProperty(PropertyName = "ent unlock")]
                public bool EntUnlockLog { get; set; }

                [JsonProperty(PropertyName = "ent auth")]
                public bool EntAuthLog { get; set; }
            }

            public class TeleportLoggingOptions
            {
                [JsonProperty(PropertyName = "teleport")]
                public bool TeleportLog { get; set; }

                [JsonProperty(PropertyName = "teleportpos")]
                public bool TeleportPosLog { get; set; }

                [JsonProperty(PropertyName = "teleport2me")]
                public bool TeleportToMeLog { get; set; }
            }

            public class GiveLoggingOptions
            {
                [JsonProperty(PropertyName = "give")]
                public bool GiveLog { get; set; }

                [JsonProperty(PropertyName = "giveid")]
                public bool GiveIdLog { get; set; }

                [JsonProperty(PropertyName = "givearm")]
                public bool GiveArmLog { get; set; }

                [JsonProperty(PropertyName = "giveto")]
                public bool GiveToLog { get; set; }

                [JsonProperty(PropertyName = "giveall")]
                public bool GiveAllLog { get; set; }
            }

            public class SpawnLoggingOptions
            {
                [JsonProperty(PropertyName = "spawn")]
                public bool SpawnLog { get; set; }

                [JsonProperty(PropertyName = "spawnat")]
                public bool SpawnAtLog { get; set; }

                [JsonProperty(PropertyName = "spawnhere")]
                public bool SpawnHereLog { get; set; }

                [JsonProperty(PropertyName = "spawnitem")]
                public bool SpawnItemLog { get; set; }
            }

            public class FreezeLoggingOptions
            {
                [JsonProperty(PropertyName = "freeze")]
                public bool FreezeLog { get; set; }

                [JsonProperty(PropertyName = "unfreeze")]
                public bool UnfreezeLog { get; set; }

                [JsonProperty(PropertyName = "freezeall")]
                public bool AllFreezeLog { get; set; }

                [JsonProperty(PropertyName = "unfreezeall")]
                public bool AllUnfreezeLog { get; set; }
            }

            public class PlayerAdministrationLoggingOptions
            {

                [JsonProperty(PropertyName = "OpenPadminCmd")]
                public bool OpenPadminCmdLog { get; set; }

                [JsonProperty(PropertyName = "ClosePadminCmd")]
                public bool ClosePadminCmdLog { get; set; }

                [JsonProperty(PropertyName = "BanUserCmd")]
                public bool BanUserCmdLog { get; set; }

                [JsonProperty(PropertyName = "UnbanUserCmd")]
                public bool UnbanUserCmdLog { get; set; }

                [JsonProperty(PropertyName = "KickUserCmd")]
                public bool KickUserCmdLog { get; set; }

                [JsonProperty(PropertyName = "MuteUserCmd")]
                public bool MuteUserCmdLog { get; set; }

                [JsonProperty(PropertyName = "UnmuteUserCmd")]
                public bool UnmuteUserCmdLog { get; set; }

                [JsonProperty(PropertyName = "FreezeCmd")]
                public bool FreezeCmdLog { get; set; }

                [JsonProperty(PropertyName = "UnreezeCmd")]
                public bool UnreezeCmdLog { get; set; }

                [JsonProperty(PropertyName = "BackpackViewCmd")]
                public bool BackpackViewCmdLog { get; set; }

                [JsonProperty(PropertyName = "InventoryViewCmd")]
                public bool InventoryViewCmdLog { get; set; }

                [JsonProperty(PropertyName = "ClearUserInventoryCmd")]
                public bool ClearUserInventoryCmdLog { get; set; }

                [JsonProperty(PropertyName = "ResetUserBPCmd")]
                public bool ResetUserBPCmdLog { get; set; }

                [JsonProperty(PropertyName = "ResetUserMetabolismCmd")]
                public bool ResetUserMetabolismCmdLog { get; set; }

                [JsonProperty(PropertyName = "RecoverUserMetabolismCmd")]
                public bool RecoverUserMetabolismLog { get; set; }

                [JsonProperty(PropertyName = "TeleportToUserCmd")]
                public bool TeleportToUserCmdLog { get; set; }

                [JsonProperty(PropertyName = "TeleportUserCmd")]
                public bool TeleportUserCmdLog { get; set; }

                [JsonProperty(PropertyName = "SpectateUserCmd")]
                public bool SpectateUserCmdLog { get; set; }

                [JsonProperty(PropertyName = "PermsCmd")]
                public bool PermsCmdLog { get; set; }

                [JsonProperty(PropertyName = "HurtUserCmd")]
                public bool HurtUserCmdLog { get; set; }

                [JsonProperty(PropertyName = "KillUserCmd")]
                public bool KillUserCmdLog { get; set; }

                [JsonProperty(PropertyName = "HealUserCmd")]
                public bool HealUserCmdLog { get; set; }

            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                configData = Config.ReadObject<ConfigData>();
                if (configData == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                LogToConsole = true,
                UpdateFreq = 5f,
                LogFileName = "adminlog",
                DiscordLog = true,
                DiscordWebhook = "",
                ExcludeList = new List<string>(){
                    "76561197960279927",
                    "76561197960287930"
                },

                DefaultCommands = new ConfigData.DefaultCommandsOptions
                {
                    ConnectionLog = true,
                    NoclipLog = true,
                    GodmodeLog = true,
                    SpectateLog = true,
                    KillPlayerLog = true,   
                    
                    EventsAllLog = true,
                    EventsLogging = new ConfigData.EventsLoggingOptions
                    {
                        HeliCallLog = true,
                        HeliCallToMeLog = true,
                        HeliDropLog = true,
                        AirdropRandomLog = true,
                        AirdropPosLog = true
                    },

                    KickAllLog = true,
                    KickLogging = new ConfigData.KickLoggingOptions
                    {
                        KickLog = true,
                        KickEveryoneLog = true
                    },

                    BanAllLog = true,
                    BanLogging = new ConfigData.BanLoggingOptions
                    {
                        BanLog = true,                       
                        UnbanLog = true
                    },

                    MuteAllLog = true,
                    MuteLogging = new ConfigData.MuteLoggingOptions
                    {
                        MuteLog = true,
                        UnmuteLog = true
                    },

                    EntAllLog = true,
                    EntityLogging = new ConfigData.EntityLoggingOptions
                    {
                        EntKillLog = true,
                        EntWhoLog = true,
                        EntLockLog = true,
                        EntUnlockLog = true,
                        EntAuthLog = true
                    },

                    TeleportAllLog = true,
                    TeleportLogging = new ConfigData.TeleportLoggingOptions
                    {
                        TeleportLog = true,
                        TeleportPosLog = true,
                        TeleportToMeLog = true

                    },

                    GiveAllLog = true,
                    GiveLogging = new ConfigData.GiveLoggingOptions
                    {
                        GiveLog = true,
                        GiveIdLog = true,
                        GiveArmLog = true,
                        GiveToLog = true,
                        GiveAllLog = true
                    },

                    SpawnAllLog = true,
                    SpawnLogging = new ConfigData.SpawnLoggingOptions
                    {
                        SpawnLog = true,
                        SpawnAtLog = true,
                        SpawnHereLog = true,
                        SpawnItemLog = true
                    }
                },

                PluginsCommands = new ConfigData.PluginsCommandsOptions
                {
                    VanishLog = true,
                    RadarLog = true,
                    NightLog = true,
                    ConvertLog = true,
                    InventoryViewerLog = true,
                    BackpacksLog = true,

                    FreezeAllLog = true,
                    FreezeLogging = new ConfigData.FreezeLoggingOptions
                    {
                        FreezeLog = true,
                        UnfreezeLog = true,
                        AllFreezeLog = true,
                        AllUnfreezeLog = true                       
                    },

                    PlayerAdministrationAllLog = true,
                    PlayerAdministrationLogging = new ConfigData.PlayerAdministrationLoggingOptions
                    {
                        OpenPadminCmdLog = true,
                        ClosePadminCmdLog = true,
                        BanUserCmdLog = true,
                        UnbanUserCmdLog = true,
                        KickUserCmdLog = true,
                        MuteUserCmdLog = true,
                        UnmuteUserCmdLog = true,
                        FreezeCmdLog = true,
                        UnreezeCmdLog = true,
                        BackpackViewCmdLog = true,
                        InventoryViewCmdLog = true,
                        ClearUserInventoryCmdLog = true,
                        ResetUserBPCmdLog = true,
                        ResetUserMetabolismCmdLog = true,
                        RecoverUserMetabolismLog = true,
                        TeleportToUserCmdLog = true,
                        TeleportUserCmdLog = true,
                        SpectateUserCmdLog = true,
                        PermsCmdLog = true,
                        HurtUserCmdLog = true,
                        KillUserCmdLog = true,
                        HealUserCmdLog = true
                    }
                }           
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        #endregion Config

        #region Localization

        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["AdminConnected"] = "{0} [{1}] connected.",
                ["AdminDisconnected"] = "{0} [{1}] disconnected.",
                ["NoclipEnabled"] = "{0} [{1}] enabled Noclip.",
                ["NoclipDisabled"] = "{0} [{1}] disabled Noclip.",
                ["GodmodeEnabled"] = "{0} [{1}] enabled Godmode.",
                ["GodmodeDisabled"] = "{0} [{1}] disabled Godmode.",
                ["SpectateEnabled"] = "{0} [{1}] enabled Spectate mode.",
                ["SpectateDisabled"] = "{0} [{1}] disabled Spectate mode.",
                ["SpectatePlayer"] = "{0} [{1}] started spectating player {2} [{3}].",
                ["KillPlayer"] = "{0} [{1}] killed {2} [{3}].",
                ["KickPlayer"] = "{0} [{1}] kicked {2} [{3}]. Reason: No reason.",
                ["KickPlayerReason"] = "{0} [{1}] kicked {2} [{3}]. Reason: {4}.",
                ["KickAllPlayers"] = "{0} [{1}] kicked all players.",
                ["BanPlayer"] = "{0} [{1}] banned {2} [{3}]. Reason: No reason.",
                ["BanPlayerReason"] = "{0} [{1}] banned {2} [{3}]. Reason: {4}.",
                ["UnbanPlayer"] = "{0} [{1}] unbanned {2} [{3}].",
                ["MutePlayer"] = "{0} [{1}] muted {2} [{3}].",
                ["UnmutePlayer"] = "{0} [{1}] unmuted {2} [{3}].",
                ["VanishEnabled"] = "{0} [{1}] enabled Vanish.",
                ["VanishDisabled"] = "{0} [{1}] disabled Vanish.",
                ["RadarEnabled"] = "{0} [{1}] enabled AdminRadar.",
                ["RadarDisabled"] = "{0} [{1}] disabled AdminRadar.",
                ["NightVisionEnabled"] = "{0} [{1}] enabled NightVision.",
                ["NightVisionDisabled"] = "{0} [{1}] disabled NightVision.",
                ["ConvertStatusEnabled"] = "{0} [{1}] converted into admin status.",
                ["ConvertStatusDisabled"] = "{0} [{1}] converted out of admin status.",
                ["InventoryView"] = "{0} [{1}] used Inventory Viewer on {2} [{3}].",
                ["TeleportSelfToPlayer"] = "{0} [{1}] teleported to {2} [{3}].",
                ["TeleportPlayerToPlayer"] = "{0} [{1}] teleported {2} [{3}] to {4} [{5}].",
                ["TeleportToSelf"] = "{0} [{1}] teleported {2} [{3}] to self.",
                ["TeleportPosition"] = "{0} [{1}] teleported to coordinates {2}.",
                ["GiveSelf"] = "{0} [{1}] gave themselves {2} x {3}.",
                ["GiveSelfArm"] = "{0} [{1}] added 1 x {2} to their belt.",
                ["GiveTo"] = "{0} [{1}] gave {2} [{3}] {4} x {5}.",
                ["GiveAll"] = "{0} [{1}] gave everyone {2} x {3}.",
                ["EntKillPrefab"] = "{0} [{1}] used *kill* on ent: {2} at position {3}.",
                ["EntKillBaseEntity"] = "{0} [{1}] used *kill* on {2} owned by {3} [{4}] at position {5}.",
                ["EntWhoBaseEntity"] = "{0} [{1}] used *who* on {2} owned by {3} [{4}] at position {5}.",
                ["EntLockBaseEntity"] = "{0} [{1}] used *lock* on {2} owned by {3} [{4}] at position {5}.",
                ["EntUnlockBaseEntity"] = "{0} [{1}] used *unlock* on {2} owned by {3} [{4}] at position {5}.",
                ["EntAuthBaseEntity"] = "{0} [{1}] used *auth* on {2} owned by {3} [{4}] at position {5}.",
                ["Spawn"] = "{0} [{1}] spawned {2} at {3}.",
                ["HeliCall"] = "{0} [{1}] called in Attack Helicopter.",
                ["HeliCallToMe"] = "{0} [{1}] called in Attack Helicopter to themselves at position {2}.",
                ["HeliCallDrop"] = "{0} [{1}] spawned Attack Helicopter at their position {2}.",
                ["AirdropCall"] = "{0} [{1}] called in a Supply Drop.",
                ["AirdropCallPos"] = "{0} [{1}] called in a Supply Drop to position (0, 0, 0).",
                ["PadminOpen"] = "{0} [{1}] opened Padmin Menu.",
                ["PadminClose"] = "{0} [{1}] closed Padmin Menu.",
                ["PadminBan"] = "{0} [{1}] banned {2} [{3}] using Padmin. Reason: Administrative decision.",
                ["PadminUnban"] = "{0} [{1}] unbanned {2} [{3}] using Padmin.",
                ["PadminKick"] = "{0} [{1}] kicked {2} [{3}] using Padmin. Reason: Administrative decision.",
                ["PadminMute"] = "{0} [{1}] muted {2} [{3}] using Padmin.",
                ["PadminUnmute"] = "{0} [{1}] unmuted {2} [{3}] using Padmin.",
                ["PadminFreeze"] = "{0} [{1}] Froze player {2} [{3}] using Padmin.",
                ["PadminUnfreeze"] = "{0} [{1}] Unfroze player {2} [{3}] using Padmin.",
                ["PadminBackpackView"] = "{0} [{1}] viewed Backpack of player {2} [{3}] using Padmin.",
                ["PadminInventoryView"] = "{0} [{1}] viewed Inventory of player {2} [{3}] using Padmin.",
                ["PadminClearInventory"] = "{0} [{1}] cleared the inventory of player {2} [{3}] using Padmin.",
                ["PadminResetBP"] = "{0} [{1}] reset the blueprints of player {2} [{3}] using Padmin.",
                ["PadminResetMetabolism"] = "{0} [{1}] reset the metabolism of player {2} [{3}] using Padmin.",
                ["PadminRecoverMetabolism"] = "{0} [{1}] recovered the metabolism of player {2} [{3}] using Padmin.",
                ["PadminTeleportToPlayer"] = "{0} [{1}] teleported to {2} [{3}] using Padmin.",
                ["PadminTeleportPlayer"] = "{0} [{1}] teleported {2} [{3}] to themselves using Padmin.",
                ["PadminSpectate"] = "{0} [{1}] started spectating player {2} [{3}] using Padmin.",
                ["PadminPerms"] = "{0} [{1}] opened the permissions manager for player {2} [{3}] using Padmin.",
                ["PadminHurt"] = "{0} [{1}] hurt player {2} [{3}] for {4} points using Padmin.",
                ["PadminKill"] = "{0} [{1}] killed player {2} [{3}] using Padmin.",
                ["PadminHeal"] = "{0} [{1}] healed player {2} [{3}] for {4} points using Padmin.",
                ["BackpacksView"] = "{0} [{1}] viewed Backpack of player {2} [{3}].",
                ["FreezePlayer"] = "{0} [{1}] Froze player {2} [{3}].",
                ["UnfreezePlayer"] = "{0} [{1}] Unfroze player {2} [{3}].",
                ["FreezeAllPlayers"] = "{0} [{1}] Froze all players.",
                ["UnfreezeAllPlayers"] = "{0} [{1}] Unfroze all players.",

            }, this);
        }

        #endregion Localization

        #region Oxide Hooks

        void OnServerInitialized()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                OnPlayerConnected(player);
            }
            InvokeHandler.Instance.InvokeRepeating(HandlePlayers, 5f, configData.UpdateFreq);
        }

        void Unload()
        {
            InvokeHandler.Instance.CancelInvoke(HandlePlayers);
        }

        void OnPlayerConnected(BasePlayer player)
        {
            if (configData.ExcludeList.Contains(player.UserIDString))
            {
                return;
            }


            if (player.IsAdmin || (configData.PluginsCommands.ConvertLog && ConvertStatus && player.IPlayer.HasPermission("convertstatus.use")))
            {
                if (configData.DefaultCommands.ConnectionLog)
                {
                    Log(configData.LogFileName, "AdminConnected", player.displayName, player.UserIDString);
                }

                adminList.Add(player);
                noclipState[player.userID] = false;
                spectateState[player.userID] = false;
                if (player.IsGod())
                {
                    godmodeState[player.userID] = true;
                }
                else
                {
                    godmodeState[player.userID] = false;
                }
            }
        }

        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (configData.ExcludeList.Contains(player.UserIDString))
            {
                return;
            }

            if (player.IsAdmin || (configData.PluginsCommands.ConvertLog && ConvertStatus && player.IPlayer.HasPermission("convertstatus.use")))
            {
                if (configData.DefaultCommands.ConnectionLog)
                {
                    Log(configData.LogFileName, "AdminDisconnected", player.displayName, player.UserIDString);
                }

                adminList.Remove(player);
            }
        }

        private void OnServerCommand(ConsoleSystem.Arg arg)
        {
            if (!arg.IsConnectionAdmin) return;
            string command = arg.cmd.Name;
            string fullCommand = arg.cmd.FullName;
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null) return;
            if (fullCommand == "chat.say") return;
            if (configData.ExcludeList.Contains(player.UserIDString))
            {
                return;
            }

            switch (command)
            {
                case "killplayer":
                    if (configData.DefaultCommands.KillPlayerLog)
                    {
                        KillPlayerLogging(arg);
                    }
                    break;
                case "kick":
                case "kickall":
                    if (configData.DefaultCommands.KickAllLog)
                    {
                        KickLogging(arg);
                    }
                    break;
                case "ban":
                case "unban":
                    if (configData.DefaultCommands.BanAllLog)
                    {
                        BanLogging(arg);
                    }
                    break;
                case "mute": 
                case "unmute":
                    if (configData.DefaultCommands.MuteAllLog)
                    {
                        MuteLogging(arg);
                    }
                    break;
                case "teleport":
                case "teleportpos":
                case "teleport2me":
                    if (configData.DefaultCommands.TeleportAllLog)
                    {
                        TeleportLogging(arg);
                    }
                    break;
                case "spectate":
                    if (configData.DefaultCommands.SpectateLog)
                    {
                        SpectateLogging(arg);
                    }
                    break;
                case "giveid":
                case "give":
                case "givearm":
                case "giveto":
                case "giveall":
                    if (configData.DefaultCommands.GiveAllLog)
                    {
                        GiveItemLogging(arg);
                    }
                    break;
                case "spawn":
                case "spawnat":
                case "spawnhere":
                case "spawnitem":
                    if (configData.DefaultCommands.SpawnAllLog)
                    {
                        SpawnLogging(arg);
                    }
                    break;
                case "entid":
                    if (configData.DefaultCommands.EntAllLog)
                    {
                        EntityLogging(arg);
                    }
                    break;
                case "vanish":
                    if (configData.PluginsCommands.VanishLog && Vanish != null && Vanish.IsLoaded && player.IPlayer.HasPermission("vanish.allow"))
                    {
                        VanishLogging(player);
                    }
                    break;
                case "freeze":
                case "unfreeze":
                case "freezeall":
                case "unfreezeall":
                    if (configData.PluginsCommands.FreezeAllLog && Freeze != null && Freeze.IsLoaded && player.IPlayer.HasPermission("freeze.use"))
                    {
                        FreezeLogging(arg);
                    }
                    break;
            }

            switch (fullCommand)
            {
                case "heli.call":
                case "heli.calltome":
                case "global.drop":
                case "drop":
                case "supply.call":
                case "supply.drop":
                    if (configData.DefaultCommands.EventsAllLog)
                    {
                        EventsLogging(arg);
                    }
                    break;
                case "playeradministration.closeui":
                case "playeradministration.kickuser":
                case "playeradministration.banuser":
                case "playeradministration.unbanuser":
                case "playeradministration.perms":
                case "playeradministration.muteuser":
                case "playeradministration.unmuteuser":
                case "playeradministration.tptouser":
                case "playeradministration.tpuser":
                case "playeradministration.viewbackpack":
                case "playeradministration.viewinventory":
                case "playeradministration.freeze":
                case "playeradministration.unfreeze":
                case "playeradministration.clearuserinventory":
                case "playeradministration.resetuserblueprints":
                case "playeradministration.resetusermetabolism":
                case "playeradministration.recoverusermetabolism":
                case "playeradministration.spectateuser":
                case "playeradministration.hurtuser":
                case "playeradministration.killuser":
                case "playeradministration.healuser":
                    if (configData.PluginsCommands.PlayerAdministrationAllLog && PlayerAdministration != null && PlayerAdministration.IsLoaded)
                    {
                        PadminLogging(arg);
                    }
                    break;
            }
        }

        void OnPlayerCommand(BasePlayer player, string command, string[] args)
        {
            if (configData.ExcludeList.Contains(player.UserIDString))
            {
                return;
            }

            switch (command)
            {
                case "vanish":
                    if (configData.PluginsCommands.VanishLog && Vanish != null && Vanish.IsLoaded && player.IPlayer.HasPermission("vanish.allow"))
                    {
                        VanishLogging(player);
                    }
                    break;
                case "radar":
                    if (configData.PluginsCommands.RadarLog && AdminRadar != null && AdminRadar.IsLoaded && player.IPlayer.HasPermission("adminradar.allowed"))
                    {
                        AdminRadarLogging(player);
                    }
                    break;
                case "nightvision":
                case "nv":
                    if (configData.PluginsCommands.NightLog && NightVision != null && NightVision.IsLoaded && player.IPlayer.HasPermission("nightvision.allowed"))
                    {
                        NightVisionLogging(player);
                    }
                    break;
                case "convert":
                    if (configData.PluginsCommands.ConvertLog && ConvertStatus != null && ConvertStatus.IsLoaded && player.IPlayer.HasPermission("convertstatus.use"))
                    {
                        ConvertStatusLogging(player);
                    }
                    break;
                case "freeze":
                case "unfreeze":
                case "freezeall":
                case "unfreezeall":
                    if (configData.PluginsCommands.FreezeAllLog && Freeze != null && Freeze.IsLoaded && player.IPlayer.HasPermission("freeze.use"))
                    {
                        FreezeLogging(player, command, args);
                    }
                    break;
                case "viewinventory":
                case "viewinv":
                    if (configData.PluginsCommands.InventoryViewerLog && InventoryViewer != null && InventoryViewer.IsLoaded && player.IPlayer.HasPermission("inventoryviewer.allowed"))
                    {
                        InventoryViewerLogging(player, args);
                    }
                    break;
                case "viewbackpack":
                    if (configData.PluginsCommands.BackpacksLog && Backpacks != null && Backpacks.IsLoaded && player.IPlayer.HasPermission("backpacks.admin"))
                    {
                        BackpacksLogging(player, args);
                    }
                    break;
                case "padmin":
                    if (configData.PluginsCommands.PlayerAdministrationAllLog && PlayerAdministration != null && PlayerAdministration.IsLoaded && player.IPlayer.HasPermission("playeradministration.access.show"))
                    {
                        PadminLogging(player);                       
                    }
                    break;
            }
        }

        void OnPlayerSpectateEnd(BasePlayer player, string spectateFilter)
        {
            if (configData.ExcludeList.Contains(player.UserIDString))
            {
                return;
            }

            if (configData.DefaultCommands.SpectateLog)
            {
                Log(configData.LogFileName, "SpectateDisabled", player.displayName, player.UserIDString);
            }
        }

        #endregion Oxide Hooks

        #region Default Commands

        #region Noclip & Godmode

        private void ClientSideCommandDetection(BasePlayer player)
        {
            if (configData.DefaultCommands.NoclipLog)
            {
                if (player.IsFlying && !noclipState[player.userID])
                {
                    Log(configData.LogFileName, "NoclipEnabled", player.displayName, player.UserIDString);
                    noclipState[player.userID] = true;
                }

                if (!player.IsFlying && noclipState[player.userID])
                {
                    Log(configData.LogFileName, "NoclipDisabled", player.displayName, player.UserIDString);
                    noclipState[player.userID] = false;
                }
            }

            if (configData.DefaultCommands.GodmodeLog)
            {
                if (player.IsGod() && godmodeState[player.userID])
                {
                    Log(configData.LogFileName, "GodmodeEnabled", player.displayName, player.UserIDString);
                    godmodeState[player.userID] = false;
                }

                if (!player.IsGod() && !godmodeState[player.userID])
                {
                    Log(configData.LogFileName, "GodmodeDisabled", player.displayName, player.UserIDString);
                    godmodeState[player.userID] = true;
                }
            }
        }

        #endregion Noclip & Godmode

        #region Events

        private void EventsLogging(ConsoleSystem.Arg arg)
        {
            string command = arg.cmd.Name;
            string fullCommand = arg.cmd.FullName;
            ulong playerUserId = arg.Connection.userid;
            var player = BasePlayer.FindByID(playerUserId);

            if (player == null)
            {
                return;
            }

            switch (fullCommand)
            {
                case "heli.call":
                    if (configData.DefaultCommands.EventsLogging.HeliCallLog)
                    {
                        Log(configData.LogFileName, "HeliCall", player.displayName, player.UserIDString);
                    }
                    break;
                case "heli.calltome":
                    if (configData.DefaultCommands.EventsLogging.HeliCallToMeLog)
                    {
                        var position = player.transform.position;
                        Log(configData.LogFileName, "HeliCallToMe", player.displayName, player.UserIDString, position);
                    }
                    break;
                case "global.drop":
                    if (configData.DefaultCommands.EventsLogging.HeliDropLog)
                    {
                        var position = player.transform.position;
                        Log(configData.LogFileName, "HeliCallDrop", player.displayName, player.UserIDString, position);
                    }
                    break;
                case "supply.call":
                    if (configData.DefaultCommands.EventsLogging.AirdropRandomLog)
                    {
                        Log(configData.LogFileName, "AirdropCall", player.displayName, player.UserIDString);
                    }
                    break;
                case "supply.drop":
                    if (configData.DefaultCommands.EventsLogging.AirdropPosLog)
                    {
                        Log(configData.LogFileName, "AirdropCallPos", player.displayName, player.UserIDString);
                    }
                    break;
            }
        }

        #endregion Events

        #region Kill Player

        private void KillPlayerLogging(ConsoleSystem.Arg arg)
        {
            if (arg.Args == null || arg.Args.Length == 0) return;

            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null) return;

            var player1 = covalence.Players.FindPlayer(arg.Args[0]);

            if (player1 == null) return;

            Log(configData.LogFileName, "KillPlayer", player.displayName, player.UserIDString, player1.Name, player1.Id);
        }

        #endregion Kill Player

        #region Kick

        private void KickLogging(ConsoleSystem.Arg arg)
        {
            string command = arg.cmd.Name;
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null) return;

            if (configData.DefaultCommands.KickLogging.KickEveryoneLog && command == "kickall")
            {
                Log(configData.LogFileName, "KickAllPlayers", player.displayName, player.UserIDString);
            }

            if (configData.DefaultCommands.KickLogging.KickLog && command == "kick")
            {
                if (arg.Args == null || arg.Args.Length == 0) return;

                var player1 = covalence.Players.FindPlayer(arg.Args[0]);
                if (player1 == null) return;

                if (arg.Args.Length == 2)
                {
                    string reason = arg.Args[1];
                    Log(configData.LogFileName, "KickPlayerReason", player.displayName, player.UserIDString, player1.Name, player1.Id, reason);
                }
                else
                {
                    Log(configData.LogFileName, "KickPlayer", player.displayName, player.UserIDString, player1.Name, player1.Id);
                }
            }
        }

        #endregion Kick

        #region Ban

        private void BanLogging(ConsoleSystem.Arg arg)
        {
            if (arg.Args == null || arg.Args.Length == 0) return;

            string command = arg.cmd.Name;
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null) return;

            var player1 = covalence.Players.FindPlayer(arg.Args[0]);
            if (player1 == null) return;

            if (configData.DefaultCommands.BanLogging.BanLog && command == "ban")
            {
                if (arg.Args.Length == 2)
                {
                    string reason = arg.Args[1];
                    Log(configData.LogFileName, "BanPlayerReason", player.displayName, player.UserIDString, player1.Name, player1.Id, reason);
                }
                else
                {
                    Log(configData.LogFileName, "BanPlayer", player.displayName, player.UserIDString, player1.Name, player1.Id);
                }
            }

            if (configData.DefaultCommands.BanLogging.UnbanLog && command == "unban")
            {
                Log(configData.LogFileName, "UnbanPlayer", player.displayName, player.UserIDString, player1.Name, player1.Id);
            }
        }

        #endregion Ban

        #region Mute

        private void MuteLogging(ConsoleSystem.Arg arg)
        {
            if (arg.Args == null || arg.Args.Length == 0) return;

            string command = arg.cmd.Name;
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null) return;

            var player1 = covalence.Players.FindPlayer(arg.Args[0]);
            if (player1 == null) return;

            if (configData.DefaultCommands.MuteLogging.MuteLog && command == "mute")
            {
                Log(configData.LogFileName, "MutePlayer", player.displayName, player.UserIDString, player1.Name, player1.Id);
            }

            if (configData.DefaultCommands.MuteLogging.UnmuteLog && command == "unmute")
            {
                Log(configData.LogFileName, "UnmutePlayer", player.displayName, player.UserIDString, player1.Name, player1.Id);
            }
        }

        #endregion Mute

        #region Spectate

        private void SpectateLogging(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null) return;

            if (arg.Args == null || arg.Args.Length == 0)
            {
                Log(configData.LogFileName, "SpectateEnabled", player.displayName, player.UserIDString);
            }

            if (arg.Args.Length == 1)
            {
                var player1 = covalence.Players.FindPlayer(arg.Args[0]);
                if (player1 == null) return;
                Log(configData.LogFileName, "SpectatePlayer", player.displayName, player.UserIDString, player1.Name, player1.Id);
            }
        }

        #endregion Spectate

        #region Teleport

        private void TeleportLogging(ConsoleSystem.Arg arg)
        {
            if (arg.Args == null || arg.Args.Length == 0) return;

            string command = arg.cmd.Name;
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null) return;

            if (configData.DefaultCommands.TeleportLogging.TeleportLog && command == "teleport")
            {
                if (arg.Args.Length == 1)
                {
                    var player1 = covalence.Players.FindPlayer(arg.Args[0]);
                    if (player1 == null) return;
                    Log(configData.LogFileName, "TeleportSelfToPlayer", player.displayName, player.UserIDString, player1.Name, player1.Id);
                }

                if (arg.Args.Length == 2)
                {
                    var player1 = covalence.Players.FindPlayer(arg.Args[0]);
                    if (player1 == null) return;
                    var player2 = covalence.Players.FindPlayer(arg.Args[1]);
                    if (player1 == null) return;
                    Log(configData.LogFileName, "TeleportPlayerToPlayer", player.displayName, player.UserIDString, player1.Name, player1.Id, player2.Name, player2.Id);
                }
            }

            if (configData.DefaultCommands.TeleportLogging.TeleportPosLog && command == "teleportpos")
            {
                Log(configData.LogFileName, "TeleportPosition", player.displayName, player.UserIDString, arg.FullString);
            }

            if (configData.DefaultCommands.TeleportLogging.TeleportToMeLog && command == "teleport2me")
            {
                var player1 = covalence.Players.FindPlayer(arg.Args[0]);
                if (player1 == null) return;
                Log(configData.LogFileName, "TeleportToSelf", player.displayName, player.UserIDString, player1.Name, player1.Id);
            }
        }

        #endregion Teleport

        #region Give

        private void GiveItemLogging(ConsoleSystem.Arg arg)
        {
            if (arg.Args == null || arg.Args.Length == 0) return;
            if (ItemManager.FindItemDefinition(arg.Args[0].ToInt()) == null) return;
        
            string command = arg.cmd.Name;
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null) return;

            switch (command)
            {
                case "giveid":
                    if (configData.DefaultCommands.GiveLogging.GiveIdLog)
                    {
                        if (arg.Args.Length == 1)
                        {
                            var itemShortName = ItemManager.FindItemDefinition(arg.Args[0].ToInt()).shortname;
                            Log(configData.LogFileName, "GiveSelf", player.displayName, player.UserIDString, "1", itemShortName);
                        }

                        if (arg.Args.Length == 2)
                        {
                            var itemShortName = ItemManager.FindItemDefinition(arg.Args[0].ToInt()).shortname;
                            var amount = arg.Args[1];
                            Log(configData.LogFileName, "GiveSelf", player.displayName, player.UserIDString, amount, itemShortName);
                        }

                        if (arg.Args.Length == 3)
                        {
                            var itemShortName = ItemManager.FindItemDefinition(arg.Args[1].ToInt()).shortname;
                            var amount = arg.Args[2];
                            var player1 = covalence.Players.FindPlayer(arg.Args[0]);
                            if (player1 == null) return;
                            Log(configData.LogFileName, "GiveTo", player.displayName, player.UserIDString, player1.Name, player1.Id, amount, itemShortName);
                        }
                    }
                    break;
                case "give":
                    if (configData.DefaultCommands.GiveLogging.GiveLog)
                    {
                        if (arg.Args.Length == 1)
                        {
                            var itemShortName = ItemManager.FindItemDefinition(arg.Args[0].ToInt()).shortname;
                            Log(configData.LogFileName, "GiveSelf", player.displayName, player.UserIDString, "1", itemShortName);
                        }
                        if (arg.Args.Length == 2)
                        {
                            var itemShortName = ItemManager.FindItemDefinition(arg.Args[0].ToInt()).shortname;
                            var amount = arg.Args[1];
                            Log(configData.LogFileName, "GiveSelf", player.displayName, player.UserIDString, amount, itemShortName);
                        }
                    }
                    break;
                case "givearm":
                    if (configData.DefaultCommands.GiveLogging.GiveArmLog)
                    {
                        var itemShortName = ItemManager.FindItemDefinition(arg.Args[0].ToInt()).shortname;
                        Log(configData.LogFileName, "GiveSelfArm", player.displayName, player.UserIDString, itemShortName);
                    }
                    break;
                case "giveto":
                    if (configData.DefaultCommands.GiveLogging.GiveToLog)
                    {
                        var player1 = covalence.Players.FindPlayer(arg.Args[0]);
                        if (player1 == null) return;

                        if (arg.Args.Length == 2)
                        {
                            var itemShortName = ItemManager.FindItemDefinition(arg.Args[1].ToInt()).shortname;
                            Log(configData.LogFileName, "GiveTo", player.displayName, player.UserIDString, player1.Name, player1.Id, "1", itemShortName);
                        }

                        if (arg.Args.Length == 3)
                        {
                            var itemShortName = ItemManager.FindItemDefinition(arg.Args[1].ToInt()).shortname;
                            var amount = arg.Args[2];
                            Log(configData.LogFileName, "GiveTo", player.displayName, player.UserIDString, player1.Name, player1.Id, amount, itemShortName);
                        }
                    }
                    break;
                case "giveall":
                    if (configData.DefaultCommands.GiveLogging.GiveAllLog)
                    {
                        if (arg.Args.Length == 1)
                        {
                            var itemShortName = ItemManager.FindItemDefinition(arg.Args[0].ToInt()).shortname;
                            Log(configData.LogFileName, "GiveAll", player.displayName, player.UserIDString, "1", itemShortName);
                        }
                        if (arg.Args.Length == 2)
                        {
                            var itemShortName = ItemManager.FindItemDefinition(arg.Args[0].ToInt()).shortname;
                            var amount = arg.Args[1];
                            Log(configData.LogFileName, "GiveAll", player.displayName, player.UserIDString, amount, itemShortName);
                        }
                    }
                    break;
            }           
        }

        #endregion Give

        #region Spawn

        private void SpawnLogging(ConsoleSystem.Arg arg)
        {
            if (arg.Args == null || arg.Args.Length < 2) return;

            string command = arg.cmd.Name;
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null) return;

            switch (command)
            {
                case "spawn":
                    if (configData.DefaultCommands.SpawnLogging.SpawnLog)
                    {
                        Log(configData.LogFileName, "Spawn", player.displayName, player.UserIDString, arg.Args[0], arg.Args[1]);
                    }
                    break;
                case "spawnat":
                    if (configData.DefaultCommands.SpawnLogging.SpawnAtLog)
                    {
                        Log(configData.LogFileName, "Spawn", player.displayName, player.UserIDString, arg.Args[0], arg.Args[1]);
                    }
                    break;
                case "spawnhere":
                    if (configData.DefaultCommands.SpawnLogging.SpawnHereLog)
                    {
                        Log(configData.LogFileName, "Spawn", player.displayName, player.UserIDString, arg.Args[0], arg.Args[1]);
                    }
                    break;
                case "spawnitem":
                    if (configData.DefaultCommands.SpawnLogging.SpawnItemLog)
                    {
                        Log(configData.LogFileName, "Spawn", player.displayName, player.UserIDString, arg.Args[0], arg.Args[1]);
                    }
                    break;
            }
        }

        #endregion Spawn

        #region Ent

        private void EntityLogging(ConsoleSystem.Arg arg)
        {
            if (arg.Args == null || arg.Args.Length < 2) return;

            string command = arg.cmd.Name;
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null) return;
            var entity = BaseNetworkable.serverEntities.Find(new NetworkableId(Convert.ToUInt64(arg.Args[1])));
            if (entity == null) return;

            if (command != "entid") return;

            switch (arg.Args[0])
            {
                case "kill":
                    if (configData.DefaultCommands.EntityLogging.EntKillLog)
                    {
                        if (entity is BaseEntity)
                        {
                            var bentity = entity as BaseEntity;
                            var player1 = covalence.Players.FindPlayerById(bentity.OwnerID.ToString());

                            if (player1 != null)
                            {
                                Log(configData.LogFileName, "EntKillBaseEntity", player.displayName, player.UserIDString, bentity.ShortPrefabName, player1.Name, player1.Id, player.transform.position);
                            }
                            else
                            {
                                Log(configData.LogFileName, "EntKillPrefab", player.displayName, player.UserIDString, entity.ShortPrefabName, player.transform.position);
                            }

                        }
                        else
                        {
                            Log(configData.LogFileName, "EntKillPrefab", player.displayName, player.UserIDString, entity.ShortPrefabName, player.transform.position);
                        }
                    }
                    break;
                case "who":
                    if (configData.DefaultCommands.EntityLogging.EntWhoLog)
                    {
                        if (entity is BaseEntity)
                        {
                            var bentity = entity as BaseEntity;
                            var player1 = covalence.Players.FindPlayerById(bentity.OwnerID.ToString());
                            if (player1 != null)
                            {
                                Log(configData.LogFileName, "EntWhoBaseEntity", player.displayName, player.UserIDString, bentity.ShortPrefabName, player1.Name, player1.Id, player.transform.position);
                            }
                        }
                    }
                    break;
                case "lock":
                    if (configData.DefaultCommands.EntityLogging.EntLockLog)
                    {
                        if (entity is BaseEntity)
                        {
                            var bentity = entity as BaseEntity;
                            var player1 = covalence.Players.FindPlayerById(bentity.OwnerID.ToString());
                            if (player1 != null)
                            {
                                Log(configData.LogFileName, "EntLockBaseEntity", player.displayName, player.UserIDString, bentity.ShortPrefabName, player1.Name, player1.Id, player.transform.position);
                            }
                        }
                    }
                    break;
                case "unlock":
                    if (configData.DefaultCommands.EntityLogging.EntUnlockLog)
                    {
                        if (entity is BaseEntity)
                        {
                            var bentity = entity as BaseEntity;
                            var player1 = covalence.Players.FindPlayerById(bentity.OwnerID.ToString());
                            if (player1 != null)
                            {
                                Log(configData.LogFileName, "EntUnlockBaseEntity", player.displayName, player.UserIDString, bentity.ShortPrefabName, player1.Name, player1.Id, player.transform.position);
                            }
                        }
                    }
                    break;
                case "auth":
                    if (configData.DefaultCommands.EntityLogging.EntAuthLog)
                    {
                        if (entity is BaseEntity)
                        {
                            var bentity = entity as BaseEntity;
                            var player1 = covalence.Players.FindPlayerById(bentity.OwnerID.ToString());
                            Log(configData.LogFileName, "EntAuthBaseEntity", player.displayName, player.UserIDString, bentity.ShortPrefabName, player1.Name, player1.Id, player.transform.position);

                        }
                    }
                    break;
            }           
        }

        #endregion Ent

        #endregion Default Commands

        #region Plugins Commands

        #region Vanish

        private void VanishLogging(BasePlayer player)
        {         
            if (Vanish.Call<bool>("IsInvisible", player))
            {
                Log(configData.LogFileName, "VanishDisabled", player.displayName, player.UserIDString);
            }
            else
            {
                Log(configData.LogFileName, "VanishEnabled", player.displayName, player.UserIDString);
            }
        }

        #endregion Vanish

        #region AdminRadar

        private void AdminRadarLogging(BasePlayer player)
        {
            if (AdminRadar.Call<bool>("IsRadar", player.UserIDString))
            {
                Log(configData.LogFileName, "RadarDisabled", player.displayName, player.UserIDString);
            }
            else
            {
                Log(configData.LogFileName, "RadarEnabled", player.displayName, player.UserIDString);
            }
        }

        #endregion AdminRadar

        #region NightVision

        private void NightVisionLogging(BasePlayer player)
        {
            if (NightVision.Call<bool>("IsPlayerTimeLocked", player))
            {
                Log(configData.LogFileName, "NightVisionDisabled", player.displayName, player.UserIDString);
            }
            else
            {
                Log(configData.LogFileName, "NightVisionEnabled", player.displayName, player.UserIDString);
            }
        }

        #endregion NightVision

        #region ConvertStatus

        private void ConvertStatusLogging(BasePlayer player)
        {
            if (player.IsAdmin)
            {
                Log(configData.LogFileName, "ConvertStatusDisabled", player.displayName, player.UserIDString);
            }
            else
            {
                Log(configData.LogFileName, "ConvertStatusEnabled", player.displayName, player.UserIDString);
            }
        }

        #endregion ConvertStatus

        #region Freeze

        private void FreezeLogging(ConsoleSystem.Arg arg)
        {
            string command = arg.cmd.Name;
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null) return;

            switch (command)
            {
                case "freeze":
                    if (configData.PluginsCommands.FreezeLogging.FreezeLog)
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "FreezePlayer", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "unfreeze":
                    if (configData.PluginsCommands.FreezeLogging.UnfreezeLog)
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "UnfreezePlayer", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "freezeall":
                    if (configData.PluginsCommands.FreezeLogging.AllFreezeLog)
                    {
                        Log(configData.LogFileName, "FreezeAllPlayers", player.displayName, player.UserIDString);
                    }
                    break;
                case "unfreezeall":
                    if (configData.PluginsCommands.FreezeLogging.AllFreezeLog)
                    {
                        Log(configData.LogFileName, "UnfreezeAllPlayers", player.displayName, player.UserIDString);
                    }
                    break;
            }
        }

        private void FreezeLogging(BasePlayer player, string command, string[] args)
        {
            switch (command)
            {
                case "freeze":
                    if (configData.PluginsCommands.FreezeLogging.FreezeLog)
                    {
                        if (args == null || args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "FreezePlayer", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "unfreeze":
                    if (configData.PluginsCommands.FreezeLogging.UnfreezeLog)
                    {
                        if (args == null || args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "UnfreezePlayer", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "freezeall":
                    if (configData.PluginsCommands.FreezeLogging.AllFreezeLog)
                    {
                        Log(configData.LogFileName, "FreezeAllPlayers", player.displayName, player.UserIDString);
                    }
                    break;
                case "unfreezeall":
                    if (configData.PluginsCommands.FreezeLogging.AllFreezeLog)
                    {
                        Log(configData.LogFileName, "UnfreezeAllPlayers", player.displayName, player.UserIDString);
                    }
                    break;
            }
        }

        #endregion Freeze

        #region InventoryViewer

        private void InventoryViewerLogging(BasePlayer player, string[] args)
        {
            if (args == null || args.Length == 0) return;
            var player1 = covalence.Players.FindPlayerById(args[0]);
            if (player1 == null) return;
            Log(configData.LogFileName, "InventoryView", player.displayName, player.UserIDString, player1.Name, player1.Id);
        }

        #endregion Backpacks

        #region Backpacks

        private void BackpacksLogging(BasePlayer player, string[] args)
        {
            if (args == null || args.Length == 0) return;
            var player1 = covalence.Players.FindPlayerById(args[0]);
            if (player1 == null) return;
            Log(configData.LogFileName, "BackpacksView", player.displayName, player.UserIDString, player1.Name, player1.Id);
        }

        #endregion Backpacks

        #region Padmin

        private void PadminLogging(BasePlayer player)
        {
            if (!configData.PluginsCommands.PlayerAdministrationLogging.OpenPadminCmdLog) return;
            Log(configData.LogFileName, "PadminOpen", player.displayName, player.UserIDString);
        }

        private void PadminLogging(ConsoleSystem.Arg arg)
        {
            string fullCommand = arg.cmd.FullName;
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null) return;

            switch (fullCommand)
            {
                case "playeradministration.closeui":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.ClosePadminCmdLog && player.IPlayer.HasPermission("playeradministration.access.show"))
                    {
                        Log(configData.LogFileName, "PadminClose", player.displayName, player.UserIDString);
                    }
                    break;
                case "playeradministration.kickuser":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.KickUserCmdLog && player.IPlayer.HasPermission("playeradministration.access.kick"))
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminKick", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "playeradministration.banuser":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.BanUserCmdLog && player.IPlayer.HasPermission("playeradministration.access.ban"))
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminBan", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "playeradministration.unbanuser":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.UnbanUserCmdLog && player.IPlayer.HasPermission("playeradministration.access.ban"))
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminUnban", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "playeradministration.muteuser":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.MuteUserCmdLog && player.IPlayer.HasPermission("playeradministration.access.mute"))
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminMute", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "playeradministration.unmuteuser":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.UnmuteUserCmdLog && player.IPlayer.HasPermission("playeradministration.access.mute"))
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminUnmute", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "playeradministration.freeze":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.FreezeCmdLog && Freeze != null && Freeze.IsLoaded && player.IPlayer.HasPermission("playeradministration.access.allowfreeze"))
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminFreeze", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "playeradministration.unfreeze":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.UnreezeCmdLog && Freeze != null && Freeze.IsLoaded && player.IPlayer.HasPermission("playeradministration.access.allowfreeze"))
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminUnfreeze", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "playeradministration.viewbackpack":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.BackpackViewCmdLog && Backpacks != null && Backpacks.IsLoaded && player.IPlayer.HasPermission("backpacks.admin"))
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminBackpackView", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "playeradministration.viewinventory":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.InventoryViewCmdLog && InventoryViewer != null && InventoryViewer.IsLoaded && player.IPlayer.HasPermission("inventoryviewer.allowed"))
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminInventoryView", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "playeradministration.clearuserinventory":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.ClearUserInventoryCmdLog && player.IPlayer.HasPermission("playeradministration.access.clearinventory"))
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminClearInventory", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "playeradministration.resetuserblueprints":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.ResetUserBPCmdLog && player.IPlayer.HasPermission("playeradministration.access.resetblueprint"))
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminResetBP", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "playeradministration.resetusermetabolism":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.ResetUserMetabolismCmdLog && player.IPlayer.HasPermission("playeradministration.access.resetmetabolism"))
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminResetMetabolism", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "playeradministration.recoverusermetabolism":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.RecoverUserMetabolismLog && player.IPlayer.HasPermission("playeradministration.access.recovermetabolism"))
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminRecoverMetabolism", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "playeradministration.tptouser":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.TeleportToUserCmdLog && player.IPlayer.HasPermission("playeradministration.access.teleport"))
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminTeleportToPlayer", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "playeradministration.tpuser":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.TeleportUserCmdLog && player.IPlayer.HasPermission("playeradministration.access.teleport"))
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminTeleportPlayer", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "playeradministration.spectateuser":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.SpectateUserCmdLog && player.IPlayer.HasPermission("playeradministration.access.spectate"))
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminSpectate", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "playeradministration.perms":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.PermsCmdLog && player.IPlayer.HasPermission("playeradministration.access.perms"))
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminPerms", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "playeradministration.hurtuser":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.HurtUserCmdLog && player.IPlayer.HasPermission("playeradministration.access.hurt"))
                    {
                        if (arg.Args == null || arg.Args.Length < 2) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminHurt", player.displayName, player.UserIDString, player1.Name, player1.Id, arg.Args[1]);
                    }
                    break;
                case "playeradministration.killuser":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.KillUserCmdLog && player.IPlayer.HasPermission("playeradministration.access.kill"))
                    {
                        if (arg.Args == null || arg.Args.Length == 0) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminKill", player.displayName, player.UserIDString, player1.Name, player1.Id);
                    }
                    break;
                case "playeradministration.healuser":
                    if (configData.PluginsCommands.PlayerAdministrationLogging.HealUserCmdLog && player.IPlayer.HasPermission("playeradministration.access.heal"))
                    {
                        if (arg.Args == null || arg.Args.Length < 2) return;
                        var player1 = covalence.Players.FindPlayerById(arg.Args[0]);
                        if (player1 == null) return;
                        Log(configData.LogFileName, "PadminHeal", player.displayName, player.UserIDString, player1.Name, player1.Id, arg.Args[1]);
                    }
                    break;

            }
        }

        #endregion Padmin

        #endregion Plugins Commands

        #region Helpers

        private void HandlePlayers()
        {
            foreach (var player in adminList)
            {
                ClientSideCommandDetection(player);
            }
        }

        private void Log(string filename, string key, params object[] args)
        {
            if (configData.LogToConsole)
            {
                Puts($"[{DateTime.Now}] {Lang(key, null, args)}");
            }

            if (configData.DiscordLog)
            {
                DiscordPost($"[{DateTime.Now}] {Lang(key, null, args)}");
            }           

            LogToFile(filename, $"[{DateTime.Now}] {Lang(key, null, args)}", this);
        }

        private string Lang(string key, string id = null, params object[] args)
        {           
            return string.Format(lang.GetMessage(key, this, id), args);
        }

        private void DiscordPost(string message)
        {
            var payload = new
            {
                content = message
            };

            var form = new WWWForm();
            form.AddField("payload_json", JsonConvert.SerializeObject(payload));

            InvokeHandler.Instance.StartCoroutine(HandleUpload(configData.DiscordWebhook, form));
        }

        private IEnumerator HandleUpload(string url, WWWForm data)
        {
            var www = UnityWebRequest.Post(url, data);
            yield return www.SendWebRequest();

            if (www.isNetworkError || www.isHttpError)
            {
                Puts($"Failed to post Discord webhook message: {www.error}");
            }
        }

        #endregion Helpers

    }
}

// --- End of file: AdminLogger.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/NoWeaponDrop.cs ---
// --- Original Local Path: BeeRust/NoWeaponDrop.cs ---

﻿using System;
using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("No Weapon Drop", "Fujikura", "1.2.0")]
	[Description("Prevents dropping of active weapon when players start to die")]
    class NoWeaponDrop : CovalencePlugin
    {
        [PluginReference]
		Plugin RestoreUponDeath;
		
		private const string permissionName = "noweapondrop.active";

		private bool Changed = false;
		private bool usePermission;
		
		private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }
		
		void LoadVariables()
        {
			usePermission = Convert.ToBoolean(GetConfig("Settings", "Use permissions", false));

            if (!Changed) return;
            SaveConfig();
            Changed = false;
        }
		
		protected override void LoadDefaultConfig()
        {
            Config.Clear();
            LoadVariables();
        }
		
		void Init()
		{
			LoadVariables();
			permission.RegisterPermission(permissionName, this);
		}
		
		object CanDropActiveItem(BasePlayer player)
		{
			if (player.IsNpc || (usePermission && !permission.UserHasPermission(player.UserIDString, permissionName)))
				return null;
			return false;
		}
	}
}


// --- End of file: NoWeaponDrop.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BeeRust/ClansSet.cs ---
// --- Original Local Path: BeeRust/ClansSet.cs ---

using System.Security;
using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("ClansSet", "King", "1.1.0")]
    class ClansSet : RustPlugin
    {
        #region [Vars]
        [PluginReference] private Plugin ImageLibrary, Clans;
        private Dictionary<string, DateTime> Cooldowns = new Dictionary<string, DateTime>();
        private Dictionary<string, string> clansData = new Dictionary<string, string>();
        private Dictionary<string, int> _itemIds = new Dictionary<string, int>();
        private List<string> SetKeys = new List<string>();

        private string Layer = "ClansSet.Layer";
        #endregion
        
        #region [Data]
        private void LoadData() => clansData = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<Dictionary<string, string>>("ClansSet/Data");
        private void SaveData() => Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("ClansSet/Data", clansData);
        #endregion

        #region [ImageLibrary]
        private bool HasImage(string imageName, ulong imageId = 0) => (bool)ImageLibrary.Call("HasImage", imageName, imageId);
        private bool AddImage(string url, string shortname, ulong skin = 0) => (bool)ImageLibrary?.Call("AddImage", url, shortname, skin);
        private string GetImage(string shortname, ulong skin = 0) => (string)ImageLibrary?.Call("GetImage", shortname, skin);
        #endregion

        #region [Oxide]
	    private void OnServerInitialized()
	    {
            LoadData();
            cmd.AddChatCommand(config._SettingsPlugin.openMenuCommand, this, "cmdOpenSet");

		    foreach (var key in config._SettingsKits)
		    {
			    if(!SetKeys.Contains(key.Key))
				    SetKeys.Add(key.Key);

			    if(!String.IsNullOrWhiteSpace(key.Value.Permissions) && !permission.PermissionExists(key.Value.Permissions, this))
				    permission.RegisterPermission(key.Value.Permissions, this);
		    }

            AddImage("https://i.imgur.com/zvtUYCS.png", "ImageLine");
            AddImage("https://i.imgur.com/LR2j88f.png", "NextPage");
            AddImage("https://i.imgur.com/5iHnDXC.png", "BackPage");
            AddImage("https://i.imgur.com/uHTdwjY.png", "ItemBackground");
        }

        private void Unload()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
                CuiHelper.DestroyUi(player, Layer);

            SaveData();
        }
        #endregion

        #region [Config]
        private PluginConfig config;

        protected override void LoadDefaultConfig()
        {
            config = PluginConfig.DefaultConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();

            if (config.PluginVersion < Version)
                UpdateConfigValues();

            Config.WriteObject(config, true);
        }

        private void UpdateConfigValues()
        {
            PluginConfig baseConfig = PluginConfig.DefaultConfig();
            if (config.PluginVersion < Version)
            {
                config.PluginVersion = Version;
                if (Version == new VersionNumber(1, 1, 0))
                {
                    //
                }

                PrintWarning("Config checked completed!");
            }
            config.PluginVersion = Version;
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        public class SettingsPlugin
        {
            [JsonProperty("Команда для открытия меню выбора скинов")]
            public string openMenuCommand;

            [JsonProperty("КД на изменения скинов")]
            public float cooldown;
        }

        public class SettingsKits
        {
            [JsonProperty("Картинка - ( Для аватарка набора )")]
            public string Image;

            [JsonProperty("ShortName ( Для аватарки набора )")]
            public string ShortName;

            [JsonProperty("SkinID ( Для аватарка набора )")]
            public ulong SkinID;

            [JsonProperty("Права дающие возможность использовать набор (оставьте поле пустым - будет доступен для всех)")]
            public string Permissions;

			[JsonProperty(PropertyName = "Настройки одежды")]
			public List<WearSettings> WearSettings;
        }

        public class WearSettings
        {
            [JsonProperty("ShortName")]
            public string ShortName;

            [JsonProperty("SkinID")]
            public ulong SkinID;
        }

        private class PluginConfig
        {
            [JsonProperty("Настройки плагина")] 
            public SettingsPlugin _SettingsPlugin = new SettingsPlugin();

		    [JsonProperty("Настройка одежды")]
		    public Dictionary<string, SettingsKits> _SettingsKits = new Dictionary<string, SettingsKits>();

            [JsonProperty("Config version")]
            public VersionNumber PluginVersion = new VersionNumber();

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    _SettingsPlugin = new SettingsPlugin()
                    {
                        openMenuCommand = "set",
                        cooldown = 5f
                    },
                    _SettingsKits = new Dictionary<string, SettingsKits>()
                    {
                        ["default_set"] = new SettingsKits
                        {
                            Image = string.Empty,
                            ShortName = "metal.facemask",
                            Permissions = string.Empty,
                            SkinID = 0,
                            WearSettings = new List<WearSettings>()
                            {
                                new WearSettings()
                                {
                                    ShortName = "metal.facemask",
                                    SkinID = 0,
                                },
                                new WearSettings()
                                {
                                    ShortName = "metal.plate.torso",
                                    SkinID = 0,
                                },
                                new WearSettings()
                                {
                                    ShortName = "roadsign.kilt",
                                    SkinID = 0,
                                },
                                new WearSettings()
                                {
                                    ShortName = "hoodie",
                                    SkinID = 0,
                                },
                                new WearSettings()
                                {
                                    ShortName = "pants",
                                    SkinID = 0,
                                },
                                new WearSettings()
                                {
                                    ShortName = "shoes.boots",
                                    SkinID = 0,
                                },
                                new WearSettings()
                                {
                                    ShortName = "rifle.ak",
                                    SkinID = 0,
                                },
                            },
                        },
                        ["white_set"] = new SettingsKits
                        {
                            Image = string.Empty,
                            ShortName = "metal.facemask",
                            Permissions = "clansset.white",
                            SkinID = 2432948498,
                            WearSettings = new List<WearSettings>()
                            {
                                new WearSettings()
                                {
                                    ShortName = "metal.facemask",
                                    SkinID = 2432948498,
                                },
                                new WearSettings()
                                {
                                    ShortName = "metal.plate.torso",
                                    SkinID = 2432947351,
                                },
                                new WearSettings()
                                {
                                    ShortName = "roadsign.kilt",
                                    SkinID = 2469019097,
                                },
                                new WearSettings()
                                {
                                    ShortName = "hoodie",
                                    SkinID = 2416648557,
                                },
                                new WearSettings()
                                {
                                    ShortName = "pants",
                                    SkinID = 2416647256,
                                },
                                new WearSettings()
                                {
                                    ShortName = "shoes.boots",
                                    SkinID = 1657109993,
                                },
                                new WearSettings()
                                {
                                    ShortName = "rifle.ak",
                                    SkinID = 2536316473,
                                },
                            },
                        },
                        ["black_set"] = new SettingsKits
                        {
                            Image = string.Empty,
                            ShortName = "metal.facemask",
                            Permissions = "clansset.black",
                            SkinID = 2105454370,
                            WearSettings = new List<WearSettings>()
                            {
                                new WearSettings()
                                {
                                    ShortName = "metal.facemask",
                                    SkinID = 2105454370,
                                },
                                new WearSettings()
                                {
                                    ShortName = "metal.plate.torso",
                                    SkinID = 2105505757,
                                },
                                new WearSettings()
                                {
                                    ShortName = "roadsign.kilt",
                                    SkinID = 2120628865,
                                },
                                new WearSettings()
                                {
                                    ShortName = "hoodie",
                                    SkinID = 2080975449,
                                },
                                new WearSettings()
                                {
                                    ShortName = "pants",
                                    SkinID = 2080977144,
                                },
                                new WearSettings()
                                {
                                    ShortName = "shoes.boots",
                                    SkinID = 2090776132,
                                },
                                new WearSettings()
                                {
                                    ShortName = "rifle.ak",
                                    SkinID = 2437435853,
                                },
                            },
                        },
                        ["opulent_set"] = new SettingsKits
                        {
                            Image = string.Empty,
                            ShortName = "metal.facemask",
                            Permissions = string.Empty,
                            SkinID = 2193149013,
                            WearSettings = new List<WearSettings>()
                            {
                                new WearSettings()
                                {
                                    ShortName = "metal.facemask",
                                    SkinID = 2193149013,
                                },
                                new WearSettings()
                                {
                                    ShortName = "metal.plate.torso",
                                    SkinID = 2193157606,
                                },
                                new WearSettings()
                                {
                                    ShortName = "roadsign.kilt",
                                    SkinID = 2199787450,
                                },
                                new WearSettings()
                                {
                                    ShortName = "hoodie",
                                    SkinID = 2207288699,
                                },
                                new WearSettings()
                                {
                                    ShortName = "pants",
                                    SkinID = 2207291626,
                                },
                                new WearSettings()
                                {
                                    ShortName = "shoes.boots",
                                    SkinID = 0,
                                },
                                new WearSettings()
                                {
                                    ShortName = "rifle.ak",
                                    SkinID = 2843727355,
                                },
                            },
                        }
                    },
                    PluginVersion = new VersionNumber()
                };
            }
        }
        #endregion

        #region [UI]
        private void cmdOpenSet(BasePlayer player)
        {
            var clan = GetClanTag(player.userID);
            if (string.IsNullOrEmpty(clan))
            {
                player.ChatMessage("Вы не находитесь ни в одном клане!");
                return;
            }
            
            if (!IsLeader(player.userID))
            {
                player.ChatMessage("Вы не являетесь главой своего клана!");
                return;
            }

            if (!clansData.ContainsKey(clan))
                clansData.Add(clan, string.Empty);

            MainUI(player);
        }

        private void MainUI(BasePlayer player)
        {
            var container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, Layer);

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0.75", Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
            }, "Overlay", Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Button = { Color = "0 0 0 0", Close = Layer },
                Text = { Text = "" }
            }, Layer);

			container.Add(new CuiPanel
			{
				Image = { Color = "1 1 1 0.4" },
				RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-506.733 -77.133", OffsetMax = "-486.733 -75.8" }
			}, Layer, Layer + ".LineOne");

			container.Add(new CuiPanel
			{
				Image = { Color = "1 1 1 0.4" },
				RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-130.333 -77.133", OffsetMax = "504.741 -75.8" }
			}, Layer, Layer + ".LineTwo");

			container.Add(new CuiElement
			{
				Name = Layer + ".Title",
				Parent = Layer,
				Components =
				{
					new CuiTextComponent { Text = "Скины этого набора, чтобы поставить нажмите на кнопку 'Использовать'", Font = "robotocondensed-regular.ttf", FontSize = 11, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
					new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-472.954 -83.327", OffsetMax = "-136.913 -67.606" }
				}
			});

            CuiHelper.AddUi(player, container);
            DrawUI_ShowSet(player, 0);
        }

	    private void DrawUI_ShowSet(BasePlayer player, int page = 0)
	    {
		    string SelectSetKey = SetKeys[page];
		    string BackSetKey = page - 1 >= 0 ? SetKeys[page - 1] : SetKeys[SetKeys.Count - 1];
		    string NextSetKey = page + 1 >= SetKeys.Count ? SetKeys[0] : SetKeys[page + 1];

		    var SetCentral = config._SettingsKits[SelectSetKey];
		    var SetBack = config._SettingsKits[BackSetKey];
		    var SetNext = config._SettingsKits[NextSetKey];

            var clan = GetClanTag(player.userID);
            var container = new CuiElementContainer();

			container.Add(new CuiPanel
			{
				CursorEnabled = false,
				Image = { Color = "1 1 1 0" },
				RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-313.267 -47.22", OffsetMax = "310.333 287.737" }
			}, Layer, Layer + ".PanelSet");

            if (!string.IsNullOrEmpty(SetBack.Image))
            {
                container.Add(new CuiElement
                {
                    Name = Layer + ".PanelSet" + ".ThreeSet",
                    Parent = Layer + ".PanelSet",
                    Components =
                    {
                        new CuiRawImageComponent { Png = GetImage(SetBack.Image), Color = "1 1 1 0.45" },
                        new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-247 -34.258",OffsetMax = "-113.666 99.075" }
                    }
                });
            }
            else
            {
                container.Add(new CuiElement
                {
                    Name = Layer + ".PanelSet" + ".ThreeSet",
                    Parent = Layer + ".PanelSet",
                    Components =
                    {
                        new CuiImageComponent { ItemId = FindItemID(SetBack.ShortName), SkinId = SetBack.SkinID, Color = "1 1 1 0.45" },
                        new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-247 -34.258",OffsetMax = "-113.666 99.075" }
                    }
                });
            }

            if (!string.IsNullOrEmpty(SetNext.Image))
            {
                container.Add(new CuiElement
                {
                    Name = Layer + ".PanelSet" + ".TwoSet",
                    Parent = Layer + ".PanelSet",
                    Components =
                    {
                        new CuiRawImageComponent { Png = GetImage(SetNext.Image), Color = "1 1 1 0.45" },
                        new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "119.667 -34.258", OffsetMax = "253 99.075" }
                    }
                });
            }
            else
            {
                container.Add(new CuiElement
                {
                    Name = Layer + ".PanelSet" + ".TwoSet",
                    Parent = Layer + ".PanelSet",
                    Components =
                    {
                        new CuiImageComponent { ItemId = FindItemID(SetNext.ShortName), SkinId = SetNext.SkinID, Color = "1 1 1 0.45" },
                        new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "119.667 -34.258", OffsetMax = "253 99.075" }
                    }
                });
            }

            if (!string.IsNullOrEmpty(SetCentral.Image))
            {
                container.Add(new CuiElement
                {
                    Name = Layer + ".PanelSet" + ".TwoSet",
                    Parent = Layer + ".PanelSet",
                    Components =
                    {
                        new CuiRawImageComponent { Png = GetImage(SetCentral.Image), Color = "1 1 1 1" },
                        new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "119.667 -34.258", OffsetMax = "253 99.075" }
                    }
                });
            }
            else
            {
                container.Add(new CuiElement
                {
                    Name = Layer + ".PanelSet" + ".TwoSet",
                    Parent = Layer + ".PanelSet",
                    Components =
                    {
                        new CuiImageComponent { ItemId = FindItemID(SetCentral.ShortName), SkinId = SetCentral.SkinID, Color = "1 1 1 1" },
                        new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-113.666 -84.258", OffsetMax = "119.667 149.075" }
                    }
                });
            }

			container.Add(new CuiElement
			{
				Name = Layer + ".PanelSet" + ".NextPage",
				Parent = Layer + ".PanelSet",
				Components =
				{
					new CuiRawImageComponent { Color = "1 1 1 1",  Png = GetImage("NextPage") },
					new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "271.8 12.408", OffsetMax = "311.8 52.408" }
				}
			});

			container.Add(new CuiElement
			{
				Name = Layer + ".PanelSet" + ".BackPage",
				Parent = Layer + ".PanelSet",
				Components =
				{
					new CuiRawImageComponent { Color = "1 1 1 1", Png = GetImage("BackPage") },
					new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-311.8 12.408", OffsetMax = "-271.8 52.408" }
				}
			});

			container.Add(new CuiButton
			{
				Button = { Color = "1 1 1 0", Command = $"UI_SETS page.change {page + 1}"},
				Text = { Text = "" },
				RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-20 -20", OffsetMax = "20 20" }
			}, Layer + ".PanelSet" + ".NextPage");

			container.Add(new CuiButton
			{
				Button = { Color = "1 1 1 0", Command = $"UI_SETS page.change {page - 1}"},
				Text = { Text = "" },
				RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-20 -20", OffsetMax = "20 20" }
			}, Layer + ".PanelSet" + ".BackPage");

			container.Add(new CuiElement
			{
				Name = Layer + ".PanelSet" + ".Button",
				Parent = Layer + ".PanelSet",
				Components =
				{
					new CuiRawImageComponent { Color = "1 1 1 1", Png = GetImage("ImageLine") },
					new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-113.666 -144.392", OffsetMax = "119.667 -113.725" }
				}
			});

			container.Add(new CuiButton
			{
				Button = { Color = "1 1 1 0", Command = $"UI_SETS set.change {SelectSetKey} {page}"},
				Text = { Text = !isPermission(player, SetCentral.Permissions) ? "Недостаточно прав" : clansData[clan] == SelectSetKey ? "Уже используете" : "Использовать", Font = "robotocondensed-regular.ttf", FontSize = 20, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
				RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" }
			}, Layer + ".PanelSet" + ".Button");

            int x = 0, y = 0;
            for (int i = 0; i < 20; i++)
            {
                var Wear = SetCentral.WearSettings.Count - 1 >= i ? SetCentral.WearSettings[i] : null;

			    container.Add(new CuiElement
			    {
				    Name = Layer + ".PanelSet" + $".Item{i}",
				    Parent = Layer + ".PanelSet",
				    Components =
				    {
					    new CuiRawImageComponent { Color = "1 1 1 1", Png = GetImage("ItemBackground") },
					    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"{-505.133 + (x * 102)} {-311.666 - (y * 110)}", OffsetMax = $"{-409.8 + (x * 102)} {-208.333 - (y * 110)}" }
				    }
			    });

                if (Wear != null)
                {
                    container.Add(new CuiElement
                    {
                        Parent = Layer + ".PanelSet" + $".Item{i}",
                        Components =
                        {
                            new CuiImageComponent { FadeIn = 0.12f * i,ItemId = FindItemID(Wear.ShortName), SkinId = Wear.SkinID },
                            new CuiRectTransformComponent {AnchorMin = "0 0", AnchorMax = "1 1"}
                        }
                    });

			        container.Add(new CuiElement
			        {
				        Parent = Layer + ".PanelSet" + $".Item{i}",
				        Components =
				        {
					        new CuiTextComponent { Text = $"{ItemManager.FindItemDefinition(Wear.ShortName)?.displayName?.english}", Font = "robotocondensed-regular.ttf", FontSize = 9, Align = TextAnchor.MiddleRight, Color = "1 1 1 1", FadeIn = 0.12f * i,},
					        new CuiRectTransformComponent { AnchorMin = "0 0.87", AnchorMax = "0.96 1" }
				        }
			        });
                }

                x++;
                if (x != 10) continue;

                x = 0;
                y++;
            }

		    CuiHelper.DestroyUi(player, Layer + ".PanelSet");
		    CuiHelper.AddUi(player, container);
        }
        #endregion

        #region [ConsoleCommand]
        [ConsoleCommand("UI_SETS")]
        private void cmdClansSet(ConsoleSystem.Arg args)
        {
		    BasePlayer player = args.Player();
		    if (player == null) return;

            switch (args.Args[0])
            {
			    case "page.change":
			    {
				    int page = int.Parse(args.Args[1]);
				    if (page >= SetKeys.Count)
					    page = 0;

				    if (page < 0)
					    page = SetKeys.Count - 1;

				    DrawUI_ShowSet(player, page);
				    break;
			    }
                case "set.change":
                {
                    var clan = GetClanTag(player.userID);
                    if (string.IsNullOrEmpty(clan)) return;

			        if (Cooldowns.ContainsKey(clan))
                        if (Cooldowns[clan].Subtract(DateTime.Now).TotalSeconds >= 0) return;

                    if (!clansData.ContainsKey(clan))
                        clansData.Add(clan, string.Empty);

                    if (clansData[clan] == args.Args[1]) return;

                    if (!SetKeys.Contains(args.Args[1])) return;
                    var getSet = config._SettingsKits[args.Args[1]];

                    if(!isPermission(player, getSet.Permissions))
                    {
                        player.ChatMessage("У вас недостаточно прав для использования этого набора одежды!");
                        return;
                    }

                    foreach (var skin in getSet.WearSettings)
                        GetChangeSkin(player.userID, skin.ShortName, skin.SkinID);

                    Cooldowns[clan] = DateTime.Now.AddSeconds(config._SettingsPlugin.cooldown);
                    clansData[clan] = args.Args[1];
                    DrawUI_ShowSet(player, int.Parse(args.Args[2]));
                    break;
                }
            }
        }
        #endregion
        
        #region [Func]
		private int FindItemID(string shortName)
		{
			int val;
			if (_itemIds.TryGetValue(shortName, out val))
				return val;

			var definition = ItemManager.FindItemDefinition(shortName);
			if (definition == null) return 0;

			val = definition.itemid;
			_itemIds[shortName] = val;
			return val;
		}

        private bool isPermission(BasePlayer player, string Permission) => String.IsNullOrWhiteSpace(Permission) || permission.UserHasPermission(player.UserIDString, Permission);

        private string GetClanTag(ulong userID) => Clans?.Call<string>("GetClanTag", userID);
        private bool IsLeader(ulong userID) => (bool)Clans?.Call<bool>("GetClanOwner", userID);
        private void GetChangeSkin(ulong userID, string shortName, ulong skinID) => Clans?.Call("GetChangeSkin", userID, shortName, skinID);
        #endregion
    }   
}

// --- End of file: ClansSet.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HudRust/Trade.cs ---
// --- Original Local Path: HudRust/Trade.cs ---

using Network;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using System;
using System.Linq;
using System.Collections.Generic;
using UnityEngine;
namespace Oxide.Plugins
{
    [Info("Trade", "OxideBro", "2.2.0")]
    public class Trade : RustPlugin
    {
        private static Trade ins;
        private PluginConfig config;
        public List<TradeBox> tradeBoxes = new List<TradeBox>();
        private List<TradePendings> pendings = new List<TradePendings>();
        private Dictionary<BasePlayer, DateTime> Cooldowns = new Dictionary<BasePlayer, DateTime>();

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Благодарим за покупку плагина на сайте RustPlugin.ru. Если вы передадите этот плагин сторонним лицам знайте - это лишает вас гарантированных обновлений!");
            config = PluginConfig.DefaultConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
            if (config.PluginVersion < Version)
                UpdateConfigValues();
            Config.WriteObject(config, true);
        }

        private void UpdateConfigValues()
        {
            PluginConfig baseConfig = PluginConfig.DefaultConfig();
            if (config.PluginVersion < new VersionNumber(2, 2, 0))
            {
                PrintWarning("Config update detected! Updating config values...");
                config.mainSettings.permsNum = new Dictionary<string, PermissionTrade>()
                {
                    ["trade.one"] = new PermissionTrade()
                    {
                        GetCapacity = 4,
                        GetCooldown = 50,
                    },
                    ["trade.two"] = new PermissionTrade()
                    {
                        GetCapacity = 5,
                        GetCooldown = 40,
                    },
                    ["trade.three"] = new PermissionTrade()
                    {
                        GetCapacity = 6,
                        GetCooldown = 30,
                    },
                };
                PrintWarning("Config update completed!");
            }
            config.PluginVersion = Version;
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        public class MainSettings
        {
            [JsonProperty("Запретить принимать запрос в BuildingBlock")]
            public bool getCupAuth = true;

            [JsonProperty("Запретить отправлять запрос в BuildingBlock")]
            public bool getCupSend = true;

            [JsonProperty("Запретить использовать трейд в полёте")]
            public bool getFly = true;

            [JsonProperty("Запретить использовать трейд в воде")]
            public bool getSwim = true;

            [JsonProperty("Запретить обмениватся игрокам если игроки не в тиме (Стандартная система друзей)")]
            public bool enabledTeamate = false;

            [JsonProperty("Запретить использовать трейд в предсмертном состоянии")]
            public bool getWound = true;

            [JsonProperty("Время ответа на предложения обмена (секунд)")]
            public int getTime = 15;

            [JsonProperty("Задержка использования трейда (Cooldown - секунд)")]
            public double CooldownTrade = 60.0;

            [JsonProperty("Разрешить трейд если между игроками если их дистанция больше указанной (-1 - отключение)")]
            public double TradeDistance = 50;

            [JsonProperty("Количество активных слотов при обмене")]
            public int getInt = 8;

            [JsonProperty("Список привилегий и размера слотов при обмене")]
            public Dictionary<string, PermissionTrade> permsNum = new Dictionary<string, PermissionTrade>();

            [JsonProperty("Привилегия на использование команды trade")]
            public string Permission = "trade.use";

            [JsonProperty("Разрешить использование трейда только если игрок имеет привилегию указаную в конфиге")]
            public bool UsePermission = false;
        }

        public class PermissionTrade
        {
            [JsonProperty("Размер слотов у данной привилегии")]
            public int GetCapacity = 0;
            [JsonProperty("Задержка после обмена у данной привилегии")]
            public int GetCooldown = 0;
        }

        class PluginConfig
        {
            [JsonProperty("Основные")]
            public MainSettings mainSettings;

            [JsonProperty("Версия конфигурации")]
            public VersionNumber PluginVersion = new VersionNumber();


            [JsonIgnore]
            [JsonProperty("Инициализация плагина")]
            public bool Init;

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    mainSettings = new MainSettings()
                    {
                        permsNum = new Dictionary<string, PermissionTrade>()
                        {
                            ["trade.one"] = new PermissionTrade()
                            {
                                GetCapacity = 4,
                                GetCooldown = 50,
                            },
                            ["trade.two"] = new PermissionTrade()
                            {
                                GetCapacity = 5,
                                GetCooldown = 40,
                            },
                            ["trade.three"] = new PermissionTrade()
                            {
                                GetCapacity = 6,
                                GetCooldown = 30,
                            },
                        }
                    },
                    PluginVersion = new VersionNumber(),

                };
            }
        }

        [PluginReference] Plugin Duel;
        private bool IsDuelPlayer(BasePlayer player)
        {
            if (!Duel) return false;
            var dueler = Duel?.Call("IsPlayerOnActiveDuel", player);
            if (dueler is bool) return (bool)dueler;
            return false;
        }

        private bool IsTeamate(BasePlayer player, BasePlayer target)
        {
            if (!config.mainSettings.enabledTeamate) return true;
            if (player.currentTeam == 0 || target.currentTeam == 0) return false;
            return player.currentTeam == target.currentTeam;
        }

        int GetTradeSize(string UserID)
        {
            int size = config.mainSettings.getInt;
            foreach (var num in config.mainSettings.permsNum)
            {
                if (permission.UserHasPermission(UserID, num.Key))
                    if (num.Value.GetCapacity > size) size = num.Value.GetCapacity;
            }
            return size;
        }

        double GetPlayerCooldown(string UserID)
        {
            var cd = config.mainSettings.CooldownTrade;
            foreach (var num in config.mainSettings.permsNum)
            {
                if (permission.UserHasPermission(UserID, num.Key))
                    if (num.Value.GetCooldown < cd) cd = num.Value.GetCapacity;
            }
            return cd;
        }

        void Reply(BasePlayer player, string langKey, params object[] args) => SendReply(player, Messages[langKey], args);

        bool CanPlayerTrade(BasePlayer player)
        {
            var reply = 288;
            if (reply == 0) { }
            if (!config.Init) return false;
            if (config.mainSettings.getSwim)
            {
                if (player.IsSwimming())
                {
                    Reply(player, "DENIED.SWIMMING");
                    return false;
                }
            }
            if (config.mainSettings.getCupSend || config.mainSettings.getCupAuth)
            {
                if (!player.CanBuild())
                {
                    Reply(player, "DENIED.PRIVILEGE");
                    return false;
                }
            }
            if (config.mainSettings.getFly)
            {
                if (!player.IsOnGround() || player.IsFlying)
                {
                    Reply(player, "DENIED.FALLING");
                    return false;
                }
            }
            if (config.mainSettings.getWound)
            {
                if (player.IsWounded())
                {
                    Reply(player, "DENIED.WOUNDED");
                    return false;
                }
            }
            if (Cooldowns.ContainsKey(player))
            {
                double seconds = Cooldowns[player].Subtract(DateTime.Now).TotalSeconds;
                if (seconds >= 0)
                {
                    Reply(player, "COOLDOWN", seconds);
                    return false;
                }
            }
            if (IsDuelPlayer(player))
            {
                Reply(player, "DENIED.DUEL");
                return false;
            }
            var canTrade = Interface.Call("CanTrade", player);
            if (canTrade != null)
            {
                if (canTrade is string)
                {
                    SendReply(player, Convert.ToString(canTrade));
                    return false;
                }
                Reply(player, "DENIED.GENERIC");
                return false;
            }
            return true;
        }

        Dictionary<string, string> Messages = new Dictionary<string, string>() {
                {
                "DENIED.SWIMMING", "Недоступно, вы плаваете!"
            }
            , {
                "DENIED.DUEL", "Недоступно, один из игроков на Duel!"
            }
            , {
                "DENIED.PERMISSIONON", "Недоступно, у Вас нету прав на использование трейда!"
            }
            , {
                "DENIED.PERMISSIOONTARGETN", "Недоступно, у {0} прав на использование трейда!"
            }
            , {
                "DENIED.FALLING", "Недоступно, вы левитируете!"
            }
            , {
                "DENIED.WOUNDED", "Недоступно, вы в предсмертном состоянии!"
            }
            , {
                "DENIED.GENERIC", "Недоступно, заблокировано другим плагином!"
            }
            , {
                "DENIED.PRIVILEGE", "Недоступно, вы в зоне Building Blocked!"
            }
            , {
                "DENIED.PERMISSION", "Недоступно, вы в зоне Building Blocked!"
            }
            , {
                "TRADE.HELP", "Trade by RustPlugin.ru\nИспользуйте комманду <color=orange>/trade \"НИК\"</color> для обмена\nЧто бы принять обмен, введите: <color=orange>/trade yes</color> (или /trade accept)\nЧто бы отказаться от обмена введите: <color=orange>/trade no </color> (или /trade cancel)"
            }
            , {
                "PLAYER.NOT.FOUND", "Игрок '{0}' не найден!"
            }
             , {
                "TRADE.ALREADY.PENDING", "Невозможно! Вы либо вам уже отправлено предложение обмена!"
            }
            , {
                "TRADE.TARGET.ALREADY.PENDING", "Невозможно! У игрока есть активное предложение обмена!"
            }

            , {
                "TRADE.ACCEPT.PENDING.EMPTY", "У вас нет входящих предложний обмена!"
            }
            , {
                "TRADE.CANCELED", "Trade отменен!"
            }
            , {
                "TRADE.TOYOU", "Нельзя отправлять запрос самому себе!"
            }
            , {
                "TRADE.SUCCESS", "Trade успешно завершён!"
            }
            , {
                "PENDING.RECIEVER.FORMAT", "Игрок '{0}' отправил вам предложние обмена\nДля принятия обмена используйте команду <color=orange>/trade yes</color>\nЧто бы отказаться введите <color=orange>/trade no</color>"
            }
            , {
                "PENDING.SENDER.FORMAT", "Предложение обмена игроку '{0}' успешно отправлено, ожидайте..."
            }
            , {
                "PENDING.TIMEOUT.SENDER", "Trade отменён! Причина: время истекло."
            }
            , {
                "PENDING.TIMEOUT.RECIEVER", "Trade отменён! Причина: вы вовремя не приняли запрос."
            }
            , {
                "PENDING.CANCEL.SENDER", "Trade отменён! Причина: игрок '{0}' отказался"
            },
            {
                "COOLDOWN", "Вы только недавно обменивались, подождите - {0:0} сек."
            },
            {
                "GET.FRIENDS", "Вы не состоите в одной тиме с игроком {0}, трейд запрещен"
            },
            {
                "GET.DISTANCE", "Трейд запрещен на малых дистанциях между вами игроком"
            },
        };


        private void Loaded()
        {
            ins = this;
            lang.RegisterMessages(Messages, this);
            Messages = lang.GetMessages("en", this);
            permission.RegisterPermission(config.mainSettings.Permission, this);
            var perms = config.mainSettings.permsNum.Where(p => p.Key.StartsWith("trade."));
            foreach (var perm in perms)
            {
                if (!permission.PermissionExists(perm.Key))
                    permission.RegisterPermission(perm.Key, this);

            }
            if (!permission.PermissionExists(config.mainSettings.Permission))
                permission.RegisterPermission(config.mainSettings.Permission, this);
            config.Init = true;
        }

        void OnServerInitialized()
        {
            timer.Every(1f, TradeTimerHandle);
        }

        class TradePendings
        {
            public BasePlayer target;
            public BasePlayer player;
            public int seconds;

            public TradePendings(BasePlayer player, int Seconds, BasePlayer target)
            {
                this.target = target;
                this.player = player;
                seconds = Seconds;

            }
        }

        void TradeTimerHandle()
        {
            for (int i = pendings.Count - 1;
           i >= 0;
           i--)
            {
                var pend = pendings[i];
                if (pend.target != null && !pend.target.IsConnected || pend.target.IsWounded())
                {
                    pendings.RemoveAt(i);
                    continue;
                }
                if (pend.player != null && !pend.player.IsConnected || pend.player.IsWounded())
                {
                    pendings.RemoveAt(i);
                    continue;
                }
                if (--pend.seconds <= 0)
                {
                    pendings.RemoveAt(i);
                    if (pend.player.IsConnected) Reply(pend.player, "PENDING.TIMEOUT.SENDER");
                    if (pend.target.IsConnected) Reply(pend.target, "PENDING.TIMEOUT.RECIEVER");
                }
            }
        }

        void Unload()
        {
            foreach (var trade in tradeBoxes)
            {
                UnityEngine.Object.Destroy(trade);
            }
        }

        private void OnItemSplit(Item item, int amount)
        {
            if (!config.Init) return;
            if (item == null) return;
            if (item.GetRootContainer() == null || item.GetRootContainer()?.entityOwner == null || item.GetRootContainer()?.entityOwner?.GetComponent<ShopFront>() == null) return;
            var container = item.GetRootContainer().entityOwner?.GetComponent<ShopFront>();
            if (container != null)
                if (container.GetComponent<TradeBox>() != null)
                {
                    if (container.vendorInventory != null && container.customerInventory != null)
                        if (container.vendorInventory.IsLocked() || container.customerInventory.IsLocked())
                            container.ResetTrade();
                }
        }

        [PluginReference] Plugin SkinBox;

        bool isSkinBox(ulong playerID)
        {
            if (!SkinBox) return false;
            return (bool)SkinBox?.Call("IsSkinBoxPlayer", playerID);
        }

        object CanMoveItem(Item item, PlayerInventory playerLoot, uint targetContainer)
        {
            if (!config.Init) return null;
            if (playerLoot == null) return null;
            var container = playerLoot.FindContainer(targetContainer);
            if (container == null) return null;
            var player = playerLoot.containerMain.playerOwner;
            if (player == null) return null;
            if (container.entityOwner != null && container.entityOwner is ShopFront)
            {
                var shopfront = container.entityOwner.GetComponent<ShopFront>();
                if (shopfront != null)
                {
                    if (item.contents != null)
                    {
                        item.contents.SetLocked(true);
                        item.MarkDirty();
                    }
                    if (shopfront.IsPlayerCustomer(player) && shopfront.customerInventory.uid != targetContainer)
                        return false;
                    else if (shopfront.IsPlayerVendor(player) && shopfront.vendorInventory.uid != targetContainer) return false;
                }
            }
            else
            {
                if (item.contents != null && item.contents.IsLocked() && !isSkinBox(player.userID))
                {
                    item.contents.SetLocked(false);
                    item.MarkDirty();
                }
            }
            return null;
        }

        void OnEntityKill(ShopFront shop)
        {
            if (shop == null) return;
            if (shop.GetComponent<TradeBox>() != null)
            {
                if (shop.GetComponent<TradeBox>().player1 != null)
                    shop.GetComponent<TradeBox>().player1.EndLooting();
                if (shop.GetComponent<TradeBox>().player2 != null)
                    shop.GetComponent<TradeBox>().player2.EndLooting();
            }
        }

        object OnEntityVisibilityCheck(ShopFront shop, BasePlayer player, uint rpcId, string debugName, float maximumDistance)
        {
            if (!config.Init) return null;
            if (shop == null || shop?.net.ID == null || player == null) return null;
            if (shop.GetComponent<TradeBox>() != null)
            {
                if (shop.IsPlayerVendor(player))
                {
                    shop.SetFlag(global::BaseEntity.Flags.Reserved1, true, false, true);
                    shop.vendorInventory.SetLocked(true);
                }
                else if (shop.IsPlayerCustomer(player))
                {
                    shop.SetFlag(global::BaseEntity.Flags.Reserved2, true, false, true);
                    shop.customerInventory.SetLocked(true);
                }
                if (shop.HasFlag(global::BaseEntity.Flags.Reserved1) && shop.HasFlag(global::BaseEntity.Flags.Reserved2))
                {
                    shop.SetFlag(global::BaseEntity.Flags.Reserved3, true, false, true);
                    shop.Invoke(new Action(shop.GetComponent<TradeBox>().CustomCompleteTrade), 2f);
                    return false;
                }
                return true;
            }
            return null;
        }

        public BasePlayer FindOnline(string nameOrUserId, ulong playerid = 294912)
        {
            nameOrUserId = nameOrUserId.ToLower();
            foreach (BasePlayer activePlayer in BasePlayer.activePlayerList)
            {
                if (activePlayer.displayName.ToLower().Contains(nameOrUserId) || activePlayer.UserIDString == nameOrUserId) return activePlayer;
            }
            return null;
        }

        [ConsoleCommand("trade")]
        void cmdTrade(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null || arg.Args.Length == 0) return;
            var name = arg.Args[0];
            CmdChatTrade(player, string.Empty, new string[] {
                name
            }
            );
        }

        [ChatCommand("trade")]
        void CmdChatTrade(BasePlayer player, string command, string[] args)
        {
            if (!config.Init) return;
            if (player == null) return;
            if (args.Length == 0 || args == null)
            {
                Reply(player, "TRADE.HELP");
                return;
            }
            if (config.mainSettings.UsePermission && !permission.UserHasPermission(player.UserIDString, config.mainSettings.Permission))
            {
                Reply(player, "DENIED.PERMISSIONON");
                return;
            }
            if (Cooldowns.ContainsKey(player))
            {
                double seconds = Cooldowns[player].Subtract(DateTime.Now).TotalSeconds;
                if (seconds >= 0)
                {
                    Reply(player, "COOLDOWN", seconds);
                    return;
                }
            }
            switch (args[0])
            {
                default:
                    if (!CanPlayerTrade(player))
                        return;
                    var name = args[0];
                    var target = FindOnline(name);
                    if (target == null)
                    {
                        Reply(player, "PLAYER.NOT.FOUND", name);
                        return;
                    }
                    if (target == player)
                    {
                        Reply(player, "TRADE.TOYOU");
                        return;
                    }
                    if (!IsTeamate(player, target))
                    {
                        Reply(player, "GET.FRIENDS", target.displayName);
                        return;
                    }
                    if (Vector3.Distance(player.transform.position, target.transform.position) < config.mainSettings.TradeDistance)
                    {
                        Reply(player, "GET.DISTANCE", target.displayName);
                        return;
                    }


                    var tradeTargetpend = pendings.Find(p => p.player == target || p.target == target);
                    if (tradeTargetpend != null)
                    {
                        Reply(player, "TRADE.TARGET.ALREADY.PENDING");
                        return;
                    }
                    if (config.mainSettings.UsePermission && !permission.UserHasPermission(target.UserIDString, config.mainSettings.Permission))
                    {
                        Reply(player, "DENIED.PERMISSIOONTARGETN", target.displayName);
                        return;
                    }
                    if (config.mainSettings.getCupSend)
                    {
                        if (!player.CanBuild())
                        {
                            Reply(player, "DENIED.PRIVILEGE");
                            return;
                        }
                    }

                    var tradepend = pendings.Find(p => p.player == player || p.target == player);
                    if (tradepend != null)
                    {
                        Reply(player, "TRADE.ALREADY.PENDING");
                        return;
                    }
                    pendings.Add(new TradePendings(player, config.mainSettings.getTime, target));
                    Reply(player, "PENDING.SENDER.FORMAT", target.displayName);
                    Reply(target, "PENDING.RECIEVER.FORMAT", player.displayName);
                    break;
                case "accept":
                case "yes":
                    if (!CanPlayerTrade(player)) return;
                    var tp = pendings.Find(p => p.player == player || p.target == player);
                    if (tp == null)
                    {
                        Reply(player, "TRADE.ACCEPT.PENDING.EMPTY");
                        return;
                    }
                    if (IsDuelPlayer(tp.target) || IsDuelPlayer(tp.player))
                    {
                        pendings.Remove(tp);
                        Reply(tp.player, "DENIED.DUEL");
                        Reply(tp.target, "DENIED.DUEL");
                        return;
                    }
                    pendings.Remove(tp);
                    TradeBox trade = TradeBox.Spawn();
                    if (trade == null) return;

                    tradeBoxes.Add(trade);
                    timer.Once(0.5f, () =>
                    {
                        if (tp.player == null || !tp.player.IsConnected) return;
                        if (tp.target == null || !tp.target.IsConnected) return;
                        trade.StartLoot(tp.player, tp.target);
                    });
                    break;
                case "cancel":
                case "no":
                    var pend = pendings.Find(p => p.player == player || p.target == player);
                    if (pend == null)
                    {
                        Reply(player, "TRADE.ACCEPT.PENDING.EMPTY");
                        return;
                    }
                    pendings.Remove(pend);

                    if (pend.player.IsConnected) Reply(pend.player, "PENDING.CANCEL.SENDER", player.displayName);
                    Reply(pend.target, "TRADE.CANCELED");
                    break;
            }
        }

        public class TradeBox : MonoBehaviour
        {
            public ShopFront shopFront;
            public BasePlayer player1, player2;

            void Awake()
            {
                shopFront = gameObject.GetComponent<ShopFront>();
                enabled = false;
            }

            public static TradeBox Spawn()
            {
                var storage = SpawnContainer(new Vector3());
                var box = storage.gameObject.AddComponent<TradeBox>();
                return box;
            }

            private static ShopFront SpawnContainer(Vector3 position)
            {
                ShopFront shopFront = GameManager.server.CreateEntity("assets/prefabs/building/wall.frame.shopfront/wall.frame.shopfront.metal.prefab", position, new Quaternion(), true) as ShopFront;
                if (shopFront == null) return null;
                shopFront.Spawn();
                shopFront.vendorInventory.capacity = 1;
                shopFront.customerInventory.capacity = 1;
                UnityEngine.Object.Destroy(shopFront.GetComponent<DestroyOnGroundMissing>());
                UnityEngine.Object.Destroy(shopFront.GetComponent<GroundWatch>());
                return shopFront;
            }

            public void StartLoot(BasePlayer player, BasePlayer target)
            {
                if (player == null || target == null)
                {
                    Destroy(this);
                    return;
                }
                player1 = player;
                player2 = target;
                shopFront.vendorInventory.capacity = ins.GetTradeSize(player.UserIDString);
                shopFront.customerInventory.capacity = ins.GetTradeSize(target.UserIDString);
                player.EndLooting();
                target.EndLooting();
                shopFront.vendorPlayer = player1;
                shopFront.customerPlayer = player2;
                if (!player1.net.subscriber.IsSubscribed(shopFront.net.group))
                    player1.net.subscriber.Subscribe(shopFront.net.group);
                if (!player2.net.subscriber.IsSubscribed(shopFront.net.group))
                    player2.net.subscriber.Subscribe(shopFront.net.group);
                SendEntity(player1, (BaseEntity)shopFront);
                SendEntity(player2, (BaseEntity)shopFront);
                SendEntity(player1, (BaseEntity)player2);
                SendEntity(player2, (BaseEntity)player1);
                StartLooting(player1);
                StartLooting(player2);
                shopFront.ResetTrade();
                shopFront.UpdatePlayers();
                enabled = true;

            }

            public void SendEntity(BasePlayer a, BaseEntity b, string reason = "⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠")
            {
                if (Net.sv.write.Start())
                {
                    a.net.connection.validate.entityUpdates++;
                    BaseNetworkable.SaveInfo c = new BaseNetworkable.SaveInfo
                    {
                        forConnection = a.net.connection,
                        forDisk = false
                    }
                    ;
                    Net.sv.write.PacketID(Message.Type.Entities);
                    Net.sv.write.UInt32(a.net.connection.validate.entityUpdates);
                    b.ToStreamForNetwork(Net.sv.write, c);
                    Net.sv.write.Send(new SendInfo(a.net.connection));
                }
            }

            public void StartLooting(BasePlayer player)
            {
                player.inventory.loot.StartLootingEntity(shopFront, false);
                player.inventory.loot.AddContainer(shopFront.vendorInventory);
                player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel", shopFront.panelName);
                shopFront.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                player.inventory.loot.AddContainer(shopFront.customerInventory);
                player.inventory.loot.SendImmediate();
            }

            public void PlayerStoppedLooting(BasePlayer player) => Destroy(this);

            public void OnDestroy()
            {
                if (player1 != null)
                    player1.EndLooting();
                if (player2 != null)
                    player2.EndLooting();
                if (shopFront != null && !shopFront.IsDestroyed)
                    shopFront.Kill();
            }

            void FixedUpdate()
            {
                if (!player1.net.subscriber.IsSubscribed(shopFront.net.group))
                {
                    SendEntity(player1, shopFront);
                    SendEntity(player1, player2);
                    player1.net.subscriber.Subscribe(shopFront.net.group);
                    shopFront.UpdatePlayers();
                }
                if (!player2.net.subscriber.IsSubscribed(shopFront.net.group))
                {
                    SendEntity(player2, shopFront);
                    SendEntity(player2, player1);
                    player2.net.subscriber.Subscribe(shopFront.net.group);
                    shopFront.UpdatePlayers();
                }
            }


            public void CustomCompleteTrade()
            {
                if (shopFront.vendorPlayer != null && shopFront.customerPlayer != null && shopFront.HasFlag(global::BaseEntity.Flags.Reserved1) && shopFront.HasFlag(global::BaseEntity.Flags.Reserved2))
                {
                    for (int i = shopFront.vendorInventory.capacity - 1; i >= 0; i--)
                    {
                        Item slot = shopFront.vendorInventory.GetSlot(i);
                        Item slot2 = shopFront.customerInventory.GetSlot(i);
                        if (shopFront.customerPlayer && slot != null)
                        {
                            player2.GiveItem(slot, global::BaseEntity.GiveItemReason.Generic);
                        }
                        if (shopFront.vendorPlayer && slot2 != null)
                        {
                            player1.GiveItem(slot2, global::BaseEntity.GiveItemReason.Generic);
                        }
                    }
                    global::Effect.server.Run(shopFront.transactionCompleteEffect.resourcePath, player1, 0u, new Vector3(0f, 1f, 0f), Vector3.zero, null, false);
                    global::Effect.server.Run(shopFront.transactionCompleteEffect.resourcePath, player2, 0u, new Vector3(0f, 1f, 0f), Vector3.zero, null, false);
                    ins.Reply(player1, "TRADE.SUCCESS");
                    ins.Reply(player2, "TRADE.SUCCESS");
                    ins.Cooldowns[player1] = DateTime.Now.AddSeconds(ins.GetPlayerCooldown(player1.UserIDString));
                    ins.Cooldowns[player2] = DateTime.Now.AddSeconds(ins.GetPlayerCooldown(player2.UserIDString));
                    ins.tradeBoxes.Remove(this);
                    Destroy(this);
                }
            }
        }

        bool PlayerGetActiveTrade(BasePlayer player)
        {
            var contains = pendings.Find(p => p.target == player);
            return contains != null;
        }
    }
}

// --- End of file: Trade.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HudRust/StacksExtended.cs ---
// --- Original Local Path: HudRust/StacksExtended.cs ---

using System; 
using System.Text; 
using System.Collections.Generic; 
using System.Linq; 
using UnityEngine;  

namespace Oxide.Plugins 
{ 
    [Info("StacksExtended", "Fujikura", "1.0.2", ResourceId = 35)] 
	
	class StacksExtended : RustPlugin 
	{ 
	
		bool Changed = false; 
		bool _loaded = false;  
	
		List<string> itemCategories = new List<string> (); 
		List<object> itemStackExcludes = new List<object>(); 
		Dictionary<string, List<string>> registeredPermissions = new Dictionary<string, List<string>> (); 
		Dictionary<string,object> containerStacks = new Dictionary<string,object>(); 
		Dictionary<string,object> containerVIP = new Dictionary<string,object>(); 
	
		bool clearOnReboot; 
		int commandsAuthLevel; 
		bool limitPlayerInventory;
		int playerInventoryStacklimit;  
		
		static List<object> defaultItemExcludes() 
		{
			var dp = new List<object>(); 
				dp.Add("water"); 
				dp.Add("water.salt"); 
				dp.Add("blood"); 
				dp.Add("blueprintbase"); 
				dp.Add("coal"); 
				dp.Add("flare"); 
				dp.Add("ammo.rocket.smoke"); 
				dp.Add("generator.wind.scrap"); 
				dp.Add("battery.small"); 
				dp.Add("mining.pumpjack"); 
				dp.Add("building.planner"); 
				dp.Add("door.key"); 
				dp.Add("map"); 
				dp.Add("note"); 
			return dp; 
		}  
		
		object GetConfig(string menu, string datavalue, object defaultValue) 
		{
			var data = Config[menu] as Dictionary<string, object>; 
			
			if (data == null) 
			{
				data = new Dictionary<string, object>(); 
				Config[menu] = data; 
				Changed = true; 
			} 
			
			object value; 
			
			if (!data.TryGetValue(datavalue, out value)) 
			{
				value = defaultValue; 
				data[datavalue] = value; 
				Changed = true; 
			} 
			return value; 
		}  
		void LoadVariables() 
		{
			itemStackExcludes = (List<object>)GetConfig("Settings", "ExcludedItems", defaultItemExcludes()); 
			
			containerStacks = (Dictionary<string, object>)GetConfig("Storages", "Stack", new Dictionary<string, object>()); 
			containerVIP = (Dictionary<string, object>)GetConfig("Storages", "VIP", new Dictionary<string, object>()); 
			clearOnReboot = Convert.ToBoolean(GetConfig("Settings", "clearOnReboot", false)); 
			commandsAuthLevel = Convert.ToInt32(GetConfig("Settings", "commandsAuthLevel", 2)); 
			limitPlayerInventory = Convert.ToBoolean(GetConfig("Settings", "limitPlayerInventory", false)); playerInventoryStacklimit =  Convert.ToInt32(GetConfig("Settings", "playerInventoryStacklimit", 0));  
			
			if (!Changed) 
				return; 
				
			SaveConfig(); 
			Changed = false; 
		}  
		protected override void LoadDefaultConfig() 
		{
			Config.Clear(); 
			LoadVariables(); 
		}  
		void Init() 
		{ 
			LoadVariables(); 
		}  
		void OnTerrainInitialized() 
		{
			_loaded = true; 
		}  
		void OnServerInitialized() 
		{
			var storages = Resources.FindObjectsOfTypeAll<StorageContainer>().Where(c => !c.isActiveAndEnabled && !c.GetComponent<LootContainer>()).Cast<BaseEntity>().Where(b => !b.ShortPrefabName.Contains("_static")).ToList(); 
			
			if (containerVIP == null || containerVIP.Count == 0) 
				CreateContainerVIP(storages); 
			if (containerStacks == null || containerStacks.Count == 0) 
				CreateContainerStacks(storages); 
			if(Config.Get("StackLimits") != null) 
			{
				if (clearOnReboot && _loaded) 
				{
					CreateContainerStacks(storages); 
					Config["Storages", "Stack"] = containerStacks; 
					StackDefaults(); 
				} 
				else StackLoad(); 
			} 
			else 
			{
				StackDefaults(); 
			} 
			
			CreatePermissions(); 
			UpdateContainerStacks(); 
			UpdateQuarryVIP(); 
			
			if (limitPlayerInventory && playerInventoryStacklimit >= 0) 
			{
				foreach(var player in BasePlayer.activePlayerList) UpdatePlayer(player); 
				foreach(var player in BasePlayer.sleepingPlayerList) UpdatePlayer(player); 
			} 
			
			storages.Clear();
		}  
		void OnEntityBuilt(Planner planner, GameObject obj) 
		{
			if (planner == null || planner.GetOwnerPlayer() == null || obj.GetComponent<BaseEntity>() == null || obj.GetComponent<BaseEntity>().OwnerID == 0) 
				return; 
			if (obj.GetComponent<BaseEntity>() is MiningQuarry) 
			{
				OnQuarryBuilt(planner, obj); 
				return; 
			} 
			
			BaseEntity entity = obj.GetComponent<BaseEntity>(); 
			BasePlayer player = planner.GetOwnerPlayer(); 
			
			if (player == null) 
				return; 
				
			var name = entity.ShortPrefabName.Replace(".deployed","").Replace("_deployed",""); 
			
			object containerLimit; 
			
			if (containerStacks.TryGetValue(name, out containerLimit)) 
			{
				if (entity.GetComponent<StorageContainer>().inventory.maxStackSize != (int)containerLimit) 
				{
					entity.GetComponent<StorageContainer>().inventory.maxStackSize = (int)containerLimit; 
					entity.SendNetworkUpdate(); 
				} 
				if (entity.OwnerID != 0) 
				{
					object containerPerms; 
				
					if (containerVIP.TryGetValue(name, out containerPerms)) 
					{
						var perms = (Dictionary<string, object>)containerPerms; 
						
						if (!(bool)perms["Enabled"]) 
							return; 
							
						foreach (var perm in ((Dictionary<string, object>)perms["Permissions"]).Reverse()) 
						{
							if ((int)containerLimit > 0 && (int)perm.Value >= 0 && (int)perm.Value > (int)containerLimit && permission.UserHasPermission(entity.OwnerID.ToString(), this.Title.ToLower()+"."+perm.Key)) 
							{
								entity.GetComponent<StorageContainer>().inventory.maxStackSize = (int)perm.Value; 
								entity.SendNetworkUpdate(); 		
							} 		
						} 		
					} 
				} 
			} 
		}  
		void OnQuarryBuilt(Planner planner, GameObject obj) 
		{
			BaseEntity entity = obj.GetComponent<BaseEntity>(); 
			BasePlayer player = planner.GetOwnerPlayer(); 
			
			if (player == null) 
				return; 
				
			var hopper = (entity as MiningQuarry).hopperPrefab.instance; 
			
			object hopperLimit; 
			
			if (containerStacks.TryGetValue(hopper.ShortPrefabName, out hopperLimit)) 
			{
				if (hopper.GetComponent<StorageContainer>().inventory.maxStackSize != (int)hopperLimit) 
				{
					hopper.GetComponent<StorageContainer>().inventory.maxStackSize = (int)hopperLimit; 
					hopper.SendNetworkUpdate(); 
				} 
			} 
			
			object hopperPerms; 
			
			if (containerVIP.TryGetValue(hopper.ShortPrefabName, out hopperPerms)) 
			{
				var perms = (Dictionary<string, object>)hopperPerms; 
				
				if (!(bool)perms["Enabled"]) 
					return; 
					
				foreach (var perm in ((Dictionary<string, object>)perms["Permissions"]).Reverse()) 
				{
					if ((int)hopperLimit > 0 && (int)perm.Value >= 0 && (int)perm.Value > (int)hopperLimit && permission.UserHasPermission(entity.OwnerID.ToString(), this.Title.ToLower()+"."+perm.Key)) 
					{
						hopper.GetComponent<StorageContainer>().inventory.maxStackSize = (int)perm.Value; 
						hopper.SendNetworkUpdate(); 
					} 
				} 
			} 
			
			var fuelstorage = (entity as MiningQuarry).fuelStoragePrefab.instance; 
			
			object fuelstorageLimit; 
			
			if (containerStacks.TryGetValue(fuelstorage.ShortPrefabName, out fuelstorageLimit)) 
			{
				if (fuelstorage.GetComponent<StorageContainer>().inventory.maxStackSize != (int)fuelstorageLimit) 
				{
					fuelstorage.GetComponent<StorageContainer>().inventory.maxStackSize = (int)fuelstorageLimit; 
					fuelstorage.SendNetworkUpdate(); 
				} 
			} 
			
			object fuelstoragePerms; 
			
			if (containerVIP.TryGetValue(fuelstorage.ShortPrefabName, out fuelstoragePerms)) 
			{
				var perms = (Dictionary<string, object>)fuelstoragePerms; 
				
				if (!(bool)perms["Enabled"]) 
					return; 
					
				foreach (var perm in ((Dictionary<string, object>)perms["Permissions"]).Reverse()) 
				{
					if ((int)fuelstorageLimit > 0 && (int)perm.Value >= 0 && (int)perm.Value > (int)fuelstorageLimit && permission.UserHasPermission(entity.OwnerID.ToString(), this.Title.ToLower()+"."+perm.Key)) 
					{
						fuelstorage.GetComponent<StorageContainer>().inventory.maxStackSize = (int)perm.Value; 
						fuelstorage.SendNetworkUpdate(); 		
					}
				} 		
			} 
		} 
		void UpdatePlayer(BasePlayer player) 
		{
			player.inventory.containerMain.maxStackSize = (int)playerInventoryStacklimit; 
			player.inventory.containerBelt.maxStackSize = (int)playerInventoryStacklimit; 
			player.inventory.SendSnapshot();
		}  
		void OnPlayerRespawned(BasePlayer player) 
		{
			if (player != null && limitPlayerInventory && playerInventoryStacklimit >= 0) 
				UpdatePlayer(player); 
		}  
		void OnPlayerInit(BasePlayer player) 
		{
			if (player != null && limitPlayerInventory && playerInventoryStacklimit >= 0) 
				UpdatePlayer(player); 
		}  
		void CreateContainerVIP(List<BaseEntity> storages) 
		{
			containerVIP = new Dictionary<string, object>(); 
			
			foreach (var storage in storages) 
			{
				var name = storage.ShortPrefabName.Replace(".deployed","").Replace("_deployed",""); 
				
				if (containerVIP.ContainsKey(name)) 
					continue; 
					
				var dp = new Dictionary<string, object>(); 
					dp.Add("Enabled", false); 
					dp.Add("Permissions", new Dictionary<string, object>() {{"vip1",0}, {"vip2",0}, {"vip3",0}} ); 
					
				containerVIP.Add(name, dp); 
			} 
			
			Config["Storages", "VIP"] = containerVIP; 
			SaveConfig(); 
		}  
		void CreateContainerStacks(List<BaseEntity> storages) 
		{
			containerStacks = new Dictionary<string, object>(); 
			
			foreach (var storage in storages) 
			{
				var name = storage.ShortPrefabName.Replace(".deployed","").Replace("_deployed",""); 
				
				if (containerStacks.ContainsKey(name)) 
					continue; 
					
				containerStacks.Add(name, storage.GetComponent<StorageContainer>().maxStackSize); 
			} 
			
			Config["Storages", "Stack"] = containerStacks; 
			SaveConfig(); 
		}  
		void CreatePermissions() 
		{
			foreach (var permSet in containerVIP) 
			{
				var perms = (Dictionary<string, object>)permSet.Value; 
				
				if ((bool)perms["Enabled"]) 
				{
					foreach (var perm in ((Dictionary<string, object>)perms["Permissions"])) 
					{
						if (!registeredPermissions.ContainsKey(this.Title.ToLower()+"."+perm.Key)) 
							registeredPermissions.Add(this.Title.ToLower()+"."+perm.Key, new List<string>()); 
						if (!registeredPermissions[this.Title.ToLower()+"."+perm.Key].Contains(permSet.Key)) 
							registeredPermissions[this.Title.ToLower()+"."+perm.Key].Add(permSet.Key); 
						if (!permission.PermissionExists(this.Title.ToLower()+"."+perm.Key)) 
							permission.RegisterPermission(this.Title.ToLower()+"."+perm.Key, this); 
					} 		
				} 		
			} 		
		}  
		
		Dictionary<string, int> UpdateContainerStacks() 
		{
			var entities = BaseNetworkable.serverEntities.Where(p => (p as BaseEntity).GetComponent<StorageContainer>() != null && (p as BaseEntity).GetComponent<LootContainer>() == null).Cast<BaseEntity>().ToList(); 
			var counter = 0; 
			var vipcounter = 0; 
			var dp = new Dictionary<string, int>(); 
			
			foreach (var entity in entities) 
			{
				var name = entity.ShortPrefabName.Replace(".deployed","").Replace("_deployed",""); 
				
				object containerLimit; 
				
				if (containerStacks.TryGetValue(name, out containerLimit)) 
				{
					if (entity.GetComponent<StorageContainer>().inventory.maxStackSize != (int)containerLimit) 
					{
						entity.GetComponent<StorageContainer>().inventory.maxStackSize = (int)containerLimit; 
						counter++; 
						entity.SendNetworkUpdate(); 
					} 
					if (entity.OwnerID != 0) 
					{
						object containerPerms; 
						
						if (containerVIP.TryGetValue(name, out containerPerms)) 
						{
							var perms = (Dictionary<string, object>)containerPerms; 
							
							if ((bool)perms["Enabled"]) 
							{
								foreach (var perm in ((Dictionary<string, object>)perms["Permissions"]).Reverse()) 
								{
									if ((int)containerLimit > 0 && (int)perm.Value >= 0 && (int)perm.Value > (int)containerLimit && permission.UserHasPermission(entity.OwnerID.ToString(), this.Title.ToLower()+"."+perm.Key)) 
									{
										entity.GetComponent<StorageContainer>().inventory.maxStackSize = (int)perm.Value; 
										vipcounter++; 
										entity.SendNetworkUpdate(); 			
									} 			
								} 			
							} 
						} 			
					} 				
				} 			
			} 
			
			dp.Add("counter", counter); 
			dp.Add("vipcounter", vipcounter); 
			return dp; 
		}  
		
		Dictionary<string, int> UpdateQuarryVIP() 
		{
			var entities = BaseNetworkable.serverEntities.Where(p => (p as BaseEntity) is MiningQuarry).Cast<BaseEntity>().ToList(); 
			var hoppercounter = 0; 
			var fuelstoragecounter = 0; 
			var dp = new Dictionary<string, int>(); 
			
			foreach (var entity in entities) 
			{
				if (entity.OwnerID == 0) 
					continue; 
					
				var hopper = (entity as MiningQuarry).hopperPrefab.instance; 
				
				object hopperPerms; 
				
				if (containerVIP.TryGetValue(hopper.ShortPrefabName, out hopperPerms)) 
				{
					var perms = (Dictionary<string, object>)hopperPerms; 
					
					if ((bool)perms["Enabled"]) 
					{
						foreach (var perm in ((Dictionary<string, object>)perms["Permissions"]).Reverse()) 
						{
							object containerLimit; 
							
							containerStacks.TryGetValue(hopper.ShortPrefabName, out containerLimit); 
							
							if ((int)containerLimit > 0 && (int)perm.Value >= 0 && (int)perm.Value > (int)containerLimit && permission.UserHasPermission(entity.OwnerID.ToString(), this.Title.ToLower()+"."+perm.Key)) 
							{
								hopper.GetComponent<StorageContainer>().inventory.maxStackSize = (int)perm.Value; 
								hoppercounter++; 
								hopper.SendNetworkUpdate(); 
							} 
						} 
					} 
				} 
				
				var fuelstorage = (entity as MiningQuarry).fuelStoragePrefab.instance; 
				
				object fuelstoragePerms; 
				
				if (containerVIP.TryGetValue(fuelstorage.ShortPrefabName, out fuelstoragePerms)) 
				{
					var perms = (Dictionary<string, object>)fuelstoragePerms; 
					
					if ((bool)perms["Enabled"]) 
					{
						foreach (var perm in ((Dictionary<string, object>)perms["Permissions"]).Reverse()) 
						{
							object containerLimit; 
							
							containerStacks.TryGetValue(fuelstorage.ShortPrefabName, out containerLimit); 
							
							if ((int)containerLimit > 0 && (int)perm.Value >= 0 && (int)perm.Value > (int)containerLimit && permission.UserHasPermission(entity.OwnerID.ToString(), this.Title.ToLower()+"."+perm.Key)) 
							{
								fuelstorage.GetComponent<StorageContainer>().inventory.maxStackSize = (int)perm.Value; 
								fuelstoragecounter++;
								fuelstorage.SendNetworkUpdate(); 				
							}				
						}
					} 
				} 
			} 
			
			dp.Add("hoppercounter", hoppercounter); 
			dp.Add("fuelstoragecounter", fuelstoragecounter); 
			return dp; 
		}  
		void StackDefaults() 
		{			
			NextTick(() => 
			{
				var itemList = ItemManager.itemList;
				
				if (itemList == null || itemList.Count == 0) 
				{
					NextTick(StackDefaults); 
					return; 
				} 
				if (clearOnReboot && _loaded) 
				{
					clearOnReboot = false; 
					Config["Settings", "clearOnReboot"] = false; 
					Config.Save(); 
					Puts($"Forced stacksizes reset..."); 
				} 
				int i = 0; 
				
				foreach (var item in itemList) 
				{
					if (item.condition.enabled && item.condition.max > 0 && item.GetComponent<ItemModDeployable>() == null) 
						continue; 
					if (itemStackExcludes.Contains(item.shortname)) 
						continue; 
						
					Config["StackLimits", item.shortname] = item.stackable; 
					
					if (!itemCategories.Contains(item.category.ToString().ToLower())) 
						itemCategories.Add(item.category.ToString().ToLower()); 
					
					i++; 
				} 
				
				Config.Save(); 
				Puts($"Created stacksize file with '{i}' items"); 
			}); 
		}  
		void StackLoad() 
		{
			bool dirty = false; 
			bool changed = false; 
			
			var itemList = ItemManager.itemList; 
			
			if (itemList == null || itemList.Count == 0) 
			{
				NextTick(StackDefaults); 
				return; 
			} 
			int c = 0; 
			
			foreach (var item in itemList) 
			{
				if (itemStackExcludes.Contains(item.shortname)) 
					continue; 
				if (item.condition.max > 0 && item.GetComponent<ItemModDeployable>() == null) 
					continue; 
				if (Config["StackLimits", item.shortname] == null) 
				{
					Config["StackLimits", item.shortname] = item.stackable; 
					dirty = true; 
				} 
				if (item.stackable != (int)Config["StackLimits", item.shortname]) 
				{
					changed = true; 
					c++; 
				} 
				
				item.stackable = (int)Config["StackLimits", item.shortname]; 
				
				if (item.GetComponent<ItemModDeployable>() != null) 
					item.condition.enabled = false; 
				if (!itemCategories.Contains(item.category.ToString().ToLower())) 
					itemCategories.Add(item.category.ToString().ToLower()); 
			} 
			
			if (changed && !_loaded) 
				Puts($"Changed '{c}' stacks with new values"); 
			if (!changed && !dirty) 
				Puts("No stacksize changed"); 
			if (dirty) 
				Puts("Updated stacksize file with new items"); 
			if (dirty) 
				Config.Save(); 
		}  
		[ConsoleCommand("se.reload")] 
		void ccmdReload(ConsoleSystem.Arg arg) 
		{
			if(arg.Connection != null && arg.Connection.authLevel < commandsAuthLevel) 
				return; 
				
			LoadConfig(); 
			LoadVariables(); 
			NextTick(()=> 
			{
				var storages = Resources.FindObjectsOfTypeAll<StorageContainer>().Where(c => !c.isActiveAndEnabled && !c.GetComponent<LootContainer>()).Cast<BaseEntity>().Where(b => !b.ShortPrefabName.Contains("_static")).ToList(); 
				
				if (containerVIP == null || containerVIP.Count == 0) 
					CreateContainerVIP(storages); 
				if (containerStacks == null || containerStacks.Count == 0) 
					CreateContainerStacks(storages); 
					
				storages.Clear(); 
				
				if (limitPlayerInventory && playerInventoryStacklimit > 0) 
				{
					foreach(var player in BasePlayer.activePlayerList) UpdatePlayer(player); 
					foreach(var player in BasePlayer.sleepingPlayerList) UpdatePlayer(player); 
				} 
				
				StackLoad(); 
				registeredPermissions.Clear(); 
				CreatePermissions(); 
				
				var containerUpdates = UpdateContainerStacks(); 
				var quarryUpdates = UpdateQuarryVIP(); 
				
				SendReply(arg, $"Config reloaded and {containerUpdates["counter"]} Storages updated"); 
				SendReply(arg, $"VIP Changes > {containerUpdates["vipcounter"]} Storages | {quarryUpdates["hoppercounter"]} Quarry Output | {quarryUpdates["fuelstoragecounter"]} Quarry Fuel"); 
			}); 
		}  
		[ConsoleCommand("se.clearreload")] 
		private void ccmdStackReload(ConsoleSystem.Arg arg) 
		{
			if(arg.Connection != null && arg.Connection.authLevel < commandsAuthLevel) 
				return; 
			
			Config["Settings", "clearOnReboot"] = true; 
			Config.Save(); 
			SendReply(arg, $"Your stack and container limits will be reverted to the defaults on next startup"); 
		}  
		[ConsoleCommand("se.stackcategory")] 
		void ccmdStackCategory(ConsoleSystem.Arg arg) 
		{
			if(arg.Connection != null && arg.Connection.authLevel < commandsAuthLevel) 
				return; 
				
			bool noInput = false; 
			
			if (arg.Args == null || arg.Args.Length != 2) 
			{
				SendReply(arg, "Syntax Error: Requires 2 arguments. Example: resources 32000"); 
				noInput = true; 
			} 
			if (arg.Args != null && arg.Args.Length > 1 && arg.Args[0].ToLower() != "all") 
				foreach (var cat in itemCategories) 
				{
					if (cat.StartsWith(arg.Args[0].ToLower())) 
					{
						arg.Args[0] = cat; 
						break; 
					} 
				} 
			if (noInput || (arg.Args[0].ToLower() != "all" && !itemCategories.Contains(arg.Args[0].ToLower()))) 
			{
				string cats = ""; 
				
				foreach (var cat in itemCategories) 
				{
					cats += cat+" ";
				} 
				
				if (!noInput) 
					SendReply(arg, $"Category '{arg?.Args[0]}' not found"); 
					
					SendReply(arg, $"Categories: {cats}all"); 
				return; 
			} 
			
			int i = 0; 
			
			var itemList = ItemManager.itemList; 
			
			foreach (var item in itemList) 
			{
				if(arg.Args[0].ToLower() != "all" && item.category.ToString().ToLower() != arg.Args[0].ToLower()) 
					continue; 
				if (Config["StackLimits", item.shortname] == null) 
					continue; 
				if (itemStackExcludes.Contains(item.shortname)) 
					continue;  
					
				Config["StackLimits", item.shortname] = Convert.ToInt32(arg.Args[1]); 
				item.stackable = Convert.ToInt32(arg.Args[1]); 
				i++; 
			}
			
			Config.Save(); 
			SendReply(arg, $"The Stack Size of '{i}' stackable '{arg.Args[0]}' items has been set to '{arg.Args[1]}'"); 
		} 
		[ConsoleCommand("se.stackitem")] 
		void ccmdStackItem(ConsoleSystem.Arg arg) 
		{
			if(arg.Connection != null && arg.Connection.authLevel < commandsAuthLevel) 
				return; 
				
			bool noInput = false; 
			
			if (arg.Args == null || arg.Args.Length != 2) 
			{
				SendReply(arg, "Syntax Error: Requires 2 arguments (shortname + number). Example: wood 32000"); 
				return; 
			} 
			
			var itemDef = ItemManager.FindItemDefinition(arg.Args[0].ToLower()); 
			
			if (itemDef == null) 
			{
				SendReply(arg, $"Item '{arg.Args[0]}' does not exist"); 
				return; 
			} 
			if (itemStackExcludes.Contains(itemDef.shortname))
			{
				SendReply(arg, $"The provided item is excluded from stacking by the config"); 
				return;
			} 
			
			int limit = -1; 
			
			if (!int.TryParse(arg.Args[1], out limit)) 
			{
				SendReply(arg, $"You need to set any number greater then 0"); 
				return; 
			} 
			else 
				itemDef.stackable = limit; 
				
			Config["StackLimits", itemDef.shortname] = limit; 
			Config.Save(); 
			SendReply(arg, $"The stacksize of '{arg.Args[0]}' has been set to '{limit}'"); 
		}  
		[ConsoleCommand("se.listcategory")] 
		void ccmdListCategory(ConsoleSystem.Arg arg) 
		{
			if(arg.Connection != null && arg.Connection.authLevel < commandsAuthLevel) 
				return; 
				
			string cats = ""; 
			
			if (arg.Args == null || arg.Args.Length != 1) 
			{
				SendReply(arg, "Syntax Error: Requires 1 argument. Example: resources"); 
				
				foreach (var cat in itemCategories) 
				{
					cats += cat+" ";
				} 
				
				SendReply(arg, $"Categories are: {cats}all"); 
				return; 
			} 
			
			foreach (var cat in itemCategories) 
			{
				if (cat.StartsWith(arg.Args[0].ToLower())) 
				{
					arg.Args[0] = cat; 
					break; 
				} 
			} 
			if (!itemCategories.Contains(arg.Args[0].ToLower())) 
			{
				SendReply(arg, $"Category '{arg?.Args[0]}' not found"); 
				
				foreach (var cat in itemCategories) 
				{
					cats += cat+" ";
				} 
				
				SendReply(arg, $"Categories: {cats}all"); 
				return; 
			} 
			
			TextTable textTable = new TextTable(); 
				textTable.AddColumn("Shortname"); 
				textTable.AddColumn("DisplayName"); 
				textTable.AddColumn("StackSize"); 
			
			var sb = new StringBuilder(); 
				sb.AppendLine($"\n === Stacksizes for category '{arg.Args[0]}':\n"); 
			
			foreach (var item in ItemManager.GetItemDefinitions()) 
			{
				if (itemStackExcludes.Contains(item.shortname)) 
					continue; 
				if (item.category.ToString().ToLower() != arg.Args[0].ToLower()) 
					continue; 
					
				textTable.AddRow(new string[] 
				{
					item.shortname, 
					item.displayName.english, 
					item.stackable.ToString() 
				}); 
			} 
			
			sb.AppendLine(textTable.ToString()); 
			SendReply(arg, sb.ToString()); 
		}  
		[ConsoleCommand("se.permissions")] 
		void ccmdListPerms(ConsoleSystem.Arg arg) 
		{
			if(arg.Connection != null && arg.Connection.authLevel < commandsAuthLevel) 	
				return; 
				
			TextTable textTable = new TextTable(); 
				textTable.AddColumn("Permission"); 
				textTable.AddColumn("Containers"); 
				
			foreach (var perm in registeredPermissions) 
			{
				string perms = string.Empty; 
				
				foreach ( var cont in perm.Value) 
				{
					perms += cont+"("+(int)((containerVIP[cont] as Dictionary<string,object>)["Permissions"] as Dictionary<string,object>)[perm.Key.Replace(this.Title.ToLower()+".","")]+") "; 
				} 
				
				textTable.AddRow(new string[] { perm.Key.ToString(), perms }); 
			} 
			
			SendReply(arg, "\n"+textTable.ToString()); 
		} 
	} 
}

// --- End of file: StacksExtended.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HudRust/CopyPaste.cs ---
// --- Original Local Path: HudRust/CopyPaste.cs ---

﻿//If debug is defined it will add a stopwatch to the paste and copydata which can be used to profile copying and pasting.
//#define DEBUG

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Drawing;
using System.Drawing.Imaging;
using System.IO;
using System.Linq;
using Facepunch;
using Newtonsoft.Json;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using Graphics = System.Drawing.Graphics;

/*
 * CREDITS
 *
 * Orange - Saving ContainerIOEntity
 * UIP88 - Turrets fix
 * bsdinis - Wire fix
 * nivex - Ownership option, sign fix
 * DezLife - CCTV fix
 * 
 */

namespace Oxide.Plugins
{
    [Info("Copy Paste", "misticos", "4.1.27")] // Wulf skipped 24 :(
    [Description("Copy and paste buildings to save them or move them")]
    public class CopyPaste : RustPlugin
    {
        private int _copyLayer =
                LayerMask.GetMask("Construction", "Prevent Building", "Construction Trigger", "Trigger", "Deployed",
                    "Default", "Ragdoll"),
            _groundLayer = LayerMask.GetMask("Terrain", "Default"),
            _rayCopy = LayerMask.GetMask("Construction", "Deployed", "Tree", "Resource", "Prevent Building"),
            _rayPaste = LayerMask.GetMask("Construction", "Deployed", "Tree", "Terrain", "World", "Water",
                "Prevent Building");

        private string _copyPermission = "copypaste.copy",
            _listPermission = "copypaste.list",
            _pastePermission = "copypaste.paste",
            _pastebackPermission = "copypaste.pasteback",
            _undoPermission = "copypaste.undo",
            _serverId = "Server",
            _subDirectory = "copypaste/";

        private Dictionary<string, Stack<List<BaseEntity>>> _lastPastes =
            new Dictionary<string, Stack<List<BaseEntity>>>();

        private Dictionary<string, SignSize> _signSizes = new Dictionary<string, SignSize>
        {
            //{"spinner.wheel.deployed", new SignSize(512, 512)},
            {"sign.pictureframe.landscape", new SignSize(256, 128)},
            {"sign.pictureframe.tall", new SignSize(128, 512)},
            {"sign.pictureframe.portrait", new SignSize(128, 256)},
            {"sign.pictureframe.xxl", new SignSize(1024, 512)},
            {"sign.pictureframe.xl", new SignSize(512, 512)},
            {"sign.small.wood", new SignSize(128, 64)},
            {"sign.medium.wood", new SignSize(256, 128)},
            {"sign.large.wood", new SignSize(256, 128)},
            {"sign.huge.wood", new SignSize(512, 128)},
            {"sign.hanging.banner.large", new SignSize(64, 256)},
            {"sign.pole.banner.large", new SignSize(64, 256)},
            {"sign.post.single", new SignSize(128, 64)},
            {"sign.post.double", new SignSize(256, 256)},
            {"sign.post.town", new SignSize(256, 128)},
            {"sign.post.town.roof", new SignSize(256, 128)},
            {"sign.hanging", new SignSize(128, 256)},
            {"sign.hanging.ornate", new SignSize(256, 128)},
            {"sign.neon.xl.animated", new SignSize(250, 250)},
            {"sign.neon.xl", new SignSize(250, 250)},
            {"sign.neon.125x215.animated", new SignSize(215, 125)},
            {"sign.neon.125x215", new SignSize(215, 125)},
            {"sign.neon.125x125", new SignSize(125, 125)},
        };

        private List<BaseEntity.Slot> _checkSlots = new List<BaseEntity.Slot>
        {
            BaseEntity.Slot.Lock,
            BaseEntity.Slot.UpperModifier,
            BaseEntity.Slot.MiddleModifier,
            BaseEntity.Slot.LowerModifier
        };

        public enum CopyMechanics
        {
            Building,
            Proximity
        }

        private class SignSize
        {
            public int Width;
            public int Height;

            public SignSize(int width, int height)
            {
                Width = width;
                Height = height;
            }
        }

        //Config

        private ConfigData _config;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Copy Options")]
            public CopyOptions Copy { get; set; }

            [JsonProperty(PropertyName = "Paste Options")]
            public PasteOptions Paste { get; set; }

            [JsonProperty(PropertyName =
                "Amount of entities to paste per batch. Use to tweak performance impact of pasting")]
            [DefaultValue(15)]
            public int PasteBatchSize = 15;

            [JsonProperty(PropertyName =
                "Amount of entities to copy per batch. Use to tweak performance impact of copying")]
            [DefaultValue(100)]
            public int CopyBatchSize = 100;

            [JsonProperty(PropertyName =
                "Amount of entities to undo per batch. Use to tweak performance impact of undoing")]
            [DefaultValue(15)]
            public int UndoBatchSize = 15;

            [JsonProperty(PropertyName = "Enable data saving feature")]
            [DefaultValue(true)]
            public bool DataSaving = true;

            public class CopyOptions
            {
                [JsonProperty(PropertyName = "Check radius from each entity (true/false)")]
                [DefaultValue(true)]
                public bool EachToEach { get; set; } = true;

                [JsonProperty(PropertyName = "Share (true/false)")]
                [DefaultValue(false)]
                public bool Share { get; set; } = false;

                [JsonProperty(PropertyName = "Tree (true/false)")]
                [DefaultValue(false)]
                public bool Tree { get; set; } = false;

                [JsonProperty(PropertyName = "Default radius to look for entities from block")]
                [DefaultValue(3.0f)]
                public float Radius { get; set; } = 3.0f;
            }

            public class PasteOptions
            {
                [JsonProperty(PropertyName = "Auth (true/false)")]
                [DefaultValue(false)]
                public bool Auth { get; set; } = false;

                [JsonProperty(PropertyName = "Deployables (true/false)")]
                [DefaultValue(true)]
                public bool Deployables { get; set; } = true;

                [JsonProperty(PropertyName = "Inventories (true/false)")]
                [DefaultValue(true)]
                public bool Inventories { get; set; } = true;

                [JsonProperty(PropertyName = "Vending Machines (true/false)")]
                [DefaultValue(true)]
                public bool VendingMachines { get; set; } = true;

                [JsonProperty(PropertyName = "Stability (true/false)")]
                [DefaultValue(true)]
                public bool Stability { get; set; } = true;

                [JsonProperty(PropertyName = "EntityOwner (true/false)")]
                [DefaultValue(true)]
                public bool EntityOwner { get; set; } = true;
            }
        }

        private void LoadVariables()
        {
            Config.Settings.DefaultValueHandling = DefaultValueHandling.Populate;

            _config = Config.ReadObject<ConfigData>();

            Config.WriteObject(_config, true);
        }

        protected override void LoadDefaultConfig()
        {
            var configData = new ConfigData
            {
                Copy = new ConfigData.CopyOptions(),
                Paste = new ConfigData.PasteOptions()
            };

            Config.WriteObject(configData, true);
        }

        //Hooks

        private void Init()
        {
            permission.RegisterPermission(_copyPermission, this);
            permission.RegisterPermission(_listPermission, this);
            permission.RegisterPermission(_pastePermission, this);
            permission.RegisterPermission(_pastebackPermission, this);
            permission.RegisterPermission(_undoPermission, this);

            var compiledLangs = new Dictionary<string, Dictionary<string, string>>();

            foreach (var line in _messages)
            {
                foreach (var translate in line.Value)
                {
                    if (!compiledLangs.ContainsKey(translate.Key))
                        compiledLangs[translate.Key] = new Dictionary<string, string>();

                    compiledLangs[translate.Key][line.Key] = translate.Value;
                }
            }

            foreach (var cLangs in compiledLangs)
            {
                lang.RegisterMessages(cLangs.Value, this, cLangs.Key);
            }
        }

        private void OnServerInitialized()
        {
            LoadVariables();

            Vis.colBuffer = new Collider[8192 * 16];

            JsonConvert.DefaultSettings = () => new JsonSerializerSettings
            {
                Formatting = Formatting.Indented,
                ReferenceLoopHandling = ReferenceLoopHandling.Ignore
            };
        }

        #region API

        private object TryCopyFromSteamId(ulong userId, string filename, string[] args, Action callback = null)
        {
            var player = BasePlayer.FindByID(userId);

            if (player == null)
                return Lang("NOT_FOUND_PLAYER", userId.ToString());

            RaycastHit hit;

            if (!Physics.Raycast(player.eyes.HeadRay(), out hit, 1000f, _rayCopy))
                return Lang("NO_ENTITY_RAY", player.UserIDString);

            return TryCopy(hit.point, hit.GetEntity().GetNetworkRotation().eulerAngles, filename,
                DegreeToRadian(player.GetNetworkRotation().eulerAngles.y), args, player, callback);
        }

        private object TryPasteFromSteamId(ulong userId, string filename, string[] args, Action callback = null)
        {
            var player = BasePlayer.FindByID(userId);

            if (player == null)
                return Lang("NOT_FOUND_PLAYER", player.UserIDString);

            RaycastHit hit;

            if (!Physics.Raycast(player.eyes.HeadRay(), out hit, 1000f, _rayPaste))
                return Lang("NO_ENTITY_RAY", player.UserIDString);

            return TryPaste(hit.point, filename, player, DegreeToRadian(player.GetNetworkRotation().eulerAngles.y),
                args, callback: callback);
        }

        private object TryPasteFromVector3(Vector3 pos, float rotationCorrection, string filename, string[] args,
            Action callback = null)
        {
            return TryPaste(pos, filename, null, rotationCorrection, args, callback: callback);
        }

        #endregion

        //Other methods

        private object CheckCollision(HashSet<Dictionary<string, object>> entities, Vector3 startPos, float radius)
        {
            foreach (var entityobj in entities)
            {
                if (Physics.CheckSphere((Vector3) entityobj["position"], radius, _copyLayer))
                    return Lang("BLOCKING_PASTE");
            }

            return true;
        }

        private bool CheckPlaced(string prefabname, Vector3 pos, Quaternion rot)
        {
            const float maxDiff = 0.01f;

            var ents = new List<BaseEntity>();
            Vis.Entities(pos, maxDiff, ents);

            foreach (var ent in ents)
            {
                if (ent.PrefabName != prefabname)
                    continue;

                if (Vector3.Distance(ent.transform.position, pos) > maxDiff)
                {
                    continue;
                }

                if (Vector3.Distance(ent.transform.rotation.eulerAngles, rot.eulerAngles) > maxDiff)
                {
                    continue;
                }

                return true;
            }

            return false;
        }

        private object CmdPasteBack(BasePlayer player, string[] args)
        {
            var userIdString = player == null ? _serverId : player.UserIDString;

            if (args.Length < 1)
                return Lang("SYNTAX_PASTEBACK", userIdString);

            var success = TryPasteBack(args[0], player, args.Skip(1).ToArray());

            if (success is string)
                return (string) success;

            return true;
        }

        private object CmdUndo(string userIdString, string[] args)
        {
            var player = BasePlayer.Find(userIdString);
            if (!_lastPastes.ContainsKey(userIdString))
                return Lang("NO_PASTED_STRUCTURE", userIdString);

            var entities = new HashSet<BaseEntity>(_lastPastes[userIdString].Pop().ToList());

            UndoLoop(entities, player);

            return true;
        }

        private void UndoLoop(HashSet<BaseEntity> entities, BasePlayer player, int count = 0)
        {
            foreach (var storageContainer in entities.OfType<StorageContainer>().Where(x => !x.IsDestroyed))
            {
                storageContainer.Kill();
            }

            // Take an amount of entities from the entity list (defined in config) and kill them. Will be repeated for every tick until there are no entities left.
            entities
                .Take(_config.UndoBatchSize)
                .ToList()
                .ForEach(p =>
                {
                    entities.Remove(p);

                    // Cleanup the hotspot beloning to the node.
                    var ore = p as OreResourceEntity;
                    if (ore != null)
                    {
                        ore.CleanupBonus();
                    }

                    if (p != null && !p.IsDestroyed)
                        p.Kill();
                });

            // If it gets stuck in infinite loop break the loop.
            if (count != 0 && entities.Count != 0 && entities.Count == count)
            {
                if (player != null)
                    SendReply(player, "Undo cancelled because of infinite loop.");
                else
                    Puts("Undo cancelled because of infinite loop.");
                return;
            }

            if (entities.Count > 0)
                NextTick(() => UndoLoop(entities, player, entities.Count));
            else
            {
                if (player != null)
                    SendReply(player, Lang("UNDO_SUCCESS", player.UserIDString));
                else
                    Puts(Lang("UNDO_SUCCESS"));

                if (_lastPastes[player?.UserIDString ?? _serverId].Count == 0)
                    _lastPastes.Remove(player?.UserIDString ?? _serverId);
            }
        }

        private void Copy(Vector3 sourcePos, Vector3 sourceRot, string filename, float rotationCorrection,
            CopyMechanics copyMechanics, float range, bool saveTree, bool saveShare, bool eachToEach, BasePlayer player,
            Action callback)
        {
            var currentLayer = _copyLayer;

            if (saveTree)
                currentLayer |= LayerMask.GetMask("Tree");

            var copyData = new CopyData
            {
                Filename = filename,
                CurrentLayer = currentLayer,
                RotCor = rotationCorrection,
                Range = range,
                SaveShare = saveShare,
                SaveTree = saveTree,
                CopyMechanics = copyMechanics,
                EachToEach = eachToEach,
                SourcePos = sourcePos,
                SourceRot = sourceRot,
                Player = player,
                Callback = callback
            };

            copyData.CheckFrom.Push(sourcePos);

            NextTick(() => CopyLoop(copyData));
            ;
        }

        // Main loop for copy, will fetch all the data needed. Is called every tick untill copy is done (can't find any entities)
        private void CopyLoop(CopyData copyData)
        {
            var checkFrom = copyData.CheckFrom;
            var houseList = copyData.HouseList;
            var buildingId = copyData.BuildingId;
            var copyMechanics = copyData.CopyMechanics;
            var batchSize = checkFrom.Count < _config.CopyBatchSize ? checkFrom.Count : _config.CopyBatchSize;

            for (var i = 0; i < batchSize; i++)
            {
                if (checkFrom.Count == 0)
                    break;

                var list = Pool.GetList<BaseEntity>();
                Vis.Entities(checkFrom.Pop(), copyData.Range, list, copyData.CurrentLayer);

                foreach (var entity in list)
                {
                    if (!houseList.Add(entity))
                        continue;

                    if (copyMechanics == CopyMechanics.Building)
                    {
                        var buildingBlock = entity.GetComponentInParent<BuildingBlock>();

                        if (buildingBlock != null)
                        {
                            if (buildingId == 0)
                                buildingId = buildingBlock.buildingID;

                            if (buildingId != buildingBlock.buildingID)
                                continue;
                        }
                    }

                    if (copyData.EachToEach)
                        checkFrom.Push(entity.transform.position);
                    if (entity.GetComponent<BaseLock>() != null)
                        continue;
                    copyData.RawData.Add(EntityData(entity, entity.transform.position,
                        entity.transform.rotation.eulerAngles / 57.29578f, copyData));
                }

                copyData.BuildingId = buildingId;
            }

            if (checkFrom.Count > 0)
            {
                NextTick(() => CopyLoop(copyData));
            }
            else
            {
                var path = _subDirectory + copyData.Filename;
                var datafile = Interface.Oxide.DataFileSystem.GetDatafile(path);

                datafile.Clear();

                var sourcePos = copyData.SourcePos;

                datafile["default"] = new Dictionary<string, object>
                {
                    {
                        "position", new Dictionary<string, object>
                        {
                            {"x", sourcePos.x.ToString()},
                            {"y", sourcePos.y.ToString()},
                            {"z", sourcePos.z.ToString()}
                        }
                    },
                    {"rotationy", copyData.SourceRot.y.ToString()},
                    {"rotationdiff", copyData.RotCor.ToString()}
                };

                datafile["entities"] = copyData.RawData;
                datafile["protocol"] = new Dictionary<string, object>
                {
                    {"items", 2},
                    {"version", Version}
                };

                Interface.Oxide.DataFileSystem.SaveDatafile(path);

                SendReply(copyData.Player, Lang("COPY_SUCCESS", copyData.Player.UserIDString, copyData.Filename));

                copyData.Callback?.Invoke();

                Interface.CallHook("OnCopyFinished", copyData.RawData, copyData.Filename);
            }
        }

        private float DegreeToRadian(float angle)
        {
            return (float) (Math.PI * angle / 180.0f);
        }

        private Dictionary<string, object> EntityData(BaseEntity entity, Vector3 entPos, Vector3 entRot,
            CopyData copyData)
        {
            var normalizedPos = NormalizePosition(copyData.SourcePos, entPos, copyData.RotCor);

            entRot.y -= copyData.RotCor;

            var data = new Dictionary<string, object>
            {
                {"prefabname", entity.PrefabName},
                {"skinid", entity.skinID},
                {"flags", TryCopyFlags(entity)},
                {
                    "pos", new Dictionary<string, object>
                    {
                        {"x", normalizedPos.x.ToString()},
                        {"y", normalizedPos.y.ToString()},
                        {"z", normalizedPos.z.ToString()}
                    }
                },
                {
                    "rot", new Dictionary<string, object>
                    {
                        {"x", entRot.x.ToString()},
                        {"y", entRot.y.ToString()},
                        {"z", entRot.z.ToString()}
                    }
                },
                {"ownerid", entity.OwnerID}
            };

            TryCopySlots(entity, data, copyData.SaveShare);

            var buildingblock = entity as BuildingBlock;

            if (buildingblock != null)
            {
                data.Add("grade", buildingblock.grade);
            }

            var box = entity as StorageContainer;
            if (box?.inventory != null)
            {
                var itemlist = new List<object>();

                foreach (var item in box.inventory.itemList)
                {
                    var itemdata = new Dictionary<string, object>
                    {
                        {"condition", item.condition.ToString()},
                        {"id", item.info.itemid},
                        {"amount", item.amount},
                        {"skinid", item.skin},
                        {"position", item.position},
                        {"blueprintTarget", item.blueprintTarget}
                    };

                    if (!string.IsNullOrEmpty(item.text))
                        itemdata["text"] = item.text;

                    var heldEnt = item.GetHeldEntity();

                    if (heldEnt != null)
                    {
                        var projectiles = heldEnt.GetComponent<BaseProjectile>();

                        if (projectiles != null)
                        {
                            var magazine = projectiles.primaryMagazine;

                            if (magazine != null)
                            {
                                itemdata.Add("magazine", new Dictionary<string, object>
                                {
                                    {magazine.ammoType.itemid.ToString(), magazine.contents}
                                });
                            }
                        }
                    }

                    if (item?.contents?.itemList != null)
                    {
                        var contents = new List<object>();

                        foreach (var itemContains in item.contents.itemList)
                        {
                            contents.Add(new Dictionary<string, object>
                            {
                                {"id", itemContains.info.itemid},
                                {"amount", itemContains.amount}
                            });
                        }

                        itemdata["items"] = contents;
                    }

                    itemlist.Add(itemdata);
                }

                data.Add("items", itemlist);
            }

            var box2 = entity as ContainerIOEntity;
            if (box2 != null)
            {
                var itemlist = new List<object>();

                foreach (var item in box2.inventory.itemList)
                {
                    var itemdata = new Dictionary<string, object>
                    {
                        {"condition", item.condition.ToString()},
                        {"id", item.info.itemid},
                        {"amount", item.amount},
                        {"skinid", item.skin},
                        {"position", item.position},
                        {"blueprintTarget", item.blueprintTarget}
                    };

                    if (!string.IsNullOrEmpty(item.text))
                        itemdata["text"] = item.text;

                    var heldEnt = item.GetHeldEntity();

                    if (heldEnt != null)
                    {
                        var projectiles = heldEnt.GetComponent<BaseProjectile>();

                        if (projectiles != null)
                        {
                            var magazine = projectiles.primaryMagazine;

                            if (magazine != null)
                            {
                                itemdata.Add("magazine", new Dictionary<string, object>
                                {
                                    {magazine.ammoType.itemid.ToString(), magazine.contents}
                                });
                            }
                        }
                    }

                    if (item?.contents?.itemList != null)
                    {
                        var contents = new List<object>();

                        foreach (var itemContains in item.contents.itemList)
                        {
                            contents.Add(new Dictionary<string, object>
                            {
                                {"id", itemContains.info.itemid},
                                {"amount", itemContains.amount}
                            });
                        }

                        itemdata["items"] = contents;
                    }

                    itemlist.Add(itemdata);
                }

                data.Add("items", itemlist);
            }

            var sign = entity as Signage;
            if (sign != null && sign.textureIDs != null)
            {
                data.Add("sign", new Dictionary<string, object>
                {
                    {"locked", sign.IsLocked()}
                });

                var signData = (Dictionary<string, object>) data["sign"];

                for (int num = 0; num < sign.textureIDs.Length; num++)
                {
                    var textureId = sign.textureIDs[num];
                    if (textureId == 0)
                        continue;

                    var imageByte = FileStorage.server.Get(textureId, FileStorage.Type.png, sign.net.ID);
                    if (imageByte != null)
                    {
                        signData.Add($"texture{num}", Convert.ToBase64String(imageByte));
                    }
                }

                signData["amount"] = sign.textureIDs.Length;
            }

            if (copyData.SaveShare)
            {
                var sleepingBag = entity as SleepingBag;

                if (sleepingBag != null)
                {
                    data.Add("sleepingbag", new Dictionary<string, object>
                    {
                        {"niceName", sleepingBag.niceName},
                        {"deployerUserID", sleepingBag.deployerUserID},
                        {"isPublic", sleepingBag.IsPublic()}
                    });
                }

                var cupboard = entity as BuildingPrivlidge;

                if (cupboard != null)
                {
                    data.Add("cupboard", new Dictionary<string, object>
                    {
                        {"authorizedPlayers", cupboard.authorizedPlayers.Select(y => y.userid).ToList()}
                    });
                }

                var autoTurret = entity as AutoTurret;

                if (autoTurret != null)
                {
                    data.Add("autoturret", new Dictionary<string, object>
                    {
                        {"authorizedPlayers", autoTurret.authorizedPlayers.Select(p => p.userid).ToList()}
                    });
                }
            }

            var cctvRc = entity as CCTV_RC;
            if (cctvRc != null)
            {
                data.Add("cctv", new Dictionary<string, object>
                {
                    {"yaw", cctvRc.yawAmount},
                    {"pitch", cctvRc.pitchAmount},
                    {"rcIdentifier", cctvRc.rcIdentifier}
                });
            }

            var vendingMachine = entity as VendingMachine;

            if (vendingMachine != null)
            {
                var sellOrders = new List<object>();

                foreach (var vendItem in vendingMachine.sellOrders.sellOrders)
                {
                    sellOrders.Add(new Dictionary<string, object>
                    {
                        {"itemToSellID", vendItem.itemToSellID},
                        {"itemToSellAmount", vendItem.itemToSellAmount},
                        {"currencyID", vendItem.currencyID},
                        {"currencyAmountPerItem", vendItem.currencyAmountPerItem},
                        {"inStock", vendItem.inStock},
                        {"currencyIsBP", vendItem.currencyIsBP},
                        {"itemToSellIsBP", vendItem.itemToSellIsBP}
                    });
                }

                data.Add("vendingmachine", new Dictionary<string, object>
                {
                    {"shopName", vendingMachine.shopName},
                    {"isBroadcasting", vendingMachine.IsBroadcasting()},
                    {"sellOrders", sellOrders}
                });
            }

            var ioEntity = entity as IOEntity;

            if (ioEntity != null)
            {
                var ioData = new Dictionary<string, object>();
                var inputs = ioEntity.inputs.Select(input => new Dictionary<string, object>
                    {
                        {"connectedID", input.connectedTo.entityRef.uid},
                        {"connectedToSlot", input.connectedToSlot},
                        {"niceName", input.niceName},
                        {"type", (int) input.type}
                    })
                    .Cast<object>()
                    .ToList();

                ioData.Add("inputs", inputs);

                var outputs = new List<object>();
                foreach (var output in ioEntity.outputs)
                {
                    var ioConnection = new Dictionary<string, object>
                    {
                        {"connectedID", output.connectedTo.entityRef.uid},
                        {"connectedToSlot", output.connectedToSlot},
                        {"niceName", output.niceName},
                        {"type", (int) output.type},
                        {"linePoints", output.linePoints?.ToList() ?? new List<Vector3>()}
                    };

                    outputs.Add(ioConnection);
                }

                ioData.Add("outputs", outputs);
                ioData.Add("oldID", ioEntity.net.ID);
                var electricalBranch = ioEntity as ElectricalBranch;
                if (electricalBranch != null)
                {
                    ioData.Add("branchAmount", electricalBranch.branchAmount);
                }

                var counter = ioEntity as PowerCounter;
                if (counter != null)
                {
                    ioData.Add("targetNumber", counter.GetTarget());
                }

                var timerSwitch = ioEntity as TimerSwitch;
                if (timerSwitch != null)
                {
                    ioData.Add("timerLength", timerSwitch.timerLength);
                }

                var rfBroadcaster = ioEntity as IRFObject;
                if (rfBroadcaster != null)
                {
                    ioData.Add("frequency", rfBroadcaster.GetFrequency());
                }

                data.Add("IOEntity", ioData);
            }

            return data;
        }

        private object FindBestHeight(HashSet<Dictionary<string, object>> entities, Vector3 startPos)
        {
            var maxHeight = 0f;

            foreach (var entity in entities)
            {
                if (((string) entity["prefabname"]).Contains("/foundation/"))
                {
                    var foundHeight = GetGround((Vector3) entity["position"]);

                    if (foundHeight != null)
                    {
                        var height = (Vector3) foundHeight;

                        if (height.y > maxHeight)
                            maxHeight = height.y;
                    }
                }
            }

            maxHeight += 1f;

            return maxHeight;
        }

        private bool FindRayEntity(Vector3 sourcePos, Vector3 sourceDir, out Vector3 point, out BaseEntity entity,
            int rayLayer)
        {
            RaycastHit hitinfo;
            entity = null;
            point = Vector3.zero;

            if (!Physics.Raycast(sourcePos, sourceDir, out hitinfo, 1000f, rayLayer))
                return false;

            entity = hitinfo.GetEntity();
            point = hitinfo.point;

            return true;
        }

        private void FixSignage(Signage sign, byte[] imageBytes, int index)
        {
            if (!_signSizes.ContainsKey(sign.ShortPrefabName))
                return;

            var size = Math.Max(sign.paintableSources.Length, 1);
            if (sign.textureIDs == null || sign.textureIDs.Length != size)
            {
                Array.Resize(ref sign.textureIDs, size);
            }

            var resizedImage = ImageResize(imageBytes, _signSizes[sign.ShortPrefabName].Width,
                _signSizes[sign.ShortPrefabName].Height);

            sign.textureIDs[index] = FileStorage.server.Store(resizedImage, FileStorage.Type.png, sign.net.ID);
        }

        private object GetGround(Vector3 pos)
        {
            RaycastHit hitInfo;
            pos += new Vector3(0, 100, 0);

            if (Physics.Raycast(pos, Vector3.down, out hitInfo, 200, _groundLayer))
                return hitInfo.point;

            return null;
        }

        private int GetItemId(int itemId)
        {
            if (ReplaceItemId.ContainsKey(itemId))
                return ReplaceItemId[itemId];

            return itemId;
        }

        private bool HasAccess(BasePlayer player, string permName)
        {
            return player.IsAdmin || permission.UserHasPermission(player.UserIDString, permName);
        }

        private byte[] ImageResize(byte[] imageBytes, int width, int height)
        {
            Bitmap resizedImage = new Bitmap(width, height),
                sourceImage = new Bitmap(new MemoryStream(imageBytes));

            Graphics.FromImage(resizedImage).DrawImage(sourceImage, new Rectangle(0, 0, width, height),
                new Rectangle(0, 0, sourceImage.Width, sourceImage.Height), GraphicsUnit.Pixel);

            var ms = new MemoryStream();
            resizedImage.Save(ms, ImageFormat.Png);

            return ms.ToArray();
        }

        private string Lang(string key, string userId = null, params object[] args) =>
            string.Format(lang.GetMessage(key, this, userId), args);

        private Vector3 NormalizePosition(Vector3 initialPos, Vector3 currentPos, float diffRot)
        {
            var transformedPos = currentPos - initialPos;
            var newX = transformedPos.x * (float) Math.Cos(-diffRot) +
                       transformedPos.z * (float) Math.Sin(-diffRot);
            var newZ = transformedPos.z * (float) Math.Cos(-diffRot) -
                       transformedPos.x * (float) Math.Sin(-diffRot);

            transformedPos.x = newX;
            transformedPos.z = newZ;

            return transformedPos;
        }

        private void Paste(ICollection<Dictionary<string, object>> entities, Dictionary<string, object> protocol,
            bool ownership, Vector3 startPos, BasePlayer player, bool stability, float rotationCorrection,
            float heightAdj, bool auth, Action callback, string filename)
        {

            var ioEntities = new Dictionary<uint, Dictionary<string, object>>();
            uint buildingId = 0;

            //Settings

            var isItemReplace = !protocol.ContainsKey("items");

            var eulerRotation = new Vector3(0f, rotationCorrection * 57.2958f, 0f);
            var quaternionRotation = Quaternion.Euler(eulerRotation);

            var pasteData = new PasteData
            {
                HeightAdj = heightAdj,
                IsItemReplace = isItemReplace,
                Entities = entities,
                Player = player,
                QuaternionRotation = quaternionRotation,
                StartPos = startPos,
                Stability = stability,
                Auth = auth,
                Ownership = ownership,
                Callback = callback,
                Filename = filename
            };

            NextTick(() => PasteLoop(pasteData));
        }

        private void PasteLoop(PasteData pasteData)
        {
            var entities = pasteData.Entities;
            var todo = entities.Take(_config.PasteBatchSize).ToArray();
            var player = pasteData.Player;

            foreach (var data in todo)
            {
                entities.Remove(data);
                var prefabname = (string) data["prefabname"];
                var skinid = ulong.Parse(data["skinid"].ToString());
                var pos = (Vector3) data["position"];
                var rot = (Quaternion) data["rotation"];

                var ownerId = player?.userID ?? 0;
                if (data.ContainsKey("ownerid"))
                {
                    ownerId = Convert.ToUInt64(data["ownerid"]);
                }

                if (CheckPlaced(prefabname, pos, rot))
                    continue;

                if (prefabname.Contains("pillar"))
                    continue;

                // Used to copy locks for no reason in previous versions (is included in the slots info so no need to copy locks) so just skipping them.
                if (prefabname.Contains("locks"))
                    continue;

                var entity = GameManager.server.CreateEntity(prefabname, pos, rot);

                if (entity == null)
                    continue;

                entity.transform.position = pos;
                entity.transform.rotation = rot;

                if (player != null)
                    entity.SendMessage("SetDeployedBy", player, SendMessageOptions.DontRequireReceiver);

                if (pasteData.Ownership)
                    entity.OwnerID = ownerId;

                var buildingBlock = entity as BuildingBlock;

                if (buildingBlock != null)
                {
                    buildingBlock.blockDefinition = PrefabAttribute.server.Find<Construction>(buildingBlock.prefabID);
                    buildingBlock.SetGrade((BuildingGrade.Enum) data["grade"]);
                    if (!pasteData.Stability)
                        buildingBlock.grounded = true;
                }

                var decayEntity = entity as DecayEntity;

                if (decayEntity != null)
                {
                    if (pasteData.BuildingId == 0)
                        pasteData.BuildingId = BuildingManager.server.NewBuildingID();

                    decayEntity.AttachToBuilding(pasteData.BuildingId);
                }

                var stabilityEntity = entity as StabilityEntity;

                if (stabilityEntity != null)
                {
                    if (!stabilityEntity.grounded)
                    {
                        stabilityEntity.grounded = true;
                        pasteData.StabilityEntities.Add(stabilityEntity);
                    }
                }

                entity.skinID = skinid;
                entity.Spawn();

                var baseCombat = entity as BaseCombatEntity;

                if (baseCombat != null)
                    baseCombat.SetHealth(baseCombat.MaxHealth());

                pasteData.PastedEntities.AddRange(TryPasteSlots(entity, data, pasteData));

                var box = entity as StorageContainer;
                if (box != null)
                {
                    box.inventory.Clear();

                    var items = new List<object>();

                    if (data.ContainsKey("items"))
                        items = data["items"] as List<object>;

                    foreach (var itemDef in items)
                    {
                        var item = itemDef as Dictionary<string, object>;
                        var itemid = Convert.ToInt32(item["id"]);
                        var itemamount = Convert.ToInt32(item["amount"]);
                        var itemskin = ulong.Parse(item["skinid"].ToString());
                        var itemcondition = Convert.ToSingle(item["condition"]);

                        if (pasteData.IsItemReplace)
                            itemid = GetItemId(itemid);

                        var i = ItemManager.CreateByItemID(itemid, itemamount, itemskin);

                        if (i != null)
                        {
                            i.condition = itemcondition;

                            if (item.ContainsKey("text"))
                                i.text = item["text"].ToString();

                            if (item.ContainsKey("blueprintTarget"))
                            {
                                var blueprintTarget = Convert.ToInt32(item["blueprintTarget"]);

                                if (pasteData.IsItemReplace)
                                    blueprintTarget = GetItemId(blueprintTarget);

                                i.blueprintTarget = blueprintTarget;
                            }

                            if (item.ContainsKey("magazine"))
                            {
                                var heldent = i.GetHeldEntity();

                                if (heldent != null)
                                {
                                    var projectiles = heldent.GetComponent<BaseProjectile>();

                                    if (projectiles != null)
                                    {
                                        var magazine = item["magazine"] as Dictionary<string, object>;
                                        var ammotype = int.Parse(magazine.Keys.ToArray()[0]);
                                        var ammoamount = int.Parse(magazine[ammotype.ToString()].ToString());

                                        if (pasteData.IsItemReplace)
                                            ammotype = GetItemId(ammotype);

                                        projectiles.primaryMagazine.ammoType = ItemManager.FindItemDefinition(ammotype);
                                        projectiles.primaryMagazine.contents = ammoamount;
                                    }

                                    //TODO Doesn't add water to some containers

                                    if (item.ContainsKey("items"))
                                    {
                                        var itemContainsList = item["items"] as List<object>;

                                        foreach (var itemContains in itemContainsList)
                                        {
                                            var contents = itemContains as Dictionary<string, object>;

                                            var contentsItemId = Convert.ToInt32(contents["id"]);

                                            if (pasteData.IsItemReplace)
                                                contentsItemId = GetItemId(contentsItemId);

                                            i.contents.AddItem(ItemManager.FindItemDefinition(contentsItemId),
                                                Convert.ToInt32(contents["amount"]));
                                        }
                                    }
                                }
                            }

                            var targetPos = -1;

                            if (item.ContainsKey("position"))
                                targetPos = Convert.ToInt32(item["position"]);

                            i.position = targetPos;
                            box.inventory.Insert(i);
                        }
                    }
                }

                var autoTurret = entity as AutoTurret;
                if (autoTurret != null)
                {
                    var authorizedPlayers = new List<ulong>();

                    if (data.ContainsKey("autoturret"))
                    {
                        var autoTurretData = data["autoturret"] as Dictionary<string, object>;
                        authorizedPlayers = (autoTurretData["authorizedPlayers"] as List<object>)
                            .Select(Convert.ToUInt64).ToList();
                    }

                    if (player != null && !authorizedPlayers.Contains(player.userID) && pasteData.Auth)
                        authorizedPlayers.Add(player.userID);

                    foreach (var userId in authorizedPlayers)
                    {
                        autoTurret.authorizedPlayers.Add(new PlayerNameID
                        {
                            userid = Convert.ToUInt64(userId),
                            username = "Player"
                        });
                    }

                    autoTurret.SendNetworkUpdate();
                }

                var containerIo = entity as ContainerIOEntity;
                if (containerIo != null)
                {
                    containerIo.inventory.Clear();

                    var items = new List<object>();

                    if (data.ContainsKey("items"))
                        items = data["items"] as List<object>;

                    foreach (var itemDef in items)
                    {
                        var itemJson = itemDef as Dictionary<string, object>;
                        var itemid = Convert.ToInt32(itemJson["id"]);
                        var itemamount = Convert.ToInt32(itemJson["amount"]);
                        var itemskin = ulong.Parse(itemJson["skinid"].ToString());
                        var itemcondition = Convert.ToSingle(itemJson["condition"]);

                        if (pasteData.IsItemReplace)
                            itemid = GetItemId(itemid);

                        var item = ItemManager.CreateByItemID(itemid, itemamount, itemskin);

                        if (item != null)
                        {
                            item.condition = itemcondition;

                            if (itemJson.ContainsKey("text"))
                                item.text = itemJson["text"].ToString();

                            if (itemJson.ContainsKey("blueprintTarget"))
                            {
                                var blueprintTarget = Convert.ToInt32(itemJson["blueprintTarget"]);

                                if (pasteData.IsItemReplace)
                                    blueprintTarget = GetItemId(blueprintTarget);

                                item.blueprintTarget = blueprintTarget;
                            }

                            if (itemJson.ContainsKey("magazine"))
                            {
                                var heldent = item.GetHeldEntity();

                                if (heldent != null)
                                {
                                    var projectiles = heldent.GetComponent<BaseProjectile>();

                                    if (projectiles != null)
                                    {
                                        var magazine = itemJson["magazine"] as Dictionary<string, object>;
                                        var ammotype = int.Parse(magazine.Keys.ToArray()[0]);
                                        var ammoamount = int.Parse(magazine[ammotype.ToString()].ToString());

                                        if (pasteData.IsItemReplace)
                                            ammotype = GetItemId(ammotype);

                                        projectiles.primaryMagazine.ammoType = ItemManager.FindItemDefinition(ammotype);
                                        projectiles.primaryMagazine.contents = ammoamount;
                                    }

                                    //TODO Doesn't add water to some containers

                                    if (itemJson.ContainsKey("items"))
                                    {
                                        var itemContainsList = itemJson["items"] as List<object>;

                                        foreach (var itemContains in itemContainsList)
                                        {
                                            var contents = itemContains as Dictionary<string, object>;

                                            var contentsItemId = Convert.ToInt32(contents["id"]);

                                            if (pasteData.IsItemReplace)
                                                contentsItemId = GetItemId(contentsItemId);

                                            item.contents.AddItem(ItemManager.FindItemDefinition(contentsItemId),
                                                Convert.ToInt32(contents["amount"]));
                                        }
                                    }
                                }
                            }

                            var targetPos = -1;
                            if (itemJson.ContainsKey("position"))
                                targetPos = Convert.ToInt32(itemJson["position"]);

                            item.position = targetPos;
                            containerIo.inventory.Insert(item);
                        }
                    }

                    if (autoTurret != null)
                    {
                        autoTurret.Invoke(autoTurret.UpdateAttachedWeapon, 0.5f);
                    }

                    containerIo.SendNetworkUpdate();
                }

                var sign = entity as Signage;
                if (sign != null && data.ContainsKey("sign"))
                {
                    var signData = data["sign"] as Dictionary<string, object>;

                    if (signData.ContainsKey("amount"))
                    {
                        int amount;
                        if (int.TryParse(signData["amount"].ToString(), out amount))
                        {
                            for (int num = 0; num < amount; num++)
                            {
                                if (signData.ContainsKey($"texture{num}"))
                                {
                                    var imageBytes = Convert.FromBase64String(signData[$"texture{num}"].ToString());

                                    FixSignage(sign, imageBytes, num);
                                }
                            }
                        }
                    }
                    else if (signData.ContainsKey("texture"))
                    {
                        var imageBytes = Convert.FromBase64String(signData["texture"].ToString());

                        FixSignage(sign, imageBytes, 0);
                    }

                    if (Convert.ToBoolean(signData["locked"]))
                        sign.SetFlag(BaseEntity.Flags.Locked, true);

                    sign.SendNetworkUpdate();
                }

                var sleepingBag = entity as SleepingBag;
                if (sleepingBag != null && data.ContainsKey("sleepingbag"))
                {
                    var bagData = data["sleepingbag"] as Dictionary<string, object>;

                    sleepingBag.niceName = bagData["niceName"].ToString();
                    sleepingBag.deployerUserID = ulong.Parse(bagData["deployerUserID"].ToString());
                    sleepingBag.SetPublic(Convert.ToBoolean(bagData["isPublic"]));
                }

                var cupboard = entity as BuildingPrivlidge;
                if (cupboard != null)
                {
                    var authorizedPlayers = new List<ulong>();

                    if (data.ContainsKey("cupboard"))
                    {
                        var cupboardData = data["cupboard"] as Dictionary<string, object>;
                        authorizedPlayers = (cupboardData["authorizedPlayers"] as List<object>).Select(Convert.ToUInt64)
                            .ToList();
                    }

                    if (player != null && !authorizedPlayers.Contains(player.userID) && pasteData.Auth)
                        authorizedPlayers.Add(player.userID);

                    foreach (var userId in authorizedPlayers)
                    {
                        cupboard.authorizedPlayers.Add(new PlayerNameID
                        {
                            userid = Convert.ToUInt64(userId),
                            username = "Player"
                        });
                    }

                    cupboard.SendNetworkUpdate();
                }

                var cctvRc = entity as CCTV_RC;
                if (cctvRc != null && data.ContainsKey("cctv"))
                {
                    var cctv = (Dictionary<string, object>) data["cctv"];
                    cctvRc.yawAmount = Convert.ToSingle(cctv["yaw"]);
                    cctvRc.pitchAmount = Convert.ToSingle(cctv["pitch"]);
                    cctvRc.rcIdentifier = cctv["rcIdentifier"].ToString();
                    cctvRc.SendNetworkUpdate();
                }

                var vendingMachine = entity as VendingMachine;
                if (vendingMachine != null && data.ContainsKey("vendingmachine"))
                {
                    var vendingData = data["vendingmachine"] as Dictionary<string, object>;

                    vendingMachine.shopName = vendingData["shopName"].ToString();
                    vendingMachine.SetFlag(BaseEntity.Flags.Reserved4,
                        Convert.ToBoolean(vendingData["isBroadcasting"]));

                    var sellOrders = vendingData["sellOrders"] as List<object>;

                    foreach (var orderPreInfo in sellOrders)
                    {
                        var orderInfo = orderPreInfo as Dictionary<string, object>;

                        if (!orderInfo.ContainsKey("inStock"))
                        {
                            orderInfo["inStock"] = 0;
                            orderInfo["currencyIsBP"] = false;
                            orderInfo["itemToSellIsBP"] = false;
                        }

                        int itemToSellId = Convert.ToInt32(orderInfo["itemToSellID"]),
                            currencyId = Convert.ToInt32(orderInfo["currencyID"]);

                        if (pasteData.IsItemReplace)
                        {
                            itemToSellId = GetItemId(itemToSellId);
                            currencyId = GetItemId(currencyId);
                        }

                        vendingMachine.sellOrders.sellOrders.Add(new ProtoBuf.VendingMachine.SellOrder
                        {
                            ShouldPool = false,
                            itemToSellID = itemToSellId,
                            itemToSellAmount = Convert.ToInt32(orderInfo["itemToSellAmount"]),
                            currencyID = currencyId,
                            currencyAmountPerItem = Convert.ToInt32(orderInfo["currencyAmountPerItem"]),
                            inStock = Convert.ToInt32(orderInfo["inStock"]),
                            currencyIsBP = Convert.ToBoolean(orderInfo["currencyIsBP"]),
                            itemToSellIsBP = Convert.ToBoolean(orderInfo["itemToSellIsBP"])
                        });
                    }

                    vendingMachine.FullUpdate();
                }

                var ioEntity = entity as IOEntity;

                if (ioEntity != null)
                {
                    var ioData = new Dictionary<string, object>();

                    if (data.ContainsKey("IOEntity"))
                    {
                        ioData = data["IOEntity"] as Dictionary<string, object> ?? new Dictionary<string, object>();
                    }

                    ioData.Add("entity", ioEntity);
                    ioData.Add("newId", ioEntity.net.ID);

                    object oldIdObject = 0;
                    if (ioData.TryGetValue("oldID", out oldIdObject))
                    {
                        var oldId = Convert.ToUInt32(oldIdObject);
                        pasteData.IoEntities.Add(oldId, ioData);
                    }
                }

                var flagsData = new Dictionary<string, object>();

                if (data.ContainsKey("flags"))
                    flagsData = data["flags"] as Dictionary<string, object>;

                var flags = new Dictionary<BaseEntity.Flags, bool>();

                foreach (var flagData in flagsData)
                {
                    BaseEntity.Flags baseFlag;
                    if (Enum.TryParse(flagData.Key, out baseFlag))
                        flags.Add(baseFlag, Convert.ToBoolean(flagData.Value));
                }

                foreach (var flag in flags)
                {
                    entity.SetFlag(flag.Key, flag.Value);
                }

                pasteData.PastedEntities.Add(entity);
            }

            if (entities.Count > 0)
                NextTick(() => PasteLoop(pasteData));
            else
            {
                foreach (var ioData in pasteData.IoEntities.Values.ToArray())
                {
                    if (!ioData.ContainsKey("entity"))
                        continue;


                    var ioEntity = ioData["entity"] as IOEntity;

                    List<object> inputs = null;
                    if (ioData.ContainsKey("inputs"))
                        inputs = ioData["inputs"] as List<object>;

                    var electricalBranch = ioEntity as ElectricalBranch;
                    if (electricalBranch != null && ioData.ContainsKey("branchAmount"))
                    {
                        electricalBranch.branchAmount = Convert.ToInt32(ioData["branchAmount"]);
                    }

                    var counter = ioEntity as PowerCounter;
                    if (counter != null && ioData.ContainsKey("targetNumber"))
                    {
                        counter.targetCounterNumber = Convert.ToInt32(ioData["targetNumber"]);
                    }

                    var timer = ioEntity as TimerSwitch;
                    if (timer != null && ioData.ContainsKey("timerLength"))
                    {
                        timer.timerLength = Convert.ToInt32(ioData["timerLength"]);
                    }

                    var rfBroadcaster = ioEntity as RFBroadcaster;
                    if (rfBroadcaster != null && ioData.ContainsKey("frequency"))
                    {
                        rfBroadcaster.frequency = Convert.ToInt32(ioData["frequency"]);
                    }

                    var rfReceiver = ioEntity as RFReceiver;
                    if (rfReceiver != null && ioData.ContainsKey("frequency"))
                    {
                        rfReceiver.frequency = Convert.ToInt32(ioData["frequency"]);
                    }

                    var doorManipulator = ioEntity as CustomDoorManipulator;
                    if (doorManipulator != null)
                    {
                        var door = doorManipulator.FindDoor();
                        doorManipulator.SetTargetDoor(door);
                    }

                    if (inputs != null && inputs.Count > 0)
                    {
                        for (var index = 0; index < inputs.Count; index++)
                        {
                            var input = inputs[index] as Dictionary<string, object>;
                            object oldIdObject;
                            if (!input.TryGetValue("connectedID", out oldIdObject))
                                continue;

                            var oldId = Convert.ToUInt32(oldIdObject);

                            if (oldId != 0 && pasteData.IoEntities.ContainsKey(oldId))
                            {
                                if (ioEntity.inputs[index] == null)
                                    ioEntity.inputs[index] = new IOEntity.IOSlot();

                                var ioConnection = pasteData.IoEntities[oldId];

                                object temp;

                                if (ioConnection.ContainsKey("newId"))
                                {
                                    ioEntity.inputs[index].connectedTo.entityRef.uid =
                                        Convert.ToUInt32(ioConnection["newId"]);
                                }
                            }
                        }
                    }

                    List<object> outputs = null;
                    if (ioData.ContainsKey("outputs"))
                        outputs = ioData["outputs"] as List<object>;

                    if (outputs != null && outputs.Count > 0)
                    {
                        for (var index = 0; index < outputs.Count; index++)
                        {
                            var output = outputs[index] as Dictionary<string, object>;
                            var oldId = Convert.ToUInt32(output["connectedID"]);

                            if (oldId != 0 && pasteData.IoEntities.ContainsKey(oldId))
                            {
                                if (ioEntity.outputs[index] == null)
                                    ioEntity.outputs[index] = new IOEntity.IOSlot();

                                var ioConnection = pasteData.IoEntities[oldId];

                                if (ioConnection.ContainsKey("newId"))
                                {
                                    var ioEntity2 = ioConnection["entity"] as IOEntity;
                                    var connectedToSlot = Convert.ToInt32(output["connectedToSlot"]);
                                    var ioOutput = ioEntity.outputs[index];

                                    ioOutput.connectedTo = new IOEntity.IORef();
                                    ioOutput.connectedTo.Set(ioEntity2);
                                    ioOutput.connectedToSlot = connectedToSlot;
                                    ioOutput.connectedTo.Init();

                                    ioEntity2.inputs[connectedToSlot].connectedTo = new IOEntity.IORef();
                                    ioEntity2.inputs[connectedToSlot].connectedTo.Set(ioEntity);
                                    ioEntity2.inputs[connectedToSlot].connectedToSlot = index;
                                    ioEntity2.inputs[connectedToSlot].connectedTo.Init();

                                    ioOutput.niceName = output["niceName"] as string;

                                    ioOutput.type = (IOEntity.IOType) Convert.ToInt32(output["type"]);
                                }

                                if (output.ContainsKey("linePoints"))
                                {
                                    var linePoints = output["linePoints"] as List<object>;
                                    if (linePoints != null)
                                    {
                                        var lineList = new List<Vector3>();
                                        foreach (var point in linePoints)
                                        {
                                            var linePoint = point as Dictionary<string, object>;
                                            lineList.Add(new Vector3(
                                                Convert.ToSingle(linePoint["x"]),
                                                Convert.ToSingle(linePoint["y"]),
                                                Convert.ToSingle(linePoint["z"])));
                                        }

                                        ioEntity.outputs[index].linePoints = lineList.ToArray();
                                    }
                                }
                            }
                        }
                    }

                    ioEntity.MarkDirtyForceUpdateOutputs();
                    ioEntity.SendNetworkUpdate();
                }

                foreach (var entity in pasteData.StabilityEntities)
                {
                    entity.grounded = false;
                    entity.InitializeSupports();
                    entity.UpdateStability();
                }

                if (player != null)
                {
                    SendReply(player, Lang("PASTE_SUCCESS", player.UserIDString));
#if DEBUG
                    SendReply(player, $"Stopwatch took: {pasteData.Sw.Elapsed.TotalMilliseconds} ms");
#endif
                }
                else
                {
                    Puts(Lang("PASTE_SUCCESS"));
                }

                if (!_lastPastes.ContainsKey(player?.UserIDString ?? _serverId))
                    _lastPastes[player?.UserIDString ?? _serverId] = new Stack<List<BaseEntity>>();

                _lastPastes[player?.UserIDString ?? _serverId].Push(pasteData.PastedEntities);

                pasteData.Callback?.Invoke();

                Interface.CallHook("OnPasteFinished", pasteData.PastedEntities, pasteData.Filename);
            }
        }

        private HashSet<Dictionary<string, object>> PreLoadData(List<object> entities, Vector3 startPos,
            float rotationCorrection, bool deployables, bool inventories, bool auth, bool vending)
        {
            var eulerRotation = new Vector3(0f, rotationCorrection, 0f);
            var quaternionRotation = Quaternion.EulerRotation(eulerRotation);
            var preloaddata = new HashSet<Dictionary<string, object>>();

            foreach (var entity in entities)
            {
                var data = entity as Dictionary<string, object>;

                if (!deployables && !data.ContainsKey("grade"))
                    continue;

                var pos = (Dictionary<string, object>) data["pos"];
                var rot = (Dictionary<string, object>) data["rot"];

                data.Add("position",
                    quaternionRotation * new Vector3(Convert.ToSingle(pos["x"]), Convert.ToSingle(pos["y"]),
                        Convert.ToSingle(pos["z"])) + startPos);
                data.Add("rotation",
                    Quaternion.EulerRotation(eulerRotation + new Vector3(Convert.ToSingle(rot["x"]),
                        Convert.ToSingle(rot["y"]), Convert.ToSingle(rot["z"]))));

                if (!inventories && data.ContainsKey("items"))
                    data["items"] = new List<object>();

                if (!vending && data["prefabname"].ToString().Contains("vendingmachine"))
                    data.Remove("vendingmachine");

                preloaddata.Add(data);
            }

            return preloaddata;
        }

        private object TryCopy(Vector3 sourcePos, Vector3 sourceRot, string filename, float rotationCorrection,
            string[] args, BasePlayer player, Action callback)
        {
            bool saveShare = _config.Copy.Share, saveTree = _config.Copy.Tree, eachToEach = _config.Copy.EachToEach;
            var copyMechanics = CopyMechanics.Proximity;
            var radius = _config.Copy.Radius;

            for (var i = 0;; i = i + 2)
            {
                if (i >= args.Length)
                    break;

                var valueIndex = i + 1;

                if (valueIndex >= args.Length)
                    return Lang("SYNTAX_COPY");

                var param = args[i].ToLower();

                switch (param)
                {
                    case "e":
                    case "each":
                        if (!bool.TryParse(args[valueIndex], out eachToEach))
                            return Lang("SYNTAX_BOOL", null, param);

                        break;

                    case "m":
                    case "method":
                        switch (args[valueIndex].ToLower())
                        {
                            case "b":
                            case "building":
                                copyMechanics = CopyMechanics.Building;
                                break;

                            case "p":
                            case "proximity":
                                copyMechanics = CopyMechanics.Proximity;
                                break;
                        }

                        break;

                    case "r":
                    case "radius":
                        if (!float.TryParse(args[valueIndex], out radius))
                            return Lang("SYNTAX_RADIUS");

                        break;

                    case "s":
                    case "share":
                        if (!bool.TryParse(args[valueIndex], out saveShare))
                            return Lang("SYNTAX_BOOL", null, param);

                        break;

                    case "t":
                    case "tree":
                        if (!bool.TryParse(args[valueIndex], out saveTree))
                            return Lang("SYNTAX_BOOL", null, param);

                        break;

                    default:
                        return Lang("SYNTAX_COPY");
                }
            }

            Copy(sourcePos, sourceRot, filename, rotationCorrection, copyMechanics, radius, saveTree, saveShare,
                eachToEach, player, callback);

            return true;
        }

        private void TryCopySlots(BaseEntity ent, IDictionary<string, object> housedata, bool saveShare)
        {
            foreach (var slot in _checkSlots)
            {
                if (!ent.HasSlot(slot))
                    continue;

                var slotEntity = ent.GetSlot(slot);

                if (slotEntity == null)
                    continue;

                var codedata = new Dictionary<string, object>
                {
                    {"prefabname", slotEntity.PrefabName},
                    {"flags", TryCopyFlags(ent)}
                };

                if (slotEntity.GetComponent<CodeLock>())
                {
                    var codeLock = slotEntity.GetComponent<CodeLock>();

                    codedata.Add("code", codeLock.code);

                    if (saveShare)
                        codedata.Add("whitelistPlayers", codeLock.whitelistPlayers);

                    if (codeLock.guestCode != null && codeLock.guestCode.Length == 4)
                    {
                        codedata.Add("guestCode", codeLock.guestCode);

                        if (saveShare)
                            codedata.Add("guestPlayers", codeLock.guestPlayers);
                    }
                }
                else if (slotEntity.GetComponent<KeyLock>())
                {
                    var keyLock = slotEntity.GetComponent<KeyLock>();
                    var code = keyLock.keyCode;

                    if (keyLock.firstKeyCreated)
                        code |= 0x80;

                    codedata.Add("ownerId", keyLock.OwnerID.ToString());
                    codedata.Add("code", code.ToString());
                }

                var slotName = slot.ToString().ToLower();

                housedata.Add(slotName, codedata);
            }
        }

        private Dictionary<string, object> TryCopyFlags(BaseEntity entity)
        {
            var flags = new Dictionary<string, object>();

            foreach (BaseEntity.Flags flag in Enum.GetValues(typeof(BaseEntity.Flags)))
            {
                if (!_config.DataSaving || entity.HasFlag(flag))
                    flags.Add(flag.ToString(), entity.HasFlag(flag));
            }

            return flags;
        }

        private object TryPaste(Vector3 startPos, string filename, BasePlayer player, float rotationCorrection,
            string[] args, bool autoHeight = true, Action callback = null)
        {
            var userId = player?.UserIDString;

            var path = _subDirectory + filename;

            if (!Interface.Oxide.DataFileSystem.ExistsDatafile(path))
                return Lang("FILE_NOT_EXISTS", userId);

            var data = Interface.Oxide.DataFileSystem.GetDatafile(path);

            if (data["default"] == null || data["entities"] == null)
                return Lang("FILE_BROKEN", userId);

            float heightAdj = 0f, blockCollision = 0f;
            bool auth = _config.Paste.Auth,
                inventories = _config.Paste.Inventories,
                deployables = _config.Paste.Deployables,
                vending = _config.Paste.VendingMachines,
                stability = _config.Paste.Stability,
                ownership = _config.Paste.EntityOwner;

            for (var i = 0;; i = i + 2)
            {
                if (i >= args.Length)
                    break;

                var valueIndex = i + 1;

                if (valueIndex >= args.Length)
                    return Lang("SYNTAX_PASTE_OR_PASTEBACK", userId);

                var param = args[i].ToLower();

                switch (param)
                {
                    case "a":
                    case "auth":
                        if (!bool.TryParse(args[valueIndex], out auth))
                            return Lang("SYNTAX_BOOL", userId, param);

                        break;

                    case "b":
                    case "blockcollision":
                        if (!float.TryParse(args[valueIndex], out blockCollision))
                            return Lang("SYNTAX_BLOCKCOLLISION", userId);

                        break;

                    case "d":
                    case "deployables":
                        if (!bool.TryParse(args[valueIndex], out deployables))
                            return Lang("SYNTAX_BOOL", userId, param);

                        break;

                    case "h":
                    case "height":
                        if (!float.TryParse(args[valueIndex], out heightAdj))
                            return Lang("SYNTAX_HEIGHT", userId);

                        break;

                    case "i":
                    case "inventories":
                        if (!bool.TryParse(args[valueIndex], out inventories))
                            return Lang("SYNTAX_BOOL", userId, param);

                        break;

                    case "s":
                    case "stability":
                        if (!bool.TryParse(args[valueIndex], out stability))
                            return Lang("SYNTAX_BOOL", userId, param);

                        break;

                    case "v":
                    case "vending":
                        if (!bool.TryParse(args[valueIndex], out vending))
                            return Lang("SYNTAX_BOOL", userId, param);

                        break;

                    case "o":
                    case "entityowner":
                        if (!bool.TryParse(args[valueIndex], out ownership))
                            return Lang("SYNTAX_BOOL", userId, param);

                        break;

                    case "autoheight":
                        if (!bool.TryParse(args[valueIndex], out autoHeight))
                            return Lang("SYNTAX_BOOL", userId, param);

                        break;

                    default:
                        return Lang("SYNTAX_PASTE_OR_PASTEBACK", userId);
                }
            }

            startPos.y += heightAdj;

            var preloadData = PreLoadData(data["entities"] as List<object>, startPos, rotationCorrection, deployables,
                inventories, auth, vending);

            if (autoHeight)
            {
                var bestHeight = FindBestHeight(preloadData, startPos);

                if (bestHeight is string)
                    return bestHeight;

                heightAdj += (float) bestHeight - startPos.y;

                foreach (var entity in preloadData)
                {
                    var pos = (Vector3) entity["position"];
                    pos.y += heightAdj;

                    entity["position"] = pos;
                }
            }

            if (blockCollision > 0f)
            {
                var collision = CheckCollision(preloadData, startPos, blockCollision);

                if (collision is string)
                    return collision;
            }

            var protocol = new Dictionary<string, object>();

            if (data["protocol"] != null)
                protocol = data["protocol"] as Dictionary<string, object>;

            Paste(preloadData, protocol, ownership, startPos, player, stability, rotationCorrection,
                autoHeight ? heightAdj : 0, auth, callback, filename);
            return true;
        }

        private List<BaseEntity> TryPasteSlots(BaseEntity ent, Dictionary<string, object> structure,
            PasteData pasteData)
        {
            var entitySlots = new List<BaseEntity>();

            foreach (var slot in _checkSlots)
            {
                var slotName = slot.ToString().ToLower();

                if (!ent.HasSlot(slot) || !structure.ContainsKey(slotName))
                    continue;

                var slotData = structure[slotName] as Dictionary<string, object>;
                var slotEntity = GameManager.server.CreateEntity((string) slotData["prefabname"], Vector3.zero);

                if (slotEntity == null)
                    continue;

                slotEntity.gameObject.Identity();
                slotEntity.SetParent(ent, slotName);
                slotEntity.OnDeployed(ent, null);
                slotEntity.Spawn();

                ent.SetSlot(slot, slotEntity);

                entitySlots.Add(slotEntity);

                if (slotName != "lock" || !slotData.ContainsKey("code"))
                    continue;

                if (slotEntity.GetComponent<CodeLock>())
                {
                    var code = (string) slotData["code"];

                    if (!string.IsNullOrEmpty(code))
                    {
                        var codeLock = slotEntity.GetComponent<CodeLock>();
                        codeLock.code = code;
                        codeLock.hasCode = true;

                        if (pasteData.Auth && pasteData.Player != null)
                            codeLock.whitelistPlayers.Add(pasteData.Player.userID);

                        if (slotData.ContainsKey("whitelistPlayers"))
                        {
                            foreach (var userId in slotData["whitelistPlayers"] as List<object>)
                            {
                                codeLock.whitelistPlayers.Add(Convert.ToUInt64(userId));
                            }
                        }

                        if (slotData.ContainsKey("guestCode"))
                        {
                            var guestCode = (string) slotData["guestCode"];

                            codeLock.guestCode = guestCode;
                            codeLock.hasGuestCode = true;

                            if (slotData.ContainsKey("guestPlayers"))
                            {
                                foreach (var userId in slotData["guestPlayers"] as List<object>)
                                {
                                    codeLock.guestPlayers.Add(Convert.ToUInt64(userId));
                                }
                            }
                        }

                        codeLock.SetFlag(BaseEntity.Flags.Locked, true);
                    }
                }
                else if (slotEntity.GetComponent<KeyLock>())
                {
                    var code = Convert.ToInt32(slotData["code"]);
                    var keyLock = slotEntity.GetComponent<KeyLock>();

                    if ((code & 0x80) != 0)
                    {
                        keyLock.keyCode = code & 0x7F;
                        keyLock.firstKeyCreated = true;
                        keyLock.SetFlag(BaseEntity.Flags.Locked, true);
                    }

                    if (pasteData.Ownership && slotData.ContainsKey("ownerId"))
                    {
                        keyLock.OwnerID = Convert.ToUInt64(slotData["ownerId"]);
                    }
                }
            }

            return entitySlots;
        }

        private object TryPasteBack(string filename, BasePlayer player, string[] args)
        {
            var path = _subDirectory + filename;

            if (!Interface.Oxide.DataFileSystem.ExistsDatafile(path))
                return Lang("FILE_NOT_EXISTS", player?.UserIDString);

            var data = Interface.Oxide.DataFileSystem.GetDatafile(path);

            if (data["default"] == null || data["entities"] == null)
                return Lang("FILE_BROKEN", player?.UserIDString);

            var defaultdata = data["default"] as Dictionary<string, object>;
            var pos = defaultdata["position"] as Dictionary<string, object>;
            var rotationCorrection = Convert.ToSingle(defaultdata["rotationdiff"]);
            var startPos = new Vector3(Convert.ToSingle(pos["x"]), Convert.ToSingle(pos["y"]),
                Convert.ToSingle(pos["z"]));

            return TryPaste(startPos, filename, player, rotationCorrection, args, autoHeight: false);
        }

        //Сhat commands

        [ChatCommand("copy")]
        private void CmdChatCopy(BasePlayer player, string command, string[] args)
        {
            if (!HasAccess(player, _copyPermission))
            {
                SendReply(player, Lang("NO_ACCESS", player.UserIDString));
                return;
            }

            if (args.Length < 1)
            {
                SendReply(player, Lang("SYNTAX_COPY", player.UserIDString));
                return;
            }

            var savename = args[0];
            var success = TryCopyFromSteamId(player.userID, savename, args.Skip(1).ToArray());

            if (success is string)
            {
                SendReply(player, (string) success);
            }
        }

        [ChatCommand("paste")]
        private void CmdChatPaste(BasePlayer player, string command, string[] args)
        {
            if (!HasAccess(player, _pastePermission))
            {
                SendReply(player, Lang("NO_ACCESS", player.UserIDString));
                return;
            }

            if (args.Length < 1)
            {
                SendReply(player, Lang("SYNTAX_PASTE_OR_PASTEBACK", player.UserIDString));
                return;
            }

            var success = TryPasteFromSteamId(player.userID, args[0], args.Skip(1).ToArray());

            if (success is string)
            {
                SendReply(player, (string) success);
            }
        }

        [ChatCommand("copylist")]
        private void CmdChatList(BasePlayer player, string command, string[] args)
        {
            if (!HasAccess(player, _listPermission))
            {
                SendReply(player, Lang("NO_ACCESS", player.UserIDString));
                return;
            }

            var files = Interface.Oxide.DataFileSystem.GetFiles(_subDirectory);

            var fileList = new List<string>();

            foreach (var file in files)
            {
                var strFileParts = file.Split('/');
                var justfile = strFileParts[strFileParts.Length - 1].Replace(".json", "");
                fileList.Add(justfile);
            }

            SendReply(player, Lang("AVAILABLE_STRUCTURES", player.UserIDString));
            SendReply(player, string.Join(", ", fileList.ToArray()));
        }

        [ChatCommand("pasteback")]
        private void CmdChatPasteBack(BasePlayer player, string command, string[] args)
        {
            if (!HasAccess(player, _pastebackPermission))
            {
                SendReply(player, Lang("NO_ACCESS", player.UserIDString));
                return;
            }

            var result = CmdPasteBack(player, args);

            if (result is string)
                SendReply(player, (string) result);
        }

        [ChatCommand("undo")]
        private void CmdChatUndo(BasePlayer player, string command, string[] args)
        {
            if (!HasAccess(player, _undoPermission))
            {
                SendReply(player, Lang("NO_ACCESS", player.UserIDString));
                return;
            }

            CmdUndo(player.UserIDString, args);
        }

        //Console commands [From Server]

        [ConsoleCommand("pasteback")]
        private void CmdConsolePasteBack(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin)
                return;

            var result = CmdPasteBack(arg.Player(), arg.Args);

            if (result is string)
                SendReply(arg, (string) result);
        }

        [ConsoleCommand("undo")]
        private void CmdConsoleUndo(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin)
                return;

            var player = arg.Player();

            CmdUndo(player == null ? _serverId : player.UserIDString, arg.Args);
        }

        //Replace between old ItemID to new ItemID

        private static readonly Dictionary<int, int> ReplaceItemId = new Dictionary<int, int>
        {
            {-1461508848, 1545779598},
            {2115555558, 588596902},
            {-533875561, 785728077},
            {1621541165, 51984655},
            {-422893115, -1691396643},
            {815896488, -1211166256},
            {805088543, -1321651331},
            {449771810, 605467368},
            {1152393492, 1712070256},
            {1578894260, -742865266},
            {1436532208, 1638322904},
            {542276424, -1841918730},
            {1594947829, -17123659},
            {-1035059994, -1685290200},
            {1818890814, -1036635990},
            {1819281075, -727717969},
            {1685058759, -1432674913},
            {93029210, 1548091822},
            {-1565095136, 352130972},
            {-1775362679, 215754713},
            {-1775249157, 14241751},
            {-1280058093, -1023065463},
            {-420273765, -1234735557},
            {563023711, -2139580305},
            {790921853, -262590403},
            {-337261910, -2072273936},
            {498312426, -1950721390},
            {504904386, 1655650836},
            {-1221200300, -559599960},
            {510887968, 15388698},
            {-814689390, 866889860},
            {1024486167, 1382263453},
            {2021568998, 609049394},
            {97329, 1099314009},
            {1046072789, -582782051},
            {97409, -1273339005},
            {-1480119738, -1262185308},
            {1611480185, 1931713481},
            {-1386464949, 1553078977},
            {93832698, 1776460938},
            {-1063412582, -586342290},
            {-1887162396, -996920608},
            {-55660037, 1588298435},
            {919780768, 1711033574},
            {-365801095, 1719978075},
            {68998734, 613961768},
            {-853695669, 1443579727},
            {271534758, 833533164},
            {-770311783, -180129657},
            {-1192532973, 1424075905},
            {-307490664, 1525520776},
            {707427396, 602741290},
            {707432758, -761829530},
            {-2079677721, 1783512007},
            {-1342405573, -1316706473},
            {-139769801, 1946219319},
            {-1043746011, -700591459},
            {2080339268, 1655979682},
            {-171664558, -1941646328},
            {1050986417, -1557377697},
            {-1693683664, 1789825282},
            {523409530, 1121925526},
            {1300054961, 634478325},
            {-2095387015, 1142993169},
            {1428021640, 1104520648},
            {94623429, 1534542921},
            {1436001773, -1938052175},
            {1711323399, 1973684065},
            {1734319168, -1848736516},
            {-1658459025, -1440987069},
            {-726947205, -751151717},
            {-341443994, 363467698},
            {1540879296, 2009734114},
            {94756378, -858312878},
            {3059095, 204391461},
            {3059624, 1367190888},
            {2045107609, -778875547},
            {583366917, 998894949},
            {2123300234, 1965232394},
            {1983936587, -321733511},
            {1257201758, -97956382},
            {-1144743963, 296519935},
            {-1144542967, -113413047},
            {-1144334585, -2022172587},
            {1066729526, -1101924344},
            {-1598790097, 1390353317},
            {-933236257, 1221063409},
            {-1575287163, -1336109173},
            {-2104481870, -2067472972},
            {-1571725662, 1353298668},
            {1456441506, 1729120840},
            {1200628767, -1112793865},
            {-778796102, 1409529282},
            {1526866730, 674734128},
            {1925723260, -1519126340},
            {1891056868, 1401987718},
            {1295154089, -1878475007},
            {498591726, 1248356124},
            {1755466030, -592016202},
            {726730162, 798638114},
            {-1034048911, -1018587433},
            {252529905, 274502203},
            {471582113, -1065444793},
            {-1138648591, 16333305},
            {305916740, 649305914},
            {305916742, 649305916},
            {305916744, 649305918},
            {1908328648, -1535621066},
            {-2078972355, 1668129151},
            {-533484654, 989925924},
            {1571660245, 1569882109},
            {1045869440, -1215753368},
            {1985408483, 528668503},
            {97513422, 304481038},
            {1496470781, -196667575},
            {1229879204, 952603248},
            {-1722829188, 936496778},
            {1849912854, 1948067030},
            {-1266285051, 1413014235},
            {-1749787215, -1000573653},
            {28178745, -946369541},
            {-505639592, -1999722522},
            {1598149413, -1992717673},
            {-1779401418, -691113464},
            {-57285700, -335089230},
            {98228420, 479143914},
            {1422845239, 999690781},
            {277631078, -1819763926},
            {115739308, 1366282552},
            {-522149009, -690276911},
            {3175989, -1899491405},
            {718197703, -746030907},
            {384204160, 1840822026},
            {-1308622549, 143803535},
            {-217113639, -2124352573},
            {-1580059655, -265876753},
            {-1832205789, 1070894649},
            {305916741, 649305917},
            {936777834, 3222790},
            {-1224598842, 200773292},
            {-1976561211, -1506397857},
            {-1406876421, 1675639563},
            {-1397343301, -23994173},
            {1260209393, 850280505},
            {-1035315940, 1877339384},
            {-1381682752, 1714496074},
            {696727039, -1022661119},
            {-2128719593, -803263829},
            {-1178289187, -1903165497},
            {1351172108, 1181207482},
            {-450738836, -1539025626},
            {-966287254, -324675402},
            {340009023, 671063303},
            {124310981, -1478212975},
            {1501403549, -2094954543},
            {698310895, -1252059217},
            {523855532, 1266491000},
            {2045246801, -886280491},
            {583506109, -237809779},
            {-148163128, 794356786},
            {-132588262, -1773144852},
            {-1666761111, 196700171},
            {-465236267, 442289265},
            {-1211618504, 1751045826},
            {2133577942, -1982036270},
            {-1014825244, -682687162},
            {-991829475, 1536610005},
            {-642008142, -1709878924},
            {661790782, 1272768630},
            {-1440143841, -1780802565},
            {569119686, 1746956556},
            {1404466285, -1102429027},
            {-1616887133, -48090175},
            {-1167640370, -1163532624},
            {-1284735799, 1242482355},
            {-1278649848, -1824943010},
            {776005741, 1814288539},
            {108061910, -316250604},
            {255101535, -1663759755},
            {-51678842, 1658229558},
            {-789202811, 254522515},
            {516382256, -132516482},
            {50834473, 1381010055},
            {-975723312, 1159991980},
            {1908195100, -850982208},
            {-1097452776, -110921842},
            {146685185, -1469578201},
            {-1716193401, -1812555177},
            {193190034, -2069578888},
            {371156815, -852563019},
            {3343606, -1966748496},
            {825308669, -1137865085},
            {830965940, -586784898},
            {1662628660, -163828118},
            {1662628661, -163828117},
            {1662628662, -163828112},
            {-1832205788, 1070894648},
            {-1832205786, 1070894646},
            {1625090418, 181590376},
            {-1269800768, -874975042},
            {429648208, -1190096326},
            {-1832205787, 1070894647},
            {-1832205785, 1070894645},
            {107868, 696029452},
            {997973965, -2012470695},
            {-46188931, -702051347},
            {-46848560, -194953424},
            {-2066726403, -989755543},
            {-2043730634, 1873897110},
            {1325935999, -1520560807},
            {-225234813, -78533081},
            {-202239044, -1509851560},
            {-322501005, 1422530437},
            {-1851058636, 1917703890},
            {-1828062867, -1162759543},
            {-1966381470, -1130350864},
            {968732481, 1391703481},
            {991728250, -242084766},
            {-253819519, 621915341},
            {-1714986849, 1827479659},
            {-1691991080, 813023040},
            {179448791, -395377963},
            {431617507, -1167031859},
            {688032252, 69511070},
            {-1059362949, -4031221},
            {1265861812, 1110385766},
            {374890416, 317398316},
            {1567404401, 1882709339},
            {-1057402571, 95950017},
            {-758925787, -1130709577},
            {-1411620422, 1052926200},
            {88869913, -542577259},
            {-2094080303, 1318558775},
            {843418712, -1962971928},
            {-1569356508, -1405508498},
            {-1569280852, 1478091698},
            {449769971, 1953903201},
            {590532217, -2097376851},
            {3387378, 1414245162},
            {1767561705, 1992974553},
            {106433500, 237239288},
            {-1334615971, -1778159885},
            {-135651869, 1722154847},
            {-1595790889, 1850456855},
            {-459156023, -1695367501},
            {106434956, -1779183908},
            {-578028723, -1302129395},
            {-586116979, 286193827},
            {-1379225193, -75944661},
            {-930579334, 649912614},
            {548699316, 818877484},
            {142147109, 1581210395},
            {148953073, 1903654061},
            {102672084, 980333378},
            {640562379, -1651220691},
            {-1732316031, -1622660759},
            {-2130280721, 756517185},
            {-1725510067, -722241321},
            {1974032895, -1673693549},
            {-225085592, -567909622},
            {509654999, 1898094925},
            {466113771, -1511285251},
            {2033918259, 1373971859},
            {2069925558, -1736356576},
            {-1026117678, 803222026},
            {1987447227, -1861522751},
            {540154065, -544317637},
            {1939428458, 176787552},
            {-288010497, -2002277461},
            {-847065290, 1199391518},
            {3506021, 963906841},
            {649603450, 442886268},
            {3506418, 1414245522},
            {569935070, -1104881824},
            {113284, -1985799200},
            {1916127949, -277057363},
            {-1775234707, -1978999529},
            {-388967316, 1326180354},
            {2007564590, -575483084},
            {-1705696613, 177226991},
            {670655301, -253079493},
            {1148128486, -1958316066},
            {-141135377, 567235583},
            {109266897, -932201673},
            {-527558546, 2087678962},
            {-1745053053, -904863145},
            {1223860752, 573926264},
            {-419069863, 1234880403},
            {-1617374968, -1994909036},
            {2057749608, 1950721418},
            {24576628, -2025184684},
            {-1659202509, 1608640313},
            {2107229499, -1549739227},
            {191795897, -765183617},
            {-1009492144, 795371088},
            {2077983581, -1367281941},
            {378365037, 352499047},
            {-529054135, -1199897169},
            {-529054134, -1199897172},
            {486166145, -1023374709},
            {1628490888, 23352662},
            {1498516223, 1205607945},
            {-632459882, -1647846966},
            {-626812403, -845557339},
            {385802761, -1370759135},
            {2117976603, 121049755},
            {1338515426, -996185386},
            {-1455694274, 98508942},
            {1579245182, 2070189026},
            {-587434450, 1521286012},
            {-163742043, 1542290441},
            {-1224714193, -1832422579},
            {644359987, 826309791},
            {-1962514734, -143132326},
            {-705305612, 1153652756},
            {-357728804, -1819233322},
            {-698499648, -1138208076},
            {1213686767, -1850571427},
            {386382445, -855748505},
            {1859976884, 553887414},
            {960793436, 996293980},
            {1001265731, 2048317869},
            {1253290621, -1754948969},
            {470729623, -1293296287},
            {1051155022, -369760990},
            {865679437, -1878764039},
            {927253046, -1039528932},
            {109552593, 1796682209},
            {-2092529553, 1230323789},
            {691633666, -363689972},
            {-2055888649, 1629293099},
            {621575320, -41440462},
            {-2118132208, 1602646136},
            {-1127699509, 1540934679},
            {-685265909, -92759291},
            {552706886, -1100422738},
            {1835797460, -1021495308},
            {-892259869, 642482233},
            {-1623330855, -465682601},
            {-1616524891, 1668858301},
            {789892804, 171931394},
            {-1289478934, -1583967946},
            {-892070738, -2099697608},
            {-891243783, -1581843485},
            {889398893, -1157596551},
            {-1625468793, 1397052267},
            {1293049486, 1975934948},
            {1369769822, 559147458},
            {586484018, 1079279582},
            {110115790, 593465182},
            {1490499512, 1523195708},
            {3552619, 2019042823},
            {1471284746, 73681876},
            {456448245, -1758372725},
            {110547964, 795236088},
            {1588977225, -1667224349},
            {918540912, -209869746},
            {-471874147, 1686524871},
            {205978836, 1723747470},
            {-1044400758, -129230242},
            {-2073307447, -1331212963},
            {435230680, 2106561762},
            {-864578046, 223891266},
            {1660607208, 935692442},
            {260214178, -1478445584},
            {-1847536522, 198438816},
            {-496055048, -967648160},
            {-1792066367, 99588025},
            {562888306, -956706906},
            {-427925529, -1429456799},
            {995306285, 1451568081},
            {-378017204, -1117626326},
            {447918618, -148794216},
            {313836902, 1516985844},
            {1175970190, -796583652},
            {525244071, -148229307},
            {-1021702157, -819720157},
            {-402507101, 671706427},
            {-1556671423, -1183726687},
            {61936445, -1614955425},
            {112903447, -1779180711},
            {1817873886, -1100168350},
            {1824679850, -132247350},
            {-1628526499, -1863559151},
            {547302405, -119235651},
            {1840561315, 2114754781},
            {-460592212, -1379835144},
            {3655341, -151838493},
            {1554697726, 418081930},
            {-1883959124, 832133926},
            {-481416622, 1524187186},
            {-481416621, -41896755},
            {-481416620, -1607980696},
            {-1151126752, 1058261682},
            {-1926458555, 794443127}
        };

        //Languages phrases

        private readonly Dictionary<string, Dictionary<string, string>> _messages =
            new Dictionary<string, Dictionary<string, string>>
            {
                {
                    "FILE_NOT_EXISTS", new Dictionary<string, string>
                    {
                        {"en", "File does not exist"},
                        {"ru", "Файл не существует"},
                        {"nl", "Bestand bestaat niet."}
                    }
                },
                {
                    "FILE_BROKEN", new Dictionary<string, string>
                    {
                        {"en", "Something went wrong during pasting because of a error in the file."},
                        {"ru", "Файл поврежден, вставка невозможна"},
                        {"nl", "Er is iets misgegaan tijdens het plakken door een beschadigd bestand."}
                    }
                },
                {
                    "NO_ACCESS", new Dictionary<string, string>
                    {
                        {"en", "You don't have the permissions to use this command"},
                        {"ru", "У вас нет прав доступа к данной команде"},
                        {"nl", "U heeft geen toestemming/permissie om dit commando te gebruiken."}
                    }
                },
                {
                    "SYNTAX_PASTEBACK", new Dictionary<string, string>
                    {
                        {
                            "en", "Syntax: /pasteback <Target Filename> <options values>\n" +
                                  "height XX - Adjust the height\n" +
                                  "vending - Information and sellings in vending machine\n" +
                                  "stability <true/false> - Wether or not to disable stability\n" +
                                  "deployables <true/false> - Wether or not to copy deployables\n" +
                                  "auth <true/false> - Wether or not to copy lock and cupboard whitelists"
                        },
                        {
                            "ru", "Синтаксис: /pasteback <Название Объекта> <опция значение>\n" +
                                  "height XX - Высота от земли\n" +
                                  "vending - Информация и товары в торговом автомате"
                        },
                        {
                            "nl", "Syntax: /pasteback <Bestandsnaam> <opties waarden>\n" +
                                  "height XX - Pas de hoogte aan \n" +
                                  "vending <true/false> - Informatie en inventaris van \"vending machines\" kopiëren\n" +
                                  "stability <true/false> - of de stabiliteit van het gebouw uitgezet moet worden\n" +
                                  "deployables <true/false> - of de \"deployables\" gekopiërd moeten worden\n" +
                                  "auth <true/false> - Of authorisatie op sloten en tool cupboards gekopiërd moet worden"
                        }
                    }
                },
                {
                    "SYNTAX_PASTE_OR_PASTEBACK", new Dictionary<string, string>
                    {
                        {
                            "en", "Syntax: /paste or /pasteback <Target Filename> <options values>\n" +
                                  "height XX - Adjust the height\n" +
                                  "autoheight true/false - sets best height, carefull of the steep\n" +
                                  "blockcollision XX - blocks the entire paste if something the new building collides with something\n" +
                                  "deployables true/false - false to remove deployables\n" +
                                  "inventories true/false - false to ignore inventories\n" +
                                  "vending - Information and sellings in vending machine\n" +
                                  "stability <true/false> - Wether or not to disable stability on the building"
                        },
                        {
                            "ru", "Синтаксис: /paste or /pasteback <Название Объекта> <опция значение>\n" +
                                  "height XX - Высота от земли\n" +
                                  "autoheight true/false - автоматически подобрать высоту от земли\n" +
                                  "blockcollision XX - блокировать вставку, если что-то этому мешает\n" +
                                  "deployables true/false - false для удаления предметов\n" +
                                  "inventories true/false - false для игнорирования копирования инвентаря\n" +
                                  "vending - Информация и товары в торговом автомате"
                        },
                        {
                            "nl", "Syntax: /paste of /pasteback <Bestandsnaam> <opties waarden>\n" +
                                  "height XX - Pas de hoogte aan \n" +
                                  "autoheight true/false - probeert de optimale hoogte te vinden om gebouw te plaatsen. Werkt optimaal op vlakke grond.\n" +
                                  "vending true/false - Informatie en inventaris van \"vending machines\" kopiëren\n" +
                                  "stability <true/false> - of de stabiliteit van het gebouw uitgezet moet worden\n" +
                                  "deployables <true/false> - of de \"deployables\" gekopiërd moeten worden\n" +
                                  "auth <true/false> - Of authorisatie op sloten en tool cupboards gekopiërd moet worden"
                        }
                    }
                },
                {
                    "PASTEBACK_SUCCESS", new Dictionary<string, string>
                    {
                        {"en", "You've successfully placed back the structure"},
                        {"ru", "Постройка успешно вставлена на старое место"},
                        {"nl", "Het gebouw is succesvol teruggeplaatst."}
                    }
                },
                {
                    "PASTE_SUCCESS", new Dictionary<string, string>
                    {
                        {"en", "You've successfully pasted the structure"},
                        {"ru", "Постройка успешно вставлена"},
                        {"nl", "Het gebouw is succesvol geplaatst."}
                    }
                },
                {
                    "SYNTAX_COPY", new Dictionary<string, string>
                    {
                        {
                            "en", "Syntax: /copy <Target Filename> <options values>\n" +
                                  "radius XX (default 3) - The radius in which to search for the next object (performs this search from every other object)\n" +
                                  "method proximity/building (default proximity) - Building only copies objects which are part of the building, proximity copies everything (within the radius)\n" +
                                  "deployables true/false (saves deployables or not) - Wether to save deployables\n" +
                                  "inventories true/false (saves inventories or not) - Wether to save inventories of found objects with inventories."
                        },
                        {
                            "ru", "Синтаксис: /copy <Название Объекта> <опция значение>\n" +
                                  "radius XX (default 3)\n" +
                                  "method proximity/building (по умолчанию proximity)\n" +
                                  "deployables true/false (сохранять предметы или нет)\n" +
                                  "inventories true/false (сохранять инвентарь или нет)"
                        },
                        {
                            "nl", "Syntax: /copy <Bestandsnaam> <opties waarden>\n" +
                                  "radius XX (standaard 3) - De radius waarin copy paste naar het volgende object zoekt\n" +
                                  "method proximity/building (standaard proximity) - Building kopieërd alleen objecten die bij het gebouw horen, proximity kopieërd alles wat gevonden is\n" +
                                  "deployables true/false (saves deployables or not) - Of de data van gevonden \"deployables\" opgeslagen moet worden\n" +
                                  "inventories true/false (saves inventories or not) - Of inventarissen van objecten (kisten, tool cupboards, etc) opgeslagen moet worden"
                        }
                    }
                },
                {
                    "NO_ENTITY_RAY", new Dictionary<string, string>
                    {
                        {"en", "Couldn't ray something valid in front of you"},
                        {"ru", "Не удалось найти какой-либо объект перед вами"},
                        {"nl", "U kijkt niet naar een geschikt object om een kopie op te starten."}
                    }
                },
                {
                    "COPY_SUCCESS", new Dictionary<string, string>
                    {
                        {"en", "The structure was successfully copied as {0}"},
                        {"ru", "Постройка успешно скопирована под названием: {0}"},
                        {"nl", "Gebouw is succesvol gekopieërd"}
                    }
                },
                {
                    "NO_PASTED_STRUCTURE", new Dictionary<string, string>
                    {
                        {"en", "You must paste structure before undoing it"},
                        {"ru", "Вы должны вставить постройку перед тем, как отменить действие"},
                        {"nl", "U moet eerst een gebouw terugplaatsen alvorens deze ongedaan gemaakt kan worden (duhh)"}
                    }
                },
                {
                    "UNDO_SUCCESS", new Dictionary<string, string>
                    {
                        {"en", "You've successfully undid what you pasted"},
                        {"ru", "Вы успешно снесли вставленную постройку"},
                        {"nl", "Laatse geplaatste gebouw is succesvol ongedaan gemaakt."}
                    }
                },
                {
                    "NOT_FOUND_PLAYER", new Dictionary<string, string>
                    {
                        {"en", "Couldn't find the player"},
                        {"ru", "Не удалось найти игрока"},
                        {"nl", "Speler niet gevonden."}
                    }
                },
                {
                    "SYNTAX_BOOL", new Dictionary<string, string>
                    {
                        {"en", "Option {0} must be true/false"},
                        {"ru", "Опция {0} принимает значения true/false"},
                        {"nl", "Optie {0} moet true of false zijn"}
                    }
                },
                {
                    "SYNTAX_HEIGHT", new Dictionary<string, string>
                    {
                        {"en", "Option height must be a number"},
                        {"ru", "Опция height принимает только числовые значения"},
                        {"nl", "De optie height accepteert alleen nummers"}
                    }
                },
                {
                    "SYNTAX_BLOCKCOLLISION", new Dictionary<string, string>
                    {
                        {"en", "Option blockcollision must be a number, 0 will deactivate the option"},
                        {
                            "ru",
                            "Опция blockcollision принимает только числовые значения, 0 позволяет отключить проверку"
                        },
                        {"nl", "Optie blockcollision accepteert alleen nummers, 0 schakelt deze functionaliteit uit"}
                    }
                },
                {
                    "SYNTAX_RADIUS", new Dictionary<string, string>
                    {
                        {"en", "Option radius must be a number"},
                        {"ru", "Опция radius принимает только числовые значения"},
                        {"nl", "Optie height accepteert alleen nummers"}
                    }
                },
                {
                    "BLOCKING_PASTE", new Dictionary<string, string>
                    {
                        {"en", "Something is blocking the paste"},
                        {"ru", "Что-то препятствует вставке"},
                        {"nl", "Iets blokkeert het plaatsen van dit gebouw"}
                    }
                },
                {
                    "AVAILABLE_STRUCTURES", new Dictionary<string, string>
                    {
                        {"ru", "<color=orange>Доступные постройки:</color>"},
                        {"en", "<color=orange>Available structures:</color>"},
                        {"nl", "Beschikbare bestanden om te plaatsen zijn:"}
                    }
                }
            };

        public class CopyData
        {
            public BasePlayer Player;
            public Stack<Vector3> CheckFrom = new Stack<Vector3>();
            public HashSet<BaseEntity> HouseList = new HashSet<BaseEntity>();
            public List<object> RawData = new List<object>();
            public Vector3 SourcePos;
            public Vector3 SourceRot;
            public Action Callback;

            public string Filename;
            public int CurrentLayer;
            public float RotCor;
            public float Range;
            public bool SaveTree;
            public bool SaveShare;
            public CopyMechanics CopyMechanics;
            public bool EachToEach;
            public uint BuildingId = 0;

#if DEBUG
            public Stopwatch Sw = new Stopwatch();
#endif
        }

        public class PasteData
        {
            public ICollection<Dictionary<string, object>> Entities;
            public List<BaseEntity> PastedEntities = new List<BaseEntity>();
            public string Filename;

            public Dictionary<uint, Dictionary<string, object>> IoEntities =
                new Dictionary<uint, Dictionary<string, object>>();

            public BasePlayer Player;
            public List<StabilityEntity> StabilityEntities = new List<StabilityEntity>();
            public Quaternion QuaternionRotation;
            public Action Callback;

            public bool Auth;
            public Vector3 StartPos;
            public float HeightAdj;
            public bool Stability;
            public bool IsItemReplace;
            public bool Ownership;

            public uint BuildingId = 0;

#if DEBUG
            public Stopwatch Sw = new Stopwatch();
#endif
        }
    }
}

// --- End of file: CopyPaste.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HudRust/IQReportSystem.cs ---
// --- Original Local Path: HudRust/IQReportSystem.cs ---

﻿using System;
using System.Collections.Generic;
using UnityEngine;
using Newtonsoft.Json;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Libraries.Covalence;
using ConVar;
using Newtonsoft.Json.Linq;
using Oxide.Core.Libraries;
using System.Linq;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("IQReportSystem", "Mercury", "0.1.9")]
    class IQReportSystem : RustPlugin
    {
        /// <summary>
        /// - Поправил , когда игроки с меню в режиме оффлайн пропадали
        /// 
        /// Обновление 0.1.8 :
        /// - Исправил совместимость с IQFakeActive
        /// - Исправил метод с жалобой, когда не был установлен IQFakeActive
        /// - Исправлены страницы
        /// - Исправлен поиск по нику или SteamID 
        /// - Корректирован поиск по игрокам , теперь он ищет не зависимо от регистра
        /// - Оптимизировал плагин
        /// 
        ///  Обновление 0.1.9 :
        ///  - Обновлены страницы
        ///  - Поправлена ошибка с стимИд после поиска
        /// </summary>

        #region Reference
        [PluginReference] Plugin GameWerAC, ImageLibrary, MultiFighting, IQChat, Friends, IQPersonal, IQFakeActive;
        public string GetImage(string shortname, ulong skin = 0) => (string)ImageLibrary?.Call("GetImage", shortname, skin);
        public bool AddImage(string url, string shortname, ulong skin = 0) => (bool)ImageLibrary?.Call("AddImage", url, shortname, skin);
        public void SetCheck(BasePlayer player) => IQPersonal?.CallHook("API_SET_CHECK", player.userID);
        public void SetBans(BasePlayer player) => IQPersonal?.CallHook("API_SET_BANS", player.userID);
        public void SetScore(ulong UserID, int Amount) => IQPersonal?.CallHook("API_SET_SCORE", UserID, Amount);
        public void RemoveScore(ulong UserID, int Amount) => IQPersonal?.CallHook("API_REMOVE_SCORE", UserID, Amount);

        #region IQFakeActive
        public bool IsFake(ulong userID)
        {
            if (!IQFakeActive) return false;
            if (!config.IQFakeActiveSettings.UseIQFakeActive) return false;

            return (bool)IQFakeActive?.Call("IsFake", userID);
        }
        public string FindFakeName(ulong userID) => (string)IQFakeActive?.Call("FindFakeName", userID);
        public void StartSysncFakeActive() => IQFakeActive?.Call("SyncReserved");
        void SyncReservedFinish(string JSON)
        {
            if (!config.IQFakeActiveSettings.UseIQFakeActive) return;
            List<FakePlayer> ContentDeserialize = JsonConvert.DeserializeObject<List<FakePlayer>>(JSON);
            PlayerBases = ContentDeserialize;

            PrintWarning("IQReportSystem - успешно синхронизирована с IQFakeActive");
            PrintWarning("=============SYNC==================");

            
        }
        public List<FakePlayer> PlayerBases = new List<FakePlayer>();
        public class FakePlayer
        {
            public ulong UserID;
            public string DisplayName;
            public string IQChatPreifx;
            public string IQChatColorChat;
            public string IQChatColorNick;
        }
        #endregion

        #endregion

        #region Vars

        #region Permission
        string PermissionModeration = "moderation.iqreportsystem";
        string PermissionAdmin = "admin.iqreportsystem";
        #endregion

        #region Lists
        public Dictionary<ulong, int> CooldownPC = new Dictionary<ulong, int>();
        public Dictionary<ulong, PlayerSaveCheckClass> PlayerSaveCheck = new Dictionary<ulong, PlayerSaveCheckClass>();
        public class PlayerSaveCheckClass
        {
            public string Discord;
            public string NickName;
            public string StatusNetwork;

            public ulong ModeratorID;
        }
        #endregion

        #region JSON
        private class Response
        {
            public List<string> last_ip;
            public string last_nick;
            public List<ulong> another_accs;
            public List<last_checks> last_check;
            public class last_checks
            {
                public ulong moderSteamID;
                public string serverName;
                public int time;
            }
            public List<RustCCBans> bans;
            public class RustCCBans
            {
                public int banID;
                public string reason;
                public string serverName;
                public int OVHserverID;
                public int banDate;
            }
        }
        #endregion

        #endregion

        #region Configuration
        private static Configuration config = new Configuration();
        public class Configuration
        {
            [JsonProperty("Основные настройки")]
            public Settings Setting = new Settings();
            [JsonProperty("Причины репорта")]
            public List<string> ReasonReport = new List<string>();
            [JsonProperty("Причины блокировки")] 
            public List<BanReason> ReasonBan = new List<BanReason>();
            [JsonProperty("Настройки RustCheatCheck(Будет при проверке выдавать доступ в чекер и выводить информацию модератору)")]
            public RCCSettings RCCSetting = new RCCSettings();
            [JsonProperty("Настройка репутации для проверяющих")]
            public RaitingSettings RaitingSetting = new RaitingSettings();
            [JsonProperty("Настройка совместной работы с IQFakeActive")]
            public IQFakeActive IQFakeActiveSettings = new IQFakeActive();
            internal class BanReason
            {
                [JsonProperty("Название")]
                public string DisplayName;
                [JsonProperty("Команда")]
                public string Command;
            }
            internal class RCCSettings
            {
                [JsonProperty("Включить поддержку RCC")]
                public bool RCCUse;
                [JsonProperty("Ключ от RCC")]
                public string Key;
            }
            internal class RaitingSettings
            {
                [JsonProperty("Сколько репутации снимать за 1-2 звезды(IQPersonal)")]
                public int RemoveAmountOneTwo;
                [JsonProperty("Сколько репутации давать за 3-4 звезды(IQPersonal)")]
                public int GiveAmountThreeFour;
                [JsonProperty("Сколько репутации давать за 5 звезд(IQPersonal)")]
                public int GiveAmountFive;
            }
            internal class IQFakeActive
            {
                [JsonProperty("Использовать IQFakeActive")]
                public bool UseIQFakeActive;
            }
            internal class Settings
            {
                [JsonProperty("Настройки IQChat")]
                public ChatSettings ChatSetting = new ChatSettings();
                [JsonProperty("Настройки интерфейса")]
                public InterfaceSetting Interface = new InterfaceSetting();

                [JsonProperty("Включить/отключить общее оповоещение для всех игроков(если игрока вызвали на проверку или вынесли вердикт,сообщение будет видно всем)")]
                public bool UseAlertUsers;

                [JsonProperty("Включить/отключить оповещение о максимальном кол-во репортов")]
                public bool MaxReportAlert;
                [JsonProperty("Максимальное количество репортов")]
                public int MaxReport;
                [JsonProperty("Перезарядка для отправки репорта(секунды)")]
                public int CooldownTime;
                [JsonProperty("Запретить друзьям репортить друг друга")]
                public bool FriendNoReport;
                [JsonProperty("Включить логирование в беседу ВК")]
                public bool VKMessage;
                [JsonProperty("Включить логирование в Discord")]
                public bool DiscrodMessage;
                [JsonProperty("Webhooks для дискорда")]
                public string WebHook;
                [JsonProperty("Настройки ВК")]
                public VKSetting VKSettings = new VKSetting();

                internal class ChatSettings
                {
                    [JsonProperty("IQChat : Кастомный префикс в чате")]
                    public string CustomPrefix;
                    [JsonProperty("IQChat : Кастомный аватар в чате(Если требуется)")]
                    public string CustomAvatar;
                }
                internal class VKSetting
                {
                    [JsonProperty("Токен от группы ВК(От группы будут идти сообщения в беседу.Вам нужно добавить свою группу в беседу!)")]
                    public string Token;
                    [JsonProperty("ID беседы для группы")]
                    public string ChatID;
                }
                internal class InterfaceSetting
                {
                    [JsonProperty("Настройка интерфейса для отправки жалобы")]
                    public ReasonInterfaceSetting ReasonInterface = new ReasonInterfaceSetting();
                    [JsonProperty("Настройка интерфейса для уведомления")]
                    public AlertInterfaceSettings AlertInterface = new AlertInterfaceSettings(); 
                    [JsonProperty("Настройка интерфейса для мини-панели модератора")]
                    public ModeratorPanelInterfaceSettings ModderatorPanel = new ModeratorPanelInterfaceSettings(); 
                    [JsonProperty("Настройка интерфейса для рейтинга")]
                    public RaitingInterfaceSettings RaitingInterface = new RaitingInterfaceSettings();
                    [JsonProperty("Sprite для рейтинга(звезды)")]
                    public string SpriteRaiting;
                    [JsonProperty("Sprite для кнопки жалоб в панели модератора")]
                    public string SpriteReportModeration;
                    [JsonProperty("Sprite для иконки жалоб")]
                    public string SpriteReport;
                    [JsonProperty("Цвет текста в плагине")]
                    public string HexLabels;
                    [JsonProperty("Цвет боковой панели")]
                    public string HexRightMenu;
                    [JsonProperty("Цвет кнопок боковой панели")]
                    public string HexButtonRightMenu;
                    [JsonProperty("Цвет основной панели")]
                    public string HexMainPanel;
                    [JsonProperty("Цвет панели поиска и заднего фона игроков")]
                    public string HexSearchPanel; 
                    [JsonProperty("Цвет кнопки у игрока для перехода к действию")]
                    public string HexPlayerButton;
                    [JsonProperty("Sprite кнопки у игрока для преехода к действию")]
                    public string SpritePlayerButton;

                    internal class ReasonInterfaceSetting
                    {
                        [JsonProperty("Цвет основной панели")]
                        public string HexMain;
                        [JsonProperty("Цвет панели с заголовком")]
                        public string HexTitlePanel;
                        [JsonProperty("Цвет жалоб")]
                        public string HexButton;
                        [JsonProperty("Цвет текста с жалобами")]
                        public string HexLabel;
                        [JsonProperty("Sprite кнопки закрыть")]
                        public string SpriteClose;             
                        [JsonProperty("Sprite панели с заголовком")]
                        public string SpriteTitlePanel;
                        [JsonProperty("Цвет кнопки закрыть")]
                        public string HexClose;
                    }
                    internal class AlertInterfaceSettings
                    {
                        [JsonProperty("Цвет основной панели")]
                        public string HexMain;
                        [JsonProperty("Цвет заголовка и полоски")]
                        public string HexTitle;
                        [JsonProperty("Цвет текста")]
                        public string HexLabel;
                    }
                    internal class ModeratorPanelInterfaceSettings
                    {
                        [JsonProperty("Цвет основной панели")]
                        public string HexMain;
                        [JsonProperty("Цвет панели с заголовком")]
                        public string HexTitlePanel;
                        [JsonProperty("Sprite панели с заголовком")]
                        public string SpriteTitlePanel;
                        [JsonProperty("Цвет текста")]
                        public string HexLabel;
                        [JsonProperty("Цвет кнопки вердикт и задний фон причин")]
                        public string HexBanButton;
                        [JsonProperty("Цвет кнопки окончания проверки")]
                        public string HexStopButton;
                    }
                    internal class RaitingInterfaceSettings
                    {
                        [JsonProperty("Цвет основной панели")]
                        public string HexMain;
                        [JsonProperty("Цвет панели с заголовком")]
                        public string HexTitlePanel;
                        [JsonProperty("Sprite панели с заголовком")]
                        public string SpriteTitlePanel;
                        [JsonProperty("Цвет текста")]
                        public string HexLabel;
                        [JsonProperty("Цвет иконок с рейтингом")]
                        public string HexRaitingButton;
                        [JsonProperty("Sprite рейтинга")]
                        public string SpriteRaiting;
                    }
                }
            }

            public static Configuration GetNewConfiguration()
            {
                return new Configuration
                {
                    Setting = new Settings
                    {
                        UseAlertUsers = true,
                        FriendNoReport = false,
                        MaxReport = 3,
                        MaxReportAlert = true,
                        CooldownTime = 600,
                        VKMessage = true,
                        DiscrodMessage = false,
                        WebHook = "",
                        ChatSetting = new Settings.ChatSettings
                        {
                            CustomAvatar = "",
                            CustomPrefix = ""
                        },
                        VKSettings = new Settings.VKSetting
                        {
                            Token = "",
                            ChatID = ""
                        },
                        Interface = new Settings.InterfaceSetting
                        {
                            SpriteRaiting = "assets/icons/favourite_servers.png",
                            SpriteReportModeration = "assets/icons/subtract.png",
                            SpriteReport = "assets/icons/examine.png",
                            SpritePlayerButton = "assets/icons/vote_up.png",
                            HexPlayerButton = "#45542BFF",
                            HexLabels = "#DAD1C7FF",
                            HexButtonRightMenu = "#802A2AFF",
                            HexMainPanel = "#21211AF2",
                            HexRightMenu = "#762424FF",
                            HexSearchPanel = "#3B3D37FF",
                            ReasonInterface = new Settings.InterfaceSetting.ReasonInterfaceSetting
                            {
                                HexMain = "#585450FF",
                                HexTitlePanel = "#54514DFF",
                                HexButton = "#3E482EFF",
                                HexClose = "#B4371EFF",
                                HexLabel = "#bdd197",
                                SpriteClose = "assets/icons/vote_down.png",
                                SpriteTitlePanel = "assets/icons/connection.png"
                            },
                            AlertInterface = new Settings.InterfaceSetting.AlertInterfaceSettings
                            {
                                HexMain = "#21211AF2",
                                HexLabel = "#DAD1C7FF",
                                HexTitle = "#B4371EFF",
                            },
                            ModderatorPanel = new Settings.InterfaceSetting.ModeratorPanelInterfaceSettings
                            {
                                HexMain = "#575450FF",
                                HexTitlePanel = "#54514DFF",
                                HexLabel = "#DAD1C7FF",
                                SpriteTitlePanel = "assets/icons/study.png",
                                HexBanButton = "#B4371EFF",
                                HexStopButton = "#3E482EFF"
                            },
                            RaitingInterface = new Settings.InterfaceSetting.RaitingInterfaceSettings
                            {
                                HexMain = "#575450FF",
                                HexTitlePanel = "#54514DFF",
                                HexLabel = "#DAD1C7FF",
                                HexRaitingButton = "#cdb980",
                                SpriteTitlePanel = "assets/icons/ignite.png",
                                SpriteRaiting = "assets/icons/favourite_servers.png"
                            }
                        }
                    },
                    ReasonReport = new List<string>
                    {
                        "Использование читов",
                        "Макросы",
                        "Игра 3+",                      
                    },
                    ReasonBan = new List<BanReason>
                    { 
                        new BanReason
                        {
                            DisplayName = "Использование читов",
                            Command = "ban {0} soft",
                        },
                        new BanReason
                        {
                            DisplayName = "Макросы",
                            Command = "ban {0} 30d macros",
                        },
                        new BanReason
                        {
                            DisplayName = "Игра 3+",
                            Command = "ban {0} 14d 3+",
                        },
                        new BanReason
                        {
                            DisplayName = "Отказ",
                            Command = "ban {0} 7d otkaz",
                        },
                    },
                    RCCSetting = new RCCSettings
                    {
                        RCCUse = false,
                        Key = "xxxxxxxxxxxxxxRCCKey",
                    },
                    IQFakeActiveSettings = new IQFakeActive
                    {
                      UseIQFakeActive = false,
                    },
                    RaitingSetting = new RaitingSettings
                    {
                        RemoveAmountOneTwo = 4,
                        GiveAmountThreeFour = 3,
                        GiveAmountFive = 5
                    }
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning($"Ошибка чтения конфигурации #93 'oxide/config/{Name}', создаём новую конфигурацию!!");
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewConfiguration();
        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion

        #region Data
        public Dictionary<ulong, PlayerInfo> ReportInformation = new Dictionary<ulong, PlayerInfo>();
        public Dictionary<ulong, ModeratorInfo> ModeratorInformation = new Dictionary<ulong, ModeratorInfo>();
        public class PlayerInfo
        {
            [JsonProperty("Отображаемое имя")]
            public string DisplayName;
            [JsonProperty("IP Адреса")]
            public List<string> IP;
            [JsonProperty("Последняя жалоба")]
            public string LastReport;
            [JsonProperty("Последний проверяющий модератор")]
            public string LastCheckModerator;
            [JsonProperty("Количество проверок")]
            public int CheckCount;
            [JsonProperty("История жалоб")]
            public List<string> ReportHistory;
            [JsonProperty("Количество жалоб")]
            public int ReportCount;
            [JsonProperty("Игровой статус")]
            public string GameStatus;
        }

        public class ModeratorInfo
        {
            [JsonProperty("Проверки игроков с вердиктами")]
            public Dictionary<string, string> CheckPlayerModerator = new Dictionary<string, string>();
            [JsonProperty("Блокировки игроков с вердиктом")]
            public Dictionary<string, string> BanPlayerModerator = new Dictionary<string, string>();
            [JsonProperty("Общее количество проверок")]
            public int CheckCount;
            [JsonProperty("История оценок модератора")]
            public List<int> Arrayrating;
            [JsonProperty("Средняя оценка качества")]
            public float AverageRating;
        }
        #endregion

        #region Metods

        #region MetodsReport

        void Metods_PlayerConnected(BasePlayer player)
        {
            if (player == null)
                return;
            if (!ReportInformation.ContainsKey(player.userID))
            {
                PlayerInfo pInfo = new PlayerInfo
                {
                    DisplayName = player.displayName,
                    IP = new List<string>(),
                    LastReport = "",
                    LastCheckModerator = "",
                    CheckCount = 0,
                    ReportCount = 0,
                    GameStatus = IsSteam(player.UserIDString),
                    ReportHistory = new List<string>(),
                };
                ReportInformation.Add(player.userID, pInfo);
            }
            else
            {
                var User = ReportInformation[player.userID];
                var IP = covalence.Players.FindPlayerById(player.UserIDString).Address;

                User.GameStatus = IsSteam(player.UserIDString);
                if (!String.IsNullOrWhiteSpace(IP))
                    if (!User.IP.Contains(IP))
                        User.IP.Add(IP);
            }

            if (permission.UserHasPermission(player.UserIDString, PermissionModeration))
            {
                if (!ModeratorInformation.ContainsKey(player.userID))
                {
                    ModeratorInfo mInfo = new ModeratorInfo
                    {
                        CheckCount = 0,
                        BanPlayerModerator = new Dictionary<string, string>(),
                        CheckPlayerModerator = new Dictionary<string, string>(),
                        Arrayrating = new List<int>(),
                        AverageRating = 0,
                    };
                    ModeratorInformation.Add(player.userID, mInfo);
                }
            }
            else
            {
                if (ModeratorInformation.ContainsKey(player.userID))
                    ModeratorInformation.Remove(player.userID);
            }
            Metods_StatusNetwork(player, lang.GetMessage("NETWORD_STATUS_ONLINE", this, player.UserIDString));
        }

        void Metods_Report(BasePlayer target, int ReasonIndex)
        {
            if (permission.UserHasPermission(target.UserIDString, PermissionAdmin))
                return;

            if (IsSteam(target.UserIDString) == lang.GetMessage("IS_STEAM_STATUS_PIRATE", this, target.UserIDString))
            {
                if (GameWerAC != null)
                {
                    GameWerAC.Call("GetScreenReport", target);
                    Puts("Выполнен скриншот экрана для пирата");
                }
            }

            string ReasonReport = config.ReasonReport[ReasonIndex];

            var User = ReportInformation[target.userID];
            User.ReportCount++;
            User.LastReport = ReasonReport;
            User.ReportHistory.Insert(0, ReasonReport);

            if (config.Setting.MaxReportAlert)
                if (User.ReportCount >= config.Setting.MaxReport)
                {
                    foreach (var MList in BasePlayer.activePlayerList)
                        if (permission.UserHasPermission(MList.UserIDString, PermissionModeration))
                            SendChat(MList, String.Format(lang.GetMessage("METODS_HELP_MODERS", this, MList.UserIDString), target.displayName, User.ReportCount));
                    VKSendMessage(String.Format(lang.GetMessage("METODS