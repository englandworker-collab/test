             },
                       },
                        useCustomLoot = true,
                        lootNpcs = new List<LootNpcOrBox>
                        {
                            new LootNpcOrBox{Shortname = "halloween.surgeonsuit", SkinID = 0, DisplayName = "", BluePrint = false, MinimalAmount = 1, MaximumAmount = 1, DropChance = 70 },
                            new LootNpcOrBox{Shortname = "metal.facemask", SkinID = 1886184322, DisplayName = "", BluePrint = false, MinimalAmount = 1, MaximumAmount = 1, DropChance = 20 },
                            new LootNpcOrBox{Shortname = "door.double.hinged.metal", SkinID = 191100000, DisplayName = "", BluePrint = false, MinimalAmount = 1, MaximumAmount = 2, DropChance = 60 },
                            new LootNpcOrBox{Shortname = "rifle.bolt", SkinID = 0, DisplayName = "", BluePrint = true, MinimalAmount = 1, MaximumAmount = 1, DropChance = 10 },
                            new LootNpcOrBox{Shortname = "rifle.lr300", SkinID = 0, DisplayName = "", BluePrint = false, MinimalAmount = 1, MaximumAmount = 1, DropChance = 15 },
                            new LootNpcOrBox{Shortname = "pistol.revolver", SkinID = 0, DisplayName = "", BluePrint = false, MinimalAmount = 1, MaximumAmount = 3, DropChance = 60 },
                            new LootNpcOrBox{Shortname = "supply.signal", SkinID = 0, DisplayName = "", BluePrint = false, MinimalAmount = 1, MaximumAmount = 3, DropChance = 20 },
                            new LootNpcOrBox{Shortname = "explosive.satchel", SkinID = 0, DisplayName = "", BluePrint = false, MinimalAmount = 1, MaximumAmount = 3, DropChance = 5 },
                            new LootNpcOrBox{Shortname = "grenade.smoke", SkinID = 0, DisplayName = "", BluePrint = false, MinimalAmount = 1, MaximumAmount = 20, DropChance = 45 },
                            new LootNpcOrBox{Shortname = "ammo.rifle", SkinID = 0, DisplayName = "", BluePrint = false, MinimalAmount = 50, MaximumAmount = 120, DropChance = 35 },
                            new LootNpcOrBox{Shortname = "scrap", SkinID = 0, DisplayName = "", BluePrint = false, MinimalAmount = 100, MaximumAmount = 500, DropChance = 20 },
                            new LootNpcOrBox{Shortname = "giantcandycanedecor", SkinID = 0, DisplayName = "Новый год", BluePrint = false, MinimalAmount = 1, MaximumAmount = 5, DropChance = 70 },
                        }
                    },
                    radiationConroller = new RadiationConroller
                    {
                        radUse = true,
                        radCount = 20
                    },
                    mapMarkers = new MapMarkers
                    {
                        rustMapUse = true,
                        rustMapIcon = "https://i.imgur.com/bwg6de6.png",
                        rustMapTxt = "Лабаратория кобальт",
                        MapUse = false,
                        MapTxt = "Лабаратория кобальт"
                    }
                };

            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                    LoadDefaultConfig();
            }
            catch
            {
                PrintWarning("Ошибка #132" + $"чтения конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!!");
                LoadDefaultConfig();
            }
            if (config.notiferSettings.colorBtnCloseUi == null)
            {
                config.notiferSettings.colorBtnCloseUi = "0.6784314 0.254902 0.1843137 0.8";
                config.notiferSettings.colorBackground = "0.8 0.28 0.2 0.8";
            }

            if (config.boxSetting.unBlockTime == 0)
            {
                config.boxSetting.unBlockTime = 900;
            }
            if (config.npcController.Accuracy == 0)
            {
                config.npcController.Accuracy = 40;
            }
            if (config.npcController.DistanceRange == 0)
            {
                config.npcController.DistanceRange = 130;
            }

            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewConfiguration();
        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion

        #region SpawnPoint

        #region CheckFlat
        private List<Vector3>[] patternPositionsAboveWater = new List<Vector3>[MaxRadius];
        private List<Vector3>[] patternPositionsUnderWater = new List<Vector3>[MaxRadius];

        private readonly Quaternion[] directions =
        {
            Quaternion.Euler(90, 0, 0),
            Quaternion.Euler(0, 0, 90),
            Quaternion.Euler(0, 0, 180)
        };

        private void FillPatterns()
        {
            Vector3[] startPositions = { new Vector3(1, 0, 1), new Vector3(-1, 0, 1), new Vector3(-1, 0, -1), new Vector3(1, 0, -1) };

            patternPositionsAboveWater[0] = new List<Vector3> { new Vector3(0, -1.0f, 0) };
            for (int loop = 1; loop < MaxRadius; loop++)
            {
                patternPositionsAboveWater[loop] = new List<Vector3>();

                for (int step = 0; step < loop * 2; step++)
                {
                    for (int pos = 0; pos < 4; pos++)
                    {
                        Vector3 sPos = startPositions[pos] * step;
                        for (int rot = 0; rot < 3; rot++)
                        {
                            Vector3 rPos = directions[rot] * sPos;
                            rPos.y = -1.0f;
                            patternPositionsAboveWater[loop].Add(rPos);
                        }
                    }
                }
            }

            for (int i = 0; i < patternPositionsAboveWater.Length; i++)
            {
                patternPositionsUnderWater[i] = new List<Vector3>();
                foreach (var vPos in patternPositionsAboveWater[i])
                {
                    var rPos = new Vector3(vPos.x, 1.0f, vPos.z);
                    patternPositionsUnderWater[i].Add(rPos);
                }
            }
        }

        [ConsoleCommand("isflat")]
        private void CmdIsFlat(ConsoleSystem.Arg arg)
        {
            Vector3 pPos = new Vector3(arg.Player().transform.position.x, TerrainMeta.HeightMap.GetHeight(arg.Player().transform.position), arg.Player().transform.position.z);
            var b = IsFlat(ref pPos);
            arg.Player().Teleport(pPos);
        }

        public bool IsFlat(ref Vector3 position)
        {
            List<Vector3>[] AboveWater = new List<Vector3>[MaxRadius];

            Array.Copy(patternPositionsAboveWater, AboveWater, patternPositionsAboveWater.Length);

            for (int i = 0; i < AboveWater.Length; i++)
            {
                for (int j = 0; j < AboveWater[i].Count; j++)
                {
                    Vector3 pPos = AboveWater[i][j];
                    Vector3 resultAbovePos = new Vector3(pPos.x + position.x, position.y + 1.0f, pPos.z + position.z);
                    Vector3 resultUnderPos = new Vector3(pPos.x + position.x, position.y - 1.0f, pPos.z + position.z);

                    if (resultAbovePos.y >= TerrainMeta.HeightMap.GetHeight(resultAbovePos) && resultUnderPos.y <= TerrainMeta.HeightMap.GetHeight(resultUnderPos))
                    {
                    }
                    else
                        return false;
                }
            }

            return true;
        }
        #endregion

        #region GenerateSpawnPoint

        public bool IsDistancePoint(Vector3 point)
        {
            bool result = busyPoints3D.Count(x => Vector3.Distance(point, x) < 20f) == 0;
            return result;
        }
        private void GenerateSpawnPoints()
        {
            for (int i = 0; i < 100; i++)
            {
                maxTry -= 1;
                Vector3 point3D = new Vector3();
                Vector2 point2D = new Vector3(UnityEngine.Random.Range(-TerrainMeta.Size.x / 2, TerrainMeta.Size.x / 2), UnityEngine.Random.Range(-TerrainMeta.Size.z / 2, TerrainMeta.Size.z / 2));

                point3D.x = point2D.x;
                point3D.z = point2D.y;
                point3D.y = TerrainMeta.HeightMap.GetHeight(point3D);

                if (!IsFlat(ref point3D))
                    continue;

                if (!Is3DPointValid(ref point3D))
                    continue;

                if (!IsDistancePoint(point3D))
                    continue;

                if (point3D != Vector3.zero)
                {
                    AcceptValue(ref point3D);
                }
            }
            if (maxTry > 0)
            {
                NextTick(() =>
                {
                    GenerateSpawnPoints();
                });
            }
            else
            {
                PrintWarning($"{busyPoints3D.Count} точек сгенерированно!");
                maxTry = 250000;
            }
        }
        private bool Is3DPointValid(ref Vector3 point)
        {
            List<BuildingPrivlidge> cupboards = new List<BuildingPrivlidge>();
            Vis.Entities(point, config.pasteSettings.radiusClear, cupboards);
            if (Physics.CheckSphere(point, config.pasteSettings.radiusClear, LayerMask.GetMask("Construction", "Default", "Deployed", "World", "Trigger", "Prevent Building")) || cupboards.Count > 0 || point.y < ConVar.Env.oceanlevel + 4f)
            {
                return false;
            }
            return true;
        }

        private void AcceptValue(ref Vector3 point)
        {
            busyPoints3D.Add(point);
        }
        #endregion

        #region GetPosition
        private object GetSpawnPoints()
        {
            if (busyPoints3D.ToList().Count <= 3)
            {
                PrintWarning("Все точки закончены!\n" +
                            "Начинаем генерировать новые...");
                busyPoints3D.Clear();
                GenerateSpawnPoints();
                GenerateIvent();
                return Vector3.zero;
            }

            Vector3 targetPos = busyPoints3D.ToList().GetRandom();
            if (targetPos == Vector3.zero)
            {
                busyPoints3D.Remove(targetPos);
                return GetSpawnPoints();
            }

            bool valid = Is3DPointValid(ref targetPos);

            if (!valid)
            {
                busyPoints3D.Remove(targetPos);
                return GetSpawnPoints();
            }
            busyPoints3D.Remove(targetPos);
            return targetPos;
        }
        #endregion

        #endregion

        #region Hooks
        void OnEntityMounted(BaseMountable entity, BasePlayer player)
        {
            if (HouseCobaltLab.Contains(entity?.GetParentEntity()))
                HouseCobaltLab.Remove(entity.GetParentEntity());
        }

        void Unload()
        {
            foreach (BaseEntity iventEnt in HouseCobaltLab)
            {
                if (!iventEnt.IsDestroyed)
                    iventEnt?.Kill();
            }
            HouseCobaltLab.Clear();
            if (SpawnHouseTime != null)
                SpawnHouseTime.Destroy();
            if (RemoveHouseTime != null)
                RemoveHouseTime.Destroy();
            DestroyZone();
            RemoveMapMarker();
            Cui.DestroyAllPlayer();
        }
        void Init()
        { UnscribeHook(); }

        private void OnServerInitialized()
        {
            if (!CopyPaste)
            {
                PrintError("Проверьте установлен ли у вас плагин 'CopyPaste'");
                Interface.Oxide.UnloadPlugin(Name);
                return;
            }
            else if (CopyPaste.Version < new VersionNumber(4, 1, 27))
            {
                PrintError("У вас старая версия CopyPaste!\nПожалуйста обновите плагин до последней версии (4.1.27 или выше) - https://umod.org/plugins/copy-paste");
                Interface.Oxide.UnloadPlugin(Name);
                return;
            }
            _ = this;
            FillPatterns();
            NextTick(() =>
            {
                GenerateSpawnPoints();
            });
            GenerateIvent();
            if (string.IsNullOrEmpty(config.pasteSettings.housepath))
                LoadDataCopyPaste();
        }
        private void CanHackCrate(BasePlayer player, HackableLockedCrate crate)
        {
            if (crate.OwnerID == 3566257)
            {
                if (RemoveHouseTime != null)
                    RemoveHouseTime.Destroy();
                if (config.boxSetting.signaling)
                {
                    var Alarm = GameManager.server.CreateEntity("assets/prefabs/deployable/playerioents/alarms/audioalarm.prefab", crate.transform.position, default(Quaternion), true);
                    Alarm.Spawn();
                    Alarm.SetFlag(BaseEntity.Flags.Reserved8, true);
                    Alarm.gameObject.Identity();
                    Alarm.SetParent(crate);

                    var Light = GameManager.server.CreateEntity("assets/prefabs/deployable/playerioents/lights/sirenlight/electric.sirenlight.deployed.prefab", crate.transform.position, Quaternion.identity, false);
                    Light.enableSaving = true;
                    Light.Spawn();
                    Light.SetParent(crate);
                    Light.transform.localPosition = new Vector3(0.4f, 1.45f, -0.3f);
                    Light.transform.hasChanged = true;
                    Light.SendNetworkUpdate();

                    Light.SetFlag(BaseEntity.Flags.Reserved8, true);
                }
                SendChatAll(config.npcController.helpBot ? "XD_IVENT_CRATEHACKHELP" : "XD_IVENT_CRATEHACK", player.displayName, PosIvent);
                if (config.npcController.helpBot)
                    SpawnBots(crate, true);
            }
        }
        void OnCrateHackEnd(HackableLockedCrate crate)
        {
            if (crate.OwnerID == 3566257)
            {
                if (RemoveHouseTime != null)
                    RemoveHouseTime.Destroy();
                SendChatAll("XD_IVENT_CRATEHACKEND", (config.iventController.timeRemoveHouse2 / 60));
                RemoveHouseTime = timer.Once(config.iventController.timeRemoveHouse2, () =>
                {
                    SendChatAll("XD_IVENT_CRATELOOTFOUND");
                    StopIvent();
                });
            }
        }
        void CanLootEntity(BasePlayer player, StorageContainer container)
        {
            if (container is HackableLockedCrate && container.OwnerID == 3566257)
            {
                SendChatAll("XD_IVENT_CRATELOOTPLAYER", player.displayName);
                if (RemoveHouseTime != null)
                    RemoveHouseTime.Destroy();
                RemoveHouseTime = timer.Once(300, () =>
                {
                    StopIvent();
                });
                container.OwnerID = 123425345634634;
            }
        }
        void OnCorpsePopulate(Scientist npc, NPCPlayerCorpse corpse)
        {
            if (npc?.GetComponent<NPCMonitor>() != null && corpse != null)
            {
                if (config.npcController.useCustomLoot && config.npcController.lootNpcs?.Count > 0)
                {
                    corpse.containers[0].itemList.Clear();
                    for (int i = 0; i < config.npcController.lootNpcs.Count; i++)
                    {
                        var main = config.npcController.lootNpcs[i];
                        if (corpse.containers[0].IsFull())
                            break;
                        bool goodChance = random.Next(0, 100) >= (100 - main.DropChance);
                        if (goodChance)
                        {
                            if (main.BluePrint)
                            {
                                Item item = ItemManager.Create(ResearchTable.GetBlueprintTemplate(), 1, 0UL);
                                item.blueprintTarget = ItemManager.FindItemDefinition(main.Shortname).itemid;
                                if (!item.MoveToContainer(corpse.containers[0]))
                                    item.Remove();
                            }
                            else
                            {
                                Item item = ItemManager.CreateByName(main.Shortname, random.Next(main.MinimalAmount, main.MaximumAmount), main.SkinID);
                                if (!string.IsNullOrEmpty(main.DisplayName))
                                {
                                    item.name = main.DisplayName;
                                }
                                if (!item.MoveToContainer(corpse.containers[0]))
                                    item.Remove();
                            }
                        }
                    }
                    corpse.containers[0].capacity = corpse.containers[0].itemList.Count;
                    corpse.containers[1].capacity = 0;
                    corpse.containers[2].capacity = 0;
                    corpse.containers[0].MarkDirty();
                    corpse.SendNetworkUpdate();
                }
            }
        }


        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
        {
            if (!entity.IsValid() || hitInfo == null)
                return;
            if (entity?.OwnerID == 342968945867)
            {
                hitInfo.damageTypes.ScaleAll(0);
            }

            var attacker = hitInfo.InitiatorPlayer;

            if (attacker.IsValid() && attacker is Scientist && (attacker as NPCPlayerApex).OwnerID == 3566257 && config.npcController.Accuracy < UnityEngine.Random.Range(0f, 100f))
            {
                hitInfo.damageTypes = new DamageTypeList();
                hitInfo.DidHit = false;
                hitInfo.DoHitEffects = false;
                hitInfo.HitEntity = null;
                return;
            }
        }
        #endregion

        #region MetodsPasteBuild
        void GenerateBuilding()
        {
            string[] options = { "stability", "true", "deployables", "true", "autoheight", "false", "entityowner", "false" };
            Vector3 resultVector = (Vector3)GetSpawnPoints();
            if (resultVector == null || resultVector == Vector3.zero)
                return;

            var success = CopyPaste.Call("TryPasteFromVector3", new Vector3(resultVector.x, resultVector.y + config.pasteSettings.heightBuilding, resultVector.z), 0f, !string.IsNullOrWhiteSpace(config.pasteSettings.housepath) ? config.pasteSettings.housepath : "HouseCobalt", options);

            if (success is string)
            {
                PrintWarning("Ошибка #1 \nПлагин не будет работать, Обратитесь к разработчику");
                GenerateIvent();
                return;
            }
        }

        void OnPasteFinished(List<BaseEntity> pastedEntities, string fileName)
        {
            if (fileName != "HouseCobalt" && fileName != config.pasteSettings.housepath)
                return;

            HouseCobaltLab = pastedEntities;
            BaseEntity box = null;
            List<CCTV_RC> cam = new List<CCTV_RC>();
            ComputerStation comp = null;
            foreach (BaseEntity ent in pastedEntities)
            {
                if (ent is MiniCopter)
                {
                    MiniCopter copter = (ent as MiniCopter);
                    copter.fuelSystem.AddStartingFuel(50);
                    copter.transform.position = new Vector3(copter.transform.position.x, copter.transform.position.y + 3f, copter.transform.position.z);
                    continue;
                }
                ent.OwnerID = 342968945867;
                if (ent is Signage)
                {
                    var ents = ent as Signage;
                    if (ents == null)
                        continue;
                    ents?.SetFlag(BaseEntity.Flags.Locked, true);
                    ents.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);
                }
                if (ent is Workbench || ent is ResearchTable || ent is MixingTable || ent is BaseArcadeMachine
                  || ent is IOEntity || ent is ComputerStation || ent is CCTV_RC)
                {
                    if (ent is IOEntity)
                        ent.SetFlag(BaseEntity.Flags.Reserved8, true);
                    if (ent is ComputerStation)
                        comp = ent as ComputerStation;
                    if (ent is CCTV_RC)
                        cam.Add(ent as CCTV_RC);
                    var ents = ent as BaseCombatEntity;
                    if (ents == null)
                        continue;
                    ents.pickup.enabled = false;
                    continue;
                }
                if (ent is VendingMachine)
                {
                    var ents = ent as VendingMachine;
                    if (ents == null)
                        continue;
                    ents.SetFlag(BaseEntity.Flags.Reserved4, false);
                    ents.UpdateMapMarker();
                }
                if (ent is FogMachine)
                {
                    var ents = ent as FogMachine;
                    if (ents == null)
                        continue;
                    ents.SetFlag(BaseEntity.Flags.Reserved8, true);
                    ents.SetFlag(BaseEntity.Flags.Reserved7, false);
                    ents.SetFlag(BaseEntity.Flags.Reserved6, false);
                }
                if (ent.name == "assets/prefabs/deployable/large wood storage/box.wooden.large.prefab")
                {
                    box = CrateHackableLocked(ent);
                    NextTick(() => { HouseCobaltLab.Remove(ent); ent.Kill(); HouseCobaltLab.Add(box); });
                    continue;

                }
                if (ent is Door)
                {
                    var ents = ent as Door;
                    if (ents == null)
                        continue;
                    ents.pickup.enabled = false;
                    ents.canTakeLock = false;
                    ents.canTakeCloser = false;
                    continue;
                }
                if (ent is ElectricGenerator)
                {
                    (ent as ElectricGenerator).electricAmount = 400;
                }
                if (ent as BuildingBlock)
                {
                    var build = ent as BuildingBlock;
                    build?.SetFlag(BaseEntity.Flags.Reserved1, false);
                    build?.SetFlag(BaseEntity.Flags.Reserved2, false);
                }
                ent?.SetFlag(BaseEntity.Flags.Busy, true);
                ent?.SetFlag(BaseEntity.Flags.Locked, true);
            }
            if (comp != null && cam.Count > 0)
            {
                foreach (CCTV_RC sd in cam)
                    comp.controlBookmarks.Add(sd.GetIdentifier(), sd.net.ID);
            }
            if (box == null)
            {
                PrintError("Ошибка #3, В постройке не найден ящик");
                StopIvent();
                GenerateIvent();
                return;
            }
            NpcZones Zone = new GameObject().AddComponent<NpcZones>();
            npcZones.Add(Zone);
            Zone.Activate(box, 15, config.radiationConroller.radUse);
            if (config.npcController.useSpawnNPC)
                SpawnBots(box);
            PosIvent = GetGridString(box.transform.position);
            GenerateMapMarker(box.transform.position);
            SendChatAll("XD_IVENT_START", PosIvent);
            if (config.notiferSettings.useUiNotifi)
                Cui.CreateUIAllPlayer();

            RemoveHouseTime = timer.Once(config.iventController.timeRemoveHouse, () =>
            {
                SendChatAll("XD_IVENT_NOPLAYER");
                StopIvent();
            });
        }

        private void GenerateMapMarker(Vector3 pos)
        {
            if (config.mapMarkers.rustMapUse)
                RustMap?.Call("ApiAddPointUrl", config.mapMarkers.rustMapIcon, Title, pos, config.mapMarkers.rustMapTxt);

            if (config.mapMarkers.MapUse)
                Interface.CallHook("API_CreateMarker", pos, "xdcobaltlab", 0, 3f, 0.3f, config.mapMarkers.MapTxt, "aeb769", "37382e");
        }

        private void RemoveMapMarker()
        {
            if (config.mapMarkers.rustMapUse)
                RustMap?.Call("ApiRemovePointUrl", Title);
            if (config.mapMarkers.MapUse)
                Interface.CallHook("API_RemoveMarker", "xdcobaltlab");
        }
        #endregion

        #region MainMetods
        private void GenerateIvent()
        {
            if (RemoveHouseTime != null)
                RemoveHouseTime.Destroy();
            if (SpawnHouseTime != null)
                SpawnHouseTime.Destroy();
            SpawnHouseTime = timer.Once(GenerateSpawnIventTime(), () =>
            {
                StartIvent();
            });
        }
        private BaseEntity CrateHackableLocked(BaseEntity box)
        {
            HackableLockedCrate CrateEnt = GameManager.server.CreateEntity("assets/prefabs/deployable/chinooklockedcrate/codelockedhackablecrate.prefab", new Vector3(box.transform.position.x, box.transform.position.y + 1f, box.transform.position.z), box.transform.rotation, true) as HackableLockedCrate;
            CrateEnt.enableSaving = false;
            CrateEnt.Spawn();
            CrateEnt.OwnerID = 3566257;
            CrateEnt.inventory.itemList.Clear();
            for (int i = 0; i < config.boxSetting.lootBoxes.Count; i++)
            {
                if (CrateEnt.inventory.itemList.Count >= config.boxSetting.maxItemCount)
                    break;
                var cfg = config.boxSetting.lootBoxes[i];
                bool goodChance = UnityEngine.Random.Range(0, 100) >= (100 - cfg.DropChance);

                if (goodChance)
                {
                    if (cfg.BluePrint)
                    {
                        Item bp = ItemManager.Create(ResearchTable.GetBlueprintTemplate());
                        bp.blueprintTarget = ItemManager.FindItemDefinition(cfg.Shortname).itemid;
                        if (!bp.MoveToContainer(CrateEnt.inventory))
                            bp.Remove();
                    }
                    else
                    {

                        int s = random.Next(cfg.MinimalAmount, cfg.MaximumAmount);
                        if (config.boxSetting.lootWipePlus && cfg.wipeCheck)
                            s = s * 2;

                        Item GiveItem = ItemManager.CreateByName(cfg.Shortname, s, cfg.SkinID);
                        if (!string.IsNullOrEmpty(cfg.DisplayName))
                        {
                            GiveItem.name = cfg.DisplayName;
                        }
                        if (!GiveItem.MoveToContainer(CrateEnt.inventory))
                            GiveItem.Remove();
                    }
                }
            }
            CrateEnt.inventory.capacity = CrateEnt.inventory.itemList.Count;
            CrateEnt.inventory.MarkDirty();
            CrateEnt.SendNetworkUpdate();
            CrateEnt.hackSeconds = HackableLockedCrate.requiredHackSeconds - config.boxSetting.unBlockTime;
            return CrateEnt;
        }

        private void StartIvent()
        {
            if (BasePlayer.activePlayerList.Count < config.iventController.minPlayedPlayers)
            {
                Puts("Недостаточно игроков для запуска ивента!");
                GenerateIvent();
                return;
            }
            if (RemoveHouseTime != null)
                RemoveHouseTime.Destroy();
            if (SpawnHouseTime != null)
                SpawnHouseTime.Destroy();
            SubscribeHook();
            GenerateBuilding();
        }

        private void StopIvent()
        {
            foreach (BaseEntity iventEnt in HouseCobaltLab)
                if (!iventEnt.IsDestroyed)
                    iventEnt?.Kill();
            if (config.notiferSettings.useUiNotifi)
                Cui.DestroyAllPlayer();

            HouseCobaltLab.Clear();
            if (SpawnHouseTime != null)
                SpawnHouseTime.Destroy();
            if (RemoveHouseTime != null)
                RemoveHouseTime.Destroy();
            DestroyZone();
            UnscribeHook();
            RemoveMapMarker();
            GenerateIvent();
        }

        private void UnscribeHook()
        {
            Unsubscribe("OnEntityTakeDamage");
            Unsubscribe("OnCorpsePopulate");
            Unsubscribe("CanLootEntity");
            Unsubscribe("OnCrateHackEnd");
            Unsubscribe("CanHackCrate");
            Unsubscribe("OnEntityMounted");
        }
        private void SubscribeHook()
        {
            Subscribe("OnEntityTakeDamage");
            Subscribe("OnCorpsePopulate");
            Subscribe("CanLootEntity");
            Subscribe("OnCrateHackEnd");
            Subscribe("CanHackCrate");
            Subscribe("OnEntityMounted");
        }


        #region Method controller npc
        Vector3 RandomCircle(Vector3 center, float radius = 2)
        {
            float ang = UnityEngine.Random.value * 360;
            Vector3 pos;
            pos.x = center.x + radius * Mathf.Sin(ang * Mathf.Deg2Rad);
            pos.z = center.z + radius * Mathf.Cos(ang * Mathf.Deg2Rad);
            pos.y = center.y;
            pos.y = GetGroundPosition(pos);

            return pos;
        }

        static float GetGroundPosition(Vector3 pos)
        {
            float y = TerrainMeta.HeightMap.GetHeight(pos);
            RaycastHit hit;

            if (Physics.Raycast(new Vector3(pos.x, pos.y + 200f, pos.z), Vector3.down, out hit, Mathf.Infinity, LayerMask.GetMask(new[] { "Terrain", "World", "Default", "Construction", "Deployed" })) && !hit.collider.name.Contains("rock_cliff"))
                return Mathf.Max(hit.point.y, y);
            return y;
        }

        private NPCPlayerApex InstantiateEntity(string type, Vector3 position)
        {
            position.y = GetGroundPosition(position);
            var gameObject = Instantiate.GameObject(GameManager.server.FindPrefab(type), position, new Quaternion());
            gameObject.name = type;
            SceneManager.MoveGameObjectToScene(gameObject, Rust.Server.EntityScene);
            UnityEngine.Object.Destroy(gameObject.GetComponent<Spawnable>());
            if (!gameObject.activeSelf)
                gameObject.SetActive(true);

            NPCPlayerApex component = gameObject.GetComponent<NPCPlayerApex>();
            return component;
        }
        void SpawnBots(BaseEntity box, bool help = false)
        {
            int count = config.npcController.countSpawnNpc;
            if (help && config.npcController.helpBot)
                if (config.npcController.helpCount > 0)
                    count = config.npcController.helpCount;

            for (int i = 0; i < count; i++)
            {
                NPCPlayerApex entity = null;
                entity = InstantiateEntity("assets/prefabs/npc/scientist/scientist.prefab", RandomCircle(box.transform.position, 10));
                entity.enableSaving = false;
                entity.Spawn();
                entity.OwnerID = 3566257;
                entity.IsInvinsible = false;
                entity.startHealth = config.npcController.healthNPC;
                entity.InitializeHealth(entity.startHealth, entity.startHealth);
                ControllerInventory(entity);
                entity.Stats.AggressionRange = entity.Stats.DeaggroRange = config.npcController.DistanceRange;
                entity.CommunicationRadius = 0;
                entity.displayName = config.npcController.nameNPC.GetRandom();
                entity.GetComponent<Scientist>().LootPanelName = entity.displayName;
                entity.CancelInvoke(entity.EquipTest);
                Equip(entity);
                entity.Stats.MaxRoamRange = 75f;
                entity.NeverMove = true;

                NPCMonitor npcMonitor = entity.gameObject.AddComponent<NPCMonitor>();
                nPCMonitors.Add(npcMonitor);
                
                npcMonitor.Initialize(box);
            }
        }

        public HeldEntity GetFirstWeapon(BasePlayer player)
        {
            foreach (Item item in player.inventory.containerBelt.itemList)
            {
                if (item.CanBeHeld() && (item.info.category == ItemCategory.Weapon))
                {
                    BaseProjectile projectile = item.GetHeldEntity() as BaseProjectile;
                    if (projectile != null)
                    {
                        global::Item items = projectile?.GetItem();
                        if (item != null && items.contents != null)
                        {
                            if (UnityEngine.Random.Range(0, 2) == 0)
                            {
                                global::Item item2 = global::ItemManager.CreateByName("weapon.mod.flashlight", 1, 0UL);
                                if (!item2.MoveToContainer(items.contents, -1, true))
                                    item2.Remove(0f);
                            }
                            else
                            {
                                global::Item item3 = global::ItemManager.CreateByName("weapon.mod.lasersight", 1, 0UL);
                                if (!item3.MoveToContainer(items.contents, -1, true))
                                    item3.Remove(0f);
                            }
                        }
                        projectile.primaryMagazine.contents = projectile.primaryMagazine.capacity;
                        projectile.SendNetworkUpdateImmediate();
                        return item.GetHeldEntity() as HeldEntity;
                    }
                }
            }
            return null;
        }
        private void Equip(BasePlayer player)
        {
            HeldEntity weapon = GetFirstWeapon(player);
            if (weapon != null)
            {
                weapon.SetHeld(true);
                weapon.SetLightsOn(false);
            }
        }

        private void ControllerInventory(BasePlayer player)
        {
            if (player == null)
                return;
            player.inventory.Strip();
            if (config?.npcController?.beltNpc?.Count > 0)
            {
                var index = random.Next(0, config.npcController.beltNpc.Count);
                ItemManager.CreateByName(config.npcController.beltNpc[index].Shortname, 1, config.npcController.beltNpc[index].SkinID).MoveToContainer(player.inventory.containerBelt);
            }
            if (config?.npcController?.wearNpc?.Count > 0)
            {
                for (int i = 0; i < config.npcController.wearNpc.Count; i++)
                {
                    if (player.inventory.containerWear.IsFull())
                        break;

                    var wear = config.npcController.wearNpc[i];
                    ItemManager.CreateByName(wear.Shortname, 1, wear.SkinID).MoveToContainer(player.inventory.containerWear);
                }
            }
        }
        public class NPCMonitor : FacepunchBehaviour
        {
            public NPCPlayerApex player
            {
                get; private set;
            }
            private List<Vector3> patrolPositions = new List<Vector3>();
            private Vector3 homePosition;
            private int lastPatrolIndex = 0;
            private void Awake()
            {
                player = GetComponent<NPCPlayerApex>();
                InvokeRepeating(UpdateDestination, 0f, 5.0f);
                checkNight();
                InvokeRandomized(new Action(checkNight), 0f, 30f, 5f);
            }
            private void checkNight()
            {
                HeldEntity heldEntity1 = player.GetActiveItem()?.GetHeldEntity() as HeldEntity;
                if (heldEntity1 != null)
                    heldEntity1.SetLightsOn(TOD_Sky.Instance.IsNight ? true : false);
            }

            public void Initialize(BaseEntity box)
            {
                this.homePosition = box.transform.position;
                GeneratePatrolPositions();
            }
            private void UpdateDestination()
            {
                if (player.AttackTarget == null)
                {
                    player.NeverMove = true;
                    float distance = (player.transform.position - homePosition).magnitude;
                    bool tooFar = distance > 20;

                    if (player.GetNavAgent == null || !player.GetNavAgent.isOnNavMesh)
                        player.finalDestination = patrolPositions[lastPatrolIndex];
                    else
                    {
                        if (Vector3.Distance(player.transform.position, patrolPositions[lastPatrolIndex]) < 5)
                            lastPatrolIndex++;
                        if (lastPatrolIndex >= patrolPositions.Count)
                            lastPatrolIndex = 0;
                        player.SetDestination(patrolPositions[lastPatrolIndex]);
                    }

                    player.SetDestination(patrolPositions[lastPatrolIndex]);
                    player.SetFact(NPCPlayerApex.Facts.Speed, tooFar ? (byte)NPCPlayerApex.SpeedEnum.Run : (byte)NPCPlayerApex.SpeedEnum.Walk, true, true);
                }
                else
                {
                    player.NeverMove = false;
                    player.IsStopped = false;

                    var attacker = player.AttackTarget as BasePlayer;
                    if (attacker == null)
                        return;

                    if (attacker.IsDead())
                        Forget();
                }
            }
            private void Forget()
            {
                player.lastDealtDamageTime = Time.time - 21f;
                player.SetFact(Facts.HasEnemy, 0, true, true);
                player.SetFact(Facts.EnemyRange, 3, true, true);
                player.SetFact(Facts.AfraidRange, 1, true, true);
                player.AiContext.EnemyNpc = null;
                player.AiContext.EnemyPlayer = null;
                player.AttackTarget = null;
                player.lastAttacker = null;
                player.lastAttackedTime = Time.time - 31f;
                player.LastAttackedDir = Vector3.zero;
                player.SetDestination(patrolPositions[lastPatrolIndex]);
            }
            private void OnDestroy()
            {
                if (player != null && !player.IsDestroyed)
                    player.Kill();
                Destroy(gameObject);
            }
            private void GeneratePatrolPositions()
            {
                for (int i = 0; i < 6; i++)
                {
                    Vector3 position = homePosition + (UnityEngine.Random.onUnitSphere * 20f);
                    position.y = TerrainMeta.HeightMap.GetHeight(position);
                    patrolPositions.Add(position);
                }
                enabled = true;
            }
        }
        #region NpcZonesOrRadiation
        public class NpcZones : MonoBehaviour
        {
            private Vector3 Position;
            private float Radius;
            private void Awake()
            {
                gameObject.layer = (int)Layer.Reserved1;
                gameObject.name = "NpcZonesOrRadiation";
                var rigidbody = gameObject.AddComponent<Rigidbody>();
                rigidbody.useGravity = false;
                rigidbody.isKinematic = true;
            }
            public void Activate(BaseEntity box, float radius, bool rad)
            {
                Position = box.transform.position;
                Radius = radius;
                transform.position = Position;
                transform.rotation = new Quaternion();
                UpdateCollider();
                gameObject.SetActive(true);
                enabled = true;
                if (rad)
                {
                    UpdateCollider();
                    gameObject.SetActive(true);
                    enabled = true;
                    var Rads = gameObject.GetComponent<TriggerRadiation>();
                    Rads = Rads ?? gameObject.AddComponent<TriggerRadiation>();
                    Rads.RadiationAmountOverride = config.radiationConroller.radCount;
                    Rads.interestLayers = LayerMask.GetMask("Player (Server)");
                    Rads.enabled = true;
                }
            }
            private void OnDestroy()
            {
                Destroy(gameObject);
            }
            public void Kill()
            {
                Destroy(gameObject);
            }

            private void UpdateCollider()
            {
                var sphereCollider = gameObject.GetComponent<SphereCollider>();
                {
                    if (sphereCollider == null)
                    {
                        sphereCollider = gameObject.AddComponent<SphereCollider>();
                        sphereCollider.isTrigger = true;
                    }
                    sphereCollider.radius = Radius;
                }
            }
        }
        #endregion
        #endregion

        #endregion

        #region HelpMetods

        #region Узнаем квадрат
        string GetGridString(Vector3 pos)
        {
            char[] alpha = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".ToCharArray();

            pos.z = -pos.z;
            pos += new Vector3(TerrainMeta.Size.x, 0, TerrainMeta.Size.z) * .5f;

            var cubeSize = 146.14f;

            int xCube = (int)(pos.x / cubeSize);
            int zCube = (int)(pos.z / cubeSize);
            // int yNumber = 2509;
            int firstLetterIndex = (int)(xCube / alpha.Length) - 1;
            string firstLetter = "";
            if (firstLetterIndex >= 0)
                firstLetter = $"{alpha[firstLetterIndex]}";

            var xStr = $"{firstLetter}{alpha[xCube % 26]}";
            var zStr = $"{zCube}";

            return $"{xStr}{zStr}";
        }

        private string NumberToString(int number)
        {
            bool a = number > 25;
            Char c = (Char)(65 + (a ? number - 26 : number));
            return a ? "A" + c : c.ToString();
        }
        #endregion

        #region discord

        #region FancyDiscord
        public class FancyMessage
        {
            public string content
            {
                get; set;
            }
            public bool tts
            {
                get; set;
            }
            public Embeds[] embeds
            {
                get; set;
            }

            public class Embeds
            {
                public string title
                {
                    get; set;
                }
                public int color
                {
                    get; set;
                }
                public List<Fields> fields
                {
                    get; set;
                }

                public Embeds(string title, int color, List<Fields> fields)
                {
                    this.title = title;
                    this.color = color;
                    this.fields = fields;
                }
            }

            public FancyMessage(string content, bool tts, Embeds[] embeds)
            {
                this.content = content;
                this.tts = tts;
                this.embeds = embeds;
            }

            public string toJSON() => JsonConvert.SerializeObject(this);
        }

        public class Fields
        {
            public string name
            {
                get; set;
            }
            public string value
            {
                get; set;
            }
            public bool inline
            {
                get; set;
            }
            public Fields(string name, string value, bool inline)
            {
                this.name = name;
                this.value = value;
                this.inline = inline;
            }
        }

        private void Request(string url, string payload, Action<int> callback = null)
        {
            Dictionary<string, string> header = new Dictionary<string, string>();
            header.Add("Content-Type", "application/json");
            webrequest.Enqueue(url, payload, (code, response) =>
            {
                if (code != 200 && code != 204)
                {
                    if (response != null)
                    {
                        try
                        {
                            JObject json = JObject.Parse(response);
                            if (code == 429)
                            {
                                float seconds = float.Parse(Math.Ceiling((double)(int)json["retry_after"] / 1000).ToString());
                            }
                            else
                            {
                                PrintWarning($" Discord rejected that payload! Responded with \"{json["message"].ToString()}\" Code: {code}");
                            }
                        }
                        catch
                        {
                            PrintWarning($"Failed to get a valid response from discord! Error: \"{response}\" Code: {code}");
                        }
                    }
                    else
                    {
                        PrintWarning($"Discord didn't respond (down?) Code: {code}");
                    }
                }
                try
                {
                    callback?.Invoke(code);
                }
                catch (Exception ex) { }

            }, this, RequestMethod.POST, header);
        }
        #endregion

        void SendDiscordMsg(string msg)
        {
            List<Fields> fields = new List<Fields>
            {
                new Fields(lang.GetMessage("XD_IVENT_HOUSECOBALT", this), msg, true),
            };
            FancyMessage newMessage = new FancyMessage(null, false, new FancyMessage.Embeds[1] { new FancyMessage.Embeds(null, 16775936, fields) });
            Request(config.notiferSettings.weebHook, newMessage.toJSON());
        }

        #endregion

        private static System.Random random = new System.Random();
        private int GenerateSpawnIventTime() => random.Next(config.iventController.minSpawnIvent, config.iventController.maxSpawnIvent);

        public static StringBuilder sb = new StringBuilder();
        public string GetLang(string LangKey, string userID = null, params object[] args)
        {
            sb.Clear();
            if (args != null)
            {
                sb.AppendFormat(lang.GetMessage(LangKey, this, userID), args);
                return sb.ToString();
            }
            return lang.GetMessage(LangKey, this, userID);
        }
        public void SendChatAll(string Message, params object[] args)
        {
            if (!String.IsNullOrEmpty(config.notiferSettings.weebHook))
            {
                string msg = GetLang(Message, null, args);
                SendDiscordMsg(GetLang(Message + "_DISCORD", null, args));
            }
            if (IQChat)
                IQChat?.Call("API_ALERT", GetLang(Message, null, args));
            else
                BasePlayer.activePlayerList.ToList().ForEach(p => p.SendConsoleCommand("chat.add", ConVar.Chat.ChatChannel.Global, 0, GetLang(Message, p.UserIDString, args)));
        }
        public void SendChatPlayer(string Message, BasePlayer player, ConVar.Chat.ChatChannel channel = ConVar.Chat.ChatChannel.Global)
        {
            if (IQChat)
                IQChat?.Call("API_ALERT_PLAYER", player, Message);
            else
                player.SendConsoleCommand("chat.add", channel, 0, Message);
        }
        private static string HexToRustFormat(string hex)
        {
            Color color;
            ColorUtility.TryParseHtmlString(hex, out color);
            sb.Clear();
            return sb.AppendFormat("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a).ToString();
        }
        private void DestroyZone()
        {
            foreach (NpcZones zones in npcZones)
                UnityEngine.Object.Destroy(zones);

            foreach (NPCMonitor zones in nPCMonitors)
                    UnityEngine.Object.Destroy(zones);
        }
        #endregion

        #region Command
        [ChatCommand("cl")]
        void CLCommand(BasePlayer player, string cmd, string[] Args)
        {
            if (!player.IsAdmin)
                return;
            if (Args == null || Args.Length == 0)
            {
                SendChatPlayer($"Используйте:\n/cl start - Запуск ивента досрочно\n/cl stop - отменить ивент досрочно", player);
                return;
            }
            switch (Args[0])
            {
                case "start":
                    {
                        if (SpawnHouseTime.Destroyed)
                        {
                            PrintToChat(player, "Ивент уже активен!");
                        }
                        else
                        {
                            SpawnHouseTime.Destroy();
                            StartIvent();
                        }
                        break;
                    }
                case "stop":
                    {
                        if (SpawnHouseTime.Destroyed)
                        {
                            StopIvent();
                            SendChatAll("Ивент окончен досрочно администратором!");
                        }
                        else
                        {

                            SendChatPlayer("Нет активных ивентов", player);
                        }
                        break;
                    }
            }

        }
        #endregion

        [ConsoleCommand("HideUi")]
        void CMDHideUi(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (Player != null)
            {
                if (!HideUIUser.Contains(player.userID))
                {
                    HideUIUser.Add(player.userID);
                    CuiHelper.DestroyUi(player, "CobaltPanel");
                }
                else
                {
                    HideUIUser.Remove(player.userID);
                    Cui.MainUI(player);
                }
            }
        }

        #region Command itemAddOrReset
        [ChatCommand("cl.items")]
        void BoxItemCommand(BasePlayer player, string cmd, string[] Args)
        {
            if (Args == null || Args.Length == 0)
            {
                SendChatPlayer("Используйте:\n/cl.items add - добавить лут к существующему\n/cl.items reset - заменить старый лут на новый", player);
                return;
            }
            switch (Args[0])
            {
                case "add":
                    {
                        foreach (var item in player.inventory.containerMain.itemList)
                        {
                            config.boxSetting.lootBoxes.Add(new LootNpcOrBox
                            {
                                BluePrint = item.IsBlueprint(),
                                Shortname = item.IsBlueprint() ? item.blueprintTargetDef.shortname : item.info.shortname,
                                SkinID = item.skin,
                                DisplayName = string.Empty,
                                DropChance = 30,
                                MinimalAmount = 1,
                                MaximumAmount = 1
                            });
                        }
                        SaveConfig();
                        SendChatPlayer("Вы успешно добавили новые предметы для ящика.\nОбязательно настройте их в конфиге", player);
                        break;
                    }
                case "reset":
                    {
                        config.boxSetting.lootBoxes.Clear();
                        foreach (var item in player.inventory.containerMain.itemList)
                        {
                            config.boxSetting.lootBoxes.Add(new LootNpcOrBox
                            {
                                BluePrint = item.IsBlueprint(),
                                Shortname = item.IsBlueprint() ? item.blueprintTargetDef.shortname : item.info.shortname,
                                SkinID = item.skin,
                                DisplayName = string.Empty,
                                DropChance = 30,
                                MinimalAmount = 1,
                                MaximumAmount = 1
                            });
                        }
                        SaveConfig();
                        SendChatPlayer("Вы успешно заменили все предметы на новые.\nОбязательно настройте их в конфиге", player);
                        break;
                    }
            }
        }
        [ChatCommand("cl.botitems")]
        void NpcLootCommand(BasePlayer player, string cmd, string[] Args)
        {
            if (Args == null || Args.Length == 0)
            {
                SendChatPlayer("Используйте:\n/cl.botitems add - добавить лут к существующему\n/cl.botitems reset - заменить старый лут на новый", player);
                return;
            }
            switch (Args[0])
            {
                case "add":
                    {
                        foreach (var item in player.inventory.containerMain.itemList)
                        {
                            config.npcController.lootNpcs.Add(new LootNpcOrBox
                            {
                                BluePrint = item.IsBlueprint(),
                                Shortname = item.IsBlueprint() ? item.blueprintTargetDef.shortname : item.info.shortname,
                                SkinID = item.skin,
                                DisplayName = string.Empty,
                                DropChance = 30,
                                MinimalAmount = 1,
                                MaximumAmount = 1
                            });
                        }
                        SaveConfig();
                        SendChatPlayer("Вы успешно добавили новые предметы для npc.\nОбязательно настройте их в конфиге", player);
                        break;
                    }
                case "reset":
                    {
                        config.npcController.lootNpcs.Clear();
                        foreach (var item in player.inventory.containerMain.itemList)
                        {
                            config.npcController.lootNpcs.Add(new LootNpcOrBox
                            {
                                BluePrint = item.IsBlueprint(),
                                Shortname = item.IsBlueprint() ? item.blueprintTargetDef.shortname : item.info.shortname,
                                SkinID = item.skin,
                                DisplayName = string.Empty,
                                DropChance = 30,
                                MinimalAmount = 1,
                                MaximumAmount = 1
                            });
                        }
                        SaveConfig();
                        SendChatPlayer("Вы успешно заменили все предметы на новые.\nОбязательно настройте их в конфиге", player);
                        break;
                    }
            }
        }
        #endregion

        #region ui

        public static class Cui
        {
            public static void CreateUIAllPlayer()
            {
                foreach (BasePlayer player in BasePlayer.activePlayerList)
                {
                    ButtonClose(player);
                    if (_.HideUIUser.Contains(player.userID))
                        continue;
                    MainUI(player);
                }       
            }

            public static void MainUI(BasePlayer player)
            {
                var container = new CuiElementContainer();
                container.Add(new CuiPanel
                {   
                    CursorEnabled = false,
                    Image = { Color = config.notiferSettings.colorBackground, Sprite = "assets/content/materials/highlight.png", Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat", FadeIn = 0.2f },
                    RectTransform = { AnchorMin = "1 0.5", AnchorMax = "1 0.5", OffsetMin = "-342.195 -15.973", OffsetMax = "-13.805 59.667" }
                }, "Overlay", "CobaltPanel");

                container.Add(new CuiElement
                {
                    Name = "CobaltImg",
                    Parent = "CobaltPanel",
                    Components = {
                    new CuiRawImageComponent { Color = "0.9568628 0.7254902 0 1", Material = "assets/icons/iconmaterial.mat", Sprite = "assets/icons/radiation.png", FadeIn = 0.2f },
                    new CuiRectTransformComponent { AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "6.5 -17.5", OffsetMax = "41.5 17.5" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "CobaltTitle",
                    Parent = "CobaltPanel",
                    Components = {
                    new CuiTextComponent { Text =  _.lang.GetMessage("XD_IVENT_HOUSECOBALT", _).ToUpper(), Font = "robotocondensed-bold.ttf", FontSize = 15, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1", FadeIn = 0.2f },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "0.5 0.5" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-103.801 -23.938", OffsetMax = "103.801 -2.861" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "CobaltInfo",
                    Parent = "CobaltPanel",
                    Components = {
                    new CuiTextComponent { Text = string.Format(_.lang.GetMessage("XD_IVENT_STARTUI", _), _.PosIvent), Font = "robotocondensed-regular.ttf", FontSize = 12, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1", FadeIn = 0.2f },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-118.84 -33.077", OffsetMax = "151.44 13.881" }
                }
                });
                CuiHelper.AddUi(player, CuiHelper.ToJson(container)); 
            }

            public static void ButtonClose(BasePlayer player)
            {
                var container = new CuiElementContainer();

                container.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    Image = { Color = config.notiferSettings.colorBtnCloseUi },
                    RectTransform = { AnchorMin = "1 0.5", AnchorMax = "1 0.5", OffsetMin = "-13.854 -15.973", OffsetMax = "0 59.667" }
                }, "Overlay", "CobaltClosePanel");

                container.Add(new CuiElement
                {
                    Name = "ButtonClodedUI",
                    Parent = "CobaltClosePanel",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Material = "assets/icons/iconmaterial.mat", Sprite = "assets/icons/chevron_right.png" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-8.739 -11.998", OffsetMax = "8.74 11.998" }
                }
                });

                container.Add(new CuiButton
                {
                    Text = { Text = "" },
                    Button = { Command = "HideUi", Color = "0 0 0 0" },
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-8.739 -37.82", OffsetMax = "8.74 37.82" }
                }, "CobaltClosePanel", "Closed");

                CuiHelper.AddUi(player, CuiHelper.ToJson(container));
            }

            public static void DestroyAllPlayer()
            {
                CommunityEntity.ServerInstance.ClientRPCEx(new SendInfo(Net.sv.connections), null, "DestroyUI", "CobaltClosePanel");
                CommunityEntity.ServerInstance.ClientRPCEx(new SendInfo(Net.sv.connections), null, "DestroyUI", "CobaltPanel");
            }
        }
        #endregion
    }
}

// --- End of file: XDCobaltLaboratory.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HudRust/MarkerManager.cs ---
// --- Original Local Path: HudRust/MarkerManager.cs ---

using System;
using System.Collections.Generic;
using Oxide.Core;
using UnityEngine;
using VLB;
using Color = UnityEngine.Color;

namespace Oxide.Plugins
{
    [Info("Marker Manager", "Orange", "2.1.1")]
    [Description("Allows to place markers on in-game map")]
    public class MarkerManager : RustPlugin
    {
        #region Vars

        private const string genericPrefab = "assets/prefabs/tools/map/genericradiusmarker.prefab";
        private const string vendingPrefab = "assets/prefabs/deployable/vendingmachine/vending_mapmarker.prefab";
        private const string permUse = "markermanager.use";
        private const string chatCommand = "marker";

        #endregion

        #region Oxide Hooks

        private void Init()
        {
            permission.RegisterPermission(permUse, this);
            cmd.AddChatCommand(chatCommand, this, nameof(cmdMarkerChat));
        }

        private void OnServerInitialized()
        {
            LoadData();
            LoadCustomMarkers();
        }

        private void Unload()
        {
            SaveData();
            RemoveMarkers();
        }

        #endregion

        #region Commands

        private void cmdMarkerChat(BasePlayer player, string command, string[] args)
        {
            if (permission.UserHasPermission(player.UserIDString, permUse) == false)
            {
                Message(player, "Permission");
                return;
            }

            if (args == null || args?.Length == 0)
            {
                Message(player, "Usage");
                return;
            }

            switch (args[0].ToLower())
            {
                default:
                    Message(player, "Usage");
                    break;

                case "add":
                case "create":
                    if (args.Length < 8)
                    {
                        Message(player, "Usage");
                    }
                    else
                    {
                        var def = new CachedMarker
                        {
                            position = player.transform.position,
                            name = args[1],
                            duration = Convert.ToInt32(args[2]),
                            refreshRate = Convert.ToSingle(args[3]),
                            radius = Convert.ToSingle(args[4]),
                            displayName = args[5],
                            color1 = args[6],
                            color2 = args[7],
                        };

                        CreateCustomMarker(def, player);
                        SaveCustomMarker(def);
                    }

                    return;

                case "remove":
                case "delete":
                    if (args.Length < 2)
                    {
                        Message(player, "Usage");
                    }
                    else
                    {
                        RemoveCustomMarker(args[1], player);
                    }

                    return;
            }
        }

        #endregion

        #region Core

        private void CreateMarker(Vector3 position, int duration, float refreshRate, string name, string displayName,
            float radius = 0.3f, string colorMarker = "00FFFF", string colorOutline = "00FFFFFF")
        {
            var marker = new GameObject().AddComponent<CustomMapMarker>();
            marker.name = name;
            marker.displayName = displayName;
            marker.radius = radius;
            marker.position = position;
            marker.duration = duration;
            marker.refreshRate = refreshRate;
            ColorUtility.TryParseHtmlString($"#{colorMarker}", out marker.color1);
            ColorUtility.TryParseHtmlString($"#{colorOutline}", out marker.color2);
        }

        private void CreateMarker(BaseEntity entity, int duration, float refreshRate, string name, string displayName,
            float radius = 0.3f, string colorMarker = "00FFFF", string colorOutline = "00FFFFFF")
        {
            var marker = entity.gameObject.GetOrAddComponent<CustomMapMarker>();
            marker.name = name;
            marker.displayName = displayName;
            marker.radius = radius;
            marker.refreshRate = refreshRate;
            marker.parent = entity;
            marker.position = entity.transform.position;
            marker.duration = duration;
            ColorUtility.TryParseHtmlString($"#{colorMarker}", out marker.color1);
            ColorUtility.TryParseHtmlString($"#{colorOutline}", out marker.color2);
        }

        private void RemoveMarker(string name)
        {
            foreach (var marker in UnityEngine.Object.FindObjectsOfType<CustomMapMarker>())
            {
                if (marker.name == name)
                {
                    UnityEngine.Object.Destroy(marker);
                }
            }
        }

        private void RemoveMarkers()
        {
            foreach (var marker in UnityEngine.Object.FindObjectsOfType<CustomMapMarker>())
            {
                UnityEngine.Object.Destroy(marker);
            }
        }

        private void CreateCustomMarker(CachedMarker def, BasePlayer player = null)
        {
            var marker = new GameObject().AddComponent<CustomMapMarker>();
            marker.name = def.name;
            marker.displayName = def.displayName;
            marker.radius = def.radius;
            marker.position = def.position;
            marker.duration = def.duration;
            marker.refreshRate = def.refreshRate;
            marker.placedByPlayer = true;
            ColorUtility.TryParseHtmlString($"#{def.color1}", out marker.color1);
            ColorUtility.TryParseHtmlString($"#{def.color2}", out marker.color2);
            Message(player, "Added", marker.displayName, marker.position);
        }

        private void RemoveCustomMarker(string name, BasePlayer player = null)
        {
            var i = 0;
            foreach (var marker in UnityEngine.Object.FindObjectsOfType<CustomMapMarker>())
            {
                if (marker.placedByPlayer == false)
                {
                    continue;
                }

                if (marker.name == name)
                {
                    UnityEngine.Object.Destroy(marker);
                    i++;
                }
            }

            RemoveSavedMarker(name);
            Message(player, "Removed", i);
        }

        private void SaveCustomMarker(CachedMarker def)
        {
            data.Add(def);
        }

        private void LoadCustomMarkers()
        {
            foreach (var def in data)
            {
                CreateCustomMarker(def);
            }
        }

        private void RemoveSavedMarker(string name)
        {
            data.RemoveAll(x => x.name == name);
        }

        #endregion

        #region Localization 1.1.1

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {
                    "Usage", "<color=#00ffff>Usage:</color>\n" +
                             " <color=#00ffff>/marker add</color> name(code name) duration(seconds, 0 to permanent) refreshRate(30) radius(0.4) displayName (on map) colorInline (HEX) colorOutline (HEX) - Add marker on map\n" +
                             " <color=#00ffff>/marker remove</color> name (code name, only for custom markers) - Remove marker from map"
                },
                {"Permission", "You don't have permission to use that!"},
                {"Added", "Marker '{0}' was added on {1}!"},
                {"Removed", "{0} markers with that name was removed!"}
            }, this);
        }

        private string GetMessage(string messageKey, string playerID, params object[] args)
        {
            return string.Format(lang.GetMessage(messageKey, this, playerID), args);
        }

        private void Message(BasePlayer player, string messageKey, params object[] args)
        {
            if (player == null)
            {
                return;
            }

            var message = GetMessage(messageKey, player.UserIDString, args);
            player.SendConsoleCommand("chat.add", (object) 0, (object) message);
        }

        #endregion

        #region Data 1.0.0

        private const string filename = "MarkerManager/Custom";
        private static List<CachedMarker> data = new List<CachedMarker>();

        private class CachedMarker
        {
            public float radius;
            public string color1;
            public string color2;
            public string displayName;
            public string name;
            public float refreshRate;
            public Vector3 position;
            public int duration;
        }

        private void LoadData()
        {
            try
            {
                data = Interface.Oxide.DataFileSystem.ReadObject<List<CachedMarker>>(filename);
            }
            catch (Exception e)
            {
                PrintWarning(e.Message);
            }

            SaveData();
            timer.Every(Core.Random.Range(500, 700f), SaveData);
        }

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(filename, data);
        }

        #endregion

        #region API

        private void API_CreateMarker(Vector3 position, string name,
            int duration = 0, float refreshRate = 3f, float radius = 0.4f,
            string displayName = "Marker", string colorMarker = "00FFFF", string colorOutline = "00FFFFFF")
        {
            CreateMarker(position, duration, refreshRate, name, displayName, radius, colorMarker, colorOutline);
        }

        private void API_CreateMarker(BaseEntity entity, string name,
            int duration = 0, float refreshRate = 3f, float radius = 0.4f,
            string displayName = "Marker", string colorMarker = "00FFFF", string colorOutline = "00FFFFFF")
        {
            CreateMarker(entity, duration, refreshRate, name, displayName, radius, colorMarker, colorOutline);
        }

        private void API_RemoveMarker(string name)
        {
            RemoveMarker(name);
        }

        #endregion

        #region Scripts

        private class CustomMapMarker : MonoBehaviour
        {
            private VendingMachineMapMarker vending;
            private MapMarkerGenericRadius generic;
            public BaseEntity parent;
            private bool asChild;

            public float radius;
            public Color color1;
            public Color color2;
            public string displayName;
            public float refreshRate;
            public Vector3 position;
            public int duration;
            public bool placedByPlayer;

            private void Start()
            {
                transform.position = position;
                asChild = parent != null;
                CreateMarkers();
            }

            private void CreateMarkers()
            {
                vending = GameManager.server.CreateEntity(vendingPrefab, position)
                    .GetComponent<VendingMachineMapMarker>();
                vending.markerShopName = displayName;
                vending.enableSaving = false;
                vending.Spawn();

                generic = GameManager.server.CreateEntity(genericPrefab).GetComponent<MapMarkerGenericRadius>();
                generic.color1 = color1;
                generic.color2 = color2;
                generic.radius = radius;
                generic.alpha = 1f;
                generic.enableSaving = false;
                generic.SetParent(vending);
                generic.Spawn();

                if (duration != 0)
                {
                    Invoke(nameof(DestroyMakers), duration);
                }

                UpdateMarkers();

                if (refreshRate > 0f)
                {
                    if (asChild)
                    {
                        InvokeRepeating(nameof(UpdatePosition), refreshRate, refreshRate);
                    }
                    else
                    {
                        InvokeRepeating(nameof(UpdateMarkers), refreshRate, refreshRate);
                    }
                }
            }

            private void UpdatePosition()
            {
                if (asChild == true)
                {
                    if (parent.IsValid() == false)
                    {
                        Destroy(this);
                        return;
                    }
                    else
                    {
                        var pos = parent.transform.position;
                        transform.position = pos;
                        vending.transform.position = pos;
                    }
                }

                UpdateMarkers();
            }

            private void UpdateMarkers()
            {
                vending.SendNetworkUpdate();
                generic.SendUpdate();
            }

            private void DestroyMakers()
            {
                if (vending.IsValid())
                {
                    vending.Kill();
                }

                if (generic.IsValid())
                {
                    generic.Kill();
                }

                if (placedByPlayer)
                {
                    data.RemoveAll(x => x.name == name);
                }
            }

            private void OnDestroy()
            {
                DestroyMakers();
            }
        }

        #endregion
    }
}

// --- End of file: MarkerManager.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HudRust/RustKits.cs ---
// --- Original Local Path: HudRust/RustKits.cs ---

﻿using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("RustKits", "VooDoo", "1.0.0")]
    [Description("Menu for RUST")]
    public class RustKits : RustPlugin
    {
        private static RustKits Instance;
        [PluginReference] Plugin XMenu;
        [PluginReference] Plugin ImageLibrary;
        [PluginReference] Plugin Notifications;

        private bool AddImage(string url, string imageName, ulong imageId = 0, Action callback = null) => (bool)ImageLibrary.Call("AddImage", url, imageName, imageId, callback);
        private string GetImage(string imageName, ulong imageId = 0, bool returnUrl = false) => (string)ImageLibrary.Call("GetImage", imageName, imageId, returnUrl);

        #region Data
        private List<Kit> _kits = new List<Kit>();
        private Dictionary<ulong, Dictionary<string, KitData>> _kitsData = new Dictionary<ulong, Dictionary<string, KitData>>();

        public class KitData
        {
            public int Amount { get; set; }
            public double Cooldown { get; set; }
        }

        public class Kit
        {
            public string Name { get; set; }
            public string Image { get; set; }
            public string Permission { get; set; }
            public int Amount { get; set; }
            public double Cooldown { get; set; }
            public List<KitItem> Items { get; set; }
        }

        public class KitItem
        {
            public string Name { get; set; }
            public string Container { get; set; }
            public int Amount { get; set; }
            public ulong SkinID { get; set; }
            public float Condition { get; set; }
            public Weapon Weapon { get; set; }
        }

        public class Weapon
        {
            public string AmmoName { get; set; }
            public int Amount;

            public List<string> Content { get; set; }
        }      

        private List<Kit> GetKitsForPlayer(BasePlayer player)
        {
            return _kits.Where(kit => kit.Name != "autokit" && (string.IsNullOrEmpty(kit.Permission) || permission.UserHasPermission(player.UserIDString, kit.Permission)) && (kit.Amount == 0 || (kit.Amount > 0 && GetKitData(player, kit.Name).Amount < kit.Amount))).ToList();
        }

        private KitData GetKitData(BasePlayer player, string kitName)
        {
            Dictionary<string, KitData> kitDictionary;
            if (_kitsData.TryGetValue(player.userID, out kitDictionary))
            {
                KitData kitData;
                if (kitDictionary.TryGetValue(kitName, out kitData))
                {
                    return kitData;
                }
                else
                {
                    _kitsData[player.userID][kitName] = new KitData();
                    return _kitsData[player.userID][kitName];
                }
            }
            else
            {
                _kitsData[player.userID] = new Dictionary<string, KitData>();
                _kitsData[player.userID][kitName] = new KitData();
                return _kitsData[player.userID][kitName];
            }
        }

        private List<KitItem> GetPlayerItems(BasePlayer player)
        {
            List<KitItem> kititems = new List<KitItem>();
            foreach (Item item in player.inventory.containerWear.itemList)
            {
                if (item != null)
                {
                    var iteminfo = ItemToKit(item, "wear");
                    kititems.Add(iteminfo);
                }
            }
            foreach (Item item in player.inventory.containerMain.itemList)
            {
                if (item != null)
                {
                    var iteminfo = ItemToKit(item, "main");
                    kititems.Add(iteminfo);
                }
            }
            foreach (Item item in player.inventory.containerBelt.itemList)
            {
                if (item != null)
                {
                    var iteminfo = ItemToKit(item, "belt");
                    kititems.Add(iteminfo);
                }
            }
            return kititems;
        }

        private KitItem ItemToKit(Item item, string container)
        {
            KitItem kitItem = new KitItem();
            kitItem.Amount = item.amount;
            kitItem.Container = container;
            kitItem.SkinID = item.skin;
            kitItem.Name = item.info.shortname;
            kitItem.Condition = item.condition;
            kitItem.Weapon = null;
            if (item.info.category == ItemCategory.Weapon)
            {
                BaseProjectile weapon = item.GetHeldEntity() as BaseProjectile;
                if (weapon != null)
                {
                    kitItem.Weapon = new Weapon();
                    kitItem.Weapon.AmmoName = weapon.primaryMagazine.ammoType.shortname;
                    kitItem.Weapon.Amount = weapon.primaryMagazine.contents;
                    
                    if (item.contents != null)
                    {
                        kitItem.Weapon.Content = new List<string>();
                        foreach (var content in item.contents.itemList)
                        {
                            kitItem.Weapon.Content.Add(content.info.shortname);
                        }
                    }


                }
            }
            return kitItem;
        }
        #endregion

        #region UnityMod Hooks
        private void OnPlayerRespawned(BasePlayer player)
        {
            if(_kits.Exists(x => x.Name == "AUTOKIT".ToLower()))
            {
                player.inventory.Strip();
                var kit = _kits.First(x => x.Name == "AUTOKIT".ToLower());
                GiveKit(player, kit);
			
            }
        }

        private void SaveKits()
        {
            Interface.Oxide.DataFileSystem.WriteObject("Kits", _kits);
        }

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject("Kits_Data", _kitsData);
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>()
            {
                ["TITLE"] = "<color=#fffffAA>List of KITS</color>",
                ["TIMER"] = "Timer",
                ["TITLE_CAN"] = "Available",
                ["BUTTON_CAN"] = "Receive",
                ["BUTTON_CANT"] = "Wait",
                ["KIT_NOTFOUND"] = "This kit does not exist",
                ["KIT_PERMISSION"] = "You are not authorized to use this kit",
                ["KIT_TIME"] = "You will be able to use this kit through {time}",
                ["KIT_NEEDSLOTS"] = "Unable to get kit - not enough space in inventory",
                ["KIT_RECEIVED"] = "You received the kit {kitname}",
                ["TITLE_KITSHOW"] = "<color=#fffffAA>List items of kit <color=#FFAA00AA>%</color></color>",
            }, this, "en");

            lang.RegisterMessages(new Dictionary<string, string>()
            {
                ["TITLE"] = "<color=#fffffAA>Список китов нашего сервера</color>",
                ["TIMER"] = "Таймер",
                ["TITLE_CAN"] = "Доступно",
                ["BUTTON_CAN"] = "Взять",
                ["BUTTON_CANT"] = "Подождите",
                ["KIT_NOTFOUND"] = "Этого набора не существует",
                ["KIT_PERMISSION"] = "У вас нет полномочий использовать этот набор",
                ["KIT_TIME"] = "Вы сможете использовать этот набор через {time}",
                ["KIT_NEEDSLOTS"] = "Невозможно получить набор - недостаточно места в инвентаре",
                ["KIT_RECEIVED"] = "Вы получили набор {kitname}",
                ["TITLE_KITSHOW"] = "<color=#fffffAA>Список содержимого набора <color=#FFAA00AA>%</color></color>",
            }, this, "ru");
        }

        private Timer initTimer;
        private void OnServerInitialized()
        {
            Instance = this;

            _kits = Interface.Oxide.DataFileSystem.ReadObject<List<Kit>>("Kits");
            _kitsData = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, Dictionary<string, KitData>>>("Kits_Data");

            for(int i = 0; i < _kits.Count; i++)
            {
                AddImage("file://" + Interface.Oxide.DataDirectory + Path.DirectorySeparatorChar + "Kits" + Path.DirectorySeparatorChar + _kits[i].Image, _kits[i].Name);
                permission.RegisterPermission(_kits[i].Permission, this);
            }

            initTimer = timer.Every(5f, () =>
            {
                if (XMenu.IsLoaded)
                {
                    XMenu.Call("API_RegisterSubMenu", this.Name, "Main", "Киты", "RenderKits", null);

                    int kitsID = (int)XMenu.Call("API_GetSubMenuID", "Main", "Киты");
                    cmd.AddChatCommand("kit", this, (p, cmd, args) => rust.RunClientCommand(p, $"custommenu true Main {kitsID}"));

                    initTimer.Destroy();
                }
            });

        }

        private void Unload()
        {
            SaveData();
        }

        [ConsoleCommand("kitadd")]
        private void AddKitCmd(ConsoleSystem.Arg arg)
        {
            if (arg.IsAdmin)
            {
                Kit kit = new Kit()
                {
                    Name = "New Kit",
                    Amount = 0,
                    Cooldown = 100000,
                    Image = "rust.png",
                    Items = new List<KitItem>(),
                    Permission = "RustKits.hide"
                };

                for(int i = 0; i < arg.Player().inventory.containerBelt.itemList.Count; i++)
                {
                    KitItem kitItem = new KitItem()
                    {
                        Container = "belt",
                        Amount = arg.Player().inventory.containerBelt.itemList[i].amount,
                        Name = arg.Player().inventory.containerBelt.itemList[i].info.shortname,
                        SkinID = arg.Player().inventory.containerBelt.itemList[i].skin,
                        Condition = arg.Player().inventory.containerBelt.itemList[i].condition,
                    };

                    if (arg.Player().inventory.containerBelt.itemList[i].info.category == ItemCategory.Weapon)
                    {
                        BaseProjectile weapon = arg.Player().inventory.containerBelt.itemList[i].GetHeldEntity() as BaseProjectile;
                        if (weapon != null)
                        {
                            kitItem.Weapon = new Weapon();
                            kitItem.Weapon.AmmoName = weapon.primaryMagazine.ammoType.shortname;
                            kitItem.Weapon.Amount = weapon.primaryMagazine.contents;
                        }
                    }

                    kit.Items.Add(kitItem);
                }

                for (int i = 0; i < arg.Player().inventory.containerMain.itemList.Count; i++)
                {
                    KitItem kitItem = new KitItem()
                    {
                        Container = "main",
                        Amount = arg.Player().inventory.containerMain.itemList[i].amount,
                        Name = arg.Player().inventory.containerMain.itemList[i].info.shortname,
                        SkinID = arg.Player().inventory.containerMain.itemList[i].skin,
                        Condition = arg.Player().inventory.containerMain.itemList[i].condition,
                    };

                    if (arg.Player().inventory.containerMain.itemList[i].info.category == ItemCategory.Weapon)
                    {
                        BaseProjectile weapon = arg.Player().inventory.containerMain.itemList[i].GetHeldEntity() as BaseProjectile;
                        if (weapon != null)
                        {
                            kitItem.Weapon = new Weapon();
                            kitItem.Weapon.AmmoName = weapon.primaryMagazine.ammoType.shortname;
                            kitItem.Weapon.Amount = weapon.primaryMagazine.contents;
                        }
                    }

                    kit.Items.Add(kitItem);
                }

                for (int i = 0; i < arg.Player().inventory.containerWear.itemList.Count; i++)
                {
                    KitItem kitItem = new KitItem()
                    {
                        Container = "wear",
                        Amount = arg.Player().inventory.containerWear.itemList[i].amount,
                        Name = arg.Player().inventory.containerWear.itemList[i].info.shortname,
                        SkinID = arg.Player().inventory.containerWear.itemList[i].skin,
                        Condition = arg.Player().inventory.containerWear.itemList[i].condition,
                    };

                    if (arg.Player().inventory.containerWear.itemList[i].info.category == ItemCategory.Weapon)
                    {
                        BaseProjectile weapon = arg.Player().inventory.containerWear.itemList[i].GetHeldEntity() as BaseProjectile;
                        if (weapon != null)
                        {
                            kitItem.Weapon = new Weapon();
                            kitItem.Weapon.AmmoName = weapon.primaryMagazine.ammoType.shortname;
                            kitItem.Weapon.Amount = weapon.primaryMagazine.contents;
                        }
                    }

                    kit.Items.Add(kitItem);
                }


                _kits.Add(kit);
                SaveKits();
            }

        }

        [ConsoleCommand("kit")]
        private void GiveKitCmd(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Player();
            if (args.HasArgs(4))
            {
                string kitName = args.Args[0];
                int i = int.Parse(args.Args[1]);
                int positionX = int.Parse(args.Args[2]);
                int positionY = int.Parse(args.Args[3]);

                if(_kits.Exists(x => x.Name == kitName) == false)
                {;
                    return;
                }

                var kit = _kits.First(x => x.Name == kitName);
                if(string.IsNullOrEmpty(kit.Permission) == false && permission.UserHasPermission(player.UserIDString, kit.Permission) == false)
                {
                    return;
                }

                var kitData = GetKitData(player, kitName);
                if (kit.Amount > 0 && kitData.Amount >= kit.Amount)
                {
                    return;
                }

                if (kit.Cooldown > 0)
                {
                    var currentTime = GetCurrentTime();
                    if (kitData.Cooldown > currentTime)
                    {
                        return;
                    }
                }

                int beltcount = kit.Items.Where(j => j.Container == "belt").Count();
                int wearcount = kit.Items.Where(j => j.Container == "wear").Count();
                int maincount = kit.Items.Where(j => j.Container == "main").Count();
                int totalcount = beltcount + wearcount + maincount;

                if ((player.inventory.containerBelt.capacity - player.inventory.containerBelt.itemList.Count) < beltcount ||
                    (player.inventory.containerWear.capacity - player.inventory.containerWear.itemList.Count) < wearcount ||
                    (player.inventory.containerMain.capacity - player.inventory.containerMain.itemList.Count) < maincount)
                {
                    if (totalcount > (player.inventory.containerMain.capacity - player.inventory.containerMain.itemList.Count))
                    {
                        return;
                    }
                }

                GiveKit(player, kit);

                if (kit.Amount > 0)
                    kitData.Amount += 1;

                if (kit.Cooldown > 0)
                    kitData.Cooldown = GetCurrentTime() + kit.Cooldown;
                CuiElementContainer Container = new CuiElementContainer();
                RenderKit(player, Container, GetKitsForPlayer(player), i, positionX, positionY);
                CuiHelper.AddUi(player, Container);
            }
        }
		
        public const string MenuLayer = "XMenu";
        public const string MenuItemsLayer = "XMenu.MenuItems";
        public const string MenuSubItemsLayer = "XMenu.MenuSubItems";
        public const string MenuContent = "XMenu.Content";
		
        private void RenderKits(ulong userID, object[] objects)
        {
            CuiElementContainer Container = (CuiElementContainer)objects[0];
			BasePlayer player = BasePlayer.FindByID(userID);
            bool FullRender = (bool)objects[1];
            string Name = (string)objects[2];
            int ID = (int)objects[3];
            int Page = (int)objects[4];
			
			Container.Add(new CuiElement
            {
                Name = MenuContent,
                Parent = MenuLayer,
                Components =
                    {
                        new CuiImageComponent
                        {
                            Color = "0 0 0 0",
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5",
                            AnchorMax = "0.5 0.5",
                            OffsetMin = "-215 -230",
                            OffsetMax = "500 270"
                        },
                    }
            });
			
            Container.Add(new CuiElement
            {
                Name = "XMenu" + ".Content" + ".Kits",
                Parent = MenuContent,
                Components =
                            {
                                new CuiImageComponent
                                {
                                    Color = "0 0 0 0",
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0 0",
                                    AnchorMax = "1 1",
                                }
                            }
            });
            Container.Add(new CuiElement
            {
                Name = "XMenu" + ".Content"  + $".Title",
                Parent = "XMenu" + ".Content" + ".Kits",
                Components =
                    {
                        new CuiTextComponent
                        {
                            Text = lang.GetMessage("TITLE", this, player.UserIDString),
                            Align = TextAnchor.MiddleCenter,
                            FontSize = 36,
                            Font = "robotocondensed-bold.ttf",
                            FadeIn = 0.5f,
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 1",
                            AnchorMax = "0.5 1",
                            OffsetMin = $"-275 -100",
                            OffsetMax = $"275 0",
                        }
                    }
            });
            List<Kit> Kits = GetKitsForPlayer(player);
            for (int i = 0, x = 0, y = 0; i < Kits.Count; i++)
            {
                if (x == 3)
                {
                    x = 0;
                    y++;
                }
                RenderKit(player, Container, Kits, i, x, y);
                x++;
            }
        }

        private void RenderKit(BasePlayer player, CuiElementContainer Container, List<Kit> Kits, int number, int positionX, int positionY)
        {
            CuiHelper.DestroyUi(player, "XMenu" + ".Content"  + $"Kit.{number}");
            double Cooldown = (GetCurrentTime() - GetKitData(player, Kits[number].Name).Cooldown) * -1;
            string Time = TimeExtensions.FormatShortTime(TimeSpan.FromSeconds(Cooldown));
            string BtnColor = "1 0.22 0.15 0.3";
            if (Cooldown < 0) BtnColor = "0.66 1 0.3 0.2";
            Container.Add(new CuiElement
            {
                Name = "XMenu" + ".Content"  + $"Kit.{number}",
                Parent = "XMenu" + ".Content" + ".Kits",
                Components =
                            {
                                new CuiImageComponent
                                {
                                    Color = "0 0 0 0.5",
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0.5 1",
                                    AnchorMax = "0.5 1",
                                    OffsetMin = $"{-300 + positionX * 205} {-200 - positionY * 105}",
                                    OffsetMax = $"{-105 + positionX * 205} {-100 - positionY * 105}"
                                }
                            }
            });
            Container.Add(new CuiElement
            {
                Name = "XMenu" + ".Content"  + $"Kit.{number}.Background",
                Parent = "XMenu" + ".Content"  + $"Kit.{number}",
                Components =
                                {
                                    new CuiImageComponent
                                    {
                                        Color = "1 1 1 0.05",
                                    },
                                    new CuiRectTransformComponent
                                    {
                                        AnchorMin = "0.025 0.05",
                                        AnchorMax = "0.475 0.95",
                                    }
                                }
            });
            Container.Add(new CuiElement
            {
                Name = "XMenu" + ".Content"  + $"Kit.{number}.Img",
                Parent = "XMenu" + ".Content"  + $"Kit.{number}",
                Components =
                            {
                                new CuiRawImageComponent
                                {
                                    FadeIn = 0.5f,
                                    Png = GetImage(Kits[number].Name),
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0.025 0.05",
                                    AnchorMax = "0.475 0.95",
                                }
                            }
            });
            Container.Add(new CuiButton
            {
                Button = { Color = "1 1 1 0", Command = $"kitshow {Kits[number].Name}" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", },
                Text = { Text = "", Align = TextAnchor.MiddleCenter }
            }, "XMenu" + ".Content"  + $"Kit.{number}.Img");
            Container.Add(new CuiElement
            {
                Name = "XMenu" + ".Content"  + $"Kit.{number}.Title",
                Parent = "XMenu" + ".Content"  + $"Kit.{number}",
                Components =
                            {
                                new CuiTextComponent
                                {
                                    Text = $"<color=#fff9f9AA>{Kits[number].Name}</color>",
                                    Align = TextAnchor.MiddleCenter,
                                    FontSize = 12,
                                    Font = "robotocondensed-bold.ttf",
                                    FadeIn = 0.5f,
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0.5 0.7",
                                    AnchorMax = "1 1",
                                }
                            }
            });
            Container.Add(new CuiElement
            {
                Name = "XMenu" + ".Content"  + $"Kit.{number}.BtnBackground",
                Parent = "XMenu" + ".Content"  + $"Kit.{number}",
                Components =
                            {
                                new CuiImageComponent
                                {
                                    Color = BtnColor,
                                    FadeIn = 0.5f,
                                    Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat"
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = "0.525 0.05",
                                    AnchorMax = "0.95 0.3",
                                },
                            }
            });
            if (Cooldown > 0)
            {
                Container.Add(new CuiElement
                {
                    Name = "XMenu" + ".Content"  + $"Kit.{number}.Timer",
                    Parent = "XMenu" + ".Content"  + $"Kit.{number}",
                    Components =
                                {
                                    new CuiTextComponent
                                    {
                                        Text = $"<color=#fff9f9AA>{lang.GetMessage("TIMER", this, player.UserIDString)}:\n {Time}</color>",
                                        Align = TextAnchor.LowerCenter,
                                        FontSize = 14,
                                        Font = "robotocondensed-bold.ttf",
                                        FadeIn = 0.5f,
                                    },
                                    new CuiRectTransformComponent
                                    {
                                        AnchorMin = "0.5 0.35",
                                        AnchorMax = "1 0.7",
                                    }
                                }
                });
                Container.Add(new CuiElement
                {
                    Name = "XMenu" + ".Content"  + $"Kit.{number}.BtnTitle",
                    Parent = "XMenu" + ".Content"  + $"Kit.{number}",
                    Components =
                                {
                                    new CuiTextComponent
                                    {
                                        Text = $"<color=#fff9f9AA>{lang.GetMessage("BUTTON_CANT", this, player.UserIDString)}</color>",
                                        Align = TextAnchor.MiddleCenter,
                                        FontSize = 14,
                                        Font = "robotocondensed-bold.ttf",
                                        FadeIn = 0.5f,
                                    },
                                    new CuiRectTransformComponent
                                    {
                                        AnchorMin = "0.525 0.05",
                                        AnchorMax = "0.95 0.3",
                                    }
                                }
                });
            }
            else
            {
                Container.Add(new CuiElement
                {
                    Name = "XMenu" + ".Content"  + $"Kit.{number}.Timer",
                    Parent = "XMenu" + ".Content"  + $"Kit.{number}",
                    Components =
                                {
                                    new CuiTextComponent
                                    {
                                        Text = $"<color=#fff9f9AA>{lang.GetMessage("TITLE_CAN", this, player.UserIDString)}</color>",
                                        Align = TextAnchor.LowerCenter,
                                        FontSize = 14,
                                        Font = "robotocondensed-bold.ttf",
                                        FadeIn = 0.5f,
                                    },
                                    new CuiRectTransformComponent
                                    {
                                        AnchorMin = "0.5 0.35",
                                        AnchorMax = "1 0.7",
                                    }
                                }
                });
                Container.Add(new CuiElement
                {
                    Name = "XMenu" + ".Content"  + $"Kit.{number}.BtnTitle",
                    Parent = "XMenu" + ".Content"  + $"Kit.{number}",
                    Components =
                                {
                                    new CuiTextComponent
                                    {
                                        Text = $"<color=#fff9f9AA>{lang.GetMessage("BUTTON_CAN", this, player.UserIDString)}</color>",
                                        Align = TextAnchor.MiddleCenter,
                                        FontSize = 14,
                                        Font = "robotocondensed-bold.ttf",
                                        FadeIn = 0.5f,
                                    },
                                    new CuiRectTransformComponent
                                    {
                                        AnchorMin = "0.525 0.05",
                                        AnchorMax = "0.95 0.3",
                                    }
                                }
                });
                Container.Add(new CuiButton
                {
                    Button = { Color = "1 1 1 0", Command = $"kit {Kits[number].Name} {number} {positionX} {positionY}" },
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Text = { Text = "", Align = TextAnchor.MiddleCenter }
                }, "XMenu" + ".Content"  + $"Kit.{number}.BtnTitle");
            }
        }

        [ConsoleCommand("kitshow")]
        void CaseShowCmd(ConsoleSystem.Arg arg)
        {
            if (arg.HasArgs())
            {
                if (arg.Args[0] == "close")
                {
                    CuiHelper.DestroyUi(arg.Player(), "XMenu" + ".Content" );

                    return;
                }
                Kit _kit = _kits.Find(x => x.Name == arg.Args[0]);
                if (_kit == null)
                {
                    Notifications.Call("API_AddUINote", arg.Connection.userid, $"Не найден набор с таким именем");
                    return;
                }

                RenderKitInfo(arg.Player(), _kit);
            }
        }

        private void RenderKitInfo(BasePlayer player, Kit kit)
        {
            CuiHelper.DestroyUi(player, "XMenu" + ".Content" + ".Kits");
            CuiElementContainer Container = new CuiElementContainer();
            Container.Add(new CuiElement
            {
                Name = "XMenu" + ".Content"  + $".Title",
                Parent = "XMenu" + ".Content" ,
                Components =
                    {
                        new CuiTextComponent
                        {
                            Text = lang.GetMessage("TITLE_KITSHOW", this, player.UserIDString).Replace("%", kit.Name),
                            Align = TextAnchor.MiddleCenter,
                            FontSize = 24,
                            Font = "robotocondensed-bold.ttf",
                            FadeIn = 0.5f,
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 1",
                            AnchorMax = "0.5 1",
                            OffsetMin = $"-275 -75",
                            OffsetMax = $"275 0",
                        }
                    }
            });

            for(int i = 0, x = 0, y = 0; i < kit.Items.Count; i++)
            {
                if(x > 5)
                {
                    x = 0;
                    y++;
                }
                if (ItemManager.itemDictionaryByName.ContainsKey(kit.Items[i].Name))
                {
                    Container.Add(new CuiElement
                    {
                        Name = "XMenu" + ".Content"  + $"Kit.Info.Item{i}.Background",
                        Parent = "XMenu" + ".Content" ,
                        Components =
                                {
                                    new CuiImageComponent
                                    {
                                        Color = "1 1 1 0.05",
                                    },
                                    new CuiRectTransformComponent
                                    {
                                        AnchorMin = "0.5 1",
                                        AnchorMax = "0.5 1",
                                        OffsetMin = $"{-275 + x * 90} {-155 - y * 90}",
                                        OffsetMax = $"{-195 + x * 90} {-75 - y * 90}",
                                    }
                                }
                    });

                    Container.Add(new CuiElement
                    {
                        Name = "XMenu" + ".Content"  + $"Kit.Info.Item{i}.Background.Img",
                        Parent = "XMenu" + ".Content"  + $"Kit.Info.Item{i}.Background",
                        Components =
                            {
                                new CuiRawImageComponent
                                {
                                    FadeIn = 0.5f,
                                    Png = GetImage(kit.Items[i].Name),
                                },
                                new CuiRectTransformComponent
                                {
                                    AnchorMin = $"0.1 0.1",
                                    AnchorMax = $"0.9 0.9",
                                }
                            }
                    });

                    Container.Add(new CuiElement
                    {
                        Name = "XMenu" + ".Content"  + $"Kit.Info.Item{i}.Background.Amount",
                        Parent = "XMenu" + ".Content"  + $"Kit.Info.Item{i}.Background",
                        Components =
                        {
                            new CuiTextComponent
                            {
                                Text = kit.Items[i].Amount + " шт",
                                Align = TextAnchor.MiddleCenter,
                                FontSize = 12,
                                Font = "robotocondensed-bold.ttf",
                                FadeIn = 0.5f,
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = $"0 0",
                                AnchorMax = $"1 0.3",
                            }
                        }
                    });
                    x++;
                }
            }

            CuiHelper.AddUi(player, Container);
        }

        private void GiveKit(BasePlayer player, Kit kit)
        {
            foreach (var kitItem in kit.Items)
            {
                if (ItemManager.itemDictionaryByName.ContainsKey(kitItem.Name))
                {
                    GiveItem(player.inventory, BuildItem(kitItem.Name, kitItem.Amount, kitItem.SkinID, kitItem.Condition, kitItem.Weapon), kitItem.Container == "belt" ? player.inventory.containerBelt : kitItem.Container == "wear" ? player.inventory.containerWear : player.inventory.containerMain);
                }
                else
                {
                    if (!string.IsNullOrEmpty(kitItem.Name))
                    {
                        rust.RunServerCommand(kitItem.Name.Replace("%STEAMID%", player.userID.ToString()));
                    }
                }
            }
        }

        private void GiveItem(PlayerInventory inv, Item item, ItemContainer cont = null)
        {
            if (item == null) return;
            var a = item.MoveToContainer(cont) || item.MoveToContainer(inv.containerBelt) || item.MoveToContainer(inv.containerWear) || item.MoveToContainer(inv.containerMain);
        }

        private Item BuildItem(string ShortName, int Amount, ulong SkinID, float Condition, Weapon weapon)
        {
            Item item = ItemManager.CreateByName(ShortName, Amount > 1 ? Amount : 1, SkinID);
            item.condition = Condition;
            if (weapon != null)
            {
                (item.GetHeldEntity() as BaseProjectile).primaryMagazine.contents = weapon.Amount;
                (item.GetHeldEntity() as BaseProjectile).primaryMagazine.ammoType = ItemManager.FindItemDefinition(weapon.AmmoName);

                if (weapon.Content != null)
                {
                    foreach (var content in weapon.Content)
                    {
                        Item itemContent = ItemManager.CreateByName(content, 1);
                        itemContent.MoveToContainer(item.contents);
                    }
                }
            }

            return item;
        }
        #endregion

        #region Utils
        private double GetCurrentTime() => new TimeSpan(DateTime.UtcNow.Ticks).TotalSeconds;

        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);

            return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
        }

        private static class TimeExtensions
        {
            public static string FormatShortTime(TimeSpan time)
            {
                string result = string.Empty;
                if (time.Days != 0)
                    result += $"{time.Days}д ";

                if (time.Hours != 0)
                    result += $"{time.Hours}ч ";

                if (time.Minutes != 0)
                    result += $"{time.Minutes}м ";

                if (time.Seconds != 0)
                    result += $"{time.Seconds}с ";

                return result;
            }

            public static string FormatTime(TimeSpan time)
            {
                string result = string.Empty;
                if (time.Days != 0)
                    result += $"{Format(time.Days, "дней", "дня", "день")} ";

                if (time.Hours != 0)
                    result += $"{Format(time.Hours, "часов", "часа", "час")} ";

                if (time.Minutes != 0)
                    result += $"{Format(time.Minutes, "минут", "минуты", "минута")} ";

                if (time.Seconds != 0)
                    result += $"{Format(time.Seconds, "секунд", "секунды", "секунда")} ";

                return result;
            }

            private static string Format(int units, string form1, string form2, string form3)
            {
                var tmp = units % 10;

                if (units >= 5 && units <= 20 || tmp >= 5 && tmp <= 9)
                    return $"{units} {form1}";

                if (tmp >= 2 && tmp <= 4)
                    return $"{units} {form2}";

                return $"{units} {form3}";
            }
        }
        #endregion
    }
}


// --- End of file: RustKits.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HudRust/ImageLibrary.cs ---
// --- Original Local Path: HudRust/ImageLibrary.cs ---

//Reference: Facepunch.Sqlite
//Reference: UnityEngine.UnityWebRequestModule
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using Steamworks;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Networking;

namespace Oxide.Plugins
{
    [Info("Image Library", "Absolut & K1lly0u", "2.0.58")]
    [Description("Plugin API for downloading and managing images")]
    class ImageLibrary : RustPlugin
    {
        #region Fields

        private ImageIdentifiers imageIdentifiers;
        private ImageURLs imageUrls;
        private SkinInformation skinInformation;
        private DynamicConfigFile identifiers;
        private DynamicConfigFile urls;
        private DynamicConfigFile skininfo;

        private static ImageLibrary il;
        private ImageAssets assets;

        private Queue<LoadOrder> loadOrders = new Queue<LoadOrder>();
        private bool orderPending;
        private bool isInitialized;

        private JsonSerializerSettings errorHandling = new JsonSerializerSettings { Error = (se, ev) => { ev.ErrorContext.Handled = true; } };

        private const string STEAM_API_URL = "https://api.steampowered.com/ISteamRemoteStorage/GetPublishedFileDetails/v1/";
        private const string STEAM_AVATAR_URL = "https://api.steampowered.com/ISteamUser/GetPlayerSummaries/v0002/?key={0}&steamids={1}";

        private string[] itemShortNames;

        #endregion Fields

        #region Oxide Hooks

        private void Loaded()
        {
            identifiers = Interface.Oxide.DataFileSystem.GetFile("ImageLibrary/image_data");
            urls = Interface.Oxide.DataFileSystem.GetFile("ImageLibrary/image_urls");
            skininfo = Interface.Oxide.DataFileSystem.GetFile("ImageLibrary/skin_data");

            il = this;
            LoadData();
        }

        private void OnServerInitialized()
        {
            itemShortNames = ItemManager.itemList.Select(x => x.shortname).ToArray();

            foreach (ItemDefinition item in ItemManager.itemList)
            {
                string workshopName = item.displayName.english.ToLower().Replace("skin", "").Replace(" ", "").Replace("-", "");
                if (!workshopNameToShortname.ContainsKey(workshopName))
                    workshopNameToShortname.Add(workshopName, item.shortname);
            }

            AddDefaultUrls();

            CheckForRefresh();

            foreach (BasePlayer player in BasePlayer.activePlayerList)
                OnPlayerConnected(player);
        }

        private void OnPlayerConnected(BasePlayer player) => GetPlayerAvatar(player?.UserIDString);

        private void Unload()
        {
            SaveData();
            UnityEngine.Object.Destroy(assets);
            il = null;
        }

        #endregion Oxide Hooks

        #region Functions
        private IEnumerator ProcessLoadOrders()
        {
            yield return new WaitWhile(() => !isInitialized);

            if (loadOrders.Count > 0)
            {
                if (orderPending)
                    yield break;

                LoadOrder nextLoad = loadOrders.Dequeue();
                if (!nextLoad.loadSilent)
                    Puts("Starting order " + nextLoad.loadName);

                if (nextLoad.imageList != null && nextLoad.imageList.Count > 0)
                {
                    foreach (KeyValuePair<string, string> item in nextLoad.imageList)
                        assets.Add(item.Key, item.Value);
                }
                if (nextLoad.imageData != null && nextLoad.imageData.Count > 0)
                {
                    foreach (KeyValuePair<string, byte[]> item in nextLoad.imageData)
                        assets.Add(item.Key, null, item.Value);
                }

                orderPending = true;

                assets.RegisterCallback(nextLoad.callback);

                assets.BeginLoad(nextLoad.loadSilent ? string.Empty : nextLoad.loadName);
            }
        }

        private void GetPlayerAvatar(string userId)
        {
            if (!configData.StoreAvatars || string.IsNullOrEmpty(userId) || string.IsNullOrEmpty(configData.SteamAPIKey) || HasImage(userId, 0))
                return;

            webrequest.Enqueue(string.Format(STEAM_AVATAR_URL, configData.SteamAPIKey, userId), null, (code, response) =>
            {
                if (response != null && code == 200)
                {
                    try
                    {
                        AvatarRoot rootObject = JsonConvert.DeserializeObject<AvatarRoot>(response, errorHandling);
                        if (rootObject?.response?.players?.Length > 0)
                        {
                            string avatarUrl = rootObject.response.players[0].avatarmedium;
                            if (!string.IsNullOrEmpty(avatarUrl))                            
                                AddImage(avatarUrl, userId, 0);                               
                        }                        
                    }
                    catch { }
                }
            }, this);
        }

        private void RefreshImagery()
        {
            imageIdentifiers.imageIds.Clear();
            imageIdentifiers.lastCEID = CommunityEntity.ServerInstance.net.ID;

            AddImage("http://i.imgur.com/sZepiWv.png", "NONE", 0);
            AddImage("http://i.imgur.com/lydxb0u.png", "LOADING", 0);
            foreach (var image in configData.UserImages)
            {
                if (!string.IsNullOrEmpty(image.Value))
                    AddImage(image.Value, image.Key, 0);
            }

            if ((Steamworks.SteamInventory.Definitions?.Length ?? 0) == 0)
            {
                PrintWarning("Waiting for Steamworks to update item definitions....");
                Steamworks.SteamInventory.OnDefinitionsUpdated += GetItemSkins;
            }
            else GetItemSkins();
        }

        private void CheckForRefresh()
        {
            if (assets == null)
                assets = new GameObject("WebObject").AddComponent<ImageAssets>();

            isInitialized = true;

            if (imageIdentifiers.lastCEID != CommunityEntity.ServerInstance.net.ID)
            {
                if (imageIdentifiers.imageIds.Count < 2)
                {
                    RefreshImagery();
                }
                else
                {
                    PrintWarning("The CommunityEntity instance ID has changed! Due to the way CUI works in Rust all previously stored images must be removed and re-stored using the new ID as reference so clients can find the images. These images will be added to a new load order. Interupting this process will result in being required to re-download these images from the web");
                    RestoreLoadedImages();
                }
            }
        }

        private void RestoreLoadedImages()
        {
            orderPending = true;

            try
            {
                Facepunch.Sqlite.Database db = new Facepunch.Sqlite.Database();
                db.Open(string.Concat(ConVar.Server.rootFolder, "/", "sv.files.", Rust.Protocol.save - 1, ".db"));                
                if (db.TableExists("data"))
                {
                    Dictionary<string, byte[]> oldFiles = new Dictionary<string, byte[]>();
                    int failed = 0;

                    for (int i = imageIdentifiers.imageIds.Count - 1; i >= 0; i--)
                    {
                        KeyValuePair<string, string> image = imageIdentifiers.imageIds.ElementAt(i);

                        uint imageId;
                        if (!uint.TryParse(image.Value, out imageId))
                            continue;

                        byte[] bytes = db.QueryBlob("SELECT data FROM data WHERE crc = ? AND filetype = ? AND entid = ? LIMIT 1", new object[] { (int)imageId, 0, imageIdentifiers.lastCEID });
                        if (bytes != null)
                            oldFiles.Add(image.Key, bytes);
                        else
                        {
                            failed++;
                            imageIdentifiers.imageIds.Remove(image.Key);
                        }
                    }

                    if (oldFiles.Count > 0)
                    {
                        loadOrders.Enqueue(new LoadOrder("Image restoration from previous database", oldFiles));
                        PrintWarning($"{imageIdentifiers.imageIds.Count - failed} images queued for restoration from previous image db, {failed} images failed");
                    }

                }
                db.Close();
            }
            catch
            {
                PrintError("Failed to open previous image database. Unable to clone previous image data");
            }
            //Facepunch.Sqlite.Database db = new Facepunch.Sqlite.Database();
            //try
            //{
            //    db.Open($"{ConVar.Server.rootFolder}/sv.files.0.db");
            //    db.Execute("DELETE FROM data WHERE entid = ?", imageIdentifiers.lastCEID);
            //    db.Close();
            //}
            //catch { }

            //loadOrders.Enqueue(new LoadOrder("Image restoration from previous database", oldFiles));
            //PrintWarning($"{imageIdentifiers.imageIds.Count - failed} images queued for restoration, {failed} images failed");
            imageIdentifiers.lastCEID = CommunityEntity.ServerInstance.net.ID;
            SaveData();

            orderPending = false;
            ServerMgr.Instance.StartCoroutine(ProcessLoadOrders());
        }

        #endregion Functions

        #region Workshop Names and Image URLs
        private void AddDefaultUrls()
        {
            foreach (ItemDefinition itemDefinition in ItemManager.itemList)
            {
                string identifier = $"{itemDefinition.shortname}_0";
                if (!imageUrls.URLs.ContainsKey(identifier))
                    imageUrls.URLs.Add(identifier, $"{configData.ImageURL}{itemDefinition.shortname}.png");
                else imageUrls.URLs[identifier] = $"{configData.ImageURL}{itemDefinition.shortname}.png";
            }
            SaveUrls();
        }

        private readonly Dictionary<string, string> workshopNameToShortname = new Dictionary<string, string>
        {
            {"longtshirt", "tshirt.long" },
            {"cap", "hat.cap" },
            {"beenie", "hat.beenie" },
            {"boonie", "hat.boonie" },
            {"balaclava", "mask.balaclava" },
            {"pipeshotgun", "shotgun.waterpipe" },
            {"woodstorage", "box.wooden" },
            {"ak47", "rifle.ak" },
            {"bearrug", "rug.bear" },
            {"boltrifle", "rifle.bolt" },
            {"bandana", "mask.bandana" },
            {"hideshirt", "attire.hide.vest" },
            {"snowjacket", "jacket.snow" },
            {"buckethat", "bucket.helmet" },
            {"semiautopistol", "pistol.semiauto" },
            {"burlapgloves", "burlap.gloves" },
            {"roadsignvest", "roadsign.jacket" },
            {"roadsignpants", "roadsign.kilt" },
            {"burlappants", "burlap.trousers" },
            {"collaredshirt", "shirt.collared" },
            {"mp5", "smg.mp5" },
            {"sword", "salvaged.sword" },
            {"workboots", "shoes.boots" },
            {"vagabondjacket", "jacket" },
            {"hideshoes", "attire.hide.boots" },
            {"deerskullmask", "deer.skull.mask" },
            {"minerhat", "hat.miner" },
            {"lr300", "rifle.lr300" },
            {"lr300.item", "rifle.lr300" },
            {"burlap.gloves", "burlap.gloves.new"},
            {"leather.gloves", "burlap.gloves"},
            {"python", "pistol.python" },
            {"m39", "rifle.m39"},
            {"woodendoubledoor", "door.double.hinged.wood"}
        };

        #endregion Workshop Names and Image URLs

        #region API

        [HookMethod("AddImage")]
        public bool AddImage(string url, string imageName, ulong imageId, Action callback = null)
        {
            loadOrders.Enqueue(new LoadOrder(imageName, new Dictionary<string, string> { { $"{imageName}_{imageId}", url } }, true, callback));
            if (!orderPending)
                ServerMgr.Instance.StartCoroutine(ProcessLoadOrders());
            return true;
        }

        [HookMethod("AddImageData")]
        public bool AddImageData(string imageName, byte[] array, ulong imageId, Action callback = null)
        {
            loadOrders.Enqueue(new LoadOrder(imageName, new Dictionary<string, byte[]> { { $"{imageName}_{imageId}", array } }, true, callback));
            if (!orderPending)
                ServerMgr.Instance.StartCoroutine(ProcessLoadOrders());
            return true;
        }

        [HookMethod("GetImageURL")]
        public string GetImageURL(string imageName, ulong imageId = 0)
        {
            string identifier = $"{imageName}_{imageId}";
            string value;
            if (imageUrls.URLs.TryGetValue(identifier, out value))
                return value;
            return string.Empty;
        }

        [HookMethod("GetImage")]
        public string GetImage(string imageName, ulong imageId = 0, bool returnUrl = false)
        {
            string identifier = $"{imageName}_{imageId}";
            string value;
            if (imageIdentifiers.imageIds.TryGetValue(identifier, out value))
                return value;
            else
            {                
                if (imageUrls.URLs.TryGetValue(identifier, out value))
                {
                    AddImage(value, imageName, imageId);
                    return imageIdentifiers.imageIds["LOADING_0"];
                }
            }

            if (returnUrl && !string.IsNullOrEmpty(value))
                return value;

            return imageIdentifiers.imageIds["NONE_0"];
        }

        [HookMethod("GetImageList")]
        public List<ulong> GetImageList(string name)
        {
            List<ulong> skinIds = new List<ulong>();
            var matches = imageUrls.URLs.Keys.Where(x => x.StartsWith(name)).ToArray();
            for (int i = 0; i < matches.Length; i++)
            {
                var index = matches[i].IndexOf("_");
                if (matches[i].Substring(0, index) == name)
                {
                    ulong skinID;
                    if (ulong.TryParse(matches[i].Substring(index + 1), out skinID))
                        skinIds.Add(ulong.Parse(matches[i].Substring(index + 1)));
                }
            }
            return skinIds;
        }

        [HookMethod("GetSkinInfo")]
        public Dictionary<string, object> GetSkinInfo(string name, ulong id)
        {
            Dictionary<string, object> skinInfo;
            if (skinInformation.skinData.TryGetValue($"{name}_{id}", out skinInfo))
                return skinInfo;
            return null;
        }

        [HookMethod("HasImage")]
        public bool HasImage(string imageName, ulong imageId)
        {
            string key = $"{imageName}_{imageId}";
            string value;

            if (imageIdentifiers.imageIds.TryGetValue(key, out value) && IsInStorage(uint.Parse(value)))            
                return true;            

            return false;
        }

        public bool IsInStorage(uint crc) => FileStorage.server.Get(crc, FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID) != null;

        [HookMethod("IsReady")]
        public bool IsReady() => loadOrders.Count == 0 && !orderPending;

        [HookMethod("ImportImageList")]
        public void ImportImageList(string title, Dictionary<string, string> imageList, ulong imageId = 0, bool replace = false, Action callback = null)
        {
            Dictionary<string, string> newLoadOrder = new Dictionary<string, string>();
            foreach (var image in imageList)
            {
                if (!replace && HasImage(image.Key, imageId))
                    continue;
                newLoadOrder[$"{image.Key}_{imageId}"] = image.Value;
            }
            if (newLoadOrder.Count > 0)
            {
                loadOrders.Enqueue(new LoadOrder(title, newLoadOrder, false, callback));
                if (!orderPending)
                    ServerMgr.Instance.StartCoroutine(ProcessLoadOrders());
            }
            else
            {
                if (callback != null)
                    callback.Invoke();
            }
        }

        [HookMethod("ImportItemList")]
        public void ImportItemList(string title, Dictionary<string, Dictionary<ulong, string>> itemList, bool replace = false, Action callback = null)
        {
            Dictionary<string, string> newLoadOrder = new Dictionary<string, string>();
            foreach (var image in itemList)
            {
                foreach (var skin in image.Value)
                {
                    if (!replace && HasImage(image.Key, skin.Key))
                        continue;
                    newLoadOrder[$"{image.Key}_{skin.Key}"] = skin.Value;
                }
            }
            if (newLoadOrder.Count > 0)
            {
                loadOrders.Enqueue(new LoadOrder(title, newLoadOrder, false, callback));
                if (!orderPending)
                    ServerMgr.Instance.StartCoroutine(ProcessLoadOrders());
            }
            else
            {
                if (callback != null)
                    callback.Invoke();
            }
        }

        [HookMethod("ImportImageData")]
        public void ImportImageData(string title, Dictionary<string, byte[]> imageList, ulong imageId = 0, bool replace = false, Action callback = null)
        {
            Dictionary<string, byte[]> newLoadOrder = new Dictionary<string, byte[]>();
            foreach (var image in imageList)
            {
                if (!replace && HasImage(image.Key, imageId))
                    continue;
                newLoadOrder[$"{image.Key}_{imageId}"] = image.Value;
            }
            if (newLoadOrder.Count > 0)
            {
                loadOrders.Enqueue(new LoadOrder(title, newLoadOrder, false, callback));
                if (!orderPending)
                    ServerMgr.Instance.StartCoroutine(ProcessLoadOrders());
            }
            else
            {
                if (callback != null)
                    callback.Invoke();
            }
        }

        [HookMethod("LoadImageList")]
        public void LoadImageList(string title, List<KeyValuePair<string, ulong>> imageList, Action callback = null)
        {
            Dictionary<string, string> newLoadOrderURL = new Dictionary<string, string>();
            List<KeyValuePair<string, ulong>> workshopDownloads = new List<KeyValuePair<string, ulong>>();

            foreach (KeyValuePair<string, ulong> image in imageList)
            {
                if (HasImage(image.Key, image.Value))                
                    continue;

                string identifier = $"{image.Key}_{image.Value}";

                if (imageUrls.URLs.ContainsKey(identifier) && !newLoadOrderURL.ContainsKey(identifier))
                {
                    newLoadOrderURL.Add(identifier, imageUrls.URLs[identifier]);
                }
                else
                {
                    workshopDownloads.Add(new KeyValuePair<string, ulong>(image.Key, image.Value));
                }
            }

            if (workshopDownloads.Count > 0)
            {
                QueueWorkshopDownload(title, newLoadOrderURL, workshopDownloads, 0, callback);
                return;
            }

            if (newLoadOrderURL.Count > 0)
            {
                loadOrders.Enqueue(new LoadOrder(title, newLoadOrderURL, null, false, callback));
                if (!orderPending)
                    ServerMgr.Instance.StartCoroutine(ProcessLoadOrders());
            }
            else
            {
                if (callback != null)
                    callback.Invoke();
            }
        }

        [HookMethod("RemoveImage")]
        public void RemoveImage(string imageName, ulong imageId)
        {
            if (!HasImage(imageName, imageId))
                return;

            uint crc = uint.Parse(GetImage(imageName, imageId));
            FileStorage.server.Remove(crc, FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID);
        }

        [HookMethod("SendImage")]
        public void SendImage(BasePlayer player, string imageName, ulong imageId = 0)
        {
            if (!HasImage(imageName, imageId) || player?.net?.connection == null)
                return;

            uint crc = uint.Parse(GetImage(imageName, imageId));
            byte[] array = FileStorage.server.Get(crc, FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID);

            if (array == null)
                return;

            CommunityEntity.ServerInstance.ClientRPCEx<uint, uint, byte[]>(new Network.SendInfo(player.net.connection)
            {
                channel = 2,
                method = Network.SendMethod.Reliable
            }, null, "CL_ReceiveFilePng", crc, (uint)array.Length, array);
        }
        #endregion API

        #region Steam API
        private List<ulong> BuildApprovedItemList()
        {
            List<ulong> list = new List<ulong>();

            foreach (InventoryDef item in Steamworks.SteamInventory.Definitions)
            {
                string shortname = item.GetProperty("itemshortname");
                ulong workshopid;

                if (item == null || string.IsNullOrEmpty(shortname))
                    continue;

                if (workshopNameToShortname.ContainsKey(shortname))
                    shortname = workshopNameToShortname[shortname];

                if (item.Id < 100)
                    continue;

                if (!ulong.TryParse(item.GetProperty("workshopid"), out workshopid))
                    continue;

                if (HasImage(shortname, workshopid))
                    continue;

                list.Add(workshopid);
            }

            return list;
        }

        private string BuildDetailsString(List<ulong> list, int page)
        {            
            int totalPages = Mathf.CeilToInt((float)list.Count / 100f);
            int index = page * 100;
            int limit = Mathf.Min((page + 1) * 100, list.Count);
            string details = string.Format("?key={0}&itemcount={1}", configData.SteamAPIKey, (limit - index));

            for (int i = index; i < limit; i++)            
                details += string.Format("&publishedfileids[{0}]={1}", i - index, list[i]);
            
            return details;
        }

        private string BuildDetailsString(List<ulong> list)
        {            
            string details = string.Format("?key={0}&itemcount={1}", configData.SteamAPIKey, list.Count);

            for (int i = 0; i < list.Count; i++)
                details += string.Format("&publishedfileids[{0}]={1}", i, list[i]);

            return details;
        }

        private bool IsValid(PublishedFileDetails item)
        {
            if (string.IsNullOrEmpty(item.preview_url))
                return false;

            if (item.tags == null)
                return false;

            return true;
        }

        private void GetItemSkins()
        {
            Steamworks.SteamInventory.OnDefinitionsUpdated -= GetItemSkins;

            PrintWarning("Retrieving item skin lists...");

            GetApprovedItemSkins(BuildApprovedItemList(), 0);
        }

        private void QueueFileQueryRequest(string details, Action<PublishedFileDetails[]> callback)
        {
            webrequest.Enqueue(STEAM_API_URL, details, (code, response) =>
            {
                try
                {
                    QueryResponse query = JsonConvert.DeserializeObject<QueryResponse>(response, errorHandling);
                    if (query == null || query.response == null || query.response.publishedfiledetails.Length == 0)
                    {
                        if (code != 200)
                            PrintError($"There was a error querying Steam for workshop item data : Code ({code})\n{details}");
                        return;
                    }
                    else
                    {
                        if (query?.response?.publishedfiledetails?.Length > 0)
                            callback.Invoke(query.response.publishedfiledetails);
                    }
                }
                catch { }
            }, this, Core.Libraries.RequestMethod.POST);
        }

        private void GetApprovedItemSkins(List<ulong> itemsToDownload, int page)
        {
            if (itemsToDownload.Count < 1)
            {
                Puts("Approved skins loaded");

                SaveUrls();
                SaveSkinInfo();

                if (!orderPending)
                    ServerMgr.Instance.StartCoroutine(ProcessLoadOrders());
                return;
            }

            int totalPages = Mathf.CeilToInt((float)itemsToDownload.Count / 100f) - 1;

            string details = BuildDetailsString(itemsToDownload, page);

            QueueFileQueryRequest(details, (PublishedFileDetails[] items) =>
            {
                ServerMgr.Instance.StartCoroutine(ProcessApprovedBlock(itemsToDownload, items, page, totalPages));
            });
        }

        private IEnumerator ProcessApprovedBlock(List<ulong> itemsToDownload, PublishedFileDetails[] items, int page, int totalPages)
        {
            PrintWarning($"Processing approved skins; Page {page + 1}/{totalPages + 1}");

            Dictionary<string, Dictionary<ulong, string>> loadOrder = new Dictionary<string, Dictionary<ulong, string>>();

            foreach (PublishedFileDetails item in items)
            {
                if (!IsValid(item))
                    continue;

                foreach (PublishedFileDetails.Tag tag in item.tags)
                {
                    if (string.IsNullOrEmpty(tag.tag))
                        continue;

                    ulong workshopid = Convert.ToUInt64(item.publishedfileid);

                    string adjTag = tag.tag.ToLower().Replace("skin", "").Replace(" ", "").Replace("-", "").Replace(".item", "");
                    if (workshopNameToShortname.ContainsKey(adjTag))
                    {
                        string shortname = workshopNameToShortname[adjTag];

                        string identifier = $"{shortname}_{workshopid}";

                        if (!imageUrls.URLs.ContainsKey(identifier))
                            imageUrls.URLs.Add(identifier, item.preview_url.Replace("https", "http"));

                        skinInformation.skinData[identifier] = new Dictionary<string, object>
                                {
                                    {"title", item.title },
                                    {"votesup", 0 },
                                    {"votesdown", 0 },
                                    {"description", item.file_description },
                                    {"score", 0 },
                                    {"views", 0 },
                                    {"created", new DateTime() },
                                };
                    }
                }
            }

            yield return CoroutineEx.waitForEndOfFrame;
            yield return CoroutineEx.waitForEndOfFrame;

            if (page < totalPages)
                GetApprovedItemSkins(itemsToDownload, page + 1);
            else
            {
                itemsToDownload.Clear();

                Puts("Approved skins loaded");

                SaveUrls();
                SaveSkinInfo();

                if (!orderPending)
                    ServerMgr.Instance.StartCoroutine(ProcessLoadOrders());
            }
        }

        private void QueueWorkshopDownload(string title, Dictionary<string, string> newLoadOrderURL, List<KeyValuePair<string, ulong>> workshopDownloads, int page = 0, Action callback = null)
        {
            int rangeMin = page * 100;
            int rangeMax = (page + 1) * 100;

            if (rangeMax > workshopDownloads.Count)
                rangeMax = workshopDownloads.Count;

            List<ulong> requestedSkins = workshopDownloads.GetRange(rangeMin, rangeMax - rangeMin).Select(x => x.Value).ToList();

            int totalPages = Mathf.CeilToInt((float)workshopDownloads.Count / 100f) - 1;

            string details = BuildDetailsString(requestedSkins);

            try
            {
                webrequest.Enqueue(STEAM_API_URL, details, (code, response) =>
                {
                    QueryResponse query = JsonConvert.DeserializeObject<QueryResponse>(response, errorHandling);
                    if (query == null || query.response == null || query.response.publishedfiledetails.Length == 0)
                    {
                        if (code != 200)
                            PrintError($"There was a error querying Steam for workshop item data : Code ({code})");

                        if (page < totalPages)
                            QueueWorkshopDownload(title, newLoadOrderURL, workshopDownloads, page + 1, callback);
                        else
                        {
                            if (newLoadOrderURL.Count > 0)
                            {
                                loadOrders.Enqueue(new LoadOrder(title, newLoadOrderURL, null, false, page < totalPages ? null : callback));
                                if (!orderPending)
                                    ServerMgr.Instance.StartCoroutine(ProcessLoadOrders());
                            }
                            else
                            {
                                if (callback != null)
                                    callback.Invoke();
                            }
                        }
                        return;
                    }
                    else
                    {
                        if (query.response.publishedfiledetails.Length > 0)
                        {
                            Dictionary<string, Dictionary<ulong, string>> loadOrder = new Dictionary<string, Dictionary<ulong, string>>();

                            foreach (PublishedFileDetails item in query.response.publishedfiledetails)
                            {
                                if (!string.IsNullOrEmpty(item.preview_url))
                                {
                                    ulong skinId = Convert.ToUInt64(item.publishedfileid);

                                    KeyValuePair<string, ulong>? kvp = workshopDownloads.Find(x => x.Value == skinId);

                                    if (kvp.HasValue)
                                    {
                                        string identifier = $"{kvp.Value.Key}_{kvp.Value.Value}";

                                        if (!newLoadOrderURL.ContainsKey(identifier))
                                            newLoadOrderURL.Add(identifier, item.preview_url);

                                        if (!imageUrls.URLs.ContainsKey(identifier))
                                            imageUrls.URLs.Add(identifier, item.preview_url);

                                        skinInformation.skinData[identifier] = new Dictionary<string, object>
                                        {
                                            {"title", item.title },
                                            {"votesup",  0 },
                                            {"votesdown", 0 },
                                            {"description", item.file_description },
                                            {"score", 0 },
                                            {"views", item.views },
                                            {"created", new DateTime(item.time_created) },
                                        };

                                        requestedSkins.Remove(skinId);
                                    }
                                }
                            }

                            SaveUrls();
                            SaveSkinInfo();

                            if (requestedSkins.Count != 0)
                            {
                                Puts($"{requestedSkins.Count} workshop skin ID's for image batch ({title}) are invalid! They may have been removed from the workshop\nIDs: {requestedSkins.ToSentence()}");
                            }
                        }

                        if (page < totalPages)
                            QueueWorkshopDownload(title, newLoadOrderURL, workshopDownloads, page + 1, callback);
                        else
                        {
                            if (newLoadOrderURL.Count > 0)
                            {
                                loadOrders.Enqueue(new LoadOrder(title, newLoadOrderURL, null, false, page < totalPages ? null : callback));
                                if (!orderPending)
                                    ServerMgr.Instance.StartCoroutine(ProcessLoadOrders());
                            }
                            else
                            {
                                if (callback != null)
                                    callback.Invoke();
                            }
                        }
                    }
                },
                this,
                Core.Libraries.RequestMethod.POST);
            }
            catch { }
        }

        #region JSON Response Classes
        public class QueryResponse
        {
            public Response response;
        }

        public class Response
        {
            public int total;
            public PublishedFileDetails[] publishedfiledetails;
        }

        public class PublishedFileDetails
        {
            public int result;
            public string publishedfileid;
            public string creator;
            public int creator_appid;
            public int consumer_appid;
            public int consumer_shortcutid;
            public string filename;
            public string file_size;
            public string preview_file_size;
            public string file_url;
            public string preview_url;
            public string url;
            public string hcontent_file;
            public string hcontent_preview;
            public string title;
            public string file_description;
            public int time_created;
            public int time_updated;
            public int visibility;
            public int flags;
            public bool workshop_file;
            public bool workshop_accepted;
            public bool show_subscribe_all;
            public int num_comments_public;
            public bool banned;
            public string ban_reason;
            public string banner;
            public bool can_be_deleted;
            public string app_name;
            public int file_type;
            public bool can_subscribe;
            public int subscriptions;
            public int favorited;
            public int followers;
            public int lifetime_subscriptions;
            public int lifetime_favorited;
            public int lifetime_followers;
            public string lifetime_playtime;
            public string lifetime_playtime_sessions;
            public int views;
            public int num_children;
            public int num_reports;
            public Preview[] previews;
            public Tag[] tags;
            public int language;
            public bool maybe_inappropriate_sex;
            public bool maybe_inappropriate_violence;

            public class Tag
            {
                public string tag;
                public bool adminonly;
            }

        }

        public class Preview
        {
            public string previewid;
            public int sortorder;
            public string url;
            public int size;
            public string filename;
            public int preview_type;
            public string youtubevideoid;
            public string external_reference;
        }
        #endregion
        #endregion

        #region Commands

        [ConsoleCommand("cancelstorage")]
        private void cmdCancelStorage(ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null || arg.Connection.authLevel > 0)
            {
                if (!orderPending)
                    PrintWarning("No images are currently being downloaded");
                else
                {
                    assets.ClearList();
                    loadOrders.Clear();
                    PrintWarning("Pending image downloads have been cancelled!");
                }
            }
        }

        private List<ulong> pendingAnswers = new List<ulong>();

        [ConsoleCommand("refreshallimages")]
        private void cmdRefreshAllImages(ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null || arg.Connection.authLevel > 0)
            {
                SendReply(arg, "Running this command will wipe all of your ImageLibrary data, meaning every registered image will need to be re-downloaded. Are you sure you wish to continue? (type yes or no)");

                ulong userId = arg.Connection == null || arg.IsRcon ? 0U : arg.Connection.userid;
                if (!pendingAnswers.Contains(userId))
                {
                    pendingAnswers.Add(userId);
                    timer.In(5, () =>
                    {
                        if (pendingAnswers.Contains(userId))
                            pendingAnswers.Remove(userId);
                    });
                }
            }
        }

        [ConsoleCommand("yes")]
        private void cmdRefreshAllImagesYes(ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null || arg.Connection.authLevel > 0)
            {
                ulong userId = arg.Connection == null || arg.IsRcon ? 0U : arg.Connection.userid;
                if (pendingAnswers.Contains(userId))
                {
                    PrintWarning("Wiping ImageLibrary data and redownloading ImageLibrary specific images. All plugins that have registered images via ImageLibrary will need to be re-loaded!");
                    RefreshImagery();

                    pendingAnswers.Remove(userId);
                }
            }
        }

        [ConsoleCommand("no")]
        private void cmdRefreshAllImagesNo(ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null || arg.Connection.authLevel > 0)
            {
                ulong userId = arg.Connection == null || arg.IsRcon ? 0U : arg.Connection.userid;

                if (pendingAnswers.Contains(userId))
                {
                    SendReply(arg, "ImageLibrary data wipe aborted!");
                    pendingAnswers.Remove(userId);
                }
            }
        }

        #endregion Commands

        #region Image Storage

        private struct LoadOrder
        {
            public string loadName;
            public bool loadSilent;

            public Dictionary<string, string> imageList;
            public Dictionary<string, byte[]> imageData;

            public Action callback;

            public LoadOrder(string loadName, Dictionary<string, string> imageList, bool loadSilent = false, Action callback = null)
            {
                this.loadName = loadName;
                this.imageList = imageList;
                this.imageData = null;
                this.loadSilent = loadSilent;
                this.callback = callback;
            }
            public LoadOrder(string loadName, Dictionary<string, byte[]> imageData, bool loadSilent = false, Action callback = null)
            {
                this.loadName = loadName;
                this.imageList = null;
                this.imageData = imageData;
                this.loadSilent = loadSilent;
                this.callback = callback;
            }
            public LoadOrder(string loadName, Dictionary<string, string> imageList, Dictionary<string, byte[]> imageData, bool loadSilent = false, Action callback = null)
            {
                this.loadName = loadName;
                this.imageList = imageList;
                this.imageData = imageData;
                this.loadSilent = loadSilent;
                this.callback = callback;
            }
        }

        private class ImageAssets : MonoBehaviour
        {
            private Queue<QueueItem> queueList = new Queue<QueueItem>();
            private bool isLoading;
            private double nextUpdate;
            private int listCount;
            private string request;

            private Action callback;

            private void OnDestroy()
            {
                queueList.Clear();
            }

            public void Add(string name, string url = null, byte[] bytes = null)
            {
                queueList.Enqueue(new QueueItem(name, url, bytes));
            }

            public void RegisterCallback(Action callback) => this.callback = callback;

            public void BeginLoad(string request)
            {
                this.request = request;
                nextUpdate = UnityEngine.Time.time + il.configData.UpdateInterval;
                listCount = queueList.Count;
                Next();
            }

            public void ClearList()
            {
                queueList.Clear();
                il.orderPending = false;
            }

            private void Next()
            {
                if (queueList.Count == 0)
                {
                    il.orderPending = false;
                    il.SaveData();
                    if (!string.IsNullOrEmpty(request))
                        print($"Image batch ({request}) has been stored successfully");

                    request = string.Empty;
                    listCount = 0;

                    if (callback != null)
                        callback.Invoke();

                    StartCoroutine(il.ProcessLoadOrders());
                    return;
                }
                if (il.configData.ShowProgress && listCount > 1)
                {
                    var time = UnityEngine.Time.time;
                    if (time > nextUpdate)
                    {
                        var amountDone = listCount - queueList.Count;
                        print($"{request} storage process at {Math.Round((amountDone / (float)listCount) * 100, 0)}% ({amountDone}/{listCount})");
                        nextUpdate = time + il.configData.UpdateInterval;
                    }
                }
                isLoading = true;

                QueueItem queueItem = queueList.Dequeue();
                if (!string.IsNullOrEmpty(queueItem.url))
                    StartCoroutine(DownloadImage(queueItem));
                else StoreByteArray(queueItem.bytes, queueItem.name);
            }

            private IEnumerator DownloadImage(QueueItem info)
            {
                UnityWebRequest www = UnityWebRequest.Get(info.url);

                yield return www.SendWebRequest();
                if (il == null) yield break;
                if (www.isNetworkError || www.isHttpError)
                {
                    print(string.Format("Image failed to download! Error: {0} - Image Name: {1} - Image URL: {2}", www.error, info.name, info.url));
                    www.Dispose();
                    isLoading = false;
                    Next();
                    yield break;
                }

                if (www?.downloadHandler?.data != null)
                {
                    Texture2D texture = new Texture2D(2, 2);
                    texture.LoadImage(www.downloadHandler.data);
                    if (texture != null)
                    {
                        bool shouldStore = true;
                        byte[] bytes = texture.EncodeToPNG();

                        if (bytes.Length > 3145728)
                        {
                            Debug.Log($"[ImageLibrary] Failed to store image data for image : {info.name} for equest {request}\nURL: {info.url}\n{bytes.Length} bytes is larger then the allowed transferable size of 3145728 bytes");
                            shouldStore = false;
                        }

                        DestroyImmediate(texture);

                        if (shouldStore)
                            StoreByteArray(bytes, info.name);
                    }
                }
                www.Dispose();
            }

            private void StoreByteArray(byte[] bytes, string name)
            {
                if (bytes != null)
                    il.imageIdentifiers.imageIds[name] = FileStorage.server.Store(bytes, FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID).ToString();
                isLoading = false;
                Next();
            }

            private class QueueItem
            {
                public byte[] bytes;
                public string url;
                public string name;
                public QueueItem(string name, string url = null, byte[] bytes = null)
                {
                    this.bytes = bytes;
                    this.url = url;
                    this.name = name;
                }
            }
        }

        #endregion Image Storage

        #region Config

        private ConfigData configData;

        class ConfigData
        {
            [JsonProperty(PropertyName = "Avatars - Store player avatars")]
            public bool StoreAvatars { get; set; }

            [JsonProperty(PropertyName = "Steam API key (get one here https://steamcommunity.com/dev/apikey)")]
            public string SteamAPIKey { get; set; }

            [JsonProperty(PropertyName = "URL to web folder containing all item icons")]
            public string ImageURL { get; set; }

            [JsonProperty(PropertyName = "Progress - Show download progress in console")]
            public bool ShowProgress { get; set; }

            [JsonProperty(PropertyName = "Progress - Time between update notifications")]
            public int UpdateInterval { get; set; }
            
            [JsonProperty(PropertyName = "User Images - Manually define images to be loaded")]
            public Dictionary<string, string> UserImages { get; set; }

            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();

            if (configData.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                ShowProgress = true,
                SteamAPIKey = string.Empty,
                StoreAvatars = false,
                UpdateInterval = 20,
                ImageURL = "https://www.rustedit.io/images/imagelibrary/",
                UserImages = new Dictionary<string, string>(),
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();

            if (configData.Version < new VersionNumber(2, 0, 47))
                configData = baseConfig;

            if (configData.Version < new VersionNumber(2, 0, 53))
                configData.StoreAvatars = false;

            if (configData.Version < new VersionNumber(2, 0, 55))
                configData.ImageURL = baseConfig.ImageURL;

            configData.Version = Version;
            PrintWarning("Config update completed!");
        }

        #endregion Config

        #region Data Management

        private void SaveData() => identifiers.WriteObject(imageIdentifiers);

        private void SaveSkinInfo() => skininfo.WriteObject(skinInformation);

        private void SaveUrls() => urls.WriteObject(imageUrls);

        private void LoadData()
        {
            try
            {
                imageIdentifiers = identifiers.ReadObject<ImageIdentifiers>();
            }
            catch
            {
                imageIdentifiers = new ImageIdentifiers();
            }
            try
            {
                skinInformation = skininfo.ReadObject<SkinInformation>();
            }
            catch
            {
                skinInformation = new SkinInformation();
            }
            try
            {
                imageUrls = urls.ReadObject<ImageURLs>();
            }
            catch
            {
                imageUrls = new ImageURLs();
            }
            if (skinInformation == null)
                skinInformation = new SkinInformation();
            if (imageIdentifiers == null)
                imageIdentifiers = new ImageIdentifiers();
            if (imageUrls == null)
                imageUrls = new ImageURLs();
        }

        private class ImageIdentifiers
        {
            public uint lastCEID;
            public Hash<string, string> imageIds = new Hash<string, string>();
        }

        private class SkinInformation
        {
            public Hash<string, Dictionary<string, object>> skinData = new Hash<string, Dictionary<string, object>>();
        }

        private class ImageURLs
        {
            public Hash<string, string> URLs = new Hash<string, string>();
        }


        public class AvatarRoot
        {
            public Response response { get; set; }

            public class Response
            {
                public Player[] players { get; set; }

                public class Player
                {
                    public string steamid { get; set; }
                    public int communityvisibilitystate { get; set; }
                    public int profilestate { get; set; }
                    public string personaname { get; set; }
                    public int lastlogoff { get; set; }
                    public string profileurl { get; set; }
                    public string avatar { get; set; }
                    public string avatarmedium { get; set; }
                    public string avatarfull { get; set; }
                    public int personastate { get; set; }
                    public string realname { get; set; }
                    public string primaryclanid { get; set; }
                    public int timecreated { get; set; }
                    public int personastateflags { get; set; }
                }
            }
        }
        #endregion Data Management
    }
}


// --- End of file: ImageLibrary.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HudRust/OreBonus.cs ---
// --- Original Local Path: HudRust/OreBonus.cs ---

﻿using Newtonsoft.Json;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("OreBonus", "DezLife", "3.5.0")]
    [Description("Добавляет новую руду в камни")]
    public class OreBonus : RustPlugin
    {
        public static OreBonus instance;
        public Dictionary<ulong, string> ToOres = new Dictionary<ulong, string>();
        bool furnacec = false;

        #region CFG
        public class CustomItem
        {
            [JsonProperty("Отображаемое имя")]
            public string DisplayName;
            [JsonProperty("Название предмета который он будет заменять")]
            public string ReplaceShortName;
            [JsonProperty("Что он получит после переплавки")]
            public string Shortnames;
            [JsonProperty("Количевство радиации каторое будет даваться каждый тик")]
            public float Radiations;
            [JsonProperty("Радиус радиации в метрах (От печки)")]
            public float RadiationsRadius;
            [JsonProperty("Минимальное выпадения переплавленой руды в печках")]
            public int mincount;
            [JsonProperty("Максимальное выпадения переплавленой руды в печках")]
            public int maxcount;
            [JsonProperty("Включить выпадения этой руды?")]
            public bool OreBool;


            [JsonProperty("Шанс выпадения")]
            public int DropChance;
            [JsonProperty("Максимальное количевство выпадения радиактивной руды")]
            public int DropAmount;

            [JsonProperty("Скин ID предмета")]
            public ulong ReplaceID;

            public int GetItemId() => ItemManager.FindItemDefinition(ReplaceShortName).itemid;
            public int GetItemAmount(BasePlayer player) => player.inventory.GetAmount(GetItemId());

            public Item Copy(int amount )
            {
                Item x = ItemManager.CreateByPartialName(ReplaceShortName, amount);
                x.skin = ReplaceID;
                x.name = DisplayName;

                return x;
            }

            public void CreateItem(BasePlayer player, int amount)
            {
                Item x = ItemManager.CreateByPartialName(ReplaceShortName, amount);
                x.skin = ReplaceID;
                x.name = DisplayName;

                if (player != null)
                {
                    if (player.inventory.containerMain.itemList.Count < 24)
                        x.MoveToContainer(player.inventory.containerMain);
                    else
                        x.Drop(player.transform.position, Vector3.zero);
                    return;
                }
            }
        }

       

        private class Configuration
        {
            [JsonProperty("Настройка руды")]
            public Dictionary<string, CustomItem> CustomItems = new Dictionary<string, CustomItem>
            {
                ["sulfur.ore"] = new CustomItem
                {
                    DisplayName = "Радиактивная сера",
                    ReplaceShortName = "glue",
                    Shortnames = "sulfur",
                    DropChance = 7,
                    DropAmount = 2,
                    ReplaceID = 1989987965,
                    Radiations = 10f,
                    RadiationsRadius = 15f,
                    mincount = 100,
                    maxcount = 1000,
                    OreBool = true
                },
                ["metal.ore"] = new CustomItem
                {
                    DisplayName = "Радиактивный металл",
                    ReplaceShortName = "ducttape",
                    Shortnames = "metal.fragments",
                    DropChance = 11,
                    DropAmount = 3,
                    ReplaceID = 1989988490,
                    Radiations = 10f,
                    RadiationsRadius = 10f,
                    mincount = 300,
                    maxcount = 1500,
                    OreBool = true
                },
                ["stones"] = new CustomItem
                {
                    DisplayName = "Радиактивный камень",
                    ReplaceShortName = "bleach",
                    Shortnames = "stones",
                    DropChance = 14,
                    DropAmount = 4,
                    ReplaceID = 1989988784,
                    Radiations = 10f,
                    RadiationsRadius = 10f,
                    mincount = 500,
                    maxcount = 2500,
                    OreBool = true
                },
                ["hq.metal.ore"] = new CustomItem
                {
                    DisplayName = "Радиактивный мвк",
                    ReplaceShortName = "bleach",
                    Shortnames = "metal.refined",
                    DropChance = 5,
                    DropAmount = 2,
                    ReplaceID = 2019140142,
                    Radiations = 20,
                    RadiationsRadius = 15f,
                    mincount = 500,
                    maxcount = 2500,
                    OreBool = true
                },
            };
        }

        private static Configuration Settings = new Configuration();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                Settings = Config.ReadObject<Configuration>();
                if (Settings?.CustomItems == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning("Ошибка #436 чтения конфигурации 'oxide/config/', создаём новую конфигурацию!");
                LoadDefaultConfig();
            }
            
            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => Settings = new Configuration();
        protected override void SaveConfig() => Config.WriteObject(Settings);
        #endregion

        #region Hooks

        [ChatCommand("ore.give")]
        void CmdChatDebugOreSpawn(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin) return;

            foreach (var check in Settings.CustomItems)
            {
                var item = check.Value.Copy(100);
                item.MoveToContainer(player.inventory.containerMain);
            }
        }
        void OnServerInitialized()
        {
            instance = this;
            furnacec = true;
            foreach (var skkinid in Settings.CustomItems)
            {
                ToOres.Add(skkinid.Value.ReplaceID, skkinid.Key);
            }

            List<BaseOven> baseOvens = UnityEngine.Object.FindObjectsOfType<BaseOven>().ToList();
            baseOvens.ForEach(baseOven =>
            {
                if (!(baseOven is BaseFuelLightSource))
                {
                    OnEntitySpawned(baseOven);
                }
            });
        }

        void OnEntitySpawned(BaseNetworkable entity)
        {
            if (!furnacec) return;
            if (entity == null) return;
            if (entity is BaseOven && !(entity is BaseFuelLightSource))
            {
                BaseOven baseOven = entity as BaseOven;
                if (baseOven == null) return;
                FurnaceBurn fBurn = new FurnaceBurn();
                fBurn.OvenTogle(baseOven);
            }
        }
        object OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            if (player == null) return null;
            if (Settings.CustomItems.ContainsKey(item.info.shortname))
            {
                if (!Settings.CustomItems[item.info.shortname].OreBool) return null;
                var items = Settings.CustomItems[item.info.shortname];
                bool goodChance = UnityEngine.Random.Range(0, 100) >= (100 - items.DropChance);   
                if (goodChance)
                {
                    Item RadSulfur = ItemManager.CreateByName(items.ReplaceShortName, UnityEngine.Random.Range(1, items.DropAmount), items.ReplaceID);
                    RadSulfur.name = items.DisplayName;
                    player?.GiveItem(RadSulfur);
                }
            }
            return null;
        }  

        object CanCombineDroppedItem(DroppedItem item, DroppedItem targetItem)
        {
            if (item.GetItem().skin != targetItem.GetItem().skin) return false;
            return null;
        }

        object CanStackItem(Item item, Item targetItem)
        {
            if (item.skin != targetItem.skin) return false;
            return null;
        }
        
        private Item OnItemSplit(Item item, int amount)
        {
            if (plugins.Find("Stacks") || plugins.Find("CustomSkinsStacksFix") || plugins.Find("SkinBox")) return null;

            var customItem = Settings.CustomItems.FirstOrDefault(p => p.Value.DisplayName == item.name);
            if (customItem.Value != null && customItem.Value.ReplaceID == item.skin)
            {
                Item x = ItemManager.CreateByPartialName(customItem.Value.ReplaceShortName, amount);
                x.name = customItem.Value.DisplayName;
                x.skin = customItem.Value.ReplaceID;
                x.amount = amount;

                item.amount -= amount;
                return x;
            }

            return null;
        }

        #endregion

        #region Metod
        public class FurnaceBurn
        {
            BaseOven oven;
            StorageContainer storageContainer;
            Timer timer;

            public void OvenTogle(BaseOven oven)
            {
                this.oven = oven;
                storageContainer = oven.GetComponent<StorageContainer>();
                timertick();
            }

            void timertick()
            {
                if (timer == null)
                {
                    timer = instance.timer.Once(5f, CheckRadOres);
                }
                else
                {
                    timer.Destroy();
                    timer = instance.timer.Once(5f, CheckRadOres);
                }
            }

            void CheckRadOres()
            {
                if (oven == null)
                {
                    timer.Destroy();
                    return;
                }
                if (oven.IsOn())
                {
                    foreach (var item in storageContainer.inventory.itemList)
                    {
                        if (instance.ToOres.ContainsKey(item.skin))
                        {
                            instance.NextTick(() =>
                            {
                                List<BasePlayer> players = new List<BasePlayer>();
                                Vis.Entities<BasePlayer>(oven.transform.position, Settings.CustomItems[instance.ToOres[item.skin]].RadiationsRadius, players);
                                players.ForEach(p => p.metabolism.radiation_poison.value += Settings.CustomItems[instance.ToOres[item.skin]].Radiations);

                                if (item.amount > 1) item.amount--;
                                else item.RemoveFromContainer();

                                Item newItem = ItemManager.CreateByName(Settings.CustomItems[instance.ToOres[item.skin]].Shortnames, UnityEngine.Random.Range(Settings.CustomItems[instance.ToOres[item.skin]].mincount, Settings.CustomItems[instance.ToOres[item.skin]].maxcount));
                                if (!newItem.MoveToContainer(storageContainer.inventory))
                                {
                                    newItem.Drop(oven.transform.position, Vector3.up);
                                }
                            });
                        }
                    }
                }
                timertick();
            }
        }
        #endregion
    }
}

// --- End of file: OreBonus.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HudRust/DVMenu.cs ---
// --- Original Local Path: HudRust/DVMenu.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("DVMenu", "ClayMond", "0.0.5")]
    [Description("Спасибо за покупку - by russia-oxide.ru")]
    class DVMenu : RustPlugin
    {
        #region Reference
        [PluginReference] Plugin ImageLibrary;
        private string GetImage(string fileName, ulong skin = 0)
        {
            var imageId = (string)plugins.Find("ImageLibrary").CallHook("GetImage", fileName, skin);
            if (!string.IsNullOrEmpty(imageId))
                return imageId;
            return string.Empty;
        }
        public bool AddImage(string url, string shortname, ulong skin = 0) => (bool)ImageLibrary?.Call("AddImage", url, shortname, skin);

        #endregion

        #region Vars
        public List<BasePlayer> IsOpenMenu = new List<BasePlayer>();
        public List<string> ActiveEvent = new List<string>();
        #endregion

        #region Configuration


        private static Configuration config = new Configuration();
        private class Configuration
        {
            [JsonProperty("Настройки плагина")]
            public SettingsPlugin SettingPlugin = new SettingsPlugin();

            internal class SettingsPlugin
            {
                [JsonProperty("Настройка иконки в панели")]
                public string PNG;
                [JsonProperty("Настройка логотипа в панели")]
                public string Logo;
                [JsonProperty("Командая при нажатие на логотип")]
                public string Bind;
                [JsonProperty("HEX Цвет панели")]
                public string HexColorPanel;
				[JsonProperty("HEX Цвет текста панели")]
				public string TextColorPanel;
                [JsonProperty("Интервал обновления информационной панели")]
                public int IntervalUpdateInfoPanel;
                [JsonProperty("Интервал обновления ивентов")]
                public int IntervalUpdateEvents;

            }

            public static Configuration GetNewConfiguration()
            {
                return new Configuration
                {
                    SettingPlugin = new SettingsPlugin
                    {
                        HexColorPanel = "#FFFFFF",
						TextColorPanel = "#FFFFFF",
                        IntervalUpdateInfoPanel = 5,
                        IntervalUpdateEvents = 5,
						Bind = "chat.say /info",
						Logo = "https://i.ibb.co/6Fzdntv/wolf.png",
                        PNG = "https://i.ibb.co/D74C9sZ/PHTlu4K.png",
                    }
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
            }
            catch
            {
                LoadDefaultConfig();
            }
            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewConfiguration();
        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion

        #region UI

        #region Parent
        public static string INTERFACE_PARENT_PANEL = "INTERFACE_MENU_PARENT_PANEL";
		public static string LOGO_PANEL = "LOGO_PANEL";
        #endregion

        void OnPlayerConnected(BasePlayer player)
        {
            UI_Panel_Interface(player);
			LOGO_UI(player);
        }


        void UI_Panel_Interface(BasePlayer player)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, INTERFACE_PARENT_PANEL);
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = "-200 -50", OffsetMax = "-3 -3" },
                Image = { Color = "0 0 0 0" }
            }, "Hud", INTERFACE_PARENT_PANEL);

            container.Add(new CuiElement
            {
                Parent = INTERFACE_PARENT_PANEL,
                Name = "Joined",
                Components = {
                        new CuiImageComponent {
                            Png = GetImage("PNG_PANEL"),
                            Color = HexToRustFormat(config.SettingPlugin.HexColorPanel),
							
                        },
                        new CuiRectTransformComponent { AnchorMin = "0.7700684 0.07777759", AnchorMax = "0.9768711 0.922222" }
                    },
            });

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1.1" },
                Text = { Text = $"<size=9>ЗАХОДЯТ</size>\n<size=16>{SingletonComponent<ServerMgr>.Instance.connectionQueue.Joining}</size>", Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter, Color = HexToRustFormat(config.SettingPlugin.TextColorPanel) }
            }, "Joined");

            container.Add(new CuiElement
            {
                Parent = INTERFACE_PARENT_PANEL,
                Name = "Sleepers",
                Components = {
                        new CuiImageComponent {
                            Png = GetImage("PNG_PANEL"),
							Color = HexToRustFormat(config.SettingPlugin.HexColorPanel),
                        },
                        new CuiRectTransformComponent { AnchorMin = "0.5390563 0.07777759", AnchorMax = "0.745859 0.922222" }
                    },
            });

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1.1" },
                Text = { Text = $"<size=9>СПЯЩИЕ</size>\n<size=16>{BasePlayer.sleepingPlayerList.Count.ToString()}</size>", Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter, Color = HexToRustFormat(config.SettingPlugin.TextColorPanel) }
            }, "Sleepers");

            container.Add(new CuiElement
            {
                Parent = INTERFACE_PARENT_PANEL,
                Name = "Online",
                Components = {
                        new CuiImageComponent {
                            Png = GetImage("PNG_PANEL"),
							Color = HexToRustFormat(config.SettingPlugin.HexColorPanel),
                        },
                        new CuiRectTransformComponent { AnchorMin = "0.3074842 0.07777759", AnchorMax = "0.514289 0.922222" }
                    },
            });

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1.1" },
                Text = { Text = $"<size=9>ОНЛАЙН</size>\n<size=16>{BasePlayer.activePlayerList.Count.ToString()}</size>", Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter, Color = HexToRustFormat(config.SettingPlugin.TextColorPanel) }
            }, "Online");

            CuiHelper.AddUi(player, container);
        }

 		void LOGO_UI(BasePlayer player)
		{
            CuiElementContainer container = new CuiElementContainer();
			CuiHelper.DestroyUi(player, LOGO_PANEL);
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "10 -77", OffsetMax = "80 -8" },
                Image = { Color = "0 0 0 0" }
            }, "Overlay", LOGO_PANEL);
			
            container.Add(new CuiElement
            {
                Parent = LOGO_PANEL,
                Name = "LogoURL",
                Components = {
                        new CuiImageComponent {
                            Png = GetImage("LOGO_PANEL"),
							Color = "1 1 1 1",
							Material = "assets/icons/greyout.mat",
                        },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1.1" }
                    },
            });
			
			container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Command = config.SettingPlugin.Bind },
                Text = { Text = "" }
            }, LOGO_PANEL);
			
			CuiHelper.AddUi(player, container);
		}
 
        #endregion


        #region Hooks
        private void OnServerInitialized()
        {
			
			Puts("Спасибо за покупку плагина");
			Puts("Thank you for purchasing the plugin");
			
            LoadImage();

            timer.Every(config.SettingPlugin.IntervalUpdateInfoPanel, () =>
            {
				foreach(var player in BasePlayer.activePlayerList)
				    LOGO_UI(player);
            });

            timer.Every(config.SettingPlugin.IntervalUpdateInfoPanel, () =>
            {
				foreach(var player in BasePlayer.activePlayerList)
				    UI_Panel_Interface(player);
            });
            
			foreach(var player in BasePlayer.activePlayerList)
                OnPlayerConnected(player);
        } 

        #endregion

        #region HelpMetods
        private static string HexToRustFormat(string hex)
        {
            UnityEngine.Color color;
            ColorUtility.TryParseHtmlString(hex, out color);
            return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
        }

        void LoadImage()
        {

            AddImage(config.SettingPlugin.PNG, "PNG_PANEL");
			AddImage(config.SettingPlugin.Logo, "LOGO_PANEL");
        }

        #endregion
    }
}


// --- End of file: DVMenu.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HudRust/SkinBox.cs ---
// --- Original Local Path: HudRust/SkinBox.cs ---

using System;
using System.Collections.Generic;
using System.Collections;
using System.Linq;
using UnityEngine;
using Rust;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using Newtonsoft.Json;
using Newtonsoft.Json.Serialization;
using Oxide.Game.Rust.Cui;

namespace Oxide.Plugins 
{
	/* Based on 1.0.0 version by MarinWebCode */
    [Info("SkinBox", "MarinWebCode", "1.0.0")]
    class SkinBox : RustPlugin 
    {
		private static SkinBox instance;
		
        private bool skinsLoaded;        
        private static SkinBox skinBox = null;
        private bool isValidated = false;        
		
        private static Dictionary<string, LinkedList<ulong>> skinsCache = new Dictionary<string, LinkedList<ulong>>();        
        private static Dictionary<string, int> approvedSkinsCount = new Dictionary<string, int>();        
        private static Dictionary<string, DateTime> cooldownTimes = new Dictionary<string, DateTime>();
        private static Dictionary<string, string> NameToItemName = new Dictionary<string, string>();
        private static Dictionary<string, string> ItemNameToName = new Dictionary<string, string>();        
        private static List<ulong> excludedSkins = new List<ulong>();
		private static Dictionary <string, List<ulong>> manualAddedSkins = new Dictionary <string, List<ulong>>();
        private static List<object> excludedSkinsPre = new List<object>();
        private static Dictionary <ulong, Vector3> activeBoxUsers = new Dictionary <ulong, Vector3>();		
        		
        Coroutine _validateManualSkins;
        Coroutine _validateExcludedSkins;        
		
        private static Dictionary<string, object> missingWorkshopNames() 
        {
            var dp = new Dictionary<string, object>();
            dp.Add("rug", "Rug");
            dp.Add("chair", "Chair");
            dp.Add("rug.bear", "Bearskin Rug");
            dp.Add("mask.bandana", "Bandana");
            dp.Add("table", "Table");
            dp.Add("fridge", "Fridge");
            return dp;
        }        		      		                                     
        
        protected override void LoadDefaultMessages() 
        {
            lang.RegisterMessages(new Dictionary<string, string> 
            {                
                {"NoPermission", "Недостаточно прав!"},                 
                {"CooldownTime", "Что бы повторно поменять скины, вам нужно подождать {0} секунд."}                
            },this);
        }
        
        private void Init()
        {
            LoadVariables();
            LoadDefaultMessages();
			
            cmd.AddChatCommand("skin", this, "cmdSkinBox");
			cmd.AddChatCommand("skins", this, "cmdSkinBox");
			cmd.AddChatCommand("skinbox", this, "cmdSkinBox");
			
			foreach(var permissionUse in configData.permissionsUse)
				if (!permission.PermissionExists(permissionUse)) 
					permission.RegisterPermission(permissionUse, this);                                               
				
            skinsCache = new Dictionary<string, LinkedList<ulong>>();            
            approvedSkinsCount = new Dictionary<string, int>();
            NameToItemName = new Dictionary<string, string>();
            ItemNameToName = new Dictionary<string, string>();            
            activeBoxUsers = new Dictionary <ulong, Vector3>();
            skinsLoaded = false;
            skinBox = this;
        }
        
        private void OnServerInitialized() 
        {
			instance = this;
            UnsubscribeAll();
            timer.Once(65f, ()=> OnServerInit());			
        }
        
        private void Unload() 
        {
            var objs = UnityEngine.Object.FindObjectsOfType<SkinBoxHandler>().ToList();
            if (objs.Count > 0) 
				foreach (var obj in objs) 
				{
					if (obj.looter == null) continue;
					obj.looter.EndLooting();
					obj.PlayerStoppedLooting(obj.looter);
					GameObject.Destroy(obj);
				}
				
			foreach (BasePlayer player in BasePlayer.activePlayerList)				
				CuiHelper.DestroyUi(player, "Buttons");			
            
            if (Interface.Oxide.IsShuttingDown) return;
			
            if (_validateManualSkins != null) ServerMgr.Instance.StopCoroutine(_validateManualSkins);
            if (_validateExcludedSkins != null) ServerMgr.Instance.StopCoroutine(_validateExcludedSkins);            
        }
        
        private void OnServerInit() 
        {
            foreach (var itemtype in Rust.Workshop.Approved.All.Select(x=> x.Value).ToList()) 
            {
                if (itemtype.Skinnable.Name == null || itemtype.Skinnable.Name == string.Empty) continue;
                if (itemtype.Skinnable.ItemName == null || itemtype.Skinnable.ItemName == string.Empty) continue;
                if (!NameToItemName.ContainsKey(itemtype.Skinnable.Name.ToLower())) NameToItemName.Add(itemtype.Skinnable.Name.ToLower(), itemtype.Skinnable.ItemName.ToLower());
                if (!ItemNameToName.ContainsKey(itemtype.Skinnable.ItemName.ToLower()))                 
                    ItemNameToName.Add(itemtype.Skinnable.ItemName.ToLower(), itemtype.Skinnable.Name.ToLower());                                                
            }
            
            var tempMissing = new Dictionary<string, object>(configData.missingSkinNames);            
			tempMissing["rifle.lr300"] = "Lr300";
            foreach (var skin in tempMissing) 
            {
                var itemname = skin.Key.ToLower();
                var itemDef = ItemManager.FindItemDefinition(itemname);
                if (itemDef == null) continue;
                var workshopname = ((string)skin.Value).ToLower();
                NameToItemName[workshopname] = itemname;
                ItemNameToName[itemname] = workshopname;
            }
            
            foreach (var manual in configData.manualAddedSkinsPre) manualAddedSkins.Add(manual.Key.ToString(), (manual.Value as List<ulong>).ConvertAll(obj => Convert.ToUInt64(obj)));
            excludedSkins = configData.excludedSkinsPre.ConvertAll(obj => Convert.ToUInt64(obj));
            _validateManualSkins = ServerMgr.Instance.StartCoroutine(ValidateManualSkins(new Dictionary <string, List<ulong>>(manualAddedSkins), done => 
            {
                int result1 = manualAddedSkins.Values.Sum(list => list.Count);
                int result2 = done.Values.Sum(list => list.Count);
                if (result1 != result2) 
                {
                    manualAddedSkins = new Dictionary <string, List<ulong>>(done);
                    configData.manualAddedSkinsPre = manualAddedSkins;
                    SaveConfig(configData);
                }
                
                _validateExcludedSkins = ServerMgr.Instance.StartCoroutine(ValidateExcludedSkins(new List<ulong>(excludedSkins), done2 => 
                {
                    if (excludedSkins.Count != done2.Count) 
                    {
                        excludedSkins = new List<ulong>(done2);
                        configData.excludedSkinsPre = excludedSkins;
                        SaveConfig();
                    }
                    
                    _validateExcludedSkins = null;
                    isValidated = true;
                    GetItemSkins();
                }
                
                ));
                _validateManualSkins = null;
            }));
        }
        
        private IEnumerator ValidateManualSkins(Dictionary <string, List<ulong>> skinDict, System.Action<Dictionary <string, List<ulong>>> done) 
        {
            done(skinDict);
            yield return done;
        }
        
        private IEnumerator ValidateExcludedSkins(List<ulong> skinList, System.Action<List<ulong>> done) 
        {            
            done(skinList);
            yield return done;
        }
        
		private static string GetFixedItemName(string name) => name == "lr300.item" ? "rifle.lr300" : name;
		
        private void GetItemSkins() 
        {
            if (skinsLoaded) return;
            int countInbuilt = 0;
            foreach (var itemDef in ItemManager.GetItemDefinitions()) 
            {
                List<ulong> skins = new List<ulong>{0};
                skins.AddRange(ItemSkinDirectory.ForItem(itemDef).Select(skin => Convert.ToUInt64(skin.id)));
                skinsCache.Add(GetFixedItemName(itemDef.shortname), new LinkedList<ulong>(skins));
                if (skins.Count > 1) countInbuilt += (skins.Count -1);
            }
            
            if (configData.showLoadedSkinCounts) Puts($"Загружено {countInbuilt} встроенных скинов.");
            if (configData.useManualAddedSkins) 
            {
                int countManual = 0;
                foreach (var manualskins in manualAddedSkins) 
                {
                    string shortname = GetFixedItemName(manualskins.Key);
                    if (!ItemNameToName.ContainsKey(shortname)) continue;
                    string itemname = ItemNameToName[shortname];
                    List<ulong> fileids = manualskins.Value;
                    foreach (var fileid in fileids) 
                    {
                        if (!skinsCache.ContainsKey(shortname)) 
                        {
                            skinsCache.Add(shortname, new LinkedList<ulong>());
                            skinsCache[shortname].AddLast(0);
                        }
                        
                        if (!skinsCache[shortname].Contains(fileid)) 
                        {
                            skinsCache[shortname].AddLast(fileid);
                            countManual++;
                        }                                                
                    }                                        
                }
                
                if (configData.showLoadedSkinCounts && countManual > 0) Puts($"Загружено {countManual} скинов, добавленных вручную.");
            }
                        
			int countApproved = 0;
			foreach (var shopskin in Rust.Workshop.Approved.All.Select(x=> x.Value).Where(skin => skin.Skinnable.ItemName != null)) 
			{
				var skinName = GetFixedItemName(shopskin.Skinnable.ItemName);
				if (!approvedSkinsCount.ContainsKey(skinName)) approvedSkinsCount[skinName] = 0;                                       
				if (!skinsCache.ContainsKey(skinName)) skinsCache[skinName] = new LinkedList<ulong>();
				if (!skinsCache[skinName].Contains(shopskin.WorkshopdId)) 
				{
					skinsCache[skinName].AddLast(shopskin.WorkshopdId);
					approvedSkinsCount[skinName]++;
					countApproved++;
				}                                        
			}
			
			if (configData.showLoadedSkinCounts) Puts($"Загружено {countApproved} одобренных скинов.");
                        
			Interface.CallHook("OnSkinCacheUpdate", skinsCache, true);
			skinsLoaded = true;            
        }                
                
		[ConsoleCommand("skins.open")] 
		private void consoleSkinsOpen(ConsoleSystem.Arg arg) => consoleSkinboxOpen(arg);
				
        [ConsoleCommand("skinbox.open")] 
		private void consoleSkinboxOpen(ConsoleSystem.Arg arg) 
        {
            if (arg == null) return;
            if (arg.Connection == null) 
            {
				if (!skinsLoaded)
				{
					SendReply(arg, "Подождите, идет инициализация плагина.");
                    return;
				}
				
                if  (arg.Args == null || arg.Args.Length == 0) 
                {
                    SendReply(arg, $"Команда 'skinbox.open' требует наличия SteamId в качестве параметра.");
                    return;
                }
                
                ulong argId = 0uL;
                if (!ulong.TryParse(arg.Args[0], out argId)) 
                {
                    SendReply(arg, $"Указан некорректный SteamId: '{arg.Args[0]}'.");
                    return;
                }
                
                BasePlayer argPlayer = BasePlayer.FindByID(argId);
                if (argPlayer == null) 
                {
                    SendReply(arg, $"Не найден указанный игрок: '{argId}'.");
                    return;
                }
                
                if (!argPlayer.inventory.loot.IsLooting()) OpenSkinBox(argPlayer);
            }            
            else if(arg.Connection != null && arg.Connection.player != null) 
            {
                BasePlayer player = arg.Player();
                if (player.inventory.loot.IsLooting()) return;
				
                if (!HasPermission(player)) 
                {
                    player.ChatMessage(lang.GetMessage("NoPermission", this, player.UserIDString));
                    return;
                }
				
				if (!skinsLoaded)
				{
					player.ChatMessage("Подождите, идет инициализация плагина.");
                    return;
				}
                                
                if (configData.enableCooldown && !player.IsAdmin)
                {
                    DateTime now = DateTime.UtcNow;
                    DateTime time;
                    var key = player.UserIDString + "-box";
                    if (cooldownTimes.TryGetValue(key, out time)) 
                    {
                        if (time > now.AddSeconds(-configData.cooldownBox)) 
                        {
                            player.ChatMessage(string.Format(lang.GetMessage("CooldownTime", this, player.UserIDString),(time - now.AddSeconds(-configData.cooldownBox)).Seconds));
                            return;
                        }                                                
                    }                                        
                }
                
                OpenSkinBox(player);
            }                        
        }
        
        private void cmdSkinBox(BasePlayer player, string command, string[] args) 
        {
            if (player.inventory.loot.IsLooting()) return;
            if (!HasPermission(player))
            {
                player.ChatMessage(lang.GetMessage("NoPermission", this, player.UserIDString));
                return;
            }
			
			if (!skinsLoaded)
			{
				player.ChatMessage("Подождите, идет инициализация плагина.");
				return;
			}
                        
            if (configData.enableCooldown && !player.IsAdmin) 
            {
                DateTime now = DateTime.UtcNow;
                DateTime time;
                var key = player.UserIDString + "-box";
                if (cooldownTimes.TryGetValue(key, out time)) 
                {
                    if (time > now.AddSeconds(-configData.cooldownBox)) 
                    {
                        player.ChatMessage(string.Format(lang.GetMessage("CooldownTime", this, player.UserIDString),(time - now.AddSeconds(-configData.cooldownBox)).Seconds));
                        return;
                    }                                        
                }                                
            }
            
            timer.Once(0.2f, () => 
            {
                OpenSkinBox(player);
            });
        }      

		private bool HasPermission(BasePlayer player) 
		{
			if (player.IsAdmin)
				return true;
			
			foreach(var permissionName in configData.permissionsUse)
				if (!string.IsNullOrEmpty(permissionName) && permission.UserHasPermission(player.UserIDString, permissionName))
					return true;
			
			return false;
		}	
        
        private sealed class SkinBoxHandler : MonoBehaviour 
        {
            public bool isCreating;
            public bool isBlocked;
            public bool isCleaning;
            public bool isEmptied;
			public bool isPaging;
            public int itemId;
            public Item item;
            public BasePlayer looter;
            public ItemContainer otherLoot;
			public ItemContainer showLoot;
            public BaseEntity entityOwner;
            public ulong skinId;
			public int page;
			public float lastOpen;
			
			public static List<SkinBoxHandler> SkinBoxes = new List<SkinBoxHandler>();
			
            void Awake() 
            {
                isCreating = false;
                isBlocked = false;
                isCleaning = false;
                isEmptied = false;
				isPaging = false;
                showLoot = GetComponent<DroppedItemContainer>().inventory;
                entityOwner = showLoot.entityOwner;
				page = 1;
				otherLoot = new ItemContainer();
				otherLoot.ServerInitialize(null, 1000);
				otherLoot.GiveUID();
				lastOpen = UnityEngine.Time.realtimeSinceStartup;				
				try { SkinBoxes.RemoveAll(x=> x == null); } catch {}
				SkinBoxes.Add(this);
            }
            
            public void PlayerStoppedLooting(BasePlayer player) 
            {				
                activeBoxUsers.Remove(player.userID);
                if (!isEmptied && item != null) 
                {
                    isEmptied = true;
                    player.GiveItem(item);
                }
				ClearContainer(otherLoot);
				CuiHelper.DestroyUi(looter, "Buttons");		
                if (activeBoxUsers.Count() == 0 && !Interface.Oxide.IsShuttingDown) skinBox.UnsubscribeAll();
                if (!GetComponent<BaseEntity>().IsDestroyed) GetComponent<BaseEntity>().Kill(BaseNetworkable.DestroyMode.None);
                if (configData.enableCooldown) cooldownTimes[player.UserIDString + "-box"] = DateTime.UtcNow;
            }
            
            void OnDestroy() 
            {											
                activeBoxUsers.Remove(looter.userID);
                if (!isEmptied && item!= null) 
                {
                    isEmptied = true;
                    looter.GiveItem(item);
                }				
				ClearContainer(otherLoot);
				CuiHelper.DestroyUi(looter, "Buttons");		
                looter.EndLooting();
				
				if (entityOwner != null)
					GameObject.Destroy(entityOwner);
				
				/*if ((UnityEngine.Time.realtimeSinceStartup - lastOpen) <= 0.5f)
				{
					if (looter != null)
						instance.OpenSkinBox(looter);
				}*/
            }                        
        }                
        
        private void OpenSkinBox(BasePlayer player) 
        {
			if (player == null) return;
			
			var ret = Interface.CallHook("SkinsCanUseSkins", player) as object;
			if (ret != null)
			{
				if (ret is string)
					SendReply(player, (string)ret);
				return;
			}

            if (activeBoxUsers.Count() == 0) SubscribeAll();
            			
			var skinBox = GameManager.server.CreateEntity("assets/prefabs/misc/item drop/item_drop_backpack.prefab", new Vector3(player.transform.position.x, -60f + UnityEngine.Random.Range(-4f, 4f), player.transform.position.z));
			
            var drop = skinBox as DroppedItemContainer;
			drop.playerName = configData.skinBoxTitle;	
			drop.playerSteamID = player.userID;			
			
			drop.Spawn();
														
			drop.inventory = new ItemContainer();
            drop.inventory.ServerInitialize(null, 36);
			drop.inventory.entityOwner = drop;
            drop.inventory.GiveUID();
			
			Rigidbody rigidBody = drop.GetComponent<Rigidbody>();
			rigidBody.useGravity = false;
			rigidBody.isKinematic = true;
            
			drop.SetFlag(BaseEntity.Flags.Open, true, false);						
			
            drop.gameObject.AddComponent<SkinBoxHandler>().looter = player;            
            drop.inventory.capacity = 36;						
            drop.SetFlag(BaseEntity.Flags.Open, true, false);
			
			player.inventory.loot.StartLootingEntity(drop, false);						
            player.inventory.loot.AddContainer(drop.inventory);						
            player.inventory.loot.SendImmediate();
			
			player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel", drop.lootPanelName);			
            drop.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);			

            activeBoxUsers[player.userID] = player.transform.position;
        }
        
        private void StartLootingEntity(PlayerLoot loot, BaseEntity targetEntity) 
        {                        
            loot.Clear();
            if (!targetEntity) return;            
			loot.PositionChecks = false;
            loot.entitySource = targetEntity;
            loot.itemSource = null;            
			loot.MarkDirty();
        }
        
        private static void ClearContainer(ItemContainer container) 
        {
            while (container.itemList.Count > 0) 
            {
                var item = container.itemList[0];
                item.RemoveFromContainer();
                item.Remove(0f);
            }                        
        }
        
        private object CanAcceptItem(ItemContainer container, Item item) 
        {
            if (container == null || item == null || container.entityOwner == null || container.entityOwner.GetComponent<SkinBoxHandler>() == null || 
				container.entityOwner != container.entityOwner.GetComponent<SkinBoxHandler>().entityOwner || 
				container.entityOwner.GetComponent<SkinBoxHandler>().isCreating || container.entityOwner.GetComponent<SkinBoxHandler>().isPaging) 
				return null;
            
			if (container.entityOwner.GetComponent<SkinBoxHandler>().isBlocked || item.amount > 1 || item.isBroken || 
				!skinsCache.ContainsKey(item.info.shortname) || (skinsCache[item.info.shortname] as LinkedList<ulong>).Count <= 1) 
				return ItemContainer.CanAcceptResult.CannotAccept;
				
            return null;
        }                
        
        private void OnItemAddedToContainer(ItemContainer container, Item item) 
        {
            if (container == null || item == null || container.entityOwner == null || container.entityOwner.GetComponent<SkinBoxHandler>() == null || 
				container.entityOwner != container.entityOwner.GetComponent<SkinBoxHandler>().entityOwner || 
				container.entityOwner.GetComponent<SkinBoxHandler>().isCreating || container.entityOwner.GetComponent<SkinBoxHandler>().isPaging) 
				return;
				
            var lootHandler = container.entityOwner.GetComponent<SkinBoxHandler>();
            lootHandler.isCreating = true;
            lootHandler.itemId = item.info.itemid;
            lootHandler.isEmptied = false;
            string shortname = item.info.shortname;
            bool hasCondition = item.hasCondition;
            float condition = item.condition;
			//float fuel = item.fuel;
			
			if (item.contents != null && item.contents.itemList.Count > 0)
			{
				var array = item.contents.itemList.ToArray();
				for (int i = 0; i < array.Length; i++)
				{
					if (array[i].info.category == ItemCategory.Weapon) continue;
					var item2 = array[i];
					lootHandler.looter.inventory.GiveItem(item2, null);
				}
			}
			
            float maxCondition = item.maxCondition;
            bool isWeapon = item.GetHeldEntity() != null && item.GetHeldEntity() is BaseProjectile;
            bool hasMods = false;
            int contents = 0;
            int capacity = 0;
            ItemDefinition ammoType = null;
            Dictionary<int, float> itemMods = new Dictionary<int, float>();
            LinkedList<ulong>  itemSkins = skinsCache[shortname] as LinkedList<ulong>;			
			
            if (isWeapon) 
            {
                contents = (item.GetHeldEntity() as BaseProjectile).primaryMagazine.contents;
                capacity = (item.GetHeldEntity() as BaseProjectile).primaryMagazine.capacity;
                ammoType = (item.GetHeldEntity() as BaseProjectile).primaryMagazine.ammoType;
                if (item.contents != null && item.contents.itemList.Count > 0) 
                {
                    hasMods = true;
                    foreach ( var mod in item.contents.itemList) itemMods.Add(mod.info.itemid, mod.condition);
                }                                
            }
            
            item.RemoveFromContainer();
            lootHandler.skinId = item.skin;
            lootHandler.item = item;
            container.capacity = itemSkins.Count();
            var itemDef = ItemManager.FindItemDefinition(shortname);
			int pos = 0;
			bool paged = false;						
			
            foreach (var skin in itemSkins) 
            {                				
                if (excludedSkins.Contains(skin) && !lootHandler.looter.IsAdmin) continue;
                Item newItem = ItemManager.Create(itemDef, 1, skin);
                
				if (hasCondition) 
                {
                    newItem.condition = condition;
                    newItem.maxCondition = maxCondition;
                }
				
				//newItem.fuel = fuel;
                
                if (isWeapon) 
                {
                    (newItem.GetHeldEntity() as BaseProjectile).primaryMagazine.contents = contents;
                    (newItem.GetHeldEntity() as BaseProjectile).primaryMagazine.capacity = capacity;
                    (newItem.GetHeldEntity() as BaseProjectile).primaryMagazine.ammoType = ammoType;
                    if (hasMods) 
                    {
                        foreach ( var mod in itemMods) 
                        {
                            Item newMod = ItemManager.CreateByItemID((int)mod.Key, 1);
                            newMod.condition = Convert.ToSingle(mod.Value);
                            newMod.MoveToContainer(newItem.contents, -1, false);
                        }
                        
                        newItem.contents.SetFlag(ItemContainer.Flag.IsLocked, true);
                        newItem.contents.SetFlag(ItemContainer.Flag.NoItemInput, true);
                    }                                        
                }                				
				
				if (container.itemList.Count < 36)
					newItem.MoveToContainer(container, pos, false);					
				else
				{	
					newItem.MoveToContainer(lootHandler.otherLoot, pos, false);		                
					paged = true;
				}	
				
				pos++;
            }
            
			if (paged) ShowButtons(lootHandler.looter);
			
            lootHandler.isCreating = false;
            lootHandler.isBlocked = true;
        }
        
        private void OnItemRemovedFromContainer(ItemContainer container, Item item) 
        {
            if (container == null || item == null || container.entityOwner == null || container.entityOwner.GetComponent<SkinBoxHandler>() == null || 
				container.entityOwner != container.entityOwner.GetComponent<SkinBoxHandler>().entityOwner || 
				container.entityOwner.GetComponent<SkinBoxHandler>().isCreating || container.entityOwner.GetComponent<SkinBoxHandler>().isCleaning ||
				container.entityOwner.GetComponent<SkinBoxHandler>().isPaging) 
				return;								
				
            var loothandler = container.entityOwner.GetComponent<SkinBoxHandler>();
            if (item.GetHeldEntity() != null && item.GetHeldEntity() is BaseProjectile) 
            {
                if (item.contents != null) 
                {
                    item.contents.SetFlag(ItemContainer.Flag.IsLocked, false);
                    item.contents.SetFlag(ItemContainer.Flag.NoItemInput, false);
                }                                
            }
            
            loothandler.isCleaning = true;
            ClearContainer(container);
			ClearContainer(loothandler.otherLoot);
			CuiHelper.DestroyUi(loothandler.looter, "Buttons");
			loothandler.page = 1;
            loothandler.isCleaning = false;
			
			if (loothandler.skinId != item.skin)
				Interface.CallHook("SkinsOnSkinChanged", loothandler.looter, item, loothandler.skinId);			
			
            if (loothandler.item != null) 
            {
                loothandler.item.Remove(0f);
                loothandler.item = null;
            }
            
            loothandler.isEmptied = true;
            container.capacity = 36;
            loothandler.isBlocked = false;
            if (item.skin == 0uL) 
            {
                loothandler.skinId = 0uL;
                return;
            }                        
            
            if (configData.enableCooldown && configData.activateAfterSkinTaken && !loothandler.looter.IsAdmin && item.skin != loothandler.skinId) 
            {
                activeBoxUsers.Remove(loothandler.looter.userID);
                loothandler.looter.EndLooting();
                cooldownTimes[loothandler.looter.UserIDString + "-box"] = DateTime.UtcNow;
            }
            
            loothandler.skinId = 0uL;
        }
        
        private void UnsubscribeAll() 
        {
			try { Unsubscribe(nameof(CanAcceptItem)); } catch { PrintWarning("Ошибка отписки хука CanAcceptItem"); }
            try { Unsubscribe(nameof(OnItemAddedToContainer)); } catch { PrintWarning("Ошибка отписки хука OnItemAddedToContainer"); }
            try { Unsubscribe(nameof(OnItemRemovedFromContainer)); } catch { PrintWarning("Ошибка отписки хука OnItemRemovedFromContainer"); }
        }
        
        private void SubscribeAll() 
        {
            try { Subscribe(nameof(CanAcceptItem)); } catch { PrintWarning("Ошибка подписки хука CanAcceptItem"); }
            try { Subscribe(nameof(OnItemAddedToContainer)); } catch { PrintWarning("Ошибка подписки хука OnItemAddedToContainer"); }
            try { Subscribe(nameof(OnItemRemovedFromContainer)); } catch { PrintWarning("Ошибка подписки хука OnItemRemovedFromContainer"); }
        }
        
        private void SendReplyCl(ConsoleSystem.Arg arg, string format) 
        {
            if (arg != null && arg.Connection != null) SendReply(arg, format);
            Puts(format);
        }        
		
		#region ExtHooks

		//void SkinsOnSkinChanged(BasePlayer player, Item item, ulong oldSkin);  - вызывается при смене скина у предмета
		
		#endregion
		
		#region GUI

		private void ShowButtons(BasePlayer player)
		{
			if (player == null) return;
			
			CuiHelper.DestroyUi(player, "Buttons");

			CuiElementContainer container = new CuiElementContainer();
            container.Add(new CuiElement
            {
                Name = "Buttons",
				Parent = "Overlay",
                Components =
                {
                    new CuiImageComponent { Color = "0 0 0 0" },										
                    new CuiRectTransformComponent()					
					{
                        AnchorMin = "0.655 0.070",
                        AnchorMax = "0.71 0.103"						
                    }
                }
            });                       

            CreateButton(player, container, "0.01 0.01", "0.40 0.99", true);						
            CreateButton(player, container, "0.60 0.01", "0.99 0.99", false);
            											
			CuiHelper.AddUi(player, container); 
		}
		
		private void ShowDir(BasePlayer player, bool isLeft)
		{			
			if (player == null) return;
			
			var name = player.UserIDString + (isLeft ? "_leftin" : "_rightin");
			CuiHelper.DestroyUi(player, name);
			CuiElementContainer container = new CuiElementContainer();
            container.Add(new CuiElement
            {                
				Name = name,
                Parent = player.UserIDString + (isLeft ? "_left" : "_right"),
                Components =
                {                    
					new CuiRawImageComponent 
					{
						Url = isLeft ? "https://i.imgur.com/OzJdfxx.png" : "https://i.imgur.com/oM5tS89.png",
						Color = "1 1 0 0.6",
						Sprite = "assets/content/textures/generic/fulltransparent.tga"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = isLeft ? "0.15 0.2" : "0.07 0.2",
                        AnchorMax = isLeft ? "0.9 0.8" : "0.82 0.8"
                    }
                }
            });
			CuiHelper.AddUi(player, container);
			timer.Once(0.3f, ()=>CuiHelper.DestroyUi(player, name));
		}
				
        private void CreateButton(BasePlayer player, CuiElementContainer container, string AnchorMin, string AnchorMax, bool isLeft)
        {            
            container.Add(new CuiElement
            {
                Name = player.UserIDString + (isLeft ? "_left" : "_right"),
                Parent = "Buttons",
                Components =
                {                    
					new CuiRawImageComponent 
					{
						Url = isLeft ? "https://i.imgur.com/a9ofmZk.png" : "https://i.imgur.com/5ZUL5Ao.png",
						Color = "1 1 1 0.6",
						Sprite = "assets/content/textures/generic/fulltransparent.tga"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = AnchorMin,
                        AnchorMax = AnchorMax
                    }
                }
            });						            
			
			container.Add(new CuiElement
            {
                Name = CuiHelper.GetGuid(),
                Parent = player.UserIDString + (isLeft ? "_left" : "_right"),
                Components =
                {
                    new CuiButtonComponent
                    {
                        Command = "button947283.select " + (isLeft ? "left" : "right"),                        
                        Color = "1 1 1 0"
                    },
                    new CuiRectTransformComponent()                    
                }
            });
        }									
		
		[ConsoleCommand("button947283.select")]
		private void ConsoleCmdSelect(ConsoleSystem.Arg arg)
		{
			if (arg.Connection != null)
            {
				string selectedButton = arg.Args[0];
				var player = arg.Player();
				if (player == null) return;

                switch(selectedButton)
                {
                    case "left":
						ShowDir(player, true);
						foreach(var box in SkinBoxHandler.SkinBoxes.Where(x=> x != null).ToList())
						{
							if (box.looter == player)
							{				
								if (box.page <= 1) return;
																
								int pageItemCount = 36;		

								box.showLoot.capacity = pageItemCount;
								
								int pageReadPos = (box.page-2)*36;
								int pageWritePos = (box.page-1)*36;
								
								box.isPaging = true;
								for(int ii=box.showLoot.itemList.Count-1;ii>=0;ii--)
								{
									var item = box.showLoot.itemList[ii];
									item.MoveToContainer(box.otherLoot, pageWritePos + item.position, false);									
								}	
								for(int ii=box.otherLoot.itemList.Count-1;ii>=0;ii--)
								{
									var item = box.otherLoot.itemList[ii];
									if (item.position >= pageReadPos && item.position < pageReadPos + pageItemCount)									
										item.MoveToContainer(box.showLoot, item.position - pageReadPos, false);									
								}			
								box.page--;								
								box.isPaging = false;								
								break;
							}
						}
						break;
                    case "right":						
						ShowDir(player, false);		
						foreach(var box in SkinBoxHandler.SkinBoxes.Where(x=> x != null).ToList())
						{
							if (box.looter == player)
							{																
								int pageItemCount = (box.showLoot.itemList.Count+box.otherLoot.itemList.Count)-36*box.page > 36 ? 36 : (box.showLoot.itemList.Count+box.otherLoot.itemList.Count)-36*box.page;
								if (pageItemCount <= 0) return;
																					
								box.showLoot.capacity = pageItemCount;
								
								int pageReadPos = box.page*36;
								int pageWritePos = (box.page-1)*36;
								
								box.isPaging = true;
								for(int ii=box.showLoot.itemList.Count-1;ii>=0;ii--)
								{
									var item = box.showLoot.itemList[ii];
									item.MoveToContainer(box.otherLoot, pageWritePos + item.position, false);									
								}	
								for(int ii=box.otherLoot.itemList.Count-1;ii>=0;ii--)
								{
									var item = box.otherLoot.itemList[ii];
									if (item.position >= pageReadPos && item.position < pageReadPos + pageItemCount)									
										item.MoveToContainer(box.showLoot, item.position - pageReadPos, false);									
								}								
								box.page++;
								box.isPaging = false;																
								break;
							}
						}
						break;                                        
                }                
			}
		}
		
		#endregion
		
		#region Config        						
		
        private static ConfigData configData;				
		
        private class ConfigData
        {            												
			[JsonProperty(PropertyName = "Разрешать использовать вручную добавленные скины")]
            public bool useManualAddedSkins;			
			
			[JsonProperty(PropertyName = "Надпись, отображаемая на панели скинов")]
			public string skinBoxTitle;			
			[JsonProperty(PropertyName = "Список привилегий для смены скинов")]
            public List<string> permissionsUse;			
			[JsonProperty(PropertyName = "Показывать счетчик загрузки скинов в консоле")]
            public bool showLoadedSkinCounts;						
			
			[JsonProperty(PropertyName = "Включить задержку перед повторным использованием скинов")]
			public bool enableCooldown;
			[JsonProperty(PropertyName = "Длительность задержки перед повторным использованием скинов (в секундах)")]
            public int cooldownBox;			
			[JsonProperty(PropertyName = "При использовании задержки разрешать менять только один скин")]            
            public bool activateAfterSkinTaken;
			
			[JsonProperty(PropertyName = "Список отсутствующих названий предметов, которым принадлежат скины")]
            public Dictionary<string, object> missingSkinNames;				
			[JsonProperty(PropertyName = "Список скинов, добавленных вручную")]
			public Dictionary<string, List<ulong>> manualAddedSkinsPre;			
			[JsonProperty(PropertyName = "Список скинов для исключения")]
			public List<ulong> excludedSkinsPre;
        }
		
        private void LoadVariables() => configData = Config.ReadObject<ConfigData>();        
		
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {                											
				useManualAddedSkins = true,								
				skinBoxTitle = "RUST PINK - Скины \n Перетащите предмет, чтобы изменить его модель",
				permissionsUse = new List<string>() { "skinbox.access", "skins.change" },				
				showLoadedSkinCounts = true,																		
				enableCooldown = false,
				cooldownBox = 60,									
				activateAfterSkinTaken = true,
				missingSkinNames = missingWorkshopNames(),
				manualAddedSkinsPre = new Dictionary<string, List<ulong>>(),
				excludedSkinsPre = new List<ulong>()
            };
            SaveConfig(config);
			timer.Once(0.1f, ()=> SaveConfig(config));
        }        
		
        private void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
		
        #endregion
        
    }      

}

// --- End of file: SkinBox.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HudRust/DVTeleportation.cs ---
// --- Original Local Path: HudRust/DVTeleportation.cs ---

using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using UnityEngine;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Cui;

namespace Oxide.Plugins
{
    [Info("DVTeleportation", "OxideBro / Допилил ClayMond", "1.5.0")]
    [Description("Спасибо за покупку - by oxide-russia.ru")]
    class DVTeleportation : RustPlugin
    {
        [PluginReference] Plugin Clans;
        [PluginReference] Plugin Friends;
        Dictionary<ulong, Vector3> lastPositions = new Dictionary<ulong, Vector3>();
        Dictionary<BasePlayer, int> spectatingPlayers = new Dictionary<BasePlayer, int>();
        bool IsClanMember(ulong playerid = 294912, ulong targetID = 0) => (bool)(Clans?.Call("HasFriend", playerid, targetID) ?? false);
        bool IsFriends(ulong playerID = 0, ulong friendId = 0) => (bool)(Friends?.Call("AreFriends", playerID, friendId) ?? false);

        bool IsTeamate(BasePlayer player, ulong targetID)
        {
            if (player.currentTeam == 0) return false;
            var team = RelationshipManager.ServerInstance.FindTeam(player.currentTeam);
            if (team == null) return false;
            var list = RelationshipManager.ServerInstance.FindTeam(player.currentTeam).members.Where(p => p == targetID).ToList();
            return list.Count > 0;
        }

        class TP
        {
            public BasePlayer Player;
            public BasePlayer Player2;
            public Vector3 pos;
            public float totalSeconds;
            public bool EnabledShip;
            public int seconds;
            public bool TPL;
            public TP(BasePlayer player, Vector3 Pos, int Seconds, bool EnabledShip1, bool tpl, BasePlayer player2 = null)
            {    
                Player = player;
                pos = Pos;
                seconds = Seconds;
                totalSeconds = Seconds;
                EnabledShip = EnabledShip1;
                Player2 = player2;
                TPL = tpl;
            }
        }
        const string TPADMIN = "DVTeleportation.admin";
        int homelimitDefault;
        Dictionary<string, int> homelimitPerms;
        int tpkdDefault;
        Dictionary<string, int> tpkdPerms;
        int tpkdhomeDefault;
        Dictionary<string, int> tpkdhomePerms;
        int teleportSecsDefault;
        int resetPendingTime;
        bool restrictCupboard;
        bool enabledTPR;
        bool homecupboard;
        bool homecupboardblock;
        bool adminsLogs;
        bool foundationOwner;
        bool foundationOwnerFC;

        bool restrictTPRCupboard;
        bool foundationEx;
        bool wipedData;
        bool createSleepingBug;
        string EffectPrefab1;
        string EffectPrefab;
        bool EnabledShipTP;
        bool EnabledBallonTP;
        bool CancelTPMetabolism;
        bool CancelTPCold;
        bool CancelTPRadiation;
        bool FriendsEnabled;
        bool CancelTPWounded;
        bool EnabledTPLForPlayers;
        int TPLCooldown;
        int TplPedingTime;
        bool TPLAdmin;
        string AutoTPAPermission;

        static DynamicConfigFile config;
        Dictionary<string, int> teleportSecsPerms;
        void OnNewSave()
        {
            if (wipedData)
            {
                PrintWarning("Обнаружен вайп. Очищаем данные с data/DVTeleportation");
                WipeData();
            }
        }
        void WipeData()
        {
            LoadData();
            tpsave = new List<TPList>();
            homes = new Dictionary<ulong, Dictionary<string, Vector3>>();
            SaveData();
        }
        protected override void LoadDefaultConfig()
        {
            GetVariable(Config, "Запрещать отправлять запрос на телепортацию в зоне действия чужого шкафа", out homecupboard, true);
            GetVariable(Config, "Удалять точку теоепртации если она в билде в какой не авторизован игрок", out homecupboard, true);
            GetVariable(Config, "Звук уведомления при получение запроса на телепорт (пустое поле = звук отключен)", out EffectPrefab1, "assets/prefabs/locks/keypad/effects/lock.code.unlock.prefab");
            GetVariable(Config, "Звук предупреждения (пустое поле = звук отключен)", out EffectPrefab, "assets/prefabs/locks/keypad/effects/lock.code.denied.prefab");
            GetVariable(Config, "Разрешать сохранять местоположение только на фундаменте", out foundationEx, true);
            GetVariable(Config, "Создавать объект при сохранении местоположения в виде Sleeping Bag", out createSleepingBug, true);
            GetVariable(Config, "Автоматический вайп данных при генерации новой карты", out wipedData, true);
            GetVariable(Config, "Запрещать принимать запрос на телепортацию в зоне действия чужого шкафа", out restrictCupboard, true);
            GetVariable(Config, "Запрещать сохранять местоположение если игрок не является владельцем фундамента", out foundationOwner, true);
            GetVariable(Config, "Привилегия на использование автоматического приёма телепорта", out AutoTPAPermission, "DVTeleportation.autotpa");
            GetVariable(Config, "Разрешать сохранять местоположение если игрок является другом или соклановцем или тимейтом владельца фундамента ", out foundationOwnerFC, true);
            GetVariable(Config, "Логировать использование команд для администраторов", out adminsLogs, true);
            GetVariable(Config, "Включить телепортацию (TPR/TPA) только к друзьям, соклановкам или тимейту", out FriendsEnabled, true);
            GetVariable(Config, "Разрешить команду TPR игрокам (false = /tpr не будет работать)", out enabledTPR, true);
            GetVariable(Config, "Разрешить отправку и приём телепорта и телепорт домой на корабле", out EnabledShipTP, true);
            GetVariable(Config, "Разрешить отправку и приём телепорта на воздушном шаре", out EnabledBallonTP, true);
            GetVariable(Config, "Запрещать отправлять запрос на телепортацию в зоне действия чужого шкафа", out restrictTPRCupboard, true);
            GetVariable(Config, "Отмета телепорта игрока (Home/TP) если у него кровотечение", out CancelTPMetabolism, true);
            GetVariable(Config, "Отмета телепорта игрока (Home/TP) если игрок ранен", out CancelTPWounded, true);
            GetVariable(Config, "Отмета телепорта игрока (Home/TP) если ему холодно", out CancelTPCold, true);
            GetVariable(Config, "Отмета телепорта игрока (Home/TP) если он облучен радиацией", out CancelTPRadiation, true);
            GetVariable(Config, "Время ответа на запрос телепортации (в секундах)", out resetPendingTime, 15);
            GetVariable(Config, "Ограничение на количество сохранённых местоположений", out homelimitDefault, 3);
            GetVariable(Config, "[TPL] Разрешить игрокам использовать TPL", out EnabledTPLForPlayers, false);
            GetVariable(Config, "[TPL] Задержка телепортации игрока на TPL", out TplPedingTime, 15);
            GetVariable(Config, "[TPL] Cooldown телепортации игрока на TPL", out TPLCooldown, 15);
            GetVariable(Config, "[TPL] Телепортировать админа без задержки и кулдауна?", out TPLAdmin, true);
            Config["Ограничение на количество сохранённых местоположений с привилегией"] = homelimitPerms = GetConfig("Ограничение на количество сохранённых местоположений с привилегией", new Dictionary<string, object>() {
                    {
                    "DVTeleportation.vip", 5
                }
            }
            ).ToDictionary(p => p.Key, p => Convert.ToInt32(p.Value));
            PermissionService.RegisterPermissions(this, homelimitPerms.Keys.ToList());
            GetVariable(Config, "Длительность задержки перед телепортацией (в секундах)", out teleportSecsDefault, 15);
            Config["Длительность задержки перед телепортацией с привилегией (в секундах)"] = teleportSecsPerms = GetConfig("Длительность задержки перед телепортацией с привилегией (в секундах)", new Dictionary<string, object>() {
                    {
                    "DVTeleportation.vip", 10
                }
            }
            ).ToDictionary(p => p.Key, p => Convert.ToInt32(p.Value));
            PermissionService.RegisterPermissions(this, teleportSecsPerms.Keys.ToList());
            GetVariable(Config, "Длительность перезарядки телепорта (в секундах)", out tpkdDefault, 300);
            Config["Длительность перезарядки телепорта с привилегией (в секундах)"] = tpkdPerms = GetConfig("Длительность перезарядки телепорта с привилегией (в секундах)", new Dictionary<string, object>() {
                    {
                    "DVTeleportation.vip", 150
                }
            }
            ).ToDictionary(p => p.Key, p => Convert.ToInt32(p.Value));
            PermissionService.RegisterPermissions(this, tpkdPerms.Keys.ToList());
            GetVariable(Config, "Длительность перезарядки телепорта домой (в секундах)", out tpkdhomeDefault, 300);
            Config["Длительность перезарядки телепорта домой с привилегией (в секундах)"] = tpkdhomePerms = GetConfig("Длительность перезарядки телепорта домой с привилегией (в секундах)", new Dictionary<string, object>() {
                    {
                    "DVTeleportation.vip", 150
                }
            }
            ).ToDictionary(p => p.Key, p => Convert.ToInt32(p.Value));
            PermissionService.RegisterPermissions(this, tpkdhomePerms.Keys.ToList());
            SaveConfig();
        }
        T GetConfig<T>(string name, T defaultValue) => Config[name] == null ? defaultValue : (T)Convert.ChangeType(Config[name], typeof(T));
        public static void GetVariable<T>(DynamicConfigFile config, string name, out T value, T defaultValue)
        {
            config[name] = value = config[name] == null ? defaultValue : (T)Convert.ChangeType(config[name], typeof(T));
        }
        public static class PermissionService
        {
            public static Permission permission = Interface.GetMod().GetLibrary<Permission>();
            public static bool HasPermission(ulong uid, string permissionName)
            {
                return !string.IsNullOrEmpty(permissionName) && permission.UserHasPermission(uid.ToString(), permissionName);
            }
            public static void RegisterPermissions(Plugin owner, List<string> permissions)
            {
                if (owner == null) throw new ArgumentNullException("owner");
                if (permissions == null) throw new ArgumentNullException("commands");
                foreach (var permissionName in permissions.Where(permissionName => !permission.PermissionExists(permissionName)))
                {
                    permission.RegisterPermission(permissionName, owner);
                }
            }
        }
        public BasePlayer FindBasePlayer(string nameOrUserId)
        {
            nameOrUserId = nameOrUserId.ToLower();
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (player.displayName.ToLower().Contains(nameOrUserId) || player.UserIDString == nameOrUserId) return player;
            }
            foreach (var player in BasePlayer.sleepingPlayerList)
            {
                if (player.displayName.ToLower().Contains(nameOrUserId) || player.UserIDString == nameOrUserId) return player;
            }
            return default(BasePlayer);
        }
        Dictionary<ulong, Dictionary<string, Vector3>> homes;
        List<TPList> tpsave;
        class TPList
        {
            public string Name;
            public Vector3 pos;
        }
        Dictionary<ulong, int> cooldownsTP = new Dictionary<ulong, int>();
        Dictionary<ulong, int> cooldownsHOME = new Dictionary<ulong, int>();
        List<TP> tpQueue = new List<TP>();
        List<TP> pendings = new List<TP>();
        List<ulong> sethomeBlock = new List<ulong>();

        /*[ChatCommand("atp")]
        void cmdAutoTPA(BasePlayer player, string com, string[] args)
        {
            if (!PermissionService.HasPermission(player.userID, AutoTPAPermission))
            {
                SendReply(player, Messages["TPAPerm"]);
                return;
            }

            if (!AutoTPA.ContainsKey(player.userID))
                AutoTPA.Add(player.userID, new AutoTPASettings());


            var data = AutoTPA[player.userID];

            if (args == null || args.Length <= 0)
            {
                if (data.Enabled)
                {
                    data.Enabled = false;
                    SendReply(player, Messages["TPADisable"]);

                }
                else
                {
                    data.Enabled = true;
                    SendReply(player, string.Format(Messages["TPAEnabled"], Messages["TPAEnabledInfo"]));
                }
                return;
            }

            switch (args[0])
            {
                case "add":
                    if (args.Length < 2)
                    {
                        SendReply(player, Messages["TPAEAddError"]);
                        return;
                    }

                    var target = covalence.Players.FindPlayers(args[1]).ToList();

                    if (target == null || target.Count <= 0)
                    {
                        SendReply(player, string.Format(Messages["TPAEAddPlayerNotFound"], "⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠⁠"));
                        return;
                    }

                    if (target.Count > 1)
                    {
                        SendReply(player, string.Format(Messages["TPAEAddPlayers"], string.Join(", ", target.Select(p => p.Name).Take(5))));
                        return;
                    }
                    if (data.PlayersList.ContainsKey(target[0].Name))
                    {
                        SendReply(player, string.Format(Messages["TPAEAddContains"], target[0].Name));
                        return;
                    }

                    data.PlayersList.Add(target[0].Name, ulong.Parse(target[0].Id));

                    SendReply(player, string.Format(Messages["TPAEAddSuccess"], target[0].Name));

                    break;
                case "remove":
                    if (args.Length < 2)
                    {
                        SendReply(player, Messages["TPARemoveError"]);
                        return;
                    }
                    var key = data.PlayersList.FirstOrDefault(p => p.Key.ToLower().Contains(args[1].ToLower())).Key;
                    if (string.IsNullOrEmpty(key))
                    {
                        SendReply(player, string.Format(Messages["TPAEAddPlayerNotFound"], string.Format(Messages["TPAEnabledList"], string.Join(", ", data.PlayersList.Select(p => p.Key)))));
                        return;
                    }

                    data.PlayersList.Remove(key);
                    SendReply(player, string.Format(Messages["TPAERemoveSuccess"], key));

                    break;
                case "list":
                    if (data.PlayersList.Count <= 0)
                        SendReply(player, Messages["TPAEListNotFound"]);
                    else
                        SendReply(player, string.Format(Messages["TPAEnabledList"], string.Join(", ", data.PlayersList.Select(p => p.Key))));
                    break;
            }
        }
        */

        [ChatCommand("sethome")]
        void cmdChatSetHome(BasePlayer player, string command, string[] args)
        {
            var uid = player.userID;
            var pos = player.transform.position;
            var entity = new BaseEntity();

            RaycastHit hitInfo;
            if (!Physics.Raycast(player.transform.position, Vector3.down, out hitInfo, 1f))
            {
                SendReply(player, Messages["buildingBrockmissing"]);
                return;
            }
            if (hitInfo.GetEntity() == null || !(hitInfo.GetEntity() is BuildingBlock))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["buildingBrockmissing"]);
                return;
            }

            if (foundationEx && !hitInfo.GetEntity().ShortPrefabName.Contains("foundation"))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["foundationmissing"]);
                return;
            }
            entity = hitInfo.GetEntity();
            var point = player.transform.position;
            point.y = player.transform.position.y;
            pos = point;
            if (args.Length != 1)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["sethomeArgsError"]);
                return;
            }
            if (CancelTPMetabolism && player.metabolism.bleeding.value > 0)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["woundedAction"]);
                return;
            }
            if (CancelTPRadiation && player.metabolism.radiation_poison.value > 10)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["Radiation"]);
                return;
            }
            if (player.IsWounded() && CancelTPWounded)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["woundedAction"]);
                return;
            }
            if (sethomeBlock.Contains(player.userID))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["sethomeBlock"]);
                return;
            }

            if (foundationOwnerFC && foundationOwner)
            {

                if (entity.OwnerID != uid)
                {
                    if (!IsFriends(entity.OwnerID, player.userID) && !IsClanMember(entity.OwnerID, player.userID) && !IsTeamate(player, entity.OwnerID))
                    {
                        Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                        SendReply(player, Messages["foundationownerFC"]);
                        return;
                    }
                }
            }
            if (foundationOwner)
            {

                if (entity.OwnerID != uid && foundationOwnerFC == (!IsFriends(entity.OwnerID, player.userID) && !IsClanMember(entity.OwnerID, player.userID) && IsTeamate(player, entity.OwnerID)))
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["foundationowner"]);
                    return;
                }
            }
            var name = args[0];
            SetHome(player, name, pos);
        }

        [ChatCommand("removehome")]
        void cmdChatRemoveHome(BasePlayer player, string command, string[] args)
        {
            if (args.Length != 1)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["removehomeArgsError"]);
                return;
            }
            if (!homes.ContainsKey(player.userID))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["homesmissing"]);
                return;
            }
            var name = args[0];
            var playerHomes = homes[player.userID];
            if (!playerHomes.ContainsKey(name))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["homenotexist"]);
                return;
            }
            foreach (var sleepingBag in SleepingBag.FindForPlayer(player.userID, true))
            {
                if (Vector3.Distance(sleepingBag.transform.position, playerHomes[name]) < 1)
                {
                    sleepingBag.Kill();
                    break;
                }
            }
            Effect.server.Run(EffectPrefab1, player, 0, Vector3.zero, Vector3.forward);
            playerHomes.Remove(name);
            SendReply(player, Messages["removehomesuccess"], name);
        }
        [ConsoleCommand("home")]
        void cmdHome(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;
            if (arg.Args == null || arg.Args.Length < 1) return;
            cmdChatHome(player, "", new[] { arg.Args[0] });
        }
        [ChatCommand("homelist")]
        private void cmdHomeList(BasePlayer player, string command, string[] args)
        {
            if (!homes.ContainsKey(player.userID) || homes[player.userID].Count == 0)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["homesmissing"]);
                return;
            }
            var playerHomes = homes[player.userID];
            var time = (GetHomeLimit(player.userID) - playerHomes.Count);
            var homelist = playerHomes.Select(x => GetSleepingBag(x.Key, x.Value) != null ? $"{x.Key} {x.Value}" : $"Дом: {x.Key} {x.Value}");

            foreach (var home in playerHomes.ToList())
            {
                if (createSleepingBug)
                    if (!GetSleepingBag(home.Key, home.Value)) playerHomes.Remove(home.Key);
            }
            SendReply(player, Messages["homeslist"], time, string.Join("\n", homelist.ToArray()));
        }
        [ChatCommand("home")]
        void cmdChatHome(BasePlayer player, string command, string[] args)
        {
            if (args.Length != 1)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["homeArgsError"]);
                return;
            }
            var ret = Interface.Call("CanTeleport", player) as string;
            if (ret != null)
            {
                SendReply(player, ret);
                return;
            }
            if (!EnabledShipTP && player.GetParentEntity() is CargoShip)
            {
                SendReply(player, Messages["PlayerIsOnCargoShip"]);
                return;
            }
            if (!EnabledBallonTP && player.GetParentEntity() is HotAirBalloon)
            {
                SendReply(player, Messages["PlayerIsOnHotAirBalloon"]);
                return;
            }
            if (player.IsWounded() && CancelTPWounded)
            {
                SendReply(player, Messages["woundedAction"]);
                return;
            }
            if (player.metabolism.bleeding.value > 0 && CancelTPMetabolism)
            {
                SendReply(player, Messages["woundedAction"]);
                return;
            }

            if (CancelTPRadiation && player.metabolism.radiation_poison.value > 10)
            {
                SendReply(player, Messages["Radiation"]);
                return;
            }
            int seconds;
            if (cooldownsHOME.TryGetValue(player.userID, out seconds) && seconds > 0)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, string.Format(Messages["tpkd"], TimeToString(seconds)));
                return;
            }
            if (homecupboard)
            {
                var privilege = player.GetBuildingPrivilege(player.WorldSpaceBounds());
                if (privilege != null && !player.IsBuildingAuthed())
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["tphomecupboard"]);
                    return;
                }
            }
            if (!homes.ContainsKey(player.userID))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["homesmissing"]);
                return;
            }
            var name = args[0];
            var playerHomes = homes[player.userID];
            if (!playerHomes.ContainsKey(name))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["homenotexist"]);
                return;
            }
            var time = GetTeleportTime(player.userID);
            var pos = playerHomes[name];
            SleepingBag bag = GetSleepingBag(name, pos);
            if (createSleepingBug)
            {
                if (bag == null)
                {
                    foreach (var sleepingBag in SleepingBag.FindForPlayer(player.userID, true))
                    {
                        if (Vector3.Distance(sleepingBag.transform.position, playerHomes[name]) < 1)
                        {
                            sleepingBag.Kill();
                            break;
                        }
                    }
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["sleepingbagmissing"]);
                    playerHomes.Remove(name);
                    return;
                }

                if (bag.GetBuildingPrivilege() != null && !bag.GetBuildingPrivilege().IsAuthed(player))
                {
                    foreach (var sleepingBag in SleepingBag.FindForPlayer(player.userID, true))
                    {
                        if (Vector3.Distance(sleepingBag.transform.position, playerHomes[name]) < 1)
                        {
                            sleepingBag.Kill();
                            break;
                        }
                    }
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["sleepingbugbuildblock"]);
                    playerHomes.Remove(name);
                    return;
                }
            }
            else
            {
                var bulds = GetBuldings(pos);
                if (bulds == null)
                {
                    foreach (var sleepingBag in SleepingBag.FindForPlayer(player.userID, true))
                    {
                        if (Vector3.Distance(sleepingBag.transform.position, playerHomes[name]) < 1)
                        {
                            sleepingBag.Kill();
                            break;
                        }
                    }
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["buildingBrockmissingR"]);
                    playerHomes.Remove(name);
                    return;
                }

                if (bulds.GetBuildingPrivilege() != null && !bulds.GetBuildingPrivilege().IsAuthed(player))
                {
                    foreach (var sleepingBag in SleepingBag.FindForPlayer(player.userID, true))
                    {
                        if (Vector3.Distance(sleepingBag.transform.position, playerHomes[name]) < 1)
                        {
                            sleepingBag.Kill();
                            break;
                        }
                    }
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["sleepingbugbuildblock"]);
                    playerHomes.Remove(name);

                    return;
                }
            }
            if (CancelTPCold && player.metabolism.temperature.value < 0)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["coldplayer"]);
                return;
            }
            if (tpQueue.Any(p => p.Player == player) || pendings.Any(p => p.Player2 == player))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["tpError"]);
                return;
            }
            var lastTp = tpQueue.Find(p => p.Player == player);
            if (lastTp != null)
            {
                tpQueue.Remove(lastTp);
            }
            tpQueue.Add(new TP(player, pos, time, false, false));
            Effect.server.Run(EffectPrefab1, player, 0, Vector3.zero, Vector3.forward);
            SendReply(player, String.Format(Messages["homequeue"], name, TimeToString(time)));
        }
        [ChatCommand("tpr")]
        void cmdChatTpr(BasePlayer player, string command, string[] args)
        {
            if (!enabledTPR) return;
            if (args.Length != 1)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["tprArgsError"]);
                return;
            }
            var ret = Interface.Call("CanTeleport", player) as string;
            if (ret != null)
            {
                SendReply(player, ret);
                return;
            }
            if (!EnabledShipTP && player.GetParentEntity() is CargoShip)
            {
                SendReply(player, Messages["PlayerIsOnCargoShip"]);
                return;
            }
            if (!EnabledBallonTP && player.GetParentEntity() is HotAirBalloon)
            {
                SendReply(player, Messages["PlayerIsOnHotAirBalloon"]);
                return;
            }
            if (player.IsWounded() && CancelTPWounded)
            {
                SendReply(player, Messages["woundedAction"]);
                return;
            }
            if (player.metabolism.bleeding.value > 0 && CancelTPMetabolism)
            {
                SendReply(player, Messages["woundedAction"]);
                return;
            }
            if (CancelTPRadiation && player.metabolism.radiation_poison.value > 10)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["Radiation"]);
                return;
            }
            if (restrictTPRCupboard)
            {
                var privilege = player.GetBuildingPrivilege(player.WorldSpaceBounds());
                if (privilege != null && !player.IsBuildingAuthed())
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["tpcupboard"]);
                    return;
                }
            }
            var name = args[0];
            var target = FindBasePlayer(name);
            if (target == null || !target.IsConnected)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["playermissing"]);
                return;
            }
            if (target == player)
            {
                SendReply(player, Messages["playerisyou"]);
                return;
            }
            if (FriendsEnabled)
                if (!IsFriends(target.userID, player.userID) && !IsTeamate(player, target.userID) && !IsClanMember(player.userID, target.userID))
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["PlayerNotFriend"]);
                    return;
                }
            int seconds = 0;
            if (restrictCupboard && player.GetBuildingPrivilege(player.WorldSpaceBounds()) != null && !player.GetBuildingPrivilege(player.WorldSpaceBounds()).authorizedPlayers.Select(p => p.userid).Contains(player.userID))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["tpcupboard"]);
                return;
            }

            if (cooldownsTP.TryGetValue(player.userID, out seconds) && seconds > 0)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, string.Format(Messages["tpkd"], TimeToString(seconds)));
                return;
            }
            if (CancelTPCold && player.metabolism.temperature.value < 0)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["coldplayer"]);
                return;
            }
            if (tpQueue.Any(p => p.Player == player) || pendings.Any(p => p.Player2 == player))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["tpError"]);
                return;
            }

            if (tpQueue.Any(p => p.Player == target) || pendings.Any(p => p.Player2 == target))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["tpError"]);
                return;
            }
            SendReply(player, string.Format(Messages["tprrequestsuccess"], target.displayName));
            SendReply(target, string.Format(Messages["tprpending"], player.displayName));
            Effect.server.Run(EffectPrefab1, target, 0, Vector3.zero, Vector3.forward);

            DVTeleportationAcceptUI(target, player.displayName);
            pendings.Add(new TP(target, Vector3.zero, 15, false, false, player));
            if (!IsFriends(target.userID, player.userID) && !IsClanMember(player.userID, target.userID) && !player.Team.members.Contains(target.userID)) return;
            cmdChatTpa(target, command, new string[] { "atp" });
            SendReply(target, Messages["TPASuccess"]);
        }
        [ChatCommand("tpa")]
        void cmdChatTpa(BasePlayer player, string command, string[] args)
        {
            if (!enabledTPR) return;
            var tp = pendings.Find(p => p.Player == player);
            if (tp == null)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["tpanotexist"]);
                return;
            }
            BasePlayer pendingPlayer = tp.Player2;
            if (pendingPlayer == null)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["tpanotexist"]);
                return;
            }
            if (!EnabledBallonTP && player.GetParentEntity() is HotAirBalloon)
            {
                SendReply(player, Messages["PlayerIsOnHotAirBalloon"]);
                return;
            }
            if (!EnabledShipTP && player.GetParentEntity() is CargoShip)
            {
                SendReply(player, Messages["PlayerIsOnCargoShip"]);
                return;
            }
            if (CancelTPCold && player.metabolism.temperature.value < 0)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["coldplayer"]);
                return;
            }
            if (player.IsWounded() && CancelTPWounded)
            {
                SendReply(player, Messages["woundedAction"]);
                return;
            }
            if (player.metabolism.bleeding.value > 0 && CancelTPMetabolism)
            {
                SendReply(player, Messages["woundedAction"]);
                return;
            }
            if (CancelTPRadiation && player.metabolism.radiation_poison.value > 10)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["Radiation"]);
                return;
            }
            if (restrictCupboard && player.GetBuildingPrivilege(player.WorldSpaceBounds()) != null && !player.GetBuildingPrivilege(player.WorldSpaceBounds()).authorizedPlayers.Select(p => p.userid).Contains(player.userID))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["tpacupboard"]);
                return;
            }
            var ret = Interface.Call("CanTeleport", player) as string;
            if (ret != null)
            {
                SendReply(player, ret);
                return;
            }
            if (FriendsEnabled)
                if (!IsFriends(pendingPlayer.userID, player.userID) && !IsTeamate(player, pendingPlayer.userID) && !IsClanMember(player.userID, pendingPlayer.userID))
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["PlayerNotFriend"]);
                    return;
                }
            var time = GetTeleportTime(pendingPlayer.userID);
            pendings.Remove(tp);
            var lastTp = tpQueue.Find(p => p.Player == pendingPlayer);
            if (lastTp != null)
            {
                tpQueue.Remove(lastTp);
            }
            var Enabled = player.GetParentEntity() is CargoShip || player.GetParentEntity() is HotAirBalloon;
            tpQueue.Add(new TP(pendingPlayer, player.transform.position, time, Enabled, false, player));
            Effect.server.Run(EffectPrefab1, player, 0, Vector3.zero, Vector3.forward);
            SendReply(pendingPlayer, string.Format(Messages["tpqueue"], player.displayName, TimeToString(time)));
            if (args.Length <= 0) SendReply(player, String.Format(Messages["tpasuccess"], pendingPlayer.displayName, TimeToString(time)));
            CuiHelper.DestroyUi(player, PARENT_TELEPORT);
        }
        
        [ChatCommand("tpc")]
        void cmdChatTpc(BasePlayer player, string command, string[] args)
        {
            var tp = pendings.Find(p => p.Player == player);
            BasePlayer target = tp?.Player2;
            if (target != null)
            {
                pendings.Remove(tp);
                SendReply(player, Messages["tpc"]);
                SendReply(target, string.Format(Messages["tpctarget"], player.displayName));
                CuiHelper.DestroyUi(player, "Teleport");
                CuiHelper.DestroyUi(target, "Teleport");
                CuiHelper.DestroyUi(target, PARENT_TELEPORT);
                return;
            }
            if (player.IsWounded() && CancelTPWounded)
            {
                SendReply(player, Messages["woundedAction"]);
                return;
            }
            if (player.metabolism.bleeding.value > 0 && CancelTPMetabolism)
            {
                SendReply(player, Messages["woundedAction"]);
                return;
            }
            if (CancelTPRadiation && player.metabolism.radiation_poison.value > 10)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["Radiation"]);
                return;
            }
            if (CancelTPCold && player.metabolism.temperature.value < 0)
            {
                SendReply(player, Messages["coldplayer"]);
                return;
            }
            foreach (var pend in pendings)
            {
                if (pend.Player2 == player)
                {
                    SendReply(player, Messages["tpc"]);
                    SendReply(pend.Player, string.Format(Messages["tpctarget"], player.displayName));
                    pendings.Remove(pend);
                    return;
                }
            }
            foreach (var tpQ in tpQueue)
            {
                if (tpQ.Player2 != null && tpQ.Player2 == player)
                {
                    SendReply(player, Messages["tpc"]);
                    SendReply(tpQ.Player, string.Format(Messages["tpctarget"], player.displayName));
                    tpQueue.Remove(tpQ);
                    CuiHelper.DestroyUi(player, "Teleport");
                    CuiHelper.DestroyUi(tpQ.Player, "Teleport");
                    return;
                }
                if (tpQ.Player == player)
                {
                    SendReply(player, Messages["tpc"]);
                    if (tpQ.Player2 != null)
                    {
                        SendReply(tpQ.Player2, string.Format(Messages["tpctarget"], player.displayName));
                        CuiHelper.DestroyUi(tpQ.Player2, "Teleport");
                    }
                    tpQueue.Remove(tpQ);
                    CuiHelper.DestroyUi(player, "Teleport");

                    return;
                }
            }
        }
        void SpectateFinish(BasePlayer player)
        {
            player.Command("camoffset", "0,1,0");
            player.StopSpectating();
            player.SetParent(null);
            player.gameObject.SetLayerRecursive(17);
            player.SetPlayerFlag(BasePlayer.PlayerFlags.Spectating, false);
            player.SetPlayerFlag(BasePlayer.PlayerFlags.ThirdPersonViewmode, false);
            player.SendNetworkUpdateImmediate();
            player.metabolism.Reset();
            player.InvokeRepeating("InventoryUpdate", 1f, 0.1f * UnityEngine.Random.Range(0.99f, 1.01f));
            if (player.net?.connection != null) player.ClientRPCPlayer(null, player, "StartLoading");
            player.StartSleeping();
            if (lastPositions.ContainsKey(player.userID))
            {
                Vector3 lastPosition = lastPositions[player.userID] + Vector3.up;
                player.MovePosition(lastPosition);
                if (player.net?.connection != null) player.ClientRPCPlayer(null, player, "ForcePositionTo", lastPosition);
                lastPositions.Remove(player.userID);

            }

            if (player.net?.connection != null) player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, true);
            player.UpdateNetworkGroup();
            player.SendNetworkUpdateImmediate(false);
            if (player.net?.connection == null) return;
            try
            {
                player.ClearEntityQueue(null);
            }
            catch { }
            player.SendFullSnapshot();

            SendReply(player, "Слежка закончена!");
        }


        private void OnUserConnected(IPlayer player) => ResetSpectate(player);

        private void OnUserDisconnected(IPlayer player) => ResetSpectate(player);

        private void ResetSpectate(IPlayer player)
        {
            player.Command("camoffset 0,1,0");

            if (lastPositions.ContainsKey(ulong.Parse(player.Id)))
            {
                lastPositions.Remove(ulong.Parse(player.Id));
            }
        }

        object OnPlayerSpectateEnd(BasePlayer player, string spectateFilter)
        {
            player.Command("camoffset", "0,1,0");
            return null;
        }

        [ChatCommand("tpl")]
        void cmdChattpGo(BasePlayer player, string command, string[] args)
        {
            if (!EnabledTPLForPlayers && !player.IsAdmin && !PermissionService.HasPermission(player.userID, "DVTeleportation.admin")) return;
            if (args == null || args.Length == 0)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["tpArgsError"]);
                return;
            }
            switch (args[0])
            {
                default:
                    if (tpsave.Count <= 0)
                    {
                        Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                        SendReply(player, Messages["homesmissing"]);
                        return;
                    }
                    var nametp = args[0];
                    var tp = tpsave.Find(p => p.Name == nametp);
                    if (tp == null)
                    {
                        Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                        SendReply(player, Messages["homenotexist"]);
                        return;
                    }
                    var position = tp.pos;
                    var ret = Interface.Call("CanTeleport", player) as string;
                    if (ret != null)
                    {
                        SendReply(player, ret);
                        return;
                    }
                    int seconds;
                    if (cooldownsHOME.TryGetValue(player.userID, out seconds) && seconds > 0)
                    {
                        Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                        SendReply(player, string.Format(Messages["tpkd"], TimeToString(seconds)));
                        return;
                    }
                    var lastTp = tpQueue.Find(p => p.Player == player);
                    if (lastTp != null) tpQueue.Remove(lastTp);
                    Effect.server.Run(EffectPrefab1, player, 0, Vector3.zero, Vector3.forward);
                    if (TPLAdmin && player.IsAdmin || PermissionService.HasPermission(player.userID, "DVTeleportation.admin")) Teleport(player, position);
                    else
                    {
                        tpQueue.Add(new TP(player, position, TplPedingTime, false, true));
                        SendReply(player, String.Format(Messages["homequeue"], nametp, TimeToString(TplPedingTime)));
                    }
                    return;
                case "add":
                    if (!player.IsAdmin && !PermissionService.HasPermission(player.userID, "DVTeleportation.admin")) return;
                    if (args == null || args.Length == 1)
                    {
                        Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                        SendReply(player, Messages["settpArgsError"]);
                        return;
                    }
                    var nameAdd = args[1];
                    SetTpSave(player, nameAdd);
                    return;
                case "remove":
                    if (!player.IsAdmin && !PermissionService.HasPermission(player.userID, "DVTeleportation.admin")) return;
                    if (args == null || args.Length == 1)
                    {
                        Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                        SendReply(player, Messages["removetpArgsError"]);
                        return;
                    }
                    nametp = args[1];
                    if (tpsave.Count > 0)
                    {
                        tp = tpsave.Find(p => p.Name == nametp);
                        if (tp == null)
                        {
                            Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                            SendReply(player, Messages["homesmissing"]);
                            return;
                        }
                        Effect.server.Run(EffectPrefab1, player, 0, Vector3.zero, Vector3.forward);
                        tpsave.Remove(tp);
                        SendReply(player, Messages["removehomesuccess"], nametp);
                    }
                    return;
                case "list":
                    if (tpsave.Count <= 0)
                    {
                        Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                        SendReply(player, Messages["TPLmissing"]);
                        return;
                    }
                    var tplist = tpsave.Select(x => $"{x.Name} {x.pos}");
                    SendReply(player, Messages["TPLList"], string.Join("\n", tplist.ToArray()));
                    return;
            }
        }
        [ChatCommand("tpspec")]
        void cmdTPSpec(BasePlayer player, string command, string[] args)
        {
            if (!PermissionService.HasPermission(player.userID, "DVTeleportation.admin")) return;
            if (!player.IsSpectating())
            {
                if (args.Length == 0 || args.Length != 1)
                {
                    SendReply(player, Messages["tpspecError"]);
                    return;
                }
                string name = args[0];
                BasePlayer target = FindBasePlayer(name);
                if (target == null)
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["playermissing"]);
                    return;
                }
                switch (args.Length)
                {
                    case 1:
                        if (!target.IsConnected)
                        {
                            SendReply(player, Messages["playermissingOff"]);
                            return;
                        }
                        if (target.IsDead())
                        {
                            SendReply(player, Messages["playermissingOrDeath"]);
                            return;
                        }
                        if (ReferenceEquals(target, player))
                        {
                            SendReply(player, Messages["playerItsYou"]);
                            return;
                        }
                        if (target.IsSpectating())
                        {
                            SendReply(player, Messages["playerItsSpec"]);
                            return;
                        }
                        spectatingPlayers.Remove(target);
                        lastPositions[player.userID] = player.transform.position;
                        HeldEntity heldEntity = player.GetActiveItem()?.GetHeldEntity() as HeldEntity;
                        heldEntity?.SetHeld(false);
                        player.SetPlayerFlag(BasePlayer.PlayerFlags.Spectating, true);
                        player.gameObject.SetLayerRecursive(10);
                        player.CancelInvoke("MetabolismUpdate");
                        player.CancelInvoke("InventoryUpdate");
                        player.ClearEntityQueue();
                        player.SendEntitySnapshot(target);
                        player.gameObject.Identity();
                        player.SetParent(target);
                        player.SetPlayerFlag(BasePlayer.PlayerFlags.ThirdPersonViewmode, true);
                        player.Command("camoffset", "0, 1.3, 0");
                        SendReply(player, $"Вы наблюдаете за игроком {target}! Что бы переключаться между игроками, нажимайте: Пробел\nЧтобы выйти с режима наблюдения, введите: /tpspec");
                        break;
                }
            }
            else SpectateFinish(player);
        }
        [ChatCommand("tp")]
        void cmdTP(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin && !PermissionService.HasPermission(player.userID, "DVTeleportation.admin")) return;
            switch (args.Length)
            {
                case 1:
                    string name = args[0];
                    BasePlayer target = FindBasePlayer(name);
                    if (target == null)
                    {
                        Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                        SendReply(player, Messages["playermissing"]);
                        return;
                    }
                    if (adminsLogs)
                    {
                        LogToFile("admin", $"[{DateTime.Now.ToShortTimeString()}] {player} телепортировался к {target}", this, true);
                    }
                    Teleport(player, target);
                    break;
                case 2:
                    string name1 = args[0];
                    string name2 = args[1];
                    BasePlayer target1 = FindBasePlayer(name1);
                    BasePlayer target2 = FindBasePlayer(name2);
                    if (target1 == null || target2 == null)
                    {
                        SendReply(player, Messages["playermissing"]);
                        return;
                    }
                    if (adminsLogs)
                    {
                        LogToFile("admin", $"[{DateTime.Now.ToShortTimeString()}] Игрок {player} телепортировал {target1} к {target2}", this, true);
                    }
                    Teleport(target1, target2);
                    break;
                case 3:
                    float x = float.Parse(args[0].Replace(",", ""));
                    float y = float.Parse(args[1].Replace(",", ""));
                    float z = float.Parse(args[2]);
                    if (adminsLogs)
                    {
                        LogToFile("admin", $"[{DateTime.Now.ToShortTimeString()}] Игрок {player} телепортировался на координаты: ({x} / {y} / {z})", this, true);
                    }
                    Teleport(player, x, y, z);
                    break;
            }
        }
        [ConsoleCommand("home.wipe")]
        private void CmdTest(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null) return;
            PrintWarning("Запущен ручной вайп. Очищаем данные с data/DVTeleportation");
            WipeData();
        }
        public string TimeToString(double time)
        {
            TimeSpan elapsedTime = TimeSpan.FromSeconds(time);
            int hours = elapsedTime.Hours;
            int minutes = elapsedTime.Minutes;
            int seconds = elapsedTime.Seconds;
            int days = Mathf.FloorToInt((float)elapsedTime.TotalDays);
            string s = "";
            if (days > 0) s += $"{days} дн.";
            if (hours > 0) s += $"{hours} ч. ";
            if (minutes > 0) s += $"{minutes} мин. ";
            if (seconds > 0) s += $"{seconds} сек.";
            else s = s.TrimEnd(' ');
            return s;
        }

        void OnPlayerDisconnected(BasePlayer player)
        {
            pendings.RemoveAll(p => p.Player == player || p.Player2 == player);
            tpQueue.RemoveAll(p => p.Player == player || p.Player2 == player);
        }

        void Loaded()
        {
            lang.RegisterMessages(Messages, this, "en");
            Messages = lang.GetMessages("en", this);
            LoadDefaultConfig();
        }

        void OnServerInitialized()
        {
            LoadData();
            permission.RegisterPermission(TPADMIN, this);
            permission.RegisterPermission(AutoTPAPermission, this);
            timer.Every(1f, DVTeleportationTimerHandle);
        }

        void OnServerSave()
        => SaveData();

        void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, PARENT_TELEPORT);
                CuiHelper.DestroyUi(player, "Teleport");
            }
            SaveData();
        }

        void OnEntityBuilt(Planner planner, GameObject gameobject)
        {
            if (planner == null || gameobject == null) return;
            var player = planner.GetOwnerPlayer();
            BaseEntity entity = gameobject.ToBaseEntity();
            if (entity == null) return;
            if (gameobject.name.Contains("foundation"))
            {
                var pos = gameobject.transform.position;
                foreach (var pending in tpQueue)
                {
                    if (Vector3.Distance(pending.pos, pos) < 3)
                    {
                        entity.Kill();
                        SendReply(planner.GetOwnerPlayer(), "Нельзя, тут телепортируется игрок!");
                        return;
                    }
                }
            }
        }

        object OnEntityTakeDamage(BasePlayer player, HitInfo info)
        {
            if (player == null || info == null) return null;
            var tp = tpQueue.Find(p => p.Player == player);
            if (tp != null)
            {
                SendReply(tp.Player, Messages["tpwounded"]);
                tpQueue.Remove(tp);
            }
            return null;
        }

        [PluginReference] Plugin Duel;
        bool InDuel(BasePlayer player) => Duel?.Call<bool>("IsPlayerOnActiveDuel", player) ?? false;

        void DVTeleportationTimerHandle()
        {
            List<ulong> tpkdToRemove = new List<ulong>();
            foreach (var uid in cooldownsTP.Keys.ToList())
            {
                if (--cooldownsTP[uid] <= 0)
                {
                    tpkdToRemove.Add(uid);
                }
            }
            tpkdToRemove.ForEach(p => cooldownsTP.Remove(p));
            List<ulong> tpkdHomeToRemove = new List<ulong>();
            foreach (var uid in cooldownsHOME.Keys.ToList())
            {
                if (--cooldownsHOME[uid] <= 0) tpkdHomeToRemove.Add(uid);
            }
            tpkdHomeToRemove.ForEach(p => cooldownsHOME.Remove(p));
            for (int i = pendings.Count - 1;
            i >= 0;
            i--)
            {
                var pend = pendings[i];
                if (pend.Player != null && pend.Player.IsConnected && pend.Player.IsWounded())
                {
                    SendReply(pend.Player, Messages["tpwounded"]);

                    if (pend.Player2 != null && pend.Player2.IsConnected)
                    {
                        CuiHelper.DestroyUi(pend.Player2, "Teleport");
                        CuiHelper.DestroyUi(pend.Player2, PARENT_TELEPORT);
                    }
                    if (pend.Player != null && pend.Player.IsConnected)
                    {
                        CuiHelper.DestroyUi(pend.Player, "Teleport");
                        CuiHelper.DestroyUi(pend.Player, PARENT_TELEPORT);
                    }
                    pendings.RemoveAt(i);
                    continue;
                }
                if (--pend.seconds <= 0)
                {
                    pendings.RemoveAt(i);
                    if (pend.Player2 != null && pend.Player2.IsConnected)
                    {
                        SendReply(pend.Player2, Messages["tppendingcanceled"]);
                        CuiHelper.DestroyUi(pend.Player2, "Teleport");
                        CuiHelper.DestroyUi(pend.Player2, PARENT_TELEPORT);
                    }
                    if (pend.Player != null && pend.Player.IsConnected)
                    {
                        SendReply(pend.Player, Messages["tpacanceled"]);
                        CuiHelper.DestroyUi(pend.Player, "Teleport");
                        CuiHelper.DestroyUi(pend.Player, PARENT_TELEPORT);
                    }
                }
                else
                {
                    if (pend.Player != null && pend.Player.IsConnected)
                    {
                        CreateUpdateUI(pend.Player, pend, "PendingTextPlayer2");
                    }
                    if (pend.Player2 != null && pend.Player2.IsConnected)
                    {
                        CreateUpdateUI(pend.Player2, pend, "PendingTextPlayer1");
                    }
                }
            }
            for (int i = tpQueue.Count - 1;
            i >= 0;
            i--)
            {
                var reply = 288;
                if (reply == 0) { }
                var tp = tpQueue[i];
                if (tp.Player != null)
                {

                    if (tp.Player.IsDead())
                    {
                        if (tp.Player2 != null && tp.Player2.IsConnected)
                        {
                            CuiHelper.DestroyUi(tp.Player2, "Teleport");
                            CuiHelper.DestroyUi(tp.Player2, PARENT_TELEPORT);
                        }
                        CuiHelper.DestroyUi(tp.Player, "Teleport");
                        CuiHelper.DestroyUi(tp.Player, PARENT_TELEPORT);
                        tpQueue.RemoveAt(i);
                        continue;
                    }
                    if (tp.Player.IsConnected && (CancelTPWounded && tp.Player.IsWounded()) || (tp.Player.metabolism.bleeding.value > 0 && CancelTPMetabolism) || (CancelTPRadiation && tp.Player.metabolism.radiation_poison.value > 10))
                    {
                        SendReply(tp.Player, Messages["tpwounded"]);
                        if (tp.Player2 != null && tp.Player2.IsConnected)
                        {
                            SendReply(tp.Player2, Messages["tpWoundedTarget"]);
                            CuiHelper.DestroyUi(tp.Player2, "Teleport");
                            CuiHelper.DestroyUi(tp.Player2, PARENT_TELEPORT);
                        }
                        CuiHelper.DestroyUi(tp.Player, "Teleport");
                        CuiHelper.DestroyUi(tp.Player, PARENT_TELEPORT);
                        tpQueue.RemoveAt(i);
                        continue;
                    }
                    if (InDuel(tp.Player))
                    {
                        SendReply(tp.Player, Messages["InDuel"]);
                        if (tp.Player2 != null && tp.Player2.IsConnected)
                        {
                            SendReply(tp.Player2, Messages["InDuelTarget"]);
                            CuiHelper.DestroyUi(tp.Player2, "Teleport");
                            CuiHelper.DestroyUi(tp.Player2, PARENT_TELEPORT);
                        }
                        CuiHelper.DestroyUi(tp.Player, "Teleport");
                        CuiHelper.DestroyUi(tp.Player, PARENT_TELEPORT);
                        tpQueue.RemoveAt(i);
                        continue;
                    }
                    if (restrictTPRCupboard)
                    {
                        var privilege = tp.Player.GetBuildingPrivilege(tp.Player.WorldSpaceBounds());
                        if (privilege != null && !tp.Player.IsBuildingAuthed())
                        {
                            Effect.server.Run(EffectPrefab, tp.Player, 0, Vector3.zero, Vector3.forward);

                            SendReply(tp.Player, Messages["tpcupboard"]);
                            if (tp.Player2 != null && tp.Player2.IsConnected)
                            {
                                SendReply(tp.Player2, Messages["tpcupboardTarget"]);
                                CuiHelper.DestroyUi(tp.Player2, "Teleport");
                                CuiHelper.DestroyUi(tp.Player2, PARENT_TELEPORT);
                            }
                            CuiHelper.DestroyUi(tp.Player, "Teleport");
                            CuiHelper.DestroyUi(tp.Player, PARENT_TELEPORT);
                            tpQueue.RemoveAt(i);
                            return;
                        }
                    }
                }

                if (tp.Player2 != null)
                {
                    if (tp.Player2.IsConnected && (tp.Player2.IsWounded() && CancelTPWounded) || (tp.Player2.metabolism.bleeding.value > 0 && CancelTPMetabolism) || (CancelTPRadiation && tp.Player2.radiationLevel > 10))
                    {
                        SendReply(tp.Player2, Messages["tpwounded"]);
                        if (tp.Player != null && tp.Player.IsConnected)
                        {
                            SendReply(tp.Player, Messages["tpWoundedTarget"]);
                            CuiHelper.DestroyUi(tp.Player, "Teleport");
                            CuiHelper.DestroyUi(tp.Player, PARENT_TELEPORT);
                        }
                        CuiHelper.DestroyUi(tp.Player2, "Teleport");
                        CuiHelper.DestroyUi(tp.Player2, PARENT_TELEPORT);
                        tpQueue.RemoveAt(i);
                        continue;
                    }
                    if (InDuel(tp.Player2))
                    {
                        SendReply(tp.Player2, Messages["InDuel"]);
                        if (tp.Player != null && tp.Player.IsConnected)
                        {
                            SendReply(tp.Player, Messages["InDuelTarget"]);
                            CuiHelper.DestroyUi(tp.Player, "Teleport");
                            CuiHelper.DestroyUi(tp.Player, PARENT_TELEPORT);
                        }
                        CuiHelper.DestroyUi(tp.Player2, "Teleport");
                        CuiHelper.DestroyUi(tp.Player2, PARENT_TELEPORT);
                        tpQueue.RemoveAt(i);
                        continue;
                    }
                    if (restrictTPRCupboard)
                    {
                        var privilege = tp.Player2.GetBuildingPrivilege(tp.Player2.WorldSpaceBounds());
                        if (privilege != null && !tp.Player2.IsBuildingAuthed())
                        {
                            Effect.server.Run(EffectPrefab, tp.Player2, 0, Vector3.zero, Vector3.forward);
                            if (tp.Player != null && tp.Player.IsConnected)
                            {
                                SendReply(tp.Player, Messages["tpcupboardTarget"]);
                                CuiHelper.DestroyUi(tp.Player, "Teleport");
                                CuiHelper.DestroyUi(tp.Player, PARENT_TELEPORT);
                            }

                            SendReply(tp.Player2, Messages["tpcupboard"]);
                            CuiHelper.DestroyUi(tp.Player2, "Teleport");
                            CuiHelper.DestroyUi(tp.Player2, PARENT_TELEPORT);
                            return;
                        }
                    }
                }
                if (--tp.seconds <= 0)
                {
                    tpQueue.RemoveAt(i);
                    var ret = Interface.CallHook("CanTeleport", tp.Player) as string;
                    if (ret != null)
                    {
                        SendReply(tp.Player, ret);
                        CuiHelper.DestroyUi(tp.Player, "Teleport");
                        CuiHelper.DestroyUi(tp.Player, PARENT_TELEPORT);
                        continue;
                    }
                    if (CheckInsideInFoundation(tp.pos))
                    {
                        SendReply(tp.Player, Messages["InsideInFoundationTP"]);
                        CuiHelper.DestroyUi(tp.Player, "Teleport");
                        CuiHelper.DestroyUi(tp.Player, PARENT_TELEPORT);
                        continue;
                    }
                    if (tp.Player2 != null)
                    {

                        if (tp.Player.GetMountedVehicle() is ScrapTransportHelicopter || tp.Player.GetMountedVehicle() is MiniCopter || tp.Player2.GetMountedVehicle() is ScrapTransportHelicopter || tp.Player2.GetMountedVehicle() is MiniCopter || tp.Player.GetComponentInParent<ScrapTransportHelicopter>() || tp.Player2.GetComponentInParent<ScrapTransportHelicopter>())
                        {
                            SendReply(tp.Player, Messages["TeleportaCancelHeli"]);
                            SendReply(tp.Player2, Messages["TeleportaCancelHeli"]);
                            CuiHelper.DestroyUi(tp.Player, "Teleport");
                            CuiHelper.DestroyUi(tp.Player2, "Teleport");
                            CuiHelper.DestroyUi(tp.Player, PARENT_TELEPORT);
                            continue;
                        }
                        tp.Player.SetParent(tp.Player2.GetParentEntity());
                        if (tp.EnabledShip) tp.pos = tp.Player2.transform.position;
                    }
                    if (tp.Player2 != null && tp.Player != null && tp.Player.IsConnected && tp.Player2.IsConnected)
                    {
                        var seconds = GetKD(tp.Player.userID);
                        cooldownsTP[tp.Player.userID] = seconds;
                        SendReply(tp.Player, string.Format(Messages["tpplayersuccess"], tp.Player2.displayName));
                        CuiHelper.DestroyUi(tp.Player, "Teleport");
                        CuiHelper.DestroyUi(tp.Player, PARENT_TELEPORT);
                        CuiHelper.DestroyUi(tp.Player2, "Teleport");
                    }
                    else if (tp.Player != null && tp.Player.IsConnected)
                    {
                        tp.Player.SetParent(null);
                        if (tp.TPL)
                        {
                            var seconds = TPLCooldown;
                            cooldownsHOME[tp.Player.userID] = seconds;
                            SendReply(tp.Player, Messages["tplsuccess"]);
                            CuiHelper.DestroyUi(tp.Player, "Teleport");
                            CuiHelper.DestroyUi(tp.Player, PARENT_TELEPORT);
                        }
                        else
                        {
                            var seconds = GetKDHome(tp.Player.userID);
                            cooldownsHOME[tp.Player.userID] = seconds;
                            SendReply(tp.Player, Messages["tphomesuccess"]);
                            CuiHelper.DestroyUi(tp.Player, "Teleport");
                            CuiHelper.DestroyUi(tp.Player, PARENT_TELEPORT);
                        }
                    }
                    if (tp.Player.IsDead())
                        continue;
                    Teleport(tp.Player, tp.pos);
                    NextTick(() => Interface.CallHook("OnPlayerTeleported", tp.Player));
                }
                else
                {
                    CreateUpdateUI(tp.Player, tp, "TimerTextPlayer1");
                    if (tp.Player2 != null && tp.Player2.IsConnected)
                    {
                        CreateUpdateUI(tp.Player2, tp, "TimerTextPlayer2");
                    }
                }
            }
        }

        void SetTpSave(BasePlayer player, string name)
        {
            var position = player.transform.position;
            if (tpsave.Count > 0)
            {
                var tp = tpsave.Find(p => p.Name == name);
                if (tp != null)
                {
                    Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                    SendReply(player, Messages["homeexist"]);
                    return;
                }
            }
            tpsave.Add(new TPList()
            {
                Name = name,
                pos = position
            }
            );

            Effect.server.Run(EffectPrefab1, player, 0, Vector3.zero, Vector3.forward);
            SendReply(player, Messages["homesucces"], name);
            timer.Once(10f, () => sethomeBlock.Remove(player.userID));
        }

        private readonly int blockLayer = LayerMask.GetMask("Construction");

        private bool ValidBlock(BaseEntity entity, Vector3 position)
        {
            Vector3 center = entity.CenterPoint();

            List<BaseEntity> ents = new List<BaseEntity>();
            Vis.Entities<BaseEntity>(center, 1.5f, ents);
            foreach (BaseEntity wall in ents)
            {
                if (wall.name.Contains("external.high"))
                    return false;
            }
            if (entity.PrefabName.Contains("triangle.prefab"))
            {
                if (Math.Abs(center.x - position.x) < 0.45f && Math.Abs(center.z - position.z) < 0.45f)
                    return true;
            }
            else if (entity.PrefabName.Contains("foundation.prefab") || entity.PrefabName.Contains("floor.prefab"))
            {
                if (Math.Abs(center.x - position.x) < 0.7f && Math.Abs(center.z - position.z) < 0.7f)
                    return true;
            }
            return false;
        }

        private List<BuildingBlock> GetFoundation(Vector3 position)
        {
            RaycastHit hitinfo;
            var entities = new List<BuildingBlock>();

            if (Physics.Raycast(position, Vector3.down, out hitinfo, 2.5f, blockLayer) && hitinfo.GetEntity().IsValid())
            {
                var entity = hitinfo.GetEntity();
                if (entity.PrefabName.Contains("foundation") || position.y < entity.WorldSpaceBounds().ToBounds().max.y)
                {
                    if (ValidBlock(entity, position))
                    {
                        entities.Add(entity as BuildingBlock);
                    }
                }
            }
            return entities;
        }


        void SetHome(BasePlayer player, string name, Vector3 pos)
        {
            var uid = player.userID;
            if (player.GetBuildingPrivilege(player.WorldSpaceBounds()) != null && !player.GetBuildingPrivilege(player.WorldSpaceBounds()).authorizedPlayers.Select(p => p.userid).Contains(player.userID))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["sethomecupboard"]);
                return;
            }
            Dictionary<string, Vector3> playerHomes;
            if (!homes.TryGetValue(uid, out playerHomes)) playerHomes = (homes[uid] = new Dictionary<string, Vector3>());
            if (GetHomeLimit(uid) == playerHomes.Count)
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["maxhomes"]);
                return;
            }
            if (playerHomes.ContainsKey(name))
            {
                Effect.server.Run(EffectPrefab, player, 0, Vector3.zero, Vector3.forward);
                SendReply(player, Messages["homeexist"]);
                return;
            }
            List<BuildingBlock> foundation = GetFoundation(pos);
            foundation.RemoveAll(x => !x.IsValid() || x.IsDestroyed);

            if (foundation.Count <= 0)
            {
                SendReply(player, Messages["foundationmissing"]);
                return;
            }

            if (CheckInsideInFoundation(player.transform.position))
            {
                SendReply(player, Messages["InsideInFoundation"]);
                return;
            }
            playerHomes.Add(name, pos);
            if (createSleepingBug)
            {
                CreateSleepingBag(player, pos, name);
            }
            Effect.server.Run(EffectPrefab1, player, 0, Vector3.zero, Vector3.forward);
            SendReply(player, Messages["homesucces"], name);
            sethomeBlock.Add(player.userID);
            timer.Once(10f, () => sethomeBlock.Remove(player.userID));
        }


        private bool CheckInsideInFoundation(Vector3 position)
        {
            foreach (var hit in Physics.RaycastAll(position, Vector3.up, 2f, LayerMask.GetMask("Terrain", "World", "Construction", "Deployed")))
            {
                if (!foundationEx && hit.GetCollider().name.Contains("foundation")) return true;
                else
                if (hit.GetCollider().name.Contains("foundation")) return true;
            }
            foreach (var hit in Physics.RaycastAll(position + Vector3.up + Vector3.up + Vector3.up + Vector3.up, Vector3.down, 2f, LayerMask.GetMask("Terrain", "World", "Construction", "Deployed")))
            {
                if (hit.GetCollider().name.Contains("foundation")) return true;
            }
            return false;
        }
        int GetKDHome(ulong uid)
        {
            int min = tpkdhomeDefault;
            foreach (var privilege in tpkdhomePerms) if (PermissionService.HasPermission(uid, privilege.Key)) min = Mathf.Min(min, privilege.Value);
            return min;
        }
        int GetKD(ulong uid)
        {
            int min = tpkdDefault;
            foreach (var privilege in tpkdPerms) if (PermissionService.HasPermission(uid, privilege.Key)) min = Mathf.Min(min, privilege.Value);
            return min;
        }
        int GetHomeLimit(ulong uid)
        {
            int max = homelimitDefault;
            foreach (var privilege in homelimitPerms) if (PermissionService.HasPermission(uid, privilege.Key)) max = Mathf.Max(max, privilege.Value);
            return max;
        }
        int GetTeleportTime(ulong uid)
        {
            int min = teleportSecsDefault;
            foreach (var privilege in teleportSecsPerms) if (PermissionService.HasPermission(uid, privilege.Key)) min = Mathf.Min(min, privilege.Value);
            return min;
        }
        BaseEntity GetBuldings(Vector3 pos)
        {
            RaycastHit hit;
            if (Physics.Raycast(new Ray(pos, Vector3.down), out hit, 0.2f))
            {
                var entity = hit.GetEntity();
                if (entity != null)
                {
                    if (entity.GetComponent<BuildingBlock>() == null) return null;
                    return entity;
                }
                else return null;
            }
            return null;
        }

        SleepingBag GetSleepingBag(string name, Vector3 pos)
        {
            List<SleepingBag> sleepingBags = new List<SleepingBag>();
            Vis.Components(pos, .1f, sleepingBags);
            return sleepingBags.Count > 0 ? sleepingBags[0] : null;
        }
        void CreateSleepingBag(BasePlayer player, Vector3 pos, string name)
        {
            SleepingBag sleepingBag = GameManager.server.CreateEntity("assets/prefabs/deployable/sleeping bag/sleepingbag_leather_deployed.prefab", pos, Quaternion.identity) as SleepingBag;
            if (sleepingBag == null) return;
            sleepingBag.skinID = 802413726;
            sleepingBag.deployerUserID = player.userID;
            sleepingBag.niceName = name;
            sleepingBag.OwnerID = player.userID;
            sleepingBag.Spawn();
            sleepingBag.SendNetworkUpdate();
        }
        Dictionary<string, Vector3> GetHomes(ulong uid)
        {
            Dictionary<string, Vector3> positions;
            if (!homes.TryGetValue(uid, out positions)) return null;
            return positions.ToDictionary(p => p.Key, p => p.Value);
        }

        public void Teleport(BasePlayer player, BasePlayer target) => Teleport(player, target.transform.position);
        public void Teleport(BasePlayer player, float x, float y, float z) => Teleport(player, new Vector3(x, y, z));
        public void Teleport(BasePlayer player, Vector3 position)
        {
            player.RemoveFromTriggers();
            if (player.GetParentEntity() != null)
                player.SetParent(null);
            if (player.IsDead() && player.IsConnected)
            {
                player.RespawnAt(position, Quaternion.identity);
                return;
            }
            var ret = Interface.Call("CanTeleport", player) as string;
            if (ret != null)
            {
                SendReply(player, ret);
                return;
            }
            BaseMountable mount = player.GetMounted();
            if (mount != null) mount.DismountPlayer(player);
            if (player.net?.connection != null) player.ClientRPCPlayer(null, player, "StartLoading");
            player.StartSleeping();
            player.Teleport(position);
            player.SendFullSnapshot();
            if (player.net?.connection != null) player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, true);
            player.SendNetworkUpdateImmediate();
            player.UpdateNetworkGroup();

        }
        DynamicConfigFile homesFile = Interface.Oxide.DataFileSystem.GetFile("DVTeleportation/Homes");
        DynamicConfigFile tpsaveFile = Interface.Oxide.DataFileSystem.GetFile("DVTeleportation/AdminTpSave");
        public Dictionary<ulong, AutoTPASettings> AutoTPA = new Dictionary<ulong, AutoTPASettings>();

        public class AutoTPASettings
        {
            public bool Enabled;
            public Dictionary<string, ulong> PlayersList = new Dictionary<string, ulong>();
        }


        void LoadData()
        {
            try
            {
                tpsave = tpsaveFile.ReadObject<List<TPList>>();
                if (tpsave == null)
                {
                    PrintError("File AdminTpSave is null! Create new data files");
                    tpsave = new List<TPList>();
                }
                homes = homesFile.ReadObject<Dictionary<ulong, Dictionary<string, Vector3>>>();
                if (homes == null)
                {
                    PrintError("File Homes is null! Create new data files");
                    homes = new Dictionary<ulong, Dictionary<string, Vector3>>();
                }
                AutoTPA = Interface.GetMod().DataFileSystem.ReadObject<Dictionary<ulong, AutoTPASettings>>($"DVTeleportation/AutoTPA");

            }
            catch
            {
                tpsave = new List<TPList>();
                homes = new Dictionary<ulong, Dictionary<string, Vector3>>();
                AutoTPA = new Dictionary<ulong, AutoTPASettings>();
            }
        }
        void SaveData()
        {
            if (tpsave != null) tpsaveFile.WriteObject(tpsave);
            if (homes != null) homesFile.WriteObject(homes);
            if (AutoTPA != null) Interface.Oxide.DataFileSystem.WriteObject($"DVTeleportation/AutoTPA", AutoTPA);

        }
        Dictionary<string, string> Messages = new Dictionary<string, string>() {
                {
                "foundationmissing", "Фундамент не найден!"
            },


                {
                "buildingBrockmissing", "Создание местоположение разрешено только на строительных блоках"
            }
            ,
            {
                "InDuel", "Вы на Дуэли. Телепорт запрещен!"
            },
            {
                "InDuelTarget", "Игрок на Дуэли. Телепорт запрещен!"
            }
            ,
            {
                "foundationmissingR", "Фундамент не найден, местоположение было удалено!"
            }
            ,
            {
                "buildingBrockmissingR", "Строительный блок не найден, местоположение было удалено!"
            }
            ,
            {
                "playerisyou", "Нельзя отправлять телепорт самому себе!"
            }
            , {
                "maxhomes", "У вас максимальное кол-во местоположений!"
            }
            , {
                "homeexist", "Такое местоположение уже существует!"
            }
            , {
                "homesucces", "Местоположение {0} успешно установлено!"
            }
            , {
                "sethomeArgsError", "Для установки местоположения используйте /sethome ИМЯ"
            }
            , {
                "settpArgsError", "Для установки местоположения используйте /tpl add ИМЯ"
            }
            , {
                "homeArgsError", "Для телепортации на местоположение используйте /home ИМЯ"
            }
            , {
                "tpArgsError", "Для телепортации на местоположение используйте /tpl ИМЯ"
            }
            , {
                "tpError", "Запрещено! Вы в очереди на телепортацию"
            }
            , {
                "homenotexist", "Местоположение с таким названием не найдено!"
            }
            , {
                "homequeue", "Телепортация на {0} будет через {1}"
            }
            , {
                "tpwounded", "Вы получили ранение! Телепортация отменена!"
            }
            , {
                "tphomesuccess", "Вы телепортированы домой!"
            }
            , {
                "tplsuccess", "Вы успешно телепортированы!"
            }
            , {
                "tptpsuccess", "Вы телепортированы на указаное место!"
            }
            , {
                "homesmissing", "У вас нет доступных местоположений!"
            }
            , {
                "TPLmissing", "Для вас нет доступных местоположений!"
            }
            , {
                "TPLList", "Доступные точки местоположения:\n{0}"
            }
            , {
                "removehomeArgsError", "Для удаления местоположения используйте /removehome ИМЯ"
            }
            , {
                "removetpArgsError", "Для удаления местоположения используйте /tpl remove ИМЯ"
            }
            , {
                "removehomesuccess", "Местоположение {0} успешно удалено"
            }
            , {
                "sleepingbagmissing", "Спальный мешок не найден, местоположение удалено!"
            },
            {
                "sleepingbugbuildblock", "Вы не авторизованы в билде точки телепортации, местоположение удалено!"
            }
            , {
                "tprArgsError", "Для отправки запроса на телепортация используйте /tpr НИК"
            }
            , {
                "playermissing", "Игрок не найден"
            }
            , {
                "PlayerNotFriend", "Игрок не являеться Вашим другом! Телепорт запрещен!"
            }
            , {
                "tpspecError", "Не правильно введена команда. Используйте: /tpspec НИК"
            }
            , {
                "playermissingOff", "Игрок не в сети"
            }
            , {
                "playermissingOrDeath", "Игрок не найден, или он мёртв"
            }
            , {
                "playerItsYou", "Нельзя следить за самым собой"
            }
            , {
                " playerItsSpec", "Игрок уже за кем то наблюдает"
            }
            , {
                "tprrequestsuccess", "Запрос {0} успешно отправлен"
            }
            , {
                "tprpending", "{0} отправил вам запрос на телепортацию\nЧтобы принять используйте /tpa\nЧтобы отказаться используйте /tpc"
            }
            , {
                "tpanotexist", "У вас нет активных запросов на телепортацию!"
            }
            , {
                "tpqueue", "{0} принял ваш запрос на телепортацию\nВы будете телепортированы через {1}"
            }
            , {
                "tpc", "Телепортация успешно отменена!"
            }
            , {
                "tpctarget", "{0} отменил телепортацию!"
            }
            , {
                "tpplayersuccess", "Вы успешно телепортировались к {0}"
            }
            , {
                "tpasuccess", "Вы приняли запрос телепортации от {0}\nОн будет телепортирован через {1}"
            }
            , {
                "tppendingcanceled", "Запрос телепортации отменён"
            }
            , {
                "tpcupboard", "Телепортация в зоне действия чужого шкафа запрещена!"
            }, {
                "tpcupboardTarget", "Вы или игрок находитесь в зоне действия чужого шкафа!"
            }
            , {
                "tphomecupboard", "Телепортация домой в зоне действия чужого шкафа запрещена!"
            }
            , {
                "tpacupboard", "Принятие телепортации в зоне действия чужого шкафа запрещена!"
            }
            , {
                "sethomecupboard", "Установка местоположения в зоне действия чужого шкафа запрещена!"
            }
            , {
                "tpacanceled", "Вы не ответили на запрос."
            }
            , {
                "tpkd", "Телепортация на перезарядке!\nОсталось {0}"
            }
            , {
                "tpWoundedTarget", "Игрок ранен. Телепортация отменена!"
            }
            , {
                "woundedAction", "Вы ранены!"
            }
            , {
                "coldplayer", "Вам холодно!"
            }
            , {
                "Radiation", "Вы облучены радиацией!"
            }
            , {
                "sethomeBlock", "Нельзя использовать /sethome слишком часто, попробуйте позже!"
            }
            , {
                "foundationowner", "Нельзя использовать /sethome не на своих строениях!"
            }
            , {
                "foundationownerFC", "Создатель обьекта не являеться вашим соклановцем или другом, /sethome запрещен"
            }
            , {
                "homeslist", "Доступное количество местоположений: {0}\n{1}"
            }
            , {
                "tplist", "Ваши сохраненные метоположения:\n{0}"
            }
            , {
                "PlayerIsOnCargoShip", "Вы не можете телепортироваться на грузовом корабле."
            }
            , {
                "PlayerIsOnHotAirBalloon", "Вы не можете телепортироваться на воздушном шаре."
            }
            , {
                "InsideInFoundation", "Вы не можете устанавливать местоположение находясь в фундаменте"
            }
            , {
                "InsideInFoundationTP", "Телепортация запрещена, местоположение находится в фундаменте"
            }
            ,{
                "TPAPerm", "У Вас нету права использовать эту команду"
            },
            {
                "TPAEnabled", "Вы успешно <color=#FDAE37>включили</color> автопринятие запроса на телепорт\n{0}"
            },
             {
                "TPADisable", "Вы успешно <color=#FDAE37>отключили</color> автопринятие запроса на телепорт"
            },
            {
                "TPAEnabledInfo", "Добавление нового игрока <color=#FDAE37>/atp add Name/SteamID</color>\nУдаление игрока <color=#FDAE37>/atp remove Name</color>\nСписок игроков <color=#FDAE37>/apt list</color>"
            },
            {
                "TPAEnabledList", "Список игроков для каких у Вас включен автоматический приём телепорта:\n{0}"
            },
            {
                "TPAEListNotFound", "Вы пока еще не добавили не одного игрока в список, используйте <color=#FDAE37>/atp add Name/SteamID</color>"
            },
            {
                "TPAEAddError", "Вы не указали игрока, используйте <color=#FDAE37>/atp add Name/SteamID</color>"
            },{
                "TPARemoveError", "Вы не указали игрока, используйте <color=#FDAE37>/atp remove Name</color>"
            },
            {
                "TPARemoveNotFound", "Игрока <color=#FDAE37>{0}</color> нету в списке, используйте <color=#FDAE37>/atp remove Name</color>"
            },
            {
                "TPAEAddPlayerNotFound", "Игрок не найден! Попробуйте уточнить <color=#FDAE37>имя</color>"
            },
            {
                "TPAEAddSuccess", "Игрок <color=#FDAE37>{0}</color> успешно добавлен в список"
            },
            {
                "TPAEAddContains", "Игрок <color=#FDAE37>{0}</color> уже добавлен в список"
            },
            {
                "TPAERemoveSuccess", "Игрок <color=#FDAE37>{0}</color> успешно удален со списка"
            },
            {
                "TPAEAddPlayers", "Найдено <color=#FDAE37>несколько</color> игроков с похожим ником:\n{0}"
            },
            {
                "TPASuccess", "Вы <color=#FDAE37>автоматически</color> приняли запрос на телепортацию так как у вас игрок в списке разрешенных."
            },
            {
                "TeleportaCancelHeli", "Телепорт отменен, кто то из игроков использует транспортное средство."
            },
            {
            "TimerTextPlayer1", "ТЕЛЕПОРТ АКТИВИРОВАН: ОСТАЛОСЬ ЖДАТЬ - <b>{0}</b>"
            },
            {
                "TimerTextPlayer2", "ТЕЛЕПОРТ К ВАМ: ОЖИДАНИЕ ОТВЕТА - <b>{0}</b>"
            },
            {
                "PendingTextPlayer1", "ТЕЛЕПОРТ ОТПРАВЛЕН: ОЖИДАНИЕ ОТВЕТА - <b>{0}</b>"
            },
            {
                "PendingTextPlayer2", "ОСТАЛОСЬ ЖДАТЬ - <b>{0}</b>"
            }
        };
        #region TPAcceptUI
        void CreateUpdateUI(BasePlayer player, DVTeleportation.TP teleport, string langMessage = "PendingTextPlayer1")
        {
            CuiHelper.DestroyUi(player, "Teleport");
            CuiElementContainer container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.3447913 0.112037", AnchorMax = "0.640625 0.1393229", OffsetMax = "0 0" },
                Image = { Color = "1 1 1 0.15" }
            }, "Hud", "Teleport");
            container.Add(new CuiElement
            {
                Parent = "Teleport",
                Name = "Teleport.Update",
                Components =
                {
                    new CuiImageComponent { Color = "0.84 0.25 0.78 0.95" },
                    new CuiRectTransformComponent {AnchorMin = $"0 0", AnchorMax = $"{(float) (teleport.totalSeconds - (teleport.totalSeconds - teleport.seconds)) / teleport.totalSeconds} 1", OffsetMin = "0 0", OffsetMax = "0 0"},
                }
            });
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Text = { Text = string.Format(Messages[langMessage], GetFormatTime(TimeSpan.FromSeconds(teleport.totalSeconds - (teleport.totalSeconds - teleport.seconds)))), Font = "robotocondensed-regular.ttf", Color = "1 1 1 0.9", FontSize = 14, Align = TextAnchor.MiddleCenter }
            }, "Teleport", "Teleport" + ".Info");
            CuiHelper.AddUi(player, container);
        }
        private string GetFormatTime(TimeSpan timespan)
        {
            return string.Format(timespan.TotalHours >= 1 ? "{2:00}:{0:00}:{1:00}" : "{0:00}:{1:00}", timespan.Minutes, timespan.Seconds, System.Math.Floor(timespan.TotalHours));
        }

        public static string PARENT_TELEPORT = "PARENT_DVTeleportation_UI";
        void DVTeleportationAcceptUI(BasePlayer target, string TprName)
        {
            CuiElementContainer container = new CuiElementContainer();
            CuiHelper.DestroyUi(target, PARENT_TELEPORT);

            container.Add(new CuiPanel
            {
                // RectTransform = { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = "-400 16", OffsetMax = "-210 98" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = "130 18", OffsetMax = "350 98" },
                Image = { Color = HexToRustFormat("#000000"), Material = "assets/content/ui/uibackgroundblur.mat" } //  //"#d02424B1" "#544E44FF"
            }, "Overlay", PARENT_TELEPORT);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.01 0.02", AnchorMax = "0.99 0.75" },
                Image = { Color = HexToRustFormat("#F65050"), Material = "assets/content/ui/uibackgroundblur.mat" } // , #bdb4ab #4b98d0
            }, PARENT_TELEPORT, "TWO_PANEL");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.009999931 0.7777777", AnchorMax = "1 1" },
                Text = { Text = $"<size=12><b>Запрос от {TprName}</b></size>", Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter }
            }, PARENT_TELEPORT);

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.5814307", AnchorMax = "1 1" },
                Text = { Text = $"<size=20><b>ПРИНЯТЬ ТЕЛЕПОРТ?</b></size>", Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter, Color = HexToRustFormat("#FFFFFFFF") }
            }, "TWO_PANEL");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.03079109 0.09436831", AnchorMax = "0.4158611 0.4517729" },
                Button = { Close = PARENT_TELEPORT, Command = "chat.say /tpa", Color = HexToRustFormat("#8b3131FF"), Material = "assets/content/ui/uibackgroundblur.mat" },
                Text = { Text = "<color=#FFFFFF><b>☑ ПРИНЯТЬ</b></color>", Align = TextAnchor.MiddleCenter }
            }, "TWO_PANEL");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.5857509 0.09436831", AnchorMax = "0.9708213 0.4517729" },
                Button = { Close = PARENT_TELEPORT, Command = "chat.say /tpc", Color = HexToRustFormat("#d02424FF"), Material = "assets/content/ui/uibackgroundblur.mat" },
                Text = { Text = "<color=#FFFFFF><b>☒ ОТМЕНА</b></color>", Align = TextAnchor.MiddleCenter } //#FF1400FF //#FF2E00FF
            }, "TWO_PANEL");

            CuiHelper.AddUi(target, container);
        }
        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            UnityEngine.Color color = new Color32(r, g, b, a);

            return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
        }
        #endregion
    }
}

// --- End of file: DVTeleportation.cs ---
// --- Next file ---

