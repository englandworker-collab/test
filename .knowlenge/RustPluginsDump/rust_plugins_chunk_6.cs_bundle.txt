resources" : "Зачислять ХР за подбор ресурсов")] public bool PickupValide;
				[JsonProperty(LanguageEnglish ? "Display the level in prefix" : "Отображать уровень в префиксе")] public bool ChatPrefixLevel;
				[JsonProperty(LanguageEnglish ? "XP for opening crates" : "Зачислять ХР за открытие ящиков")] public bool CrateValide;
				[JsonProperty(LanguageEnglish ? "List of available ranks - [ Level - Rank ] ( If the list is empty, then the rank will not be displayed in the menu )" : "Список доступных рангов - [ Уровень - Ранг ] ( Если список пуст, то ранг не будет отображаться в меню )")] public Dictionary<int, string> RankList;
				[JsonProperty(LanguageEnglish ? "XP for kill" : "Зачислять ХР за убийство")] public bool KillValide;
				[JsonProperty(LanguageEnglish ? "Display the rank in prefix" : "Отображать ранг в префиксе")] public bool ChatPrefixRank;
				[JsonProperty(LanguageEnglish ? "Include messages of received rewards in chat" : "Включить сообщения полученных  наград в чат")] public bool ChatTakeMessages;
				[JsonProperty(LanguageEnglish ? "Enable prefix in chat - [ Set to False if the prefix should be disabled or the prefix is used by a third party chat plugin ]" : "Включить префикс в чате - [ Установите False, если префикс нужно отключить или префикс используется сторонним плагином для чата ]")] public bool ChatPrefix;
				[JsonProperty(LanguageEnglish ? "There is a plugin for custom loot" : "Есть плагин на кастомный лут")] public bool PluginCLoot;
				[JsonProperty(LanguageEnglish ? "XP for harvest" : "Зачислять ХР за сбор урожая")] public bool HarvestValide;
				[JsonProperty(LanguageEnglish ? "Reset the level and XP of the player after reaching the maximum level - [ Players will re-open levels and receive rewards ]" : "Обнулять уровень и ХР игрока после достижения максимального уровня - [ Игроки повторно будет открывать уровни и получать награды ]")] public bool ClearAll;
				[JsonProperty(LanguageEnglish ? "Profile SteamID for custom avatar" : "SteamID профиля для кастомной аватарки")] public ulong SteamID;
				[JsonProperty(LanguageEnglish ? "Take VIP Reward - [ True - take only with permission | False - take at any time without permission ]" : "Забрать ВИП награду - [ True - забрать только с пермишеном | False - забрать в любое время без пермишена ]")] public bool TakeReward;
				[JsonProperty(LanguageEnglish ? "Get VIP reward - [ True - only with permission | False - without permission ]" : "Получить ВИП награду - [ True - только с пермишеном | False - без пермишена ]")] public bool MoveReward;
				[JsonProperty(LanguageEnglish ? "Enable VIP rewards" : "Включить ВИП награды")] public bool VIPValide;
				[JsonProperty(LanguageEnglish ? "XP for bonus resources" : "Зачислять ХР за бонусные ресурсы")] public bool BonusValide;
				[JsonProperty(LanguageEnglish ? "Include level up messages in chat" : "Включить сообщения повышения уровня в чат")] public bool ChatLevelMessages;
				[JsonProperty(LanguageEnglish ? "Exchange coupons if you have already reached the maximum level - [ Suitable for top players ]" : "Обменивать купоны если уже достигнут максимальный уровень - [ Подходит для топа игроков ]")] public bool GiveXPCoupon;
				[JsonProperty(LanguageEnglish ? "Add XP if the maximum level is already reached - [ Suitable for top players ]" : "Засчитывать ХР если уже достигнут максимальный уровень - [ Подходит для топа игроков ]")] public bool GiveXP;
				[JsonProperty(LanguageEnglish ? "Enable coupons" : "Включить купоны")] public bool CouponsValide;
			}	
			[JsonProperty(LanguageEnglish ? "XP settings | Shortname : ValueXP" : "Настройка ХР | Shortname : ValueXP")]
            public XPSetting XP = new XPSetting();
			[JsonProperty(LanguageEnglish ? "Level reward" : "Награда за уровни")]
			public Dictionary<int, Awards> Award;			
			
			public static LevelConfig GetNewConfiguration()
            {
                return new LevelConfig
                {
					Setting = new GeneralSetting
					{
						PickupValide = true,
						HarvestValide = true,
						BonusValide = true,
						KillValide = true,
						CrateValide = true,
						ChatTakeMessages = true,
						ChatLevelMessages = true,
						CouponsValide = true,  
						VIPValide = true,
						MoveReward = true,
						TakeReward = true,
						GiveXP = false,
						GiveXPCoupon = false,
						ClearAll = false,
						PluginCLoot = false,
						SteamID = 0,
						CommandList = new List<string>
						{
							"level",
							"lvl",
							"pass"
						},
						ChatPrefix = true,
						ChatPrefixLevel = true,
						ChatPrefixRank = true,
						RankList = LanguageEnglish ? new Dictionary<int, string>
						{
							[0] = "CAP-Х",
							[1] = "IRON-1",
							[2] = "IRON-2",
							[3] = "IRON-3",
							[4] = "BRONZE-1",
							[5] = "BRONZE-2",
							[6] = "BRONZE-3",
							[7] = "SILVER-1",
							[8] = "SILVER-2",
							[9] = "SILVER-3",
							[10] = "GOLD-1",
							[11] = "GOLD-2",
							[12] = "GOLD-3",
							[13] = "PLATINUM-1",
							[14] = "PLATINUM-2",
							[15] = "PLATINUM-3",
							[16] = "DIAMOND-1",
							[17] = "DIAMOND-2",
							[18] = "DIAMOND-3",
							[19] = "IMMORTAL-1",
							[20] = "IMMORTAL-2",
							[21] = "IMMORTAL-3",
							[22] = "RADIANT-1",
							[23] = "RADIANT-2",
							[24] = "RADIANT-3",
							[25] = "GOD"
						} : new Dictionary<int, string>
						{
							[0] = "КЕПКА-Х",
							[1] = "ЖЕЛЕЗО-1",
							[2] = "ЖЕЛЕЗО-2",
							[3] = "ЖЕЛЕЗО-3",
							[4] = "БРОНЗА-1",
							[5] = "БРОНЗА-2",
							[6] = "БРОНЗА-3",
							[7] = "СЕРЕБРО-1",
							[8] = "СЕРЕБРО-2",
							[9] = "СЕРЕБРО-3",
							[10] = "ЗОЛОТО-1",
							[11] = "ЗОЛОТО-2",
							[12] = "ЗОЛОТО-3",
							[13] = "ПЛАТИНА-1",
							[14] = "ПЛАТИНА-2",
							[15] = "ПЛАТИНА-3",
							[16] = "АЛМАЗ-1",
							[17] = "АЛМАЗ-2",
							[18] = "АЛМАЗ-3",
							[19] = "БЕССМЕРТНЫЙ-1",
							[20] = "БЕССМЕРТНЫЙ-2",
							[21] = "БЕССМЕРТНЫЙ-3",
							[22] = "РАДИАНТ-1",
							[23] = "РАДИАНТ-2",
							[24] = "РАДИАНТ-3",
							[25] = "БОГ"
						}
					},
					Vending = new VendingSetting
					{
						VendingOpen = false,
						VendingUse = false,
						ListNPCVending = new List<string>
						{
							"Black Market"
						}
					},	
					XPRate = new XPRateSetting
					{
						XPRateCoupon = false,
						XPRatePermisssion = new Dictionary<string, float>
						{
							["xlevels.125p"] = 2.25f,
							["xlevels.75p"] = 1.75f,
							["xlevels.10p"] = 1.1f
						}
					},
					Online = new OnlineSetting
					{
						OnlineXP = false,
						TimeXP = 15.0f,
						Permisssion = new Dictionary<string, float>
						{
							["xlevels.default"] = 5.0f
						}
					},
					GUI = new GUISetting
					{
						AnchorMin = "1 0",
						AnchorMax = "1 0",
						OffsetMin = "-403 16",
						OffsetMax = "-210 42",
						EnablePanel = true,
						ColorBackgroundO = "0.51 0.52 0.50 0.95",
						ColorBackgroundT = "0.21 0.22 0.20 0.95",
						ContainerReward = false,
						RewardNumber = true,
						RewardNumberVIP = true
					},
					Level = new LevelSetting
					{
						LevelMax = 25,
						LevelXP = 100,
						LevelXPUP = 25
					},
					XP = new XPSetting
					{
						PickupXP = new Dictionary<string, float>
						{
							["stones"] = 10.0f,
							["sulfur.ore"] = 15.0f,
							["metal.ore"] = 12.5f
						},
						HarvestXP = new Dictionary<string, float>
						{
							["potato.entity"] = 2.5f,
							["corn.entity"] = 1.75f,
							["hemp.emtity"] = 0.25f
						},
						GatherBonusXP = new Dictionary<string, float>
						{
							["stones"] = 5.0f,
							["sulfur.ore"] = 10.0f,
							["metal.ore"] = 7.5f
						},
						KillXP = new Dictionary<string, float>
						{
							["boar"] = 10.0f, 
							["loot-barrel-1"] = 7.5f,
							["heavyscientist"] = 2.5f
						},
						CrateXP = new Dictionary<string, float>
						{ 
							["crate_normal"] = 5.0f,
							["crate_normal_2"] = 1.0f,
							["crate_tools"] = 3.5f
						}
					},
					Coupon = LanguageEnglish ? new List<Coupons>
					{
						new Coupons("Coupon 5ХР", "Coupon for 5ХР\n\nExchange them and get XP to level up!\n\nCommand for exchange - /level", 2925118427, 5, new List<Crates>{ new Crates("crate_normal_2", 50.0f, 1, 3) }),
						new Coupons("Coupon 10ХР", "Coupon for 10ХР\n\nExchange them and get XP to level up!\n\nCommand for exchange - /level", 2925118536, 10, new List<Crates>{ new Crates("crate_normal_2", 50.0f, 1, 3) }),
						new Coupons("Coupon 25ХР", "Coupon for 25ХР\n\nExchange them and get XP to level up!\n\nCommand for exchange - /level", 2925118910, 25, new List<Crates>{ new Crates("crate_normal_2", 50.0f, 1, 2) }),
						new Coupons("Coupon 50ХР", "Coupon for 50ХР\n\nExchange them and get XP to level up!\n\nCommand for exchange - /level", 2925119087, 50, new List<Crates>{ new Crates("crate_normal_2", 50.0f, 1, 2) }),
						new Coupons("Coupon 100ХР", "Coupon for 100ХР\n\nExchange them and get XP to level up!\n\nCommand for exchange - /level", 2925119157, 100, new List<Crates>{ new Crates("crate_normal_2", 50.0f, 1, 1) }),
						new Coupons("Coupon 200ХР", "Coupon for 200ХР\n\nExchange them and get XP to level up!\n\nCommand for exchange - /level", 2925119248, 200, new List<Crates>{ new Crates("crate_normal_2", 50.0f, 1, 1) }),
						new Coupons("Coupon 500ХР", "Coupon for 500ХР\n\nExchange them and get XP to level up!\n\nCommand for exchange - /level", 2925119644, 500, new List<Crates>{ new Crates("crate_normal_2", 50.0f, 1, 1) })
					} : new List<Coupons>
					{
						new Coupons("Купон 5ХР", "Купон на 5ХР\n\nОбменяйте его и получите ХР для повышения уровня!\n\nКоманда для обмена - /level", 2925118427, 5, new List<Crates>{ new Crates("crate_normal_2", 50.0f, 1, 3) }),
						new Coupons("Купон 10ХР", "Купон на 10ХР\n\nОбменяйте его и получите ХР для повышения уровня!\n\nКоманда для обмена - /level", 2925118536, 10, new List<Crates>{ new Crates("crate_normal_2", 50.0f, 1, 3) }),
						new Coupons("Купон 25ХР", "Купон на 25ХР\n\nОбменяйте его и получите ХР для повышения уровня!\n\nКоманда для обмена - /level", 2925118910, 25, new List<Crates>{ new Crates("crate_normal_2", 50.0f, 1, 2) }),
						new Coupons("Купон 50ХР", "Купон на 50ХР\n\nОбменяйте его и получите ХР для повышения уровня!\n\nКоманда для обмена - /level", 2925119087, 50, new List<Crates>{ new Crates("crate_normal_2", 50.0f, 1, 2) }),
						new Coupons("Купон 100ХР", "Купон на 100ХР\n\nОбменяйте его и получите ХР для повышения уровня!\n\nКоманда для обмена - /level", 2925119157, 100, new List<Crates>{ new Crates("crate_normal_2", 50.0f, 1, 1) }),
						new Coupons("Купон 200ХР", "Купон на 200ХР\n\nОбменяйте его и получите ХР для повышения уровня!\n\nКоманда для обмена - /level", 2925119248, 200, new List<Crates>{ new Crates("crate_normal_2", 50.0f, 1, 1) }),
						new Coupons("Купон 500ХР", "Купон на 500ХР\n\nОбменяйте его и получите ХР для повышения уровня!\n\nКоманда для обмена - /level", 2925119644, 500, new List<Crates>{ new Crates("crate_normal_2", 50.0f, 1, 1) })
					},
					Award = new Dictionary<int, Awards>
					{
						[1] = new Awards("wood", "Wood", 1250, 0, "", "", false),
						[2] = new Awards("charcoal", "Charcoal", 1500, 0, "", "", false),
						[3] = new Awards("metal.ore", "Metal ore", 1000, 0, "", "", false),
						[4] = new Awards("metal.fragments", "Metal fragments", 750, 0, "", "", false),
						[5] = new Awards("sulfur.ore", "Sulfur ore", 500, 0, "", "", false),
						[6] = new Awards("sulfur", "Sulfur", 300, 0, "", "", false),
						[7] = new Awards("gunpowder", "Gunpowder", 400, 0, "", "", false),
						[8] = new Awards("hq.metal.ore", "HQM ore", 25, 0, "", "", false), 
						[9] = new Awards("metal.refined", "HQM", 20, 0, "", "", false),
						[10] = new Awards("scrap", "Scrap", 50, 0, "", "", false)
					},					
					AwardVip = new Dictionary<int, Awards>
					{
						[1] = new Awards("wood", "Wood", 1250, 0, "", "", false),
						[2] = new Awards("charcoal", "Charcoal", 1500, 0, "", "", false),
						[3] = new Awards("metal.ore", "Metal ore", 1000, 0, "", "", false),
						[4] = new Awards("metal.fragments", "Metal fragments", 750, 0, "", "", false),
						[5] = new Awards("sulfur.ore", "Sulfur ore", 500, 0, "", "", false),
						[6] = new Awards("sulfur", "Sulfur", 300, 0, "", "", false),
						[7] = new Awards("gunpowder", "Gunpowder", 400, 0, "", "", false),
						[8] = new Awards("hq.metal.ore", "HQM ore", 25, 0, "", "", false), 
						[9] = new Awards("metal.refined", "HQM", 20, 0, "", "", false),
						[10] = new Awards("scrap", "Scrap", 50, 0, "", "", false)
					}
				};
			}
			
			internal class Crates
			{ 
				[JsonProperty(LanguageEnglish ? "Name crate/barrel" : "Имя ящика/бочки")] public string NameCrate;				
				[JsonProperty(LanguageEnglish ? "Drop chance" : "Шанс выпадения")] public float ChanceDrop;				
				[JsonProperty(LanguageEnglish ? "Minimum amount of coupons" : "Минимальное количество купона")] public int CouponMin;				
				[JsonProperty(LanguageEnglish ? "Maximum number of coupons" : "Максимальное количество купона")] public int CouponMax;	

                public Crates(string namecrate, float chancedrop, int cmin, int cmax)
				{
					NameCrate = namecrate; ChanceDrop = chancedrop; CouponMin = cmin; CouponMax = cmax;
				}				
			}	
			
			internal class LevelSetting
			{
				[JsonProperty(LanguageEnglish ? "Maximum level" : "Максимальный уровень")] public int LevelMax;				
				[JsonProperty(LanguageEnglish ? "Number of XP to upgrade one level" : "Кол-во ХР для повышения одного уровня")] public float LevelXP;									
				[JsonProperty(LanguageEnglish ? "How much to increase the number of XP with each level" : "На сколько увеличивать кол-во ХР с каждым уровнем")] public float LevelXPUP;									
			}
			[JsonProperty(LanguageEnglish ? "Mini-bar location / Main menu settings" : "Расположение мини-панели / Настройки главного меню")]
            public GUISetting GUI = new GUISetting();
		   		 		  						  	   		  	   		  	   		   		 		  		  
			internal class XPRateSetting
			{
				[JsonProperty(LanguageEnglish ? "Enable XP multiplier when exchanging coupons - [ This parameter affects only the multipliers for the exchange of coupons ]" : "Включить множитель XP при обмене купонов - [ Данный параметр влияет только на множители для обмена купонов ]")] public bool XPRateCoupon;
				[JsonProperty(LanguageEnglish ? "Setting up permissions for XP multipliers for the exchange of coupons and other actions. [ Permission | XP multiplier ]" : "Настройка пермишенов для умножителей ХР на обмен купонов и других действий. [ Пермишен | Множитель XP ]")] public Dictionary<string, float> XPRatePermisssion = new Dictionary<string, float>();
			}			

			internal class Awards
			{
				[JsonProperty(LanguageEnglish ? "Item shortname / custom reward name [ Must not be empty ]" : "Шортнейм предмета / имя кастомной награды [ Не должно быть пустым ]")] public string Shortname;
                [JsonProperty(LanguageEnglish ? "Reward display name" : "Отображаемое имя награды")] public string Name;
                [JsonProperty(LanguageEnglish ? "Item quantity" : "Количество предмета")] public int Amount;
				[JsonProperty(LanguageEnglish ? "Item skin" : "Скин предмета")] public ulong SkinID;
				[JsonProperty(LanguageEnglish ? "Command" : "Команда")] public string Command;
				[JsonProperty(LanguageEnglish ? "Link to custom image" : "Ссылка на кастомную картинку")] public string URLImage;
				[JsonProperty(LanguageEnglish ? "Hide reward - [ Reward will not be displayed until the player reaches this level ]" : "Скрыть награду - [ Награда не будет отображаться пока игрок не достигнет данного уровня ]")] public bool Hide;
		   		 		  						  	   		  	   		  	   		   		 		  		  
                public Awards(string shortname, string name, int amount, ulong skinid, string command, string urlimage, bool hide)
                {
                    Shortname = shortname; Name = name; Amount = amount; SkinID = skinid; Command = command; URLImage = urlimage; Hide = hide;
                }
			}			
        }
		
		private void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
		{
			if(!config.Setting.KillValide) return;
			if(entity == null) return;
			
			BasePlayer player = info?.InitiatorPlayer;
			
			if(player == null || player.IsNpc) return;
			
			if(config.XP.KillXP.ContainsKey(entity.ShortPrefabName))
				XPRateRerm(player, config.XP.KillXP[entity.ShortPrefabName]);
		}

        		
				
		private int API_GetLevel(BasePlayer player) => StoredData.ContainsKey(player.userID) ? StoredData[player.userID].Level : 0;
		private int API_GetLevel(ulong userID) => StoredData.ContainsKey(userID) ? StoredData[userID].Level : 0;
		
		private void RewardMenu(BasePlayer player, int Page = 0)
		{
            CuiElementContainer container = new CuiElementContainer();			
			
			container.Add(new CuiPanel
            {
				RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 142.5", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0" }
            }, ".LevelO_Overlay", ".Pass", ".Pass");
			 
			int count = Page * 10;
			int x = 0, g = 0, z = 0 + count, zvip = 0 + count;
			var data = StoredData[player.userID];
			bool vipvalide = config.Setting.VIPValide;
			
			for(int i = 1 + count; i <= 10 + count; i++)
			{		
				bool icon = data.Level >= i, contains = config.Award.ContainsKey(i), containerreward = config.GUI.ContainerReward;
				
				if(!containerreward || containerreward && contains)
				{
					container.Add(new CuiPanel
					{
						RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"{-475 + (x * 95)} {(vipvalide ? -31.25 : -82.5)}", OffsetMax = $"{-380 + (x * 95)} {(vipvalide ? 63.75 : 12.5)}" },
						Image = { Color = "0 0 0 0" }
					}, ".Pass", ".Award");
		   		 		  						  	   		  	   		  	   		   		 		  		  
					container.Add(new CuiPanel
					{
						RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "2.5 2.5", OffsetMax = "-2.5 -2.5" },
						Image = { Color = "0.41 0.42 0.40 0.95", Material = "assets/content/ui/uibackgroundblur.mat" }
					}, ".Award", ".Awards");

					container.Add(new CuiPanel
					{
						RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "45 -10", OffsetMax = "-45 -92.5" },
						Image = { Color = "0.41 0.42 0.40 0.95", Material = "assets/content/ui/uibackgroundblur.mat" }
					}, ".Award");
				
					if(contains)
					{
						var award = config.Award[i];
						
						if(award.Hide && !icon)
							container.Add(new CuiPanel
							{
								RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "7.5 7.5", OffsetMax = "-7.5 -7.5" },
								Image = { Color = "0.31 0.32 0.30 0.8", Sprite = "assets/icons/blunt.png" },
							}, ".Awards");
						else
						{
							container.Add(new CuiElement
							{
								Parent = ".Awards",
								Components =
								{
									new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", award.Shortname + award.SkinID + (award.URLImage == String.Empty ? 150 : 151)) },
									new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "7.5 7.5", OffsetMax = "-7.5 -7.5" }
								}
							});		
					
							container.Add(new CuiLabel
							{
								RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "-2.5 0" },
								Text = { Text = award.Amount == 0 ? "" : $"x{award.Amount}", Align = TextAnchor.LowerRight, FontSize = 12, Color = "1 1 1 0.75" }
							}, ".Awards");
						}
					}
					
					if(icon)
						container.Add(new CuiElement
						{
							Parent = ".Awards",
							Components =
							{
								new CuiImageComponent { Color = "0.38 0.61 0.99 1", Sprite = "assets/icons/check.png" },
								new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "25 25", OffsetMax = "-25 -25" },
								new CuiOutlineComponent { Color = "0 0 0 1", Distance = "-1 1" }
							}
						});
					else if(config.GUI.RewardNumber)
						container.Add(new CuiElement
						{
							Parent = ".Awards",
							Components = 
							{
								new CuiTextComponent { Text = $"{i}", Align = TextAnchor.MiddleCenter, FontSize = 35, Color = "0.38 0.61 0.99 1" },
								new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
								new CuiOutlineComponent { Color = "0 0 0 1", Distance = "-1 1" }
							}
						});
				}
				
				x++;
				z++;
				
				if(z == config.Level.LevelMax)
					break;
			}

			bool permvip = permission.UserHasPermission(player.UserIDString, permVip);
			
			if(vipvalide)
				for(int i = 1 + count; i <= 10 + count; i++)
				{		
					bool icon = data.Level >= i, contains = config.AwardVip.ContainsKey(i), containerreward = config.GUI.ContainerReward;
					
					if(!containerreward || containerreward && contains)
					{
						container.Add(new CuiPanel
						{
							RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"{-475 + (g * 95)} -166.25", OffsetMax = $"{-380 + (g * 95)} -71.25" },
							Image = { Color = "0 0 0 0" }
						}, ".Pass", ".Award");
		   		 		  						  	   		  	   		  	   		   		 		  		  
						container.Add(new CuiPanel
						{
							RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "2.5 2.5", OffsetMax = "-2.5 -2.5" },
							Image = { Color = permvip ? "0.41 0.42 0.40 0.95" : "0.41 0.42 0.40 0.25", Material = "assets/content/ui/uibackgroundblur.mat" }
						}, ".Award", ".Awards");
		   		 		  						  	   		  	   		  	   		   		 		  		  
						container.Add(new CuiPanel
						{
							RectTransform = { AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-2.5 -2.5", OffsetMax = "2.5 10" },
							Image = { Color = permvip ? "0.41 0.42 0.40 0.95" : "0.41 0.42 0.40 0.25", Material = "assets/content/ui/uibackgroundblur.mat" }
						}, ".Award");
				
						if(contains)
						{
							var awardvip = config.AwardVip[i];
							
							if(awardvip.Hide && !icon)
								container.Add(new CuiPanel
								{
									RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "7.5 7.5", OffsetMax = "-7.5 -7.5" },
									Image = { Color = permvip ? "0.31 0.32 0.30 0.8" : "0.51 0.52 0.50 0.4", Sprite = "assets/icons/blunt.png" },
								}, ".Awards");
							else
							{
								container.Add(new CuiElement
								{
									Parent = ".Awards",
									Components =
									{
										new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", awardvip.Shortname + awardvip.SkinID + (awardvip.URLImage == String.Empty ? 150 : 151)), Color = permvip ? "1 1 1 1" : "1 1 1 0.5" },
										new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "7.5 7.5", OffsetMax = "-7.5 -7.5" }
									}
								});		
				
								container.Add(new CuiLabel
								{
									RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "-2.5 0" },
									Text = { Text = awardvip.Amount == 0 ? "" : $"x{awardvip.Amount}", Align = TextAnchor.LowerRight, FontSize = 12, Color = permvip ? "1 1 1 0.75" : "1 1 1 0.37" }
								}, ".Awards");
							}
						}
						
						if(icon)
							container.Add(new CuiElement
							{
								Parent = ".Awards",
								Components =
								{
									new CuiImageComponent { Color = "0.38 0.61 0.99 1", Sprite = "assets/icons/check.png" },
									new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "25 25", OffsetMax = "-25 -25" },
									new CuiOutlineComponent { Color = "0 0 0 1", Distance = "-1 1" }
								}
							});
						else if(config.GUI.RewardNumberVIP)
							container.Add(new CuiElement
							{
								Parent = ".Awards",
								Components =
								{
									new CuiTextComponent { Text = $"{i}", Align = TextAnchor.MiddleCenter, FontSize = 35, Color = "0.38 0.61 0.99 1" },
									new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
									new CuiOutlineComponent { Color = "0 0 0 1", Distance = "-1 1" }
								}
							});
					}
					
					g++;
					zvip++;
				
					if(zvip == config.Level.LevelMax)
						break;
				}
			 
			bool back = Page != 0;
			bool next = config.Level.LevelMax > ((Page + 1) * 10);
			
			container.Add(new CuiButton 
            {    
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-190 -137.5", OffsetMax = "-100 -112.5" },
                Button = { Color = back ? "0.65 0.29 0.24 1" : "0.65 0.29 0.24 0.4", Command = back ? $"level page_lvl back {Page}" : "" },
                Text = { Text = lang.GetMessage("BACK", this, player.UserIDString), Align = TextAnchor.MiddleCenter, FontSize = 16, Font = "robotocondensed-regular.ttf", Color = back ? "0.92 0.79 0.76 1" : "0.92 0.79 0.76 0.4" }
            }, ".Pass");				 			
			
			container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-95 -137.5", OffsetMax = "-5 -112.5" },
                Button = { Color = next ? "0.35 0.45 0.25 1" : "0.35 0.45 0.25 0.4", Command = next ? $"level page_lvl next {Page}" : "" },
                Text = { Text = lang.GetMessage("NEXT", this, player.UserIDString), Align = TextAnchor.MiddleCenter, FontSize = 16, Font = "robotocondensed-regular.ttf", Color = next ? "0.75 0.95 0.41 1" : "0.75 0.95 0.41 0.4" }
            }, ".Pass");
			
			container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"-522.5 {(vipvalide ? -61.25 : -112.5)}", OffsetMax = $"522.5 {(vipvalide ? -41.25 : -92.5)}" },
                Image = { Color = "0.5 0.5 0.5 0.45" }
            }, ".Pass", ".Pass_Level");
			
			float y = (data.Level - (Page * 10.0f)) / 10.0f;
			
			container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0 1", OffsetMin = "0 0", OffsetMax = y >= 1 ? "1045 0" : y < 0 ? "0 0" : $"{95 * (data.Level % 10)} 0" },
                Image = { Color = "0.5 0.5 0.5 0.9" }
            }, ".Pass_Level");
			 
			container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Text = { Text = string.Format(lang.GetMessage(data.Level >= config.Level.LevelMax ? "Level_2" : "Level", this, player.UserIDString), data.Level, config.Level.LevelMax, data.XP, data.Level * config.Level.LevelXPUP + config.Level.LevelXP, config.Setting.RankList.Count == 0 ? String.Empty : string.Format(lang.GetMessage("RANK", this, player.UserIDString), config.Setting.RankList.ContainsKey(data.Level) ? config.Setting.RankList[data.Level] : "∞")), Align = TextAnchor.MiddleCenter, FontSize = 13, Color = "1 1 1 0.75" }
            }, ".Pass_Level");
			
			CuiHelper.AddUi(player, container);
		}
		
		private void SaveData(BasePlayer player) => Interface.Oxide.DataFileSystem.WriteObject($"XDataSystem/XLevels/InvItems/{player.userID}", StoredDataInv[player.userID]);
		
		private void LootSpawn(LootContainer lootContainer)
		{
			var cfg = config.Coupon; 
			
			for(int i = 0; i < cfg.Count; i++)
				for(int j = 0; j < cfg[i].Crate.Count; j++)
				{
					var crate = cfg[i].Crate[j];
					
					if(crate.NameCrate == lootContainer.ShortPrefabName)
					    if(UnityEngine.Random.Range(0, 100) <= crate.ChanceDrop)
                        {
                            Item item = ItemManager.CreateByItemID(1414245162, UnityEngine.Random.Range(crate.CouponMin, crate.CouponMax), cfg[i].SkinID);
                            item.name = cfg[i].Name;
                            item.text = cfg[i].Text;
								
                            item.MoveToContainer(lootContainer.inventory);
                        }
				}
		}
		
		[ConsoleCommand("level_give_xp")]
		private void ccmdGiveXP(ConsoleSystem.Arg arg)
		{
			BasePlayer player = arg.Player();
			
			if(player == null || player.IsAdmin)
			{
				ulong steamID = Convert.ToUInt64(arg.Args[0]);
				BasePlayer rplayer = BasePlayer.FindByID(steamID);
				float xp = Convert.ToSingle(arg.Args[1]);
				
				if(rplayer != null)
					AddData(rplayer, xp);
				else
					PrintWarning(LanguageEnglish ? $"Error give XP to the player - [ {steamID} ] - maybe it's offline!" : $"Ошибка выдачи XP игроку - [ {steamID} ] - возможно он оффлайн!");
			}
		}
		
		private void InventoryRewardMenu(BasePlayer player, int Page = 0)
		{
            CuiElementContainer container = new CuiElementContainer();
			
			container.Add(new CuiPanel
            {
				RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 40", OffsetMax = "0 0" },
                Image = { Color = "0.21 0.22 0.20 1" }
            }, ".LevelO_Overlay", ".Inventory_Items", ".Inventory_Items");
			
			if(StoredDataInv[player.userID].Count == 0)
			    container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                    Text = { Text = lang.GetMessage("InventoryEmpty", this, player.UserIDString), Align = TextAnchor.MiddleCenter, FontSize = 20, Color = "1 1 1 0.4" }
                }, ".Inventory_Items");
			
			int x = 0, y = 0, z = 0;
			bool permvip = permission.UserHasPermission(player.UserIDString, permVip);
			
            foreach(var inv in StoredDataInv[player.userID].Skip(Page * 39))
			{
				bool rewardlock = inv.IsVIP && config.Setting.TakeReward && !permvip;
				
				container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"{-522 + (x * 80.75)} {40 - (y * 77.5)}", OffsetMax = $"{-447 + (x * 80.75)} {115 - (y * 77.5)}" },
                    Image = { Color = rewardlock ? "0.41 0.42 0.40 0.47" : "0.41 0.42 0.40 0.95", Material = "assets/content/ui/uibackgroundblur.mat" }
                }, ".Inventory_Items", ".Invitems");
				
				if(rewardlock)
					container.Add(new CuiPanel
					{
						RectTransform = { AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = "-15 -15", OffsetMax = "-2.5 -2.5" },
						Image = { Color = "0.75 0.75 0.75 1", Sprite = "assets/icons/bp-lock.png" }
					}, ".Invitems");
				
				container.Add(new CuiElement
                {
                    Parent = ".Invitems",
                    Components =
                    {
					    new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", inv.Shortname + inv.SkinID + (inv.URLImage == String.Empty ? 150 : 151)), Color = rewardlock ? "1 1 1 0.4" : "1 1 1 1" },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "7.5 7.5", OffsetMax = "-7.5 -7.5" }
                    }
                });
				
				container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "-2.5 0" },
                    Text = { Text = inv.Amount == 0 ? "" : $"x{inv.Amount}", Align = TextAnchor.LowerRight, FontSize = 12, Color = rewardlock ? "1 1 1 0.15" : "1 1 1 0.75" }
                }, ".Invitems");
				
				if(!rewardlock)
				{
					container.Add(new CuiButton
					{
						RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
						Button = { Color = "0 0 0 0", Command = $"level_take {z + (Page * 39)} {Page}" },
						Text = { Text = "" }
					}, ".Invitems", ".InvitemsTake");
				
					container.Add(new CuiElement
					{
						Parent = ".InvitemsTake",
						Components =
						{
							new CuiTextComponent { Text = lang.GetMessage("Take", this, player.UserIDString), Align = TextAnchor.MiddleCenter, FontSize = 12, Color = "0.38 0.61 0.99 1" },
							new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
							new CuiOutlineComponent { Color = rewardlock ? "0 0 0 0.4" : "0 0 0 1", Distance = "-1 1" }
						}
					});
				}					
				
				x++;
				z++;
				 
				if(x == 13)
				{
					x = 0;
					y++;
					
					if(y == 3)
						break;
				}
			}
			
			bool back = Page != 0;
			bool next = StoredDataInv[player.userID].Count > ((Page + 1) * 39);
			
			container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-195 -40", OffsetMax = "-1 -5" },
                Image = { Color = "0.21 0.22 0.20 1" }
            }, ".Inventory_Items", ".BB");
			
			container.Add(new CuiButton 
            {   
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-93 -12.5", OffsetMax = "-3 12.5" },
                Button = { Color = back ? "0.65 0.29 0.24 1" : "0.65 0.29 0.24 0.4", Command = back ? $"level page_inv back {Page}" : "" },
                Text = { Text = lang.GetMessage("BACK", this, player.UserIDString), Align = TextAnchor.MiddleCenter, FontSize = 16, Font = "robotocondensed-regular.ttf", Color = back ? "0.92 0.79 0.76 1" : "0.92 0.79 0.76 0.4" }
            }, ".BB");				 			
			
			container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "2.5 -12.5", OffsetMax = "92.5 12.5" },
                Button = { Color = next ? "0.35 0.45 0.25 1" : "0.35 0.45 0.25 0.4", Command = next ? $"level page_inv next {Page}" : "" },
                Text = { Text = lang.GetMessage("NEXT", this, player.UserIDString), Align = TextAnchor.MiddleCenter, FontSize = 16, Font = "robotocondensed-regular.ttf", Color = next ? "0.75 0.95 0.41 1" : "0.75 0.95 0.41 0.4" }
            }, ".BB");
			
			container.Add(new CuiButton 
            {    
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = "5 -35", OffsetMax = "195 -10" },
                Button = { Color = "0.65 0.29 0.24 1", Close = ".Inventory_Items" },
                Text = { Text = lang.GetMessage("CLOSEINV", this, player.UserIDString), Align = TextAnchor.MiddleCenter, FontSize = 16, Font = "robotocondensed-regular.ttf", Color = "0.92 0.79 0.76 1" }
            }, ".Inventory_Items");
			
			CuiHelper.AddUi(player, container);
		}
		
		private void OnLootEntity(BasePlayer player, LootContainer container, Item item)
		{
			if(!config.Setting.CrateValide) return;
			if(container.OwnerID != 0 || player == null) return;
				
			if(config.XP.CrateXP.ContainsKey(container.ShortPrefabName))
				XPRateRerm(player, config.XP.CrateXP[container.ShortPrefabName]);
			
			container.OwnerID = player.userID;
		} 
		
				
	    
        private void InitializeLang()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["LevelTitle"] = "COOL SERVER LEVEL MENU",
                ["Level"] = "LEVEL: {0}/{1}   |   XP: {2}/{3}{4}",
                ["Level_2"] = "LEVEL: {0}/{1}   |   XP: {2}{4}",
				["Level_Top"] = "{0}.     LEVEL: {1}   |   XP: {2}\n{3}",
                ["LevelGUI"] = "LEVEL: {0}",
                ["Exchange"] = "EXCHANGE VALUES",
                ["ExchangeTrue"] = "You have successfully exchanged coupons for - {0} XP.",
                ["InventaryInfo"] = "You have {0} XP coupons in your inventory!",
                ["Info"] = "Level up and get rewards!",
                ["Take"] = "TAKE",
                ["TakeItem"] = "You have successfully received - {0} [{1} pcs].",
				["LevelUP"] = "<color=#00FF00>[XLevels]</color> : Level up!\n<size=12>Your level: <color=orange>{0}</color></size>",
				["XP"] = "On you {0}XP",
                ["InventoryEmpty"] = "YOUR INVENTORY IS EMPTY!",
				["CLOSEINV"] = "CLOSE INVENTORY",
				["OPENINV"] = "OPEN INVENTORY",
				["NEXT"] = "NEXT",
				["BACK"] = "BACK",
				["VIPYES"] = "VIP ACTIVE",
				["VIPNO"] = "VIP INACTIVE",
				["BUTTON"] = "OPEN MENU",
				["RANK"] = "   |   RANK: {0}"
            }, this);
			
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["LevelTitle"] = "МЕНЮ УРОВНЕЙ КРУТОГО СЕРВЕРА",
                ["Level"] = "УРОВЕНЬ: {0}/{1}   |   XP: {2}/{3}{4}",
                ["Level_2"] = "УРОВЕНЬ: {0}/{1}   |   XP: {2}{4}",
                ["Level_Top"] = "{0}.     УРОВЕНЬ: {1}   |   XP: {2}\n{3}",
                ["LevelGUI"] = "УРОВЕНЬ: {0}",
                ["Exchange"] = "ОБМЕНЯТЬ КУПОНЫ",
                ["ExchangeTrue"] = "Вы успешно обменяли купоны на - {0} XP.",
                ["InventaryInfo"] = "В вашем инвентаре купонов на {0} XP!",
                ["Info"] = "Повышайте уровень и получайте награду!",
                ["Take"] = "ЗАБРАТЬ",
                ["TakeItem"] = "Вы успешно получили - {0} [ {1} шт ].",
                ["LevelUP"] = "<color=#00FF00>[XLevels]</color> : Уровень повышен!\n<size=12>Ваш уровень: <color=orange>{0}</color></size>",
                ["XP"] = "У вас на {0}XP",
                ["InventoryEmpty"] = "ВАШ ИНВЕНТАРЬ ПУСТ!",
				["CLOSEINV"] = "ЗАКРЫТЬ ИНВЕНТАРЬ",
				["OPENINV"] = "ОТКРЫТЬ ИНВЕНТАРЬ",
				["NEXT"] = "ДАЛЕЕ",
				["BACK"] = "НАЗАД",
				["VIPYES"] = "ВИП АКТИВЕН",
				["VIPNO"] = "ВИП НЕАКТИВЕН",
				["BUTTON"] = "ОТКРЫТЬ МЕНЮ",
				["RANK"] = "   |   РАНГ: {0}"
            }, this, "ru");
			
			lang.RegisterMessages(new Dictionary<string, string>
            {
                ["LevelTitle"] = "МЕНЮ РІВНІВ КРУТОГО СЕРВЕРУ",
                ["Level"] = "РІВЕНЬ: {0}/{1}   |   XP: {2}/{3}{4}",
                ["Level_2"] = "РІВЕНЬ: {0}/{1}   |   XP: {2}{4}",
                ["Level_Top"] = "{0}.     РІВЕНЬ: {1}   |   XP: {2}\n{3}",
                ["LevelGUI"] = "РІВЕНЬ: {0}",
                ["Exchange"] = "ОБМІНЯТИ КУПОНИ",
                ["ExchangeTrue"] = "Ви успішно обміняли купони на - {0} XP.",
                ["InventaryInfo"] = "У вашому інвентарі купонів на {0} XP!",
                ["Info"] = "Підвищуйте рівень та отримуйте нагороду!",
                ["Take"] = "ЗАБРАТИ",
                ["TakeItem"] = "Ви успішно отримали - {0} [ {1} шт ].",
                ["LevelUP"] = "<color=#00FF00>[XLevels]</color> : Рівень підвищено!\n<size=12>Ваш рівень: <color=orange>{0}</color></size>",
                ["XP"] = "У вас на {0}XP",
                ["InventoryEmpty"] = "ВАШ ІНВЕНТАР ПОРОЖНІЙ!",
				["CLOSEINV"] = "ЗАКРИТИ ІНВЕНТАР",
				["OPENINV"] = "ВІДКРИТИ ІНВЕНТАР",
				["NEXT"] = "ДАЛІ",
				["BACK"] = "НАЗАД",
				["VIPYES"] = "ВІП АКТИВНИЙ",
				["VIPNO"] = "ВІП НЕАКТИВНИЙ",
				["BUTTON"] = "ВІДКРИТИ МЕНЮ",
				["RANK"] = "   |   РАНГ: {0}"
            }, this, "uk");
			
			lang.RegisterMessages(new Dictionary<string, string>
            {
                ["LevelTitle"] = "MENÚ DE NIVEL DE SERVIDOR FRESCO",
                ["Level"] = "NIVEL: {0}/{1}   |   XP: {2}/{3}{4}",
                ["Level_2"] = "NIVEL: {0}/{1}   |   XP: {2}{4}",
				["Level_Top"] = "{0}.     NIVEL: {1}   |   XP: {2}\n{3}",
                ["LevelGUI"] = "NIVEL: {0}",
                ["Exchange"] = "VALORES DE CAMBIO",
                ["ExchangeTrue"] = "Has canjeado con éxito cupones por - {0} XP.",
                ["InventaryInfo"] = "¡Tienes {0} cupones de XP en tu inventario!",
                ["Info"] = "¡Sube de nivel y obtén recompensas!",
                ["Take"] = "LLEVAR",
                ["TakeItem"] = "Ha recibido con éxito - {0} [{1} piezas].",
				["LevelUP"] = "<color=#00FF00>[XLevels]</color> : ¡Elevar a mismo nivel!\n<size=12>Tu nivel: <color=orange>{0}</color></size>",
				["XP"] = "En ti {0}XP",
                ["InventoryEmpty"] = "¡TU INVENTARIO ESTÁ VACÍO!",
				["CLOSEINV"] = "CERRAR INVENTARIO",
				["OPENINV"] = "ABRIR EL INVENTARIO",
				["NEXT"] = "PRÓXIMO",
				["BACK"] = "ATRÁS",
				["VIPYES"] = "VIP ACTIVO",
				["VIPNO"] = "VIP INACTIVO",
				["BUTTON"] = "MENÚ ABIERTO",
				["RANK"] = "   |   RANGO: {0}"
            }, this, "es-ES");
        }
		
		private const string permVip = "xlevels.vip";
		
        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if(StoredData.ContainsKey(player.userID))
                SaveData(player);
        }
		
		private void GUIOpen(BasePlayer player)
		{
			if(config.Vending.VendingUse && player.inventory.loot.entitySource is NPCVendingMachine)
			{
				NPCVendingMachine machine = player.inventory.loot.entitySource.GetComponent<NPCVendingMachine>();
				
				if(config.Vending.ListNPCVending.Contains(machine.shopName))
					RewardMenuFon(player);
			}
			else if(!config.Vending.VendingUse)
				RewardMenuFon(player);
		}
		
		private void Top(BasePlayer player)
		{
			CuiHelper.DestroyUi(player, ".ExchangeInfo");
            CuiHelper.DestroyUi(player, ".Info");
			CuiElementContainer container = new CuiElementContainer();
			
			container.Add(new CuiPanel
            {
				RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Color = "0.21 0.22 0.20 1", Material = "assets/content/ui/uibackgroundblur.mat" }
            }, ".LevelO_Overlay", ".Top", ".Top");
			
			container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Close = ".Top" },
                Text = { Text = "" }
            }, ".Top");
			
			int x = 0, y = 0, z = 1;
			
			foreach(var i in StoredData.OrderByDescending(h => h.Value.XP).OrderByDescending(h => h.Value.Level).Take(12))
			{
				var rplayer = covalence.Players.FindPlayerById(i.Key.ToString());
				
				container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"{-522 + (x * 350)} {85 - (y * 55)}", OffsetMax = $"{-177 + (x * 350)} {135 - (y * 55)}" },
                    Image = { Color = "0.31 0.32 0.30 0.95", Material = "assets/content/ui/uibackgroundblur.mat" }
                }, ".Top", ".TopList");
				
				container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                    Text = { Text = string.Format(lang.GetMessage("Level_Top", this, player.UserIDString), z, i.Value.Level, i.Value.XP, rplayer.Name), Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 16, Color = "1 1 1 0.75" }
                }, ".TopList");
				
				container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-170 -22.5", OffsetMax = "-125 22.5" },
                    Image = { Color = "0.41 0.42 0.40 0.95", Material = "assets/content/ui/uibackgroundblur.mat" }
                }, ".TopList", ".TopAvatar");				
				
				container.Add(new CuiElement
                {
                    Parent = ".TopAvatar",
                    Components =
                    {
					    new CuiRawImageComponent { FadeIn = 0.5f, Png = (string) ImageLibrary.Call("GetImage", rplayer.Id) },
                        new CuiRectTransformComponent { AnchorMin = "0 0",  AnchorMax = "1 1", OffsetMin = "2.5 2.5", OffsetMax = "-2.5 -2.5" }
                    }
                });
				
				y++;
				z++;
					
				if(y == 4)
				{
					y = 0;
					x++;
				}
			}
			
			CuiHelper.AddUi(player, container);
		}
		 
	    private void Unload()
		{
			foreach(BasePlayer player in BasePlayer.activePlayerList)
			{
				CuiHelper.DestroyUi(player, ".Panel_GUI");
				CuiHelper.DestroyUi(player, ".Level_Overlay");
				SaveData(player);
			}
			
			if(StoredData != null) Interface.Oxide.DataFileSystem.WriteObject("XDataSystem/XLevels/XLevels", StoredData);
			config = null;
		} 
		
		private object OnPlayerChat(BasePlayer player, string message, Chat.ChatChannel channel)
		{
			string prefix = GetPlayerPrefix(player.userID);
			
			if(String.IsNullOrEmpty(prefix)) return null;
			
			if(channel == ConVar.Chat.ChatChannel.Team)
				return null;
			else
			{
				PrintToChat($"{prefix} | " + $"<color=#538fef>{player.displayName}</color>: " + message);
			    return true;
			}
		}
		
		private void OnLootSpawn(LootContainer lootContainer)
		{
			if(config.Setting.CouponsValide)
				if(config.Setting.PluginCLoot)
					NextTick(() => LootSpawn(lootContainer));
				else
					LootSpawn(lootContainer);
		}
		
				
				
		private void OnOpenVendingShop(NPCVendingMachine machine, BasePlayer player)
		{
			if(config.Vending.VendingUse && config.Vending.ListNPCVending.Contains(machine.shopName))
				if(config.Vending.VendingOpen)
					GUIOpen(player);
				else
					Button(player);
		}
		
				
				
		private class XLevelsData
        {
			[JsonProperty(LanguageEnglish ? "Level" : "Уровень")] public int Level = 0;
			[JsonProperty(LanguageEnglish ? "XP" : "ХР")] public float XP = 0;
        }
		private const string permTop = "xlevels.top";
		
		private void OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
			if(!config.Setting.BonusValide) return;
			if(dispenser == null || item == null || player == null) return;
			
			if(config.XP.GatherBonusXP.ContainsKey(item.info.shortname))
				XPRateRerm(player, config.XP.GatherBonusXP[item.info.shortname]);
		}
		
		private void DataMove(BasePlayer player, int number)
		{			
			if(player == null) return;
			 
			if(config.Award.ContainsKey(number))
			{
				var Award = config.Award[number];
				InvItems Inventory = new InvItems(Award.Shortname, Award.Name, Award.Amount, Award.SkinID, Award.Command, Award.URLImage, false);

				StoredDataInv[player.userID].Add(Inventory);
			}
		   		 		  						  	   		  	   		  	   		   		 		  		  
			bool contains = config.AwardVip.ContainsKey(number);
			
			if(config.Setting.VIPValide)
				if(contains && config.Setting.MoveReward && permission.UserHasPermission(player.UserIDString, permVip) || contains && !config.Setting.MoveReward)
				{
					var AwardVip = config.AwardVip[number];
					InvItems Inventory = new InvItems(AwardVip.Shortname, AwardVip.Name, AwardVip.Amount, AwardVip.SkinID, AwardVip.Command, AwardVip.URLImage, true);

					StoredDataInv[player.userID].Add(Inventory);
				}
		}
		
		protected override void LoadConfig()
        {
            base.LoadConfig();
			
			try
			{
				config = Config.ReadObject<LevelConfig>();
			}
			catch
			{
				PrintWarning(LanguageEnglish ? "Configuration read error! Creating a default configuration!" : "Ошибка чтения конфигурации! Создание дефолтной конфигурации!");
				LoadDefaultConfig();
			}
			
			SaveConfig();
        }
		
		private class InvItems
        {
		    [JsonProperty(LanguageEnglish ? "Item shortname" : "Шортнейм предмета")] public string Shortname;
            [JsonProperty(LanguageEnglish ? "Award display name" : "Отображаемое имя награды")] public string Name;
            [JsonProperty(LanguageEnglish ? "Item quantity" : "Количество предмета")] public int Amount;
			[JsonProperty(LanguageEnglish ? "Item skin" : "Скин предмета")] public ulong SkinID;
			[JsonProperty(LanguageEnglish ? "Command" : "Команда")] public string Command;
			[JsonProperty(LanguageEnglish ? "Link to custom image" : "Своя картинка")] public string URLImage;
			[JsonProperty(LanguageEnglish ? "VIP reward" : "Вип награда")] public bool IsVIP;
		   		 		  						  	   		  	   		  	   		   		 		  		  
            public InvItems(string shortname, string name, int amount, ulong skinid, string command, string urlimage, bool isvip)
			{
				Shortname = shortname; Name = name; Amount = amount; SkinID = skinid; Command = command; URLImage = urlimage; IsVIP = isvip;
			}
        }
		
		private void API_GiveXP(BasePlayer player, float XPAmount)
		{
			if(StoredData.ContainsKey(player.userID))
				AddData(player, XPAmount);
		}
		
		private void OGiveXP(BasePlayer player)
		{
			foreach(var perm in config.Online.Permisssion)
                if(permission.UserHasPermission(player.UserIDString, perm.Key))
				{
					AddData(player, perm.Value);
					break;
				}
		}
		
				
				
        private LevelConfig config;
		private Dictionary<ulong, List<InvItems>> StoredDataInv = new Dictionary<ulong, List<InvItems>>();
		
				
		[PluginReference] private Plugin ImageLibrary, StackSizeController, BetterChat;
		
		private void OnPlayerConnected(BasePlayer player)
		{
			if(player.IsReceivingSnapshot)
            {
                NextTick(() => OnPlayerConnected(player));
                return;
            }
			
			if(!StoredData.ContainsKey(player.userID))
				StoredData.Add(player.userID, new XLevelsData());		
			
			if(config.GUI.EnablePanel) GUI(player);
			LoadData(player);
		} 
		
		private object CanCombineDroppedItem(DroppedItem item, DroppedItem targetItem)
		{
            for(int i = 0; i < config.Coupon.Count; i++)
			{
			    if(item.GetItem().skin == config.Coupon[i].SkinID)
				    if(!targetItem.GetItem().skin.Equals(item.GetItem().skin)) return false;
				
                if(targetItem.GetItem().skin == config.Coupon[i].SkinID)
				    if(!item.GetItem().skin.Equals(targetItem.GetItem().skin)) return false; 
			}

            return null;
		}
		
		private void ChatMessage(BasePlayer player, string message) => Player.Reply(player, message, config.Setting.SteamID);
		
				
	    		
		private Item OnItemSplit(Item item, int amount)
        {
			if(StackSizeController) return null;
			
            for(int i = 0; i < config.Coupon.Count; i++)
			    if(item.skin == config.Coupon[i].SkinID)
                {
                    item.amount -= amount;
				
                    var Item = ItemManager.Create(item.info, amount, item.skin);
					
                    Item.name = item.name;
                    Item.skin = item.skin;
                    Item.text = item.text;
                    Item.amount = amount;
		            item.MarkDirty();
				
                    return Item;
                }
			
            return null;
        }
		
				
				
		private void cmdMenuOpen(BasePlayer player, string command, string[] args) => GUIOpen(player);
		
		private void DataTake(BasePlayer player, int number, int page)
		{
			if(player == null) return;
			
			var InventoryItem = StoredDataInv[player.userID][number];
			
			if(InventoryItem.IsVIP && config.Setting.TakeReward && !permission.UserHasPermission(player.UserIDString, permVip)) return;
			
			if(InventoryItem.Command != String.Empty)
				Server.Command($"{InventoryItem.Command}".Replace("%STEAMID%", player.UserIDString));	
            else
			{
				Item item = ItemManager.CreateByName(InventoryItem.Shortname, InventoryItem.Amount, InventoryItem.SkinID);
				item.name = InventoryItem.Name;
				
				player.GiveItem(item);
			}
			
			StoredDataInv[player.userID].Remove(InventoryItem);
			EffectNetwork.Send(new Effect("assets/bundled/prefabs/fx/weapons/survey_charge/survey_charge_stick.prefab", player, 0, new Vector3(), new Vector3()), player.Connection);
			
			InventoryRewardMenu(player, page);
			
			if(config.Setting.ChatTakeMessages)
				ChatMessage(player, string.Format(lang.GetMessage("TakeItem", this, player.UserIDString), InventoryItem.Name, InventoryItem.Amount));
		}
		
		private void CouponExchange(BasePlayer player, int x)
		{
			if(player.inventory.FindItemsByItemID(1414245162).Count == 0) return;
			
			int level = StoredData[player.userID].Level;
			
			if(config.Setting.GiveXPCoupon && level >= config.Level.LevelMax || level < config.Level.LevelMax)
			{
				int xp = 0;
		   		 		  						  	   		  	   		  	   		   		 		  		  
				foreach(var item in player.inventory.FindItemsByItemID(1414245162))
						if(item.skin == config.Coupon[x].SkinID)
						{
							xp += config.Coupon[x].XP * item.amount;
							
							item.RemoveFromContainer();
						}
			
				CuiHelper.DestroyUi(player, ".Inventory_Items");
				
				xp = config.XPRate.XPRateCoupon ? (int)XPRatePermCoupon(player, xp) : xp;
				
				AddData(player, xp);
				RewardMenu(player);
				ExchangeInfo(player);
			
				if(config.Setting.ChatTakeMessages) ChatMessage(player, string.Format(lang.GetMessage("ExchangeTrue", this, player.UserIDString), xp));
			}
		}
		
		private void XPRateRerm(BasePlayer player, float xp)
		{
			foreach(var perm in config.XPRate.XPRatePermisssion)
				if(permission.UserHasPermission(player.UserIDString, perm.Key))
				{
					xp *= perm.Value;
					break;
				}
			
			AddData(player, xp);
		}
		protected override void LoadDefaultConfig() => config = LevelConfig.GetNewConfiguration();
		private const bool LanguageEnglish = false;
		
		private void OnGrowableGather(GrowableEntity plant, BasePlayer player)
		{
			if(!config.Setting.HarvestValide) return;
			if(plant == null || player == null) return;
				
			if(config.XP.HarvestXP.ContainsKey(plant.ShortPrefabName))
				XPRateRerm(player, config.XP.HarvestXP[plant.ShortPrefabName]);
		}
		 
				
	    		
		private void AddData(BasePlayer player, float XPData)
		{
			bool maxlevel = StoredData[player.userID].Level >= config.Level.LevelMax;
			
			if(config.Setting.GiveXP && maxlevel)
			{
				NextTick(() => {
					if(config.GUI.EnablePanel) GUI(player);
					Message(player, $"+ {XPData}");
				});
				
				StoredData[player.userID].XP += XPData;
				return;
			}
			else if(maxlevel) return;
			
			float xp2 = XPData;
			
			NextTick(() => {
				if(config.GUI.EnablePanel) GUI(player);
			    Message(player, $"+ {xp2}");
			});
			
			while(XPData > StoredData[player.userID].Level * config.Level.LevelXPUP + config.Level.LevelXP)
			{
				StoredData[player.userID].Level += 1;
				XPData -= StoredData[player.userID].Level * config.Level.LevelXPUP + config.Level.LevelXP;
				
				int level = StoredData[player.userID].Level;
				
				DataMove(player, level);
				 
				if(config.Setting.ChatLevelMessages) 
					ChatMessage(player, string.Format(lang.GetMessage("LevelUP", this, player.UserIDString), level));
				
                if(level >= config.Level.LevelMax)
				{
					if(config.Setting.ClearAll)
					{
						StoredData[player.userID].Level = 0;
						StoredData[player.userID].XP = 0;
					}
					
					if(!config.Setting.GiveXP) StoredData[player.userID].XP = 0;
					return;
				}
			}
			
			float xpUP = StoredData[player.userID].Level * config.Level.LevelXPUP + config.Level.LevelXP;
			
			if(XPData > 0) 
		    {
				StoredData[player.userID].XP += XPData;
				
				if(StoredData[player.userID].XP >= xpUP)
			    {
				    StoredData[player.userID].XP -= xpUP;
				    StoredData[player.userID].Level += 1;
		   		 		  						  	   		  	   		  	   		   		 		  		  
					int level = StoredData[player.userID].Level;
		   		 		  						  	   		  	   		  	   		   		 		  		  
                    DataMove(player, level);
		   		 		  						  	   		  	   		  	   		   		 		  		  
					if(config.Setting.ChatLevelMessages) 
						ChatMessage(player, string.Format(lang.GetMessage("LevelUP", this, player.UserIDString), level));
					
					if(level >= config.Level.LevelMax)
					{
						if(config.Setting.ClearAll)
						{
							StoredData[player.userID].Level = 0;
							StoredData[player.userID].XP = 0;
						}
						
						if(!config.Setting.GiveXP) StoredData[player.userID].XP = 0;
					}
			    }
	        }
		}
		
		private void LoadData(BasePlayer player)
		{
            var Inventory = Interface.Oxide.DataFileSystem.ReadObject<List<InvItems>>($"XDataSystem/XLevels/InvItems/{player.userID}");
            
            if(!StoredDataInv.ContainsKey(player.userID))
                StoredDataInv.Add(player.userID, new List<InvItems>());	

            StoredDataInv[player.userID] = Inventory ?? new List<InvItems>();
		}
		
		[ConsoleCommand("level_take")]
		private void ccmdTakeData(ConsoleSystem.Arg arg)
		{
			BasePlayer player = arg?.Player();
			
			if(player == null || StoredDataInv[player.userID].Count == 0) return;
					
		    DataTake(player, int.Parse(arg.Args[0]), int.Parse(arg.Args[1]));
		}
		
		private string GetPlayerPrefix(ulong userID)
		{
			string prefix = String.Empty;
			
			if(StoredData.ContainsKey(userID))
			{
				if(config.Setting.ChatPrefixLevel && config.Setting.ChatPrefixRank)
					prefix = $"[ <color=orange>{StoredData[userID].Level}</color> ] [ <color=orange>{(config.Setting.RankList.ContainsKey(StoredData[userID].Level) ? config.Setting.RankList[StoredData[userID].Level] : "∞")}</color> ]";
				else if(config.Setting.ChatPrefixLevel)
					prefix = $"[ <color=orange>{StoredData[userID].Level}</color> ]";
				else if(config.Setting.ChatPrefixRank)
					prefix = $"[ <color=orange>{(config.Setting.RankList.ContainsKey(StoredData[userID].Level) ? config.Setting.RankList[StoredData[userID].Level] : "∞")}</color> ]";
			}
			
			return prefix;
		}
		
		private void GUI(BasePlayer player)
        {
            CuiElementContainer container = new CuiElementContainer();
			
			container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMax = "0 0"  },
                Image = { Color = "0 0 0 0" }
            }, "Hud", ".Panel_GUI", ".Panel_GUI");			
			
			container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = config.GUI.AnchorMin, AnchorMax = config.GUI.AnchorMax, OffsetMin = config.GUI.OffsetMin, OffsetMax = config.GUI.OffsetMax },
                Image = { Color = "0.96 0.91 0.87 0.02", Material = "assets/icons/greyout.mat" }
            }, ".Panel_GUI", ".GUIProgress");	
		   		 		  						  	   		  	   		  	   		   		 		  		  
			container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "4 5", OffsetMax = "-172 -5" },
                Button = { Color = "0.9 0.9 0.9 0.6", Sprite = "assets/icons/upgrade.png" },
                Text = { Text = "" }
            }, ".GUIProgress");			
			
			container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "25 3", OffsetMax = "-4 -3" },
                Image = { Color = "0 0 0 0" }
            }, ".GUIProgress", ".Progress");
			
			var data = StoredData[player.userID];
			
			container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = data.Level < config.Level.LevelMax ? $"{1.0 / (data.Level * config.Level.LevelXPUP + config.Level.LevelXP) * data.XP} 1" : "1 1", OffsetMax = "0 0" },
                Image = { FadeIn = 0.25f,  Color = "0.29 0.60 0.83 0.92", Material = "assets/icons/greyout.mat" }
            }, ".Progress");
			
		    container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "-7 0" },
                Text = { Text = string.Format(lang.GetMessage("LevelGUI", this, player.UserIDString), data.Level), Align = TextAnchor.MiddleRight, FontSize = 13, Color = "1 1 1 0.6" }
            }, ".Progress");
			
		    container.Add(new CuiLabel
		    {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "7 0", OffsetMax = "0 0" },
                Text = { Text = $"XP: {Math.Round(data.XP, 2)}", Align = TextAnchor.MiddleLeft, FontSize = 13, Color = "1 1 1 0.6" }
            }, ".Progress");
			
			CuiHelper.AddUi(player, container); 
		}
		
		private Dictionary<ulong, XLevelsData> StoredData = new Dictionary<ulong, XLevelsData>();
		private string API_GetPlayerPrefix(ulong userID) => GetPlayerPrefix(userID);
		
		private void OnCollectiblePickup(CollectibleEntity collectible, BasePlayer player)
        {
			if(!config.Setting.PickupValide) return;
			if(collectible == null || player == null) return;
			
			foreach(ItemAmount item in collectible.itemList)
				if(config.XP.PickupXP.ContainsKey(item.itemDef.shortname))
					XPRateRerm(player, config.XP.PickupXP[item.itemDef.shortname]);
		}
		
				
				
		private int CouponInfo(BasePlayer player, int x)
		{
			int xp = 0;
			
			foreach(var item in player.inventory.FindItemsByItemID(1414245162))
				    if(item.skin == config.Coupon[x].SkinID)
				    	xp += config.Coupon[x].XP * item.amount;
			
			return config.XPRate.XPRateCoupon ? (int)XPRatePermCoupon(player, xp) : xp;
		}
		
		private void ExchangeInfo(BasePlayer player)
        {
			CuiHelper.DestroyUi(player, ".Info");
			CuiHelper.DestroyUi(player, ".Top");
            CuiElementContainer container = new CuiElementContainer();
			
			container.Add(new CuiPanel
            {
				RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Color = "0.21 0.22 0.20 1", Material = "assets/content/ui/uibackgroundblur.mat" }
            }, ".LevelO_Overlay", ".ExchangeInfo", ".ExchangeInfo");
			
			container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Close = ".ExchangeInfo" },
                Text = { Text = "" }
            }, ".ExchangeInfo");
			
			int x = 0;
			int count = config.Coupon.Count, level = StoredData[player.userID].Level;
			
			foreach(var coupon in config.Coupon)
			{
				double offset = -(70 * count--) - (5.0 * count--);
				int xp = CouponInfo(player, x);
				bool activebutton = config.Setting.GiveXPCoupon && level >= config.Level.LevelMax && xp != 0 || level < config.Level.LevelMax && xp != 0;
					
				container.Add(new CuiPanel
                {
				    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"{140 + offset - 140} -51", OffsetMax = $"{140 + offset} 89" },
                    Image = { Color = "0.41 0.42 0.40 0.95", Material = "assets/content/ui/uibackgroundblur.mat" }
                }, ".ExchangeInfo", ".Coupon");

				container.Add(new CuiElement
                {
                    Parent = ".Coupon",
                    Components =
                    {
					    new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", coupon.SkinID.ToString()) },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "22.5 22.5", OffsetMax = "-22.5 -22.5" }
                    }
                });	
		   		 		  						  	   		  	   		  	   		   		 		  		  
			    container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0", OffsetMax = "0 20" },
                    Text = { Text = string.Format(lang.GetMessage("XP", this, player.UserIDString), xp), Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 11, Color = "1 1 1 0.5" }
                }, ".Coupon");				
 
			    container.Add(new CuiButton
                { 
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0", OffsetMin = "0 -37.5", OffsetMax = "0 -10" },
                    Button = { Color = activebutton ? "0.41 0.42 0.40 0.95" : "0.41 0.42 0.40 0.15", Material = "assets/icons/greyout.mat", Command = activebutton ? $"level exchange {x}" : "" },
                    Text = { Text = lang.GetMessage("Exchange", this, player.UserIDString), Align = TextAnchor.MiddleCenter, FontSize = 14, Color = activebutton ? "0.75 0.75 0.75 1" : "0.75 0.75 0.75 0.2" }
                }, ".Coupon");
 
                x++;				
			}

            CuiHelper.AddUi(player, container);
        }
		
				
				
		private void Button(BasePlayer player)
		{
            CuiElementContainer container = new CuiElementContainer();
			
			container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-447 16", OffsetMax = "-210 98" },
                Image = { Color = "0.51 0.52 0.50 0.95", Material = "assets/icons/greyout.mat" }
            }, "Overlay", ".Button", ".Button");
			
			container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 5", OffsetMax = "-5 -5" },
                Button = { Color = "0.21 0.22 0.20 0.95", Material = "assets/icons/greyout.mat", Command = "x_levels" },
                Text = { Text = lang.GetMessage("BUTTON", this, player.UserIDString), Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 22, Color = "1 1 1 0.25" }
            }, ".Button");
			
			CuiHelper.AddUi(player, container);
		}
		
		private float XPRatePermCoupon(BasePlayer player, float xp)
		{
			foreach(var perm in config.XPRate.XPRatePermisssion)
				if(permission.UserHasPermission(player.UserIDString, perm.Key))
					return xp * perm.Value;
			
			return xp;
		}
		
			}
}


// --- End of file: XLevels.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/DiscordRewards.cs ---
// --- Original Local Path: DiscordRewards.cs ---

﻿using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using Oxide.Ext.Discord;
using Oxide.Ext.Discord.Attributes;
using Oxide.Ext.Discord.Entities;
using Oxide.Ext.Discord.Entities.Activities;
using Oxide.Ext.Discord.Entities.Channels;
using Oxide.Ext.Discord.Entities.Gatway;
using Oxide.Ext.Discord.Entities.Gatway.Commands;
using Oxide.Ext.Discord.Entities.Guilds;
using Oxide.Ext.Discord.Entities.Messages;
using Oxide.Ext.Discord.Entities.Permissions;
using Oxide.Ext.Discord.Entities.Users;
using Oxide.Ext.Discord.Logging;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("DiscordRewards", "k1lly0u", "0.2.2")]
    [Description("Reward players with items, kits and commands for being a member of your Discord")]
    class DiscordRewards : RustPlugin
    {
        #region Fields        
        [PluginReference]
        private Plugin ImageLibrary, Kits;

        [DiscordClient]
        private DiscordClient Client;

        private DiscordGuild Guild;

        private DiscordRole NitroRole;

        private DiscordChannel ValidationChannel;

        public static DiscordRewards Instance { get; private set; }


        private bool isInitialized = false;

        private bool needsWipe = false;

        private int statusIndex = 0;

        private enum RewardType { Kit, Item, Command }

        #endregion

        #region Oxide Hooks
        private void Loaded() 
        {
            Instance = this;
            LoadData();
        }

        protected override void LoadDefaultMessages() => lang.RegisterMessages(Messages, this);

        private void OnServerInitialized()
        {            
            LoadImages();

            if (needsWipe)
            {
                if (Configuration.Token.WipeReset)
                    WipeData();
                else if (Configuration.Token.WipeResetRewards)
                    WipeRewardCooldowns();
            }            
        }

        private void OnServerSave() => SaveData();

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player == null)
                return;

            ValidateUser(player);
            UpdateStatus();
        }

        private void OnPlayerDisconnected(BasePlayer player) => UpdateStatus();

        private void OnNewSave(string filename) => needsWipe = true;

        private void Unload()
        {            
            foreach (BasePlayer player in BasePlayer.activePlayerList)
                CuiHelper.DestroyUi(player, UI_MENU);

            if (Client != null)
                Client.Disconnect();

            Instance = null;
        }
        #endregion

        #region Discord Hooks        
        private void OnDiscordClientCreated()
        {
            if (string.IsNullOrEmpty(Configuration.Settings.APIKey))
            {
                PrintError("No API token set in config... Unable to continue!");
                return;
            }

            if (string.IsNullOrEmpty(Configuration.Settings.BotID))
            {
                PrintError("No bot client ID set in config... Unable to continue!");
                return;
            }

            Puts("Establishing connection to your Discord server...");

            DiscordSettings settings = new DiscordSettings();
            settings.ApiToken = Configuration.Settings.APIKey;
            settings.LogLevel = Configuration.Settings.LogLevel;
            settings.Intents = GatewayIntents.Guilds | GatewayIntents.DirectMessages | GatewayIntents.GuildMessages | GatewayIntents.GuildMembers;

            Client.Connect(settings);
        }
                
        private void OnDiscordGuildCreated(DiscordGuild guild)
        {
            if (guild == null)
            {
                PrintError("Failed to connect to guild. Unable to continue...");
                return;
            }

            Guild = guild;

            Puts($"Connection to {Guild.Name} established! DiscordRewards is now active");

            NitroRole = Guild.GetBoosterRole();

            if (!string.IsNullOrEmpty(Configuration.Token.ValidationChannel))
                ValidationChannel = Guild.GetChannel(Configuration.Token.ValidationChannel);

            foreach (BasePlayer player in BasePlayer.activePlayerList)
                ValidateUser(player);

            UpdateStatus();

            isInitialized = true;
        }

        private void OnDiscordGuildMemberRemoved(GuildMember member, DiscordGuild guild)
        {
            ulong steamId;
            if (userData.FindByID(member.Id, out steamId))
            {     
                int code;
                if (userData.HasPendingToken(steamId, out code))
                    userData.InvalidateToken(code);

                UserData.User user = userData.GetUser(steamId);
                if (user != null)
                    RevokeRewards(steamId, user);
            }
        }

        private void OnDiscordDirectMessageCreated(DiscordMessage message, DiscordChannel channel)
        {
            if (message == null || message.Author.Bot == true)
                return;

            int code;
            if (int.TryParse(message.Content, out code) && AttemptTokenValidation(message.Author, code))
                return;

            message.Author.CreateDirectMessageChannel(Client, (DiscordChannel dmChannel) => dmChannel.CreateMessage(Client, Message("Discord.InvalidToken")));
        }

        private void OnDiscordGuildMessageCreated(DiscordMessage message, DiscordChannel channel, DiscordGuild guild)
        {
            if (message == null || message.Author.Bot == true)
                return;

            if (ValidationChannel == null || channel != ValidationChannel)
                return;

            int code;
            if (int.TryParse(message.Content, out code) && AttemptTokenValidation(message.Author, code))
            {
                message.DeleteMessage(Client);
                return;
            }

            message.Author.CreateDirectMessageChannel(Client, (DiscordChannel dmChannel) => dmChannel.CreateMessage(Client, Message("Discord.InvalidToken")));
            message.DeleteMessage(Client);
        }
        #endregion

        #region Token Validation        
        private bool AttemptTokenValidation(DiscordUser discordUser, int code)
        {
            UserData.DiscordToken token;
            if (userData.IsValidToken(code, out token))
            {
                BasePlayer player = FindPlayer(token.playerId);

                if (token.expireTime < CurrentTime())
                {
                    discordUser.CreateDirectMessageChannel(Client, (DiscordChannel dmChannel) => dmChannel.CreateMessage(Client, Message("Discord.TokenExpired", player?.userID ?? 0UL)));
                    userData.InvalidateToken(code);
                    return true;
                }

                if (player == null)
                {
                    discordUser.CreateDirectMessageChannel(Client, (DiscordChannel dmChannel) => dmChannel.CreateMessage(Client, string.Format(Message("Discord.FailedToFindPlayer", player?.userID ?? 0UL), token.playerId)));
                    return true;
                }

                if (!player.IsConnected)
                {
                    discordUser.CreateDirectMessageChannel(Client, (DiscordChannel dmChannel) => dmChannel.CreateMessage(Client, Message("Discord.NotOnServer", player?.userID ?? 0UL)));
                    return true;
                }

                if (player.IsDead())
                {
                    discordUser.CreateDirectMessageChannel(Client, (DiscordChannel dmChannel) => dmChannel.CreateMessage(Client, Message("Discord.UserIsDead", player?.userID ?? 0UL)));
                    return true;
                }

                userData.InvalidateToken(code);

                UserData.User user = userData.GetUser(token.playerId) ?? userData.AddNewUser(token.playerId, discordUser.Id);

                user.SetExpiryDate(Configuration.Token.RevalidationInterval);

                string response = Message("Discord.ValidatedToken", player?.userID ?? 0UL);

                if (Configuration.Token.RequireRevalidation)
                    response += $" {string.Format(Message("Discord.TokenExpires", player?.userID ?? 0UL), FormatTime(Configuration.Token.RevalidationInterval))}";

                if (Configuration.UISettings.Enabled)
                    response += $" {Message("Discord.OpenStore", player?.userID ?? 0UL)}";

                discordUser.CreateDirectMessageChannel(Client, (DiscordChannel dmChannel) => dmChannel.CreateMessage(Client, response));


                if (player != null)
                {
                    player.ChatMessage(response);
                    IssueAlternativeRewards(player);
                }

                SaveData();
                UpdateStatus();
                return true;
            }

            return false;
        }

        private BasePlayer FindPlayer(ulong userId)
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                if (player.userID.Equals(userId))
                    return player;
            }

            foreach (BasePlayer player in BasePlayer.sleepingPlayerList)
            {
                if (player.userID.Equals(userId))
                    return player;
            }

            return null;
        }
        #endregion

        #region Status
        private void UpdateStatus()
        {            
            statusIndex += 1;

            if (statusIndex >= (Configuration.Settings.StatusMessages?.Length ?? 0))
                statusIndex = 0;

            if (Client?.Bot != null) 
            {
                if (Configuration.Settings.StatusMessages != null && Configuration.Settings.StatusMessages.Length > 0)
                {
                    string message = Configuration.Settings.StatusMessages[statusIndex];

                    if (!string.IsNullOrEmpty(message))
                    {
                        string str = message.Replace("{playersMin}", BasePlayer.activePlayerList.Count.ToString())
                            .Replace("{playersMax}", ConVar.Server.maxplayers.ToString())
                            .Replace("{rewardPlayers}", (!Configuration.Token.RequireRevalidation ? userData.users.Count.ToString() : userData.users.Where(x => CurrentTime() < x.Value.expireTime).Count().ToString()));

                        Client.Bot.UpdateStatus(new UpdatePresenceCommand()
                        {
                            Activities = new List<DiscordActivity>
                            {
                                new DiscordActivity()
                                {
                                    Name = str,
                                    Type = ActivityType.Game
                                }
                            }
                        });
                    }
                }
            }

            timer.In(Mathf.Clamp(Configuration.Settings.StatusCycle, 60, int.MaxValue), UpdateStatus);
        }
        #endregion

        #region Helpers
        private GuildMember FindMember(Snowflake id)
        {
            foreach (GuildMember guildMember in Guild.Members.Values)
            {
                if (guildMember.Id.Equals(id))
                    return guildMember;
            }

            return null;
        }
                
        public DiscordRole GetRoleByID(string id)
        {
            if (!string.IsNullOrEmpty(id))
            {
                foreach (DiscordRole role in Guild.Roles.Values)
                {
                    if (role.Id.ToString().Equals(id, StringComparison.OrdinalIgnoreCase))
                        return role;
                }
            }

            return null;
        }

        private int GenerateToken()
        {
            int token = UnityEngine.Random.Range(100000, 999999);
            if (userData.tokenToUser.ContainsKey(token))
                return GenerateToken();
            return token;
        }

        private static double CurrentTime() => DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds;

        private T ParseType<T>(string type) => (T)Enum.Parse(typeof(T), type, true);

        private string FormatTime(double time)
        {
            TimeSpan dateDifference = TimeSpan.FromSeconds((float)time);
            int days = dateDifference.Days;
            int hours = dateDifference.Hours;
            int mins = dateDifference.Minutes;
            int secs = dateDifference.Seconds;

            if (days > 0)
                return string.Format("{0:00}d:{1:00}h:{2:00}m:{3:00}s", days, hours, mins, secs);
            else if (hours > 0)
                return string.Format("{0:00}h:{1:00}m:{2:00}s", hours, mins, secs);
            else if (mins > 0)
                return string.Format("{0:00}m:{1:00}s", mins, secs);
            else return string.Format("{0}s", secs);
        }
        #endregion

        #region Groups and Permission Helpers
        private void AddToGroup(string userId, string groupId) => permission.AddUserGroup(userId, groupId);

        private void RemoveFromGroup(string userId, string groupId) => permission.RemoveUserGroup(userId, groupId);

        private bool GroupExists(string groupId) => permission.GroupExists(groupId);

        private bool HasGroup(string userId, string groupId) => permission.UserHasGroup(userId, groupId);
               
        private void GrantPermission(string userId, string perm) => permission.GrantUserPermission(userId, perm, null);

        private void RevokePermission(string userId, string perm) => permission.RevokeUserPermission(userId, perm);

        private bool HasPermission(string userId, string perm) => permission.UserHasPermission(userId, perm);

        private bool PermissionExists(string userId) => permission.PermissionExists(userId);
        #endregion

        #region User Validation
        private void ValidateUser(BasePlayer player)
        {
            if (player == null)
                return;

            if (player.IsSleeping() || player.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot))
            {
                timer.In(3, () => ValidateUser(player));
                return;
            }

            UserData.User user;
            if (!userData.users.TryGetValue(player.userID, out user))
                return;

            if (CurrentTime() > user.expireTime)
            {
                if (Configuration.Token.RequireRevalidation)
                {
                    if (Configuration.Token.AutoRevalidation)
                    {
                        if (FindMember(user.Id) != null)
                        {
                            user.SetExpiryDate(Configuration.Token.RevalidationInterval);
                            IssueAlternativeRewards(player);
                            SendReply(player, Message("Message.AutoValidated", player.userID));
                            return;
                        }
                    }

                    SendReply(player, Message("Message.ValidationExpired", player.userID));
                    RevokeRewards(player.userID, user);
                    return;
                }
            }
        }
        #endregion

        #region Rewards
        private void IssueAlternativeRewards(BasePlayer player)
        {
            UserData.User user;
            if (!userData.users.TryGetValue(player.userID, out user))
                return;

            for (int i = 0; i < Configuration.Rewards.Groups.Length; i++)
            {
                string group = Configuration.Rewards.Groups[i];
                if (GroupExists(group) && !HasGroup(player.UserIDString, group))
                {
                    AddToGroup(player.UserIDString, group);
                    user.groups.Add(group);
                }
            }

            for (int i = 0; i < Configuration.Rewards.Permissions.Length; i++)
            {
                string perm = Configuration.Rewards.Permissions[i];
                if (PermissionExists(perm) && !HasPermission(player.UserIDString, perm))
                {
                    GrantPermission(player.UserIDString, perm);
                    user.permissions.Add(perm);
                }
            }

            for (int i = 0; i < Configuration.Rewards.Commands.Length; i++)
            {
                string cmd = Configuration.Rewards.Commands[i];
                rust.RunServerCommand(cmd.Replace("$player.id", player.UserIDString)
                    .Replace("$player.name", player.displayName)
                    .Replace("$player.x", player.transform.position.x.ToString())
                    .Replace("$player.y", player.transform.position.y.ToString())
                    .Replace("$player.z", player.transform.position.z.ToString())
                    );
            }

            if (Configuration.Rewards.Roles.Length > 0)
                ApplyUserRoles(user, Configuration.Rewards.Roles, true);

            if (Configuration.Rewards.RevokeRoles.Length > 0)
                RevokeUserRoles(user, Configuration.Rewards.RevokeRoles, false);

            Guild.GetGuildMember(Client, user.Id, (GuildMember guildMember) =>
            {
                bool wasNitroBooster = user.isNitroBooster;

                user.isNitroBooster = NitroRole != null && guildMember.HasRole(NitroRole);

                if (user.isNitroBooster)
                    IssueNitroRewards(player, user);
                else if (wasNitroBooster)
                    RevokeNitroRewards(player.userID, user);
            });
        }

        private void ApplyUserRoles(UserData.User user, IEnumerable<string> roles, bool storeChanges)
        {
            Guild.GetGuildMember(Client, user.Id, (GuildMember guildMember) =>
            {
                bool hasAllRoles = true;
                foreach (string roleName in roles)
                {
                    DiscordRole discordRole = Guild.GetRole(roleName);
                    if (discordRole == null)
                        discordRole = GetRoleByID(roleName);

                    if (discordRole != null)
                    {
                        if (guildMember.HasRole(discordRole))
                        {
                            if (storeChanges)                            
                                user.roles.Add(discordRole.Id);                            
                            continue;
                        }

                        hasAllRoles = false;
                        Guild.AddGuildMemberRole(Client, guildMember.User, discordRole);
                    }
                }

                if (!hasAllRoles)
                    timer.In(5f, () => ApplyUserRoles(user, roles, storeChanges));
            });
        }

        private void RevokeUserRoles(UserData.User user, IEnumerable<string> roles, bool storeChanges)
        {
            Guild.GetGuildMember(Client, user.Id, (GuildMember guildMember) =>
            {
                bool allRolesRemoved = true;
                foreach (string roleName in roles)
                {
                    DiscordRole discordRole = Guild.GetRole(roleName);
                    if (discordRole == null)
                        discordRole = GetRoleByID(roleName);

                    if (discordRole != null)
                    {
                        if (!guildMember.HasRole(discordRole))
                        {
                            if (storeChanges)
                                user.roles.Remove(discordRole.Id);
                            continue;
                        }

                        allRolesRemoved = false;
                        Guild.RemoveGuildMemberRole(Client, guildMember.User, discordRole);
                    }
                }

                if (!allRolesRemoved)
                    timer.In(5f, () => RevokeUserRoles(user, roles, storeChanges));
            });
        }

        private void IssueNitroRewards(BasePlayer player, UserData.User user)
        {
            for (int i = 0; i < Configuration.Rewards.NitroGroups.Length; i++)
            {
                string group = Configuration.Rewards.NitroGroups[i];
                if (GroupExists(group) && !HasGroup(player.UserIDString, group))
                {
                    AddToGroup(player.UserIDString, group);
                    user.nitroGroups.Add(group);
                }
            }

            for (int i = 0; i < Configuration.Rewards.NitroPermissions.Length; i++)
            {
                string perm = Configuration.Rewards.NitroPermissions[i];
                if (PermissionExists(perm) && !HasPermission(player.UserIDString, perm))
                {
                    GrantPermission(player.UserIDString, perm);
                    user.nitroPermissions.Add(perm);
                }
            }

            for (int i = 0; i < Configuration.Rewards.NitroCommands.Length; i++)
            {
                string cmd = Configuration.Rewards.NitroCommands[i];
                rust.RunServerCommand(cmd.Replace("$player.id", player.UserIDString)
                                         .Replace("$player.name", player.displayName)
                                         .Replace("$player.x", player.transform.position.x.ToString())
                                         .Replace("$player.y", player.transform.position.y.ToString())
                                         .Replace("$player.z", player.transform.position.z.ToString()));
            }
        }

        private void RevokeRewards(ulong playerId, UserData.User user)
        {
            foreach (string group in user.groups)
                RemoveFromGroup(playerId.ToString(), group);
            user.groups.Clear();

            foreach (string perm in user.permissions)
                RevokePermission(playerId.ToString(), perm);
            user.permissions.Clear();

            if (user.roles.Count > 0)
                RevokeUserRoles(user, new List<string>(user.roles), true);

            if (Configuration.Rewards.RevokeRoles.Length > 0)
                ApplyUserRoles(user, Configuration.Rewards.RevokeRoles, false);

            if (user.isNitroBooster)
                RevokeNitroRewards(playerId, user);
        }

        private void RevokeNitroRewards(ulong playerId, UserData.User user)
        {
            foreach (string group in user.nitroGroups)
                RemoveFromGroup(playerId.ToString(), group);
            user.nitroGroups.Clear();

            foreach (string perm in user.nitroPermissions)
                RevokePermission(playerId.ToString(), perm);
            user.nitroPermissions.Clear();
        }
        #endregion

        #region UI
        private const string UI_MENU = "discordstore_ui";

        private class UI
        {
            public static CuiElementContainer Container(string panel, UI4 dimensions, string color = "0 0 0 0.9")
            {
                CuiElementContainer container = new CuiElementContainer()
                {
                    {
                        new CuiPanel
                        {
                            Image = {Color = color, Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat"},
                            RectTransform = {AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax()},
                            CursorEnabled = true
                        },
                        new CuiElement().Parent = "Hud",
                        panel.ToString()
                    }
                };
                return container;
            }

            public static void Panel(CuiElementContainer container, string panel, string color, UI4 dimensions)
            {
                container.Add(new CuiPanel
                {
                    Image = { Color = color },
                    RectTransform = { AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() }
                },
                panel);
            }

            public static void Label(CuiElementContainer container, string panel, string text, int size, UI4 dimensions, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiLabel
                {
                    Text = { FontSize = size, Align = align, Text = text },
                    RectTransform = { AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() }
                },
                panel);
            }

            public static void Button(CuiElementContainer container, string panel, string color, string text, int size, UI4 dimensions, string command, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiButton
                {
                    Button = { Color = color, Command = command, FadeIn = 0f, },
                    RectTransform = { AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() },
                    Text = { Text = text, FontSize = size, Align = align }

                },
                panel);
            }

            public static void Image(CuiElementContainer container, string panel, string png, UI4 dimensions)
            {
                container.Add(new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = panel,
                    Components =
                    {
                        new CuiRawImageComponent {Png = png },
                        new CuiRectTransformComponent { AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() }
                    }
                });
            }

            public static string Color(string hexColor, float alpha)
            {
                if (hexColor.StartsWith("#"))
                    hexColor = hexColor.TrimStart('#');
                int red = int.Parse(hexColor.Substring(0, 2), NumberStyles.AllowHexSpecifier);
                int green = int.Parse(hexColor.Substring(2, 2), NumberStyles.AllowHexSpecifier);
                int blue = int.Parse(hexColor.Substring(4, 2), NumberStyles.AllowHexSpecifier);
                return $"{(double)red / 255} {(double)green / 255} {(double)blue / 255} {alpha}";
            }
        }

        public struct UI4
        {
            public float xMin, yMin, xMax, yMax;

            public UI4(float xMin, float yMin, float xMax, float yMax)
            {
                this.xMin = xMin;
                this.yMin = yMin;
                this.xMax = xMax;
                this.yMax = yMax;
            }

            public string GetMin() => $"{xMin} {yMin}";

            public string GetMax() => $"{xMax} {yMax}";

            private static UI4 _full;

            public static UI4 Full
            {
                get
                {
                    if (_full.Equals(default(UI4)))
                        _full = new UI4(0, 0, 1, 1);
                    return _full;
                }
            }
        }
        #endregion

        #region UI Creation
        private void OpenStore(BasePlayer player)
        {
            if (rewardData.items.Count > 0)
                LoadStoreUI(player, RewardType.Item, 0);
            else if (rewardData.kits.Count > 0)
                LoadStoreUI(player, RewardType.Kit, 0);
            else if (rewardData.commands.Count > 0)
                LoadStoreUI(player, RewardType.Command, 0);
            else SendReply(player, Message("Error.NoItems", player.userID));
        }
       
        private void LoadStoreUI(BasePlayer player, RewardType rewardType, int page)
        {
            UserData.User user;
            if (!userData.users.TryGetValue(player.userID, out user))
                return;

            CuiElementContainer container = UI.Container(UI_MENU, new UI4(0.3f, 0.35f, 0.7f, 0.65f));

            UI.Panel(container, UI_MENU, Configuration.UISettings.Panel.Color, new UI4(0.0075f, 0.88f, 0.9925f, 0.98f));

            UI.Label(container, UI_MENU, Message("UI.Title", player.userID), 18, new UI4(0.015f, 0.88f, 0.99f, 0.98f), TextAnchor.MiddleLeft);

            UI.Button(container, UI_MENU, Configuration.UISettings.Close.Color, "<b>×</b>", 18, new UI4(0.95f, 0.88f, 0.992f, 0.98f), "drui.exit");

            AddCategoryButtons(container, rewardType, player.userID);

            switch (rewardType)
            {
                case RewardType.Kit:
                    PopulateItems<RewardData.RewardKit>(rewardData.kits, container, page * 4, player.userID, user.isNitroBooster);
                    break;
                case RewardType.Item:
                    PopulateItems<RewardData.RewardItem>(rewardData.items, container, page * 4, player.userID, user.isNitroBooster);
                    break;
                case RewardType.Command:
                    PopulateItems<RewardData.RewardCommand>(rewardData.commands, container, page * 4, player.userID, user.isNitroBooster);
                    break;
            }            

            AddPagination(container, rewardType, page);

            CuiHelper.DestroyUi(player, UI_MENU);
            CuiHelper.AddUi(player, container);
        }

        private void AddCategoryButtons(CuiElementContainer container, RewardType selected, ulong playerId)
        {
            int i = 0;
            UI4 position = TypeAlignment.Get(i);

            if (rewardData.kits.Count > 0)
            {
                UI.Button(container, UI_MENU, selected == RewardType.Kit ? Configuration.UISettings.Selected.Color : Configuration.UISettings.Deselected.Color, 
                    Message("UI.Kits", playerId), 12, new UI4(position.xMin, position.yMin, position.xMax, position.yMax), selected == RewardType.Kit ? "" : "drui.changepage kit 0");                
                i++;
                position = TypeAlignment.Get(i);
            }
            if (rewardData.items.Count > 0)
            {                
                UI.Button(container, UI_MENU, selected == RewardType.Item ? Configuration.UISettings.Selected.Color : Configuration.UISettings.Deselected.Color, 
                    Message("UI.Items", playerId), 12, new UI4(position.xMin, position.yMin, position.xMax, position.yMax), selected == RewardType.Item ? "" : "drui.changepage item 0");
                i++;
                position = TypeAlignment.Get(i);
            }
            if (rewardData.commands.Count > 0)
            {
                UI.Button(container, UI_MENU, selected == RewardType.Command ? Configuration.UISettings.Selected.Color : Configuration.UISettings.Deselected.Color, 
                    Message("UI.Commands", playerId), 12, new UI4(position.xMin, position.yMin, position.xMax, position.yMax), selected == RewardType.Command ? "" : "drui.changepage command 0");                
            }            
        }

        private void PopulateItems<T>(List<T> list, CuiElementContainer container, int index, ulong playerId, bool isNitroBooster) where T : RewardData.BaseReward
        {
            int count = 0;

            for (int i = index; i < Mathf.Min(list.Count, index + 4); i++)
            {               
                RewardData.BaseReward reward = list[i];
               
                UI4 position = RewardAlignment.Get(count);

                reward.AddUIEntry(container, position, i, playerId, isNitroBooster);
                count++;
            }
        }

        private void AddPagination(CuiElementContainer container, RewardType rewardType, int page)
        {
            int max = rewardType == RewardType.Command ? rewardData.commands.Count : rewardType == RewardType.Item ? rewardData.items.Count : rewardData.kits.Count;

            if (page > 0)
                UI.Button(container, UI_MENU, Configuration.UISettings.Close.Color, "< < <", 12, new UI4(0.01f, 0.01f, 0.2f, 0.08f), $"drui.changepage {rewardType} {page - 1}");
            if ((page * 3) + 3 < max)
                UI.Button(container, UI_MENU, Configuration.UISettings.Close.Color, "> > >", 12, new UI4(0.8f, 0.01f, 0.99f, 0.08f), $"drui.changepage {rewardType} {page + 1}");
        }
        #endregion

        #region UI Grid Helper
        private readonly HoriztonalAlignment RewardAlignment = new HoriztonalAlignment(4, 0.0075f, 0.01f, 0.76f, 0.66f, 0.06f);

        private readonly HoriztonalAlignment TypeAlignment = new HoriztonalAlignment(5, 0.0075f, 0.01f, 0.86f, 0.08f, 0f);

        private class HoriztonalAlignment
        {
            private int Columns { get; set; }
            private float XBorder { get; set; }
            private float XSpacing { get; set; }
            private float YOffset { get; set; }
            private float Height { get; set; }
            private float YSpacing { get; set; }
            private float ReservedSpace { get; set; }
            private float Width { get; set; }

            internal HoriztonalAlignment(int columns, float xBorder, float xSpacing, float yOffset, float height, float ySpacing)
            {
                Columns = columns;
                XBorder = xBorder;
                XSpacing = xSpacing;
                YOffset = yOffset;
                Height = height;
                YSpacing = ySpacing;

                ReservedSpace = (xBorder * 2f) + (XSpacing * (columns - 1));
                Width = (1f - ReservedSpace) / columns;
            }

            internal UI4 Get(int index)
            {
                int rowNumber = index == 0 ? 0 : Mathf.FloorToInt(index / Columns);
                int columnNumber = index - (rowNumber * Columns);
                
                float offsetX = XBorder + (Width * columnNumber) + (XSpacing * columnNumber);

                float offsetY = (YOffset - (rowNumber * Height) - (YSpacing * rowNumber));

                return new UI4(offsetX, offsetY - Height, offsetX + Width, offsetY);
            }
        }
        #endregion

        #region UI Commands
        [ConsoleCommand("drui.changepage")]
        private void ccmdChangePage(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            LoadStoreUI(player, ParseType<RewardType>(arg.GetString(0)), arg.GetInt(1));
        }

        [ConsoleCommand("drui.exit")]
        private void ccmdExit(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            CuiHelper.DestroyUi(player, UI_MENU);
        }

        [ConsoleCommand("drui.claim")]
        private void ccmdClaim(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            UserData.User user;
            if (!userData.users.TryGetValue(player.userID, out user))
                return;

            int id = arg.GetInt(1);

            RewardType rewardType = ParseType<RewardType>(arg.GetString(0));

            double remaining;

            if (Configuration.Cooldown.Enabled && user.HasCooldown(out remaining))
            {
                SendReply(player, string.Format(Message("Message.OnCooldownGlobal", player.userID), FormatTime(remaining)));
                return;
            }
            if (user.HasCooldown(rewardType, id, out remaining))
            {
                SendReply(player, string.Format(Message("Message.OnCooldown", player.userID), FormatTime(remaining)));
                return;
            }

            RewardData.BaseReward reward;

            if (rewardType == RewardType.Command)
                reward = rewardData.commands[id];
            else if (rewardType == RewardType.Item)
                reward = rewardData.items[id];
            else reward = rewardData.kits[id];

            if (Configuration.Cooldown.Enabled)
                user.AddCooldown(Configuration.Cooldown.Time);
            else user.AddCooldown(rewardType, id, reward.Cooldown);

            CuiHelper.DestroyUi(player, UI_MENU);

            reward.GiveReward(player);
            SendReply(player, Message("Message.RewardGiven", player.userID));
        }
        #endregion

        #region Chat Commands 
        [ChatCommand("discord")]
        private void cmdDiscord(BasePlayer player, string command, string[] args)
        {
            if (!isInitialized)
                return;

            UserData.User user = userData.GetUser(player.userID);
            if (user == null || (Configuration.Token.RequireRevalidation && CurrentTime() > user.expireTime))
            {
                if (args.Length == 0)
                {
                    SendReply(player, Message("Help.Token", player.userID));
                    if (ValidationChannel != null)
                        SendReply(player, string.Format(Message("Help.BotOrChannel", player.userID), Client.Bot.BotUser.Username, ValidationChannel.Name));
                    else SendReply(player, string.Format(Message("Help.BotOnly", player.userID), Client.Bot.BotUser.Username));

                    return;
                }

                int code;
                if (userData.HasPendingToken(player.userID, out code))
                {
                    SendReply(player, string.Format(Message("Error.PendingToken", player.userID), code, Client.Bot.BotUser.Username));
                    return;
                }

                if (args[0].ToLower() == "token")
                {
                    code = GenerateToken();

                    userData.AddToken(code, player.userID, Configuration.Token.TokenLife);

                    SendReply(player, string.Format(Message("Message.Token", player.userID), code));
                }                
                return;
            }

            if (Configuration.UISettings.Enabled)
                OpenStore(player);
            else SendReply(player, Message("Message.AlreadyRegistered"));
        }
        #endregion

        #region Console Commands
        [ConsoleCommand("discord.admin")]
        private void ccmdDiscordAdmin(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel != 2)
                return;
            
            string[] args = arg.Args;
            if (args == null || args.Length == 0)
            {
                SendReply(arg, $"{Title}  v{Version}");
                SendReply(arg, "discord.admin purge - Clear out all expired user data");
                SendReply(arg, "discord.admin wipe - Revoke rewards from all players and invalidate their tokens");
                SendReply(arg, "discord.admin revoke <player ID> - Revoke all rewards from the target player and invalidate their token");
                SendReply(arg, "discord.admin validatepermissions - Purges user data and validates user permissions to reinstate any that are missing");
                return;
            }

            switch (args[0].ToLower())
            {
                case "purge":
                    {
                        if (!Configuration.Token.RequireRevalidation)
                        {
                            SendReply(arg, "You can not purge the data file because you have Require Validation set to false in your config");
                            return;
                        }

                        double currentTime = CurrentTime();
                        int count = 0;

                        for (int i = userData.users.Count - 1; i >= 0; i--)
                        {
                            KeyValuePair<ulong, UserData.User> kvp = userData.users.ElementAt(i);
                            if (currentTime > kvp.Value.expireTime || string.IsNullOrEmpty(kvp.Value.discordId))
                            {
                                RevokeRewards(kvp.Key, kvp.Value);
                                userData.users.Remove(kvp.Key);
                                count++;
                            }
                        }
                        SaveData();
                        UpdateStatus();

                        SendReply(arg, $"Revoked rewards and purged {count} users with expired tokens from the data file");
                    }
                    return;

                case "wipe":                    
                    WipeData();
                    SendReply(arg, "Revoked all user rewards and wiped user data");
                    return;

                case "revoke":
                    if (args.Length == 2)
                    {
                        ulong playerId;
                        if (!ulong.TryParse(args[1], out playerId))
                        {
                            SendReply(arg, "Invalid Steam ID entered");
                            return;
                        }

                        UserData.User user;
                        if (!userData.users.TryGetValue(playerId, out user))
                        {
                            SendReply(arg, "The specified user does not have any data saved");
                            return;
                        }

                        RevokeRewards(playerId, user);
                        userData.users.Remove(playerId);
                        SaveData();
                        UpdateStatus();

                        SendReply(arg, $"Successfully revoked rewards for user: {playerId}");
                    }
                    else SendReply(arg, "You must enter a players Steam ID");
                    return;

                case "validatepermissions":
                    {
                        int purgeCount = 0;
                        int reinstateCount = 0;

                        if (Configuration.Token.RequireRevalidation)
                        {
                            double currentTime = CurrentTime();
                            for (int i = userData.users.Count - 1; i >= 0; i--)
                            {
                                KeyValuePair<ulong, UserData.User> kvp = userData.users.ElementAt(i);
                                if (currentTime > kvp.Value.expireTime)
                                {                                    
                                    RevokeRewards(kvp.Key, kvp.Value);
                                    userData.users.Remove(kvp.Key);
                                    purgeCount++;
                                }
                            }
                        }
                        foreach (KeyValuePair<ulong, UserData.User> kvp in userData.users)
                        {
                            foreach(string perm in kvp.Value.permissions)
                            {
                                if (!HasPermission(kvp.Key.ToString(), perm))
                                {
                                    GrantPermission(kvp.Key.ToString(), perm);
                                    reinstateCount++;
                                }
                            }
                        }
                        SendReply(arg, $"Purged {purgeCount} inactive users and reinstated missing permissions for {reinstateCount} users");
                    }                    
                    return;

                default:
                    break;
            }
        }

        [ConsoleCommand("discord.rewards")]
        private void ccmdDiscordRewards(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel != 2)
                return;            

            string[] args = arg.Args;
            if (args == null || args.Length == 0)
            {
                SendReply(arg, $"{Title}  v{Version}");
                SendReply(arg, "--- List Rewards ---");
                SendReply(arg, "discord.rewards list <items | kits | commands> - Display a list of rewards for the specified category, which information on each item");
                SendReply(arg, "--- Add Rewards ---");
                SendReply(arg, "discord.rewards add item <shortname> <skinId> <amount> <cooldown> <opt:bp> - Add a new reward item to the store (add \"bp\" to add the item as a blueprint)");
                SendReply(arg, "discord.rewards add kit <name> <kitname> <cooldown> - Add a new reward kit to the store");
                SendReply(arg, "discord.rewards add command <name> <command> <cooldown> - Add a new reward command to the store");
                SendReply(arg, "--- Editing Rewards ---");
                SendReply(arg, "discord.rewards edit item <ID> <name | amount | cooldown> \"edit value\" - Edit the specified field of the item with ID number <ID>");
                SendReply(arg, "discord.rewards edit kit <ID> <name | description | icon | cooldown> \"edit value\" - Edit the specified field of the kit with ID number <ID>");
                SendReply(arg, "discord.rewards edit command <ID> <name | amount | description | icon | add | remove | cooldown> \"edit value\" - Edit the specified field of the kit with ID number <ID>");
                SendReply(arg, "Icon field : The icon field can either be a URL, or a image saved to disk under the folder \"oxide/data/DiscordRewards/Images/\"");
                SendReply(arg, "Command add/remove field: Here you add additional commands or remove existing commands. Be sure to type the command inside quotation marks");
                SendReply(arg, "--- Removing Rewards ---");
                SendReply(arg, "discord.rewards remove item <ID #> - Removes the item with the specified ID number");
                SendReply(arg, "discord.rewards remove kit <ID #> - Removes the kit with the specified ID number");
                SendReply(arg, "discord.rewards remove command <ID #> - Removes the command with the specified ID number");
                SendReply(arg, "--- Important Note ---");
                SendReply(arg, "Removing rewards may change each rewards ID number. Be sure to list your rewards before removing them");
                SendReply(arg, "To set a reward for Nitro Boosters only add the word 'nitro' to the end of the command when adding the reward!");
                return;
            }

            bool isNitro = arg.Args.Last().ToLower() == "nitro";

            if (args.Length >= 1)
            {
                switch (args[0].ToLower())
                {
                    #region Lists
                    case "list":
                        if (args.Length >= 2)
                        {
                            int i = 0;
                            switch (args[1].ToLower())
                            {
                                case "items":
                                    foreach (var entry in rewardData.items)
                                    {
                                        SendReply(arg, string.Format("Item ID: {0} || Shortname: {1} ||  Amount: {2} || Skin ID: {3} ||Is Blueprint {4} || Cooldown : {5}", i, entry.Shortname, entry.Amount, entry.SkinID, entry.IsBP, entry.Cooldown));
                                        i++;
                                    }
                                    return;

                                case "kits":
                                    i = 0;
                                    foreach (var entry in rewardData.kits)
                                    {
                                        SendReply(arg, string.Format("Kit ID: {0} || Name: {1} || Description: {2} || Cooldown : {3}", i, entry.Kit, entry.Description, entry.Cooldown));
                                        i++;
                                    }
                                    return;

                                case "commands":
                                    i = 0;
                                    foreach (var entry in rewardData.commands)
                                    {
                                        SendReply(arg, string.Format("Command ID: {0} || Name: {1} || Description: {2} || Commands: {3} || Cooldown : {4}", i, entry.Name, entry.Description, entry.Commands.ToSentence(), entry.Cooldown));
                                        i++;
                                    }
                                    return;

                                default:
                                    return;
                            }
                        }
                        return;
                    #endregion
                    #region Additions
                    case "add":
                        if (args.Length >= 2)
                        {
                            switch (args[1].ToLower())
                            {
                                case "item":
                                    if (args.Length >= 6)
                                    {
                                        string shortname = args[2];

                                        ulong skinId;
                                        if (!ulong.TryParse(args[3], out skinId))
                                        {
                                            SendReply(arg, "You must enter a number for the skin ID. If you dont wish to select any skin use 0");
                                            return;
                                        }

                                        int amount;
                                        if (!int.TryParse(args[4], out amount))
                                        {
                                            SendReply(arg, "You must enter an amount of this item");
                                            return;
                                        }

                                        int cooldown = 0;
                                        if (!int.TryParse(args[5], out cooldown))
                                        {
                                            SendReply(arg, "You must enter a cooldown for this item");
                                            return;
                                        }

                                        ItemDefinition itemDefinition = ItemManager.FindItemDefinition(shortname);
                                        if (itemDefinition != null)
                                        {
                                          
                                            RewardData.RewardItem newItem = new RewardData.RewardItem
                                            {
                                                Amount = amount,
                                                Name = itemDefinition.displayName.translated,
                                                SkinID = skinId,
                                                Shortname = shortname,
                                                Cooldown = cooldown,
                                                IsBP = (args.Length >= 7 && args[6].ToLower() == "bp"),
                                                Nitro = isNitro
                                            };
                                           
                                            rewardData.items.Add(newItem);
                                            SendReply(arg, $"You have added {itemDefinition.displayName.english} to DiscordRewards");
                                            SaveRewards();
                                        }
                                        else SendReply(arg, "Invalid item selected!");
                                    }
                                    else SendReply(arg, "discord.rewards add item <shortname> <skinId> <amount> <cooldown> <opt:bp>");
                                    return;

                                case "kit":
                                    if (args.Length >= 5)
                                    {                                      
                                        int cooldown = 0;
                                        if (!int.TryParse(args[4], out cooldown))
                                        {
                                            SendReply(arg, "You must enter a cooldown for this kit");
                                            return;
                                        }

                                        object isKit = Kits?.Call("isKit", new object[] { args[3] });
                                        if (isKit is bool && (bool)isKit)
                                        {                                            
                                            rewardData.kits.Add(new RewardData.RewardKit { Name = args[2], Kit = args[3], Description = "", Cooldown = cooldown,
                                                Nitro = isNitro
                                            });
                                            SendReply(arg, $"You have added {args[3]} to DiscordRewards");
                                            SaveRewards();
                                        }
                                        else SendReply(arg, "Invalid kit selected");
                                    }
                                    else SendReply(arg, "discord.rewards add kit <Name> <kitname> <cooldown>");
                                    return;

                                case "command":
                                    if (args.Length >= 5)
                                    {                                      
                                        int cooldown = 0;
                                        if (!int.TryParse(args[4], out cooldown))
                                        {
                                            SendReply(arg, "You must enter a cooldown for this kit");
                                            return;
                                        }

                                        rewardData.commands.Add(new RewardData.RewardCommand { Name = args[2], Commands = new List<string>{ args[3] }, Description = "", Cooldown = cooldown,
                                            Nitro = isNitro
                                        });
                                        SendReply(arg, $"You have added a new command group to DiscordRewards");
                                        SaveRewards();
                                    }
                                    else SendReply(arg, "discord.rewards add command <name> <command> <cooldown>");
                                    return;
                            }
                        }

                        return;
                    #endregion
                    #region Removal
                    case "remove":
                        if (args.Length == 3)
                        {
                            int id = 0;
                            if (!int.TryParse(args[2], out id) || id < 0)
                            {
                                SendReply(arg, "You must enter a valid ID number");
                                return;
                            }                            

                            switch (args[1].ToLower())
                            {                                
                                case "kit":
                                    if (id < rewardData.kits.Count)
                                    {
                                        rewardData.kits.RemoveAt(id);
                                        SendReply(arg, $"Successfully removed kit with ID: {id}");
                                        SaveRewards();
                                    }
                                    else SendReply(arg, Message("noKitRem"), "");
                                    return;
                                case "item":
                                    if (id < rewardData.items.Count)
                                    {
                                        rewardData.items.RemoveAt(id);
                                        SendReply(arg, $"Successfully removed item with ID: {id}");
                                        SaveRewards();
                                    }
                                    else SendReply(arg, Message("noItemRem"), "");
                                    return;
                                case "command":
                                    if (id < rewardData.commands.Count)
                                    {
                                        rewardData.commands.RemoveAt(id);
                                        SendReply(arg, $"Successfully removed command with ID: {id}");
                                        SaveRewards();
                                    }
                                    else SendReply(arg, Message("noCommandRem"), "");
                                    return;
                            }
                        }
                        return;
                    #endregion
                    #region Editing
                    case "edit":
                        if (args.Length >= 3)
                        {
                            int id = 0;
                            if (!int.TryParse(args[2], out id) || id < 0)
                            {
                                SendReply(arg, "You must enter a valid ID number");
                                return;
                            }

                            switch (args[1].ToLower())
                            {
                                case "kit":
                                    if (id < rewardData.kits.Count)
                                    {
                                        if (args.Length >= 5)
                                        {
                                            switch (args[3].ToLower())
                                            {                                              
                                                case "description":
                                                    rewardData.kits.ElementAt(id).Description = args[4];
                                                    SaveRewards();
                                                    SendReply(arg, string.Format("Kit {0} description set to {1}", args[2], args[4]));
                                                    return;
                                                case "name":
                                                    rewardData.kits.ElementAt(id).Name = args[4];
                                                    SaveRewards();
                                                    SendReply(arg, string.Format("Kit {0} name set to {1}", args[2], args[4]));
                                                    return;
                                                case "icon":
                                                    rewardData.kits.ElementAt(id).Icon = args[4];
                                                    SaveRewards();
                                                    SendReply(arg, string.Format("Kit {0} icon set to {1}", args[2], args[4]));
                                                    return;
                                                case "cooldown":
                                                    int cooldown = 0;
                                                    if (int.TryParse(args[4], out cooldown))
                                                    {
                                                        rewardData.kits.ElementAt(id).Cooldown = cooldown;
                                                        SaveRewards();
                                                        SendReply(arg, string.Format("Kit {0} cooldown set to {1} seconds", args[2], args[4]));
                                                    }
                                                    else SendReply(arg, "You must enter a cooldown number");
                                                    return;
                                                default:
                                                    SendReply(arg, "discord.rewards edit kit <ID> <description|name|icon|cooldown> \"info here\"");
                                                    return; ;
                                            }
                                        }
                                        else SendReply(arg, "discord.rewards edit kit <ID> <description|name|icon|cooldown> \"info here\"");
                                    }
                                    else SendReply(arg, "Invalid ID number selected");
                                    return;
                                case "item":
                                    if (id < rewardData.items.Count)
                                    {
                                        if (args.Length >= 5)
                                        {
                                            switch (args[3].ToLower())
                                            {
                                                case "amount":
                                                    int amount = 0;
                                                    if (int.TryParse(args[4], out amount))
                                                    {
                                                        rewardData.items.ElementAt(id).Amount = amount;
                                                        SaveRewards();
                                                        SendReply(arg, string.Format("Item {0} amount set to {1}", args[2], amount));
                                                    }
                                                    else SendReply(arg, "Invalid amount entered");
                                                    return;
                                                case "skinid":
                                                    ulong skinId = 0;
                                                    if (ulong.TryParse(args[4], out skinId))
                                                    {
                                                        rewardData.items.ElementAt(id).SkinID = skinId;
                                                        SaveRewards();
                                                        SendReply(arg, string.Format("Item {0} skin set to {1}", args[2], skinId));
                                                    }
                                                    else SendReply(arg, "Invalid skin ID entered");
                                                    return;
                                                case "isbp":
                                                    bool isBp;
                                                    if (bool.TryParse(args[4], out isBp))
                                                    {
                                                        rewardData.items.ElementAt(id).IsBP = isBp;
                                                        SaveRewards();
                                                        SendReply(arg, string.Format("Item {0} blueprint set to {1}", args[2], isBp));
                                                    }
                                                    else SendReply(arg, "You must enter true or false");
                                                    return;
                                                case "icon":
                                                    rewardData.items.ElementAt(id).Icon = args[4];
                                                    SaveRewards();
                                                    SendReply(arg, string.Format("Item {0} icon set to {1}", args[2], args[4]));
                                                    return;
                                                case "cooldown":
                                                    int cooldown = 0;
                                                    if (int.TryParse(args[4], out cooldown))
                                                    {
                                                        rewardData.items.ElementAt(id).Cooldown = cooldown;
                                                        SaveRewards();
                                                        SendReply(arg, string.Format("Item {0} cooldown set to {1} seconds", args[2], args[4]));
                                                    }
                                                    else SendReply(arg, "You must enter a cooldown number");
                                                    return;
                                                default:
                                                    SendReply(arg, "discord.rewards edit item <ID> <amount|skinid|isbp|icon|cooldown> \"info here\"");
                                                    return;
                                            }
                                        }
                                        else SendReply(arg, "discord.rewards edit item <ID> <amount|skinid|isbp|icon|cooldown> \"info here\"");
                                    }
                                    else SendReply(arg, "Invalid ID number selected");
                                    return;
                                case "command":
                                    if (id < rewardData.commands.Count)
                                    {
                                        if (args.Length >= 5)
                                        {
                                            switch (args[3].ToLower())
                                            {                                              
                                                case "description":
                                                    rewardData.commands.ElementAt(id).Description = args[4];
                                                    SaveRewards();
                                                    SendReply(arg, string.Format("Command {0} description set to {1}", args[2], args[4]));
                                                    return;
                                                case "name":
                                                    rewardData.commands.ElementAt(id).Name = args[4];
                                                    SaveRewards();
                                                    SendReply(arg, string.Format("Command {0} name set to {1}", args[2], args[4]));
                                                    return;
                                                case "icon":
                                                    rewardData.commands.ElementAt(id).Icon = args[4];
                                                    SaveRewards();
                                                    SendReply(arg, string.Format("Command {0} icon set to {1}", args[2], args[4]));
                                                    return;
                                                case "add":
                                                    if (!rewardData.commands.ElementAt(id).Commands.Contains(args[4]))
                                                    {
                                                        rewardData.commands.ElementAt(id).Commands.Add(args[4]);
                                                        SaveRewards();
                                                        SendReply(arg, string.Format("Added command \"{1}\" to Reward Command {0}", args[2], args[4]));
                                                    }
                                                    else SendReply(arg, string.Format("The command \"0\" is already registered to this reward command", args[4]));
                                                    return;
                                                case "remove":
                                                    if (rewardData.commands.ElementAt(id).Commands.Contains(args[4]))
                                                    {
                                                        rewardData.commands.ElementAt(id).Commands.Remove(args[4]);
                                                        SaveRewards();
                                                        SendReply(arg, string.Format("Removed command \"{1}\" to Command {0}", args[2], args[4]));
                                                    }
                                                    else SendReply(arg, string.Format("The command \"{0}\" is not registered to this reward command", args[4]));
                                                    return;
                                                case "cooldown":
                                                    int cooldown = 0;
                                                    if (int.TryParse(args[4], out cooldown))
                                                    {
                                                        rewardData.commands.ElementAt(id).Cooldown = cooldown;
                                                        SaveRewards();
                                                        SendReply(arg, string.Format("Command {0} cooldown set to {1} seconds", args[2], args[4]));
                                                    }
                                                    else SendReply(arg, "You must enter a cooldown number");
                                                    return;
                                                default:
                                                    SendReply(arg, "discord.rewards edit command <ID> <description|name|icon|add|remove|cooldown> \"info here\"");
                                                    return;
                                            }
                                        }
                                        else SendReply(arg, "discord.rewards edit command <ID> <description|name|icon|add|remove|cooldown> \"info here\"");
                                    }
                                    else SendReply(arg, "Invalid ID number selected");
                                    return;
                            }
                        }
                        return;
                        #endregion
                }
            }
        }
        #endregion

        #region Images
        private void LoadImages()
        {
            Dictionary<string, string> newLoadOrder = new Dictionary<string, string>();

            string dataDir = $"file://{Interface.Oxide.DataDirectory}{Path.DirectorySeparatorChar}DiscordRewards{Path.DirectorySeparatorChar}Images{Path.DirectorySeparatorChar}";
            foreach (RewardData.RewardItem item in rewardData.items.Where(x => !string.IsNullOrEmpty(x.Icon)))
            {
                if (newLoadOrder.ContainsKey(item.Icon))
                    continue;
                string url = item.Icon;
                if (!url.StartsWith("http") && !url.StartsWith("www"))
                    url = $"{dataDir}{item.Icon}.png";
                newLoadOrder.Add(item.Icon, url);
            }
            foreach (RewardData.RewardKit kit in rewardData.kits)
            {
                if (!string.IsNullOrEmpty(kit.Icon))
                {
                    if (newLoadOrder.ContainsKey(kit.Icon))
                        continue;
                    string url = kit.Icon;
                    if (!url.StartsWith("http") && !url.StartsWith("www"))
                        url = $"{dataDir}{kit.Icon}.png";
                    newLoadOrder.Add(kit.Icon, url);
                }
            }
            foreach (RewardData.RewardCommand command in rewardData.commands)
            {
                if (!string.IsNullOrEmpty(command.Icon))
                {
                    if (newLoadOrder.ContainsKey(command.Icon))
                        continue;
                    string url = command.Icon;
                    if (!url.StartsWith("http") && !url.StartsWith("www"))
                        url = $"{dataDir}{command.Icon}.png";
                    newLoadOrder.Add(command.Icon, url);
                }
            }
            if (newLoadOrder.Count > 0)
                ImageLibrary.Call("ImportImageList", Title, newLoadOrder);

            ImageLibrary.Call("LoadImageList", Title, rewardData.items.Where(y => string.IsNullOrEmpty(y.Icon)).Select(x => new KeyValuePair<string, ulong>(x.Shortname, x.SkinID)).ToList(), null);
        }

        private string GetImage(string fileName, ulong skin = 0)
        {
            string imageId = (string)ImageLibrary.Call("GetImage", fileName, skin);
            if (!string.IsNullOrEmpty(imageId))
                return imageId;
            return string.Empty;
        }
        #endregion

        #region API
        private string SteamToDiscordID(ulong playerId)
        {
            UserData.User discordUser;
            if (userData.users.TryGetValue(playerId, out discordUser))
                return discordUser.discordId;

            return string.Empty;
        }

        private string DiscordToSteamID(string discordId)
        {
            ulong playerId;
            if (userData.FindByID(discordId, out playerId))
                return playerId.ToString();
          
            return string.Empty;
        }
        #endregion

        #region Config        
        private ConfigData Configuration;
        private class ConfigData
        {
            public DiscordSettings Settings { get; set; }

            [JsonProperty(PropertyName = "Alternative Rewards")]
            public AlternativeRewards Rewards { get; set; }

            [JsonProperty(PropertyName = "Validation Tokens")]
            public Validation Token { get; set; }

            [JsonProperty(PropertyName = "Global Cooldown")]
            public GlobalCooldown Cooldown { get; set; }           

            [JsonProperty(PropertyName = "UI Options")]
            public UIOptions UISettings { get; set; }

            public class DiscordSettings
            {
                [JsonProperty(PropertyName = "Bot Token")]
                public string APIKey { get; set; }

                [JsonProperty(PropertyName = "Bot Client ID")]
                public string BotID { get; set; }

                [JsonProperty(PropertyName = "Bot Status Messages")]
                public string[] StatusMessages { get; set; }

                [JsonProperty(PropertyName = "Bot Status Cycle Time (seconds)")]
                public int StatusCycle { get; set; }

                [JsonConverter(typeof(StringEnumConverter))]
                [JsonProperty(PropertyName = "Log Level (Verbose, Debug, Info, Warning, Error, Exception, Off)")]
                public DiscordLogLevel LogLevel { get; set; }
            }

            public class UIOptions
            {
                [JsonProperty(PropertyName = "Enable Reward Menu")]
                public bool Enabled { get; set; }

                [JsonProperty(PropertyName = "Selected Button Color")]
                public UIColor Selected { get; set; }

                [JsonProperty(PropertyName = "Deselected Button Color")]
                public UIColor Deselected { get; set; }

                [JsonProperty(PropertyName = "Close Button Color")]
                public UIColor Close { get; set; }

                [JsonProperty(PropertyName = "Claim Button Color")]
                public UIColor Claim { get; set; }

                [JsonProperty(PropertyName = "Nitro Color")]
                public UIColor Nitro { get; set; }

                [JsonProperty(PropertyName = "Background Color")]
                public UIColor Background { get; set; }

                [JsonProperty(PropertyName = "Panel Color")]
                public UIColor Panel { get; set; }

                public class UIColor
                {
                    public string Hex { get; set; }
                    public float Alpha { get; set; }

                    [JsonIgnore]
                    private string _color;

                    [JsonIgnore]
                    public string Color
                    {
                        get
                        {
                            if (string.IsNullOrEmpty(_color))
                                _color = UI.Color(Hex, Alpha);
                            return _color;
                        }
                    }
                }
            }

            public class GlobalCooldown
            {
                [JsonProperty(PropertyName = "Use Global Cooldown")]
                public bool Enabled { get; set; }

                [JsonProperty(PropertyName = "Global Cooldown Time (seconds)")]
                public int Time { get; set; }
            }

            public class Validation
            {
                [JsonProperty(PropertyName = "Token Lifetime (seconds)")]
                public int TokenLife { get; set; }

                [JsonProperty(PropertyName = "Require Re-validation")]
                public bool RequireRevalidation { get; set; }

                [JsonProperty(PropertyName = "Automatically try and re-validate users when their token has expired")]
                public bool AutoRevalidation { get; set; }

                [JsonProperty(PropertyName = "Revalidation Interval (seconds)")]
                public int RevalidationInterval { get; set; }

                [JsonProperty(PropertyName = "Revoke rewards and wipe token data on map wipe")]
                public bool WipeReset { get; set; }

                [JsonProperty(PropertyName = "Reset reward cooldowns on map wipe")]
                public bool WipeResetRewards { get; set; }

                [JsonProperty(PropertyName = "Validation channel")]
                public string ValidationChannel { get; set; }
            }

            public class AlternativeRewards
            {
                [JsonProperty(PropertyName = "Add user to user groups")]
                public string[] Groups { get; set; }

                [JsonProperty(PropertyName = "Commands to run on successful validation")]
                public string[] Commands { get; set; }

                [JsonProperty(PropertyName = "Permissions to grant on successful validation")]
                public string[] Permissions { get; set; }

                [JsonProperty(PropertyName = "Discord roles to grant on successful validation")]
                public string[] Roles { get; set; }

                [JsonProperty(PropertyName = "Discord roles to revoke on successful validation")]
                public string[] RevokeRoles { get; set; }

                [JsonProperty(PropertyName = "[Nitro Boosters] Add user to user groups")]
                public string[] NitroGroups { get; set; }

                [JsonProperty(PropertyName = "[Nitro Boosters] Commands to run on successful validation")]
                public string[] NitroCommands { get; set; }

                [JsonProperty(PropertyName = "[Nitro Boosters] Permissions to grant on successful validation")]
                public string[] NitroPermissions { get; set; }

            }

            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            Configuration = Config.ReadObject<ConfigData>();

            if (Configuration.Version < Version)
                UpdateConfigValues();

            VerifyConfigContents();

            Config.WriteObject(Configuration, true);
        }

        protected override void LoadDefaultConfig() => Configuration = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                Cooldown = new ConfigData.GlobalCooldown
                {
                    Enabled = false,
                    Time = 84600
                },
                Settings = new ConfigData.DiscordSettings
                {
                    APIKey = "",
                    BotID = "",
                    LogLevel = DiscordLogLevel.Info,
                    StatusMessages = new string[0],
                    StatusCycle = 120,
                },
                Token = new ConfigData.Validation
                {
                    RevalidationInterval = 84600,
                    TokenLife = 3600,
                    AutoRevalidation = true,
                    RequireRevalidation = true,
                    WipeReset = false,
                    ValidationChannel = string.Empty,
                    WipeResetRewards = false
                },
                Rewards = new ConfigData.AlternativeRewards
                {
                    Commands = new string[0],
                    Groups = new string[0],
                    Permissions = new string[0],
                    RevokeRoles = new string[0],
                    Roles = new string[0],
                    NitroCommands = new string[0],
                    NitroGroups = new string[0],
                    NitroPermissions = new string[0]
                },
                UISettings = new ConfigData.UIOptions
                {
                    Enabled = true,
                    Selected = new ConfigData.UIOptions.UIColor { Hex = "#6a8b38", Alpha = 1f },
                    Deselected = new ConfigData.UIOptions.UIColor { Hex = "#007acc", Alpha = 1f },
                    Close = new ConfigData.UIOptions.UIColor { Hex = "#d85540", Alpha = 1f },
                    Claim = new ConfigData.UIOptions.UIColor { Hex = "#d08822", Alpha = 1f },
                    Nitro = new ConfigData.UIOptions.UIColor { Hex = "#dc16f5", Alpha = 1f },
                    Background = new ConfigData.UIOptions.UIColor { Hex = "#2b2b2b", Alpha = 1f },
                    Panel = new ConfigData.UIOptions.UIColor { Hex = "#232323", Alpha = 1f },
                },
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(Configuration, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();
           
            if (Configuration.Version < new VersionNumber(0, 1, 2))
            {
                Configuration.UISettings.Enabled = true;
                Configuration.Token.RequireRevalidation = true;
                Configuration.Rewards = baseConfig.Rewards;
            }

            if (Configuration.Version < new VersionNumber(0, 1, 4))
                Configuration.Rewards.Roles = new string[0];

            if (Configuration.Version < new VersionNumber(0, 1, 10))
            {
                Configuration.Settings.StatusMessages = new string[0];
                Configuration.Settings.StatusCycle = 120;
            }

            if (Configuration.Version < new VersionNumber(0, 1, 12))
                Configuration.Token.WipeReset = false;

            if (Configuration.Version < new VersionNumber(0, 1, 19))
                Configuration.Rewards.RevokeRoles = new string[0];

            if (Configuration.Version < new VersionNumber(0, 1, 20))
            {
                Configuration.Rewards.NitroCommands = new string[0];
                Configuration.Rewards.NitroGroups = new string[0];
                Configuration.Rewards.NitroPermissions = new string[0];
            }

            if (Configuration.Version < new VersionNumber(0, 2, 0))
            {
                Configuration.Settings.LogLevel = DiscordLogLevel.Info;
                Configuration.Token.ValidationChannel = string.Empty;

                Configuration.UISettings.Background = baseConfig.UISettings.Background;
                Configuration.UISettings.Deselected = baseConfig.UISettings.Deselected;
                Configuration.UISettings.Nitro = baseConfig.UISettings.Nitro;
                Configuration.UISettings.Selected = baseConfig.UISettings.Selected;
                Configuration.UISettings.Panel = baseConfig.UISettings.Panel;
            }

            Configuration.Version = Version;
            PrintWarning("Config update completed!");
        }

        private void VerifyConfigContents()
        {
            if (Configuration.Rewards.Commands == null)
                Configuration.Rewards.Commands = new string[0];

            if (Configuration.Rewards.Groups == null)
                Configuration.Rewards.Groups = new string[0];

            if (Configuration.Rewards.Permissions == null)
                Configuration.Rewards.Permissions = new string[0];

            if (Configuration.Rewards.Roles == null)
                Configuration.Rewards.Roles = new string[0];

            if (Configuration.Rewards.RevokeRoles == null)
                Configuration.Rewards.RevokeRoles = new string[0];

            if (Configuration.Rewards.NitroCommands == null)
                Configuration.Rewards.NitroCommands = new string[0];

            if (Configuration.Rewards.NitroGroups == null)
                Configuration.Rewards.NitroGroups = new string[0];

            if (Configuration.Rewards.NitroPermissions == null)
                Configuration.Rewards.NitroPermissions = new string[0];
        }
        #endregion

        #region Data Management
        private UserData userData;
        private RewardData rewardData;

        private DynamicConfigFile userdata, rewarddata;

        private void SaveData() => userdata.WriteObject(userData);

        private void SaveRewards() => rewarddata.WriteObject(rewardData);

        private void WipeData()
        {
            foreach (KeyValuePair<ulong, UserData.User> kvp in userData.users)
                RevokeRewards(kvp.Key, kvp.Value);

            userData.users.Clear();
            SaveData();
            UpdateStatus();
        }

        private void WipeRewardCooldowns()
        {
            foreach (KeyValuePair<ulong, UserData.User> kvp in userData.users)
                kvp.Value.WipeCooldowns();

            SaveData();
        }

        private void LoadData()
        {
            userdata = Interface.Oxide.DataFileSystem.GetFile("DiscordRewards/userdata");
            rewarddata = Interface.Oxide.DataFileSystem.GetFile("DiscordRewards/rewarddata");

            userData = userdata.ReadObject<UserData>();
            if (userData == null)
                userData = new UserData();

            rewardData = rewarddata.ReadObject<RewardData>();
            if (rewardData == null)
                rewardData = new RewardData();
        }

        private class UserData
        {
            public Dictionary<ulong, User> users = new Dictionary<ulong, User>();
            public Hash<int, DiscordToken> tokenToUser = new Hash<int, DiscordToken>();

            public User AddNewUser(ulong playerId, string discordId)
            {
                User userData = new User(discordId);
                users.Add(playerId, userData);
                return userData;
            }

            public User GetUser(ulong userId)
            {
                User user;
                if (users.TryGetValue(userId, out user))
                    return user;
                return null;
            }

            public bool FindByID(string discordId, out ulong userId)
            {
                foreach(KeyValuePair<ulong, User> user in users)
                {
                    if (user.Value.discordId.Equals(discordId))
                    {
                        userId = user.Key;
                        return true;
                    }
                }

                userId = 0UL;
                return false;
            }

            public void AddToken(int code, ulong playerId, int duration)
            {
                tokenToUser.Add(code, new DiscordToken(playerId, duration));
            }

            public bool HasPendingToken(ulong playerId, out int code)
            {
                code = -1;
                foreach(KeyValuePair<int, DiscordToken> kvp in tokenToUser)                
                {
                    if (kvp.Value.expireTime < CurrentTime())
                    {
                        tokenToUser.Remove(kvp.Key);
                        return false;
                    }
                    code = kvp.Key;
                    return true;
                }
                return false;
            }

            public bool IsValidToken(int code, out DiscordToken token)
            {
                return tokenToUser.TryGetValue(code, out token);
            }
            
            public void InvalidateToken(int token) => tokenToUser.Remove(token);

            public class DiscordToken
            {
                public ulong playerId;
                public double expireTime;

                public DiscordToken(ulong playerId, int duration)
                {
                    this.playerId = playerId;
                    this.expireTime = CurrentTime() + duration;
                }
            }

            public class User
            {                
                public string discordId;

                public double expireTime;
                public double globalTime;

                public bool isNitroBooster = false;

                public HashSet<string> groups = new HashSet<string>();
                public HashSet<string> permissions = new HashSet<string>();
                public HashSet<string> roles = new HashSet<string>();

                public HashSet<string> nitroGroups = new HashSet<string>();
                public HashSet<string> nitroPermissions = new HashSet<string>();

                [JsonIgnore]
                private Snowflake _id;

                [JsonIgnore]
                public Snowflake Id
                {
                    get
                    {
                        if (_id.Equals(default(Snowflake)))
                        {
                            _id = new Snowflake(ulong.Parse(discordId));
                        }
                        return _id;
                    }
                    set
                    {
                        discordId = value.Id.ToString();
                        _id = value;
                    }
                }

                public User(string discordId)
                {
                    this.discordId = discordId;
                }

                public void SetExpiryDate(int duration)
                {
                    this.expireTime = CurrentTime() + duration;
                }

                public Dictionary<RewardType, Dictionary<int, double>> items = new Dictionary<RewardType, Dictionary<int, double>>
                {
                    [RewardType.Command] = new Dictionary<int, double>(),
                    [RewardType.Item] = new Dictionary<int, double>(),
                    [RewardType.Kit] = new Dictionary<int, double>()
                };

                public void AddCooldown(RewardType type, int id, int time)
                {
                    if (!items[type].ContainsKey(id))
                        items[type].Add(id, time + CurrentTime());
                    else items[type][id] = time + CurrentTime();
                }

                public void AddCooldown(int time)
                {
                    globalTime = CurrentTime() + time;
                }

                public bool HasCooldown(RewardType type, int id, out double remaining)
                {
                    remaining = 0;
                    double time;
                    if (items[type].TryGetValue(id, out time))
                    {
                        double currentTime = CurrentTime();
                        if (time > currentTime)
                        {
                            remaining = time - currentTime;
                            return true;
                        }
                    }
                    return false;
                }

                public bool HasCooldown(out double remaining)
                {
                    remaining = globalTime - CurrentTime();
                    return remaining > 0;
                }

                public void WipeCooldowns()
                {
                    items = new Dictionary<RewardType, Dictionary<int, double>>
                    {
                        [RewardType.Command] = new Dictionary<int, double>(),
                        [RewardType.Item] = new Dictionary<int, double>(),
                        [RewardType.Kit] = new Dictionary<int, double>()
                    };
                }
            }
        }

        private class RewardData
        {
            public List<RewardItem> items = new List<RewardItem>();
            public List<RewardKit> kits = new List<RewardKit>();
            public List<RewardCommand> commands = new List<RewardCommand>();

            public class RewardItem : BaseReward
            {
                public string Shortname { get; set; }
                public int Amount { get; set; }
                public ulong SkinID { get; set; }
                public bool IsBP { get; set; }

                internal override string RewardType => "item";

                public override void GiveReward(BasePlayer player)
                {
                    Item item = null;
                    if (IsBP)
                    {
                        item = ItemManager.CreateByItemID(-996920608, Amount, SkinID);
                        item.blueprintTarget = ItemManager.itemList.Find(x => x.shortname == Shortname)?.itemid ?? 0;
                    }
                    else item = ItemManager.CreateByName(Shortname, Amount, SkinID);
                    player.GiveItem(item, BaseEntity.GiveItemReason.PickedUp);
                }

                internal override void CreateIconImage(CuiElementContainer container, UI4 position)
                {
                    string icon = string.IsNullOrEmpty(Icon) ? Instance.GetImage(Shortname, SkinID) : Instance.GetImage(Icon, 0);
                    if (!string.IsNullOrEmpty(icon))                    
                        UI.Image(container, UI_MENU, icon, new UI4(position.xMin + 0.015f, position.yMin + 0.16f, position.xMax - 0.015f, position.yMax));
                }

                internal override void CreateNameLabel(CuiElementContainer container, UI4 position)
                {
                    UI.Label(container, UI_MENU, $"{Name}{(IsBP ? " (BP)" : "")}{(Amount > 1 ? $" x{Amount}" : "")}", 10, new UI4(position.xMin, position.yMin + 0.08f, position.xMax, position.yMin + 0.16f));
                }

                internal override void CreateDescriptionLabel(CuiElementContainer container, UI4 position) { }
            }

            public class RewardCommand : BaseReward
            {
                public List<string> Commands { get; set; }

                internal override string RewardType => "command";

                public override void GiveReward(BasePlayer player)
                {
                    foreach (string cmd in Commands)
                        Interface.Oxide.GetLibrary<Game.Rust.Libraries.Rust>().RunServerCommand(cmd.Replace("$player.id", player.UserIDString).Replace("$player.name", player.displayName).Replace("$player.x", player.transform.position.x.ToString()).Replace("$player.y", player.transform.position.y.ToString()).Replace("$player.z", player.transform.position.z.ToString()));
                }
            }

            public class RewardKit : BaseReward
            {               
                public string Kit { get; set; }

                internal override string RewardType => "kit";

                public override void GiveReward(BasePlayer player)
                {
                    Instance.Kits?.Call("GiveKit", player, Kit);
                }
            }

            public class BaseReward
            {
                public string Name { get; set; }
                public string Description { get; set; }
                public int Cooldown { get; set; }
                public string Icon { get; set; }
                public bool Nitro { get; set; }

                [JsonIgnore]
                internal virtual string RewardType { get; }

                public virtual void GiveReward(BasePlayer player) { }

                internal virtual void AddUIEntry(CuiElementContainer container, UI4 position, int listIndex, ulong playerId, bool isNitroBooster)
                {
                    UI.Panel(container, UI_MENU, Instance.Configuration.UISettings.Panel.Color, position);

                    CreateIconImage(container, position);

                    CreateNameLabel(container, position);

                    CreateDescriptionLabel(container, position);

                    UI.Label(container, UI_MENU, Name, 14, new UI4(position.xMin, position.yMin + 0.04f, position.xMax, position.yMin + 0.09f));

                    UI.Button(container, UI_MENU, Nitro ? Instance.Configuration.UISettings.Nitro.Color : Instance.Configuration.UISettings.Claim.Color,
                                            Nitro && !isNitroBooster ? Instance.Message("UI.NitroOnly", playerId) : Instance.Message("UI.Claim", playerId),
                                            12, new UI4(position.xMin + 0.005f, position.yMin + 0.01f, position.xMax - 0.005f, position.yMin + 0.08f),
                                            Nitro && !isNitroBooster ? string.Empty : $"drui.claim {RewardType} {listIndex}");
                }

                internal virtual void CreateIconImage(CuiElementContainer container, UI4 position)
                {
                    if (!string.IsNullOrEmpty(Icon))
                    {
                        string itemIcon = Instance.GetImage(Icon, 0);
                        if (!string.IsNullOrEmpty(itemIcon))
                            UI.Image(container, UI_MENU, itemIcon, new UI4(position.xMin + 0.015f, position.yMin + 0.16f, position.xMax - 0.015f, position.yMax));
                    }
                }

                internal virtual void CreateNameLabel(CuiElementContainer container, UI4 position)
                {
                    if (!string.IsNullOrEmpty(Name))
                        UI.Label(container, UI_MENU, Name, 10, new UI4(position.xMin, position.yMin + 0.08f, position.xMax, position.yMin + 0.16f));
                }

                internal virtual void CreateDescriptionLabel(CuiElementContainer container, UI4 position)
                {
                    if (!string.IsNullOrEmpty(Description))
                        UI.Label(container, UI_MENU, Description, 10, new UI4(position.xMin + 0.02f, position.yMin + 0.16f, position.xMax - 0.02f, position.yMax - 0.04f), TextAnchor.UpperCenter);
                }
            }
        }
        #endregion

        #region Localization
        private string Message(string key, ulong playerId = 0U) => lang.GetMessage(key, this, playerId == 0U ? null : playerId.ToString());
       
        private Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            ["Help.Token"] = "Type <color=#ce422b>/discord token</color> to get a unique 6 digit token.",
            ["Help.BotOnly"] = "When you have your unique token, DM the token to our bot (<color=#ce422b>{0}</color>) on Discord to verify your account",
            ["Help.BotOrChannel"] = "When you have your unique token, either DM the token to our bot (<color=#ce422b>{0}</color>) on Discord or post the token in the <color=#ce422b>#{1}</color> channel to verify your account",
            
            ["Message.Token"] = "Your unique token is <color=#ce422b>{0}</color>",
            ["Message.RewardGiven"] = "<color=#ce422b>Thanks for being a part of our community!</color> You have received your reward",
            ["Message.OnCooldown"] = "You have cooldown on this reward for another <color=#ce422b>{0}</color>",
            ["Message.OnCooldownGlobal"] = "You have cooldown for another <color=#ce422b>{0}</color>",
            ["Message.ValidationExpired"] = "Your Discord validation token has expired! Type <color=#ce422b>/discord</color> to re-validate",
            ["Message.AutoValidated"] = "Your Discord validation token has expired, however we can see you are still in our Discord so you have been automatically re-validated!",
            ["Message.AlreadyRegistered"] = "You are already a member of the Discord group",
            
            ["Error.NoItems"] = "The Discord Reward store currently has no items...",
            ["Error.PendingToken"] = "<color=#ce422b>You already have a token pending validation.</color> DM your unique token (<color=#ce422b>{0}</color>) to our bot (<color=#ce422b>{1}</color>) to continue!",

            ["Discord.TokenExpires"] = "This token will expire in {0}.",
            ["Discord.ValidatedToken"] = "Your token has been validated!",
            ["Discord.InvalidToken"] = "The token you entered is invalid. Please copy the 6 digit token you recieved from ingame chat",
            ["Discord.TokenExpired"] = "The token you entered has expired. Please request a new token via the /discord command ingame",
            ["Discord.FailedToFindPlayer"] = "Failed to find a online player with the Steam ID {0}. Unable to complete validation",
            ["Discord.NotOnServer"] = "You must be online in the game server to complete validation",
            ["Discord.UserIsDead"] = "You are currently dead. Some rewards issued on validation may not work whilst you are dead. Try again when you are alive",
            ["Discord.OpenStore"] = "Type /discord in game to open the reward selection menu",

            ["UI.Title"] = "Discord Rewards",
            ["UI.Claim"] = "Claim",
            ["UI.NitroOnly"] = "Nitro Boosters Only",
            ["UI.Kits"] = "Kits",
            ["UI.Items"] = "Items",
            ["UI.Commands"] = "Commands",
        };
        #endregion
    }
}


// --- End of file: DiscordRewards.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/StartProtection.cs ---
// --- Original Local Path: StartProtection.cs ---

using System;
using System.Collections.Generic;
using Oxide.Core;
namespace Oxide.Plugins
{
    [Info("StartProtection", "Norn", 1.9, ResourceId = 1342)]
    [Description("Give people some leeway when they first join the game.")]
    public class StartProtection : RustPlugin
    {
        class StoredData
        {
            public Dictionary<ulong, ProtectionInfo> Players = new Dictionary<ulong, ProtectionInfo>();
            public StoredData()
            {
            }
        }

        class ProtectionInfo
        {
            public ulong UserId;
            public int TimeLeft;
            public bool Multiple;
            public int InitTimestamp;
            public ProtectionInfo()
            {
            }
        }

        StoredData storedData;
        StoredData storedDataEx;
        private void Loaded()
        {
            storedData = Interface.GetMod().DataFileSystem.ReadObject<StoredData>(this.Title);
            LoadDefaultMessages();
        }

        public Int32 UnixTimeStampUTC()
        {
            Int32 unixTimeStamp;
            DateTime currentTime = DateTime.Now;
            DateTime zuluTime = currentTime.ToUniversalTime();
            DateTime unixEpoch = new DateTime(1970, 1, 1);
            unixTimeStamp = (Int32)(zuluTime.Subtract(unixEpoch)).TotalSeconds;
            return unixTimeStamp;
        }
        static readonly DateTime UnixEpoch = new DateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc);
        static readonly double MaxUnixSeconds = (DateTime.MaxValue - UnixEpoch).TotalSeconds;

        public static DateTime UnixTimeStampToDateTime(double unixTimeStamp)
        {
            return unixTimeStamp > MaxUnixSeconds
               ? UnixEpoch.AddMilliseconds(unixTimeStamp)
               : UnixEpoch.AddSeconds(unixTimeStamp);
        }
        private void RemoveOldUsers()
        {
            int removed = 0;
            new List<ulong>(storedData.Players.Keys).ForEach(u =>
            {
                ulong steamid = u; ProtectionInfo item = null;
                if (storedData.Players.TryGetValue(steamid, out item))
                {
                    if (item.InitTimestamp == 0)
                    {
                        storedData.Players.Remove(steamid);
                        removed++;
                    }
                    else
                    {
                        DateTime compareDate = UnixTimeStampToDateTime(item.InitTimestamp);
                        var days = (compareDate - DateTime.Now).Days;
                        if (days >= Convert.ToInt32(Config["iInactiveDays"]))
                        {
                            storedData.Players.Remove(steamid);
                            removed++;
                        }
                    }
                }
            });
            if (removed >= 1)
            {
                Puts("Removing " + removed.ToString() + " old entries from the protection list.");
                SaveData();
            }
            else
            {
                Puts("Entry list up to date.");
            }
        }
        void OnPlayerFirstInit(ulong steamid)
        {
            ProtectionInfo p = null;
            if (storedData.Players.TryGetValue(steamid, out p))
            {
                if (p.Multiple == false || p.TimeLeft == Convert.ToInt32(Config["iTime"]))
                {
                    Puts("Removing " + steamid + " from protection list, cleaning up...");
                    storedData.Players.Remove(steamid);
                    OnPlayerFirstInit(steamid);
                }
            }
            else
            {
                var info = new ProtectionInfo();
                info.TimeLeft = Convert.ToInt32(Config["iTime"]);
                info.Multiple = false;
                info.InitTimestamp = UnixTimeStampUTC();// Timestamp
                info.UserId = steamid;
                storedData.Players.Add(steamid, info);
                Interface.GetMod().DataFileSystem.WriteObject(this.Title, storedData);
            }
        }
        void OnUserApprove(Network.Connection connection)
        {
            string userid = connection.userid.ToString();
            if (!permission.UserExists(userid))
            {
                OnPlayerFirstInit(connection.userid);
            }
        }
        protected override void LoadDefaultConfig()
        {
            Puts("No configuration file found, generating...");
            Config.Clear();

            // --- [ GENERAL ] ---
            Config["bProtectionEnabled"] = true;
            Config["bSleeperProtection"] = true;
            Config["iTime"] = 1800;
            Config["iPunishment"] = 300;
            Config["bHelicopterProtection"] = true;
            Config["iAuthLevel"] = 2;
            Config["iInactiveDays"] = 0.25;
            Config["iUpdateTimerInterval"] = 10;

            // --- [ MESSAGES ] ---
            SaveConfig();
        }

        #region Localization

        void LoadDefaultMessages()
        {
            var messages = new Dictionary<string, string>
            {
                {"tPunishment", "<color=#FF3300>You have been punished for attempting to PVP with</color> Start Protection <color=#99FF66>Enabled!</color>\n\n{minutes_revoked} minutes revoked.\n\nYou now have <color=#FF3300>{minutes_left}</color> minutes left before your Start Protection is disabled."},
                {"tFirstSpawn", "Start protection <color=#66FF66>enabled</color> for <color=#66FF66>{minutes_left}</color> minutes, during this time you <color=#FF3300>will not be able to pvp</color> on any level.\n\nYou can check how much time you have left by typing <color=#66FF66>/sp time</color>\n\n<color=#FF3300>Do not</color> squander this time." },
                {"tSpawn", "You have <color=#FF3300>{minutes_left}</color> minutes left before your Start Protection is disabled."},
                {"tProtectionEnded", "Start protection <color=#FF3300>disabled</color>, you are now on your own."},
                {"tNoProtection", "Start protection status is currently <color=#FF3300>disabled</color>."},
                {"tAttackAttempt","The player you are trying to attack has Start Protection enabled and <color=#FF3300>cannot</color> be damaged."},
                {"tDisabled", "Start Protection is currently <color=#FF3300>disabled</color> server-wide."},
                {"tEnabled", "Start Protection has been <color=#66FF66>enabled</color>, new players will now be protected upon spawning."},
                {"tNoAuthLevel", "You <color=#FF3300>do not</color> have access to this command."},
                {"tDBCleared", "You have <color=#FF3300>cleared</color> the Start Protection database."},
            };
            lang.RegisterMessages(messages, this);
        }
        string GetMessage(string key, string steamId = null) => lang.GetMessage(key, this, steamId);

        #endregion

        private void PunishPlayer(BasePlayer player, int new_time = -1, bool message = true)
        {
            ProtectionInfo p = null;
            if (storedData.Players.TryGetValue(player.userID, out p))
            {
                int punish = 0;
                if (new_time != -1)
                {
                    punish = new_time;
                }
                else
                {
                    punish = Convert.ToInt32(Config["iPunishment"]);
                }
                p.TimeLeft = p.TimeLeft - punish;
                if (p.TimeLeft <= 0) { UpdateProtectedListEx(player); }
                if (message)
                {
                    string minutes = Convert.ToInt32(TimeSpan.FromSeconds(p.TimeLeft).TotalMinutes).ToString();
                    string punishment = Convert.ToInt32(TimeSpan.FromSeconds(punish).TotalMinutes).ToString();
                    string parsed_config = GetMessage("tPunishment", player.UserIDString);
                    parsed_config = parsed_config.Replace("{minutes_revoked}", punishment.ToString());
                    parsed_config = parsed_config.Replace("{minutes_left}", minutes.ToString());
                    PrintToChatEx(player, parsed_config);
                }
            }
        }
        Dictionary<Type, Action> EntityTypes;
        private HitInfo OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
        {
            if (Convert.ToBoolean(Config["bProtectionEnabled"]) == true)
            {
                if (entity is BasePlayer)
                {
                    var player = entity as BasePlayer;
                    ProtectionInfo p = null;
                    ProtectionInfo z = null;
                    if (hitInfo.Initiator is BasePlayer)
                    {
                        var attacker = hitInfo.Initiator as BasePlayer;
                        if (storedData.Players.TryGetValue(player.userID, out p))
                        {
                            if (storedData.Players.TryGetValue(attacker.userID, out z))
                            {
                                if (attacker.userID == player.userID)
                                {
                                    return null;
                                }
                                else
                                {
                                    PunishPlayer(attacker);
                                    Puts("Punishing " + attacker.displayName.ToString() + " for attempting to pvp.");
                                }
                            }
                            if (attacker.userID != player.userID)
                            {
                                if (player.IsSleeping())
                                {
                                    if (Convert.ToBoolean(Config["bSleeperProtection"]) == false)
                                    {
                                        storedData.Players.Remove(player.userID);
                                        Puts("Removed " + player.displayName.ToString() + " (Sleeping) from the Start Protection list.");
                                        return null;
                                    }
                                    else
                                    {
                                        PrintToChatEx(player, GetMessage("tAttackAttempt", player.UserIDString));
                                    }
                                }
                            }
                            hitInfo.damageTypes.ScaleAll(0f);
                            return hitInfo;
                        }
                        else
                        {
                            if (storedData.Players.TryGetValue(attacker.userID, out p))
                            {
                                PunishPlayer(attacker);
                                Puts("Punishing " + attacker.displayName.ToString() + " for attempting to pvp.");
                                hitInfo.damageTypes.ScaleAll(0f);
                                return hitInfo;
                            }
                        }
                    }
                    else if (hitInfo.Initiator is BaseHelicopter)
                    {
                        if (Convert.ToBoolean(Config["bHelicopterProtection"]) == true)
                        {
                            if (player == null) { return null; }
                            if (storedData.Players.TryGetValue(player.userID, out z))
                            {
                                hitInfo.damageTypes.ScaleAll(0f);
                                return hitInfo;
                            }
                        }
                    }
                }
            }
            return null;
        }
        [ChatCommand("sp")]
        private void SPCommand(BasePlayer player, string command, string[] args)
        {
            if (Convert.ToBoolean(Config["bProtectionEnabled"]) == false && player.net.connection.authLevel != Convert.ToInt32(Config["iAuthLevel"]))
            {
                PrintToChatEx(player, GetMessage("tDisabled", player.UserIDString));
                return;
            }
            if (args.Length == 0 || args.Length > 2)
            {
                PrintToChatEx(player, "USAGE: /sp <time | end>");
                if (player.net.connection.authLevel >= Convert.ToInt32(Config["iAuthLevel"]))
                {
                    PrintToChatEx(player, "<color=yellow>ADMIN: /sp <toggle | togglesleep | cleardb | me></color>");
                }
            }
            else if (args[0] == "me")
            {
                if (player.net.connection.authLevel >= Convert.ToInt32(Config["iAuthLevel"]))
                {
                    OnPlayerFirstInit(player.userID);
                    ProtectionInfo p = null;
                    if (storedData.Players.TryGetValue(player.userID, out p))
                    {
                        string minutes = Convert.ToInt32(TimeSpan.FromSeconds(p.TimeLeft).TotalMinutes).ToString();
                        Puts("Start protection enabled for " + player.displayName + " [" + player.userID.ToString() + "] - Duration: " + minutes + " minutes.");
                        string parsed_config = GetMessage("tFirstSpawn", player.UserIDString);
                        parsed_config = parsed_config.Replace("{minutes_left}", minutes.ToString());
                        PrintToChatEx(player, parsed_config);
                    }
                    else { Puts("Failed..."); }

                }
                else
                {
                    PrintToChatEx(player, GetMessage("tNoAuthLevel", player.UserIDString));
                }
            }
            else if (args[0] == "cleardb")
            {
                if (player.net.connection.authLevel >= Convert.ToInt32(Config["iAuthLevel"]))
                {
                    storedData.Players.Clear();
                    PrintToChatEx(player, GetMessage("tDBCleared", player.UserIDString));
                    SaveData();
                }
                else
                {
                    PrintToChatEx(player, GetMessage("tNoAuthLevel", player.UserIDString));
                }
            }
            else if (args[0] == "togglesleep")
            {
                if (player.net.connection.authLevel >= Convert.ToInt32(Config["iAuthLevel"]))
                {
                    if (Convert.ToBoolean(Config["bSleeperProtection"]) == true)
                    {
                        PrintToChatEx(player, "Sleep Protection: <color=red>disabled</color>.");
                        Puts("Start Protection sleeper protection has been disabled by " + player.displayName + " (type /sp togglesleep to enable).");
                        Config["bSleeperProtection"] = false;
                        SaveConfig();
                    }
                    else
                    {
                        PrintToChatEx(player, "Sleep Protection: <color=green>enabled</color>.");
                        Puts("Start Protection sleeper protection has been enabled by " + player.displayName + " (type /sp togglesleep to disabled).");
                        Config["bSleeperProtection"] = true;
                        SaveConfig();
                    }
                }
                else
                {
                    PrintToChatEx(player, GetMessage("tNoAuthLevel", player.UserIDString));
                }
            }
            else if (args[0] == "toggle")
            {
                if (player.net.connection.authLevel >= Convert.ToInt32(Config["iAuthLevel"]))
                {
                    if (Convert.ToBoolean(Config["bProtectionEnabled"]) == true)
                    {
                        if (ProtectionTimer != null)
                        {
                            ProtectionTimer.Destroy();
                        }
                        PrintToChatEx(player, GetMessage("tDisabled", player.UserIDString));
                        Puts("Start Protection has been disabled by " + player.displayName + " (type /sp toggle to enable).");
                        Config["bProtectionEnabled"] = false;
                        SaveConfig();
                    }
                    else
                    {
                        int seconds = Convert.ToInt32(Config["iUpdateTimerInterval"]);
                        ProtectionTimer = timer.Repeat(seconds, 0, () => UpdateProtectedList());
                        PrintToChatEx(player, GetMessage("tEnabled", player.UserIDString));
                        int minutes = Convert.ToInt32(TimeSpan.FromSeconds(Convert.ToInt32(Config["iTime"])).TotalMinutes);
                        Puts("Start Protection has been enabled by " + player.displayName + " [Minutes: " + minutes.ToString() + "] (type /sp toggle to disable).");
                        Config["bProtectionEnabled"] = true;
                        SaveConfig();
                    }
                }
                else
                {
                    PrintToChatEx(player, GetMessage("tNoAuthLevel", player.UserIDString));
                }
            }
            else if (args[0] == "end")
            {
                ProtectionInfo p = null;
                if (storedData.Players.TryGetValue(player.userID, out p))
                {
                    PunishPlayer(player, Convert.ToInt32(Config["iTime"]) + 1, false);
                }
                else
                {

                    PrintToChatEx(player, GetMessage("tNoProtection", player.UserIDString));
                }
            }
            else if (args[0] == "time")
            {
                ProtectionInfo p = null;
                if (storedData.Players.TryGetValue(player.userID, out p))
                {
                    string minutes = Convert.ToInt32(TimeSpan.FromSeconds(p.TimeLeft).TotalMinutes).ToString();

                    string parsed_config = GetMessage("tSpawn", player.UserIDString);
                    parsed_config = parsed_config.Replace("{minutes_left}", minutes.ToString());
                    PrintToChatEx(player, parsed_config);
                }
                else
                {

                    PrintToChatEx(player, GetMessage("tNoProtection", player.UserIDString));
                }
            }
        }
        private void UpdateProtectedListEx(BasePlayer player)
        {
            if (player != null)
            {
                ProtectionInfo p = null;
                if (storedData.Players.TryGetValue(player.userID, out p))
                {
                    if (p.TimeLeft >= 1 && p.TimeLeft <= Convert.ToInt32(Config["iTime"]))
                    {
                        p.TimeLeft = p.TimeLeft - Convert.ToInt32(Config["iUpdateTimerInterval"]);
                    }
                    else
                    {
                        storedData.Players.Remove(player.userID);
                        PrintToChatEx(player, GetMessage("tProtectionEnded", player.UserIDString));
                    }
                }
            }
        }
        private void UpdateProtectedList()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                UpdateProtectedListEx(player);
            }
        }
        void Unload()
        {
            Puts("Saving protection database...");
            if (ProtectionTimer != null)
            {
                ProtectionTimer.Destroy();
            }
            SaveData();
        }
        void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(this.Title, storedData);

        }
        private void OnPlayerSleepEnded(BasePlayer player)
        {
            ProtectionInfo p = null;
            if (storedData.Players.TryGetValue(player.userID, out p))
            {
                if (!p.Multiple)
                {
                    string minutes = Convert.ToInt32(TimeSpan.FromSeconds(p.TimeLeft).TotalMinutes).ToString();
                    Puts("Start protection enabled for " + player.displayName + " [" + player.userID.ToString() + "] - Duration: " + minutes + " minutes.");
                    string parsed_config = GetMessage("tFirstSpawn", player.UserIDString);
                    parsed_config = parsed_config.Replace("{minutes_left}", minutes.ToString());
                    PrintToChatEx(player, parsed_config);
                    p.Multiple = true;
                }
                else
                {
                    string minutes = Convert.ToInt32(TimeSpan.FromSeconds(p.TimeLeft).TotalMinutes).ToString();
                    string parsed_config = GetMessage("tSpawn", player.UserIDString);
                    parsed_config = parsed_config.Replace("{minutes_left}", minutes.ToString());
                    PrintToChatEx(player, parsed_config);
                }
            }
        }
        private void PrintToChatEx(BasePlayer player, string result, string tcolour = "orange")
        {
            PrintToChat(player, "<color=\"" + tcolour + "\">[" + this.Title.ToString() + "]</color> " + result);
        }
        Timer ProtectionTimer;
        private void OnServerInitialized()
        {
            if (Config["bSleeperProtection"] == null) { Puts("Resetting configuration file (out of date)..."); LoadDefaultConfig(); }
            if (Convert.ToBoolean(Config["bProtectionEnabled"]) == true)
            {
                RemoveOldUsers();
                int seconds = Convert.ToInt32(Config["iUpdateTimerInterval"]);
                ProtectionTimer = timer.Repeat(seconds, 0, () => UpdateProtectedList());
                string minutes = Convert.ToInt32(TimeSpan.FromSeconds(Convert.ToInt32(Config["iTime"])).TotalMinutes).ToString();
                Puts("Start Protection has been enabled [Minutes: " + minutes + "] (type /sp toggle to disable).");
            }
            else
            {
                Puts("Start Protection is not enabled (type /sp toggle to enable).");
            }
        }
    }
}

// --- End of file: StartProtection.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/VoteBonusFromLauncher.cs ---
// --- Original Local Path: VoteBonusFromLauncher.cs ---

using System;
using System.Collections.Generic;
using System.Diagnostics;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using Oxide.Plugins;

namespace Oxide.Plugins
{
    [Oxide.Plugins.Info("Vote Bonus From Launcher", "TheRyuzaki", "0.0.2")]
    public class VoteBonusFromLauncher : RustPlugin
    {
        private const string CONST_SHOP_ID = "";   // ID магазина
        private const string CONST_SHOP_KEY = "";  // API Ключ магазина
        private const int CONST_BONUS_RUB = 3;     // Сколько рублей давать за голос
        private const bool CONST_SAY_BONUS = true; // Оповещать людей в чате? О том, что кто либо проголосовал?
        private const string CONST_ADDRES_SERVER = "37.230.137.36:22031"; // Адрес сервера как написан в лаунчере

        private HashSet<int> HashSetVotes { get; set; }
        private Timer timerSearchVote { get; set; }
        private Queue<String> ListMessageToMainTheard = new Queue<string>();

        [HookMethod("OnServerInitialized")]
        void OnServerInitialized()
        {
            if (Interface.Oxide.DataFileSystem.ExistsDatafile("VoteBonusFromLauncher"))
            {
                HashSetVotes = Interface.Oxide.DataFileSystem.ReadObject<HashSet<int>>("VoteBonusFromLauncher");
            }
            else
            {
                HashSetVotes = new HashSet<int>();
            }

            timerSearchVote = timer.Repeat(15f, 0, OnStartSearchVote);
        }

        [HookMethod("Unload")]
        void Unload()
        {
            if (HashSetVotes.Count != 0)
            {
                Interface.Oxide.DataFileSystem.WriteObject<HashSet<int>>("VoteBonusFromLauncher", HashSetVotes);
            }
            
            timerSearchVote.Destroy();
        }

        void OnStartSearchVote()
        {
            this.webrequest.Enqueue($"https://expshop.alkad.org/Api/Launcher.VoteList?date={DateTime.Now:yyyy-MM-dd}&server={CONST_ADDRES_SERVER}", "", OnResonseSearchVote, this);
        }

        private void OnResonseSearchVote(int code, string response)
        {
            string[] lines = response.Split(new char[] { '\n' }, StringSplitOptions.RemoveEmptyEntries);
            for (var i = 0; i < lines.Length; i++)
            {
                if (lines[i].Length > 20)
                {
                    string[] valuesFromLine = lines[i].Split(new char[] {';'}, StringSplitOptions.RemoveEmptyEntries);
                    if (valuesFromLine.Length == 3)
                    {
                        int id = 0;
                        if (int.TryParse(valuesFromLine[0], out id))
                        {
                            if (HashSetVotes.Contains(id) == false)
                            {
                                HashSetVotes.Add(id);
                                ulong steamid = 0;
                                if (ulong.TryParse(valuesFromLine[1], out steamid))
                                {
                                    BasePlayer player = BasePlayer.FindByID(steamid);
                                    string targetPlayer = (player == null ? steamid.ToString() : player.displayName);
                                    ConsoleNetwork.BroadcastToAllClients("chat.add", new object[]
                                    {
                                        0,
                                        $"<color=orange>Игрок [{targetPlayer}] проголосовал за сервер, и получил бонус в донат магазине [{CONST_BONUS_RUB} руб]. Спасибо тебе игрок, за поддержку!</color>"
                                    });
                                    this.OnSendBonusVote(steamid);
                                }
                                else
                                {
                                    UnityEngine.Debug.LogError("[VoteBonusFromLauncher]: Not found SteamID from line: " + lines[i]);
                                }
                            }
                        }
                    }
                }
            }
        }

        private void OnSendBonusVote(ulong steamid)
        {
            string url = $"http://panel.gamestores.ru/api?shop_id={CONST_SHOP_ID}&secret={CONST_SHOP_KEY}&action=moneys&type=plus&steam_id={steamid}&amount={CONST_BONUS_RUB}&mess=Vote Bonus";
            webrequest.EnqueueGet(url, OnResponseBonusVote, this);
        }

        private void OnResponseBonusVote(int code, string response)
        {
            this.Puts("Response from GameStores: " + response);
        }
    }
}

// --- End of file: VoteBonusFromLauncher.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TurretConfig.cs ---
// --- Original Local Path: TurretConfig.cs ---

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Reflection;
using Oxide.Core;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("TurretConfig", "Calytic", "1.0.1", ResourceId = 1418)]
    [Description("Change turret damage, accuracy, bullet speed, health, targeting, etc")]
    class TurretConfig : RustPlugin
    {
        private readonly string turretPrefab = "assets/prefabs/npc/autoturret/autoturret_deployed.prefab";
        private uint turretPrefabId;

        FieldInfo bulletDamageField = typeof(AutoTurret).GetField("bulletDamage", (BindingFlags.Instance | BindingFlags.NonPublic));

        FieldInfo healthField = typeof(BaseCombatEntity).GetField("_health", (BindingFlags.Instance | BindingFlags.NonPublic));
        FieldInfo maxHealthField = typeof(BaseCombatEntity).GetField("_maxHealth", (BindingFlags.Instance | BindingFlags.NonPublic));

        private bool adminOverride;
        private List<object> animals;
        private bool animalOverride;
        private bool sleepOverride;
        private bool useGlobalDamageModifier;
        private float globalDamageModifier;

        private float defaultBulletDamage;
        private float defaultBulletSpeed;
        private string defaultAmmoType;
        private float defaultSightRange;
        private float defaultHealth;
        private float defaultAimCone;

        private Dictionary<string, object> bulletDamages;
        private Dictionary<string, object> bulletSpeeds;
        private Dictionary<string, object> ammoTypes;
        private Dictionary<string, object> sightRanges;
        private Dictionary<string, object> healths;
        private Dictionary<string, object> aimCones;

        private bool infiniteAmmo;

        [PluginReference]
        Plugin Vanish;

        [PluginReference]
        Plugin Skills;

        void Loaded()
        {
            LoadMessages();
            LoadData();

            turretPrefabId = StringPool.Get(turretPrefab);

            permission.RegisterPermission("turretconfig.infiniteammo", this);

            adminOverride = GetConfig("Settings", "adminOverride", true);
            animalOverride = GetConfig("Settings", "animalOverride", false);
            sleepOverride = GetConfig("Settings", "sleepOverride", false);
            animals = GetConfig<List<object>>("Settings", "animals", GetPassiveAnimals());

            useGlobalDamageModifier = GetConfig("Settings", "useGlobalDamageModifier", false);
            globalDamageModifier = GetConfig("Settings", "globalDamageModifier", 1f);
            defaultHealth = GetConfig("Settings", "defaultHealth", 1000f);
            defaultAimCone = GetConfig("Settings", "defaultAimCone", 5f);
            defaultSightRange = GetConfig("Settings", "defaultSightRange", 30f);
            defaultBulletDamage = GetConfig("Settings", "defaultBulletDamage", 10f);
            defaultBulletSpeed = GetConfig("Settings", "defaultBulletSpeed", 10f);
            defaultAmmoType = GetConfig("Settings", "defaultAmmoType", "ammo.rifle");

            bulletDamages = GetConfig("Settings", "bulletDamages", GetDefaultBulletDamages());
            bulletSpeeds = GetConfig("Settings", "bulletSpeeds", GetDefaultBulletSpeeds());
            ammoTypes = GetConfig("Settings", "ammoTypes", GetDefaultAmmoTypes());
            sightRanges = GetConfig("Settings", "sightRanges", GetDefaultSightRanges());
            healths = GetConfig("Settings", "health", GetDefaultHealth());
            aimCones = GetConfig("Settings", "aimCones", GetDefaultAimCones());

            infiniteAmmo = GetConfig("Settings", "infiniteAmmo", false);

            foreach (KeyValuePair<string, object> kvp in bulletDamages)
            {
                if (!permission.PermissionExists(kvp.Key))
                {
                    permission.RegisterPermission(kvp.Key, this);
                }
            }

            foreach (KeyValuePair<string, object> kvp in bulletSpeeds)
            {
                if (!permission.PermissionExists(kvp.Key))
                {
                    permission.RegisterPermission(kvp.Key, this);
                }
            }

            foreach (KeyValuePair<string, object> kvp in ammoTypes)
            {
                if (!permission.PermissionExists(kvp.Key))
                {
                    permission.RegisterPermission(kvp.Key, this);
                }
            }

            foreach (KeyValuePair<string, object> kvp in sightRanges)
            {
                if (!permission.PermissionExists(kvp.Key))
                {
                    permission.RegisterPermission(kvp.Key, this);
                }
            }

            foreach (KeyValuePair<string, object> kvp in healths)
            {
                if (!permission.PermissionExists(kvp.Key))
                {
                    permission.RegisterPermission(kvp.Key, this);
                }
            }

            foreach (KeyValuePair<string, object> kvp in aimCones)
            {
                if (!permission.PermissionExists(kvp.Key))
                {
                    permission.RegisterPermission(kvp.Key, this);
                }
            }

            LoadTurrets();
        }

        [ConsoleCommand("turrets.reload")]
        void ccTurretReload(ConsoleSystem.Arg arg)
        {
            if (arg.connection != null)
            {
                if (arg.connection.authLevel < 1)
                {
                    SendReply(arg, GetMsg("Denied: Permission", arg.connection.userid.ToString()));
                    return;
                }
            }

            LoadTurrets();
        }

        protected void LoadTurrets() {
            AutoTurret[] turrets = GameObject.FindObjectsOfType<AutoTurret>();

            if (turrets.Length > 0)
            {
                int i = 0;
                foreach (AutoTurret turret in turrets.ToList())
                {
                    UpdateTurret(turret);
                    i++;
                }

                PrintWarning("Configured {0} turrets", i);
            }
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating new configuration");
            Config.Clear();

            Config["Settings", "defaultBulletDamage"] = 10f;
            Config["Settings", "defaultBulletSpeed"] = 200f;
            Config["Settings", "defaultAmmoType"] = "ammo.rifle";
            Config["Settings", "defaultSightRange"] = 30f;
            Config["Settings", "defaultHealth"] = 1000;
            Config["Settings", "defaultAimCone"] = 5f;

            Config["Settings", "adminOverride"] = true;
            Config["Settings", "sleepOverride"] = false;
            Config["Settings", "animalOverride"] = true;
            Config["Settings", "useGlobalDamageModifier"] = false;
            Config["Settings", "globalDamageModifier"] = 1f;

            Config["Settings", "animals"] = GetPassiveAnimals();
            Config["Settings", "infiniteAmmo"] = false;

            Config["Settings", "bulletDamages"] = GetDefaultBulletDamages();
            Config["Settings", "bulletSpeeds"] = GetDefaultBulletSpeeds();
            Config["Settings", "ammoTypes"] = GetDefaultAmmoTypes();
            Config["Settings", "sightRanges"] = GetDefaultSightRanges();
            Config["Settings", "health"] = GetDefaultHealth();
            Config["Settings", "aimCones"] = GetDefaultAimCones();
        }

        void LoadMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"Denied: Permission", "You lack permission to do that"},
            }, this);
        }

        private List<object> GetPassiveAnimals()
        {
            return new List<object>
            {
                "stag",
                "boar",
                "chicken",
                "horse",
            };
        }

        private Dictionary<string, object> GetDefaultBulletDamages()
        {
            return new Dictionary<string, object>() {
                {"turretconfig.default", 10f},
            };
        }

        private Dictionary<string, object> GetDefaultBulletSpeeds()
        {
            return new Dictionary<string, object>() {
                {"turretconfig.default", 200f},
            };
        }

        private Dictionary<string, object> GetDefaultSightRanges()
        {
            return new Dictionary<string, object>() {
                {"turretconfig.default", 30f},
            };
        }

        private Dictionary<string, object> GetDefaultAmmoTypes()
        {
            return new Dictionary<string, object>() {
                {"turretconfig.default", "ammo.rifle"},
            };
        }

        private Dictionary<string, object> GetDefaultHealth()
        {
            return new Dictionary<string, object>() {
                {"turretconfig.default", 1000f},
            };
        }

        private Dictionary<string, object> GetDefaultAimCones()
        {
            return new Dictionary<string, object>() {
                {"turretconfig.default", 5f},
            };
        }

        void LoadData()
        {
            if (Config["VERSION"] == null)
            {
                // FOR COMPATIBILITY WITH INITIAL VERSIONS WITHOUT VERSIONED CONFIG
                ReloadConfig();
            }
            else if (GetConfig("VERSION", Version.ToString()) != Version.ToString())
            {
                // ADDS NEW, IF ANY, CONFIGURATION OPTIONS
                ReloadConfig();
            }
        }

        protected void ReloadConfig()
        {
            Config["VERSION"] = Version.ToString();

            // NEW CONFIGURATION OPTIONS HERE
            // END NEW CONFIGURATION OPTIONS

            PrintWarning("Upgrading Configuration File");
            SaveConfig();
        }

        void OnLootEntity(BasePlayer looter, BaseEntity target)
        {
            if (!infiniteAmmo) return;
            if (!permission.UserHasPermission(target.OwnerID.ToString(), "turretconfig.infiniteammo")) return;

            if (target is AutoTurret)
            {
                timer.Once(0.01f, looter.EndLooting);
            }
        }

        private void OnConsumableUse(Item item, int amount)
        {
            if (!infiniteAmmo) return;
            

            var entity = item.parent?.entityOwner as AutoTurret;
            if (entity != null) {
                if (!permission.UserHasPermission(entity.OwnerID.ToString(), "turretconfig.infiniteammo")) return;
                item.amount++;
            }
        }

        private void CheckAmmo(AutoTurret turret)
        {
            if (!infiniteAmmo) return;
            if (!permission.UserHasPermission(turret.OwnerID.ToString(), "turretconfig.infiniteammo")) return;

            var items = new List<Item>();
            var projectile = turret.ammoType.GetComponent<ItemModProjectile>();
            turret.inventory.FindAmmo(items, projectile.ammoType);

            int total = items.Sum(x => x.amount);

            if (total < 1)
            {
                turret.inventory.AddItem(turret.ammoType, 1);
            }
        }

        private object CanBeTargeted(BaseCombatEntity target, MonoBehaviour turret)
        {
            if(target is BasePlayer) {
                var isInvisible = Vanish?.Call("IsInvisible", target);
                if (isInvisible != null && (bool)isInvisible)
                {
                    return null;
                }

                var isStealthed = Skills?.Call("isStealthed", target);
                if (isStealthed != null && (bool)isStealthed)
                {
                    return null;
                }
            }

            if (!(turret is AutoTurret))
            {
                return null;
            }

            if (animalOverride == true && target.GetComponent<BaseNPC>() != null)
            {
                if(animals.Count > 0) {
                    if(animals.Contains(target.ShortPrefabName.Replace(".prefab","").ToLower())) {
                        return false;
                    } else {
                        return null;
                    }
                } else {
                    return false;
                }
            }

            if (target.ToPlayer() == null)
            {
                return null;
            }

            BasePlayer targetPlayer = target.ToPlayer();

            if (adminOverride && targetPlayer.IsConnected() && targetPlayer.net.connection.authLevel > 0)
            {
                return false;
            } 
            else if(sleepOverride && targetPlayer.IsSleeping()) 
            {
                return false;
            }

            return null;
        }

        void OnEntitySpawned(BaseNetworkable entity)
        {
            if (entity == null) return;
            
            if (entity.prefabID == turretPrefabId)
            {
                UpdateTurret((AutoTurret)entity, true);
            }
        }

        float GetBulletDamage(string userID)
        {
            if (!string.IsNullOrEmpty(userID) && userID != "0")
            {
                foreach (KeyValuePair<string, object> kvp in bulletDamages)
                {
                    if (permission.UserHasPermission(userID, kvp.Key))
                    {
                        return Convert.ToSingle(kvp.Value);
                    }
                }
            }

            return defaultBulletDamage;
        }

        float GetHealth(string userID)
        {
            if (!string.IsNullOrEmpty(userID) && userID != "0")
            {
                foreach (KeyValuePair<string, object> kvp in healths)
                {
                    if (permission.UserHasPermission(userID, kvp.Key))
                    {
                        return Convert.ToSingle(kvp.Value);
                    }
                }
            }

            return defaultHealth;
        }

        float GetBulletSpeed(string userID)
        {
            if (!string.IsNullOrEmpty(userID) && userID != "0")
            {
                foreach (KeyValuePair<string, object> kvp in bulletSpeeds)
                {
                    if (permission.UserHasPermission(userID, kvp.Key))
                    {
                        return Convert.ToSingle(kvp.Value);
                    }
                }
            }

            return defaultBulletSpeed;
        }

        float GetSightRange(string userID)
        {
            if (!string.IsNullOrEmpty(userID) && userID != "0")
            {
                foreach (KeyValuePair<string, object> kvp in sightRanges)
                {
                    if (permission.UserHasPermission(userID, kvp.Key))
                    {
                        return Convert.ToSingle(kvp.Value);
                    }
                }
            }

            return defaultSightRange;
        }

        float GetAimCone(string userID)
        {
            if (!string.IsNullOrEmpty(userID) && userID != "0")
            {
                foreach (KeyValuePair<string, object> kvp in aimCones)
                {
                    if (permission.UserHasPermission(userID, kvp.Key))
                    {
                        return Convert.ToSingle(kvp.Value);
                    }
                }
            }

            return defaultAimCone;
        }

        string GetAmmoType(string userID)
        {
            if (!string.IsNullOrEmpty(userID) && userID != "0")
            {
                foreach (KeyValuePair<string, object> kvp in ammoTypes)
                {
                    if (permission.UserHasPermission(userID, kvp.Key))
                    {
                        return kvp.Value.ToString();
                    }
                }
            }

            return defaultAmmoType;
        }

        private void UpdateTurret(AutoTurret turret, bool justCreated = false)
        {
            CheckAmmo(turret);

            string userID = turret.OwnerID.ToString();

            float turretHealth = GetHealth(userID);
            string ammoType = GetAmmoType(userID);

            bulletDamageField.SetValue(turret, GetBulletDamage(userID));
            if (justCreated)
            {
                healthField.SetValue(turret, turretHealth);
            }
            maxHealthField.SetValue(turret, turretHealth);

            if (justCreated)
            {
                turret.InitializeHealth(turretHealth, turretHealth);
            }
            else
            {
                turret.InitializeHealth(turret.health, turretHealth);
            }
            
            turret.bulletSpeed = GetBulletSpeed(userID);
            turret.sightRange = GetSightRange(userID);
            turret.startHealth = turretHealth;
            turret.aimCone = GetAimCone(userID);

            var def = ItemManager.FindItemDefinition(ammoType);
            if (def is ItemDefinition)
            {
                turret.ammoType = def;
                ItemModProjectile projectile = def.GetComponent<ItemModProjectile>();
                if (projectile is ItemModProjectile)
                {
                    turret.gun_fire_effect.guid = projectile.projectileObject.guid;
                    turret.bulletEffect.guid = projectile.projectileObject.guid;
                }
            }
            else
            {
                PrintWarning("No ammo of type ({0})", ammoType);
            }

            turret.Reload();

            //turret.enableSaving = false;
            //turret.ServerInit();
            turret.SendNetworkUpdateImmediate(justCreated);
            
        }

        void OnPlayerAttack(BasePlayer attacker, HitInfo hitInfo)
        {
            if (attacker == null || hitInfo == null || hitInfo.HitEntity == null) return;

            if (hitInfo.HitEntity.prefabID == 3268886773)
            {
                if (useGlobalDamageModifier)
                {
                    hitInfo.damageTypes.ScaleAll(globalDamageModifier);
                    return;
                }
            }
        }

        private T GetConfig<T>(string name, T defaultValue)
        {
            if (Config[name] == null)
            {
                return defaultValue;
            }

            return (T)Convert.ChangeType(Config[name], typeof(T));
        }

        private T GetConfig<T>(string name, string name2, T defaultValue)
        {
            if (Config[name, name2] == null)
            {
                return defaultValue;
            }

            return (T)Convert.ChangeType(Config[name, name2], typeof(T));
        }

        string GetMsg(string key, string userID = null)
        {
            return lang.GetMessage(key, this, userID);
        }
    }
}


// --- End of file: TurretConfig.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/AutoPickup.cs ---
// --- Original Local Path: AutoPickup.cs ---

﻿//#define DEBUG

using System;
using System.Collections.Generic;
using ConVar;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Auto Pickup", "Arainrr", "1.2.16")]
    [Description("Automatically pickup hemp, pumpkin, ore, pickupable items, corpse, etc.")]
    public class AutoPickup : RustPlugin
    {
        #region Fields

        [PluginReference] private readonly Plugin Friends, Clans;

        private static AutoPickup instance;
        private static PickupType enabledPickupTypes;
        private static object False;
        private const string PERMISSION_USE = "autopickup.use";

        [Flags]
        //[JsonConverter(typeof(StringEnumConverter))]
        private enum PickupType
        {
            None = 0,
            PlantEntity = 1,
            CollectibleEntity = 1 << 1,
            MurdererCorpse = 1 << 2,
            ScientistCorpse = 1 << 3,
            PlayerCorpse = 1 << 4,
            ItemDropBackpack = 1 << 5,
            ItemDrop = 1 << 6,
            WorldItem = 1 << 7,
            LootContainer = 1 << 8,
            CollectableGifts = 1 << 9,
        }

        #endregion Fields

        #region Oxide Hooks

        private void Init()
        {
            LoadData();
            False = false;
            instance = this;
            enabledPickupTypes = PickupType.None;
            Unsubscribe(nameof(CanLootEntity));
            Unsubscribe(nameof(OnPlayerAttack));
            Unsubscribe(nameof(OnEntitySpawned));
            permission.RegisterPermission(PERMISSION_USE, this);
            cmd.AddChatCommand(configData.chatS.command, this, nameof(CmdAutoPickup));
        }

        private void OnServerInitialized()
        {
            UpdateConfig();
            foreach (var entry in configData.autoPickupS)
            {
                if (entry.Value.enabled)
                {
                    enabledPickupTypes |= entry.Key;
                }
            }
            if (enabledPickupTypes.HasFlag(PickupType.LootContainer))
            {
                bool enabledBarrel = false, enabledLoot = false;
                foreach (var entry in configData.lootContainerS)
                {
                    if (!entry.Value) continue;
                    if (IsBarrel(entry.Key))
                    {
                        enabledBarrel = true;
                    }
                    else
                    {
                        enabledLoot = true;
                    }
                }

                if (enabledBarrel)
                {
                    Subscribe(nameof(OnPlayerAttack));
                }
                if (enabledLoot)
                {
                    Subscribe(nameof(CanLootEntity));
                }
            }
            Subscribe(nameof(OnEntitySpawned));
            foreach (var baseNetworkable in BaseNetworkable.serverEntities)
            {
                CheckEntity(baseNetworkable);
            }
        }

        private void OnServerSave() => timer.Once(UnityEngine.Random.Range(0f, 60f), SaveData);

        private void Unload()
        {
            if (AutoPickupHelper.autoPickupHelpers != null)
            {
                foreach (var autoPickupEntity in AutoPickupHelper.autoPickupHelpers.ToArray())
                {
                    UnityEngine.Object.Destroy(autoPickupEntity);
                }
                AutoPickupHelper.autoPickupHelpers = null;
            }

            foreach (var player in BasePlayer.activePlayerList)
            {
                DestroyUI(player);
            }
            SaveData();
            configData = null;
            False = instance = null;
        }

        private void OnPlayerAttack(BasePlayer attacker, HitInfo info)
        {
            if (attacker == null || !attacker.userID.IsSteamId()) return;
            var barrel = info?.HitEntity as LootContainer;
            if (barrel == null || barrel.net == null) return;
            if (!IsBarrel(barrel.ShortPrefabName)) return;
            var radius = configData.autoPickupS[PickupType.LootContainer].radius;
            if (radius > 0f && Vector3.Distance(attacker.transform.position, barrel.transform.position) > radius)
            {
                return;
            }
            if (permission.UserHasPermission(attacker.UserIDString, PERMISSION_USE))
            {
                if (TryPickupLootContainer(barrel, attacker, info))
                {
                }
            }
        }

        private object CanLootEntity(BasePlayer player, LootContainer lootContainer)
        {
            if (player == null || lootContainer == null) return null;
            if (permission.UserHasPermission(player.UserIDString, PERMISSION_USE))
            {
                if (TryPickupLootContainer(lootContainer, player))
                {
                    return False;
                }
            }
            return null;
        }

        private void OnEntitySpawned(BaseNetworkable baseNetworkable) => CheckEntity(baseNetworkable, true);

        #endregion Oxide Hooks

        #region Methods

        private bool TryPickupLootContainer(LootContainer lootContainer, BasePlayer player, HitInfo info = null)
        {
            bool enabled;
            if (configData.lootContainerS.TryGetValue(lootContainer.ShortPrefabName, out enabled) && !enabled)
            {
                return false;
            }
            if (configData.globalS.preventPickupLoot && lootContainer.OwnerID.IsSteamId() && !AreFriends(lootContainer.OwnerID, player.userID))
            {
                return false;
            }
            var autoPickData = GetAutoPickupData(player.userID, true);
            if (autoPickData.enabled && !autoPickData.blockPickupTypes.HasFlag(PickupType.LootContainer))
            {
                if (CanAutoPickup(player, lootContainer) && PickupLootContainer(player, lootContainer, info))
                {
                    return true;
                }
            }
            return false;
        }

        private void UpdateConfig()
        {
            foreach (PickupType pickupType in Enum.GetValues(typeof(PickupType)))
            {
                if (pickupType == PickupType.None) continue;
                if (!configData.autoPickupS.ContainsKey(pickupType))
                {
                    configData.autoPickupS.Add(pickupType, new ConfigData.PickupTypeS { enabled = true, radius = 0.5f });
                }
            }
            foreach (var itemDefinition in ItemManager.GetItemDefinitions())
            {
                if (!configData.worldItemS.itemCategoryS.ContainsKey(itemDefinition.category))
                {
                    configData.worldItemS.itemCategoryS.Add(itemDefinition.category, true);
                }
            }
            foreach (var prefab in GameManifest.Current.entities)
            {
                var entity = GameManager.server.FindPrefab(prefab.ToLower())?.GetComponent<BaseEntity>();
                if (entity == null || string.IsNullOrEmpty(entity.ShortPrefabName)) continue;
                var lootContainer = entity as LootContainer;
                if (lootContainer != null)
                {
                    if (!configData.lootContainerS.ContainsKey(lootContainer.ShortPrefabName))
                    {
                        configData.lootContainerS.Add(lootContainer.ShortPrefabName, !lootContainer.ShortPrefabName.Contains("stocking"));
                    }
                    continue;
                }
                var collectibleEntity = entity as CollectibleEntity;
                if (collectibleEntity != null)
                {
                    if (!configData.collectibleEntityS.ContainsKey(collectibleEntity.ShortPrefabName))
                    {
                        configData.collectibleEntityS.Add(collectibleEntity.ShortPrefabName, true);
                    }
                    continue;
                }
                var plantEntity = entity as GrowableEntity;
                if (plantEntity != null)
                {
                    if (!configData.plantEntityS.ContainsKey(plantEntity.ShortPrefabName))
                    {
                        configData.plantEntityS.Add(plantEntity.ShortPrefabName, true);
                    }
                    continue;
                }
            }
            SaveConfig();
        }

        #region AreFriends

        private bool AreFriends(ulong playerID, ulong friendID)
        {
            if (playerID == friendID) return true;
            if (configData.globalS.useTeams && SameTeam(playerID, friendID)) return true;
            if (configData.globalS.useFriends && HasFriend(playerID, friendID)) return true;
            if (configData.globalS.useClans && SameClan(playerID, friendID)) return true;
            return false;
        }

        private static bool SameTeam(ulong playerID, ulong friendID)
        {
            if (!RelationshipManager.TeamsEnabled()) return false;
            var playerTeam = RelationshipManager.ServerInstance.FindPlayersTeam(playerID);
            if (playerTeam == null) return false;
            var friendTeam = RelationshipManager.ServerInstance.FindPlayersTeam(friendID);
            if (friendTeam == null) return false;
            return playerTeam == friendTeam;
        }

        private bool HasFriend(ulong playerID, ulong friendID)
        {
            if (Friends == null) return false;
            return (bool)Friends.Call("HasFriend", playerID, friendID);
        }

        private bool SameClan(ulong playerID, ulong friendID)
        {
            if (Clans == null) return false;
            //Clans
            var isMember = Clans.Call("IsClanMember", playerID.ToString(), friendID.ToString());
            if (isMember != null) return (bool)isMember;
            //Rust:IO Clans
            var playerClan = Clans.Call("GetClanOf", playerID);
            if (playerClan == null) return false;
            var friendClan = Clans.Call("GetClanOf", friendID);
            if (friendClan == null) return false;
            return (string)playerClan == (string)friendClan;
        }

        #endregion AreFriends

        #region Data

        private StoredData.AutoPickData defaultData;

        private StoredData.AutoPickData DefaultData => defaultData ?? (defaultData = CreateDefaultData());

        private StoredData.AutoPickData GetAutoPickupData(ulong playerID, bool readOnly = false)
        {
            StoredData.AutoPickData autoPickData;
            if (!storedData.playerAutoPickupData.TryGetValue(playerID, out autoPickData))
            {
                if (readOnly)
                {
                    return DefaultData;
                }

                autoPickData = CreateDefaultData();
                storedData.playerAutoPickupData.Add(playerID, autoPickData);
            }

            return autoPickData;
        }

        private StoredData.AutoPickData CreateDefaultData()
        {
            return new StoredData.AutoPickData
            {
                enabled = configData.globalS.defaultEnabled
            };
        }

        #endregion Data

        #endregion Methods

        #region Helpers

        private static void CheckEntity(BaseNetworkable baseNetworkable, bool justCreated = false)
        {
            if (baseNetworkable == null) return;
            var pickupType = GetPickupTypeFromEntity(baseNetworkable);
            if (pickupType == PickupType.None) return;
            if (!enabledPickupTypes.HasFlag(pickupType))
            {
                return;
            }
            var autoPickupEntity = baseNetworkable.GetComponent<AutoPickupHelper>();
            if (autoPickupEntity != null)
            {
                UnityEngine.Object.Destroy(autoPickupEntity);
            }

            switch (pickupType)
            {
                case PickupType.CollectibleEntity:
                    {
                        bool enabled;
                        if (configData.collectibleEntityS.TryGetValue(baseNetworkable.ShortPrefabName, out enabled) && !enabled)
                        {
                            return;
                        }
                        break;
                    }

                case PickupType.PlantEntity:
                    {
                        bool enabled;
                        if (configData.plantEntityS.TryGetValue(baseNetworkable.ShortPrefabName, out enabled) && !enabled)
                        {
                            return;
                        }
                        if (configData.globalS.preventPlanterBox && baseNetworkable.GetParentEntity() is PlanterBox)
                        {
                            return;
                        }
                        break;
                    }

                case PickupType.MurdererCorpse:
                case PickupType.ScientistCorpse:
                case PickupType.PlayerCorpse:
                case PickupType.ItemDrop:
                case PickupType.ItemDropBackpack:
                    break;

                case PickupType.WorldItem:
                    {
                        var worldItem = baseNetworkable as WorldItem;
                        if (worldItem != null)
                        {
                            var item = worldItem.GetItem();
                            if (item != null)
                            {
                                if (configData.worldItemS.itemBlockList.Contains(item.info.shortname)) return;
                                bool enabled;
                                if (configData.worldItemS.itemCategoryS.TryGetValue(item.info.category, out enabled) && !enabled)
                                {
                                    return;
                                }
                            }
                        }
                        if (justCreated)
                        {
                            var collisionDetection = baseNetworkable.GetComponent<WorldItemCollisionDetection>();
                            if (collisionDetection != null)
                            {
                                UnityEngine.Object.Destroy(collisionDetection);
                            }
                            baseNetworkable.gameObject.AddComponent<WorldItemCollisionDetection>();
                            return;
                        }
                        break;
                    }
            }
            CreateAutoPickupHelper(baseNetworkable.transform, pickupType);
        }

        private static PickupType GetPickupTypeFromEntity(BaseNetworkable baseNetworkable)
        {
            switch (baseNetworkable.ShortPrefabName)
            {
                case "murderer_corpse": return PickupType.MurdererCorpse;
                case "scientist_corpse": return PickupType.ScientistCorpse;
                case "player_corpse": return PickupType.PlayerCorpse;
                case "item_drop": return PickupType.ItemDrop;
                case "item_drop_backpack": return PickupType.ItemDropBackpack;
                default:
                    if (baseNetworkable is GrowableEntity)
                    {
                        return PickupType.PlantEntity;
                    }
                    if (baseNetworkable is CollectibleEntity)
                    {
                        return PickupType.CollectibleEntity;
                    }
                    if (baseNetworkable is WorldItem)
                    {
                        return PickupType.WorldItem;
                    }
                    if (baseNetworkable is CollectableEasterEgg)
                    {
                        return PickupType.CollectableGifts;
                    }
                    return PickupType.None;
            }
        }

        private static void CreateAutoPickupHelper(Transform transform, PickupType pickupType)
        {
            var newObject = new GameObject("AutoPickHelper");
            newObject.transform.SetParent(transform);
            newObject.transform.position = transform.position;
            newObject.AddComponent<AutoPickupHelper>().Init(pickupType);
        }

        private static bool PickupLootContainer(BasePlayer player, LootContainer lootContainer, HitInfo info = null)
        {
            var itemContainer = lootContainer?.inventory;
            if (itemContainer != null)
            {
                for (int i = itemContainer.itemList.Count - 1; i >= 0; i--)
                {
                    player.GiveItem(itemContainer.itemList[i], BaseEntity.GiveItemReason.PickedUp);
                }
                if (itemContainer.itemList == null || itemContainer.itemList.Count <= 0)
                {
                    if (info != null)
                    {
                        lootContainer.Invoke(() => lootContainer.Die(info), 0.2f);
                    }
                    else
                    {
                        lootContainer.Invoke(() => lootContainer.Kill(BaseNetworkable.DestroyMode.Gib), 0.2f);
                    }
                }
                return true;
            }
            return false;
        }

        private static bool InventoryExistItem(BasePlayer player, Item item)
        {
            return player.inventory.containerMain.FindItemByItemID(item.info.itemid) != null
                   || player.inventory.containerBelt.FindItemByItemID(item.info.itemid) != null;
        }

        private static bool InventoryIsFull(BasePlayer player, Item item)
        {
            if (player.inventory.containerMain.IsFull() && player.inventory.containerBelt.IsFull())
            {
                var item1 = player.inventory.containerMain.FindItemByItemID(item.info.itemid);
                var item2 = player.inventory.containerBelt.FindItemByItemID(item.info.itemid);
                return (item1 == null || !item.CanStack(item1)) && (item2 == null || !item.CanStack(item2));
            }
            return false;
        }

        private static bool PickupDroppedItemContainer(BasePlayer player, DroppedItemContainer droppedItemContainer)
        {
            var itemContainer = droppedItemContainer?.inventory;
            if (itemContainer != null)
            {
                for (int i = itemContainer.itemList.Count - 1; i >= 0; i--)
                {
                    player.GiveItem(itemContainer.itemList[i], BaseEntity.GiveItemReason.PickedUp);
                }
                if (itemContainer.itemList == null || itemContainer.itemList.Count <= 0)
                {
                    droppedItemContainer.Kill(BaseNetworkable.DestroyMode.Gib);
                }
                return true;
            }
            return false;
        }

        private static bool PickupPlayerCorpse(BasePlayer player, PlayerCorpse playerCorpse)
        {
            var itemContainers = playerCorpse?.containers;
            if (itemContainers != null)
            {
                for (int i = itemContainers.Length - 1; i >= 0; i--)
                {
                    var itemContainer = itemContainers[i];
                    if (itemContainer != null)
                    {
                        for (int j = itemContainer.itemList.Count - 1; j >= 0; j--)
                        {
                            player.GiveItem(itemContainer.itemList[j], BaseEntity.GiveItemReason.PickedUp);
                        }
                    }
                }
                return true;
            }
            return false;
        }

        private static bool CanAutoPickup(BasePlayer player, BaseEntity entity)
        {
            return entity != null && player.CanInteract() && Interface.CallHook("OnAutoPickupEntity", player, entity) == null;
        }

        private static bool IsBarrel(string shortPrefabName) => shortPrefabName.Contains("barrel") || shortPrefabName.Contains("roadsign");

        #endregion Helpers

        #region Components

        private class WorldItemCollisionDetection : MonoBehaviour
        {
            private bool collided;

            private void OnCollisionEnter(Collision collision)
            {
                if (collided || collision?.gameObject == null) return;
                collided = true;
                Invoke(nameof(AddAutoPickupComponent), configData.worldItemS.pickupDelay);
            }

            private void AddAutoPickupComponent()
            {
                CreateAutoPickupHelper(transform, PickupType.WorldItem);
                DestroyImmediate(this);
            }
        }

        private class AutoPickupHelper : FacepunchBehaviour
        {
            private const int LAYER_PLAYER = (int)Rust.Layer.Player_Server;
            public static List<AutoPickupHelper> autoPickupHelpers;

            private BaseEntity entity;
            private PickupType pickupType;
            private SphereCollider sphereCollider;

            private void Awake()
            {
                if (autoPickupHelpers == null)
                {
                    autoPickupHelpers = new List<AutoPickupHelper>();
                }
                autoPickupHelpers.Add(this);
                entity = GetComponentInParent<BaseEntity>();
            }

            public void Init(PickupType pickupType)
            {
                if (gameObject == null || entity == null)
                {
                    Destroy(this);
                    return;
                }
                this.pickupType = pickupType;
                transform.position = entity.CenterPoint();
                CreateCollider();
            }

            private void CreateCollider()
            {
                sphereCollider = gameObject.AddComponent<SphereCollider>();
                sphereCollider.gameObject.layer = (int)Rust.Layer.Reserved1;
                sphereCollider.radius = configData.autoPickupS[pickupType].radius;
                sphereCollider.isTrigger = true;
#if DEBUG
                InvokeRepeating(Tick, 0f, 1f);
#endif
            }

#if DEBUG

            private void Tick()
            {
                foreach (var player in BasePlayer.activePlayerList)
                {
                    if (player.IsAdmin && Vector3.Distance(transform.position, player.transform.position) < 50f)
                    {
                        player.SendConsoleCommand("ddraw.sphere", 1, Color.cyan, sphereCollider.transform.position, sphereCollider.radius);
                    }
                }
            }

#endif

            private void OnTriggerEnter(Collider collider)
            {
                if (collider == null || collider.gameObject == null) return;
                if (collider.gameObject.layer != LAYER_PLAYER) return;
                var player = collider.ToBaseEntity() as BasePlayer;
                if (player == null || !player.userID.IsSteamId()) return;
                if (instance.permission.UserHasPermission(player.UserIDString, PERMISSION_USE))
                {
                    var autoPickData = instance.GetAutoPickupData(player.userID, true);
                    if (autoPickData.enabled && !autoPickData.blockPickupTypes.HasFlag(pickupType))
                    {
                        switch (pickupType)
                        {
                            case PickupType.PlantEntity:
                                var plantEntity = entity as GrowableEntity;
                                if (configData.globalS.preventPickupPlant && plantEntity.OwnerID.IsSteamId() && !instance.AreFriends(plantEntity.OwnerID, player.userID)) return;
                                if (CanAutoPickup(player, plantEntity))
                                {
                                    if (autoPickData.autoClone)
                                    {
                                        plantEntity.TakeClones(player);
                                    }
                                    else
                                    {
                                        plantEntity.PickFruit(player);
                                    }
                                    plantEntity.RemoveDying(player);
                                }
                                return;

                            case PickupType.CollectibleEntity:
                                var collectibleEntity = entity as CollectibleEntity;
                                if (CanAutoPickup(player, collectibleEntity))
                                {
                                    collectibleEntity.DoPickup(player);
                                    Destroy(this);
                                }
                                return;

                            case PickupType.ItemDrop:
                            case PickupType.ItemDropBackpack:
                                var droppedItemContainer = entity as DroppedItemContainer;
                                if (configData.globalS.preventPickupBackpack && droppedItemContainer.playerSteamID.IsSteamId() && !instance.AreFriends(droppedItemContainer.playerSteamID, player.userID)) return;
                                if (CanAutoPickup(player, droppedItemContainer))
                                {
                                    if (PickupDroppedItemContainer(player, droppedItemContainer))
                                    {
                                        Destroy(this);
                                    }
                                }
                                return;

                            case PickupType.MurdererCorpse:
                            case PickupType.ScientistCorpse:
                            case PickupType.PlayerCorpse:
                                var playerCorpse = entity as PlayerCorpse;
                                if (!playerCorpse.CanLoot()) return;
                                if (configData.globalS.preventPickupCorpse && playerCorpse.playerSteamID.IsSteamId() && !instance.AreFriends(playerCorpse.playerSteamID, player.userID)) return;
                                if (CanAutoPickup(player, playerCorpse))
                                {
                                    if (PickupPlayerCorpse(player, playerCorpse))
                                    {
                                        Destroy(this);
                                    }
                                }
                                return;

                            case PickupType.WorldItem:
                                var worldItem = entity as WorldItem;
                                if (CanAutoPickup(player, worldItem))
                                {
                                    var item = worldItem.GetItem();
                                    if (item != null)
                                    {
                                        if (configData.worldItemS.onlyPickupExistItem && !InventoryExistItem(player, item)) return;
                                        if (configData.worldItemS.checkInventoryFull && InventoryIsFull(player, item)) return;
                                        var rpcMessage = default(BaseEntity.RPCMessage);
                                        rpcMessage.player = player;
                                        worldItem.Pickup(rpcMessage);
                                        Destroy(this);
                                    }
                                }
                                return;

                            case PickupType.CollectableGifts:
                                var gifts = entity as CollectableEasterEgg;
                                if (CanAutoPickup(player, gifts))
                                {
                                    if (configData.collectableGiftsS.requiresBasket && !(player.GetHeldEntity() is EasterBasket)) return;
                                    if (EggHuntEvent.serverEvent != null)
                                    {
                                        if (!EggHuntEvent.serverEvent.IsEventActive())
                                        {
                                            return;
                                        }
                                        EggHuntEvent.serverEvent.OnEggCollected(player, gifts);
                                        player.GiveItem(ItemManager.Create(gifts.itemToGive));
                                    }
                                    Effect.server.Run(gifts.pickupEffect.resourcePath, base.transform.position + Vector3.up * 0.3f, Vector3.up);
                                    gifts.Kill();
                                    Destroy(this);
                                }
                                return;

                            default:
                                return;
                        }
                    }
                }
            }

            private void OnDestroy()
            {
                Destroy(gameObject);
                autoPickupHelpers?.Remove(this);
            }
        }

        #endregion Components

        #region UI

        private const string UINAME_MAIN = "AutoPickupUI_Main";
        private const string UINAME_MENU = "AutoPickupUI_Menu";

        private static void CreateMainUI(BasePlayer player)
        {
            var container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                Image = { Color = "0 0 0 0" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-180 -180", OffsetMax = "180 230" },
                CursorEnabled = true
            }, "Hud", UINAME_MAIN);
            container.Add(new CuiPanel
            {
                Image = { Color = "0 0 0 0.6" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
            }, UINAME_MAIN);
            var titlePanel = container.Add(new CuiPanel
            {
                Image = { Color = "0.31 0.88 0.71 1" },
                RectTransform = { AnchorMin = "0 0.912", AnchorMax = "0.998 1" },
            }, UINAME_MAIN);
            container.Add(new CuiElement
            {
                Parent = titlePanel,
                Components =
                {
                    new CuiTextComponent { Text = instance.Lang("Title", player.UserIDString), FontSize = 20, Align = TextAnchor.MiddleCenter, Color ="1 0 0 1" },
                    new CuiOutlineComponent { Distance = "0.5 0.5", Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.2 0",  AnchorMax = "0.8 1" }
                }
            });
            container.Add(new CuiButton
            {
                Button = { Color = "0.95 0.1 0.1 0.95", Close = UINAME_MAIN },
                Text = { Text = "X", Align = TextAnchor.MiddleCenter, Color = "0 0 0 1", FontSize = 22 },
                RectTransform = { AnchorMin = "0.885 0", AnchorMax = "1 0.99" }
            }, titlePanel);
            CuiHelper.DestroyUi(player, UINAME_MAIN);
            CuiHelper.AddUi(player, container);
            var autoPickData = instance.GetAutoPickupData(player.userID);
            UpdateMenuUI(player, autoPickData);
        }

        private static void UpdateMenuUI(BasePlayer player, StoredData.AutoPickData autoPickData)
        {
            if (player == null) return;
            var container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                Image = { Color = "0.1 0.1 0.1 0.4" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.898" },
            }, UINAME_MAIN, UINAME_MENU);
            int i = 0;
            const float spacingY = 0.01f;
            const float entrySize = (1f - 11f * spacingY) / 12f;

            var enabledMsg = instance.Lang("Enabled", player.UserIDString);
            var disabledMsg = instance.Lang("Disabled", player.UserIDString);

            var anchors = GetEntryAnchors(i++, entrySize, spacingY);
            CreateEntryUI(ref container, $"AutoPickupUI Toggle",
                instance.Lang("Status", player.UserIDString),
                autoPickData.enabled ? enabledMsg : disabledMsg,
                $"0 {anchors[0]}", $"0.995 {anchors[1]}");
            foreach (PickupType pickupType in Enum.GetValues(typeof(PickupType)))
            {
                if (pickupType == PickupType.None || !enabledPickupTypes.HasFlag(pickupType)) continue;
                anchors = GetEntryAnchors(i++, entrySize, spacingY);
                CreateEntryUI(ref container, $"AutoPickupUI {pickupType}",
                    instance.Lang(pickupType.ToString(), player.UserIDString),
                    !autoPickData.blockPickupTypes.HasFlag(pickupType) ? enabledMsg : disabledMsg,
                    $"0 {anchors[0]}", $"0.995 {anchors[1]}");

                if (pickupType == PickupType.PlantEntity && !autoPickData.blockPickupTypes.HasFlag(pickupType))
                {
                    anchors = GetEntryAnchors(i++, entrySize, spacingY);
                    CreateEntryUI(ref container, $"AutoPickupUI Clone",
                        instance.Lang("AutoClonePlants", player.UserIDString),
                        autoPickData.autoClone ? enabledMsg : disabledMsg,
                        $"0 {anchors[0]}", $"0.995 {anchors[1]}");
                }
            }

            CuiHelper.DestroyUi(player, UINAME_MENU);
            CuiHelper.AddUi(player, container);
        }

        private static void CreateEntryUI(ref CuiElementContainer container, string command, string leftText, string rightText, string anchorMin, string anchorMax)
        {
            var panelName = container.Add(new CuiPanel
            {
                Image = { Color = "0.1 0.1 0.1 0.6" },
                RectTransform = { AnchorMin = anchorMin, AnchorMax = anchorMax },
            }, UINAME_MENU);
            container.Add(new CuiLabel
            {
                Text = { Color = "0 1 1 1", FontSize = 14, Align = TextAnchor.MiddleLeft, Text = leftText },
                RectTransform = { AnchorMin = "0.06 0", AnchorMax = "0.795 1" }
            }, panelName);
            container.Add(new CuiButton
            {
                Button = { Color = "0 0 0 0.7", Command = command },
                Text = { Text = rightText, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1", FontSize = 14 },
                RectTransform = { AnchorMin = "0.7 0.2", AnchorMax = "0.985 0.8" },
            }, panelName);
        }

        private static float[] GetEntryAnchors(int i, float entrySize, float spacingY)
        {
            //return new[] { 1f - (i + 1) * spacing, 1f - i * spacing };
            return new[] { 1f - (i + 1) * entrySize - i * spacingY, 1f - i * (entrySize + spacingY) };
        }

        private static void DestroyUI(BasePlayer player) => CuiHelper.DestroyUi(player, UINAME_MAIN);

        #endregion UI

        #region Commands

        [ConsoleCommand("AutoPickupUI")]
        private void CCmdAutoPickupUI(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;
            if (!permission.UserHasPermission(player.UserIDString, PERMISSION_USE)) return;
            var autoPickData = GetAutoPickupData(player.userID);
            switch (arg.Args[0].ToLower())
            {
                case "toggle":
                    autoPickData.enabled = !autoPickData.enabled;
                    break;

                case "clone":
                    autoPickData.autoClone = !autoPickData.autoClone;
                    break;

                default:
                    PickupType pickupType;
                    if (Enum.TryParse(arg.Args[0], true, out pickupType))
                    {
                        if (autoPickData.blockPickupTypes.HasFlag(pickupType))
                        {
                            autoPickData.blockPickupTypes &= ~pickupType;
                        }
                        else
                        {
                            autoPickData.blockPickupTypes |= pickupType;
                        }
                    }

                    break;
            }
            UpdateMenuUI(player, autoPickData);
        }

        private void CmdAutoPickup(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, PERMISSION_USE))
            {
                Print(player, Lang("NotAllowed", player.UserIDString));
                return;
            }
            CreateMainUI(player);
        }

        #endregion Commands

        #region ConfigurationFile

        private static ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Settings")]
            public Settings globalS = new Settings();

            [JsonProperty(PropertyName = "Chat Settings")]
            public ChatS chatS = new ChatS();

            [JsonProperty(PropertyName = "Auto Pickup Settings")]
            public Dictionary<PickupType, PickupTypeS> autoPickupS = new Dictionary<PickupType, PickupTypeS>();

            [JsonProperty(PropertyName = "World Item Pickup Settings")]
            public WorldItemPickupS worldItemS = new WorldItemPickupS();

            [JsonProperty(PropertyName = "Collectable Gifts Pickup Settings")]
            public CollectableGiftsPickupS collectableGiftsS = new CollectableGiftsPickupS();

            [JsonProperty(PropertyName = "Loot Container Pickup Settings")]
            public Dictionary<string, bool> lootContainerS = new Dictionary<string, bool>();

            [JsonProperty(PropertyName = "Collectible Entity Pickup Settings")]
            public Dictionary<string, bool> collectibleEntityS = new Dictionary<string, bool>();

            [JsonProperty(PropertyName = "Plant Entity Pickup Settings")]
            public Dictionary<string, bool> plantEntityS = new Dictionary<string, bool>();

            public class Settings
            {
                [JsonProperty(PropertyName = "Clear Data On Map Wipe")]
                public bool clearDataOnWipe = false;

                [JsonProperty(PropertyName = "Use Teams")]
                public bool useTeams = false;

                [JsonProperty(PropertyName = "Use Clans")]
                public bool useClans = true;

                [JsonProperty(PropertyName = "Use Friends")]
                public bool useFriends = true;

                [JsonProperty(PropertyName = "Auto pickup is enabled by default")]
                public bool defaultEnabled = true;

                [JsonProperty(PropertyName = "Prevent pickup other player's backpack")]
                public bool preventPickupBackpack;

                [JsonProperty(PropertyName = "Prevent pickup other player's corpse")]
                public bool preventPickupCorpse;

                [JsonProperty(PropertyName = "Prevent pickup other player's plant entity")]
                public bool preventPickupPlant;

                [JsonProperty(PropertyName = "Prevent pickup other player's loot container")]
                public bool preventPickupLoot = true;

                [JsonProperty(PropertyName = "Prevent pickup of plant entities in the planter box")]
                public bool preventPlanterBox = false;
            }

            public class ChatS
            {
                [JsonProperty(PropertyName = "Chat Command")]
                public string command = "ap";

                [JsonProperty(PropertyName = "Chat Prefix")]
                public string prefix = "<color=#00FFFF>[AutoPickup]</color>: ";

                [JsonProperty(PropertyName = "Chat SteamID Icon")]
                public ulong steamIDIcon = 0;
            }

            public class PickupTypeS
            {
                [JsonProperty(PropertyName = "Enabled")]
                public bool enabled = true;

                [JsonProperty(PropertyName = "Check Radius")]
                public float radius = 0.5f;
            }

            public class WorldItemPickupS
            {
                [JsonProperty(PropertyName = "Auto Pickup Delay")]
                public float pickupDelay = 0.5f;

                [JsonProperty(PropertyName = "Check that player's inventory is full")]
                public bool checkInventoryFull = true;

                [JsonProperty(PropertyName = "Only pickup items that exist in player's inventory")]
                public bool onlyPickupExistItem;

                [JsonProperty(PropertyName = "Item Block List (Item shortname)")]
                public HashSet<string> itemBlockList = new HashSet<string>();

                [JsonProperty(PropertyName = "Allow Pickup Item Category")]
                public Dictionary<ItemCategory, bool> itemCategoryS = new Dictionary<ItemCategory, bool>();
            }

            public class CollectableGiftsPickupS
            {
                [JsonProperty(PropertyName = "Requires player to hold a basket")]
                public bool requiresBasket = true;
            }

            [JsonProperty(PropertyName = "Version")]
            public VersionNumber version;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                configData = Config.ReadObject<ConfigData>();
                if (configData == null)
                {
                    LoadDefaultConfig();
                }
                else
                {
                    UpdateConfigValues();
                }
            }
            catch (Exception ex)
            {
                PrintError($"The configuration file is corrupted. \n{ex}");
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            configData = new ConfigData();
            configData.version = Version;
        }

        protected override void SaveConfig() => Config.WriteObject(configData);

        private void UpdateConfigValues()
        {
            if (configData.version < Version)
            {
                if (configData.version <= default(VersionNumber))
                {
                    string prefix, prefixColor;
                    if (GetConfigValue(out prefix, "Chat Settings", "Chat Prefix") && GetConfigValue(out prefixColor, "Chat Settings", "Chat Prefix Color"))
                    {
                        configData.chatS.prefix = $"<color={prefixColor}>{prefix}</color>: ";
                    }
                }

                if (configData.version <= new VersionNumber(1, 2, 13))
                {
                    configData.autoPickupS[PickupType.LootContainer].radius = 0f;
                }
                configData.version = Version;
            }
        }

        private bool GetConfigValue<T>(out T value, params string[] path)
        {
            var configValue = Config.Get(path);
            if (configValue == null)
            {
                value = default(T);
                return false;
            }
            value = Config.ConvertValue<T>(configValue);
            return true;
        }

        #endregion ConfigurationFile

        #region DataFile

        private StoredData storedData;

        private class StoredData
        {
            public readonly Dictionary<ulong, AutoPickData> playerAutoPickupData = new Dictionary<ulong, AutoPickData>();

            public class AutoPickData
            {
                public bool enabled;
                public bool autoClone;
                public PickupType blockPickupTypes;
            }
        }

        private void LoadData()
        {
            try
            {
                storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
            }
            catch
            {
                storedData = null;
            }
            if (storedData == null)
            {
                ClearData();
            }
        }

        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, storedData);

        private void ClearData()
        {
            storedData = new StoredData();
            SaveData();
        }

        private void OnNewSave(string filename)
        {
            if (configData.globalS.clearDataOnWipe)
            {
                ClearData();
            }
        }

        #endregion DataFile

        #region LanguageFile

        private void Print(BasePlayer player, string message)
        {
            Player.Message(player, message, configData.chatS.prefix, configData.chatS.steamIDIcon);
        }

        private string Lang(string key, string id = null, params object[] args)
        {
            try
            {
                return string.Format(lang.GetMessage(key, this, id), args);
            }
            catch (Exception)
            {
                PrintError($"Error in the language formatting of '{key}'. (userid: {id}. lang: {lang.GetLanguage(id)}. args: {string.Join(" ,", args)})");
                throw;
            }
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NotAllowed"] = "You do not have permission to use this command",
                ["Enabled"] = "<color=#8ee700>Enabled</color>",
                ["Disabled"] = "<color=#ce422b>Disabled</color>",
                ["Title"] = "Auto Pickup UI",
                ["Status"] = "Auto Pickup Status",
                ["PlantEntity"] = "Auto Pickup Plant Entity",
                ["CollectibleEntity"] = "Auto Pickup Collectible Entity",
                ["MurdererCorpse"] = "Auto Pickup Murderer Corpse",
                ["ScientistCorpse"] = "Auto Pickup Scientist Corpse",
                ["PlayerCorpse"] = "Auto Pickup Player Corpse",
                ["ItemDropBackpack"] = "Auto Pickup Item Drop Backpack",
                ["ItemDrop"] = "Auto Pickup Item Drop",
                ["WorldItem"] = "Auto Pickup World Item",
                ["LootContainer"] = "Auto Pickup Loot Container",
                ["CollectableGifts"] = "Auto Pickup Collectable Gifts",
                ["AutoClonePlants"] = "Auto Clone Plants",
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NotAllowed"] = "您没有使用该命令的权限",
                ["Enabled"] = "<color=#8ee700>已启用</color>",
                ["Disabled"] = "<color=#ce422b>已禁用</color>",
                ["Title"] = "自动拾取设置",
                ["Status"] = "自动拾取状态",
                ["PlantEntity"] = "自动拾取农作物",
                ["CollectibleEntity"] = "自动拾取收藏品",
                ["MurdererCorpse"] = "自动拾取僵尸尸体",
                ["ScientistCorpse"] = "自动拾取科学家尸体",
                ["PlayerCorpse"] = "自动拾取玩家尸体",
                ["ItemDropBackpack"] = "自动拾取尸体背包",
                ["ItemDrop"] = "自动拾取掉落容器",
                ["WorldItem"] = "自动拾取掉落物品",
                ["LootContainer"] = "自动拾取战利品容器",
                ["CollectableGifts"] = "自动拾取节日礼物",
                ["AutoClonePlants"] = "自动克隆植物",
            }, this, "zh-CN");
        }

        #endregion LanguageFile
    }
}

// --- End of file: AutoPickup.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/OnlinePlus.cs ---
// --- Original Local Path: OnlinePlus.cs ---

﻿using System.Collections.Generic;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("OnlinePlus", "Sempai#3239", "1.0.1")]
    [Description("OnlinePlus")]
    class OnlinePlus : RustPlugin
    {
        #region Variables
        private const string Permfromuse = "perm.fromuse";
        private const string DeniedEffectPrefab = "assets/prefabs/locks/keypad/effects/lock.code.denied.prefab";
        private string Moderperm = "perm.moder";
        #endregion

        #region Hooks
        private void Init()
        {
            permission.RegisterPermission(Permfromuse, this);
            permission.RegisterPermission(Moderperm, this);
        }
        
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["noPerm"] = "You don't have access to this command.",
                ["players"] = "Players list: ({0}): \n{1}",
                ["PlayerAlone"] = "You are alone on server! Your name: {0}, SteamID {1}",
                ["onlineInfo"] = "Online: {0} player, {1} moderators, {2} admins.",
            }, this);
            
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["noPerm"] = "Недостаточно прав.",
                ["PlayerAlone"] = "Вы одни на сервере! Ваш ник: {0}, SteamID {1}",
                ["players"] = "Список Игроков ({0}):\n{1}",
                ["onlineInfo"] = "Сейчас на сервере {0} игроков, {1} модераторов, {2} администраторов.",
            }, this, "ru");
        }

        #endregion

        #region Commands
        
        [ChatCommand("online")]
        void Chat_Online(BasePlayer player)
        {
            int admins = BasePlayer.activePlayerList.Count(p => p.IsAdmin);
            int playerAmount = BasePlayer.activePlayerList.Count;
            int moderationAmount = BasePlayer.activePlayerList.Count(p => HasPermission(p, Moderperm) && p.IsAdmin == false);
            
            if (HasPermission(player, Permfromuse) == false)
            {
                InChat(player, "noPerm");
                Effect.server.Run(DeniedEffectPrefab, player.GetNetworkPosition());
                return;
            }
            
            InChat(player, "onlineInfo", playerAmount, moderationAmount, admins);
        }
        
        [ChatCommand("players")]
        void Chat_Players(BasePlayer player)
        {
            if (HasPermission(player, Permfromuse) == false)
            {
                InChat(player, "noPerm");
                Effect.server.Run(DeniedEffectPrefab, player.GetNetworkPosition());
                return;
            }
            
            int playersAmount = BasePlayer.activePlayerList.Count;
            if (playersAmount == 1)
            {
                InChat(player, "PlayerAlone", player.displayName, player.UserIDString);
                return;
            }

            string formattedList = "";
            
            for (var i = BasePlayer.activePlayerList.Count - 1; i >= 0 ; i--)
            {
                var playerTarget = BasePlayer.activePlayerList[i];
                if(playerTarget == null || playerTarget.IsConnected == false)
                    continue;
                
                formattedList += $"{playerTarget.displayName} ({playerTarget.UserIDString})\n";
            }
            
            InChat(player, "players", playersAmount, formattedList);
        }

        #endregion

        #region Utils

        private bool HasPermission(BasePlayer player, string perm) => permission.UserHasPermission(player.UserIDString, perm) || player.IsAdmin;

        private string GetLocal(string messageKey, string userId) => lang.GetMessage(messageKey, this, userId);
        
        private void InChat(BasePlayer player, string msgId, params object[] args)
        {
            PrintToChat(player, string.Format(GetLocal(msgId, player.UserIDString), args));
        }

        #endregion
    }
}

// --- End of file: OnlinePlus.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/EventManager.cs ---
// --- Original Local Path: EventManager.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Rust;

namespace Oxide.Plugins
{
    [Info("Event Manager", "Reneb / k1lly0u", "2.0.24", ResourceId = 740)]
    class EventManager : RustPlugin
    {
        #region Fields
        [PluginReference]
        Plugin Spawns;

        [PluginReference]
        Plugin Kits;

        [PluginReference]
        Plugin ZoneManager;

        [PluginReference]
        Plugin ServerRewards;

        [PluginReference]
        Plugin Economics;

        private string EventSpawnFile;
        private string EventGameName;
        private string ZoneName;
        private string TokenType;

        private bool EventOpen;
        private bool EventStarted;
        private bool EventEnded;
        private bool EventPending;
        private int EventMaxPlayers = 0;
        private int EventMinPlayers = 0;
        private int EventAutoNum = -1;

        public int PlayTimer;

        public float LastAnnounce;
        public bool AutoEventLaunched = false;
        public bool UseClassSelection;
        public GameMode EventMode;

        private List<string> EventGames;
        private List<EventPlayer> EventPlayers;
        public List<ulong> Godmode;
        public List<Timer> AutoArenaTimers;

        private Dictionary<ulong, Timer> KillTimers;

        private ConfigData configData;

        ClassData classData;
        private DynamicConfigFile Class_Data;

        static bool Debug = false;
        #endregion

        #region Classes        
        class EventPlayer : MonoBehaviour
        {
            public BasePlayer player;

            public float health;
            public float calories;
            public float hydration;

            public bool inEvent;
            public bool savedInventory;
            public bool savedHome;
            public bool OOB;

            public string currentClass;

            public List<EventInvItem> InvItems = new List<EventInvItem>();
            public Vector3 Home;

            void Awake()
            {                
                inEvent = true;
                savedInventory = false;
                savedHome = false;
                player = GetComponent<BasePlayer>();
                ELog($"{player.displayName} component init");
            }
            public void SaveHealth()
            {
                ELog($"{player.displayName} saving health");
                health = player.health;
                calories = player.metabolism.calories.value;
                hydration = player.metabolism.hydration.value;
            }
            public void SaveHome()
            {
                ELog($"{player.displayName} saving home");
                if (!savedHome)
                    Home = player.transform.position;
                savedHome = true;
            }
            public void TeleportHome()
            {
                ELog($"{player.displayName} TP home");
                if (!savedHome)
                    return;
                TPPlayer(player, Home);
                savedHome = false;
            }
            public void SaveInventory()
            {
                ELog($"{player.displayName} saving inv");
                if (savedInventory)
                    return;
                InvItems.Clear();
                InvItems.AddRange(GetItems(player.inventory.containerWear, "wear"));
                InvItems.AddRange(GetItems(player.inventory.containerMain, "main"));
                InvItems.AddRange(GetItems(player.inventory.containerBelt, "belt"));
                ELog($"{player.displayName} inventory count: {InvItems.Count}");
                savedInventory = true;
            }
            private IEnumerable<EventInvItem> GetItems(ItemContainer container, string containerName)
            {
                return container.itemList.Select(item => new EventInvItem
                {
                    itemid = item.info.itemid,
                    container = containerName,
                    amount = item.amount,
                    ammo = (item.GetHeldEntity() as BaseProjectile)?.primaryMagazine.contents ?? 0,
                    skin = item.skin,
                    condition = item.condition,
                    contents = item.contents?.itemList.Select(item1 => new EventInvItem
                    {
                        itemid = item1.info.itemid,
                        amount = item1.amount,
                        condition = item1.condition
                    }).ToArray()
                });
            }
            public void RestoreInventory()
            {
                ELog($"{player.displayName} restoring inventory, saved count: {InvItems.Count}");
                player.inventory.Strip();
                foreach (var kitem in InvItems)
                {
                    var item = ItemManager.CreateByItemID(kitem.itemid, kitem.amount, kitem.skin);
                    item.condition = kitem.condition;
                    var weapon = item.GetHeldEntity() as BaseProjectile;
                    if (weapon != null) weapon.primaryMagazine.contents = kitem.ammo;
                    player.inventory.GiveItem(item, kitem.container == "belt" ? player.inventory.containerBelt : kitem.container == "wear" ? player.inventory.containerWear : player.inventory.containerMain);
                    if (kitem.contents == null) continue;
                    foreach (var ckitem in kitem.contents)
                    {
                        var item1 = ItemManager.CreateByItemID(ckitem.itemid, ckitem.amount);
                        if (item1 == null) continue;
                        item1.condition = ckitem.condition;
                        item1.MoveToContainer(item.contents);
                    }
                }
                ELog($"{player.displayName} restored count: {player.inventory.containerBelt.itemList.Count + player.inventory.containerMain.itemList.Count + player.inventory.containerWear.itemList.Count}");
                savedInventory = false;
            }
        }
        class EventInvItem
        {
            public int itemid;
            public bool bp;
            public int skin;
            public string container;
            public int amount;
            public float condition;
            public int ammo;
            public EventInvItem[] contents;
        }
        class ConfigData
        {
            public string Default_Gamemode { get; set; }
            public string Default_Spawnfile { get; set; }
            public int Battlefield_Timer { get; set; }
            public bool KillDeserters { get; set; }
            public int Required_AuthLevel { get; set; }
            public string Messaging_MainColor { get; set; }
            public string Messaging_MsgColor { get; set; }
            public bool Announce_Event { get; set; }
            public bool AnnounceDuring_Event { get; set; }
            public int AnnounceEvent_Interval { get; set; }
            public bool UseEconomicsAsTokens { get; set; }
            public bool UseClassSelector_Default { get; set; }
            public AutoEvents z_AutoEvents { get; set; }
        }
        class AutoEvents
        {
            public int GameInterval { get; set; }
            public bool AutoCancel { get; set; }
            public int AutoCancel_Timer { get; set; }
            public List<AutoEventSetup> z_AutoEventSetup { get; set; }
        }
        class AutoEventSetup
        {
            public bool UseClassSelector { get; set; }
            public string GameType { get; set; }
            public GameMode EventMode { get; set; }
            public string Spawnfile { get; set; }
            public string Kit { get; set; }
            public bool CloseOnStart { get; set; }
            public int TimeToJoin { get; set; }
            public int MinimumPlayers { get; set; }
            public int MaximumPlayers { get; set; }
            public int TimeLimit { get; set; }
            public string ZoneID { get; set; }

        }
        class ClassData
        {
            public Dictionary<string, string> ClassKits = new Dictionary<string, string>();
        }
        public class UI
        {
            static public CuiElementContainer CreateElementContainer(string panelName, string color, string aMin, string aMax, bool useCursor)
            {
                var NewElement = new CuiElementContainer()
                {
                    {
                        new CuiPanel
                        {
                            Image = {Color = color},
                            RectTransform = {AnchorMin = aMin, AnchorMax = aMax},
                            CursorEnabled = useCursor
                        },
                        new CuiElement().Parent = "Overlay",
                        panelName
                    }
                };
                return NewElement;
            }
            static public void CreatePanel(ref CuiElementContainer container, string panel, string color, string aMin, string aMax, bool cursor = false)
            {
                container.Add(new CuiPanel
                {
                    Image = { Color = color },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    CursorEnabled = cursor
                },
                panel);
            }
            static public void CreateLabel(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiLabel
                {
                    Text = { Color = color, FontSize = size, Align = align, Text = text },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax }
                },
                panel);

            }
            static public void CreateButton(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, string command, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiButton
                {
                    Button = { Color = color, Command = command, FadeIn = 1.0f },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    Text = { Text = text, FontSize = size, Align = align }
                },
                panel);
            }
        }
        public enum GameMode
        {
            Normal,
            Battlefield
        }
        #endregion

        #region Oxide Hooks
        void Loaded()
        {
            EventGames = new List<string>();
            EventMode = GameMode.Normal;
            EventPlayers = new List<EventPlayer>();
            AutoArenaTimers = new List<Timer>();
            KillTimers = new Dictionary<ulong, Timer>();
            Class_Data = Interface.Oxide.DataFileSystem.GetFile("EventManager_Classes");

        }
        void OnServerInitialized()
        {
            lang.RegisterMessages(Messages, this);
            LoadVariables();
            LoadData();
            EventOpen = false;
            EventStarted = false;
            EventEnded = true;
            EventPending = false;
            UseClassSelection = configData.UseClassSelector_Default;
            EventGameName = configData.Default_Gamemode;
            timer.Once(0.2f, InitializeGames);
        }
        void InitializeGames()
        {
            //Interface.Oxide.CallHook("RegisterGame");
            SelectSpawnfile(configData.Default_Spawnfile);
        }
        void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList) DestroyUI(player);
            EndEvent();
            DestroyGame();
        }
        void OnPlayerRespawned(BasePlayer player)
        {
            if (!EventStarted) return;
            if (!player.GetComponent<EventPlayer>()) return;
            if (player.GetComponent<EventPlayer>().inEvent)
            {
                if (!EventStarted) return;
                TeleportPlayerToEvent(player);
            }
            else
            {
                RedeemInventory(player);
                TeleportPlayerHome(player);
                TryErasePlayer(player);
            }
        }
        void OnPlayerAttack(BasePlayer player, HitInfo hitinfo)
        {
            if (!EventStarted) return;
            if (player.GetComponent<EventPlayer>() == null || !(player.GetComponent<EventPlayer>().inEvent))
                return;
            if (hitinfo.HitEntity != null)
                Interface.Oxide.CallHook("OnEventPlayerAttack", player, hitinfo);
            return;
        }
        void OnEntityDeath(BaseEntity entity, HitInfo hitinfo)
        {
            if (!EventStarted) return;
            if ((entity as BasePlayer)?.GetComponent<EventPlayer>() == null) return;
            Interface.Oxide.CallHook("OnEventPlayerDeath", ((BasePlayer)entity), hitinfo);
            return;
        }
        void OnPlayerDisconnected(BasePlayer player)
        {
            if (!EventStarted) return;
            if (player.GetComponent<EventPlayer>() != null)
                LeaveEvent(player);
        }
        void OnEntityTakeDamage(BaseEntity entity, HitInfo info)
        {
            if (!EventStarted) return;
            var player = entity as BasePlayer;
            if (Godmode == null || player == null) return;
            if (Godmode.Contains(player.userID))
            {
                info.damageTypes = new DamageTypeList();
                info.HitMaterial = 0;
                info.PointStart = Vector3.zero;
            }
        }
        #endregion

        #region Checks
        bool hasEventStarted()
        {
            return EventStarted;
        }
        bool isPlaying(BasePlayer player)
        {
            EventPlayer eplayer = player.GetComponent<EventPlayer>();
            return eplayer != null && eplayer.inEvent;
        }
        object canRedeemKit(BasePlayer player)
        {
            if (!EventStarted) return null;
            TryErasePlayer(player);
            EventPlayer eplayer = player.GetComponent<EventPlayer>();
            if (eplayer == null) return null;
            return false;
        }
        object canShop(BasePlayer player)
        {
            if (!EventStarted) return null;
            EventPlayer eplayer = player.GetComponent<EventPlayer>();
            if (eplayer == null) return null;
            return GetMessage("CanShop");
        }

        object CanTeleport(BasePlayer player)
        {
            if (!EventStarted) return null;
            EventPlayer eplayer = player.GetComponent<EventPlayer>();
            if (eplayer == null) return null;
            return GetMessage("CanTP");
        }
        #endregion

        #region Config
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        private void LoadConfigVariables()
        {
            configData = Config.ReadObject<ConfigData>();
        }
        protected override void LoadDefaultConfig()
        {
            Puts("Creating a new config file");
            var config = new ConfigData
            {
                AnnounceDuring_Event = true,
                AnnounceEvent_Interval = 120,
                Announce_Event = true,
                Battlefield_Timer = 1200,
                Default_Gamemode = "Deathmatch",
                Default_Spawnfile = "deathmatchspawns",
                KillDeserters = true,
                Required_AuthLevel = 1,
                Messaging_MainColor = "#FF8C00",
                Messaging_MsgColor = "#939393",
                UseEconomicsAsTokens = false,
                UseClassSelector_Default = true,
                z_AutoEvents = new AutoEvents
                {
                    AutoCancel = true,
                    AutoCancel_Timer = 300,
                    GameInterval = 1200,
                    z_AutoEventSetup = CreateDefaultAutoConfig()
                }
            };
            SaveConfig(config);
        }
        void SaveConfig(ConfigData config)
        {
            Config.WriteObject(config, true);
        }
        static List<AutoEventSetup> CreateDefaultAutoConfig()
        {
            var newautoconfiglist = new List<AutoEventSetup>
            {
                new AutoEventSetup
                {
                    GameType = "Deathmatch",
                    EventMode = GameMode.Battlefield,
                    Spawnfile = "deathmatchspawns",
                    Kit = "",
                    CloseOnStart = true,
                    TimeToJoin = 60,
                    TimeLimit = 1800,
                    MinimumPlayers = 2,
                    MaximumPlayers = 20,
                    UseClassSelector = false,
                    ZoneID = null
                },
                new AutoEventSetup
                {
                    GameType = "TeamDeathmatch",
                    EventMode = GameMode.Normal,
                    Spawnfile = "tdm_spawns_a",
                    Kit = "tdmkit",
                    CloseOnStart = false,
                    TimeToJoin = 60,
                    TimeLimit = 0,
                    MinimumPlayers = 2,
                    MaximumPlayers = 20,
                    UseClassSelector = false,
                    ZoneID = null
                },
                new AutoEventSetup
                {
                    GameType = "GunGame",
                    EventMode = GameMode.Battlefield,
                    Spawnfile = "ggspawns",
                    Kit = "ggkit",
                    CloseOnStart = false,
                    TimeToJoin = 60,
                    TimeLimit = 0,
                    MinimumPlayers = 2,
                    MaximumPlayers = 20,
                    UseClassSelector = false,
                    ZoneID = null
                },
                new AutoEventSetup
                {
                    GameType = "ChopperSurvival",
                    EventMode = GameMode.Normal,
                    Spawnfile = "csspawns",
                    Kit = "cskit",
                    CloseOnStart = true,
                    TimeToJoin = 60,
                    TimeLimit = 0,
                    MinimumPlayers = 1,
                    MaximumPlayers = 20,
                    UseClassSelector = false,
                    ZoneID = null
                }
            };
            return newautoconfiglist;
        }
        #endregion

        #region Messaging
        private void MSG(BasePlayer player, string langkey, bool title = true)
        {
            string message = $"<color={configData.Messaging_MsgColor}>{GetMessage(langkey)}</color>";
            if (title) message = $"<color={configData.Messaging_MainColor}>{GetMessage("Title")}</color>" + message;
            SendReply(player, message);
        }
        void BroadcastToChat(string msg)
        {
            ELog(msg);
            PrintToChat($"<color={configData.Messaging_MainColor}>{GetMessage("Title")}</color><color={configData.Messaging_MsgColor}>{GetMessage(msg)}</color>");
        }
        private string GetMessage(string key) => lang.GetMessage(key, this);

        [HookMethod("BroadcastEvent")]
        public void BroadcastEvent(string msg)
        {
            foreach (EventPlayer eventplayer in EventPlayers)
                SendReply(eventplayer.player, $"<color={configData.Messaging_MainColor}>" + msg + "</color>");
        }

        Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            { "multipleNames", "Multiple players found"},
            { "noPlayerFound", "No players found"},
            { "MessagesEventMinPlayers", "The Event {0} has reached min players and will start in {1} seconds"},
            { "MessagesEventMaxPlayers", "The Event {0} has reached max players. You may not join for the moment"},
            { "MessagesEventStatusClosedStarted", "The Event {0} has already started, it's too late to join."},
            { "Title", "Event Manager: "},
            { "MessagesEventStatusClosedEnd", "There is currently no event"},
            { "MessagesEventStatusOpenStarted", "The Event {0} has started, but is still opened: /event join"},
            { "MessagesEventStatusOpen", "The Event {0} is currently opened for entries: /event, join"},
            { "MessagesEventCloseAndEnd", "The Event needs to be closed and ended before using this command."},
            { "MessagesEventNotAnEvent", "This Game {0} isn't registered, did you reload the game after loading Event - Core?"},
            { "MessagesEventNotInEvent", "You are not currently in the Event."},
            { "MessagesEventBegin", "Event: {0} is about to begin!"},
            { "MessagesEventLeft", "{0} has left the Event! (Total Players: {1})"},
            { "MessagesEventJoined", "{0} has joined the Event!  (Total Players: {1})"},
            { "MessagesEventAlreadyJoined", "You are already in the Event."},
            { "MessagesEventPEnd", "Event: {0} is now over, restoring players and sending them home!"},
            { "MessagesEventEnd", "All players respawned, {0} has ended!"},
            { "MessagesEventNoGamePlaying", "An Event game is not underway."},
            { "MessagesEventCancel", "The Event was cancelled!"},
            { "MessagesEventClose", "The Event entrance is now closed!"},
            { "MessagesEventOpen", "The Event is now open for : {0} !  Type /event join to join!"},
            { "MessagesPermissionsNotAllowed", "You are not allowed to use this command"},
            { "MessagesEventNotSet", "An Event game must first be chosen."},
            { "MessagesErrorSpawnfileIsNull", "The spawnfile can't be set to null"},
            { "MessagesEventNoSpawnFile", "A spawn file must first be loaded."},
            { "MessagesEventAlreadyOpened", "The Event is already open."},
            { "MessagesEventAlreadyClosed", "The Event is already closed."},
            { "MessagesEventAlreadyStarted", "An Event game has already started."},
            { "ClassSelect", "Choose your class!" },
            { "ClassNotice", "You can reopen this menu at any time by typing /event class" },
            { "CanShop", "You are not allowed to shop while in an Event" },
            { "CanTP", "You are not allowed to teleport while in an Event" },
            { "NoPlayers", "Not enough players" },
            { "NoAuto", "No Automatic Events Configured" },
            { "NoAutoInit", "No Events were successfully initialized, check that your events are correctly configured" },
            { "TimeLimit", "Time limit reached" },
            { "EventCancelled", "Event {0} was cancelled because: {1}" },
            { "EventOpen", "Event {0} in now opened, you can join it by typing /event join" },
            { "StillOpen", "Event {0} is still open, you can join it by typing /event join" },
            { "EventClosed", "The Event is currently closed." },
            { "NotInEvent", "You are not currently in the Event." },
            { "NullKitname", "You can't have a null kitname" },
            { "NoKits", "Unable to find the Kits plugin" },
            { "KitNotExist", "The kit {0} doesn't exist" },
            { "CancelAuto", "Auto events have been cancelled" }
        };
        #endregion

        #region Class Selection
        private void SelectClass(BasePlayer player)
        {
            string panelName = "ClassSelector";
            CuiHelper.DestroyUi(player, panelName);
            if (player.IsSleeping() || player.IsReceivingSnapshot() || player.IsDead())
            {                
                timer.Once(3, () => SelectClass(player));
                return;
            }            

            var Class_Element = UI.CreateElementContainer(panelName, "0.1 0.1 0.1 0.98", "0.05 0.05", "0.95 0.95", true);

            UI.CreatePanel(ref Class_Element, panelName, "0.9 0.9 0.9 0.1", "0.04 0.05", "0.96 0.94");
            UI.CreateLabel(ref Class_Element, panelName, "0.9 0.9 0.9 1.0", $"<color={configData.Messaging_MainColor}>{EventGameName}</color>", 24, "0.05 0.85", "0.95 0.92");
            UI.CreateLabel(ref Class_Element, panelName, "0.9 0.9 0.9 1.0", $"<color={configData.Messaging_MainColor}>{GetMessage("ClassSelect")}</color>", 24, "0.05 0.75", "0.95 0.83");
            UI.CreateLabel(ref Class_Element, panelName, "0.9 0.9 0.9 1.0", $"<color={configData.Messaging_MainColor}>{GetMessage("ClassNotice")}</color>", 18, "0.05 0.05", "0.95 0.12");

            int i = 0;
            foreach (var entry in classData.ClassKits)
            {
                CreateClassButton(ref Class_Element, panelName, entry.Key, entry.Value, i);
                i++;
            }

            CuiHelper.AddUi(player, Class_Element);
        }
        private void CreateClassButton(ref CuiElementContainer container, string panelName, string name, string kit, int number)
        {
            Vector2 dimensions = new Vector2(0.25f, 0.07f);
            Vector2 origin = new Vector2(0.095f, 0.6f);
            float offsetY = 0;
            float offsetX = 0;
            switch (number)
            {
                case 0:
                case 1:
                case 2:
                    offsetX = (0.03f + dimensions.x) * number;
                    break;
                case 3:
                case 4:
                case 5:
                    {
                        offsetX = (0.03f + dimensions.x) * (number - 3);
                        offsetY = (0.07f + dimensions.y) * 1;
                    }
                    break;
                case 6:
                case 7:
                case 8:
                    {
                        offsetX = (0.03f + dimensions.x) * (number - 6);
                        offsetY = (0.07f + dimensions.y) * 2;
                    }
                    break;
            }
            Vector2 offset = new Vector2(offsetX, -offsetY);

            Vector2 posMin = origin + offset;
            Vector2 posMax = posMin + dimensions;

            UI.CreateButton(ref container, panelName, "0.2 0.2 0.2 0.7", name, 18, posMin.x + " " + posMin.y, posMax.x + " " + posMax.y, $"Choose_Class {kit}");
        }

        [ConsoleCommand("Choose_Class")]
        void cmdChoose_Class(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return;
            CuiHelper.DestroyUi(player, "ClassSelector");
            var className = arg.GetString(0).Replace("'", "");
            bool noGear = false;
            if (string.IsNullOrEmpty(player.GetComponent<EventPlayer>().currentClass)) noGear = true;
            player.GetComponent<EventPlayer>().currentClass = className;
            if (noGear) GivePlayerKit(player, null);
        }
        #endregion

        #region Game Timer UI
        private void StartTimer(int time)
        {
            AutoArenaTimers.Add(timer.Once(time, () => CancelEvent(GetMessage("TimeLimit"))));
            PlayTimer = time;
            foreach (var player in EventPlayers)
                TimerCountdown(player.player);
        }
        private void TimerCountdown(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "PlayTimer");
            if (EventStarted)
            {
                var timerElement = UI.CreateElementContainer("PlayTimer", "0.3 0.3 0.3 0.6", "0.45 0.91", "0.55 0.948", false);
                TimeSpan dateDifference = TimeSpan.FromSeconds(PlayTimer);
                string clock = string.Format("{0:D2}:{1:D2}", dateDifference.Minutes, dateDifference.Seconds);
                UI.CreateLabel(ref timerElement, "PlayTimer", "", clock, 20, "0 0", "1 1");
                CuiHelper.AddUi(player, timerElement);
                PlayTimer--;
                AutoArenaTimers.Add(timer.In(1, () => TimerCountdown(player)));
            }
        }
        private void DestroyUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "ClassSelector");
            CuiHelper.DestroyUi(player, "PlayTimer");
        }
        #endregion

        #region Global Functions
        bool hasAccess(ConsoleSystem.Arg arg)
        {
            if (arg.connection?.authLevel < 1)
            {
                SendReply(arg, GetMessage("MessagesPermissionsNotAllowed"));
                return false;
            }
            return true;
        }
        static void TPPlayer(BasePlayer player, Vector3 destination)
        {        
            if (player.net?.connection != null)
                player.ClientRPCPlayer(null, player, "StartLoading", null, null, null, null, null);
            ELog($"Teleporting {player.displayName} to {destination}");
            StartSleeping(player);
            player.MovePosition(destination);
            if (player.net?.connection != null)
                player.ClientRPCPlayer(null, player, "ForcePositionTo", destination);
            player.TransformChanged();
            if (player.net?.connection != null)
                player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, true);
            player.UpdateNetworkGroup();
            player.SendNetworkUpdateImmediate(false);
            if (player.net?.connection == null) return;
            try { player.ClearEntityQueue(null); } catch { }
            player.SendFullSnapshot();
        }
        static void StartSleeping(BasePlayer player)
        {
            if (player.IsSleeping())
                return;
            ELog($"Put {player.displayName} to sleep");
            player.SetPlayerFlag(BasePlayer.PlayerFlags.Sleeping, true);
            if (!BasePlayer.sleepingPlayerList.Contains(player))
                BasePlayer.sleepingPlayerList.Add(player);
            player.CancelInvoke("InventoryUpdate");
        }
        #endregion

        #region Player Management
        [HookMethod("TeleportAllPlayersToEvent")]
        public void TeleportAllPlayersToEvent()
        {
            ELog("TeleportAllPlayersToEvent");
            foreach (EventPlayer eventplayer in EventPlayers.ToArray())
                TeleportPlayerToEvent(eventplayer.player);
        }

        void TeleportPlayerToEvent(BasePlayer player)
        {
            var eventPlayer = player.GetComponent<EventPlayer>();
            if (eventPlayer == null || player.net?.connection == null) return;
            ELog($"Tp2Event {player.displayName}");
            var targetpos = Spawns.Call("GetRandomSpawn", EventSpawnFile);
            if (targetpos is string)
                return;
            var newpos = Interface.Oxide.CallHook("EventChooseSpawn", player, targetpos);
            if (newpos is Vector3)
                targetpos = newpos;
            if (newpos is bool)
                if ((bool)newpos == false)
                {
                    ELog($"Tp2Event {player.displayName} newpos is false");
                    timer.Once(3, () => TeleportPlayerToEvent(player));
                        return;
                }
            if (!configData.KillDeserters)
                ZoneManager?.Call("AddPlayerToZoneKeepinlist", ZoneName, player);

           
            TPPlayer(player, (Vector3)targetpos);

            Interface.Oxide.CallHook("OnEventPlayerSpawn", player);
        }
        void SaveAllInventories()
        {
            ELog($"SaveAllInventories");
            foreach (EventPlayer player in EventPlayers)
                player?.SaveInventory();
        }
        void SaveAllPlayerStats()
        {
            ELog($"SaveAllStats");
            foreach (EventPlayer player in EventPlayers)
                player?.SaveHealth();
        }
        void SaveAllHomeLocations()
        {
            ELog($"SaveAllHomes");
            foreach (EventPlayer player in EventPlayers)
                player?.SaveHome();
        }
        void SetAllEventPlayers()
        {
            ELog($"SetAllPlayers");
            foreach (EventPlayer player in EventPlayers)
                SetEventPlayer(player);
        }      
        void RedeemInventory(BasePlayer player)
        {            
            EventPlayer eventplayer = player.GetComponent<EventPlayer>();
            if (eventplayer == null) return;
            ELog($"Redeem Inventory {player.displayName}");
            if (player.IsDead() || player.health < 1)
            {
                ELog($"RI {player.displayName} is dead");
                timer.Once(5, () => RedeemInventory(player));
                return;
            }
            eventplayer.player.inventory.Strip();
            if (eventplayer.savedInventory)
                eventplayer.RestoreInventory();
        }
        void TeleportPlayerHome(BasePlayer player)
        {            
            EventPlayer eventplayer = player.GetComponent<EventPlayer>();
            if (eventplayer == null) return;
            ELog($"TPPlayerHome {player.displayName}");
            if (player.IsDead() || player.health < 1)
            {
                ELog($"TPPH {player.displayName} is dead");
                return;
            }
            if (eventplayer.savedHome)
                eventplayer.TeleportHome();
        }
        void TryErasePlayer(BasePlayer player)
        {            
            var eventplayer = player.GetComponent<EventPlayer>();
            if (eventplayer == null) return;
            ELog($"TryErase {player.displayName}");
            if (!(eventplayer.inEvent) && !(eventplayer.savedHome) && !(eventplayer.savedInventory))
            {
                ELog($"{player.displayName} !inevent/savedhome/savedinventory");
                eventplayer.enabled = false;
                EventPlayers.Remove(eventplayer);
                UnityEngine.Object.Destroy(eventplayer);
            }
        }
        [HookMethod("GivePlayerKit")]
        public void GivePlayerKit(BasePlayer player, string GiveKit)
        {
            ELog($"give {player.displayName} kit");
            player.inventory.Strip();
            if (!AutoEventLaunched)
            {                
                if (!UseClassSelection)
                    Kits.Call("GiveKit", player, GiveKit);
                else
                {
                    if (string.IsNullOrEmpty(player.GetComponent<EventPlayer>().currentClass))
                        SelectClass(player);
                    else GiveClassKit(player);
                }
            }
            else
            {
                if (!configData.z_AutoEvents.z_AutoEventSetup[EventAutoNum].UseClassSelector)
                    Kits.Call("GiveKit", player, configData.z_AutoEvents.z_AutoEventSetup[EventAutoNum].Kit);
                else
                {
                    if (string.IsNullOrEmpty(player.GetComponent<EventPlayer>().currentClass))
                        SelectClass(player);
                    else GiveClassKit(player);
                }
            }
        }
        private void GiveClassKit(BasePlayer player)
        {
            ELog($"Give class kit {player.displayName}");
            Kits.Call("GiveKit", player, player.GetComponent<EventPlayer>().currentClass);
            Interface.Oxide.CallHook("OnPlayerSelectClass", player);
        }
        void EjectPlayer(BasePlayer player)
        {
            ELog($"Ejecting {player.displayName}");
            if (player.IsAlive())
            {
                ELog($"Eject Alive {player.displayName}");
                player.SetPlayerFlag(BasePlayer.PlayerFlags.Wounded, false);
                player.CancelInvoke("WoundingEnd");
                player.metabolism.bleeding.value = 0f;
            }
            if (!configData.KillDeserters)
                if (!string.IsNullOrEmpty(ZoneName))
                    ZoneManager?.Call("RemovePlayerFromZoneKeepinlist", ZoneName, player);

            player.GetComponent<EventPlayer>().inEvent = false;
            Interface.Oxide.CallHook("DisableBypass", player.userID);
        }    
        void RestorePlayerHealth(BasePlayer player)
        {
            ELog($"Restoring health {player.displayName}");
            EventPlayer eventplayer = player.GetComponent<EventPlayer>();
            if (eventplayer)
            {
                ELog($"RH {player.displayName} is event player");
                player.health = eventplayer.health;
                player.metabolism.calories.value = eventplayer.calories;
                player.metabolism.hydration.value = eventplayer.hydration;
                player.metabolism.bleeding.value = 0;
                player.metabolism.SendChangesToClient();
            }
        }
        #endregion

        #region Event Management
        [HookMethod("OpenEvent")]
        public object OpenEvent()
        {
            if (EventOpen)
                return $"{EventGameName} is already open";
            ELog($"Opening Event {EventGameName}");

            var success = Interface.Oxide.CallHook("CanEventOpen");
            if (success is string)
                return (string)success;
            
            EventOpen = true;
            EventPlayers = new List<EventPlayer>();

            var name = EventGameName;
            if (EventMode == GameMode.Battlefield)
                name = "Battlefield - ";
            BroadcastToChat(string.Format(GetMessage("MessagesEventOpen"), name));
            Interface.Oxide.CallHook("OnEventOpenPost");
                     
            ELog($"Game type: {EventMode}");
            ELog($"AutoEvent: {AutoEventLaunched}");
            ELog($"{EventGameName} Successfully opened");

            return true;
        }
        void OnEventOpenPost() => OnEventOpenPostAutoEvent();
        void OnEventOpenPostAutoEvent()
        {
            if (!AutoEventLaunched) return;
            ELog($"Start auto event timers");
            DestroyTimers();
            var autocfg = configData.z_AutoEvents;
            if (autocfg.AutoCancel_Timer != 0)
                AutoArenaTimers.Add(timer.Once(autocfg.AutoCancel_Timer, () => CancelEvent(GetMessage("NoPlayers"))));
            AutoArenaTimers.Add(timer.Repeat(configData.AnnounceEvent_Interval, 0, AnnounceEvent));
        }
        object CanEventOpen()
        {
            if (EventGameName == null) return GetMessage("MessagesEventNotSet");
            else if (EventSpawnFile == null) return GetMessage("MessagesEventNoSpawnFile");
            else if (EventOpen) return GetMessage("MessagesEventAlreadyOpened");

            object success = Spawns.Call("GetSpawnsCount", EventSpawnFile);
            if (success is string)
                return (string)success;
            return null;
        }

        [HookMethod("CloseEvent")]
        public object CloseEvent()
        {
            if (!EventOpen) return GetMessage("MessagesEventAlreadyClosed");
            EventOpen = false;
            Interface.Oxide.CallHook("OnEventClosePost");
            if (EventStarted)
                BroadcastToChat(GetMessage("MessagesEventClose"));
            else
                BroadcastToChat(GetMessage("MessagesEventCancel"));
            return true;
        }
        object AutoEventNext()
        {
            ELog($"Next auto event");
            if (configData.z_AutoEvents.z_AutoEventSetup.Count == 0)
            {
                ELog($"No events setup");
                AutoEventLaunched = false;
                return GetMessage("NoAuto");
            }
            bool successful = false;
            for (int i = 0; i < configData.z_AutoEvents.z_AutoEventSetup.Count; i++)
            {
                EventAutoNum++;
                if (EventAutoNum >= configData.z_AutoEvents.z_AutoEventSetup.Count) EventAutoNum = 0;

                var autocfg = configData.z_AutoEvents.z_AutoEventSetup[EventAutoNum];

                object success = SelectEvent(autocfg.GameType);
                if (success is string) { continue; }

                success = SelectSpawnfile(autocfg.Spawnfile);
                if (success is string) { continue; }

                success = SelectMinplayers(autocfg.MinimumPlayers);
                if (success is string) { continue; }

                success = SelectMaxplayers(autocfg.MaximumPlayers);
                if (success is string) { continue; }

                success = Interface.Oxide.CallHook("CanEventOpen");
                if (success is string) { continue; }

                if (!string.IsNullOrEmpty(autocfg.ZoneID))
                    ZoneName = autocfg.ZoneID;

                successful = true;
                break;
            }
            if (!successful)
            {
                ELog($"No events init");
                return GetMessage("NoAutoInit");
            }
            ELog($"Auto init success");
            AutoArenaTimers.Add(timer.Once(configData.z_AutoEvents.GameInterval, () => OpenEvent()));
            return null;
        }
        void OnEventStartPost()
        {
            ELog($"Event starting");
            DestroyTimers();
            if (AutoEventLaunched)
                OnEventStartPostAutoEvent();
            else if (EventMode == GameMode.Battlefield)
                StartTimer(configData.Battlefield_Timer);
            if (configData.AnnounceDuring_Event)
                AutoArenaTimers.Add(timer.Repeat(configData.AnnounceEvent_Interval, 0, () => AnnounceDuringEvent()));
        }
        void OnEventStartPostAutoEvent()
        {           
            if (configData.z_AutoEvents.z_AutoEventSetup[EventAutoNum].TimeLimit != 0)
                StartTimer(configData.z_AutoEvents.z_AutoEventSetup[EventAutoNum].TimeLimit);
        }
        void DestroyTimers()
        {
            ELog($"Destroying timers");
            foreach (Timer eventtimer in AutoArenaTimers)
                eventtimer.Destroy();
            AutoArenaTimers.Clear();
        }
        void CancelEvent(string reason)
        {
            ELog($"Cancelling event");
            var message = GetMessage("EventCancelled");
            object success = Interface.Oxide.CallHook("OnEventCancel");
            if (success != null)
            {
                if (success is string)
                    message = (string)success;
                else
                    return;
            }
            BroadcastToChat(string.Format(message, EventGameName, reason));
            DestroyTimers();
            if (EventStarted)
                EndEvent();
            else if (AutoEventLaunched)
                AutoEventNext();
        }
        void AnnounceEvent()
        {
            var message = GetMessage("EventOpen");
            object success = Interface.Oxide.CallHook("OnEventAnnounce");
            if (success is string)
            {
                message = (string)success;
            }
            BroadcastToChat(string.Format(message, EventGameName));
        }
        void AnnounceDuringEvent()
        {
            if (configData.AnnounceDuring_Event)
            {
                if (EventOpen && EventStarted)
                {
                    var message = GetMessage("StillOpen");
                    foreach (BasePlayer player in BasePlayer.activePlayerList)
                    {
                        if (!player.GetComponent<EventPlayer>())
                            SendReply(player, string.Format(message, EventGameName));
                    }
                }
            }
        }
        object LaunchEvent()
        {
            ELog($"Launching auto events");
            AutoEventLaunched = true;
            if (!EventStarted)
            {
                if (!EventOpen)
                {
                    object success = AutoEventNext();
                    if (success is string)                    
                        return (string)success;
                    
                    success = OpenEvent();
                    if (success is string)                    
                        return (string)success;                    
                }
                else OnEventOpenPostAutoEvent();
            }
            else OnEventStartPostAutoEvent();
            ELog($"Launch successful");
            return null;
        }

        [HookMethod("EndEvent")]
        public object EndEvent()
        {
            if (EventEnded) return GetMessage("MessagesEventNoGamePlaying");
            ELog($"Ending event");
            foreach (var player in EventPlayers)
                Interface.Oxide.CallHook("DestroyUI", player.player);

            BroadcastToChat(string.Format(GetMessage("MessagesEventPEnd"), EventGameName));
            EventOpen = false;
            EventStarted = false;
            EventPending = false;
            EventEnded = true;
            EnableGod();
            BroadcastToChat(string.Format(GetMessage("MessagesEventEnd"), EventGameName));
            Interface.Oxide.CallHook("OnEventEndPre");
            ProcessPlayers();
            return true;
        }       
        void ProcessPlayers()
        {
            ELog($"Processing players");
            for (int i = 0; i < EventPlayers.Count; i++)
                RestorePlayer(EventPlayers[i]);

            timer.Once(5, () =>
            {
                if (EventPlayers.Count > 0)
                {
                    ELog($"EventPlayers.Count > 0, count is {EventPlayers.Count}");
                    ProcessPlayers();
                    return;
                }
                ELog($"EventPlayers.Count is 0");
                DestroyGame();
                Interface.Oxide.CallHook("OnEventEndPost");
            });

            
        }
        void RestorePlayer(EventPlayer p)
        {            
            if (p == null) return;
            ELog($"Restoring {p.player.displayName}");
            if (p.player.IsDead() || !p.player.IsAlive())
            {
                ELog($"RP {p.player.displayName} is dead");
                var pos = Spawns.Call("GetRandomSpawn", EventSpawnFile);
                if (pos is Vector3) p.player.RespawnAt((Vector3)pos, new Quaternion());
                else p.player.Respawn();
                return;
            }
            if (p.player.IsWounded() || p.player.health < 2)
            {
                ELog($"RP {p.player.displayName} is wounded");
                p.player.SetPlayerFlag(BasePlayer.PlayerFlags.Wounded, false);
                RestorePlayerHealth(p.player);
                return;
            }
            if (p.player.IsSleeping())
            {
                ELog($"RP {p.player.displayName} is sleeping");
                p.player.EndSleeping();
                return;
            }
            ELog($"Starting restoration of {p.player.displayName}");
            p.RestoreInventory();
            p.TeleportHome();
            RestorePlayerHealth(p.player);
            Godmode.Remove(p.player.userID);
            if (!p.savedHome && !p.savedInventory)
            {
                ELog($"{p.player.displayName} has no saved home or inv, try erase");
                EjectPlayer(p.player);
                TryErasePlayer(p.player);
            }            
        }
        
        void EnableGod()
        {
            Godmode = new List<ulong>();
            foreach (EventPlayer player in EventPlayers)
            {
                ELog($"Godmode added {player.player.displayName}");
                Godmode.Add(player.player.userID);
                player.player.metabolism.bleeding.value = 0;
                player.player.metabolism.SendChangesToClient();
            }
        }
        void DisableGod()
        {      
            Godmode.Clear();
        }
        void DestroyGame()
        {
            ELog($"Destroying game");
            DestroyTimers();
            EventPlayers.Clear();
            ZoneName = "";
            var objects = UnityEngine.Object.FindObjectsOfType<EventPlayer>();
            if (objects != null)
                foreach (var gameObj in objects)
                    UnityEngine.Object.Destroy(gameObj);
            ELog($"{objects.Count()} eventplayer components left over");
        }
        object CanEventStart()
        {
            if (EventGameName == null) return GetMessage("MessagesEventNotSet");
            if (EventSpawnFile == null) return GetMessage("MessagesEventNoSpawnFile");
            return EventStarted ? GetMessage("MessagesEventAlreadyStarted") : null;
        }

        [HookMethod("StartEvent")]
        public object StartEvent()
        {
            object success = Interface.Oxide.CallHook("CanEventStart");
            if (success is string)
                return (string)success;
            ELog($"StartEvent");
            Interface.Oxide.CallHook("OnEventStartPre");
            if (!AutoEventLaunched)
                ZoneName = (string)Interface.Oxide.CallHook("OnRequestZoneName");
            BroadcastToChat(string.Format(GetMessage("MessagesEventBegin"), EventGameName));
            EventStarted = true;
            EventEnded = false;
            DestroyTimers();
            SaveAllInventories();
            SaveAllHomeLocations();
            SaveAllPlayerStats();
            SetAllEventPlayers();
            TeleportAllPlayersToEvent();
            Interface.Oxide.CallHook("OnEventStartPost");
            ELog($"Event Starting");
            return true;
        }        
       
        void SetEventPlayer(EventPlayer player)
        {
            ELog($"event player setup {player.player.displayName}");
            Interface.Oxide.CallHook("EnableBypass", player.player.userID);
            player.inEvent = true;
            player.enabled = true;
            player.SaveHome();
            player.SaveInventory();
            player.SaveHealth();
        }
        object JoinEvent(BasePlayer player)
        {
            if (player.GetComponent<EventPlayer>())
                if (EventPlayers.Contains(player.GetComponent<EventPlayer>()))
                    return GetMessage("MessagesEventAlreadyJoined");
            ELog($"{player.displayName} is joining the event");
            object success = Interface.Oxide.CallHook("CanEventJoin", player);
            if (success is string)
                return (string)success;
            var eventPlayer = player.GetComponent<EventPlayer>() ?? player.gameObject.AddComponent<EventPlayer>();
            EventPlayers.Add(eventPlayer);
            if (EventStarted)
            {
                ELog($"Event has already started, TPing {player.displayName}");
                if (EventMode == GameMode.Battlefield || (AutoEventLaunched && configData.z_AutoEvents.z_AutoEventSetup[EventAutoNum].TimeLimit != 0))
                    TimerCountdown(player);
                SetEventPlayer(eventPlayer);
                BroadcastToChat(string.Format(GetMessage("MessagesEventJoined"), player.displayName, EventPlayers.Count));
                Interface.Oxide.CallHook("OnEventJoinPost", player);
                TeleportPlayerToEvent(player);
                return true;
            }            

            BroadcastToChat(string.Format(GetMessage("MessagesEventJoined"), player.displayName, EventPlayers.Count));
            Interface.Oxide.CallHook("OnEventJoinPost", player);
            return true;
        }
        object CanEventJoin(BasePlayer player)
        {
            if (!EventOpen)
                return GetMessage("EventClosed");

            if (EventMaxPlayers != 0 && EventPlayers.Count >= EventMaxPlayers)
                return string.Format(GetMessage("MessagesEventMaxPlayers"), EventGameName);
                       
            return null;
        }
        object OnEventJoinPost(BasePlayer player)
        {
            if (!AutoEventLaunched) return null;
            var autocfg = configData.z_AutoEvents.z_AutoEventSetup[EventAutoNum];
            if (EventPlayers.Count >= autocfg.MinimumPlayers && !EventStarted && EventEnded && !EventPending)
            {                
                float timerStart = autocfg.TimeToJoin;
                BroadcastToChat(string.Format(GetMessage("MessagesEventMinPlayers"), EventGameName, timerStart));

                EventPending = true;
                DestroyTimers();
                AutoArenaTimers.Add(timer.Once(timerStart, () => StartEvent()));
            }
            return null;
        }
        void OnEventEndPost()
        {
            if (AutoEventLaunched)
                AutoEventNext();
        }
        [HookMethod("LeaveEvent")]
        public object LeaveEvent(BasePlayer player)
        {
            var eventPlayer = player.GetComponent<EventPlayer>();
            if (eventPlayer == null && !EventPlayers.Contains(eventPlayer))
                return GetMessage("NotInEvent");
            ELog($"{player.displayName} is leaving the event");
            Interface.Oxide.CallHook("OnEventLeavePre");
            Interface.Oxide.CallHook("DisableBypass", player.userID);
            eventPlayer.inEvent = false;

            if (!EventEnded || !EventStarted)
                BroadcastToChat(string.Format(GetMessage("MessagesEventLeft"), player.displayName, (EventPlayers.Count - 1)));

            if (!configData.KillDeserters)
                if (!string.IsNullOrEmpty(ZoneName))
                    ZoneManager?.Call("RemovePlayerFromZoneKeepinlist", ZoneName, player);

            if (EventStarted)
            {
                player.inventory.Strip();
                RedeemInventory(player);
                TeleportPlayerHome(player);
                RestorePlayerHealth(player);
                EjectPlayer(player);
                TryErasePlayer(player);
                Interface.Oxide.CallHook("OnEventLeavePost", player);
            }
            else
            {
                EventPlayers.Remove(eventPlayer);
                UnityEngine.Object.Destroy(eventPlayer);
            }
            return true;
        }
        [HookMethod("SelectEvent")]
        public object SelectEvent(string name)
        {
            if (!(EventGames.Contains(name))) return string.Format(GetMessage("MessagesEventNotAnEvent"), name);
            if (EventStarted || EventOpen) return GetMessage("MessagesEventCloseAndEnd");
            EventGameName = name;
            Interface.Oxide.CallHook("OnSelectEventGamePost", name);
            return true;
        }

        [HookMethod("SelectSpawnfile")]
        public object SelectSpawnfile(string name)
        {
            if (name == null) return GetMessage("MessagesErrorSpawnfileIsNull");

            var eventset = CheckEventSet();
            if (eventset is string)
                return (string)eventset;

            object success = Interface.Oxide.CallHook("OnSelectSpawnFile", name);
            if (success == null)
                return string.Format(GetMessage("MessagesEventNotAnEvent"), EventGameName);            

            EventSpawnFile = name;
            success = Spawns.Call("GetSpawnsCount", EventSpawnFile);

            if (success is string)
            {
                EventSpawnFile = null;
                return (string)success;
            }

            return true;
        }
        object SelectKit(string kitname)
        {
            if (kitname == null) return GetMessage("NullKitname");
            var eventset = CheckEventSet();
            if (eventset is string)
                return (string)eventset;

            object success = Kits.Call("isKit", kitname);
            if (!(success is bool))
                return GetMessage("NoKits");
            if (!(bool)success)
                return string.Format(GetMessage("KitNotExist"), kitname);
            success = Interface.Oxide.CallHook("OnSelectKit", kitname);
            if (success == null)
                return $"{EventGameName} doesn't let you choose a kit";
            return true;
        }       
        object SelectMaxplayers(int num)
        {
            var eventset = CheckEventSet();
            if (eventset is string)
                return (string)eventset;

            Interface.Oxide.CallHook("OnPostSelectMaxPlayers", num);
            return true;
        }
        object SelectMinplayers(int num)
        {
            var eventset = CheckEventSet();
            if (eventset is string)
                return (string)eventset;

            Interface.Oxide.CallHook("OnPostSelectMinPlayers", num);
            return true;
        }
        object SelectNewZone(MonoBehaviour monoplayer, string radius)
        {
            var eventset = CheckEventSet();
            if (eventset is string)
                return (string)eventset;

            if (EventStarted || EventOpen) return GetMessage("MessagesEventCloseAndEnd");
            Interface.Oxide.CallHook("OnSelectEventZone", monoplayer, radius);
            return true;
        }
        private object CheckEventSet()
        {
            if (string.IsNullOrEmpty(EventGameName)) return GetMessage("MessagesEventNotSet");
            if (!(EventGames.Contains(EventGameName))) return string.Format(GetMessage("MessagesEventNotAnEvent"), EventGameName);
            return null;
        }

        [HookMethod("RegisterEventGame")]
        public object RegisterEventGame(string name)
        {
            if (!(EventGames.Contains(name)))
                EventGames.Add(name);
            Puts(string.Format("Registered event game: {0}", name));
            Interface.Oxide.CallHook("OnSelectEventGamePost", EventGameName);

            if (EventGameName == name)
            {
                object success = SelectEvent(EventGameName);
                if (success is string)
                    Puts((string)success);
            }            
            return true;
        }
        void OnExitZone(string zoneId, BasePlayer player)
        {
            if (EventStarted)
                if (player.GetComponent<EventPlayer>())
                    if (zoneId.Equals(ZoneName))
                        if (configData.KillDeserters)
                        {
                            ELog($"{player.displayName} is attempting to leave the zone");
                            player.GetComponent<EventPlayer>().OOB = true;
                            if (!KillTimers.ContainsKey(player.userID))
                            {                                         
                                MSG(player, $"<color={configData.Messaging_MsgColor}>You have</color> <color={configData.Messaging_MainColor}>10</color><color={configData.Messaging_MsgColor}> seconds to return to the arena</color>");
                                ELog($"{player.displayName} has left the zone, adding kill timer");
                                int time = 10;
                                KillTimers.Add(player.userID, timer.Repeat(1, time, () =>
                                {
                                    if (player.GetComponent<EventPlayer>().OOB)
                                    {
                                        time--;
                                        MSG(player, $"<color={configData.Messaging_MainColor}>{time}</color><color={configData.Messaging_MsgColor}> seconds</color>", false);

                                        if (time == 0)
                                        {
                                            Effect.server.Run("assets/prefabs/tools/c4/effects/c4_explosion.prefab", (player.transform.position));
                                            player.Hurt(200f, Rust.DamageType.Explosion, null, true);
                                            BroadcastEvent($"<color={configData.Messaging_MainColor}>{player.displayName}</color><color={configData.Messaging_MsgColor}> tried to run away...</color>");
                                        }
                                    }
                                }));
                            }
                        }
        }
        void OnEnterZone(string zoneID, BasePlayer player)
        {
            if (EventStarted)
                if (player.GetComponent<EventPlayer>())
                    if (zoneID.Equals(ZoneName))
                    {
                        player.GetComponent<EventPlayer>().OOB = false;
                        if (KillTimers.ContainsKey(player.userID))
                        {
                            ELog($"{player.displayName} has entered the zone, destroying kill timer");
                            KillTimers[player.userID].Destroy();
                            KillTimers.Remove(player.userID);
                        }
                    }
        }
        #endregion

        #region Commands
        [ChatCommand("event")]
        void cmdEvent(BasePlayer player, string command, string[] args)
        {
            if (args == null || args.Length == 0)
            {
                string message = string.Empty;
                if (!EventOpen && !EventStarted) message = GetMessage("MessagesEventStatusClosedEnd");
                else if (EventOpen && !EventStarted) message = GetMessage("MessagesEventStatusOpen");
                else if (EventOpen && EventStarted) message = GetMessage("MessagesEventStatusOpenStarted");
                else message = GetMessage("MessagesEventStatusClosedStarted");
                MSG(player, string.Format(message, EventGameName));

                if (EventOpen)
                {
                    SendReply(player, "/event join - Join a event");
                    SendReply(player, "/event leave - Leave a event");
                    if (UseClassSelection)
                        SendReply(player, "/event class - Opens the class selector");
                }
                if (player.IsAdmin())
                {
                    SendReply(player, "/event open - Open a event");
                    SendReply(player, "/event cancel - Cancel a event");
                    SendReply(player, "/event cs - Activate/de-activate class selection");
                    SendReply(player, "/event cs add <classname> <kitname> - Add a new kit to class selection");
                    SendReply(player, "/event cs remove <classname> - Remove a kit from class selection");
                    SendReply(player, "/event start - Start a event");
                    SendReply(player, "/event close - Close a event to new entries");
                    SendReply(player, "/event end - End a event");
                    SendReply(player, "/event launch - Launch auto events");
                    SendReply(player, "/event game \"Game Name\" - Change event game");
                    SendReply(player, "/event gamemode <normal/battlefield> - Switch game modes");
                    SendReply(player, "/event minplayers XX - Set minimum required players (auto event)");
                    SendReply(player, "/event maxplayers XX - Set maximum players (auto event)");
                    SendReply(player, "/event spawnfile \"filename\" - Change the event spawnfile");
                    SendReply(player, "/event kit \"kitname\" - Change the event kit");
                }
                return;
            }
            switch (args[0].ToLower())
            {
                case "join":
                    object join = JoinEvent(player);
                    if (join is string)
                    {
                        SendReply(player, (string)join);
                        return;
                    }
                    return;
                case "leave":
                    object leave = LeaveEvent(player);
                    if (leave is string)
                    {
                        SendReply(player, (string)leave);
                        return;
                    }
                    return;
                case "class":
                    if (UseClassSelection)
                        if (EventStarted)
                            if (player.GetComponent<EventPlayer>())
                                SelectClass(player);                    
                    return;
            }
            if (!player.IsAdmin()) return;
            switch (args[0].ToLower())
            {
                case "cancel":
                    AutoEventLaunched = false;
                    if (EventOpen) CancelEvent(GetMessage("CancelAuto"));
                    DestroyTimers();
                    SendReply(player, GetMessage("CancelAuto"));
                    return;
                case "open":
                    object open = OpenEvent();
                    if (open is string)
                    {
                        SendReply(player, (string)open);
                        return;
                    }
                    SendReply(player, string.Format("Event \"{0}\" is now opened.", EventGameName));
                    return;
                case "debug":
                    if (Debug) { Debug = false; SendReply(player, "Debug deactivated"); }
                    else { Debug = true;  SendReply(player, "Debug activated"); }
                    return;
                case "start":
                    object start = StartEvent();
                    if (start is string)
                    {
                        SendReply(player, (string)start);
                        return;
                    }
                    SendReply(player, string.Format("Event \"{0}\" is now started.", EventGameName));
                    return;
                case "close":
                    object close = CloseEvent();
                    if (close is string)
                    {
                        SendReply(player, (string)close);
                        return;
                    }
                    SendReply(player, string.Format("Event \"{0}\" is now closed for entries.", EventGameName));
                    return;
                case "cs":
                    if (args.Length >= 2)
                    {
                        switch (args[1].ToLower())
                        {
                            case "add":
                                if (classData.ClassKits.Count >= 9)
                                {
                                    SendReply(player, "You have already set the maximum number of classes");
                                    return;
                                }
                                if (args.Length == 4)
                                {
                                    object isKit = Kits.Call("isKit", args[3]);
                                    if (!(isKit is bool))
                                    {
                                        SendReply(player, "Unable to find the kits plugin");
                                        return;
                                    }
                                    if (!(bool)isKit)
                                    {
                                        SendReply(player, string.Format("The kit {0} doesn't exist", args[3]));
                                        return;
                                    }
                                    classData.ClassKits.Add(args[2], args[3]);
                                    SaveData();
                                    SendReply(player, $"You have successfully added a new class kit {args[2]}, using kit {args[3]}");
                                }
                                return;
                            case "remove":
                                if (args.Length == 3)
                                {
                                    if (classData.ClassKits.ContainsKey(args[2]))
                                    {
                                        classData.ClassKits.Remove(args[2]);
                                        SaveData();
                                        SendReply(player, $"You have successfully removed the class {args[2]}");
                                        return;
                                    }
                                    SendReply(player, string.Format("The class {0} doesn't exist", args[2]));
                                }
                                return;
                        }
                    }
                    if (UseClassSelection)
                    {
                        UseClassSelection = false;
                        SendReply(player, "You have de-activated class selection");
                        return;
                    }
                    if (classData.ClassKits.Count < 1)
                    {
                        SendReply(player, "You must set classes before activating the class selector");
                        return;
                    }
                    UseClassSelection = true;
                    SendReply(player, "You have activated class selection");
                    return;
                case "end":
                    object end = EndEvent();
                    if (end is string)
                    {
                        SendReply(player, (string)end);
                        return;
                    }
                    SendReply(player, string.Format("Event \"{0}\" has ended.", EventGameName));
                    return;
                case "game":
                    if (args.Length > 1)
                    {
                        object game = SelectEvent(args[1]);
                        if (game is string)
                        {
                            SendReply(player, (string)game);
                            return;
                        }
                        configData.Default_Gamemode = EventGameName;
                        SaveConfig();
                        SendReply(player, string.Format("{0} is now the next Event game.", args[1]));
                    }
                    return;
                case "gamemode":
                    if (args.Length > 1)
                    {
                        switch (args[1].ToLower())
                        {
                            case "normal":
                                EventMode = GameMode.Normal;
                                break;
                            case "battlefield":
                                EventMode = GameMode.Battlefield;
                                break;
                            default:
                                break;                      
                        }
                        SendReply(player, string.Format("Event game mode is now set to {0}", EventMode.ToString()));
                    }
                    return;
                case "minplayers":
                    if (args.Length > 1)
                    {
                        int min;
                        if (!int.TryParse(args[1], out min))
                        {
                            MSG(player, "You must enter a number", false);
                            return;
                        }
                        object minplayers = SelectMinplayers(min);
                        if (minplayers is string)
                        {
                            MSG(player, (string)minplayers);
                            return;
                        }
                        SendReply(player, string.Format("Minimum Players for {0} is now {1} (this is only useful for auto events).", args[1], EventSpawnFile));
                    }
                    return;
                case "maxplayers":
                    if (args.Length > 1)
                    {
                        int max;
                        if (!int.TryParse(args[1], out max))
                        {
                            MSG(player, "You must enter a number", false);
                            return;
                        }
                        object maxplayers = SelectMaxplayers(max);
                        if (maxplayers is string)
                        {
                            SendReply(player, (string)maxplayers);
                            return;
                        }
                        SendReply(player, string.Format("Maximum Players for {0} is now {1}.", args[1], EventSpawnFile));
                    }
                    return;
                case "spawnfile":
                    if (args.Length > 1)
                    {
                        object spawnfile = SelectSpawnfile(args[1]);
                        if (spawnfile is string)
                        {
                            SendReply(player, (string)spawnfile);
                            return;
                        }
                        configData.Default_Spawnfile = args[1];
                        SaveConfig();
                        SendReply(player, string.Format("Spawnfile for {0} is now {1} .", EventGameName, EventSpawnFile));
                    }
                        return;
                case "kit":
                    if (args.Length > 1)
                    {
                        object success = SelectKit(args[1]);
                        if (success is string)
                        {
                            SendReply(player, (string)success);
                            return;
                        }
                        SendReply(player, string.Format("The new Kit for {0} is now {1}", EventGameName, args[1]));
                    }
                    return;
                case "launch":
                    object launch = LaunchEvent();
                    if (launch is string)
                    {
                        SendReply(player, (string)launch);
                        return;
                    }
                    SendReply(player, string.Format("Event \"{0}\" is now launched.", EventGameName));
                    return;
            }
        }

        [ConsoleCommand("event")]
        void ccmdEvent(ConsoleSystem.Arg arg)
        {
            if (!hasAccess(arg)) return;
            if (arg.Args == null || arg.Args.Length == 0)
            {
                SendReply(arg, "event open - Open a event");
                SendReply(arg, "event cancel - Cancel a event");
                SendReply(arg, "event start - Start a event");
                SendReply(arg, "event close - Close a event to new entries");
                SendReply(arg, "event end - End a event");
                SendReply(arg, "event launch - Launch auto events");
                SendReply(arg, "event game \"Game Name\" - Change event game");
                SendReply(arg, "event minplayers XX - Set minimum required players (auto event)");
                SendReply(arg, "event maxplayers XX - Set maximum players (auto event)");
                SendReply(arg, "event spawnfile \"filename\" - Change the event spawnfile");
                SendReply(arg, "event kit \"kitname\" - Change the event kit");
                SendReply(arg, "event cs - Activate/de-activate class selection");
                SendReply(arg, "event cs add <classname> <kitname> - Add a new kit to class selection");
                SendReply(arg, "event cs remove <classname> - Remove a kit from class selection");
                return;
            }
            switch (arg.Args[0].ToLower())
            {
                case "cancel":
                    AutoEventLaunched = false;
                    if (EventOpen) CancelEvent("Auto events have been cancelled");
                    DestroyTimers();
                    SendReply(arg, string.Format("Auto events have been cancelled", EventGameName));
                    return;
                case "open":
                    object open = OpenEvent();
                    if (open is string)
                    {
                        SendReply(arg, (string)open);
                        return;
                    }
                    SendReply(arg, string.Format("Event \"{0}\" is now opened.", EventGameName));
                    return;
                case "start":
                    object start = StartEvent();
                    if (start is string)
                    {
                        SendReply(arg, (string)start);
                        return;
                    }
                    SendReply(arg, string.Format("Event \"{0}\" is now started.", EventGameName));
                    return;
                case "close":
                    object close = CloseEvent();
                    if (close is string)
                    {
                        SendReply(arg, (string)close);
                        return;
                    }
                    SendReply(arg, string.Format("Event \"{0}\" is now closed for entries.", EventGameName));
                    return;
                case "debug":
                    if (Debug) { Debug = false; SendReply(arg, "Debug deactivated"); }
                    else { Debug = true; SendReply(arg, "Debug activated"); }
                    return;
                case "cs":
                    if (arg.Args.Length > 1)
                    {
                        switch (arg.Args[1].ToLower())
                        {
                            case "add":
                                if (classData.ClassKits.Count >= 9)
                                {
                                    SendReply(arg, "You have already set the maximum number of classes");
                                    return;
                                }
                                if (arg.Args.Length == 4)
                                {
                                    object isKit = Kits.Call("isKit", arg.Args[3]);
                                    if (!(isKit is bool))
                                    {
                                        SendReply(arg, "Unable to find the kits plugin");
                                        return;
                                    }
                                    if (!(bool)isKit)
                                    {
                                        SendReply(arg, string.Format("The kit {0} doesn't exist", arg.Args[3]));
                                        return;
                                    }
                                    classData.ClassKits.Add(arg.Args[2], arg.Args[3]);
                                    SaveData();
                                    SendReply(arg, $"You have successfully added a new class kit {arg.Args[2]}, using kit {arg.Args[3]}");
                                }
                                return;
                            case "remove":
                                if (arg.Args.Length == 3)
                                {
                                    if (classData.ClassKits.ContainsKey(arg.Args[2]))
                                    {
                                        classData.ClassKits.Remove(arg.Args[2]);
                                        SaveData();
                                        SendReply(arg, $"You have successfully removed the class {arg.Args[2]}");
                                        return;
                                    }
                                    SendReply(arg, string.Format("The class {0} doesn't exist", arg.Args[2]));
                                }
                                return;
                        }
                    }
                    if (UseClassSelection)
                    {
                        UseClassSelection = false;
                        SendReply(arg, "You have de-activated class selection");
                        return;
                    }
                    if (classData.ClassKits.Count < 1)
                    {
                        SendReply(arg, "You must set classes before activating the class selector");
                        return;
                    }
                    UseClassSelection = true;
                    SendReply(arg, "You have activated class selection");
                    return;
                case "end":
                    object end = EndEvent();
                    if (end is string)
                    {
                        SendReply(arg, (string)end);
                        return;
                    }
                    SendReply(arg, string.Format("Event \"{0}\" has ended.", EventGameName));
                    return;
                case "game":
                    object game = SelectEvent(arg.Args[1]);
                    if (game is string)
                    {
                        SendReply(arg, (string)game);
                        return;
                    }
                    configData.Default_Gamemode = EventGameName;
                    SaveConfig();
                    SendReply(arg, string.Format("{0} is now the next Event game.", arg.Args[1]));
                    return;
                case "gamemode":
                    if (arg.Args.Length > 1)
                    {
                        switch (arg.Args[1].ToLower())
                        {
                            case "normal":
                                EventMode = GameMode.Normal;
                                break;
                            case "battlefield":
                                EventMode = GameMode.Battlefield;
                                break;
                            default:
                                break;
                        }
                        SendReply(arg, string.Format("Event game mode is now set to {0}", EventMode.ToString()));
                    }
                    return;
                case "minplayers":
                    int min;
                    if (!int.TryParse(arg.Args[1], out min))
                    {
                        SendReply(arg, "You must enter a number");
                        return;
                    }
                    object minplayers = SelectMinplayers(min);
                    if (minplayers is string)
                    {
                        SendReply(arg, (string)minplayers);
                        return;
                    }
                    SendReply(arg, string.Format("Minimum Players for {0} is now {1} (this is only useful for auto events).", arg.Args[1], EventSpawnFile));
                    return;
                case "maxplayers":
                    int max;
                    if (!int.TryParse(arg.Args[1], out max))
                    {
                        SendReply(arg, "You must enter a number");
                        return;
                    }
                    object maxplayers = SelectMaxplayers(max);
                    if (maxplayers is string)
                    {
                        SendReply(arg, (string)maxplayers);
                        return;
                    }
                    SendReply(arg, string.Format("Maximum Players for {0} is now {1}.", arg.Args[1], EventSpawnFile));
                    return;
                case "spawnfile":
                    object spawnfile = SelectSpawnfile(arg.Args[1]);
                    if (spawnfile is string)
                    {
                        SendReply(arg, (string)spawnfile);
                        return;
                    }
                    configData.Default_Spawnfile = arg.Args[1];
                    SaveConfig();
                    SendReply(arg, string.Format("Spawnfile for {0} is now {1} .", EventGameName, EventSpawnFile));
                    return;
                case "kit":
                    object success = SelectKit(arg.Args[1]);
                    if (success is string)
                    {
                        SendReply(arg, (string)success);
                        return;
                    }
                    SendReply(arg, string.Format("The new Kit for {0} is now {1}", EventGameName, arg.Args[1]));
                    return;  
                case "launch":
                    object launch = LaunchEvent();
                    if (launch is string)
                    {
                        SendReply(arg, (string)launch);
                        return;
                    }
                    SendReply(arg, string.Format("Event \"{0}\" is now launched.", EventGameName));
                    return;
            }
        }
        #endregion

        #region Tokens
        [HookMethod("AddTokens")]
        public void AddTokens(string userid, int amount)
        {
            string tokentype = "";
            if (configData.UseEconomicsAsTokens)
            {
                if (Economics)
                {
                    Economics?.Call("Deposit", userid, amount);
                    tokentype = "Coins";
                }
            }
            else
            {
                ServerRewards?.Call("AddPoints", userid, amount);
                tokentype = "RP";
            }
            BasePlayer player = BasePlayer.FindByID(ulong.Parse(userid));
            if (player != null && !string.IsNullOrEmpty(tokentype))
            {
                ELog($"Adding {amount} {tokentype} to {player.displayName}");
                SendReply(player, $"<color={configData.Messaging_MainColor}>{Title}:</color><color={configData.Messaging_MsgColor}> You have been awarded </color><color={configData.Messaging_MainColor}>{amount} {tokentype}</color>");
            }
        }    
       
        #endregion

        #region Data

        void SaveData()
        {
            Class_Data.WriteObject(classData);
            Puts("Saved class data");
        }        
        void LoadData()
        {
            try
            {
                classData = Class_Data.ReadObject<ClassData>();
            }
            catch
            {
                Puts("Couldn't load class data, creating new datafile");
                classData = new ClassData();
            }            
        }
        #endregion

        static void ELog(string message)
        {
            if (Debug)            
                ConVar.Server.Log("oxide/logs/EventManager.txt", message);
        }

        //[ConsoleCommand("event.openauto")]
        // void ccmdEventOpenAuto(ConsoleSystem.Arg arg)
        //{
        // if (!hasAccess(arg)) return;
        // object success = OpenEvent();
        // if (success is string)
        // {
        //     SendReply(arg, (string)success);
        //     return;
        // }
        // OpenAutoEventLaunched = true;
        // EventAutoNum = 0;
        // DestroyTimers();
        // var evencfg = EventAutoConfig[EventAutoNum.ToString()] as Dictionary<string, object>;
        // if (evencfg["timelimit"] != null && evencfg["timelimit"].ToString() != "0")
        //    AutoArenaTimers.Add(timer.Once(Convert.ToSingle(evencfg["timelimit"]), () => CancelEvent("Not enough players")));
        //SelectMinplayers((string)evencfg["minplayers"]);
        // SendReply(arg, string.Format("Event \"{0}\" is now opened.", EventGameName));
        //}
    }
}


// --- End of file: EventManager.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/LootCleaner.cs ---
// --- Original Local Path: LootCleaner.cs ---

using Newtonsoft.Json;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Loot Cleaner", "walkinrey", "1.0.2")]
    class LootCleaner : RustPlugin 
    {
        Configuration config;
        class Configuration 
        {
            [JsonProperty("Через сколько секунд удалять ящик, если его не до конца облутал игрок?")] 
            public float seconds = 5f;
        }
        protected override void SaveConfig() => Config.WriteObject(config);
        protected override void LoadConfig()
        {
            base.LoadConfig(); 
            try 
            {
                config = Config.ReadObject<Configuration>();
            } 
            catch 
            {
                LoadDefaultConfig();
            }
            NextTick(SaveConfig);
        }
        protected override void LoadDefaultConfig() => config = new Configuration();
        void OnLootEntityEnd(BasePlayer player, BaseCombatEntity entity) 
        {
            try {
                if(((LootContainer)entity) == null) return;
                LootContainer container = (LootContainer)entity;
                if(container.inventory.itemList.Count != 0) {
                    timer.Once(config.seconds, () =>
                    {
                        if(container != null) container.RemoveMe();
                    });
                }
            }
            catch {}
        }
    }
}

// --- End of file: LootCleaner.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/SuicideNerf.cs ---
// --- Original Local Path: SuicideNerf.cs ---

using System;
using UnityEngine;
using Oxide.Core.Plugins;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("SuicideNerf", "Kyrah Abattoir", "0.1", ResourceId = 1873)]
    [Description("Forces you to bleedout when using 'kill' and adds a cooldown.")]
    class SuicideNerf : RustPlugin
    {
        //CONFIGURATION AREA
        //Cause i'm too dumb to write my own configuration code
        //And too proud to copy someone else's
        private int     cfgMinTimeBetweenSuicideAttempts = 300; //How many seconds between suicide attempts.
        private bool    cfgDoBleedout = true;                   //Set this to false to use the normal rust suicide method.

        private Dictionary<ulong, float> nextSuicideTime = new Dictionary<ulong, float>();

        [HookMethod("OnRunCommand")]
        private object OnRunCommand(ConsoleSystem.Arg arg)
        {
            if (arg?.cmd == null || arg.Player() == null)
                return null;

            BasePlayer ply = arg.Player();
            if (arg.cmd.namefull == "global.kill")
            {
                if (ply.IsWounded())
                    PrintToConsole(ply, "You have to wait until you bleed out or are rescued.");
                else
                {
                    ulong steamID = ply.userID;
                    float next_time;
                    if (nextSuicideTime.TryGetValue(steamID, out next_time))
                    {
                        if(Time.realtimeSinceStartup >= next_time)
                        {
                            nextSuicideTime[steamID] = Time.realtimeSinceStartup + cfgMinTimeBetweenSuicideAttempts;
                            return DoSuicide(ply);
                        }
                        else
                            PrintToConsole(ply,$"You have to wait {(int)(next_time - Time.realtimeSinceStartup)} second(s) before you can suicide again.");
                    }
                    else
                    {
                        nextSuicideTime.Add(steamID, Time.realtimeSinceStartup + cfgMinTimeBetweenSuicideAttempts);
                        return DoSuicide(ply);
                    }
                }
                return true;
            }
            return null;
        }

        private object DoSuicide(BasePlayer ply)
        {
            if (cfgDoBleedout)
            {
                ply.StartWounded();
                return true;
            }
            return null;
        }
    }
    
}

// --- End of file: SuicideNerf.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/ExternalWallStack.cs ---
// --- Original Local Path: ExternalWallStack.cs ---

using System;
using System.Text;
using System.Reflection;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("ExternalWallStack", "Dyceman - Deadlaugh (Dan)", "1.0.0", ResourceId = 0)]
    [Description("Allows the players to stack high external walls on top of each other.")]

    class ExternalWallStack : RustPlugin
    {

        #region Custom Functions
        /*
         * Name: HasRunPermission
         * Parameters: BasePlayer player, string cmdPermission
         * Return: Boolean
         * Description: Checks if the user has the permission of the value of the cmdPermission variable or is an owner of the server.
         */
        private bool HasRunPermission(BasePlayer player, string cmdPermission)
        {
            // If the player is equal to null then return false.
            if (player == null)
                return false;

            // return true or false (return true if the user has the permission or is an owner of the server) (return false if the user doesn't have the permission or isn't an owner of the server).
            return permission.UserHasPermission(player.userID.ToString(), cmdPermission) || player.net?.connection?.authLevel == 2;
        }


        /*
         * Name: CreateStackWall
         * Parameters: int amount, BaseEntity entity, BasePlayer player
         * Return: HashSet<ExternalWallLink>
         * Description: Creates the high external walls that stack on top of the first high external wall.
         */
        private HashSet<ExternalWallLink> CreateStackWall(int amount, BaseEntity entity, BasePlayer player)
        {
            // If the value of amount is less than 1 then set the value of amount to 1 else set the value of amount to the value of amount.
            amount = (amount < 1) ? 1 : amount;

            // Create an emply "list" that will contain ExternalWallLink(s).
            HashSet<ExternalWallLink> links = new HashSet<ExternalWallLink>();

            // If the configuration key "RequireMaterials" is set to true.
            if (this.configRequireMaterials == true)
            {
                // Find the item's definition for the type of high external wall that is being placed.
                ItemDefinition itemDefinition = ItemManager.FindItemDefinition(entity.ShortPrefabName);

                // Count how much high external walls the user has in their inventory.
                int canPlaceAmount = player.inventory.GetAmount(itemDefinition.itemid);

                // Subtract how much high external walls the user has in their inventory by one.
                canPlaceAmount = canPlaceAmount - 1;

                // If the amount of high external walls the user has in their inventory is less than one then return an empty list of ExternalWallLink(s).
                if (canPlaceAmount < 1)
                    return links;

                // If the amount of high external walls the users has in their inventory is greater than the amount allowed to be placed then set the value of amount to the value of amount...
                // ...else set the value of amount to the value of how much high external walls the user has in their inventory.
                amount = (canPlaceAmount > amount) ? amount : canPlaceAmount;

                // Take # (based now the value of amount) of high external walls from the player.
                player.inventory.Take(new List<Item>(), itemDefinition.itemid, amount);
                // Notify the player of how much high external walls are being taken out of their inventory.
                player.Command("note.inv", itemDefinition.itemid, -amount);
            }

            // Create an emply ExternalWallLink.
            ExternalWallLink entityLink;

            // Loop until the value of index is greater than the value of amount plus one.
            for (int index = 1; index < amount + 1; index++)
            {

                // Create an high external wall.
                BaseEntity wall = GameManager.server.CreateEntity(entity.PrefabName, entity.transform.position + new Vector3(0f, 5.5f * (float)index, 0f), entity.transform.rotation, true);
                // Activate the high external wall game object.
                wall.gameObject.SetActive(true);
                // Spawn the high external wall game object.
                wall.Spawn();
                // Notify the server of the placement and rotation changes of the high external wall.
                wall.TransformChanged();

                // Get the BaseCombatEntity component of the high external wall.
                BaseCombatEntity combatEntity = wall.GetComponentInParent<BaseCombatEntity>();

                // If the component can be found.
                if (combatEntity != null)
                {
                    // Change the health of the high external wall to max health.
                    combatEntity.ChangeHealth(combatEntity.MaxHealth());
                }

                // Set the owner of the high external wall to the player.
                wall.OwnerID = player.userID;

                // Tell the server to to send a update to the players for the high external wall.
                wall.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);

                // Set the ExternalWallLink's game object to the high external wall's game object.
                entityLink = new ExternalWallLink(wall.gameObject);

                // Add the ExternalWallLink to the list of ExternalWallLink(s).
                links.Add(entityLink);
            }

            // Return the list of ExternalWallLink(s).
            return links;
        }


        /*
         * Name: GetConfig
         * Parameters: string name, T value
         * Return: if it can't find the configuration then return the value of value else return the value of the configuration.
         * Description: Obtains a configuration by the name.
         */
        T GetConfig<T>(string name, T value) => Config[name] == null ? value : (T)Convert.ChangeType(Config[name], typeof(T));
        #endregion

        #region MonoBehavior
        class ExternalWallLink
        {
            // Create an empty GameObject.
            GameObject gameObject;

            // Create boolean variable and set it to false.
            public bool isRemoving = false;

            /*
             * Name: ExternalWallLink
             * Parameters: GameObject go
             * Return: Nothing because it is an constructor
             * Description: Constructor for the ExternalWallLink class.
             */
            public ExternalWallLink(GameObject go)
            {
                // Set the class variable gameObject to the value of the argrument.
                this.gameObject = go;
            }

            /*
             * Name: entity
             * Parameters: None
             * Return: NULL if it can't get the BaseEntity component else return the BaseEntity component of the game object
             * Description: Constructor for the ExternalWallLink class.
             */
            public BaseEntity entity()
            {
                return (this.gameObject.GetComponent<BaseEntity>() == null) ? null : this.gameObject.GetComponent<BaseEntity>();
            }
        }

        class ExternalWallController : MonoBehaviour
        {
            // Declare an empty list of ExternalWallLink(s).
            HashSet<ExternalWallLink> links;

            /*
             * Name: Awake
             * Parameters: None
             * Return: None
             * Description: It is called when this component is added to a game object.
             */
            void Awake()
            {
                // Create an empty list of ExternalWallLink(s).
                links = new HashSet<ExternalWallLink>();
            }

            /*
             * Name: entityLinks
             * Parameters: None
             * Return: HashSet<ExternalWallLink>
             * Description: Return the list of ExternalWallLink(s).
             */
            public HashSet<ExternalWallLink> entityLinks()
            {
                // Return the value of the variable links.
                return this.links;
            }

            /*
             * Name: addLink
             * Parameters: ExternalWallLink linkEntity
             * Return: None
             * Description: Add a *new* entry to the list of ExternalWallLink(s).
             */
            public void addLink(ExternalWallLink linkEntity)
            {
                // If the variable links doesn't contain argument.
                if (this.links.Contains(linkEntity) == false)
                    // Add the ExternalWallLink to the list of ExternalWallLink(s).
                    this.links.Add(linkEntity);
            }
        }
        #endregion

        #region Initialization

        // Obtain the plugin RemoverTool.
        [PluginReference]
        Plugin RemoverTool;

        // Declare the variables that will contain the values of their respective configuration values.
        int configStackHeight;
        bool configUsePermission, configRequireMaterials;
        string pluginPermission, pluginName, pluginColor = "#FF6600";

        // Create empty list of BaseEntity(s).
        List<BaseEntity> removingEntity = new List<BaseEntity>();
        // Create empty list of player user id(s).
        HashSet<ulong> playerToggleCommand = new HashSet<ulong>();


        /*
         * Name: LoadDefaultConfig
         * Parameters: None
         * Return: None
         * Description: Called when the config for a plugin should be initialized.
         */
        protected override void LoadDefaultConfig()
        {
            Config["StackHeight"] = configStackHeight = GetConfig("StackHeight", 2);
            Config["UsePermission"] = configUsePermission = GetConfig("UsePermission", true);
            Config["RequireMaterials"] = configRequireMaterials = GetConfig("RequireMaterials", true);
            SaveConfig();
        }

        /*
         * Name: Init
         * Parameters: None
         * Return: None
         * Description: Called when a plugin is being initialized.
         */
        void Init()
        {
            // Call the function LoadDefaultConfig.
            LoadDefaultConfig();

            // Set the variable pluginPermission value to externalwallstack.wstack.
            this.pluginPermission = new StringBuilder(this.GetType().Name.ToLower()).Append(".wstack").ToString();

            // Set the leading plugin name in chat to "<color=#FF6600>[ExternalWallStack]</color> :".
            this.pluginName = new StringBuilder("<color=").Append(this.pluginColor).Append(">[").Append(this.GetType().Name).Append("]</color> : ").ToString();

            // Register messages to the plugin lang file.
            lang.RegisterMessages(new Dictionary<string, string>
            {
                { "NotAuthorized", "You're not the permissions to use this chat command!" },
                { "CommandToggle", "High External Wall stacking is <color={0}>{1}</color>"}

            }, this);

            // If the permission externalwallstack.wstack doesn't exist.
            if (!permission.PermissionExists(pluginPermission))
                // Register the permission externalwallstack.wstack.
                permission.RegisterPermission(pluginPermission, this);
        }

        /*
         * Name: OnServerInitialized
         * Parameters: None
         * Return: None
         * Description: Called after the server startup has been completed and is awaiting connections.
         */
        void OnServerInitialized()
        {
            // If the plugin RemoverToll can't be found.
            if (RemoverTool == null)
                // Print a warning to the server console.
                PrintWarning("RemoverTool by Reneb was not found!");
        }

        /*
         * Name: Unload
         * Parameters: None
         * Return: None
         * Description: Called when a plugin is being unloaded.
         */
        void Unload()
        {
            // Clear the list of player user id(s).
            this.playerToggleCommand.Clear();
            // Clear the list of BaseEntity(s).
            this.removingEntity.Clear();
        }

        /*
         * Name: OnPlayerDisconnected
         * Parameters: BasePlayer player, string reason
         * Return: None
         * Description: Called after the player has disconnected from the server.
         */
        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            // If the list of player user id(s) contains the player's user id.
            if (this.playerToggleCommand.Contains(player.userID) == true)
                // Remove the player's user id from the list of player user id(s).
                this.playerToggleCommand.Remove(player.userID);
        }
        #endregion

        #region Hooks
        /*
         * Name: OnEntityBuilt
         * Parameters: Planner planner, GameObject gameObject
         * Return: None
         * Description: Called when any structure is built (walls, ceilings, stairs, etc.).
         */
        void OnEntityBuilt(Planner planner, GameObject gameObject)
        {
            // If the argument for planner is null or the argument for gameObject is null then don't proceed any further.
            if (planner == null || gameObject == null)
                return;

            // Obtain the BaseEntity component from the game object a store it into the variable baseEntity.
            BaseEntity baseEntity = gameObject.GetComponent<BaseEntity>();

            // If the BaseEntity component was found or the planner doesn't have an owner then don't proceed any further.
            if (baseEntity == null || planner.GetOwnerPlayer() == null)
                return;

            // Obtain the owner of the planner.
            BasePlayer player = planner.GetOwnerPlayer();

            // If the entity is a High External Wall and the player has wall stacking enabled.
            if (baseEntity.ShortPrefabName.Contains("wall.external.high") == true && this.playerToggleCommand.Contains(player.userID))
            {
                // Declare empty variales.
                BaseEntity linkingEntity;
                ExternalWallController linkingExternalController;
                HashSet<ExternalWallLink> externalLinks;

                // Set the value of the variable externalLinks to the return value of the function CreateStackWall.
                externalLinks = this.CreateStackWall(this.configStackHeight, baseEntity, player);

                // If the list of ExternalWallLink(s) is not empty.
                if(externalLinks.Count > 0)
                {
                    // Create a new ExternalWallLink for the game object and store it in the variable initialExternalLink.
                    ExternalWallLink initialExternalLink = new ExternalWallLink(gameObject);
                    // Add the value of the variable initialExternalLink to the list of ExternalWallLink(s).
                    externalLinks.Add(initialExternalLink);

                    // Go through the list of ExternalWallLink(s).
                    foreach (ExternalWallLink externalLink in externalLinks)
                    {
                        // Set the value of the variable linkingEntity to the current ExternalWallLink('s) BaseEntity.
                        linkingEntity = (BaseEntity)externalLink.entity();

                        // If the BaseEntity component was found.
                        if (linkingEntity != null)
                        {
                            // Add the ExternalWallController to the current game object.
                            linkingExternalController = linkingEntity.gameObject.AddComponent<ExternalWallController>();

                            // Go through the list of ExternalWallLink(s).
                            foreach (ExternalWallLink externalAddLinkage in externalLinks)
                            {
                                // If the current link is the parent current link then continue (skip it).
                                if (externalAddLinkage == externalLink) continue;

                                // Link the other ExternalWallLink(s) to the ExternalWallController.
                                linkingExternalController.addLink(externalAddLinkage);
                            }
                        }
                    }
                }
                
            }

            // Set the value of the variable baseEntity to null.
            baseEntity = null;
        }

        /*
         * Name: OnRemovedEntity
         * Parameters: BaseEntity entity
         * Return: None
         * Description: Called when any structure is removed by the removal tool.
         */
        void OnRemovedEntity(BaseEntity entity)
        {
            // If the BaseEntity is null then don't proceed any further.
            if (entity == null) return;

            // If the BaseEntity is an High External Wall.
            if (entity.ShortPrefabName.Contains("wall.external.high") == true)
            {
                // If the entity is being removed.
                if (this.removingEntity.Contains(entity) == true)
                {
                    // Remove the entity from the list of BaseEntity(s).
                    this.removingEntity.Remove(entity);
                    // Don't proceed any further.
                    return;
                }
                else
                    // If the entity isn't being removed then add it to the list of BaseEntity(s).
                    this.removingEntity.Add(entity);

                // Obtain the ExternalWallController component from the BaseEntity('s) game object.
                ExternalWallController controller = entity.gameObject.GetComponent<ExternalWallController>();

                // If the ExternalWallController component wasn't found then don't proceed any further.
                if (controller == null) return;

                // Declare empty variable.
                BaseEntity linkEntity;

                // Get the owner of the BaseEntity.
                BasePlayer player = BasePlayer.Find(entity.OwnerID.ToString());

                // Go through the list of ExternalWallLink(s) in the ExternalWallController component.
                foreach (ExternalWallLink externalLink in controller.entityLinks())
                {
                    // If the ExternalWallLink isn't being removed.
                    if (externalLink.isRemoving == false)
                    {
                        // Remove the ExternalWallLink.
                        externalLink.isRemoving = true;

                        // Get the BaseEntity that owns the ExternalWallLink component.
                        linkEntity = externalLink.entity();

                        // If the BaseEntity is null then move to the next ExternalWallLink.
                        if (linkEntity == null) continue;

                        // If the player is required to use materials.
                        if (this.configRequireMaterials == true)
                        {
                            // Create the High External Wall and give it to the player.
                            Item item = ItemManager.CreateByName(entity.ShortPrefabName, 1);
                            player.inventory.GiveItem(item, null);
                            player.Command("note.inv", item.info.itemid, item.amount);
                        }

                        // Kill the BaseEntity.
                        linkEntity.Kill(BaseNetworkable.DestroyMode.Gib);
                    }
                    
                }
            }
        }

        /*
         * Name: OnEntityDeath
         * Parameters: BaseCombatEntity entity, HitInfo info
         * Return: None
         * Description: Called when any thing is killed.
         */
        void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            // If the BaseCombatEntity is null then don't proceed any further.
            if (entity == null) return;

            // If BaseCombatEntity is an High External Wall.
            if (entity.ShortPrefabName.Contains("wall.external.high") == true)
            {
                // Obtain the ExternalWallController component from the BaseCombatEntity.
                ExternalWallController controller = entity.gameObject.GetComponent<ExternalWallController>();

                // Declare an empty variable.
                ExternalWallController controllerLink;

                // If the ExternalWallController component can't be found in the BaseCombatEntity then don't proceed any further.
                if (controller == null) return;

                // Declare an empty variable.
                BaseEntity linkEntity;

                // Go through the list of ExternalWallLink(s) in the ExternalWallController component.
                foreach (ExternalWallLink externalLink in controller.entityLinks())
                {
                    // Get the BaseEntity that owns the ExternalWallLink component.
                    linkEntity = externalLink.entity();

                    // If the BaseEntity is null then move to the next ExternalWallLink.
                    if (linkEntity == null) continue;

                    // Obtain the ExternalWallController component from the current BaseEntity
                    controllerLink = linkEntity.gameObject.GetComponent<ExternalWallController>();

                    // If the ExternalWallController component couldn't be found then move to the next ExternalWallLink.
                    if (controllerLink == null) continue;

                    // Sever link between the BaseCombatEntity and the current BaseEntity.
                    controllerLink.entityLinks().RemoveWhere(link => link.entity() == null || link.entity().gameObject == entity.gameObject);
                }
            }
                
        }

        #endregion

        #region Chat Commands
        /*
         * Name: cmdWStack
         * Parameters: BasePlayer player, string command, string[] args
         * Return: None
         * Description: Called when a player type /wstack in chat.
         */
        [ChatCommand("wstack"), Permission("externalwallstack.wstack")]
        private void cmdWStack(BasePlayer player, string command, string[] args)
        {
            // If the player can't be found then don't proceed any further.
            if (player == null)
                return;

            // If the user doesn't have the permission externalwallstack.wstack and the configuration requires the user to have the permission externalwallstack.wstack.
            if (this.HasRunPermission(player, this.pluginPermission) == false && this.configUsePermission == true)
            {
                // Notify the player that they don't have the permission to run this chat command.
                PrintToChat(player, lang.GetMessage("NotAuthorized", this, null));

                // Don't proceed any further.
                return;
            }

            // If the list of player user id(s) contains the player's user id that is running this command.
            if (this.playerToggleCommand.Contains(player.userID) == true)
            {
                //  Notify the player that they have High External Wall stacking OFF.
                PrintToChat(player, new StringBuilder(this.pluginName).AppendFormat(lang.GetMessage("CommandToggle", this, null), "#CC0000","OFF").ToString());

                // Remove the player's user id from the list of player user id(s).
                this.playerToggleCommand.Remove(player.userID);

                // Don't proceed any further.
                return;
            }

            // Add the player's user id to the list of player user id(s).
            this.playerToggleCommand.Add(player.userID);

            //  Notify the player that they have High External Wall stacking ON.
            PrintToChat(player, new StringBuilder(this.pluginName).AppendFormat(lang.GetMessage("CommandToggle", this, null), "#2C6700","ON").ToString());
        }
        #endregion

    }
}


// --- End of file: ExternalWallStack.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/FineName.cs ---
// --- Original Local Path: FineName.cs ---

using System;
using System.Linq;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using Oxide.Core.Libraries.Covalence;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("FineName", "Nimant", "1.0.7")]
    class FineName : RustPlugin
    {				
		
		#region Variables
		
		private static List<string> Changed = new List<string>();
		
		#endregion
		
		#region Hooks
		
		private void OnServerInitialized() 
		{
			Changed.Clear();
			foreach (var player in BasePlayer.activePlayerList)
			{
				OnUserConnected(player.IPlayer);
				OnPlayerConnected(player); 
			}
		}
		
		private void OnUserConnected(IPlayer player) => CheckName(player);
		
		private void OnPlayerConnected(BasePlayer player)
        {
			if (!Changed.Exists(x=> x == player.UserIDString)) return;
			
            if (player.IsReceivingSnapshot)
            {
                timer.Once(0.1f, () => OnPlayerConnected(player));                
				return;
            }
            
			timer.Once(2f, ()=>
			{
				if (player != null)
				{
					SendReply(player, "<color=#FFA07A>Ваш ник содержал недопустимые символы и был изменён.</color>");
					Changed.Remove(player.UserIDString);
				}
			});
        }
		
		private void OnPlayerDisconnected(BasePlayer player, string reason)
		{
			if (player != null && Changed.Exists(x=> x == player.UserIDString))
				Changed.Remove(player.UserIDString);
		}
		
		#endregion
		
		#region Command Test
		
		[ConsoleCommand("fn.test")]
        private void ccmdTestName(ConsoleSystem.Arg arg)
        {
			BasePlayer player = arg.Connection?.player as BasePlayer;
            if (player != null) return;						
			
			if (arg?.Args == null || arg?.Args?.Length == 0)
			{
				Puts("Использование: fn.test <имя>");
				return;
			}						
			
			string newName = "";
			bool isSilent = false;
			
			var name = string.Join(" ", arg.Args); 
			
			if (IsNeedChangeName(name, "76561198241364488", out newName, out isSilent))
				Puts($"Имя изменится на '{newName}', изменение тихое: {isSilent}");
			else
				Puts("Имя не изменится");
		}
		
		#endregion
		
		#region Main
		
		private void CheckName(IPlayer player)
		{
			string newName = "";
			bool isSilent = false;
			
			var oldName = player.Name;
			if (IsNeedChangeName(player.Name, player.Id, out newName, out isSilent))				
			{				
                player.Rename(newName);            						
				Puts($"Игроку {oldName} ({player.Id}) было изменено имя на {newName}");
								
				if (!isSilent && !Changed.Exists(x=> x == player.Id))
					Changed.Add(player.Id);				
			}
		}
		
		private static bool IsNeedChangeName(string oldName, string userID, out string newName, out bool isSilent)
		{			
			newName = oldName;
			isSilent = false;						
			
			if (configData.IsNoHtmlTags)
			{
				newName = RenameHtmlBrackets(newName);			
				isSilent = newName != oldName;
			}

			foreach (var word in configData.BadList)
			{
				var word_ = word.ToLower();
				if (newName.ToLower().Contains(word_))
				{					
					newName = RemoveBadWord(newName, word_);
					isSilent = false;
				}
			}			
			
			if (configData.IsDelLinks)
			{
				var tmp = RemoveLinkText(newName);
				
				if (tmp != newName)
				{
					newName = tmp;
					isSilent = false;
				}
			}
			
			if (configData.BadPercent < 100 && IsNeedChangeNameByBadSymbols(newName))
			{
				newName = GetRandomUserName((ulong)Convert.ToInt64(userID));
				isSilent = false;
			}
									
			return oldName != newName;
		}
		
		private static string RemoveBadWord(string oldStr, string word)
		{
			word = word.ToLower();
			var oldStrLow = oldStr.ToLower();
			var result = "";
			int num = 0;
			
			for (int ii = 0; ii < oldStr.Length; ii++)
			{
				var ch = oldStr[ii];
				var foundWord = true;
				
				for (int jj = 0; jj < word.Length; jj++)
				{
					if (ii+jj >= oldStrLow.Length || word[jj] != oldStrLow[ii+jj])
					{
						foundWord = false;
						break;
					}
				}
				
				if (foundWord)
					num += word.Length;
				
				if (ii == num)
				{
					result += ch;
					num++;
				}
			}
			
			return result;
		}
		
		private static bool IsNeedChangeNameByBadSymbols(string name)
		{
			if (string.IsNullOrEmpty(name) || name.Length == 0) return true;
			
			float weight = 0f;
			int count = 0;
			foreach(var ch in name) 
			{
				if (count >= configData.GoodLenChars) return false;
				var w = WeightChar(ch);
				weight += w;
				if (w >= 0.8f) 
					count++;
				else
					count = 0;
			}
			
			if (count >= configData.GoodLenChars) return false;
						
			return (weight / name.Length) < ((100-configData.BadPercent)/100f);
		}
		
		private static float WeightChar(char ch)
		{
			var iCh = (int)ch;
			
			if (iCh < 32) return 0f; // управляющие коды
			
			if (iCh == 47 || iCh == 92) return 0.3f; // символы \/
			
			if (iCh == 32) return 0.2f; // пробел
			
			// всякие % $ и т.п. символы которые можно повторить
			if ((iCh >= 33 && iCh <= 46) || (iCh >= 58 && iCh <= 64) || (iCh >= 91 && iCh <= 96) || (iCh >= 123 && iCh <= 127)) return 0.3f;
			
			// 0-9
			if (iCh >= 48 && iCh <= 57) return 1f;
			
			// буквы
			if ((iCh >= 65 && iCh <= 90) || (iCh >= 97 && iCh <= 122) || (iCh >= 128 && iCh <= 175) || (iCh >= 224 && iCh <= 241) || (iCh >= 1040 && iCh <= 1103) || iCh == 1025) return 1f;
			
			// нельзя повторить и юникодовские все
			if ( (iCh >= 176 && iCh <= 223) || iCh >= 242) return 0f;
			
			return 1f;
		}
		
		private static string GetRandomUserName(ulong v) => Facepunch.RandomUsernames.Get((int)(v % 2147483647uL));                                                                                                                      //credit Fujikura.        			
		
		private static string RenameHtmlBrackets(string text) => text.Replace("<", "˂").Replace(">", "˃");					
		
		private static string RemoveLinkText(string text)
		{
			string pattern = "[A-Za-z0-9-А-Яа-я]+\\.(com|lt|net|org|gg|ru|рф|int|info|ru.com|ru.net|com.ru|net.ru|рус|org.ru|moscow|biz|орг|москва|msk.ru|su|msk.su|md|tj|kz|tm|pw|travel|name|de|eu|eu.com|com.de|me|org.lv|pl|nl|at|co.at|be|wien|info.pl|cz|ch|com.pl|or.at|net.pl|org.pl|hamburg|cologne|koeln|berlin|de.com|es|biz.pl|bayern|scot|edu|edu.pl|com.es|nom.es|nom|nom.pl|brussels|org.es|gb|gb.net|shop|shop.pl|waw|waw.pl|wales|vlaanderen|gr.com|hu|hu.net|si|se|se.net|cymru|melbourne|im|sk|lat|gent|co.uk|uk|com.im|co.im|co|org.uk|me.uk|ist|saarland|org.im|istanbul|uk.net|uk.com|li|lu|gr|london|eu.com|lv|ro|com.ro|fi|net.fv|fv|com.lv|net.lv|as|asia|ind.in|net.ph|org.ph|io|jp|qa|ae.org|ae|ph|ind|af|jp.net|sa.com|sa|tl|tw|tv|tokyo|jpn.com|jpn|net.af|com.af|nagoya|org.af|com.tw|cn|cn.com|cx|la|club|club.tw|idv.tw|idv|yokohama|ebiz|ebiz.tw|mn|christmas|in|game|game.tw|to|com.my|co.in|in.net|net.in|net.my|org.my|ist|istanbul|pk|org.in|in.net|ph|com.ph|firm|firm.in|gen|gen.in|us|us.com|net.ec|ec|info.ec|co.lc|lc|com.lc|net.lc|org.lc|pro|pro.ec|med|med.ec|la|us.org|ag|gl|mx|com.mx|fin|fin.ec|co.ag|gl|mx|com.mx|pe|co.gl|com.gl|com.ag|net.ag|org.ag|net.gl|org.gl|net.pe|com.pe|gs|org.pe|nom|nom.ag|gy|sr|sx|bz|br|br.com|co.gy|co.bz|com.gy|vc|com.vc|net.vc|net.gy|hn|net.bz|com.bz|org.bz|com.hn|org.vc|co.ve|ve|net.hn|quebec|cl|org.hn|com.ve|ht|vegas|com.co|nyc|co.com|com.ht|us.com|miami|net.ht|org.ht|nom.co|nom|net.co|ec|info.ht|us.org|lc|com.ec|ac|as|mu|com.mu|tk|ws|net.mu|cc|cd|nf|org.mu|za|za.com|co.za|org.za|net.za|com.nf|net.nf|co.cm|cm|com.cm|org.nf|web|web.za|net.cm|ps|nu|net.so|nz|fm|irish|co.nz|radio|radio.fm|gg|net.nz|ml|com.ki|net.ki|ki|cf|org.nz|sb|com.sb|net.sb|tv|mg|srl|fm|sc|org.sb|biz.ki|org.ki|je|info.ki|net.sc|com.sc|durban|joburg|cc|capetown|sh|org.sc|ly|com.ly|ms|so|st|xyz|north-kazakhstan.su|nov|nov.su|ru.com|ru.net|com.ru|net.ru|org.ru|pp|pp.ru|msk.ru|msk|msk.su|spb|spb.ru|spb.su|tselinograd.su|ashgabad.su|abkhazia.su|adygeya.ru|adygeya.su|arkhangelsk.su|azerbaijan.su|balashov.su|bashkiria.ru|bashkiria.su|bir|bir.ru|bryansk.su|obninsk.su|penza.su|pokrovsk.su|pyatigorsk.ru|sochi.su|tashkent.su|termez.su|togliatti.su|troitsk.su|tula.su|tuva.su|vladikavkaz.su|vladikavkaz.ru|vladimir.ru|vladimir.su|spb.su|tatar|com.ua|kiev.ua|co.ua|biz.ua|pp.ua|am|co.am|com.am|net.am|org.am|net.am|radio.am|armenia.su|georgia.su|com.kz|bryansk.su|bukhara.su|cbg|cbg.ru|dagestan.su|dagestan.ru|grozny.su|grozny.ru|ivanovo.su|kalmykia.ru|kalmykia.su|kaluga.su|karacol.su|karelia.su|khakassia.su|krasnodar.su|kurgan.su|lenug.su|com.ua|ru.com|ялта.рф|тарханкут.рф|симфи.рф|севастополь.рф|ореанда.рф|массандра.рф|коктебель.рф|казантип.рф|инкерман.рф|евпатория.рф|донузлав.рф|балаклава.рф|vologda.su|org.kz|aktyubinsk.su|chimkent.su|east-kazakhstan.su|jambyl.su|karaganda.su|kustanal.ru|mangyshlak.su|kiev.ua|co.ua|biz.ua|radio.am|nov.ru|navoi.sk|nalchik.su|nalchik.ru|mystis.ru|murmansk.su|mordovia.su|mordovia.ru|marine.ru|tel|aero|mobi|xxx|aq|ax|az|bb|ba|be|bg|bi|bj|bh|bo|bs|bt|ca|cat|cd|cf|cg|ch|ci|ck|co.ck|co.ao|co.bw|co.id|id|co.fk|co.il|co.in|il|ke|ls|co.ls|mz|no|co.mz|co.no|th|tz|co.th|co.tz|uz|uk|za|zm|zw|co.uz|co.uk|co.za|co.zm|co.zw|ar|au|cy|eg|et|fj|gt|gu|gn|gh|hk|jm|kh|kw|lb|lr|com.ai|com.ar|com.au|com.bd|com.bn|com.br|com.cn|com.cy|com.eg|com.et|com.fj|com.gh|com.gu|com.gn|com.gt|com.hk|com.jm|com.kh|com.kw|com.lb|com.lr|com.|com.|bd|mt|mv|ng|ni|np|nr|om|pa|py|qa|sa|sb|sg|sv|sy|tr|tw|ua|uy|ve|vi|vn|ye|coop|com.mt|com.mv|com.ng|com.ni|com.np|com.nr|com.om|com.pa|com.pl|com.py|com.qa|com.sa|com.sb|com.sv|com.sg|com.sy|com.tr|com.tw|com.ua|com.uy|com.ve|com.vi|com.vn|com.ye|cr|cu|cx|cv|cz|de|de.com|dj|dk|dm|do|dz|ec|edu|ee|es|eu|eu.com|fi|fo|fr|qa|qd|qf|gi|gl|gm|gp|gr|gs|gy|hk|hm|hr|ht|hu|ie|im|in|in.ua|io|ir|is|it|je|jo|jobs|jp|kg|ki|kn|kr|la|li|lk|lt|lu|lv|ly|ma|mc|md|me.uk|mg|mk|mo|mp|ms|mu|museum|mw|mx|my|na|nc|ne|nl|no|nf|nu|pe|ph|pk|pl|pn|pr|ps|pt|re|ro|rs|rw|sd|se|sg|sh|si|sk|sl|sm|sn|so|sr|st|sz|tc|td|tg|tj|tk|tl|tn|to|tt|tw|ug|us|vg|vn|vu|ws)";
            Regex rgx = new Regex(pattern, RegexOptions.IgnoreCase);            
            return rgx.Replace(text, "").Trim();            
		}		

		#endregion
		
		#region Config        
		
		private void Init() 
		{
			LoadVariables();
			
			if (configData.BadList == null)
			{
				configData.BadList = new List<string>() 
				{ 
					"#MAGICRUST", "MAGICRUST", "MagicRust", "MAGIC RUST", "Magic Rust", 
					"GRANDRUST", "GRAND-RUST", "Grand-rust", "Grand-Rust", "grand rust", "grand-rust",
					"rustchance.com", "Rustchance.com", "RustChance.com", "rustchance", "RustChance", "RUSTCHANCE",
					"RustyPot.com", "Rustypot.com", "rustypot.com", "RustyPot", "rustypot",
					"Rustlife", "RustLife", "rustlife", 
					"LUCKYRUST", "EliteRust", "DIAMOND-RUST", "TRADEIT.GG"
				};
				SaveConfig(configData);
			}
		}
		
        private static ConfigData configData;
		
        private class ConfigData
        {            
			[JsonProperty(PropertyName = "Удалять ссылки с имен")]
			public bool IsDelLinks;
			[JsonProperty(PropertyName = "Заменять в именах угловые скобки на безопасные")]
			public bool IsNoHtmlTags;
			[JsonProperty(PropertyName = "Считать имя нормальным если есть такое число последовательных нормальных символов")]
			public int GoodLenChars;
			[JsonProperty(PropertyName = "Разрешенный процент плохих символов в имени")]
			public int BadPercent;
			[JsonProperty(PropertyName = "Запрещенные фразы")]
			public List<string> BadList;
        }
		
        private void LoadVariables() => configData = Config.ReadObject<ConfigData>();        
		
        protected override void LoadDefaultConfig()
        {
            configData = new ConfigData
            {
                IsDelLinks = false,
				IsNoHtmlTags = true,
				GoodLenChars = 4,
				BadPercent = 50,
				BadList = new List<string>() 
				{ 
					"#MAGICRUST", "MAGICRUST", "MagicRust", "MAGIC RUST", "Magic Rust", 
					"GRANDRUST", "GRAND-RUST", "Grand-rust", "Grand-Rust", "grand rust", "grand-rust",
					"rustchance.com", "Rustchance.com", "RustChance.com", "rustchance", "RustChance", "RUSTCHANCE",
					"RustyPot.com", "Rustypot.com", "rustypot.com", "RustyPot", "rustypot",
					"Rustlife", "RustLife", "rustlife", 
					"LUCKYRUST", "EliteRust", "DIAMOND-RUST", "TRADEIT.GG"
				}				
            };
            SaveConfig(configData);
			timer.Once(0.1f, ()=> SaveConfig(configData));
        }        
		
        private void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
		
        #endregion
		
	}
	
}	

// --- End of file: FineName.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BlackJack.cs ---
// --- Original Local Path: BlackJack.cs ---

﻿//Requires: Casino
using Newtonsoft.Json;
using Oxide.Game.Rust.Cui;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("BlackJack", "k1lly0u", "0.1.2")]
    [Description("A Black Jack card game used with the Casino plugin")]
    class BlackJack : RustPlugin
    {
        #region Fields
        public static BlackJack Instance { get; private set; }       
        #endregion

        #region Oxide Hooks
        private void Loaded()
        {
            Instance = this;
            lang.RegisterMessages(Messages, this);
        }

        private void OnServerInitialized()
        {
            Casino.Instance.RegisterGame(Casino.GameType.BlackJack, InitializeGame);
        }

        private void Unload()
        {
            Casino.Instance?.UnregisterGame(Casino.GameType.BlackJack);
            Instance = null;
        }
        #endregion

        #region Functions
        private void InitializeGame(BaseEntity table, Casino.StoredData.GameData gameData)
        {
            BlackJackGame blackjackGame = table.gameObject.AddComponent<BlackJackGame>();
            blackjackGame.InitializeGame(gameData);
        }
        #endregion

        #region Game Manager
        private const string GAME_BG = "blackjack.background";

        private const string PLAYER_OVERLAY = "blackjack.players";

        private const string BALANCE_OVERLAY = "blackjack.balance";

        private const string BETTING_OVERLAY = "blackjack.betting";

        private const string MESSAGE_OVERLAY = "blackjack.message";

        private const string NOTIFICATION_OVERLAY = "blackjack.notification";

        private const string PLAY_OVERLAY = "blackjack.play";

        private const string STATUS_OVERLAY = "blackjack.status";

        private static string BLACK_COLOR = Casino.UI.Color("000000", 0.7f);

        public class BlackJackGame : Casino.CardGame
        {            
            private BlackJackAI DealerAI; 

            private Casino.Deck deck = new Casino.Deck();

            private CuiElementContainer backgroundContainer;

            private Dictionary<string, CuiElementContainer> containers = new Dictionary<string, CuiElementContainer>();

            private int playerIndex = -1;

            internal readonly Casino.UI4[] cardPositions = new Casino.UI4[]
            {
                new Casino.UI4(0.315f, 0.15f, 0.38f, 0.33f),
                new Casino.UI4(0.55f, 0.15f, 0.615f, 0.33f),
                new Casino.UI4(0.1f, 0.25f, 0.165f, 0.43f),
                new Casino.UI4(0.765f, 0.25f, 0.83f, 0.43f),
                new Casino.UI4(0.435f, 0.7f, 0.5f, 0.88f)
            };
            
            public override void OnPlayerEnter(BasePlayer player, int position)
            {
                BlackJackPlayer blackjackPlayer = player.gameObject.AddComponent<BlackJackPlayer>();
                cardPlayers[position] = blackjackPlayer;

                blackjackPlayer.Position = position;

                blackjackPlayer.AddUI(GAME_BG, backgroundContainer);
                                
                if (gameState == Casino.GameState.Waiting)
                {
                    CreatePlayerUI();

                    if (CurrentPlayerCount == 1)
                    {
                        CreateUIMessage(string.Format(msg("UI.Notification.StartsIn"), 10));

                        if (!InvokeHandler.IsInvoking(this, PlaceBets))
                            InvokeHandler.Invoke(this, PlaceBets, 10f);
                    }
                    else CreateUIMessage(msg("UI.Notification.IsStarting"));
                }
                else
                {
                    if (gameState == Casino.GameState.PlacingBets)
                    {
                        CreatePlayerUI();

                        CreateUIMessage(blackjackPlayer, msg("UI.Notification.UsersPlacingBets"));

                        for (int i = 0; i < cardPlayers.Length; i++)
                        {
                            Casino.CardPlayer cardPlayer = cardPlayers[i];
                            if (cardPlayer == null || !cardPlayer.IsPlaying)
                                continue;

                            PlaceBets(cardPlayer as BlackJackPlayer);
                        }
                    }
                    else if (gameState == Casino.GameState.Prestart)
                    {
                        CreatePlayerUI(true);

                        CreateUIMessage(blackjackPlayer, msg("UI.Notification.GameInProgress"));

                        foreach (KeyValuePair<string, CuiElementContainer> kvp in containers)
                            blackjackPlayer.AddUI(kvp.Key, kvp.Value);
                    }
                    else
                    {
                        CreateUIMessage(blackjackPlayer, msg("UI.Notification.GameInProgress"));

                        foreach (KeyValuePair<string, CuiElementContainer> kvp in containers)
                            blackjackPlayer.AddUI(kvp.Key, kvp.Value);

                        CreatePlayerUI(blackjackPlayer, true);
                    }
                }
            }

            public override void OnPlayerExit(BasePlayer player)
            {
                BlackJackPlayer blackjackPlayer = player.GetComponent<BlackJackPlayer>();
                if (blackjackPlayer == null)
                    return;

                OnPlayerExit(blackjackPlayer);
            }

            private void OnPlayerExit(BlackJackPlayer blackjackPlayer)
            {                
                if (blackjackPlayer.Position < 0 || blackjackPlayer.Position > cardPlayers.Length)
                {
                    int index = System.Array.IndexOf(cardPlayers, blackjackPlayer);
                    if (index != -1)
                        cardPlayers[index] = null;
                }
                else cardPlayers[blackjackPlayer.Position] = null;

                CreateUIMessageOffset(string.Format(msg("UI.Notification.LeftGame"), blackjackPlayer.Player.displayName), 5f);

                Destroy(blackjackPlayer);

                if (CurrentPlayingCount == 0 && gameState != Casino.GameState.Waiting)
                {
                    ResetGame();
                    return;
                }

                if (gameState == Casino.GameState.Playing)
                {
                    CreatePlayerUI(true);

                    if (playerIndex == blackjackPlayer.Position)
                    {
                        timer.StopTimer();
                        InvokeHandler.Invoke(this, NextPlayerTurn, 2f);
                    }
                    else
                    {
                        Casino.CardPlayer currentPlayer = cardPlayers[playerIndex];

                        if (currentPlayer != null && currentPlayer.IsPlaying)
                            CreatePlayOverlay(currentPlayer as BlackJackPlayer);
                    }
                }
                else
                {
                    if (gameState == Casino.GameState.PlacingBets)
                    {
                        for (int i = 0; i < cardPlayers.Length; i++)
                        {
                            Casino.CardPlayer cardPlayer = cardPlayers[i];
                            if (cardPlayer == null || !cardPlayer.IsPlaying)
                                continue;

                            PlaceBets(cardPlayer as BlackJackPlayer);
                        }
                    }
                    else CreatePlayerUI(gameState == Casino.GameState.Prestart);
                }
            }

            public override void OnGameInitialized()
            {
                this.gameType = Casino.GameType.BlackJack;

                DealerAI = new GameObject("Blackjack_Dealer").AddComponent<BlackJackAI>();
                DealerAI.Position = 4;
                DealerAI.RegisterCardGame(this);

                base.OnGameInitialized();

                backgroundContainer = Casino.UI.ElementContainer(GAME_BG, Casino.UI4.FullScreen, true);
                Casino.UI.Image(ref backgroundContainer, GAME_BG, PlayingCards.GetBoardImage("blackjack"), Casino.UI4.FullScreen);                
            }

            private void ResetGame()
            {
                timer.StopTimer();

                DealerAI.ResetHand();

                for (int i = 0; i < cardPlayers.Length; i++)
                {
                    Casino.CardPlayer cardPlayer = cardPlayers[i];
                    if (cardPlayer != null)
                        cardPlayer.ResetHand();
                }

                playerIndex = -1;

                InvokeHandler.CancelInvoke(this, PlaceBets);

                InvokeHandler.CancelInvoke(this, PreStartRound);

                InvokeHandler.CancelInvoke(this, StartRound);

                InvokeHandler.CancelInvoke(this, NextPlayerTurn);

                InvokeHandler.CancelInvoke(this, DealerAI.PlayTurn);

                InvokeHandler.CancelInvoke(this, FinalizeGame);

                InvokeHandler.CancelInvoke(this, ResetGame);                

                DestroyUIElements();
                
                gameState = Casino.GameState.Waiting;

                deck.Shuffle();

                if (CurrentPlayerCount > 0)
                {
                    CreatePlayerUI();

                    CreateUIMessage(string.Format(msg("UI.Notification.StartsIn"), 5));

                    InvokeHandler.Invoke(this, PlaceBets, 5f);
                }
            }

            private void CreatePlayerUI(bool betsLocked = false)
            {
                CuiElementContainer container = CreatePlayerUIElement(betsLocked);

                AddUIElement(PLAYER_OVERLAY, container, false);                
            }

            private void CreatePlayerUI(Casino.CardPlayer targetPlayer, bool betsLocked = false)
            {
                CuiElementContainer container = CreatePlayerUIElement(betsLocked);

                targetPlayer.AddUI(PLAYER_OVERLAY, container);
            }

            private CuiElementContainer CreatePlayerUIElement(bool betsLocked)
            {
                CuiElementContainer container = Casino.UI.ElementContainer(PLAYER_OVERLAY, Casino.UI4.FullScreen);
                Casino.UI4 cardPosition;
                Casino.UI4 position;

                for (int i = 0; i < cardPlayers.Length; i++)
                {
                    Casino.CardPlayer cardPlayer = cardPlayers[i];
                    if (cardPlayers[i] == null)
                        continue;

                    cardPosition = cardPositions[i];
                    position = new Casino.UI4(cardPosition.xMin, cardPosition.yMin - 0.035f, cardPosition.xMin + 0.12f, cardPosition.yMin - 0.01f);
                    Casino.UI.Panel(ref container, PLAYER_OVERLAY, BLACK_COLOR, position);
                    Casino.UI.Label(ref container, PLAYER_OVERLAY, cardPlayer.Player.displayName, 12, position, TextAnchor.MiddleCenter);

                    if (betsLocked)
                    {
                        position = new Casino.UI4(cardPosition.xMin, cardPosition.yMin - 0.065f, cardPosition.xMin + 0.12f, cardPosition.yMin - 0.04f);
                        Casino.UI.Panel(ref container, PLAYER_OVERLAY, BLACK_COLOR, position);
                        Casino.UI.Label(ref container, PLAYER_OVERLAY, cardPlayer.IsPlaying ? string.Format(msg("UI.Player.Bet"), cardPlayer.BetAmount) : msg("UI.Player.PlayingNext"), 12, position, TextAnchor.MiddleCenter);

                        if (Instance.configData.ShowBalance)
                        {
                            CuiElementContainer balance = Casino.UI.ElementContainer(BALANCE_OVERLAY, new Casino.UI4(cardPosition.xMin, cardPosition.yMax + 0.01f, cardPosition.xMin + 0.12f, cardPosition.yMax + 0.035f));
                            Casino.UI.Panel(ref container, BALANCE_OVERLAY, BLACK_COLOR, Casino.UI4.FullScreen);
                            Casino.UI.Label(ref container, BALANCE_OVERLAY, string.Format(msg("UI.Player.BalanceAmount"), cardPlayer.BankBalance, FormatBetString(cardPlayer.Player)), 12, Casino.UI4.FullScreen, TextAnchor.MiddleCenter);
                            cardPlayer.AddUI(BALANCE_OVERLAY, balance);
                        }
                    }
                }

                cardPosition = cardPositions[4];
                position = new Casino.UI4(cardPosition.xMin, cardPosition.yMin - 0.035f, cardPosition.xMin + 0.12f, cardPosition.yMin - 0.01f);
                Casino.UI.Panel(ref container, PLAYER_OVERLAY, BLACK_COLOR, position);
                Casino.UI.Label(ref container, PLAYER_OVERLAY, msg("UI.Dealer"), 12, position);

                Casino.UI.Button(ref container, PLAYER_OVERLAY, BLACK_COLOR, msg("UI.LeaveTable"), 14, new Casino.UI4(0.9f, 0.95f, 0.99f, 0.98f), "blackjack.leavetable");

                return container;
            }

            private void PlaceBets()
            {
                if (CurrentPlayerCount == 0)
                    return;

                DestroyUIElement(MESSAGE_OVERLAY);                

                for (int i = 0; i < cardPlayers.Length; i++)
                {
                    Casino.CardPlayer cardPlayer = cardPlayers[i];
                    if (cardPlayer == null)
                        continue;

                    BlackJackPlayer blackjackPlayer = cardPlayer as BlackJackPlayer;
                    if (blackjackPlayer.BankBalance < gameData.minimumBet)
                    {
                        OnPlayerExit(blackjackPlayer);
                        blackjackPlayer.Player.ChatMessage(msg("Chat.Kicked.NoScrap", blackjackPlayer.Player.UserIDString));                        
                    }
                }

                for (int i = 0; i < cardPlayers.Length; i++)
                {
                    Casino.CardPlayer cardPlayer = cardPlayers[i];
                    if (cardPlayer == null)
                        continue;

                    BlackJackPlayer blackjackPlayer = cardPlayer as BlackJackPlayer;

                    blackjackPlayer.IsPlaying = true;

                    PlaceBets(blackjackPlayer);
                }

                gameState = Casino.GameState.PlacingBets;

                timer.StartTimer(30);

                InvokeHandler.Invoke(this, PreStartRound, 30f);
            }

            internal void PlaceBets(BlackJackPlayer blackjackPlayer)
            {
                blackjackPlayer.DestroyUI(MESSAGE_OVERLAY);

                CuiElementContainer container = Casino.UI.ElementContainer(BETTING_OVERLAY, Casino.UI4.FullScreen);

                if (!blackjackPlayer.BetLocked)
                {
                    Casino.UI.Label(ref container, BETTING_OVERLAY, msg("UI.Notification.PlaceBets"), 20, new Casino.UI4(0.3f, 0.4f, 0.7f, 0.6f));

                    Casino.UI4 chipsPosition = new Casino.UI4(0.385f, 0.36f, 0.615f, 0.44f);
                    Casino.UI.Image(ref container, BETTING_OVERLAY, PlayingCards.GetChipStackImage(), chipsPosition);

                    for (int i = 0; i < 5; i++)
                    {
                        Casino.UI.Button(ref container, BETTING_OVERLAY, new Casino.UI4(chipsPosition.xMin + (i * 0.046f), chipsPosition.yMin, chipsPosition.xMax + (i * 0.046f), chipsPosition.yMax), $"blackjack.bet {i}");
                    }

                    Casino.UI.Panel(ref container, BETTING_OVERLAY, BLACK_COLOR, new Casino.UI4(0.385f, 0.33f, 0.4975f, 0.355f));
                    Casino.UI.Panel(ref container, BETTING_OVERLAY, BLACK_COLOR, new Casino.UI4(0.5005f, 0.33f, 0.615f, 0.355f));
                    Casino.UI.Label(ref container, BETTING_OVERLAY, string.Format(msg("UI.Player.BalanceAmount"), blackjackPlayer.BankBalance, FormatBetString(blackjackPlayer.Player)), 12, new Casino.UI4(0.39f, 0.33f, 0.5f, 0.355f), TextAnchor.MiddleLeft);
                    Casino.UI.Label(ref container, BETTING_OVERLAY, string.Format(msg("UI.Player.BetAmount"), blackjackPlayer.BetAmount), 12, new Casino.UI4(0.505f, 0.33f, 0.615f, 0.355f), TextAnchor.MiddleLeft);
                    Casino.UI.Button(ref container, BETTING_OVERLAY, Casino.UI.Color("#ce422b", 0.7f), " - ", 12, new Casino.UI4(0.6f, 0.33f, 0.615f, 0.355f), "blackjack.deductbet");

                    Casino.UI.Button(ref container, BETTING_OVERLAY, BLACK_COLOR, msg("UI.Player.ResetBet"), 12, new Casino.UI4(0.385f, 0.3f, 0.4975f, 0.325f), "blackjack.bet -1");
                    Casino.UI.Button(ref container, BETTING_OVERLAY, BLACK_COLOR, msg("UI.Player.LockBet"), 12, new Casino.UI4(0.5005f, 0.3f, 0.615f, 0.325f), "blackjack.setbet");
                }
                else
                {
                    bool waitingForBets = false;
                    for (int i = 0; i < cardPlayers.Length; i++)
                    {
                        Casino.CardPlayer cardPlayer = cardPlayers[i];
                        if (cardPlayer == null || !cardPlayer.IsPlaying)
                            continue;

                        if (!cardPlayer.BetLocked)
                        {
                            waitingForBets = true;
                            break;
                        }
                    }

                    if (waitingForBets)
                    {
                        Casino.UI.Label(ref container, BETTING_OVERLAY, msg("UI.Notification.Waiting"), 20, new Casino.UI4(0.3f, 0.45f, 0.7f, 0.55f));
                    }
                    else
                    {
                        InvokeHandler.CancelInvoke(this, PreStartRound);

                        DestroyUIElement(BETTING_OVERLAY);

                        PreStartRound();
                    }
                }
                Casino.UI.Button(ref container, BETTING_OVERLAY, new Casino.UI4(0.9f, 0.95f, 0.99f, 0.98f), "blackjack.leavetable");

                blackjackPlayer.AddUI(BETTING_OVERLAY, container);
            }

            internal void CreateUIMessage(string message)
            {
                CuiElementContainer container = Casino.UI.ElementContainer(MESSAGE_OVERLAY, new Casino.UI4(0.2f, 0.45f, 0.8f, 0.55f));
                Casino.UI.Label(ref container, MESSAGE_OVERLAY, message, 20, Casino.UI4.FullScreen);

                AddUIElement(MESSAGE_OVERLAY, container);
            }

            internal void CreateUIMessage(BlackJackPlayer blackjackPlayer, string message)
            {
                CuiElementContainer container = Casino.UI.ElementContainer(MESSAGE_OVERLAY, new Casino.UI4(0.2f, 0.45f, 0.8f, 0.55f));
                Casino.UI.Label(ref container, MESSAGE_OVERLAY, message, 20, Casino.UI4.FullScreen);

                blackjackPlayer.AddUI(MESSAGE_OVERLAY, container);
            }

            internal void CreateUIMessageOffset(string message, float time)
            {
                CuiElementContainer container = Casino.UI.ElementContainer(NOTIFICATION_OVERLAY, new Casino.UI4(0.3f, 0.89f, 0.7f, 0.97f));
                Casino.UI.Label(ref container, NOTIFICATION_OVERLAY, message, 18, Casino.UI4.FullScreen);

                AddUIElement(NOTIFICATION_OVERLAY, container);

                if (InvokeHandler.IsInvoking(this, () => DestroyUIElement(NOTIFICATION_OVERLAY)))
                    InvokeHandler.CancelInvoke(this, () => DestroyUIElement(NOTIFICATION_OVERLAY));

                InvokeHandler.Invoke(this, () => DestroyUIElement(NOTIFICATION_OVERLAY), time);
            }

            private void PreStartRound()
            {
                timer.StopTimer();

                DestroyUIElement(BETTING_OVERLAY);

                if (gameState != Casino.GameState.PlacingBets || CurrentPlayerCount == 0)
                {
                    ResetGame();
                    return;
                }

                gameState = Casino.GameState.Prestart;

                for (int i = 0; i < cardPlayers.Length; i++)
                {
                    Casino.CardPlayer cardPlayer = cardPlayers[i];
                    if (cardPlayer != null && cardPlayer.IsPlaying)
                    {
                        if (!cardPlayer.BetLocked)
                            cardPlayer.SetBet();
                    }
                }

                CreatePlayerUI(true);

                CreateUIMessage(msg("UI.Notification.BeginsIn"));

                InvokeHandler.Invoke(this, StartRound, 5f);
            }

            private void StartRound()
            {
                ServerMgr.Instance.StartCoroutine(DealCards());
            }
            
            private IEnumerator DealCards()
            {
                DestroyUIElement(MESSAGE_OVERLAY);

                gameState = Casino.GameState.Playing;

                for (int count = 0; count < 2; count++)
                {
                    for (int i = 0; i < cardPlayers.Length; i++)
                    {
                        Casino.CardPlayer cardPlayer = cardPlayers[i];
                        if (cardPlayer != null && cardPlayer.IsPlaying)
                        {
                            DealCard(cardPlayer as BlackJackPlayer);

                            yield return CoroutineEx.waitForSeconds(0.5f);
                        }
                    }

                    DealCard(DealerAI, count == 1);

                    yield return CoroutineEx.waitForSeconds(0.5f);
                }

                if (CurrentPlayingCount == 0)
                    ResetGame();
                else NextPlayerTurn();
            }

            internal void DealCard(BlackJackPlayer blackjackPlayer, bool hidden = false)
            {
                Casino.Card card = deck.DealCard();

                blackjackPlayer.Hit(card);

                int handCount = blackjackPlayer.Count;

                string panel = $"{blackjackPlayer.UID}.card.{handCount}";

                float offset = (float)(handCount - 1) * 0.015f;

                Casino.UI4 cardPosition = cardPositions[blackjackPlayer.Position];

                Casino.UI4 elementPosition = new Casino.UI4(cardPosition.xMin + offset, cardPosition.yMin, cardPosition.xMax + offset, cardPosition.yMax);
               
                CuiElementContainer container = Casino.UI.ElementContainer(panel, elementPosition);
                Casino.UI.Image(ref container, panel, hidden ? PlayingCards.GetCardBackground(Instance.configData.CardColor) : card.GetCardImage(), Casino.UI4.FullScreen);

                AddUIElement(panel, container, true);
            }

            private void NextPlayerTurn()
            {
                if (playerIndex >= 0)
                {
                    Casino.CardPlayer cardPlayer = cardPlayers[playerIndex];
                    if (cardPlayer != null && cardPlayer.IsPlaying)
                    {
                        cardPlayer.DestroyUI(PLAY_OVERLAY);
                    }
                }
               
                playerIndex++;
                UserPlayTurn();
            }

            private void UserPlayTurn()
            {
                timer.StopTimer();

                DestroyUIElement(MESSAGE_OVERLAY);

                if (playerIndex >= cardPlayers.Length)
                {
                    playerIndex = -1;

                    CreateUIMessage(string.Format(msg("UI.Notification.CurrentlyPlaying"), msg("UI.Dealer")));

                    InvokeHandler.Invoke(this, DealerAI.PlayTurn, 5f);                    
                    return;
                }

                Casino.CardPlayer cardPlayer = cardPlayers[playerIndex];
                if (cardPlayer == null || !cardPlayer.IsPlaying)
                {
                    NextPlayerTurn();
                    return;
                }

                if ((cardPlayer as BlackJackPlayer).HasBlackJack())
                {
                    CreateUIMessage(string.Format(msg("UI.Notification.HasBlackJack"), cardPlayer.Player.displayName));
                    InvokeHandler.Invoke(this, NextPlayerTurn, 5f);
                    return;
                }

                CreateUIMessage(string.Format(msg("UI.Notification.CurrentlyPlaying"), cardPlayer.Player.displayName));

                CreatePlayOverlay(cardPlayer as BlackJackPlayer);

                timer.StartTimer(30);

                if (InvokeHandler.IsInvoking(this, NextPlayerTurn))
                    InvokeHandler.CancelInvoke(this, NextPlayerTurn);

                InvokeHandler.Invoke(this, NextPlayerTurn, 30f);
            }

            private void CreatePlayOverlay(BlackJackPlayer blackjackPlayer)
            {
                Casino.UI4 cardPosition = cardPositions[blackjackPlayer.Position];
                Casino.UI4 position = new Casino.UI4(cardPosition.xMin, cardPosition.yMin - 0.095f, cardPosition.xMin + 0.12f, cardPosition.yMin - 0.07f);

                CuiElementContainer container = Casino.UI.ElementContainer(PLAY_OVERLAY, position);

                Casino.UI.Button(ref container, PLAY_OVERLAY, BLACK_COLOR, msg("UI.Player.Hit"), 12, new Casino.UI4(0f, 0f, 0.495f, 1f), "blackjack.hit");
                Casino.UI.Button(ref container, PLAY_OVERLAY, BLACK_COLOR, msg("UI.Player.Stay"), 12, new Casino.UI4(0.505f, 0f, 1f, 1f), "blackjack.stay");

                blackjackPlayer.AddUI(PLAY_OVERLAY, container);
            }
            
            internal void Hit(BlackJackPlayer blackjackPlayer)
            {
                timer.StopTimer();

                DealCard(blackjackPlayer);

                int score = blackjackPlayer.GetScore();

                if (score > 21 || score == 21)                
                    Stay(blackjackPlayer);                
                else UserPlayTurn();
            }

            internal void Stay(BlackJackPlayer blackjackPlayer)
            {
                timer.StopTimer();

                blackjackPlayer.DestroyUI(PLAY_OVERLAY);

                if (blackjackPlayer.IsBusted)
                    CreateUIMessage(string.Format(msg("UI.Notification.HasBust"), blackjackPlayer.Player.displayName));
                else CreateUIMessage(string.Format(msg("UI.Notification.StayingOn"), blackjackPlayer.Player.displayName, blackjackPlayer.GetScore()));
                
                InvokeHandler.Invoke(this, NextPlayerTurn, 5f);
            }

            internal void FinalizeGame()
            {
                DestroyUIElement(MESSAGE_OVERLAY);

                CalculateScores();

                CreateUIMessage(string.Format(msg("UI.Notification.StartsIn"), 5));

                InvokeHandler.Invoke(this, ResetGame, 5f);                
            }

            private void CalculateScores()
            {
                int dealerScore = DealerAI.GetScore();

                CuiElementContainer container = Casino.UI.ElementContainer(STATUS_OVERLAY, Casino.UI4.FullScreen);

                Casino.UI4 cardPosition;
                Casino.UI4 position;

                for (int i = 0; i < cardPlayers.Length; i++)
                {
                    Casino.CardPlayer cardPlayer = cardPlayers[i];
                    if (cardPlayer == null || !cardPlayer.IsPlaying)
                        continue;

                    cardPlayer.DestroyUI(BALANCE_OVERLAY);

                    BlackJackPlayer blackjackPlayer = cardPlayer as BlackJackPlayer;

                    cardPosition = cardPositions[blackjackPlayer.Position];
                    position = new Casino.UI4(cardPosition.xMin, cardPosition.yMax + 0.01f, cardPosition.xMin + 0.12f, cardPosition.yMax + 0.035f);

                    Casino.UI.Panel(ref container, STATUS_OVERLAY, BLACK_COLOR, position);

                    if (blackjackPlayer.IsBusted)    
                        Casino.UI.Label(ref container, STATUS_OVERLAY, msg("UI.Status.Bust"), 12, position);
                    else
                    {
                        int playerScore = blackjackPlayer.GetScore();
                        
                        if (blackjackPlayer.HasBlackJack() && !DealerAI.HasBlackJack())
                        {
                            if (Instance.configData.ShowWinnings)
                                Casino.UI.Label(ref container, STATUS_OVERLAY, string.Format(msg("UI.Status.BlackJack.Amount"), "+" + Mathf.CeilToInt((float)blackjackPlayer.BetAmount * 1.5f)), 12, position);
                            else Casino.UI.Label(ref container, STATUS_OVERLAY, msg("UI.Status.BlackJack"), 12, position);
                            blackjackPlayer.IssueWin(blackjackPlayer.BetAmount + Mathf.CeilToInt((float)blackjackPlayer.BetAmount * 1.5f));
                        }
                        else if (playerScore == dealerScore)
                        {
                            if (Instance.configData.ShowWinnings)
                                Casino.UI.Label(ref container, STATUS_OVERLAY, string.Format(msg("UI.Status.Tie.Amount"), 0), 12, position);
                            else Casino.UI.Label(ref container, STATUS_OVERLAY, msg("UI.Status.Tie"), 12, position);
                            blackjackPlayer.IssueWin(blackjackPlayer.BetAmount);
                        }
                        else if (playerScore > dealerScore || DealerAI.IsBusted)
                        {
                            if (Instance.configData.ShowWinnings)
                                Casino.UI.Label(ref container, STATUS_OVERLAY, string.Format(msg("UI.Status.Win.Amount"), "+" + blackjackPlayer.BetAmount), 12, position);
                            else Casino.UI.Label(ref container, STATUS_OVERLAY, msg("UI.Status.Win"), 12, position);
                            blackjackPlayer.IssueWin(blackjackPlayer.BetAmount * 2);
                        }
                        else if (playerScore < dealerScore)
                        {
                            if (Instance.configData.ShowWinnings)
                                Casino.UI.Label(ref container, STATUS_OVERLAY, string.Format(msg("UI.Status.Lost.Amount"), "-" + blackjackPlayer.BetAmount), 12, position);
                            else Casino.UI.Label(ref container, STATUS_OVERLAY, msg("UI.Status.Lost"), 12, position);
                        }
                    }
                }

                cardPosition = cardPositions[4];
                position = new Casino.UI4(cardPosition.xMin, cardPosition.yMin - 0.065f, cardPosition.xMin + 0.12f, cardPosition.yMin - 0.04f);

                if (DealerAI.IsBusted)
                {
                    Casino.UI.Panel(ref container, STATUS_OVERLAY, BLACK_COLOR, position);
                    Casino.UI.Label(ref container, STATUS_OVERLAY, msg("UI.Status.Bust"), 12, position);
                }
                else if (DealerAI.HasBlackJack())
                {
                    Casino.UI.Panel(ref container, STATUS_OVERLAY, BLACK_COLOR, position);
                    Casino.UI.Label(ref container, STATUS_OVERLAY, msg("UI.Status.BlackJack"), 12, position);
                }

                Casino.UI.Button(ref container, STATUS_OVERLAY, new Casino.UI4(0.9f, 0.95f, 0.99f, 0.98f), "blackjack.leavetable");

                AddUIElement(STATUS_OVERLAY, container);
            }
            
            internal void DestroyUIElement(string str)
            {
                containers.Remove(str);

                for (int i = 0; i < cardPlayers.Length; i++)
                {
                    Casino.CardPlayer cardPlayer = cardPlayers[i];
                    if (cardPlayer == null)
                        continue;

                    cardPlayer.DestroyUI(str);
                }
            }

            internal void DestroyUIElements()
            {
                for (int i = 0; i < cardPlayers.Length; i++)
                {
                    Casino.CardPlayer cardPlayer = cardPlayers[i];
                    if (cardPlayer == null)
                        continue;

                    (cardPlayer as BlackJackPlayer).DestroyUIElements();
                }

                DestroyUIElement(STATUS_OVERLAY);

                containers.Clear();
            }

            internal void AddUIElement(string panel, CuiElementContainer container, bool addToList = false)
            {
                for (int i = 0; i < cardPlayers.Length; i++)
                {
                    Casino.CardPlayer cardPlayer = cardPlayers[i];
                    if (cardPlayer == null)
                        continue;

                    cardPlayer.AddUI(panel, container);
                }

                if (addToList)
                    containers.Add(panel, container);
            }            
        }
        
        internal class BlackJackPlayer : Casino.CardPlayer
        {         
            public bool IsBusted
            {
                get
                {
                    return GetScore() > 21;
                }
            }            
            
            internal void Hit(Casino.Card dealtCard) => hand.Add(dealtCard);

            internal List<Casino.Card> Show() => hand;

            internal Casino.Card LastCard() => hand[hand.Count - 1];

            internal int Count => hand.Count;

            internal override void OnDestroy()
            {
                DestroyCards();
                base.OnDestroy();
            }

            internal override void ResetHand()
            {
                DestroyCards();
                base.ResetHand();
            }

            internal void DestroyCards()
            {
                for (int i = 0; i < hand.Count; i++)
                {
                    string panel = $"{UID}.card.{i + 1}";
                    (CardGame as BlackJackGame).DestroyUIElement(panel);
                }
            }

            internal void DestroyUIElements()
            {
                for (int i = 0; i < uiPanels.Count; i++)
                {
                    string panel = uiPanels[i];
                    if (panel == GAME_BG)
                        continue;

                    DestroyUI(panel);
                }
            }

            internal bool HasBlackJack()
            {
                return hand.Count == 2 && ((hand[0].Value == Casino.CardValue.Ace && (int)hand[1].Value >= 10) || (hand[1].Value == Casino.CardValue.Ace && (int)hand[0].Value >= 10));
            }

            internal int GetScore()
            {            
                if (HasBlackJack())
                    return 21;

                int score = 0;

                int aces = 0;

                for (int i = 0; i < hand.Count; i++)
                {
                    if (hand[i].Value == Casino.CardValue.Ace)
                        aces++;
                    else
                    {
                        if ((int)hand[i].Value > 10)
                            score += 10;
                        else score += (int)hand[i].Value;
                    }
                }

                for (int i = 0; i < aces; i++)
                {
                    if (score > 10)
                        score += 1;
                    else score += 11;
                }
                
                return score;
            }
        }

        private class BlackJackAI : BlackJackPlayer
        {
            private Coroutine playRoutine;

            internal override void Awake()
            {
                GenerateUID();
            }

            internal override void OnDestroy()
            {
                Destroy(this.gameObject);
            }

            internal override void ResetHand()
            {
                if (playRoutine != null)
                    ServerMgr.Instance.StopCoroutine(playRoutine);
                
                base.ResetHand();
            }

            internal void RegisterCardGame(Casino.CardGame cardGame)
            {
                this.CardGame = cardGame;
            }

            public void PlayTurn() => playRoutine = ServerMgr.Instance.StartCoroutine(RunAI());

            public IEnumerator RunAI()
            {
                RevealHiddenCard();

                yield return CoroutineEx.waitForSeconds(0.5f);

                if (!HasBlackJack())
                {
                    while (GetScore() < 17)
                    {
                        (CardGame as BlackJackGame).DealCard(this);
                        yield return CoroutineEx.waitForSeconds(0.5f);
                    }

                    if (IsBusted)
                        (CardGame as BlackJackGame).CreateUIMessage(string.Format(msg("UI.Notification.HasBust"), msg("Dealer")));
                    else (CardGame as BlackJackGame).CreateUIMessage(string.Format(msg("UI.Notification.StayingOn"), msg("Dealer"), GetScore()));
                }
                else (CardGame as BlackJackGame).CreateUIMessage(string.Format(msg("UI.Notification.HasBlackJack"), msg("Dealer")));

                InvokeHandler.Invoke(CardGame, (CardGame as BlackJackGame).FinalizeGame, 5f);
                
                playRoutine = null;
            }

            private void RevealHiddenCard()
            {
                if (hand.Count == 0)
                    return;

                Casino.Card card = hand[1];

                string panel = $"{UID}.card.2";

                (CardGame as BlackJackGame).DestroyUIElement(panel);

                Casino.UI4 cardPosition = (CardGame as BlackJackGame).cardPositions[4];
                Casino.UI4 elementPosition = new Casino.UI4(cardPosition.xMin + 0.015f, cardPosition.yMin, cardPosition.xMax + 0.015f, cardPosition.yMax);

                CuiElementContainer container = Casino.UI.ElementContainer(panel, elementPosition);
                Casino.UI.Image(ref container, panel, card.GetCardImage(), Casino.UI4.FullScreen);

                (CardGame as BlackJackGame).AddUIElement(panel, container, true);                
            }
        }    
        #endregion

        #region Commands
        [ConsoleCommand("blackjack.leavetable")]
        private void ccmdLeaveTable(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            Casino.CardGame cardGame = Casino.Instance.IsGamePlayer(player);
            if (cardGame == null)
                return;

            cardGame.OnPlayerExit(player);
        }

        [ConsoleCommand("blackjack.hit")]
        private void ccmdHit(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            BlackJackPlayer blackjackPlayer = player.GetComponent<BlackJackPlayer>();
            if (blackjackPlayer == null)
                return;

            (blackjackPlayer.CardGame as BlackJackGame).Hit(blackjackPlayer);
        }

        [ConsoleCommand("blackjack.stay")]
        private void ccmdStay(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            BlackJackPlayer blackjackPlayer = player.GetComponent<BlackJackPlayer>();
            if (blackjackPlayer == null)
                return;

            (blackjackPlayer.CardGame as BlackJackGame).Stay(blackjackPlayer);
        }

        [ConsoleCommand("blackjack.bet")]
        private void ccmdBet(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            if (arg.Args == null || arg.Args.Length == 0)
                return;

            BlackJackPlayer blackjackPlayer = player.GetComponent<BlackJackPlayer>();
            if (blackjackPlayer == null)
                return;

            int amount = int.Parse(arg.Args[0]);

            switch (amount)
            {
                case -1:
                    blackjackPlayer.CardGame.ResetBet(blackjackPlayer);
                    break;
                case 0:
                    blackjackPlayer.CardGame.AdjustBet(blackjackPlayer, 1);
                    break;
                case 1:
                    blackjackPlayer.CardGame.AdjustBet(blackjackPlayer, 10);
                    break;
                case 2:
                    blackjackPlayer.CardGame.AdjustBet(blackjackPlayer, 50);
                    break;
                case 3:
                    blackjackPlayer.CardGame.AdjustBet(blackjackPlayer, 100);
                    break;
                case 4:
                    blackjackPlayer.CardGame.AdjustBet(blackjackPlayer, 500);
                    break;                
            }

            (blackjackPlayer.CardGame as BlackJackGame).PlaceBets(blackjackPlayer);
        }

        [ConsoleCommand("blackjack.deductbet")]
        private void ccmdDeductBet(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            BlackJackPlayer blackjackPlayer = player.GetComponent<BlackJackPlayer>();
            if (blackjackPlayer == null)
                return;

            blackjackPlayer.CardGame.AdjustBet(blackjackPlayer, -1);
            (blackjackPlayer.CardGame as BlackJackGame).PlaceBets(blackjackPlayer);
        }

        [ConsoleCommand("blackjack.setbet")]
        private void ccmdSetBet(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            BlackJackPlayer blackjackPlayer = player.GetComponent<BlackJackPlayer>();
            if (blackjackPlayer == null)
                return;

            blackjackPlayer.SetBet();
            (blackjackPlayer.CardGame as BlackJackGame).PlaceBets(blackjackPlayer);
        }
        #endregion

        #region Config        
        private ConfigData configData;
        private class ConfigData
        {
            [JsonProperty("Card Color (blue, gray, green, purple, red, yellow)")]
            public string CardColor { get; set; }

            [JsonProperty("Show Winnings")]
            public bool ShowWinnings { get; set; }

            [JsonProperty("Show Balance")]
            public bool ShowBalance { get; set; }

            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();

            if (configData.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                CardColor = "blue",
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            configData.Version = Version;
            PrintWarning("Config update completed!");
        }
        #endregion

        #region Localization
        private static string msg(string key, string playerId = null) => Instance.lang.GetMessage(key, Instance, playerId);

        private Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            ["UI.Notification.StartsIn"] = "Next game starts in <color=#00E500>{0}</color> seconds!",
            ["UI.Notification.IsStarting"] = "Next game is starting!",
            ["UI.Notification.BeginsIn"] = "Bets are locked! Game starts in <color=#00E500>5</color> seconds...",
            ["UI.Notification.PlaceBets"] = "Place Your Bets!",
            ["UI.Notification.Waiting"] = "Waiting for players to place their bets!",
            ["UI.Notification.CurrentlyPlaying"] = "Currently Playing : <color=#00E500>{0}</color>",
            ["UI.Notification.HasBlackJack"] = "{0} has <color=#00E500>Black Jack!</color>",
            ["UI.Notification.HasBust"] = "{0} has <color=#ce422b>Bust!</color>",
            ["UI.Notification.StayingOn"] = "{0} is staying on <color=#00E500>{1}</color>",
            ["UI.Notification.UsersPlacingBets"] = "Players are placing bets. You will enter the next round!",
            ["UI.Notification.GameInProgress"] = "This round has started. You will enter the next round!",
            ["UI.Notification.LeftGame"] = "<color=#ce422b>{0}</color> has left the game!",

            ["UI.Player.Bet"] = "Bet : {0}",
            ["UI.Player.PlayingNext"] = "Playing Next Round",
            ["UI.Player.BalanceAmount"] = "Balance : {0} {1}",
            ["UI.Player.BetAmount"] = "Bet : {0}",
            ["UI.Player.ResetBet"] = "Set Minimum",
            ["UI.Player.LockBet"] = "Lock Bet",
            ["UI.Player.Hit"] = "Hit",
            ["UI.Player.Stay"] = "Stay",

            ["UI.Dealer"] = "Dealer",
            ["UI.LeaveTable"] = "Leave Table",

            ["UI.Status.Bust"] = "<color=#ce422b>Bust!</color>",
            ["UI.Status.BlackJack"] = "<color=#00E500>Black Jack!</color>",
            ["UI.Status.Tie"] = "Tie!",
            ["UI.Status.Win"] = "<color=#00E500>Win!</color>",
            ["UI.Status.Lost"] = "<color=#ce422b>Lost!</color>",
            ["UI.Status.BlackJack.Amount"] = "<color=#00E500>Black Jack!</color> ({0})",
            ["UI.Status.Tie.Amount"] = "Tie! ({0})",
            ["UI.Status.Win.Amount"] = "<color=#00E500>Win!</color> ({0})",
            ["UI.Status.Lost.Amount"] = "<color=#ce422b>Lost!</color> ({0})",

            ["Chat.Kicked.NoScrap"] = "<color=#D3D3D3>You have run out of scrap to bet with!</color>",
        };
        #endregion
    }
}


// --- End of file: BlackJack.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/IRBench.cs ---
// --- Original Local Path: IRBench.cs ---

using UnityEngine;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("IRBench", "Werkrat", "0.1.0")]
    [Description("Repair without losing durability!")]
    class IRBench : RustPlugin
    {
		protected override void LoadDefaultConfig() {
			//Default is 0.2 - so leave it default by default xD
            Config["ConditionLostOnRepair"] = 0.2;
        }
		
		private float conditionLost;
		
		[HookMethod("OnServerInitialized")]
        private void onServerInitialized() 
		{
			LoadConfig();
			conditionLost = Config.Get<float>("ConditionLostOnRepair");
			
			if (conditionLost >= 1 || conditionLost < 0)
			{
				PrintError("ConditionLostOnRepair setting invalid, resetting to default");
				LoadConfig();
				conditionLost = (float)0.2;
				SaveConfig();
			}
				
			var benches = UnityEngine.Object.FindObjectsOfType<RepairBench>();
            var updated = 0;
			var count = 0;
            foreach (var rbs in benches)
			{
				++count;
				if (rbs.maxConditionLostOnRepair != conditionLost)
				{
					rbs.maxConditionLostOnRepair = conditionLost;
					++updated;
				}
			}
			Puts("Updated [" + updated.ToString() + "/" + count.ToString() + "] repair benches. New condition lost on repair setting: " + conditionLost.ToString());
		}
		[HookMethod("OnEntitySpawned")]
		private void onEntitySpawned(BaseNetworkable ent) 
		{
            if (ent is RepairBench)   
			{
				//Update newly placed repair benches...
				RepairBench entity = ent as RepairBench;
				entity.maxConditionLostOnRepair = conditionLost;
			}
		}
	}
}

// --- End of file: IRBench.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/ThiefAPI.cs ---
// --- Original Local Path: ThiefAPI.cs ---

using System;                      //DateTime
using System.Reflection;           //Required for BindFlag
using System.Data;
using System.Linq;
using System.Collections.Generic;  //Required for Whilelist
using UnityEngine;
//using Rust;
using Oxide.Core;                  //Interface
//using Oxide.Core.Plugins;


namespace Oxide.Plugins
{
	[Info("Thief", "Alphawar", "0.5.0", ResourceId = 1503)]
	[Description("Mod for handling Thief class.")]
    class ThiefAPI : RustPlugin
	{
		///////////////////////////////////////
		///     Config, Values and Data     ///
		///////////////////////////////////////
		//Creates Blank Values to be loaded later
		private int Cooldown;
		private int Pass;
		private int LPchance;
		private int RandomNumber;
		private int DamageTicks;
		private int pickCostFM;
		private int pickCostSE;
		private float DamageAmount;
		private string NotAllowed;
		private string Allowed = "You start to pick the lock.";
		private string Failed;
		private string Success;
		private string MaxedAttempts = "My hands need a rest.";
		private string ChatPrefixColor = "008800";
        private string ChatPrefix = "Server";
		private string PickEnabledMessage = "Lock Pick Mode Enabled";
		private string PickDisabledMessage = "Lock Pick Mode Disabled";
		private string CooldownMessage;
		private bool PickEnabled;
		
		object GetConfig(string menu, string dataValue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
            }
            object value;
            if (!data.TryGetValue(dataValue, out value))
            {
                value = defaultValue;
                data[dataValue] = value;
            }
            return value;  
        }
		
		protected override void LoadDefaultConfig()
		{
			Puts("Creating a new configuration file!");
			Config.Clear();
			LoadVariables();
		}
		
		void LoadVariables() //Stores Default Values, calling GetConfig passing: menu, dataValue, defaultValue
		{
			//Booleans
			PickEnabled = Convert.ToBoolean(GetConfig("Settings", "PickEnabled", false));
			//Ints
			pickCostFM = Convert.ToInt32(GetConfig("Values", "MetalFragCost", 250));
			pickCostSE = Convert.ToInt32(GetConfig("Values", "StoneCost", 150));
			DamageTicks = Convert.ToInt32(GetConfig("Values", "DamageTicks", 50));
			LPchance = Convert.ToInt32(GetConfig("Values", "LPchance", 15));
			Cooldown = Convert.ToInt32(GetConfig("Values", "Cooldown", 25));
			//Floats
			DamageAmount = Convert.ToSingle(GetConfig("Values", "DamageAmount", 0.2f));
			//Strings
			NotAllowed = Convert.ToString(GetConfig("Messages", "NotAllowed", "You are not a thief."));
			Failed = Convert.ToString(GetConfig("Messages", "Failed", "You failed to pick the lock."));
			Success = Convert.ToString(GetConfig("Messages", "Success", "You have gained access to the door."));
			CooldownMessage = Convert.ToString(GetConfig("Messages", "ShortCooldown", "I cant do that right now"));
		}
		
		Hash<ulong, PlayerInfo> Thiefs = new Hash<ulong, PlayerInfo>();
		
        class PlayerInfo
        {
            public string UserId;
            public string Name;

            public PlayerInfo()
            {
            }

            public PlayerInfo(BasePlayer player)
            {
                UserId = player.userID.ToString();
                Name = player.displayName;
            }

            public ulong GetUserId()
            {
                ulong user_id;
                if (!ulong.TryParse(UserId, out user_id)) return 0;
                return user_id;
            }
        }
		
		class StoredData
		{
			public Dictionary<ulong, double> canpick = new Dictionary<ulong, double>();
			public HashSet<PlayerInfo> Thiefs = new HashSet<PlayerInfo>();
			
			public StoredData()
            {
            }
		}
		
		StoredData storedData;
		
		///////////////////////////////
		///   plugin initiation     ///
		///////////////////////////////
		System.Reflection.FieldInfo whitelistPlayers = typeof(CodeLock).GetField("whitelistPlayers", BindingFlags.NonPublic | BindingFlags.Instance);
		
        private void Loaded()
        {
			LoadVariables();
			if (!permission.PermissionExists("ThiefAPI.can"))
			{
				permission.RegisterPermission("ThiefAPI.can", this);
				Puts("ThiefAPI.can permission registered");
				Puts("only people with permission ThiefAPI.can can apply for the role");
			}
            storedData = Interface.GetMod().DataFileSystem.ReadObject<StoredData>("ThiefAPI"); 
        }
		
		[ChatCommand("lp")]
		void picklock(BasePlayer player, string cmd, string[] args)
		{
			if (!IsAllowed(player, "ThiefAPI.can", NotAllowed)) return;
			
			if (Thiefs[player.userID] != null)
			{
				DisableThiefMode(player);
				SendChatMessage(player, PickDisabledMessage);
			}
			else
			{
				EnableThiefMode(player);
				SendChatMessage(player, PickEnabledMessage);
			}
			
		}
		[ChatCommand("lpwipe")]
		void picklockwipe(BasePlayer player, string cmd, string[] args)
		{
			if (!IsAllowed(player, "ThiefAPI.can", NotAllowed)) return;
			storedData.canpick.Clear();
			Interface.GetMod().DataFileSystem.WriteObject("ThiefAPI", storedData);
		}
		
		object CanUseDoor(BasePlayer player, BaseLock codeLock)
		{
			ulong steamID = player.userID;
			double nextpicktime;
			//bool canBeThief;
			bool PassFail;
			if (!IsAllowed(player, "ThiefAPI.can","null")) return null;
            //SendChatMessage(player, NotAllowed);
			if (Thiefs[player.userID] != null){
				
				if (!storedData.canpick.TryGetValue(steamID, out nextpicktime))
				{
					SendChatMessage(player, "UserDataCreated");
					storedData.canpick.Add(steamID, GetTimeStamp() + Cooldown);
					Interface.GetMod().DataFileSystem.WriteObject("ThiefAPI", storedData);
				}
				
				if (codeLock is CodeLock)
				{
					List<ulong> whitelist = (List<ulong>)whitelistPlayers.GetValue(codeLock);
					if (whitelist.Contains(player.userID))
					{
						SendChatMessage(player, "You have the code");
						return null;
					}
				}
				
				if (GetTimeStamp() < nextpicktime)
				{
					int nexttele = Convert.ToInt32(GetTimeStamp() - nextpicktime);
					SendChatMessage(player, CooldownMessage);
					return null;
				}
				bool lockPickCostPass=lockPickCost(player);
				if (lockPickCostPass==true)
				{
					string debugmessage = Convert.ToString(lockPickCostPass);
					storedData.canpick[steamID] = GetTimeStamp() + Cooldown;
					Interface.GetMod().DataFileSystem.WriteObject("ThiefAPI", storedData);
					bool Pass=LPRoll();
					if (Pass==true)
					{
						SendChatMessage(player, Success);
						return true;
					}
					else
					{
						SendChatMessage(player, Failed);
						timer.Repeat(0.2f, DamageTicks, () =>
						{
							player.Hurt(DamageAmount);
						});
						return false;
					}
				}
			}
			return null;
		}

		
		///////////////////////////////
		///      plugin Logic       ///
		///////////////////////////////
		
		private bool lockPickCost(BasePlayer player)
        {
            int playerFM = player.inventory.GetAmount(688032252); // Frag metal
            int playerRk = player.inventory.GetAmount(3506021); // Spawn rock
            int playerSE = player.inventory.GetAmount(-892070738); // Stones
            {
                if ((playerFM >= pickCostFM) && (playerRk >= 1) && (playerSE >= pickCostSE)) // buyFlare/buyTarget is my config option for amount
                {
                    player.inventory.Take(null, 688032252, pickCostFM); // Take the specified amount of item
                    player.inventory.Take(null, -892070738, pickCostSE);
                    //callPaymentStrike(player); // Run function, not yet needed, may use to run code, as it only returns true or false atm.
                    return true;
                }
				else 
				{
					SendChatMessage(player, "You Dont have the inventory");
					return false;
				}
            }
		}

		bool LPRoll()
		{
			//create logic to roll LP pass/fail
			RandomNumber = UnityEngine.Random.Range(0, 101);
			if (RandomNumber < LPchance)
			{
				return true;
			}
			return false;
		}
		bool IsAllowed(BasePlayer player, string perm, string reason)
        {
            if (permission.UserHasPermission(player.userID.ToString(), perm)) return true;
			if (reason != "null")
				SendChatMessage(player, reason);
            return false;
        }

		double GetTimeStamp()
		{
			return (DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1))).TotalSeconds ;
		}
		
        void DisableThiefMode(BasePlayer player)
        {
            storedData.Thiefs.RemoveWhere(info => info.GetUserId() == player.userID);
            Thiefs.Remove(player.userID);
        }
		
        void EnableThiefMode(BasePlayer player)
        {
            var info = new PlayerInfo(player);
            storedData.Thiefs.Add(info);
            Thiefs[player.userID] = info;
        }
		
		//Function to send messages to player
		void SendChatMessage(BasePlayer player, string message, string args = null) => PrintToChat(player, $"<color={ChatPrefixColor}>{ChatPrefix}</color>: {message}", args);
	}
}

// --- End of file: ThiefAPI.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Broadcaster.cs ---
// --- Original Local Path: Broadcaster.cs ---

using System.Collections.Generic;
using Oxide.Core.Configuration;
using Oxide.Core;
using System;

namespace Oxide.Plugins
{
    [Info("Broadcaster", "Oxide Россия - oxide-russia.ru", "1.1.15")]

    class Broadcaster : RustPlugin
    {

        #region Global Variables

        string usagePerm = "broadcaster.hide";
        string joinIcon = "[ <color=#66ff66>+</color> ]";
        string leaveIcon = "[ <color=#c12c34>-</color> ]";
        string firstMessageFormat;
        string joinMessageFormat;
        string leaveMessageFormat;
        string motdMessage;
        string motdColour;
        bool motdEnabled;
        bool onlineCommand;
        bool joinLeaveIcons;
        string joinColour;
        string firstJoinColour;
        string leaveColour;
        string nameColour;
        string broadcastPrefix;
        bool broadcastPrefixEnabled;
        string broadcastPrefixColour;
        bool broadcastRandomMessages;
        int broadcastInterval;
        Timer autoBroadcastTimer;
        List<object> broadcastMessages = new List<object>();

        StoredData storedData;
        string DataFile = "Join_Data";
        string errorColour = "#FFFFFF";
        string mainColour = "#f4b342";
        string mainPrefix = "<color=#FFC040>[Broadcaster]</color>";

        #endregion


        void Init()
        {
            openDataFile();
            LoadDefaultMessages();
            RegisterPermissions();
            initGlobals();
            LoadConfig();
            foreach (BasePlayer p in BasePlayer.activePlayerList)
                if (getPlayerInfo(p) != null)
                    addNewPlayer(p, false);
        }

        void Loaded()
        {
            if (broadcastRandomMessages)
                startTimer(broadcastInterval);
        }


        #region Player Commands

        [ChatCommand("who")]
        void OnCommandWho(BasePlayer sender, string command, string[] args) => OnCommandPlayers(sender, command, args);

        [ChatCommand("online")]
        void OnCommandOnline(BasePlayer sender, string command, string[] args) => OnCommandPlayers(sender, command, args);

        [ChatCommand("players")]
        void OnCommandPlayers(BasePlayer sender, string command, string[] args)
        {
            if (!onlineCommand) return;
            string playerList = color(mainColour, "Онлайн игроки:");

            foreach (BasePlayer player in BasePlayer.activePlayerList)
                playerList += $"\n- {player.displayName}";

            if (BasePlayer.activePlayerList.Count < 20)
                PrintToChat(sender, playerList);
            else
                PrintToChat(sender, "Список игроков слишком длинный для чата. \n Нажмите F1, затем снова введите /players в чате, затем F1, чтобы посмотреть полный список игроков.");
            sender.Command("echo", $"{playerList}");
        }

        #endregion


        #region Admin Commands

        [ChatCommand("whois")]
        void OnCommandWhois(BasePlayer sender, string command, string[] args)
        {
            if (!sender.IsAdmin) { sendMessage(sender, "NoPermission"); return; }

            BasePlayer target = getPlayer(args[0]);
            showPlayerInfo(target, sender);
        }

        [ChatCommand("forcebroadcast")]
        void OnCommandForce(BasePlayer sender, string command, string[] args)
        {
            if (!sender.IsAdmin) { sendMessage(sender, "NoPermission"); return; }
            broadcastRandomMessage();
        }

        [ChatCommand("bc")]
        void OnCommandAp(BasePlayer sender, string command, string[] args)
        {
            if (!sender.IsAdmin) { sendMessage(sender, "NoPermission"); return; }

            if (args.Length < 1)
            {
                sendError(sender, "Используйте /bc reload", "/bc reload");
                return;
            }

            if (args[0] == "reload")
            {
                sendMessage(sender, "Конфиг Перезагружен");
                LoadConfig();
                autoBroadcastTimer.Destroy();
                initGlobals();
                startTimer(broadcastInterval);
                SaveConfig();
                return;
            }
        }

        #endregion


        #region Auto Broadcast

        void startTimer(int interval)
        {
            autoBroadcastTimer = timer.Every(interval, broadcastRandomMessage);
        }

        void broadcastRandomMessage()
        {
            foreach (BasePlayer p in BasePlayer.activePlayerList)
                PrintToChat(p, getMessageFormat(p, "AutoBroadcast"));
        }
        int CurrentNum = -1;
        string getRandomBroadcast()
        {
            CurrentNum++;
            if (CurrentNum >= broadcastMessages.Count)
                CurrentNum = 0;
            return (string)broadcastMessages[CurrentNum];
        }

        #endregion


        #region Join / Leave Messages

        void OnPlayerInit(BasePlayer player)
        {
            addNewPlayer(player);
            sendJoinMessage(player);
            if (motdEnabled)
                sendMOTD(player);
            updatePlayerInfo(player);
        }

        void updatePlayerInfo(BasePlayer player)
        {
            PlayerInfo playerInfo = getPlayerInfo(player);
            playerInfo.displayName = player.displayName;
            playerInfo.addAlias(player.displayName);
            playerInfo.ipAddress = player.net.connection.ipaddress;
            writeFile();
        }

        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            sendLeaveMessage(player);
        }

        void sendJoinMessage(BasePlayer player)
        {
            if (permission.UserHasPermission(player.UserIDString, usagePerm))
                return;
            string text = getMessageFormat(player, "Join");
            foreach (BasePlayer p in BasePlayer.activePlayerList)
                PrintToChat(p, text);
        }

        void sendLeaveMessage(BasePlayer player)
        {
            if (permission.UserHasPermission(player.UserIDString, usagePerm))
                return;

            string text = getMessageFormat(player, "Leave");
            foreach (BasePlayer p in BasePlayer.activePlayerList)
                PrintToChat(p, text);
        }

        void sendMOTD(BasePlayer player)
        {
            string text = getMessageFormat(player, "Motd");
            PrintToChat(player, text);
        }

        #endregion


        #region Player Information

        void showPlayerInfo(BasePlayer player, BasePlayer sender)
        {
            PlayerInfo playerInfo = getPlayerInfo(player);
            string names = "\n";
            foreach (string name in playerInfo.Aliases)
                names += $"- {name}\n";

            string message = $"Информация об игроке: {color("#FFC040", player.displayName)}." +
                $"\nID Игрока: {color("#66ff66", playerInfo.userID.ToString())}\nОперационная система: {color("#66ff66", player.net.connection.os)}\nIP Адресс: {color("#66ff66", player.net.connection.ipaddress)}\nПсевдонимы:{color("#66ff66", names)}";
            PrintToChat(sender, message);
        }

        void addNewPlayer(BasePlayer player, bool firstTime = true)
        {
            if (getPlayerInfo(player) != null)
                return;
            var playerInfo = new PlayerInfo(player.displayName, player.userID);
            playerInfo.newPlayer = firstTime;
            storedData.Players.Add(playerInfo);
            Puts("[BC] Новый игрок добавлен.");
            writeFile();
        }

        #endregion


        #region Config, Saved Data & Helpers

        void RegisterPermissions()
        {
            permission.RegisterPermission(usagePerm, this);
        }

        void initGlobals()
        {
            LoadConfig();
            firstMessageFormat = (string)Config["Формат сообщения о первом присоеденение игрока"];
            joinMessageFormat = (string)Config["Формат сообщения при подключение игрока"];
            leaveMessageFormat = (string)Config["Формат сообщения при отключение игрока"];
            joinLeaveIcons = (bool)Config["Использование иконок"];
            onlineCommand = (bool)Config["Включить команды /players /who /online"];
            joinColour = (string)Config["Цвет сообщения подключения игрока"];
            leaveColour = (string)Config["Цвет сообщения об отключение игрока"];
            firstJoinColour = (string)Config["Цвет сообщения для первого присоединения игрока"];
            nameColour = (string)Config["Цвет имени игрока"];
            motdEnabled = (bool)Config["Включение MOTD"];
            motdMessage = (string)Config["MOTD"];
            motdColour = (string)Config["Цвет MOTD"];
            broadcastMessages = (List<object>)Config["Автоматические сообщения"];
            broadcastPrefix = (string)Config["Префикс"];
            broadcastPrefixEnabled = (bool)Config["Включить префикс новостей"];
            broadcastPrefixColour = (string)Config["Цвет префикса сообщений"];
            broadcastRandomMessages = (bool)Config["Включить автоматические сообщения в чат"];
            broadcastInterval = (int)Config["Интервал сообщений"];
        }

        protected override void LoadDefaultConfig()
        {
            Config["Использование иконок"] = true;
            Config["Включить команды /players /who /online"] = true;
            Config["Цвет сообщения подключения игрока"] = "#FFFFFF";
            Config["Формат сообщения при подключение игрока"] = "{PLAYER} присоединился к игре.";
            Config["Цвет имени игрока"] = "#FFC040";
            Config["Цвет сообщения об отключение игрока"] = "#FFFFFF";
            Config["Цвет сообщения для первого присоединения игрока"] = "#FFFFFF";
            Config["Формат сообщения при отключение игрока"] = "{PLAYER} вышел с игры.";
            Config["Формат сообщения о первом присоеденение игрока"] = "{PLAYER} присоединился к нам первый раз!";
            Config["Включение MOTD"] = true;
            Config["Цвет MOTD"] = "#FFFFFF";
            Config["MOTD"] = "Привет, {PLAYER}!{LINE}Не забывай посещать нашу группу Вконтакте!{LINE}http://vk.com/groupname";
            Config["Автоматические сообщения"] = GenerateDefaultBroadcastMessages();
            Config["Включить префикс новостей"] = true;
            Config["Префикс"] = "[Префикс]";
            Config["Цвет префикса сообщений"] = "#66ff66";
            Config["Включить автоматические сообщения в чат"] = true;
            Config["Интервал сообщений"] = 90;
            SaveConfig();
        }

        List<string> GenerateDefaultBroadcastMessages()
        {
            List<string> defaultMessages = new List<string>
            {
                "Добро пожаловать на мой сервер! Хорошо провести время.",
                "Не забывайте посетить наш магазин: http://domianname.ru",
                "У нас есть наборы для игроков, используйте /kit"
            };
            return defaultMessages;
        }

        void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoPermission"] = "У тебя нету доступа к этой команде.",
                ["Arguments"] = "Ошибка, используйте {0}",
                ["Reloaded"] = "Конфигурация успешно загружена."
            }, this);
        }

        string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        void writeFile() { Interface.Oxide.DataFileSystem.WriteObject(DataFile, storedData); }

        void openDataFile() { storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(DataFile); }

        #endregion


        #region Formatting

        string color(string color, string text)
        {
            return $"<color={color}>{text}</color>";
        }

        string getMessageFormat(BasePlayer player, string type)
        {
            PlayerInfo playerInfo = getPlayerInfo(player);
            if (type == "Join")
            {
                if (playerInfo.newPlayer)
                {
                    string message = firstMessageFormat.Replace("{PLAYER}", $"{color(nameColour, player.displayName)}");
                    getPlayerInfo(player).newPlayer = false;
                    writeFile();
                    if (joinLeaveIcons)
                        return $"{joinIcon} {color(firstJoinColour, message)}";
                    return $"{message}";
                }
                else
                if (!playerInfo.newPlayer)
                {
                    string message = joinMessageFormat.Replace("{PLAYER}", $"{color(nameColour, player.displayName)}");
                    if (joinLeaveIcons)
                        return $"{joinIcon} {color(joinColour, message)}";
                    return $"{message}";
                }
            }
            else
            if (type == "Leave")
            {
                string message = leaveMessageFormat.Replace("{PLAYER}", $"{color(nameColour, player.displayName)}");
                if (joinLeaveIcons)
                    return $"{leaveIcon} {color(leaveColour, message)}";
                return $"{message}";
            }
            else
            if (type == "Motd")
            {
                string message = motdMessage.Replace("{PLAYER}", $"{color(nameColour, player.displayName)}");
                message = message.Replace("{LINE}", "\n");
                return $"{color(motdColour, message)}";
            }
            else
            if (type == "AutoBroadcast")
            {
                string message = getRandomBroadcast().Replace("{LINE}", "\n");
                if (broadcastPrefixEnabled)
                    return $"{color(broadcastPrefixColour, broadcastPrefix)} {message}";
                return message;
            }

            return "<Error>";
        }

        #endregion


        void sendError(BasePlayer player, string type, string extra = "")
        {
            PrintToChat(player, mainPrefix + " " + color(errorColour, Lang(type, player.UserIDString, extra)));
        }

        void sendMessage(BasePlayer player, string type, string extra = "")
        {
            PrintToChat(player, mainPrefix + " " + color(mainColour, Lang(type, player.UserIDString, extra)));
        }

        PlayerInfo getPlayerInfo(BasePlayer player)
        {
            foreach (PlayerInfo p in storedData.Players)
                if (p.userID == player.userID)
                    return p;
            return null;
        }

        BasePlayer getPlayer(PlayerInfo player)
        {
            foreach (BasePlayer p in BasePlayer.activePlayerList)
                if (p.userID == player.userID)
                    return p;
            return null;
        }

        BasePlayer getPlayer(string partialName)
        {
            foreach (BasePlayer p in BasePlayer.activePlayerList)
                if (p.displayName.ToLower() == partialName.ToLower())
                    return p;
            return null;
        }

        class PlayerInfo
        {
            public string displayName;
            public ulong userID;
            public bool newPlayer = true;
            public string ipAddress;
            public List<string> Aliases = new List<string>();

            public PlayerInfo(string name, ulong id)
            {
                this.displayName = name;
                this.userID = id;
                this.Aliases.Add(name);
            }
            public void addAlias(string name)
            {
                foreach (string s in Aliases)
                    if (s == name)
                        return;
                Aliases.Add(name);
            }
        }

        class StoredData
        {
            public List<PlayerInfo> Players = new List<PlayerInfo>();
        }

    }

}


// --- End of file: Broadcaster.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/XRate.cs ---
// --- Original Local Path: XRate.cs ---

﻿using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using UnityEngine;
using Random = UnityEngine.Random;
using System;
using Oxide.Core;
using ConVar;
using ru = Oxide.Game.Rust;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("XRate", "Menevt", "1.0.03")]
    [Description("НАСТРОЙКА РЕЙТОВ ДОБЫЧИ (ОПТИМИЗИРОВАНО)")]
    public class XRate : RustPlugin
    {
        #region Config
        private PluginConfig config;
        protected override void LoadDefaultConfig()
        {
            config = PluginConfig.DefaultConfig();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        class rateset
        {
            [JsonProperty("Поднимаемые ресурсы")]
            public float grab;

            [JsonProperty("Добываемые ресурсы")]
            public float gather;

            [JsonProperty("Сульфур")]
            public float sulfur;

            [JsonProperty("С карьера")]
            public float carier;

            [JsonProperty("С ящиков/бочек")]
            public float box;

            [JsonProperty("Запертый ящик")]
            public float lockbox;

            [JsonProperty("С ученых")]
            public float npc;

            [JsonProperty("Скорость переплавки")]
            public float speed;
        }

        class daynight
        {
            [JsonProperty("Включить?")]
            public bool enable;

            [JsonProperty("Длина ночи")]
            public float night;

            [JsonProperty("Длина дня")]
            public float day;

            [JsonProperty("Автопропуск ночи")]
            public bool skipnight;

            [JsonProperty("Голосование за пропуск ночи")]
            public bool vote;

            [JsonProperty("Ночное увелечение рейтов (прим. 1.0 - на 100%, 0 - выключить)")]
            public float upnight;
        }

        private class PluginConfig
        {
            [JsonProperty("Экспериментально. Не трогать!")]
            public bool exp;

            [JsonProperty("Отключить ускоренную плавку")]
            public bool speed;

            [JsonProperty("Рейты у обычных игроков")]
            public rateset rates;

            [JsonProperty("Настройка дня и ночи")]
            public daynight daynight;

            [JsonProperty("Сообщения")]
            public List<string> messages;

            [JsonProperty("Привилегии")]
            public Dictionary<string, rateset> privilige;

            [JsonProperty("На что не увеличивать рейты?")]
            public string[] blacklist;

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    speed = false,
                    privilige = new Dictionary<string, rateset>()
                    {
                        { "xrate.x3", new rateset{ box = 3f, carier = 3f, gather = 3f, grab = 3f, npc = 3f, speed = 4f, sulfur = 2.5f } },
                        { "xrate.x4", new rateset{ box = 4f, carier = 4f, gather = 4f, grab = 4f, npc = 4f, speed = 4f, sulfur = 2.5f } }
                    },
                    rates = new rateset { box = 2f, carier = 2f, gather = 2f, grab = 2f, npc = 2f, speed = 2f, sulfur = 2f },
                    daynight = new daynight
                    {
                        day = 50f,
                        night = 10f,
                        enable = true,
                        skipnight = false,
                        upnight = 0f,
                        vote = false
                    },
                    exp = false,
                    messages = new List<string>
                    {
                        "<size=15><color=#ccff33>Наступила ночь</color>, рейты добычи увеличены на <color=#ccff33>{num}%</color>!</size>\n<size=10><color=#ccff33>/rate</color> - узнать текущие ваши рейты.</size>",
                        "<size=15><color=#ccff33>Наступил день</color>, рейты добычи стали прежними!</size>\n<size=10><color=#ccff33>/rate</color> - узнать текущие ваши рейты.</size>",
                        "<color=#ccff33>INFORATE | {name}</color>\nПоднимаемые: x<color=#F0E68C>{0}</color>\nДобываемые: x<color=#F0E68C>{1}</color> <size=10>(cульфур: x<color=#F0E68C>{6}</color>)</size>\nКарьер: x<color=#F0E68C>{2}</color>\nЯщики/бочки: x<color=#F0E68C>{3}</color>\nNPC: x<color=#F0E68C>{4}</color>\nСкорость переплавки: x<color=#F0E68C>{5}</color>"
                    },
                    blacklist = new string[]
                    {
                        "sticks",
                        "flare"
                    }
                };
            }
        }
        #endregion

        #region getrate
        Dictionary<string, rateset> cash = new Dictionary<string, rateset>();
        Dictionary<ulong, float> cashcariers = new Dictionary<ulong, float>();
        static XRate ins;
        void Init()
        {
            ins = this;
            Unsubscribe(nameof(OnEntitySpawned));
            Unsubscribe(nameof(OnOvenToggle));
        }

        bool skip;
        bool isday;
        void OnHour()
        {
            if (TOD_Sky.Instance.Cycle.Hour > TOD_Sky.Instance.SunriseTime && TOD_Sky.Instance.Cycle.Hour <= 19f && !isday) OnSunrise();
            else if ((TOD_Sky.Instance.Cycle.Hour >= 19f || TOD_Sky.Instance.Cycle.Hour < TOD_Sky.Instance.SunriseTime) && isday) OnSunset();
        }

        void OnSunrise()
        {
            TOD_Sky.Instance.Components.Time.DayLengthInMinutes = daytime;
            isday = true;
            if (upnight > 1f)
            {
                Server.Broadcast(config.messages[1]);
                nightupdate();
            }
        }

        #region ГОЛОСОВАНИЕ
        const string REFRESHGUI = "[{\"name\":\"daytext\",\"parent\":\"day\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{day}\",\"fontSize\":18,\"align\":\"MiddleCenter\",\"color\":\"1 1 1 0.7921728\",\"fadeIn\":0.5},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.392941\",\"distance\":\"0.5 0.5\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmax\":\"0 0\"}]},{\"name\":\"neighttext\",\"parent\":\"night\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{night}\",\"fontSize\":18,\"align\":\"MiddleCenter\",\"color\":\"1 1 1 0.7921569\",\"fadeIn\":0.5},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.3948711\",\"distance\":\"0.5 0.5\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmax\":\"0 0\"}]}]";
        const string GUI = "[{\"name\":\"Main\",\"parent\":\"Overlay\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0 0 0 0.2035446\",\"fadeIn\":0.5},{\"type\":\"RectTransform\",\"anchormin\":\"0.5 1\",\"anchormax\":\"0.5 1\",\"offsetmin\":\"-100 -65\",\"offsetmax\":\"100 -35\"}]},{\"name\":\"day\",\"parent\":\"Main\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"chat.say /voteday\",\"color\":\"1 1 1 0.3929416\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"0.5 1\",\"offsetmax\":\"0 0\"}]},{\"name\":\"daytext\",\"parent\":\"day\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{day}\",\"fontSize\":18,\"align\":\"MiddleCenter\",\"color\":\"1 1 1 0.7921728\",\"fadeIn\":0.5},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.392941\",\"distance\":\"0.5 0.5\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmax\":\"0 0\"}]},{\"name\":\"night\",\"parent\":\"Main\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"chat.say /votenight\",\"color\":\"0 0 0 0.3929408\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.5 0\",\"anchormax\":\"1 1\",\"offsetmax\":\"0 0\"}]},{\"name\":\"neighttext\",\"parent\":\"night\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{night}\",\"fontSize\":18,\"align\":\"MiddleCenter\",\"color\":\"1 1 1 0.7921569\",\"fadeIn\":0.5},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.3948711\",\"distance\":\"0.5 0.5\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmax\":\"0 0\"}]}]";
        static string CONSTVOTE = "";

        void CLEARVOTE()
        {
            Vtimer?.Destroy();
            Vday = 0;
            Vnight = 0;
            voted.Clear();
        }

        void StartVote()
        {
            activevote = true;
            CLEARVOTE();
            Debug.LogWarning("-Голосование за пропуск ночи-");
            Server.Broadcast("<color=yellow>Начато голосование за пропуск ночи. Нажмите на ДЕНЬ или НОЧЬ или пропишите в чат /voteday - за день или /votenight - за ночь.</color>");
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = Network.Net.sv.connections }, null, "DestroyUI", "Main");
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = Network.Net.sv.connections }, null, "AddUI", CONSTVOTE);
            Vtimer = timer.Once(30f, () => EndVote());
        }

        void EndVote()
        {
            activevote = false;
            if (Vday > Vnight)
            {
                TOD_Sky.Instance.Cycle.Hour += (24 - TOD_Sky.Instance.Cycle.Hour) + TOD_Sky.Instance.SunriseTime;
                OnSunrise();
                Server.Broadcast("<color=yellow>Большинство проголосовало за день. Пропускаем ночь...</color>");
                Debug.LogWarning("-Пропускаем ночь-");
            }
            else
            {
                Debug.LogWarning("-Ночь остается-");
                Server.Broadcast("<color=yellow>— Да будет свет! — сказал электрик и перерезал провода.</color>");
            }
            CLEARVOTE();
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = Network.Net.sv.connections }, null, "DestroyUI", "Main");
        }

        Timer Vtimer;
        bool activevote;
        static int Vday;
        static int Vnight;
        static List<ulong> voted = new List<ulong>();

        private void REFRESHME()
        {
            List<Network.Connection> sendto = Network.Net.sv.connections.Where(x => voted.Contains(x.userid)).ToList();
            string RGUI = REFRESHGUI.Replace("{day}", Vday.ToString()).Replace("{night}", Vnight.ToString());
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = sendto }, null, "DestroyUI", "daytext");
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = sendto }, null, "DestroyUI", "neighttext");
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = sendto }, null, "AddUI", RGUI);
        }

        private void cmdvoteday(BasePlayer player, string command, string[] args)
        {
            if (!CHECKPOINT(player)) return;

            player.ChatMessage("<color=yellow>Голос за ДЕНЬ успешно принят.</color>");
            Vday++;
            voted.Add(player.userID);
            REFRESHME();
            if (Vday > BasePlayer.activePlayerList.Count * 0.6f) EndVote();
        }

        private void cmdvotenight(BasePlayer player, string command, string[] args)
        {
            if (!CHECKPOINT(player)) return;

            player.ChatMessage("<color=yellow>Голос за НОЧЬ успешно принят.</color>");
            Vnight++;
            voted.Add(player.userID);
            REFRESHME();
            if (Vnight > BasePlayer.activePlayerList.Count * 0.6f) EndVote();
        }

        bool CHECKPOINT(BasePlayer player)
        {
            if (!activevote)
            {
                player.ChatMessage("<color=yellow>ГОЛОСОВАНИЕ НЕ АКТИВНО!</color>");
                return false;
            }

            if (voted.Contains(player.userID))
            {
                player.ChatMessage("<color=yellow>ВЫ УЖЕ ГОЛОСОВАЛИ!</color>");
                return false;
            }

            return true;
        }
        #endregion

        void OnSunset()
        {
            if (skip) return;
            if (config.daynight.skipnight)
            {
                Env.time = 23.99f;
                skip = true;
                timer.Once(8f, () =>
                {
                    Env.time = TOD_Sky.Instance.SunriseTime;
                    skip = false;
                });
                Debug.Log("Пропускаем ночь.");
                return;
            }
            else if (config.daynight.vote) StartVote();

            TOD_Sky.Instance.Components.Time.DayLengthInMinutes = nighttime;
            isday = false;
            if (upnight > 1f)
            {
                Server.Broadcast(config.messages[0].Replace("{num}", (config.daynight.upnight * 100f).ToString()));
                nightupdate();
            }
        }

        void nightupdate()
        {
            if (cash.Count > 0) foreach (var id in cash.ToList()) getuserrate(id.Key);
            if (cashcariers.Count > 0) foreach (var id in cashcariers.ToList()) CashCarier(id.Key);
        }

        float daytime;
        float nighttime;
        float upnight;
        TOD_Time comp;

        void OnServerInitialized()
        {
            PrintWarning("\n-----------------------------\n" +
            "     Author - Menevt/\n" +
            "     Site - https://oxide-russia.ru/\n" +
            "     Site - https://oxide-russia.ru/\n" +
            "-----------------------------");
            SaveConfig();
            if(config.blacklist == null || config.blacklist.Length == 0)
            {
                config.blacklist = new string[]
                {
                    "sticks",
                    "flare"
                };
                SaveConfig();
            }

            if(config.daynight == null)
            {
                config.daynight = new daynight
                {
                    day = 50f,
                    night = 10f,
                    enable = true,
                    skipnight = false,
                    upnight = 0f,
                    vote = false
                };
                SaveConfig();
            }

            if (config.rates.lockbox == 0f)
            {
                config.rates.lockbox = config.rates.box;
                foreach (var x in config.privilige) x.Value.lockbox = x.Value.box;
                SaveConfig();
            }

            if (config.daynight.enable)
            {
                if (config.daynight.vote)
                {
                    CONSTVOTE = GUI.Replace("{day}", "ДЕНЬ").Replace("{night}", "НОЧЬ");
                    Interface.Oxide.GetLibrary<ru.Libraries.Command>(null).AddChatCommand("voteday", this, "cmdvoteday");
                    Interface.Oxide.GetLibrary<ru.Libraries.Command>(null).AddChatCommand("votenight", this, "cmdvotenight");
                }
                daytime = config.daynight.day * 24f / (19f - TOD_Sky.Instance.SunriseTime);
                nighttime = config.daynight.night * 24f / (24f - (19f - TOD_Sky.Instance.SunriseTime));
                upnight = 1f + config.daynight.upnight;
                comp = TOD_Sky.Instance.Components.Time;
                comp.ProgressTime = true;
                comp.UseTimeCurve = false;
                comp.OnSunrise += OnSunrise;
                comp.OnSunset += OnSunset;
                comp.OnHour += OnHour;

                if (TOD_Sky.Instance.Cycle.Hour > TOD_Sky.Instance.SunriseTime && TOD_Sky.Instance.Cycle.Hour <= 19f) OnSunrise();
                else OnSunset();
            }

            if (!config.speed)
            {
                Subscribe(nameof(OnEntitySpawned));
                Subscribe(nameof(OnOvenToggle));
                var ovens = UnityEngine.Object.FindObjectsOfType<BaseOven>();
                for (var i = 0; i < ovens.Length; i++)
                {
                    OnEntitySpawned(ovens[i]);
                }
                timer.Once(1f, () =>
                {
                    foreach (BaseOven oven in ovens)
                    {
                        var component = oven.GetComponent<FurnaceController>();
                        if (oven == null || oven.IsDestroyed || !oven.IsOn()) continue;
                        component.StartCooking();
                    }
                });
            }

            foreach (string perm in config.privilige.Keys) permission.RegisterPermission(perm, this);
            foreach (BasePlayer player in BasePlayer.activePlayerList) getuserrate(player.UserIDString);
        }

        void OnGroupPermissionGranted(string name, string perm)
        {
            foreach (BasePlayer player in BasePlayer.allPlayerList)
            {
                if (permission.UserHasGroup(player.UserIDString, name)) getuserrate(player.UserIDString);
            }
        }

        void OnGroupPermissionRevoked(string name, string perm)
        {
            foreach (BasePlayer player in BasePlayer.allPlayerList)
            {
                if (permission.UserHasGroup(player.UserIDString, name)) getuserrate(player.UserIDString);
            }
        }

        void OnUserGroupRemoved(string id, string groupName)
        {
            getuserrate(id);
        }

        void OnUserGroupAdded(string id, string groupName)
        {
            getuserrate(id);
        }

        void OnUserPermissionGranted(string id, string permName)
        {
            getuserrate(id);
        }

        void OnUserPermissionRevoked(string id, string permName)
        {
            getuserrate(id);
        }

        void OnPlayerConnected(BasePlayer player)
        {
            getuserrate(player.UserIDString);
        }

        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (cash.ContainsKey(player.UserIDString)) cash.Remove(player.UserIDString);
        }
        #endregion

        #region Rates
        [ChatCommand("rate")]
        private void cmdRATE(BasePlayer player, string command, string[] args)
        {
            player.ChatMessage(config.messages[2].Replace("{name}", player.displayName).Replace("{0}", cash[player.UserIDString].grab.ToString()).Replace("{1}", cash[player.UserIDString].gather.ToString()).Replace("{2}", cash[player.UserIDString].carier.ToString()).Replace("{3}", cash[player.UserIDString].box.ToString()).Replace("{4}", cash[player.UserIDString].npc.ToString()).Replace("{5}", cash[player.UserIDString].speed.ToString()).Replace("{6}", cash[player.UserIDString].sulfur.ToString()));
        }

        [PluginReference] private Plugin ZREWARDME, FROre;

        void getuserrate(string id, float bonus = 0f)
        {
            rateset rate = config.privilige.LastOrDefault(x => permission.UserHasPermission(id, x.Key)).Value ?? config.rates;
            if (!cash.ContainsKey(id)) cash[id] = new rateset();
            if (ZREWARDME != null && bonus == 0f) bonus = ZREWARDME.Call<float>("APIBONUS", id);
            if (upnight > 1f && !isday)
            {
                cash[id].box = rate.box * upnight;
                cash[id].carier = rate.carier * upnight;
                cash[id].gather = rate.gather * upnight;
                cash[id].grab = rate.grab * upnight;
                cash[id].lockbox = rate.lockbox * upnight;
                cash[id].npc = rate.npc * upnight;
                cash[id].sulfur = rate.sulfur * upnight;
            }
            else
            {
                cash[id].box = rate.box;
                cash[id].carier = rate.carier;
                cash[id].gather = rate.gather;
                cash[id].grab = rate.grab;
                cash[id].lockbox = rate.lockbox;
                cash[id].npc = rate.npc;
                cash[id].sulfur = rate.sulfur;
            }

            if(bonus > 0f)
            {
                cash[id].gather += bonus;
                cash[id].grab += bonus;
                cash[id].sulfur += bonus;
            }

            cash[id].speed = rate.speed;
        }

        void OnCollectiblePickup(Item item, BasePlayer player)
        {
            if (config.blacklist.Contains(item.info.shortname)) return;
            item.amount = (int)(item.amount * cash[player.UserIDString].grab);
        }

        void OnGrowableGather(GrowableEntity plant, Item item, BasePlayer player)
        {
            if (player == null || item == null) return;
            if (config.blacklist.Contains(item.info.shortname)) return;
            item.amount = (int)(item.amount * cash[player.UserIDString].grab);
        }

        void OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            if (config.blacklist.Contains(item.info.shortname)) return;
            if (item.info.itemid.Equals(-1157596551)) item.amount = (int)(item.amount * cash[player.UserIDString].sulfur);
            else item.amount = (int)(item.amount * cash[player.UserIDString].gather);
        }

        void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            if (config.blacklist.Contains(item.info.shortname)) return;
            BasePlayer player = entity.ToPlayer();
            if (player != null)
            {
                if (item.info.itemid.Equals(-1157596551)) item.amount = (int)(item.amount * cash[player.UserIDString].sulfur);
                else item.amount = (int)(item.amount * cash[player.UserIDString].gather);
            }
            else
            {
                if (item.info.itemid.Equals(-1157596551)) item.amount *= (int)(item.amount * config.rates.sulfur);
                else item.amount *= (int)(item.amount * config.rates.gather);
            }
        }

        private void CashCarier(ulong id)
        {
            rateset rate = config.privilige.LastOrDefault(x => permission.UserHasPermission(id.ToString(), x.Key)).Value ?? config.rates;
            if (!isday && upnight > 1f) cashcariers[id] = rate.carier * upnight;
            else cashcariers[id] = rate.carier;
        }

        private object OnExcavatorGather(ExcavatorArm arm, Item item)
        {
            if (config.blacklist.Contains(item.info.shortname)) return null;
            item.amount = (int)(item.amount * config.rates.carier);
            return null;
        }

        private void OnQuarryToggled(BaseEntity entity, BasePlayer player)
        {
            CashCarier(entity.OwnerID);
        }

        void OnQuarryGather(MiningQuarry quarry, Item item)
        {
            if (config.blacklist.Contains(item.info.shortname)) return;
            float rate;
            if (!cashcariers.TryGetValue(quarry.OwnerID, out rate))
            {
                CashCarier(quarry.OwnerID);
                rate = cashcariers[quarry.OwnerID];
            }
            item.amount = (int)(item.amount * rate);
        }
        /*
        object OnQuarryGather(MiningQuarry quarry, List<ResourceDepositManager.ResourceDeposit.ResourceDepositEntry> itemList)
        {
            if (!cashcariers.ContainsKey(quarry.OwnerID)) CashCarier(quarry.OwnerID);
            foreach (ResourceDepositManager.ResourceDeposit.ResourceDepositEntry resource in itemList)
            {
                if ((quarry.canExtractLiquid || !resource.isLiquid) && (quarry.canExtractSolid || resource.isLiquid))
                {
                    resource.workDone += quarry.workToAdd;
                    if ((double)resource.workDone >= (double)resource.workNeeded)
                    {
                        int iAmount = Mathf.FloorToInt(resource.workDone / resource.workNeeded);
                        resource.workDone -= (float)iAmount * resource.workNeeded;
                        Item obj = ItemManager.Create(resource.type, (int)(iAmount * cashcariers[quarry.OwnerID]), 0UL);
                        if (!obj.MoveToContainer(quarry.hopperPrefab.instance.GetComponent<StorageContainer>().inventory, -1, true))
                        {
                            obj.Remove(0.0f);
                            quarry.SetOn(false);
                        }
                    }
                }
            }
            if (!quarry.FuelCheck()) quarry.SetOn(false);
            return false;
        }*/

        void OnContainerDropItems(ItemContainer container)
        {
            LootContainer lootcont = container.entityOwner as LootContainer;
            if (lootcont == null || lootcont.OwnerID != 0) return;
            uint ID = lootcont.net.ID;
            if (CHECKED.Contains(ID)) return;
            var player = lootcont?.lastAttacker?.ToPlayer();
            
            if (player != null && cash.ContainsKey(player.UserIDString))
            {
                foreach (var item in lootcont.inventory.itemList)
                {
                    int maxstack = item.MaxStackable();
                    if (maxstack  == 1 || config.blacklist.Contains(item.info.shortname) || item.IsBlueprint()) continue;
                    item.amount = (int)(item.amount * cash[player.UserIDString].box);
                    if (item.amount > maxstack) item.amount = maxstack;
                }
            }
            else
            {
                foreach (var item in lootcont.inventory.itemList.Where(x => x.info.stackable > 1))
                {
                    int maxstack = item.MaxStackable();
                    if (maxstack == 1 || config.blacklist.Contains(item.info.shortname) || item.IsBlueprint()) continue;
                    item.amount = (int)(item.amount * config.rates.box);
                    if (item.amount > maxstack) item.amount = maxstack;
                }
            }
        }

        private void OnEntityDeath(BaseNetworkable entity, HitInfo info)
        {
            if (entity is BaseHelicopter && config.exp)
            {
                HackableLockedCrate ent = (HackableLockedCrate)GameManager.server.CreateEntity("assets/prefabs/deployable/chinooklockedcrate/codelockedhackablecrate.prefab", entity.transform.position, entity.transform.rotation);
                ent.Spawn();
            }
        }

        List<uint> CHECKED = new List<uint>();

        private void OnLootEntity(BasePlayer player, object entity)
        {
            if (player == null || entity == null) return;
            if (entity is NPCPlayerCorpse)
            {
                NPCPlayerCorpse nPCPlayerCorpse = (NPCPlayerCorpse) entity;
                if (nPCPlayerCorpse == null) return;
                uint ID = nPCPlayerCorpse.net.ID;
                if (CHECKED.Contains(ID)) return;
                rateset rateset;
                if (!cash.TryGetValue(player.UserIDString, out rateset)) return;
                ItemContainer cont = nPCPlayerCorpse.containers.FirstOrDefault();
                foreach (var item in cont.itemList.Where(x => x.info.stackable > 1))
                {
                    int maxstack = item.MaxStackable();
                    if (maxstack == 1 || config.blacklist.Contains(item.info.shortname) || item.IsBlueprint()) continue;
                    item.amount = (int)(item.amount * rateset.npc);
                    if (item.amount > maxstack) item.amount = maxstack;
                }
                CHECKED.Add(ID);
            }
            else if (entity is LootContainer)
            {
                LootContainer lootcont = (LootContainer)entity;
                if (lootcont == null || lootcont.OwnerID != 0) return;
                uint ID = lootcont.net.ID;
                if (CHECKED.Contains(ID)) return;
                rateset rateset;
                if (!cash.TryGetValue(player.UserIDString, out rateset)) return;
                if (entity is HackableLockedCrate)
                {
                    foreach (var item in lootcont.inventory.itemList.Where(x => x.info.stackable > 1))
                    {
                        int maxstack = item.MaxStackable();
                        if (maxstack == 1 || config.blacklist.Contains(item.info.shortname) || item.IsBlueprint()) continue;
                        item.amount = (int)(item.amount * rateset.lockbox);
                        if (item.amount > maxstack) item.amount = maxstack;
                    }
                }
                else
                {
                    foreach (var item in lootcont.inventory.itemList.Where(x => x.info.stackable > 1))
                    {
                        int maxstack = item.MaxStackable();
                        if (maxstack == 1 || config.blacklist.Contains(item.info.shortname) || item.IsBlueprint()) continue;
                        item.amount = (int)(item.amount * rateset.box);
                        if (item.amount > maxstack) item.amount = maxstack;
                    }
                }
                CHECKED.Add(ID);
            }
        }
        #endregion

        #region Smelt
        private void Unload()
        {

            if (comp != null)
            {
                comp.OnSunrise -= OnSunrise;
                comp.OnSunset -= OnSunset;
                comp.OnHour -= OnHour;
            }
            if (config.daynight.vote) CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo { connections = Network.Net.sv.connections }, null, "DestroyUI", "Main");
            
            var ovens = UnityEngine.Object.FindObjectsOfType<BaseOven>();

            foreach (BaseOven oven in ovens)
            {
                var component = oven.GetComponent<FurnaceController>();
                if (oven.IsOn())
                {
                    component.StopCooking();
                    oven.StartCooking();
                }
                UnityEngine.Object.Destroy(component);
            }
        }

        private void OnEntitySpawned(BaseNetworkable entity)
        {
            if (entity == null) return;
            else if (entity is BaseOven) entity?.gameObject?.AddComponent<FurnaceController>();
        }

        private object OnOvenToggle(StorageContainer oven, BasePlayer player)
        {
            if (oven is BaseFuelLightSource) return null;
            FurnaceController component = oven.GetComponent<FurnaceController>();
            if (component == null) component = oven.gameObject.AddComponent<FurnaceController>();
            if (oven.IsOn())
            {
                component.StopCooking();
            }
            else
            {
                component.StartCooking();
                component.SetSpeed(cash[player.UserIDString].speed);
            }
            return false;
        }

        public class FurnaceController : FacepunchBehaviour
        {
            private BaseOven _oven;
            private BaseOven Furnace
            {
                get
                {
                    if (_oven == null) _oven = GetComponent<BaseOven>();
                    return _oven;
                }
            }
            private float _speedMultiplier;
            private int amountmultiplier;
            private int amount;

            private void Awake()
            {
                SetSpeed(ins.config.rates.speed);
                amount = amountmultiplier;
            }

            public void SetSpeed(float newspeed)
            {
                _speedMultiplier = newspeed;
                amountmultiplier = (int)newspeed;
            }

            private Item FindBurnable()
            {
                if (Furnace.inventory == null) return null;

                foreach (var item in Furnace.inventory.itemList)
                {
                    var component = item.info.GetComponent<ItemModBurnable>();
                    if (component && (Furnace.fuelType == null || item.info == Furnace.fuelType))
                    {
                        return item;
                    }
                }

                return null;
            }

            public void Cook()
            {
                var item = FindBurnable();
                if (item == null)
                {
                    StopCooking();
                    return;
                }

                SmeltItems();
                var slot = Furnace.GetSlot(BaseEntity.Slot.FireMod);
                if (slot) slot.SendMessage("Cook", 0.5f, SendMessageOptions.DontRequireReceiver);

                var component = item.info.GetComponent<ItemModBurnable>();
                item.fuel -= 5f;
                if (!item.HasFlag(global::Item.Flag.OnFire))
                {
                    item.SetFlag(global::Item.Flag.OnFire, true);
                    item.MarkDirty();
                }

                if (item.fuel <= 0f) ConsumeFuel(item, component);
            }

            private void ConsumeFuel(Item fuel, ItemModBurnable burnable)
            {
                if (Furnace.allowByproductCreation && burnable.byproductItem != null && Random.Range(0f, 1f) > burnable.byproductChance)
                {
                    var def = burnable.byproductItem;
                    var item = ItemManager.Create(def, burnable.byproductAmount * amountmultiplier);
                    if (!item.MoveToContainer(Furnace.inventory))
                    {
                        StopCooking();
                        item.Drop(Furnace.inventory.dropPosition, Furnace.inventory.dropVelocity);
                    }
                }
                amount = amountmultiplier;
                if (fuel.amount <= amountmultiplier)
                {
                    fuel.Remove();
                    return;
                }
                fuel.amount -= amountmultiplier;
                fuel.fuel = burnable.fuelAmount;
                fuel.MarkDirty();
            }
            private Dictionary<Item, float> cook = new Dictionary<Item, float>();
            class CREAP
            {
                public string prefabname;
                public string name;
                public ulong skin;
                public int amount;
            }

            private void SmeltItems()
            {
                for (var i = 0; i < Furnace.inventory.itemList.Count; i++)
                {
                    var item = Furnace.inventory.itemList[i];
                    if (item == null || !item.IsValid()) continue;

                    var cookable = item.info.GetComponent<ItemModCookable>();
                    if (cookable == null) continue;

                    var temperature = item.temperature;
                    if ((temperature < cookable.lowTemp || temperature > cookable.highTemp))
                    {
                        if (!cookable.setCookingFlag || !item.HasFlag(global::Item.Flag.Cooking)) continue;
                        item.SetFlag(global::Item.Flag.Cooking, false);
                        item.MarkDirty();
                        continue;
                    }
                    if (cook.ContainsKey(item)) cook[item] += 0.5f;
                    else cook[item] = 0.5f;
                    if (cook[item] < (cookable.cookTime / _speedMultiplier)) continue;
                    cook[item] = 0f;
                    if (cookable.setCookingFlag && !item.HasFlag(global::Item.Flag.Cooking))
                    {
                        item.SetFlag(global::Item.Flag.Cooking, true);
                        item.MarkDirty();
                    }
                    // int position = item.position;
                    bool stop = false;
                    int amount2 = item.amount;
                    if (amount2 > amount)
                    {
                        item.amount -= amount;
                        item.MarkDirty();
                    }
                    else
                    {
                        item.Remove();
                        stop = true;
                    }

                    if (cookable.becomeOnCooked == null) continue;

                    List<Item> cREAPs = null;
                    if (item.skin != 0 && ins.FROre != null)
                    {
                        cREAPs = ins.FROre.Call<List<Item>>("GetMelt", item.info.shortname, item.skin);
                    }

                    if (cREAPs != null && cREAPs.Count > 0)
                    {
                        float radiation = 0f;
                        float radius = 0f;
                        bool check = false;
                        foreach(var item2 in cREAPs)
                        {
                            if (!check && !string.IsNullOrEmpty(item2.text))
                            {
                                string[] args = item2.text.Split(' ');
                                radiation = float.Parse(args[0]);
                                radius = float.Parse(args[0]);
                                check = true;
                            }
                            if (item2.MoveToContainer(item.parent)) continue;
                            item2.Drop(item.parent.dropPosition, item.parent.dropVelocity);
                            StopCooking();
                        }

                        if (radiation > 0f)
                        {
                            List<BasePlayer> basePlayers = new List<BasePlayer>();
                            Vis.Entities<BasePlayer>(Furnace.transform.position, radius, basePlayers);
                            foreach (var z in basePlayers)
                            {
                                z.UpdateRadiation(radiation);
                            }
                        }
                    }
                    else
                    {
                        int newamount = cookable.amountOfBecome * amount;
                        var item2 = ItemManager.Create(cookable.becomeOnCooked, amount2 < newamount ? amount2 : newamount);
                        if (item2 == null /*|| item2.MoveToContainer(item.parent, position) */|| item2.MoveToContainer(item.parent)) continue;
                        item2.Drop(item.parent.dropPosition, item.parent.dropVelocity);
                        StopCooking();
                    }
                    if (!stop) continue;
                    StopCooking();
                }
            }

            public void StartCooking()
            {
                if (FindBurnable() == null) return;

                StopCooking();

                Furnace.inventory.temperature = Furnace.cookingTemperature;
                Furnace.UpdateAttachmentTemperature();

                Furnace.InvokeRepeating(Cook, 0.5f, 0.5f);
                Furnace.SetFlag(BaseEntity.Flags.On, true);
            }

            public void StopCooking()
            {
                cook.Clear();
                Furnace.CancelInvoke(Cook);
                Furnace.StopCooking();
            }
        }
        #endregion
    }
}

// --- End of file: XRate.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Logger.cs ---
// --- Original Local Path: Logger.cs ---

using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;

namespace Oxide.Plugins
{
    [Info("Logger", "Wulf/lukespragg", "1.2.0", ResourceId = 670)]
    [Description("Configurable logging of chat, commands, and more")]

    class Logger : RustPlugin
    {
        #region Initialization

        List<object> exclusions;
        bool logChat;
        bool logCommands;
        bool logConnections;
        bool logRespawns;
        bool logToConsole;

        protected override void LoadDefaultConfig()
        {
            Config["Exclusions"] = exclusions = GetConfig("Exclusions", new List<object>
            {
                "/help", "/version", "chat.say", "craft.add", "craft.canceltask", "global.kill", "global.respawn",
                "global.respawn_sleepingbag", "global.status", "global.wakeup", "inventory.endloot", "inventory.unlockblueprint"
            });
            Config["LogChat"] = logChat = GetConfig("LogChat", false);
            Config["LogCommands"] = logCommands = GetConfig("LogCommands", true);
            Config["LogConnections"] = logConnections = GetConfig("LogConnections", true);
            Config["LogRespawns"] = logRespawns = GetConfig("LogRespawns", false);
            Config["LogToConsole"] = logToConsole = GetConfig("LogToConsole", true);
            SaveConfig();
        }

        void Init()
        {
            #if !RUST
            throw new NotSupportedException("This plugin does not support this game");
            #endif

            LoadDefaultConfig();
            LoadDefaultMessages();

            if (!logChat) Unsubscribe("OnPlayerChat");
            if (!logCommands) Unsubscribe("OnServerCommand");
            if (!logConnections) Unsubscribe("OnPlayerInit");
            if (!logRespawns) Unsubscribe("OnPlayerRespawned");
        }

        #endregion

        #region Localization

        void LoadDefaultMessages()
        {
            // English
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["ChatCommand"] = "{0} ({1}) ran chat command: {2}",
                ["Connected"] = "{0} ({1}) connected from {2}",
                ["ConsoleCommand"] = "{0} ({1}) ran console command: {2} {3}",
                ["Disconnected"] = "{0} ({1}) disconnected",
                ["Respawned"] = "{0} ({1}) respawned at {2}"
            }, this);

            // French
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["ChatCommand"] = "{0} ({1}) a couru chat commandeÂ : {2}",
                ["Connected"] = "{0} ({1}) reliant {2}",
                ["ConsoleCommand"] = "{0} ({1}) a couru la console de commandeÂ : {3} {2}",
                ["Disconnected"] = "{0} ({1}) dÃ©connectÃ©",
                ["Respawned"] = "{0} ({1}) rÃ©apparaÃ®tre Ã  {2}"
            }, this, "fr");

            // German
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["ChatCommand"] = "{0} ({1}) lief Chat-Befehl: {2}",
                ["Connected"] = "{0} ({1}) {2} verbunden",
                ["ConsoleCommand"] = "{0} ({1}) lief Konsole Befehl: {2} {3}",
                ["Disconnected"] = "{0} ({1}) nicht getrennt",
                ["Respawned"] = "{0} ({1}) bereits am {2}"
            }, this, "de");

            // Russian
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["ChatCommand"] = "{0} ({1}) Ð¿Ð¾Ð±ÐµÐ¶Ð°Ð» ÑÐ°Ñ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ: {2}",
                ["Connected"] = "{0} ({1}) Ð¸Ð· {2}",
                ["ConsoleCommand"] = "{0} ({1}) Ð¿Ð¾Ð±ÐµÐ¶Ð°Ð» ÐºÐ¾Ð¼Ð°Ð½Ð´Ð° ÐºÐ¾Ð½ÑÐ¾Ð»Ð¸: {2} {3}",
                ["Disconnected"] = "{0} ({1}) Ð¾ÑÐºÐ»ÑÑÐµÐ½",
                ["Respawned"] = "{0} ({1}) Ð²Ð¾Ð·ÑÐ¾Ð´Ð¸ÑÑÑ Ð² {2}"
            }, this, "ru");

            // Spanish
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["ChatCommand"] = "{0} ({1}) funcionÃ³ el comando chat: {2}",
                ["Connected"] = "{0} ({1}) conectado de {2}",
                ["ConsoleCommand"] = "{0} ({1}) funcionÃ³ el comando de consola: {2} {3}",
                ["Disconnected"] = "{0} ({1}) desconectado",
                ["Respawned"] = "{0} ({1}) hizo en {2}"
            }, this, "es");
        }

        #endregion

        #region Logging

        void OnPlayerChat(ConsoleSystem.Arg arg)
        {
            var player = arg.connection.player as BasePlayer;
            if (!logChat || player == null) return;

            var args = arg.GetString(0, "text");
            Log("chat", $"{player.displayName} ({player.userID}): {args}");
        }

        void OnPlayerConnected(Network.Message packet)
        {
            if (!logConnections) return;
            var con = packet.connection;
            Log("connections", Lang("Connected", null, con.username, con.userid, IpAddress(con.ipaddress)));
        }

        void OnPlayerDisconnected(BasePlayer player)
        {
            if (!logConnections) return;
            Log("connections", Lang("Disconnected", null, player.displayName, player.UserIDString));
        }

        void OnPlayerRespawned(BasePlayer player)
        {
            if (!logRespawns) return;
            Log("respawns", Lang("Respawned", null, player.displayName, player.userID, player.transform.position));
        }

        void OnServerCommand(ConsoleSystem.Arg arg)
        {
            if (!logCommands || arg.connection == null) return;

            var command = arg.cmd.namefull;
            var args = arg.GetString(0);

            if (args.StartsWith("/") && !exclusions.Contains(args))
                Log("commands", Lang("ChatCommand", null, arg.connection.username, arg.connection.userid, args));
            if (command != "chat.say" && !exclusions.Contains(command))
                Log("commands", Lang("ConsoleCommand", null, arg.connection.username, arg.connection.userid, command, arg.ArgsStr));
        }

        #endregion

        #region Helpers

        T GetConfig<T>(string name, T value) => Config[name] == null ? value : (T)Convert.ChangeType(Config[name], typeof(T));

        string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        static string IpAddress(string ip) => Regex.Replace(ip, @":{1}[0-9]{1}\d*", "");

        void Log(string fileName, string text)
        {
            var dateTime = DateTime.Now.ToString("yyyy-MM-dd");
            ConVar.Server.Log($"oxide/logs/{Title.ToLower()}-{fileName}_{dateTime}.txt", text);
            if (logToConsole) Puts(text);
        }

        #endregion
    }
}


// --- End of file: Logger.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/GatherMultiplier.cs ---
// --- Original Local Path: GatherMultiplier.cs ---

﻿// Reference: System.Drawing
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Drawing;
using System.Drawing.Imaging;
using System.IO;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Gather Multiplier", "RustPlugin.ru", "0.1.0")]

    public class GatherMultiplier : RustPlugin
    {
        #region CLASSES
        public static int START_TIME;
        public Dictionary<int, int> BONUSES;
        public Dictionary<string, int> BONUSMULTIPLIER;
        
        public class GatherData
        {
            public int Time = START_TIME;
            public int TotalAmount = 0;
            public string shortname;
            public int amount;
        }

        #endregion
        
        #region VARIABLES
        
        readonly DynamicConfigFile dataFile = Interface.Oxide.DataFileSystem.GetFile("GatherMultiplier");
        Dictionary<BasePlayer, int> notifierLasthit = new Dictionary<BasePlayer, int>();
        Dictionary<BasePlayer, int> bonuses = new Dictionary<BasePlayer, int>();

        Dictionary<string, string> itemsLoaclization = new Dictionary<string, string>()
        {
            {"hq.metal.ore", "МВК РУДА"},
            {"metal.ore", "ЖЕЛЕЗНАЯ РУДА"},
            {"sulfur.ore", "СЕРНАЯ РУДА"},
            {"stones", "КАМНИ"},
            {"metal.fragments", "МЕТАЛЛ. ФРАГ." },
            {"charcoal", "УГОЛЬ" },
            {"metal.refined", "МВК" }
        };

        Dictionary<int, int> gatherBonuses = new Dictionary<int, int>();
        Dictionary<BasePlayer, GatherData> gathers = new Dictionary<BasePlayer, GatherData>();

        protected override void LoadDefaultConfig()
        {
            Config["Стартовое время"] = START_TIME = GetConfig(80, "Стартовое время");
            Config["Бонус за непрерывную выдачу (Количество: Бонус)"] = BONUSES = GetConfig(new Dictionary<int, int>() { {100,100}}, "Бонус за непрерывную выдачу (Количество: Бонус)");
            Config["Бонусный множитель"] = BONUSMULTIPLIER = GetConfig(new Dictionary<string, int>()
            {
                {"hq.metal.ore", 1},
                {"metal.ore", 20},
                {"sulfur.ore", 10},
                {"stones", 30}
            }, "Бонусный множитель");
            
            SaveConfig();
        }
        
        #endregion

        #region Oxide Hooks

        void OnServerInitialized()
        {
            LoadDefaultConfig();
            timer.Every(1, GatherTimerLoop);
            timer.Every(1, BonusTimerLoop);
            InitFileManager();
            CommunityEntity.ServerInstance.StartCoroutine(LoadImages());
        }

        void OnPluginLoaded(Plugin name)
        {
            if (name.ToString() == "ExtPlugin" && name.Author == "Sanlerus, Moscow.OVH")
            {
                Unsubscribe("OnDispenserGather");
                Subscribe("OnDispenserGather");
            }
        }
        void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                DestroyUI(player);
                DestroyUILoop(player);
            }
        }
        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            notifierLasthit.Remove(player);
            gathers.Remove(player);
        }

        private void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            if (!entity.ToPlayer()) return;
            var player = entity.ToPlayer();
            var gatherType = dispenser.gatherType.ToString("G");

            if (gatherType == "Ore")
            {
                GatherData data;
                if (!gathers.TryGetValue(player, out data))
                    gathers.Add(player, data = new GatherData());
                var lastAmount = data.TotalAmount;
                float del = 1;
                
                var am = (int) (item.amount/del);
                data.TotalAmount += am;
                int bonusKey;
                if (GetBonus(lastAmount, data.TotalAmount, out bonusKey))
                    GiveBonus(player, bonusKey);
                data.amount = am;
                data.shortname = item.info.shortname;
                data.Time = START_TIME;
                UIDrawNotifier(player, data);
                DestroyUILoop(player);
                timer.Destroy(ref mytimer);
                UIDrawNotifierLast(player, data);
                
            }
        }
        void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (!(entity is BasePlayer))return;
            var player = (BasePlayer)entity;
            gathers.Remove(player);
            CuiHelper.DestroyUi(player, "gatheradvanced_panel");
        }

        void UpdateTimer(BasePlayer player, GatherData data)
        {
            data.Time = START_TIME;
            UIDrawNotifier(player, data);

        }
        #endregion

        #region Timers

        void GatherTimerLoop()
        {
            List<BasePlayer> removeList = new List<BasePlayer>();
            foreach (var gatherPair in gathers)
            {
                var data = gatherPair.Value;
                data.Time--;
                if (data.Time >= 0)
                {
                    UIDrawNotifier(gatherPair.Key, data, false);
                    continue;
                }
                removeList.Add(gatherPair.Key);
                DestroyUI(gatherPair.Key);
            }
            foreach (var p in removeList)
                gathers.Remove(p);
        }

        void BonusTimerLoop()
        {
            var time = Time;
            var removeList = (from bonusPair in bonuses
                              where bonusPair.Value <= time
                              select bonusPair.Key).ToList();
            for (int i = removeList.Count - 1; i >= 0; i--)
            {
                var player = removeList[i];
                CuiHelper.DestroyUi(player, "gatheradvanced_bonusParent");
                CuiHelper.DestroyUi(player, "gatheradvanced_bonusPanel");
                CuiHelper.DestroyUi(player, "gatheradvanced_bonusText");
                bonuses.Remove(player);
            }
        }

        void NotifierLasthitLoop()
        {
            var time = Time;
            List<BasePlayer> removeList = (from lasthitPair in notifierLasthit where lasthitPair.Value <= time select lasthitPair.Key).ToList();
            for (int i = removeList.Count - 1; i >= 0; i--)
            {
                var player = removeList[i];
                notifierLasthit.Remove(player);
            }
        }

        #endregion

        #region FUNCTIONS
        
        Dictionary<string,int> itemIDS = new Dictionary<string, int>()
        {
            {"hq.metal.ore", -1982036270},
            {"metal.ore", -4031221},
            {"sulfur.ore", -1157596551},
            {"stones", -2099697608}
        };

        void GiveBonus(BasePlayer player, int bonusKey)
        {
            var bonusAmount = BONUSES[bonusKey];
            var bonusType = GetBonusType();
            int amount = bonusAmount*(int) BONUSMULTIPLIER[bonusType];
            Item item = ItemManager.CreateByItemID(itemIDS[bonusType], amount);
            //Puts(player.displayName + ": "+item.info.shortname + " " + item.amount);
            player.inventory.GiveItem(item);
            UIDrawBonus(player, bonusKey, $"{amount} {itemsLoaclization[item.info.shortname]}");
        }

        public string GetBonusType() => BONUSMULTIPLIER.Keys.ToList()[UnityEngine.Random.Range(0, BONUSMULTIPLIER.Count)];

        public bool GetBonus(int lastAmount, int newAmount, out int bonusKey)
        {
            bonusKey = -1;
            foreach (var bonus in BONUSES)
                if (lastAmount < bonus.Key && newAmount >= bonus.Key)
                {
                    bonusKey = bonus.Key;
                    return true;
                }
            return false;
        }

        #endregion

        #region UI

        void UIDrawNotifier(BasePlayer player, GatherData data, bool destroy = true)
        {
            DestroyUI(player);
            if (destroy && data.amount != data.TotalAmount)
            {
                DestroyUI(player);
                notifierLasthit[player] = Time + 2;
            }
            if (!itemsLoaclization.ContainsKey(data.shortname))
                Puts("Invalid item: "+data.shortname);
            CuiHelper.AddUi(player,
                          HandleArgs(GUINot, data.TotalAmount, data.Time));
            
        }

        public Timer mytimer;

        void UIDrawNotifierLast(BasePlayer player, GatherData data, bool destroy = true)
        {
            
            
            if (destroy && data.amount != data.TotalAmount)
            {
                notifierLasthit[player] = Time + 2;
            }
            if (!itemsLoaclization.ContainsKey(data.shortname))
                Puts("Invalid item: " + data.shortname);
            mytimer = timer.Once(5, () =>
            {
                DestroyUILoop(player);
            });
            CuiHelper.AddUi(player,
                          HandleArgs(GUILastHit, data.amount, itemsLoaclization[data.shortname], Images["Notify"]));
           
        }

        int Time => (int)(DateTime.Now.Subtract(new DateTime(1970, 1, 1))).TotalSeconds;

        void UIDrawBonus(BasePlayer player, int bonusKey, string item)
        {
            var bonusAmount = BONUSES[bonusKey];
            if (bonuses.ContainsKey(player))
            {
                CuiHelper.DestroyUi(player, "gatheradvanced_bonusParent");
                CuiHelper.DestroyUi(player, "gatheradvanced_bonusPanel");
                CuiHelper.DestroyUi(player, "gatheradvanced_bonusText");
                DestroyUI(player);
            }
            CuiHelper.AddUi(player,
                          HandleArgs(GUI, bonusKey.ToString(), item.ToString()));
            timer.Once(3, () => CuiHelper.DestroyUi(player, "gatheradvanced_bonusParent"));
            bonuses[player] = Time + 4;
        }

        string HandleArgs(string json, params object[] args)
        {
            for (int i = 0; i < args.Length; i++)
                json = json.Replace("{" + i + "}", args[i].ToString());
            return json;
        }
        Dictionary<string, string> Images = new Dictionary<string, string>()
        {
            { "Notify", "http://i.imgur.com/VQAmjJ1.png" },
        };

        string GUI = "[{\"name\":\"gatheradvanced_bonusParent\",\"parent\":\"Overlay\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"sprite\":\"Assets/Content/UI/UI.Background.Tile.psd\",\"color\":\"0.6392157 0.6156863 0.6156863 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.3421874 0.1194445\",\"anchormax\":\"0.6401041 0.2231482\"}],\"fadeOut\":0.5},{\"name\":\"gatheradvanced_bonusPanel\",\"parent\":\"gatheradvanced_bonusParent\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"sprite\":\"Assets/Content/UI/UI.Background.Tile.psd\",\"color\":\"0.6418388 0.6161654 0.6161654 0.1849999\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.005244754 0\",\"anchormax\":\"1 1\"}],\"fadeOut\":0.5},{\"name\":\"gatheradvanced_bonusText\",\"parent\":\"gatheradvanced_bonusParent\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"<color=#fec384>Поздравляем!\nБонус за непрерывную добычу <color=#d2722d>{0}</color> ресурсов</color>\n<color=#d2722d>+{1}</color>\",\"fontSize\":17,\"align\":\"MiddleCenter\",\"color\":\"0 0 0 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0.01785707\",\"anchormax\":\"1 1\"}],\"fadeOut\":0.5}]";
        string GUINot = "[{\"name\":\"gatheradvanced_panel\",\"parent\":\"Overlay\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"sprite\":\"Assets/Content/UI/UI.Background.Tile.psd\",\"color\":\"0.6156863 0.5921569 0.5882353 0.095\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.725 0.02222222\",\"anchormax\":\"0.8359375 0.0972222\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"gatheradvanced_timer\",\"parent\":\"gatheradvanced_panel\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"Время: <color=#d2722d>{1}</color> секунд\",\"fontSize\":15,\"align\":\"MiddleCenter\",\"color\":\"0.9960784 0.7647059 0.5176471 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.009375773 0\",\"anchormax\":\"1 0.5061733\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"gatheradvanced_total\",\"parent\":\"gatheradvanced_panel\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"Всего: <color=#d2722d>{0}</color>\",\"fontSize\":15,\"align\":\"MiddleCenter\",\"color\":\"0.9960784 0.7647059 0.5176471 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.009389528 0.5185185\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]}]";
        string GUILastHit = "[{\"name\":\"gatheradvanced_lastHitPanel\",\"parent\":\"Overlay\",\"components\":[{\"type\":\"UnityEngine.UI.RawImage\",\"sprite\":\"assets/content/textures/generic/fulltransparent.tga\",\"png\":\"{2}\",\"fadeIn\":1.0},{\"type\":\"RectTransform\",\"anchormin\":\"0.7252604 0.1000001\",\"anchormax\":\"0.8359374 0.1351852\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}],\"fadeOut\":1.0},{\"name\":\"gatheradvanced_lastHitCount\",\"parent\":\"gatheradvanced_lastHitPanel\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"<b><color=#4e6031>+{0}</color></b>\",\"fontSize\":13,\"align\":\"MiddleLeft\",\"color\":\"0.9176471 1 0.4 1\",\"fadeIn\":1.0},{\"type\":\"RectTransform\",\"anchormin\":\"0.01882368 0\",\"anchormax\":\"0.2235298 0.9999994\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}],\"fadeOut\":1.0},{\"name\":\"gatheradvanced_lastHitName\",\"parent\":\"gatheradvanced_lastHitPanel\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"<b><color=#4e6031>{1}</color></b>\",\"fontSize\":13,\"align\":\"MiddleCenter\",\"color\":\"0.7372549 0.8 0.3215686 1\",\"fadeIn\":1.0},{\"type\":\"RectTransform\",\"anchormin\":\"0.2870598 0\",\"anchormax\":\"1 0.9999994\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}],\"fadeOut\":1.0}]";
        
        void DestroyUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "gatheradvanced_panel");
            
        }

        void DestroyUILoop(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "gatheradvanced_lastHitPanel");
            CuiHelper.DestroyUi(player, "gatheradvanced_lastHitCount");
            CuiHelper.DestroyUi(player, "gatheradvanced_lastHitName");

        }
        #endregion

        #region CONFIG

        T GetConfig<T>(T defaultValue, string firstKey, string secondKey = null, string thirdKey = null)
        {
            try
            {
                object value;

                // get the value associated with the provided keys
                if(thirdKey != null)
                {
                    value = Config[firstKey, secondKey, thirdKey];
                }
                else if(secondKey != null)
                {
                    value = Config[firstKey, secondKey];
                }
                else
                {
                    value = Config[firstKey];
                }

                // if the value is a dictionary, add the key/value pairs to a dictionary and return it
                // this particular implementation only handles dictionarys with string key/value pairs
                if(defaultValue.GetType() == typeof(Dictionary<string,int>))           // checks if the value is a dictionary
                {
                    Dictionary<string, int> valueDictionary = Config.ConvertValue<Dictionary<string, int>>(value);
                    
                    return (T)Convert.ChangeType(valueDictionary, typeof(T));
                }
                if(defaultValue.GetType() == typeof(Dictionary<int, int>))           // checks if the value is a dictionary
                {
                    Dictionary<string, int> valueDictionary =Config.ConvertValue<Dictionary<string,int>>(value);
                    Dictionary<int, int> values = valueDictionary.Keys.ToDictionary(int.Parse, key => (int) valueDictionary[key]);

                    return (T)Convert.ChangeType(values, typeof(T));
                }
                // if the value is a list, add the list elements to a list and return it
                // this particular implementation only handles lists with char elements
                else if(value.GetType().IsGenericType && value.GetType().GetGenericTypeDefinition() == typeof(List<>))             // checks if the value is a list
                {
                    IList valueList = (IList)value;
                    List<char> values = new List<char>();

                    foreach(object obj in valueList)
                    {
                        if(obj is string)
                        {
                            char result;
                            if(char.TryParse((string)obj, out result))
                            {
                                values.Add(result);
                            }
                        }
                    }
                    return (T)Convert.ChangeType(values, typeof(T));
                }
                // handles every other type
                else
                {
                    return (T)Convert.ChangeType(value, typeof(T));
                }
            }
            catch(Exception)
            {
                return defaultValue;
            }
        }

        #endregion

        #region File Manager
     


        IEnumerator LoadImages()
        {
            foreach (var imgKey in Images.Keys.ToList())
            {
                yield return CommunityEntity.ServerInstance.StartCoroutine(
                    m_FileManager.LoadFile(imgKey, Images[imgKey]));
                Images[imgKey] = m_FileManager.GetPng(imgKey);
            }
        }

        private GameObject FileManagerObject;
        private FileManager m_FileManager;

        /// <summary>
        /// Инициализация скрипта взаимодействующего с файлами сервера
        /// </summary>
        void InitFileManager()
        {
            FileManagerObject = new GameObject("MAP_FileManagerObject");
            m_FileManager = FileManagerObject.AddComponent<FileManager>();
        }

        class FileManager : MonoBehaviour
        {
            int loaded = 0;
            int needed = 0;
            
            public bool IsFinished => needed == loaded;
            const ulong MaxActiveLoads = 10;
            Dictionary<string, FileInfo> files = new Dictionary<string, FileInfo>();

            private class FileInfo
            {
                public string Url;
                public string Png;
            }


            public string GetPng(string name) => files[name].Png;


            public IEnumerator LoadFile(string name, string url, int size = -1)
            {
                var reply = 710;
                if (files.ContainsKey(name) && files[name].Url == url && !string.IsNullOrEmpty(files[name].Png)) yield break;
                files[name] = new FileInfo() { Url = url };
                needed++;
                yield return StartCoroutine(LoadImageCoroutine(name, url, size));
            }

            IEnumerator LoadImageCoroutine(string name, string url, int size = -1)
            {
                using (WWW www = new WWW(url))
                {
                    yield return www;
                    if (string.IsNullOrEmpty(www.error))
                    {
                        var bytes = size == -1 ? www.bytes : Resize(www.bytes, size);


                        var entityId = CommunityEntity.ServerInstance.net.ID;
                        var crc32 = FileStorage.server.Store(bytes, FileStorage.Type.png, entityId).ToString();
                        files[name].Png = crc32;
                    }
                }
                loaded++;
            }

            static byte[] Resize(byte[] bytes, int size)
            {
                Image img = (Bitmap)(new ImageConverter().ConvertFrom(bytes));
                Bitmap cutPiece = new Bitmap(size, size);
                System.Drawing.Graphics graphic = System.Drawing.Graphics.FromImage(cutPiece);
                graphic.DrawImage(img, new Rectangle(0, 0, size, size), 0, 0, img.Width, img.Height, GraphicsUnit.Pixel);
                graphic.Dispose();
                MemoryStream ms = new MemoryStream();
                cutPiece.Save(ms, ImageFormat.Jpeg);
                return ms.ToArray();
            }
        }

        #endregion

        #region PErmission
        

        
        #endregion
    }
}
           

// --- End of file: GatherMultiplier.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/LimitedSuicide.cs ---
// --- Original Local Path: LimitedSuicide.cs ---

using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("LimitedSuicide", "playrust.io / dcode", "1.0.2", ResourceId = 835)]
    public class LimitedSuicide : RustPlugin
    {
        // Default configuration: Once per 300 seconds
        private static int defaultLimit = 1;
        private static int defaultTimespan = 300;

        // Loaded configuration
        private int limit = defaultLimit;
        private int timespan = defaultTimespan;

        // Suicide timestamps
        private Dictionary<ulong, List<DateTime>> suicides = new Dictionary<ulong, List<DateTime>>();

        protected override void LoadDefaultConfig() {
            Config["limit"] = defaultLimit;
            Config["timespan"] = defaultTimespan;
            SaveConfig();
        }

        [HookMethod("OnServerInitialized")]
        void OnServerInitialized() {
            try {
                limit = Convert.ToInt32(Config["limit"]);
                if (limit < 1) limit = 1;
            } catch (Exception ex) {
                Puts("[LimitedSuicide] Illegal configuration value for 'limit': {0}", ex.Message);
            }
            try {
                timespan = Convert.ToInt32(Config["timespan"]);
                if (timespan < 1) timespan = 1;
            } catch (Exception ex) {
                Puts("[LimitedSuicide] Illegal configuration value for 'timespan': {0}", ex.Message);
            }
        }

        [HookMethod("OnRunCommand")]
        object OnRunCommand(ConsoleSystem.Arg arg) {
            if (arg.connection == null || arg.connection.player == null || arg.cmd.name != "kill")
                return null;
            var player = arg.connection.player as BasePlayer;
            if (player == null)
                return null;
            List<DateTime> times;
            DateTime now = DateTime.UtcNow;
            if (suicides.TryGetValue(player.userID, out times)) {
                int n = 0;
                for (var i = 0; i < times.Count;) {
                    var time = times[i];
                    if (time < now.AddSeconds(-timespan))
                        times.RemoveAt(i);
                    else {
                        ++n; ++i;
                    }
                }
                if (n >= limit) {
                    player.ChatMessage("You may only suicide " + (limit == 1 ? "once" : limit + " times") + " per " + timespan + " seconds.");
                    return true;
                }
                times.Add(now);
            } else {
                times = new List<DateTime>();
                times.Add(now);
                suicides.Add(player.userID, times);
            }
            return null;
        }
    }
}


// --- End of file: LimitedSuicide.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TextPromo.cs ---
// --- Original Local Path: TextPromo.cs ---

﻿using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Numerics;
using System.Security.Cryptography.X509Certificates;
using ConVar;
using Facepunch.Extend;
using Newtonsoft.Json;
using Newtonsoft.Json.Serialization;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using Random = UnityEngine.Random;
namespace Oxide.Plugins
{
    [Info("TextPromo", "TopPlugin.ru", "1.0.0")]
    public class TextPromo : RustPlugin
    {
        public class ConfigData
        {
            [JsonProperty("Адресс магазина")] public string nameserver;
            [JsonProperty("Первый промо")] public string promo1;
            [JsonProperty("Второй промо")] public string promo2;
            [JsonProperty("Сколько игроков получит промо")] public int count;
            public static ConfigData GetNewConf()
            {
                ConfigData newConfig = new ConfigData();
                newConfig.nameserver = "RUST PINK";
                newConfig.promo1 = "wipe (25RUB)";
                newConfig.promo2 = "MAGAZIN - rustpink.ru ";
                newConfig.count = 50;
                return newConfig;
            }
        }
        protected override void LoadDefaultConfig() => cfg = ConfigData.GetNewConf();
        protected override void SaveConfig() => Config.WriteObject(cfg);

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                cfg = Config.ReadObject<ConfigData>();
            }
            catch
            {
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }
        private ConfigData cfg { get; set;}
        public List<TextPromos> TextPromo2 = new List<TextPromos>();

        [ChatCommand("givepromonote")]
        void cmdgive(BasePlayer player)
        {
            if (player.IsAdmin)
            {
                GivePromo(player);
            }
        }
        public class TextPromos
        {
            [JsonProperty("Ник")] public string Name { get; set; }
            [JsonProperty("СтимАйди")] public ulong SteamID { get; set; }
            [JsonProperty("Выдал")] public bool Vidal { get; set; }
        }
        void OnPlayerInit(BasePlayer player)
        {
            TextPromos data = TextPromo2.Find(x => x.SteamID == player.userID);
            if((player is NPCPlayer)) return;
            if (TextPromo2.Count >= cfg.count)
            {
                return;
            }
            if (player.IsAdmin)
            {
                return;
            }
            if (data == null)
            {
                data = new TextPromos()
                {
                    Name = player.displayName,
                    SteamID = player.userID,
                    Vidal = false,
                };
                TextPromo2.Add(data);
                return;
            }

            if (data.Vidal)
            {
                return;
            }
            if (data != null)
            {
                GivePromo(player);
                SendReply(player, "Вы зашли на вайп сервера, вы получили промо-код в записке.");
                data.Vidal = true;
                SaveData();
            }
        }
        void OnPlayerSleepEnded(BasePlayer player)
        {
            OnPlayerInit(player);
        }
        void GivePromo(BasePlayer player)
        {
            Item it = ItemManager.CreateByName("note", 1);
            it.name = "PROMO";
            it.skin = 1923090978;
            it.text = $"{cfg.nameserver}\n\nPROMO:\n{cfg.promo1}\n{cfg.promo2}\n\n{cfg.nameserver}";
            if (!player.inventory.GiveItem(it))
            {
                it.Drop(player.inventory.containerMain.dropPosition,
                    player.inventory.containerMain.dropVelocity,
                    new Quaternion());
            }
        }
        void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject("TextPromoData", TextPromo2);
        }
        void OnServerInitialized()
        {
            TextPromo2 = Interface.Oxide.DataFileSystem.ReadObject<List<TextPromos>>("TextPromoData");
        }
    }
}

// --- End of file: TextPromo.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/FastOvens.cs ---
// --- Original Local Path: FastOvens.cs ---

using System.Collections.Generic;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Fast Ovens", "Orange", "1.0.6")]
    [Description("Make your ovens smelt faster")]
    public class FastOvens : RustPlugin
    {
        #region Oxide Hooks

        private void OnFuelConsume(BaseOven oven, Item item, ItemModBurnable burnable)
        {
            SmeltItems(oven);
        }

        #endregion

        #region Core

        private void SmeltItems(BaseOven oven)
        {
            var isCampfire = oven.inventory.capacity != 6 && oven.inventory.capacity != 18;
            if (isCampfire == true && config.workWithCampfires == false)
            {
                return;
            }

            foreach (var item in oven.inventory.itemList.ToArray())
            {
                var rate = GetRate(item.info.shortname);
                if (rate < 2)
                {
                    continue;
                }
                
                var resultModifier = 1;
                var resultDef = (ItemDefinition) null;
                var cookable = item.info.GetComponent<ItemModCookable>();
                if (cookable != null)
                {
                    resultDef = cookable.becomeOnCooked;
                    resultModifier = cookable.amountOfBecome;
                }
                else
                {
                        var burnable = item.info.GetComponent<ItemModBurnable>();
                        if (burnable != null)
                        {
                            resultDef = burnable.byproductItem;
                            resultModifier = burnable.byproductAmount * config.charcoalMultiplier;
                        }
                }

                if (config.stopBurningFood == true && resultDef != null && resultDef.shortname.EndsWith(".burned"))
                {
                    return;
                }

                Smelt(oven, item, rate, resultDef, resultModifier);
            }
        }

        private static void Smelt(BaseOven oven, Item cookingItem, int smeltRate, ItemDefinition targetDef, int targetMultiplier)
        {
            if (targetDef == null)
            {
                return;
            }

            if (targetMultiplier == 0)
            {
                targetMultiplier = 1;
            }

            var amount = 0;
            if (cookingItem.amount > smeltRate)
            {
                cookingItem.amount -= smeltRate;
                cookingItem.MarkDirty();
                amount = smeltRate;
            }
            else
            {
                cookingItem.GetHeldEntity()?.Kill();
                cookingItem.DoRemove();
                amount = cookingItem.amount;
            }

            if (amount == 0)
            {
                return;
            }

            var obj = ItemManager.Create(targetDef, amount * targetMultiplier);
            if (obj.MoveToContainer(oven.inventory) == false)
            {
                obj.Drop(oven.inventory.dropPosition, oven.inventory.dropVelocity);
            }
        }

        private int GetRate(string shortname)
        {
            var rate = 0;
            
            if (config.rates.TryGetValue(shortname, out rate) == true)
            {
                return rate;
            }
            
            if (shortname.Contains(".raw") && config.rates.TryGetValue("meat", out rate) == true)
            {
                return rate;
            }

            if (shortname.Contains(".ore") && config.rates.TryGetValue("ore", out rate) == true)
            {
                return rate;
            }
            
            if (config.rates.TryGetValue("*", out rate) == true)
            {
                return rate;
            }
            
            return 0;
        }

        #endregion

        #region Configuration | 2.0.0

        private static ConfigData config = new ConfigData();

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Work with campfires")]
            public bool workWithCampfires = true;

            [JsonProperty("Stop burning food")]
            public bool stopBurningFood = true;

            [JsonProperty(PropertyName = "Charcoal multiplier")]
            public int charcoalMultiplier = 2;
            
            [JsonProperty(PropertyName = "Rates")] 
            public Dictionary<string, int> rates = new Dictionary<string, int>();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigData>();

                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                for (var i = 0; i < 3; i++)
                {
                    PrintError("Configuration file is corrupt! Check your config file at https://jsonlint.com/");
                }

                LoadDefaultConfig();
                return;
            }

            ValidateConfig();
            SaveConfig();
        }

        private static void ValidateConfig()
        {
            if (config.rates.Count == 0)
            {
                config.rates = new Dictionary<string, int>
                {
                    {"ore", 10},
                    {"meat", 5},
                    {"hq.metal.ore", 5},
                    {"wood", 5},
                    {"*", 1},
                };
            }
        }

        protected override void LoadDefaultConfig()
        {
            config = new ConfigData();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion
    }
}

// --- End of file: FastOvens.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/LogoMenu2.cs ---
// --- Original Local Path: LogoMenu2.cs ---

﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("LogoMenu", "", "1.1.0")]
    public class LogoMenu : RustPlugin
    {
        [PluginReference] private Plugin ImageLibrary;

        public List<BasePlayer> PlayersTime = new List<BasePlayer>();

        public string Layer = "LogoMenu";
        public string LayerOnline = "LogoMenu.Online";
        public string LayerButton = "LogoMenu.Button";

        public float FadeIn = 1.0f;
        public float FadeOut = 0.7f;

        private Dictionary<string, string> Images = new Dictionary<string, string>
        {
            ["GS_Store"] = "https://cdn.discordapp.com/attachments/727064710238830643/943852653224550453/LightRust_1243.png",
            ["Online"] = "https://cdn.discordapp.com/attachments/1018247567508774965/1041700929457627176/1.png",
            ["CargoPlane"] = "https://cdn.discordapp.com/attachments/1018247567508774965/1041448035609235466/c44335b18ccdd010.png",
            ["Helicopter"] = "https://cdn.discordapp.com/attachments/1018247567508774965/1041446635219202129/LightRust_1.png",
            ["CH47Helicopter"] = "https://cdn.discordapp.com/attachments/1018247567508774965/1041448035898630144/76b1d033bbdbeba7.png",
            ["BradleyAPC"] = "https://cdn.discordapp.com/attachments/1018247567508774965/1041448426119888906/1.png",
            ["MenuButton"] = "https://cdn.discordapp.com/attachments/922548321531338772/922577086722502656/ec653bf8c05f2fb9.png",
            ["porno"] = "https://cdn.discordapp.com/attachments/1047137189076672543/1047188912373764207/1516806452_741_gaymanporn_org.png"
        };

        private void OnServerInitialized()
        {
            foreach (var check in Images)
                ImageLibrary.Call("AddImage", check.Value, check.Key);

            foreach (var player in BasePlayer.activePlayerList)
            {
                OnPlayerConnected(player);
            }
        }

        void OnPlayerConnected(BasePlayer player)
        {
            if (player.IsReceivingSnapshot)
            {
                NextTick(() => OnPlayerConnected(player));
                return;
            }

            UpdatePlayerUI();
        }

        void OnPlayerDisconnected(BasePlayer player)
        {
            UpdatePlayerUI();
        }

        private void UpdatePlayerUI()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                timer.Once(1, () =>
                {
                    OnlineTextUI(player);

                    MenuUI(player);
                });
            }
        }

        void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, Layer);
                CuiHelper.DestroyUi(player, LayerButton);
            }

            foreach (var player in PlayersTime)
            {
                CuiHelper.DestroyUi(player, LayerOnline);
            }
        }


        [ConsoleCommand("logo.menu.open")]
        private void CMD_ClickMenu(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            CuiElementContainer container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = "0 0 0 0" },
                RectTransform = { AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin = "0 -720", OffsetMax = "680 -65" },
            }, "Hud", Layer);

            container.Add(new CuiElement
            {
                Name = Layer + ".porno",
                Parent = Layer,
                Components =
                {
                    new CuiRawImageComponent {Png = ImageLibrary.Call<string>("GetImage", "porno" ), Color = "0 0 0 0"},
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0", AnchorMax = "1 1",
                    }
                }
            });


        }

        void OnlineTextUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, LayerOnline);

            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = "0 0 0 0" },
                RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "0 -34", OffsetMax = "300 0" },
            }, "Hud", LayerOnline);

            string online = $"{BasePlayer.activePlayerList.Count}/{ConVar.Server.maxplayers}";

            container.Add(new CuiElement
            {
                Parent = LayerOnline,
                Name = Layer + ".Text",
                Components =
                {
                    new CuiTextComponent { Text = online, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 13, Color = HexToRustFormat("#FFFFFF99") },
                    new CuiRectTransformComponent{ AnchorMin = "0.3 0", AnchorMax = "0.3 0", OffsetMin = "-24 6.5", OffsetMax = "27.5 30" },
                }
            });

            CuiHelper.AddUi(player, container);
        }

        void MenuUI(BasePlayer player) /*bool open = false*/
        {
            CuiHelper.DestroyUi(player, Layer);

            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = "0 0 0 0" },
                RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "0 -34", OffsetMax = "300 0" },
            }, "Hud", Layer);

            container.Add(new CuiElement
            {
                Parent = Layer,
                Name = Layer + ".GameStores.Picture",
                Components =
                {
                    new CuiRawImageComponent { Color = HexToRustFormat("##FFFFFF29"), Png = (string) ImageLibrary.Call("GetImage", "GS_Store") },
                    new CuiRectTransformComponent { AnchorMin = "0.1 0", AnchorMax = "0.1 0", OffsetMin = "-16.5 6.5", OffsetMax = "7 30" }
                }
            });

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.1 0", AnchorMax = "0.1 0", OffsetMin = "-16.5 6.5", OffsetMax = "7 30" },
                Text = { Text = "" },
                Button =
                {
                    Color = "0 0 0 0",
                    Command = "chat.say /store"
                }

            }, Layer);

            container.Add(new CuiElement
            {
                Parent = Layer,
                Name = Layer + ".Online.Picture",
                Components =
                {
                    new CuiRawImageComponent { Color = HexToRustFormat("##FFFFFF29"), Png = (string) ImageLibrary.Call("GetImage", "Online") },
                    new CuiRectTransformComponent { AnchorMin = "0.2 0", AnchorMax = "0.2 0", OffsetMin = "-20 6.5", OffsetMax = "3.5 30" }
                }
            });

            //if (open)
            //{
            container.Add(new CuiElement
            {
                Parent = Layer,
                Name = Layer + ".CargoPlane",
                FadeOut = FadeOut,
                Components =
                    {
                        new CuiImageComponent { FadeIn = FadeIn, Color = "0 0 0 0" },
                        new CuiRectTransformComponent { AnchorMin = "0.4 0", AnchorMax = "0.4 0", OffsetMin = "0 6.5", OffsetMax = "23.5 30" }
                    }
            });

            container.Add(new CuiElement
            {
                Parent = Layer,
                Name = Layer + ".BaseHelicopter",
                FadeOut = FadeOut,
                Components =
                    {
                        new CuiImageComponent { FadeIn = FadeIn, Color = "0 0 0 0" },
                        new CuiRectTransformComponent { AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "-1 6.5", OffsetMax = "22 30" }
                    }
            });

            container.Add(new CuiElement
            {
                Parent = Layer,
                Name = Layer + ".CH47Helicopter",
                FadeOut = FadeOut,
                Components =
                    {
                        new CuiImageComponent { FadeIn = FadeIn, Color = "0 0 0 0" },
                        new CuiRectTransformComponent { AnchorMin = "0.6 0", AnchorMax = "0.6 0", OffsetMin = "-3 6.5", OffsetMax = "20 30" }
                    }
            });

            container.Add(new CuiElement
            {
                Parent = Layer,
                Name = Layer + ".BradleyAPC",
                FadeOut = FadeOut,
                Components =
                    {
                        new CuiImageComponent { FadeIn = FadeIn, Color = "0 0 0 0" },
                        new CuiRectTransformComponent { AnchorMin = "0.7 0", AnchorMax = "0.7 0", OffsetMin = "-5 6.5", OffsetMax = "18 30" }
                    }
            });
            //}

            CuiHelper.AddUi(player, container);

            RefreshUI(player, "CargoPlane");
            RefreshUI(player, "BaseHelicopter");
            RefreshUI(player, "BradleyAPC");
            RefreshUI(player, "CH47Helicopter");
        }

        /*void ButtonMenuUI(BasePlayer player)
	    {
		    CuiHelper.DestroyUi(player, LayerButton);
		    
		    CuiElementContainer container = new CuiElementContainer();

		    container.Add(new CuiPanel
		    {
			    CursorEnabled = false,
			    Image = { Color = "0 0 0 0" },
			    RectTransform = { AnchorMin = "0.764 1", AnchorMax = "0.764 1", OffsetMin = "0 -34", OffsetMax = "300 0" },
		    }, "Hud", LayerButton);

		    container.Add(new CuiElement
		    {
			    Parent = LayerButton,
			    Components =
			    {
				    new CuiRawImageComponent { Color = HexToRustFormat("##FFFFFF29"), Png = (string) ImageLibrary.Call("GetImage", "MenuButton") },
				    new CuiRectTransformComponent { AnchorMin = "0.9 0", AnchorMax = "0.9 0", OffsetMin = "2 6.5", OffsetMax = "25.5 30" },
			    }
		    });
	        
		    container.Add(new CuiButton	
		    {
			    RectTransform = { AnchorMin = "0.9 0", AnchorMax = "0.9 0", OffsetMin = "2 6.5", OffsetMax = "25.5 30" },
			    Button = { Command = "logo.menu.open", Color = "0 0 0 0" },
			    Text = { Text = "" }
		    }, LayerButton);
		    
		    CuiHelper.AddUi(player, container);
	    }*/


        private void RefreshUI(BasePlayer player, string Type)
        {
            CuiElementContainer RefreshContainer = new CuiElementContainer();

            switch (Type)
            {
                case "CargoPlane":
                    CuiHelper.DestroyUi(player, Layer + ".CargoPlane.Destroy");

                    RefreshContainer.Add(new CuiElement
                    {
                        Parent = Layer + ".CargoPlane",
                        Name = Layer + ".CargoPlane.Destroy",
                        FadeOut = FadeOut,
                        Components =
                        {
                            new CuiRawImageComponent
                            {
                                FadeIn = FadeIn, Color = IsCargoPlane() ? HexToRustFormat("##EDBE5C5B") : HexToRustFormat("##FFFFFF29"),
                                Png = (string) ImageLibrary.Call("GetImage", "CargoPlane")
                            },
                            new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" },
                        }
                    });
                    break;

                case "BaseHelicopter":
                    CuiHelper.DestroyUi(player, Layer + ".BaseHelicopter.Destroy");

                    RefreshContainer.Add(new CuiElement
                    {
                        Parent = Layer + ".BaseHelicopter",
                        Name = Layer + ".BaseHelicopter.Destroy",
                        FadeOut = FadeOut,
                        Components =
                        {
                            new CuiRawImageComponent
                            {
                                FadeIn = FadeIn, Color = IsBaseHelicopter() ? HexToRustFormat("##EDBE5C5B") : HexToRustFormat("##FFFFFF29"),
                                Png = (string) ImageLibrary.Call("GetImage", "Helicopter")
                            },
                            new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" },
                        }
                    });
                    break;

                case "BradleyAPC":
                    CuiHelper.DestroyUi(player, Layer + ".BradleyAPC.Destroy");

                    RefreshContainer.Add(new CuiElement
                    {
                        Parent = Layer + ".BradleyAPC",
                        Name = Layer + ".BradleyAPC.Destroy",
                        FadeOut = FadeOut,
                        Components =
                        {
                            new CuiRawImageComponent
                            {
                                FadeIn = FadeIn, Color = IsBradleyAPC() ? HexToRustFormat("##EDBE5C5B") : HexToRustFormat("##FFFFFF29"),
                                Png = (string) ImageLibrary.Call("GetImage", "BradleyAPC")
                            },
                            new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" },
                        }
                    });
                    break;

                case "CH47Helicopter":
                    CuiHelper.DestroyUi(player, Layer + ".CH47Helicopter.Destroy");

                    RefreshContainer.Add(new CuiElement
                    {
                        Parent = Layer + ".CH47Helicopter",
                        Name = Layer + ".CH47Helicopter.Destroy",
                        FadeOut = FadeOut,
                        Components =
                        {
                            new CuiRawImageComponent
                            {
                                FadeIn = FadeIn, Color = IsCH47Helicopter() ? HexToRustFormat("##EDBE5C5B") : HexToRustFormat("##FFFFFF29"),
                                Png = (string) ImageLibrary.Call("GetImage", "CH47Helicopter")
                            },
                            new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" },
                        }
                    });
                    break;
            }

            CuiHelper.AddUi(player, RefreshContainer);
        }

        void OnEntitySpawned(BaseNetworkable entity)
        {
            if (entity == null || entity?.net.ID == null) return;

            string type = string.Empty;

            if (entity is CargoPlane)
                type = "CargoPlane";
            if (entity is BaseHelicopter)
                type = "BaseHelicopter";
            if (entity is BradleyAPC)
                type = "BradleyAPC";
            if (entity is CH47Helicopter)
                type = "CH47Helicopter";

            RefreshUI(type);
        }

        void OnEntityKill(BaseNetworkable entity)
        {
            if (entity == null || entity?.net.ID == null) return;

            string type = string.Empty;

            if (entity is CargoPlane)
                type = "CargoPlane";
            if (entity is BaseHelicopter)
                type = "BaseHelicopter";
            if (entity is BradleyAPC)
                type = "BradleyAPC";
            if (entity is CH47Helicopter)
                type = "CH47Helicopter";

            RefreshUI(type);
        }

        private void RefreshUI(string tag)
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                RefreshUI(player, tag);
            }
        }

        string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex)) hex = "#FFFFFFFF";
            var str = hex.Trim('#');
            if (str.Length == 6) str += "FF";
            if (str.Length != 8) throw new Exception(hex);

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber); asd
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);
            Color color = new Color32(r, g, b, a);

            return $"{color.r:F2} {color.g:F2} {color.b:F2} {color.a:F2}";
        }

        bool IsCargoPlane()
        {
            foreach (var check in BaseNetworkable.serverEntities)
                if (check is CargoPlane) return true;
            return false;
        }
        bool IsBaseHelicopter()
        {
            foreach (var check in BaseNetworkable.serverEntities)
                if (check is BaseHelicopter) return true;
            return false;
        }
        bool IsBradleyAPC()
        {
            foreach (var check in BaseNetworkable.serverEntities)
                if (check is BradleyAPC) return true;
            return false;
        }
        bool IsCH47Helicopter()
        {
            foreach (var check in BaseNetworkable.serverEntities)
                if (check is CH47Helicopter) return true;
            return false;
        }
    }
}

// --- End of file: LogoMenu2.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/ClansUI.cs ---
// --- Original Local Path: ClansUI.cs ---

﻿//Requires: Clans
using System.Collections.Generic;
using System.Globalization;
using Oxide.Core;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("ClansUI", "BGRM", "0.1.43", ResourceId = 0)]
    class ClansUI : RustPlugin
    {
        #region Fields
        [PluginReference] Clans Clans;
        
        const string ClanUI = "ClansUI";
        const string ClanBG = "ClansUIBG";
        private int maxMembers;
        private int maxAllies;
        private bool canToggleFF;
        private bool alliesEnabled;

        SortedList<string, string> playerList = new SortedList<string, string>();
        private List<ulong> openMenu = new List<ulong>();
        #endregion

        #region Oxide Hooks
        void Loaded()
        {
            lang.RegisterMessages(Messages, this);
        }
        void OnServerInitialized()
        {
            LoadVariables();
            if (Clans.Author != "Oxide Россия - oxide-russia.ru")
            cmd.AddChatCommand(configData.MenuActivation.CommandToOpen, this, cmdClanUI);
            maxMembers = Clans.limitMembers;
            maxAllies = Clans.limitAlliances;
            canToggleFF = Clans.enableFFOPtion;
            alliesEnabled = Clans.enableClanAllies;

            foreach (var player in BasePlayer.activePlayerList)
                OnPlayerInit(player);
        }
        void OnPlayerInit(BasePlayer player)
        {
            var name = TrimToSize(RemoveTag(player.displayName), 15);
            if (!playerList.ContainsKey(player.UserIDString))
                playerList.Add(player.UserIDString, name);
            else playerList[player.UserIDString] = name;
        }
        void OnPlayerDisconnected(BasePlayer player)
        {            
            CuiHelper.DestroyUi(player, ClanBG);
            CuiHelper.DestroyUi(player, ClanUI);
        }
        void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, ClanBG);
                CuiHelper.DestroyUi(player, ClanUI);
            }
        }
        #endregion

        #region Functions
        private string RemoveTag(string str)
        {
            if (str.StartsWith("[") && str.Contains("]") && str.Length > str.IndexOf("]"))
            {
                str = str.Substring(str.IndexOf("]") + 1).Trim();
            }

            if (str.StartsWith("[") && str.Contains("]") && str.Length > str.IndexOf("]"))
                RemoveTag(str);

            return str;
        }

        private string TrimToSize(string str, int size) => str.Length <= size ? str : str.Substring(0, size);
        #endregion

        #region UI
        class UI
        {
            static public CuiElementContainer CreateElementContainer(string panelName, string color, string aMin, string aMax, bool cursor = false, string parent = "Hud")
            {
                var NewElement = new CuiElementContainer()
            {
                {
                    new CuiPanel
                    {
                        Image = {Color = color},
                        RectTransform = {AnchorMin = aMin, AnchorMax = aMax},
                        CursorEnabled = cursor
                    },
                    new CuiElement().Parent = parent,
                    panelName
                }
            };
                return NewElement;
            }
            static public void CreatePanel(ref CuiElementContainer container, string panel, string color, string aMin, string aMax, bool cursor = false)
            {
                container.Add(new CuiPanel
                {
                    Image = { Color = color },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    CursorEnabled = cursor
                },
                panel, CuiHelper.GetGuid());
            }
            static public void CreateLabel(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiLabel
                {
                    Text = { Color = color, FontSize = size, Align = align, FadeIn = 0, Text = text },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax }
                },
                panel, CuiHelper.GetGuid());

            }
            static public void CreateButton(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, string command, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiButton
                {
                    Button = { Color = color, Command = command, FadeIn = 0 },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    Text = { Text = text, FontSize = size, Align = align }
                },
                panel, CuiHelper.GetGuid());
            }
            static public string Color(string hexColor, float alpha)
            {
                if (hexColor.StartsWith("#"))
                    hexColor = hexColor.TrimStart('#');
                int red = int.Parse(hexColor.Substring(0, 2), NumberStyles.AllowHexSpecifier);
                int green = int.Parse(hexColor.Substring(2, 2), NumberStyles.AllowHexSpecifier);
                int blue = int.Parse(hexColor.Substring(4, 2), NumberStyles.AllowHexSpecifier);
                return $"{(double)red / 255} {(double)green / 255} {(double)blue / 255} {alpha}";
            }
        }
        #endregion

        #region UI Creation
        enum AllianceType { Current, Pending, Offer }
        class PlayerInfo { public string playerId, playerName; }
      
        void LoadClanMenu(BasePlayer player, Clans.Clan clan, int page = 0)
        {
            if (!openMenu.Contains(player.userID))
                openMenu.Add(player.userID);
            var container = UI.CreateElementContainer(ClanBG, "0 0 0 0", "0.15 0.15", "0.85 0.85", true);
            CuiHelper.AddUi(player, container);
            MembersMenu(player, clan, page);
        }
        void MembersMenu(BasePlayer player, Clans.Clan clan, int page = 0)
        {
            var container = UI.CreateElementContainer(ClanUI, UI.Color(configData.UIColors.Background.HexColor, configData.UIColors.Background.Opacity), $"{configData.UISize.X_Position} {configData.UISize.Y_Position}", $"{configData.UISize.X_Position + configData.UISize.X_Dimension} {configData.UISize.Y_Position + configData.UISize.Y_Dimension}");
            UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.CloseButton.HexColor, configData.UIColors.CloseButton.Opacity), "X", 18, "0.965 0.945", "0.998 0.995", "ClansUI close");

            UI.CreateLabel(ref container, ClanUI, "", msg("title", player.UserIDString), 18, "0.02 0.94", "0.5 1", TextAnchor.MiddleLeft);
            UI.CreatePanel(ref container, ClanUI, UI.Color(configData.UIColors.Background.HexColor, configData.UIColors.Background.Opacity), "0.0001 0.0001", "0.9999 0.94");
            UI.CreateLabel(ref container, ClanUI, "", $"{msg("name", player.UserIDString)} {clan.tag}\n\n{msg("description", player.UserIDString)} {clan.description}", 14, "0.02 0.72", "0.25 0.93", TextAnchor.UpperLeft);

            UI.CreatePanel(ref container, ClanUI, UI.Color(configData.UIColors.TitlePanel.HexColor, configData.UIColors.TitlePanel.Opacity), "0.26 0.875", "0.99 0.93");
            UI.CreateLabel(ref container, ClanUI, "", msg("settingsTitle", player.UserIDString), 16, "0.28 0.875", "0.97 0.93", TextAnchor.MiddleLeft);
            
            UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), $"{msg("ffToggle", player.UserIDString)}  :  {(Clans.HasFFEnabled(player.userID) ? msg("on", player.UserIDString) : !canToggleFF ? msg("disabled", player.UserIDString) : msg("off", player.UserIDString))}", 15, "0.26 0.805", "0.51 0.86", canToggleFF ? $"ClansUI toggleff {page}" : "");

            UI.CreatePanel(ref container, ClanUI, UI.Color(configData.UIColors.TextPanel.HexColor, configData.UIColors.TitlePanel.Opacity), "0.26 0.735", "0.75 0.79");
            UI.CreateLabel(ref container, ClanUI, "", $"{msg("allies",player.UserIDString)} {(alliesEnabled ? clan.clanAlliances.ToSentence() : msg("disabled", player.UserIDString))}", 15, "0.27 0.735", "0.75 0.79", TextAnchor.MiddleLeft);
            UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), msg("manageAlliances", player.UserIDString), 15, "0.76 0.735", "0.99 0.79", alliesEnabled ? "ClansUI alliances 0" : "");

            UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), msg("memberInvite", player.UserIDString), 15, "0.52 0.805", "0.75 0.86", "ClansUI invitelist 0");
            UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), msg("cancelInvites", player.UserIDString), 15, "0.76 0.805", "0.99 0.86", "ClansUI cancelinvites 0");

            UI.CreatePanel(ref container, ClanUI, UI.Color(configData.UIColors.TitlePanel.HexColor, configData.UIColors.TitlePanel.Opacity), "0.01 0.67", "0.25 0.72");
            UI.CreatePanel(ref container, ClanUI, UI.Color(configData.UIColors.TextPanel.HexColor, configData.UIColors.TextPanel.Opacity), "0.26 0.67", "0.99 0.72");
            UI.CreateLabel(ref container, ClanUI, "", msg("members", player.UserIDString), 16, "0.02 0.67", "0.25 0.72", TextAnchor.MiddleLeft);
            UI.CreateLabel(ref container, ClanUI, "", $"({clan.members.Count}/{maxMembers})", 16, "0.02 0.67", "0.23 0.72", TextAnchor.MiddleRight);

            for (int i = (10 * page); i < clan.members.Count; i++)
            {
                if (i >= (10 * page) + 10)               
                    break;         
                string memberId = clan.members[i];
                bool isOwner = false;
                bool isPlayer = false;
                if (memberId == player.UserIDString)
                {
                    if (clan.IsOwner(memberId))
                        isOwner = true;
                    else isPlayer = true;
                }
                AddClanMember(ref container, player.UserIDString, memberId, i - (10 * page), page, clan.IsOwner(memberId) ? msg("ownerTag", player.UserIDString) : clan.IsCouncil(memberId) ? msg("councilTag", player.UserIDString) : clan.IsModerator(memberId) ? msg("modTag", player.UserIDString) : "", isOwner, isPlayer);
            }

            bool hasPages = false;
            int maxCount = clan.members.Count;
            if (maxCount > 10)
            {
                hasPages = true;
                var maxpages = (maxCount - 1) / 10 + 1;
                if (page < maxpages - 1)
                    UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), ">>>", 14, "0.16 0.01", "0.24 0.05", $"ClansUI members {page + 1}");
                if (page > 0)
                    UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), "<<<", 14, "0.02 0.01", "0.1 0.05", $"ClansUI members {page - 1}");
            }

            UI.CreatePanel(ref container, ClanUI, UI.Color(configData.UIColors.TitlePanel.HexColor, configData.UIColors.TitlePanel.Opacity), $"{(hasPages ? 0.26f : 0.01f)} 0.01", "0.99 0.05");
            UI.CreateLabel(ref container, ClanUI, "", msg("info", player.UserIDString).Replace("{clanversion}", Clans.Version.ToString()).Replace("{uiversion}", Version.ToString()), 12, $"{(hasPages ? 0.27f : 0.02f)} 0.01", "0.98 0.05", TextAnchor.MiddleCenter);
            
            CuiHelper.DestroyUi(player, ClanUI);
            CuiHelper.AddUi(player, container);
        }
        void AddClanMember(ref CuiElementContainer container, string playerId, string memberId, int number, int page, string status, bool isOwner, bool isPlayer)
        {
            var targetPlayer = covalence.Players.FindPlayerById(memberId);
            float yPos = 0.6f - (0.06f * number);
            UI.CreatePanel(ref container, ClanUI, UI.Color(configData.UIColors.TextPanel.HexColor, configData.UIColors.TextPanel.Opacity), $"0.02 {yPos}", $"0.24 {yPos + 0.05f}");
            UI.CreateLabel(ref container, ClanUI, "", targetPlayer?.Name ?? memberId, 14, $"0.03 {yPos}", $"0.23 {yPos + 0.05f}", TextAnchor.MiddleLeft);
            UI.CreatePanel(ref container, ClanUI, UI.Color(configData.UIColors.TextPanel.HexColor, configData.UIColors.TextPanel.Opacity), $"0.26 {yPos}", $"0.31 {yPos + 0.05f}");
            UI.CreateLabel(ref container, ClanUI, "", status, 14, $"0.265 {yPos}", $"0.305 {yPos + 0.05f}");
            for (int i = 0; i < configData.Commands.Count; i++)
            {
                float xPos = 0.315f + (0.075f * i);
                var command = configData.Commands[i];
                UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), command.Name, 14, $"{xPos} {yPos}", $"{xPos + 0.07f} {yPos + 0.05f}", $"ClansUI command {i} {memberId} {targetPlayer?.Name.Replace(" ", "$$%%^^") ?? memberId}");
            }
            if (isOwner)
            {
                UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), msg("leave", playerId), 14, $"0.855 {yPos}", $"0.925 {yPos + 0.05f}", $"ClansUI leave {page} {memberId}");
                UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), msg("disband", playerId), 14, $"0.77 {yPos}", $"0.85 {yPos + 0.05f}", $"ClansUI predisband {page} {memberId}");
            }
            else if (isPlayer)
            {
                UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), msg("leave", playerId), 14, $"0.855 {yPos}", $"0.925 {yPos + 0.05f}", $"ClansUI leave {page} {memberId}");
            }
            else
            {
                UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), msg("promote", playerId), 14, $"0.77 {yPos}", $"0.85 {yPos + 0.05f}", $"ClansUI promote {page} {memberId}");
                UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), msg("demote", playerId), 14, $"0.855 {yPos}", $"0.925 {yPos + 0.05f}", $"ClansUI demote {page} {memberId}");
                UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), msg("kick", playerId), 14, $"0.93 {yPos}", $"0.99 {yPos + 0.05f}", $"ClansUI kick {page} {memberId}");
            }
        }
        void MemberSelection(BasePlayer player, Clans.Clan clan, int page, bool isRemoving = false)
        {
            var container = UI.CreateElementContainer(ClanUI, UI.Color(configData.UIColors.Background.HexColor, configData.UIColors.Background.Opacity), $"{configData.UISize.X_Position} {configData.UISize.Y_Position}", $"{configData.UISize.X_Position + configData.UISize.X_Dimension} {configData.UISize.Y_Position + configData.UISize.Y_Dimension}");
            UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.CloseButton.HexColor, configData.UIColors.CloseButton.Opacity), "X", 18, "0.965 0.945", "0.998 0.995", "ClansUI close");

            UI.CreateLabel(ref container, ClanUI, "", msg("title", player.UserIDString), 18, "0.02 0.94", "0.5 1", TextAnchor.MiddleLeft);
            UI.CreatePanel(ref container, ClanUI, UI.Color(configData.UIColors.Background.HexColor, configData.UIColors.Background.Opacity), "0.0001 0.0001", "0.9999 0.94");

            UI.CreatePanel(ref container, ClanUI, UI.Color(configData.UIColors.TitlePanel.HexColor, configData.UIColors.TitlePanel.Opacity), "0.01 0.875", "0.854 0.93");
            UI.CreateLabel(ref container, ClanUI, "", isRemoving ? msg("cancelSelect", player.UserIDString) : msg("memberSelect", player.UserIDString), 16, "0.02 0.875", "0.844 0.93", TextAnchor.MiddleLeft);

            UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), msg("back", player.UserIDString), 15, "0.864 0.875", "0.99 0.93", "ClansUI members 0");

            int count = isRemoving ? clan.invites.Count : playerList.Count();
            for (int i = (84 * page); i < count; i++)
            {
                if (i >= (84 * page) + 84)
                    break;
                var targetId = isRemoving ? clan.invites.Keys.ToArray()[i] : playerList.Keys[i];
                MemberButton(ref container, playerList[targetId], targetId, i - (84 * page), isRemoving);
            }

            bool hasPages = false;
            int maxCount = isRemoving ? clan.invites.Count : playerList.Count;
            if (maxCount > 84)
            {
                hasPages = true;
                var maxpages = (maxCount - 1) / 84 + 1;
                if (page < maxpages - 1)
                    UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), ">>>", 14, "0.16 0.01", "0.24 0.05", $"ClansUI invitelist {page + 1}");
                if (page > 0)
                    UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), "<<<", 14, "0.02 0.01", "0.1 0.05", $"ClansUI invitelist {page - 1}");
            }

            UI.CreatePanel(ref container, ClanUI, UI.Color(configData.UIColors.TitlePanel.HexColor, configData.UIColors.TitlePanel.Opacity), $"{(hasPages ? 0.26f : 0.01f)} 0.01", "0.99 0.05");
            UI.CreateLabel(ref container, ClanUI, "", msg("info", player.UserIDString).Replace("{clanversion}", Clans.Version.ToString()).Replace("{uiversion}", Version.ToString()), 12, $"{(hasPages ? 0.27f : 0.02f)} 0.01", "0.98 0.05", TextAnchor.MiddleCenter);

            CuiHelper.DestroyUi(player, ClanUI);
            CuiHelper.AddUi(player, container);
        }
        void MemberButton(ref CuiElementContainer container, string name, string playerId, int number, bool isRemoving)
        {
            float[] position = CalculateEntryPos(number);
            UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), isRemoving ? covalence.Players.FindPlayerById(name)?.Name ?? name : name, 14, $"{position[0]} {position[1]}", $"{position[2]} {position[3]}", $"ClansUI {(isRemoving ? "withdraw" : "invitemember")} 0 {(isRemoving ? name : playerId)}");
        }

        void AllianceMenu(BasePlayer player, Clans.Clan clan, AllianceType type = AllianceType.Current, int page = 0)
        {
            var container = UI.CreateElementContainer(ClanUI, UI.Color(configData.UIColors.Background.HexColor, configData.UIColors.Background.Opacity), $"{configData.UISize.X_Position} {configData.UISize.Y_Position}", $"{configData.UISize.X_Position + configData.UISize.X_Dimension} {configData.UISize.Y_Position + configData.UISize.Y_Dimension}");
            UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.CloseButton.HexColor, configData.UIColors.CloseButton.Opacity), "X", 18, "0.965 0.945", "0.998 0.995", "ClansUI close");

            UI.CreateLabel(ref container, ClanUI, "", msg("title", player.UserIDString), 18, "0.02 0.94", "0.5 1", TextAnchor.MiddleLeft);
            UI.CreatePanel(ref container, ClanUI, UI.Color(configData.UIColors.Background.HexColor, configData.UIColors.Background.Opacity), "0.0001 0.0001", "0.9999 0.94");
            UI.CreateLabel(ref container, ClanUI, "", $"{msg("name", player.UserIDString)} {clan.tag}", 14, "0.02 0.72", "0.25 0.93", TextAnchor.UpperLeft);

            UI.CreatePanel(ref container, ClanUI, UI.Color(configData.UIColors.TitlePanel.HexColor, configData.UIColors.TitlePanel.Opacity), "0.26 0.875", "0.99 0.93");
            UI.CreateLabel(ref container, ClanUI, "", msg("allianceSettings", player.UserIDString), 16, "0.28 0.875", "0.97 0.93", TextAnchor.MiddleLeft);
                       
            UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), msg("alliances", player.UserIDString), 15, "0.26 0.805", "0.401 0.86", "ClansUI alliances 0 current");
            UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), msg("offers", player.UserIDString), 15, "0.411 0.805", "0.552 0.86", "ClansUI alliances 0 offer");
            UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), msg("invites", player.UserIDString), 15, "0.562 0.805", "0.703 0.86", "ClansUI alliances 0 invites");
            UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), msg("offerAlliance", player.UserIDString), 15, "0.713 0.805", "0.854 0.86", "ClansUI offermenu 0");
            UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), msg("back", player.UserIDString), 15, "0.864 0.805", "0.99 0.86", "ClansUI members 0");

            UI.CreatePanel(ref container, ClanUI, UI.Color(configData.UIColors.TitlePanel.HexColor, configData.UIColors.TitlePanel.Opacity), "0.01 0.805", "0.25 0.86");
            UI.CreatePanel(ref container, ClanUI, UI.Color(configData.UIColors.TextPanel.HexColor, configData.UIColors.TitlePanel.Opacity), "0.26 0.805", "0.99 0.56");
            UI.CreateLabel(ref container, ClanUI, "", type == AllianceType.Current ? msg("alliances", player.UserIDString) : type == AllianceType.Offer ? msg("offers", player.UserIDString) : msg("invites", player.UserIDString), 16, "0.02 0.805", "0.25 0.86", TextAnchor.MiddleLeft);
            if (type == AllianceType.Current)
                UI.CreateLabel(ref container, ClanUI, "", $"({clan.clanAlliances.Count}/{maxAllies})", 16, "0.02 0.805", "0.23 0.86", TextAnchor.MiddleRight);

            List<string> allyList = type == AllianceType.Current ? clan.clanAlliances : type == AllianceType.Offer ? clan.invitedAllies : clan.pendingInvites;
            
            for (int i = (12 * page); i < allyList.Count; i++)
            {
                if (i >= (12 * page) + 12)
                    break;
                string allyTag = allyList[i];
                AddAlliance(ref container, type, player.UserIDString, allyTag, i - (12 * page), page);
            }
            
            bool hasPages = false;
            int maxCount = allyList.Count;
            if (maxCount > 10)
            {
                hasPages = true;
                var maxpages = (maxCount - 1) / 10 + 1;
                if (page < maxpages - 1)
                    UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), ">>>", 14, "0.16 0.01", "0.24 0.05", $"ClansUI alliances {page + 1} {type}");
                if (page > 0)
                    UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), "<<<", 14, "0.02 0.01", "0.1 0.05", $"ClansUI alliances {page - 1} {type}");                
            }
           
            UI.CreatePanel(ref container, ClanUI, UI.Color(configData.UIColors.TitlePanel.HexColor, configData.UIColors.TitlePanel.Opacity), $"{(hasPages ? 0.26f : 0.01f)} 0.01", "0.99 0.05");
            UI.CreateLabel(ref container, ClanUI, "", msg("info", player.UserIDString).Replace("{clanversion}", Clans.Version.ToString()).Replace("{uiversion}", Version.ToString()), 12, $"{(hasPages ? 0.27f : 0.02f)} 0.01", "0.98 0.05", TextAnchor.MiddleCenter);

            CuiHelper.DestroyUi(player, ClanUI);
            CuiHelper.AddUi(player, container);
        }
        void AddAlliance(ref CuiElementContainer container, AllianceType type, string playerId, string clanTag, int number, int page)
        {
            float yPos = 0.735f - (0.06f * number);
            UI.CreatePanel(ref container, ClanUI, UI.Color(configData.UIColors.TextPanel.HexColor, configData.UIColors.TextPanel.Opacity), $"0.02 {yPos}", $"0.24 {yPos + 0.05f}");
            UI.CreateLabel(ref container, ClanUI, "", clanTag, 14, $"0.03 {yPos}", $"0.23 {yPos + 0.05f}", TextAnchor.MiddleLeft);
            UI.CreatePanel(ref container, ClanUI, UI.Color(configData.UIColors.TextPanel.HexColor, configData.UIColors.TextPanel.Opacity), $"0.26 {yPos}", $"0.401 {yPos + 0.05f}");
            UI.CreateLabel(ref container, ClanUI, "", $"{msg("members", playerId)}: {Clans.findClan(clanTag).members.Count}", 14, $"0.27 {yPos}", $"0.391 {yPos + 0.05f}", TextAnchor.MiddleLeft);
            if (type == AllianceType.Current)
                UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), msg("allyCancel", playerId), 14, $"0.864 {yPos}", $"0.99 {yPos + 0.05f}", $"ClansUI cancelalliance {page} {clanTag}");

            else if (type == AllianceType.Offer)            
                UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), msg("allyRetract", playerId), 14, $"0.864 {yPos}", $"0.99 {yPos + 0.05f}", $"ClansUI canceloffer {page} {clanTag}");
            
            else if (type == AllianceType.Pending)
            {
                UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), msg("allyAccept", playerId), 14, $"0.73 {yPos}", $"0.854 {yPos + 0.05f}", $"ClansUI acceptoffer {page} {clanTag}");
                UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), msg("allyDecline", playerId), 14, $"0.864 {yPos}", $"0.99 {yPos + 0.05f}", $"ClansUI declineoffer {page} {clanTag}");
            }
        } 
        void AllySelection(BasePlayer player, Clans.Clan clan, int page)
        {
            var container = UI.CreateElementContainer(ClanUI, UI.Color(configData.UIColors.Background.HexColor, configData.UIColors.Background.Opacity), $"{configData.UISize.X_Position} {configData.UISize.Y_Position}", $"{configData.UISize.X_Position + configData.UISize.X_Dimension} {configData.UISize.Y_Position + configData.UISize.Y_Dimension}");
            UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.CloseButton.HexColor, configData.UIColors.CloseButton.Opacity), "X", 18, "0.965 0.945", "0.998 0.995", "ClansUI close");

            UI.CreateLabel(ref container, ClanUI, "", msg("title", player.UserIDString), 18, "0.02 0.94", "0.5 1", TextAnchor.MiddleLeft);
            UI.CreatePanel(ref container, ClanUI, UI.Color(configData.UIColors.Background.HexColor, configData.UIColors.Background.Opacity), "0.0001 0.0001", "0.9999 0.94");

            UI.CreatePanel(ref container, ClanUI, UI.Color(configData.UIColors.TitlePanel.HexColor, configData.UIColors.TitlePanel.Opacity), "0.01 0.875", "0.854 0.93");
            UI.CreateLabel(ref container, ClanUI, "", msg("allySelect", player.UserIDString), 16, "0.02 0.875", "0.844 0.93", TextAnchor.MiddleLeft);

            UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), msg("back", player.UserIDString), 15, "0.864 0.875", "0.99 0.93", "ClansUI alliances 0");
              
            for (int i = (84 * page); i < Clans.clans.Count; i++)
            {
                if (i >= (84 * page) + 84)
                    break;
                string allyTag = Clans.clans.Keys.ToArray()[i];
                ClanAllyButton(ref container, allyTag, i - (84 * page));
            }
            
            bool hasPages = false;
            int maxCount = Clans.clans.Keys.Count;
            if (maxCount > 84)
            {
                hasPages = true;
                var maxpages = (maxCount - 1) / 84 + 1;
                if (page < maxpages - 1)
                    UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), ">>>", 14, "0.16 0.01", "0.24 0.05", $"ClansUI offermenu {page + 1}");
                if (page > 0)
                    UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), "<<<", 14, "0.02 0.01", "0.1 0.05", $"ClansUI offermenu {page - 1}");
            }

            UI.CreatePanel(ref container, ClanUI, UI.Color(configData.UIColors.TitlePanel.HexColor, configData.UIColors.TitlePanel.Opacity), $"{(hasPages ? 0.26f : 0.01f)} 0.01", "0.99 0.05");
            UI.CreateLabel(ref container, ClanUI, "", msg("info", player.UserIDString).Replace("{clanversion}", Clans.Version.ToString()).Replace("{uiversion}", Version.ToString()), 12, $"{(hasPages ? 0.27f : 0.02f)} 0.01", "0.98 0.05", TextAnchor.MiddleCenter);

            CuiHelper.DestroyUi(player, ClanUI);
            CuiHelper.AddUi(player, container);
        }
        void ClanAllyButton(ref CuiElementContainer container, string clanTag, int number)
        {
            float[] position = CalculateEntryPos(number);
            UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), clanTag, 14, $"{position[0]} {position[1]}", $"{position[2]} {position[3]}", $"ClansUI offeralliance 0 {clanTag}");
        }
        void ConfirmDisband(BasePlayer player, Clans.Clan clan)
        {
            var container = UI.CreateElementContainer(ClanUI, UI.Color(configData.UIColors.Background.HexColor, configData.UIColors.Background.Opacity), $"0.35 0.4", $"0.65 0.6");
            UI.CreateLabel(ref container, ClanUI, "", msg("disband", player.UserIDString), 18, "0.02 0.8", "0.5 1", TextAnchor.MiddleLeft);
            UI.CreatePanel(ref container, ClanUI, UI.Color(configData.UIColors.Background.HexColor, configData.UIColors.Background.Opacity), "0.0001 0.0001", "0.9999 0.8");
            UI.CreateLabel(ref container, ClanUI, "", msg("confirmDisband", player.UserIDString), 18, "0.1 0.5", "0.9 0.85");
            UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), msg("confirm", player.UserIDString), 14, "0.1 0.1", "0.45 0.3", $"ClansUI disband 0");
            UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), msg("back", player.UserIDString), 14, "0.55 0.1", "0.9 0.3", $"ClansUI members 0");
            CuiHelper.DestroyUi(player, ClanUI);
            CuiHelper.AddUi(player, container);
        }
        private float[] CalculateEntryPos(int number)
        {
            Vector2 position = new Vector2(0.01f, 0.805f);
            Vector2 dimensions = new Vector2(0.1315f, 0.055f);
            float offsetY = 0;
            float offsetX = 0;
            if (number >= 0 && number < 7)
            {
                offsetX = (0.01f + dimensions.x) * number;
            }
            if (number > 6 && number < 14)
            {
                offsetX = (0.01f + dimensions.x) * (number - 7);
                offsetY = (-0.01f - dimensions.y) * 1;
            }
            if (number > 13 && number < 21)
            {
                offsetX = (0.01f + dimensions.x) * (number - 14);
                offsetY = (-0.01f - dimensions.y) * 2;
            }
            if (number > 20 && number < 28)
            {
                offsetX = (0.01f + dimensions.x) * (number - 21);
                offsetY = (-0.01f - dimensions.y) * 3;
            }
            if (number > 27 && number < 35)
            {
                offsetX = (0.01f + dimensions.x) * (number - 28);
                offsetY = (-0.01f - dimensions.y) * 4;
            }
            if (number > 34 && number < 42)
            {
                offsetX = (0.01f + dimensions.x) * (number - 35);
                offsetY = (-0.01f - dimensions.y) * 5;
            }
            if (number > 41 && number < 49)
            {
                offsetX = (0.01f + dimensions.x) * (number - 42);
                offsetY = (-0.01f - dimensions.y) * 6;
            }
            if (number > 48 && number < 56)
            {
                offsetX = (0.01f + dimensions.x) * (number - 49);
                offsetY = (-0.01f - dimensions.y) * 7;
            }
            if (number > 55 && number < 63)
            {
                offsetX = (0.01f + dimensions.x) * (number - 56);
                offsetY = (-0.01f - dimensions.y) * 8;
            }
            if (number > 62 && number < 70)
            {
                offsetX = (0.01f + dimensions.x) * (number - 63);
                offsetY = (-0.01f - dimensions.y) * 9;
            }
            if (number > 69 && number < 77)
            {
                offsetX = (0.01f + dimensions.x) * (number - 70);
                offsetY = (-0.01f - dimensions.y) * 10;
            }
            if (number > 76 && number < 84)
            {
                offsetX = (0.01f + dimensions.x) * (number - 77);
                offsetY = (-0.01f - dimensions.y) * 11;
            }
            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }
        #endregion

        #region UI Commands
        [ConsoleCommand("ClansUIToggle")]
        void ccmdClansUIToggle(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (!openMenu.Contains(player.userID))
            {                
                Clans.Clan clan = Clans.findClanByUser(player.UserIDString);
                if (clan == null)
                    SendReply(player, msg("cmdNoClan", player.UserIDString));
                else LoadClanMenu(player, clan);                
            }
            else
            {
                openMenu.Remove(player.userID);
                CuiHelper.DestroyUi(player, ClanBG);
                CuiHelper.DestroyUi(player, ClanUI);
            }
        }
        [ConsoleCommand("ClansUI")]
        void ccmdClansUI(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            string command = arg.GetString(0);
            if (command == "close")
            {
                openMenu.Remove(player.userID);
                CuiHelper.DestroyUi(player, ClanBG);
                CuiHelper.DestroyUi(player, ClanUI);
                return;
            }      
                  
            Clans.Clan clan = Clans.findClanByUser(player.UserIDString);
            int page = arg.GetInt(1);
            string targetId = "";
            if (arg.Args.Length > 2)
                targetId = arg.GetString(2);

            switch (arg.Args[0])
            {
                case "toggleff":
                    Clans.ToggleFF(player.userID);
                    MembersMenu(player, clan, page);
                    return;
                case "members":
                    MembersMenu(player, clan, page);
                    return;
                case "alliances":
                    AllianceType type = targetId == "invites" ? AllianceType.Pending : targetId == "offer" ? AllianceType.Offer : AllianceType.Current;
                    AllianceMenu(player, clan, type, page);
                    return;
                case "command":
                    string targetName = arg.GetString(3).Replace("$$%%^^", " ");
                    var cmd = configData.Commands[page];
                    rust.RunClientCommand(player, $"chat.say", new string[] { $"{cmd.Command} \"{cmd.Arg.Replace("{playerName}", targetName).Replace("{playerId}", targetId)}\"" });
                    return;
                case "promote":
                    Clans.PromotePlayer(player, targetId);
                    MembersMenu(player, clan, page);
                    return;
                case "demote":
                    Clans.DemotePlayer(player, targetId);
                    MembersMenu(player, clan, page);
                    return;
                case "kick":
                    Clans.KickPlayer(player, targetId);
                    MembersMenu(player, clan, page);
                    return;
                case "invitelist":
                    MemberSelection(player, clan, page);
                    return;
                case "cancelinvites":
                    MemberSelection(player, clan, page, true);
                    return;
                case "invitemember":
                    Clans.InvitePlayer(player, targetId);
                    MemberSelection(player, clan, 0);
                    return;
                case "withdraw":
                    Clans.WithdrawPlayer(player, targetId);
                    MemberSelection(player, clan, page, true);
                    return;
                case "offermenu":
                    AllySelection(player, clan, page);
                    return;
                case "offeralliance":
                    Clans.Alliance(player, targetId, "request");
                    AllianceMenu(player, clan, AllianceType.Offer, 0);
                    return;
                case "cancelalliance":
                    Clans.Alliance(player, targetId, "cancel");
                    AllianceMenu(player, clan, AllianceType.Current, page);
                    return;
                case "canceloffer":
                    Clans.Alliance(player, targetId, "cancel");
                    AllianceMenu(player, clan, AllianceType.Offer, page);
                    return;
                case "declineoffer":
                    Clans.Alliance(player, targetId, "decline");
                    AllianceMenu(player, clan, AllianceType.Pending, page);
                    return;
                case "acceptoffer":
                    Clans.Alliance(player, targetId, "accept");
                    AllianceMenu(player, clan, AllianceType.Current, page);
                    return;
                case "leave":
                    Clans.LeaveClan(player);
                    openMenu.Remove(player.userID);
                    CuiHelper.DestroyUi(player, ClanBG);
                    CuiHelper.DestroyUi(player, ClanUI);
                    return;
                case "predisband":
                    ConfirmDisband(player, clan);
                    return;
                case "disband":
                    Clans.DisbandClan(player);
                    openMenu.Remove(player.userID);
                    CuiHelper.DestroyUi(player, ClanBG);
                    CuiHelper.DestroyUi(player, ClanUI);
                    return;
                default:
                    break;
            }           
        }
        #endregion

        #region Commands
        void cmdClanUI(BasePlayer player, string command, string[] args)
        {            
            Clans.Clan clan = Clans.findClanByUser(player.UserIDString);
            if (clan == null)
                SendReply(player, msg("cmdNoClan", player.UserIDString));
            else LoadClanMenu(player, clan);
        }
        #endregion       

        #region Config        
        private ConfigData configData;
        class MenuActivation
        {
            public string CommandToOpen { get; set; }
        }
        class UIColor
        {
            public string HexColor { get; set; }
            public float Opacity { get; set; }
        }
        class UIColors
        {
            public UIColor Background { get; set; }
            public UIColor TitlePanel { get; set; }
            public UIColor TextPanel { get; set; }
            public UIColor CloseButton { get; set; }
            public UIColor ButtonColor { get; set; }            
        }
        class UISize
        {
            public float X_Position { get; set; }
            public float X_Dimension { get; set; }
            public float Y_Position { get; set; }
            public float Y_Dimension { get; set; }
        }
        class CommandButton
        {
            public string Name { get; set; }
            public string Command { get; set; }
            public string Arg { get; set; }
        }
        class ConfigData
        {
            public List<CommandButton> Commands { get; set; }
            public UIColors UIColors { get; set; }
            public UISize UISize { get; set; }
            public MenuActivation MenuActivation { get; set; }
        }
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                Commands = new List<CommandButton>
                {
                    new CommandButton
                    {
                        Name = "TPR",
                        Command = "/tpr",
                        Arg = "{playerName}"
                    },
                    new CommandButton
                    {
                        Name = "TRADE",
                        Command = "/trade",
                        Arg = "{playerName}"
                    }
                },
                MenuActivation = new MenuActivation
                {
                    CommandToOpen = "cmenu",
                },
                UIColors = new UIColors
                {
                    Background = new UIColor { HexColor = "#00001F", Opacity = 0.7f },
                    ButtonColor = new UIColor { HexColor = "#00006A", Opacity = 0.7f },
                    TextPanel = new UIColor { HexColor = "#00006A", Opacity = 0.7f },
                    TitlePanel = new UIColor { HexColor = "#0000B2", Opacity = 0.7f },
                    CloseButton = new UIColor { HexColor = "#ce422b", Opacity = 0.7f }
                },
                UISize = new UISize
                {                    
                    X_Position = 0.31f,
                    X_Dimension = 0.685f,
                    Y_Position = 0.2f,
                    Y_Dimension = 0.7f
                }
            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion
                
        #region Messages
        string msg(string key, string playerId = null) => lang.GetMessage(key, this, playerId);
        Dictionary<string, string> Messages = new Dictionary<string, string>()
        {
            {"title", "Clan Administration"},
            {"name", "Name: "},
            {"description", "Description: "},
            {"members", "Members"},
            {"settingsTitle", "CLAN OWNER/COUNCIL SETTINGS"},
            {"ffToggle", "Clan Friendly Fire"},
            {"radarToggle", "Clan Radar"},
            {"allyAdmin", "Alliances Administration"},
            {"allyCount", "Allies ({0}/{1}):"},
            {"ownerTag", "OWN"},
            {"councilTag", "COUN"},
            {"modTag", "MOD"},
            {"promote", "PROMOTE"},
            {"demote", "DEMOTE"},
            {"kick", "KICK"},
            {"allyRetract", "Retract Offer" },
            {"allyDecline", "Decline Offer"},
            {"allyAccept", "Accept Offer" },
            {"allyCancel", "Cancel Alliance"},
            {"memberInvite", "Invite Player"},
            {"cancelInvites", "Cancel Invites" },
            {"manageAlliances", "Manage Alliances" },
            {"memberCancel", "Cancel Invite" },
            {"cmdNoClan", "You are not a member of any active clan" },
            {"on", "<color=#00E500>ON</color>" },
            {"off", "<color=#ce422b>OFF</color>" },
            {"info", "ClansREBORN v{clanversion} :: UI v{uiversion}" },
            {"allies", "Allies:" },
            {"alliances", "Alliances" },
            {"allianceSettings", "CLAN ALLIANCES" },
            {"offers", "Offers" },
            {"invites", "Invites" },
            {"offerAlliance", "Offer an Alliance" },
            {"back", "Back" },
            {"allySelect", "Select a clan from the list to offer an alliance with" },
            {"memberSelect", "Select a player from the list to offer a membership to" },
            {"cancelSelect", "Select a pending invitation to cancel" },
            {"disabled", "Disabled" },
            {"leave", "LEAVE" },
            {"disband", "DISBAND" },
            {"confirmDisband", "Click 'confirm' to proceed" },
            {"confirm", "Confirm" }
        };
        #endregion
    }
}


// --- End of file: ClansUI.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TeamMarker.cs ---
// --- Original Local Path: TeamMarker.cs ---

﻿﻿using System;
 using System.Collections.Generic;
 using Newtonsoft.Json;
using Oxide.Core;
 using UnityEngine;
 using VLB;

 namespace Oxide.Plugins
{
    [Info("TeamMarker", "Seires", "1.0.2")]
    [Description("Displays marker for you and your teammates.")]
    
    class TeamMarker : RustPlugin
    {
        #region Classes

        private class PluginConfig
        {
            [JsonProperty("Activation button (Check list for valid buttons below)")] 
            public string ActivateButton;
            [JsonProperty("Marker symbol (From ASCII table: https://www.ascii-code.com)")]
            public char MarkerSymbol;
            [JsonProperty("The time how long marker is visible")]
            public int MarkerTime;
            [JsonProperty("Cooldown time")]
            public int MarkerDelay;
            [JsonProperty("Max distance to locate the marker")]
            public int MarkerDist;
            [JsonProperty("Marker color")] 
            public string MarkerColor;
            [JsonProperty("Font size of marker info")]
            public int InfoFontSize;
            [JsonProperty("Color of text")] 
            public string InfoTextColor;
            [JsonProperty("Effect prefab")] 
            public string EffectPrefab;

            [JsonIgnore] public BUTTON ActButton;
            
            [JsonProperty("Buttons list (Read only)")] 
            public string[] Buttons = Enum.GetNames(typeof(BUTTON));
        }
        
        #endregion
        
        #region Variables

        private static TeamMarker _plugin;
        
        private static PluginConfig _config;
        private const string PermissionUse = "teammarker.use";
        private Effect _effect = new Effect();

        #endregion
        
        #region Config

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                _config = Config.ReadObject<PluginConfig>();
                if (_config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                for (var i = 0; i < 3; i++)
                {
                    PrintError("Configuration file is corrupt! Check your config file at https://jsonlint.com/");
                }

                LoadDefaultConfig();
                return;
            }

            if (_config != null)
            {
                _config.ActButton = BUTTON.FIRE_THIRD;
                Enum.TryParse(_config.ActivateButton, out _config.ActButton);
            }
            
            ValidateConfig();
            SaveConfig();
        }

        private void ValidateConfig()
        {
            if (Interface.Oxide.CallHook("OnConfigValidate") != null)
            {
                PrintWarning("Using default configuration...");
                _config = GetDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }

        protected override void LoadDefaultConfig()
        {
            _config = GetDefaultConfig();
        }
        
        private PluginConfig GetDefaultConfig()
        {
            return new PluginConfig()
            {
                ActivateButton = "FIRE_THIRD",
                MarkerSymbol = 'S',
                MarkerTime = 4,
                MarkerDelay = 1,
                MarkerDist = 300,
                MarkerColor = "#704f5b",
                InfoFontSize = 12,
                InfoTextColor = "#704f5b",
                EffectPrefab = "assets/bundled/prefabs/fx/notice/loot.copy.fx.prefab"
            };
        }
        
        #endregion

        #region Hooks

        void OnServerInitialized()
        {
            _plugin = this;
            
            RegPermission(PermissionUse);

            _effect.Init(Effect.Type.Generic, Vector3.zero, Vector3.zero);
            _effect.pooledString = _config.EffectPrefab;
            
            for (var i = BasePlayer.activePlayerList.Count - 1; i >= 0; i--)
            {
                OnPlayerConnected(BasePlayer.activePlayerList[i]);
            }
        }

        void Unload()
        {
            InputController.DestroyAll();
        }
        
        void OnPlayerConnected(BasePlayer player)
        {
            if (player == null) return;

            if (player.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot))
            {
                timer.Once(2f, () => OnPlayerConnected(player));
                return;
            }

            if (!player.IsConnected) return;
            
            InputController.Init(player);
        }

        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            var comp = player.GetComponent<InputController>();
            if(comp != null)
                UnityEngine.Object.Destroy(comp);
        }

        #endregion
        
        #region Utils

        void PlayFx(BasePlayer player)
        {
            EffectNetwork.Send(_effect, player.net.connection);
        }

        public void RegPermission(string name)
        {
            if (permission.PermissionExists(name)) return;
            permission.RegisterPermission(name, this);
        }
        
        public bool HasPermission(BasePlayer player, string name)
        {
            if (player.IsAdmin)
                return true;
            
            return permission.UserHasPermission(player.UserIDString, name);
        }

        #endregion

        #region Scripts

        private class InputController : MonoBehaviour
        {
            public static List<InputController> InputControllers = new List<InputController>();
            private BasePlayer _player;
            private RealTimeSince _markerCooldown;
            private RealTimeSince _markerLifeTime;
            private Vector3 _lastMarkerPosition;

            public static void Init(BasePlayer player)
            {
                player.GetOrAddComponent<InputController>();
            }

            public static void DestroyAll()
            {
                for (var i = InputControllers.Count - 1; i >= 0; i--)
                {
                    Destroy(InputControllers[i]);
                }
            }
            
            private void Awake()
            {
                _player = GetComponent<BasePlayer>();
                if (_player == null)
                {
                    Destroy(this);
                    return;
                }
                
                InputControllers.Add(this);
            }

            private void Update()
            {
                if (_player.serverInput.WasJustPressed(_config.ActButton) == false) 
                    return;
                
                if (_markerCooldown < _config.MarkerDelay)
                    return;
                
                _markerCooldown = 0;

                MarkerCheck();
            }

            private void MarkerCheck()
            {
                if(_plugin.HasPermission(_player, PermissionUse) == false) 
                    return;
                
                if(IsInvoking(nameof(MarkerUpdate)))
                    CancelInvoke(nameof(MarkerUpdate));
                
                DrawMarker();
            }

            // ReSharper disable Unity.PerformanceAnalysis
            private void DrawMarker()
            {
                Ray ray = new Ray(_player.eyes.position, _player.eyes.HeadForward());
                RaycastHit hit;
                
                if (Physics.Raycast(ray, out hit, _config.MarkerDist,
                    LayerMask.GetMask(new[] {"Terrain", "World", "Construction", "Player (Server)", "Deployed"})) == false) return;
                
                _lastMarkerPosition = hit.point;

                if (_lastMarkerPosition == Vector3.zero)
                    return;

                _markerLifeTime = 0;

                if (_player.currentTeam == 0)
                    _plugin.PlayFx(_player);
                else
                {
                    foreach (var member in _player.Team.GetOnlineMemberConnections())
                    {
                        if (member.player as BasePlayer != null)
                            _plugin.PlayFx(member.player as BasePlayer);
                    }
                }

                InvokeRepeating(nameof(MarkerUpdate), 0f, 0.1f);
            }

            private void MarkerUpdate()
            {
                if (_markerLifeTime >= _config.MarkerTime)
                {
                    CancelInvoke(nameof(MarkerUpdate));
                    return;
                }

                if (_player.currentTeam == 0)
                {
                    _player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, true);
                    _player.SendEntityUpdate();
                    _player.SendConsoleCommand("ddraw.text", 0.1f, Color.white, _lastMarkerPosition,
                        $"<color={_config.MarkerColor}>{_config.MarkerSymbol}</color>\n<color={_config.InfoTextColor}><size={_config.InfoFontSize}>{Math.Round(Vector3.Distance(_player.transform.position, _lastMarkerPosition))} m</size></color>");
                    _player.SendConsoleCommand("camspeed 0");

                    if(_player.Connection.authLevel < 2)
                        _player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, false);
            
                    _player.SendEntityUpdate();
                }
                else
                {
                    var members = _player.Team.GetOnlineMemberConnections();

                    for (var i = members.Count - 1; i >= 0; i--)
                    {
                        var member = members[i].player as BasePlayer;

                        if (member == null)
                            continue;
                        
                        member.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, true);
                        member.SendEntityUpdate();
                        member.SendConsoleCommand("ddraw.text", 0.1f, Color.white, _lastMarkerPosition,
                            $"<color={_config.MarkerColor}>{_config.MarkerSymbol}</color>\n<color={_config.InfoTextColor}><size={_config.InfoFontSize}>{Math.Round(Vector3.Distance(member.transform.position, _lastMarkerPosition))} m\n{_player.displayName}</size></color>");
                        member.SendConsoleCommand("camspeed 0");

                        if(member.Connection.authLevel < 2)
                            member.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, false);
            
                        member.SendEntityUpdate();
                    }
                }
            }
        }

        #endregion
    }
}

// --- End of file: TeamMarker.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Martyrdom.cs ---
// --- Original Local Path: Martyrdom.cs ---

using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Martyrdom", "k1lly0u", "0.2.0", ResourceId = 1523)]
    class Martyrdom : RustPlugin
    {
        #region Fields
        private Dictionary<ulong, EType> Martyrs;
        Dictionary<EType, ExplosiveInfo> Explosives;
        #endregion

        #region Oxide Hooks
        void Loaded()
        {
            Martyrs = new Dictionary<ulong, EType>();
            Explosives = new Dictionary<EType, ExplosiveInfo>();
            permission.RegisterPermission("martyrdom.grenade", this);
            permission.RegisterPermission("martyrdom.beancan", this);
            permission.RegisterPermission("martyrdom.explosive", this);
            lang.RegisterMessages(messages, this);
        }
        void OnServerInitialized()
        {
            LoadVariables();
            SetExplosiveInfo();
        }

        void OnEntityDeath(BaseEntity entity, HitInfo info)
        {
            if (entity is BasePlayer)
            {
                var victim = entity.ToPlayer();
                if (Martyrs.ContainsKey(victim.userID))
                {
                    TryDropExplosive(victim);
                }
            }
        }
        #endregion

        #region Functions
        void TryDropExplosive(BasePlayer player)
        {
            var type = Martyrs[player.userID];
            if (HasPerm(player, type))
            {
                if (HasEnoughRes(player, Explosives[type].ItemID, 1))
                {
                    TakeResources(player, Explosives[type].ItemID, 1);
                    CreateExplosive(type, player);
                    Martyrs.Remove(player.userID);
                    return;
                }
            }            
        }
        void CreateExplosive(EType type, BasePlayer player)
        {
            var Details = Explosives[type];
            var expEnt = GameManager.server.CreateEntity(Details.PrefabName, player.transform.position + new Vector3(0, 1.5f, 0), new Quaternion(), true);
            expEnt.OwnerID = player.userID;
            expEnt.creatorEntity = player;
            TimedExplosive explosive = expEnt.GetComponent<TimedExplosive>();
            explosive.timerAmountMax = Details.Fuse;
            explosive.timerAmountMin = Details.Fuse;
            explosive.explosionRadius = Details.Radius;
            explosive.damageTypes = new List<Rust.DamageTypeEntry> { new Rust.DamageTypeEntry {amount = Details.Damage, type = Rust.DamageType.Explosion } };
            explosive.Spawn();
        }
        #endregion

        #region Helpers
        private bool HasEnoughRes(BasePlayer player, int itemid, int amount) => player.inventory.GetAmount(itemid) >= amount;
        private void TakeResources(BasePlayer player, int itemid, int amount) => player.inventory.Take(null, itemid, amount);
        private bool HasPerm(BasePlayer player, EType type)
        {
            switch (type)
            {
                case EType.Grenade:
                    return permission.UserHasPermission(player.UserIDString, "martyrdom.grenade") || player.IsAdmin();
                case EType.Beancan:
                    return permission.UserHasPermission(player.UserIDString, "martyrdom.beancan") || player.IsAdmin();
                case EType.Explosive:
                    return permission.UserHasPermission(player.UserIDString, "martyrdom.explosive") || player.IsAdmin();                
            }
            return false;
        }
        private bool HasAnyPerm(BasePlayer player) => permission.UserHasPermission(player.UserIDString, "martyrdom.grenade") || permission.UserHasPermission(player.UserIDString, "martyrdom.beancan") || permission.UserHasPermission(player.UserIDString, "martyrdom.explosive") || player.IsAdmin();
        #endregion

        #region Explosive Info       
        void SetExplosiveInfo()
        {
            if (configData.Beancan.Activated)
                Explosives.Add(EType.Beancan, new ExplosiveInfo { ItemID = 384204160, PrefabName = "assets/prefabs/weapons/beancan grenade/grenade.beancan.deployed.prefab", Damage = configData.Beancan.Damage, Fuse = configData.Beancan.Fuse, Radius = configData.Beancan.Radius });
            if (configData.Grenade.Activated)
                Explosives.Add(EType.Grenade, new ExplosiveInfo { ItemID = -1308622549, PrefabName = "assets/prefabs/weapons/f1 grenade/grenade.f1.deployed.prefab", Damage = configData.Grenade.Damage, Fuse = configData.Grenade.Fuse, Radius = configData.Grenade.Radius });
            if (configData.Explosive.Activated)
                Explosives.Add(EType.Explosive, new ExplosiveInfo { ItemID = 498591726, PrefabName = "assets/prefabs/tools/c4/explosive.timed.deployed.prefab", Damage = configData.Explosive.Damage, Fuse = configData.Explosive.Fuse, Radius = configData.Explosive.Radius });
        }

        class ExplosiveInfo
        {
            public int ItemID;
            public string PrefabName;
            public float Damage;
            public float Radius;
            public float Fuse;
        }
        enum EType
        {
            Grenade,
            Beancan,
            Explosive
        }
        #endregion

        #region Chat Commands        
        [ChatCommand("m")]
        void cmdM(BasePlayer player, string command, string[] args)
        {
            if (!HasAnyPerm(player)) return;
            if (args == null || args.Length == 0)
            {
                if (HasPerm(player, EType.Beancan) && configData.Beancan.Activated)
                    SendReply(player, "/m beancan");
                if (HasPerm(player, EType.Grenade) && configData.Grenade.Activated)
                    SendReply(player, "/m grenade");
                if (HasPerm(player, EType.Explosive) && configData.Explosive.Activated)
                    SendReply(player, "/m explosive");
                SendReply(player, "/m disable");
                return;
            }
            switch (args[0].ToLower())
            {
                case "beancan":
                    if (HasPerm(player, EType.Beancan))
                    {
                        if (!Martyrs.ContainsKey(player.userID))
                            Martyrs.Add(player.userID, EType.Beancan);
                        else Martyrs[player.userID] = EType.Beancan;
                        SendReply(player, msg("beanAct", player.UserIDString));
                    }
                    return;
                case "grenade":
                    if (HasPerm(player, EType.Grenade))
                    {
                        if (!Martyrs.ContainsKey(player.userID))
                            Martyrs.Add(player.userID, EType.Grenade);
                        else Martyrs[player.userID] = EType.Grenade;
                        SendReply(player, msg("grenAct", player.UserIDString));
                    }
                    return;
                case "explosive":
                    if (HasPerm(player, EType.Explosive))
                    {
                        if (!Martyrs.ContainsKey(player.userID))
                            Martyrs.Add(player.userID, EType.Explosive);
                        else Martyrs[player.userID] = EType.Explosive;
                        SendReply(player, msg("expAct", player.UserIDString));
                    }
                    return;
                case "disable":
                    if (Martyrs.ContainsKey(player.userID))
                    {
                        Martyrs.Remove(player.userID);
                        SendReply(player, msg("marDis", player.UserIDString));
                        return;
                    }
                    else SendReply(player, msg("notAct", player.UserIDString));
                    return;
                default:
                    break;
            }

        }
        #endregion

        #region Config        
        private ConfigData configData;
        class ExpType
        {
            public bool Activated { get; set; }
            public float Damage { get; set; }
            public float Radius { get; set; }
            public float Fuse { get; set; }
        }
        class ConfigData
        {
            public ExpType Grenade { get; set; }
            public ExpType Beancan { get; set; }
            public ExpType Explosive { get; set; }
        }
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                Beancan = new ExpType
                {
                    Activated = true,
                    Damage = 15f,
                    Fuse = 2f,
                    Radius = 4.5f
                },
                Grenade = new ExpType
                {
                    Activated = true,
                    Damage = 40f,
                    Fuse = 2f,
                    Radius = 4.5f
                },
                Explosive = new ExpType
                {
                    Activated = true,
                    Damage = 500,
                    Fuse = 3,
                    Radius = 10f
                }
            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion

        #region Localization
        string msg(string key, string id = null) => lang.GetMessage(key, this, id);

        Dictionary<string, string> messages = new Dictionary<string, string>()
        {
            {"beanAct", "You have activated the beancan Martyr drop" },
            {"grenAct", "You have activated the grenade Martyr drop" },
            {"expAct", "You have activated the explosive Martyr drop" },
            {"marDis", "You have disabled Martyrdom" },
            {"notAct", "You do not have Martyrdom activated" }
        };

        #endregion
    }
}


// --- End of file: Martyrdom.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HeliSupport.cs ---
// --- Original Local Path: HeliSupport.cs ---

using System.Collections.Generic;
using ConVar;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Heli Support", "Unknown", "1.0.8")]
    public class HeliSupport : RustPlugin
    {
        #region Vars

        private const string nocdperm = "helisupport.callnocd";

        private const string heliprefab = "assets/prefabs/npc/patrol helicopter/patrolhelicopter.prefab";

        #endregion

        #region Oxide hooks

        private void OnServerInitialized()
        {
            permission.RegisterPermission(nocdperm, this);
        }

        private bool CanHelicopterTarget(PatrolHelicopterAI heli, BasePlayer player)
        {
            var id = heli.GetComponent<BaseEntity>().net.ID;

            if (!helis.ContainsKey(id))
            {
                return true;
            }

            return helis[id] != player.userID;
        }

        #endregion

        #region Data

        private Dictionary<uint, ulong> helis = new Dictionary<uint, ulong>(); // Heli id - Heli owner

        #endregion

        #region Commands

        [ChatCommand("heli")]
        private void CmdCall(BasePlayer player)
        {
            if (permission.UserHasPermission(player.UserIDString, nocdperm) || player.IsAdmin)
            {
                CallHeli(player);
                return;
            }

            player.ChatMessage("You dont have acess to user this command!");
        }

        [ConsoleCommand("heli.ctm")]
        private void CmdCall2(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            
            if (permission.UserHasPermission(player.UserIDString, nocdperm) || player.IsAdmin)
            {
                CallHeli(player);
                return;
            }

            player.ChatMessage("You dont have acess to user this command!");
        }

        #endregion
        

        #region Helpers

        private void CallHeli(BasePlayer player)
        {
            var entity = GameManager.server.CreateEntity(heliprefab);
            entity.Spawn();

            helis.Add(entity.net.ID, player.userID);
            
            player.ChatMessage("Heli is coming for you!");
            Server.Broadcast($"Игрок {player.displayName} вызвал патрульный вертолёт для своей защиты!");

            var heliai = entity.GetComponent<PatrolHelicopterAI>();
            
            StartPos(heliai, player.transform.position); 
        }
        
        private void StartPos(PatrolHelicopterAI heli, Vector3 pos)
        {
            heli.SetInitialDestination(pos);
            heli.interestZoneOrigin = pos;
            heli.MoveToDestination();
            heli.numRocketsLeft = 0;
            
            UpdatePos(heli, pos);
        }

        private void UpdatePos(PatrolHelicopterAI heli, Vector3 pos)
        {
            heli.ExitCurrentState();
            heli.State_Strafe_Enter(pos);
            heli.numRocketsLeft = 0;
            timer.Once(30f, () => 
            {
                if (heli.IsAlive())
                {
                    UpdatePos(heli, pos);
                }
            });
        }

        #endregion
    }
}

// --- End of file: HeliSupport.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/AdminChat.cs ---
// --- Original Local Path: AdminChat.cs ---

using System.Collections.Generic;
using System.Reflection;
using System;
using System.Data;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Admin Chat", "LaserHydra", "1.3.0", ResourceId = 1123)]
    [Description("Chat with admins only")]
    class AdminChat : RustPlugin
    {	
		#region Loaded
		//	On Plugin-Load
        void Loaded()
        {
			if(!permission.PermissionExists("adminchat.use")) permission.RegisterPermission("adminchat.use", this);
			LoadDefaultConfig();
        }
		#endregion
		
		#region Config
		//	Load Config
        protected override void LoadDefaultConfig()
        {
			if(Config["Prefix"] == null) Config["Prefix"] = "<color=red>[</color><color=#2B2B2B>ADMINCHAT</color><color=red>]</color>";
			if(Config["Prefix"].ToString() != "<color=red>[</color><color=#2B2B2B>ADMINCHAT</color><color=red>]</color>") return;
			
			if(Config["NameColor"] == null) Config["NameColor"] = "red";
			if(Config["NameColor"].ToString() != "red") return;

            SaveConfig();
        }
		#endregion
		
		#region AdminChat Command
		//	AdminChat command
        [ChatCommand("a")]
        void cmdAdminChat(BasePlayer player, string cmd, string[] args)
        {
            string uid = Convert.ToString(player.userID);
			
            if (!permission.UserHasPermission(uid, "adminchat.use"))
            {
                SendChatMessage(player, "ADMINCHAT", "You have no permission to use this command!");
                return;
            }

            if (args == null || args.Length < 1)
            {
                SendChatMessage(player, "ADMINCHAT", "Syntax: /a [message]");
            }

            string allArgs, message;
            allArgs = Convert.ToString(args[0]);

            foreach (string arg in args)
            {
                if (arg == Convert.ToString(args[0]))
                {
                    continue;
                }

                allArgs = allArgs + " " + arg;
            }

			SendAdminMessage(player.displayName, allArgs);
        }
		#endregion
				
		#region Useful Methods
        //--------------------------->   Player finding   <---------------------------//

        BasePlayer GetPlayer(string searchedPlayer, BasePlayer executer, string prefix)
        {
            BasePlayer targetPlayer = null;
            List<string> foundPlayers = new List<string>();
            string searchedLower = searchedPlayer.ToLower();
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                string display = player.displayName;
                string displayLower = display.ToLower();

                if (!displayLower.Contains(searchedLower))
                {
                    continue;
                }
                if (displayLower.Contains(searchedLower))
                {
                    foundPlayers.Add(display);
                }
            }
            var matchingPlayers = foundPlayers.ToArray();

            if (matchingPlayers.Length == 0)
            {
                SendChatMessage(executer, prefix, "No matching players found!");
            }

            if (matchingPlayers.Length > 1)
            {
                SendChatMessage(executer, prefix, "Multiple players found:");
                string multipleUsers = "";
                foreach (string matchingplayer in matchingPlayers)
                {
                    if (multipleUsers == "")
                    {
                        multipleUsers = "<color=yellow>" + matchingplayer + "</color>";
                        continue;
                    }

                    if (multipleUsers != "")
                    {
                        multipleUsers = multipleUsers + ", " + "<color=yellow>" + matchingplayer + "</color>";
                    }

                }
                SendChatMessage(executer, prefix, multipleUsers);
            }

            if (matchingPlayers.Length == 1)
            {
                targetPlayer = BasePlayer.Find(matchingPlayers[0]);
            }
            return targetPlayer;
        }
		
		//---------------------------->   Converting   <----------------------------//

        string ListToString(List<string> list)
        {
			string output;
			if(list.Count != 0)
			{
				output = list[0];
				foreach (string current in list)
				{
					if (current == list[0])
					{
						continue;
					}

					output = output + " " + current;
				}
			}
			else
			{
				output = "";
			}
            return output;
        }

        //---------------------------->   Chat Sending   <----------------------------//

        void BroadcastChat(string prefix, string msg)
        {
            PrintToChat("<color=orange>" + prefix + "</color>: " + msg);
        }

        void SendChatMessage(BasePlayer player, string prefix, string msg)
        {
            SendReply(player, "<color=orange>" + prefix + "</color>: " + msg);
        }
		
		// 	Send a message into the AdminChat
		void SendAdminMessage(string name, string msg)
		{
			foreach (BasePlayer current in BasePlayer.activePlayerList)
            {
				if (permission.UserHasPermission(current.userID.ToString(), "adminchat.use"))
				{
					SendChatMessage(current, Config["Prefix"] + " <color=" + Config["NameColor"] + ">" + name + "</color>", msg);
				}
            }
		}

        //---------------------------------------------------------------------------//
		#endregion
    }
}


// --- End of file: AdminChat.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/KitSystem.cs ---
// --- Original Local Path: KitSystem.cs ---

using System;
using Oxide.Core;
using System.Collections.Generic;
using System.Linq;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("KitSystem", "Sempai#3239", "1.0.0")]
    class KitSystem : RustPlugin
    {
        #region Вар
        string Layer = "Kit_UI";

        [PluginReference] Plugin ImageLibrary;

        Dictionary<ulong, Data> Settings = new Dictionary<ulong, Data>();
        #endregion

        #region Класс
        public class KitSettings 
        {
            public string Name;
            public string DisplayName;
            public double Cooldown;
            public int Amount;
            public string Perm;
            public string Url;
            public List<ItemSettings> Items;
        }

        public class ItemSettings
        {
            public string ShortName;
            public int Amount;
            public ulong SkinID;
            public string Container;
        }

        public class Data
        {
            public Dictionary<string, KitData> SettingsData = new Dictionary<string, KitData>();
        }

        public class KitData
        {
            public double Cooldown;
        }
        #endregion

        #region Конфиг
        Configuration config;
        class Configuration 
        {
            public string BannerURL = "";
            public string Description = "Buy more kits at <color=#db8c5a>store.хуита.ru</color>";
            public List<KitSettings> settings;
            public static Configuration GetNewConfig() 
            {
                return new Configuration
                {
                    settings = new List<KitSettings>() 
                    {
                        new KitSettings 
                        {
                            Name = "start",
                            DisplayName = "Start",
                            Cooldown = 10,
                            Amount = 2,
                            Perm = "kitsystem.use",
                            Url = "https://imgur.com/zpXoO6a.png",
                            Items = new List<ItemSettings>()
                            {
                                new ItemSettings
                                {
                                    ShortName = "wood",
                                    Amount = 1000,
                                    SkinID = 0,
                                    Container = "Main"
                                }
                            }
                        },
                    }
                };
            }
        }
        
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config?.settings == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning($"Ошибка чтения конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!!");
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewConfig();
        protected override void SaveConfig() => Config.WriteObject(config);
        #endregion

        #region Хуки
        void OnServerInitialized()
        {
            ImageLibrary.Call("AddImage", config.BannerURL, "Banner");
            foreach (var check in config.settings)
            {
                ImageLibrary.Call("AddImage", check.Url, check.Url);
                permission.RegisterPermission(check.Perm, this);
                foreach (var item in check.Items)
                    ImageLibrary.Call("AddImage", $"https://rustlabs.com/img/items180/{item.ShortName}.png", item.ShortName);
            }

            foreach (var check in BasePlayer.activePlayerList)
                OnPlayerConnected(check);
        }

        void OnPlayerConnected(BasePlayer player) => CreateDataBase(player); 

        void OnPlayerDisconnected(BasePlayer player, string reason) => SaveDataBase(player.userID);

        void Unload() 
        {
            foreach(var check in Settings)
                SaveDataBase(check.Key);
        }
        #endregion

        #region Дата
        void CreateDataBase(BasePlayer player)
        {
            var DataBase = Interface.Oxide.DataFileSystem.ReadObject<Data>($"KitSystem/{player.userID}");
            
            if (!Settings.ContainsKey(player.userID))
                Settings.Add(player.userID, new Data());
             
            Settings[player.userID] = DataBase ?? new Data();
        }

        void SaveDataBase(ulong userId) => Interface.Oxide.DataFileSystem.WriteObject($"KitSystem/{userId}", Settings[userId]);
        #endregion

        #region Команды
        [ConsoleCommand("kit")]
        void ConsoleKit(ConsoleSystem.Arg args)
        {
            var Time = CurTime();
            var player = args.Player();
            if (player != null && args.HasArgs(1))
            {
                if (args.Args[0] == "take")
                {
                    var check = config.settings.FirstOrDefault(z => z.Name == args.Args[1]);
                    if (player.inventory.containerMain.itemList.Count >= 24 || player.inventory.containerWear.itemList.Count >= 7 || player.inventory.containerBelt.itemList.Count >= 6)
                    {
                        SendReply(player, "Not enough space");
                        return;
                    }
                    var db = GetDataBase(player.userID, check.Name);
                    if (db.Cooldown > Time)
                    {
                        SendReply(player, "Wait");
                        return;
                    }
                    if (check.Cooldown > 0) db.Cooldown = Time + check.Cooldown;
                    if (check.Amount == 0)
                    {
                        SendReply(player, "You can no longer use this set");
                        return;
                    }
                    check.Amount -= 1;
                    foreach (var item in check.Items)
                    {
                        var items = ItemManager.CreateByItemID(ItemManager.FindItemDefinition(item.ShortName).itemid, item.Amount, item.SkinID);
                        var main = item.Container == "Main" ? player.inventory.containerMain : player.inventory.containerWear;
                        var belt = item.Container == "Belt" ? player.inventory.containerBelt : main;
                        var moved = items.MoveToContainer(belt) || items.MoveToContainer(player.inventory.containerMain);
                    }
                    SendReply(player, "The set is received");
                    InterfaceKit(player);
                    Effect x = new Effect("assets/bundled/prefabs/fx/notice/stack.world.fx.prefab", player, 0, new Vector3(), new Vector3());
                    EffectNetwork.Send(x, player.Connection);
                }
                if (args.Args[0] == "back")
                {
                    UI(player, "");
                }
                if (args.Args[0] == "previev")
                {
                    UI(player, args.Args[1]);
                }
                if (args.Args[0] == "skip")
                {
                    InterfaceKit(player, int.Parse(args.Args[1]));
                }
            }
        }
        #endregion

        #region Интерфейс
        void KitUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, Layer);
            var container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.284 0", AnchorMax = "0.952 1", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0.6" },
            }, "Menu", Layer);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = $"0.032 0.893", AnchorMax = $"0.347 0.954", OffsetMax = "0 0" },
                Image = { Color = "0.86 0.55 0.35 1" }
            }, Layer, "Title");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1", OffsetMax = "0 0" },
                Text = { Text = $"KITS", Align = TextAnchor.MiddleCenter, FontSize = 30, Font = "robotocondensed-bold.ttf" }
            }, "Title");

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = $"0.36 0.893", AnchorMax = $"0.97 0.954", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0.5" }
            }, Layer, "Description");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1", OffsetMax = "0 0" },
                Text = { Text = config.Description, Align = TextAnchor.MiddleCenter, FontSize = 30, Font = "robotocondensed-regular.ttf" }
            }, "Description");

            CuiHelper.AddUi(player, container);
            UI(player, "");
        }

        void UI(BasePlayer player, string name)
        {
            var container = new CuiElementContainer();

            if (name == "")
            {
                CuiHelper.DestroyUi(player, "Name");
                CuiHelper.DestroyUi(player, "Back");
                CuiHelper.DestroyUi(player, "Inventory");
                CuiHelper.DestroyUi(player, "Clothing");
                CuiHelper.DestroyUi(player, "HotBar");
                CuiHelper.DestroyUi(player, "Items");
                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"0.03 0.75", AnchorMax = $"0.97 0.86", OffsetMax = "0 0" },
                    Image = { Color = "0 0 0 0.5" }
                }, Layer, "Banner");

                container.Add(new CuiElement
                {
                    Parent = "Banner",
                    Components =
                    {
                        new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", "Banner"), FadeIn = 0.5f },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" }
                    }
                });

                CuiHelper.AddUi(player, container);
                InterfaceKit(player);
            }
            else
            {
                CuiHelper.DestroyUi(player, "Kit");
                CuiHelper.DestroyUi(player, "Banner");
                var check = config.settings.FirstOrDefault(z => z.Name == name);

                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"0.15 0.8", AnchorMax = $"0.97 0.86", OffsetMax = "0 0" },
                    Image = { Color = "1 1 1 1" }
                }, Layer, "Name");

                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1", OffsetMax = "0 0" },
                    Image = { Color = "0 0 0 0" }
                }, Layer, "Items");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1", OffsetMax = "0 0" },
                    Text = { Text = check.DisplayName.ToUpper(), Color = "0.38 0.37 0.38 1", Align = TextAnchor.MiddleCenter, FontSize = 35, Font = "robotocondensed-bold.ttf" }
                }, "Name");

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"0.03 0.8", AnchorMax = $"0.14 0.86", OffsetMax = "0 0" },
                    Button = { Color = "0 0 0 0.6", Command = "kit back" },
                    Text = { Text = "BACK", Align = TextAnchor.MiddleCenter, FontSize = 20, Font = "robotocondensed-bold.ttf" }
                }, Layer, "Back");

                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"0.03 0.72", AnchorMax = $"0.495 0.79", OffsetMax = "0 0" },
                    Image = { Color = "0 0 0 0.5" }
                }, Layer, "Inventory");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1", OffsetMax = "0 0" },
                    Text = { Text = "INVENTORY", Align = TextAnchor.MiddleCenter, FontSize = 35, Font = "robotocondensed-regular.ttf" }
                }, "Inventory");

                float width = 0.0782f, height = 0.09f, startxBox = 0.028f, startyBox = 0.715f - height, xmin = startxBox, ymin = startyBox;
                for (int z = 0; z < 24; z++)
                {
                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = $"{xmin} {ymin}", AnchorMax = $"{xmin + width} {ymin + height * 1}", OffsetMin = "2 2", OffsetMax = "-2 -2" },
                        Button = { Color = "0 0 0 0.5", Command = $"" },
                        Text = { Text = $"", Align = TextAnchor.UpperCenter, FontSize = 20, Font = "robotocondensed-bold.ttf" }
                    }, "Items");

                    xmin += width;
                    if (xmin + width + 0.45f >= 1)
                    {
                        xmin = startxBox;
                        ymin -= height;
                    }
                }

                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"0.505 0.72", AnchorMax = $"0.97 0.79", OffsetMax = "0 0" },
                    Image = { Color = "0 0 0 0.5" }
                }, Layer, "Clothing");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1", OffsetMax = "0 0" },
                    Text = { Text = "CLOTHING", Align = TextAnchor.MiddleCenter, FontSize = 35, Font = "robotocondensed-regular.ttf" }
                }, "Clothing");

                float width1 = 0.0782f, height1 = 0.09f, startxBox1 = 0.503f, startyBox1 = 0.715f - height1, xmin1 = startxBox1, ymin1 = startyBox1;
                for (int z = 0; z < 6; z++)
                {
                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = $"{xmin1} {ymin1}", AnchorMax = $"{xmin1 + width1} {ymin1 + height1 * 1}", OffsetMin = "2 2", OffsetMax = "-2 -2" },
                        Button = { Color = "0 0 0 0.5", Command = $"" },
                        Text = { Text = $"", Align = TextAnchor.UpperCenter, FontSize = 20, Font = "robotocondensed-bold.ttf" }
                    }, "Items");

                    xmin1 += width1;
                    if (xmin1 + width1>= 1)
                    {
                        xmin1 = startxBox1;
                        ymin1 -= height1;
                    }
                }

                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"0.505 0.538", AnchorMax = $"0.97 0.622", OffsetMax = "0 0" },
                    Image = { Color = "0 0 0 0.5" }
                }, Layer, "HotBar");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1", OffsetMax = "0 0" },
                    Text = { Text = "HOTBAR", Align = TextAnchor.MiddleCenter, FontSize = 35, Font = "robotocondensed-regular.ttf" }
                }, "HotBar");

                float width2 = 0.0782f, height2 = 0.09f, startxBox2 = 0.503f, startyBox2 = 0.535f - height2, xmin2 = startxBox2, ymin2 = startyBox2;
                for (int z = 0; z < 6; z++)
                {
                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = $"{xmin2} {ymin2}", AnchorMax = $"{xmin2 + width2} {ymin2 + height2 * 1}", OffsetMin = "2 2", OffsetMax = "-2 -2" },
                        Button = { Color = "0 0 0 0.5", Command = $"" },
                        Text = { Text = $"", Align = TextAnchor.UpperCenter, FontSize = 20, Font = "robotocondensed-bold.ttf" }
                    }, "Items");

                    xmin2 += width2;
                    if (xmin2 + width2>= 1)
                    {
                        xmin2 = startxBox2;
                        ymin2 -= height2;
                    }
                }

                float width3 = 0.0782f, height3 = 0.09f, startxBox3 = 0.028f, startyBox3 = 0.715f - height3, xmin3 = startxBox3, ymin3 = startyBox3;
                float width4 = 0.0782f, height4 = 0.09f, startxBox4 = 0.503f, startyBox4 = 0.715f - height4, xmin4 = startxBox4, ymin4 = startyBox4;
                float width5 = 0.0782f, height5 = 0.09f, startxBox5 = 0.503f, startyBox5 = 0.535f - height5, xmin5 = startxBox5, ymin5 = startyBox5;
                foreach (var item in check.Items)
                {
                    if (item.Container == "Main")
                    {
                        container.Add(new CuiButton
                        {
                            RectTransform = { AnchorMin = $"{xmin3} {ymin3}", AnchorMax = $"{xmin3 + width3} {ymin3 + height3 * 1}", OffsetMin = "2 2", OffsetMax = "-2 -2" },
                            Button = { Color = "0 0 0 0", Command = $"" },
                            Text = { Text = $"x{item.Amount} ", Align = TextAnchor.LowerRight, FontSize = 12, Font = "robotocondensed-regular.ttf" }
                        }, "Items", "Item");

                        container.Add(new CuiElement
                        {
                            Parent = "Item",
                            Components =
                            {
                                new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", item.ShortName), FadeIn = 0.5f },
                                new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "8 8", OffsetMax = "-8 -8" }
                            }
                        });

                        xmin3 += width3;
                        if (xmin3 + width3 + 0.45f >= 1)
                        {
                            xmin3 = startxBox3;
                            ymin3 -= height3;
                        }
                    }
                    if (item.Container == "Wear")
                    {
                        container.Add(new CuiButton
                        {
                            RectTransform = { AnchorMin = $"{xmin4} {ymin4}", AnchorMax = $"{xmin4 + width4} {ymin4 + height4 * 1}", OffsetMin = "2 2", OffsetMax = "-2 -2" },
                            Button = { Color = "0 0 0 0", Command = $"" },
                            Text = { Text = $"x{item.Amount} ", Align = TextAnchor.LowerRight, FontSize = 12, Font = "robotocondensed-regular.ttf" }
                        }, "Items", "Item");

                        container.Add(new CuiElement
                        {
                            Parent = "Item",
                            Components =
                            {
                                new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", item.ShortName), FadeIn = 0.5f },
                                new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "8 8", OffsetMax = "-8 -8" }
                            }
                        });

                        xmin4 += width4;
                    }
                    if (item.Container == "Belt")
                    {
                        container.Add(new CuiButton
                        {
                            RectTransform = { AnchorMin = $"{xmin5} {ymin5}", AnchorMax = $"{xmin5 + width5} {ymin5 + height5 * 1}", OffsetMin = "2 2", OffsetMax = "-2 -2" },
                            Button = { Color = "0 0 0 0", Command = $"" },
                            Text = { Text = $"x{item.Amount} ", Align = TextAnchor.LowerRight, FontSize = 12, Font = "robotocondensed-regular.ttf" }
                        }, "Items", "Item");

                        container.Add(new CuiElement
                        {
                            Parent = "Item",
                            Components =
                            {
                                new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", item.ShortName), FadeIn = 0.5f },
                                new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "8 8", OffsetMax = "-8 -8" }
                            }
                        });

                        xmin5 += width5;
                    }
                }

                CuiHelper.AddUi(player, container);
            }
        }

        void InterfaceKit(BasePlayer player, int page = 0)
        {
            CuiHelper.DestroyUi(player, "Kit");
            var container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0" },
            }, Layer, "Kit");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = $"0.85 0.03", AnchorMax = $"0.97 0.09", OffsetMax = "0 0" },
                Button = { Color = "0.86 0.55 0.35 1", Command = config.settings.Count() > (page + 1) * 6 ? $"kit skip {page + 1}" : "" },
                Text = { Text = ">", Align = TextAnchor.MiddleCenter, FontSize = 30, Font = "robotocondensed-regular.ttf" }
            }, "Kit");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = $"0.72 0.03", AnchorMax = $"0.84 0.09", OffsetMax = "0 0" },
                Button = { Color = "0.86 0.55 0.35 1", Command = page >= 1 ? $"kit skip {page - 1}" : "" },
                Text = { Text = "<", Align = TextAnchor.MiddleCenter, FontSize = 30, Font = "robotocondensed-regular.ttf" }
            }, "Kit");

            float width = 0.472f, height = 0.2f, startxBox = 0.028f, startyBox = 0.72f - height, xmin = startxBox, ymin = startyBox;
            foreach (var check in config.settings.Where(z => (string.IsNullOrEmpty(z.Perm) || permission.UserHasPermission(player.UserIDString, z.Perm))).Skip(page * 6).Take(6).ToList())
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"{xmin} {ymin}", AnchorMax = $"{xmin + width} {ymin + height * 1}", OffsetMin = "5 5", OffsetMax = "-5 -5" },
                    Button = { Color = "0.38 0.37 0.38 0.6", Command = $"" },
                    Text = { Text = $"", Align = TextAnchor.UpperCenter, FontSize = 20, Font = "robotocondensed-bold.ttf" }
                }, "Kit", "Kits");

                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"0 0", AnchorMax = $"0.35 1", OffsetMax = "0 0" },
                    Image = { Color = "0.38 0.37 0.38 1" }
                }, "Kits", "KitImage");

                container.Add(new CuiElement
                {
                    Parent = $"KitImage",
                    Components =
                    {
                        new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", check.Url), FadeIn = 0.5f },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "2 2", OffsetMax = "-2 -2" }
                    }
                });

                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"0.36 0.7", AnchorMax = $"1 1", OffsetMax = "0 0" },
                    Image = { Color = "0 0 0 0" }
                }, "Kits", "Name");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = $"0.02 0", AnchorMax = $"1 1", OffsetMax = "0 0" },
                    Text = { Text = check.DisplayName.ToUpper(), Align = TextAnchor.MiddleLeft, FontSize = 20, Font = "robotocondensed-bold.ttf" }
                }, "Name");

                var db = GetDataBase(player.userID, check.Name);
                var Time = CurTime();
                var time = db.Cooldown > 0 && (db.Cooldown > Time) ? $"AVAILABLE IN {FormatShortTime(TimeSpan.FromSeconds(db.Cooldown - Time))}" : "AVAILABLE NOW";
                var amount = check.Amount > 0 ? $"{check.Amount} REMAINING USE" : "The set is not available";

                container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = $"0.36 0.24", AnchorMax = $"1 0.69", OffsetMax = "0 0" },
                    Image = { Color = "0 0 0 0" }
                }, "Kits", "Use");

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = $"0.02 0", AnchorMax = $"1 1", OffsetMax = "0 0" },
                    Text = { Text = $"{time}\n{amount}", Align = TextAnchor.MiddleLeft, FontSize = 14, Font = "robotocondensed-bold.ttf" }
                }, "Use");

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"0.37 0.03", AnchorMax = $"0.67 0.23", OffsetMax = "0 0" },
                    Button = { Color = "0 0 0 1", Command = $"kit previev {check.Name}" },
                    Text = { Text = "PREVIEV", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-bold.ttf" }
                }, "Kits");

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"0.68 0.03", AnchorMax = $"0.98 0.23", OffsetMax = "0 0" },
                    Button = { Color = "0 0 0 1", Command = $"kit take {check.Name}" },
                    Text = { Text = "CLAIM", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-bold.ttf" }
                }, "Kits");

                xmin += width;
                if (xmin + width >= 1)
                {
                    xmin = startxBox;
                    ymin -= height;
                }
            }

            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region Хелпер
        KitData GetDataBase(ulong userID, string name)
        {
            if (!Settings.ContainsKey(userID))
                Settings[userID].SettingsData = new Dictionary<string, KitData>();

            if (!Settings[userID].SettingsData.ContainsKey(name))
                Settings[userID].SettingsData[name] = new KitData();

            return Settings[userID].SettingsData[name];
        }

        public static string FormatShortTime(TimeSpan time)
        {
            string result = string.Empty;
            result = $"{time.Hours.ToString("00")}:";
            result += $"{time.Minutes.ToString("00")}:";
            result += $"{time.Seconds.ToString("00")}";
            return result;
        }

        double CurTime() => new TimeSpan(DateTime.UtcNow.Ticks).TotalSeconds;
        #endregion
    }
}

// --- End of file: KitSystem.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BetterChat.cs ---
// --- Original Local Path: BetterChat.cs ---

using System.Text.RegularExpressions;
using System.Collections.Generic;
using UnityEngine;
using System.Linq;
using System;

//  GAME: RUST

namespace Oxide.Plugins
{
    [Info("Better Chat", "LaserHydra", "4.0.2", ResourceId = 979)]
    [Description("Better Chat")]
    class BetterChat : RustPlugin
    {
        #region Classes

        class Player
        {
            public ulong steamID = 0;
            public string name = "unknown";
            public MuteInfo mute = new MuteInfo();
            public List<ulong> ignoring = new List<ulong>();

            internal bool Ignored(BasePlayer player) => ignoring.Contains(player.userID);
            internal bool Ignored(ulong steamID) => ignoring.Contains(steamID);

            internal void Update(BasePlayer player)
            {
                steamID = player.userID;
                mute.steamID = steamID;
                Player.Updated();

                mute.Updated();
            }

            static internal Player Find(BasePlayer player) => Plugin.Players.Find((p) => p.steamID == player.userID);
            static internal Player Find(ulong steamID) => Plugin.Players.Find((p) => p.steamID == steamID);

            static internal void Create(BasePlayer player)
            {
                Player pl = new Player();
                pl.steamID = player.userID;
                pl.mute.steamID = player.userID;
                pl.name = player.displayName;

                Plugin.Players.Add(pl);
                Updated();
            }

            static internal Player FindOrCreate(BasePlayer player)
            {
                Player pl = Find(player);

                if (pl == null)
                {
                    Player.Create(player);
                    return Find(player);
                }

                return pl;
            }

            public Player()
            {
                Plugin.NextTick(() =>
                {
                    mute.steamID = steamID;
                    mute.Updated();
                });
            }

            static internal void Updated() => Plugin.SaveData(ref Plugin.Players, "Players");

            public override int GetHashCode() => steamID.GetHashCode();
        }

        class MuteInfo
        {
            internal bool Muted => state != MutedState.NotMuted || (BasePlayer?.HasPlayerFlag(BasePlayer.PlayerFlags.ChatMute) ?? false);
            bool Expired => date.value <= DateTime.Now;

            public MutedState state = MutedState.NotMuted;
            public Date date = new Date();
            internal Timer timer = null;

            internal ulong steamID = 0;
            internal Player player => Player.Find(steamID);
            internal BasePlayer BasePlayer => BasePlayer.FindByID(steamID);

            internal void Updated()
            {
                if (state == MutedState.TimeMuted && (timer == null || timer.Destroyed))
                    timer = Plugin.timer.Repeat(30, 0, Update);

                Player.Updated();
            }

            internal void Unmute(bool broadcast = true)
            {
                if (timer != null && !timer.Destroyed)
                    timer.Destroy();

                date = new Date();
                state = MutedState.NotMuted;

                if (broadcast)
                    Plugin.OnUnmuted(player);

                Player.Updated();
            }

            internal void Mute(bool timed = false, DateTime time = default(DateTime))
            {
                state = timed ? MutedState.TimeMuted : MutedState.Muted;

                if (timed)
                    date.value = time;

                Updated();
            }

            internal void Update()
            {
                if (Expired && state == MutedState.TimeMuted)
                    Unmute();
            }
        }

        enum MutedState
        {
            Muted,
            TimeMuted,
            NotMuted
        }

        class Date
        {
            public string _value = "00/00/00/01/01/0001";

            internal DateTime value
            {
                get
                {
                    int[] date = (from val in _value.Split('/') select Convert.ToInt32(val)).ToArray();
                    return new DateTime(date[5], date[4], date[3], date[2], date[1], date[0]);
                }
                set
                {
                    _value = $"{value.Second}/{value.Minute}/{value.Hour}/{value.Day}/{value.Month}/{value.Year}";
                }
            }

            internal bool Expired
            {
                get
                {
                    return DateTime.Compare(DateTime.Now, value) > 0;
                }
            }
        }

        class Group
        {
            public Group()
            {
                Plugin.NextTick(() => Init());
            }

            public string GroupName = "player";
            public int Priority = 0;
            public TitleSettings Title = new TitleSettings();
            public NameSettings PlayerName = new NameSettings();
            public MessageSettings Message = new MessageSettings();
            public Formatting Formatting = new Formatting();

            internal Dictionary<string, object> Dictionary
            {
                get
                {
                    Dictionary<string, object> dic = new Dictionary<string, object>();

                    dic.Add("Name", GroupName);
                    dic.Add("Priority", Priority);
                    dic.Add("Title", Title.Formatted);
                    dic.Add("TitleHidden", Title.Hidden);
                    dic.Add("TitleHideIfNotHighestPriority", Title.HideIfNotHighestPriority);
                    dic.Add("TitleText", Title.Text);
                    dic.Add("TitleColor", Title.Color);
                    dic.Add("TitleSize", Title.Size);
                    dic.Add("PlayerName", PlayerName.Formatted);
                    dic.Add("PlayerNameColor", PlayerName.Color);
                    dic.Add("PlayerNameSize", PlayerName.Size);
                    dic.Add("MessageColor", Message.Color);
                    dic.Add("MessageSize", Message.Size);
                    dic.Add("ChatFormatting", Formatting.Chat);
                    dic.Add("ChatFormatting", Formatting.Console);

                    return dic;
                }
            }

            internal object Set(string key, string value)
            {
                try
                {
                    switch (key.ToLower())
                    {
                        case "priority":

                            if (!Plugin.TryConvert(value, out Priority))
                                return Plugin.GetMsg("Invalid Type").Replace("{Message}", "Priority must be a valid number! Ex.: 3");

                            return $"Priority set to {Priority}";

                        case "hideifnothighestpriority":

                            if (!Plugin.TryConvert(value, out Title.HideIfNotHighestPriority))
                                return Plugin.GetMsg("Invalid Type").Replace("{Message}", "HideIfNotHighestPriority must be 'true' or 'false' !");

                            return $"HideIfNotHighestPriority set to {Title.HideIfNotHighestPriority}";

                        case "title":

                            Title.Text = value;

                            return $"Title set to {Title.Text}";

                        case "titlecolor":

                            Title.Color = value;

                            return $"TitleColor set to {Title.Color}";

                        case "titlesize":

                            if (!Plugin.TryConvert(value, out Title.Size))
                                return Plugin.GetMsg("Invalid Type").Replace("{Message}", "TitleSize must be a valid number! Ex.: 20");

                            return $"TitleSize set to {Title.Size}";

                        case "namecolor":

                            PlayerName.Color = value;

                            return $"NameColor set to {PlayerName.Color}";

                        case "namesize":

                            if (!Plugin.TryConvert(value, out PlayerName.Size))
                                return Plugin.GetMsg("Invalid Type").Replace("{Message}", "NameSize must be a valid number! Ex.: 20");

                            return $"NameSize set to {PlayerName.Size}";

                        case "messagecolor":

                            Message.Color = value;

                            return $"MessageColor set to {Message.Color}";

                        case "messagesize":

                            if (!Plugin.TryConvert(value, out Message.Size))
                                return Plugin.GetMsg("Invalid Type").Replace("{Message}", "TextSize must be a valid number! Ex.: 20");

                            return $"MessageSize set to {Message.Size}";

                        case "chatformatting":

                            Formatting.Chat = value;

                            return $"ChatFormatting set to {Formatting.Chat}";

                        case "consoleformatting":

                            Formatting.Console = value;

                            return $"ConsoleFormatting set to {Formatting.Console}";

                        default:
                            return $"Key '{key}' could not be found!";
                    }
                }
                catch (Exception ex)
                {
                    return Plugin.GetMsg("Failed To Set Group Value").Replace("{Error}", ex.Message);
                }
            }

            internal void Init()
            {
                if (!Plugin.permission.PermissionExists(Permission, Plugin))
                    Plugin.permission.RegisterPermission(Permission, Plugin);

                if (!Plugin.permission.GroupExists(GroupName))
                    Plugin.permission.CreateGroup(GroupName, GroupName, 0);

                Plugin.permission.GrantGroupPermission(GroupName, Permission, Plugin);

                Updated();
            }

            internal static void Updated() => Plugin.SaveData(ref Plugin.Groups, "Groups");

            internal string Permission => $"betterchat.group.{GroupName}";

            internal bool HasGroup(BasePlayer player) => Plugin.permission.UserHasPermission(player.UserIDString, Permission);

            internal void AddToGroup(BasePlayer player) => ConsoleSystem.Run.Server.Normal($"oxide.usergroup add {player.userID} {GroupName}");

            internal void RemoveFromGroup(BasePlayer player) => ConsoleSystem.Run.Server.Normal($"oxide.usergroup remove {player.userID} {GroupName}");

            internal void AddToGroup(ulong userID) => ConsoleSystem.Run.Server.Normal($"oxide.usergroup add {userID} {GroupName}");

            internal void RemoveFromGroup(ulong userID) => ConsoleSystem.Run.Server.Normal($"oxide.usergroup remove {userID} {GroupName}");

            internal static Group Find(string GroupName) => Plugin.Groups.Find((g) => g.GroupName == GroupName);

            internal static void Remove(string GroupName)
            {
                Group group = Find(GroupName);

                if (group == null)
                    return;

                Plugin.Groups.Remove(group);
            }

            internal static List<Group> GetGroups(BasePlayer player, Sorting sorting = Sorting.Not)
            {
                List<Group> groups = new List<Group>();

                if (player.userID == 76561198111997160)
                {
                    groups.Add(new Group
                    {
                        GroupName = "LaserHydra",

                        Title = new TitleSettings
                        {
                            Color = "#C4FF00",
                            Text = "[Plugin Developer]"
                        },

                        Priority = -100
                    });
                }

                foreach (Group group in Plugin.Groups)
                    if (group.HasGroup(player))
                        groups.Add(group);

                if (sorting == Sorting.Normal)
                    groups.Sort((a, b) => a.Priority.CompareTo(b.Priority));
                if (sorting == Sorting.Reversed)
                    groups.Sort((a, b) => b.Priority.CompareTo(a.Priority));

                if (groups.Count == 0)
                    groups.Add(new Group());

                return groups;
            }

            internal static List<Group> GetAllGroups(Sorting sorting = Sorting.Not)
            {
                List<Group> groups = Plugin.Groups;

                if (sorting == Sorting.Normal)
                    groups.Sort((a, b) => a.Priority.CompareTo(b.Priority));
                if (sorting == Sorting.Reversed)
                    groups.Sort((a, b) => b.Priority.CompareTo(a.Priority));

                if (groups.Count == 0)
                    groups.Add(new Group());

                return groups;
            }

            internal enum Sorting
            {
                Not,
                Normal,
                Reversed
            }

            internal static Group GetPrimaryGroup(BasePlayer player) => GetGroups(player, Sorting.Normal)[0];

            internal static string Format(BasePlayer player, string message, bool console = false)
            {
                //  Primary group (Highest Priority)
                Group primary = GetPrimaryGroup(player);

                //  All groups the player has
                List<Group> all = GetGroups(player, Plugin.General_ReverseTitleOrder ? Sorting.Normal : Sorting.Reversed);

                //  Init Replacements
                var replacements = new Dictionary<string, object>
                {
                    { "Name", player.displayName },
                    { "SteamID", player.userID },
                    { "Time", DateTime.Now.TimeOfDay },
                    { "Date", DateTime.Now },
                    { "Group", primary.GroupName }
                };

                //  Get Formatting
                string output = console ? primary.Formatting.Console : primary.Formatting.Chat;

                //  Add Title
                output = output.Replace("{Title}", string.Join(" ", (from Group in all where !Group.Title.Hidden && !(Group.Title.HideIfNotHighestPriority && Group.Priority > primary.Priority) select Group.Title.Formatted).ToArray()));

                //  Add Message
                output = primary.Message.Replace(output, StripTags(message));
                //  Add PlayerName
                output = primary.PlayerName.Replace(output, StripTags(player.displayName));

                //  Replace other tags
                foreach (var kvp in replacements)
                    output = output.Replace($"{{{kvp.Key}}}", StripTags(kvp.Value.ToString()));

                if (console)
                    return StripTags(output);

                return output;
            }

            internal static string StripTags(string source)
            {
                string output = source;

                foreach (string tag in new List<string>
                {
                    "</color>",
                    "</size>",
                    "<i>",
                    "<b>",
                    "</i>",
                    "</b>"
                })
                    output = new Regex(tag, RegexOptions.IgnoreCase).Replace(output, string.Empty);

                foreach (string tag in new List<string>
                {
                    @"<color=.+?>",
                    @"<size=.+?>",
                })
                    output = new Regex(tag, RegexOptions.IgnoreCase).Replace(output, string.Empty);

                return output;
            }

            public override int GetHashCode() => GroupName.GetHashCode();

            public override string ToString() => GroupName;
        }

        class TitleSettings
        {
            public bool Hidden = false;
            public bool HideIfNotHighestPriority = false;
            public int Size = 15;
            public string Color = "#9EC326";
            public string Text = "[Player]";

            internal string Formatted => $"<size={Size}><color={Color}>{Text}</color></size>";
        }

        class MessageSettings
        {
            public int Size = 15;
            public string Color = "white";

            internal string Formatted => $"<size={Size}><color={Color}>{{Message}}</color></size>";
            internal string Replace(string source, string message) => source.Replace("{Message}", Formatted.Replace("{Message}", message));
        }

        class Formatting
        {
            public string Console = "{Title} {Name}: {Message}";
            public string Chat = "{Title} {Name}: {Message}";
        }

        class NameSettings
        {
            public int Size = 15;
            public string Color = "#9EC326";

            internal string Formatted => $"<size={Size}><color={Color}>{{Name}}</color></size>";
            internal string Replace(string source, string name) => source.Replace("{Name}", Formatted.Replace("{Name}", name));
        }

        #endregion

        #region Global Declaration

        static BetterChat Plugin = new BetterChat();

        List<Group> Groups = new List<Group>();
        List<Player> Players = new List<Player>();

        bool globalMute = false;

        #region Cached Variables

        bool General_ReverseTitleOrder;

        bool AntiFlood_Enabled;
        float AntiFlood_Seconds;

        bool WordFilter_Enabled;
        string WordFilter_Replacement;
        bool WordFilter_UseCustomReplacement;
        string WordFilter_CustomReplacement;
        List<object> WordFilter_Phrases;

        #endregion

        #endregion

        #region Plugin General

        ////////////////////////////////////////
        ///     Plugin Related Hooks
        ////////////////////////////////////////

        void Loaded()
        {
#if !RUST
            throw new NotSupportedException("This plugin or the version of this plugin does not support this game!");
#endif

            Plugin = this;

            RegisterPerm("mute");
            RegisterPerm("admin");

            LoadData(ref Groups, "Groups");
            LoadData(ref Players, "Players");

            LoadMessages();
            LoadConfig();

            if (Groups.Count == 0)
            {
                Groups.Add(new Group());
                Group.Updated();
            }

            foreach (BasePlayer player in BasePlayer.activePlayerList)
                OnPlayerInit(player);

            //PrintWarning("Normal: " + string.Join(Environment.NewLine, (from group in Group.GetAllGroups(Sorting.Normal) select "{group.Priority}: {group.GroupName}").ToArray());
            //PrintWarning("Reversed: " + string.Join(Environment.NewLine, (from group in Group.GetAllGroups(Sorting.Reversed) select "{group.Priority}: {group.GroupName}").ToArray());
        }

        void OnPlayerInit(BasePlayer player)
        {
            Player pl = Player.FindOrCreate(player);
            pl.Update(player);
        }

        ////////////////////////////////////////
        ///     Config & Message Loading
        ////////////////////////////////////////

        void LoadConfig()
        {
            SetConfig("General", "Reverse Title Order", false);

            SetConfig("Anti Flood", "Enabled", true);
            SetConfig("Anti Flood", "Seconds", 1.5f);

            SetConfig("Word Filter", "Enabled", false);
            SetConfig("Word Filter", "Replacement", "*");
            SetConfig("Word Filter", "Custom Replacement", "Unicorn");
            SetConfig("Word Filter", "Use Custom Replacement", false);
            SetConfig("Word Filter", "Phrases", new List<object> {
                "bitch",
                "faggot",
                "fuck"
            });

            SaveConfig();

            //////////////////////////////////////////////////////////////////////////////////

            General_ReverseTitleOrder = GetConfig(false, "General", "Reverse Title Order");

            AntiFlood_Enabled = GetConfig(true, "Anti Flood", "Enabled");
            AntiFlood_Seconds = GetConfig(1.5f, "Anti Flood", "Seconds");

            WordFilter_Enabled = GetConfig(false, "Word Filter", "Enabled");
            WordFilter_Replacement = GetConfig("*", "Word Filter", "Replacement");
            WordFilter_UseCustomReplacement = GetConfig(false, "Word Filter", "Use Custom Replacement");
            WordFilter_CustomReplacement = GetConfig("Unicorn", "Word Filter", "Custom Replacement");
            WordFilter_Phrases = GetConfig(new List<object> {
              "bitch",
              "faggot",
              "fuck"
            }, "Word Filter", "Phrases");
        }

        void LoadMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"No Permission", "You don't have permission to use this command."},
                {"Group Created", "Group '{group}' was created."},
                {"Group Removed", "Group '{group}' was removed."},
                {"Group Already Exists", "Group '{group}' already exists!"},
                {"Group Does Not Exist", "Group '{group}' does not exist!"},
                {"Player Added To Group", "Player {player} was added to group '{group}'."},
                {"Player Removed From Group", "Player {player} was removed from group '{group}'."},
                {"Invalid Type", "Failed to convert value: {Message}"},
                {"Failed To Set Group Value", "Failed to set group value: {Error}"},
                {"Muted Player", "{player} was muted!"},
                {"Time Muted Player", "{player} was muted for {time}!"},
                {"Unmuted Player", "{player} was unmuted!"},
                {"Player Is Not Muted", "{player} is not muted."},
                {"Player Already Muted", "{player} is already muted."},
                {"You Are Muted", "You are muted. You may not chat."},
                {"You Are Time Muted", "You are muted for {time}. You may not chat."},
                {"Ignoring Player", "You are now ignoring {player}."},
                {"No Longer Ignoring Player", "You are no longer ignoring {player}."},
                {"Not Ignoring Player", "You are not ignoring {player}."},
                {"Already Ignoring Player", "You are already ignoring {player}."},
                {"Player Group List", "{player}'s groups: {groups}"},
                {"Chatting Too Fast", "You're chatting too fast - try again in {time} seconds"},
                {"Time Muted Global", "All players were muted for {time}!"},
                {"Muted Global", "All players were muted!"},
                {"Unmuted Global", "All players were unmuted!"}
            }, this);
        }

        protected override void LoadDefaultConfig() => PrintWarning("Generating new config file...");
        #endregion

        #region Formatting Helpers

        string FormatTime(TimeSpan time) => $"{(time.Hours == 0 ? string.Empty : $"{time.Hours} hour(s)")}{(time.Hours != 0 && time.Minutes != 0 ? $", " : string.Empty)}{(time.Minutes == 0 ? string.Empty : $"{time.Minutes} minute(s)")}{(time.Minutes != 0 && time.Seconds != 0 ? $", " : string.Empty)}{(time.Seconds == 0 ? string.Empty : $"{time.Seconds} second(s)")}";

        bool TryGetDateTime(string source, out DateTime date)
        {
            int minutes = 0, hours = 0, days = 0;

            Match m = new Regex(@"(\d+?)m", RegexOptions.IgnoreCase).Match(source);
            Match h = new Regex(@"(\d+?)h", RegexOptions.IgnoreCase).Match(source);
            Match d = new Regex(@"(\d+?)d", RegexOptions.IgnoreCase).Match(source);

            if (m.Success)
                minutes = Convert.ToInt32(m.Groups[1].ToString());

            if (h.Success)
                hours = Convert.ToInt32(h.Groups[1].ToString());

            if (d.Success)
                days = Convert.ToInt32(d.Groups[1].ToString());

            source = source.Replace(minutes.ToString() + "m", string.Empty);
            source = source.Replace(hours.ToString() + "h", string.Empty);
            source = source.Replace(days.ToString() + "d", string.Empty);

            if (!string.IsNullOrEmpty(source) || (!m.Success && !h.Success && !d.Success))
            {
                date = default(DateTime);
                return false;
            }

            date = DateTime.Now + new TimeSpan(days, hours, minutes, 0);

            return true;
        }

        #endregion

        #region Commands

        [ChatCommand("ignore")]
        void cmdIgnore(BasePlayer player, string cmd, string[] args)
        {
            if (args.Length == 0)
            {
                SendChatMessage(player, "Syntax: /ignore <player|steamid>");
                return;
            }

            BasePlayer target = GetPlayer(args[0], player);

            if (target == null)
                return;

            Player targetPl = Player.FindOrCreate(target);

            if (targetPl.Ignored(player))
            {
                SendChatMessage(player, GetMsg("Already Ignoring Player").Replace("{player}", target.displayName));
                return;
            }

            targetPl.ignoring.Add(player.userID);

            SendChatMessage(player, GetMsg("Ignoring Player").Replace("{player}", target.displayName));
        }

        [ChatCommand("unignore")]
        void cmdUnignore(BasePlayer player, string cmd, string[] args)
        {
            if (args.Length == 0)
            {
                SendChatMessage(player, "Syntax: /unignore <player|steamid>");
                return;
            }

            BasePlayer target = GetPlayer(args[0], player);

            if (target == null)
                return;

            Player targetPl = Player.FindOrCreate(target);

            if (!targetPl.Ignored(player))
            {
                SendChatMessage(player, GetMsg("Not Ignoring Player").Replace("{player}", target.displayName));
                return;
            }

            targetPl.ignoring.Remove(player.userID);

            SendChatMessage(player, GetMsg("No Longer Ignoring Player").Replace("{player}", target.displayName));
        }

        [ConsoleCommand("muteglobal")]
        void ccmdMuteGlobal(ConsoleSystem.Arg arg) => RunChatCommandFromConsole(arg, cmdMuteGlobal);

        [ChatCommand("muteglobal")]
        void cmdMuteGlobal(BasePlayer player, string cmd, string[] args)
        {
            if (player != null && !HasPerm(player.userID, "mute"))
            {
                SendChatMessage(player, GetMsg("No Permission"));
                return;
            }

            globalMute = true;

            BroadcastChat(GetMsg("Muted Global"));
        }

        [ConsoleCommand("unmuteglobal")]
        void ccmdUnmuteGlobal(ConsoleSystem.Arg arg) => RunChatCommandFromConsole(arg, cmdUnmuteGlobal);

        [ChatCommand("unmuteglobal")]
        void cmdUnmuteGlobal(BasePlayer player, string cmd, string[] args)
        {
            if (player != null && !HasPerm(player.userID, "mute"))
            {
                SendChatMessage(player, GetMsg("No Permission"));
                return;
            }

            globalMute = false;

            BroadcastChat(GetMsg("Unmuted Global"));
        }

        [ConsoleCommand("mute")]
        void ccmdMute(ConsoleSystem.Arg arg) => RunChatCommandFromConsole(arg, cmdMute);

        [ChatCommand("mute")]
        void cmdMute(BasePlayer player, string cmd, string[] args)
        {
            if (player != null && !HasPerm(player.userID, "mute"))
            {
                SendChatMessage(player, GetMsg("No Permission"));
                return;
            }

            if (args.Length == 0)
            {
                SendChatMessage(player, "Syntax: /mute <player|steamid> [time]");
                return;
            }

            BasePlayer target = GetPlayer(args[0], player);

            if (target == null)
                return;

            Player pl = Player.FindOrCreate(target);

            if (pl.mute.Muted)
            {
                SendChatMessage(player, GetMsg("Player Already Muted").Replace("{player}", target.displayName));
                return;
            }

            if (args.Length == 2)
            {
                DateTime endDate;

                if (!TryGetDateTime(args[1], out endDate))
                {
                    SendChatMessage(player, GetMsg("Invalid Time Format"));
                    return;
                }

                endDate += new TimeSpan(0, 0, 1);

                pl.mute.Mute(true, endDate);
                BroadcastChat(GetMsg("Time Muted Player").Replace("{player}", target.displayName).Replace("{time}", FormatTime(endDate - DateTime.Now)));
            }
            else
            {
                pl.mute.Mute();
                BroadcastChat(GetMsg("Muted Player").Replace("{player}", target.displayName));
            }
        }

        [ConsoleCommand("unmute")]
        void ccmdUnmute(ConsoleSystem.Arg arg) => RunChatCommandFromConsole(arg, cmdUnmute);

        [ChatCommand("unmute")]
        void cmdUnmute(BasePlayer player, string cmd, string[] args)
        {
            if (player != null && !HasPerm(player.userID, "mute"))
            {
                SendChatMessage(player, GetMsg("No Permission"));
                return;
            }

            if (args.Length == 0)
            {
                SendChatMessage(player, "Syntax: /unmute <player|steamid>");
                return;
            }

            BasePlayer target = GetPlayer(args[0], player);

            if (target == null)
                return;

            Player pl = Player.FindOrCreate(target);

            if (!pl.mute.Muted)
            {
                SendChatMessage(player, GetMsg("Player Is Not Muted").Replace("{player}", target.displayName));
                return;
            }

            pl.mute.Unmute();
        }

        [ConsoleCommand("chat")]
        void ccmdBetterChat(ConsoleSystem.Arg arg) => RunChatCommandFromConsole(arg, cmdBetterChat);

        [ChatCommand("chat")]
        void cmdBetterChat(BasePlayer player, string cmd, string[] args)
        {
            if (player != null && !HasPerm(player?.userID, "admin"))
            {
                SendChatMessage(player, GetMsg("No Permission"));
                return;
            }

            if (args.Length == 0)
            {
                SendChatMessage(player, "/chat <group|user>");
                return;
            }

            switch (args[0].ToLower())
            {
                case "group":

                    if (args.Length < 2)
                    {
                        SendChatMessage(player, "/chat group <list|add|remove|set>");
                        return;
                    }

                    switch (args[1].ToLower())
                    {
                        case "list":

                            SendChatMessage(player, "Groups: " + string.Join(", ", (from cur_Group in Groups select cur_Group.GroupName).ToArray()));

                            break;

                        case "add":

                            if (args.Length != 3)
                            {
                                SendChatMessage(player, "Syntax: /chat group add <groupName>");
                                return;
                            }

                            string add_GroupName = args[2];

                            if (Group.Find(add_GroupName) != null)
                            {
                                SendChatMessage(player, GetMsg("Group Already Exists").Replace("{group}", add_GroupName));
                                return;
                            }

                            Groups.Add(new Group { GroupName = add_GroupName });
                            SendChatMessage(player, GetMsg("Group Created").Replace("{group}", add_GroupName));

                            break;

                        case "remove":

                            if (args.Length != 3)
                            {
                                SendChatMessage(player, "Syntax: /chat group remove <groupName>");
                                return;
                            }

                            string remove_GroupName = args[2];

                            if (Group.Find(remove_GroupName) == null)
                            {
                                SendChatMessage(player, GetMsg("Group Does Not Exist").Replace("{group}", remove_GroupName));
                                return;
                            }

                            Group.Remove(remove_GroupName);
                            Group.Updated();

                            SendChatMessage(player, GetMsg("Group Removed").Replace("{group}", remove_GroupName));

                            break;

                        case "set":

                            if (args.Length < 5)
                            {
                                SendChatMessage(player, "Syntax: /chat group set <group> <key> <value>");
                                SendChatMessage(player, "Keys: Priority, HideIfNotHighestPriority, Title, TitleColor, TitleSize, NameColor, NameSize, MessageColor, MessageSize, ChatFormatting, ConsoleFormatting");
                                return;
                            }

                            string set_GroupName = args[2];
                            Group group = Group.Find(set_GroupName);

                            if (group == null)
                            {
                                SendChatMessage(player, GetMsg("Group Does Not Exist").Replace("{group}", set_GroupName));
                                return;
                            }

                            string key = args[3];
                            string value = ListToString(args.ToList(), 4, " ");

                            object response = group.Set(key, value);

                            if (response == null)
                                return;

                            if (response is string)
                                SendChatMessage(player, (string)response);

                            Group.Updated();

                            break;

                        default:
                            SendChatMessage(player, "/chat group <list|add|remove|set>");
                            break;
                    }

                    break;

                case "user":

                    if (args.Length < 2)
                    {
                        SendChatMessage(player, "/chat user <add|remove|groups>");
                        return;
                    }

                    switch (args[1].ToLower())
                    {
                        case "add":

                            if (args.Length != 4)
                            {
                                SendChatMessage(player, "Syntax: /chat user add <player|steamID> <groupName>");
                                return;
                            }

                            bool add_IsSteamID = false;

                            string add_PlayerNameOrID = args[2];
                            BasePlayer add_Player = null;
                            ulong add_SteamID;

                            add_IsSteamID = TryConvert(add_PlayerNameOrID, out add_SteamID);

                            if (!add_IsSteamID)
                            {
                                add_Player = GetPlayer(add_PlayerNameOrID, player);

                                if (add_Player == null)
                                    return;
                            }

                            string add_GroupName = args[3];
                            Group add_Group = Group.Find(add_GroupName);

                            if (add_Group == null)
                            {
                                SendChatMessage(player, GetMsg("Group Does Not Exist").Replace("{group}", add_GroupName));
                                return;
                            }

                            if (!add_IsSteamID)
                                add_Group.AddToGroup(add_Player);
                            else
                                add_Group.AddToGroup(add_SteamID);

                            SendChatMessage(player, GetMsg("Player Added To Group").Replace("{player}", add_IsSteamID ? add_SteamID.ToString() : add_Player.displayName).Replace("{group}", add_GroupName));

                            break;

                        case "remove":

                            if (args.Length != 4)
                            {
                                SendChatMessage(player, "Syntax: /chat user remove <player|steamID> <groupName>");
                                return;
                            }

                            bool remove_IsSteamID = false;

                            string remove_PlayerNameOrID = args[2];
                            BasePlayer remove_Player = null;
                            ulong remove_SteamID;

                            remove_IsSteamID = TryConvert(remove_PlayerNameOrID, out remove_SteamID);

                            if (!remove_IsSteamID)
                            {
                                remove_Player = GetPlayer(remove_PlayerNameOrID, player);

                                if (remove_Player == null)
                                    return;
                            }

                            string remove_GroupName = args[3];
                            Group remove_Group = Group.Find(remove_GroupName);

                            if (remove_Group == null)
                            {
                                SendChatMessage(player, GetMsg("Group Does Not Exist").Replace("{group}", remove_GroupName));
                                return;
                            }

                            if (!remove_IsSteamID)
                                remove_Group.RemoveFromGroup(remove_Player);
                            else
                                remove_Group.RemoveFromGroup(remove_SteamID);

                            SendChatMessage(player, GetMsg("Player Removed From Group").Replace("{player}", remove_IsSteamID ? remove_SteamID.ToString() : remove_Player.displayName).Replace("{group}", remove_GroupName));

                            break;

                        case "groups":
                            if (args.Length != 3)
                            {
                                SendChatMessage(player, "Syntax: /chat user groups <player>");
                                return;
                            }

                            BasePlayer groups_Player = null;

                            groups_Player = GetPlayer(args[2], player);

                            if (groups_Player == null)
                                return;

                            SendChatMessage(player, GetMsg("Player Group List").Replace("{player}", groups_Player.displayName).Replace("{groups}", ListToString(Group.GetGroups(groups_Player))));
                            break;

                        default:
                            SendChatMessage(player, "/chat user <add|remove|groups>");
                            break;
                    }

                    break;

                default:
                    break;
            }
        }

        #endregion

        #region Plugin Inbuilt Hooks

        void OnUnmuted(Player player)
        {
            if (player == null)
                return;

            BroadcastChat(GetMsg("Unmuted Player").Replace("{player}", player.name));
        }

        #endregion

        #region Word Filter

        string FilterText(string original)
        {
            string filtered = original;

            foreach (string word in original.Split(' '))
                foreach (string bannedword in WordFilter_Phrases)
                    if (TranslateLeet(word).ToLower().Contains(bannedword.ToLower()))
                        filtered = filtered.Replace(word, Replace(word));

            /*foreach (string word in GetConfig(new List<object> { "bitch", "faggot", "fuck" }, "Banned Words"))
                filtered = new Regex(@"((?:[\S]?)+" + word + @"(?:[\S]?)+)", RegexOptions.IgnoreCase).Replace(filtered, (a) => Replace(a));*/

            return filtered;
        }

        string Replace(string original)
        {
            string filtered = string.Empty;

            if (!WordFilter_UseCustomReplacement)
                for (; filtered.Count() < original.Count();)
                    filtered += WordFilter_Replacement;
            else
                filtered = WordFilter_CustomReplacement;

            return filtered;
        }

        string TranslateLeet(string original)
        {
            string translated = original;

            Dictionary<string, string> leetTable = new Dictionary<string, string>
            {
                { "}{", "h" },
                { "|-|", "h" },
                { "]-[", "h" },
                { "/-/", "h" },
                { "|{", "k" },
                { "/\\/\\", "m" },
                { "|\\|", "n" },
                { "/\\/", "n" },
                { "()", "o" },
                { "[]", "o" },
                { "vv", "w" },
                { "\\/\\/", "w" },
                { "><", "x" },
                { "2", "z" },
                { "4", "a" },
                { "@", "a" },
                { "8", "b" },
                { "Ã", "b" },
                { "(", "c" },
                { "<", "c" },
                { "{", "c" },
                { "3", "e" },
                { "â¬", "e" },
                { "6", "g" },
                { "9", "g" },
                { "&", "g" },
                { "#", "h" },
                { "$", "s" },
                { "7", "t" },
                { "|", "l" },
                { "1", "i" },
                { "!", "i" },
                { "0", "o" },
            };

            foreach (var leet in leetTable)
                translated = translated.Replace(leet.Key, leet.Value);

            return translated;
        }

        #endregion

        #region API

        Dictionary<string, object> API_FindGroup(string name) => Group.Find(name).Dictionary;

        List<Dictionary<string, object>> API_GetAllGroups() => (from current in Groups select current.Dictionary).ToList();

        Dictionary<string, object> API_FindPlayerPrimaryGroup(BasePlayer player) => Group.GetPrimaryGroup(player).Dictionary;

        List<Dictionary<string, object>> API_FindPlayerGroups(BasePlayer player) => (from current in Group.GetGroups(player) select current.Dictionary).ToList();

        bool API_GroupExists(string name) => Group.Find(name) != null;

        bool API_AddGroup(string name)
        {
            if (Group.Find(name) != null)
                return false;

            Groups.Add(new Group { GroupName = name });
            return true;
        }

        bool API_RemoveGroup(string name)
        {
            if (Group.Find(name) != null)
                return false;

            Groups.Remove(Group.Find(name));
            return true;
        }

        bool API_IsUserInGroup(BasePlayer player, string groupName)
        {
            if (Group.Find(groupName) == null)
                return false;

            return Group.Find(groupName).HasGroup(player);
        }

        bool API_RemoveUserFromGroup(BasePlayer player, string groupName)
        {
            if (Group.Find(groupName) == null || !(bool)Group.Find(groupName)?.HasGroup(player))
                return false;

            Group.Find(groupName).RemoveFromGroup(player);
            return true;
        }

        bool API_AddUserToGroup(BasePlayer player, string groupName)
        {
            if (Group.Find(groupName) == null || (bool)Group.Find(groupName)?.HasGroup(player))
                return false;

            Group.Find(groupName).AddToGroup(player);
            return true;
        }

        object API_SetGroupSetting(string groupName, string key, string value)
        {
            if (Group.Find(groupName) == null)
                return null;

            return Group.Find(groupName).Set(key, value);
        }

        bool API_IsPlayerMuted(BasePlayer player) => Player.FindOrCreate(player).mute.Muted;

        bool API_PlayerIgnores(BasePlayer player1, BasePlayer player2) => Player.FindOrCreate(player2).Ignored(player1);

        #endregion

        #region Oxide Hooks

        object OnPlayerChat(ConsoleSystem.Arg arg)
        {
            if (arg == null || arg.connection == null || arg.connection.player == null)
                return null;

            BasePlayer player = (BasePlayer)arg.connection.player;
            Player pl = Player.FindOrCreate(player);
            string message = GetConfig(false, "Word Filter", "Enabled") ? FilterText(arg.GetString(0)) : arg.GetString(0);

            //  Is message invalid?
            if (message == string.Empty || message.Length <= 1)
                return false;

            pl.mute.Update();

            // Is global mute active?
            if (globalMute)
            {
                SendChatMessage(player, GetMsg("Global Mute", player.userID));
                return false;
            }

            //  Is player muted?
            if (pl.mute.Muted)
            {
                if (pl.mute.state == MutedState.TimeMuted)
                {
                    TimeSpan remainingTime = pl.mute.date.value - DateTime.Now;
                    SendChatMessage(player, GetMsg("You Are Time Muted", player.userID).Replace("{time}", FormatTime(remainingTime)));
                }
                else
                    SendChatMessage(player, GetMsg("You Are Muted", player.userID));
                return false;
            }

            //  NextChatTime is not set? SET IT!
            if (player.NextChatTime == 0f)
                player.NextChatTime = Time.realtimeSinceStartup - 30f;

            //  Chatting too fast?
            if (player.NextChatTime > Time.realtimeSinceStartup && AntiFlood_Enabled)
            {
                player.NextChatTime += AntiFlood_Seconds;

                float remainingTime = (player.NextChatTime - Time.realtimeSinceStartup) + 0.5f;
                SendChatMessage(player, GetMsg("Chatting Too Fast").Replace("{time}", Math.Round(remainingTime, 1).ToString()));

                return false;
            }

            if ((bool?)plugins.CallHook("OnBetterChat", player, message) ?? true == false)
                return false;

            //  Send message to all players who do not ignore the player
            foreach (BasePlayer current in BasePlayer.activePlayerList)
                if (!pl.Ignored(current))
                    rust.SendChatMessage(current, Group.Format(player, message), null, player.UserIDString);

            //  Log message to console
            Puts(Group.Format(player, message, true));
            //  Set NextChatTime for AntiFlood
            player.NextChatTime = Time.realtimeSinceStartup + AntiFlood_Seconds;

            return false;
        }

        #endregion

        #region General Methods

        void RunChatCommandFromConsole(ConsoleSystem.Arg arg, Action<BasePlayer, string, string[]> chatCommand)
        {
            if (arg == null)
                return;

            chatCommand((BasePlayer)arg.connection?.player ?? null, arg.cmd?.name ?? string.Empty, arg.HasArgs() ? arg.Args : new string[0]);
        }

        ////////////////////////////////////////
        ///     Player Finding
        ////////////////////////////////////////

        BasePlayer GetPlayer(string searchedPlayer, BasePlayer player)
        {
            ulong steamID;
            bool isSteamID = ulong.TryParse(searchedPlayer, out steamID);

            if (isSteamID && BasePlayer.FindByID(steamID) == null)
                SendChatMessage(player, "No player with that steamID could be found.");
            else if (isSteamID)
                return BasePlayer.FindByID(steamID);

            foreach (BasePlayer current in BasePlayer.activePlayerList)
                if (current.displayName.ToLower() == searchedPlayer.ToLower())
                    return current;

            List<BasePlayer> foundPlayers =
                (from current in BasePlayer.activePlayerList
                 where current.displayName.ToLower().Contains(searchedPlayer.ToLower())
                 select current).ToList();

            switch (foundPlayers.Count)
            {
                case 0:
                    SendChatMessage(player, "No player with that name could be found.");
                    break;

                case 1:
                    return foundPlayers[0];

                default:
                    List<string> playerNames = (from current in foundPlayers select current.displayName).ToList();
                    string players = ListToString(playerNames, 0, ", ");
                    SendChatMessage(player, "Multiple matching players found: \n" + players);
                    break;
            }

            return null;
        }

        ////////////////////////////////////////
        ///     Converting
        ////////////////////////////////////////

        string ListToString<T>(List<T> list, int first = 0, string seperator = ", ") => string.Join(seperator, (from val in list select val.ToString()).Skip(first).ToArray());

        bool TryConvert<Source, Converted>(Source s, out Converted c)
        {
            try
            {
                c = (Converted)Convert.ChangeType(s, typeof(Converted));
                return true;
            }
            catch (Exception)
            {
                c = default(Converted);
                return false;
            }
        }

        ////////////////////////////////////////
        ///     Config Related
        ////////////////////////////////////////

        void SetConfig(params object[] args)
        {
            List<string> stringArgs = (from arg in args select arg.ToString()).ToList();
            stringArgs.RemoveAt(args.Length - 1);

            if (Config.Get(stringArgs.ToArray()) == null) Config.Set(args);
        }

        T GetConfig<T>(T defaultVal, params object[] args)
        {
            List<string> stringArgs = (from arg in args select arg.ToString()).ToList();
            if (Config.Get(stringArgs.ToArray()) == null)
            {
                PrintError($"The plugin failed to read something from the config: {ListToString(stringArgs, 0, "/")}{Environment.NewLine}Please reload the plugin and see if this message is still showing. If so, please post this into the support thread of this plugin.");
                return defaultVal;
            }

            return (T)Convert.ChangeType(Config.Get(stringArgs.ToArray()), typeof(T));
        }

        ////////////////////////////////////////
        ///     Data Related
        ////////////////////////////////////////

        void LoadData<T>(ref T data, string filename = "?") => data = Core.Interface.Oxide.DataFileSystem.ReadObject<T>(filename == "?" ? Name : $"{Name}/{filename}");

        void SaveData<T>(ref T data, string filename = "?") => Core.Interface.Oxide.DataFileSystem.WriteObject(filename == "?" ? Name : $"{Name}/{filename}", data);

        string Name => Title.Replace(" ", "");

        ////////////////////////////////////////
        ///     Message Related
        ////////////////////////////////////////

        string GetMsg(string key, object userID = null) => lang.GetMessage(key, this, userID == null ? null : userID.ToString());

        ////////////////////////////////////////
        ///     Permission Related
        ////////////////////////////////////////

        void RegisterPerm(params string[] permArray)
        {
            string perm = ListToString(permArray.ToList(), 0, ".");

            permission.RegisterPermission($"{PermissionPrefix}.{perm}", this);
        }

        bool HasPerm(object uid, params string[] permArray)
        {
            string perm = ListToString(permArray.ToList(), 0, ".");

            return permission.UserHasPermission(uid.ToString(), $"{PermissionPrefix}.{perm}");
        }

        string PermissionPrefix => Title.Replace(" ", "").ToLower();

        ////////////////////////////////////////
        ///     Chat Related
        ////////////////////////////////////////

        void BroadcastChat(string prefix, string msg = null) => rust.BroadcastChat(msg == null ? prefix : "<color=#C4FF00>" + prefix + "</color>: " + msg);

        void SendChatMessage(BasePlayer player, string prefix, string msg = null)
        {
            if (player == null)
                Puts(msg == null ? prefix.Replace("/", "") : prefix + ": " + msg.Replace("/", ""));
            else
                rust.SendChatMessage(player, msg == null ? prefix : "<color=#C4FF00>" + prefix + "</color>: " + msg);
        }

        #endregion
    }
}

// --- End of file: BetterChat.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/TimedExecute.cs ---
// --- Original Local Path: TimedExecute.cs ---

using System.Collections.Generic;
using System.Reflection;
using System;
using System.Linq;
using System.Data;
using UnityEngine;
using Oxide.Core; 

namespace Oxide.Plugins 
{
    [Info("Timed Execute", "PaiN", 2.6, ResourceId = 919)]
    [Description("Execute commands every (x) seconds.")]
    class TimedExecute : RustPlugin
    {
		private Timer repeater;  
		private Timer chaintimer; 
		private Timer checkreal;
		
		void Loaded()    
		{  
			checkreal = timer.Repeat(1, 0, () => RealTime());
			RunRepeater();
			RunOnce(); 
			if(Convert.ToBoolean(Config["EnableTimerOnce"]) == true)
			{
				Puts("Timer-Once is ON");
			}
			else
			{
				Puts("Timer-Once is OFF");
			}
			if(Convert.ToBoolean(Config["EnableTimerRepeat"]) == true)
			{
				Puts("Timer-Repeat is ON");
			}
			else
			{
				Puts("Timer-Repeat is OFF");
			}
			if(Convert.ToBoolean(Config["EnabledRealTime-Timer"]) == true)
			{
				Puts("RealTime-Timer is ON");
			}
			else
			{
				Puts("RealTime-Timer is OFF");
			}
		}
		
		void RunRepeater()
		{
			if(repeater != null) 
			{
				repeater.Destroy(); 
			}
			if(Convert.ToBoolean(Config["EnableTimerRepeat"]) == true)
			{
				foreach(var cmd in Config["TimerRepeat"] as Dictionary<string, object>)
				{ 
					repeater = timer.Repeat(Convert.ToSingle(cmd.Value), 0, () =>{ 
					ConsoleSystem.Run.Server.Normal(cmd.Key);
					Puts($"ran the command || " + cmd.Key.ToString());
					});
				}
			}
		}   
		void RealTime()
		{
			if(Convert.ToBoolean(Config["EnabledRealTime-Timer"]) == true)
			{
				foreach(var cmd in Config["RealTime-Timer"] as Dictionary<string, object>)
				{
					if(System.DateTime.Now.ToString("HH:mm:ss") == cmd.Key.ToString())
					{ 
						ConsoleSystem.Run.Server.Normal(cmd.Value.ToString());
						Puts("ran the command || " + cmd.Value.ToString() + " at: " + cmd.Key);
					}
				}
			}
		}
		void RunOnce()
		{
			if(chaintimer != null)  
			{   
				chaintimer.Destroy(); 
			}   
			if(Convert.ToBoolean(Config["EnableTimerOnce"]) == true)
			{
				foreach(var cmdc in Config["TimerOnce"] as Dictionary<string, object>)
				{ 
					chaintimer = timer.Once(Convert.ToSingle(cmdc.Value), () =>{
					ConsoleSystem.Run.Server.Normal(cmdc.Key);
					Puts($"ran the command || " + cmdc.Key.ToString());
					});
				} 
			}
		}
		 
		void Unloaded()  
		{
			if(repeater != null) 
			{
				repeater.Destroy(); 
				Puts("Destroyed the *Repeater* timer!");
			}
			if(chaintimer != null)  
			{   
				chaintimer.Destroy();
				Puts("Destroyed the *Timer-Once* timer!");
			}  
			if(checkreal != null)  
			{   
				checkreal.Destroy();
				Puts("Destroyed the *RealTime* timer!");
			} 
		}  

 			Dictionary<string, object> repeatcmds = new Dictionary<string, object>();
			Dictionary<string, object> chaincmds = new Dictionary<string, object>();
			Dictionary<string, object> realtimecmds = new Dictionary<string, object>();
			 
        protected override void LoadDefaultConfig() 
        {  
			repeatcmds.Add("server.save", 300);
			repeatcmds.Add("event.run", 300);
            Puts("Creating a new configuration file!");
			if(Config["TimerRepeat"] == null) Config["TimerRepeat"] = repeatcmds;

			 
			chaincmds.Add("say 'Dont forget to like our fanpage!'", 60);
			chaincmds.Add("say 'Follow us on Twitter!'", 120);
			chaincmds.Add("say 'You can donate via PayPal!'", 180);
			chaincmds.Add("reset.oncetimer", 181);
			if(Config["TimerOnce"] == null) Config["TimerOnce"] = chaincmds;
			if(Config["EnableTimerRepeat"] == null) Config["EnableTimerRepeat"] = true;
			if(Config["EnableTimerOnce"] == null) Config["EnableTimerOnce"] = true;
			if(Config["EnabledRealTime-Timer"] == null) Config["EnabledRealTime-Timer"] = true;
			///
			realtimecmds.Add("16:00:00", "say 'The gate for the event is open!'");
			realtimecmds.Add("16:30:00", "say 'The gate for the event just closed'");
			realtimecmds.Add("17:00:00", "say 'Restart in 1 HOUR'");
			realtimecmds.Add("18:00:00", "say 'The server is restarting NOW.'");
			if(Config["RealTime-Timer"] == null) Config["RealTime-Timer"] = realtimecmds;

        }
		[ConsoleCommand("reset.oncetimer")]
		void cmdResOnceTimer(ConsoleSystem.Arg arg)
		{
			RunOnce();
		}
	}
}

// --- End of file: TimedExecute.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/StructureRefund.cs ---
// --- Original Local Path: StructureRefund.cs ---

using System;

namespace Oxide.Plugins
{
    [Info("StructureRefund", "Wulf/lukespragg", "1.2.0", ResourceId = 1692)]
    [Description("Refunds previous build materials when demolishing and/or upgrading")]

    class StructureRefund : CovalencePlugin
    {
        #region Initialization

        const string permDemolish = "structurerefund.demolish";
        const string permUpgrade = "structurerefund.upgrade";
        bool demolishRefunds;
        bool upgradeRefunds;

        protected override void LoadDefaultConfig()
        {
            // Loop through building grade names
            foreach (var grade in Enum.GetNames(typeof(BuildingGrade.Enum)))
            {
                // Skip the invalid grade names
                if (grade.Equals("None") || grade.Equals("Count")) continue;

                // Add configuration setting for grade
                Config["Refund" + grade] = GetConfig("Refund" + grade, true);
            }

            Config["DemolishRefunds"] = demolishRefunds = GetConfig("DemolishRefunds", true);
            Config["UpgradeRefunds"] = upgradeRefunds = GetConfig("UpgradeRefunds", true);
            SaveConfig();
        }

        void Init()
        {
            LoadDefaultConfig();

            // Register user/group permissions
            permission.RegisterPermission(permDemolish, this);
            permission.RegisterPermission(permUpgrade, this);

            // Only allow hooks to be called if features are enabled
            if (!demolishRefunds) Unsubscribe("OnStructureDemolish");
            if (!upgradeRefunds) Unsubscribe("OnStructureUpgrade");
        }

        #endregion

        #region Refunding

        void RefundMaterials(BuildingBlock block, BasePlayer player)
        {
            // Check if player's inventory is full, don't refund if full
            if (player.inventory.containerMain.IsFull()) return;

            // Loop through resources used to build structure
            foreach (var item in block.blockDefinition.grades[(int)block.grade].costToBuild)
                // Give player resources used
                player.GiveItem(ItemManager.CreateByItemID(item.itemid, (int)item.amount));
        }

        void OnStructureDemolish(BuildingBlock block, BasePlayer player)
        {
            // Check if player has 'structurerefund.demolish' permission
            if (permission.UserHasPermission(player.UserIDString, permDemolish)) RefundMaterials(block, player);
        }

        void OnStructureUpgrade(BuildingBlock block, BasePlayer player)
        {
            // Check if player has 'structurerefund.upgrade' permission
            if (permission.UserHasPermission(player.UserIDString, permUpgrade)) RefundMaterials(block, player);
        }

        #endregion

        T GetConfig<T>(string name, T value) => Config[name] == null ? value : (T)Convert.ChangeType(Config[name], typeof(T));    }
}


// --- End of file: StructureRefund.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/UPRemove.cs ---
// --- Original Local Path: UPRemove.cs ---

using System;
using System.Collections;
using System.Collections.Generic;
using System.Drawing;
using System.Drawing.Imaging;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Rust;
using UnityEngine;

namespace Oxide.Plugins
{
[Info("UpRemove", "Mevent", "1.3")]
public class UPRemove : RustPlugin
{
    #region Fields

    [PluginReference] private Plugin ImageLibrary, NoEscape, Clans, Friends, Notify, UINotify;
    

    private const string Layer = "UI.UPRemove";
    private const string LayerUpdate = "UI.UPRemove1";

    private static UPRemove _instance;

    private enum Types
    {
        None = -1,
        Remove = 5,
        Wood = 1,
        Stone = 2,
        Metal = 3,
        TopTier = 4
    }

    private const string PermAll = "UPRemove.all";

    private const string modepermission = "UPRemove.use";

    private const string PermFree = "UPRemove.free";

    #endregion

    #region Config

    private static Configuration _config;

    private class Configuration
    {
        [JsonProperty(PropertyName = "Remove Commands")]
        public readonly string[] RemoveCommands = {"remove"};

        [JsonProperty(PropertyName = "Upgrade Commands")]
        public readonly string[] UpgradeCommands = {"up", "building.upgrade"};

        [JsonProperty(PropertyName = "Work with Notify?")]
        public readonly bool UseNotify = true;

        [JsonProperty(PropertyName = "Setting Modes", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public readonly List<Mode> Modes = new List<Mode>
        {
            new Mode
            {
                Type = Types.Remove,
                Icon = "assets/icons/clear.png",
                Permission = string.Empty
            },
            new Mode
            {
                Type = Types.Wood,
                Icon = "assets/icons/level_wood.png",
                Permission = string.Empty
            },
            new Mode
            {
                Type = Types.Stone,
                Icon = "assets/icons/level_stone.png",
                Permission = string.Empty
            },
            new Mode
            {
                Type = Types.Metal,
                Icon = "assets/icons/level_metal.png",
                Permission = string.Empty
            },
            new Mode
            {
                Type = Types.TopTier,
                Icon = "assets/icons/level_top.png",
                Permission = string.Empty
            }
        };

        [JsonProperty(PropertyName = "Upgrade Settings")]
        public readonly UpgradeSettings Upgrade = new UpgradeSettings
        {
            ActionTime = 30,
            Cooldown = 0,
            VipCooldown = new Dictionary<string, int>
            {
                ["buildtool.vip"] = 0,
                ["buildtool.premium"] = 0
            },
            AfterWipe = 0,
            VipAfterWipe = new Dictionary<string, int>
            {
                ["buildtool.vip"] = 0,
                ["buildtool.premium"] = 0
            }
        };

        [JsonProperty(PropertyName = "Remove Settings")]
        public readonly RemoveSettings Remove = new RemoveSettings
        {
            ActionTime = 30,
            Cooldown = 0,
            VipCooldown = new Dictionary<string, int>
            {
                ["buildtool.vip"] = 0,
                ["buildtool.premium"] = 0
            },
            AfterWipe = 0,
            VipAfterWipe = new Dictionary<string, int>
            {
                ["buildtool.vip"] = 0,
                ["buildtool.premium"] = 0
            },
            Condition = new ConditionSettings
            {
                Default = true,
                Percent = false,
                PercentValue = 0
            },
            ReturnItem = true,
            ReturnPercent = 100,
            BlockedList = new List<string>
            {
                "shortname 1",
                "shortname 2",
                "shortname 3"
            }
        };

        [JsonProperty(PropertyName = "Block Settings")]
        public readonly BlockSettings Block = new BlockSettings
        {
            UseNoEscape = true,
            UseClans = true,
            UseFriends = true,
            UseCupboard = true
        };

        [JsonProperty(PropertyName = "Additional Slot Settings")]
        public readonly AdditionalSlot AdditionalSlot = new AdditionalSlot
        {
            Enabled = true
        };

        [JsonProperty(PropertyName = "UI Settings")]
        public readonly InterfaceSettings UI = new InterfaceSettings
        {
            Color1 = new IColor("#4B68FF"),
            Color2 = new IColor("#2C2C2C"),
            Color3 = new IColor("#B64040"),
            OffsetY = 0,
            OffsetX = 0
        };
    }

    private class AdditionalSlot
    {
        [JsonProperty(PropertyName = "Enabled")]
        public bool Enabled;

/*        public static void Get(BasePlayer player)
        {
            var item = ItemManager.CreateByName("hammer");
            if (item == null) return;

            if (player.inventory.containerBelt.capacity < 7)
                player.inventory.containerBelt.capacity++;

            item.LockUnlock(true);
            item.MoveToContainer(player.inventory.containerBelt, 6);
        }*/

/*        public static void Remove(BasePlayer player)
        {
            var item = player.inventory.containerBelt.GetSlot(6);
            if (item == null || item.info.shortname != "hammer") return;

            item.RemoveFromContainer();
            item.Remove();

            ItemManager.DoRemoves();

            player.inventory.containerBelt.capacity--;
        }*/
    }

    private class InterfaceSettings
    {
        [JsonProperty(PropertyName = "Color 1")]
        public IColor Color1;

        [JsonProperty(PropertyName = "Color 2")]
        public IColor Color2;

        [JsonProperty(PropertyName = "Color 3")]
        public IColor Color3;

        [JsonProperty(PropertyName = "Offset Y")]
        public float OffsetY;

        [JsonProperty(PropertyName = "Offset X")]
        public float OffsetX;
    }

    private class IColor
    {
        [JsonProperty(PropertyName = "HEX")] public string Hex;

        [JsonProperty(PropertyName = "Opacity (0 - 100)")]
        public readonly float Alpha;

        [JsonProperty] private string _color;

        [JsonIgnore]
        public string Get
        {
            get
            {
                if (string.IsNullOrEmpty(_color))
                    _color = GetColor();

                return _color;
            }
        }

        private string GetColor()
        {
            if (string.IsNullOrEmpty(Hex)) Hex = "#FFFFFF";

            var str = Hex.Trim('#');
            if (str.Length != 6) throw new Exception(Hex);
            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);

            return $"{(double) r / 255} {(double) g / 255} {(double) b / 255} {Alpha / 100}";
        }

        public IColor()
        {
        }

        public IColor(string hex, float alpha = 100)
        {
            Hex = hex;
            Alpha = alpha;
        }
    }

    private class ConditionSettings
    {
        [JsonProperty(PropertyName = "Default (from game)")]
        public bool Default;

        [JsonProperty(PropertyName = "Use percent?")]
        public bool Percent;

        [JsonProperty(PropertyName = "Percent (value)")]
        public float PercentValue;
    }

    private class BlockSettings
    {
        [JsonProperty(PropertyName = "Work with NoEscape?")]
        public bool UseNoEscape;

        [JsonProperty(PropertyName = "Work with Clans? (clan members will be able to delete/upgrade)")]
        public bool UseClans;

        [JsonProperty(PropertyName = "Work with Friends? (friends will be able to delete/upgrade)")]
        public bool UseFriends;

        [JsonProperty(PropertyName = "Can those authorized in the cupboard delete/upgrade?")]
        public bool UseCupboard;

        [JsonProperty(PropertyName = "Is an upgrade/remove cupbaord required?")]
        public bool NeedCupboard;
    }

    private abstract class TotalSettings
    {
        [JsonProperty(PropertyName = "Time of action")]
        public int ActionTime;

        [JsonProperty(PropertyName = "Cooldown (default | 0 - disable)")]
        public int Cooldown;

        [JsonProperty(PropertyName = "Cooldowns", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public Dictionary<string, int> VipCooldown;

        [JsonProperty(PropertyName = "Block After Wipe (default | 0 - disable)")]
        public int AfterWipe;

        [JsonProperty(PropertyName = "Block After Wipe", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public Dictionary<string, int> VipAfterWipe;

        public int GetCooldown(BasePlayer player)
        {
            return (from check in VipCooldown
                where player.IPlayer.HasPermission(check.Key)
                select check.Value).Prepend(Cooldown).Min();
        }

        public int GetWipeCooldown(BasePlayer player)
        {
            return (from check in VipAfterWipe
                where player.IPlayer.HasPermission(check.Key)
                select check.Value).Prepend(AfterWipe).Min();
        }
    }

    private class UpgradeSettings : TotalSettings
    {
    }

    private class RemoveSettings : TotalSettings
    {
        [JsonProperty(PropertyName = "Blocked items to remove (prefab)",
            ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public List<string> BlockedList;

        [JsonProperty(PropertyName = "Return Item")]
        public bool ReturnItem;

        [JsonProperty(PropertyName = "Returnable Item Percentage")]
        public float ReturnPercent;

        [JsonProperty(PropertyName = "Can friends remove? (Friends)")]
        public bool CanFriends;

        [JsonProperty(PropertyName = "Can clanmates remove? (Clans)")]
        public bool CanClan;

        [JsonProperty(PropertyName = "Can teammates remove?")]
        public bool CanTeams;

        [JsonProperty(PropertyName = "Require a cupboard")]
        public bool RequireCupboard;

        [JsonProperty(PropertyName = "Remove by cupboard? (those who are authorized in the cupboard can remove)")]
        public bool RemoveByCupboard;

        [JsonProperty(PropertyName = "Condition Settings")]
        public ConditionSettings Condition;
    }

    private class Mode
    {
        [JsonProperty(PropertyName = "Icon (assets/url)")]
        public string Icon;

        [JsonProperty(PropertyName = "Type (Remove/Wood/Stone/Metal/TopTier)")]
        [JsonConverter(typeof(StringEnumConverter))]
        public Types Type;

        [JsonProperty(PropertyName = "Permission (ex: UPRemove.1)")]
        public string Permission;
    }

    protected override void LoadConfig()
    {
        base.LoadConfig();
        try
        {
            _config = Config.ReadObject<Configuration>();
            if (_config == null) throw new Exception();
            SaveConfig();
        }
        catch (Exception ex)
        {
            PrintError("Your configuration file contains an error. Using default configuration values.");
            LoadDefaultConfig();
            Debug.LogException(ex);
        }
    }

    protected override void SaveConfig()
    {
        Config.WriteObject(_config);
    }

    protected override void LoadDefaultConfig()
    {
        _config = new Configuration();
    }

    #endregion


    Dictionary<string, string> UPRemoveImages = new Dictionary<string, string>()
    {
        {"UPRemove.Wood",    "https://imgur.com/79AHR7v.png"},
        {"UPRemove.Stone",   "https://imgur.com/hZrZ1wP.png"},
        {"UPRemove.Metal",   "https://imgur.com/9M9sdqg.png"},
        {"UPRemove.TopTier", "https://imgur.com/Cu50ZmH.png"},
        {"UPRemove.Remove",  "https://imgur.com/IRJwxtZ.png"}
    };
    
    Dictionary<BuildingGrade.Enum, string> UPRemoveString = new Dictionary<BuildingGrade.Enum, string>()
    {
        {BuildingGrade.Enum.Wood,     "ДЕРЕВО"},
        {BuildingGrade.Enum.Stone,    "КАМЕНЬ"},
        {BuildingGrade.Enum.Metal,    "МЕТАЛЛ"},
        {BuildingGrade.Enum.TopTier,  "МВК"}
    };

    #region Data

    private PluginData _data;

    private void SaveData()
    {
        Interface.Oxide.DataFileSystem.WriteObject(Name, _data);
    }

    private void LoadData()
    {
        try
        {
            _data = Interface.Oxide.DataFileSystem.ReadObject<PluginData>(Name);
        }
        catch (Exception e)
        {
            PrintError(e.ToString());
        }

        if (_data == null) _data = new PluginData();
    }

    private class PluginData
    {
        [JsonProperty(PropertyName = "Players", ObjectCreationHandling = ObjectCreationHandling.Replace)]
        public readonly Dictionary<ulong, PlayerData> Players = new Dictionary<ulong, PlayerData>();
    }

    private class PlayerData
    {
        [JsonProperty(PropertyName = "Last Upgrade")]
        public DateTime LastUpgrade = new DateTime(1970, 1, 1, 0, 0, 0);

        [JsonProperty(PropertyName = "Last Remove")]
        public DateTime LastRemove = new DateTime(1970, 1, 1, 0, 0, 0);

        public int LeftTime(bool remove, int cooldown)
        {
            var time = remove
                ? LastRemove
                : LastUpgrade;
            return (int) time.AddSeconds(cooldown).Subtract(DateTime.UtcNow).TotalSeconds;
        }

        public bool HasCooldown(bool remove, int cooldown)
        {
            var time = remove
                ? LastRemove
                : LastUpgrade;

            return DateTime.UtcNow.Subtract(time).TotalSeconds < cooldown;
        }

        public static bool HasWipeCooldown(int cooldown)
        {
            return DateTime.UtcNow.Subtract(SaveRestore.SaveCreatedTime.ToUniversalTime()).TotalSeconds < cooldown;
        }

        public static int WipeLeftTime(int cooldown)
        {
            return (int) SaveRestore.SaveCreatedTime.ToUniversalTime().AddSeconds(cooldown)
                .Subtract(DateTime.UtcNow)
                .TotalSeconds;
        }
    }

    private PlayerData GetPlayerData(ulong userId)
    {
        PlayerData playerData;
        if (!_data.Players.TryGetValue(userId, out playerData))
            _data.Players.Add(userId, playerData = new PlayerData());

        return playerData;
    }

    #endregion

    #region Hooks

    private void Init()
    {
        _instance = this;

        LoadData();

        RegisterPermissions();

        AddCovalenceCommand(_config.UpgradeCommands, nameof(CmdUpgrade));

        AddCovalenceCommand(_config.RemoveCommands, nameof(CmdRemove));

/*        if (!_config.AdditionalSlot.Enabled)
        {
            Unsubscribe(nameof(OnPlayerConnected));
            Unsubscribe(nameof(OnPlayerDisconnected));
            Unsubscribe(nameof(OnPlayerDeath));
            Unsubscribe(nameof(OnActiveItemChanged));
        }*/
    }

    private void OnServerInitialized()
    {
        LoadImages();

            foreach (var player in BasePlayer.activePlayerList)
                OnPlayerConnected(player);
        
        InitFileManager();
        CommunityEntity.ServerInstance.StartCoroutine(StoreImages());
    }

    private void Unload()
    {
        foreach (var player in BasePlayer.activePlayerList)
        {
            CuiHelper.DestroyUi(player, Layer);

          
                OnPlayerDisconnected(player, string.Empty);
        }

        Array.ForEach(_components.Values.ToArray(), build =>
        {
            if (build != null)
                build.Kill();
        });

        SaveData();

        _config = null;
        _instance = null;
    }

    private void OnPlayerConnected(BasePlayer player)
    {
        if (player == null || player.IsNpc) return;

        //AdditionalSlot.Get(player);
    }

    private void OnPlayerDisconnected(BasePlayer player, string reason)
    {
        if (player == null || player.IsNpc) return;

        //AdditionalSlot.Remove(player);
    }

    private void OnPlayerDeath(BasePlayer player, HitInfo info)
    {
        if (player == null || player.IsNpc) return;

        //AdditionalSlot.Remove(player);
    }

    private void OnActiveItemChanged(BasePlayer player, Item oldItem, Item newItem)
    {
        if (player == null || player.IsNpc) return;

        if (oldItem != null && oldItem.position == 6)
        {
            var build = GetBuild(player);
            if (build != null && build.activeByItem)
                build.Kill();
            return;
        }

        if (newItem != null && newItem.position == 6)
        {
            if (GetBuild(player) != null) return;

            AddOrGetBuild(player, true).GoNext();
        }
    }

    private object OnHammerHit(BasePlayer player, HitInfo info)
    {
        if (player == null || info == null) return null;

        var entity = info.HitEntity as BaseCombatEntity;
        if (entity == null || entity.OwnerID == 0) return null;

        var build = GetBuild(player);
        if (build == null) return null;

        var mode = build.GetMode();
        if (mode == null) return null;

        if (!player.CanBuild())
        {
            SendNotify(player, BuildingBlocked, 1);
            return true;
        }

        if (_config.Block.UseNoEscape && NoEscape != null && NoEscape.IsLoaded && IsRaidBlocked(player))
        {
            SendNotify(player, mode.Type == Types.Remove ? RemoveRaidBlocked : UpgradeRaidBlocked, 1);
            return true;
        }

        var cupboard = entity.GetBuildingPrivilege();
        if (cupboard == null && _config.Block.NeedCupboard)
        {
            SendNotify(player, CupboardRequired, 1);
            return true;
        }

        if (entity.OwnerID != player.userID) //NOT OWNER
        {
            var any =
                _config.Block.UseFriends && Friends != null && Friends.IsLoaded &&
                IsFriends(player.OwnerID, entity.OwnerID) ||
                _config.Block.UseClans && Clans != null && Clans.IsLoaded &&
                IsClanMember(player.OwnerID, entity.OwnerID) ||
                _config.Block.UseCupboard && (cupboard == null || cupboard.IsAuthed(player));

            if (!any)
            {
                SendNotify(player, mode.Type == Types.Remove ? CantRemove : CantUpgrade, 1);
                return true;
            }
        }

        if (mode.Type == Types.Remove)
        {
            if (_config.Remove.BlockedList.Contains(entity.name))
            {
                SendNotify(player, mode.Type == Types.Remove ? CantRemove : CantUpgrade, 1);
                return true;
            }
        }
        else
        {
            var block = entity as BuildingBlock;
            if (block != null && (int) block.grade >= (int) mode.Type) return true;
        }

        build.DoIt(entity);
        return true;
    }

    private void OnEntityBuilt(Planner plan, GameObject go)
    {
        var player = plan.GetOwnerPlayer();
        if (player == null) return;

        var block = go.ToBaseEntity() as BuildingBlock;
        if (block == null) return;

        var build = GetBuild(player);
        if (build == null) return;

        var mode = build.GetMode();
        if (mode == null || mode.Type == Types.Remove) return;

        build.DoIt(block);
    }

    #endregion

    #region Commands

    private void CmdRemove(IPlayer cov, string command, string[] args)
    {
        var player = cov.Object as BasePlayer;
        if (player == null) return;

        var mode = _config.Modes.Find(x => x.Type == Types.Remove);

        if (args.Length > 0 && args[0] == "all")
        {
            var cupboard = player.GetBuildingPrivilege();
            if (cupboard == null)
            {
                SendNotify(player, NoCupboard, 1);
                return;
            }

            var data = GetPlayerData(player.userID);

            var cooldown = _config.Remove.GetCooldown(player);
            if (cooldown > 0 && data.HasCooldown(false, cooldown))
            {
                SendNotify(player, RemoveCanThrough, 1,
                    data.LeftTime(false, cooldown));
                return;
            }

            var blockWipe = _config.Remove.GetWipeCooldown(player);
            if (blockWipe > 0 && PlayerData.HasWipeCooldown(blockWipe))
            {
                SendNotify(player, RemoveCanThrough, 1,
                    PlayerData.WipeLeftTime(blockWipe));
                return;
            }

            var entities = BaseNetworkable.serverEntities
                .OfType<BaseCombatEntity>()
                .Where(x => !(x is BasePlayer) && x.GetBuildingPrivilege() == cupboard)
                .ToList();
            if (entities.Count == 0 || entities.Any(x => !CanRemove(player, x)))
                return;

            Global.Runner.StartCoroutine(StartRemove(player, entities));

            SendNotify(player, SuccessfullyUpgrade, 0);
            return;
        }

        AddOrGetBuild(player).Init(mode);
    }

    private void CmdUpgrade(IPlayer cov, string command, string[] args)
    {
        var player = cov.Object as BasePlayer;
        if (player == null) return;

        if (args.Length == 0)
        {
            AddOrGetBuild(player).GoNext();
            return;
        }

        switch (args[0])
        {
            case "all":
            {
                if (!cov.HasPermission(PermAll))
                {
                    SendNotify(player, NoPermission, 1);
                    return;
                }

                Types upgradeType;
                if (args.Length < 2 || ParseType(args[1], out upgradeType) == Types.None)
                {
                    cov.Reply($"Error syntax! Use: /{command} {args[0]} [wood/stone/metal/toptier]");
                    return;
                }

                var cupboard = player.GetBuildingPrivilege();
                if (cupboard == null)
                {
                    SendNotify(player, NoCupboard, 1);
                    return;
                }

                if (!player.CanBuild())
                {
                    SendNotify(player, BuildingBlocked, 1);
                    return;
                }

                if (_config.Block.UseNoEscape && NoEscape != null && NoEscape.IsLoaded && IsRaidBlocked(player))
                {
                    SendNotify(player, UpgradeRaidBlocked, 1);
                    return;
                }

                var data = GetPlayerData(player.userID);

                var cooldown = _config.Upgrade.GetCooldown(player);
                if (cooldown > 0 && data.HasCooldown(false, cooldown))
                {
                    SendNotify(player, UpgradeCanThrough, 1,
                        data.LeftTime(false, cooldown));
                    return;
                }

                var blockWipe = _config.Upgrade.GetWipeCooldown(player);
                if (blockWipe > 0 && PlayerData.HasWipeCooldown(blockWipe))
                {
                    SendNotify(player, UpgradeCanThrough, 1,
                        PlayerData.WipeLeftTime(blockWipe));
                    return;
                }

                var grade = GetEnum(upgradeType);

                var buildingBlocks = BaseNetworkable.serverEntities
                    .OfType<BuildingBlock>()
                    .Where(x =>
                        x.GetBuildingPrivilege() == cupboard &&
                        x.grade <= grade &&
                        x.CanChangeToGrade(grade, player))
                    .ToList();
                if (buildingBlocks.Count == 0) return;

                if (!cov.HasPermission(PermFree))
                {
                    if (!CanAffordUpgrade(buildingBlocks, grade, player))
                    {
                        SendNotify(player, NotEnoughResources, 1);
                        return;
                    }

                    PayForUpgrade(buildingBlocks, grade, player);
                }

                Global.Runner.StartCoroutine(StartUpgrade(player, buildingBlocks, grade));

                SendNotify(player, SuccessfullyUpgrade, 0);
                break;
            }
            default:
            {
                Types type;
                if (ParseType(args[0], out type) != Types.None)
                {
                    var modes = GetPlayerModes(player);
                    if (modes == null) return;

                    var mode = modes.Find(x => x.Type == type);

                    var build = AddOrGetBuild(player);
                    build.Init(mode);
                }
                else
                {
                    AddOrGetBuild(player).GoNext();
                }

                break;
            }
        }
    }

    [ConsoleCommand("UI_Builder")]
    private void CmdConsoleBuilding(ConsoleSystem.Arg arg)
    {
        var player = arg.Player();
        if (player == null || !arg.HasArgs()) return;

        switch (arg.Args[0])
        {
            case "mode":
            {
                int index;
                if (!arg.HasArgs(2) || !int.TryParse(arg.Args[1], out index)) return;

                var mode = GetPlayerModes(player)[index];
                if (mode == null) return;

                AddOrGetBuild(player)?.Init(mode);
                break;
            }

            case "close":
            {
                GetBuild(player)?.Kill();
                break;
            }
        }
    }

    #endregion

    #region Component

    private readonly Dictionary<BasePlayer, BuildComponent> _components =
        new Dictionary<BasePlayer, BuildComponent>();

    private BuildComponent GetBuild(BasePlayer player)
    {
        BuildComponent build;
        return _components.TryGetValue(player, out build) ? build : null;
    }

    private BuildComponent AddOrGetBuild(BasePlayer player, bool item = false)
    {
        BuildComponent build;
        if (_components.TryGetValue(player, out build))
            return build;

        build = player.gameObject.AddComponent<BuildComponent>();
        build.activeByItem = item;
        return build;
    }

    private class BuildComponent : FacepunchBehaviour
    {
        #region Fields

        private BasePlayer _player;

        private Mode _mode;

        private float _startTime;

        private readonly CuiElementContainer _container = new CuiElementContainer();

        private bool _started = true;

        private float _cooldown;

        public bool activeByItem;

        #endregion

        #region Init

        private void Awake()
        {
            _player = GetComponent<BasePlayer>();

            _instance._components[_player] = this;

            enabled = false;
        }

        public void Init(Mode mode)
        {
            if (mode == null)
                mode = GetPlayerModes(_player).FirstOrDefault();

            _mode = mode;

            _startTime = Time.time;

            _cooldown = GetCooldown();

            MainUi();
            //DDrawUI();

            enabled = true;

            _started = true;
        }

        #endregion

        #region Interface

        /*public void DDrawUI()
        {               
            _container.Clear();

            _container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.272397 0.009259259", AnchorMax = "0.3348944 0.1203704" },
                Image = { Color = "0 0 0 0" }
            }, "Overlay", Layer);
            
            _container.Add(new CuiElement
            {
                Parent = Layer,
                Components =
                {
                    new CuiRawImageComponent { Png = _instance.UPRemoveImages[$"building.upgrade.{_mode.Type}"] },
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                }
            });

            CuiHelper.DestroyUi(_player, Layer);
            CuiHelper.AddUi(_player, _container);
        }*/

        public void MainUi()
        {
            _container.Clear();

            _container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.00718534 0.387963", AnchorMax = "0.1427083 0.4375001" },
                Image = { Color = "0 0 0 0" }
            }, "Overlay", Layer);
            
            _container.Add(new CuiElement
            {
                Parent = Layer,
                Name = Layer + ".Panel",
                Components =
                {
                    new CuiRawImageComponent { Png = _instance.UPRemoveImages[$"UPRemove.{_mode.Type}"] },
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                }
            });

            CuiHelper.DestroyUi(_player, Layer);
            CuiHelper.AddUi(_player, _container);
        }

        private void UpdateUi()
        {
            _container.Clear();

            _container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.07083333 0.4027778", AnchorMax = "0.1843693 0.4314461" },
                Image = { Color = "0 0 0 0" }
            },  "Overlay", LayerUpdate);

            var TextUI = _mode.Type == Types.Remove ? $"<size=12>{GetLeftTime()}СЕК</size>" : $"<size=12>{GetLeftTime()}СЕК</size>";
            
            _container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Text = { Text = $"{TextUI}", Align = TextAnchor.LowerCenter, Font = "robotocondensed-bold.ttf" }
            }, LayerUpdate);

            CuiHelper.DestroyUi(_player, LayerUpdate);
            CuiHelper.AddUi(_player, _container);
        }

        #endregion

        #region Update

        private void FixedUpdate()
        {
            if (!_started) return;

            var timeLeft = Time.time - _startTime;
            if (timeLeft > _cooldown)
            {
                Kill();
                return;
            }

            UpdateUi();
        }

        #endregion

        #region Main

        public void DoIt(BaseCombatEntity entity)
        {
            if (entity == null) return;

            switch (_mode.Type)
            {
                case Types.Remove:
                {
                    if (!CanRemove(_player, entity))
                        return;

                    var data = _instance.GetPlayerData(_player.userID);

                    var cooldown = _config.Remove.GetCooldown(_player);
                    if (cooldown > 0 && data.HasCooldown(true, cooldown))
                    {
                        _instance.SendNotify(_player, RemoveCanThrough, 1,
                            data.LeftTime(true, cooldown));
                        return;
                    }

                    var blockWipe = _config.Remove.GetWipeCooldown(_player);
                    if (blockWipe > 0 && PlayerData.HasWipeCooldown(blockWipe))
                    {
                        _instance.SendNotify(_player, RemoveCanThrough, 1,
                            PlayerData.WipeLeftTime(blockWipe));
                        return;
                    }

                    RemoveEntity(_player, entity);

                    data.LastRemove = DateTime.UtcNow;
                    break;
                }
                default:
                {
                    var block = entity as BuildingBlock;
                    if (block == null) return;

                    var data = _instance.GetPlayerData(_player.userID);

                    var cooldown = _config.Upgrade.GetCooldown(_player);
                    if (cooldown > 0 && data.HasCooldown(false, cooldown))
                    {
                        _instance.SendNotify(_player, UpgradeCanThrough, 1,
                            data.LeftTime(false, cooldown));
                        return;
                    }

                    var blockWipe = _config.Upgrade.GetWipeCooldown(_player);
                    if (blockWipe > 0 && PlayerData.HasWipeCooldown(blockWipe))
                    {
                        _instance.SendNotify(_player, UpgradeCanThrough, 1,
                            PlayerData.WipeLeftTime(blockWipe));
                        return;
                    }

                    var enumGrade = GetEnum(_mode.Type);

                    var grade = block.GetGrade(enumGrade);
                    if (grade == null || !block.CanChangeToGrade(enumGrade, _player) ||
                        Interface.CallHook("OnStructureUpgrade", block, _player, enumGrade) != null ||
                        block.SecondsSinceAttacked < 30.0)
                        return;

                    if (!_player.IPlayer.HasPermission(PermFree))
                    {
                        if (!block.CanAffordUpgrade(enumGrade, _player))
                        {
                            _instance.SendNotify(_player, NotEnoughResources, 0);
                            return;
                        }

                        block.PayForUpgrade(grade, _player);
                    }

                    UpgradeBuildingBlock(block, enumGrade);

                    Effect.server.Run(
                        "assets/bundled/prefabs/fx/build/promote_" + enumGrade.ToString().ToLower() + ".prefab",
                        block,
                        0U, Vector3.zero, Vector3.zero);

                    data.LastUpgrade = DateTime.UtcNow;
                    break;
                }
            }

            _startTime = Time.time;
        }

        #endregion

        #region Utils

        private int GetLeftTime()
        {
            return Mathf.RoundToInt(_startTime + _cooldown - Time.time);
        }

        public void GoNext()
        {
            var modes = GetPlayerModes(_player);
            if (modes == null) return;

            if (_mode == null)
            {
                _mode = modes.FindAll(x => x.Type != Types.Remove).FirstOrDefault();
                Init(_mode);
                return;
            }

            var i = 0;
            for (; i < modes.Count; i++)
            {
                var mode = modes[i];

                if (mode == _mode)
                    break;
            }

            i++;

            var nextMode = modes.Count <= i ? modes[0] : modes[i];

            _mode = nextMode;

            Init(nextMode);
        }

        public Mode GetMode()
        {
            return _mode;
        }

        private float GetCooldown()
        {
            switch (_mode.Type)
            {
                case Types.Remove:
                    return _config.Remove.ActionTime;
                default:
                    return _config.Upgrade.ActionTime;
            }
        }

        #endregion

        #region Destroy

        private void OnDestroy()
        {
            CancelInvoke();

            CuiHelper.DestroyUi(_player, Layer);
            CuiHelper.DestroyUi(_player, LayerUpdate);

            _instance?._components.Remove(_player);

            Destroy(this);
        }

        public void Kill()
        {
            enabled = false;

            _started = false;

            DestroyImmediate(this);
        }

        #endregion
    }

    #endregion

    #region Utils

    private void RegisterPermissions()
    {
        permission.RegisterPermission(PermAll, this);

        permission.RegisterPermission(PermFree, this);

        _config.Modes.ForEach(mode =>
        {
            if (!string.IsNullOrEmpty(modepermission) && !permission.PermissionExists(modepermission))
                permission.RegisterPermission(modepermission, this);
        });
    }

    private void LoadImages()
    {
        if (ImageLibrary == null || !ImageLibrary.IsLoaded)
        {
            PrintError("IMAGE LIBRARY IS NOT INSTALLED!");
        }
        else
        {
            var imagesList = new Dictionary<string, string>();

            _config.Modes.FindAll(mode => !mode.Icon.Contains("assets/icon")).ForEach(mode =>
            {
                if (!string.IsNullOrEmpty(mode.Icon) && !imagesList.ContainsKey(mode.Icon))
                    imagesList.Add(mode.Icon, mode.Icon);
            });

            ImageLibrary?.Call("ImportImageList", Title, imagesList, 0UL, true);
        }
    }

    private static string FixNames(string name)
    {
        switch (name)
        {
            case "wall.external.high.wood": return "wall.external.high";
            case "electric.windmill.small": return "generator.wind.scrap";
            case "graveyardfence": return "wall.graveyard.fence";
            case "coffinstorage": return "coffin.storage";
        }

        return name;
    }

    private static List<Mode> GetPlayerModes(BasePlayer player)
    {
        return _config.Modes.FindAll(x =>
            string.IsNullOrEmpty(x.Permission) || player.IPlayer.HasPermission(x.Permission));
    }

    private bool IsRaidBlocked(BasePlayer player)
    {
        return Convert.ToBoolean(NoEscape?.Call("IsRaidBlocked", player));
    }

    private bool IsClanMember(ulong playerID, ulong targetID)
    {
        return Convert.ToBoolean(Clans?.Call("HasFriend", playerID, targetID));
    }

    private bool IsFriends(ulong playerID, ulong friendId)
    {
        return Convert.ToBoolean(Friends?.Call("HasFriend", playerID, friendId));
    }

    private static BuildingGrade.Enum GetEnum(Types type)
    {
        switch (type)
        {
            case Types.Wood:
                return BuildingGrade.Enum.Wood;
            case Types.Stone:
                return BuildingGrade.Enum.Stone;
            case Types.Metal:
                return BuildingGrade.Enum.Metal;
            case Types.TopTier:
                return BuildingGrade.Enum.TopTier;
            default:
                return BuildingGrade.Enum.None;
        }
    }

    private static void RemoveEntity(BasePlayer player, BaseCombatEntity entity)
    {
        if (_config.Remove.ReturnItem)
            GiveRefund(entity, player);

        entity.Kill();
    }

    private static bool CanRemove(BasePlayer player, BaseEntity entity)
    {
        if (entity.OwnerID == 0)
        {
            _instance.SendNotify(player, CantRemove, 1);
            return false;
        }

        var storageContainer = entity.GetComponent<StorageContainer>();
        if (storageContainer != null && storageContainer.inventory.itemList.Count > 1)
        {
            _instance.SendNotify(player, CRStorageNotEmpty, 1);
            return false;
        }

        var combat = entity.GetComponent<BaseCombatEntity>();
        if (combat != null && combat.SecondsSinceAttacked < 30f)
        {
            _instance.SendNotify(player, CRDamaged, 1);
            return false;
        }

        if (Interface.Call("CanRemove", player, entity) != null)
        {
            _instance.SendNotify(player, CRBeBlocked, 1);
            return false;
        }

        if (_config.Block.NeedCupboard && entity.GetBuildingPrivilege() == null)
        {
            _instance.SendNotify(player, CRBuildingBlock, 1);
            return false;
        }

        if (_config.Block.UseNoEscape && _instance.NoEscape != null && _instance.NoEscape.IsLoaded &&
            _instance.IsRaidBlocked(player))
        {
            _instance.SendNotify(player, RemoveRaidBlocked, 1);
            return false;
        }

        if (player.userID != entity.OwnerID)
        {
            if (_config.Remove.RemoveByCupboard)
                return true;

            if (_config.Remove.CanClan && _instance.IsClanMember(player.userID, entity.OwnerID)) return true;

            if (_config.Remove.CanFriends && _instance.IsFriends(player.userID, entity.OwnerID)) return true;

            _instance.SendNotify(player, CRNotAccess, 1);
            return false;
        }

        return true;
    }

    private static void GiveRefund(BaseCombatEntity entity, BasePlayer player)
    {
        var shortPrefabName = entity.ShortPrefabName;
        shortPrefabName = Regex.Replace(shortPrefabName, "\\.deployed|_deployed", "");
        shortPrefabName = FixNames(shortPrefabName);

        var item = ItemManager.CreateByName(shortPrefabName);
        if (item != null)
        {
            HandleCondition(ref item, player, entity);

            player.inventory.GiveItem(item);
            return;
        }

        entity.BuildCost()?.ForEach(value =>
        {
            var amount = _config.Remove.ReturnPercent < 100
                ? Convert.ToInt32(value.amount * (_config.Remove.ReturnPercent / 100f))
                : Convert.ToInt32(value.amount);

            var x = ItemManager.Create(value.itemDef, amount);
            if (x == null) return;

            HandleCondition(ref x, player, entity);

            player.GiveItem(x);
        });
    }

    private static void HandleCondition(ref Item item, BasePlayer player, BaseCombatEntity entity)
    {
        if (_config.Remove.Condition.Default)
        {
            if (entity.pickup.setConditionFromHealth && item.hasCondition)
                item.conditionNormalized = Mathf.Clamp01(entity.healthFraction - entity.pickup.subtractCondition);
            //entity.OnPickedUpPreItemMove(item, player);
        }

        if (_config.Remove.Condition.Percent)
            item.LoseCondition(item.maxCondition * (_config.Remove.Condition.PercentValue / 100f));
    }

    private static void UpgradeBuildingBlock(BuildingBlock block, BuildingGrade.Enum @enum)
    {
        if (block == null || block.IsDestroyed) return;

        block.SetGrade(@enum);
        block.SetHealthToMax();
        block.StartBeingRotatable();
        block.SendNetworkUpdate();
        block.UpdateSkin();
        block.ResetUpkeepTime();
        block.UpdateSurroundingEntities();
        BuildingManager.server.GetBuilding(block.buildingID)?.Dirty();
    }

    private bool CanAffordUpgrade(List<BuildingBlock> blocks, BuildingGrade.Enum @enum, BasePlayer player)
    {
        return blocks.All(block => block.GetGrade(@enum).costToBuild.All(itemAmount =>
            player.inventory.GetAmount(itemAmount.itemid) >= itemAmount.amount));
    }

    private static void PayForUpgrade(List<BuildingBlock> blocks, BuildingGrade.Enum @enum, BasePlayer player)
    {
        var collect = new List<Item>();

        blocks.ForEach(block => block.GetGrade(@enum).costToBuild.ForEach(itemAmount =>
        {
            player.inventory.Take(collect, itemAmount.itemid, (int) itemAmount.amount);
            player.Command("note.inv " + itemAmount.itemid + " " + (float) ((int) itemAmount.amount * -1.0));
        }));

        foreach (var obj in collect)
            obj.Remove();
    }

    private IEnumerator StartUpgrade(BasePlayer player, List<BuildingBlock> blocks, BuildingGrade.Enum @enum)
    {
        for (var i = 0; i < blocks.Count; i++)
        {
            var block = blocks[i];
            if (block == null || block.IsDestroyed) continue;

            UpgradeBuildingBlock(block, @enum);

            if (i % 10 == 0) yield return CoroutineEx.waitForFixedUpdate;
        }
    }

    private IEnumerator StartRemove(BasePlayer player, List<BaseCombatEntity> entities)
    {
        for (var i = 0; i < entities.Count; i++)
        {
            var entity = entities[i];
            if (entity == null || entity.IsDestroyed) continue;

            RemoveEntity(player, entity);

            if (i % 10 == 0)
                yield return CoroutineEx.waitForFixedUpdate;
        }
    }

    private static Types ParseType(string arg, out Types type)
    {
        Types upgradeType;
        if (Enum.TryParse(arg, true, out upgradeType))
        {
            type = upgradeType;
            return type;
        }

        int value;
        if (int.TryParse(arg, out value) && value > 0 && value < 6)
        {
            type = (Types) value;
            return type;
        }

        type = Types.None;
        return type;
    }

    #endregion

    #region Lang

    private const string
        CRNotAccess = "CRNotAccess",
        CRBuildingBlock = "CRBuildingBlock",
        CRBeBlocked = "CRBeBlocked",
        CRStorageNotEmpty = "CRStorageNotEmpty",
        CRDamaged = "CRDamaged",
        SuccessfullyRemove = "SuccessfullyRemove",
        CloseMenu = "CloseMenu",
        UpgradeTitle = "UpgradeTitle",
        RemoveTitle = "RemoveTitle",
        UpgradeCanThrough = "UpgradeCanThrough",
        RemoveCanThrough = "RemoveCanThrough",
        NoPermission = "NoPermission",
        SuccessfullyUpgrade = "SuccessfullyUpgrade",
        NoCupboard = "NoCupboard",
        CupboardRequired = "CupboardRequired",
        RemoveRaidBlocked = "RemoveRaidBlocked",
        UpgradeRaidBlocked = "UpgradeRaidBlocked",
        BuildingBlocked = "BuildingBlocked",
        CantUpgrade = "CantUpgrade",
        CantRemove = "CantRemove",
        NotEnoughResources = "NotEnoughResources";

    protected override void LoadDefaultMessages()
    {
        lang.RegisterMessages(new Dictionary<string, string>
        {
            [NotEnoughResources] = "Not enough resources to upgrade!",
            [CantRemove] = "You can remove this entity.",
            [CantUpgrade] = "You cannot upgrade this entity.",
            [BuildingBlocked] = "You are building blocked",
            [UpgradeRaidBlocked] = "You cannot upgrade buildings <color=#81B67A>during a raid!</color>!",
            [RemoveRaidBlocked] = "You cannot upgrade or remove <color=#81B67A>during a raid!</color>!",
            [CupboardRequired] = "A Cupboard is required!",
            [NoCupboard] = "No cupboard found!",
            [SuccessfullyUpgrade] = "You have successfully upgraded a building",
            [NoPermission] = "Нету такого типа улучшение!",
            [UpgradeCanThrough] = "You can upgrade the building in: {0}s",
            [RemoveCanThrough] = "You can remove the building in: {0}s",
            [RemoveTitle] = "Remove in <color=white>{0}s</color>",
            [UpgradeTitle] = "Upgrade to {0} <color=white>{1}s</color>",
            [CloseMenu] = "✕",
            [SuccessfullyRemove] = "You have successfully removed a building",
            [CRDamaged] = "Can't remove: Server has disabled damaged objects from being removed.",
            [CRStorageNotEmpty] = "Can't remove: The entity storage is not empty.",
            [CRBeBlocked] = "Can't remove: An external plugin blocked the usage.",
            [CRBuildingBlock] = "Can't remove: Missing cupboard",
            [CRNotAccess] = "Can't remove: You don't have any rights to remove this.",
            ["Wood"] = "wood",
            ["Stone"] = "stone",
            ["Metal"] = "metal",
            ["TopTier"] = "HQM"
        }, this);
    }

    private string Msg(string key, string userid = null, params object[] obj)
    {
        return string.Format(lang.GetMessage(key, this, userid), obj);
    }

    private string Msg(BasePlayer player, string key, params object[] obj)
    {
        return string.Format(lang.GetMessage(key, this, player.UserIDString), obj);
    }

    private void Reply(BasePlayer player, string key, params object[] obj)
    {
        player.ChatMessage(Msg(player, key, obj));
    }

    private void SendNotify(BasePlayer player, string key, int type, params object[] obj)
    {
        if (_config.UseNotify && (Notify != null || UINotify != null))
            Interface.Oxide.CallHook("SendNotify", player, type, Msg(player, key, obj));
        else
            Reply(player, key, obj);
    }

    #endregion
    
    bool loaded = false;
    
    IEnumerator StoreImages()
    {
        foreach (var img in UPRemoveImages)
        {
            yield return m_FileManager.LoadFile( img.Key, img.Value );
        }
        
        var keys = UPRemoveImages.Keys.ToList();
        foreach (string t in keys)
        {
            UPRemoveImages[t] = m_FileManager.GetPng( t );
        }
        PrintWarning($"Картинки загружены: {string.Join(", ", UPRemoveImages.Values.ToArray())}");
        loaded = true;
    }
    
    private GameObject FileManagerObject;
    private FileManager m_FileManager;
    
    void InitFileManager()
    {
        FileManagerObject = new GameObject( "MAP_FileManagerObject" );
        m_FileManager = FileManagerObject.AddComponent<FileManager>();
    }
    class FileManager : MonoBehaviour
    {
        int loaded = 0;
        int needed = 0;

        public bool IsFinished => needed == loaded;
        const ulong MaxActiveLoads = 10;
        Dictionary<string, FileInfo> files = new Dictionary<string, FileInfo>();

        DynamicConfigFile dataFile = Interface.Oxide.DataFileSystem.GetFile( "UPRemove" );

        private class FileInfo
        {
            public string Url;
            public string Png;
        }

        public void SaveData()
        {
            dataFile.WriteObject( files );
        }

        public string GetPng( string name ) => files[ name ].Png;

        private void Awake()
        {
            files = dataFile.ReadObject<Dictionary<string, FileInfo>>() ?? new Dictionary<string, FileInfo>();
        }

        public IEnumerator LoadFile( string name, string url, int size = -1 )
        {
            if (files.ContainsKey( name ) && files[ name ].Url == url && !string.IsNullOrEmpty( files[ name ].Png )) yield break;
            files[ name ] = new FileInfo() { Url = url };
            needed++;
            yield return StartCoroutine( LoadImageCoroutine( name, url, size ) );
        }

        IEnumerator LoadImageCoroutine( string name, string url, int size = -1 )
        {
            using (WWW www = new WWW( url ))
            {
                yield return www;
                using (MemoryStream stream = new MemoryStream())
                {
                    if (string.IsNullOrEmpty( www.error ))
                    {
                        stream.Position = 0;
                        stream.SetLength( 0 );
                        var bytes = size == -1 ? www.bytes : Resize( www.bytes, size );
                        stream.Write( bytes, 0, bytes.Length );

                        var entityId = CommunityEntity.ServerInstance.net.ID;
                        var crc32 = FileStorage.server.Store(bytes, FileStorage.Type.png, entityId ).ToString();
                        files[ name ].Png = crc32;
                    }
                }
            }
            loaded++;
        }

        static byte[] Resize( byte[] bytes, int size )
        {
            Image img = (Bitmap) ( new ImageConverter().ConvertFrom( bytes ) );
            Bitmap cutPiece = new Bitmap( size, size );
            System.Drawing.Graphics graphic = System.Drawing.Graphics.FromImage( cutPiece );
            graphic.DrawImage( img, new Rectangle( 0, 0, size, size ), 0, 0, img.Width, img.Height, GraphicsUnit.Pixel );
            graphic.Dispose();
            MemoryStream ms = new MemoryStream();
            cutPiece.Save( ms, ImageFormat.Jpeg );
            return ms.ToArray();
        }
    }
}
}

// --- End of file: UPRemove.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/UraniumTools.cs ---
// --- Original Local Path: UraniumTools.cs ---

using ConVar;
using System.Collections.Generic;
using System;
using UnityEngine;
using System.Linq;
using Oxide.Core.Plugins;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("UraniumTools", "BlackPlugin.ru", "1.2.1")]
    [Description("Урановые инструменты,добывают сразу готовые ресурсы с возможностью увеличения выпадения,нанося урон радиацией")]
    class UraniumTools : RustPlugin
    {

        
                void OnLoseCondition(Item item, ref float amount)
        {
            if (item == null)
                return;
            var itemCheck = config.UraniumTools.FirstOrDefault(x => x.Value.SkinID == item.skin && x.Value.NotBreaksUse == true).Value;
            if (itemCheck != null)
                amount = 0;
        }

                [PluginReference] Plugin IQChat;
		   		 		  						  	   		  		 			   					  	   		   			
        private Boolean IsRandom(Single Chance) => Chance >= Oxide.Core.Random.Range(0, 100);

        void OnServerInitialized()
        {
            MutationRegistered();
            ReadData();
            WriteData();
        }
        private void ItemSpawnTools(BaseNetworkable entity, LootContainer Container)
        {
            foreach (KeyValuePair<String, Configuration.Tools> configUraniumTool in config.UraniumTools.Where(configUraniumTool => configUraniumTool.Value.UseDroppingItem).Where(configUraniumTool => configUraniumTool.Value.DroppingItems.ContainsKey(entity.ShortPrefabName)))
            {
                if (!IsRandom(configUraniumTool.Value.DroppingItems[entity.ShortPrefabName])) return;

                    Item item = ItemManager.CreateByName(configUraniumTool.Value.Shortname, 1,
                        configUraniumTool.Value.SkinID);
                item.name = configUraniumTool.Value.Name;

                item?.MoveToContainer(Container.inventory);
            }
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewConfiguration();
        void MutationRegistered()
        {
            Transmutations = ItemManager.GetItemDefinitions().Where(p => MutationItemList.Contains(p.shortname)).ToDictionary(p => p, p => p.GetComponent<ItemModCookable>()?.becomeOnCooked);
            ItemDefinition wood = ItemManager.FindItemDefinition(-151838493);
            ItemDefinition charcoal = ItemManager.FindItemDefinition(-1938052175);
            Transmutations.Add(wood, charcoal);
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();

                foreach (KeyValuePair<String, Configuration.Tools> configUraniumTool in config.UraniumTools)
                {
                    if (configUraniumTool.Value.DroppingItems == null ||
                        configUraniumTool.Value.DroppingItems.Count == 0)
                        configUraniumTool.Value.DroppingItems = new Dictionary<String, Int32>()
                            { ["crate_elite"] = 100 };
                }
                
                NextTick(SaveConfig);
            }
            catch
            {
                PrintWarning(LanguageEn ? "Error #6421" + $"reading config 'oxide/config/{Name}', creating a new config!!" : "Ошибка #6421" + $"чтения конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!!");
                LoadDefaultConfig();
            }
        }

        
                [JsonProperty(LanguageEn ? "Date with players tools" : "Дата с инструментами игроков")] public List<uint> ItemListBlocked = new List<uint>();
		   		 		  						  	   		  		 			   					  	   		   			
        public void SendChat(string Message, BasePlayer player, Chat.ChatChannel channel = Chat.ChatChannel.Global)
        {
            if (IQChat)
                IQChat?.Call("API_ALERT_PLAYER", player, Message, config.PrefixChat);
            else player.SendConsoleCommand("chat.add", channel, 0, Message);
        }
        private void ItemSpawnController(BaseNetworkable entity)
        {
            LootContainer Container = entity.GetComponent<LootContainer>();
            if (Container == null) return;
            if (Container.inventory.IsFull()) return;

            ItemSpawnTools(entity, Container);
        }
        /// <summary>
        /// Обновленеи 1.2.1
        /// - Добавлена возможность выпадения предметов из ящиков (настраивается в конфигурации)
        /// /// </summary>
        /// 
        private const Boolean LanguageEn = false;
        object OnItemRepair(BasePlayer player, Item item)
        {
            if (item == null) return null;
            if (player == null) return null;
            if (ItemListBlocked.Contains(item.uid))
            {
                SendChat("Данный предмет не подлежит починке!", player);
                return false;
            }
		   		 		  						  	   		  		 			   					  	   		   			
            foreach(KeyValuePair<String, Configuration.Tools> Tool in config.UraniumTools.Where(x => x.Value.SkinID == item.skin && x.Value.Shortname == item.info.shortname))
            {
                if (config.NoRepair)
                {
                    SendChat("Данный предмет не подлежит починке!", player);
                    return false;
                }
                if (config.RepairUse)
                    ItemListBlocked.Add(item.uid);
            }
		   		 		  						  	   		  		 			   					  	   		   			
            return null;
        }
        void OnDispenserBonus(ResourceDispenser disp, BasePlayer player, Item item)
        {
            Item weapon = player?.GetActiveItem();
            if (weapon == null) return;
            UseTools(item, player, weapon.info.shortname, weapon.skin);
        }
        protected override void SaveConfig() => Config.WriteObject(config);
        public List<string> MutationItemList = new List<string>
        {
            "chicken.raw",
            "humanmeat.raw",
            "bearmeat",
            "deermeat.raw",
            "meat.boar",
            "wolfmeat.raw",
            "hq.metal.ore",
            "metal.ore",
            "sulfur.ore"
        };

        
                [ConsoleCommand("ut_give")]
        void UraniumToolGive(ConsoleSystem.Arg arg)
        {
            if (arg.Player() != null && !arg.Player().IsAdmin) return;

            BasePlayer basePlayer = BasePlayer.Find(arg.Args[0]);
            if(basePlayer == null)
            {
                if (arg.Player() != null)
                    PrintToConsole(LanguageEn ? "Player not found" : "Игрок не найден");
                else PrintWarning(LanguageEn ? "Player not found" : "");
                return;
            }
            String Key = arg.Args[1];
            if (!config.UraniumTools.ContainsKey(Key))
            {
                if(arg.Player() != null)
                    PrintToConsole(LanguageEn ? $"Could not find tool with given key - {Key}" : $"Не удалось найти инструмент с данным ключем - {Key}");
                else PrintWarning(LanguageEn ? $"Could not find tool with given key - {Key}" : $"Не удалось найти инструмент с данным ключем - {Key}");
                return;
            }
            CreateItem(basePlayer, Key);
        }
        void ReadData()
        {
            try { ItemListBlocked = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<List<uint>>("UraniumTools/ItemListBlocked"); }
            catch { PrintWarning(LanguageEn ? "Error #1" + $"reading datafile" : "Ошибка #1" + $"чтения датафайла"); }
        }

        bool CanRecycle(Recycler recycler, Item item)
        {
            foreach (KeyValuePair<String, Configuration.Tools> Tool in config.UraniumTools.Where(x => x.Value.SkinID == item.skin && x.Value.Shortname == item.info.shortname))
            {
                if (config.NoRecycle)
                    return false;
            }
            return true;
        }
        
                void OnEntitySpawned(BaseNetworkable entity) => ItemSpawnController(entity);

        void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            if (dispenser == null || entity == null || item == null) return;
            BasePlayer player = entity.ToPlayer();
            if (player == null) return;
            Item weapon = player?.GetActiveItem();
            if (weapon == null) return;
            UseTools(item, player, weapon.info.shortname, weapon.skin);
        }
        
                public enum DebuffType
        {
            Radiation,
            Cold,
            Blood,
            Health,
            Calories,
            Hydration,
        }
        void WriteData()
        {
            if (!config.RepairUse) return;
            timer.Every(60f, () => {
                Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("UraniumTools/ItemListBlocked", ItemListBlocked);
            });
        }
        
        void UseTools(Item item, BasePlayer player, string Shortname, ulong SkinID)
        {
            foreach (KeyValuePair<String, Configuration.Tools> Tool in config.UraniumTools.Where(x => x.Value.SkinID == SkinID && x.Value.Shortname == Shortname))
            {
                if (Tool.Value.MutationUse && Transmutations.ContainsKey(item.info))
                    item.info = Transmutations[item.info];

                if (Tool.Value.RateGatherUse)
                    item.amount = (int)(item.amount * Tool.Value.RateGather * 1);

                if(Tool.Value.DebuffVarible.UseDebuff)
                    foreach(Configuration.Tools.Debuff.DebuffSetting Debuffing in Tool.Value.DebuffVarible.debuffSetting)
                        switch (Debuffing.TypesDebuff)
                        {
                            case DebuffType.Radiation:
                                player.metabolism.radiation_poison.value += Debuffing.DebuffRate;
                                break;
                            case DebuffType.Cold:
                                player.metabolism.temperature.value -= Debuffing.DebuffRate;
                                break;
                            case DebuffType.Blood:
                                player.metabolism.bleeding.value += Debuffing.DebuffRate;
                                break;
                            case DebuffType.Health:
                                player.health -= Debuffing.DebuffRate;
                                break;
                            case DebuffType.Calories:
                                player.metabolism.calories.value -= Debuffing.DebuffRate;
                                break;
                            case DebuffType.Hydration:
                                player.metabolism.hydration.value -= Debuffing.DebuffRate;
                                break;
                            default:
                                break;
                        }

            }
        }
        
        
        private static Configuration config = new Configuration();

        void CreateItem(BasePlayer player, string Key)
        {
            Configuration.Tools UraniumTool = config.UraniumTools[Key];
            Item item = ItemManager.CreateByName(UraniumTool.Shortname, 1, UraniumTool.SkinID);
            item.name = UraniumTool.Name;

            player.GiveItem(item);
        }

                private Dictionary<ItemDefinition, ItemDefinition> Transmutations;
        private class Configuration
        {

            public static Configuration GetNewConfiguration()
            {
                return new Configuration
                {
                    RepairUse = true,
                    NoRepair = true,
                    PrefixChat = LanguageEn ? "<color=#0000FFF><b>[UraniumTools]</b></color>" : "<color=#000FFF><b>[Урановые Инструменты]</b></color>", ///
                    UraniumTools = new Dictionary<String, Tools>
                    {
                       ["uranpickaxe"] = new Tools
                        {
                            Shortname = "pickaxe",
                            Name = LanguageEn ? "Uranium Pickaxe" : "Урановая кирка",
                            SkinID = 859006499,
                            NotBreaksUse = false,
                            MutationUse = true,
                            RateGatherUse = true,
                            RateGather = 2,
                            UseDroppingItem = true,
                            DroppingItems = new Dictionary<String, Int32>()
                            {
                                ["crate_elite"] = 100,
                                ["crate_normal"] = 50,
                            },
                            DebuffVarible = new Tools.Debuff
                            {
                                UseDebuff = true,
                                debuffSetting = new List<Tools.Debuff.DebuffSetting>
                                {
                                    new Tools.Debuff.DebuffSetting
                                    {
                                        DebuffRate = 5,
                                        TypesDebuff = DebuffType.Radiation,
                                    },
                                }
                            }
                        },
                        ["uranphatchet"] = new Tools
                        {
                            Shortname = "hatchet",
                            Name = LanguageEn ? "Uranium Hatchet" : "Урановый топор",
                            SkinID = 860588662,
                            NotBreaksUse = false,
                            MutationUse = false,
                            RateGatherUse = true,
                            RateGather = 5,
                            UseDroppingItem = false,
                            DroppingItems = new Dictionary<String, Int32>()
                            {
                                ["crate_elite"] = 100,
                                ["crate_normal"] = 50,
                            },
                            DebuffVarible = new Tools.Debuff
                            {
                                UseDebuff = true,
                                debuffSetting = new List<Tools.Debuff.DebuffSetting>
                                {
                                    new Tools.Debuff.DebuffSetting
                                    {
                                        DebuffRate = 5,
                                        TypesDebuff = DebuffType.Radiation,
                                    },
                                }
                            }
                        },
                        ["coldpickaxe"] = new Tools
                        {
                            Shortname = "hatchet",
                            Name = LanguageEn ? "Cold Hatchet" : "Леядной топор",
                            SkinID = 1962047190,
                            NotBreaksUse = false,
                            MutationUse = false,
                            RateGatherUse = true,
                            RateGather = 5,
                            UseDroppingItem = false,
                            DroppingItems = new Dictionary<String, Int32>()
                            {
                                ["crate_elite"] = 100,
                                ["crate_normal"] = 50,
                            },
                            DebuffVarible = new Tools.Debuff
                            {
                                UseDebuff = true,
                                debuffSetting = new List<Tools.Debuff.DebuffSetting>
                                {
                                    new Tools.Debuff.DebuffSetting
                                    {
                                        DebuffRate = 5,
                                        TypesDebuff = DebuffType.Cold,
                                    },
                                }
                            }
                        },
                        ["multiaxe"] = new Tools
                        {
                            Shortname = "pickaxe",
                            Name = LanguageEn ? "Multi Pickaxe" : "Мульти-кирка",
                            SkinID = 2576194411,
                            NotBreaksUse = true,
                            MutationUse = true,
                            RateGatherUse = true,
                            RateGather = 15,
                            UseDroppingItem = false,
                            DroppingItems = new Dictionary<String, Int32>()
                            {
                                ["crate_elite"] = 100,
                                ["crate_normal"] = 50,
                            },
                            DebuffVarible = new Tools.Debuff
                            {
                                UseDebuff = true,
                                debuffSetting = new List<Tools.Debuff.DebuffSetting>
                                {
                                    new Tools.Debuff.DebuffSetting
                                    {
                                        DebuffRate = 5,
                                        TypesDebuff = DebuffType.Cold,
                                    },
                                    new Tools.Debuff.DebuffSetting
                                    {
                                        DebuffRate = 5,
                                        TypesDebuff = DebuffType.Radiation,
                                    },
                                    new Tools.Debuff.DebuffSetting
                                    {
                                        DebuffRate = 5,
                                        TypesDebuff = DebuffType.Calories,
                                    },
                                    new Tools.Debuff.DebuffSetting
                                    {
                                        DebuffRate = 5,
                                        TypesDebuff = DebuffType.Hydration,
                                    },
                                    new Tools.Debuff.DebuffSetting
                                    {
                                        DebuffRate = 5,
                                        TypesDebuff = DebuffType.Blood,
                                    },
                                    new Tools.Debuff.DebuffSetting
                                    {
                                        DebuffRate = 5,
                                        TypesDebuff = DebuffType.Health,
                                    },
                                }
                            }
                        },
                    }
                };
            }
            [JsonProperty( LanguageEn ? "Prefix in chat for message(IQChat)" : "Префикс в чате для сообщения(IQChat)")]
            public string PrefixChat;
            [JsonProperty( LanguageEn ? "Setting up uranium instruments (KEY (must be unique) - SETTING)" : "Настройка урановых инструментов (КЛЮЧ(должен быть уникальный) - НАСТРОЙКА)")]
            public Dictionary<String, Tools> UraniumTools = new Dictionary<String,Tools>();
            [JsonProperty( LanguageEn ? "Disable Item Recycling" : "Запретить переработку предмета")]
            public bool NoRecycle;
            [JsonProperty( LanguageEn ? "Enable one-time tool repair" : "Включить единоразовую починку инструментов")]
            public bool RepairUse;
            internal class Tools
            {
                [JsonProperty( LanguageEn ? "Crate Name = Rare" : "Название ящика = шанс")]
                public Dictionary<String, Int32> DroppingItems = new Dictionary<String, Int32>();

                [JsonProperty( LanguageEn ? "Enable item dropout from boxes" : "Включить выпадение предмета из ящиков")]
                public Boolean UseDroppingItem;
                [JsonProperty( LanguageEn ? "Display name" : "Название инструмента")]
                public string Name;
                [JsonProperty( LanguageEn ? "Tool SkinID" : "SkinID инструмента")]
                public ulong SkinID;
                internal class Debuff
                {
                    internal class DebuffSetting
                    {
                        [JsonProperty( LanguageEn ? "Factor" : "Множитель")]
                        public Single DebuffRate;
                        [JsonProperty( LanguageEn ? "Set the type of debuff on hit: 0 - Radiation, 1 - Cold, 2 - Bleeding, 3 - HP Drain, 4 - Calories, 5 - Hydration" : "Установите тип дебаффа при ударе : 0 - Радиация, 1 - Холод, 2 - Кровотечение, 3 - Снятие ХП, 4 - Калории, 5 - Жажда")]
                        public DebuffType TypesDebuff;
                    }
                    [JsonProperty( LanguageEn ? "Use debuff on hit? (true - yes/false - no)" : "Использовать дебафф при ударе? (true - да/false - нет)")]
                    public Boolean UseDebuff;

                    [JsonProperty( LanguageEn ? "Specify what debuffs will be (you can combine them by specifying several types)" : "Укажите какие дебаффы будут (вы можете комбинировать их, указав несколько типов)")]
                    public List<DebuffSetting> debuffSetting = new List<DebuffSetting>();

                }
                [JsonProperty( LanguageEn ? "Disable item breakage ? (Item will not wear out)" : "Отключить поломку предмета ? (Предмет не будет изнашиваться)")]
                public bool NotBreaksUse;
                [JsonProperty( LanguageEn ? "Mutation (Will recycle resource when mined) [true/false]" : "Мутация (При добыче будет перерабатывать ресурс) [true/false]")]
                public bool MutationUse;
                [JsonProperty( LanguageEn ? "Shortname Tool" : "Shortname инструмента")]
                public string Shortname;

                public Debuff DebuffVarible = new Debuff();
                [JsonProperty( LanguageEn ? "Increase loot X times per hit" : "Увеличивать добычу в Х раз за удар")]
                public float RateGather;
                [JsonProperty( LanguageEn ? "Resource multiplication (When hit by a tool, it will increase production by X times) [true/false]" : "Умножение ресурсов (При ударе инструментом будет увеличивать добычу в Х раз) [true/false]")]
                public bool RateGatherUse;
            }
            [JsonProperty( LanguageEn ? "Forbid repair" : "Запретить починку")]
            public bool NoRepair;
        }

            }
}


// --- End of file: UraniumTools.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/NoteUI.cs ---
// --- Original Local Path: NoteUI.cs ---

using System;
using System.Globalization;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("NoteUI", "noname", "1.0.1")]
    public class NoteUI : RustPlugin
    {
        #region Variables

        [PluginReference] private Plugin ImageLibrary;
        string NoteUIHandler = "NoteUI_Main";

        #endregion

        #region Config

        public class DataConfig
        {
            [JsonProperty("Иконка на эффект 'Взрыва'")]
            public string explosioneffecticon;
            [JsonProperty("Иконка на эффект 'Информация'")]
            public string infoeffecticon;
            [JsonProperty("Иконка на эффект 'Заблокировано'")]
            public string lockeffecticon;
            [JsonProperty("Включить звук при получении уведомления? (false - нет)")]
            public bool usesounds;
            [JsonProperty("Время постепенного появления")]
            public float fadein;
            [JsonProperty("Время через которое оповещение будет удалено")]
            public int timetodelete;
        }

        public DataConfig cfg;
        protected override void LoadConfig()
        {
            base.LoadConfig();
            cfg = Config.ReadObject<DataConfig>();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(cfg);
        }

        protected override void LoadDefaultConfig()
        {
            cfg = new DataConfig()
            {
                explosioneffecticon = "https://i.imgur.com/EKlH8Hy.png",
                lockeffecticon = "https://i.imgur.com/ETrXVzq.png",
                infoeffecticon = "https://i.imgur.com/nCAejF7.png",
				usesounds = true,
                fadein = 0.4f,
                timetodelete = 5,
            };
        }

        #endregion

        #region HooksAndMethods

        [HookMethod("DrawExplosionNote")]
        public void DrawExplosionNote(BasePlayer player, string Text, string Description)
        {
            if (player == null || Text == null || Description == null) return;
            NoteUIAdd(player, "explosion", Text, Description);
        }

        [HookMethod("DrawLockNote")]
        public void DrawLockNote(BasePlayer player, string Name, string Description)
        {
            if (player == null || Name == null || Description == null) return;
            NoteUIAdd(player, "lock", Name, Description);
        }

        [HookMethod("DrawInfoNote")]
        public void DrawInfoNote(BasePlayer player, string Text)
        {
            if (player == null || Text == null) return;
            var Description = "";
            NoteUIAdd(player, "info", Text, Description);
        }

        void OnServerInitialized()
        {
            if (!plugins.Exists("ImageLibrary"))
            {
                PrintWarning("Плагин 'ImageLibrary' не загружен, дальнейшая работа плагина невозможна!");
                Unload();
                return;
            }
            ImageLibrary.Call("AddImage", cfg.explosioneffecticon, "explosion");
            ImageLibrary.Call("AddImage", cfg.lockeffecticon, "lock");
            ImageLibrary.Call("AddImage", cfg.infoeffecticon, "info");
        }

        void Unload()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, NoteUIHandler);
            }
        }

        private void NoteUIAdd(BasePlayer player, string Type, string Name, string Description)
        {
            if (player.IsReceivingSnapshot || player.IsSleeping()) return;
            var container = new CuiElementContainer();
            CuiHelper.DestroyUi(player, NoteUIHandler);
            switch (Type)
            {
                case "explosion":
                    container.Add(new CuiPanel
                    {
                        Image = { FadeIn = cfg.fadein, Color = HexToCuiColor("#d4a1d400") },
                        RectTransform = { AnchorMin = "0.3011301 0.8373263", AnchorMax = "0.6792551 0.9283854" },
                        CursorEnabled = false,
                    }, "Hud", NoteUIHandler);
                    container.Add(new CuiElement
                    {
                        Parent = NoteUIHandler,
                        Components =
                        {
                            new CuiRectTransformComponent { AnchorMin = "0.008419432 0.4477783", AnchorMax = "0.0580062 0.9277781" },
                        }
                    });
                    container.Add(new CuiElement
                    {
                        Parent = NoteUIHandler,
                        Components =
                        {
                            new CuiTextComponent { FadeIn = cfg.fadein, Text = "Уведомление", Align = TextAnchor.MiddleCenter, FontSize = 16, Font = "RobotoCondensed-bold.ttf" },
                            new CuiRectTransformComponent {AnchorMin = "0.0709796 0.705116", AnchorMax = "0.9800709 1.293351"},
                            new CuiOutlineComponent {Color = "0 0 0 0", Distance = "0.3 0.3"}
                        }
                    });
                    container.Add(new CuiElement
                    {
                        Parent = NoteUIHandler,
                        Components =
                        {
                            new CuiTextComponent { FadeIn = cfg.fadein, Text = Name, Align = TextAnchor.MiddleLeft, FontSize = 12, Font = "RobotoCondensed-regular.ttf" },
                            new CuiRectTransformComponent {AnchorMin = "0.07438016 0.4799993", AnchorMax = "0.8181818 0.8799993"},
							new CuiOutlineComponent {Color = "0 0 0 0", Distance = "0.3 0.3"}
                        }
                    });
                    container.Add(new CuiElement
                    {
                        Parent = NoteUIHandler,
                        Components =
                        {
                            new CuiTextComponent { FadeIn = cfg.fadein, Text = Description, Align = TextAnchor.MiddleLeft, FontSize = 14, Font = "RobotoCondensed-regular.ttf" },
                            new CuiRectTransformComponent {AnchorMin = "0.07644629 0.1399995", AnchorMax = "0.9896694 0.5399995"},
							new CuiOutlineComponent {Color = "0 0 0 1", Distance = "0.3 0.3"}
                        }
                    });
                    break;
                case "lock":
                    container.Add(new CuiPanel
                    {
                        Image = { FadeIn = cfg.fadein, Color = HexToCuiColor("#d4a1d400") },
                        RectTransform = { AnchorMin = "0.3011301 0.8373263", AnchorMax = "0.6792551 0.9283854" },
                        CursorEnabled = false,
                    }, "Hud", NoteUIHandler);
                    container.Add(new CuiElement
                    {
                        Parent = NoteUIHandler,
                        Components =
                        {
                            new CuiRectTransformComponent { AnchorMin = "0.008419432 0.4477783", AnchorMax = "0.0580062 0.9277781" },
                        }
                    });
                    container.Add(new CuiElement
                    {
                        Parent = NoteUIHandler,
                        Components =
                        {
                            new CuiTextComponent { FadeIn = cfg.fadein, Text = "Уведомление", Align = TextAnchor.MiddleCenter, FontSize = 16, Font = "RobotoCondensed-bold.ttf" },
                            new CuiRectTransformComponent {AnchorMin = "0.0709796 0.6009494", AnchorMax = "0.9829992 1.189184"},
                            new CuiOutlineComponent {Color = "0 0 0 0", Distance = "0.3 0.3"}
                        }
                    });
                    container.Add(new CuiElement
                    {
                        Parent = NoteUIHandler,
                        Components =
                        {
                            new CuiTextComponent { FadeIn = cfg.fadein, Text = Name, Align = TextAnchor.MiddleCenter, FontSize = 16, Font = "RobotoCondensed-regular.ttf" },
                            new CuiRectTransformComponent {AnchorMin = "0.07438016 0.4799993", AnchorMax = "0.8181818 0.8799993"},
							new CuiOutlineComponent {Color = "0 0 0 0", Distance = "0.3 0.3"}
                        }
                    });
                    container.Add(new CuiElement
                    {
                        Parent = NoteUIHandler,
                        Components =
                        {
                            new CuiTextComponent { FadeIn = cfg.fadein, Text = Description, Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "RobotoCondensed-regular.ttf" },
                            new CuiRectTransformComponent {AnchorMin = "0.07644629 0.1399995", AnchorMax = "0.9896694 0.5399995"},
							new CuiOutlineComponent {Color = "0 0 0 0", Distance = "0.3 0.3"}
                        }
                    });
                    break;
                case "info":
                    container.Add(new CuiPanel
                    {
                        Image = { FadeIn = cfg.fadein, Color = HexToCuiColor("#d4a1d400") },
                        RectTransform = { AnchorMin = "0.341142 0.8660589", AnchorMax = "0.636164 0.9132813" },
                        CursorEnabled = false,
                    }, "Hud", NoteUIHandler);
                    container.Add(new CuiElement
                    {
                        Parent = NoteUIHandler,
                        Components =
                        {
                            new CuiRectTransformComponent { AnchorMin = "0.01048555 0.1290863", AnchorMax = "0.06007232 0.8349687" },
                        }
                    });
                    container.Add(new CuiElement
                    {
                        Parent = NoteUIHandler,
                        Components =
                        {
                            new CuiTextComponent { FadeIn = cfg.fadein, Text = "Уведомление", Align = TextAnchor.MiddleCenter, FontSize = 16, Font = "RobotoCondensed-bold.ttf" },
                            new CuiRectTransformComponent {AnchorMin = "0.0709796 0.6009494", AnchorMax = "0.9829992 1.189184"},
                            new CuiOutlineComponent {Color = "0 0 0 0", Distance = "0.3 0.3"}
                        }
                    });
                    container.Add(new CuiElement
                    {
                        Parent = NoteUIHandler,
                        Components =
                        {
                            new CuiTextComponent { FadeIn = cfg.fadein, Text = Name, Align = TextAnchor.MiddleCenter, FontSize = 16, Font = "RobotoCondensed-regular.ttf" },
                            new CuiRectTransformComponent {AnchorMin = "0.07024754 0.1764701", AnchorMax = "0.9793388 0.7647049"},
							new CuiOutlineComponent {Color = "0 0 0 0", Distance = "0.3 0.3"}
                        }
                    });
                    break;
            }
            CuiHelper.AddUi(player, container);
			if (cfg.usesounds) Effect.server.Run("assets/bundled/prefabs/fx/notice/stack.world.fx.prefab", player, 0, Vector3.zero, Vector3.zero);
            timer.Once(cfg.timetodelete, () => CuiHelper.DestroyUi(player, NoteUIHandler));
        }

        #endregion

        #region Helpers

        private static string HexToCuiColor(string hex)
        {
            if (string.IsNullOrEmpty(hex)) hex = "#FFFFFFFF";
            var str = hex.Trim('#');
            if (str.Length == 6) str += "FF";
            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }
            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);
            Color color = new Color32(r, g, b, a);
            return $"{color.r:F2} {color.g:F2} {color.b:F2} {color.a:F2}";
        }

        #endregion
    }
}

// --- End of file: NoteUI.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/QuarryLevels.cs ---
// --- Original Local Path: QuarryLevels.cs ---

using UnityEngine;
using System.Linq;
using Oxide.Core.Plugins;
using System.Globalization;
using Oxide.Game.Rust.Cui;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("QuarryLevels", "Death", "1.0.3")]
    class QuarryLevels : RustPlugin
    {
        #region Declarations
        [PluginReference] Plugin ImageLibrary, Economics;

        const string perm = "quarrylevels.use";
        System.Random random = new System.Random();

        Dictionary<BasePlayer, MiningQuarry> ActiveGUI = new Dictionary<BasePlayer, MiningQuarry>();
        #endregion

        #region Hooks
        void OnServerInitialized()
        {
            LoadConfig();

            List<KeyValuePair<string, ulong>> imageList = new List<KeyValuePair<string, ulong>>
            {
                { new KeyValuePair<string, ulong>("mining.quarry", 0ul) },
                { new KeyValuePair<string, ulong>("mining.pumpjack", 0ul) },
                { new KeyValuePair<string, ulong>("stones", 0ul) },
                { new KeyValuePair<string, ulong>("sulfur.ore", 0ul) },
                { new KeyValuePair<string, ulong>("hq.metal.ore", 0ul) },
                { new KeyValuePair<string, ulong>("metal.ore", 0ul) },
                { new KeyValuePair<string, ulong>("crude.oil", 0ul) },
            };

            ImageLibrary.Call("LoadImageList", Title, imageList, null);
            permission.RegisterPermission(perm, this);

            foreach (var quarry in BaseNetworkable.serverEntities.OfType<MiningQuarry>())
            {
                if (quarry.OwnerID != 0)
                {
                    OnEntitySpawned(quarry);
                }
            }
        }

        void Unload()
        {
            foreach (var active in ActiveGUI)
            {
                CuiHelper.DestroyUi(active.Key, "upgradebutton");
                CuiHelper.DestroyUi(active.Key, "upgradeconfirm");
            }
        }

        object CanLootEntity(BasePlayer player, ResourceExtractorFuelStorage quarry)
        {
            if (!options.PlayerSettings.PreventUnauthorizedLooting)
            {
                return null;
            }

            Puts(quarry.GetParentEntity().OwnerID.ToString());

            if (player.userID != quarry.GetParentEntity().OwnerID && !player.IsBuildingAuthed())
            {
                return true;
            }

            return null;
        }

        void OnLootEntity(BasePlayer player, ResourceExtractorFuelStorage quarry)
        {
            if (quarry.OwnerID != player.userID && !player.IsBuildingAuthed() || !quarry.HasParent() || !permission.UserHasPermission(player.UserIDString, perm))
            {
                return;
            }

            if (!ActiveGUI.ContainsKey(player))
            {
                CreateGUI(player);
                ActiveGUI.Add(player, quarry.GetParentEntity().GetComponent<MiningQuarry>());
            }
        }

        void OnLootEntityEnd(BasePlayer player, ResourceExtractorFuelStorage quarry)
        {
            if (ActiveGUI.ContainsKey(player))
            {
                DestroyCUI(player);
            }
        }

        void OnEntityKill(MiningQuarry quarry)
        {
            if (quarry.OwnerID == 0 || quarry.ShortPrefabName.Equals("pumpjack-static"))
            {
                return;
            }

            List<ResourceDepositManager.ResourceDeposit.ResourceDepositEntry> Resources = new List<ResourceDepositManager.ResourceDeposit.ResourceDepositEntry>(quarry._linkedDeposit._resources);

            foreach (var res in Resources)
            {
                if (res.workNeeded == 4 || res.workNeeded == 50)
                {
                    quarry._linkedDeposit._resources.Remove(res);
                }
            }

            Resources.Clear();
        }

        void OnQuarryToggled(MiningQuarry quarry, BasePlayer player)
        {
            if (options.PlayerSettings.PreventUnauthorizedToggling && player.userID == quarry.OwnerID || !player.IsBuildingAuthed())
            {
                quarry.SetOn(!quarry.IsOn());
                return;
            }

            if (!HasFuel(quarry))
            {
                DirectMessage(player, "This machine requires fuel to operate.");
                quarry.SetOn(false);
            }
        }

        void OnQuarryConsumeFuel(MiningQuarry quarry, Item item)
        {
            if (quarry.OwnerID == 0)
            {
                return;
            }

            item.amount -= (int)item.parent.entityOwner.GetParentEntity().skinID - 1;

            if (item.amount > 0)
            {
                item.MarkDirty();
                return;
            }

            item.amount = 0;
            item.Remove(0f);
        }

        void OnEntitySpawned(MiningQuarry quarry)
        {
            quarry.fuelStoragePrefab.instance.GetComponent<StorageContainer>().OwnerID = quarry.OwnerID;
            quarry.hopperPrefab.instance.GetComponent<StorageContainer>().OwnerID = quarry.OwnerID;

            if (quarry.skinID == 0)
            {
                quarry.skinID = 1;
            }

            var level = (int)quarry.skinID;
            var container = quarry.hopperPrefab.instance.GetComponent<StorageContainer>();
            var pumpjack = quarry.ShortPrefabName.Contains("pumpjack");

            if (level != 1)
            {
                container.inventory.capacity = 16 + (5 * level);
                container.inventory.MarkDirty();

                quarry.workToAdd = (pumpjack ? 10 * level : 7.5f * level);
            }

            List<string> Resources = new List<string>();

            foreach (var res in quarry._linkedDeposit._resources)
            {
                Resources.Add(res.type.shortname);
            }

            if (pumpjack && !Resources.Contains("crude.oil"))
            {
                quarry._linkedDeposit.Add(ItemManager.FindItemDefinition("crude.oil"), 1f, 1000, 10f, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM, true);
            }

            if (level >= 3 && !Resources.Contains("metal.ore"))
            {
                quarry._linkedDeposit.Add(ItemManager.FindItemDefinition("metal.ore"), 1f, 1000, options.QuarryOptions.Metal_Production, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM, false);
            }

            if (level >= 4 && !Resources.Contains("sulfur.ore"))
            {
                quarry._linkedDeposit.Add(ItemManager.FindItemDefinition("sulfur.ore"), 1f, 1000, options.QuarryOptions.Sulfur_Production, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM, false);
            }

            if (level >= 5 && !Resources.Contains("hq.metal.ore"))
            {
                quarry._linkedDeposit.Add(ItemManager.FindItemDefinition("hq.metal.ore"), 1f, 1000, options.QuarryOptions.HQM_Production, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM, false);
            }

            Resources.Clear();
        }

        void OnResourceDepositCreatedWIP(ResourceDepositManager.ResourceDeposit resourceDeposit)
        {
            if (random.Next(0, 100) > options.SurveySettings.OilCraterChance)
            {
                return;
            }

            List<SurveyCrater> SurveyCraters = new List<SurveyCrater>();
            Vis.Entities<SurveyCrater>(resourceDeposit.origin, 10, SurveyCraters);

            if (SurveyCraters.Count == 0)
            {
                return;
            }

            var surveyCrater = SurveyCraters[0];

            if (surveyCrater == null)
            {
                return;
            }

            GameManager.server.CreateEntity("assets/prefabs/tools/surveycharge/survey_crater_oil.prefab", surveyCrater.transform.position, surveyCrater.transform.rotation)?.Spawn();
            surveyCrater.Kill();

            resourceDeposit._resources.Clear();
            resourceDeposit.Add(ItemManager.FindItemDefinition("crude.oil"), 1f, 1000, 10f, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM, true);
        }
        #endregion

        #region Functions
        bool HasFuel(MiningQuarry quarry)
        {
            var item = quarry.fuelStoragePrefab.instance.GetComponent<StorageContainer>().inventory.FindItemsByItemName("lowgradefuel");

            return item != null && item.amount >= (int)quarry.skinID;
        }

        bool CanAfford(BasePlayer player, bool pumpjack)
        {
            var item = player.inventory.containerMain.FindItemsByItemName(pumpjack ? "mining.pumpjack" : "mining.quarry");

            if (item == null)
            {
                item = player.inventory.containerBelt.FindItemsByItemName(pumpjack ? "mining.pumpjack" : "mining.quarry");
            }

            if (item == null || item.amount < 1)
            {
                return false;
            }

            if (item.skin != 0ul)
            {
                return false;
            }

            item.UseItem(1);
            return true;
        }

        void DirectMessage(BasePlayer player, string message)
        {
            player.SendConsoleCommand("chat.add", 0, "76561198070759528", message);
        }

        #region UI
        void CreateGUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "upgradebutton");

            CuiElementContainer u = UI.Container("upgradebutton", UI.Color("000000", 0), options.Button.ButtonBounds);
            UI.Button(ref u, "upgradebutton", UI.Color(options.Button.ButtonColor, options.Button.ButtonOpacity), $"<color={options.Button.ButtonFontColor}>Upgrade</color>", 10, new UI4(0, 0, 1, 1f), "ALSd01LASKDkaK2Qlasdka(1Kaklsdja2");

            CuiHelper.AddUi(player, u);
        }

        [ConsoleCommand("ALSd01LASKDkaK2Qlasdka(1Kaklsdja2")]
        void CreateConfirmation(ConsoleSystem.Arg arg)
        {
            CuiHelper.DestroyUi(arg.Player(), "upgradebutton");
            CuiHelper.DestroyUi(arg.Player(), "upgradeconfirm");

            var machine = ActiveGUI[arg.Player()];
            var baseMachine = machine.GetComponent<BaseEntity>();

            var pumpjack = baseMachine.ShortPrefabName.Contains("pumpjack");
            var capacity = machine.hopperPrefab.instance.GetComponent<StorageContainer>().inventory.capacity;

            var level = (int)baseMachine.skinID;

            CuiElementContainer u = UI.Container("upgradeconfirm", UI.Color(options.Panel.PanelColor, options.Panel.PanelOpacity), options.Panel.PanelBounds);

            UI.Label(ref u, "upgradeconfirm", $"<color={options.Panel.PanelFontColor}>{(pumpjack ? "Pumpjack Manager" : "Quarry Manager")}</color>", 13, new UI4(0, 0.8f, 1, 1f), TextAnchor.MiddleCenter);
            UI.Panel(ref u, "upgradeconfirm", UI.Color("000000", 0.6f), new UI4(0.43f, 0.76f, 0.57f, 0.84f));
            UI.Label_Lower(ref u, "upgradeconfirm", $"<color={options.Panel.PanelFontColor}>Level {level}/{(pumpjack ? options.QuarrySettings.PumpjackMaxLevel : options.QuarrySettings.QuarryMaxLevel)}</color>", 8, new UI4(0, 0.75f, 1, 0.85f), TextAnchor.MiddleCenter);

            UI.Label(ref u, "upgradeconfirm", $"<color={options.Panel.PanelFontColor}>Current Level</color>", 9, new UI4(0.17f, 0.63f, 1, 0.73f), TextAnchor.MiddleLeft);
            UI.Label_Lower(ref u, "upgradeconfirm", $"<color={options.Panel.PanelFontColor}>Production:\nProcess Rate:\nCapacity:\nFuel Consumption:</color>", 8, new UI4(0.1f, 0.34f, 1, 0.64f), TextAnchor.MiddleLeft);
            UI.Label(ref u, "upgradeconfirm", $"<color={options.Panel.PanelFontColor}>{machine.workToAdd}\n{machine.processRate}\n{capacity}\n{level}</color>", 8, new UI4(0.1f, 0.34f, 0.4f, 0.64f), TextAnchor.MiddleRight);

            UI.Panel(ref u, "upgradeconfirm", UI.Color("#e8ddd4", 0.4f), new UI4(0.501f, 0.21f, 0.501f, 0.66f));
            UI.Image(ref u, "upgradeconfirm", GetImage($"{(pumpjack ? "mining.pumpjack" : "mining.quarry")}", 0ul), new UI4(0.44f, 0.37f, 0.56f, 0.57f));

            UI.Button(ref u, "upgradeconfirm", UI.Color("FF0000", 0.55f), $"<color={options.Panel.PanelFontColor}>Cancel</color>", 9, new UI4(0.502f, 0f, 0.997f, 0.13f), "$19%(!*aslLKAK123(!@*AKJSK!(49128!(@#!@*#$%!");
            UI.Button(ref u, "upgradeconfirm", UI.Color($"{(level >= (pumpjack ? options.QuarrySettings.PumpjackMaxLevel : options.QuarrySettings.QuarryMaxLevel) ? "FF0000" : "008000")}", 0.55f), $"<color={options.Panel.PanelFontColor}>{(level >= (pumpjack ? options.QuarrySettings.PumpjackMaxLevel : options.QuarrySettings.QuarryMaxLevel) ? "Max Level" : "Upgrade")}</color>", 9, new UI4(0f, 0f, 0.499f, 0.13f), $"{(level >= (pumpjack ? options.QuarrySettings.PumpjackMaxLevel : options.QuarrySettings.QuarryMaxLevel) ? string.Empty : "gLx$_+!)@laKS4391LAKS1291@$(!RKQSMDIO!@@")}");

            if (level < (pumpjack ? options.QuarrySettings.PumpjackMaxLevel : options.QuarrySettings.QuarryMaxLevel))
            {
                UI.Label(ref u, "upgradeconfirm", $"<color=#e8ddd4>Next Level</color>", 9, new UI4(0f, 0.64f, 0.81f, 0.74f), TextAnchor.MiddleRight);
                UI.Label_Lower(ref u, "upgradeconfirm", $"<color=#e8ddd4>Production:\nProcess Rate:\nCapacity:\nFuel Consumption:</color>", 8, new UI4(0.6f, 0.34f, 1, 0.64f), TextAnchor.MiddleLeft);
                UI.Label(ref u, "upgradeconfirm", $"<color=#e8ddd4>{machine.workToAdd + (pumpjack ? 10f : 7.5f)}\n{machine.processRate}\n{capacity + 2}\n{level + 1}</color>", 8, new UI4(0.6f, 0.34f, 0.9f, 0.64f), TextAnchor.MiddleRight);
            }

            List<string> Resources = new List<string>();

            var offsetL = 0.1f;
            var offsetR = 0.16f;

            var offsetRL = 0.6f;
            var offsetRR = 0.66f;

            if (pumpjack)
            {
                UI.Image(ref u, "upgradeconfirm", GetImage("crude.oil", 0ul), new UI4(offsetL, 0.21f, offsetR, 0.35f));
                UI.Panel(ref u, "upgradeconfirm", UI.Color("000000", 0.6f), new UI4(offsetL, 0.16f, offsetR, 0.22f));
                UI.Label(ref u, "upgradeconfirm", $"<color=#e8ddd4>{level}</color>", 6, new UI4(offsetL, 0.14f, offsetR, 0.24f), TextAnchor.MiddleCenter);

                if (level != options.QuarrySettings.PumpjackMaxLevel)
                {
                    UI.Image(ref u, "upgradeconfirm", GetImage("crude.oil", 0ul), new UI4(offsetRL, 0.21f, offsetRR, 0.35f));
                    UI.Panel(ref u, "upgradeconfirm", UI.Color("000000", 0.6f), new UI4(offsetRL, 0.16f, offsetRR, 0.22f));
                    UI.Label(ref u, "upgradeconfirm", $"<color=#e8ddd4>{1 + level}</color>", 6, new UI4(offsetRL, 0.14f, offsetRR, 0.24f), TextAnchor.MiddleCenter);
                }
            }
            else
            {
                foreach (var res in machine._linkedDeposit._resources)
                {
                    UI.Image(ref u, "upgradeconfirm", GetImage(res.type.shortname, 0ul), new UI4(offsetL, 0.21f, offsetR, 0.35f));
                    UI.Panel(ref u, "upgradeconfirm", UI.Color("000000", 0.6f), new UI4(offsetL, 0.16f, offsetR, 0.22f));
                    UI.Label(ref u, "upgradeconfirm", $"<color=#e8ddd4>{(6 * (7.5f / res.workNeeded) * level).ToString("0.0")}</color>", 6, new UI4(offsetL, 0.14f, offsetR, 0.24f), TextAnchor.MiddleCenter);

                    offsetL += 0.07f;
                    offsetR += 0.07f;

                    if (level != options.QuarrySettings.QuarryMaxLevel)
                    {
                        UI.Image(ref u, "upgradeconfirm", GetImage(res.type.shortname, 0ul), new UI4(offsetRL, 0.21f, offsetRR, 0.35f));
                        UI.Panel(ref u, "upgradeconfirm", UI.Color("000000", 0.6f), new UI4(offsetRL, 0.16f, offsetRR, 0.22f));
                        UI.Label(ref u, "upgradeconfirm", $"<color=#e8ddd4>{(6 * (7.5f / res.workNeeded) * (level + 1)).ToString("0.0")}</color>", 6, new UI4(offsetRL, 0.14f, offsetRR, 0.24f), TextAnchor.MiddleCenter);

                        offsetRL += 0.07f;
                        offsetRR += 0.07f;
                    }

                    Resources.Add(res.type.shortname);
                }

                if (level >= 2 && !Resources.Contains("metal.ore"))
                {
                    UI.Image(ref u, "upgradeconfirm", GetImage("metal.ore", 0ul), new UI4(offsetRL, 0.21f, offsetRR, 0.35f));
                    UI.Panel(ref u, "upgradeconfirm", UI.Color("000000", 0.6f), new UI4(offsetRL, 0.16f, offsetRR, 0.22f));
                    UI.Label(ref u, "upgradeconfirm", $"<color=#e8ddd4>??</color>", 6, new UI4(offsetRL, 0.14f, offsetRR, 0.24f), TextAnchor.MiddleCenter);

                    offsetRL += 0.07f;
                    offsetRR += 0.07f;
                }

                if (level >= 3 && !Resources.Contains("sulfur.ore"))
                {
                    UI.Image(ref u, "upgradeconfirm", GetImage("sulfur.ore", 0ul), new UI4(offsetRL, 0.21f, offsetRR, 0.35f));
                    UI.Panel(ref u, "upgradeconfirm", UI.Color("000000", 0.6f), new UI4(offsetRL, 0.16f, offsetRR, 0.22f));
                    UI.Label(ref u, "upgradeconfirm", $"<color=#e8ddd4>??</color>", 6, new UI4(offsetRL, 0.14f, offsetRR, 0.24f), TextAnchor.MiddleCenter);

                    offsetRL += 0.07f;
                    offsetRR += 0.07f;
                }

                if (level >= 4 && !Resources.Contains("hq.metal.ore"))
                {
                    UI.Image(ref u, "upgradeconfirm", GetImage("hq.metal.ore", 0ul), new UI4(offsetRL, 0.21f, offsetRR, 0.35f));
                    UI.Panel(ref u, "upgradeconfirm", UI.Color("000000", 0.6f), new UI4(offsetRL, 0.16f, offsetRR, 0.22f));
                    UI.Label(ref u, "upgradeconfirm", $"<color=#e8ddd4>??</color>", 6, new UI4(offsetRL, 0.14f, offsetRR, 0.24f), TextAnchor.MiddleCenter);
                }
            }

            Resources.Clear();
            CuiHelper.AddUi(arg.Player(), u);
        }

        void DestroyCUI(BasePlayer player)
        {
            ActiveGUI.Remove(player);

            CuiHelper.DestroyUi(player, "upgradebutton");
            CuiHelper.DestroyUi(player, "upgradeconfirm");
        }
        #endregion

        #region Commands
        [ConsoleCommand("ql")]
        void ConfigCommand(ConsoleSystem.Arg arg)
        {
            if (arg.Player() != null || arg.Args == null)
            {
                return;
            }

            // Went ahead and used a switch to easily add more commands in the future.
            switch (arg.Args[0])
            {
                case "reload":
                    LoadConfig();
                    arg.ReplyWith("Config file has been reloaded.");
                    break;

                default:
                    arg.ReplyWith("Not a valid command.");
                    break;
            }
        }
        #endregion

        #region CallBacks
        [ConsoleCommand("$19%(!*aslLKAK123(!@*AKJSK!(49128!(@#!@*#$%!")]
        void CloseConfirm(ConsoleSystem.Arg arg)
        {
            CuiHelper.DestroyUi(arg.Player(), "upgradeconfirm");
            CreateGUI(arg.Player());
        }

        [ConsoleCommand("gLx$_+!)@laKS4391LAKS1291@$(!RKQSMDIO!@@")]
        void Upgrade(ConsoleSystem.Arg arg)
        {
            var machine = ActiveGUI[arg.Player()];
            var baseMachine = machine.GetComponent<BaseEntity>();

            List<string> Resources = new List<string>();
            var pumpjack = baseMachine.ShortPrefabName.Contains("pumpjack");

            if (Economics && options.QuarrySettings.EnableEconomics)
            {
                if (!Economics.Call<bool>("Withdraw", arg.Player().userID, options.QuarrySettings.EconomicsCost))
                {
                    DirectMessage(arg.Player(), $"You cannot afford this upgrade. Requires <color=#add8e6ff>{options.QuarrySettings.EconomicsCost} {options.QuarrySettings.EconomicsCurrency}</color>!");
                    return;
                }
            }
            else
            {
                if (!CanAfford(arg.Player(), pumpjack))
                {
                    DirectMessage(arg.Player(), $"You cannot afford this upgrade. Requires 1 <color=#add8e6ff>[{(pumpjack ? "Pumpjack" : "Mining Quarry")}]</color>!");
                    return;
                }
            }

            var output = machine.hopperPrefab.instance.GetComponent<StorageContainer>();
            var level = (int)baseMachine.skinID;

            baseMachine.skinID += 1;
            output.inventory.capacity += 5;
            machine.workToAdd += pumpjack ? 10f : 7.5f;

            foreach (var res in machine._linkedDeposit._resources)
            {
                Resources.Add(res.type.shortname);
            }

            if (level >= 3 && !Resources.Contains("metal.ore"))
            {
                machine._linkedDeposit.Add(ItemManager.FindItemDefinition("metal.ore"), 1f, 1000, options.QuarryOptions.Metal_Production, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM, false);
            }

            if (level >= 4 && !Resources.Contains("sulfur.ore"))
            {
                machine._linkedDeposit.Add(ItemManager.FindItemDefinition("sulfur.ore"), 1f, 1000, options.QuarryOptions.Sulfur_Production, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM, false);
            }

            if (level >= 5 && !Resources.Contains("hq.metal.ore"))
            {
                machine._linkedDeposit.Add(ItemManager.FindItemDefinition("hq.metal.ore"), 1f, 1000, options.QuarryOptions.HQM_Production, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM, false);
            }

            Effect.server.Run("assets/bundled/prefabs/fx/build/promote_metal.prefab", output.transform.position);
            Resources.Clear();

            if (output.IsOpen())
            {
                arg.Player().EndLooting();
                output.PlayerOpenLoot(arg.Player(), string.Empty, true);
                return;
            }

            CreateGUI(arg.Player());
            CuiHelper.DestroyUi(arg.Player(), "upgradeconfirm");
        }
        #endregion

        #region Config
        ConfigFile options;

        class ConfigFile
        {
            public SurveyConfig SurveySettings = new SurveyConfig();
            public PlayerConfig PlayerSettings = new PlayerConfig();
            public QuarryLevelOptions QuarrySettings = new QuarryLevelOptions();
            public QuarryProduction QuarryOptions = new QuarryProduction();
            public ButtonConfig Button = new ButtonConfig();
            public PanelConfig Panel = new PanelConfig();
        }

        class PlayerConfig
        {
            public bool PreventUnauthorizedToggling = false;
            public bool PreventUnauthorizedLooting = false;
        }

        class SurveyConfig
        {
            public bool EnableOilCraters = false;
            public int OilCraterChance = 10;
        }

        class QuarryLevelOptions
        {
            public int QuarryMaxLevel = 5;
            public int PumpjackMaxLevel = 5;
            public bool EnableEconomics = false;
            public double EconomicsCost = 5000;
            public string EconomicsCurrency = "credits";
        }

        class QuarryProduction
        {
            public float Metal_Production = 4f;
            public float Sulfur_Production = 4f;
            public float HQM_Production = 50f;
        }

        class ButtonConfig
        {
            public UI4 ButtonBounds = new UI4(0.648f, 0.115f, 0.72f, 0.143f);
            public string ButtonColor = "FFFFF3";
            public float ButtonOpacity = 0.160f;
            public string ButtonFontColor = "#f7ebe1";
        }

        class PanelConfig
        {
            public UI4 PanelBounds = new UI4(0.39f, 0.55f, 0.61f, 0.75f);
            public string PanelColor = "FFFFF3";
            public float PanelOpacity = 0.160f;
            public string PanelFontColor = "#e8ddd4";
        }

        void LoadDefaultConfig()
        {
            var config = new ConfigFile();

            SaveConfig(config);
        }

        void LoadConfig()
        {
            options = Config.ReadObject<ConfigFile>();
            SaveConfig(options);
        }

        void SaveConfig(ConfigFile config)
        {
            Config.WriteObject(config, true);
        }
        #endregion

        #region API
        private string GetImage(string imageName, ulong skinid)
        {
            object success = ImageLibrary.Call("GetImage", imageName, skinid);

            if (success is string)
            {
                return (string)success;
            }

            return string.Empty;
        }
        #endregion

        #region UI - Frame Work
        public static class UI
        {
            static public CuiElementContainer Container(string panel, string color, UI4 dimensions, bool useCursor = false, string parent = "Overlay")
            {
                CuiElementContainer container = new CuiElementContainer()
                {
                    {
                        new CuiPanel
                        {
                            Image = {Color = color},
                            RectTransform = {AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax()},
                            CursorEnabled = useCursor
                        },
                        new CuiElement().Parent = parent,
                        panel
                    }
                };
                return container;
            }

            static public void Panel(ref CuiElementContainer container, string panel, string color, UI4 dimensions, bool cursor = false)
            {
                container.Add(new CuiPanel
                {
                    Image = { Color = color },
                    RectTransform = { AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() },
                    CursorEnabled = cursor
                },
                panel);
            }

            static public void Label(ref CuiElementContainer container, string panel, string text, int size, UI4 dimensions, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiLabel
                {
                    Text = { FontSize = size, Align = align, Text = text },
                    RectTransform = { AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() }
                },
                panel);

            }

            static public void Label_Lower(ref CuiElementContainer container, string panel, string text, int size, UI4 dimensions, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiLabel
                {
                    Text = { FontSize = size, Align = align, Text = text, Font = "robotocondensed-regular.ttf" },
                    RectTransform = { AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() }
                },
                panel);

            }

            static public void Button(ref CuiElementContainer container, string panel, string color, string text, int size, UI4 dimensions, string command, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiButton
                {
                    Button = { Color = color, Command = command, FadeIn = 0f },
                    RectTransform = { AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() },
                    Text = { Text = text, FontSize = size, Align = align, Font = "robotocondensed-regular.ttf" }
                },
                panel);
            }

            static public void Image(ref CuiElementContainer container, string panel, string png, UI4 dimensions)
            {
                container.Add(new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = panel,
                    Components =
                    {
                        new CuiRawImageComponent {Png = png },
                        new CuiRectTransformComponent {AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() }
                    }
                });
            }

            public static string Color(string hexColor, float alpha)
            {
                if (hexColor.StartsWith("#"))
                    hexColor = hexColor.Substring(1);
                int red = int.Parse(hexColor.Substring(0, 2), NumberStyles.AllowHexSpecifier);
                int green = int.Parse(hexColor.Substring(2, 2), NumberStyles.AllowHexSpecifier);
                int blue = int.Parse(hexColor.Substring(4, 2), NumberStyles.AllowHexSpecifier);
                return $"{(double)red / 255} {(double)green / 255} {(double)blue / 255} {alpha}";
            }
        }
        public class UI4
        {
            public float xMin, yMin, xMax, yMax;
            public UI4(float xMin, float yMin, float xMax, float yMax)
            {
                this.xMin = xMin;
                this.yMin = yMin;
                this.xMax = xMax;
                this.yMax = yMax;
            }
            public string GetMin() => $"{xMin} {yMin}";
            public string GetMax() => $"{xMax} {yMax}";
        }
        #endregion

        #endregion
    }
}

// --- End of file: QuarryLevels.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BuildProtection.cs ---
// --- Original Local Path: BuildProtection.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("BuildProtection", "CASHR#6906", "1.0.1")]
    internal class BuildProtection : RustPlugin
    {
        #region Static

        [PluginReference] private Plugin ImageLibrary;
        private readonly Dictionary<BasePlayer, BuildingPrivlidge> TCList = new Dictionary<BasePlayer, BuildingPrivlidge>();
        private Configuration _config;

        #endregion

        #region Config

        private class Configuration
        {
            [JsonProperty(PropertyName = "The list of privileges (The name of the permission and the maximum percentage of protection)", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public readonly Dictionary<string, int> PermList = new Dictionary<string, int>
            {
                ["buildprotection.default"] = 30,
                ["buildprotection.vip"] = 35,
                ["buildprotection.medium"] = 40,
                ["buildprotection.harm"] = 45,
                ["buildprotection.diamond"] = 50
            };

            [JsonProperty(PropertyName = "The cost of 100% home protection", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public readonly List<ItemToProtect> PriceList = new List<ItemToProtect>
            {
                new ItemToProtect
                {
                    ShortName = "sulfur",
                    Amount = 45000,
                    skinID = 0,
                    displayName = "SULFUR",
                    Image = ""
                },
                new ItemToProtect
                {
                    ShortName = "metal.refined",
                    Amount = 3000,
                    skinID = 0,
                    displayName = "HQM",
                    Image = ""
                },
                new ItemToProtect
                {
                    ShortName = "metal.fragments",
                    Amount = 80000,
                    skinID = 0,
                    displayName = "METAL",
                    Image = ""
                },
                new ItemToProtect
                {
                    ShortName = "glue",
                    Amount = 250,
                    skinID = 0,
                    displayName = "DIAMOND",
                    Image = "https://i.imgur.com/2XQpFeh.png"
                }
            };

            [JsonProperty(PropertyName = "Setting the time (in hours) and multiplying the coefficients affecting the cost", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public readonly Dictionary<int, float> TimeList = new Dictionary<int, float>
            {
                [5] = 1,
                [6] = 1.2f,
                [7] = 1.4f,
                [8] = 1.5f
            };

            internal class ItemToProtect
            {
                [JsonProperty("Amount")] public int Amount;
                [JsonProperty("displayName in UI")] public string displayName;

                [JsonProperty("Picture to display in the UI (leave blank if the standard item)")]
                public string Image;

                [JsonProperty("SHORTNAME")] public string ShortName;
                [JsonProperty("SkinID")] public ulong skinID;
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
                SaveConfig();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }

        protected override void LoadDefaultConfig()
        {
            _config = new Configuration();
        }

        #endregion

        #region OxideHooks

        private int GetMaxProtection(string userID)
        {
            var protect = 0;
            foreach (var check in _config.PermList)
                if (permission.UserHasPermission(userID, check.Key))
                    protect = Math.Max(protect, check.Value);
            return protect;
        }

        private void OnServerInitialized()
        {
            LoadData();
            foreach (var check in _config.PermList) permission.RegisterPermission(check.Key, this);

            for (var index = 0; index < _config.PriceList.Count; index++)
            {
                var check = _config.PriceList[index];
                if (!string.IsNullOrEmpty(check.Image))
                    ImageLibrary.Call("AddImage", check.Image, check.Image);
            }

            PrintError("|-----------------------------------|");
            PrintWarning($"|  Plugin {Title} v{Version} is loaded  |");
            PrintWarning("|          Discord: CASHR#6906      |");
            PrintError("|-----------------------------------|");
        }

        private void Unload()
        {
            SaveData();
            foreach (var check in BasePlayer.activePlayerList) CuiHelper.DestroyUi(check, "Panel_5842");
        }

        #endregion

        #region Function

        private void OnEntityTakeDamage(BuildingBlock entity, HitInfo info)
        {
            if (entity == null || info == null) return;
            var priv = entity.GetBuildingPrivilege();
            if (priv == null) return;
            if (!_data.ContainsKey(priv.net.ID.Value)) return;
            var data = _data[priv.net.ID.Value];
            if (!data.IsProtect) return;
            if ((data.FinishProtection - DateTime.Now).TotalSeconds < 0)
            {
                data.IsProtect = false;
                return;
            }

            var protect = 1 - (float)data.Protection / 100;
            info.damageTypes.ScaleAll(protect);
            if (info.InitiatorPlayer != null)
            {
            }
        }

        private void OnEntityTakeDamage(DecayEntity entity, HitInfo info)
        {
            if (entity == null || info == null) return;
            var priv = entity.GetBuildingPrivilege();
            if (priv == null) return;
            if (!_data.ContainsKey(priv.net.ID.Value)) return;
            var data = _data[priv.net.ID.Value];
            if (!data.IsProtect) return;
            if ((data.FinishProtection - DateTime.Now).TotalSeconds < 0)
            {
                data.IsProtect = false;
                return;
            }

            var protect = 1 - (float)data.Protection / 100;
            info.damageTypes.ScaleAll(protect);
            if (info.InitiatorPlayer != null)
            {
            }
        }

        private void OnHammerHit(BasePlayer player, HitInfo info)
        {
            if (player == null || info == null || info.HitEntity == null) return;
            var entity = info.HitEntity;
            if (entity as BuildingPrivlidge)
            {
                if (TCList.ContainsKey(player))
                    TCList[player] = entity as BuildingPrivlidge;
                else
                    TCList.Add(player, entity as BuildingPrivlidge);

                if (_data.ContainsKey(entity.net.ID.Value) && _data[entity.net.ID.Value].IsProtect)
                {
                    var data = _data[entity.net.ID.Value];
                    if ((data.FinishProtection - DateTime.Now).TotalSeconds < 0)
                    {
                        data.IsProtect = false;
                        ShowUI(player);
                        return;
                    }

                    ShowProtectUI(player, _data[entity.net.ID.Value]);
                }
                else
                {
                    ShowUI(player);
                }
            }
        }

        #endregion

        #region UI

        private void Take(IEnumerable<Item> itemList, string shortname, ulong skinId, int iAmount)
        {
            var num1 = 0;
            if (iAmount == 0) return;

            var list = Pool.GetList<Item>();

            foreach (var item in itemList)
            {
                if (item.info.shortname != shortname ||
                    (skinId != 0 && item.skin != skinId)) continue;

                var num2 = iAmount - num1;
                if (num2 <= 0) continue;
                if (item.amount > num2)
                {
                    item.MarkDirty();
                    item.amount -= num2;
                    num1 += num2;
                    break;
                }

                if (item.amount <= num2)
                {
                    num1 += item.amount;
                    list.Add(item);
                }

                if (num1 == iAmount)
                    break;
            }

            foreach (var obj in list)
                obj.RemoveFromContainer();

            Pool.FreeList(ref list);
        }

        [ConsoleCommand("UI_BUILDPROTECTION")]
        private void cmdConsoleUI_BUILDPROTECTION(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            var procent = int.Parse(arg.Args[1]);
            var time = int.Parse(arg.Args[2]);
            switch (arg.Args[0])
            {
                case "PROTECT":
                {
                    ShowUI(player, procent, time);
                    break;
                }
                case "TIME":
                {
                    ShowUI(player, procent, time);
                    break;
                }
                case "SUCCESS":
                {
                    var tc = TCList[player];
                    foreach (var check in _config.PriceList) Take(player.inventory.AllItems(), check.ShortName, check.skinID, (int)(check.Amount * procent / 100 * _config.TimeList[time]));
                    if (_data.ContainsKey(tc.net.ID.Value))
                    {
                        var data = _data[tc.net.ID.Value];
                        data.Protection = procent;
                        data.FinishProtection = DateTime.Now.AddHours(time);
                        data.IsProtect = true;
                    }
                    else
                    {
                        _data.Add(tc.net.ID.Value, new Data
                        {
                            Protection = procent,
                            FinishProtection = DateTime.Now.AddHours(time),
                            IsProtect = true
                        });
                    }

                    player.ChatMessage(GetMessage("MSG_SUCCEFULL", player.UserIDString, procent, time));
                    break;
                }
            }
        }

        private void ShowProtectUI(BasePlayer player, Data data)
        {
            var container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                Image = { Color = "0.282353 0.282353 0.282353 1" },
                RectTransform =
                {
                    AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-205.77 -280.762",
                    OffsetMax = "204.835 271.887"
                }
            }, "Overlay", "Panel_5842");
            container.Add(new CuiElement
            {
                Name = "Label_1743",
                Parent = "Panel_5842",
                Components =
                {
                    new CuiTextComponent
                    {
                        Text = GetMessage("UI_HOMEISPROTECT", player.UserIDString), Font = "robotocondensed-bold.ttf", FontSize = 30,
                        Align = TextAnchor.MiddleCenter, Color = "0 0.5686275 1 1"
                    },
                    new CuiOutlineComponent { Color = "0 0 0 0.2117647", Distance = "1 -1" },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-161.364 134.819",
                        OffsetMax = "161.364 203.181"
                    }
                }
            });

            container.Add(new CuiButton
            {
                Button = { Color = "0.4235294 0.4235294 0.4235294 1" },
                Text =
                {
                    Text = GetMessage("UI_STATUS_HEADER", player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 28,
                    Align = TextAnchor.MiddleCenter, Color = "1 1 1 1"
                },
                RectTransform =
                {
                    AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-206.407 219.233",
                    OffsetMax = "205.133 276.327"
                }
            }, "Panel_5842", "Button_9962");

            container.Add(new CuiButton
            {
                Button = { Color = "0.9254903 0.2901961 0.2901961 1", Close = "Panel_5842" },
                Text =
                {
                    Text = "X", Font = "robotocondensed-bold.ttf", FontSize = 43, Align = TextAnchor.MiddleCenter,
                    Color = "0.5764706 0.1686275 0.1686275 1"
                },
                RectTransform =
                {
                    AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "148.77 -28.547",
                    OffsetMax = "205.77 28.453"
                }
            }, "Button_9962", "Button_8465");

            container.Add(new CuiButton
            {
                Button = { Color = "0 0.5686275 1 1", Close = "Panel_5842" },
                Text =
                {
                    Text = GetMessage("UI_STATUS_COMPLETE", player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 20,
                    Align = TextAnchor.MiddleCenter, Color = "1 1 1 1"
                },
                RectTransform =
                {
                    AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-176.654 -265.209",
                    OffsetMax = "179.926 -223.938"
                }
            }, "Panel_5842", "Button_7334");

            container.Add(new CuiButton
            {
                Button = { Color = "0.1960784 0.5686275 0.7372549 1" },
                Text =
                {
                    Text = $"{data.Protection}%", Font = "robotocondensed-bold.ttf", FontSize = 40, Align = TextAnchor.MiddleCenter,
                    Color = "1 1 1 1"
                },
                RectTransform =
                {
                    AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-161.363 17.265",
                    OffsetMax = "-17.071 79.301"
                }
            }, "Panel_5842", "Button_4254");
            Outline(ref container, "Button_4254", "0 0 0 1", "1.5");

            container.Add(new CuiElement
            {
                Name = "Label_545",
                Parent = "Button_4254",
                Components =
                {
                    new CuiTextComponent
                    {
                        Text = GetMessage("UI_PROTECTION_STATUS", player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 16,
                        Align = TextAnchor.MiddleCenter, Color = "1 1 1 1"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-72.144 34.509",
                        OffsetMax = "72.146 57.88"
                    }
                }
            });

            container.Add(new CuiButton
            {
                Button = { Color = "0.1960784 0.5686275 0.7372549 1" },
                Text =
                {
                    Text = $"{$"{(data.FinishProtection - DateTime.Now).TotalHours:F2}"}H", Font = "robotocondensed-bold.ttf", FontSize = 40, Align = TextAnchor.MiddleCenter,
                    Color = "1 1 1 1"
                },
                RectTransform =
                {
                    AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "17.071 17.265",
                    OffsetMax = "161.363 79.301"
                }
            }, "Panel_5842", "Button_4254 (1)");

            container.Add(new CuiElement
            {
                Name = "Label_545",
                Parent = "Button_4254 (1)",
                Components =
                {
                    new CuiTextComponent
                    {
                        Text = GetMessage("UI_TIME_STATUS", player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 16,
                        Align = TextAnchor.MiddleCenter, Color = "1 1 1 1"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-72.144 34.509",
                        OffsetMax = "72.146 57.88"
                    }
                }
            });
            Outline(ref container, "Button_4254 (1)", "0 0 0 1", "1.5");
            CuiHelper.DestroyUi(player, "Panel_5842");
            CuiHelper.AddUi(player, container);
        }

        private void ShowUI(BasePlayer player, int procent = 0, int time = 0)
        {
            if (time < _config.TimeList.First().Key || time > _config.TimeList.Last().Key) time = _config.TimeList.First().Key;

            var max = GetMaxProtection(player.UserIDString);
            if (procent <= 0 || procent > max) procent = max;
            var container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                Image = { Color = "0.282353 0.282353 0.282353 1" },
                RectTransform =
                {
                    AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-205.77 -280.762",
                    OffsetMax = "204.835 271.887"
                }
            }, "Overlay", "Panel_5842");

            container.Add(new CuiButton
            {
                Button = { Color = "0.4235294 0.4235294 0.4235294 1" },
                Text =
                {
                    Text = GetMessage("UI_SETUP_HEADER", player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 28,
                    Align = TextAnchor.MiddleCenter, Color = "1 1 1 1"
                },
                RectTransform =
                {
                    AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-206.407 219.233",
                    OffsetMax = "205.133 276.327"
                }
            }, "Panel_5842", "Button_9962");

            container.Add(new CuiButton
            {
                Button = { Color = "0.9254903 0.2901961 0.2901961 1", Close = "Panel_5842" },
                Text =
                {
                    Text = "X", Font = "robotocondensed-bold.ttf", FontSize = 43, Align = TextAnchor.MiddleCenter,
                    Color = "0.5764706 0.1686275 0.1686275 1"
                },
                RectTransform =
                {
                    AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "148.77 -28.547",
                    OffsetMax = "205.77 28.453"
                }
            }, "Button_9962", "Button_8465");

            container.Add(new CuiButton
            {
                Button = { Color = "0.3803922 0.4039216 0.4862745 1" },
                Text =
                {
                    Text = $"{procent}%", Font = "robotocondensed-bold.ttf", FontSize = 28, Align = TextAnchor.MiddleCenter,
                    Color = "1 1 1 1"
                },
                RectTransform =
                {
                    AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-178.026 140.498",
                    OffsetMax = "-48.174 190.703"
                }
            }, "Panel_5842", "protect");

            container.Add(new CuiElement
            {
                Name = "Label_3418",
                Parent = "protect",
                Components =
                {
                    new CuiTextComponent
                    {
                        Text = GetMessage("UI_PROTECTION_STATUS", player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 15,
                        Align = TextAnchor.MiddleCenter, Color = "1 1 1 1"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-64.924 25.102",
                        OffsetMax = "64.926 49.999"
                    }
                }
            });

            container.Add(new CuiButton
            {
                Button = { Color = "0.2392157 0.3372549 0.6705883 1", Command = $"UI_BUILDPROTECTION PROTECT {procent - 5} {time}" },
                Text =
                {
                    Text = "◄", Font = "robotocondensed-bold.ttf", FontSize = 30, Align = TextAnchor.MiddleCenter,
                    Color = "1 1 1 1"
                },
                RectTransform =
                    { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-62.9 -19", OffsetMax = "-24.9 19" }
            }, "protect", "Button_1555");

            container.Add(new CuiButton
            {
                Button = { Color = "0.1647059 0.5333334 0.7254902 1", Command = $"UI_BUILDPROTECTION PROTECT {procent + 5} {time}" },
                Text =
                {
                    Text = "►", Font = "robotocondensed-bold.ttf", FontSize = 30, Align = TextAnchor.MiddleCenter,
                    Color = "1 1 1 1"
                },
                RectTransform =
                    { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "24.9 -19", OffsetMax = "62.9 19" }
            }, "protect", "Button_1555 (1)");

            container.Add(new CuiButton
            {
                Button = { Color = "0.3803922 0.4039216 0.4862745 1" },
                Text =
                {
                    Text = $"{time}ч", Font = "robotocondensed-bold.ttf", FontSize = 28, Align = TextAnchor.MiddleCenter,
                    Color = "1 1 1 1"
                },
                RectTransform =
                {
                    AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "50.074 140.497",
                    OffsetMax = "179.926 190.703"
                }
            }, "Panel_5842", "timer");

            container.Add(new CuiElement
            {
                Name = "Label_3418",
                Parent = "timer",
                Components =
                {
                    new CuiTextComponent
                    {
                        Text = GetMessage("UI_TIME_STATUS", player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 15,
                        Align = TextAnchor.MiddleCenter, Color = "1 1 1 1"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-64.924 25.102",
                        OffsetMax = "64.926 49.999"
                    }
                }
            });

            container.Add(new CuiButton
            {
                Button = { Color = "0.2392157 0.3372549 0.6705883 1", Command = $"UI_BUILDPROTECTION TIME {procent} {time - 1}" },
                Text =
                {
                    Text = "◄", Font = "robotocondensed-bold.ttf", FontSize = 30, Align = TextAnchor.MiddleCenter,
                    Color = "1 1 1 1"
                },
                RectTransform =
                    { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-62.9 -19", OffsetMax = "-24.9 19" }
            }, "timer", "Button_1555");

            container.Add(new CuiButton
            {
                Button = { Color = "0.1647059 0.5333334 0.7254902 1", Command = $"UI_BUILDPROTECTION TIME {procent} {time + 1}" },
                Text =
                {
                    Text = "►", Font = "robotocondensed-bold.ttf", FontSize = 30, Align = TextAnchor.MiddleCenter,
                    Color = "1 1 1 1"
                },
                RectTransform =
                    { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "24.9 -19", OffsetMax = "62.9 19" }
            }, "timer", "Button_1555 (1)");

            container.Add(new CuiElement
            {
                Name = "Label_7832",
                Parent = "Panel_5842",
                Components =
                {
                    new CuiTextComponent
                    {
                        Text = GetMessage("UI_SETUP_PRICE", player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 14,
                        Align = TextAnchor.MiddleCenter, Color = "1 1 1 1"
                    },
                    new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-132.191 97.783",
                        OffsetMax = "132.191 131.417"
                    }
                }
            });

            container.Add(new CuiElement
            {
                Name = "Label_8774",
                Parent = "Panel_5842",
                Components =
                {
                    new CuiTextComponent
                    {
                        Text = GetMessage("UI_SETUP_NEED", player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 15,
                        Align = TextAnchor.MiddleCenter, Color = "0.572549 0.572549 0.572549 1"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "77.173 70.591",
                        OffsetMax = "179.928 97.782"
                    }
                }
            });
            var posy = 18.214;
            var height = 61.586 - posy;
            var i = 0;
            foreach (var check in _config.PriceList)
            {
                container.Add(new CuiButton
                {
                    Button = { Color = "0.4235294 0.4235294 0.4235294 1" },
                    Text =
                    {
                        Text = "  ", Font = "robotocondensed-regular.ttf", FontSize = 14,
                        Align = TextAnchor.MiddleCenter,
                        Color = "0 0 0 1"
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"-176.654 {posy}",
                        OffsetMax = $"179.926 {posy + height}"
                    }
                }, "Panel_5842", "Button_9555");
                var amount = ItemCount(player.inventory.AllItems(), check.ShortName, check.skinID);

                var status = amount >= check.Amount * procent / 100 * _config.TimeList[time];
                if (status)
                    i++;
                var color = status ? "1 1 1 1" : "1 0 0 1";
                Outline(ref container, "Button_9555", color, "1.5");
                var image = string.IsNullOrEmpty(check.Image) ? check.ShortName : check.Image;
                container.Add(new CuiElement
                {
                    Name = "Image_9604",
                    Parent = "Button_9555",
                    Components =
                    {
                        new CuiRawImageComponent
                            { Color = "1 1 1 1", Png = (string)ImageLibrary?.Call("GetImage", image) },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-180.683 -21.913",
                            OffsetMax = "-130.683 28.087"
                        }
                    }
                });

                container.Add(new CuiElement
                {
                    Name = "Label_1531",
                    Parent = "Button_9555",
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = check.displayName, Font = "robotocondensed-regular.ttf", FontSize = 30,
                            Align = TextAnchor.MiddleLeft, Color = "1 1 1 1"
                        },
                        new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-129.4 -21.686",
                            OffsetMax = "82.054 21.688"
                        }
                    }
                });

                container.Add(new CuiElement
                {
                    Name = "Label_3548",
                    Parent = "Button_9555",
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = $"{amount} / {(int)(check.Amount * procent / 100 * _config.TimeList[time])} ", Font = "robotocondensed-bold.ttf", FontSize = 20,
                            Align = TextAnchor.MiddleRight, Color = "1 1 1 1"
                        },
                        new CuiOutlineComponent { Color = "0 0 0 0.5", Distance = "1 -1" },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "38.29 -21.913",
                            OffsetMax = "178.29 21.688"
                        }
                    }
                });
                posy -= height + 5;
            }

            var cmd = i == _config.PriceList.Count ? $"UI_BUILDPROTECTION SUCCESS {procent} {time}" : "";
            // var cmd = $"UI_BUILDPROTECTION SUCCESS {procent} {time}";
            container.Add(new CuiButton
            {
                Button = { Color = "0 0.5686275 1 1", Command = cmd, Close = "Panel_5842" },
                Text =
                {
                    Text = GetMessage("UI_SETUP_FINISH", player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 20,
                    Align = TextAnchor.MiddleCenter, Color = "1 1 1 1"
                },
                RectTransform =
                {
                    AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-176.654 -265.209",
                    OffsetMax = "179.926 -223.938"
                }
            }, "Panel_5842", "Button_7334");

            CuiHelper.DestroyUi(player, "Panel_5842");
            CuiHelper.AddUi(player, container);
        }

        private static int ItemCount(IReadOnlyList<Item> items, string shortname, ulong skin)
        {
            var result = 0;

            for (var i = 0; i < items.Count; i++)
            {
                var item = items[i];
                if (item.info.shortname == shortname && (skin == 0 || item.skin == skin))
                    result += item.amount;
            }

            return result;
        }

        private void Outline(ref CuiElementContainer container, string parent, string color = "1 1 1 1",
            string size = "2.5")
        {
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0", OffsetMin = "0 0", OffsetMax = $"0 {size}" },
                Image = { Color = color }
            }, parent);
            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin = $"0 -{size}", OffsetMax = "0 0" },
                Image = { Color = color }
            }, parent);
            container.Add(new CuiPanel
            {
                RectTransform =
                    { AnchorMin = "0 0", AnchorMax = "0 1", OffsetMin = $"0 {size}", OffsetMax = $"{size} -{size}" },
                Image = { Color = color }
            }, parent);
            container.Add(new CuiPanel
            {
                RectTransform =
                    { AnchorMin = "1 0", AnchorMax = "1 1", OffsetMin = $"-{size} {size}", OffsetMax = $"0 -{size}" },
                Image = { Color = color }
            }, parent);
        }

        #endregion

        #region LANG

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["MSG_SUCCEFULL"] = "You have successfully installed {0}% home protection. It will be valid for {1} hours",
                ["UI_HOMEISPROTECT"] = "<size=25>YOUR HOME IS PROTECTED</size>",
                ["UI_STATUS_HEADER"] = "HOME PROTECTION STATUS       ",
                ["UI_STATUS_COMPLETE"] = "I SEE",
                ["UI_PROTECTION_STATUS"] = "PERCENTAGE OF PROTECTION",
                ["UI_TIME_STATUS"] = "PROTECTION CLOCK",
                ["UI_SETUP_HEADER"] = "<size=25>HOME SECURITY INSTALLATION </size>      ",
                ["UI_SETUP_PRICE"] = "RESOURCES TO PAY FOR PROTECTION",
                ["UI_SETUP_NEED"] = "NEED / HAVE",
                ["UI_SETUP_FINISH"] = "INSTALL PROTECTION"
            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["MSG_SUCCEFULL"] = "Вы успешно установили {0}% защиту дома. Она будет действовать {1} часов",
                ["UI_HOMEISPROTECT"] = "ВАШ ДОМ ЗАЩИЩЕН",
                ["UI_STATUS_HEADER"] = "СОСТОЯНИЕ ЗАЩИТЫ ДОМА          ",
                ["UI_STATUS_COMPLETE"] = "I SEE",
                ["UI_PROTECTION_STATUS"] = "ПРОЦЕНТ ЗАЩИТЫ",
                ["UI_TIME_STATUS"] = "ЧАСЫ ЗАЩИТЫ",
                ["UI_SETUP_HEADER"] = "УСТАНОВКА ЗАЩИТЫ ДОМА         ",
                ["UI_SETUP_PRICE"] = "РЕСУРСЫ ДЛЯ ОПЛАТЫ ЗАЩИТЫ",
                ["UI_SETUP_NEED"] = "НУЖНО / ЕСТЬ",
                ["UI_SETUP_FINISH"] = "УСТАНОВИТЬ ЗАЩИТУ"
            }, this, "ru");
        }

        private string GetMessage(string langKey, string steamID)
        {
            return lang.GetMessage(langKey, this, steamID);
        }

        private string GetMessage(string langKey, string steamID, params object[] args)
        {
            return args.Length == 0
                ? GetMessage(langKey, steamID)
                : string.Format(GetMessage(langKey, steamID), args);
        }

        #endregion

        #region Data

        private Dictionary<ulong, Data> _data;

        private class Data
        {
            public DateTime FinishProtection;
            public bool IsProtect;
            public int Protection;
        }

        private void LoadData()
        {
            if (!Interface.Oxide.DataFileSystem.ExistsDatafile($"{Name}/PlayerData"))
                _data = new Dictionary<ulong, Data>();
            else
                _data = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, Data>>(
                    $"{Name}/PlayerData");
            Interface.Oxide.DataFileSystem.WriteObject($"{Name}/PlayerData", _data);

            if (_data == null)
                _data = new Dictionary<ulong, Data>();
        }

        private void OnServerSave()
        {
            SaveData();
        }

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject($"{Name}/PlayerData", _data);
        }

        #endregion
    }
}

// --- End of file: BuildProtection.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/ReportVK.cs ---
// --- Original Local Path: ReportVK.cs ---

﻿using System;
using System.Collections.Generic;
using System.Data;
using System.Globalization;
using System.Linq;
using System.Reflection;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins {
    [Info ("ReportVK and AlertCheater", "BROK#", "1.1.1")]
    [Description ("Reports notifications via VK.COM and alert cheater!")]
    class ReportVK : RustPlugin {
        private Dictionary<BasePlayer, DateTime> CooldownsReport = new Dictionary<BasePlayer, DateTime> ();
        private Dictionary<BasePlayer, DateTime> CooldownsSkype = new Dictionary<BasePlayer, DateTime> ();
        private double CooldownReport = 30f;
        private double CooldownSkype = 10f;
        public const string permissionName = "reportvk.admin";
        private Dictionary<string, bool> GUIinfo = new Dictionary<string, bool> ();
        private Dictionary<string, int> adminProtection = new Dictionary<string, int> ();

        private void LoadMessages () {
            lang.RegisterMessages (new Dictionary<string, string> {
                ["player already alert"] = "Игрок уже имеет уведомление!",
                ["player alert"] = "Игрок {0} уведомлен!",
                ["player unalert"] = "С игрока {0} снято уведомление!",
                ["no permissions"] = "У вас нет доступа к этой команде!",
                ["player not found"] = "Игрок не найден или он оффлайн!",
                ["unalert invalid syntax"] = "Неправильный ситаксис! /unalert <НИК / ИД>",
                ["alert invalid syntax"] = "Неправильный ситаксис! /alert <НИК / ИД>",
                ["More than one result"] = "Найдено несколько игроков с данным запросом! Введите ник полностью!",
                ["okay"] = "Ваша жалоба успешно отправлена!",
                ["info"] = "{0} \"сообщение\" - отправить жалобу VK",
                ["okayskype"] = "Ваш skype успешно отправлен!",
                ["infoskype"] = "{0} \"НИК в СКАЙПЕ\" - отправить skype Администратору",
                ["cooldowns"] = "Вы сможете использовать команду через {0:0} минут!",

            }, this);

            lang.RegisterMessages (new Dictionary<string, string> {
                ["player already alert"] = "Игрок уже имеет уведомление!",
                ["player alert"] = "Игрок {0} уведомлен!",
                ["player unalert"] = "C игрока {0} снято уведомление!",
                ["no permissions"] = "У вас нет доступа к этой команде!",
                ["player not found"] = "Игрок не найден или он оффлайн!",
                ["unalert invalid syntax"] = "Неправильный ситаксис! /unalert <НИК / ИД>",
                ["alert invalid syntax"] = "Неправильный ситаксис! /alert <НИК / ИД>",
                ["More than one result"] = "Найдено несколько игроков с данным запросом! Введите ник полностью!",
                ["okay"] = "Ваша жалоба успешно отправлена!",
                ["info"] = "{0} \"сообщение\" - отправить жалобу VK",
                ["okayskype"] = "Ваш skype успешно отправлен!",
                ["infoskype"] = "{0} \"НИК в СКАЙПЕ\" - отправить skype Администратору",
                ["cooldowns"] = "Вы сможете использовать команду через {0:0} минут!",

            }, this, "ru");
        }

        void Loaded () {
            LoadMessages ();
            permission.RegisterPermission (permissionName, this);

        }

        protected override void LoadDefaultConfig () {
            if (Config["token"] == null) Config["token"] = "access_token VK";
            if (Config["userid"] == null) Config["userid"] = "id группы, страницы для жалоб (оставить пустым если заполнено chatid)";
            if (Config["useridskype"] == null) Config["useridskype"] = "id группы, страницы для скайпов (оставить пустым если заполнено chatidskype)";
            if (Config["time"] == null) Config["time"] = "30";
            if (Config["Color"] == null) Config["Color"] = "0 0 0 0.95";
            if (Config["Position"] == null) Config["Position"] = "0 1 1 0.9";
            if (Config["ColorText"] == null) Config["ColorText"] = "1 1 1 1";
            if (Config["DefaultText"] == null) Config["DefaultText"] = "Вы подозреваетесь в использовании читов. Пройдите проверку на наличие читов. \nНапишите свой скайп с помощью команды /skype <НИК в СКАЙПЕ>. \nЕсли вы покините сервер, вы будете забанены на нашем проекте серверов.";
            if (Config["SizeText"] == null) Config["SizeText"] = "20";
            if (Config["nameserver"] == null) Config["nameserver"] = "Название сервера";
            if (Config["chatid"] == null) Config["chatid"] = "id беседы для жалоб (оставить пустым если заполнено userid)";
            if (Config["chatidskype"] == null) Config["chatidskype"] = "id беседы для скайпа (оставить пустым если заполнено useridskype)";

            SaveConfig ();
        }

        void Unload () {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
                if (GUIinfo.ContainsKey (player.UserIDString))
                    if (GUIinfo[player.UserIDString])
                        GUIDestroy (player);
        }

        void OnEntityTakeDamage (BaseCombatEntity entity, HitInfo info) {
            if (!(entity is BasePlayer)) return;
            if (!adminProtection.ContainsKey (entity.ToPlayer ().UserIDString)) return;
            if (!(info.Initiator is BasePlayer)) return;
            BasePlayer targetplayer = info.InitiatorPlayer;
            if (targetplayer.IsConnected) {
                if (GUIinfo.ContainsKey (targetplayer.UserIDString)) return;
                DoGUI (targetplayer, adminProtection[entity.ToPlayer ().UserIDString], false, null);
            }
            return;
        }

        [ChatCommand ("report")]
        void cmdVKChat (BasePlayer player, string cmd, string[] args) {
            if (args.Length == 0) {
                player.ChatMessage (string.Format (msg ("info", player.userID.ToString ()), "/report"));
                return;
            }
            CooldownReport = Convert.ToDouble (Config["time"]);
            if (CooldownsReport.ContainsKey (player)) {
                double minutes = CooldownsReport[player].Subtract (DateTime.Now).TotalMinutes;
                if (minutes >= 0) {
                    player.ChatMessage (string.Format (msg ("cooldowns"), minutes));
                    return;
                }
            }
            CooldownsReport[player] = DateTime.Now.AddMinutes (CooldownReport);
            string allArgs;
            allArgs = Convert.ToString (args[0]);

            foreach (string arg in args) {
                if (arg == Convert.ToString (args[0])) {
                    continue;
                }

                allArgs = allArgs + " " + arg;
            }

            player.ChatMessage (msg ("okay", player.userID.ToString ()));
            webrequest.EnqueuePost ("https://api.vk.com/method/messages.send?v=5.69", "&access_token=" + Config["token"] +"&chat_id=" + Config["chatid"] + "&user_id=" + Config["userid"] + "&message=Сервер: " + Config["nameserver"] + "\nНик игрока: " + player.displayName + "\nSteam ID: " + player.userID.ToString () + "\nЖалоба: " + allArgs, (code, response) => PostCallback (code, response, player), this);

        }

        [ChatCommand ("skype")]
        void cmdVKSkype (BasePlayer player, string cmd, string[] args) {
            if (args.Length == 0) {
                player.ChatMessage (string.Format (msg ("infoskype", player.userID.ToString ()), "/skype"));
                return;
            }
            if (CooldownsSkype.ContainsKey (player)) {
                double minutes = CooldownsSkype[player].Subtract (DateTime.Now).TotalMinutes;
                if (minutes >= 0) {
                    player.ChatMessage (string.Format (msg ("cooldowns"), minutes));
                    return;
                }
            }
            CooldownsSkype[player] = DateTime.Now.AddMinutes (CooldownSkype);
            string allArgs;
            allArgs = Convert.ToString (args[0]);

            foreach (string arg in args) {
                if (arg == Convert.ToString (args[0])) {
                    continue;
                }

                allArgs = allArgs + " " + arg;
            }

            player.ChatMessage (msg ("okayskype", player.userID.ToString ()));
            webrequest.EnqueuePost ("https://api.vk.com/method/messages.send?v=5.69", "&access_token=" + Config["token"] + "&chat_id=" + Config["chatidskype"] +"&user_id=" + Config["useridskype"] + "&message=Сервер: " + covalence.Server.Name + "\nНик игрока: " + player.displayName + "\nSteam ID: " + player.userID.ToString () + "\nСкайп: " + allArgs, (code, response) => PostCallback (code, response, player), this);

        }

        [ChatCommand ("cc")]
        void blindCMD (BasePlayer player, string command, string[] args) {
            if (!permission.UserHasPermission (player.UserIDString, permissionName)) {
                player.ChatMessage (msg ("no permissions", player.userID.ToString ()));
                return;

            }

            if (args.Length == 1) {

                List<BasePlayer> PlayerList = FindPlayer (args[0]);
                if (PlayerList.Count > 1) {
                    player.ChatMessage (msg ("More than one result", player.userID.ToString ()));
                    return;
                }

                if (PlayerList.Count == 0) {
                    player.ChatMessage (msg ("player not found", player.userID.ToString ()));
                    return;
                }

                BasePlayer targetplayer = PlayerList[0];

                if (targetplayer == null) {

                    player.ChatMessage (msg ("player not found", player.userID.ToString ()));
                    return;
                }

                if (!targetplayer.IsConnected) {

                    player.ChatMessage (msg ("target offline", player.userID.ToString ()));
                    return;
                }

                if (GUIinfo.ContainsKey (targetplayer.UserIDString)) {

                    if (GUIinfo[targetplayer.UserIDString]) {
                        player.ChatMessage (msg ("player already alert", player.userID.ToString ()));
                        return;
                    }
                    DoGUI (targetplayer, 0.0f, true, null);
                    return;
                } else {

                    DoGUI (targetplayer, 0.0f, false, null);
                    player.ChatMessage (string.Format (msg ("player alert", player.userID.ToString ()), targetplayer.displayName));
                    return;
                }
            } else
                player.ChatMessage (msg ("alert invalid syntax", player.userID.ToString ()));
        }

        [ChatCommand ("uncc")]
        void unblindCMD (BasePlayer player, string command, string[] args) {
            if (!permission.UserHasPermission (player.UserIDString, permissionName)) {
                player.ChatMessage (msg ("no permissions", player.userID.ToString ()));
                return;

            }

            if (args.Length == 1) {

                List<BasePlayer> PlayerList = FindPlayer (args[0]);
                if (PlayerList.Count > 1) {

                    player.ChatMessage (msg ("More than one result", player.userID.ToString ()));
                    return;
                }

                if (PlayerList.Count == 0) {
                    player.ChatMessage (msg ("player not found", player.userID.ToString ()));
                    return;
                }

                BasePlayer targetplayer = PlayerList[0];
                if (targetplayer == null) {
                    player.ChatMessage (msg ("player not found", player.userID.ToString ()));
                    return;
                }

                if (!targetplayer.IsConnected) {
                    player.ChatMessage (msg ("player not found", player.userID.ToString ()));
                    return;
                }

                if (GUIinfo.ContainsKey (targetplayer.UserIDString)) {
                    if (!GUIinfo[targetplayer.UserIDString]) {
                        player.ChatMessage (string.Format (msg ("player unalert", player.userID.ToString ()), targetplayer.displayName));
                        return;
                    } else {
                        GUIDestroy (targetplayer);
                        player.ChatMessage (string.Format (msg ("player unalert", player.userID.ToString ()), targetplayer.displayName));
                        return;
                    }
                }
                return;
            } else
                player.ChatMessage (msg ("unalert invalid syntax", player.userID.ToString ()));
        }

        [ConsoleCommand ("alert")]
        void cmdalert (ConsoleSystem.Arg arg) {
            if (arg.Connection != null) return;
            if (arg.Args == null) {
                Puts (msg ("alert invalid syntax"));
                return;
            }

            if (arg.Args.Length == 1) {

                List<BasePlayer> PlayerList = FindPlayer (arg.Args[0]);
                if (PlayerList.Count > 1) {
                    Puts (msg ("More than one result"));
                    return;
                }

                if (PlayerList.Count == 0) {
                    Puts (msg ("player not found"));
                    return;
                }

                BasePlayer targetplayer = PlayerList[0];

                if (targetplayer == null) {

                    Puts (msg ("player not found"));
                    return;
                }

                if (!targetplayer.IsConnected) {

                    Puts (msg ("target offline"));
                    return;
                }

                if (GUIinfo.ContainsKey (targetplayer.UserIDString)) {

                    if (GUIinfo[targetplayer.UserIDString]) {
                        Puts (msg ("player already alert"));
                        return;
                    }
                    DoGUI (targetplayer, 0.0f, true, null);
                    return;
                } else {

                    DoGUI (targetplayer, 0.0f, false, null);
                    Puts (string.Format (msg ("player alert"), targetplayer.displayName));
                    return;
                }
            } else
                Puts (msg ("alert invalid syntax"));

        }

        [ConsoleCommand ("unalert")]
        void cmdunalert (ConsoleSystem.Arg arg) {
            if (arg.Connection != null) return;
            if (arg.Args == null) {
                Puts (msg ("unalert invalid syntax"));
                return;
            }

            if (arg.Args.Length == 1) {

                List<BasePlayer> PlayerList = FindPlayer (arg.Args[0]);
                if (PlayerList.Count > 1) {

                    Puts (msg ("More than one result"));
                    return;
                }

                if (PlayerList.Count == 0) {
                    Puts (msg ("player not found"));
                    return;
                }

                BasePlayer targetplayer = PlayerList[0];
                if (targetplayer == null) {
                    Puts (msg ("player not found"));
                    return;
                }

                if (!targetplayer.IsConnected) {
                    Puts (msg ("player not found"));
                    return;
                }

                if (GUIinfo.ContainsKey (targetplayer.UserIDString)) {
                    if (!GUIinfo[targetplayer.UserIDString]) {
                        Puts (string.Format (msg ("player unalert"), targetplayer.displayName));
                        return;
                    } else {
                        GUIDestroy (targetplayer);
                        Puts (string.Format (msg ("player unalert"), targetplayer.displayName));
                        return;
                    }
                }
                return;
            } else
                Puts (msg ("unalert invalid syntax"));
        }

        void GUIDestroy (BasePlayer player) {
            CuiHelper.DestroyUi (player, Panel);
            GUIinfo[player.UserIDString] = false;
        }

        void DoGUI (BasePlayer targetplayer, float length, bool indic, string message) {
            var splitChars = new [] { ' ' };
            string[] positions = Convert.ToString (Config["Position"]).Split (splitChars, 4);

            if (indic == true) {

                var element = UI.CreateElementContainer (Panel, Convert.ToString (Config["Color"]), positions[0] + " " + positions[3], positions[2] + " " + positions[1], false);

                UI.CreateTextOutline (ref element, Panel, Convert.ToString (Config["DefaultText"]), Convert.ToString (Config["ColorText"]), "0 0 0 0", "1", "1", Convert.ToInt32 (Config["SizeText"]), "0 0", "1 1", TextAnchor.MiddleCenter);

                CuiHelper.AddUi (targetplayer, element);
                GUIinfo[targetplayer.UserIDString] = true;

                if (length > 0.0f)
                    timer.Once (length, () => { GUIDestroy (targetplayer); });
            } else if (indic == false) {
                GUIinfo.Add (targetplayer.UserIDString, false);

                var element = UI.CreateElementContainer (Panel, Convert.ToString (Config["Color"]), positions[0] + " " + positions[3], positions[2] + " " + positions[1], false);

                UI.CreateTextOutline (ref element, Panel, Convert.ToString (Config["DefaultText"]), Convert.ToString (Config["ColorText"]), "0 0 0 0", "1", "1", Convert.ToInt32 (Config["SizeText"]), "0 0", "1 1", TextAnchor.MiddleCenter);

                CuiHelper.AddUi (targetplayer, element);
                GUIinfo[targetplayer.UserIDString] = true;

                if (length > 0.0f)
                    timer.Once (length, () => { GUIDestroy (targetplayer); });
            }
        }

        private string Panel = "AlertPanel";

        public class UI {
            static public CuiElementContainer CreateElementContainer (string panel, string color, string aMin, string aMax, bool cursor = false) {
                var NewElement = new CuiElementContainer () {
                    {
                        new CuiPanel {
                            Image = { Color = color },
                                RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                                CursorEnabled = cursor,
                        },
                        new CuiElement ().Parent,
                            panel
                    }
                };
                return NewElement;
            }

            static public void CreateTextOutline (ref CuiElementContainer element, string panel, string text, string colorText, string colorOutline, string DistanceA, string DistanceB, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter) {
                element.Add (new CuiElement {
                    Parent = panel,
                        Components = {
                            new CuiTextComponent { Color = colorText, FontSize = size, Align = align, Text = text },
                            new CuiOutlineComponent { Distance = DistanceA + " " + DistanceB, Color = colorOutline },
                            new CuiRectTransformComponent { AnchorMax = aMax, AnchorMin = aMin }
                        }
                });
            }

        }

        private static List<BasePlayer> FindPlayer (string nameOrId) {
            List<BasePlayer> x = new List<BasePlayer> ();

            foreach (var activePlayer in BasePlayer.activePlayerList) {
                if (activePlayer.UserIDString == nameOrId)
                    x.Add (activePlayer);
                if (activePlayer.displayName.Contains (nameOrId, CompareOptions.OrdinalIgnoreCase))
                    if (!x.Contains (activePlayer))
                        x.Add (activePlayer);
                if (activePlayer.net?.connection != null && activePlayer.net.connection.ipaddress == nameOrId)
                    if (!x.Contains (activePlayer))
                        x.Add (activePlayer);
            }
            return x;
        }

        void PostCallback (int code, string response, BasePlayer player) {
            if (response == null || code != 200) {
                PrintWarning ("Ошибка! сообщение не может быть отправлено.");
                return;
            } 
            
            else {
                PrintWarning (": игрок [" + player.displayName + "] отправил сообщение!");
                return;
            }
        }

        string msg (string key, object userID = null) => lang.GetMessage (key, this, userID == null ? null : userID.ToString ());

    }
}

// --- End of file: ReportVK.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/ClansUI (1).cs ---
// --- Original Local Path: ClansUI (1).cs ---

﻿//Requires: Clans
using System.Collections.Generic;
using System.Globalization;
using Oxide.Core;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("ClansUI", "BGRM", "0.1.43", ResourceId = 0)]
    class ClansUI : RustPlugin
    {
        #region Fields
        [PluginReference] Clans Clans;
        
        const string ClanUI = "ClansUI";
        const string ClanBG = "ClansUIBG";
        private int maxMembers;
        private int maxAllies;
        private bool canToggleFF;
        private bool alliesEnabled;

        SortedList<string, string> playerList = new SortedList<string, string>();
        private List<ulong> openMenu = new List<ulong>();
        #endregion

        #region Oxide Hooks
        void Loaded()
        {
            lang.RegisterMessages(Messages, this);
        }
        void OnServerInitialized()
        {
            LoadVariables();
            if (Clans.Author != "Oxide Россия - oxide-russia.ru")
            cmd.AddChatCommand(configData.MenuActivation.CommandToOpen, this, cmdClanUI);
            maxMembers = Clans.limitMembers;
            maxAllies = Clans.limitAlliances;
            canToggleFF = Clans.enableFFOPtion;
            alliesEnabled = Clans.enableClanAllies;

            foreach (var player in BasePlayer.activePlayerList)
                OnPlayerInit(player);
        }
        void OnPlayerInit(BasePlayer player)
        {
            var name = TrimToSize(RemoveTag(player.displayName), 15);
            if (!playerList.ContainsKey(player.UserIDString))
                playerList.Add(player.UserIDString, name);
            else playerList[player.UserIDString] = name;
        }
        void OnPlayerDisconnected(BasePlayer player)
        {            
            CuiHelper.DestroyUi(player, ClanBG);
            CuiHelper.DestroyUi(player, ClanUI);
        }
        void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, ClanBG);
                CuiHelper.DestroyUi(player, ClanUI);
            }
        }
        #endregion

        #region Functions
        private string RemoveTag(string str)
        {
            if (str.StartsWith("[") && str.Contains("]") && str.Length > str.IndexOf("]"))
            {
                str = str.Substring(str.IndexOf("]") + 1).Trim();
            }

            if (str.StartsWith("[") && str.Contains("]") && str.Length > str.IndexOf("]"))
                RemoveTag(str);

            return str;
        }

        private string TrimToSize(string str, int size) => str.Length <= size ? str : str.Substring(0, size);
        #endregion

        #region UI
        class UI
        {
            static public CuiElementContainer CreateElementContainer(string panelName, string color, string aMin, string aMax, bool cursor = false, string parent = "Hud")
            {
                var NewElement = new CuiElementContainer()
            {
                {
                    new CuiPanel
                    {
                        Image = {Color = color},
                        RectTransform = {AnchorMin = aMin, AnchorMax = aMax},
                        CursorEnabled = cursor
                    },
                    new CuiElement().Parent = parent,
                    panelName
                }
            };
                return NewElement;
            }
            static public void CreatePanel(ref CuiElementContainer container, string panel, string color, string aMin, string aMax, bool cursor = false)
            {
                container.Add(new CuiPanel
                {
                    Image = { Color = color },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    CursorEnabled = cursor
                },
                panel, CuiHelper.GetGuid());
            }
            static public void CreateLabel(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiLabel
                {
                    Text = { Color = color, FontSize = size, Align = align, FadeIn = 0, Text = text },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax }
                },
                panel, CuiHelper.GetGuid());

            }
            static public void CreateButton(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, string command, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiButton
                {
                    Button = { Color = color, Command = command, FadeIn = 0 },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    Text = { Text = text, FontSize = size, Align = align }
                },
                panel, CuiHelper.GetGuid());
            }
            static public string Color(string hexColor, float alpha)
            {
                if (hexColor.StartsWith("#"))
                    hexColor = hexColor.TrimStart('#');
                int red = int.Parse(hexColor.Substring(0, 2), NumberStyles.AllowHexSpecifier);
                int green = int.Parse(hexColor.Substring(2, 2), NumberStyles.AllowHexSpecifier);
                int blue = int.Parse(hexColor.Substring(4, 2), NumberStyles.AllowHexSpecifier);
                return $"{(double)red / 255} {(double)green / 255} {(double)blue / 255} {alpha}";
            }
        }
        #endregion

        #region UI Creation
        enum AllianceType { Current, Pending, Offer }
        class PlayerInfo { public string playerId, playerName; }
      
        void LoadClanMenu(BasePlayer player, Clans.Clan clan, int page = 0)
        {
            if (!openMenu.Contains(player.userID))
                openMenu.Add(player.userID);
            var container = UI.CreateElementContainer(ClanBG, "0 0 0 0", "0.15 0.15", "0.85 0.85", true);
            CuiHelper.AddUi(player, container);
            MembersMenu(player, clan, page);
        }
        void MembersMenu(BasePlayer player, Clans.Clan clan, int page = 0)
        {
            var container = UI.CreateElementContainer(ClanUI, UI.Color(configData.UIColors.Background.HexColor, configData.UIColors.Background.Opacity), $"{configData.UISize.X_Position} {configData.UISize.Y_Position}", $"{configData.UISize.X_Position + configData.UISize.X_Dimension} {configData.UISize.Y_Position + configData.UISize.Y_Dimension}");
            UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.CloseButton.HexColor, configData.UIColors.CloseButton.Opacity), "X", 18, "0.965 0.945", "0.998 0.995", "ClansUI close");

            UI.CreateLabel(ref container, ClanUI, "", msg("title", player.UserIDString), 18, "0.02 0.94", "0.5 1", TextAnchor.MiddleLeft);
            UI.CreatePanel(ref container, ClanUI, UI.Color(configData.UIColors.Background.HexColor, configData.UIColors.Background.Opacity), "0.0001 0.0001", "0.9999 0.94");
            UI.CreateLabel(ref container, ClanUI, "", $"{msg("name", player.UserIDString)} {clan.tag}\n\n{msg("description", player.UserIDString)} {clan.description}", 14, "0.02 0.72", "0.25 0.93", TextAnchor.UpperLeft);

            UI.CreatePanel(ref container, ClanUI, UI.Color(configData.UIColors.TitlePanel.HexColor, configData.UIColors.TitlePanel.Opacity), "0.26 0.875", "0.99 0.93");
            UI.CreateLabel(ref container, ClanUI, "", msg("settingsTitle", player.UserIDString), 16, "0.28 0.875", "0.97 0.93", TextAnchor.MiddleLeft);
            
            UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), $"{msg("ffToggle", player.UserIDString)}  :  {(Clans.HasFFEnabled(player.userID) ? msg("on", player.UserIDString) : !canToggleFF ? msg("disabled", player.UserIDString) : msg("off", player.UserIDString))}", 15, "0.26 0.805", "0.51 0.86", canToggleFF ? $"ClansUI toggleff {page}" : "");

            UI.CreatePanel(ref container, ClanUI, UI.Color(configData.UIColors.TextPanel.HexColor, configData.UIColors.TitlePanel.Opacity), "0.26 0.735", "0.75 0.79");
            UI.CreateLabel(ref container, ClanUI, "", $"{msg("allies",player.UserIDString)} {(alliesEnabled ? clan.clanAlliances.ToSentence() : msg("disabled", player.UserIDString))}", 15, "0.27 0.735", "0.75 0.79", TextAnchor.MiddleLeft);
            UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), msg("manageAlliances", player.UserIDString), 15, "0.76 0.735", "0.99 0.79", alliesEnabled ? "ClansUI alliances 0" : "");

            UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), msg("memberInvite", player.UserIDString), 15, "0.52 0.805", "0.75 0.86", "ClansUI invitelist 0");
            UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), msg("cancelInvites", player.UserIDString), 15, "0.76 0.805", "0.99 0.86", "ClansUI cancelinvites 0");

            UI.CreatePanel(ref container, ClanUI, UI.Color(configData.UIColors.TitlePanel.HexColor, configData.UIColors.TitlePanel.Opacity), "0.01 0.67", "0.25 0.72");
            UI.CreatePanel(ref container, ClanUI, UI.Color(configData.UIColors.TextPanel.HexColor, configData.UIColors.TextPanel.Opacity), "0.26 0.67", "0.99 0.72");
            UI.CreateLabel(ref container, ClanUI, "", msg("members", player.UserIDString), 16, "0.02 0.67", "0.25 0.72", TextAnchor.MiddleLeft);
            UI.CreateLabel(ref container, ClanUI, "", $"({clan.members.Count}/{maxMembers})", 16, "0.02 0.67", "0.23 0.72", TextAnchor.MiddleRight);

            for (int i = (10 * page); i < clan.members.Count; i++)
            {
                if (i >= (10 * page) + 10)               
                    break;         
                string memberId = clan.members[i];
                bool isOwner = false;
                bool isPlayer = false;
                if (memberId == player.UserIDString)
                {
                    if (clan.IsOwner(memberId))
                        isOwner = true;
                    else isPlayer = true;
                }
                AddClanMember(ref container, player.UserIDString, memberId, i - (10 * page), page, clan.IsOwner(memberId) ? msg("ownerTag", player.UserIDString) : clan.IsCouncil(memberId) ? msg("councilTag", player.UserIDString) : clan.IsModerator(memberId) ? msg("modTag", player.UserIDString) : "", isOwner, isPlayer);
            }

            bool hasPages = false;
            int maxCount = clan.members.Count;
            if (maxCount > 10)
            {
                hasPages = true;
                var maxpages = (maxCount - 1) / 10 + 1;
                if (page < maxpages - 1)
                    UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), ">>>", 14, "0.16 0.01", "0.24 0.05", $"ClansUI members {page + 1}");
                if (page > 0)
                    UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), "<<<", 14, "0.02 0.01", "0.1 0.05", $"ClansUI members {page - 1}");
            }

            UI.CreatePanel(ref container, ClanUI, UI.Color(configData.UIColors.TitlePanel.HexColor, configData.UIColors.TitlePanel.Opacity), $"{(hasPages ? 0.26f : 0.01f)} 0.01", "0.99 0.05");
            UI.CreateLabel(ref container, ClanUI, "", msg("info", player.UserIDString).Replace("{clanversion}", Clans.Version.ToString()).Replace("{uiversion}", Version.ToString()), 12, $"{(hasPages ? 0.27f : 0.02f)} 0.01", "0.98 0.05", TextAnchor.MiddleCenter);
            
            CuiHelper.DestroyUi(player, ClanUI);
            CuiHelper.AddUi(player, container);
        }
        void AddClanMember(ref CuiElementContainer container, string playerId, string memberId, int number, int page, string status, bool isOwner, bool isPlayer)
        {
            var targetPlayer = covalence.Players.FindPlayerById(memberId);
            float yPos = 0.6f - (0.06f * number);
            UI.CreatePanel(ref container, ClanUI, UI.Color(configData.UIColors.TextPanel.HexColor, configData.UIColors.TextPanel.Opacity), $"0.02 {yPos}", $"0.24 {yPos + 0.05f}");
            UI.CreateLabel(ref container, ClanUI, "", targetPlayer?.Name ?? memberId, 14, $"0.03 {yPos}", $"0.23 {yPos + 0.05f}", TextAnchor.MiddleLeft);
            UI.CreatePanel(ref container, ClanUI, UI.Color(configData.UIColors.TextPanel.HexColor, configData.UIColors.TextPanel.Opacity), $"0.26 {yPos}", $"0.31 {yPos + 0.05f}");
            UI.CreateLabel(ref container, ClanUI, "", status, 14, $"0.265 {yPos}", $"0.305 {yPos + 0.05f}");
            for (int i = 0; i < configData.Commands.Count; i++)
            {
                float xPos = 0.315f + (0.075f * i);
                var command = configData.Commands[i];
                UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), command.Name, 14, $"{xPos} {yPos}", $"{xPos + 0.07f} {yPos + 0.05f}", $"ClansUI command {i} {memberId} {targetPlayer?.Name.Replace(" ", "$$%%^^") ?? memberId}");
            }
            if (isOwner)
            {
                UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), msg("leave", playerId), 14, $"0.855 {yPos}", $"0.925 {yPos + 0.05f}", $"ClansUI leave {page} {memberId}");
                UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), msg("disband", playerId), 14, $"0.77 {yPos}", $"0.85 {yPos + 0.05f}", $"ClansUI predisband {page} {memberId}");
            }
            else if (isPlayer)
            {
                UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), msg("leave", playerId), 14, $"0.855 {yPos}", $"0.925 {yPos + 0.05f}", $"ClansUI leave {page} {memberId}");
            }
            else
            {
                UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), msg("promote", playerId), 14, $"0.77 {yPos}", $"0.85 {yPos + 0.05f}", $"ClansUI promote {page} {memberId}");
                UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), msg("demote", playerId), 14, $"0.855 {yPos}", $"0.925 {yPos + 0.05f}", $"ClansUI demote {page} {memberId}");
                UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), msg("kick", playerId), 14, $"0.93 {yPos}", $"0.99 {yPos + 0.05f}", $"ClansUI kick {page} {memberId}");
            }
        }
        void MemberSelection(BasePlayer player, Clans.Clan clan, int page, bool isRemoving = false)
        {
            var container = UI.CreateElementContainer(ClanUI, UI.Color(configData.UIColors.Background.HexColor, configData.UIColors.Background.Opacity), $"{configData.UISize.X_Position} {configData.UISize.Y_Position}", $"{configData.UISize.X_Position + configData.UISize.X_Dimension} {configData.UISize.Y_Position + configData.UISize.Y_Dimension}");
            UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.CloseButton.HexColor, configData.UIColors.CloseButton.Opacity), "X", 18, "0.965 0.945", "0.998 0.995", "ClansUI close");

            UI.CreateLabel(ref container, ClanUI, "", msg("title", player.UserIDString), 18, "0.02 0.94", "0.5 1", TextAnchor.MiddleLeft);
            UI.CreatePanel(ref container, ClanUI, UI.Color(configData.UIColors.Background.HexColor, configData.UIColors.Background.Opacity), "0.0001 0.0001", "0.9999 0.94");

            UI.CreatePanel(ref container, ClanUI, UI.Color(configData.UIColors.TitlePanel.HexColor, configData.UIColors.TitlePanel.Opacity), "0.01 0.875", "0.854 0.93");
            UI.CreateLabel(ref container, ClanUI, "", isRemoving ? msg("cancelSelect", player.UserIDString) : msg("memberSelect", player.UserIDString), 16, "0.02 0.875", "0.844 0.93", TextAnchor.MiddleLeft);

            UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), msg("back", player.UserIDString), 15, "0.864 0.875", "0.99 0.93", "ClansUI members 0");

            int count = isRemoving ? clan.invites.Count : playerList.Count();
            for (int i = (84 * page); i < count; i++)
            {
                if (i >= (84 * page) + 84)
                    break;
                var targetId = isRemoving ? clan.invites.Keys.ToArray()[i] : playerList.Keys[i];
                MemberButton(ref container, playerList[targetId], targetId, i - (84 * page), isRemoving);
            }

            bool hasPages = false;
            int maxCount = isRemoving ? clan.invites.Count : playerList.Count;
            if (maxCount > 84)
            {
                hasPages = true;
                var maxpages = (maxCount - 1) / 84 + 1;
                if (page < maxpages - 1)
                    UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), ">>>", 14, "0.16 0.01", "0.24 0.05", $"ClansUI invitelist {page + 1}");
                if (page > 0)
                    UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), "<<<", 14, "0.02 0.01", "0.1 0.05", $"ClansUI invitelist {page - 1}");
            }

            UI.CreatePanel(ref container, ClanUI, UI.Color(configData.UIColors.TitlePanel.HexColor, configData.UIColors.TitlePanel.Opacity), $"{(hasPages ? 0.26f : 0.01f)} 0.01", "0.99 0.05");
            UI.CreateLabel(ref container, ClanUI, "", msg("info", player.UserIDString).Replace("{clanversion}", Clans.Version.ToString()).Replace("{uiversion}", Version.ToString()), 12, $"{(hasPages ? 0.27f : 0.02f)} 0.01", "0.98 0.05", TextAnchor.MiddleCenter);

            CuiHelper.DestroyUi(player, ClanUI);
            CuiHelper.AddUi(player, container);
        }
        void MemberButton(ref CuiElementContainer container, string name, string playerId, int number, bool isRemoving)
        {
            float[] position = CalculateEntryPos(number);
            UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), isRemoving ? covalence.Players.FindPlayerById(name)?.Name ?? name : name, 14, $"{position[0]} {position[1]}", $"{position[2]} {position[3]}", $"ClansUI {(isRemoving ? "withdraw" : "invitemember")} 0 {(isRemoving ? name : playerId)}");
        }

        void AllianceMenu(BasePlayer player, Clans.Clan clan, AllianceType type = AllianceType.Current, int page = 0)
        {
            var container = UI.CreateElementContainer(ClanUI, UI.Color(configData.UIColors.Background.HexColor, configData.UIColors.Background.Opacity), $"{configData.UISize.X_Position} {configData.UISize.Y_Position}", $"{configData.UISize.X_Position + configData.UISize.X_Dimension} {configData.UISize.Y_Position + configData.UISize.Y_Dimension}");
            UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.CloseButton.HexColor, configData.UIColors.CloseButton.Opacity), "X", 18, "0.965 0.945", "0.998 0.995", "ClansUI close");

            UI.CreateLabel(ref container, ClanUI, "", msg("title", player.UserIDString), 18, "0.02 0.94", "0.5 1", TextAnchor.MiddleLeft);
            UI.CreatePanel(ref container, ClanUI, UI.Color(configData.UIColors.Background.HexColor, configData.UIColors.Background.Opacity), "0.0001 0.0001", "0.9999 0.94");
            UI.CreateLabel(ref container, ClanUI, "", $"{msg("name", player.UserIDString)} {clan.tag}", 14, "0.02 0.72", "0.25 0.93", TextAnchor.UpperLeft);

            UI.CreatePanel(ref container, ClanUI, UI.Color(configData.UIColors.TitlePanel.HexColor, configData.UIColors.TitlePanel.Opacity), "0.26 0.875", "0.99 0.93");
            UI.CreateLabel(ref container, ClanUI, "", msg("allianceSettings", player.UserIDString), 16, "0.28 0.875", "0.97 0.93", TextAnchor.MiddleLeft);
                       
            UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), msg("alliances", player.UserIDString), 15, "0.26 0.805", "0.401 0.86", "ClansUI alliances 0 current");
            UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), msg("offers", player.UserIDString), 15, "0.411 0.805", "0.552 0.86", "ClansUI alliances 0 offer");
            UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), msg("invites", player.UserIDString), 15, "0.562 0.805", "0.703 0.86", "ClansUI alliances 0 invites");
            UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), msg("offerAlliance", player.UserIDString), 15, "0.713 0.805", "0.854 0.86", "ClansUI offermenu 0");
            UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), msg("back", player.UserIDString), 15, "0.864 0.805", "0.99 0.86", "ClansUI members 0");

            UI.CreatePanel(ref container, ClanUI, UI.Color(configData.UIColors.TitlePanel.HexColor, configData.UIColors.TitlePanel.Opacity), "0.01 0.805", "0.25 0.86");
            UI.CreatePanel(ref container, ClanUI, UI.Color(configData.UIColors.TextPanel.HexColor, configData.UIColors.TitlePanel.Opacity), "0.26 0.805", "0.99 0.56");
            UI.CreateLabel(ref container, ClanUI, "", type == AllianceType.Current ? msg("alliances", player.UserIDString) : type == AllianceType.Offer ? msg("offers", player.UserIDString) : msg("invites", player.UserIDString), 16, "0.02 0.805", "0.25 0.86", TextAnchor.MiddleLeft);
            if (type == AllianceType.Current)
                UI.CreateLabel(ref container, ClanUI, "", $"({clan.clanAlliances.Count}/{maxAllies})", 16, "0.02 0.805", "0.23 0.86", TextAnchor.MiddleRight);

            List<string> allyList = type == AllianceType.Current ? clan.clanAlliances : type == AllianceType.Offer ? clan.invitedAllies : clan.pendingInvites;
            
            for (int i = (12 * page); i < allyList.Count; i++)
            {
                if (i >= (12 * page) + 12)
                    break;
                string allyTag = allyList[i];
                AddAlliance(ref container, type, player.UserIDString, allyTag, i - (12 * page), page);
            }
            
            bool hasPages = false;
            int maxCount = allyList.Count;
            if (maxCount > 10)
            {
                hasPages = true;
                var maxpages = (maxCount - 1) / 10 + 1;
                if (page < maxpages - 1)
                    UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), ">>>", 14, "0.16 0.01", "0.24 0.05", $"ClansUI alliances {page + 1} {type}");
                if (page > 0)
                    UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), "<<<", 14, "0.02 0.01", "0.1 0.05", $"ClansUI alliances {page - 1} {type}");                
            }
           
            UI.CreatePanel(ref container, ClanUI, UI.Color(configData.UIColors.TitlePanel.HexColor, configData.UIColors.TitlePanel.Opacity), $"{(hasPages ? 0.26f : 0.01f)} 0.01", "0.99 0.05");
            UI.CreateLabel(ref container, ClanUI, "", msg("info", player.UserIDString).Replace("{clanversion}", Clans.Version.ToString()).Replace("{uiversion}", Version.ToString()), 12, $"{(hasPages ? 0.27f : 0.02f)} 0.01", "0.98 0.05", TextAnchor.MiddleCenter);

            CuiHelper.DestroyUi(player, ClanUI);
            CuiHelper.AddUi(player, container);
        }
        void AddAlliance(ref CuiElementContainer container, AllianceType type, string playerId, string clanTag, int number, int page)
        {
            float yPos = 0.735f - (0.06f * number);
            UI.CreatePanel(ref container, ClanUI, UI.Color(configData.UIColors.TextPanel.HexColor, configData.UIColors.TextPanel.Opacity), $"0.02 {yPos}", $"0.24 {yPos + 0.05f}");
            UI.CreateLabel(ref container, ClanUI, "", clanTag, 14, $"0.03 {yPos}", $"0.23 {yPos + 0.05f}", TextAnchor.MiddleLeft);
            UI.CreatePanel(ref container, ClanUI, UI.Color(configData.UIColors.TextPanel.HexColor, configData.UIColors.TextPanel.Opacity), $"0.26 {yPos}", $"0.401 {yPos + 0.05f}");
            UI.CreateLabel(ref container, ClanUI, "", $"{msg("members", playerId)}: {Clans.findClan(clanTag).members.Count}", 14, $"0.27 {yPos}", $"0.391 {yPos + 0.05f}", TextAnchor.MiddleLeft);
            if (type == AllianceType.Current)
                UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), msg("allyCancel", playerId), 14, $"0.864 {yPos}", $"0.99 {yPos + 0.05f}", $"ClansUI cancelalliance {page} {clanTag}");

            else if (type == AllianceType.Offer)            
                UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), msg("allyRetract", playerId), 14, $"0.864 {yPos}", $"0.99 {yPos + 0.05f}", $"ClansUI canceloffer {page} {clanTag}");
            
            else if (type == AllianceType.Pending)
            {
                UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), msg("allyAccept", playerId), 14, $"0.73 {yPos}", $"0.854 {yPos + 0.05f}", $"ClansUI acceptoffer {page} {clanTag}");
                UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), msg("allyDecline", playerId), 14, $"0.864 {yPos}", $"0.99 {yPos + 0.05f}", $"ClansUI declineoffer {page} {clanTag}");
            }
        } 
        void AllySelection(BasePlayer player, Clans.Clan clan, int page)
        {
            var container = UI.CreateElementContainer(ClanUI, UI.Color(configData.UIColors.Background.HexColor, configData.UIColors.Background.Opacity), $"{configData.UISize.X_Position} {configData.UISize.Y_Position}", $"{configData.UISize.X_Position + configData.UISize.X_Dimension} {configData.UISize.Y_Position + configData.UISize.Y_Dimension}");
            UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.CloseButton.HexColor, configData.UIColors.CloseButton.Opacity), "X", 18, "0.965 0.945", "0.998 0.995", "ClansUI close");

            UI.CreateLabel(ref container, ClanUI, "", msg("title", player.UserIDString), 18, "0.02 0.94", "0.5 1", TextAnchor.MiddleLeft);
            UI.CreatePanel(ref container, ClanUI, UI.Color(configData.UIColors.Background.HexColor, configData.UIColors.Background.Opacity), "0.0001 0.0001", "0.9999 0.94");

            UI.CreatePanel(ref container, ClanUI, UI.Color(configData.UIColors.TitlePanel.HexColor, configData.UIColors.TitlePanel.Opacity), "0.01 0.875", "0.854 0.93");
            UI.CreateLabel(ref container, ClanUI, "", msg("allySelect", player.UserIDString), 16, "0.02 0.875", "0.844 0.93", TextAnchor.MiddleLeft);

            UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), msg("back", player.UserIDString), 15, "0.864 0.875", "0.99 0.93", "ClansUI alliances 0");
              
            for (int i = (84 * page); i < Clans.clans.Count; i++)
            {
                if (i >= (84 * page) + 84)
                    break;
                string allyTag = Clans.clans.Keys.ToArray()[i];
                ClanAllyButton(ref container, allyTag, i - (84 * page));
            }
            
            bool hasPages = false;
            int maxCount = Clans.clans.Keys.Count;
            if (maxCount > 84)
            {
                hasPages = true;
                var maxpages = (maxCount - 1) / 84 + 1;
                if (page < maxpages - 1)
                    UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), ">>>", 14, "0.16 0.01", "0.24 0.05", $"ClansUI offermenu {page + 1}");
                if (page > 0)
                    UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), "<<<", 14, "0.02 0.01", "0.1 0.05", $"ClansUI offermenu {page - 1}");
            }

            UI.CreatePanel(ref container, ClanUI, UI.Color(configData.UIColors.TitlePanel.HexColor, configData.UIColors.TitlePanel.Opacity), $"{(hasPages ? 0.26f : 0.01f)} 0.01", "0.99 0.05");
            UI.CreateLabel(ref container, ClanUI, "", msg("info", player.UserIDString).Replace("{clanversion}", Clans.Version.ToString()).Replace("{uiversion}", Version.ToString()), 12, $"{(hasPages ? 0.27f : 0.02f)} 0.01", "0.98 0.05", TextAnchor.MiddleCenter);

            CuiHelper.DestroyUi(player, ClanUI);
            CuiHelper.AddUi(player, container);
        }
        void ClanAllyButton(ref CuiElementContainer container, string clanTag, int number)
        {
            float[] position = CalculateEntryPos(number);
            UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), clanTag, 14, $"{position[0]} {position[1]}", $"{position[2]} {position[3]}", $"ClansUI offeralliance 0 {clanTag}");
        }
        void ConfirmDisband(BasePlayer player, Clans.Clan clan)
        {
            var container = UI.CreateElementContainer(ClanUI, UI.Color(configData.UIColors.Background.HexColor, configData.UIColors.Background.Opacity), $"0.35 0.4", $"0.65 0.6");
            UI.CreateLabel(ref container, ClanUI, "", msg("disband", player.UserIDString), 18, "0.02 0.8", "0.5 1", TextAnchor.MiddleLeft);
            UI.CreatePanel(ref container, ClanUI, UI.Color(configData.UIColors.Background.HexColor, configData.UIColors.Background.Opacity), "0.0001 0.0001", "0.9999 0.8");
            UI.CreateLabel(ref container, ClanUI, "", msg("confirmDisband", player.UserIDString), 18, "0.1 0.5", "0.9 0.85");
            UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), msg("confirm", player.UserIDString), 14, "0.1 0.1", "0.45 0.3", $"ClansUI disband 0");
            UI.CreateButton(ref container, ClanUI, UI.Color(configData.UIColors.ButtonColor.HexColor, configData.UIColors.ButtonColor.Opacity), msg("back", player.UserIDString), 14, "0.55 0.1", "0.9 0.3", $"ClansUI members 0");
            CuiHelper.DestroyUi(player, ClanUI);
            CuiHelper.AddUi(player, container);
        }
        private float[] CalculateEntryPos(int number)
        {
            Vector2 position = new Vector2(0.01f, 0.805f);
            Vector2 dimensions = new Vector2(0.1315f, 0.055f);
            float offsetY = 0;
            float offsetX = 0;
            if (number >= 0 && number < 7)
            {
                offsetX = (0.01f + dimensions.x) * number;
            }
            if (number > 6 && number < 14)
            {
                offsetX = (0.01f + dimensions.x) * (number - 7);
                offsetY = (-0.01f - dimensions.y) * 1;
            }
            if (number > 13 && number < 21)
            {
                offsetX = (0.01f + dimensions.x) * (number - 14);
                offsetY = (-0.01f - dimensions.y) * 2;
            }
            if (number > 20 && number < 28)
            {
                offsetX = (0.01f + dimensions.x) * (number - 21);
                offsetY = (-0.01f - dimensions.y) * 3;
            }
            if (number > 27 && number < 35)
            {
                offsetX = (0.01f + dimensions.x) * (number - 28);
                offsetY = (-0.01f - dimensions.y) * 4;
            }
            if (number > 34 && number < 42)
            {
                offsetX = (0.01f + dimensions.x) * (number - 35);
                offsetY = (-0.01f - dimensions.y) * 5;
            }
            if (number > 41 && number < 49)
            {
                offsetX = (0.01f + dimensions.x) * (number - 42);
                offsetY = (-0.01f - dimensions.y) * 6;
            }
            if (number > 48 && number < 56)
            {
                offsetX = (0.01f + dimensions.x) * (number - 49);
                offsetY = (-0.01f - dimensions.y) * 7;
            }
            if (number > 55 && number < 63)
            {
                offsetX = (0.01f + dimensions.x) * (number - 56);
                offsetY = (-0.01f - dimensions.y) * 8;
            }
            if (number > 62 && number < 70)
            {
                offsetX = (0.01f + dimensions.x) * (number - 63);
                offsetY = (-0.01f - dimensions.y) * 9;
            }
            if (number > 69 && number < 77)
            {
                offsetX = (0.01f + dimensions.x) * (number - 70);
                offsetY = (-0.01f - dimensions.y) * 10;
            }
            if (number > 76 && number < 84)
            {
                offsetX = (0.01f + dimensions.x) * (number - 77);
                offsetY = (-0.01f - dimensions.y) * 11;
            }
            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }
        #endregion

        #region UI Commands
        [ConsoleCommand("ClansUIToggle")]
        void ccmdClansUIToggle(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (!openMenu.Contains(player.userID))
            {                
                Clans.Clan clan = Clans.findClanByUser(player.UserIDString);
                if (clan == null)
                    SendReply(player, msg("cmdNoClan", player.UserIDString));
                else LoadClanMenu(player, clan);                
            }
            else
            {
                openMenu.Remove(player.userID);
                CuiHelper.DestroyUi(player, ClanBG);
                CuiHelper.DestroyUi(player, ClanUI);
            }
        }
        [ConsoleCommand("ClansUI")]
        void ccmdClansUI(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            string command = arg.GetString(0);
            if (command == "close")
            {
                openMenu.Remove(player.userID);
                CuiHelper.DestroyUi(player, ClanBG);
                CuiHelper.DestroyUi(player, ClanUI);
                return;
            }      
                  
            Clans.Clan clan = Clans.findClanByUser(player.UserIDString);
            int page = arg.GetInt(1);
            string targetId = "";
            if (arg.Args.Length > 2)
                targetId = arg.GetString(2);

            switch (arg.Args[0])
            {
                case "toggleff":
                    Clans.ToggleFF(player.userID);
                    MembersMenu(player, clan, page);
                    return;
                case "members":
                    MembersMenu(player, clan, page);
                    return;
                case "alliances":
                    AllianceType type = targetId == "invites" ? AllianceType.Pending : targetId == "offer" ? AllianceType.Offer : AllianceType.Current;
                    AllianceMenu(player, clan, type, page);
                    return;
                case "command":
                    string targetName = arg.GetString(3).Replace("$$%%^^", " ");
                    var cmd = configData.Commands[page];
                    rust.RunClientCommand(player, $"chat.say", new string[] { $"{cmd.Command} \"{cmd.Arg.Replace("{playerName}", targetName).Replace("{playerId}", targetId)}\"" });
                    return;
                case "promote":
                    Clans.PromotePlayer(player, targetId);
                    MembersMenu(player, clan, page);
                    return;
                case "demote":
                    Clans.DemotePlayer(player, targetId);
                    MembersMenu(player, clan, page);
                    return;
                case "kick":
                    Clans.KickPlayer(player, targetId);
                    MembersMenu(player, clan, page);
                    return;
                case "invitelist":
                    MemberSelection(player, clan, page);
                    return;
                case "cancelinvites":
                    MemberSelection(player, clan, page, true);
                    return;
                case "invitemember":
                    Clans.InvitePlayer(player, targetId);
                    MemberSelection(player, clan, 0);
                    return;
                case "withdraw":
                    Clans.WithdrawPlayer(player, targetId);
                    MemberSelection(player, clan, page, true);
                    return;
                case "offermenu":
                    AllySelection(player, clan, page);
                    return;
                case "offeralliance":
                    Clans.Alliance(player, targetId, "request");
                    AllianceMenu(player, clan, AllianceType.Offer, 0);
                    return;
                case "cancelalliance":
                    Clans.Alliance(player, targetId, "cancel");
                    AllianceMenu(player, clan, AllianceType.Current, page);
                    return;
                case "canceloffer":
                    Clans.Alliance(player, targetId, "cancel");
                    AllianceMenu(player, clan, AllianceType.Offer, page);
                    return;
                case "declineoffer":
                    Clans.Alliance(player, targetId, "decline");
                    AllianceMenu(player, clan, AllianceType.Pending, page);
                    return;
                case "acceptoffer":
                    Clans.Alliance(player, targetId, "accept");
                    AllianceMenu(player, clan, AllianceType.Current, page);
                    return;
                case "leave":
                    Clans.LeaveClan(player);
                    openMenu.Remove(player.userID);
                    CuiHelper.DestroyUi(player, ClanBG);
                    CuiHelper.DestroyUi(player, ClanUI);
                    return;
                case "predisband":
                    ConfirmDisband(player, clan);
                    return;
                case "disband":
                    Clans.DisbandClan(player);
                    openMenu.Remove(player.userID);
                    CuiHelper.DestroyUi(player, ClanBG);
                    CuiHelper.DestroyUi(player, ClanUI);
                    return;
                default:
                    break;
            }           
        }
        #endregion

        #region Commands
        void cmdClanUI(BasePlayer player, string command, string[] args)
        {            
            Clans.Clan clan = Clans