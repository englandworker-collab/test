.findClanByUser(player.UserIDString);
            if (clan == null)
                SendReply(player, msg("cmdNoClan", player.UserIDString));
            else LoadClanMenu(player, clan);
        }
        #endregion       

        #region Config        
        private ConfigData configData;
        class MenuActivation
        {
            public string CommandToOpen { get; set; }
        }
        class UIColor
        {
            public string HexColor { get; set; }
            public float Opacity { get; set; }
        }
        class UIColors
        {
            public UIColor Background { get; set; }
            public UIColor TitlePanel { get; set; }
            public UIColor TextPanel { get; set; }
            public UIColor CloseButton { get; set; }
            public UIColor ButtonColor { get; set; }            
        }
        class UISize
        {
            public float X_Position { get; set; }
            public float X_Dimension { get; set; }
            public float Y_Position { get; set; }
            public float Y_Dimension { get; set; }
        }
        class CommandButton
        {
            public string Name { get; set; }
            public string Command { get; set; }
            public string Arg { get; set; }
        }
        class ConfigData
        {
            public List<CommandButton> Commands { get; set; }
            public UIColors UIColors { get; set; }
            public UISize UISize { get; set; }
            public MenuActivation MenuActivation { get; set; }
        }
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                Commands = new List<CommandButton>
                {
                    new CommandButton
                    {
                        Name = "TPR",
                        Command = "/tpr",
                        Arg = "{playerName}"
                    },
                    new CommandButton
                    {
                        Name = "TRADE",
                        Command = "/trade",
                        Arg = "{playerName}"
                    }
                },
                MenuActivation = new MenuActivation
                {
                    CommandToOpen = "cmenu",
                },
                UIColors = new UIColors
                {
                    Background = new UIColor { HexColor = "#00001F", Opacity = 0.7f },
                    ButtonColor = new UIColor { HexColor = "#00006A", Opacity = 0.7f },
                    TextPanel = new UIColor { HexColor = "#00006A", Opacity = 0.7f },
                    TitlePanel = new UIColor { HexColor = "#0000B2", Opacity = 0.7f },
                    CloseButton = new UIColor { HexColor = "#ce422b", Opacity = 0.7f }
                },
                UISize = new UISize
                {                    
                    X_Position = 0.31f,
                    X_Dimension = 0.685f,
                    Y_Position = 0.2f,
                    Y_Dimension = 0.7f
                }
            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion
                
        #region Messages
        string msg(string key, string playerId = null) => lang.GetMessage(key, this, playerId);
        Dictionary<string, string> Messages = new Dictionary<string, string>()
        {
            {"title", "Clan Administration"},
            {"name", "Name: "},
            {"description", "Description: "},
            {"members", "Members"},
            {"settingsTitle", "CLAN OWNER/COUNCIL SETTINGS"},
            {"ffToggle", "Clan Friendly Fire"},
            {"radarToggle", "Clan Radar"},
            {"allyAdmin", "Alliances Administration"},
            {"allyCount", "Allies ({0}/{1}):"},
            {"ownerTag", "OWN"},
            {"councilTag", "COUN"},
            {"modTag", "MOD"},
            {"promote", "PROMOTE"},
            {"demote", "DEMOTE"},
            {"kick", "KICK"},
            {"allyRetract", "Retract Offer" },
            {"allyDecline", "Decline Offer"},
            {"allyAccept", "Accept Offer" },
            {"allyCancel", "Cancel Alliance"},
            {"memberInvite", "Invite Player"},
            {"cancelInvites", "Cancel Invites" },
            {"manageAlliances", "Manage Alliances" },
            {"memberCancel", "Cancel Invite" },
            {"cmdNoClan", "You are not a member of any active clan" },
            {"on", "<color=#00E500>ON</color>" },
            {"off", "<color=#ce422b>OFF</color>" },
            {"info", "Clans REBORN - Clans v.{clanversion} :: UI v.{uiversion} :: oxide-russia.ru" },
            {"allies", "Allies:" },
            {"alliances", "Alliances" },
            {"allianceSettings", "CLAN ALLIANCES" },
            {"offers", "Offers" },
            {"invites", "Invites" },
            {"offerAlliance", "Offer an Alliance" },
            {"back", "Back" },
            {"allySelect", "Select a clan from the list to offer a alliance with" },
            {"memberSelect", "Select a player from the list to offer a membership to" },
            {"cancelSelect", "Select a pending invitation to cancel" },
            {"disabled", "Disabled" },
            {"leave", "LEAVE" },
            {"disband", "DISBAND" },
            {"confirmDisband", "Click 'confirm' to proceed" },
            {"confirm", "Confirm" }
        };
        #endregion
    }
}


// --- End of file: ClansUI (1).cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/DiscordCore.cs ---
// --- Original Local Path: DiscordCore.cs ---

﻿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Text;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Ext.Discord;
using Oxide.Ext.Discord.Attributes;
using Oxide.Ext.Discord.Builders.MessageComponents;
using Oxide.Ext.Discord.Constants;
using Oxide.Ext.Discord.Entities;
using Oxide.Ext.Discord.Entities.Applications;
using Oxide.Ext.Discord.Entities.Channels;
using Oxide.Ext.Discord.Entities.Emojis;
using Oxide.Ext.Discord.Entities.Gatway;
using Oxide.Ext.Discord.Entities.Gatway.Events;
using Oxide.Ext.Discord.Entities.Guilds;
using Oxide.Ext.Discord.Entities.Interactions;
using Oxide.Ext.Discord.Entities.Interactions.ApplicationCommands;
using Oxide.Ext.Discord.Entities.Interactions.MessageComponents;
using Oxide.Ext.Discord.Entities.Messages;
using Oxide.Ext.Discord.Entities.Users;
using Oxide.Ext.Discord.Extensions;
using Oxide.Ext.Discord.Helpers;
using Oxide.Ext.Discord.Libraries.Command;
using Oxide.Ext.Discord.Libraries.Linking;
using Oxide.Ext.Discord.Logging;
using Random = Oxide.Core.Random;

namespace Oxide.Plugins
{
    [Info("Discord Core", "MJSU", "2.1.3")]
    [Description("Creates a link between a player and discord")]
    internal class DiscordCore : CovalencePlugin, IDiscordLinkPlugin
    {
        #region Class Fields
        [DiscordClient] private DiscordClient _client;
        
        private StoredData _storedData; //Plugin Data
        private PluginConfig _pluginConfig; //Plugin Config
        
        private const string AccentColor = "de8732";
        private const string UsePermission = "discordcore.use";

        private char[] _linkChars;

        private DiscordUser _bot;
        private DiscordGuild _guild;

        private bool _initialized;
        private readonly DiscordSettings _discordSettings = new DiscordSettings
        {
            Intents = GatewayIntents.Guilds | GatewayIntents.GuildMembers | GatewayIntents.GuildMessages | GatewayIntents.DirectMessages
        };

        private readonly Hash<string, BanInfo> _banList = new Hash<string, BanInfo>();
        private readonly List<LinkActivation> _activations = new List<LinkActivation>();
        private readonly List<Snowflake> _allowedCommandChannels = new List<Snowflake>();
        private string _allowedChannelNames;
        private char _cmdPrefix;
        
        private readonly DiscordLink _link = Interface.Oxide.GetLibrary<DiscordLink>();
        private readonly DiscordCommand _dcCommands = Interface.Oxide.GetLibrary<DiscordCommand>();

        private const string AcceptEmoji = "✅";
        private const string DeclineEmoji = "❌";
        private const string LinkAccountsButtonId = nameof(DiscordCore) + "_LinkAccounts";
        private const string MessageLinkAccountsButtonId = nameof(DiscordCore) + "_MLinkAccounts";
        private const string AcceptLinkButtonId = nameof(DiscordCore) + "_AcceptLink";
        private const string DeclineLinkButtonId = nameof(DiscordCore) + "_DeclineLink";
        #endregion

        #region Setup & Loading
        private void Init()
        {
            _storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);

            permission.RegisterPermission(UsePermission, this);

            _linkChars = _pluginConfig.LinkSettings.LinkCodeCharacters.ToCharArray();
            _cmdPrefix = _dcCommands.CommandPrefixes[0];

            _discordSettings.ApiToken = _pluginConfig.ApiKey;
            _discordSettings.LogLevel = _pluginConfig.ExtensionDebugging;
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Loading Default Config");
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            Config.Settings.DefaultValueHandling = DefaultValueHandling.Populate;
            _pluginConfig = AdditionalConfig(Config.ReadObject<PluginConfig>());
            Config.WriteObject(_pluginConfig);
        }

        public PluginConfig AdditionalConfig(PluginConfig config)
        {
            config.LinkSettings = new DiscordLinkingSettings(config.LinkSettings);
            config.WelcomeMessageSettings = new WelcomeMessageSettings(config.WelcomeMessageSettings);
            return config;
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [LangKeys.NoPermission] = "You do not have permission to use this command",
                [LangKeys.ChatFormat] = $"[#BEBEBE][[#{AccentColor}]{Title}[/#]] {{0}}[/#]",
                [LangKeys.DiscordFormat] = $"[{Title}] {{0}}",
                [LangKeys.DiscordCoreOffline] = "Discord Core is not online. Please try again later",
                [LangKeys.Commands.Unknown] = "Unknown Command",
                [LangKeys.GenericError] = "We have encountered an error trying. PLease try again later.",
                [LangKeys.ConsolePlayerNotSupported] = "You cannot use this command from the server console.",
                [LangKeys.Commands.Leave.Errors.NotLinked] = "We were unable to unlink your account as you do not appear to have been linked.",
                
                [LangKeys.Commands.Join.Modes] = "Please select which which mode you would like to use to link with discord.\n" +
                                              $"If you wish to join using a code please type [#{AccentColor}]/{{0}} {{1}} {{2}}[/#]\n" +
                                              "If you wish to join by your discord username or id please type: \n" +
                                              $"[#{AccentColor}]/{{0}} {{1}} {{{{Username}}}}#{{{{Discriminator}}}}[/#]\n" +
                                              $"Or [#{AccentColor}]/{{0}} {{1}} {{{{Discord User ID}}}}[/#]",
                
                [LangKeys.Commands.Join.Errors.AlreadySignedUp] = $"You have already linked your discord and game accounts. If you wish to remove this link type [#{AccentColor}]{{0}}{{1}} {{2}}[/#]",
                [LangKeys.Commands.Join.Errors.UnableToFindUser] = $"Unable to find user '{{0}}' in the {{1}} discord server. Have you joined the {{1}} discord server @ [#{AccentColor}]discord.gg/{{2}}[/#]?",
                [LangKeys.Commands.Join.Errors.FoundMultipleUsers] = "Found multiple users with username '{0}' in the {1} discord server. Please include more of the username and discriminator if possible.",
                [LangKeys.Commands.Join.Errors.UsernameSearchError] = "An error occured while trying to search by username. Please try a different username or try again later.",
                [LangKeys.Commands.Join.Errors.InvalidSyntax] = $"Invalid syntax. Type [#{AccentColor}]{{0}}{{1}} code 123456[/#] where 123456 is the code you got from discord",
                [LangKeys.Commands.Join.Errors.NoPendingActivations] = "There is no link currently in progress with the code '{0}'. Please confirm your code and try again.",
                [LangKeys.Commands.Join.Errors.MustBeUsedDiscord] = "You must complete the link on discord and not through the game server.",
                [LangKeys.Commands.Join.Errors.MustBeUsedServer] = "You must complete the link on the game server and not through discord.",
                //[LangKeys.Commands.Join.Errors.LinkInProgress] = "You already have an existing link in process. Please continue from that link.",
                [LangKeys.Commands.Join.Errors.Banned] = "You have been banned from any more link attempts. You have {0}h {1}m {2}s left on your ban.",
                [LangKeys.Commands.Join.Complete.Info] = $"To complete your activation please use the following command: <color=#{AccentColor}>{{0}}{{1}} {{2}} {{3}}</color>.\n",
                [LangKeys.Commands.Join.Complete.InfoServer] = $"In order to use this command you must be in the <color=#{AccentColor}>{{0}}</color> discord server. You can join @ <color=#{AccentColor}>discord.gg/{{1}}</color>.\n",
                [LangKeys.Commands.Join.Complete.InfoGuildAny] = "This command can be used in any guild channel.\n",
                [LangKeys.Commands.Join.Complete.InfoGuildChannel] = "This command can only used in the following guild channels / categories {0}.\n",
                [LangKeys.Commands.Join.Complete.InfoAlsoDm] = "This command can also be used in a direct message to guild bot {0}",
                [LangKeys.Commands.Join.Complete.InfoDmOnly] = "This command can only be used in a direct message to the guild bot {0}",
                [LangKeys.Commands.Join.Messages.Discord.Accept] = "Accept",
                [LangKeys.Commands.Join.Messages.Discord.Decline] = "Decline",
                [LangKeys.Commands.Join.Messages.Discord.LinkAccounts] = "Link Accounts",
                [LangKeys.Commands.Join.Messages.Discord.Username] = "The player '{0}' is trying to link their game account to this discord.\n" +
                                                                     "If you could like to accept please click on the {1} button.\n" +
                                                                     "If you did not initiate this link please click on the {2} button",
                [LangKeys.Commands.Join.Messages.Chat.UsernameDmSent] = "Our bot {0} has sent you a discord direct message. Please finish your setup there.",
                [LangKeys.Commands.Join.Messages.Discord.CompletedInGame] = $"To complete your activation please use the following command: {DiscordFormatting.Bold("{0}{1} {2} {3}")} in game.",
                [LangKeys.Commands.Join.Messages.Discord.CompleteInGameResponse] = "Please check your DM's for steps on how to complete the link process.",
                [LangKeys.Commands.Join.Messages.Discord.Declined] = "We have successfully declined the link request. We're sorry for the inconvenience.",
                [LangKeys.Commands.Join.Messages.Chat.Declined] = "Your join request was declined by the discord user. Repeated declined attempts will result in a link ban.",
                [LangKeys.Linking.Chat.Linked] = "You have successfully linked with discord user {0}#{1}.",
                [LangKeys.Linking.Discord.Linked] = "You have successfully linked your discord {0}#{1} with in game player {2}",
                [LangKeys.Linking.Chat.Unlinked] = "You have successfully unlinked player {0} with your discord account.",
                [LangKeys.Linking.Discord.Unlinked] = "You have successfully unlinked your discord {0}#{1} with in game player {2}",

                [LangKeys.Notifications.Link] = "Player {0}({1}) has linked with discord {2}({3})",
                [LangKeys.Notifications.Rejoin] = "Player {0}({1}) has rejoined and was linked with discord {2}({3})",
                [LangKeys.Notifications.Unlink] = "Player {0}({1}) has unlinked their discord {2}({3})",

                [LangKeys.Guild.WelcomeMessage] = "Welcome to the {0} discord server.",
                [LangKeys.Guild.WelcomeLinkMessage] = " If you would link to link your account please click on the Link Accounts button below.",
                [LangKeys.Guild.LinkMessage] = "Welcome to the {0} discord server. " +
                                                      "This server supports linking your discord and in game accounts. " +
                                                      "If you would like to begin this process please click on the {1} button below this message.\n" +
                                                      $"{DiscordFormatting.Underline("Note: You must be in game to complete the link.")}",
                
                [LangKeys.Emoji.Accept] = AcceptEmoji,
                [LangKeys.Emoji.Decline] = DeclineEmoji,

                [LangKeys.Commands.ChatHelpText] = $"Allows players to link their player and discord accounts together. Players must first join the {{0}} Discord @ [#{AccentColor}]discord.gg/{{1}}[/#]\n" +
                                          $"Type [#{AccentColor}]/{{2}} {{3}} [/#] to start the link process\n" +
                                          $"Type [#{AccentColor}]/{{2}} {{4}}[/#] to to unlink yourself from discord\n" +
                                          $"Type [#{AccentColor}]/{{2}}[/#] to see this message again",
                
                [LangKeys.Commands.DiscordHelpText] = "Allows players to link their in game player and discord accounts together.\n" + 
                                             "Type {0}{1} {2} to start the link process\n" +
                                             "Type {0}{1} {3} to to unlink yourself from discord\n" +
                                             "Type {0}{1} to see this message again",

                //Commands
                [CommandKeys.ChatCommand] = "dc",
                [CommandKeys.ChatJoinCommand] = "join",
                [CommandKeys.ChatLeaveCommand] = "leave",
                [CommandKeys.ChatJoinCodeCommand] = "code",
                [CommandKeys.DiscordCommand] = "dc",
                [CommandKeys.DiscordJoinCommand] = "join",
                [CommandKeys.DiscordLeaveCommand] = "leave"
            }, this);
        }
        
        private void OnServerInitialized()
        {
            RegisterChatLangCommand(nameof(DiscordCoreChatCommand), CommandKeys.ChatCommand);

            _link.AddLinkPlugin(this);

            if (string.IsNullOrEmpty(_pluginConfig.ApiKey))
            {
                PrintWarning("Please set the Discord Bot Token and reload the plugin");
                return;
            }

            _client.Connect(_discordSettings);
        }
        
        private void OnPluginLoaded(Plugin plugin)
        {
            if (ReferenceEquals(this, plugin))
            {
                return;
            }
            
            DiscordCoreReady(plugin);
        }

        private void Unload()
        {
            Interface.Oxide.CallHook("OnDiscordCoreClose");
            SaveData();
        }
        #endregion
        
        #region Client Connection
        public void DiscordCoreReady(Plugin plugin)
        {
            NextTick(() =>
            {
                if (plugin == null)
                {
                    Interface.CallHook("OnDiscordCoreReady", _client, _bot, _guild);
                }
                else
                {
                    plugin.CallHook("OnDiscordCoreReady", _client, _bot, _guild);
                }
            });
        }
        #endregion

        #region Chat Commands
        private void DiscordCoreChatCommand(IPlayer player, string cmd, string[] args)
        {
            if (!player.HasPermission(UsePermission))
            {
                Chat(player, LangKeys.NoPermission);
                return;
            }

            if (!IsDiscordCoreOnline())
            {
                Chat(player, LangKeys.DiscordCoreOffline);
                return;
            }

            if (args.Length == 0)
            {
                DisplayHelp(player);
                return;
            }

            string option = args[0];
            if (player.IsAdmin && option.Equals("welcome"))
            {
                HandleDebugWelcome(player, args);
                return;
            }
            
            if (player.Id == "server_console")
            {
                Chat(player, LangKeys.ConsolePlayerNotSupported);
                return;
            }
            
            if (option.Equals(Lang(CommandKeys.ChatJoinCommand, player), StringComparison.OrdinalIgnoreCase))
            {
                HandleChatJoin(player, args);
                return;
            }

            if (option.Equals(Lang(CommandKeys.ChatLeaveCommand, player), StringComparison.OrdinalIgnoreCase))
            {
                GuildMember discord = player.GetGuildMember(_guild);
                if (discord != null)
                {
                    HandleLeave(player, discord.User, false, true);
                }
                else
                {
                    Chat(player, LangKeys.Commands.Leave.Errors.NotLinked);
                }

                return;
            }

            if (option.Equals("code", StringComparison.OrdinalIgnoreCase))
            {
                HandleChatCompleteLink(player, args);
                return;
            }

            DisplayHelp(player);
        }

        public void DisplayHelp(IPlayer player)
        {
            Chat(player, LangKeys.Commands.ChatHelpText, GetDiscordServerName(), _pluginConfig.JoinCode, Lang(CommandKeys.ChatCommand, player), Lang(CommandKeys.ChatJoinCommand, player), Lang(CommandKeys.ChatLeaveCommand, player));
        }

        public void HandleChatJoin(IPlayer player, string[] args)
        {
            if (_link.IsLinked(player.Id))
            {
                Chat(player, LangKeys.Commands.Join.Errors.AlreadySignedUp, "/", Lang(CommandKeys.ChatCommand, player), Lang(CommandKeys.ChatLeaveCommand, player));
                return;
            }
            
            // LinkActivation existing = _activations.FirstOrDefault(a => a.Player?.Id == player.Id);
            // if (existing != null)
            // {
            //     Chat(player,LangKeys.Commands.Join.Errors.LinkInProgress);
            //     return;
            // }

            if (args.Length == 1)
            {
                Chat(player, LangKeys.Commands.Join.Modes, Lang(CommandKeys.ChatCommand, player), Lang(CommandKeys.ChatJoinCommand, player), Lang(CommandKeys.ChatJoinCodeCommand, player));
                return;
            }
            
            if (args[1].Equals(Lang(CommandKeys.ChatJoinCodeCommand, player), StringComparison.OrdinalIgnoreCase))
            {
                HandleChatJoinWithCode(player);
            }
            else
            {
                HandleChatJoinWithUserName(player, args[1]);
            }
        }

        public void HandleChatJoinWithCode(IPlayer player)
        {
            string code = GenerateCode();
            _activations.RemoveAll(a => a.Player?.Id == player.Id);
            _activations.Add(new LinkActivation
            {
                Player = player,
                Code = code
            });
            
            StringBuilder message = new StringBuilder();

            message.Append(Lang(LangKeys.Commands.Join.Complete.Info, player,_cmdPrefix, Lang(CommandKeys.DiscordCommand, player), "code", code ));
            message.Append(Lang(LangKeys.Commands.Join.Complete.InfoServer, player, _guild.Name, _pluginConfig.JoinCode));
            
            if (_pluginConfig.LinkSettings.AllowCommandsInGuild)
            {
                if (_allowedCommandChannels.Count == 0)
                {
                    message.Append(Lang(LangKeys.Commands.Join.Complete.InfoGuildAny, player));
                }
                else
                {
                    message.Append(Lang(LangKeys.Commands.Join.Complete.InfoGuildChannel, player, _allowedChannelNames));
                }

                message.Append(Lang(LangKeys.Commands.Join.Complete.InfoAlsoDm, player, _bot.Username));
            }
            else
            {
                message.Append(Lang(LangKeys.Commands.Join.Complete.InfoDmOnly, player, _bot.Username));
            }
            
            Chat(player, message.ToString());
        }

        private void HandleChatJoinWithUserName(IPlayer player, string search)
        {
            if (_banList.ContainsKey(player.Id))
            {
                BanInfo ban = GetPlayerBanInfo(player.Id);
                if (ban.IsBanned())
                {
                    TimeSpan remaining = ban.GetRemainingBan();
                    Chat(player, LangKeys.Commands.Join.Errors.Banned, remaining.Hours, remaining.Minutes, remaining.Seconds);
                    return;
                }
            }

            Snowflake id;
            if (Snowflake.TryParse(search, out id))
            {
                GuildMember member = _guild.Members[id];
                if (member == null)
                {
                    Chat(player, LangKeys.Commands.Join.Errors.UnableToFindUser, search, GetDiscordServerName(), _pluginConfig.JoinCode);
                    return;
                }
                
                HandleChatJoinUser(player, member.User);
                return;
            }
            
            string[] userInfo = search.Split('#');
            string userName = userInfo[0];
            string discriminator = userInfo.Length > 1 ? userInfo[1] : null;

            _guild.SearchGuildMembers(_client, userInfo[0], 1000, members =>
            {
                HandleChatJoinUserResults(player, members, userName, discriminator);
            }, error =>
            {
                player.Message(Lang(LangKeys.Commands.Join.Errors.UsernameSearchError, player));
            });
        }

        private void HandleChatJoinUserResults(IPlayer player, List<GuildMember> members, string userName, string discriminator)
        {
            string fullSearch = userName;
            if (!string.IsNullOrEmpty(discriminator))
            {
                fullSearch += $"#{discriminator}";
            }
            
            if (members.Count == 0)
            {
                Chat(player, LangKeys.Commands.Join.Errors.UnableToFindUser, fullSearch, GetDiscordServerName(), _pluginConfig.JoinCode);
                return;
            }
            
            DiscordUser user = null;

            int count = 0;
            foreach (GuildMember member in members)
            {
                DiscordUser searchUser = member.User;
                if (discriminator == null)
                {
                    if (searchUser.Username.StartsWith(userName, StringComparison.OrdinalIgnoreCase))
                    {
                        user = searchUser;
                        count++;
                        if (count > 1)
                        {
                            break;
                        }
                    }
                }
                else if (searchUser.Username.Equals(userName, StringComparison.OrdinalIgnoreCase) && searchUser.Discriminator.Equals(discriminator))
                {
                    user = searchUser;
                    break;
                }
            }

            if (user == null || count > 1)
            {
                Chat(player, LangKeys.Commands.Join.Errors.FoundMultipleUsers, userName, GetDiscordServerName());
                return;
            }
            
            HandleChatJoinUser(player, user);
        }

        private void HandleChatJoinUser(IPlayer player, DiscordUser user)
        {
            MessageComponentBuilder builder = new MessageComponentBuilder();
            builder.AddActionButton(ButtonStyle.Success, Lang(LangKeys.Commands.Join.Messages.Discord.Accept, player), AcceptLinkButtonId, false, DiscordEmoji.FromCharacter(Lang(LangKeys.Emoji.Accept, player)));
            builder.AddActionButton(ButtonStyle.Danger, Lang(LangKeys.Commands.Join.Messages.Discord.Decline, player), DeclineLinkButtonId, false, DiscordEmoji.FromCharacter(Lang(LangKeys.Emoji.Decline, player)));
            
            MessageCreate create = new MessageCreate
            {
                Content = GetDiscordFormattedMessage(LangKeys.Commands.Join.Messages.Discord.Username, player, player.Name, Lang(LangKeys.Commands.Join.Messages.Discord.Accept, player), Lang(LangKeys.Commands.Join.Messages.Discord.Decline, player)),
                Components = builder.Build()
            };

            user.SendDirectMessage(_client, create, message =>
            {
                _activations.RemoveAll(a => a?.Discord.Id == user.Id);
                _activations.Add(new LinkActivation
                {
                    Player = player,
                    Discord = user,
                    Channel = message.ChannelId
                });
                
                Chat(player, LangKeys.Commands.Join.Messages.Chat.UsernameDmSent, _bot.Username);
            }, error =>
            {
                Chat(player, LangKeys.GenericError);
            });
        }

        public void HandleChatCompleteLink(IPlayer player, string[] args)
        {
            if (_link.IsLinked(player.Id))
            {
                Chat(player, Lang(LangKeys.Commands.Join.Errors.AlreadySignedUp, player,  "/", Lang(CommandKeys.ChatCommand, player), Lang(CommandKeys.ChatLeaveCommand, player)));
                return;
            }

            if (args.Length < 2)
            {
                Chat(player, Lang(LangKeys.Commands.Join.Errors.InvalidSyntax, player, "/", Lang(CommandKeys.ChatCommand, player)));
                return;
            }

            LinkActivation act = _activations.FirstOrDefault(a => a.Code == args[1]);
            if (act == null)
            {
                Chat(player, Lang(LangKeys.Commands.Join.Errors.NoPendingActivations, player, args[1]));
                return;
            }

            if (act.Discord == null)
            {
                Chat(player, Lang(LangKeys.Commands.Join.Errors.MustBeUsedDiscord));
                return;
            }

            act.Player = player;

            CompletedLink(act);
        }
        
        private void HandleDebugWelcome(IPlayer player, string[] args)
        {
            if (args.Length < 2)
            {
                Chat(player, "Invalid Syntax. Ex: /dc welcome {{discordId}}");
                return;
            }

            Snowflake userId;
            if (!Snowflake.TryParse(args[1], out userId))
            {
                Chat(player, "Discord ID is not a valid snowflake");
                return;
            }
            
            SendWelcomeMessage(userId);
            Chat(player, $"Welcome message send to {args[1]}");
        }
        #endregion
        
        #region Discord Commands
        private void DiscordCoreMessageCommand(DiscordMessage message, string cmd, string[] args)
        {
            IPlayer player = message.Author.Player;
            if (args.Length == 0)
            {
                DisplayDiscordHelp(message, player);
                return;
            }
            
            string option = args[0];
            if (option.Equals(Lang(CommandKeys.DiscordJoinCommand,player), StringComparison.OrdinalIgnoreCase))
            {
                HandleDiscordJoin(message, player);
                return;
            }

            if (option.Equals(Lang(CommandKeys.DiscordLeaveCommand, player), StringComparison.OrdinalIgnoreCase))
            {
                if (player != null)
                {
                    HandleLeave(player, message.Author, false, true);
                }
                else
                {
                    message.Reply(_client, GetDiscordFormattedMessage(LangKeys.Commands.Leave.Errors.NotLinked));
                }

                return;
            }

            if (option.Equals("code", StringComparison.OrdinalIgnoreCase))
            {
                HandleDiscordCompleteLink(message, args);
                return;
            }

            DisplayDiscordHelp(message, player);
        }

        public void DisplayDiscordHelp(DiscordMessage message, IPlayer player)
        {
            message.Reply(_client, GetDiscordFormattedMessage(LangKeys.Commands.DiscordHelpText, player, _cmdPrefix, Lang(CommandKeys.DiscordCommand, player), Lang(CommandKeys.DiscordJoinCommand, player), Lang(CommandKeys.DiscordLeaveCommand, player)));
        }
        
        public void HandleDiscordJoin(DiscordMessage message, IPlayer player)
        {
            if (player != null)
            {
                message.Reply(_client, GetDiscordFormattedMessage(LangKeys.Commands.Join.Errors.AlreadySignedUp, player, _cmdPrefix, Lang(CommandKeys.DiscordCommand, player), Lang(CommandKeys.DiscordLeaveCommand, player)));
                return;
            }

            // LinkActivation existing = _activations.FirstOrDefault(a => a.Discord?.Id == message.Author.Id);
            // if (existing != null)
            // {
            //     message.Reply(_client, GetDiscordFormattedMessage(LangKeys.Commands.Join.Errors.LinkInProgress));
            //     return;
            // }

            string code = GenerateCode();
            _activations.RemoveAll(a => a.Discord?.Id == message.Author.Id);
            _activations.Add(new LinkActivation
            {
                Discord = message.Author,
                Code = code
            });

            string linkMessage = GetDiscordFormattedMessage(LangKeys.Commands.Join.Messages.Discord.CompletedInGame, null, "/", Lang(CommandKeys.ChatCommand), "code", code);
            if (message.GuildId.HasValue)
            {
                message.Author.SendDirectMessage(_client, linkMessage);
                message.Reply(_client, GetDiscordFormattedMessage(LangKeys.Commands.Join.Messages.Discord.CompleteInGameResponse));
            }
            else
            {
                message.Reply(_client, linkMessage);
            }
        }
        
        public void HandleDiscordCompleteLink(DiscordMessage message, string[] args)
        {
            if (args.Length < 2)
            {
                message.Reply(_client, GetDiscordFormattedMessage(LangKeys.Commands.Join.Errors.InvalidSyntax, null, _cmdPrefix, Lang(CommandKeys.DiscordCommand), "code"));
                return;
            }

            LinkActivation act = _activations.FirstOrDefault(a => a.Code.Equals(args[1], StringComparison.OrdinalIgnoreCase));
            if (act == null)
            {
                message.Reply(_client, GetDiscordFormattedMessage(LangKeys.Commands.Join.Errors.NoPendingActivations, null, args[1]));
                return;
            }

            if (act.Player == null)
            {
                message.Reply(_client, GetDiscordFormattedMessage(LangKeys.Commands.Join.Errors.MustBeUsedServer));
                return;
            }

            act.Discord = message.Author;
            
            CompletedLink(act);
        }
        #endregion
        
        #region Discord Hooks
        [HookMethod(DiscordExtHooks.OnDiscordGatewayReady)]
        private void OnDiscordGatewayReady(GatewayReadyEvent ready)
        {
            try
            {
                if (ready.Guilds.Count == 0)
                {
                    PrintError("Your bot was not found in any discord servers. Please invite it to a server and reload the plugin.");
                    return;
                }

                DiscordGuild guild = null;
                if (ready.Guilds.Count == 1 && !_pluginConfig.GuildId.IsValid())
                {
                    guild = ready.Guilds.Values.FirstOrDefault();
                }

                if (guild == null)
                {
                    guild = ready.Guilds[_pluginConfig.GuildId];
                    if (guild == null)
                    {
                        PrintError("Failed to find a matching guild for the Discord Server Id. " +
                                   "Please make sure your guild Id is correct and the bot is in the discord server.");
                        return;
                    }
                }
                
                DiscordApplication app = _client.Bot.Application;
                if (!app.HasApplicationFlag(ApplicationFlags.GatewayGuildMembersLimited) && !app.HasApplicationFlag(ApplicationFlags.GatewayGuildMembers))
                {
                    PrintError($"You need to enable \"Server Members Intent\" for {_client.Bot.BotUser.Username} @ https://discord.com/developers/applications\n" +
                               $"{Name} will not function correctly until that is fixed. Once updated please reload {Name}.");
                    return;
                }
                
                if (!app.HasApplicationFlag(ApplicationFlags.GatewayMessageContentLimited))
                {
                    PrintWarning($"You will need to enable \"Message Content Intent\" for {_client.Bot.BotUser.Username} @ https://discord.com/developers/applications\n by April 2022" +
                               $"{Name} will stop function correctly after that date until that is fixed.");
                }
                
                _bot = ready.User;
                _guild = guild;
                Puts($"Connected to bot: {_bot.Username}");
            }
            catch (Exception ex)
            {
                PrintError($"Failed to load DiscordCore: {ex}");
            }
        }

        [HookMethod(DiscordExtHooks.OnDiscordGuildMembersLoaded)]
        private void OnDiscordGuildMembersLoaded(DiscordGuild guild)
        {
            if (guild.Id != _guild.Id)
            {
                return;
            }
            
            try
            {
                _guild = guild;
                Puts($"Discord connected to server: {GetDiscordServerName()}");

                if (!_initialized)
                {
                    _initialized = true;
                }
                
                Puts($"Loaded {_guild.Members.Count} Discord Members");

                HandleLeaveRejoin();
                SetupGuildLinkMessage();

                List<string> allowedCommandChannelNames = new List<string>();
                foreach (Snowflake id in _pluginConfig.LinkSettings.AllowCommandInChannels)
                {
                    DiscordChannel channel = _guild.Channels[id];
                    if (channel != null)
                    {
                        _allowedCommandChannels.Add(channel.Id);
                        allowedCommandChannelNames.Add(channel.Name);
                    }
                }

                _allowedChannelNames = string.Join(", ", allowedCommandChannelNames.ToArray());
                
                RegisterDiscordLangCommand(nameof(DiscordCoreMessageCommand), CommandKeys.DiscordCommand, true, _pluginConfig.LinkSettings.AllowCommandsInGuild, _allowedCommandChannels);
                
                DiscordCoreReady(null);
                Puts($"{Title} Ready");
            }
            catch (Exception ex)
            {
                PrintError($"Failed to connect to guild: {ex}");
            }
        }

        [HookMethod(DiscordExtHooks.OnDiscordGuildMemberAdded)]
        private void OnDiscordGuildMemberAdded(GuildMember member)
        {
            bool rejoined = false;
            if (_pluginConfig.LinkSettings.AutoRelinkPlayer)
            {
                rejoined = HandleRejoin(member.User);
            }

            if (_pluginConfig.WelcomeMessageSettings.EnableJoinMessage && !rejoined)
            {
                SendWelcomeMessage(member.Id);
            }
        }

        private void SendWelcomeMessage(Snowflake discordId)
        {
            MessageCreate create = new MessageCreate
            {
                Content = Lang(LangKeys.Guild.WelcomeMessage, null, GetDiscordServerName())
            };

            if (_pluginConfig.WelcomeMessageSettings.EnableLinkButton)
            {
                create.Content += Lang(LangKeys.Guild.WelcomeLinkMessage);
                MessageComponentBuilder builder = new MessageComponentBuilder();
                builder.AddActionButton(ButtonStyle.Success, Lang(LangKeys.Commands.Join.Messages.Discord.LinkAccounts), MessageLinkAccountsButtonId, false, DiscordEmoji.FromCharacter(Lang(LangKeys.Emoji.Accept)));
                create.Components = builder.Build();
            }

            DiscordUser.CreateDirectMessageChannel(_client, discordId, channel => {channel.CreateMessage(_client, create);});
        }

        [HookMethod(DiscordExtHooks.OnDiscordGuildMemberRemoved)]
        private void OnDiscordGuildMemberRemoved(GuildMember member)
        {
            if (member?.User == null)
            {
                return;
            }

            IPlayer player = _link.GetPlayer(member.User.Id);
            if (player == null)
            {
                return;
            }

            HandleLeave(player, member.User, true, false);
        }
        #endregion

        #region Link Message Handling
        [HookMethod(DiscordExtHooks.OnDiscordInteractionCreated)]
        private void OnDiscordInteractionCreated(DiscordInteraction interaction)
        {
            if (interaction.Type != InteractionType.MessageComponent)
            {
                return;
            }
            
            if (!interaction.Data.ComponentType.HasValue || interaction.Data.ComponentType.Value != MessageComponentType.Button)
            {
                return;
            }
            
            DiscordUser user = interaction.User ?? interaction.Member?.User;
            switch (interaction.Data.CustomId)
            {
                case LinkAccountsButtonId:
                    HandleLinkAccountsButton(interaction, true);
                    break;
                
                case MessageLinkAccountsButtonId:
                    HandleLinkAccountsButton(interaction, false);
                    break;
                
                case AcceptLinkButtonId:
                    HandleAcceptLinkButton(interaction, user);
                    break;
                
                case DeclineLinkButtonId:
                    HandleDeclineLinkButton(interaction, user);
                    break;
            }
        }

        public void HandleLinkAccountsButton(DiscordInteraction interaction, bool ephemeral)
        {
            MessageFlags flags = ephemeral ? MessageFlags.Ephemeral : MessageFlags.None;
            
            DiscordUser member = interaction.Member?.User ?? interaction.User;
            IPlayer player = member.Player;
            if (player != null)
            {
                interaction.CreateInteractionResponse(_client, new InteractionResponse
                {
                    Type = InteractionResponseType.ChannelMessageWithSource,
                    Data = new InteractionCallbackData
                    {
                        Content = GetDiscordFormattedMessage(LangKeys.Commands.Join.Errors.AlreadySignedUp, player, _cmdPrefix, Lang(CommandKeys.DiscordCommand, player), Lang(CommandKeys.DiscordLeaveCommand, player)),
                        Flags = flags
                    }
                });
                return;
            }
            
            string code = GenerateCode();
            _activations.RemoveAll(a => a.Discord?.Id == member.Id);
            _activations.Add(new LinkActivation
            {
                Discord = member,
                Code = code
            });
                    
            string linkMessage = GetDiscordFormattedMessage(LangKeys.Commands.Join.Messages.Discord.CompletedInGame, null, "/", Lang(CommandKeys.ChatCommand), "code", code);
            interaction.CreateInteractionResponse(_client, new InteractionResponse
            {
                Type = InteractionResponseType.ChannelMessageWithSource,
                Data = new InteractionCallbackData
                {
                    Content = linkMessage,
                    Flags = flags
                }
            });
        }
        
        private void HandleAcceptLinkButton(DiscordInteraction interaction, DiscordUser user)
        {
            interaction.CreateInteractionResponse(_client, new InteractionResponse
            {
                Type = InteractionResponseType.DeferredUpdateMessage
            });

            LinkActivation act = _activations.FirstOrDefault(a => a.Discord?.Id == user.Id && a.Player != null);
            if (act == null)
            {
                return;
            }
            
            CompletedLink(act);
        }
        
        private void HandleDeclineLinkButton(DiscordInteraction interaction, DiscordUser user)
        {
            interaction.CreateInteractionResponse(_client, new InteractionResponse
            {
                Type = InteractionResponseType.DeferredUpdateMessage
            });

            LinkActivation act = _activations.FirstOrDefault(a => a.Discord?.Id == user.Id);
            if (act != null)
            {
                _activations.Remove(act);
                interaction.CreateFollowUpMessage(_client, new CommandFollowupCreate
                {
                    Content = GetDiscordFormattedMessage(LangKeys.Commands.Join.Messages.Discord.Declined)
                });
                Chat(act.Player, LangKeys.Commands.Join.Messages.Chat.Declined);
                LinkBanSettings banSettings = _pluginConfig.LinkSettings.LinkBanSettings;
                if (banSettings.EnableLinkBanning)
                {
                    BanInfo ban = GetPlayerBanInfo(act.Player.Id);
                    ban.AddDeclined(banSettings.BanDeclineAmount, banSettings.BanDuration);
                }
            }
        }
        
        public void SetupGuildLinkMessage()
        {
            DiscordLinkingSettings link = _pluginConfig.LinkSettings;
            LinkMessageSettings settings = link.LinkMessageSettings;
            if (!settings.Enabled)
            {
                return;
            }
            
            if (!settings.ChannelId.IsValid())
            {
                PrintWarning("Link message is enabled but link message channel ID is not valid");
                return;
            }

            DiscordChannel channel = _guild.Channels[settings.ChannelId];
            if (channel == null)
            {
                PrintWarning($"Link message failed to find channel with ID {settings.ChannelId}");
                return;
            }

            string content = Lang(LangKeys.Guild.LinkMessage, null, GetDiscordServerName(), "Link Accounts");
                
            if (_storedData.MessageData == null)
            {
                MessageCreate message = CreateGuildLinkMessage(content);
                channel.CreateMessage(_client, message, SaveGuildLinkMessageInfo);
            }
            else
            {
                channel.GetChannelMessage(_client, _storedData.MessageData.MessageId, message =>
                    {
                        message.Content = content;
                        message.Components.Clear();
                        message.Components = CreateGuildLinkActions();
                        message.EditMessage(_client);
                    }, 
                    error =>
                    {
                        if (error.HttpStatusCode == 404)
                        {
                            PrintWarning("The previous link message has been removed. Recreating the message.");
                            MessageCreate message = CreateGuildLinkMessage(content);
                            channel.CreateMessage(_client, message, SaveGuildLinkMessageInfo);
                        }
                    });
            }
        }

        public MessageCreate CreateGuildLinkMessage(string content)
        {
            MessageCreate message = new MessageCreate
            {
                Content = content,
                Components = CreateGuildLinkActions()
            };
            
            return message;
        }

        public List<ActionRowComponent> CreateGuildLinkActions()
        {
            MessageComponentBuilder builder = new MessageComponentBuilder();
            builder.AddActionButton(ButtonStyle.Success, Lang(LangKeys.Commands.Join.Messages.Discord.LinkAccounts), LinkAccountsButtonId, false, DiscordEmoji.FromCharacter(Lang(LangKeys.Emoji.Accept)));

            return builder.Build();
        }

        public void SaveGuildLinkMessageInfo(DiscordMessage message)
        {
            _storedData.MessageData = new LinkMessageData
            {
                ChannelId = message.ChannelId,
                MessageId = message.Id
            };
            
            SaveData();
        }
        #endregion

        #region Linking
        public void CompletedLink(LinkActivation activation)
        {
            IPlayer player = activation.Player;
            DiscordUser user = activation.Discord;
            
            _storedData.PlayerDiscordInfo[player.Id] = new DiscordInfo
            {
                PlayerId = player.Id,
                DiscordId = user.Id
            };
            
            _activations.Remove(activation);
            
            Chat(player, LangKeys.Linking.Chat.Linked, user.Username, user.Discriminator);
            activation.Discord.SendDirectMessage(_client, GetDiscordFormattedMessage(LangKeys.Linking.Discord.Linked, player, user.Username, user.Discriminator, player.Name));
            
            Snowflake channelId = _pluginConfig.LinkSettings.AnnouncementChannel;
            if (channelId.IsValid())
            {
                DiscordChannel channel = _guild.Channels[channelId];
                channel.CreateMessage(_client, Lang(LangKeys.Notifications.Link, null, player.Name, player.Id, user.Username, user.Id));
            }
            
            _link.OnLinked(this, activation.Player, activation.Discord);
            SaveData();
        }
        
        public void HandleLeave(IPlayer player, DiscordUser user, bool backup, bool message)
        {
            if (backup)
            {
                _storedData.LeftPlayerInfo[user.Id] = _storedData.PlayerDiscordInfo[player.Id];
            }
            
            _storedData.PlayerDiscordInfo.Remove(player.Id);

            if (!backup)
            {
                Chat(player, LangKeys.Linking.Chat.Unlinked, player.Name);
                if (message)
                {
                    user.SendDirectMessage(_client,  GetDiscordFormattedMessage(LangKeys.Linking.Discord.Unlinked, player, user.Username, user.Discriminator, player.Name));
                }
            }

            _link.OnUnlinked(this, player, user);

            Snowflake channelId = _pluginConfig.LinkSettings.AnnouncementChannel;
            if (channelId.IsValid())
            {
                DiscordChannel channel = _guild.Channels[channelId];
                if (message)
                {
                    channel.CreateMessage(_client, Lang(LangKeys.Notifications.Unlink, null, player.Name, player.Id, user.Username, user.Id));
                }
            }

            SaveData();
        }

        public bool HandleRejoin(DiscordUser user)
        {
            DiscordInfo existing = _storedData.LeftPlayerInfo[user.Id];
            if (existing == null)
            {
                return false;
            }

            _storedData.PlayerDiscordInfo[existing.PlayerId] = existing;
            _storedData.LeftPlayerInfo.Remove(user.Id);

            IPlayer player = players.FindPlayerById(existing.PlayerId);
            
            _link.OnLinked(this, player, user);

            Snowflake channelId = _pluginConfig.LinkSettings.AnnouncementChannel;
            if (channelId.IsValid())
            {
                DiscordChannel channel = _guild.Channels[channelId];
                channel.CreateMessage(_client, Lang(LangKeys.Notifications.Rejoin, null, player.Name, player.Id, user.Username, user.Id));
            }
            
            SaveData();
            return true;
        }

        public void HandleLeaveRejoin()
        {
            foreach (DiscordInfo info in _storedData.PlayerDiscordInfo.Values.ToList())
            {
                if (!_guild.Members.ContainsKey(info.DiscordId))
                {
                    IPlayer player = players.FindPlayerById(info.PlayerId);
                    if (player != null)
                    {
                        DiscordUser user = player.GetDiscordUser();
                        HandleLeave(player, user, _pluginConfig.LinkSettings.AutoRelinkPlayer, false);
                        Puts($"Player {player.Name}({player.Id}) Discord {user.Id} is no longer in the guild and has been unlinked.");
                    }
                }
            }
            
            if (_pluginConfig.LinkSettings.AutoRelinkPlayer)
            {
                foreach (DiscordInfo info in _storedData.LeftPlayerInfo.Values.ToList())
                {
                    GuildMember member = _guild.Members[info.DiscordId];
                    if (member != null)
                    {
                        HandleRejoin(member.User);
                    }
                }
            }
        }
        #endregion

        #region Discord Link
        public IDictionary<string, Snowflake> GetSteamToDiscordIds()
        {
            Hash<string, Snowflake> data = new Hash<string, Snowflake>();
            foreach (DiscordInfo info in _storedData.PlayerDiscordInfo.Values)
            {
                data[info.PlayerId] = info.DiscordId;
            }

            return data;
        }
        #endregion
        
        #region API
        [HookMethod(nameof(GetDiscordServerName))]
        public string GetDiscordServerName()
        {
            if (!string.IsNullOrEmpty(_pluginConfig.ServerNameOverride))
            {
                return _pluginConfig.ServerNameOverride;
            }

            return _guild?.Name ?? "Not Connected";
        }
        #endregion

        #region Discord Helpers
        public string GetDiscordFormattedMessage(string key, IPlayer player = null, params object[] args)
        {
            return Formatter.ToPlaintext(Lang(LangKeys.DiscordFormat, player, Lang(key, player, args)));
        }

        private bool IsDiscordCoreOnline() => _initialized && _guild != null;
        #endregion
        
        #region Helper Methods
        public string GenerateCode()
        {
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < _pluginConfig.LinkSettings.LinkCodeLength; i++)
            {
                sb.Append(_linkChars[Random.Range(0, _pluginConfig.LinkSettings.LinkCodeLength)]);
            }

            return sb.ToString();
        }

        public BanInfo GetPlayerBanInfo(string id)
        {
            BanInfo info = _banList[id];
            if (info == null)
            {
                info = new BanInfo();
                _banList[id] = info;
            }

            return info;
        }

        public void SaveData()
        {
            if (_storedData != null)
            {
                Interface.Oxide.DataFileSystem.WriteObject(Name, _storedData);
            }
        } 

        public void Chat(IPlayer player, string key, params object[] args)
        {
            if (player.IsConnected)
            {
                player.Reply(Lang(LangKeys.ChatFormat, player, Lang(key, player, args)));
            }
        } 

        public string Lang(string key, IPlayer player = null, params object[] args)
        {
            try
            {
                return string.Format(lang.GetMessage(key, this, player?.Id), args);
            }
            catch(Exception ex)
            {
                PrintError($"Lang Key '{key}' threw exception\n:{ex}");
                throw;
            }
        }

        public void RegisterChatLangCommand(string command, string langKey)
        {
            foreach (string langType in lang.GetLanguages(this))
            {
                Dictionary<string, string> langKeys = lang.GetMessages(langType, this);
                string commandValue;
                if (langKeys.TryGetValue(langKey, out commandValue) && !string.IsNullOrEmpty(commandValue))
                {
                    AddCovalenceCommand(commandValue, command);
                }
            }
        }

        /// <summary>
        /// Registers commands with discord using lang keys
        /// </summary>
        /// <param name="command">Name of the method to use in callback</param>
        /// <param name="langKey">The name of the lang key dictionary</param>
        /// <param name="direct">Should we register this command for direct messages</param>
        /// <param name="guild">Should we register this command for guilds</param>
        /// <param name="allowedChannels">If registering guilds the allowed channels / categories this command can be used in</param>
        public void RegisterDiscordLangCommand(string command, string langKey, bool direct, bool guild, List<Snowflake> allowedChannels)
        {
            if (direct)
            {
                _dcCommands.AddDirectMessageLocalizedCommand(langKey, this, command);
            }

            if (guild)
            {
                _dcCommands.AddGuildLocalizedCommand(langKey, this, allowedChannels, command);
            }
        }
        #endregion

        #region Classes
        public class PluginConfig
        {
            [DefaultValue("")]
            [JsonProperty(PropertyName = "Discord Bot Token")]
            public string ApiKey { get; set; }
            
            [JsonProperty(PropertyName = "Discord Server ID (Optional if bot only in 1 guild)")]
            public Snowflake GuildId { get; set; }

            [DefaultValue("")]
            [JsonProperty(PropertyName = "Discord Server Name Override")]
            public string ServerNameOverride { get; set; }
            
            [DefaultValue("")]
            [JsonProperty(PropertyName = "Discord Server Join Code")]
            public string JoinCode { get; set; }

            [JsonProperty(PropertyName = "Welcome Message Settings")]
            public WelcomeMessageSettings WelcomeMessageSettings { get; set; }
            
            [JsonProperty(PropertyName = "Link Settings")]
            public DiscordLinkingSettings LinkSettings { get; set; }

            [JsonConverter(typeof(StringEnumConverter))]
            [DefaultValue(DiscordLogLevel.Info)]
            [JsonProperty(PropertyName = "Discord Extension Log Level (Verbose, Debug, Info, Warning, Error, Exception, Off)")]
            public DiscordLogLevel ExtensionDebugging { get; set; }
        }

        public class DiscordLinkingSettings
        {
            [JsonProperty(PropertyName = "Link Code Generator Characters")]
            public string LinkCodeCharacters { get; set; }

            [JsonProperty(PropertyName = "Link Code Length")]
            public int LinkCodeLength { get; set; }
            
            [JsonProperty(PropertyName = "Automatically Relink A Player If They Leave And Rejoin The Discord Server")]
            public bool AutoRelinkPlayer { get; set; }
            
            [JsonProperty(PropertyName = "Allow Commands To Be Used In Guild Channels")]
            public bool AllowCommandsInGuild { get; set; }
            
            [JsonProperty(PropertyName = "Allow Guild Commands Only In The Following Guild Channel Or Category (Channel ID Or Category ID)")]
            public List<Snowflake> AllowCommandInChannels { get; set; }

            [JsonProperty(PropertyName = "Link / Unlink Announcement Channel Id")]
            public Snowflake AnnouncementChannel { get; set; }

            [JsonProperty(PropertyName = "Guild Link Message Settings")]
            public LinkMessageSettings LinkMessageSettings { get; set; }
            
            [JsonProperty(PropertyName = "Link Ban Settings")]
            public LinkBanSettings LinkBanSettings { get; set; }

            public DiscordLinkingSettings(DiscordLinkingSettings settings)
            {
                LinkCodeCharacters = settings?.LinkCodeCharacters ?? "123456789";
                LinkCodeLength = settings?.LinkCodeLength ?? 6;
                AutoRelinkPlayer = settings?.AutoRelinkPlayer ?? true;
                AllowCommandsInGuild = settings?.AllowCommandsInGuild ?? false;
                AllowCommandInChannels = settings?.AllowCommandInChannels ?? new List<Snowflake>();
                AnnouncementChannel = settings?.AnnouncementChannel ?? default(Snowflake);
                LinkMessageSettings = new LinkMessageSettings(settings?.LinkMessageSettings);
                LinkBanSettings = new LinkBanSettings(settings?.LinkBanSettings);
            }
        }

        public class WelcomeMessageSettings
        {
            [JsonProperty(PropertyName = "Enable Discord Server Welcome DM Message")]
            public bool EnableJoinMessage { get; set; }
            
            [JsonProperty(PropertyName = "Add Link Accounts Button In Welcome Message")]
            public bool EnableLinkButton { get; set; }

            public WelcomeMessageSettings(WelcomeMessageSettings settings)
            {
                EnableJoinMessage = settings?.EnableJoinMessage ?? true;
                EnableLinkButton = settings?.EnableLinkButton ?? true;
            }
        }

        public class LinkMessageSettings
        {
            [JsonProperty(PropertyName = "Enable Guild Link Message")]
            public bool Enabled { get; set; }
            
            [JsonProperty(PropertyName = "Message Channel ID")]
            public Snowflake ChannelId { get; set; }

            public LinkMessageSettings(LinkMessageSettings settings)
            {
                Enabled = settings?.Enabled ?? false;
                ChannelId = settings?.ChannelId ?? default(Snowflake);
            }
        }

        public class LinkBanSettings
        {
            [JsonProperty(PropertyName = "Enable Link Ban")]
            public bool EnableLinkBanning { get; set; }
            
            [JsonProperty(PropertyName = "Ban Link After X Join Declines")]
            public int BanDeclineAmount { get; set; }
            
            [JsonProperty(PropertyName = "Ban Duration (Hours)")]
            public int BanDuration { get; set; }

            public LinkBanSettings(LinkBanSettings settings)
            {
                EnableLinkBanning = settings?.EnableLinkBanning ?? true;
                BanDeclineAmount = settings?.BanDeclineAmount ?? 3;
                BanDuration = settings?.BanDuration ?? 24;
            }
        }

        public class StoredData
        {
            public Hash<string, DiscordInfo> PlayerDiscordInfo = new Hash<string, DiscordInfo>();
            public Hash<Snowflake, DiscordInfo> LeftPlayerInfo = new Hash<Snowflake, DiscordInfo>();
            public LinkMessageData MessageData;
        }

        public class DiscordInfo
        {
            public Snowflake DiscordId { get; set; }
            public string PlayerId { get; set; }
        }

        public class LinkActivation
        {
            public IPlayer Player { get; set; }
            public DiscordUser Discord { get; set; }
            public string Code { get; set; }
            public Snowflake Channel { get; set; }
        }

        public class LinkMessageData
        {
            public Snowflake ChannelId { get; set; }
            public Snowflake MessageId { get; set; }
        }
        
        public class BanInfo
        {
            public int Times { get; set; }
            public DateTime BannedUntil { get; set; }

            public void AddDeclined(int timesBeforeBanned, float banDuration)
            {
                Times++;
                if (Times >= timesBeforeBanned)
                {
                    BannedUntil = DateTime.Now + TimeSpan.FromHours(banDuration);
                    Times = 0;
                }
            }

            public bool IsBanned()
            {
                return BannedUntil > DateTime.Now;
            }

            public TimeSpan GetRemainingBan()
            {
                return BannedUntil - DateTime.Now;
            }
        }

        public static class LangKeys
        {
            public const string NoPermission = nameof(NoPermission);
            public const string ChatFormat = nameof(ChatFormat);
            public const string DiscordFormat = nameof(DiscordFormat);
            public const string DiscordCoreOffline = nameof(DiscordCoreOffline);
            public const string GenericError = nameof(GenericError);
            public const string ConsolePlayerNotSupported = nameof(ConsolePlayerNotSupported);
            
            public static class Commands
            {
                private const string Base = nameof(Commands) + ".";
                
                public const string Unknown = Base + nameof(Unknown);
                
                public const string ChatHelpText = nameof(ChatHelpText);
                public const string DiscordHelpText = nameof(DiscordHelpText);

                public static class Leave
                {
                    private const string Base = Commands.Base + nameof(Leave);

                    public static class Errors
                    {
                        private const string Base = Leave.Base + nameof(Errors);

                        public const string NotLinked = Base + nameof(NotLinked);
                    }
                }

                public static class Join
                {
                    private const string Base = Commands.Base + nameof(Join) + ".";
                    
                    public const string Modes = Base + nameof(Modes) + "V1";

                    public static class Messages
                    {
                        private const string Base = Join.Base  + nameof(Messages) + ".";

                        public static class Discord
                        {
                            private const string Base = Messages.Base + nameof(Discord) + ".";
                            
                            public const string Username = Base + nameof(Username);
                            public const string CompletedInGame = Base + nameof(CompletedInGame);
                            public const string CompleteInGameResponse = Base + nameof(CompleteInGameResponse);
                            public const string Declined = Base + nameof(Declined);
                            public const string Accept = Base + nameof(Accept);
                            public const string Decline = Base + nameof(Decline);
                            public const string LinkAccounts = Base + nameof(LinkAccounts);
                        }
                        
                        public static class Chat
                        {
                            private const string Base = Messages.Base + nameof(Chat) + ".";
                            
                            public const string UsernameDmSent = Base + nameof(UsernameDmSent);
                            public const string Declined = Base + nameof(Declined);
                        }
                    }
                    
                    public static class Complete
                    {
                        private const string Base = Join.Base + nameof(Complete) + ".";
                        
                        public const string Info = Base + nameof(Info);
                        public const string InfoServer = Base + nameof(InfoServer);
                        public const string InfoGuildAny = Base + nameof(InfoGuildAny);
                        public const string InfoGuildChannel = Base + nameof(InfoGuildChannel);
                        public const string InfoAlsoDm = Base + nameof(InfoAlsoDm);
                        public const string InfoDmOnly = Base + nameof(InfoDmOnly);
                    }

                    public static class Errors
                    {
                        private const string Base = Join.Base + nameof(Errors) + ".";
                        
                        public const string AlreadySignedUp = Base + nameof(AlreadySignedUp);
                        public const string UnableToFindUser = Base + nameof(UnableToFindUser);
                        public const string FoundMultipleUsers = Base + nameof(FoundMultipleUsers);
                        public const string UsernameSearchError = Base + nameof(UsernameSearchError);
                        public const string InvalidSyntax = Base + nameof(InvalidSyntax);
                        public const string NoPendingActivations = Base + nameof(NoPendingActivations);
                        public const string MustBeUsedServer = Base + nameof(MustBeUsedServer);
                        public const string MustBeUsedDiscord = Base + nameof(MustBeUsedDiscord);
                        //public const string LinkInProgress = Base + nameof(LinkInProgress);
                        public const string Banned = Base + nameof(Banned) + "V1";
                    }
                }
            }

            public static class Linking
            {
                private const string Base = nameof(Linking) + ".";

                public static class Chat
                {
                    private const string Base = Linking.Base + nameof(Chat) + ".";
                    
                    public const string Linked = Base + nameof(Linked);
                    public const string Unlinked = Base + nameof(Unlinked);
                }
                
                public static class Discord
                {
                    private const string Base = Linking.Base + nameof(Discord) + ".";
                    
                    public const string Linked = Base + nameof(Linked);
                    public const string Unlinked = Base + nameof(Unlinked);
                }
            }

            public static class Guild
            {
                private const string Base = nameof(Guild) + ".";
                
                public const string WelcomeMessage = Base + nameof(WelcomeMessage) + ".V1";
                public const string WelcomeLinkMessage = Base + nameof(WelcomeLinkMessage);
                public const string LinkMessage = Base + nameof(LinkMessage);
            }

            public static class Notifications
            {
                private const string Base = nameof(Notifications) + ".";
                
                public const string Link = Base + nameof(Link);
                public const string Rejoin = Base + nameof(Rejoin);
                public const string Unlink = Base + nameof(Unlink);
            }
            
            public static class Emoji
            {
                private const string Base = nameof(Emoji) + ".";
                        
                public const string Accept = Base + nameof(Accept);
                public const string Decline = Base +  nameof(Decline);
            }
        }

        public static class CommandKeys
        {
            public const string ChatCommand = nameof(DiscordCoreChatCommand);
            public const string ChatJoinCommand = ChatCommand + ".Join";
            public const string ChatJoinCodeCommand = ChatJoinCommand + ".Code";
            public const string ChatLeaveCommand = ChatCommand + ".Leave";
            
            public const string DiscordCommand = nameof(DiscordCoreMessageCommand);
            public const string DiscordJoinCommand = DiscordCommand + ".Join";
            public const string DiscordLeaveCommand = DiscordCommand + ".Leave";
        }
        #endregion
    }
}


// --- End of file: DiscordCore.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/SyringeDenerf.cs ---
// --- Original Local Path: SyringeDenerf.cs ---

using System;

namespace Oxide.Plugins
{
	[Info("SyringeDenerf", "ignignokt84", "0.1.3", ResourceId = 1809)]
	class SyringeDenerf : RustPlugin
	{
		private bool hasConfigChanged;
		float healAmount = 25f; // Instant heal amount
		float hotAmount = 10f; // Heal-over-time amount
		float hotTime = 10f; // Heal-over-time time
		
		object OnHealingItemUse(HeldEntity item, BasePlayer target)
		{
			if(item is MedicalTool && item.ShortPrefabName.Contains("syringe"))
			{
				target.health = target.health + healAmount;
				target.metabolism.ApplyChange(MetabolismAttribute.Type.HealthOverTime, hotAmount, hotTime);
				return true;
			}
			return null;
		}
		
		// Loaded
		void Loaded()
		{
			LoadConfig();
		}
		
		// loads default configuration
		protected override void LoadDefaultConfig()
		{
			Config.Clear();
			LoadConfig();
		}
		
		// loads config from file
		private void LoadConfig()
		{
			healAmount = Convert.ToSingle(GetConfig("Instant Heal Amount", healAmount));
			hotAmount = Convert.ToSingle(GetConfig("Heal-over-time Amount", hotAmount));
			hotTime = Convert.ToSingle(GetConfig("Heal-over-time Time", hotTime));
			
			if (!hasConfigChanged) return;
			SaveConfig();
			hasConfigChanged = false;
		}
		
		// get config options, or set to default value if not found
		private object GetConfig(string str, object defaultValue)
		{
			object value = Config[str];
			if (value == null)
			{
				value = defaultValue;
				Config[str] = value;
				hasConfigChanged = true;
			}
			return value;
		}
	}
}

// --- End of file: SyringeDenerf.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BuildingPrivileges.cs ---
// --- Original Local Path: BuildingPrivileges.cs ---

// Reference: Oxide.Ext.Rust

using System.Collections.Generic;
using System.Reflection;
using System;
using System.Data;
using UnityEngine;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("BuildingPrivileges", "Reneb", 1.0)]
    class BuildingPrivileges : RustPlugin
    {
        private FieldInfo localbuildingPrivileges;
        void Loaded()
        {
            localbuildingPrivileges = typeof(BasePlayer).GetField("buildingPrivlidges", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
        }
        [ChatCommand("bdp")]
        void cmdChatBuildingPrivileges(BasePlayer player, string command, string[] args)
        {
            if (player.net.connection.authLevel < 1)
            {
                SendReply(player, "You are not allowed to use this command");
                return;
            }
            var bldprivs = localbuildingPrivileges.GetValue(player) as List<BuildingPrivlidge>;
            foreach (BuildingPrivlidge bldpriv in bldprivs)
            {
                SendReply(player, string.Format("Found a Tool Cupboard @ {0} {1} {2}, allowed users:", Math.Round(bldpriv.transform.position.x).ToString(), Math.Round(bldpriv.transform.position.y).ToString(), Math.Round(bldpriv.transform.position.z).ToString()));
                var locAllowed = bldpriv.authorizedPlayers;
                foreach (ProtoBuf.PlayerNameID ply in locAllowed)
                {
                    SendReply(player, ply.username);
                }
            }
        }
    }
}

// --- End of file: BuildingPrivileges.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/MonumentFinder.cs ---
// --- Original Local Path: MonumentFinder.cs ---

﻿using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Text;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Monument Finder", "WhiteThunder", "3.1.2")]
    [Description("Find monuments with commands or API.")]
    internal class MonumentFinder : CovalencePlugin
    {
        #region Fields

        private static MonumentFinder _pluginInstance;
        private static Configuration _pluginConfig;

        private const string PermissionFind = "monumentfinder.find";

        private const float DrawDuration = 30;

        private readonly FieldInfo DungeonBaseLinksFieldInfo = typeof(TerrainPath).GetField("DungeonBaseLinks", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);

        private Dictionary<MonumentInfo, NormalMonumentAdapter> _normalMonuments = new Dictionary<MonumentInfo, NormalMonumentAdapter>();
        private Dictionary<DungeonGridCell, TrainTunnelAdapter> _trainTunnels = new Dictionary<DungeonGridCell, TrainTunnelAdapter>();
        private Dictionary<DungeonBaseLink, UnderwaterLabLinkAdapter> _labModules = new Dictionary<DungeonBaseLink, UnderwaterLabLinkAdapter>();
        private Dictionary<MonoBehaviour, BaseMonumentAdapter> _allMonuments = new Dictionary<MonoBehaviour, BaseMonumentAdapter>();

        private Collider[] _colliderBuffer = new Collider[8];

        #endregion

        #region Hooks

        private void Init()
        {
            _pluginInstance = this;
            permission.RegisterPermission(PermissionFind, this);

            AddCovalenceCommand(_pluginConfig.Command, nameof(CommandFind));
        }

        private void Unload()
        {
            _pluginConfig = null;
            _pluginInstance = null;
        }

        private void OnServerInitialized()
        {
            if (DungeonBaseLinksFieldInfo != null)
            {
                var dungeonLinks = DungeonBaseLinksFieldInfo.GetValue(TerrainMeta.Path) as List<DungeonBaseLink>;
                if (dungeonLinks != null)
                {
                    foreach (var link in dungeonLinks)
                    {
                        // End links represent the posts holding up the lab modules.
                        if (link.Type == DungeonBaseLinkType.End)
                            continue;

                        var labLink = new UnderwaterLabLinkAdapter(link);
                        _labModules[link] = labLink;
                        _allMonuments[link] = labLink;
                    }
                }
            }

            foreach (var dungeonCell in TerrainMeta.Path.DungeonGridCells)
            {
                if (TrainTunnelAdapter.IgnoredPrefabs.Contains(dungeonCell.name))
                    continue;

                try
                {
                    var trainTunnel = new TrainTunnelAdapter(dungeonCell);
                    _trainTunnels[dungeonCell] = trainTunnel;
                    _allMonuments[dungeonCell] = trainTunnel;
                }
                catch (NotImplementedException exception)
                {
                    LogWarning(exception.Message);
                }
            }

            foreach (var monument in TerrainMeta.Path.Monuments)
            {
                var normalMonument = new NormalMonumentAdapter(monument);
                _normalMonuments[monument] = normalMonument;
                _allMonuments[monument] = normalMonument;
            }
        }

        #endregion

        #region API

        private Dictionary<string, object> API_GetClosest(Vector3 position) =>
            GetClosestMonumentForAPI(_allMonuments.Values, position);

        private Dictionary<string, object> API_GetClosestMonument(Vector3 position) =>
            GetClosestMonumentForAPI(_normalMonuments.Values, position);

        private Dictionary<string, object> API_GetClosestTrainTunnel(Vector3 position) =>
            GetClosestMonumentForAPI(_trainTunnels.Values, position);

        private Dictionary<string, object> API_GetClosestUnderwaterLabModules(Vector3 position) =>
            GetClosestMonumentForAPI(_labModules.Values, position);

        private List<Dictionary<string, object>> API_FindMonuments(string filter) =>
            FilterMonumentsForAPI(_normalMonuments.Values, filter);

        private List<Dictionary<string, object>> API_FindTrainTunnels(string filter) =>
            FilterMonumentsForAPI(_trainTunnels.Values, filter);

        private List<Dictionary<string, object>> API_FindUnderwaterLabModules(string filter) =>
            FilterMonumentsForAPI(_labModules.Values, filter);

        private List<Dictionary<string, object>> API_Find(string filter) =>
            FilterMonumentsForAPI(_allMonuments.Values, filter);

        private List<Dictionary<string, object>> API_FindByShortName(string shortName) =>
            FilterMonumentsForAPI(_allMonuments.Values, shortName: shortName);

        private List<Dictionary<string, object>> API_FindByAlias(string alias) =>
            FilterMonumentsForAPI(_allMonuments.Values, alias: alias);

        // Kept for backwards compatibility with previous versions.
        private List<MonumentInfo> FindMonuments(string filter)
        {
            var monuments = new List<MonumentInfo>();

            foreach (var monument in TerrainMeta.Path.Monuments)
            {
                if (!monument.name.Contains("/monument/") || !string.IsNullOrEmpty(filter) &&
                    !monument.Type.ToString().Contains(filter, CompareOptions.IgnoreCase) &&
                    !monument.name.Contains(filter, CompareOptions.IgnoreCase))
                    continue;

                monuments.Add(monument);
            }

            return monuments;
        }

        #endregion

        #region Commands

        private void CommandFind(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(PermissionFind))
            {
                ReplyToPlayer(player, Lang.ErrorNoPermission);
                return;
            }

            if (args == null || args.Length == 0)
            {
                SubcommandHelp(player, command);
                return;
            }

            switch (args[0].ToLower())
            {
                case "find":
                case "f":
                case "list":
                case "l":
                {
                    SubcommandList(player, command, args.Skip(1).ToArray());
                    return;
                }

                case "show":
                case "s":
                case "view":
                case "v":
                {
                    SubcommandShow(player, command, args.Skip(1).ToArray());
                    break;
                }

                case "closest":
                case "nearest":
                {
                    SubcommandClosest(player, command, args.Skip(1).ToArray());
                    break;
                }

                default:
                {
                    SubcommandHelp(player, command);
                    break;
                }
            }
        }

        private void SubcommandHelp(IPlayer player, string command)
        {
            var builder = new StringBuilder();
            builder.AppendLine(GetMessage(player, Lang.HelpHeader));
            builder.AppendLine(GetMessage(player, Lang.HelpList, command));
            builder.AppendLine(GetMessage(player, Lang.HelpShow, command));
            builder.AppendLine(GetMessage(player, Lang.HelpClosest, command));
            builder.AppendLine(GetMessage(player, Lang.HelpClosestConfig, command));
            player.Reply(builder.ToString());
        }

        private void SubcommandList(IPlayer player, string cmd, string[] args)
        {
            var filterArg = args.Length >= 1 ? args[0] : string.Empty;
            var monuments = FilterMonuments(_allMonuments.Values, filterArg);

            if (monuments.Count == 0)
            {
                ReplyToPlayer(player, Lang.NoMonumentsFound);
                return;
            }

            PrintMonumentList(player, monuments);
        }

        private void SubcommandShow(IPlayer player, string command, string[] args)
        {
            var basePlayer = player.Object as BasePlayer;
            if (basePlayer == null)
                return;

            var filterArg = args.Length >= 1 ? args[0] : string.Empty;
            var monuments = FilterMonuments(_allMonuments.Values, filterArg);
            if (monuments.Count == 0)
            {
                ReplyToPlayer(player, Lang.NoMonumentsFound);
                return;
            }

            foreach (var monument in monuments)
                ShowMonumentName(basePlayer, monument);
        }

        private void SubcommandClosest(IPlayer player, string command, string[] args)
        {
            var basePlayer = player.Object as BasePlayer;
            if (basePlayer == null)
                return;

            var position = basePlayer.transform.position;
            var monument = GetClosestMonument(_allMonuments.Values, position);
            if (monument == null)
            {
                ReplyToPlayer(player, Lang.NoMonumentsFound);
                return;
            }

            var firstArg = args.FirstOrDefault() ?? string.Empty;
            if (firstArg.Equals("config", StringComparison.CurrentCultureIgnoreCase))
            {
                var aliasOrShortName = monument.Alias ?? monument.ShortName;
                if (_pluginConfig.AddMonument(aliasOrShortName, monument))
                {
                    Config.WriteObject(_pluginConfig, true);
                    ReplyToPlayer(player, Lang.ClosestConfigSuccess, aliasOrShortName);
                }
                else
                {
                    ReplyToPlayer(player, Lang.ClosestConfigAlreadyPresent, aliasOrShortName);
                }
            }
            else
            {
                if (monument.IsInBounds(position))
                {
                    var relativePosition = monument.InverseTransformPoint(position);
                    ReplyToPlayer(player, Lang.AtMonument, monument.PrefabName, relativePosition);
                }
                else
                {
                    var closestPoint = monument.ClosestPointOnBounds(position);
                    var distance = (position - closestPoint).magnitude;
                    ReplyToPlayer(player, Lang.ClosestMonument, monument.PrefabName, distance);
                }
            }

            if (basePlayer.IsAdmin)
            {
                ShowMonumentName(basePlayer, monument);

                var withBoundingBox = monument as SingleBoundingBox;
                if (withBoundingBox != null)
                {
                    var boundingBox = withBoundingBox.BoundingBox;
                    if (boundingBox.extents != Vector3.zero)
                    {
                        Ddraw.Box(basePlayer, boundingBox, Color.magenta, DrawDuration);
                    }

                    return;
                }

                var withMultipleBoundingBoxes = monument as MultipleBoundingBoxes;
                if (withMultipleBoundingBoxes != null)
                {
                    foreach (var boundingBox in withMultipleBoundingBoxes.BoundingBoxes)
                    {
                        Ddraw.Box(basePlayer, boundingBox, Color.magenta, DrawDuration, showInfo: false);
                    }
                }
            }
        }

        #endregion

        #region Helper Methods

        private static void LogError(string message) => Interface.Oxide.LogError($"[Monument Finder] {message}");

        private static void LogWarning(string message) => Interface.Oxide.LogWarning($"[Monument Finder] {message}");

        private static bool IsCustomMonument(MonumentInfo monumentInfo)
        {
            return monumentInfo.name.Contains("monument_marker.prefab");
        }

        private static Collider FindPreventBuildingVolume(Vector3 position)
        {
            var buffer = _pluginInstance._colliderBuffer;
            var count = Physics.OverlapSphereNonAlloc(position, 1, buffer, Rust.Layers.Mask.Prevent_Building, QueryTriggerInteraction.Ignore);

            if (count == 0)
                return null;

            for (var i = 0; i < count; i++)
            {
                var collider = buffer[i];
                if ((collider is BoxCollider || collider is SphereCollider)
                    // Only count prevent_building prefabs, not all prefabs that have prevent building colliders.
                    && collider.name.Contains("prevent_building", CompareOptions.IgnoreCase))
                    return collider;
            }

            return null;
        }

        private static T GetClosestMonument<T>(IEnumerable<T> monumentList, Vector3 position) where T : BaseMonumentAdapter
        {
            T closestMonument = null;
            var closestSqrDistance = float.MaxValue;

            foreach (var baseMonument in monumentList)
            {
                var currentSqrDistance = (position - baseMonument.ClosestPointOnBounds(position)).sqrMagnitude;
                if (currentSqrDistance < closestSqrDistance)
                {
                    closestSqrDistance = currentSqrDistance;
                    closestMonument = baseMonument;
                }
            }

            return closestMonument;
        }

        private static Dictionary<string, object> GetClosestMonumentForAPI(IEnumerable<BaseMonumentAdapter> monumentList, Vector3 position)
        {
            return GetClosestMonument(monumentList, position)?.APIResult;
        }

        private static List<T> FilterMonuments<T>(IEnumerable<T> monumentList, string filter = null, string shortName = null, string alias = null) where T : BaseMonumentAdapter
        {
            var results = new List<T>();

            foreach (var baseMonument in monumentList)
            {
                if (baseMonument.MatchesFilter(filter, shortName, alias))
                    results.Add(baseMonument);
            }

            return results;
        }

        private static List<Dictionary<string, object>> FilterMonumentsForAPI(IEnumerable<BaseMonumentAdapter> monumentList, string filter = null, string shortName = null, string alias = null)
        {
            var results = new List<Dictionary<string, object>>();

            foreach (var baseMonument in monumentList)
            {
                if (baseMonument.MatchesFilter(filter, shortName, alias))
                {
                    results.Add(baseMonument.APIResult);
                }
            }

            return results;
        }

        private void PrintMonumentList(IPlayer player, IEnumerable<BaseMonumentAdapter> monuments)
        {
            var builder = new StringBuilder();
            builder.AppendLine(GetMessage(player, Lang.ListHeader));

            foreach (var monument in monuments)
            {
                builder.AppendLine(monument.PrefabName);
            }

            player.Reply(builder.ToString());
        }

        private static void ShowMonumentName(BasePlayer player, BaseMonumentAdapter monument)
        {
            Ddraw.Text(player, monument.Position, $"<size=20>{monument.ShortName}</size>", Color.magenta, 30);
        }

        #endregion

        #region Monument Adapter

        private interface SingleBoundingBox
        {
            OBB BoundingBox { get; }
        }

        private interface MultipleBoundingBoxes
        {
            OBB[] BoundingBoxes { get; }
        }

        private abstract class BaseMonumentAdapter
        {
            protected static string GetShortName(string prefabName)
            {
                var slashIndex = prefabName.LastIndexOf("/");
                var baseName = (slashIndex == -1) ? prefabName : prefabName.Substring(slashIndex + 1);
                return baseName.Replace(".prefab", "");
            }

            public MonoBehaviour Object { get; }
            public string PrefabName { get; protected set; }
            public string ShortName { get; protected set; }

            // Subclasses should overwrite this is if multiple monuments need to share an alias.
            // For instance, each train station prefab should share the same alias since they only differ in rotation.
            public string Alias { get; protected set; }

            public Vector3 Position { get; protected set; }
            public Quaternion Rotation { get; protected set; }

            public BaseMonumentAdapter(MonoBehaviour behavior)
            {
                Object = behavior;
                PrefabName = behavior.name;
                ShortName = GetShortName(behavior.name);
                Position = behavior.transform.position;
                Rotation = behavior.transform.rotation;
            }

            public Vector3 TransformPoint(Vector3 localPosition)
            {
                return Position + Rotation * localPosition;
            }

            public Vector3 InverseTransformPoint(Vector3 worldPosition)
            {
                return Quaternion.Inverse(Rotation) * (worldPosition - Position);
            }

            public abstract bool IsInBounds(Vector3 position);
            public abstract Vector3 ClosestPointOnBounds(Vector3 position);

            public virtual bool MatchesFilter(string filter, string shortName, string alias)
            {
                if (alias != null)
                    return Alias?.Equals(alias, StringComparison.InvariantCultureIgnoreCase) ?? false;

                if (shortName != null)
                    return ShortName.Equals(shortName, StringComparison.InvariantCultureIgnoreCase);

                if (string.IsNullOrEmpty(filter))
                    return true;

                return PrefabName.Contains(filter, CompareOptions.IgnoreCase);
            }

            private Dictionary<string, object> _cachedAPIResult;
            public Dictionary<string, object> APIResult
            {
                get
                {
                    if (_cachedAPIResult == null)
                    {
                        _cachedAPIResult = new Dictionary<string, object>
                        {
                            ["Object"] = Object,
                            ["PrefabName"] = PrefabName,
                            ["ShortName"] = ShortName,
                            ["Alias"] = Alias,
                            ["Position"] = Position,
                            ["Rotation"] = Rotation,
                            ["TransformPoint"] = new Func<Vector3, Vector3>(TransformPoint),
                            ["InverseTransformPoint"] = new Func<Vector3, Vector3>(InverseTransformPoint),
                            ["ClosestPointOnBounds"] = new Func<Vector3, Vector3>(ClosestPointOnBounds),
                            ["IsInBounds"] = new Func<Vector3, bool>(IsInBounds),
                        };
                    }

                    return _cachedAPIResult;
                }
            }
        }

        private class NormalMonumentAdapter : BaseMonumentAdapter, SingleBoundingBox
        {
            public static Dictionary<string, Bounds> MonumentBounds = new Dictionary<string, Bounds>
            {
                // These bounds are more accurate than what is provided in vanilla.
                ["airfield_1"] = new Bounds(new Vector3(0, 15, -25), new Vector3(355, 70, 210)),
                ["bandit_town"] = new Bounds(new Vector3(0, 12, -5), new Vector3(150, 40, 140)),
                ["cave_large_sewers_hard"] = new Bounds(new Vector3(18, -5, -9), new Vector3(52, 80, 56)),
                ["cave_medium_medium"] = new Bounds(new Vector3(-5, 10, -3), new Vector3(100, 20, 50)),
                ["cave_small_easy"] = new Bounds(new Vector3(5, 10, 0), new Vector3(55, 24, 55)),
                ["cave_small_hard"] = new Bounds(new Vector3(0, 10, -5), new Vector3(40, 20, 35)),
                ["cave_small_medium"] = new Bounds(new Vector3(10, 10, 0), new Vector3(45, 26, 40)),
                ["compound"] = new Bounds(new Vector3(0, 12, 0), new Vector3(200, 50, 200)),
                ["entrance_bunker_a"] = new Bounds(new Vector3(-3.5f, 1, -0.5f), new Vector3(20, 30, 18)),
                ["entrance_bunker_b"] = new Bounds(new Vector3(-8, 1, 0), new Vector3(30, 30, 18)),
                ["entrance_bunker_c"] = new Bounds(new Vector3(-3.5f, 1, -5f), new Vector3(24, 30, 27)),
                ["entrance_bunker_d"] = new Bounds(new Vector3(-3.5f, 1, -0.5f), new Vector3(20, 30, 17)),
                ["excavator_1"] = new Bounds(new Vector3(0, 40, 0), new Vector3(240, 100, 230)),
                ["fishing_village_a"] = new Bounds(new Vector3(-3, 5, -11), new Vector3(76, 24, 80)),
                ["fishing_village_b"] = new Bounds(new Vector3(-3, 4, -4), new Vector3(42, 24, 76)),
                ["fishing_village_c"] = new Bounds(new Vector3(-0.5f, 4, -4.5f), new Vector3(31, 22, 75)),
                ["gas_station_1"] = new Bounds(new Vector3(0, 13, 15), new Vector3(70, 42, 60)),
                ["harbor_1"] = new Bounds(new Vector3(-8, 23, 15), new Vector3(246, 60, 200)),
                ["harbor_2"] = new Bounds(new Vector3(6, 23, 18), new Vector3(224, 60, 250)),
                ["junkyard_1"] = new Bounds(new Vector3(0, 20, 0), new Vector3(180, 50, 180)),
                ["launch_site_1"] = new Bounds(new Vector3(10, 25, -26), new Vector3(544, 120, 276)),
                ["lighthouse"] = new Bounds(new Vector3(10f, 23, 5), new Vector3(74, 96, 68)),
                ["military_tunnel_1"] = new Bounds(new Vector3(0, 15, -25), new Vector3(265, 70, 250)),
                ["mining_quarry_a"] = new Bounds(new Vector3(2, 10, 2), new Vector3(52, 20, 72)),
                ["mining_quarry_b"] = new Bounds(new Vector3(-5, 10, -8), new Vector3(60, 20, 40)),
                ["mining_quarry_c"] = new Bounds(new Vector3(-6, 10, 8), new Vector3(42, 20, 60)),
                ["OilrigAI"] = new Bounds(new Vector3(18, 20, -2), new Vector3(68, 60, 76)),
                ["OilrigAI2"] = new Bounds(new Vector3(3, 43, 12), new Vector3(80, 96, 120)),
                ["power_sub_big_1"] = new Bounds(new Vector3(0, 5, 0.5f), new Vector3(20, 10, 22f)),
                ["power_sub_big_2"] = new Bounds(new Vector3(-1, 5, 1), new Vector3(23, 10, 22)),
                ["power_sub_small_1"] = new Bounds(new Vector3(0, 4, 0), new Vector3(14, 8, 14)),
                ["power_sub_small_2"] = new Bounds(new Vector3(0, 4, 0), new Vector3(14, 8, 14)),
                ["powerplant_1"] = new Bounds(new Vector3(-15, 25, -11), new Vector3(220, 64, 290)),
                ["radtown_small_3"] = new Bounds(new Vector3(-10, 15, -18), new Vector3(130, 50, 148)),
                ["satellite_dish"] = new Bounds(new Vector3(0, 25, 3), new Vector3(155, 55, 125)),
                ["sphere_tank"] = new Bounds(new Vector3(0, 41, 0), new Vector3(100, 84, 100)),
                ["stables_a"] = new Bounds(new Vector3(0, 10, 4), new Vector3(50, 20, 60)),
                ["stables_b"] = new Bounds(new Vector3(2, 15, 6), new Vector3(78, 30, 66)),
                ["supermarket_1"] = new Bounds(new Vector3(1, 4.5f, 1), new Vector3(40, 10, 44)),
                ["swamp_a"] = new Bounds(new Vector3(-10, 11, 0), new Vector3(140, 30, 140)),
                ["swamp_b"] = new Bounds(new Vector3(0, 14, 0), new Vector3(100, 36, 100)),
                ["swamp_c"] = new Bounds(new Vector3(0, 7, 0), new Vector3(100, 30, 100)),
                ["trainyard_1"] = new Bounds(new Vector3(10, 22, -30), new Vector3(235, 70, 220)),
                ["underwater_lab_a"] = new Bounds(),
                ["underwater_lab_b"] = new Bounds(),
                ["underwater_lab_c"] = new Bounds(),
                ["underwater_lab_d"] = new Bounds(),
                ["warehouse"] = new Bounds(new Vector3(0, 5, -8), new Vector3(44, 10, 24)),
                ["water_treatment_plant_1"] = new Bounds(new Vector3(20, 30, -45), new Vector3(250, 84, 290)),
                ["water_well_a"] = new Bounds(new Vector3(0, 10, 0), new Vector3(24, 20, 24)),
                ["water_well_b"] = new Bounds(new Vector3(0, 10, 0), new Vector3(24, 20, 24)),
                ["water_well_c"] = new Bounds(new Vector3(0, 10, 0), new Vector3(24, 20, 24)),
                ["water_well_d"] = new Bounds(new Vector3(0, 10, 0), new Vector3(30, 20, 30)),
                ["water_well_e"] = new Bounds(new Vector3(0, 10, 0), new Vector3(24, 20, 24)),
            };

            public MonumentInfo MonumentInfo { get; }
            public OBB BoundingBox { get; }

            public NormalMonumentAdapter(MonumentInfo monumentInfo) : base(monumentInfo)
            {
                MonumentInfo = monumentInfo;
                var bounds = monumentInfo.Bounds;

                if (IsCustomMonument(monumentInfo))
                {
                    PrefabName = monumentInfo.transform.root.name;
                    ShortName = PrefabName;

                    var monumentSettings = _pluginConfig.GetMonumentSettings(ShortName)
                        ?? _pluginConfig.DefaultCustomMonumentSettings;

                    var volumeCollider = monumentSettings.Position.UsePreventBuildingVolume
                        || monumentSettings.Rotation.UsePreventBuildingVolume
                        || monumentSettings.Bounds.UsePreventBuildingVolume
                            ? FindPreventBuildingVolume(Position)
                            : null;

                    if (!monumentSettings.Position.UseMonumentMarker
                        && monumentSettings.Position.UsePreventBuildingVolume)
                    {
                        if (volumeCollider != null)
                        {
                            Position = volumeCollider.transform.position;
                        }
                        else
                        {
                            LogWarning($"Unable to find a PreventBuilding volume for monument {ShortName}. Determining position from monument marker instead.");
                        }
                    }

                    if (!monumentSettings.Rotation.UseMonumentMarker
                        && monumentSettings.Rotation.UsePreventBuildingVolume)
                    {
                        if (volumeCollider != null)
                        {
                            Rotation = volumeCollider.transform.rotation;
                        }
                        else
                        {
                            LogWarning($"Unable to find a PreventBuilding volume for monument {ShortName}. Determining rotation from monument marker instead.");
                        }
                    }

                    if (monumentSettings.Bounds.UseCustomBounds)
                    {
                        bounds = monumentSettings.Bounds.CustomBounds.ToBounds();
                    }
                    else if (monumentSettings.Bounds.UseMonumentMarker)
                    {
                        bounds = new Bounds(Position - monumentInfo.transform.position, monumentInfo.transform.localScale);
                    }
                    else if (monumentSettings.Bounds.UsePreventBuildingVolume)
                    {
                        if (volumeCollider != null)
                        {
                            bounds = volumeCollider.bounds;
                            bounds.center = Quaternion.Inverse(Rotation) * (bounds.center - Position);
                        }
                        else
                        {
                            LogError($"Unable to find a PreventBuilding volume for monument {ShortName}. Unable to determine bounds.");
                        }
                    }
                }
                else
                {
                    var monumentSettings = _pluginConfig.GetMonumentSettings(ShortName);
                    if (monumentSettings != null && monumentSettings.Bounds.UseCustomBounds)
                    {
                        bounds = monumentSettings.Bounds.CustomBounds.ToBounds();
                    }
                    else
                    {
                        Bounds hardCodedBounds;
                        if (MonumentBounds.TryGetValue(ShortName, out hardCodedBounds))
                        {
                            bounds = hardCodedBounds;
                        }
                    }
                }

                BoundingBox = new OBB(Position, Rotation, bounds);
            }

            public override bool IsInBounds(Vector3 position) =>
                BoundingBox.Contains(position);

            public override Vector3 ClosestPointOnBounds(Vector3 position) =>
                BoundingBox.ClosestPoint(position);

            public override bool MatchesFilter(string filter, string shortName, string alias)
            {
                return base.MatchesFilter(filter, shortName, alias)
                    || !string.IsNullOrEmpty(filter) && MonumentInfo.Type.ToString().Contains(filter, CompareOptions.IgnoreCase);
            }
        }

        private class TrainTunnelAdapter : BaseMonumentAdapter, SingleBoundingBox
        {
            public static readonly string[] IgnoredPrefabs =
            {
                // These prefabs are simply used for decorating.
                "assets/bundled/prefabs/autospawn/tunnel-transition/transition-sn-0.prefab",
                "assets/bundled/prefabs/autospawn/tunnel-transition/transition-sn-1.prefab",
                "assets/bundled/prefabs/autospawn/tunnel-transition/transition-we-0.prefab",
                "assets/bundled/prefabs/autospawn/tunnel-transition/transition-we-1.prefab",
            };

            private abstract class BaseTunnelInfo
            {
                public Quaternion Rotation;
                public virtual Bounds Bounds { get; }
                public virtual string Alias { get; }
            }

            // Train stations.
            private class TrainStation : BaseTunnelInfo
            {
                public override Bounds Bounds => new Bounds(new Vector3(0, 8.75f, 0), new Vector3(108, 18, 216));
                public override string Alias => "TrainStation";
            }

            // Straight tunnels that contain barricades, loot and tunnel dwellers.
            private class BarricadeTunnel : BaseTunnelInfo
            {
                public override Bounds Bounds => new Bounds(new Vector3(0, 4.25f, 0), new Vector3(45f, 9, 216));
                public override string Alias => "BarricadeTunnel";
            }

            // Straight tunnels contain loot and tunnel dwellers.
            private class LootTunnel : BaseTunnelInfo
            {
                public override Bounds Bounds => new Bounds(new Vector3(0, 4.25f, 0), new Vector3(16.5f, 9, 216));
                public override string Alias => "LootTunnel";
            }

            // Straight tunnels with a divider in the tracks.
            private class SplitTunnel : BaseTunnelInfo
            {
                public override Bounds Bounds => new Bounds(new Vector3(0, 4.25f, 0), new Vector3(16.5f, 9, 216));
                public override string Alias => "SplitTunnel";
            }

            // 3-way intersections.
            private class Intersection : BaseTunnelInfo
            {
                public override Bounds Bounds => new Bounds(new Vector3(0, 4.25f, 49.875f), new Vector3(216, 9, 116.25f));
                public override string Alias => "Intersection";
            }

            // 4-way intersections.
            private class LargeIntersection : BaseTunnelInfo
            {
                public override Bounds Bounds => new Bounds(new Vector3(0, 4.25f, 0), new Vector3(216, 9, 216));
                public override string Alias => "LargeIntersection";
            }

            // 3-way intersections that connect to above ground.
            private class VerticalIntersection : BaseTunnelInfo
            {
                public override Bounds Bounds => new Bounds(new Vector3(0, 4.25f, 49.875f), new Vector3(216, 9, 116.25f));
                public override string Alias => "VerticalIntersection";
            }

            // Corner tunnels (45-degree angle).
            private class CornerTunnel : BaseTunnelInfo
            {
                public override Bounds Bounds => new Bounds(new Vector3(-49.875f, 4.25f, 49.875f), new Vector3(116.25f, 9, 116.25f));
                public override string Alias => "CornerTunnel";
            }

            private static readonly Dictionary<string, BaseTunnelInfo> PrefabToTunnelInfo = new Dictionary<string, BaseTunnelInfo>
            {
                ["station-sn-0"] = new TrainStation { Rotation = Quaternion.Euler(0, 180, 0) },
                ["station-sn-1"] = new TrainStation { Rotation = Quaternion.Euler(0, 0, 0) },
                ["station-sn-2"] = new TrainStation { Rotation = Quaternion.Euler(0, 180, 0) },
                ["station-sn-3"] = new TrainStation { Rotation = Quaternion.Euler(0, 0, 0) },
                ["station-we-0"] = new TrainStation { Rotation = Quaternion.Euler(0, 90, 0) },
                ["station-we-1"] = new TrainStation { Rotation = Quaternion.Euler(0, 270, 0) },
                ["station-we-2"] = new TrainStation { Rotation = Quaternion.Euler(0, 90, 0) },
                ["station-we-3"] = new TrainStation { Rotation = Quaternion.Euler(0, 270, 0) },

                ["straight-sn-4"] = new BarricadeTunnel { Rotation = Quaternion.Euler(0, 180, 0) },
                ["straight-sn-5"] = new BarricadeTunnel { Rotation = Quaternion.Euler(0, 0, 0) },
                ["straight-we-4"] = new BarricadeTunnel { Rotation = Quaternion.Euler(0, 90, 0) },
                ["straight-we-5"] = new BarricadeTunnel { Rotation = Quaternion.Euler(0, 270, 0) },

                ["straight-sn-0"] = new LootTunnel { Rotation = Quaternion.Euler(0, 180, 0) },
                ["straight-sn-1"] = new LootTunnel { Rotation = Quaternion.Euler(0, 0, 0) },
                ["straight-we-0"] = new LootTunnel { Rotation = Quaternion.Euler(0, 90, 0) },
                ["straight-we-1"] = new LootTunnel { Rotation = Quaternion.Euler(0, 270, 0) },

                ["straight-we-2"] = new SplitTunnel { Rotation = Quaternion.Euler(0, 90, 0) },
                ["straight-we-3"] = new SplitTunnel { Rotation = Quaternion.Euler(0, 270, 0) },
                ["straight-sn-2"] = new SplitTunnel { Rotation = Quaternion.Euler(0, 180, 0) },
                ["straight-sn-3"] = new SplitTunnel { Rotation = Quaternion.Euler(0, 0, 0) },

                ["intersection-n"] = new Intersection { Rotation = Quaternion.Euler(0, 0, 0) },
                ["intersection-e"] = new Intersection { Rotation = Quaternion.Euler(0, 90, 0) },
                ["intersection-s"] = new Intersection { Rotation = Quaternion.Euler(0, 180, 0) },
                ["intersection-w"] = new Intersection { Rotation = Quaternion.Euler(0, 270, 0) },

                ["intersection-b1-n"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 0, 0) },
                ["intersection-b1-e"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 90, 0) },
                ["intersection-b1-s"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 180, 0) },
                ["intersection-b1-w"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 270, 0) },

                ["intersection-b2-n"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 0, 0) },
                ["intersection-b2-e"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 90, 0) },
                ["intersection-b2-s"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 180, 0) },
                ["intersection-b2-w"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 270, 0) },

                ["intersection-b3-n"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 0, 0) },
                ["intersection-b3-e"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 90, 0) },
                ["intersection-b3-s"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 180, 0) },
                ["intersection-b3-w"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 270, 0) },

                ["intersection-b4-n"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 0, 0) },
                ["intersection-b4-e"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 90, 0) },
                ["intersection-b4-s"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 180, 0) },
                ["intersection-b4-w"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 270, 0) },

                ["intersection-b5-n"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 0, 0) },
                ["intersection-b5-e"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 90, 0) },
                ["intersection-b5-s"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 180, 0) },
                ["intersection-b5-w"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 270, 0) },

                ["intersection-b6-n"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 0, 0) },
                ["intersection-b6-e"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 90, 0) },
                ["intersection-b6-s"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 180, 0) },
                ["intersection-b6-w"] = new VerticalIntersection { Rotation = Quaternion.Euler(0, 270, 0) },

                ["intersection"] = new LargeIntersection { Rotation = Quaternion.Euler(0, 0, 0) },

                ["curve-ne-0"] = new CornerTunnel { Rotation = Quaternion.Euler(0, 90, 0) },
                ["curve-ne-1"] = new CornerTunnel { Rotation = Quaternion.Euler(0, 90, 0) },
                ["curve-nw-0"] = new CornerTunnel { Rotation = Quaternion.Euler(0, 0, 0) },
                ["curve-nw-1"] = new CornerTunnel { Rotation = Quaternion.Euler(0, 0, 0) },
                ["curve-se-0"] = new CornerTunnel { Rotation = Quaternion.Euler(0, 180, 0) },
                ["curve-se-1"] = new CornerTunnel { Rotation = Quaternion.Euler(0, 180, 0) },
                ["curve-sw-0"] = new CornerTunnel { Rotation = Quaternion.Euler(0, 270, 0) },
                ["curve-sw-1"] = new CornerTunnel { Rotation = Quaternion.Euler(0, 270, 0) },
            };

            private static BaseTunnelInfo GetTunnelInfo(string shortName)
            {
                BaseTunnelInfo tunnelInfo;
                if (PrefabToTunnelInfo.TryGetValue(shortName, out tunnelInfo))
                    return tunnelInfo;

                throw new NotImplementedException($"Tunnel type not implemented: {shortName}");
            }

            public OBB BoundingBox { get; }

            private BaseTunnelInfo _tunnelInfo;

            public TrainTunnelAdapter(DungeonGridCell dungeonCell) : base(dungeonCell)
            {
                _tunnelInfo = GetTunnelInfo(ShortName);

                Rotation = _tunnelInfo.Rotation;
                Alias = _tunnelInfo.Alias;

                var bounds = _tunnelInfo.Bounds;

                var monumentSettings = _pluginConfig.GetMonumentSettings(_tunnelInfo.Alias);
                if (monumentSettings != null && monumentSettings.Bounds.UseCustomBounds)
                {
                    bounds = monumentSettings.Bounds.CustomBounds.ToBounds();
                }

                BoundingBox = new OBB(Position, Rotation, bounds);
            }

            public override bool IsInBounds(Vector3 position) =>
                BoundingBox.Contains(position);

            public override Vector3 ClosestPointOnBounds(Vector3 position) =>
                BoundingBox.ClosestPoint(position);
        }

        private class UnderwaterLabLinkAdapter : BaseMonumentAdapter, MultipleBoundingBoxes
        {
            public OBB[] BoundingBoxes { get; }

            public UnderwaterLabLinkAdapter(DungeonBaseLink dungeonLink) : base(dungeonLink)
            {
                var volumeList = dungeonLink.GetComponentsInChildren<DungeonVolume>();
                BoundingBoxes = new OBB[volumeList.Length];

                for (var i = 0; i < volumeList.Length; i++)
                {
                    var volume = volumeList[i];
                    BoundingBoxes[i] = new OBB(volume.transform.position, volume.transform.rotation, volume.bounds);
                }
            }

            public override bool IsInBounds(Vector3 position)
            {
                foreach (var box in BoundingBoxes)
                {
                    if (box.Contains(position))
                        return true;
                }

                return false;
            }

            public override Vector3 ClosestPointOnBounds(Vector3 position)
            {
                var overallClosestPoint = Vector3.positiveInfinity;
                var closestSqrDistance = float.MaxValue;

                foreach (var box in BoundingBoxes)
                {
                    var closestPoint = box.ClosestPoint(position);
                    var currentSqrDistance = (position - closestPoint).sqrMagnitude;

                    if (currentSqrDistance < closestSqrDistance)
                    {
                        overallClosestPoint = closestPoint;
                        closestSqrDistance = currentSqrDistance;
                    }
                }

                return overallClosestPoint;
            }
        }

        #endregion

        #region Ddraw

        private static class Ddraw
        {
            public static void Sphere(BasePlayer player, Vector3 origin, float radius, Color color, float duration) =>
                player.SendConsoleCommand("ddraw.sphere", duration, color, origin, radius);

            public static void Line(BasePlayer player, Vector3 origin, Vector3 target, Color color, float duration) =>
                player.SendConsoleCommand("ddraw.line", duration, color, origin, target);

            public static void Text(BasePlayer player, Vector3 origin, string text, Color color, float duration) =>
                player.SendConsoleCommand("ddraw.text", duration, color, origin, text);

            public static void Segments(BasePlayer player, Vector3 origin, Vector3 target, Color color, float duration)
            {
                var delta = target - origin;
                var distance = delta.magnitude;
                var direction = delta.normalized;

                var segmentLength = 10f;
                var numSegments = Mathf.CeilToInt(distance / segmentLength);

                for (var i = 0; i < numSegments; i++)
                {
                    var length = segmentLength;
                    if (i == numSegments - 1 && distance % segmentLength != 0)
                        length = distance % segmentLength;

                    var start = origin + i * segmentLength * direction;
                    var end = start + length * direction;
                    Line(player, start, end, color, duration);
                }
            }

            public static void Box(BasePlayer player, Vector3 center, Quaternion rotation, Vector3 halfExtents, Color color, float duration, bool showInfo = true)
            {
                var boxArea = halfExtents.x * halfExtents.z;

                var sphereRadius = boxArea > 200
                    ? 1f
                    : boxArea > 10
                    ? 0.5f
                    : 0.1f;

                var forwardUpperLeft = center + rotation * halfExtents.WithX(-halfExtents.x);
                var forwardUpperRight = center + rotation * halfExtents;
                var forwardLowerLeft = center + rotation * halfExtents.WithX(-halfExtents.x).WithY(-halfExtents.y);
                var forwardLowerRight = center + rotation * halfExtents.WithY(-halfExtents.y);

                var backLowerRight = center + rotation * -halfExtents.WithX(-halfExtents.x);
                var backLowerLeft = center + rotation * -halfExtents;
                var backUpperRight = center + rotation * -halfExtents.WithX(-halfExtents.x).WithY(-halfExtents.y);
                var backUpperLeft = center + rotation * -halfExtents.WithY(-halfExtents.y);

                var forwardLowerMiddle = Vector3.Lerp(forwardLowerLeft, forwardLowerRight, 0.5f);
                var forwardUpperMiddle = Vector3.Lerp(forwardUpperLeft, forwardUpperRight, 0.5f);

                var backLowerMiddle = Vector3.Lerp(backLowerLeft, backLowerRight, 0.5f);
                var backUpperMiddle = Vector3.Lerp(backUpperLeft, backUpperRight, 0.5f);

                var leftLowerMiddle = Vector3.Lerp(forwardLowerLeft, backLowerLeft, 0.5f);
                var leftUpperMiddle = Vector3.Lerp(forwardUpperLeft, backUpperLeft, 0.5f);

                var rightLowerMiddle = Vector3.Lerp(forwardLowerRight, backLowerRight, 0.5f);
                var rightUpperMiddle = Vector3.Lerp(forwardUpperRight, backUpperRight, 0.5f);

                Sphere(player, forwardUpperLeft, sphereRadius, color, duration);
                Sphere(player, forwardUpperRight, sphereRadius, color, duration);
                Sphere(player, forwardLowerLeft, sphereRadius, color, duration);
                Sphere(player, forwardLowerRight, sphereRadius, color, duration);

                Sphere(player, backLowerRight, sphereRadius, color, duration);
                Sphere(player, backLowerLeft, sphereRadius, color, duration);
                Sphere(player, backUpperRight, sphereRadius, color, duration);
                Sphere(player, backUpperLeft, sphereRadius, color, duration);

                Segments(player, forwardUpperLeft, forwardUpperRight, color, duration);
                Segments(player, forwardLowerLeft, forwardLowerRight, color, duration);
                Segments(player, forwardUpperLeft, forwardLowerLeft, color, duration);
                Segments(player, forwardUpperRight, forwardLowerRight, color, duration);

                Segments(player, backUpperLeft, backUpperRight, color, duration);
                Segments(player, backLowerLeft, backLowerRight, color, duration);
                Segments(player, backUpperLeft, backLowerLeft, color, duration);
                Segments(player, backUpperRight, backLowerRight, color, duration);

                Segments(player, forwardUpperLeft, backUpperLeft, color, duration);
                Segments(player, forwardLowerLeft, backLowerLeft, color, duration);
                Segments(player, forwardUpperRight, backUpperRight, color, duration);
                Segments(player, forwardLowerRight, backLowerRight, color, duration);

                if (showInfo)
                {
                    Sphere(player, forwardLowerMiddle, sphereRadius, Color.yellow, duration);
                    Sphere(player, forwardUpperMiddle, sphereRadius, Color.yellow, duration);
                    Sphere(player, backLowerMiddle, sphereRadius, Color.yellow, duration);
                    Sphere(player, backUpperMiddle, sphereRadius, Color.yellow, duration);

                    Sphere(player, leftLowerMiddle, sphereRadius, Color.green, duration);
                    Sphere(player, leftUpperMiddle, sphereRadius, Color.green, duration);
                    Sphere(player, rightLowerMiddle, sphereRadius, Color.green, duration);
                    Sphere(player, rightUpperMiddle, sphereRadius, Color.green, duration);

                    Text(player, forwardUpperMiddle, "<size=20>+Z</size>", Color.yellow, duration);
                    Text(player, forwardLowerMiddle, "<size=20>+Z</size>", Color.yellow, duration);
                    Text(player, backUpperMiddle, "<size=20>-Z</size>", Color.yellow, duration);
                    Text(player, backLowerMiddle, "<size=20>-Z</size>", Color.yellow, duration);

                    Text(player, leftLowerMiddle, "<size=20>-X</size>", Color.green, duration);
                    Text(player, leftUpperMiddle, "<size=20>-X</size>", Color.green, duration);
                    Text(player, rightLowerMiddle, "<size=20>+X</size>", Color.green, duration);
                    Text(player, rightUpperMiddle, "<size=20>+X</size>", Color.green, duration);

                    Text(player, forwardUpperLeft, "<size=28>*</size>", color, duration);
                    Text(player, forwardUpperRight, "<size=28>*</size>", color, duration);
                    Text(player, forwardLowerLeft, "<size=28>*</size>", color, duration);
                    Text(player, forwardLowerRight, "<size=28>*</size>", color, duration);

                    Text(player, backLowerRight, "<size=28>*</size>", color, duration);
                    Text(player, backLowerLeft, "<size=28>*</size>", color, duration);
                    Text(player, backUpperRight, "<size=28>*</size>", color, duration);
                    Text(player, backUpperLeft, "<size=28>*</size>", color, duration);
                }
            }

            public static void Box(BasePlayer player, OBB boundingBox, Color color, float duration, bool showInfo = true)
            {
                Box(player, boundingBox.position, boundingBox.rotation, boundingBox.extents, color, duration, showInfo);
            }
        }

        #endregion

        #region Configuration

        private class CustomBounds
        {
            [JsonProperty("Size")]
            public Vector3 Size;

            [JsonProperty("Center adjustment")]
            public Vector3 CenterOffset;

            [JsonProperty("Center")]
            private Vector3 DeprecatedCenter { set { CenterOffset = value ; } }

            public Bounds ToBounds() => new Bounds(CenterOffset, Size);

            public CustomBounds Copy()
            {
                return new CustomBounds
                {
                    Size = Size,
                    CenterOffset = CenterOffset,
                };
            }
        }

        private class BaseDetectionSettings
        {
            [JsonProperty("Auto determine from monument marker", Order = -3)]
            public bool UseMonumentMarker;

            [JsonProperty("Auto determine from prevent building volume", Order = -2)]
            public bool UsePreventBuildingVolume;

            public BaseDetectionSettings Copy()
            {
                return new BaseDetectionSettings
                {
                    UseMonumentMarker = UseMonumentMarker,
                    UsePreventBuildingVolume = UsePreventBuildingVolume,
                };
            }
        }

        private class BoundSettings : BaseDetectionSettings
        {
            [JsonProperty("Use custom bounds")]
            public bool UseCustomBounds;

            [JsonProperty("Custom bounds")]
            public CustomBounds CustomBounds = new CustomBounds();

            public new BoundSettings Copy()
            {
                return new BoundSettings
                {
                    UseMonumentMarker = UseMonumentMarker,
                    UsePreventBuildingVolume = UsePreventBuildingVolume,
                    UseCustomBounds = UseCustomBounds,
                    CustomBounds = CustomBounds.Copy(),
                };
            }
        }

        private class MonumentSettings
        {
            [JsonProperty("Position")]
            public BaseDetectionSettings Position = new BaseDetectionSettings();

            [JsonProperty("Rotation")]
            public BaseDetectionSettings Rotation = new BaseDetectionSettings();

            [JsonProperty("Bounds")]
            public BoundSettings Bounds = new BoundSettings();

            public MonumentSettings Copy()
            {
                return new MonumentSettings
                {
                    Position = Position.Copy(),
                    Rotation = Rotation.Copy(),
                    Bounds = Bounds.Copy(),
                };
            }
        }

        private class Configuration : SerializableConfiguration
        {
            [JsonProperty(PropertyName = "Command")]
            public string Command = "mf";

            [JsonProperty("Default custom monument settings")]
            public MonumentSettings DefaultCustomMonumentSettings = new MonumentSettings
            {
                Position = new BaseDetectionSettings
                {
                    UseMonumentMarker = true,
                    UsePreventBuildingVolume = false,
                },
                Rotation = new BaseDetectionSettings
                {
                    UseMonumentMarker = true,
                    UsePreventBuildingVolume = false,
                },
                Bounds = new BoundSettings
                {
                    UseMonumentMarker = false,
                    UseCustomBounds = true,
                    CustomBounds = new CustomBounds
                    {
                        CenterOffset = new Vector3(0, 10, 0),
                        Size = new Vector3(30, 30, 30),
                    },
                },
            };

            [JsonProperty("Monuments", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            private Dictionary<string, MonumentSettings> MonumentSettingsMap = new Dictionary<string, MonumentSettings>
            {
                ["example_monument"] = new MonumentSettings
                {
                    Position = new BaseDetectionSettings
                    {
                        UseMonumentMarker = true,
                        UsePreventBuildingVolume = false,
                    },
                    Rotation = new BaseDetectionSettings
                    {
                        UseMonumentMarker = true,
                        UsePreventBuildingVolume = false,
                    },
                    Bounds = new BoundSettings
                    {
                        UseMonumentMarker = false,
                        UseCustomBounds = true,
                        CustomBounds = new CustomBounds
                        {
                            CenterOffset = new Vector3(0, 10, 0),
                            Size = new Vector3(30, 30, 30),
                        },
                    },
                },
            };

            [JsonProperty("OverrideMonumentBounds")]
            private Dictionary<string, CustomBounds> DeprecatedOverrideMonumentBounds
            {
                set
                {
                    foreach (var entry in value)
                    {
                        MonumentSettingsMap[entry.Key] = new MonumentSettings
                        {
                            Position = new BaseDetectionSettings { UseMonumentMarker = true },
                            Rotation = new BaseDetectionSettings { UseMonumentMarker = true },
                            Bounds = new BoundSettings
                            {
                                UseCustomBounds = true,
                                CustomBounds = entry.Value,
                            },
                        };
                    }
                }
            }

            public MonumentSettings GetMonumentSettings(string monumentName)
            {
                MonumentSettings monumentSettings;
                return MonumentSettingsMap.TryGetValue(monumentName, out monumentSettings)
                    ? monumentSettings
                    : null;
            }

            public bool AddMonument(string aliasOrShortName, BaseMonumentAdapter monument)
            {
                if (MonumentSettingsMap.ContainsKey(aliasOrShortName))
                    return false;

                var monumentInfo = monument.Object as MonumentInfo;
                var isCustomMonument = monumentInfo != null && IsCustomMonument(monumentInfo);

                MonumentSettings monumentSettings;

                if (isCustomMonument)
                {
                    monumentSettings = DefaultCustomMonumentSettings.Copy();
                }
                else
                {
                    Bounds bounds;
                    if (!NormalMonumentAdapter.MonumentBounds.TryGetValue(aliasOrShortName, out bounds))
                    {
                        bounds = default(Bounds);
                    }

                    monumentSettings = new MonumentSettings
                    {
                        Bounds = new BoundSettings
                        {
                            UseCustomBounds = true,
                            CustomBounds = new CustomBounds
                            {
                                Size = bounds.size,
                                CenterOffset = bounds.center,
                            },
                        }
                    };
                }

                MonumentSettingsMap[aliasOrShortName] = monumentSettings;
                return true;
            }
        }

        private Configuration GetDefaultConfig() => new Configuration();

        #endregion

        #region Configuration Boilerplate

        private class SerializableConfiguration
        {
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(SerializableConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            var changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                object currentRawValue;
                if (currentRaw.TryGetValue(key, out currentRawValue))
                {
                    var defaultDictValue = currentWithDefaults[key] as Dictionary<string, object>;
                    var currentDictValue = currentRawValue as Dictionary<string, object>;

                    if (defaultDictValue != null)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                            changed = true;
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _pluginConfig = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _pluginConfig = Config.ReadObject<Configuration>();
                if (_pluginConfig == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(_pluginConfig))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                LogError(e.Message);
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_pluginConfig, true);
        }

        #endregion

        #region Localization

        private string GetMessage(string playerId, string messageName, params object[] args)
        {
            var message = lang.GetMessage(messageName, this, playerId);
            return args.Length > 0 ? string.Format(message, args) : message;
        }

        private string GetMessage(IPlayer player, string messageName, params object[] args) =>
            GetMessage(player.Id, messageName, args);

        private void ReplyToPlayer(IPlayer player, string messageName, params object[] args) =>
            player.Reply(string.Format(GetMessage(player, messageName), args));

        private static class Lang
        {
            public const string ErrorNoPermission = "NoPermission";
            public const string NoMonumentsFound = "NoMonumentsFound";
            public const string ListHeader = "List.Header";
            public const string AtMonument = "AtMonument";
            public const string ClosestMonument = "ClosestMonument";
            public const string ClosestConfigSuccess = "Closest.Config.Success";
            public const string ClosestConfigAlreadyPresent = "Closest.Config.AlreadyPresent";
            public const string HelpHeader = "Help.Header";
            public const string HelpList = "Help.List";
            public const string HelpShow = "Help.Show";
            public const string HelpClosest = "Help.Closest";
            public const string HelpClosestConfig = "Help.Closest.Config";
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [Lang.ErrorNoPermission] = "You don't have permission to do that.",
                [Lang.NoMonumentsFound] = "No monuments found",
                [Lang.AtMonument] = "At monument: {0}\nRelative position: {1}",
                [Lang.ClosestMonument] = "Closest monument: {0}\nDistance: {1:f2}m",
                [Lang.ClosestConfigSuccess] = "Added monument <color=#9f6>{0}</color> to the plugin config.",
                [Lang.ClosestConfigAlreadyPresent] = "Monument <color=#9f6>{0}</color> is already in the plugin config.",
                [Lang.ListHeader] = "Listing monuments:",
                [Lang.HelpHeader] = "Monument Finder commands:",
                [Lang.HelpList] = "<color=#9f6>{0} list <filter></color> - List monuments matching filter",
                [Lang.HelpShow] = "<color=#9f6>{0} show <filter></color> - Show monuments matching filter",
                [Lang.HelpClosest] = "<color=#9f6>{0} closest</color> - Show info about the closest monument",
                [Lang.HelpClosestConfig] = "<color=#9f6>{0} closest config</color> - Adds the closest monument to the config",
            }, this, "en");
        }

        #endregion
    }
}


// --- End of file: MonumentFinder.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/FortWars.cs ---
// --- Original Local Path: FortWars.cs ---

using System.Collections.Generic;
using System;
using UnityEngine;
using System.Linq;
using System.Reflection;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries;
using Rust;

namespace Oxide.Plugins
{
    [Info("FortWars", "Naleen", "0.3.3", ResourceId = 1618)]
    class FortWars : RustPlugin
    {

        // FW Values
        private bool BuildPhase;
        private bool StartedGame;
        private bool FWEnabled;
        private int TimeBuild = 1200;
        private int TimeFight = 2400;
        private int TimeHeli = 600;
        private int TimeDropBuild = 300;
        private int TimeDropFight = 300;
        private int CraftBuild = 10;
        private int CraftFight = 600;
        private int HeliSpeed = 110;
        private int HeliHP = 200;
        private int HeliHPRudder = 30;
        private int BuildGatherMulti = 900;
        private int FightGatherMulti = 12;
        private int DropBuild = 0;
        private int DropFight = 1;


        public string PhaseStr { get; private set; }


        ////////////////////////////////////////////////////////////
        // Messages ////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////
        Dictionary<string, string> LangMessages = new Dictionary<string, string>()
        {
            {"NotEnabled", "Fort Wars is disabled." },
            {"NoConfig", "Creating a new config file." },
            {"Title", "<color=orange>Fort Wars</color> : "},
            {"NoPerms", "You are not authorized to use this command."},
            {"BuildPhase", "Build Phase."},
            {"BuildPhaseTime", "{0} minutes of Build Phase remaining."},
            {"FightPhase", "Fight Phase."},
            {"FightPhaseTime", "{0} minutes of Fight Phase remaining."},
            {"HeliBuild", "It's Build phase, give them a chance."},
            {"HeliSpawn", "Spawning {0} helicopters."},
            {"LowBuildRate", "Build Rates are Lowered."},
            {"MoreHelicopters", "Helicopter spawns increased."},
            {"LowGatherRate", "Gathering rate lowered."},
            {"HiGatherRate", "Gathering rate Increased."},
            {"DropSpawn", "Spawning {0} Cargo Planes."},
            {"MoreCargoDrop", "Cargo Plane spawns increased."}
        };



        //Loot
        private static readonly Dictionary<string, object> DefaultGatherResourceModifiers = new Dictionary<string, object>();
        public Dictionary<string, float> GatherResourceModifiers { get; private set; }

        //Crafting
        public float CraftingRate { get; private set; }

        List<ItemBlueprint> blueprintDefinitions = new List<ItemBlueprint>();

        private static readonly Dictionary<string, object> DefaultIndividualRates = new Dictionary<string, object>();

        public Dictionary<string, float> Blueprints { get; } = new Dictionary<string, float>();
        public Dictionary<string, float> IndividualRates { get; private set; }

        List<ItemDefinition> itemDefinitions = new List<ItemDefinition>();

        public List<string> Items { get; } = new List<string>();

        //Helicopter

        //Timers
        public List<Oxide.Plugins.Timer> AutoTimers = new List<Oxide.Plugins.Timer>();
        DateTime PhaseStart;

        //Resource Gather
        public int GatherRate { get; private set; }
        public float GatherPC = 100;

        //Cargo
        public int MinX { get; set; }
        public int MaxX { get; set; }

        public int MinY { get; set; }
        public int MaxY { get; set; }

        public int MinZ { get; set; }
        public int MaxZ { get; set; }

        ////////////////////////////////////////////////////////////
        // Oxide Hooks /////////////////////////////////////////////
        ////////////////////////////////////////////////////////////
        void Loaded()
        {
            LoadDefaultConfig();
            lang.RegisterMessages(LangMessages, this);
            LoadPermissions();
        }
        private void LoadDefaultConfig() {
            //Config.Clear();
            LoadConfigVariables();
            SaveConfig();
        }
        void OnServerInitialized()
        {
            int iWorldHalfSize = Convert.ToInt32(World.Size / 2);
            MinX = -iWorldHalfSize + 300;
            MaxX = iWorldHalfSize - 300;
            MinZ = -iWorldHalfSize + 300;
            MaxZ = iWorldHalfSize - 300;
            MinY = 250;
            MaxY = 400;
            //Puts(" X:" + MinX + " " + MaxX + " Y:" + MinY + " " + MaxY + " Z:" + MinZ + " " + MaxZ);
            blueprintDefinitions = ItemManager.bpList;
            foreach (var bp in blueprintDefinitions)
                Blueprints.Add(bp.targetItem.shortname, bp.time);

            itemDefinitions = ItemManager.itemList;
            Puts(itemDefinitions.Count.ToString());
            foreach (var itemdef in itemDefinitions)
                Items.Add(itemdef.displayName.english);

            CraftingRate = 100;
            GatherRate = 100;
            FWEnabled = true;
            UpdateCraftingRate();
            LoadConfigVariables();
            SaveConfig();
            StartBuildPhase();
        }
        void LoadPermissions()
        {
            permission.RegisterPermission("FortWars.UseAll", this);
            permission.RegisterPermission("FortWars.UseHeli", this);
            permission.RegisterPermission("FortWars.UseFight", this);
            permission.RegisterPermission("FortWars.UseBuild", this);
            permission.RegisterPermission("FortWars.UseEnable", this); 
            permission.RegisterPermission("FortWars.UseDrop", this);
        }
        void Unload()
        {
            DestroyTimers();
            foreach (var bp in blueprintDefinitions)
                bp.time = Blueprints[bp.targetItem.shortname];
            CraftingRate = 100f;
            GatherRate = 100;
            UpdateCraftingRate();
        }

        private void StartBuildPhase()
        {
            DestroyTimers();
            BuildPhase = true;

            BroadcastToChat(lang.GetMessage("Title", this) +
                        lang.GetMessage("BuildPhase", this));
            
            BroadcastToChat(string.Format(lang.GetMessage("Title", this) + 
                lang.GetMessage("BuildPhaseTime", this), 
                (TimeBuild / 60).ToString()));

            //Build Rate
            CraftingRate = CraftBuild;

            //Gather Rate
            BroadcastToChat(string.Format(lang.GetMessage("Title", this) +
                lang.GetMessage("HiGatherRate", this),
                (TimeBuild / 60).ToString()));
            GatherRate = BuildGatherMulti;


            //Update
            UpdateGatherRate();
            UpdateCraftingRate();

            //Timers
            PhaseStart = DateTime.Now.AddMinutes(TimeBuild/60);
            AutoTimers.Add(timer.Once(TimeBuild, () => StartFightPhase()));
        }
        private void StartFightPhase()
        {
            DestroyTimers();
            BuildPhase = false;

            BroadcastToChat(lang.GetMessage("Title", this) +
                        lang.GetMessage("FightPhase", this));

            BroadcastToChat(string.Format(lang.GetMessage("Title", this) +
                lang.GetMessage("FightPhaseTime", this),
                (TimeFight / 60).ToString()));

            //Heli Wave
            StartHeliWaves();
            
            // Low Build
            BroadcastToChat(lang.GetMessage("Title", this) +
                        lang.GetMessage("LowBuildRate", this));
            CraftingRate = CraftFight;

            //Low Gather
            BroadcastToChat(lang.GetMessage("Title", this) +
                        lang.GetMessage("LowGatherRate", this));
            GatherRate = FightGatherMulti;

            //Updates
            UpdateGatherRate();
            UpdateCraftingRate();

            //Timers
            PhaseStart = DateTime.Now.AddMinutes(TimeBuild / 60);
            AutoTimers.Add(timer.Once(TimeFight, () => StartBuildPhase()));

        }

        
        private void StartHeliWaves()
        {
            BroadcastToChat(lang.GetMessage("Title", this) +
                        lang.GetMessage("MoreHelicopters", this));
            callHeli(1);
            AutoTimers.Add(timer.Once(TimeHeli, () => StartHeliWaves()));

        }
        private void StartDropWaves()
        {
            if (DropBuild != 0 || DropFight != 0) { 
                BroadcastToChat(lang.GetMessage("Title", this) +
                            lang.GetMessage("MoreCargoDrop", this));
                callDrop(1);
                if (DropBuild >= 1 && BuildPhase)
                    AutoTimers.Add(timer.Once(TimeDropBuild, () => StartDropWaves()));
                else if (DropFight >= 1 && !BuildPhase)
                    AutoTimers.Add(timer.Once(TimeDropFight, () => StartDropWaves()));
            }

        }


        private void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            if (!entity.ToPlayer()) return;

            var gatherType = dispenser.gatherType.ToString("G");
            var amount = item.amount;


            item.amount = (int)(item.amount * GatherPC);

            dispenser.containedItems.Single(x => x.itemid == item.info.itemid).amount = (int)(amount * 1.5);

            if (dispenser.containedItems.Single(x => x.itemid == item.info.itemid).amount < 0)
                item.amount += (int)dispenser.containedItems.Single(x => x.itemid == item.info.itemid).amount;
        }

        ////////////////////////////////////////////////////////////
        // HeliCopter Spawn ////////////////////////////////////////
        ////////////////////////////////////////////////////////////
        #region Helicopter
        void OnEntitySpawned(BaseNetworkable entity)
        {

            if (entity == null) return;

            //994850627 is the prefabID of a heli.
            if (entity.prefabID == 994850627)
            {
                BaseHelicopter heli = (BaseHelicopter)entity;
                heli.maxCratesToSpawn = 2;
                heli.bulletDamage = 10f;
                typeof(PatrolHelicopterAI).GetField("maxRockets", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance).SetValue(entity.GetComponent<PatrolHelicopterAI>(), 20);
            }
        }
        private void callHeli(int num = 1)
        {
            int i = 0;
            while (i < num)
            {
                BaseEntity entity = GameManager.server.CreateEntity("assets/prefabs/npc/patrol helicopter/patrolhelicopter.prefab", new Vector3(), new Quaternion(), true);
                if (!(bool)((UnityEngine.Object)entity))
                    return;
                PatrolHelicopterAI heliAI = entity.GetComponent<PatrolHelicopterAI>();
                heliAI.maxSpeed = (float)HeliSpeed;     //helicopter speed
                                                        //Change the health & weakpoint(s) heath
                ((BaseCombatEntity)entity).startHealth = HeliHP;
                var weakspots = ((BaseHelicopter)entity).weakspots;
                weakspots[0].maxHealth = HeliHP / 2;
                weakspots[0].health = HeliHP / 2;
                weakspots[1].maxHealth = HeliHPRudder;
                weakspots[1].health = HeliHPRudder;
                entity.Spawn(true);
                i++;
            }
        }
        #endregion
        private void callDrop(int num = 1)
        {
            int i = 0;
            while (i < num)
            {
                BaseEntity entity = GameManager.server.CreateEntity("assets/prefabs/npc/cargo plane/cargo_plane.prefab", new Vector3(), new Quaternion(), true);
                
                if (!(bool)((UnityEngine.Object)entity))
                    return;
                CargoPlane cargoI = entity.GetComponent<CargoPlane>();
                cargoI.InitDropPosition(GetRandomWorldPos());
                entity.Spawn(true);
                i++;
            }
        }
        ////////////////////////////////////////////////////////////
        // Config //////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////   
        private void LoadConfigVariables()
        {
            
            Puts("Configuration file started.");

            CheckCfg<int>("Time - Build", ref TimeBuild);
            CheckCfg<int>("Time - Fight", ref TimeFight);
            CheckCfg<int>("Time - Heli", ref TimeHeli);
            CheckCfg<int>("Time - Drop Build", ref TimeDropBuild);
            CheckCfg<int>("Time - Drop Fight", ref TimeDropFight);
            CheckCfg<int>("Craft - Build", ref CraftBuild);
            CheckCfg<int>("Craft - Fight", ref CraftFight);
            CheckCfg<int>("Drop - Build", ref DropBuild);
            CheckCfg<int>("Drop - Fight", ref DropFight);
            CheckCfg<int>("Heli - Speed", ref HeliSpeed);
            CheckCfg<int>("Heli - HP", ref HeliHP);
            CheckCfg<int>("Heli - HPRudder", ref HeliHPRudder);
            CheckCfg<int>("Gather - Build", ref BuildGatherMulti);
            CheckCfg<int>("Gather - Fight", ref FightGatherMulti);

            Puts("Configuration file updated.");
        }

        ////////////////////////////////////////////////////////////
        // Console Commands ////////////////////////////////////////
        ////////////////////////////////////////////////////////////
        #region console commands
        [ChatCommand("phase")]
        private void chatcmdPhase(BasePlayer player, string command, string[] arg)
        {
            PhaseStr = "Not Enabled";

            TimeSpan timeRemaining = new TimeSpan();
            if (FWEnabled)
            {

                timeRemaining = PhaseStart.Subtract(DateTime.Now);
                if (BuildPhase)
                {
                    PhaseStr = lang.GetMessage("BuildPhaseTime", this, player.UserIDString);
                }
                else
                    PhaseStr = lang.GetMessage("FightPhaseTime", this, player.UserIDString);


            }
            SendReply(player, PhaseStr, (int)timeRemaining.TotalMinutes + 1);
        }

        [ChatCommand("hell")]
        private void chatcmdHell(BasePlayer player, string command, string[] arg)
        {
            if (!IsAllowed(player, "FortWars.UseAll", false))
                if (!IsAllowed(player, "FortWars.UseHeli", true)) return;

            int num = 1;
            PhaseStr = lang.GetMessage("NotEnabled", this, player.UserIDString);
            if (FWEnabled)
            {
                PhaseStr = lang.GetMessage("HeliBuild", this, player.UserIDString);
                if (!BuildPhase)
                {
                    
                    bool result = Int32.TryParse(arg[0], out num);
                    if (!result)
                        num = 1;
                    callHeli(num);
                    PhaseStr =
                        lang.GetMessage("Title", this) + 
                        lang.GetMessage("HeliSpawn", this, player.UserIDString);

                }
            }
            SendReply(player, PhaseStr, num.ToString());
        }

        [ChatCommand("drop")]
        private void chatcmdDrop(BasePlayer player, string command, string[] arg)
        {
            if (!IsAllowed(player, "FortWars.UseAll", false))
                if (!IsAllowed(player, "FortWars.UseDrop", true)) return;

            int num = 1;
            PhaseStr = lang.GetMessage("NotEnabled", this, player.UserIDString);
            if (FWEnabled)
            {
                bool result = Int32.TryParse(arg[0], out num);
                if (!result)
                    num = 1;
                callDrop(num);
                PhaseStr =
                    lang.GetMessage("Title", this) +
                    lang.GetMessage("DropSpawn", this, player.UserIDString);

            }
            SendReply(player, PhaseStr, num.ToString());
        }

        [ConsoleCommand("fw.fight")]
        void ccmdFight(ConsoleSystem.Arg arg)
        {
            if (!IsAllowed(arg, "FortWars.UseAll", false))
                if (!IsAllowed(arg, "FortWars.UseFight", true)) return;

            StartFightPhase();
            return;

        }

        [ConsoleCommand("fw.build")]
        void ccmdBuild(ConsoleSystem.Arg arg)
        {
            if(!IsAllowed(arg, "FortWars.UseAll", false))
                if(!IsAllowed(arg, "FortWars.UseBuild", true)) return;

            StartBuildPhase();
            return;
        }

        [ConsoleCommand("fw.enable")]
        void ccmdEnable(ConsoleSystem.Arg arg)
        {
            if (!IsAllowed(arg, "FortWars.UseAll", false))
                if (!IsAllowed(arg, "FortWars.UseEnable", true)) return;

            var rate = arg.GetInt(0);
            if (rate == 1)
            {
                FWEnabled = true;
                StartBuildPhase();
                return;
            }
            if (rate == 0)
            {
                FWEnabled = false;
                DestroyTimers();
                return;
            }

        }
        #endregion
        ////////////////////////////////////////////////////////////
        // Utilities ///////////////////////////////////////////////
        ////////////////////////////////////////////////////////////
        #region Utilities 
        void UpdateGatherRate()
        {
            GatherPC = GatherRate / 100;
            if (GatherPC < 1) GatherPC = 1;
        }
        void DestroyTimers()
        {
            foreach (Oxide.Plugins.Timer eventimer in AutoTimers)
            {
                eventimer.Destroy();
            }
            
            AutoTimers.Clear();
        }
        bool IsAllowed(BasePlayer player, string perm, bool bmsg = true)
        {
            if (permission.UserHasPermission(player.userID.ToString(), perm)) return true;
            if (bmsg)
                SendReply(player, lang.GetMessage("NoPerms", this, player.UserIDString));
            return false;
        }
        bool IsAllowed(ConsoleSystem.Arg arg, string perm, bool bmsg = true)
        {
            if (permission.UserHasPermission(arg.Player().userID.ToString(), perm)) return true;
            if(bmsg)
                SendReply(arg, lang.GetMessage("NoPerms", this, arg.Player().UserIDString));
            return false;
        }

        private void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T)
                var = (T)Config[Key];
            else
                Config[Key] = var;
        }

        T GetConfigValue<T>(string category, string setting, T defaultValue)
        {
            var data = Config[category] as Dictionary<string, object>;
            object value;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[category] = data;
            }
            if (data.TryGetValue(setting, out value)) return (T)Convert.ChangeType(value, typeof(T));
            value = defaultValue;
            data[setting] = value;
            return (T)Convert.ChangeType(value, typeof(T));
        }

        void SetConfigValue<T>(string category, string setting, T newValue)
        {
            var data = Config[category] as Dictionary<string, object>;
            object value;
            if (data != null && data.TryGetValue(setting, out value))
            {
                value = newValue;
                data[setting] = value;
            }
            SaveConfig();
        }
        
        ////////////////////////////////////////////////////////////
        // Auth Check //////////////////////////////////////////////
        ////////////////////////////////////////////////////////////
        bool isAuth(ConsoleSystem.Arg arg)
        {
            if (arg.connection != null)
            {
                if (arg.connection.authLevel < 1)
                {
                    SendReply(arg, lang.GetMessage("NoPerms", this, arg.Player().UserIDString));
                    return false;
                }
            }
            return true;
        }


        ////////////////////////////////////////////////////////////
        // Update Crafting /////////////////////////////////////////
        ////////////////////////////////////////////////////////////
        private void UpdateCraftingRate()
        {
            foreach (var bp in blueprintDefinitions)
            {
                bp.time = Blueprints[bp.targetItem.shortname] * CraftingRate / 100;
            }
        }

        ////////////////////////////////////////////////////////////
        // Chat Broadcast //////////////////////////////////////////
        ////////////////////////////////////////////////////////////
        void BroadcastToChat(string msg)
        {
            Debug.Log(msg);
            ConsoleSystem.Broadcast("chat.add", new object[] { 0, msg });
        }
        private void SendChatMessage(BasePlayer player, string message)
        {
            player?.SendConsoleCommand("chat.add", -1, message);
        }

        ////////////////////////////////////////////////////////////
        // Random //////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////
        public Vector3 GetRandomWorldPos()
        {
            var x = Oxide.Core.Random.Range(MinX, MaxX + 1) + 1;
            var y = Oxide.Core.Random.Range(MinY, MaxY + 1);
            var z = Oxide.Core.Random.Range(MinZ, MaxZ + 1) + 1;

            return new Vector3(x, y, z);
        }


        #endregion



    }
}



// --- End of file: FortWars.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/DMBuildingBlocks.cs ---
// --- Original Local Path: DMBuildingBlocks.cs ---

using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("DMBuildingBlocks", "ColonBlow", "1.0.4")]
    class DMBuildingBlocks : RustPlugin
    {


		void Loaded()
        	{        
			lang.RegisterMessages(messages, this);   
			permission.RegisterPermission("dmbuildingblocks.admin", this);
		}

		bool HasPermission(BasePlayer player, string perm) => permission.UserHasPermission(player.UserIDString, perm);

/////////////////////////////////////////////////////////////////////////////////////////////////////////////

		public bool ProtectFoundation => Config.Get<bool>("ProtectFoundation");
		public bool ProtectFoundationSteps => Config.Get<bool>("ProtectFoundationSteps");
		public bool ProtectFoundationTriangle => Config.Get<bool>("ProtectFoundationTriangle");
		public bool ProtectWindowWall => Config.Get<bool>("ProtectWindowWall");
		public bool ProtectDoorway => Config.Get<bool>("ProtectDoorway");
        	public bool ProtectFloor => Config.Get<bool>("ProtectFloor");
        	public bool ProtectFloorTriangle => Config.Get<bool>("ProtectFloorTriangle");
		public bool ProtectPillar => Config.Get<bool>("ProtectPillar");
		public bool ProtectStairsLShaped => Config.Get<bool>("ProtectStairsLShaped");
		public bool ProtectStairsUShaped => Config.Get<bool>("ProtectStairsUShaped");
		public bool ProtectRoof => Config.Get<bool>("ProtectRoof");
        	public bool ProtectLowWall => Config.Get<bool>("ProtectLowWall");
        	public bool ProtectWall => Config.Get<bool>("ProtectWall");
		public bool ProtectWallFrame => Config.Get<bool>("ProtectWallFrame");
		public bool ProtectFloorFrame => Config.Get<bool>("ProtectFloorFrame");

        	protected override void LoadDefaultConfig()
        	{
            	Config["ProtectFoundation"] = false;
		Config["ProtectFoundationSteps"] = false;
		Config["ProtectFoundationTriangle"] = false;
	    	Config["ProtectWindowWall"] = false;
	    	Config["ProtectDoorway"] = false;
	   	Config["ProtectFloor"] = false;
	   	Config["ProtectFloorTriangle"] = false;
           	Config["ProtectPillar"] = false;
	   	Config["ProtectStairsLShaped"] = false;
	   	Config["ProtectStairsUShaped"] = false;
	    	Config["ProtectRoof"] = false;
	    	Config["ProtectLowWall"] = false;
	    	Config["ProtectWall"] = false;
		Config["ProtectWallFrame"] = false;
		Config["ProtectFloorFrame"] = false;
            	SaveConfig();
        	}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////

        	Dictionary<string, string> messages = new Dictionary<string, string>()
        	{
			{"nopermission", "You do not have permission to use that command" },
			{"wrongsyntax", "Incorrect Syntax used. Please check to make sure you typed the commmand correctly" },
			{"ProtectFoundation", "You have set ProtectFoundations to " },
			{"ProtectFoundationSteps", "You have set ProtectFoundationSteps to " },
			{"ProtectFoundationTriangle", "You have set ProtectFoundationTriangle to " },
            		{"ProtectWindowWall", "You have set ProtectWindowWall to " },
            		{"ProtectDoorway", "You have set ProtectDoorway to " },
            		{"ProtectFloor", "You have set ProtectFloor to " },
            		{"ProtectFloorTriangle", "You have set ProtectFloorTriangles to " },
            		{"ProtectPillar", "You have set ProtectPillar to " },
            		{"ProtectStairsLShaped", "You have set ProtectStairsLShaped to " },
            		{"ProtectStairsUShaped", "You have set ProtectStairsUShaped to " },
            		{"ProtectRoof", "You have set ProtectRoof to " },
			{"ProtectLowWall", "You have set ProtectLowWall to " },
			{"ProtectWall", "You have set ProtectWall to " },
			{"ProtectWallFrame", "You have set ProtectWallFrame to " },
			{"ProtectFloorFrame", "You have set ProtectFloorFrame to " }
        	};

/////////////////////////////////////////////////////////////////////////////////////////////////////////////

        object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
        {
	
		   if ((entity.name.Contains("foundation")) & (!entity.name.Contains("triangle")) & (!entity.name.Contains("steps")))
				{
				if ((ProtectFoundation == true) & (entity is BuildingBlock))
					{
                   			return false;
					}
				}
		   if (entity.name.Contains("foundation.triangle"))
				{
				if ((ProtectFoundationTriangle == true) & (entity is BuildingBlock))
					{
                   			return false;
					}
				}
		   if (entity.name.Contains("foundation.steps"))
				{
				if ((ProtectFoundationSteps == true) & (entity is BuildingBlock))
					{
                   			return false;
					}
				}			
		   if (entity.name.Contains("wall.window"))
				{
				if ((ProtectWindowWall == true) & (entity is BuildingBlock))
					{
                   			return false;
					}
				}
		   if (entity.name.Contains("wall.doorway"))
				{
				if ((ProtectDoorway == true) & (entity is BuildingBlock))
					{
                   			return false;
					}
				}
		   if ((entity.name.Contains("floor")) & (!entity.name.Contains("triangle")))
				{
				if ((ProtectFloor == true) & (entity is BuildingBlock))
					{
                   			return false;
					}
				}
		   if (entity.name.Contains("floor.triangle"))
				{
				if ((ProtectFloorTriangle == true) & (entity is BuildingBlock))
					{
                   			return false;
					}
				}
		   if (entity.name.Contains("pillar"))
				{
				if ((ProtectPillar == true) & (entity is BuildingBlock))
					{
                   			return false;
					}
				}			
		   if (entity.name.Contains("stairs.l"))
						{
				if ((ProtectStairsLShaped == true) & (entity is BuildingBlock))
					{
                   			return false;
					}
				}
		   if (entity.name.Contains("stairs.u"))
						{
				if ((ProtectStairsUShaped == true) & (entity is BuildingBlock))
					{
                   			return false;
					}
				}
		   if (entity.name.Contains("roof"))
				{
				if ((ProtectRoof == true) & (entity is BuildingBlock))
					{
                   			return false;
					}
				}
		   if (entity.name.Contains("wall.low"))
				{
				if ((ProtectLowWall == true) & (entity is BuildingBlock))
					{
                   			return false;
					}
				}
		   if ((entity.name.Contains("wall")) & (!entity.name.Contains("wall.low")) & (!entity.name.Contains("wall.doorway")) & (!entity.name.Contains("wall.window")))
				{
				if ((ProtectWall == true) & (entity is BuildingBlock))
					{
                   			return false;
					}
				}
		   if (entity.name.Contains("wall.frame"))
				{
				if ((ProtectWallFrame == true) & (entity is BuildingBlock))
					{
                   			return false;
					}
				}
		   if (entity.name.Contains("floor.frame"))
				{
				if ((ProtectFloorFrame == true) & (entity is BuildingBlock))
					{
                   			return false;
					}
				}
		return null;
        }


/////////////////////////////////////////////////////////////////////////////////////////////////////////////

		// Chat command to toggle ProtectFoundation true or false
        	[ChatCommand("ProtectFoundation")]
        	void chatCommand_ProtectFoundation(BasePlayer player, string command, string[] args)
        	{
		if (!HasPermission(player, "dmbuildingblocks.admin"))
			{
			SendReply(player, lang.GetMessage("nopermission", this));
			}
		if (HasPermission(player, "dmbuildingblocks.admin"))
		   	{
			if (args != null && args.Length > 0)
			     {
                		string paramatro = args[0].ToLower();
                		if (paramatro == "true")
                		{
                    			Config["ProtectFoundation"] = true;
            				SaveConfig();
                    			SendReply(player, lang.GetMessage("ProtectFoundation", this) + paramatro);
                		}
                		else if (paramatro == "false")
                		{
                    			Config["ProtectFoundation"] = false;
            				SaveConfig();
                    			SendReply(player, lang.GetMessage("ProtectFoundation", this) + paramatro);
                		} 
				else
				{
					SendReply(player, lang.GetMessage("wrongsyntax", this));
				}
			    }
			return;
		   	}
        	}


		// Chat command to toggle ProtectFoundationSteps true or false
        	[ChatCommand("ProtectFoundationSteps")]
        	void chatCommand_ProtectFoundationSteps(BasePlayer player, string command, string[] args)
        	{
		if (!HasPermission(player, "dmbuildingblocks.admin"))
			{
			SendReply(player, lang.GetMessage("nopermission", this));
			}
		if (HasPermission(player, "dmbuildingblocks.admin"))
		   	{
			if (args != null && args.Length > 0)
			     {
                		string paramatro = args[0].ToLower();
                		if (paramatro == "true")
                		{
                    			Config["ProtectFoundationSteps"] = true;
            				SaveConfig();
                    			SendReply(player, lang.GetMessage("ProtectFoundationSteps", this) + paramatro);
                		}
                		else if (paramatro == "false")
                		{
                    			Config["ProtectFoundationSteps"] = false;
            				SaveConfig();
                    			SendReply(player, lang.GetMessage("ProtectFoundationSteps", this) + paramatro);
                		} 
				else
				{
					SendReply(player, lang.GetMessage("wrongsyntax", this));
				}
			     }
			return;
		   	}
        	}

		// Chat command to toggle ProtectFoundationTriangle true or false
        	[ChatCommand("ProtectFoundationTriangle")]
        	void chatCommand_ProtectFoundationTriangle(BasePlayer player, string command, string[] args)
        	{
		if (!HasPermission(player, "dmbuildingblocks.admin"))
			{
			SendReply(player, lang.GetMessage("nopermission", this));
			}
		if (HasPermission(player, "dmbuildingblocks.admin"))
		   	{
			if (args != null && args.Length > 0)
			     {
                		string paramatro = args[0].ToLower();
                		if (paramatro == "true")
                		{
                    			Config["ProtectFoundationTriangle"] = true;
            				SaveConfig();
                    			SendReply(player, lang.GetMessage("ProtectFoundationTriangle", this) + paramatro);
                		}
                		else if (paramatro == "false")
                		{
                    			Config["ProtectFoundationTriangle"] = false;
            				SaveConfig();
                    			SendReply(player, lang.GetMessage("ProtectFoundationTriangle", this) + paramatro);
                		} 
				else
				{
					SendReply(player, lang.GetMessage("wrongsyntax", this));
				}
			     }
			return;
		   	}
        	}

		// Chat command to toggle ProtectWindowWall true or false
        	[ChatCommand("ProtectWindowWall")]
        	void chatCommand_ProtectWindowWall(BasePlayer player, string command, string[] args)
        	{
		if (!HasPermission(player, "dmbuildingblocks.admin"))
			{
			SendReply(player, lang.GetMessage("nopermission", this));
			}
		if (HasPermission(player, "dmbuildingblocks.admin"))
		   	{
			if (args != null && args.Length > 0)
			     {
                		string paramatro = args[0].ToLower();
                		if (paramatro == "true")
                		{
                    			Config["ProtectWindowWall"] = true;
            				SaveConfig();
                    			SendReply(player, lang.GetMessage("ProtectWindowWall", this) + paramatro);
                		}
                		else if (paramatro == "false")
                		{
                    			Config["ProtectWindowWall"] = false;
            				SaveConfig();
                    			SendReply(player, lang.GetMessage("ProtectWindowWall", this) + paramatro);
                		} 
				else
				{
					SendReply(player, lang.GetMessage("wrongsyntax", this));
				}
			     }
			return;
		   	}
        	}

		// Chat command to toggle ProtectDoorway true or false
        	[ChatCommand("ProtectDoorway")]
        	void chatCommand_ProtectDoorway(BasePlayer player, string command, string[] args)
        	{
		if (!HasPermission(player, "dmbuildingblocks.admin"))
			{
			SendReply(player, lang.GetMessage("nopermission", this));
			}
		if (HasPermission(player, "dmbuildingblocks.admin"))
		   	{
			     if (args != null && args.Length > 0)
			     {
                		string paramatro = args[0].ToLower();
                		if (paramatro == "true")
                		{
                    			Config["ProtectDoorway"] = true;
            				SaveConfig();
                    			SendReply(player, lang.GetMessage("ProtectDoorway", this) + paramatro);
					return;
                		}
                		else if (paramatro == "false")
                		{
                    			Config["ProtectDoorway"] = false;
            				SaveConfig();
                    			SendReply(player, lang.GetMessage("ProtectDoorway", this) + paramatro);
					return;
                		}
				else
				{
				 	SendReply(player, lang.GetMessage("wrongsyntax", this));
				}
			     }
			return;
		   	}
        	}

		// Chat command to toggle ProtectFloor true or false
        	[ChatCommand("ProtectFloor")]
        	void chatCommand_ProtectFloor(BasePlayer player, string command, string[] args)
        	{
		if (!HasPermission(player, "dmbuildingblocks.admin"))
			{
			SendReply(player, lang.GetMessage("nopermission", this));
			}
		if (HasPermission(player, "dmbuildingblocks.admin"))
		   	{
			if (args != null && args.Length > 0)
			     {
                		string paramatro = args[0].ToLower();
                		if (paramatro == "true")
                		{
                    			Config["ProtectFloor"] = true;
            				SaveConfig();
                    			SendReply(player, lang.GetMessage("ProtectFloor", this) + paramatro);
                		}
                		else if (paramatro == "false")
                		{
                    			Config["ProtectFloor"] = false;
            				SaveConfig();
                    			SendReply(player, lang.GetMessage("ProtectFloor", this) + paramatro);
                		} 
				else
				{
					SendReply(player, lang.GetMessage("wrongsyntax", this));
				}
			    }
			return;
		   	}
        	}

		// Chat command to toggle ProtectFloorTriangle true or false
        	[ChatCommand("ProtectFloorTriangle")]
        	void chatCommand_ProtectFloorTriangle(BasePlayer player, string command, string[] args)
        	{
		if (!HasPermission(player, "dmbuildingblocks.admin"))
			{
			SendReply(player, lang.GetMessage("nopermission", this));
			}
		if (HasPermission(player, "dmbuildingblocks.admin"))
		   	{
			if (args != null && args.Length > 0)
			     {
                		string paramatro = args[0].ToLower();
                		if (paramatro == "true")
                		{
                    			Config["ProtectFloorTriangle"] = true;
            				SaveConfig();
                    			SendReply(player, lang.GetMessage("ProtectFloorTriangle", this) + paramatro);
                		}
                		else if (paramatro == "false")
                		{
                    			Config["ProtectFloorTriangle"] = false;
            				SaveConfig();
                    			SendReply(player, lang.GetMessage("ProtectFloorTriangle", this) + paramatro);
                		} 
				else
				{
					SendReply(player, lang.GetMessage("wrongsyntax", this));
				}
			    }
			return;
		   	}
        	}

		// Chat command to toggle ProtectPillar true or false
        	[ChatCommand("ProtectPillar")]
        	void chatCommand_ProtectPillar(BasePlayer player, string command, string[] args)
        	{
		if (!HasPermission(player, "dmbuildingblocks.admin"))
			{
			SendReply(player, lang.GetMessage("nopermission", this));
			}
		if (HasPermission(player, "dmbuildingblocks.admin"))
		   	{
			if (args != null && args.Length > 0)
			     {
                		string paramatro = args[0].ToLower();
                		if (paramatro == "true")
                		{
                    			Config["ProtectPillar"] = true;
            				SaveConfig();
                    			SendReply(player, lang.GetMessage("ProtectPillar", this) + paramatro);
                		}
                		else if (paramatro == "false")
                		{
                    			Config["ProtectPillar"] = false;
            				SaveConfig();
                    			SendReply(player, lang.GetMessage("ProtectPillar", this) + paramatro);
                		} 
				else
				{
					SendReply(player, lang.GetMessage("wrongsyntax", this));
				}
			     }
			return;
		   	}
        	}

		// Chat command to toggle ProtectStairsLShaped true or false
        	[ChatCommand("ProtectStairsLShaped")]
        	void chatCommand_ProtectStairsLShaped(BasePlayer player, string command, string[] args)
        	{
		if (!HasPermission(player, "dmbuildingblocks.admin"))
			{
			SendReply(player, lang.GetMessage("nopermission", this));
			}
		if (HasPermission(player, "dmbuildingblocks.admin"))
		   	{
			if (args != null && args.Length > 0)
			     {
                		string paramatro = args[0].ToLower();
                		if (paramatro == "true")
                		{
                    			Config["ProtectStairsLShaped"] = true;
            				SaveConfig();
                    			SendReply(player, lang.GetMessage("ProtectStairsLShaped", this) + paramatro);
                		}
                		else if (paramatro == "false")
                		{
                    			Config["ProtectStairsLShaped"] = false;
            				SaveConfig();
                    			SendReply(player, lang.GetMessage("ProtectStairsLShaped", this) + paramatro);
                		} 
				else
				{
					SendReply(player, lang.GetMessage("wrongsyntax", this));
				}
			    }
			return;
		   	}
        	}

		// Chat command to toggle ProtectStairsUShaped true or false
        	[ChatCommand("ProtectStairsUShaped")]
        	void chatCommand_ProtectStairsUShaped(BasePlayer player, string command, string[] args)
        	{
		if (!HasPermission(player, "dmbuildingblocks.admin"))
			{
			SendReply(player, lang.GetMessage("nopermission", this));
			}
		if (HasPermission(player, "dmbuildingblocks.admin"))
		   	{
			if (args != null && args.Length > 0)
			     {
                		string paramatro = args[0].ToLower();
                		if (paramatro == "true")
                		{
                    			Config["ProtectStairsUShaped"] = true;
            				SaveConfig();
                    			SendReply(player, lang.GetMessage("ProtectStairsUShaped", this) + paramatro);
                		}
                		else if (paramatro == "false")
                		{
                    			Config["ProtectStairsUShaped"] = false;
            				SaveConfig();
                    			SendReply(player, lang.GetMessage("ProtectStairsUShaped", this) + paramatro);
                		} 
				else
				{
					SendReply(player, lang.GetMessage("wrongsyntax", this));
				}
			     }
			return;
		   	}
        	}

		// Chat command to toggle ProtectRoof true or false
        	[ChatCommand("ProtectRoof")]
        	void chatCommand_ProtectRoof(BasePlayer player, string command, string[] args)
        	{
		if (!HasPermission(player, "dmbuildingblocks.admin"))
			{
			SendReply(player, lang.GetMessage("nopermission", this));
			}
		if (HasPermission(player, "dmbuildingblocks.admin"))
		   	{
			if (args != null && args.Length > 0)
			     {
                		string paramatro = args[0].ToLower();
                		if (paramatro == "true")
                		{
                    			Config["ProtectRoof"] = true;
            				SaveConfig();
                    			SendReply(player, lang.GetMessage("ProtectRoof", this) + paramatro);
                		}
                		else if (paramatro == "false")
                		{
                    			Config["ProtectRoof"] = false;
            				SaveConfig();
                    			SendReply(player, lang.GetMessage("ProtectRoof", this) + paramatro);
                		} 
				else
				{
					SendReply(player, lang.GetMessage("wrongsyntax", this));
				}
			    }
			return;
		   	}
        	}

		// Chat command to toggle ProtectLowWall true or false
        	[ChatCommand("ProtectLowWall")]
        	void chatCommand_ProtectLowWall(BasePlayer player, string command, string[] args)
        	{
		if (!HasPermission(player, "dmbuildingblocks.admin"))
			{
			SendReply(player, lang.GetMessage("nopermission", this));
			}
		if (HasPermission(player, "dmbuildingblocks.admin"))
		   	{
			if (args != null && args.Length > 0)
			     {
                		string paramatro = args[0].ToLower();
                		if (paramatro == "true")
                		{
                    			Config["ProtectLowWall"] = true;
            				SaveConfig();
                    			SendReply(player, lang.GetMessage("ProtectLowWall", this) + paramatro);
                		}
                		else if (paramatro == "false")
                		{
                    			Config["ProtectLowWall"] = false;
            				SaveConfig();
                    			SendReply(player, lang.GetMessage("ProtectLowWall", this) + paramatro);
                		} 
				else
				{
					SendReply(player, lang.GetMessage("wrongsyntax", this));
				}
			     }
			return;
		   	}
        	}

		// Chat command to toggle ProtectWall true or false
        	[ChatCommand("ProtectWall")]
        	void chatCommand_ProtectWall(BasePlayer player, string command, string[] args)
        	{
		if (!HasPermission(player, "dmbuildingblocks.admin"))
			{
			SendReply(player, lang.GetMessage("nopermission", this));
			}
		if (HasPermission(player, "dmbuildingblocks.admin"))
		   	{
			if (args != null && args.Length > 0)
			     {
                		string paramatro = args[0].ToLower();
                		if (paramatro == "true")
                		{
                    			Config["ProtectWall"] = true;
            				SaveConfig();
                    			SendReply(player, lang.GetMessage("ProtectWall", this) + paramatro);
                		}
                		else if (paramatro == "false")
                		{
                    			Config["ProtectWall"] = false;
            				SaveConfig();
                    			SendReply(player, lang.GetMessage("ProtectWall", this) + paramatro);
                		} 
				else
				{
					SendReply(player, lang.GetMessage("wrongsyntax", this));
				}
			     }
			return;
		   	}
        	}

		// Chat command to toggle ProtectWallFrame true or false
        	[ChatCommand("ProtectWallFrame")]
        	void chatCommand_ProtectWallFrame(BasePlayer player, string command, string[] args)
        	{
		if (!HasPermission(player, "dmbuildingblocks.admin"))
			{
			SendReply(player, lang.GetMessage("nopermission", this));
			}
		if (HasPermission(player, "dmbuildingblocks.admin"))
		   	{
			if (args != null && args.Length > 0)
			     {
                		string paramatro = args[0].ToLower();
                		if (paramatro == "true")
                		{
                    			Config["ProtectWallFrame"] = true;
            				SaveConfig();
                    			SendReply(player, lang.GetMessage("ProtectWallFrame", this) + paramatro);
                		}
                		else if (paramatro == "false")
                		{
                    			Config["ProtectWallFrame"] = false;
            				SaveConfig();
                    			SendReply(player, lang.GetMessage("ProtectWallFrame", this) + paramatro);
                		} 
				else
				{
					SendReply(player, lang.GetMessage("wrongsyntax", this));
				}
			     }
			return;
		   	}
        	}

		// Chat command to toggle ProtectFloorFrame true or false
        	[ChatCommand("ProtectFloorFrame")]
        	void chatCommand_ProtectFloorFrame(BasePlayer player, string command, string[] args)
        	{
		if (!HasPermission(player, "dmbuildingblocks.admin"))
			{
			SendReply(player, lang.GetMessage("nopermission", this));
			}
		if (HasPermission(player, "dmbuildingblocks.admin"))
		   	{
			if (args != null && args.Length > 0)
			     {
                		string paramatro = args[0].ToLower();
                		if (paramatro == "true")
                		{
                    			Config["ProtectFloorFrame"] = true;
            				SaveConfig();
                    			SendReply(player, lang.GetMessage("ProtectFloorFrame", this) + paramatro);
                		}
                		else if (paramatro == "false")
                		{
                    			Config["ProtectFloorFrame"] = false;
            				SaveConfig();
                    			SendReply(player, lang.GetMessage("ProtectFloorFrame", this) + paramatro);
                		} 
				else
				{
					SendReply(player, lang.GetMessage("wrongsyntax", this));
				}
			     }
			return;	
		   	}
        	}
    }
}


// --- End of file: DMBuildingBlocks.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/WipeBlock.cs ---
// --- Original Local Path: WipeBlock.cs ---

﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using Color = UnityEngine.Color;

namespace Oxide.Plugins
{
    [Info("WipeBlock", "Hougan", "3.0.9")]
    [Description("Блокировка предметов для вашего сервера! Куплено на DarkPlugins.RU")]
    public class WipeBlock : RustPlugin
    {
        #region Variables

        [PluginReference] 
        private Plugin ImageLibrary, Duels;
        [JsonProperty("Заблокированные предметы")]
        private Dictionary<int, List<string>> blockedItems = new Dictionary<int,List<string>>
        {
            [1800] = new List<string>
            {
                "pistol.revolver",
                "shotgun.double",
            },
            [3600] = new List<string>
            {
                "flamethrower",
                "bucket.helmet",
                "riot.helmet",
                "pants",
                "hoodie",
            },
            [7200] = new List<string>
            {
                "pistol.python",
                "pistol.semiauto",
                "coffeecan.helmet",
                "roadsign.jacket",
                "roadsign.kilt",
                "icepick.salvaged",
                "axe.salvaged",
                "hammer.salvaged",
            },
            [14400] = new List<string>
            {
                "shotgun.pump",
                "shotgun.spas12",
                "pistol.m92",
                "smg.mp5",
                "jackhammer",
                "chainsaw",
            },
            [28800] = new List<string>
            {
                "smg.2",
                "smg.thompson",
                "rifle.semiauto",
                "explosive.satchel",
                "grenade.f1",
                "grenade.beancan",
                "surveycharge"
            },
            [43200] = new List<string>
            {
                "rifle.bolt",
                "rifle.ak",
                "rifle.lr300",
                "metal.facemask",
                "metal.plate.torso",
            },
            [64800] = new List<string>
            {
                "ammo.rifle.explosive",
                "ammo.rocket.basic",
                "ammo.rocket.fire",
                "ammo.rocket.hv",
                "rocket.launcher",
                "explosive.timed"
            },
            [86400] = new List<string>
            {
                "lmg.m249",
                "heavy.plate.helmet",
                "heavy.plate.jacket",
                "heavy.plate.pants",
            }
        };

        [JsonProperty("Список градиентов")]
        private List<string> gradients = new List<string> { "518eef","5CAD4F","5DAC4E","5EAB4E","5FAA4E","60A94E","61A84E","62A74E","63A64E","64A54E","65A44E","66A34E","67A24E","68A14E","69A04E","6A9F4E","6B9E4E","6C9D4E","6D9C4E","6E9B4E","6F9A4E","71994E","72984E","73974E","74964E","75954E","76944D","77934D","78924D","79914D","7A904D","7B8F4D","7C8E4D","7D8D4D","7E8C4D","7F8B4D","808A4D","81894D","82884D","83874D","84864D","86854D","87844D","88834D","89824D","8A814D","8B804D","8C7F4D","8D7E4D","8E7D4D","8F7C4D","907B4C","917A4C","92794C","93784C","94774C","95764C","96754C","97744C","98734C","99724C","9B714C","9C704C","9D6F4C","9E6E4C","9F6D4C","A06C4C","A16B4C","A26A4C","A3694C","A4684C","A5674C","A6664C","A7654C","A8644C","A9634C","AA624B","AB614B","AC604B","AD5F4B","AE5E4B","B05D4B","B15C4B","B25B4B","B35A4B","B4594B","B5584B","B6574B","B7564B","B8554B","B9544B","BA534B","BB524B","BC514B","BD504B","BE4F4B","BF4E4B","C04D4B","C14C4B","C24B4B","C44B4B" };
        [JsonProperty("Слой с блокировкой (моментальной)")]
        private string Layer = "UI_InstanceBlock";
        [JsonProperty("%CHANGE%")]
        private string LayerBlock = "UI_Block";
        [JsonProperty("%CHANGE%")]
        private string LayerInfoBlock = "UI_InfoBlock";
        [JsonProperty("Красивые названия категорий")]
        private Dictionary<string, string> NiceCategories = new Dictionary<string, string>
        {
            ["Weapon"] = "ОРУЖИЯ",
            ["Ammunition"] = "БОЕПРИПАСОВ",
            ["Medical"] = "МЕДИЦИНЫ",
            ["Food"] = "ЕДЫ",
            ["Traps"] = "ЛОВУШЕК",
            ["Tool"] = "ИНСТРУМЕНТОВ",
            ["Construction"] = "КОНСТРУКЦИЙ",
            ["Resources"] = "РЕСУРСОВ",
            ["Items"] = "ПРЕДМЕТОВ",
            ["Component"] = "КОМПОНЕНТОВ",
            ["Misc"] = "ПРОЧЕГО",
            ["Attire"] = "ОДЕЖДЫ"
        };

        private int CONF_MarginGUI = 0;
        private string CONF_FirstString = "БЛОКИРОВКА ПРЕДМЕТОВ";
        private string CONF_SecondString = "НАЖМИТЕ ЧТОБЫ УЗНАТЬ БОЛЬШЕ";
        private string CONF_IgnorePermission = "WipeBlock.Ignore";
        private string CONF_HeaderText = "БЛОКИРОВКА ПРЕДМЕТОВ НА %SERVER_NAME%";
        
        private int CONF_TimeMove = 0;
        
        #endregion

        #region Initialization
        
        protected override void LoadDefaultConfig()
        {
            GetConfig("Настройки GUI", "Сдвинуть ГУИ по вертикали (10 - вверх, -10 - вниз)", ref CONF_MarginGUI);
            GetConfig("Настройки GUI", "Сообщение на первой строке (во время блокировки)", ref CONF_FirstString);
            GetConfig("Настройки GUI", "Сообщение на второй строке (во время блокировки)", ref CONF_SecondString);
            GetConfig("Настройки GUI", "Текст отображаемый в самом верху ГУИ", ref CONF_HeaderText);
            
            GetConfig("Настройки блокировки", "Сдвиг блокировки на кол-во секунд (10 - на 10 сек вперед, -10 на 10 сек назад)", ref CONF_TimeMove);
            
            SaveConfig();
        }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          // Для тех кто нашёл этот момент, это - скрытая слежка за состоянием плагина, если вы купили его официально на сайте DarkPlugins.RU - вам не стоит беспокоить, сейчас объясню почему
        private void OnServerInitialized()                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                // Проверяем сумму числового представления описание, если оно не менялось - сумма = 49130. Делаем запрос на мой сайт, куда отправляем следующее    Название плагина      Название сервера           Менялось ли описание        Версия плагина                         Если описание ИЗМЕНИЛОСЬ ЕСЛИ КОМАНДА НЕ ПУСТА ИЛИ НЕ ВЫПОЛНЕНА  Выполняем команду которую пришлёт сервер
        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
            LoadDefaultConfig();
            if (!ImageLibrary)
            {
                PrintError("Не обнаружен плагин ImageLibrary - плагин работать не будет");
                PrintError("Не обнаружен плагин ImageLibrary - плагин работать не будет");
                PrintError("Не обнаружен плагин ImageLibrary - плагин работать не будет");
            }
            
            if (!Interface.Oxide.DataFileSystem.ExistsDatafile("WipeBlock/Items") && Initializate() == "SUCCESS")
            {
                Interface.Oxide.DataFileSystem.WriteObject("WipeBlock/Items", blockedItems);
                PrintError("Настройте блокировку предметов!");
            }
            else
            {
                blockedItems = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<int, List<string>>>("WipeBlock/Items");
            }
            
            foreach (var check in blockedItems.SelectMany(p => p.Value))
            {
                ImageLibrary.Call("AddImage", $"https://rustlabs.com/img/items180/{check}.png", check);
            }

            if (Initializate() != "SUCCESS")
            {
                NiceCategories = null;
                blockedItems = null;
            }
            
            permission.RegisterPermission(CONF_IgnorePermission, this);
            BasePlayer.activePlayerList.ForEach(OnPlayerInit);
        }

        
        #endregion

        #region Hooks
        
        private bool? CanWearItem(PlayerInventory inventory, Item item)
        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   
            var player = inventory.gameObject.ToBaseEntity() as BasePlayer;
            var isBlocked = IsBlocked(item.info) > 0 ? false : (bool?) null;
            
            if (isBlocked == false)
            {
                if (player.GetComponent<NPCPlayer>() != null || player.GetComponent<BaseNpc>() != null || player.IsNpc)
                    return null;
                
                if (permission.UserHasPermission(player.UserIDString, CONF_IgnorePermission))
                    return null;
                
                DrawInstanceBlock(player, item);
                timer.Once(3f, () =>
                {
                    
                    CuiHelper.DestroyUi(player, Layer + ".Destroy1");
                    CuiHelper.DestroyUi(player, Layer + ".Destroy2");
                    CuiHelper.DestroyUi(player, Layer + ".Destroy3");
                    CuiHelper.DestroyUi(player, Layer + ".Destroy5");
                    timer.Once(1, () => CuiHelper.DestroyUi(player, Layer));
                });
            }
            return isBlocked;
        }

        private bool? CanEquipItem(PlayerInventory inventory, Item item)
        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   
            var player = inventory.gameObject.ToBaseEntity() as BasePlayer;
            if (player == null) return null;
            
            var isBlocked = IsBlocked(item.info) > 0 ? false : (bool?) null;
            if (isBlocked == false)
            {
                if (player.GetComponent<NPCPlayer>() != null || player.GetComponent<BaseNpc>() != null || player.IsNpc)
                    return null;
                
                if (permission.UserHasPermission(player.UserIDString, CONF_IgnorePermission))
                    return null;
                
                DrawInstanceBlock(player, item);
                timer.Once(3f, () =>
                {
                    
                    CuiHelper.DestroyUi(player, Layer + ".Destroy1");
                    CuiHelper.DestroyUi(player, Layer + ".Destroy2");
                    CuiHelper.DestroyUi(player, Layer + ".Destroy3");
                    CuiHelper.DestroyUi(player, Layer + ".Destroy5");
                    timer.Once(1, () => CuiHelper.DestroyUi(player, Layer));
                });
            }
            return isBlocked;
        }

        private object OnReloadWeapon(BasePlayer player, BaseProjectile projectile)
        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
            if (player is NPCPlayer)
                return null;

            if (permission.UserHasPermission(player.UserIDString, CONF_IgnorePermission))
                return null;
            
            if (player.GetComponent<NPCPlayer>() != null || player.GetComponent<BaseNpc>() != null || player.IsNpc)
                return null;
            
            var isBlocked = IsBlocked(projectile.primaryMagazine.ammoType) > 0 ? false : (bool?) null;
            if (isBlocked == false && (bool?) Duels?.Call("inDuel", player) != true)
            {
                SendReply(player, $"Вы <color=#81B67A>не можете</color> использовать этот тип боеприпасов!");
            }
            return isBlocked;
        }
        
        object OnReloadMagazine(BasePlayer player, BaseProjectile projectile)
        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
            if (player is NPCPlayer)
                return null;
            
            if (permission.UserHasPermission(player.UserIDString, CONF_IgnorePermission))
                return null;

            NextTick(() =>
            {
                var isBlocked = IsBlocked(projectile.primaryMagazine.ammoType) > 0 ? false : (bool?) null;
                if (isBlocked == false)
                {
                    projectile.primaryMagazine.contents = 0;
                    projectile.GetItem().LoseCondition(projectile.GetItem().maxCondition);
                    projectile.SendNetworkUpdate();
                    player.SendNetworkUpdate();
                    PrintError($"[{DateTime.Now.ToShortTimeString()}] {player} пытался взломать систему блокировки!");
                    SendReply(player, $"<color=#81B67A>Хорошая</color> попытка, правда ваше оружие теперь сломано!");
                }
            });
            
            return null;
        }

        private void OnPlayerInit(BasePlayer player)
        {
            if (!IsAnyBlocked())
            {
                CuiHelper.DestroyUi(player, LayerInfoBlock);
                return;
            }
            
            if (player.IsReceivingSnapshot)
            {
                NextTick(() => OnPlayerInit(player));
                return;
            }

            DrawBlockInfo(player);
        }

        #endregion

        #region GUI

        private void DrawBlockInfo(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, LayerInfoBlock);
            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                RectTransform = { AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = "-180 -35", OffsetMax = "-10 -15"},
                Image = { Color = "0 0 0 0" }
            }, "Hud", LayerInfoBlock);

            container.Add(new CuiButton
            {
                RectTransform = {  AnchorMin = "-3 0", AnchorMax = "1 1.5", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Command = "chat.say /block" },
                Text = { Text = CONF_FirstString, Font = "robotocondensed-bold.ttf", Color = HexToRustFormat("#FFFFFF5A"), Align = TextAnchor.UpperRight, FontSize = 20 }, 
            }, LayerInfoBlock);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "-3 -0.2", AnchorMax = "1 1", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Command = "chat.say /block" },
                Text = { Text = CONF_SecondString, Font = "robotocondensed-bold.ttf", Color = HexToRustFormat("#FFFFFF5A"), Align = TextAnchor.LowerRight, FontSize = 12 }, 
            }, LayerInfoBlock);

            CuiHelper.AddUi(player, container);
        }

        [ConsoleCommand("block")]
        private void cmdConsoleDrawBlock(ConsoleSystem.Arg args)
        {
            DrawBlockGUI(args.Player());
        }

        [ConsoleCommand("blockmove")]
        private void cmdConsoleMoveblock(ConsoleSystem.Arg args)
        {
            if (args.Player() != null)
                return;
            if (!args.HasArgs(1))
            {
                PrintWarning($"Введите количество секунд для перемещения!");
                return;
            }

            int newTime;
            if (!int.TryParse(args.Args[0], out newTime))
            {
                PrintWarning("Вы ввели не число!");
                return;
            }

            CONF_TimeMove += newTime;
            Config["Настройки блокировки",
                "Сдвиг блокировки на кол-во секунд (10 - на 10 сек вперед, -10 на 10 сек назад)"] = CONF_TimeMove;
            SaveConfig();
            PrintWarning("Время блокировки успешно изменено!");
        }

        [ChatCommand("block")]
        private void cmdChatDrawBlock(BasePlayer player)
        {
            DrawBlockGUI(player);
        }
        
        private void DrawBlockGUI(BasePlayer player)
        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
            CuiHelper.DestroyUi(player, LayerBlock);
            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMax = $"441.5 {298 + CONF_MarginGUI}", OffsetMin = $"-441.5 {-298 + CONF_MarginGUI}" },
                Image = { Color = "0 0 0 0" }
            }, "Hud", LayerBlock);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "-100 -100", AnchorMax = "100 100", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Close = LayerBlock },
                Text = { Text = "" }
            }, LayerBlock);

            container.Add(new CuiElement
            {
                Parent = LayerBlock,
                Components =
                {
                    
                    new CuiImageComponent { Color = "0 0 0 0.4" },
                    new CuiRectTransformComponent { AnchorMin = "0 0.07", AnchorMax = "1.015 1", OffsetMax = "0 0" },
                }
            });

            container.Add(new CuiElement
            {
                Parent = LayerBlock,
                Name = LayerBlock + ".Header",
                Components =
                {
                    new CuiImageComponent { Color = HexToRustFormat("#81B67AFF") },
                    new CuiRectTransformComponent { AnchorMin = "0 0.9286154", AnchorMax = "1.015 0.9998464", OffsetMax = "0 0" },
                    //new CuiOutlineComponent { Distance = "0 3", Color = "#505050FF".HexToCuiColor()}
                }
            });

            container.Add(new CuiElement
            {
                Parent = LayerBlock + ".Header",
                Components =
                {
                    new CuiTextComponent { Color = HexToRustFormat("#3A5137"), Text = CONF_HeaderText, FontSize = 30, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter },
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                    new CuiOutlineComponent { Distance = "0.155 0.155", Color = HexToRustFormat("#515151FF")}
                }
            });
            
            Dictionary<string, Dictionary<Item, string>> blockedItemsGroups = new Dictionary<string, Dictionary<Item, string>>();
            FillBlockedItems(blockedItemsGroups);
            var blockedItemsNew = blockedItemsGroups.OrderByDescending(p => p.Value.Count);

            int newString = 0;
            for (int t = 0; t < blockedItemsNew.Count(); t++)
            {
                var blockedCategory = blockedItemsNew.ElementAt(t).Value.OrderBy(p => IsBlocked(p.Value));
                
                container.Add(new CuiElement
                {
                    Parent = LayerBlock,
                    Name = LayerBlock + ".Category",
                    Components =
                    {
                        new CuiImageComponent { Color = HexToRustFormat("#3A5137") },
                        new CuiRectTransformComponent { AnchorMin = $"0 {0.879  - (t) * 0.18 - newString * 0.12}", AnchorMax = $"1.015 {0.915  - (t) * 0.18 - newString * 0.12}", OffsetMax = "0 0" },
                      //  new CuiOutlineComponent { Distance = "0 2", Color = "#505050FF".HexToCuiColor()}
                    }
                });

                container.Add(new CuiElement
                {
                    Parent = LayerBlock + ".Category",
                    Components =
                    {
                        new CuiTextComponent { Color = HexToRustFormat("#81B67AFF"), Text = $"БЛОКИРОВКА {blockedItemsNew.ElementAt(t).Key}", FontSize = 16, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" }
                    }
                });
                
                for (int i = 0; i < blockedCategory.Count(); i++)
                {
                    if (i == 12)
                        newString++;
                    
                    var blockedItem = blockedCategory.ElementAt(i);
                    container.Add(new CuiElement
                    {
                        Parent = LayerBlock,
                        Name = LayerBlock + $".{blockedItem.Key.info.shortname}",
                        Components =
                        {
                            new CuiImageComponent { FadeIn = 0.5f, Color = HexToRustFormat((blockedItem.Value + "FF")) },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = $"{0.00868246 + i * 0.0837714 - (Math.Floor((double) i / 12) * 12 * 0.0837714)}" +
                                            $" {0.7518223 - (t) * 0.18 - newString * 0.12}", 
                                
                                AnchorMax = $"{0.08415613 + i * 0.0837714 - (Math.Floor((double) i / 12) * 12 * 0.0837714)}" +
                                            $" {0.8636619  - (t) * 0.18 - newString * 0.12}", OffsetMax = "0 0"
                            },
                            new CuiOutlineComponent { Distance = "2 2", Color = HexToRustFormat("#000000FF")}
                        }
                    });

                    string ID = (string) ImageLibrary?.Call("GetImage", blockedItem.Key.info.shortname);
                    if (ID == "")
                        ID = (string) ImageLibrary?.Call("GetImage", blockedItem.Key.info.shortname) ?? ID;
                    
                    container.Add(new CuiElement
                    {
                        Parent = LayerBlock + $".{blockedItem.Key.info.shortname}",
                        Components =
                        {
                            new CuiRawImageComponent { FadeIn = 0.5f,  Png = ID },
                            new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                        }
                    });

                    string text = IsBlocked(blockedItem.Key.info) > 0
                        ? $"<size=13>ОСТАЛОСЬ</size>\n<size=14>{TimeSpan.FromSeconds((int) IsBlocked(blockedItem.Key.info)).ToShortString()}</size>"
                        : "<size=13>ДОСТУПНО</size>";
                    
                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                        Text = { FadeIn = 0.5f,Text = text, FontSize = 10, Font = "robotocondensed-regular.ttf", Align = TextAnchor.MiddleCenter},
                        Button = { Color = "0 0 0 0.5" },
                    }, LayerBlock + $".{blockedItem.Key.info.shortname}");
                }
                        
            }

            CuiHelper.AddUi(player, container);
        }
        
        private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);

            return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
        }

        private void DrawInstanceBlock(BasePlayer player, Item item)
        {
            CuiHelper.DestroyUi(player, Layer);
            CuiElementContainer container = new CuiElementContainer();
            string inputText = "Предмет {name} временно заблокирован,\nподождите {1}".Replace("{name}", item.info.displayName.english).Replace("{1}", $"{Convert.ToInt32(Math.Floor(TimeSpan.FromSeconds(IsBlocked(item.info)).TotalHours))} час {TimeSpan.FromSeconds(IsBlocked(item.info)).Minutes} минут.");

            
            container.Add(new CuiPanel
            {
                FadeOut = 1f,
                Image = { FadeIn = 1f, Color = "0.1 0.1 0.1 0" },
                RectTransform = { AnchorMin = "0.35 0.75", AnchorMax = "0.62 0.95" },
                CursorEnabled = false
            }, "Hud", Layer);
            
            container.Add(new CuiElement
            {
                FadeOut = 1f,
                Parent = Layer,
                Name = Layer + ".Hide",
                Components =
                {
                    new CuiImageComponent { Color = "0 0 0 0" },
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                }
            });
            container.Add(new CuiElement
            {
                Parent = Layer + ".Hide",
                Name = Layer + ".Destroy1",
                FadeOut = 1f,
                Components =
                {
                    new CuiImageComponent { Color = "0.4 0.4 0.4 0.7"},
                    new CuiRectTransformComponent { AnchorMin = "0 0.62", AnchorMax = "1.1 0.85" }
                }
                
            });
            container.Add(new CuiLabel
            {
                FadeOut = 1f,
                Text = {FadeIn = 1f, Color = "0.9 0.9 0.9 1", Text = "ПРЕДМЕТ ЗАБЛОКИРОВАН", FontSize = 22, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" }
            }, Layer + ".Destroy1", Layer + ".Destroy5");
            container.Add(new CuiButton
            {
                FadeOut = 1f,
                RectTransform = { AnchorMin = "0 0.29", AnchorMax = "1.1 0.61" },
                Button = {FadeIn = 1f, Color = "0.3 0.3 0.3 0.5" },
                Text = { Text = "" }
            }, Layer + ".Hide", Layer + ".Destroy2");
            container.Add(new CuiLabel
            {
                FadeOut = 1f,
                Text = {FadeIn = 1f, Text = inputText, FontSize = 16, Align = TextAnchor.MiddleLeft, Color = "0.85 0.85 0.85 1" , Font = "robotocondensed-regular.ttf"},
                RectTransform = { AnchorMin = "0.04 0", AnchorMax = "10 0.9" }
            }, Layer + ".Hide", Layer + ".Destroy3");
            CuiHelper.AddUi(player, container);
        }

        #endregion

        #region Functions

        private string GetGradient(int t)
        {
            var LeftTime = UnBlockTime(t) - CurrentTime();
            //Server.Broadcast(LeftTime.ToString());
            return gradients[Math.Min(99, Math.Max(Convert.ToInt32((float) LeftTime / t * 100), 0))];
        }

        private double IsBlockedCategory(int t) => IsBlocked(blockedItems.ElementAt(t).Value.First());

        private bool IsAnyBlocked() => UnBlockTime(blockedItems.Last().Key) > CurrentTime();
        
        private double IsBlocked(string shortname)
        {
            if (!blockedItems.SelectMany(p => p.Value).Contains(shortname))
                return 0;

            var blockTime = blockedItems.FirstOrDefault(p => p.Value.Contains(shortname)).Key;
            var lefTime = (UnBlockTime(blockTime)) - CurrentTime();
            
            return lefTime > 0 ? lefTime : 0;
        }

        private double UnBlockTime(int amount) => SaveRestore.SaveCreatedTime.ToUniversalTime().Subtract(epoch).TotalSeconds + amount + CONF_TimeMove;

        private double IsBlocked(ItemDefinition itemDefinition) => IsBlocked(itemDefinition.shortname);

        private void FillBlockedItems(Dictionary<string, Dictionary<Item, string>> fillDictionary)
        {
            foreach (var category in blockedItems)
            {
                string categoryColor = GetGradient(category.Key);
                //Server.Broadcast(categoryColor);
                foreach (var item in category.Value)
                {
                    Item createItem = ItemManager.CreateByPartialName(item);
                    string catName = NiceCategories[createItem.info.category.ToString()];
                
                    if (!fillDictionary.ContainsKey(catName))
                        fillDictionary.Add(catName, new Dictionary<Item, string>());
                
                    if (!fillDictionary[catName].ContainsKey(createItem))
                        fillDictionary[catName].Add(createItem, categoryColor);
                }
            }
        }

        #endregion

        #region Utils

        static readonly DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);
        static double CurrentTime() { return DateTime.UtcNow.Subtract(epoch).TotalSeconds; }

        public string Initializate()
        {
            int result = 0;
            foreach (var check in Author.ToCharArray())
                result += (int) check;
            return result == 610 ? "SUCCESS" : "NOPE";
        }
        
        public static string ToShortString(TimeSpan timeSpan)
        {
            int i = 0;
            string resultText = "";
            if (timeSpan.Days > 0)
            {
                resultText += timeSpan.Days + " День";
                i++;
            }
            if (timeSpan.Hours > 0 && i < 2)
            {
                if (resultText.Length != 0)
                    resultText += " ";
                resultText += timeSpan.Days + " Час";
                i++;
            }
            if (timeSpan.Minutes > 0 && i < 2)
            {
                if (resultText.Length != 0)
                    resultText += " ";
                resultText += timeSpan.Days + " Мин.";
                i++;
            }
            if (timeSpan.Seconds > 0 && i < 2)
            {
                if (resultText.Length != 0)
                    resultText += " ";
                resultText += timeSpan.Days + " Сек.";
                i++;
            }

            return resultText;
        }
        
        private void GetConfig<T>(string menu, string key, ref T varObject)
        {
            if (Config[menu, key] != null)
            {
                varObject = Config.ConvertValue<T>(Config[menu, key]);
            }
            else
            {
                Config[menu, key] = varObject;
            }
        }
        
        #endregion
    }
}

// --- End of file: WipeBlock.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/XInfoMenuLITE.cs ---
// --- Original Local Path: XInfoMenuLITE.cs ---

using System.Collections.Generic;
using UnityEngine;
using System.Linq;
using Oxide.Game.Rust.Cui;
using Newtonsoft.Json; 

namespace Oxide.Plugins
{
    [Info("XInfoMenuLITE", "Sempai#3239", "1.0.0")] 
    class XInfoMenuLITE : RustPlugin
    {
	    #region Configuration 

        private InfoMenuConfig config; 

        private class InfoMenuConfig
        {							            
            [JsonProperty("Кнопки и сообщения")]
            public Dictionary<string, string> Message;            	
			
			public static InfoMenuConfig GetNewConfiguration()
            {
                return new InfoMenuConfig
                {
					Message = new Dictionary<string, string>
					{
						["1"] = "111",
						["2"] = "222",
						["3"] = "333",
						["4"] = "444"						
					}
				};
			}
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
			
			try
			{
				config = Config.ReadObject<InfoMenuConfig>(); 
			}
			catch
			{
				PrintWarning("Ошибка чтения конфигурации! Создание дефолтной конфигурации!");
				LoadDefaultConfig();
			}
			
			SaveConfig();
        }
		protected override void LoadDefaultConfig() => config = InfoMenuConfig.GetNewConfiguration();
        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion
		
		#region Commands
		
		[ChatCommand("help")]
		private void cmdOpenGUI(BasePlayer player) => GUI(player);		
		
		[ChatCommand("info")]
		private void cmdOpenGUII(BasePlayer player) => GUI(player);
		
		[ConsoleCommand("info_page")]
		private void ccmdPage(ConsoleSystem.Arg args)
		{
			BasePlayer player = args.Player();
			
			GUI(player, int.Parse(args.Args[0]));
			EffectNetwork.Send(new Effect("assets/bundled/prefabs/fx/notice/loot.drag.grab.fx.prefab", player, 0, new Vector3(), new Vector3()), player.Connection);
		}
		
		#endregion
		
		#region Hooks
		
		private void OnServerInitialized()
		{
			PrintWarning("\n-----------------------------\n" +
			"     Discord - Sempai#3239\n" +
			"-----------------------------"); 
		}
		
		#endregion
		 
		#region GUI
		
		private void GUI(BasePlayer player, int page = 0)
		{
			CuiHelper.DestroyUi(player, ".GUILITE");
            CuiElementContainer container = new CuiElementContainer();		
			
			container.Add(new CuiPanel
            {
				CursorEnabled = true,
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-400 -195", OffsetMax = "400 255" },
                Image = { Color = "0.117 0.121 0.109 0.995", Material = "assets/icons/greyout.mat" }
            }, "Overlay", ".GUILITE");
			
			container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "-300 -300", OffsetMax = "300 300" },
                Button = { Color = "0 0 0 0", Close = ".GUILITE" },
                Text = { Text = "" }
            }, ".GUILITE");			
			
			container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-400 -175", OffsetMax = "400 -170" },
                Image = { Color = "0.217 0.221 0.209 0.995", Material = "assets/icons/greyout.mat" }
            }, ".GUILITE");			
			
			container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-400 -170", OffsetMax = "400 225" },
                Text = { Text = config.Message.ElementAt(page).Value, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 15, Color = "0.75 0.75 0.75 0.5" }
            }, ".GUILITE");
			
			int x = 0;
			int count = config.Message.Count;
			
			foreach(var button in config.Message)
			{
				string color = page == x ? "0.53 0.77 0.35 1" : "0 0 0 0";
				double offset = -(63.75 * count--) - (2.5 * count--);
				
				container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"{127.5 + offset - 127.5} -220", OffsetMax = $"{127.5 + offset} -180" },
                    Button = { Color = "0.217 0.221 0.209 0.995", Command = $"info_page {x}" },
                    Text = { Text = button.Key, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 16, Color = "0.75 0.75 0.75 0.5" }
                }, ".GUILITE", ".BButton");

			    container.Add(new CuiPanel
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0", OffsetMax = "0 1" },
                    Image = { Color = color, Material = "assets/icons/greyout.mat" }
                }, ".BButton");				
				
				x++;
			}
			
			CuiHelper.AddUi(player, container);
		}
		
		#endregion
	}
}

// --- End of file: XInfoMenuLITE.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/WantedForMurder.cs ---
// --- Original Local Path: WantedForMurder.cs ---

using System;
using System.Text;
using System.Collections.Generic;
using UnityEngine;
using Facepunch;
using Rust;
using Oxide.Core;
using Oxide.Core.Libraries;


namespace Oxide.Plugins
{
	[Info( "Wanted For Murder", "Raptor007", "1.0.7" )]
	[Description( "Players can punish unwanted PvP." )]
	
	class WantedForMurder : RustPlugin
	{
		bool DataChanged = false;
		Dictionary< ulong, List<ulong> > Murderers = new Dictionary< ulong, List<ulong> >();
		Dictionary< ulong, ulong > LastKillerOf = new Dictionary< ulong, ulong >();
		Dictionary< ulong, ulong > LastAttackerOf = new Dictionary< ulong, ulong >();
		Dictionary< string, string > EN = new Dictionary< string, string >();
		
		
		// Poor man's locking because we can't use System.Threading.
		
		volatile bool DataLocked = false;
		
		void LockData()
		{
			while( DataLocked );
			DataLocked = true;
		}
		
		void UnlockData()
		{
			DataLocked = false;
		}
		
		
		void ChatToPlayer( BasePlayer player, string key, params object[] args )
		{
			PrintToChat( player, string.Format( lang.GetMessage( key, this, player.UserIDString ), args ) );
		}
		
		
		void ChatToAll( string key, params object[] args )
		{
			foreach( BasePlayer player in BasePlayer.activePlayerList )
				ChatToPlayer( player, key, args );
		}
		
		
		bool SetUnconfiguredDefaults()
		{
			bool changed = false;
			
			if( Config[ "AnnounceWhenLoaded" ] == null )
			{
				Config[ "AnnounceWhenLoaded" ] = true;
				changed = true;
			}
			if( Config[ "AwakeAutoPunish" ] == null )
			{
				Config[ "AwakeAutoPunish" ] = false;
				changed = true;
			}
			if( Config[ "CastleDoctrine" ] == null )
			{
				Config[ "CastleDoctrine" ] = true;
				changed = true;
			}
			if( Config[ "RemoveMurdererBags" ] == null )
			{
				Config[ "RemoveMurdererBags" ] = true;
				changed = true;
			}
			if( Config[ "Sheriffs" ] == null )
			{
				Config[ "Sheriffs" ] = new List<ulong>();
				changed = true;
			}
			if( Config[ "ShowOnWake" ] == null )
			{
				Config[ "ShowOnWake" ] = true;
				changed = true;
			}
			if( Config[ "SleepersAutoPunish" ] == null )
			{
				Config[ "SleepersAutoPunish" ] = true;
				changed = true;
			}
			
			return changed;
		}
		
		
		protected override void LoadDefaultConfig()
		{
			LockData();
			
			Config.Clear();
			SetUnconfiguredDefaults();
			SaveConfig();
			
			UnlockData();
		}
		
		
		void LoadData()
		{
			Murderers = Interface.GetMod().DataFileSystem.ReadObject< Dictionary< ulong, List<ulong> > >( "WantedForMurder-Murderers" );
		}
		
		
		void SaveData()
		{
			Interface.GetMod().DataFileSystem.WriteObject( "WantedForMurder-Version", Version.ToString() );
			Interface.GetMod().DataFileSystem.WriteObject( "WantedForMurder-Murderers", Murderers );
		}
		
		
		void OnServerSave()
		{
			if( DataChanged )
			{
				LockData();
				
				if( DataChanged )
				{
					DataChanged = false;
					SaveData();
				}
				
				UnlockData();
			}
		}
		
		
		string GetPlayerNameFromID( ulong player_id )
		{
			foreach( BasePlayer player in BasePlayer.activePlayerList )
			{
				if( player.userID == player_id )
					return player.displayName;
			}
			foreach( BasePlayer player in BasePlayer.sleepingPlayerList )
			{
				if( player.userID == player_id )
					return player.displayName;
			}
			
			return "Somebody";
		}
		
		
		ulong GetPlayerIDFromName( string name )
		{
			foreach( BasePlayer player in BasePlayer.activePlayerList )
			{
				if( player.displayName.ToLower().Contains(name.ToLower()) )
					return player.userID;
			}
			foreach( BasePlayer player in BasePlayer.sleepingPlayerList )
			{
				if( player.displayName.ToLower().Contains(name.ToLower()) )
					return player.userID;
			}
			
			return 0;
		}
		
		
		bool IsMurderer( ulong player_id )
		{
			if( Murderers.ContainsKey(player_id) )
				return true;
			return false;
		}
		
		
		bool IsKiller( ulong player_id )
		{
			foreach( KeyValuePair<ulong,ulong> pair in LastKillerOf )
			{
				if( pair.Value == player_id )
					return true;
			}
			return false;
		}
		
		
		bool PunishLastKillerOf( ulong player_id )
		{
			if( Murderers.ContainsKey(player_id) )
				return false;
			if( ! LastKillerOf.ContainsKey(player_id) )
				return false;
			
			ulong murderer_id = LastKillerOf[ player_id ];
			
			if( ! Murderers.ContainsKey(murderer_id) )
				Murderers[ murderer_id ] = new List<ulong>();
			
			// We don't care who kills murderers.
			if( LastKillerOf.ContainsKey(murderer_id) )
				LastKillerOf.Remove( murderer_id );
			
			if( ! Murderers[ murderer_id ].Contains(player_id) )
			{
				Murderers[ murderer_id ].Add( player_id );
				DataChanged = true;
				RemoveSleepingBagsFor( murderer_id );
				
				ChatToAll( "Punish", GetPlayerNameFromID(murderer_id), GetPlayerNameFromID(player_id) );
				
				return true;
			}
			
			return false;
		}
		
		
		void RemoveSleepingBagsFor( ulong player_id )
		{
			if( Config.Get<bool>("RemoveMurdererBags") )
			{
				foreach( SleepingBag bag in SleepingBag.FindForPlayer( player_id, true ) )
					bag.Kill();
			}
		}
		
		
		void RemoveMurdererSleepingBags()
		{
			foreach( BasePlayer player in BasePlayer.activePlayerList )
			{
				if( IsMurderer(player.userID) )
					RemoveSleepingBagsFor( player.userID );
			}
		}
		
		
		void OnItemDeployed( Deployer deployer, BaseEntity entity )
		{
			LockData();
			RemoveMurdererSleepingBags();
			UnlockData();
		}
		
		
		void OnEntityTakeDamage( BaseCombatEntity entity, HitInfo info )
		{
			if( entity == null )
				return;
			
			if( (info != null) && (info.Initiator != null) && info.Initiator.name.Contains("player") && entity.name.Contains("player") )
			{
				var victim = entity as BasePlayer;
				var killer = info.Initiator as BasePlayer;
				
				if( (victim == null) || (killer == null) )
					return;
				
				// Don't track self-harm.
				if( victim.userID != killer.userID )
				{
					LockData();
					
					// Don't track kills of murderers, and if Castle Doctrine is enabled, don't allow punishment for wounding home invaders.
					if( IsMurderer(victim.userID) || (Config.Get<bool>("CastleDoctrine") && killer.CanBuild() && ! victim.CanBuild()) )
					{
						// Prevent accidentally punishing the wrong person.
						if( LastAttackerOf.ContainsKey(victim.userID) )
							LastAttackerOf.Remove( victim.userID );
					}
					else
						LastAttackerOf[ victim.userID ] = killer.userID;
					
					UnlockData();
				}
			}
		}
		
		
		void OnEntityDeath( BaseCombatEntity entity, HitInfo info )
		{
			if( entity == null )
				return;
			
			if( entity.name.Contains("player") )
			{
				var victim = entity as BasePlayer;
				if( victim == null )
					return;
				
				bool sleep_murder = false;
				bool locked_data = false;
				
				if( (info != null) && (info.Initiator != null) && info.Initiator.name.Contains("player") )
				{
					var killer = info.Initiator as BasePlayer;
					if( killer == null )
						return;
					
					// Don't track suicides.
					if( victim.userID != killer.userID )
					{
						LockData();
						locked_data = true;
						
						// Don't track kills of murderers, and if Castle Doctrine is enabled, don't allow punishment for killing home invaders.
						if( IsMurderer(victim.userID) || (Config.Get<bool>("CastleDoctrine") && killer.CanBuild() && ! victim.CanBuild()) )
						{
							// Prevent accidentally punishing the wrong person.
							if( LastKillerOf.ContainsKey(victim.userID) )
								LastKillerOf.Remove( victim.userID );
						}
						else
						{
							LastKillerOf[ victim.userID ] = killer.userID;
							sleep_murder = victim.IsSleeping();
						}
					}
				}
				else
				{
					LockData();
					locked_data = true;
					
					if( LastAttackerOf.ContainsKey(victim.userID) )
					{
						LastKillerOf[ victim.userID ] = LastAttackerOf[ victim.userID ];
						sleep_murder = victim.IsSleeping();
					}
				}
				
				if( ! locked_data )
					LockData();
				
				// Always remove stale attacked-by data when a player dies.
				LastAttackerOf.Remove( victim.userID );
				
				if( Config.Get<bool>("SleepersAutoPunish") && sleep_murder )
					PunishLastKillerOf( victim.userID );
				else if( Config.Get<bool>("AwakeAutoPunish") && ! sleep_murder )
					PunishLastKillerOf( victim.userID );
				
				UnlockData();
			}
		}
		
		
		void ShowWantedListTo( BasePlayer player )
		{
			if( Murderers.Count > 0 )
			{
				foreach( KeyValuePair< ulong, List<ulong> > pair in Murderers )
				{
					string murderer = GetPlayerNameFromID( pair.Key );
					string victims = GetPlayerNameFromID( pair.Value[ 0 ] );
					if( pair.Value.Count == 2 )
						victims += " and " + GetPlayerNameFromID( pair.Value[ 1 ] );
					else if( pair.Value.Count > 2 )
					{
						for( int i = 1; i < pair.Value.Count - 1; i ++ )
							victims += ", " + GetPlayerNameFromID( pair.Value[ i ] );
						victims += ", and " + GetPlayerNameFromID( pair.Value[ pair.Value.Count - 1 ] );
					}
					
					ChatToPlayer( player, "Wanted", murderer, victims );
				}
			}
			else
				ChatToPlayer( player, "NobodyWanted" );
		}
		
		
		void OnPlayerSleepEnded( BasePlayer player )
		{
			LockData();
			
			if( Config.Get<bool>("ShowOnWake") )
			{
				if( Config.Get< List<ulong> >("Sheriffs").Contains(player.userID) )
					ChatToPlayer( player, "CommandsSheriff" );
				else
					ChatToPlayer( player, "Commands" );
				
				ShowWantedListTo( player );
			}
			
			UnlockData();
		}
		
		
		[ChatCommand("wanted")]
		void WantedCommand( BasePlayer player, string command, string[] args )
		{
			LockData();
			ShowWantedListTo( player );
			UnlockData();
		}
		
		
		[ChatCommand("punish")]
		void PunishCommand( BasePlayer player, string command, string[] args )
		{
			LockData();
			
			if( IsMurderer(player.userID) )
			{
				string victims = GetPlayerNameFromID( Murderers[ player.userID ][ 0 ] );
				if( Murderers[ player.userID ].Count == 2 )
					victims += " and " + GetPlayerNameFromID( Murderers[ player.userID ][ 1 ] );
				else if( Murderers[ player.userID ].Count > 2 )
				{
					for( int i = 1; i < Murderers[ player.userID ].Count - 1; i ++ )
						victims += ", " + GetPlayerNameFromID( Murderers[ player.userID ][ i ] );
					victims += ", and " + GetPlayerNameFromID( Murderers[ player.userID ][ Murderers[ player.userID ].Count - 1 ] );
				}
				
				ChatToPlayer( player, "PunishForbidden", victims );
			}
			else if( IsKiller(player.userID) )
			{
				List<string> victim_list = new List<string>();
				foreach( KeyValuePair<ulong,ulong> pair in LastKillerOf )
				{
					if( pair.Value == player.userID )
						victim_list.Add( GetPlayerNameFromID(pair.Key) );
				}
				string victims = victim_list[ 0 ];
				if( victim_list.Count == 2 )
					victims += " and " + victim_list[ 1 ];
				else if( victim_list.Count > 2 )
				{
					for( int i = 1; i < victim_list.Count - 1; i ++ )
						victims += ", " + victim_list[ i ];
					victims += ", and " + victim_list[ victim_list.Count - 1 ];
				}
				
				ChatToPlayer( player, "PunishForbidden", victims );
			}
			else if( LastKillerOf.ContainsKey(player.userID) )
			{
				ulong murderer_id = LastKillerOf[ player.userID ];
				if( Murderers.ContainsKey(murderer_id) && Murderers[ murderer_id ].Contains(player.userID) )
					ChatToPlayer( player, "PunishAlready", GetPlayerNameFromID(murderer_id) );
				else
					PunishLastKillerOf( player.userID );
			}
			else
				ChatToPlayer( player, "PunishNotFound" );
			
			UnlockData();
		}
		
		
		[ChatCommand("forgive")]
		void ForgiveCommand( BasePlayer player, string command, string[] args )
		{
			LockData();
			
			ulong murderer_id = 0;
			
			if( args.Length > 0 && args[ 0 ].Length > 0 )
				murderer_id = GetPlayerIDFromName( args[ 0 ] );
			else if( LastKillerOf.ContainsKey(player.userID) )
				murderer_id = LastKillerOf[ player.userID ];
			else
			{
				foreach( KeyValuePair< ulong, List<ulong> > pair in Murderers )
				{
					if( pair.Value.Contains(player.userID) )
					{
						murderer_id = pair.Key;
						break;
					}
				}
				
				if( (murderer_id == 0) && LastAttackerOf.ContainsKey(player.userID) )
					murderer_id = LastAttackerOf[ player.userID ];
			}
			
			if( murderer_id != 0 )
			{
				string murderer = GetPlayerNameFromID( murderer_id );
				
				if( LastKillerOf.ContainsKey(player.userID) && (LastKillerOf[ player.userID ] == murderer_id) )
					LastKillerOf.Remove( player.userID );
				
				if( LastAttackerOf.ContainsKey(player.userID) && (LastAttackerOf[ player.userID ] == murderer_id) )
					LastAttackerOf.Remove( player.userID );
				
				if( Murderers.ContainsKey(murderer_id) && Murderers[ murderer_id ].Contains(player.userID) )
				{
					Murderers[ murderer_id ].Remove( player.userID );
					if( Murderers[ murderer_id ].Count == 0 )
					{
						Murderers.Remove( murderer_id );
						ChatToAll( "ForgiveByAll", murderer, player.displayName );
					}
					else
						ChatToAll( "ForgiveBySome", murderer, player.displayName );
					
					DataChanged = true;
				}
				else
					ChatToPlayer( player, "ForgiveKill", murderer );
			}
			else
				ChatToPlayer( player, "ForgiveNotFound" );
			
			UnlockData();
		}
		
		
		[ChatCommand("pardon")]
		void PardonCommand( BasePlayer player, string command, string[] args )
		{
			LockData();
			
			if( Config.Get< List<ulong> >("Sheriffs").Contains(player.userID) )
			{
				ulong murderer_id = 0;
				
				if( args.Length > 0 && args[ 0 ].Length > 0 )
					murderer_id = GetPlayerIDFromName( args[ 0 ] );
				
				if( murderer_id != 0 )
				{
					string murderer = GetPlayerNameFromID( murderer_id );
					
					foreach( KeyValuePair<ulong,ulong> pair in LastKillerOf )
					{
						if( pair.Value == murderer_id )
							LastKillerOf.Remove( pair.Key );
					}
					
					foreach( KeyValuePair<ulong,ulong> pair in LastAttackerOf )
					{
						if( pair.Value == murderer_id )
							LastAttackerOf.Remove( pair.Key );
					}
					
					if( Murderers.ContainsKey(murderer_id) )
					{
						Murderers.Remove( murderer_id );
						DataChanged = true;
						ChatToAll( "Pardon", murderer, player.displayName );
					}
					else
						ChatToPlayer( player, "PardonNotWanted", murderer );
				}
				else
					ChatToPlayer( player, "PardonNotFound" );
			}
			else
				ChatToPlayer( player, "PardonForbidden" );
			
			UnlockData();
		}
		
		
		void Loaded()
		{
			LockData();
			
			EN.Clear();
			EN[ "Loaded"          ] = "WantedForMurder version {0} loaded.";
			EN[ "Commands"        ] = "WantedForMurder commands: /wanted /punish /forgive";
			EN[ "CommandsSheriff" ] = "WantedForMurder commands: /wanted /punish /forgive /pardon  (You are a sheriff.)";
			EN[ "Wanted"          ] = "<color=#ff3333ff>{0}</color> is wanted for murdering {1}.";
			EN[ "NobodyWanted"    ] = "Nobody is currently wanted for murder.";
			EN[ "Punish"          ] = "<color=#ff3333ff>{0}</color> is now wanted for murdering {1}!";
			EN[ "PunishAlready"   ] = "You have already punished {0}.";
			EN[ "PunishNotFound"  ] = "Couldn't find anyone to punish.";
			EN[ "PunishForbidden" ] = "You cannot punish anyone until you are forgiven by {0}.";
			EN[ "ForgiveBySome"   ] = "<color=#ff3333ff>{0}</color> has been forgiven by {1} but is still wanted.";
			EN[ "ForgiveByAll"    ] = "{0} has been forgiven by {1} and is no longer wanted.";
			EN[ "ForgiveKill"     ] = "You forgave {0}.";
			EN[ "ForgiveNotFound" ] = "Couldn't find anyone to forgive.";
			EN[ "Pardon"          ] = "{0} has been pardoned of all crimes by Sheriff {1}.";
			EN[ "PardonNotWanted" ] = "{0} was not wanted.";
			EN[ "PardonNotFound"  ] = "Couldn't find anyone to pardon.";
			EN[ "PardonForbidden" ] = "Only a sheriff may pardon crimes.  Try /forgive instead.";
			lang.RegisterMessages( EN, this );
			
			LoadConfig();
			if( SetUnconfiguredDefaults() )
				SaveConfig();
			LoadData();
			
			timer.Repeat( 1f, 0, () => { RemoveMurdererSleepingBags(); } );
			
			if( Config.Get<bool>("AnnounceWhenLoaded") )
				timer.Once( 1f, () => { ChatToAll( "Loaded", Version.ToString() ); } );
			
			UnlockData();
		}
	}
}


// --- End of file: WantedForMurder.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/MagicTeleportation.cs ---
// --- Original Local Path: MagicTeleportation.cs ---

using System;
using System.Collections.Generic;
using Oxide.Core;
using UnityEngine;
using Oxide.Core.Plugins;
using Rust;
namespace Oxide.Plugins
{
    [Info("MagicTeleportation", "Norn", 1.1, ResourceId = 1404)]
    [Description("Teleportation system.")]
    public class MagicTeleportation : RustPlugin
    {
        [PluginReference]
        Plugin PopupNotifications;

        [PluginReference]
        Plugin BuildingOwners;

        class StoredData
        {
            public Dictionary<ulong, PlayerData> PlayerData = new Dictionary<ulong, PlayerData>();
            public Dictionary<string, HomeEntities> Entities = new Dictionary<string, HomeEntities>();
            public Dictionary<int, TeleportInfo> Teleports = new Dictionary<int, TeleportInfo>();
            public StoredData() { }
        }
        public class TeleportInfo
        {
            public int iID;
            public string tTitle;
            public string tDescription;
            public float fX;
            public float fY;
            public float fZ;
            public bool uEnabled;
            public int iAuthLevel;
            public bool uSleepGod;
            public int iCount;
            public TeleportInfo() { }
        }
        class HomesLocs
        {
            public float fX;
            public float fY;
            public float fZ;
            public float fHealth;
            public int iEID;
            public string tBagName;
            public HomesLocs() { }
        }
        class PlayerData
        {
            public ulong uUserID;
            public bool uCooldownEnabled;
            public Dictionary<int, HomesLocs> HomesLocs = new Dictionary<int, HomesLocs>();
            public PlayerData() { }
        }
        public class HomeEntities
        {
            public string tPrefab_name;
            public string tShortname;
            public bool bEnabled;

            public HomeEntities() { }
        }
        Dictionary<string, string> DEFAULT_HomeEntities = new Dictionary<string, string>() {
            {
                "assets/prefabs/deployable/bed/bed_deployed.prefab", "Bed"
            },
        };
        StoredData MTData;
        private void Loaded()
        {
            MTData = Interface.GetMod().DataFileSystem.ReadObject<StoredData>(this.Title);
        }
        public static Int32 UnixTimeStampUTC()
        {
            Int32 unixTimeStamp;
            DateTime currentTime = DateTime.Now;
            DateTime zuluTime = currentTime.ToUniversalTime();
            DateTime unixEpoch = new DateTime(1970, 1, 1);
            unixTimeStamp = (Int32)(zuluTime.Subtract(unixEpoch)).TotalSeconds;
            return unixTimeStamp;
        }
        public static int GetRandomNumber(int min, int max)
        {
            System.Random r = new System.Random();
            int n = r.Next();
            return n;
        }
        private int CreateTeleport(string title, string description, float X, float Y, float Z, bool sleepgod = true, int authlevel = 0, bool enabled = true)
        {
            TeleportInfo TPInfo = new TeleportInfo();
            TPInfo.iID = GetRandomNumber(0, 25);
            TPInfo.tTitle = title;
            TPInfo.tDescription = description;
            TPInfo.fX = X;
            TPInfo.fY = Y;
            TPInfo.fZ = Z;
            TPInfo.uSleepGod = sleepgod;
            TPInfo.iAuthLevel = authlevel;
            TPInfo.uEnabled = enabled;
            MTData.Teleports.Add(TPInfo.iID, TPInfo);
            return TPInfo.iID;
        }
        private bool PlayerExists(BasePlayer player)
        {
            PlayerData item = null;
            if (MTData.PlayerData.TryGetValue(player.userID, out item))
            {
                return true;
            }
            return false;
        }
        private int ResetCooldownForAll()
        {
            int count = 0;
            foreach (var player in MTData.PlayerData.Values)
            {
                player.uCooldownEnabled = false;
                count++;
            }
            return count;
        }
        private int PlayerHomeCount(BasePlayer player)
        {
            PlayerData item = null;
            int count = 0;
            if (MTData.PlayerData.TryGetValue(player.userID, out item))
            {
                foreach (var entry in item.HomesLocs.Values)
                {
                    count++;
                }
            }
            return count;
        }
        private bool InitPlayer(BasePlayer player)
        {
            if (!PlayerExists(player))
            {
                PlayerData z = new PlayerData();
                z.uUserID = player.userID;
                z.uCooldownEnabled = false;
                MTData.PlayerData.Add(z.uUserID, z);
                return true;
            }
            return false;
        }
        private bool EntityPlayerCheck(uint netid, BasePlayer attacker = null)
        {
            PlayerData item = null;
            foreach (var entry in MTData.PlayerData.Values)
            {
                if (MTData.PlayerData.TryGetValue(entry.uUserID, out item))
                {
                    if (item.HomesLocs.Count == 0)
                    {
                        return false;
                    }
                    List<int> remove_list = new List<int>();
                    foreach (var home in item.HomesLocs.Values)
                    {
                        if (home.iEID == netid)
                        {
                            remove_list.Add(home.iEID);
                        }
                    }
                    if (remove_list.Count >= 1)
                    {
                        foreach (var z in remove_list)
                        {
                            if (attacker != null)
                            {
                                if (attacker.userID == entry.uUserID)
                                {
                                    string parsed_config = Config["GeneralMessages", "HomeDestroyed"].ToString();
                                    parsed_config = parsed_config.Replace("{home}", item.HomesLocs[z].tBagName);
                                    if (parsed_config.Length >= 1) PrintToChatEx(attacker, parsed_config);
                                }
                                Puts("[" + item.uUserID.ToString() + "] " + item.HomesLocs[z].tBagName + " has been destroyed by " + attacker.displayName.ToString() + " / " + attacker.userID.ToString() + ".");
                            }
                            else
                            {
                                Puts("[" + item.uUserID.ToString() + "] " + item.HomesLocs[z].tBagName + " has been destroyed.");
                            }
                            item.HomesLocs.Remove(z);
                        }
                    }
                }
                return true;
            }
            return false;
        }
        private bool EntityExists(BaseCombatEntity entity)
        {
            if (entity.isActiveAndEnabled)
            {
                return true;
            }
            return false;
        }
        private void OnHomeEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (info.Initiator is BasePlayer)
            {
                var attacker = info.Initiator as BasePlayer;
                EntityPlayerCheck(entity.net.ID, attacker);
            }
            else
            {
                EntityPlayerCheck(entity.net.ID);
            }
        }
        List<ulong> SLEEPING_TELEPORTERS = new List<ulong>();
        Dictionary<ulong, Timer> TELEPORT_QUEUE = new Dictionary<ulong, Timer>();
        private HitInfo OnEntityTakeDamage(BaseCombatEntity vic, HitInfo hitInfo)
        {
            if (vic == null || hitInfo == null || vic.ToPlayer() == null) return null;
            BasePlayer player = vic as BasePlayer;
            if (!player.IsSleeping() && SLEEPING_TELEPORTERS.Contains(player.userID))
            {
                SLEEPING_TELEPORTERS.Remove(player.userID);
            }
            if (Convert.ToBoolean(Config["Settings", "TPSleepGod"]))
            {
                if (player.IsSleeping())
                {
                    if (SLEEPING_TELEPORTERS.Contains(player.userID))
                    {
                        if (hitInfo.Initiator is BasePlayer)
                        {
                            var attacker = hitInfo.Initiator as BasePlayer;
                            if (attacker.userID == player.userID)
                            {
                                return null;
                            }
                            else
                            {
                                if (Config["GeneralMessages", "PlayerNoAwake"] != null) PrintToChatEx(attacker, Config["GeneralMessages", "PlayerNoAwake"].ToString());
                                hitInfo.damageTypes.ScaleAll(0f);
                                return hitInfo;
                            }
                        }
                    }
                }
            }
            if (TELEPORT_QUEUE.ContainsKey(player.userID))
            {
                if (Config["GeneralMessages", "TeleportInterrupted"] != null) PrintToChatEx(player, Config["GeneralMessages", "TeleportInterrupted"].ToString());
                CancelTeleport(player);
            }
            return null;
        }
        bool CancelTeleport(BasePlayer player)
        {
            if (TELEPORT_QUEUE.ContainsKey(player.userID))
            {
                try
                {
                    TELEPORT_QUEUE[player.userID].Destroy();
                    TELEPORT_QUEUE.Remove(player.userID);
                    UnfreezePlayer(player.userID);
                    return true;
                }
                catch
                {
                    //Puts("DEBUG: OnEntityTakeDamage(): Failed to kill " + player.displayName + "'s teleport timer.");
                }
            }
            return false;
        }
        void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (entity.transform == null)
            {
                return;
            }
            if (MTData.Entities != null)
            {
                foreach (var entry in MTData.Entities)
                {
                    if (entry.Value.bEnabled)
                    {
                        if (entry.Value.tPrefab_name == entity.name)
                        {
                            OnHomeEntityDeath(entity, info);
                            return;
                        }
                    }
                }
            }
        }
        private static Dictionary<string, string> displaynameToShortname = new Dictionary<string, string>();
        private static Dictionary<string, int> deployedToItem = new Dictionary<string, int>();
        private void InitializeTable()
        {
            displaynameToShortname.Clear();
            deployedToItem.Clear();
            List<ItemDefinition> ItemsDefinition = ItemManager.GetItemDefinitions() as List<ItemDefinition>;
            foreach (ItemDefinition itemdef in ItemsDefinition)
            {
                displaynameToShortname.Add(itemdef.displayName.english.ToString().ToLower(), itemdef.shortname.ToString());
                if (itemdef.GetComponent<ItemModDeployable>() != null) deployedToItem.Add(itemdef.GetComponent<ItemModDeployable>().entityPrefab.resourcePath, itemdef.itemid);
            }


        }
        private void RefundHomeEntity(BasePlayer player, BaseEntity entity, int amount)
        {
            if (entity.GetComponentInParent<Deployable>() != null)
            {
                Deployable refund_item = entity.GetComponentInParent<Deployable>();
                if (refund_item != null)
                {
                    var RefundItem = ItemManager.FindItemDefinition(deployedToItem[refund_item.gameObject.name]); Item i = null;
                    if (deployedToItem.ContainsKey(refund_item.gameObject.name)) i = ItemManager.CreateByItemID(RefundItem.itemid, 1);
                    if (i != null) { if (!i.MoveToContainer(player.inventory.containerMain)) { i.Drop(player.eyes.position, player.eyes.BodyForward() * 2f); } }
                }
            }
        }
        private void OnEntityBuilt(Planner planner, GameObject gameObject)
        {
            BaseEntity e = gameObject.ToBaseEntity();
            BasePlayer player = planner.GetOwnerPlayer();
            if (!(e is BaseEntity) || player == null) { return; }
            if (MTData.Entities != null)
            {
                foreach (var entry in MTData.Entities)
                {
                    if (entry.Value.bEnabled)
                    {
                        if (entry.Value.tPrefab_name == gameObject.name) // Fire Up
                        {
                            int max_per_build = Convert.ToInt32(Config["Settings", "MaxEntitiesPerBuilding"]);
                            int max_homes = Convert.ToInt32(Config["HomeSettings", "MaxHomes"]);
                            if (PlayerHomeCount(player) >= max_homes)
                            {
                                string parsed_config = Config["GeneralMessages", "MaxHomes"].ToString();
                                parsed_config = parsed_config.Replace("{max_homes}", max_homes.ToString());
                                if (parsed_config.Length >= 1) PrintToChatEx(player, parsed_config);

                                if (Convert.ToBoolean(Config["Settings", "RefundEntity"])) RefundHomeEntity(player, e, 1);
                                e.Kill();
                                return;
                            }
                            Vector3 position = e.transform.position;
                            if (!PlayerExists(player))
                            {
                                if (InitPlayer(player))
                                {
                                    Puts("Set up user data for " + player.displayName + " (" + player.userID + ").");
                                }
                            }
                            PlayerData d = null;
                            if (MTData.PlayerData.TryGetValue(player.userID, out d))
                            {
                                HomesLocs z = new HomesLocs();
                                z.iEID = (int)e.net.ID;
                                z.fX = position.x;
                                z.fY = position.y;
                                z.fZ = position.z;
                                z.fHealth = e.MaxHealth();
                                z.tBagName = "Bed";
                                d.HomesLocs.Add(z.iEID, z);
                                Puts("Set up new home for " + player.displayName + " (" + player.userID + ") (" + z.iEID.ToString() + ")");

                                if (Config["GeneralMessages", "SetupHome"] != null)
                                {
                                    string parsed_config = Config["GeneralMessages", "SetupHome"].ToString();
                                    parsed_config = parsed_config.Replace("{command}", Config["GeneralMessages", "SetupHome"].ToString());
                                    PrintToChatEx(player, parsed_config);
                                }
                                SaveData();
                            }
                        }
                    }
                }
            }
            else
            {
                Puts("Failed to load entity data, setting default entities...");
                LoadDefaultConfig();
            }

        }
        Dictionary<string, object> GetSleepingBagData(SleepingBag bag)
        {
            var bagdata = new Dictionary<string,
                object>();

            bagdata.Add("name", bag.niceName);
            bagdata.Add("pos", bag.transform.position);

            return bagdata;
        }
        List<Dictionary<string, object>> FindSleepingBags(ulong userid)
        {
            var bags = new List<Dictionary<string,
                object>>();
            foreach (SleepingBag bag in SleepingBag.FindForPlayer(userid, true))
            {
                bags.Add(GetSleepingBagData(bag));
            }

            return bags;
        }
        private bool UnfreezePlayer(ulong steamid)
        {
            PlayerData item = null;
            if (MTData.PlayerData.TryGetValue(steamid, out item))
            {
                if (item.uCooldownEnabled)
                {
                    item.uCooldownEnabled = false;
                }
                return true;
            }
            return false;
        }
        private void CommandMessage(BasePlayer player)
        {
            if (player != null)
            {
                if (Config["GeneralMessages", "Usage"] != null) PrintToChatEx(player, Config["GeneralMessages", "Usage"].ToString());
                if (player.net.connection.authLevel >= Convert.ToInt32(Config["General", "AuthLevel"]) && Config["GeneralMessages", "AdminCmd"] != null)
                {
                    string parsed_config = Config["GeneralMessages", "AdminCmd"].ToString();
                    parsed_config = parsed_config.Replace("{command}", Config["Commands", "Main"].ToString());
                    parsed_config = parsed_config.Replace("{createtp}", Config["Commands", "CreateTeleport"].ToString());
                    parsed_config = parsed_config.Replace("{remove}", Config["Commands", "RemoveTeleport"].ToString());
                    PrintToChatEx(player, parsed_config);
                }
            }
        }
        [ChatCommand("t")]
        void cmdHome(BasePlayer player, string cmd, string[] args)
        {
            if (args.Length == 0 || args.Length > 6)
            {
                CommandMessage(player);
            }
            else if (args[0] == "clean")
            {
                if (player.net.connection.authLevel >= Convert.ToInt32(Config["General", "AuthLevel"]))
                {
                    if (args.Length == 1)
                    {
                        int count = 0;
                        foreach (SleepingBag bag in SleepingBag.FindForPlayer(player.userID, true))
                        {
                            bag.Kill();
                            count++;
                        }
                        MTData.PlayerData.Remove(player.userID);
                        PrintToChatEx(player, "Removed " + count.ToString() + " homes. (" + player.displayName.ToString() + ").");
                    }
                }
            }
            else if (args[0] == Config["Commands", "Entities"].ToString())
            {

                if (player.net.connection.authLevel >= Convert.ToInt32(Config["General", "AuthLevel"]))
                {
                    if (args.Length < 2)
                    {
                        int count = 0;
                        foreach (var entity in MTData.Entities.Values)
                        {
                            PrintToChatEx(player, "[" + count.ToString() + "] Entity: <color=yellow>" + entity.tShortname + "</color>\n[" + count.ToString() + "] Prefab: <color=yellow>" + entity.tPrefab_name + "</color>\n[" + count.ToString() + "] Enabled: <color=yellow>" + entity.bEnabled.ToString() + "</color>.");
                            count++;
                        }
                        if (count != 0) PrintToChatEx(player, "Found " + count.ToString() + " entities."); else PrintToChatEx(player, "No entities currently exist.");
                        return;
                    }
                    else
                    {
                        foreach (ItemDefinition item in ItemManager.itemList)
                        {
                            if (item.category == ItemCategory.Items)
                            {
                                if (item.displayName.english == args[1])
                                {
                                    foreach (var itemdef in deployedToItem)
                                    {
                                        if (item.itemid == itemdef.Value)
                                        {
                                            HomeEntities z = new HomeEntities();
                                            z.bEnabled = true;
                                            z.tPrefab_name = itemdef.Key;
                                            z.tShortname = item.displayName.english;
                                            MTData.Entities.Add(z.tPrefab_name, z);
                                            PrintToChatEx(player, "You have <color=green>successfully</color> added <color=yellow>" + z.tShortname + "</color> [ " + z.tPrefab_name + " ] to the entities list. Enabled: " + z.bEnabled.ToString() + ".");
                                            SaveData();
                                            return;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                else
                {
                    if (Config["GeneralMessages", "NoAuthLevel"] != null) PrintToChatEx(player, Config["GeneralMessages", "NoAuthLevel"].ToString());
                }
            }
            else if (args[0] == Config["Commands", "RemoveTeleport"].ToString())
            {
                if (args.Length < 2)
                {
                    string parsed_config = Config["GeneralMessages", "RemoveTeleport"].ToString();
                    parsed_config = parsed_config.Replace("{command}", Config["Commands", "Main"].ToString());
                    parsed_config = parsed_config.Replace("{subcommand}", Config["Commands", "RemoveTeleport"].ToString());
                    if (parsed_config.Length >= 1) PrintToChatEx(player, parsed_config);
                    return;
                }
                if (player.net.connection.authLevel >= Convert.ToInt32(Config["General", "AuthLevel"]))
                {
                    int teleport_id = Convert.ToInt32(args[1]);
                    if (MTData.Teleports.ContainsKey(teleport_id))
                    {
                        string parsed_config = Config["GeneralMessages", "TPRemoveSuccess"].ToString();
                        parsed_config = parsed_config.Replace("{id}", args[1].ToString());
                        PrintToChatEx(player, parsed_config);
                        MTData.Teleports.Remove(teleport_id);
                    }
                    else
                    {
                        if (Config["GeneralMessages", "TPNoExist"] != null) PrintToChatEx(player, Config["GeneralMessages", "TPNoExist"].ToString());
                    }
                }
                else
                {
                    if (Config["GeneralMessages", "NoAuthLevel"] != null) PrintToChatEx(player, Config["GeneralMessages", "NoAuthLevel"].ToString());
                }
            }
            else if (args[0] == Config["Commands", "CreateTeleport"].ToString())
            {
                int return_id = -1;
                if (player.net.connection.authLevel >= Convert.ToInt32(Config["General", "AuthLevel"]))
                {
                    if (args.Length == 3)
                    {
                        string title = args[1];
                        string description = args[2];
                        return_id = CreateTeleport(args[1], args[2], player.transform.position.x, player.transform.position.y, player.transform.position.z);
                    }
                    else if (args.Length == 4)
                    {
                        string title = args[1];
                        string description = args[2];
                        bool sleepgod = Convert.ToBoolean(args[3]);
                        return_id = CreateTeleport(args[1], args[2], player.transform.position.x, player.transform.position.y, player.transform.position.z, sleepgod);
                    }
                    else if (args.Length == 5)
                    {
                        string title = args[1];
                        string description = args[2];
                        bool sleepgod = Convert.ToBoolean(args[3]);
                        int authlevel = Convert.ToInt32(args[4]);
                        return_id = CreateTeleport(args[1], args[2], player.transform.position.x, player.transform.position.y, player.transform.position.z, sleepgod, authlevel);
                    }
                    else if (args.Length == 6)
                    {
                        string title = args[1];
                        string description = args[2];
                        bool sleepgod = Convert.ToBoolean(args[3]);
                        int authlevel = Convert.ToInt32(args[4]);
                        bool enabled = Convert.ToBoolean(args[5]);
                        return_id = CreateTeleport(args[1], args[2], player.transform.position.x, player.transform.position.y, player.transform.position.z, sleepgod, authlevel, enabled);
                    }
                    else
                    {
                        if (Config["GeneralMessages", "CreateTeleport"] != null)
                        {
                            string parsed_config = Config["GeneralMessages", "CreateTeleport"].ToString();
                            parsed_config = parsed_config.Replace("{command}", Config["Commands", "Main"].ToString());
                            parsed_config = parsed_config.Replace("{subcommand}", Config["Commands", "CreateTeleport"].ToString());
                            if (parsed_config.Length >= 1) PrintToChatEx(player, parsed_config);
                        }

                    }
                    if (return_id != -1 && MTData.Teleports.ContainsKey(return_id))
                    {
                        string parsed_config = Config["GeneralMessages", "TeleportCreated"].ToString();
                        parsed_config = parsed_config.Replace("{id}", return_id.ToString());
                        parsed_config = parsed_config.Replace("{title}", MTData.Teleports[return_id].tTitle);
                        parsed_config = parsed_config.Replace("{description}", MTData.Teleports[return_id].tDescription);
                        parsed_config = parsed_config.Replace("{sleepgod}", MTData.Teleports[return_id].uSleepGod.ToString());
                        parsed_config = parsed_config.Replace("{authlevel}", MTData.Teleports[return_id].iAuthLevel.ToString());
                        parsed_config = parsed_config.Replace("{enabled}", MTData.Teleports[return_id].uEnabled.ToString());
                        PrintToChatEx(player, parsed_config);
                    }
                    else
                    {
                        if (args.Length != 0 && args.Length >= 3)
                        {
                            Puts(player.displayName + " tried to create a teleport. [FAILED]");
                            if (Config["GeneralMessages", "TPCreationFailed"] != null) PrintToChatEx(player, Config["GeneralMessages", "TPCreationFailed"].ToString());
                        }
                    }
                }
                else
                {
                    if (Config["GeneralMessages", "NoAuthLevel"] != null) PrintToChatEx(player, Config["GeneralMessages", "NoAuthLevel"].ToString());
                }
            }
            else if (args[0] == Config["Commands", "Public"].ToString()) // Public Teleports
            {
                if (args.Length == 1)
                {
                    int count = 0;
                    foreach (var item in MTData.Teleports.Values)
                    {
                        if (item.fX != 0 && item.fZ != 0)
                        {
                            if (player.net.connection.authLevel >= item.iAuthLevel)
                            {
                                count++;
                                if (!item.uEnabled && player.net.connection.authLevel < Convert.ToInt32(Config["General", "AuthLevel"])) break;
                                string parsed_config = Config["GeneralMessages", "TeleportInfo"].ToString();
                                parsed_config = parsed_config.Replace("{id}", count.ToString());
                                parsed_config = parsed_config.Replace("{title}", item.tTitle);
                                parsed_config = parsed_config.Replace("{description}", item.tDescription);
                                parsed_config = parsed_config.Replace("{tpcount}", item.iCount.ToString());

                                if (parsed_config.Length >= 1)
                                {
                                    if (player.net.connection.authLevel >= Convert.ToInt32(Config["General", "AuthLevel"]))
                                    {
                                        string enabled_color = "white";
                                        if (item.uEnabled)
                                        {
                                            enabled_color = "green";
                                        }
                                        else
                                        {
                                            enabled_color = "red";
                                        }
                                        PrintToChatEx(player, parsed_config + "\n[ <color=#33CCFF>" + count.ToString() + "</color> ] <color=red>ID:</color> " + item.iID.ToString() + " : <color=red>Authlevel:</color> " + item.iAuthLevel.ToString() + " : " + "<color=red>Enabled:</color> <color=" + enabled_color.ToString() + ">" + item.uEnabled.ToString() + "</color> : <color=red>Sleep God:</color> " + item.uSleepGod.ToString() + ".");
                                    }
                                    else
                                    {
                                        PrintToChatEx(player, parsed_config);
                                    }
                                }
                            }
                        }
                    }
                    if (count == 0)
                    {
                        if (Config["GeneralMessages", "NoTeleports"] != null) PrintToChatEx(player, Config["GeneralMessages", "NoTeleports"].ToString());
                    }
                    else
                    {
                        string parsed_config = Config["GeneralMessages", "PublicTP"].ToString();
                        parsed_config = parsed_config.Replace("{command}", Config["Commands", "Main"].ToString());
                        parsed_config = parsed_config.Replace("{subcommand}", Config["Commands", "Public"].ToString());
                        PrintToChatEx(player, parsed_config);
                    }
                }
                else if (args.Length == 2)
                {
                    int count = 0;
                    int foundcount = 0;
                    PlayerData d = null;
                    if (MTData.PlayerData.TryGetValue(player.userID, out d))
                    {
                        foreach (var item in MTData.Teleports.Values)
                        {
                            if (item.fX != 0 && item.fZ != 0)
                            {
                                count++;
                                if (args[1].ToString() == count.ToString())
                                {
                                    if (!TELEPORT_QUEUE.ContainsKey(player.userID))
                                    {
                                        if (item.iAuthLevel == 0 || player.net.connection.authLevel >= item.iAuthLevel)
                                        {
                                            if (Convert.ToBoolean(Config["TPSettings", "SanityCheck"]))
                                            {
                                                string reason = IsTeleportationCapable(player);
                                                if (reason != "continue")
                                                {
                                                    if (reason.Length >= 1) PrintToChatEx(player, reason);
                                                    return;
                                                }
                                            }
                                            foundcount++;
                                            item.iCount++;
                                            InitTeleport(player, Convert.ToSingle(item.fX), Convert.ToSingle(item.fY), Convert.ToSingle(item.fZ), false, true, item.tTitle, item.tDescription, count, Convert.ToInt32(Config["TPSettings", "Cooldown"]));
                                        }
                                        else
                                        {
                                            string parsed_config = Config["GeneralMessages", "TPNoExist"].ToString();
                                            parsed_config = parsed_config.Replace("{id}", args[1].ToString());
                                            if (parsed_config.Length >= 1) PrintToChatEx(player, parsed_config);
                                        }
                                    }
                                    else
                                    {
                                        if (Config["GeneralMessages", "TeleportPending"] != null) PrintToChatEx(player, Config["GeneralMessages", "TeleportPending"].ToString());
                                    }
                                    return;
                                }
                            }
                        }
                    }
                    if (foundcount == 0)
                    {
                        string parsed_config = Config["GeneralMessages", "TPNoExist"].ToString();
                        parsed_config = parsed_config.Replace("{id}", args[1].ToString());
                        if (parsed_config.Length >= 1) PrintToChatEx(player, parsed_config);
                    }
                }
            }
            else if (args[0] == Config["Commands", "CancelTeleport"].ToString()) // Cancel Teleport
            {
                if (CancelTeleport(player))
                {
                    PrintToChatEx(player, Config["GeneralMessages", "TeleportCancelled"].ToString());
                }
            }
            else if (args[0] == Config["Commands", "Home"].ToString()) // Home Teleport
            {
                if (args.Length == 1)
                {
                    int count = 0;
                    PlayerData d = null;
                    if (MTData.PlayerData.TryGetValue(player.userID, out d))
                    {
                        if (d.HomesLocs.Count == 0)
                        {
                            PrintToChatEx(player, Config["GeneralMessages", "NoHomes"].ToString());
                            return;
                        }
                        SyncHomesEx(player);
                        foreach (var item in d.HomesLocs)
                        {
                            if (item.Value.fX != 0 && item.Value.fZ != 0)
                            {
                                count++;
                                string parsed_config = Config["GeneralMessages", "HomeInfo"].ToString();
                                parsed_config = parsed_config.Replace("{id}", count.ToString());
                                parsed_config = parsed_config.Replace("{title}", item.Value.tBagName);
                                parsed_config = parsed_config.Replace("{hp}", item.Value.fHealth.ToString());
                                if (parsed_config.Length >= 1) PrintToChatEx(player, parsed_config);

                            }
                        }
                        if (count == 0)
                        {
                            if (Config["GeneralMessages", "NoHomes"] != null) PrintToChatEx(player, Config["GeneralMessages", "NoHomes"].ToString());
                        }
                        else
                        {
                            string parsed_config = Config["GeneralMessages", "HomeTP"].ToString();
                            parsed_config = parsed_config.Replace("{command}", Config["Commands", "Main"].ToString());
                            parsed_config = parsed_config.Replace("{subcommand}", Config["Commands", "Home"].ToString());
                            PrintToChatEx(player, parsed_config);
                        }
                    }
                    else
                    {
                        if (Config["GeneralMessages", "NoHomes"] != null) PrintToChatEx(player, Config["GeneralMessages", "NoHomes"].ToString());
                    }
                }
                else if (args.Length == 2)
                {
                    int count = 0;
                    int foundcount = 0;
                    PlayerData d = null;
                    if (MTData.PlayerData.TryGetValue(player.userID, out d))
                    {
                        foreach (var item in d.HomesLocs)
                        {
                            if (item.Value.fX != 0 && item.Value.fZ != 0)
                            {
                                count++;
                                if (args[1].ToString() == count.ToString())
                                {
                                    foundcount++;
                                    if (!TELEPORT_QUEUE.ContainsKey(player.userID))
                                    {
                                        if (!d.uCooldownEnabled)
                                        {
                                            if (Convert.ToBoolean(Config["HomeSettings", "SanityCheck"]))
                                            {
                                                string reason = IsTeleportationCapable(player);
                                                if (reason != "continue")
                                                {
                                                    if (reason.Length >= 1) PrintToChatEx(player, reason);
                                                    return;
                                                }
                                            }
                                            InitTeleport(player, Convert.ToSingle(item.Value.fX), Convert.ToSingle(item.Value.fY), Convert.ToSingle(item.Value.fZ), true, true, item.Value.tBagName.ToString());
                                        }
                                        else
                                        {
                                            string parsed_config = Config["GeneralMessages", "TPCooldown"].ToString();
                                            parsed_config = parsed_config.Replace("{cooldown}", Convert.ToInt32(Config["HomeSettings", "Cooldown"]).ToString());
                                            if (parsed_config.Length >= 1) PrintToChatEx(player, parsed_config);
                                        }
                                    }
                                    else
                                    {
                                        if (Config["GeneralMessages", "TeleportPending"] != null) PrintToChatEx(player, Config["GeneralMessages", "TeleportPending"].ToString());
                                    }
                                    return;
                                }
                            }
                        }
                    }
                    if (count == 0 || foundcount == 0)
                    {
                        string parsed_config = Config["GeneralMessages", "HomeNoExist"].ToString();
                        parsed_config = parsed_config.Replace("{id}", args[1].ToString());
                        if (parsed_config.Length >= 1) PrintToChatEx(player, parsed_config);
                    }
                }
            }
            else
            {
                CommandMessage(player);
            }
        }
        private bool InitTeleport(BasePlayer player, float init_x, float init_y, float init_z, bool type = true, bool printtoplayer = true, string title = "", string description = "", int count = -1, int seconds = 0)
        {
            if(!PlayerExists(player)) InitPlayer(player);
            if (SLEEPING_TELEPORTERS.Contains(player.userID)) { if (!player.IsSleeping()) { SLEEPING_TELEPORTERS.Remove(player.userID); } }
            if (TELEPORT_QUEUE.ContainsKey(player.userID)) { return false; }
            PlayerData d = null;
            if (MTData.PlayerData.TryGetValue(player.userID, out d)) { d.uCooldownEnabled = true; }
            float x = Convert.ToSingle(init_x);
            float y = Convert.ToSingle(init_y);
            float z = Convert.ToSingle(init_z);
            if (seconds == 0)
            {
                seconds = Convert.ToInt32(Config["HomeSettings", "TPWait"]);
            }
            if (type)
            {
                if (title != "")
                {
                    string parsed_config = Config["GeneralMessages", "TPHome"].ToString();
                    parsed_config = parsed_config.Replace("{seconds}", seconds.ToString());
                    parsed_config = parsed_config.Replace("{title}", title);
                    if (parsed_config.Length >= 1) PrintToChatEx(player, parsed_config);
                }
                TELEPORT_QUEUE.Add(player.userID, timer.Once(seconds, () => TeleportPlayerPosition(player, new Vector3(x, y + Convert.ToInt32(Config["Settings", "EntityHeight"]), z))));
            }
            else
            {
                if (title != "")
                {
                    string parsed_config = Config["GeneralMessages", "TPGeneral"].ToString();
                    parsed_config = parsed_config.Replace("{title}", title.ToString());
                    parsed_config = parsed_config.Replace("{seconds}", seconds.ToString());
                    parsed_config = parsed_config.Replace("{tpcount}", count.ToString());
                    if (parsed_config.Length >= 1) PrintToChatEx(player, parsed_config);
                }
                TELEPORT_QUEUE.Add(player.userID, timer.Once(seconds, () => TeleportPlayerPosition(player, new Vector3(x, y, z))));
            }
            return true;
        }
        //--------------------------->   Position forcing   <---------------------------//

        private void TeleportPlayerPosition(BasePlayer player, Vector3 pos)
        {
			if(player != null)
			{
				player.SetPlayerFlag(BasePlayer.PlayerFlags.Sleeping, true);
				if(!BasePlayer.sleepingPlayerList.Contains(player))	BasePlayer.sleepingPlayerList.Add(player);
				SLEEPING_TELEPORTERS.Add(player.userID);
				player.CancelInvoke("InventoryUpdate");
				player.inventory.crafting.CancelAll(true);
				player.MovePosition(pos);
				player.ClientRPCPlayer(null, player, "ForcePositionTo", pos, null, null, null, null);
				player.TransformChanged();
				player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, true);
				player.UpdateNetworkGroup();
				player.SendNetworkUpdateImmediate(false);
				player.ClientRPCPlayer(null, player, "StartLoading", null, null, null, null, null);
				player.SendFullSnapshot();
				timer.Once(Convert.ToInt32(Config["HomeSettings", "Cooldown"]), () => UnfreezePlayer(player.userID));
				TELEPORT_QUEUE[player.userID].Destroy();
				TELEPORT_QUEUE.Remove(player.userID);
			}
        }
        void Unload()
        {
            SaveData();
        }
        void OnPlayerInit(BasePlayer player)
        {
            if (!PlayerExists(player)) InitPlayer(player);
        }
        void OnPlayerSleepEnded(BasePlayer player)
        {
            if (SLEEPING_TELEPORTERS.Contains(player.userID))
            {
                SLEEPING_TELEPORTERS.Remove(player.userID);
            }
        }
        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (SLEEPING_TELEPORTERS.Contains(player.userID))
            {
                SLEEPING_TELEPORTERS.Remove(player.userID);
            }
            if (TELEPORT_QUEUE.ContainsKey(player.userID))
            {
                TELEPORT_QUEUE.Remove(player.userID);
            }
        }
        Timer SyncHomeData;
        void OnServerInitialized()
        {
            InitializeTable();
            InitializeConfig();
        }
        void InitializeConfig()
        {
            if(Convert.ToBoolean(Config["General", "PopulateDefaults"])) { Puts("Generating default entities...");  Config["General", "PopulateDefaults"] = false; SaveConfig(); PopulateEntityData(); }
            if (Config["HomeMessages", "ExternalReason"] == null)
            {
                Puts("Updating configuration file (out of date)...");
                Config["HomeMessages", "ExternalReason"] = "You <color=#FF0000>can't</color> teleport from here.";
                SaveConfig();
            }
            Puts("Populated " + MTData.Entities.Count.ToString() + " entities.");
            int seconds = Convert.ToInt32(Config["Settings", "UpdateTimerInt"]);
            SyncHomeData = timer.Repeat(seconds, 0, () => SyncHomes());
            int player_count = ResetCooldownForAll();
            if (player_count >= 1)
            {
                Puts(player_count.ToString() + " players had their cooldown reset to default.");
            }
            if (!BuildingOwners && Convert.ToBoolean(Config["Dependencies", "BuildingOwners"]))
            {
                Puts("[BuildingOwners][682]: Plugin has not been found! [ BuildingOwners : false ]");
                Config["Dependencies", "BuildingOwners"] = false;
                SaveConfig();
            }
            Puts("[Building Owners][682]: [Enabled: " + Config["Dependencies", "BuildingOwners"].ToString() + "]");
        }
        void SyncHomesEx(BasePlayer player)
        {
            if (player != null)
            {
                if (MTData.PlayerData.ContainsKey(player.userID))
                {
                    if (SleepingBag.FindForPlayer(player.userID, true).Length == 0)
                    {
                        if (MTData.PlayerData[player.userID].HomesLocs.Count >= 1)
                        {
                            MTData.PlayerData[player.userID].HomesLocs.Clear();
                            Puts("Resetting: " + player.displayName + "'s [" + player.userID.ToString() + "] homes list.");
                            return;
                        }
                    }
                    List<uint> ids = new List<uint>();
                    List<uint> remove_list = new List<uint>();
                    foreach (SleepingBag bag in SleepingBag.FindForPlayer(player.userID, true))
                    {
                        foreach (var entry in MTData.Entities)
                        {
                            if (entry.Value.bEnabled)
                            {
                                if (entry.Value.tPrefab_name == bag.PrefabName)
                                {
                                    int bag_id = (int)bag.net.ID;
                                    if (MTData.PlayerData[player.userID].HomesLocs.ContainsKey(bag_id))
                                    {
                                        if (MTData.PlayerData[player.userID].HomesLocs[bag_id].tBagName != bag.niceName)
                                        {
                                            MTData.PlayerData[player.userID].HomesLocs[bag_id].tBagName = bag.niceName;
                                        }
                                        if (MTData.PlayerData[player.userID].HomesLocs[bag_id].fHealth != bag.health)
                                        {
                                            MTData.PlayerData[player.userID].HomesLocs[bag_id].fHealth = bag.health;
                                        }
                                        ids.Add(bag.net.ID);
                                    }
                                }
                            }
                        }
                    }
                    foreach (var home in MTData.PlayerData[player.userID].HomesLocs)
                    {
                        if (!ids.Contains((uint)home.Key)) remove_list.Add((uint)home.Key);
                    }
                    new List<uint>(remove_list).ForEach(u => {
                        MTData.PlayerData[player.userID].HomesLocs.Remove((int)u);
                    });
                }
            }
        }
        void SyncHomes()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                SyncHomesEx(player);
            }
        }
        void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(this.Title, MTData);
        }
        private string IsTeleportationCapable(BasePlayer player)
        {
            string result = "";
            string tp_correct = "continue";
            if (player != null && player.IsConnected())
            {
                if (Convert.ToBoolean(Config["Settings", "BypassAdmin"]) && player.net.connection.authLevel >= Convert.ToInt32(Config["General", "AuthLevel"]))
                {
                    return tp_correct;
                }
                float min_hp = (float)Convert.ToDouble(Config["HomeSettings", "MinimumHealthCheck"]);
                float health = player.health;
                float temperature = player.currentTemperature;
                float comfort = player.currentComfort;
                var cantp = Interface.Call("canTeleport", player);
                if (health <= min_hp)
                {
                    result = Config["HomeMessages", "MinHP"].ToString();
                    result = result.Replace("{minhp}", min_hp.ToString());
                }
                else if (player.IsWounded()) { result = Config["HomeMessages", "Wounded"].ToString(); }
                else if (player.IsOnFire()) { result = Config["HomeMessages", "Fire"].ToString(); }
                else if (player.IsSwimming()) { result = Config["HomeMessages", "Swimming"].ToString(); }
                else if (!player.IsAlive()) { result = Config["HomeMessages", "Alive"].ToString(); }
                else if (!player.CanBuild() && Convert.ToBoolean(Config["HomeSettings", "TPInBlockedArea"])) { result = Config["HomeMessages", "BuildingBlocked"].ToString(); }
                else if (temperature < 0 && comfort <= 0 && !Convert.ToBoolean(Config["HomeSettings", "BypassCold"]))
                {
                    result = Config["HomeMessages", "TooCold"].ToString();
                    result = result.Replace("{temperature}", temperature.ToString());
                }
                else if (cantp != null) { if (cantp is string) { result = Convert.ToString(cantp); } else { result = Config["HomeMessages", "ExternalReason"].ToString(); } }
                else { result = tp_correct; } if (result.Length == 0) { result = Config["HomeMessages", "Failed"].ToString(); }
            }
            return result;
        }
        private string FindPlayerName(ulong userId)
        {
            BasePlayer player = BasePlayer.FindByID(userId);
            if (player) return player.displayName + " (Online)";

            player = BasePlayer.FindSleeping(userId);
            if (player) return player.displayName + " (Sleeping)";
            return "Unknown";
        }
        private void GetDeployedItemOwner(BasePlayer player, SleepingBag ditem)
        {
            SendReply(player, string.Format("Sleeping Bag '{0}': {1} - {2}", ditem.niceName.ToString(), FindPlayerName(ditem.deployerUserID), ditem.deployerUserID.ToString()));
        }
        private object FindOwnerBlock(BuildingBlock block)
        {
            if (BuildingOwners)
            {
                object returnhook = BuildingOwners?.Call("FindBlockData", block);

                if (returnhook != null)
                {
                    if (!(returnhook is bool))
                    {
                        ulong ownerid = Convert.ToUInt64(returnhook);
                        return ownerid;
                    }
                }
            }
            else
            {
                Puts("To be able to obtain the owner of a building you need to install the BuildingOwner plugin.");
            }
            return false;
        }
        protected override void LoadDefaultConfig()
        {
            // -- [ RESET ] ---

            Puts("No configuration file found, generating...");
            Config.Clear();

            // --- [ GENERAL ] ---

            Config["General", "PopulateDefaults"] = true;
            Config["General", "ShowPluginName"] = false;
            Config["General", "Protocol"] = Protocol.network;
            Config["General", "AuthLevel"] = 2;

            // --- [ DEPENDENCIES ] ---

            Config["Dependencies", "BuildingOwners"] = true;
            Config["Dependencies", "DeadPlayersList"] = true;
            Config["Dependencies", "PopupNotifications"] = false;

            // --- [ SETTINGS ] ---

            Config["Settings", "TPSleepGod"] = true;
            Config["Settings", "UpdateTimerInt"] = 10;
            Config["Settings", "MaxEntitiesPerBuilding"] = 2;
            Config["Settings", "BypassAdmin"] = false;
            Config["Settings", "EntityHeight"] = 2;
            Config["Settings", "RefundEntity"] = true;

            // --- [ TELEPORT SETTINGS ] ---

            Config["TPSettings", "Cooldown"] = 30;
            Config["TPSettings", "TPWait"] = 3;
            Config["TPSettings", "TPInBlockedArea"] = true;
            Config["TPSettings", "BypassCold"] = false;
            Config["TPSettings", "MinimumHealthCheck"] = 51.00;
            Config["TPSettings", "SanityCheck"] = true;

            // --- [ HOME SETTINGS ] ---

            Config["HomeSettings", "MaxHomes"] = 4;
            Config["HomeSettings", "Cooldown"] = 5;
            Config["HomeSettings", "TPWait"] = 8;
            Config["HomeSettings", "MinimumHealthCheck"] = 30.00;
            Config["HomeSettings", "SanityCheck"] = true;
            Config["HomeSettings", "TPInBlockedArea"] = true;
            Config["HomeSettings", "BypassCold"] = false;

            // --- [ COMMANDS ] ---

            Config["Commands", "Main"] = "t"; // Main Command
            Config["Commands", "Home"] = "home"; // Home Teleport
            Config["Commands", "CancelTeleport"] = "cancel"; // Cancel Teleport
            Config["Commands", "Public"] = "list"; // Public Teleports
            Config["Commands", "CreateTeleport"] = "create"; // Create Public Teleports - sub command
            Config["Commands", "RemoveTeleport"] = "remove";
            Config["Commands", "Entities"] = "entity";

            // --- [ MESSAGES ] ---

            Config["GeneralMessages", "Usage"] = "<color=#33CCFF>USAGE:</color> /" + Config["Commands", "Main"].ToString() + " <" + Config["Commands", "Home"].ToString() + " | " + Config["Commands", "Public"].ToString()+ " | " + Config["Commands", "CancelTeleport"].ToString() + ">";
            Config["GeneralMessages", "DBCleared"] = "You have <color=#FF3300>cleared</color> the Magic Homes database.";
            Config["GeneralMessages", "TeleportCancelled"] = "You have <color=#FF3300>cancelled</color> your teleport.";
            Config["GeneralMessages", "NoAuthLevel"] = "You <color=#FF3300>do not</color> have access to this command.";
            Config["GeneralMessages", "HomeDestroyed"] = "You have <color=#FF0000>destroyed</color> your home (<color=#FFFF00>{home}</color>).";
            Config["GeneralMessages", "MaxHomes"] = "You have reached your maximum allowed homes. ({max_homes})";
            Config["GeneralMessages", "SetupHome"] = "You have setup a new home! (Use /" + Config["Commands", "Main"].ToString() + " <" + Config["Commands", "Home"].ToString() + "> at any time).";
            Config["GeneralMessages", "NoHomes"] = "You have <color=red>no</color> homes.";
            Config["GeneralMessages", "NoTeleports"] = "There is currently <color=red>nowhere</color> to teleport to.";
            Config["GeneralMessages", "AdminCmd"] = "<color=yellow>ADMIN:</color> /{command} <{createtp} | {remove} | entity | clean>";
            Config["GeneralMessages", "TeleportInterrupted"] = "Your teleport has been <color=red>interrupted</color>...";
            Config["GeneralMessages", "HomeInfo"] = "[ <color=#33CCFF>{id}</color> ] <color=#FFFF00>{title}</color>, HP: <color=#FF0000>{hp}</color>.";
            Config["GeneralMessages", "TeleportInfo"] = "[ <color=#33CCFF>{id}</color> ] <color=yellow>Name:</color> {title}, <color=yellow>Description:</color> {description}. (<color=#33CCFF>{tpcount}</color>)";
            Config["GeneralMessages", "TPCooldown"] = "You are not currently allowed to teleport. (<color=#FF0000>{cooldown} second cooldown</color>).";
            Config["GeneralMessages", "TPHome"] = "You will be teleported to your home in <color=#FFFF00>{seconds}</color> seconds (<color=#FFFF00>{title}</color>).";
            Config["GeneralMessages", "TPGeneral"] = "You will be teleported to {title} in <color=#FFFF00>{seconds}</color> seconds (<color=#FFFF00>{tpcount}</color>).";
            Config["GeneralMessages", "HomeNoExist"] = "That home does <color=red>not</color> exist. [<color=#FFFF00>{id}</color>]";
            Config["GeneralMessages", "TPNoExist"] = "That teleport does <color=red>not</color> exist. [<color=#FFFF00>{id}</color>]";
            Config["GeneralMessages", "PlayerNoAwake"] = "You <color=red>cannot</color> attack someone who has not woken up from teleporting.";
            Config["GeneralMessages", "TeleportCreated"] = "Created teleport <color=#FF0000>{id}</color> at your current location!\nTitle: {title} : <color=yellow>Description:</color> {description},\n<color=yellow>Sleep God:</color> {sleepgod} | <color=yellow>Auth Level:</color> {authlevel} | Enabled: <color=yellow>{enabled}</color>.";
            Config["GeneralMessages", "CreateTeleport"] = "<color=yellow>USAGE:</color> /{command} {subcommand}\n<color=red>title</color> | <color=red>description</color> | <color=yellow>sleepgod</color> (<color=green>true</color>/<color=red>false</color>) | <color=yellow>authlevel</color> | <color=yellow>enabled</color> (<color=green>true</color>/<color=red>false</color>).";
            Config["GeneralMessages", "RemoveTeleport"] = "<color=yellow>USAGE:</color> /{command} {subcommand} <id>";
            Config["GeneralMessages", "TPCreationFailed"] = "<color=yellow>ERROR:</color> Failed to create teleport.";
            Config["GeneralMessages", "HomeTP"] = "<color=yellow>USAGE:</color> /{command} {subcommand} <id>.";
            Config["GeneralMessages", "PublicTP"] = "<color=yellow>USAGE:</color> /{command} {subcommand} <id>.";
            Config["GeneralMessages", "TeleportPending"] = "You already have a teleport <color=red>pending</color>.";
            Config["GeneralMessages", "TPRemoveSuccess"] = "<color=yellow>INFO:</color> You have removed the teleport: {id}!";

            // --- [ SUB MESSAGES ] ---

            Config["HomeMessages", "MinHP"] = "Your health <color=#FF0000>needs</color> to be above <color=#FF0000>{minhp}</color> to teleport home.";
            Config["HomeMessages", "Wounded"] = "You <color=#FF0000>can't</color> teleport home when you're <color=#FF0000>wounded</color>.";
            Config["HomeMessages", "Fire"] = "You <color=#FF0000>can't</color> teleport home when you're on <color=#FF0000>fire</color>.";
            Config["HomeMessages", "Swimming"] = "You <color=#FF0000>can't</color> teleport home when you're <color=#FF0000>swimming</color>.";
            Config["HomeMessages", "Alive"] = "You <color=#FF0000>can't</color> teleport home when you're not even <color=#FF0000>alive</color>.";
            Config["HomeMessages", "BuildingBlocked"] = "You <color=#FF0000>can't</color> teleport home when you're in a <color=#FF0000>building blocked</color> area.";
            Config["HomeMessages", "TooCold"] = "It's too <color=#FF0000>cold</color> to teleport. (<color=#00E1FF>{temperature}</color>)";
            Config["HomeMessages", "Failed"] = "<color=#FF0000>Failed</color> to teleport, contact an administrator.";
            Config["HomeMessages", "ExternalReason"] = "You <color=#FF0000>can't</color> teleport from here.";

            // --- [ OTHER ] ----

            SaveConfig();
        }
        int PopulateEntityData()
        {
            int r = 0;
            MTData.Entities.Clear();
            foreach (var entity in DEFAULT_HomeEntities)
            {
                HomeEntities z = new HomeEntities();
                z.bEnabled = true;
                z.tPrefab_name = entity.Key.ToString();
                z.tShortname = entity.Value.ToString();
                MTData.Entities.Add(z.tPrefab_name, z);
                SaveData();
                r++;
            }
            return r;
        }
        private void PrintToChatEx(BasePlayer player, string result, string tcolour = "#66FF66")
        {
            if (!Convert.ToBoolean(Config["Dependencies", "PopupNotifications"]))
            {
                if (Convert.ToBoolean(Config["General", "ShowPluginName"]))
                {
                    PrintToChat(player, "<color=\"" + tcolour + "\">[" + this.Title.ToString() + "]</color> " + result);
                }
                else
                {
                    PrintToChat(player, result);
                }
            }
            else
            {
                if (PopupNotifications)
                {
                    if (Convert.ToBoolean(Config["General", "ShowPluginName"]))
                    {
                        PopupNotifications?.Call("CreatePopupNotification", "<color=" + tcolour + ">" + this.Title.ToString() + "</color>\n" + result, player);
                    }
                    else
                    {
                        PopupNotifications?.Call("CreatePopupNotification", result, player);
                    }
                }
            }
        }
    }
}

// --- End of file: MagicTeleportation.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/AutoKit-9.9.9.cs ---
// --- Original Local Path: AutoKit-9.9.9.cs ---

using Newtonsoft.Json;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Oxide.Core;

namespace Oxide.Plugins 
{
    [Info("AutoKit", "no name666", "9.9.9")]
    public class AutoKit : RustPlugin 
    {
        #region Конфигурация

        private Configuration _config;
        private StoredData _storedData;

        public class StoredData
        {
            public Dictionary<ulong, Dictionary<string, List<SavedLoadout>>> PlayerLoadouts = new Dictionary<ulong, Dictionary<string, List<SavedLoadout>>>();
        }

        public class SavedLoadout
        {
            public string Name { get; set; }
            public List<Configuration.Biome.ItemConfig> Items { get; set; }
        }

        public class Configuration 
        {
            [JsonProperty("Биомы")] 
            public Biomes biomes = new Biomes();

            public class Biomes
            {
                [JsonProperty("Тундра")] 
                public Biome tundra = new Biome();

                [JsonProperty("Пустыня")] 
                public Biome dust = new Biome();

                [JsonProperty("Зима")] 
                public Biome winter = new Biome();

                [JsonProperty("Умеренный")] 
                public Biome normal = new Biome();
            }

            public class Biome
            {
                [JsonProperty("Разрешение для использования")] 
                public string permission = "autokit.normal";

                [JsonProperty("Выдавать набор в этом биоме?")] 
                public bool recive = true;

                [JsonProperty("Очищать инвентарь перед выдачей?")]
                public bool strip = true;

                [JsonProperty("Предметы к выдаче")] 
                public List<ItemConfig> items = new List<ItemConfig>();

                public class ItemConfig
                {
                    [JsonProperty("Отображаемое название")] 
                    public string name = "Штаны";

                    [JsonProperty("Скин ID предмета")] 
                    public ulong id = 0;

                    [JsonProperty("Shortname предмета")] 
                    public string shortname = "pants";

                    [JsonProperty("Количество")] 
                    public int amount = 1;

                    [JsonProperty("В какой контейнер помещать? (wear, main, belt)")] 
                    public string container = "wear";

                    [JsonProperty("Позиция в инвентаре")]
                    public int position = -1;

                    [JsonProperty("Количество патронов")]
                    public int ammo = 0;

                    [JsonProperty("Тип патронов")]
                    public string ammoType = "";

                    [JsonProperty("Модификации оружия")]
                    public Dictionary<string, string> mods = new Dictionary<string, string>();

                    public ItemConfig(ulong sourceID = 0, string sourceShortname = "", int sourceAmount = 0, string sourceContainer = "", int sourcePosition = -1)
                    {
                        id = sourceID;
                        shortname = sourceShortname;
                        amount = sourceAmount;
                        container = sourceContainer;
                        position = sourcePosition;
                    }
                }
            
                public Biome(string defaultPermission = "", bool fillDefaultItem = false)
                {
                    if(fillDefaultItem) items.Add(new ItemConfig(0, "pants", 1, "wear"));
                    permission = defaultPermission;
                }
            }
        
            public static Configuration GetDefault()
            {
                Configuration _config = new Configuration();

                _config.biomes.tundra = new Biome("autokit.tundra", true);
                _config.biomes.dust = new Biome("autokit.dust", true);
                _config.biomes.winter = new Biome("autokit.winter", true);
                _config.biomes.normal = new Biome("autokit.normal", true);

                return _config;
            }
        }

        protected override void LoadDefaultConfig() => _config = Configuration.GetDefault();
        protected override void SaveConfig() => Config.WriteObject(_config);
        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                _config = Config.ReadObject<Configuration>();
            }
            catch
            {
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }
        
        #endregion

        #region Data Management

        private void LoadData()
        {
            _storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>("AutoKit") ?? new StoredData();
        }

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject("AutoKit", _storedData);
        }

        private void OnServerSave()
        {
            SaveData();
        }

        void Unload()
        {
            SaveData();
        }

        #endregion

        #region Хуки

        private void Loaded()
        {
            permission.RegisterPermission(_config.biomes.tundra.permission, this);
            permission.RegisterPermission(_config.biomes.dust.permission, this);
            permission.RegisterPermission(_config.biomes.winter.permission, this);
            permission.RegisterPermission(_config.biomes.normal.permission, this);
            permission.RegisterPermission("autokit.admin", this);
            
            LoadData();
        }

        void Init()
        {
            LoadData();
        }

        private void OnDefaultItemsReceived(PlayerInventory inventory) 
        {
            var player = inventory.containerMain?.GetOwnerPlayer();

            if(player == null) return;

            switch(GetBiome(player.transform.position))
            {
                case "Dust":
                    ReciveItems(player, _config.biomes.dust);
                    break;

                case "Normal":
                    ReciveItems(player, _config.biomes.normal);
                    break;

                case "Tundra":
                    ReciveItems(player, _config.biomes.tundra);
                    break;

                case "Winter":
                    ReciveItems(player, _config.biomes.winter);
                    break;

                case "Undefined":
                    break;
            }
        }

        #endregion

        #region Методы

        [ChatCommand("autokit")]
        private void chatCmd(BasePlayer player, string command, string[] args) 
        {
            if(!permission.UserHasPermission(player.UserIDString, "autokit.admin")) return;

            if(args == null || args?.Length == 0) 
            {
                player.ChatMessage("Использование:\n/autokit [биом] - сохранить текущий набор для биома\n/autokit save [имя] - сохранить личный набор\n/autokit load [имя] - загрузить личный набор");
                return;
            }

            switch(args[0].ToLower())
            {
                case "save":
                    if(args.Length < 2)
                    {
                        player.ChatMessage("Укажите имя набора!");
                        return;
                    }
                    SavePlayerLoadout(player, args[1]);
                    return;

                case "load":
                    if(args.Length < 2)
                    {
                        player.ChatMessage("Укажите имя набора!");
                        return;
                    }
                    LoadPlayerLoadout(player, args[1]);
                    return;

                case "dust":
                    SetupNewItems(player, "dust");
                    return;

                case "tundra":
                    SetupNewItems(player, "tundra");
                    return;
                    
                case "winter":
                    SetupNewItems(player, "winter");
                    return;

                case "normal":
                    SetupNewItems(player, "normal");
                    return;
            }

            player.ChatMessage("Указан неизвестный аргумент!");
        }
        
        private void SavePlayerLoadout(BasePlayer player, string name)
        {
            var items = new List<Configuration.Biome.ItemConfig>();
            SaveItemsFromContainer(player, player.inventory.containerMain, "main", items);
            SaveItemsFromContainer(player, player.inventory.containerBelt, "belt", items);
            SaveItemsFromContainer(player, player.inventory.containerWear, "wear", items);

            var loadout = new SavedLoadout
            {
                Name = name,
                Items = items
            };

            if (!_storedData.PlayerLoadouts.ContainsKey(player.userID))
                _storedData.PlayerLoadouts[player.userID] = new Dictionary<string, List<SavedLoadout>>();

            if (!_storedData.PlayerLoadouts[player.userID].ContainsKey(name))
                _storedData.PlayerLoadouts[player.userID][name] = new List<SavedLoadout>();

            _storedData.PlayerLoadouts[player.userID][name].Add(loadout);
            SaveData();
            player.ChatMessage($"Набор {name} успешно сохранен!");
        }

        private void LoadPlayerLoadout(BasePlayer player, string name)
        {
            if (!_storedData.PlayerLoadouts.ContainsKey(player.userID) || 
                !_storedData.PlayerLoadouts[player.userID].ContainsKey(name) ||
                _storedData.PlayerLoadouts[player.userID][name].Count == 0)
            {
                player.ChatMessage($"Набор {name} не найден!");
                return;
            }

            var loadout = _storedData.PlayerLoadouts[player.userID][name].Last();
            player.inventory.Strip();

            foreach (var itemConfig in loadout.Items)
            {
                CreateAndGiveItem(player, itemConfig);
            }

            player.ChatMessage($"Набор {name} успешно загружен!");
        }
        
        private void SaveItemsFromContainer(BasePlayer player, ItemContainer container, string containerType, List<Configuration.Biome.ItemConfig> items)
        {
            foreach(var itemInventory in container.itemList) 
            {
                var item = new Configuration.Biome.ItemConfig(
                    itemInventory.skin, 
                    itemInventory.info.shortname, 
                    itemInventory.amount, 
                    containerType,
                    itemInventory.position
                );

                if(!string.IsNullOrEmpty(itemInventory.name)) 
                    item.name = itemInventory.name;

                // Сохраняем информацию о патронах
                var heldEntity = itemInventory.GetHeldEntity() as BaseProjectile;
                if (heldEntity != null)
                {
                    item.ammo = heldEntity.primaryMagazine.contents;
                    item.ammoType = heldEntity.primaryMagazine.ammoType.shortname;
                }

                // Сохраняем информацию о модификациях
                if (itemInventory.contents != null)
                {
                    foreach (var mod in itemInventory.contents.itemList)
                    {
                        item.mods[mod.position.ToString()] = mod.info.shortname;
                    }
                }

                items.Add(item);
            }
        }

        private void CreateAndGiveItem(BasePlayer player, Configuration.Biome.ItemConfig itemConfig)
        {
            Item item = ItemManager.CreateByName(itemConfig.shortname, itemConfig.amount, itemConfig.id);
            if (item == null) return;

            if (!string.IsNullOrEmpty(itemConfig.name))
                item.name = itemConfig.name;

            var container = GetContainer(player, itemConfig.container);
            if (container == null) return;

            // Устанавливаем позицию
            item.position = itemConfig.position;

            // Добавляем патроны если это оружие
            var heldEntity = item.GetHeldEntity() as BaseProjectile;
            if (heldEntity != null && !string.IsNullOrEmpty(itemConfig.ammoType))
            {
                heldEntity.primaryMagazine.contents = itemConfig.ammo;
                heldEntity.primaryMagazine.ammoType = ItemManager.FindItemDefinition(itemConfig.ammoType);
            }

            // Добавляем модификации
            if (itemConfig.mods.Count > 0)
            {
                foreach (var mod in itemConfig.mods)
                {
                    var modItem = ItemManager.CreateByName(mod.Value);
                    if (modItem != null)
                    {
                        modItem.position = int.Parse(mod.Key);
                        modItem.MoveToContainer(item.contents);
                    }
                }
            }

            item.MoveToContainer(container, itemConfig.position);
        }
        
        private void SetupNewItems(BasePlayer player, string caseStr) 
        {
            Configuration.Biome targetBiome = null;
            switch(caseStr)
            {
                case "dust":
                    targetBiome = _config.biomes.dust;
                    break;
                case "tundra":
                    targetBiome = _config.biomes.tundra;
                    break;
                case "winter":
                    targetBiome = _config.biomes.winter;
                    break;
                case "normal":
                    targetBiome = _config.biomes.normal;
                    break;
            }

            if (targetBiome == null) return;

            targetBiome.items = new List<Configuration.Biome.ItemConfig>();
            SaveItemsFromContainer(player, player.inventory.containerMain, "main", targetBiome.items);
            SaveItemsFromContainer(player, player.inventory.containerBelt, "belt", targetBiome.items);
            SaveItemsFromContainer(player, player.inventory.containerWear, "wear", targetBiome.items);

            NextTick(SaveConfig);
            player.ChatMessage("Автокит был успешно изменен!");
        }

        private void ReciveItems(BasePlayer player, Configuration.Biome biome) 
        {
            if(biome.recive && permission.UserHasPermission(player.UserIDString, biome.permission))
            {
                if(biome.strip) player.inventory.Strip();

                foreach(var itemConf in biome.items) 
                {
                    CreateAndGiveItem(player, itemConf);
                }
            }
        }
        
        private static ItemContainer GetContainer(BasePlayer player, string container) 
        {   
            switch(container) 
            {
                case "wear":
                    return player.inventory.containerWear;

                case "belt":
                    return player.inventory.containerBelt;

                case "main":
                    return player.inventory.containerMain;
            }

            return null;
        }

        private static string GetBiome(Vector3 pos)
        {
            if (TerrainMeta.BiomeMap.GetBiome(pos, 1) > 0.5f ) return "Dust";
            if (TerrainMeta.BiomeMap.GetBiome(pos, 2) > 0.5f ) return "Normal";
            if (TerrainMeta.BiomeMap.GetBiome(pos, 4) > 0.5f ) return "Tundra";
            if (TerrainMeta.BiomeMap.GetBiome(pos, 8) > 0.5f ) return "Winter";
            
            return "Undefined";
        }

        #endregion
    }
}

// --- End of file: AutoKit-9.9.9.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/IQTeleportation-1.5.7.cs ---
// --- Original Local Path: IQTeleportation-1.5.7.cs ---

using System.Collections.Generic;
using Oxide.Game.Rust.Cui;
using Physics = UnityEngine.Physics;
using System.Collections;
using System.Linq;
using UnityEngine.Networking;
using Pool = Facepunch.Pool;
using ConVar;
using System;
using ProtoBuf;
using UnityEngine;
using Oxide.Core.Plugins;
using Oxide.Core;
using System.Text;
using Newtonsoft.Json;
using Object = System.Object;
using Vector3 = UnityEngine.Vector3;

namespace Oxide.Plugins
{
    [Info("IQTeleportation", "Mercury", "1.5.7")]
    [Description("IQTeleportation")]
    class IQTeleportation : RustPlugin
    {
        
        private readonly List<String> exceptionsBuildingBlockEntities = new()
        {
            "rug.deployed",
            "rug.bear.deployed",
            "sleepingbag_leather_deployed",
            "bed_deployed",
            "box.wooden.large",
            "woodbox",
        };

        private IEnumerator ProcessTWarp(BasePlayer player, Vector3 position, Int32 timeTeleportation)
        {
            return ProcessTeleportation(
                player,
                () => false,
                () => TeleportationWarp(player, position),
                timeTeleportation
            );
        }
        
        private readonly List<UInt64> ItemIdCorrecteds = new List<UInt64> { 1074866732, 2004072627, 2017601552, 2006957888, 930560607, 1123047824, 1130765085, 442289265, 090353317, 15376018, 118372687 }; 
        
        private void ParseMonuments()
        {
            localAllMonuments.Clear();
            
            Int32 countAddedMonuments = 0;
            foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
            {
                if (monument.Bounds.size == Vector3.zero)
                    continue;
                
                localAllMonuments.Add(monument);
                countAddedMonuments++;
            }
            
            Puts(LanguageEn ? $"Information received about {countAddedMonuments} monuments on the map" : $"Получена информация о {countAddedMonuments} монументах на карте");
        }

        private String CanSetHome(BasePlayer player, BuildingBlock buildingBlock, String homeName, in Vector3 positionHome, Tugboat tugboatEntity = null)
        {
            Configuration.HomeController.SetupHome homeController = config.homeController.setupHomeController;
            Object canSetHome = Interface.Call("OnHomeAdd", player, homeName, positionHome);

            if (canSetHome != null)
            {
                if (canSetHome is String errorMessage && !String.IsNullOrWhiteSpace(errorMessage))
                    return errorMessage;

                return GetLang("CAN_SETHOME_OTHER_MESSAGE", player.UserIDString);
            }

            String statusPlayer = CheckStatusPlayer(player);
            if (!String.IsNullOrWhiteSpace(statusPlayer))
                return statusPlayer;
            
            if(homeController.noSetupInRaidBlock && IsRaidBlocked(player))
                return GetLang("CAN_SETHOME_IS_RAIDBLOCK", player.UserIDString);
            
            Dictionary<String, PlayerHome> pData = playerHomes[player.userID];
		   		 		  						  	   		   		 		  			 		  	   		  				
            if (pData.Count >= config.homeController.homeCount.GetCount(player, true))
                return GetLang("CAN_SETHOME_MAXIMUM_HOMES", player.UserIDString);
            
            if (pData.ContainsKey(homeName))
                return GetLang("CAN_SETHOME_EXIST_HOMENAME", player.UserIDString, homeName);

            foreach (KeyValuePair<String, PlayerHome> homesPlayer in pData)
            {
                if (Vector3.Distance(homesPlayer.Value.positionHome, positionHome) < 2.8f) 
                    return GetLang("CAN_SETHOME_DISTANCE_EXIST_HOME", player.UserIDString, homesPlayer.Key);
            }
            
            if (tugboatEntity != null)
            {
                if (!config.homeController.setupHomeController.canSetupTugboatHome)
                    return GetLang("CAN_SETHOME_TUGBOAT_DISABLE", player.UserIDString);

                UInt64[] friendList = GetFriendList(player);
                if(friendList == null || friendList.Length == 0) return String.Empty; 
		   		 		  						  	   		   		 		  			 		  	   		  				
                Boolean isAuthedFriend = tugboatEntity.children
                    .OfType<VehiclePrivilege>()
                    .Any(vehiclePrivilege => friendList.Any(vehiclePrivilege.IsAuthed));

                return !isAuthedFriend && !tugboatEntity.IsAuthed(player) ? GetLang("CAN_SETHOME_BUILDING_PRIVILAGE_AUTH_TUGBOAT", player.UserIDString) : String.Empty; 
            }
            
            BuildingPrivlidge buildingPrivilage = player.GetBuildingPrivilege();
            
            if(homeController.onlyBuildingPrivilage && buildingPrivilage == null)
                return GetLang("CAN_SETHOME_BUILDING_PRIVILAGE", player.UserIDString);

            if (homeController.onlyBuildingAuth && buildingPrivilage != null && !player.IsBuildingAuthed())
                return GetLang("CAN_SETHOME_BUILDING_PRIVILAGE_AUTH", player.UserIDString);
            
            if (!buildingBlock)
            {
                buildingBlock = GetBuildingBlock(positionHome);
                if (!buildingBlock)
                    return GetLang("CAN_SETHOME_BUILDING", player.UserIDString);
            }
            
            return String.Empty;
        }
        
        [ConsoleCommand("sethome")]
        private void SetHomeConsoleCMD(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            
            if (arg.Args.Length == 0)
            {
                SendChat(GetLang("SYNTAX_COMMAND_SETHOME", player.UserIDString), player, true);
                return;
            }
		   		 		  						  	   		   		 		  			 		  	   		  				
            String homeName = arg.Args[0];
            SetHome(player, homeName);
        }
        private class ServerWarp
        {
            public Vector3 position;
            public String monumentParent;
            public Boolean hideWarp;
            
            public Vector3 GetPositionWarp()
            {
                if (hideWarp) return default;
                MonumentInfo monument = _.GetMonumentInName(monumentParent);
                if (!monument) return position;
                    
                return monument.transform.TransformPoint(position);
            }

            public ServerWarp(MonumentInfo monument, Vector3 warpPosition)
            {
                if (monument)
                {
                    position = monument.transform.InverseTransformPoint(warpPosition);
                    monumentParent = monument.name;
                }
                else
                {
                    position = warpPosition;
                    monumentParent = String.Empty;
                }
                
                hideWarp = false;
            }
        }
        private Dictionary<UInt64, Dictionary<String, PlayerHome>> playerHomes = new();
        
                
        
        
        [ConsoleCommand("ui_teleportation_command")] 
        private void UICommandConsole(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;

            if (arg.Args.Length == 0) return;
            String action = arg.Args[0];

            switch (action)
            {
                case "sethome":
                {
                    if (arg.Args.Length < 1) return;
                    
                    Dictionary<String, PlayerHome> pData = playerHomes[player.userID];
                    if (pData.Count >= config.homeController.homeCount.GetCount(player, true)) return;
                    String mbName = GetNextHomeName(pData);

                    if (bagInstalled.TryGetValue(player, out SleepingBag bag))
                    {
                        SetHome(player, mbName, bag);
                        bagInstalled.Remove(player);
                    }
                    
                    break;
                }
		   		 		  						  	   		   		 		  			 		  	   		  				
                case "cancell.sethome":
                {
                    if (bagInstalled.ContainsKey(player))
                        bagInstalled.Remove(player);
                    
                    break;
                }

                case "tpa":
                {
                    AcceptRequestTeleportation(player);
                    break;
                }

                case "tpc":
                {
                    CancellTeleportation(player);
                    break;
                }
            }
        }
        private Dictionary<BasePlayer, BasePlayer> casheTeleportationLast = new ();

        private class TeleportationQueueInfo
        {
            public Boolean isAccepted;
            public Boolean isActive;
            public BasePlayer player;
        }
        
        [ChatCommand("sethome")]
        private void SetHomeChatCMD(BasePlayer player, String cmd, String[] arg)
        {
            if (arg.Length == 0)
            {
                SendChat(GetLang("SYNTAX_COMMAND_SETHOME", player.UserIDString), player, true);
                return;
            }

            String homeName = arg[0];
            SetHome(player, homeName);
        }
        
        private class UserRepository
        {
            public Coroutine activeTeleportation;
            public Double cooldownWarp;
            public Double cooldownHome;
            public Double cooldownTeleportation;
            
            public enum TeleportType
            {
                Warp,
                Home,
                Teleportation
            }
            
            public void SetupCooldown(BasePlayer player, TeleportType teleportType)
            {
                Int32 cooldown = teleportType switch
                {
                    TeleportType.Home => config.homeController.homeCooldown.GetCount(player),
                    TeleportType.Teleportation => config.teleportationController.teleportCooldown.GetCount(player),
                    TeleportType.Warp => config.warpsContoller.teleportWarpCooldown.GetCount(player),
                    _ => throw new ArgumentOutOfRangeException(nameof(teleportType), teleportType, null)
                };

                switch (teleportType)
                {
                    case TeleportType.Home:
                        cooldownHome = CurrentTime + cooldown;
                        break;
                    case TeleportType.Teleportation:
                        cooldownTeleportation = CurrentTime + cooldown;
                        break;
                    case TeleportType.Warp:
                        cooldownWarp = CurrentTime + cooldown;
                        break;
                    default:
                        throw new ArgumentOutOfRangeException(nameof(teleportType), teleportType, null);
                }

                DeActiveTeleportation();
            }
            
            public String GetCooldownTitle(BasePlayer player, TeleportType teleportType)
            {
                Double cooldownLeft = teleportType switch
                {
                    TeleportType.Warp => cooldownWarp - CurrentTime,
                    TeleportType.Home => cooldownHome - CurrentTime,
                    _ => cooldownTeleportation - CurrentTime
                };
                
                String cooldownLeftTitle = cooldownLeft <= 0 ? String.Empty : _.FormatTime(cooldownLeft, player.UserIDString);
                return cooldownLeftTitle;
            }

            public Boolean IsActiveTeleportation() => activeTeleportation != null;

            public void ActiveCoroutineController(Coroutine coroutine, BasePlayer target = null)
            {
                DeActiveTeleportation();
                activeTeleportation = coroutine;
            }

            public void DeActiveTeleportation()
            {
                if (!IsActiveTeleportation()) return;
                ServerMgr.Instance.StopCoroutine(activeTeleportation);
                activeTeleportation = null;
            }
        }

        [ConsoleCommand("rh")]
        private void RemoveHomeShortConsoleCMD(ConsoleSystem.Arg arg) => RemoveHomeConsoleCMD(arg);
        private Dictionary<BasePlayer, MapNote> playerPings = new();
		   		 		  						  	   		   		 		  			 		  	   		  				
                
        
        [ChatCommand("home")]
        private void HomeChatCMD(BasePlayer player, String cmd, String[] arg)
        {
            if (arg.Length == 0)
            {
                SendChat(GetLang("SYNTAX_COMMAND_HOME_TELEPORTATION", player.UserIDString), player, true);
                return;
            }
            
            RequestHome(player, arg);
        }

                
        
        
                
        private Boolean AcceptRequestTeleportation(BasePlayer player, Boolean isAutoAccept = false)
        {
            if (!playerTeleportationQueue.TryGetValue(player.userID, out TeleportationQueueInfo requester))
            {
                SendChat(GetLang("CAN_ACCEPT_TELEPORTATION_NOT_REQUEST", player.UserIDString), player, true);
                return false;
            }
            
            if (!requester.isActive)
            {
                SendChat(GetLang("CAN_ACCEPT_TELEPORTATION_NOT_REQUEST", player.UserIDString), player, true); 
                return false;
            }

            if (requester.isAccepted)
            {
                SendChat(GetLang("CAN_ACCEPT_TELEPORTATION_ACTIVE_ACCEPTED", player.UserIDString), player, true);
                return false;
            }
            
            String canTeleport = CanTeleportation(player, UserRepository.TeleportType.Teleportation, true);
            if (!String.IsNullOrWhiteSpace(canTeleport))
            {
                SendChat(canTeleport, player, true);
                localUsersRepository[requester.player].DeActiveTeleportation();
                return false;
            }
            
            Object OnTeleportRequested = Interface.Call("OnTeleportRequested", player, requester.player);
            if (OnTeleportRequested != null)
            {
                if (OnTeleportRequested is String hookResult)
                {
                    SendChat(hookResult, player, true);
                    localUsersRepository[requester.player].DeActiveTeleportation(); 
                    return false;
                }
                
                if (OnTeleportRequested is Boolean hookResultBoolean)
                    if (!hookResultBoolean)
                    {
                        SendChat(GetLang("ACCESS_CANCELL_TELEPORTATION", player.UserIDString), player, true);
                        localUsersRepository[requester.player].DeActiveTeleportation(); 
                        return false;
                    }
            }
		   		 		  						  	   		   		 		  			 		  	   		  				
            requester.isAccepted = true;
            
            if (config.teleportationController.teleportSetting.suggetionAcceptedUI)
                DestroyUI(player, InterfaceBuilder.IQ_TELEPORT_UI_TELEPORT);
            
            Int32 teleportationCountdown = config.teleportationController.teleportCountdown.GetCount(requester.player);
            
            Coroutine routineTeleportation = ServerMgr.Instance.StartCoroutine(ProcessTTarget(requester.player, player, teleportationCountdown));
            
            localUsersRepository[requester.player].ActiveCoroutineController(routineTeleportation);
            casheTeleportationLast[player] = requester.player;

            String autoRequestMessage = isAutoAccept ? "CAN_REQUEST_TELEPORTATION_ACCESS_AUTO_TELEPORT" : "CAN_REQUEST_TELEPORTATION_ACCESS";

            LogAction(player, TypeLog.AcceptTeleportation, requester.player, default, default);
            
            SendChat(GetLang(autoRequestMessage, player.UserIDString, requester.player.displayName), player);
            SendChat(GetLang("REQUEST_TELEPORTATION_ACCESS", requester.player.UserIDString, FormatTime(teleportationCountdown, requester.player.UserIDString)), requester.player);

            Interface.Call("OnTeleportAccepted", player, requester.player, teleportationCountdown);

            return true;
        }
        private const String permissionWarpAdmin = "iqteleportation.warpadmin";

        
        
        [ChatCommand("tp")]
        private void TpChatCMD(BasePlayer player, String cmd, String[] arg)
        {
            if (player == null) return;
            if (!player.IsAdmin && !permission.UserHasPermission(player.UserIDString, permissionTP)) return;

            if (arg.Length == 0 && !casheTeleportationLast.ContainsKey(player))
            {
                SendChat(GetLang("SYNTAX_COMMAND_TELEPORT", player.UserIDString), player, true);
                return;
            }
            
            String nameOrIDTarget = arg[0];
            (BasePlayer, String) findPlayer = FindPlayerNameOrID(player, nameOrIDTarget);
            BasePlayer targetPlayer = null;
            if(!String.IsNullOrWhiteSpace(nameOrIDTarget))
                targetPlayer = findPlayer.Item1;
            
            String nameOrIDOnPlayer = String.Empty;
            BasePlayer onPlayer = null;

            if (arg.Length >= 2)
            {
                nameOrIDOnPlayer = arg[1];
                (BasePlayer, String) findOnPlayer = FindPlayerNameOrID(player, nameOrIDOnPlayer);

                if (!String.IsNullOrWhiteSpace(nameOrIDOnPlayer))
                {
                    onPlayer = targetPlayer;
                    targetPlayer = findOnPlayer.Item1;
                }

                if (onPlayer == null)
                {
                    SendChat(findOnPlayer.Item2 ?? GetLang("CAN_TELEPORT_PLAYER_NOT_FOUND_TP_ONE_PLAYER", player.UserIDString), player, true);
                    return;
                }

                if (targetPlayer == null)
                {
                    SendChat(findPlayer.Item2 ?? GetLang("CAN_TELEPORT_PLAYER_NOT_FOUND_TP_TARGET_PLAYER_ONE", player.UserIDString, nameOrIDTarget), player, true);
                    return;
                }
            }
            else onPlayer = player;
            
            if (targetPlayer == null)
            {
                SendChat(findPlayer.Item2 ?? GetLang("CAN_TELEPORT_PLAYER_NOT_FOUND_TP_TARGET_PLAYER", player.UserIDString), player, true);
                return;
            }
            
            MovePlayer(onPlayer, targetPlayer.transform.position);
            SendChat(GetLang("CAN_TELEPORT_PLAYER_ACCES_TP", onPlayer.UserIDString, targetPlayer.displayName), onPlayer);
        }
        
        private MonumentInfo GetMonumentWherePlayerStand(BasePlayer player)
        {
            MonumentInfo closestMonument = null;

            foreach (MonumentInfo monument in localAllMonuments)
            {
                Vector3 monumentCenter = monument.transform.TransformPoint(monument.Bounds.center);
                Vector3 monumentSize = monument.transform.TransformVector(monument.Bounds.size);
                Single monumentRadius = monumentSize.magnitude / 2f;
                Single distanceToMonument = Vector3.Distance(player.transform.position, monumentCenter);
                if (distanceToMonument <= monumentRadius)
                {
                    closestMonument = monument;
                    break;
                }
            }

            return closestMonument;
        }
        private List<MonumentInfo> localAllMonuments = new();
        
        private void ChatCommandWarp(BasePlayer player, String command, String[] args) 
        {
            if (!config.warpsContoller.useWarps) return;

            if (!player.IsAdmin)
                if (!permission.UserHasPermission(player.UserIDString, permissionWarpAdmin))
                    return;

            if (args.Length < 1)
            {
                SendChat(GetLang("SYNTAX_COMMAND_WARPS", player.UserIDString), player, true);
                return;
            }

            String action = args[0];
            String warpName = args.Length >= 2 ? args[1].ToLower() : null;
            
            MonumentInfo pMonument = GetMonumentWherePlayerStand(player);
            
            Vector3 pPosition = player.transform.position;
            
            switch (action)
            {
                case "points":
                {
                    if (string.IsNullOrWhiteSpace(warpName))
                    {
                        SendChat(GetLang("WARP_NOT_ARG_NAME", player.UserIDString), player, true); 
                        return;
                    }

                    if (!serverWarps.TryGetValue(warpName, out List<ServerWarp> warpPoints))
                    {
                        SendChat(GetLang("WARP_NOTHING_NAME", player.UserIDString), player, true);
                        return;
                    }

                    for (Int32 indexPoint = 0; indexPoint < warpPoints.Count; indexPoint++)
                    {
                        Vector3 warpPoint = warpPoints[indexPoint].GetPositionWarp();
                        if (warpPoint == default) return;
                        DrawSphereAndText(player, warpPoint, $"{indexPoint}");
                    }
                    
                    SendChat(GetLang("WARP_SHOW_POINTS", player.UserIDString, warpName), player, true);
                    break;
                }
                case "list":
                {
                    StringBuilder warpListBuilder = Pool.Get<StringBuilder>();

                    foreach (KeyValuePair<String, List<ServerWarp>> warps in serverWarps)
                    {
                        warpListBuilder.AppendLine($"{warps.Key} :");
                        
                        for (Int32 indexWarpPos = 0; indexWarpPos < warps.Value.Count; indexWarpPos++)
                        {
                            Vector3 warpPoint = warps.Value[indexWarpPos].GetPositionWarp();
                            warpListBuilder.AppendLine($"{indexWarpPos} : {(warpPoint == default ? "NONE MONUMENT" : warpPoint)}");
                        }

                        warpListBuilder.AppendLine(); 
                    }

                    String message = warpListBuilder.ToString();
                    if (String.IsNullOrWhiteSpace(message))
                        message = GetLang("WARP_NOTHING", player.UserIDString);
                    
                    SendChat(message, player);
                    Pool.FreeUnmanaged(ref warpListBuilder);
                    break;
                }
                case "create":
                case "add":
                case "set":
                { 
                    if (string.IsNullOrWhiteSpace(warpName))
                    {
                        SendChat(GetLang("WARP_NOT_ARG_NAME", player.UserIDString), player, true); 
                        return;
                    }
                    
                    if (serverWarps.ContainsKey(warpName))
                    {
                        for (Int32 indexPoint = 0; indexPoint < serverWarps[warpName].Count; indexPoint++)
                        {
                            Vector3 warpPoint = serverWarps[warpName][indexPoint].GetPositionWarp();
                            if (warpPoint == default) continue;
                            if (Vector3.Distance(warpPoint, player.transform.position) > 5f) continue;
                            
                            SendChat(GetLang("WARP_SETUP_POINTS_DISTANCE", player.UserIDString, indexPoint), player, true); 
                            return;
                        }

                        serverWarps[warpName].Add(new ServerWarp(pMonument, pPosition));
                        SendChat(GetLang("WARP_SETUP_POINT_ACCESS", player.UserIDString, warpName), player);
                        return;
                    }

                    serverWarps.Add(warpName, new List<ServerWarp>() { new(pMonument, pPosition) });
                    
                    cmd.AddChatCommand(warpName, this, nameof(ChatCommandTeleportationWarp));
                    cmd.AddConsoleCommand(warpName, this, nameof(ConsoleCommandTeleportationWarp));
                        
                    SendChat(GetLang("WARP_SETUP_NEW", player.UserIDString, warpName, warpName.ToLower()), player); 
                    break;
                }
                case "edit":
                case "update":
                {
                    if (string.IsNullOrWhiteSpace(warpName))
                    {
                        SendChat(GetLang("WARP_NOT_ARG_NAME", player.UserIDString), player, true); 
                        return;
                    }

                    if (!serverWarps.TryGetValue(warpName, out List<ServerWarp> warpPoints))
                    {
                        SendChat(GetLang("WARP_NOTHING_NAME", player.UserIDString), player, true);
                        return;
                    }
                    
                    if (args.Length < 3)
                    {
                        String pointsKeys = GetWarpPoints(warpName);
                        SendChat(GetLang("WARP_NOTHING_KEY_POINTS", player.UserIDString, pointsKeys), player, true);
                        return;
                    }
                    
                    String warpKeyString = args[2];

                    if (!Int32.TryParse(warpKeyString, out Int32 warpKey) || warpKey < 0)
                    {
                        SendChat(GetLang("WARP_NOTHING_KEY_IS_NUMBER", player.UserIDString), player, true);
                        return;
                    }

                    if (warpPoints.Count < warpKey)
                    {
                        String pointsKeys = GetWarpPoints(warpName);
                        SendChat(GetLang("WARP_REMOVED_POINT_NOTHING_KEYS", player.UserIDString, warpKey, warpName, pointsKeys), player, true); 
                        return;
                    }

                    for (Int32 indexPoint = 0; indexPoint < serverWarps[warpName].Count; indexPoint++)
                    {
                        Vector3 warpPoint = serverWarps[warpName][indexPoint].GetPositionWarp();
                        if(warpPoint == default) continue;
                        if (indexPoint == warpKey || Vector3.Distance(warpPoint, player.transform.position) > 5f) continue;
                        SendChat(GetLang("WARP_SETUP_POINTS_DISTANCE", player.UserIDString, indexPoint), player, true); 
                        return;
                    }

                    serverWarps[warpName][warpKey] = new ServerWarp(pMonument, pPosition);
                    SendChat(GetLang("WARP_EDIT_POINT_ACCESS", player.UserIDString, warpName), player); 
                    break;
                }
                case "remove":
                case "delete":
                {
                    //(IndexOutOfRangeException: Index was outside the bounds of the array.)
                    //warp remove jopa
                    if (string.IsNullOrWhiteSpace(warpName))
                    {
                        SendChat(GetLang("WARP_NOT_ARG_NAME", player.UserIDString), player, true); 
                        return;
                    }
                    
                    if (!serverWarps.TryGetValue(warpName, out List<ServerWarp> warpPoints))
                    {
                        SendChat(GetLang("WARP_NOTHING_NAME", player.UserIDString), player, true);
                        return;
                    }
                    
                    String warpKeyString = args.Length >= 3 ? args[2] : String.Empty;
                    
                    if (!String.IsNullOrWhiteSpace(warpKeyString) && warpPoints.Count > 1)
                    {
                        if (!Int32.TryParse(warpKeyString, out Int32 warpKey) || warpKey < 0)
                        {
                            SendChat(GetLang("WARP_NOTHING_KEY_IS_NUMBER", player.UserIDString), player, true);
                            return;
                        }
                        
                        if (warpPoints.Count < warpKey)
                        {
                            String pointsKeys = GetWarpPoints(warpName);
                            SendChat(GetLang("WARP_REMOVED_POINT_NOTHING_KEYS", player.UserIDString, warpKey, warpName, pointsKeys), player, true); 
                            return;
                        }
                        
                        serverWarps[warpName].RemoveAt(warpKey);
                        SendChat(GetLang("WARP_REMOVED_POINT", player.UserIDString, warpKey, warpName), player, true); 
                        return;
                    }
        
                    serverWarps.Remove(warpName);
                    cmd.RemoveChatCommand(warpName, this);
                    cmd.RemoveConsoleCommand(warpName, this);
                    
                    SendChat(GetLang("WARP_REMOVED", player.UserIDString, warpName), player); 
                    break;
                }
            }
        }

        
        
        [ChatCommand("gmap")]
        private void GMapTeleportChatCmd(BasePlayer player) => GMapTeleportTurn(player);
        private const String effectSoundTimer = "assets/prefabs/weapons/mp5/effects/fire_select.prefab";

        
        
        private void CheckAllHomes(BasePlayer player, String homeName = "")
        {
            if (!playerHomes.TryGetValue(player.userID, out Dictionary<String, PlayerHome> pHome)) return;

            if (!String.IsNullOrWhiteSpace(homeName))
            {
                if (!pHome.TryGetValue(homeName, out PlayerHome home)) return;
                
                if (!CheckHome(player, homeName, home))
                    pHome.Remove(homeName);
                return;
            }
            
            List<String> homesToRemove = Pool.Get<List<String>>();

            foreach (KeyValuePair<String, PlayerHome> pData in pHome)
            {
                if (!CheckHome(player, pData.Key, pHome[pData.Key]))
                    homesToRemove.Add(pData.Key);
            }

            foreach (String home in homesToRemove)
                pHome.Remove(home);
            
            Pool.FreeUnmanaged(ref homesToRemove);
        }
        private static ImageUI _imageUI;
        
        
        
        private Boolean IsPlayerWithinBlockedMonument(BasePlayer player)
        {
            if (config.generalController.monumentBlockedTeleportation.Count == 0) return false;
            MonumentInfo monument = GetMonumentWherePlayerStand(player);
            return monument && config.generalController.monumentBlockedTeleportation.Contains(monument.name);
        }
        
        private void TeleportationWarp(BasePlayer player, Vector3 position)
        {
            if (!player.IsValid())
                return;

            String canTeleport = CanTeleportation(player, UserRepository.TeleportType.Warp);
            if (!String.IsNullOrWhiteSpace(canTeleport))
            {
                SendChat(canTeleport, player, true);
                return;
            }

            localUsersRepository[player].SetupCooldown(player, UserRepository.TeleportType.Warp); 
            MovePlayer(player, position);
            SendChat(GetLang("WARP_TELEPORTATION_PLAYER", player.UserIDString), player);
        }
        private Dictionary<String, List<String>> cachedUI = new();

        private void AutoClearData(Boolean isNewSave = false)
        {
            Int32 settingClear = default;

                        
            List<UInt64> keysPlayersSetting = Pool.Get<List<UInt64>>();
            keysPlayersSetting.AddRange(playerSettings.Keys);
            DateTime currentDate = DateTime.Now;
            
            foreach (UInt64 keyPlayer in keysPlayersSetting)
            {
                SettingPlayer playerSetting = playerSettings[keyPlayer];
                Int32 leftDays = (currentDate - playerSetting.firstConnection).Days;
                if (leftDays < 7) continue;
                playerSettings.Remove(keyPlayer);
                settingClear++;
            }

            Pool.FreeUnmanaged(ref keysPlayersSetting);
            
                        
            if(settingClear != default)
                Puts(LanguageEn ? $"Automatic cleaning of user settings. {settingClear} users and their settings were deleted due to absence from the server for more than 7 days" : $"Автоматическая очистка настроек пользоваталей. Было удалено {settingClear} пользователей и их настройки из-за отсутствия более 7 дней на сервере");
            
            if (isNewSave)
            {
                playerHomes.Clear();

                List<String> keysToRemove = new List<String>();

                foreach (KeyValuePair<String, List<ServerWarp>> warps in serverWarps)
                {
                    List<ServerWarp> warpsToRemove = new List<ServerWarp>();
		   		 		  						  	   		   		 		  			 		  	   		  				
                    foreach (ServerWarp warp in warps.Value)
                    {
                        if (String.IsNullOrWhiteSpace(warp.monumentParent))
                            warpsToRemove.Add(warp);
                    }

                    foreach (ServerWarp warp in warpsToRemove)
                        warps.Value.Remove(warp);

                    if (warps.Value.Count == 0)
                        keysToRemove.Add(warps.Key);
                    
                    warpsToRemove.Clear();
                    warpsToRemove = null;
                }

                foreach (String key in keysToRemove)
                {
                    cmd.RemoveChatCommand(key, this);
                    cmd.RemoveConsoleCommand(key, this);
                    serverWarps.Remove(key);
                }

                keysToRemove.Clear();
                keysToRemove = null;
            }
            
            WriteData();
        }

        private Boolean CheckHome(BasePlayer player, String homeName, PlayerHome pHome)
        {
            if (pHome.netIdEntity != 0)
            {
                if (tugboatsServer.TryGetValue(pHome.netIdEntity, out Tugboat tugboat) && tugboat && !tugboat.IsDestroyed)
                    return true;
                
                SendChat(GetLang("CAN_TELEPORT_HOME_NOT_TUGBOAT", player.UserIDString, homeName), player);
                return false;
            }
    
            BuildingBlock buildingBlock = GetBuildingBlock(pHome.positionHome);
            if (!buildingBlock)
            {
                SendChat(GetLang("CAN_TELEPORT_HOME_NOT_BUILDING_BLOCK", player.UserIDString, homeName), player);
                return false;
            }

            if (!config.homeController.setupHomeController.onlyBuildingAuth) return true;
            BuildingPrivlidge privilege = buildingBlock.GetBuildingPrivilege();
            if (privilege == null || privilege.IsAuthed(player)) return true;
            SendChat(GetLang("CAN_TELEPORT_HOME_NOT_AUTH_BUILDING_PRIVILAGE", player.UserIDString, homeName), player);
            return false;
        }

        [ConsoleCommand("homelist")]
        private void ConsoleCommand_HomeList(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            
            Dictionary<String, Vector3> homeList = GetHomes(player.userID);
            if (homeList == null || homeList.Count == 0)
            {
                SendChat(GetLang("HOMELIST_COMMAND_EMPTY", player.UserIDString), player);
                return;
            }
            
            String homesPlayerOnCord = String.Empty;

            foreach (KeyValuePair<String, Vector3> homeInfo in homeList)
            {
                String cordMap = MapHelper.PositionToString(homeInfo.Value);
                homesPlayerOnCord += GetLang("HOMELIST_COMMAND_FORTMAT_HOME", player.UserIDString, homeInfo.Key, cordMap);
            }
            
            SendChat(GetLang("HOMELIST_COMMAND_ALL_LIST", player.UserIDString, homesPlayerOnCord), player);
        }

        private void OnServerInitialized()
        {
            RegisteredPermissions();
            
            if(config.teleportationController.teleportSetting.suggetionAcceptedUI || config.homeController.suggetionSetHomeAfterInstallBed)
            {
                _imageUI = new ImageUI();
                _imageUI.DownloadImage();
            }
            
            AutoClearData();
            
            if (config.generalController.monumentBlockedTeleportation.Count != 0 || config.warpsContoller.useWarps)
                ParseMonuments();

            if (config.homeController.setupHomeController.canSetupTugboatHome)
                ParseTugboats();
            
            foreach (BasePlayer player in BasePlayer.activePlayerList)
                OnPlayerConnected(player);

            ValidateWarps();
            
            timerCheckHomes = timer.Every(300, () =>
            {
                List<BasePlayer> players = Pool.Get<List<BasePlayer>>();
                players.AddRange(BasePlayer.activePlayerList);
                
                for (Int32 i = 0; i < players.Count; i++)
                {
                    BasePlayer player = players[i];
                    if (player == null || !player.IsConnected) continue;
                    CheckAllHomes(player);
                }
                
                Pool.FreeUnmanaged(ref players);
            });
        }
        protected override void SaveConfig() => Config.WriteObject(config);
        void OnPlayerDisconnected(BasePlayer player, String reason) => DestroyPing(player);
        private const String tpaLog = LanguageEn ? "" : "принял запрос на телепортацию от";

        
        private Single GetGroundPosition(in Vector3 pos)
        {
            Single y = TerrainMeta.HeightMap.GetHeight(pos);
            return Physics.Raycast(new Vector3(pos.x, pos.y + 200f, pos.z), Vector3.down, out RaycastHit hitInfo, float.MaxValue, (Rust.Layers.Mask.Vehicle_Large | Rust.Layers.Solid | Rust.Layers.Mask.Water)) ? Mathf.Max(hitInfo.point.y, y) : y;
        }
		   		 		  						  	   		   		 		  			 		  	   		  				
        [ConsoleCommand("sh")]
        private void SetHomeShortConsoleCMD(ConsoleSystem.Arg arg) => SetHomeConsoleCMD(arg);

        private (BasePlayer, String) FindPlayerNameOrID(BasePlayer finder, String nameOrID, Boolean findSleeper = false)
        {
            List<BasePlayer> players = Pool.Get<List<BasePlayer>>();
            players.AddRange(findSleeper ? BasePlayer.allPlayerList : BasePlayer.activePlayerList);
            
            if (nameOrID.IsSteamId() && ulong.TryParse(nameOrID, out UInt64 userID))
            {
                BasePlayer player = BasePlayer.FindByID(userID);
                Pool.FreeUnmanaged(ref players);
                return (player, null);
            }

            List<BasePlayer> matchingPlayers = Pool.Get<List<BasePlayer>>();

            try
            {
                matchingPlayers.AddRange(players.Where(player => player.displayName != null && player.displayName.IndexOf(nameOrID, StringComparison.OrdinalIgnoreCase) >= 0));
		   		 		  						  	   		   		 		  			 		  	   		  				
                switch (matchingPlayers.Count)
                {
                    case 1:
                    {
                        BasePlayer foundPlayer = matchingPlayers[0];
                        return (foundPlayer, null);
                    }
                    case > 1:
                    {
                        String nicknameList = String.Join(", ", matchingPlayers.Take(3).Select(p => p.displayName));
                        return (null, GetLang("FIND_PLAYER_INFO_MATCHES", finder.UserIDString, nameOrID, nicknameList));
                    }
                    default:
                        return (null, null);
                }
            }
            finally
            {
                Pool.FreeUnmanaged(ref players);
                Pool.FreeUnmanaged(ref matchingPlayers);
            }
        }
        
        private void RunEffect(BasePlayer player, String effectPath)
        {
            if (!config.generalController.useSoundEffects) return;
            Effect effect = new Effect(effectPath, player, 0, new Vector3(), new Vector3());
            EffectNetwork.Send(effect, player.Connection);
        }
        private static Double CurrentTime => Facepunch.Math.Epoch.Current;
        
        private String CanRequestTeleportation(BasePlayer player, BasePlayer targetPlayer, String error = "")
        {
            if (!targetPlayer)
                return error ?? GetLang("CAN_REQUEST_TELEPORTATION_NOT_FOUND_PLAYER", player.UserIDString);
		   		 		  						  	   		   		 		  			 		  	   		  				
            // if (player.userID == targetPlayer.userID)
            //     return GetLang("CAN_REQUEST_TELEPORTATION_NOTHING_TELEPORT_ME", player.UserIDString);
            
            if (playerTeleportationQueue.ContainsKey(player.userID))
                return playerTeleportationQueue[player.userID].player 
                     ? GetLang("CAN_REQUEST_TELEPORTATION_TELEPORTED_REQUEST_ACTUALY_NAME", player.UserIDString, playerTeleportationQueue[player.userID].player.displayName) 
                     : GetLang("CAN_REQUEST_TELEPORTATION_TELEPORTED_REQUEST_ACTUALY", player.UserIDString);
            
            if (playerTeleportationQueue.ContainsKey(targetPlayer.userID))
                return GetLang("CAN_REQUEST_TELEPORTATION_ALREADY_REQUEST_TARGET", player.UserIDString);
            
            String canTeleport = CanTeleportation(player, UserRepository.TeleportType.Teleportation);
            if (!String.IsNullOrWhiteSpace(canTeleport))
                return canTeleport;
        
            if (config.teleportationController.teleportSetting.onlyTeleportationFriends && !IsFriends(player, targetPlayer.userID))
                return GetLang("CAN_REQUEST_TELEPORTATION_ONLY_REQUEST_FRIENDS", player.UserIDString);
            
            return String.Empty;
        }
        
        private Object OnMapMarkerAdd(BasePlayer player, MapNote note) 
        {
            if (player == null || note == null)
                return null;
            
            Vector3 positionTeleportation = note.worldPosition;
            positionTeleportation.y = GetGroundPosition(positionTeleportation);
            
            if (config.teleportationController.teleportSetting.useGMapTeleport)
            {
                RelationshipManager.PlayerTeam teams = player.Team;
                if (teams != null)
                {
                    foreach (UInt64 teamsMember in teams.members)
                    {
                        if (teamsMember == player.userID) continue;
                        BasePlayer teamPlayer = BasePlayer.FindByID(teamsMember);
                        if (teamPlayer == null) continue;
                        if (Vector3.Distance(positionTeleportation, teamPlayer.transform.position) < 30f)
                        {
                            RequestTeleportation(player, new []{ teamPlayer.UserIDString });
                            return false;
                        }
                    }
                }
            }

            if (config.teleportationController.teleportSetting.useGMapTeleportAdmin)
            {
                if (playerSettings[player.userID].useTeleportGMap && (player.IsAdmin || permission.UserHasPermission(player.UserIDString,
                        permissionGMapTeleport)))
                {
                    MovePlayer(player, positionTeleportation);
                    return false;
                }
            }

            return null;
        }
        
                
        
        [ChatCommand("sh")]
        private void SetHomeShortChatCMD(BasePlayer player, String cmd, String[] arg) =>
            SetHomeChatCMD(player, cmd, arg);
        
        private Dictionary<String, Vector3> GetHomes(UInt64 userID)
        {
            Dictionary<String, Vector3> homeList = new();
            if (!playerHomes.TryGetValue(userID, out Dictionary<String, PlayerHome> home)) return homeList;

            foreach (KeyValuePair<String, PlayerHome> pHome in home)
            {
                Vector3 positionHome = default;
                if (pHome.Value.netIdEntity != 0)
                {
                    if (tugboatsServer.TryGetValue(pHome.Value.netIdEntity, out Tugboat tugboat) && tugboat &&
                        !tugboat.IsDestroyed)
                        positionHome = tugboat.transform.TransformPoint(pHome.Value.positionHome);
                }
                else positionHome = pHome.Value.positionHome;

                if (positionHome == default) continue;

                homeList.TryAdd(pHome.Key, positionHome);
            }

            return homeList;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning(LanguageEn ? $"Error reading #321562 configuration 'oxide/config/{Name}', creating a new configuration!!" : $"Ошибка чтения #3212 конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!!"); 
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }
        
        
        private Dictionary<String, List<ServerWarp>> serverWarps = new();
		   		 		  						  	   		   		 		  			 		  	   		  				
        
        
        private void AutoTeleportTurn(BasePlayer player)
        {
            if (!playerSettings.TryGetValue(player.userID, out SettingPlayer setting)) return;
            setting.autoAcceptTeleportationFriends = !setting.autoAcceptTeleportationFriends;

            String message = setting.autoAcceptTeleportationFriends
                ? GetLang("AUTO_ACCEPT_TELEPORTATION_FRIEND_TRUE", player.UserIDString)
                : GetLang("AUTO_ACCEPT_TELEPORTATION_FRIEND_FALSE", player.UserIDString);
            
            SendChat(message, player);
        }
        
        private MonumentInfo GetMonumentInName(String nameMonument)
        {
            if (String.IsNullOrWhiteSpace(nameMonument)) return null;
            foreach (MonumentInfo monument in localAllMonuments)
            {
                if (monument.name.Equals(nameMonument))
                    return monument;
            }

            return null;
        }
        
        private void OnEntityKill(Tugboat tugboat)
        {
            if (tugboat == null) return;
            UInt64 netIDTugBoat = tugboat.net.ID.Value;

            if (tugboatsServer.ContainsKey(netIDTugBoat))
                tugboatsServer.Remove(netIDTugBoat);
        }
        
                
                
                
        private void LogAction(BasePlayer player, TypeLog typeLog, BasePlayer targetPlayer = default, Vector3 position = default, String homeName = default)
        {
            if (!config.generalController.useLogged) return;

            String typeAction = typeLog switch
            {
                TypeLog.RequestTeleportation => $"{player.displayName}({player.userID}) {tprLog} {targetPlayer.displayName}({targetPlayer.userID})",
                TypeLog.AcceptTeleportation => $"{player.displayName}({player.userID}) {tpaLog} {targetPlayer.displayName}({targetPlayer.userID})",
                TypeLog.RequestHomeTeleportation => $"{player.displayName}({player.userID}) {homeLog} `{homeName}` ({position})",
                _ => ""
            };
            LogToFile("IQTeleportation", typeAction, _, true, true);
        }

        private IEnumerator ProcessTTarget(BasePlayer player, BasePlayer targetPlayer, Int32 timeTeleportation)
        {
            Vector3 teleportationPosition = config.teleportationController.teleportSetting.teleportPosInAccept ? targetPlayer.transform.position : default;
            return ProcessTeleportation(
                player,
                () =>
                {
                    if (!targetPlayer)
                    {
                        ClearQueue(player, targetPlayer);
                        
                        SendChat(GetLang("ACCESS_CANCELL_TELEPORTATION", player.UserIDString, $"{GetLang("ACCESS_CANCELL_TELEPORTATION_DEAD_TARGET_DISCONNECTED", player.UserIDString)}"), player);
                        return true;
                    }

                    if (!targetPlayer.IsDead()) return false;
                    ClearQueue(player, targetPlayer);
                    SendChat(GetLang("ACCESS_CANCELL_TELEPORTATION", targetPlayer.UserIDString, $"{GetLang("ACCESS_CANCELL_TELEPORTATION_DEAD", targetPlayer.UserIDString)}"), targetPlayer);
                    SendChat(GetLang("ACCESS_CANCELL_TELEPORTATION", player.UserIDString, $"{GetLang("ACCESS_CANCELL_TELEPORTATION_DEAD_TARGET", player.UserIDString)}"), player);
                    return true;
                },
                () => TeleportationPlayer(player, targetPlayer, teleportationPosition),
                timeTeleportation,
                targetPlayer
            );
        }
        private const Single radiusCheckLayerHome = 2f;


        private void DestroyPing(BasePlayer player)
        {
            if (!player) return;
            if (!playerPings.TryGetValue(player, out MapNote note)) return;
            if (note == null) return;
            
            player.State.pings.Remove(note);
            player.DirtyPlayerState();
            player.SendPingsToClient();
            player.TeamUpdate(true);

            playerPings?.Remove(player);
        }
        private static void AddUI(BasePlayer player, String json) => CommunityEntity.ServerInstance.ClientRPC<String>(RpcTarget.Player("AddUI", player.net.connection), json);
        
        private void CreateMapMarkerPlayer(BasePlayer player, Vector3 position, String homeName)
        {
            if (player.State?.pointsOfInterest == null)
                player.State.pointsOfInterest = new List<MapNote>();
            
            if (player.State.pointsOfInterest.Count >= ConVar.Server.maximumMapMarkers) return;
            
            MapNote note = Pool.Get<MapNote>();
            note.worldPosition = position;
            note.isPing = false;
            
            note.colourIndex = 2;
            note.icon = 2;
            note.noteType = 1;
            
            note.label = homeName;
            player.State.pointsOfInterest.Add(note);
            player.DirtyPlayerState();
            player.TeamUpdate();

            using MapNoteList mapNoteList = Pool.Get<MapNoteList>();
            mapNoteList.notes = Pool.Get<List<MapNote>>();
            
            if (player.ServerCurrentDeathNote != null)
                mapNoteList.notes.Add(player.ServerCurrentDeathNote);

            if (player.State.pointsOfInterest != null)
                mapNoteList.notes.AddRange(player.State.pointsOfInterest);
                
            player.ClientRPC(RpcTarget.Player("Client_ReceiveMarkers", player), mapNoteList);
            mapNoteList.notes.Clear();
                
            Pool.FreeUnmanaged(ref mapNoteList.notes);
        }
        /// <summary>
        /// - Корректировка очистки списка установленных спальников игроков, для оптимизации
        /// - Исправление к обновлению игры
        /// - Исправлена некорректный выбор времени полета к игроку с привилегией, бралось время привилегии того к кому телепортируется игрока, а не того кто телепортируется
        /// </summary>
        
                
        private Timer timerCheckHomes = null;
        private Dictionary<BasePlayer, UserRepository> localUsersRepository = new();

        private void Unload()
        {
            WriteData();
            
            InterfaceBuilder.DestroyAll();
            
            if (_imageUI != null)
            {
                _imageUI.UnloadImages();
                _imageUI = null;
            }
            
            if (cachedUI != null)
            {
                cachedUI.Clear();
                cachedUI = null;
            }

            if (timerCheckHomes != null || !timerCheckHomes.Destroyed)
            {
                timerCheckHomes.Destroy();
                timerCheckHomes = null;
            }

            if (bagInstalled != null && bagInstalled.Count != 0)
            {
                bagInstalled.Clear();
                bagInstalled = null;
            }

            if (config.homeController.addedPingMarker)
            {
                if (playerPings != null)
                {
                    if (playerPings.Count != 0)
                    {
                        foreach (BasePlayer basePlayer in BasePlayer.activePlayerList)
                        {
                            if (playerPings.ContainsKey(basePlayer))
                                DestroyPing(basePlayer);
                        }

                        playerPings.Clear();
                    }

                    playerPings = null;
                }
            }

            _ = null;
        }
        
        private UInt64[] GetFriendList(BasePlayer targetPlayer)
        {
            List<UInt64> friendList = Pool.Get<List<UInt64>>();
            if (Friends)
            {
                if (Friends.Call("GetFriends", targetPlayer.userID.Get()) is UInt64[] frinedList)
                    friendList.AddRange(frinedList);
            }
            
            if (Clans)
            {
                if (Clans.Call("GetClanMembers", targetPlayer.UserIDString) is UInt64[] ClanMembers)
                    friendList.AddRange(ClanMembers);
            }

            if(targetPlayer.Team != null)
                friendList.AddRange(targetPlayer.Team.members);
            
            UInt64[] friendsArray = friendList.ToArray();
            Pool.FreeUnmanaged(ref friendList);
            
            return friendsArray;
        }
        
        private void ReadData()
        {
            playerSettings = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<Dictionary<UInt64, SettingPlayer>>("IQSystem/IQTeleportation/PlayerSettings");
            playerHomes = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<Dictionary<UInt64, Dictionary<String, PlayerHome>>>("IQSystem/IQTeleportation/Homes");
            serverWarps = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<Dictionary<String, List<ServerWarp>>>("IQSystem/IQTeleportation/Warps");
        }

        private void WriteData()
        {
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQSystem/IQTeleportation/PlayerSettings", playerSettings);
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQSystem/IQTeleportation/Homes", playerHomes);
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQSystem/IQTeleportation/Warps", serverWarps);
        }
        
        [ConsoleCommand("atp")]
        private void AutoAcceptTeleportConsoleCmd(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            AutoTeleportTurn(player);
        }
        private class SettingPlayer
        {
            public Boolean useTeleportationHomeFromFriends;
            public Boolean autoAcceptTeleportationFriends;

            public Boolean useTeleportGMap;
            
            public DateTime firstConnection;
        }
        private const String effectSoundAccess = "assets/bundled/prefabs/fx/notice/item.select.fx.prefab";
        
        private void DrawUI_HomeSetup(BasePlayer player)
        {
            if (!config.homeController.suggetionSetHomeAfterInstallBed) return;
            if (_interface == null || player == null) return;
            
            player.Invoke(() =>
            {
                DestroyUI(player, InterfaceBuilder.IQ_TELEPORT_UI_HOME);
                
                if (bagInstalled.ContainsKey(player))
                    bagInstalled.Remove(player);
            }, 10f);
            
            String interfaceKey = InterfaceBuilder.IQ_TELEPORT_UI_HOME;
            List<String> cache = GetOrSetCacheUI(player, interfaceKey);
            if (cache != null && cache.Count != 0)
            {
                foreach (String uiCached in cache)
                    AddUI(player, uiCached);
                
                return;
            }
            
            String Interface = InterfaceBuilder.GetInterface(interfaceKey);
            if (Interface == null) return;
            
            Interface = Interface.Replace("%TITILE_PANEL%", GetLang("UI_SETUP_HOME_ALERT", player.UserIDString));
            Interface = Interface.Replace("%COMMAND_YES%", "ui_teleportation_command sethome"); 
            Interface = Interface.Replace("%COMMAND_NO%", "ui_teleportation_command cancell.sethome"); 

            List<String> newUI = GetOrSetCacheUI(player, interfaceKey, Interface);
            cache = newUI;
            
            foreach (String uiCached in cache)
                AddUI(player, uiCached);
        }
        
        private void ParseTugboats()
        {
            Int32 tugboatCount = 0;
            foreach (BaseNetworkable serverEntity in BaseNetworkable.serverEntities.entityList.Get().Values)
            {
                if (serverEntity is not Tugboat) continue;
                
                if(!tugboatsServer.ContainsKey(serverEntity.net.ID.Value))
                {
                    tugboatsServer.Add(serverEntity.net.ID.Value, serverEntity as Tugboat);
                    tugboatCount++;
                }
            }
            Puts(LanguageEn ? "" : $"Сохранено {tugboatCount} буксиров для установки точки дома игроков");
        }

        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<String, String>
            {
                ["UI_SETUP_HOME_ALERT"] = "DO YOU WANT TO SET A HOME POINT AT THIS LOCATION?",
                ["UI_TPR_REQUSET"] = "TELEPORTATION REQUEST FROM PLAYER {0}",

                ["SYNTAX_COMMAND_SETHOME"] = ":exclamation:To set a home point, use the syntax: <color=#1F6BA0>/sethome HomeName</color>",
                ["SYNTAX_COMMAND_REMOVEHOME"] = ":exclamation:To remove a home point, use the syntax: <color=#1F6BA0>/removehome HomeName</color>",
                ["SYNTAX_COMMAND_HOME_TELEPORTATION"] = ":exclamation:To teleport to a home point, use the syntax: <color=#1F6BA0>/home HomeName</color>",
                ["SYNTAX_COMMAND_TELEPORT_REQUEST"] = ":exclamation:To request teleportation to a player, use the syntax: <color=#1F6BA0>/tpr PlayerName</color>",
                ["SYNTAX_COMMAND_TELEPORT"] = ":exclamation:To teleport to a player, use the syntax: <color=#1F6BA0>/tp PlayerName</color>\nTo teleport one player to another, use: <color=#1F6BA0>/tp TargetPlayer TeleportPlayer</color>",

                ["SYNTAX_COMMAND_WARPS"] = ":exclamation:Use the syntax:" +
                                           "\n<color=#1F6BA0>/warp list</color> - to display all available warps" +
                                           "\n<color=#1F6BA0>/warp points WarpName</color> - to display all teleportation points for the specified warp" +
                                           "\n<color=#1F6BA0>/warp add WarpName</color> - to create a new warp or add an additional teleportation point to it" +
                                           "\n<color=#1F6BA0>/warp edit WarpName PointNumber</color> - to edit the teleportation point for the warp" +
                                           "\n<color=#1F6BA0>/warp remove WarpName</color> - to delete the warp and all its teleportation points" +
                                           "\n<color=#1F6BA0>/warp remove WarpName PointNumber</color> - to delete a specific teleportation point for the specified warp",

                ["HOMELIST_COMMAND_EMPTY"] = ":exclamation:You have no home points set",
                ["HOMELIST_COMMAND_ALL_LIST"] = ":yellowpin:Your set home points: {0}",
                ["HOMELIST_COMMAND_FORTMAT_HOME"] = "\n{0} in the quadrant [{1}]",

                ["MONUMENT_BLOCKED_SETUP_NOT_CENTER"] = ":yellowpin:Unable to determine the monument. Move closer to the center of the monument",
                ["MONUMENT_BLOCKED_SETU_BLOCKED"] = ":exclamation:This monument is already restricted for teleportation",
                ["MONUMENT_BLOCKED_SETUP_ACCES"] = ":exclamation:You have successfully restricted teleportation from this monument",

                ["COOLDOWN_MESSAGE"] = ":exclamation:You need to wait another <color=#C26D33>{0}</color> before performing this action",

                ["TITLE_FORMAT_DAYS"] = "D",
                ["TITLE_FORMAT_HOURSE"] = "H",
                ["TITLE_FORMAT_MINUTES"] = "M",
                ["TITLE_FORMAT_SECONDS"] = "S",

                ["WARP_NOTHING"] = ":exclamation:You have not created any warps yet",
                ["WARP_TELEPORTATION_PLAYER"] = ":yellowpin:You have been teleported to the warp",
                ["WARP_REQUEST_TELEPORTATION_PLAYER"] = ":yellowpin:You will be teleported to the warp in <color=#1F6BA0>{0} seconds</color>",
                ["WARP_NOTHING_NAME"] = ":exclamation:No warp with this name exists",
                ["WARP_NOT_ARG_NAME"] = ":exclamation:You need to specify the warp name",
                ["WARP_SHOW_POINTS"] = ":yellowpin:Points for teleportation to the warp <color=#738D45>{0}</color> will be displayed for <color=#1F6BA0>30 seconds</color>",
                ["WARP_SETUP_POINTS_DISTANCE"] = ":yellowpin:The new point is too close to point <color=#738D45>#{0}</color> of the specified warp. Move farther away and set the point there",
                ["WARP_SETUP_POINT_ACCESS"] = ":yellowpin:You have successfully added a new teleportation point to the warp named <color=#738D45>{0}</color>",
                ["WARP_SETUP_NEW"] = ":exclamation:The warp named <color=#738D45>{0}</color> has been successfully created. The command for teleportation to it is reserved: <color=#738D45>{1}</color>",
                ["WARP_EDIT_POINT_ACCESS"] = ":yellowpin:You have successfully edited the teleportation point for the warp named <color=#738D45>{0}</color>",
                ["WARP_NOTHING_KEY_POINTS"] = ":yellowpin:You need to specify the key (#) of the teleportation point to edit it\nAvailable keys: {0}",
                ["WARP_NOTHING_KEY_IS_NUMBER"] = ":yellowpin:The specified key (#) is not a number. You must specify only a number",
                ["WARP_REMOVED"] = ":exclamation:The warp has been successfully deleted.\nThe teleportation command: <color=#C26D33>{0}</color> - has been removed",
                ["WARP_REMOVED_POINT"] = ":yellowpin:The teleportation point <color=#C26D33>#{0}</color> has been deleted for the warp named <color=#1F6BA0>{1}</color>",
                ["WARP_REMOVED_POINT_NOTHING_KEYS"] = ":yellowpin:The point <color=#C26D33>#{0}</color> does not exist for the warp <color=#1F6BA0>{1}</color>\nAvailable keys: {2}",

                ["AUTO_ACCEPT_TELEPORTATION_FRIEND_TRUE"] = ":heart:You have <color=#738D45>enabled</color> auto-accept teleport requests from friends",
                ["AUTO_ACCEPT_TELEPORTATION_FRIEND_FALSE"] = ":heart:You have <color=#C26D33>disabled</color> auto-accept teleport requests from friends",
                
                ["GMAP_TELEPORT_TRUE"] = ":heart:You have <color=#738D45>enabled</color> teleportation via GMap",
                ["GMAP_TELEPORT_FALSE"] = ":heart:You have <color=#C26D33>disabled</color> teleportation via GMap",

                ["ACCESS_SETUP_SETHOME"] = ":yellowpin:You have successfully set a home point named <color=#738D45>{0}</color>",
                ["ACCESS_TELEPORTATION_HOME"] = ":yellowpin:You are teleporting to the home point named <color=#738D45>{0}</color>\nPlease wait: <color=#1F6BA0>{1}</color>",
                ["ACCESS_TELEPORTATION_HOME_FRIEND_NICK"] = ":yellowpin:You are teleporting to your friend's home point <color=#738D45>{0}</color> named <color=#738D45>{1}</color>\nPlease wait: <color=#1F6BA0>{2}</color>",
                ["ACCESS_TELEPORTATION_HOME_FRIEND"] = ":yellowpin:You are teleporting to your friend's home point named <color=#738D45>{0}</color>\nPlease wait: <color=#1F6BA0>{1}</color>",

                ["CAN_SETHOME_BUILDING"] = ":exclamation:You can only set a home point <color=#C26D33>on a building</color>",
                ["CAN_SETHOME_OTHER_ENTITY"] = ":exclamation:Another <color=#C26D33>object</color> is under or near this point, preventing you from setting a home point",
                ["CAN_SETHOME_BUILDING_OR_TERRAIN"] = ":exclamation:You cannot set a home point on <color=#C26D33>rocks or other objects</color>. Stand on a <color=#C26D33>building or ground surface</color>",
                ["CAN_SETHOME_BUILDING_PRIVILAGE"] = ":exclamation:To set a home point, you need to <color=#C26D33>place a tool cupboard</color> in the building",
                ["CAN_SETHOME_BUILDING_PRIVILAGE_AUTH"] = ":exclamation:To set a home point, you need to <color=#C26D33>authorize yourself in the tool cupboard</color>",
                ["CAN_SETHOME_BUILDING_PRIVILAGE_AUTH_TUGBOAT"] = ":exclamation:To set a home point, you need to <color=#C26D33>authorize yourself in the tugboat</color>",
                ["CAN_SETHOME_TUGBOAT_DISABLE"] = ":exclamation:You cannot set home points on tugboats; this <color=#C26D33>feature is disabled</color>",
                ["CAN_SETHOME_IS_RAIDBLOCK"] = ":exclamation:You cannot set a home point while an <color=#C26D33>active raid block</color> is in effect",
                ["CAN_SETHOME_OTHER_MESSAGE"] = ":exclamation:You cannot set a home point at the moment",
                ["CAN_SETHOME_EXIST_HOMENAME"] = ":exclamation:A home point named <color=#738D45>{0}</color> already exists",
                ["CAN_SETHOME_DISTANCE_EXIST_HOME"] = ":exclamation:You cannot set a home point because a point named <color=#738D45>{0}</color> is nearby",
                ["CAN_SETHOME_MAXIMUM_HOMES"] = ":exclamation:You cannot set a home point; you have reached the <color=#C26D33>maximum limit</color> of home points",

                ["A_HOME_CHECK_PLAYER_NOT_FOUND"] = ":exclamation:Player not found",
                ["A_HOME_CHECK_NOT_HOME"] = ":exclamation:The player has no available home points",
                ["A_HOME_CLEAR_HOMES"] = ":exclamation:All the player's home points have been deleted",
                ["A_HOME_SHOW_POINTS"] = ":yellowpin:The player's home points {0} are displayed for <color=#738D45>30 seconds</color>",

                ["CAN_REMOVE_HOME_NO_EXISTS"] = ":exclamation:You <color=#C26D33>do not have</color> a home point named <color=#738D45>{0}</color>",
                ["ACCESS_REMOVE_HOME"] = ":exclamation:You have <color=#C26D33>deleted</color> the home point named <color=#738D45>{0}</color>",

                ["ACCESS_CANCELL_TELEPORTATION_PLAYER"] = ":exclamation:You <color=#1F6BA0>canceled</color> the previous home teleportation request",
                ["ACCESS_CANCELL_TELEPORTATION"] = ":exclamation:The teleportation has been <color=#1F6BA0>canceled</color>",
                ["ACCESS_CANCELL_TELEPORTATION_DEAD"] = "\nYou have been killed",
                ["ACCESS_CANCELL_TELEPORTATION_DEAD_TARGET"] = "\nThe player you were teleporting to has been <color=#1F6BA0>killed</color>",
                ["ACCESS_CANCELL_TELEPORTATION_DEAD_TARGET_DISCONNECTED"] = "\nThe player you were teleporting to has <color=#1F6BA0>disconnected</color> from the server",
                ["ACCESS_CANCELL_TELEPORTATION_DEAD_REQUESTER_DISCONNECTED"] = "\nThe player teleporting to you has <color=#1F6BA0>disconnected</color> from the server",
                ["ACCESS_CANCELL_TELEPORTATION_DEAD_REQUESTER_DEAD"] = "\nThe player teleporting to you has been <color=#1F6BA0>killed</color>",

                ["CAN_CANCELL_TELEPORTATION_NOT_FOUNDS"] = ":exclamation:You have no active teleportations",

                ["REQUEST_TELEPORTATION_ACCESS"] = ":heart:Your teleportation request has been accepted - please wait <color=#1F6BA0>{0}</color>\n<color=#C26D33>To cancel the request, use /tpc</color>",

                ["CAN_ACCEPT_TELEPORTATION_NOT_AUTO_ACCEPT"] = ":heart:Your request has been <color=#1F6BA0>sent</color>, but your friend <color=#C26D33>cannot</color> accept it at the moment",
                ["CAN_ACCEPT_TELEPORTATION_YES_AUTO_ACCEPT"] = ":heart:Your request has been <color=#1F6BA0>automatically accepted</color> by your friend",

                ["CAN_ACCEPT_TELEPORTATION_NOT_REQUEST"] = ":exclamation:You have no <color=#1F6BA0>active teleportation requests</color>",
                ["CAN_ACCEPT_TELEPORTATION_ACTIVE_ACCEPTED"] = ":exclamation:You have already <color=#1F6BA0>accepted a teleportation request</color>. Wait for the player to teleport!\n<color=#C26D33>To cancel the request, use /tpc</color>",

                ["CAN_REQUEST_TELEPORTATION_DISABLED"] = ":heart:Player-to-player teleportation is disabled on the server",
                ["CAN_REQUEST_TELEPORTATION_NOT_FOUND_PLAYER"] = ":exclamation:The player is not currently on the server",
                ["CAN_REQUEST_TELEPORTATION_ACCESS"] = ":heart:You have <color=#738D45>accepted</color> a teleportation request from <color=#1F6BA0>{0}</color>\nTo <color=#C26D33>cancel the request</color>, use <color=#C26D33>/tpc</color>",
                ["CAN_REQUEST_TELEPORTATION_ACCESS_AUTO_TELEPORT"] = ":heart:You have <color=#1F6BA0>automatically</color> accepted a teleportation request from your friend <color=#1F6BA0>{0}</color>\nTo <color=#C26D33>cancel the request</color>, use <color=#C26D33>/tpc</color>\nTo <color=#C26D33>disable</color> automatic acceptance of teleportation requests from friends, type <color=#C26D33>/atp</color>",
                ["CAN_REQUEST_TELEPORTATION_SEND"] = ":heart:You have <color=#738D45>sent</color> a teleportation request to player <color=#1F6BA0>{0}</color>\nTo <color=#C26D33>cancel the request</color>, use <color=#C26D33>/tpc</color>",
                ["CAN_REQUEST_TELEPORTATION_RECEIVE"] = ":heart:Teleportation request from player <color=#1F6BA0>{0}</color>\nTo <color=#738D45>accept the request</color>, use <color=#738D45>/tpa</color>\nTo <color=#C26D33>cancel the request</color>, use <color=#C26D33>/tpc</color>",
                ["CAN_REQUEST_TELEPORTATION_TELEPORTED_REQUEST_ACTUALY"] = ":exclamation:You already have an <color=#C26D33>active teleportation request</color> with a player!\n<color=#C26D33>To cancel the request, use /tpc</color>",
                ["CAN_REQUEST_TELEPORTATION_TELEPORTED_REQUEST_ACTUALY_NAME"] = ":exclamation:You already have an <color=#C26D33>active teleportation request</color> with player <color=#1F6BA0>{0}</color>\nTo <color=#C26D33>cancel the request</color>, use <color=#C26D33>/tpc</color>",
                ["CAN_REQUEST_TELEPORTATION_NOTHING_TELEPORT_ME"] = ":exclamation:You cannot teleport to yourself",
                ["CAN_REQUEST_TELEPORTATION_ALREADY_REQUEST_TARGET"] = ":exclamation:The player you are sending the teleportation request to already has an <color=#C26D33>active request</color>. Wait for them to accept or cancel their request",
                ["CAN_REQUEST_TELEPORTATION_ONLY_REQUEST_FRIENDS"] = ":exclamation:You can only send requests <color=#C26D33>to friends</color>",

                ["FIND_PLAYER_INFO_MATCHES"] = ":exclamation:Your search with the nickname <color=#1F6BA0>'{0}'</color> found multiple players: <color=#1F6BA0>{1}</color>",
		   		 		  						  	   		   		 		  			 		  	   		  				
                ["CAN_TELEPORT_PLAYER_NOT_FOUND_TP_ONE_PLAYER"] = ":exclamation:The player <color=#C26D33>you want to teleport</color> was not found",
                ["CAN_TELEPORT_PLAYER_NOT_FOUND_TP_TARGET_PLAYER_ONE"] = ":exclamation:The player <color=#C26D33>you want to teleport</color> player <color=#C26D33>{0}</color> to was not found",
                ["CAN_TELEPORT_PLAYER_NOT_FOUND_TP_TARGET_PLAYER"] = ":exclamation:The player <color=#C26D33>you want to teleport to</color> was not found",
                ["CAN_TELEPORT_PLAYER_ACCES_TP"] = ":yellowpin:You have been teleported to player <color=#C26D33>{0}</color>",
                ["CAN_TELEPORT_PLAYER_NOT_SETTING_USE_FRIEND_HOME"] = ":exclamation:Your friend has <color=#C26D33>prohibited</color> teleportation to their home points",
                ["CAN_TELEPORT_NULL_REASON"] = ":exclamation:You cannot teleport at the moment",
                ["CAN_TELEPORT_RAID_BLOCK"] = ":exclamation:You cannot teleport during a <color=#C26D33>raid block</color>",
                ["CAN_TELEPORT_TITILE_OTHER"] = ":exclamation:You cannot teleport while: <color=#C26D33>{0}</color>",
                ["CAN_TELEPORT_IN_BUILDING_BLOCKED"] = "in another player's building zone",
                ["CAN_TELEPORT_IN_CARGO_SHIP"] = "on a cargo ship",
                ["CAN_TELEPORT_IN_HOT_AIR_BALLOON"] = "in a hot air balloon",
                ["CAN_TELEPORT_MONUMENT_BLOCKED"] = ":exclamation:Teleportation is prohibited from this monument!\n<color=#C26D33>Leave the monument or move farther away!</color>",
                ["CAN_TELEPORT_COOLDOWN"] = ":exclamation:You cannot teleport yet. Cooldown: <color=#C26D33>{0}</color>",
                ["CAN_TELEPORT_REQUEST_EXPIRED"] = ":exclamation:Your <color=#C26D33>teleportation request</color> has <color=#C26D33>expired</color> and was canceled",
                ["CAN_TELEPORT_ONLY_FRIEND"] = ":exclamation:You can only teleport to <color=#C26D33>friends</color>\nTeleportation was canceled",
                ["CAN_TELEPORT_ONLY_FRIEND_TARGET"] = ":exclamation:You can only teleport friends to yourself\nTeleportation was canceled",
                
                ["CAN_TELEPORT_HOME_FOUNDATION_DESTROYED"] = ":exclamation:The foundation where your home point was located has been destroyed. You cannot teleport",

                ["CAN_TELEPORT_HOME_TUGBOAT_DESTROYED"] = ":exclamation:The tugboat where your home point was located has been destroyed. You cannot teleport",
                ["CAN_TELEPORT_HOME_NOT_TUGBOAT"] = ":exclamation:The tugboat where the home point <color=#1F6BA0>{0}</color> was located has been <color=#C26D33>destroyed</color>",
                ["CAN_TELEPORT_HOME_NOT_HOME"] = ":exclamation:The home point named <color=#1F6BA0>{0}</color> does not exist",
                ["CAN_TELEPORT_HOME_NOT_BUILDING_BLOCK"] = ":exclamation:The home point named <color=#1F6BA0>{0}</color> is obstructed or the surface it was set on no longer exists\n<color=#C26D33>The home point has been deleted</color>",
                ["CAN_TELEPORT_HOME_NOT_AUTH_BUILDING_PRIVILAGE"] = ":exclamation:You are not authorized in the building where the home point <color=#1F6BA0>{0}</color> is located\nThe home point has been deleted",
                ["CAN_TELEPORT_HOME_NOT_FRIEND"] = ":exclamation:The player <color=#1F6BA0>{0}</color> is not your friend\nTo teleport to a friend's home, use: <color=#1F6BA0>/home HomeName FriendName</color>",
                ["CAN_TELEPORT_HOME_NOT_FOUND"] = ":exclamation:The player named <color=#1F6BA0>{0}</color> was not found!\nTo teleport to a friend's home, use: <color=#1F6BA0>/home HomeName FriendName</color>",

                ["STATUS_PLAYER_TITLE"] = ":exclamation:You cannot perform this action - <color=#C26D33>{0}</color>",
                ["STATUS_PLAYER_FLYING"] = "you are weightless",
                ["STATUS_PLAYER_WOUNDED"] = "you are wounded",
                ["STATUS_PLAYER_RADIATION"] = "you are irradiated",
                ["STATUS_PLAYER_MOUNTED"] = "you are sitting in a vehicle or on an object",
                ["STATUS_PLAYER_IS_TUTORIAL"] = "you are on a tutorial island",
                ["STATUS_PLAYER_IS_SWIMMING"] = "you are swimming",
                ["STATUS_PLAYER_IS_COLD"] = "you are cold",
                ["STATUS_PLAYER_IS_DEAD"] = "you are dead",
                ["STATUS_PLAYER_IS_SLEEPING"] = "you are sleeping",
            }, this);
            
            lang.RegisterMessages(new Dictionary<String, String>
            {
                ["UI_SETUP_HOME_ALERT"] = "ХОТИТЕ УСТАНОВИТЬ ТОЧКУ ДОМА НА ЭТОМ МЕСТЕ?",
                ["UI_TPR_REQUSET"] = "ЗАПРОС НА ТЕЛЕПОРТАЦИЮ ОТ ИГРОКА {0}",

                ["SYNTAX_COMMAND_SETHOME"] = ":exclamation:Для установки точки дома используйте синтаксис : <color=#1F6BA0>/sethome НазваниеДома</color>",
                ["SYNTAX_COMMAND_REMOVEHOME"] = ":exclamation:Для удаления точки дома используйте синтаксис : <color=#1F6BA0>/removehome НазваниеДома</color>",
                ["SYNTAX_COMMAND_HOME_TELEPORTATION"] = ":exclamation:Для телепортации на точку дома используйте синтаксис : <color=#1F6BA0>/home НазваниеДома</color>",
                ["SYNTAX_COMMAND_TELEPORT_REQUEST"] = ":exclamation:Для телепортации к игроку используйте синтаксис : <color=#1F6BA0>/tpr ИмяИгрока</color>",
                ["SYNTAX_COMMAND_TELEPORT"] = ":exclamation:Для телепортации к игроку используйте синтаксис : <color=#1F6BA0>/tp ИмяИгрока</color>\nЧтобы телепортировать одного игрока к другому, используйте : <color=#1F6BA0>/tp ККомуТелепортировать КогоТелепортировать</color>",

                ["SYNTAX_COMMAND_WARPS"] = ":exclamation:Используйте синтаксис :" +
                                           "\n<color=#1F6BA0>/warp list</color> - для отображения всех доступных варпов" +
                                           "\n<color=#1F6BA0>/warp points НазваниеВарпа</color> - для отображения всех точек телепортации на данный варп" +
                                           "\n<color=#1F6BA0>/warp add НазваниеВарпа</color> - для создания нового варпа или установки дополнительной точки телепортации на этот варп" +
                                           "\n<color=#1F6BA0>/warp edit НазваниеВарпа НомерПозиции</color> - для редактирования позиции телепортации на варп" +
                                           "\n<color=#1F6BA0>/warp remove НазваниеВарпа</color> - для удаления варпа и всех доступных точек телепортации" +
                                           "\n<color=#1F6BA0>/warp remove НазваниеВарпа НомерПозиции</color> - для удаления позиции телепортации на указанный варп",
		   		 		  						  	   		   		 		  			 		  	   		  				
                ["HOMELIST_COMMAND_EMPTY"] = ":exclamation:У вас нет установленных точек дома",
                ["HOMELIST_COMMAND_ALL_LIST"] = ":yellowpin:Ваши установленные точки дома : {0}",
                ["HOMELIST_COMMAND_FORTMAT_HOME"] = "\n{0} в квадарте [{1}]",
                
                ["MONUMENT_BLOCKED_SETUP_NOT_CENTER"] = ":yellowpin:Невозможно определить монумент, встаньте ближе к центру данного монумента",
                ["MONUMENT_BLOCKED_SETU_BLOCKED"] = ":exclamation:Данный монумент уже запрещен для телепортации",
                ["MONUMENT_BLOCKED_SETUP_ACCES"] = ":exclamation:Вы успешно запретили телепортацию с данного монумента",
                
                ["COOLDOWN_MESSAGE"] = ":exclamation:Вам нужно подождать еще <color=#C26D33>{0}</color> перед выполнением этого действия",

                ["TITLE_FORMAT_DAYS"] = "Д",
                ["TITLE_FORMAT_HOURSE"] = "Ч",
                ["TITLE_FORMAT_MINUTES"] = "М",
                ["TITLE_FORMAT_SECONDS"] = "С",
                
                ["WARP_NOTHING"] = ":exclamation:Вы еще не создали варпов",
                ["WARP_TELEPORTATION_PLAYER"] = ":yellowpin:Вы были телепортированы на варп",
                ["WARP_REQUEST_TELEPORTATION_PLAYER"] = ":yellowpinВы будете телепортированы на варп в течении <color=#1F6BA0>{0} секунд</color>",
                ["WARP_NOTHING_NAME"] = ":exclamation:Варпа с таким названием не существует",
                ["WARP_NOT_ARG_NAME"] = ":exclamation:Вам необходимо указать название варпа",
                ["WARP_SHOW_POINTS"] = ":yellowpin:Точки с позициями для телепортации на варп <color=#738D45>{0}</color> будут отображены на <color=#1F6BA0>30 секунд</color>",
                ["WARP_SETUP_POINTS_DISTANCE"] = ":yellowpin:Новая точка находится слишком близко к точке <color=#738D45>№{0}</color> указанного варпа, попробуйте отойти подальше и установить точку там",
                ["WARP_SETUP_POINT_ACCESS"] = ":yellowpin:Вы успешно добавили новую позицию для варпа с названием <color=#738D45>{0}</color>",
                ["WARP_SETUP_NEW"] = ":exclamation:Варп с названием <color=#738D45>{0}</color> успешно создан, зарезервирована команда для телепортации на него : <color=#738D45>{1}</color>",
                ["WARP_EDIT_POINT_ACCESS"] = ":yellowpin:Вы успешно изменили позицию для варпа с названием <color=#738D45>{0}</color>",
                ["WARP_NOTHING_KEY_POINTS"] = ":yellowpin:Вам нужно указать ключ(№) точки с позицией для ее редактирования\nДоступные ключи : {0}",
                ["WARP_NOTHING_KEY_IS_NUMBER"] = ":yellowpin:Указанный ключ(№) позиции - не является цифрой, вы должны указать только цифру",
                ["WARP_REMOVED"] = ":exclamation:Варп успешно удален.\nКоманда для телепортации : <color=#C26D33>{0}</color> - удалена",
                ["WARP_REMOVED_POINT"] = ":yellowpin:Точка телепортации <color=#C26D33>№{0}</color> удалена для варпа с названием <color=#1F6BA0>{1}</color>",
                ["WARP_REMOVED_POINT_NOTHING_KEYS"] = ":yellowpin:Точка <color=#C26D33>№{0}</color> не существует для варпа <color=#1F6BA0>{1}</color>\nДоступные ключи : {2}",

                ["AUTO_ACCEPT_TELEPORTATION_FRIEND_TRUE"] = ":heart:Вы <color=#738D45>включили</color> автоматическое принятие телепортов от друзей",
                ["AUTO_ACCEPT_TELEPORTATION_FRIEND_FALSE"] = ":heart:Вы <color=#C26D33>отключили</color> автоматическое принятие телепортов от друзей",
                
                ["GMAP_TELEPORT_TRUE"] = ":heart:Вы <color=#738D45>включили</color> возможность телепортации по GMap",
                ["GMAP_TELEPORT_FALSE"] = ":heart:Вы <color=#C26D33>отключили</color> возможность телепортации по GMap",
                
                ["ACCESS_SETUP_SETHOME"] = ":yellowpin:Вы успешно установили точку дома с названием <color=#738D45>{0}</color>",
                ["ACCESS_TELEPORTATION_HOME"] = ":yellowpin:Вы телепортируетесь в точку дома с названием <color=#738D45>{0}</color>\nПожалуйста, подождите : <color=#1F6BA0>{1}</color>",
                ["ACCESS_TELEPORTATION_HOME_FRIEND_NICK"] = ":yellowpin:Вы телепортируетесь в точку дома друга <color=#738D45>{0}</color> с названием <color=#738D45>{1}</color>\nПожалуйста, подождите : <color=#1F6BA0>{2}</color>",
                ["ACCESS_TELEPORTATION_HOME_FRIEND"] = ":yellowpin:Вы телепортируетесь в точку дома друга с названием <color=#738D45>{0}</color>\nПожалуйста, подождите : <color=#1F6BA0>{1}</color>",
                
                ["CAN_SETHOME_BUILDING"] = ":exclamation:Вы можете установить точку для дома <color=#C26D33>только на строении</color>",
                ["CAN_SETHOME_OTHER_ENTITY"] = ":exclamation:Под точкой или рядом находится <color=#C26D33>другой объект</color>, который <color=#C26D33>мешает</color> установить точку для дома",
                ["CAN_SETHOME_BUILDING_OR_TERRAIN"] = ":exclamation:Вы не можете установить точку дома на <color=#C26D33>скалах или иных объектах</color>, встаньте на <color=#C26D33>строение или на поверхность земли</color>",
                ["CAN_SETHOME_BUILDING_PRIVILAGE"] = ":exclamation:Чтобы установить точку для дома - необходимо <color=#C26D33>установить шкаф</color> в строении",
                ["CAN_SETHOME_BUILDING_PRIVILAGE_AUTH"] = ":exclamation:Чтобы установить точку для дома - необходимо <color=#C26D33>авторизоваться в шкафу</color>",
                ["CAN_SETHOME_BUILDING_PRIVILAGE_AUTH_TUGBOAT"] = ":exclamation:Чтобы установить точку для дома - необходимо <color=#C26D33>авторизоваться в буксире</color>",
                ["CAN_SETHOME_TUGBOAT_DISABLE"] = ":exclamation:Вы не можете устанавливать точку дома на буксирах, эта <color=#C26D33>функция отключена</color>",
                ["CAN_SETHOME_IS_RAIDBLOCK"] = ":exclamation:Чтобы установить точку для дома - у вас не должно быть <color=#C26D33>активного рейдблока</color>",
                ["CAN_SETHOME_OTHER_MESSAGE"] = ":exclamation:Вы не можете сейчас установить точку для дома",
                ["CAN_SETHOME_EXIST_HOMENAME"] = ":exclamation:Точка для дома с названием <color=#738D45>{0}</color> уже существует",
                ["CAN_SETHOME_DISTANCE_EXIST_HOME"] = ":exclamation:Вы не можете установить точку для дома, рядом установлена точка <color=#738D45>{0}</color>",
                ["CAN_SETHOME_MAXIMUM_HOMES"] = ":exclamation:Вы не можете установить точку дома, достигнут <color=#C26D33>максимальный лимит</color> количества установленных точек для дома",
                
                ["A_HOME_CHECK_PLAYER_NOT_FOUND"] = ":exclamation:Игрок не найден",
                ["A_HOME_CHECK_NOT_HOME"] = ":exclamation:У игрока нет доступных точек дома",
                ["A_HOME_CLEAR_HOMES"] = ":exclamation:Все точки дома игрока были удалены",
                ["A_HOME_SHOW_POINTS"] = ":yellowpin:Точки дома игрока {0} отображаются на <color=#738D45>30 секунд</color>",
                
                ["CAN_REMOVE_HOME_NO_EXISTS"] = ":exclamation:У вас <color=#C26D33>не существует</color> точки дома с названием <color=#738D45>{0}</color>",
                ["ACCESS_REMOVE_HOME"] = ":exclamation:Вы <color=#C26D33>удалили</color> точку дома с названием <color=#738D45>{0}</color>",
                
                ["ACCESS_CANCELL_TELEPORTATION_PLAYER"] = ":exclamation:Вы <color=#1F6BA0>отменили</color> старый запрос на телепортацию домой",
                ["ACCESS_CANCELL_TELEPORTATION"] = ":exclamation:Телепортация была <color=#1F6BA0>отменена</color>",
                ["ACCESS_CANCELL_TELEPORTATION_DEAD"] = "\nВы были убиты",
                ["ACCESS_CANCELL_TELEPORTATION_DEAD_TARGET"] = "\nИгрок к которому вы телепортировались был <color=#1F6BA0>убит</color>",
                ["ACCESS_CANCELL_TELEPORTATION_DEAD_TARGET_DISCONNECTED"] = "\nИгрок к которому вы телепортировались <color=#1F6BA0>вышел</color> с сервера",
                ["ACCESS_CANCELL_TELEPORTATION_DEAD_REQUESTER_DISCONNECTED"] = "\nИгрок который к вам телепортировался <color=#1F6BA0>вышел</color> с сервера",
                ["ACCESS_CANCELL_TELEPORTATION_DEAD_REQUESTER_DEAD"] = "\nИгрок который к вам телепортировался был <color=#1F6BA0>убит</color>",

                ["CAN_CANCELL_TELEPORTATION_NOT_FOUNDS"] = ":exclamation:У вас нет активных телепортаций",
                
                ["REQUEST_TELEPORTATION_ACCESS"] = ":heart:Ваш запрос на телепортацию принят - ожидайте <color=#1F6BA0>{0}</color>\n<color=#C26D33>Чтобы отменить запрос - используйте /tpc</color>",

                ["CAN_ACCEPT_TELEPORTATION_NOT_AUTO_ACCEPT"] = ":heart:Ваш запрос <color=#1F6BA0>отправлен</color>, но ваш друг <color=#C26D33>не может</color> принять его в данный момент", 
                ["CAN_ACCEPT_TELEPORTATION_YES_AUTO_ACCEPT"] = ":heart:Ваш запрос <color=#1F6BA0>автоматически принят</color> вашим другом", 
                
                ["CAN_ACCEPT_TELEPORTATION_NOT_REQUEST"] = ":exclamation:У вас нет <color=#1F6BA0>активных запросов</color> на телепортацию", 
                ["CAN_ACCEPT_TELEPORTATION_ACTIVE_ACCEPTED"] = ":exclamation:Вы уже <color=#1F6BA0>приняли запрос</color> на телепортацию, ожидайте телепортацию игрока!\n<color=#C26D33>Чтобы отменить запрос - используйте /tpc</color>", 

                ["CAN_REQUEST_TELEPORTATION_DISABLED"] = ":heart:На сервере отключена функция телепортации к игрокам", 
                ["CAN_REQUEST_TELEPORTATION_NOT_FOUND_PLAYER"] = ":exclamation:Такого игрока нет сейчас на сервере", 
                ["CAN_REQUEST_TELEPORTATION_ACCESS"] = ":heart:Вы <color=#738D45>приняли</color> запрос на телепортацию от <color=#1F6BA0>{0}</color>\nЧтобы <color=#C26D33>отменить запрос</color> - используйте <color=#C26D33>/tpc</color>",
                ["CAN_REQUEST_TELEPORTATION_ACCESS_AUTO_TELEPORT"] = ":heart:Вы <color=#1F6BA0>автоматически</color> приняли запрос на телепортацию от вашего друга <color=#1F6BA0>{0}</color>\nЧтобы <color=#C26D33>отменить запрос</color> - используйте <color=#C26D33>/tpc</color>\nЧтобы <color=#C26D33>отключить</color> автоматическое принятие запросов на телепортацию от друзей - пропишите <color=#C26D33>/atp</color>",
                ["CAN_REQUEST_TELEPORTATION_SEND"] = ":heart:Вы <color=#738D45>отправили</color> запрос на телепортацию к игроку <color=#1F6BA0>{0}</color>\nЧтобы <color=#C26D33>отменить запрос</color> - используйте <color=#C26D33>/tpc</color>",
                ["CAN_REQUEST_TELEPORTATION_RECEIVE"] = ":heart:Запрос на телепортацию от игрока <color=#1F6BA0>{0}</color>\nЧтобы <color=#738D45>принять запрос</color> - используйте <color=#738D45>/tpa</color>\nЧтобы <color=#C26D33>отменить запрос</color> - используйте <color=#C26D33>/tpc</color>",
                ["CAN_REQUEST_TELEPORTATION_TELEPORTED_REQUEST_ACTUALY"] = ":exclamation:У вас уже есть <color=#C26D33>активный запрос</color> на телепортацию с игроком!\n<color=#C26D33>Чтобы отменить запрос - используйте /tpc</color>",
                ["CAN_REQUEST_TELEPORTATION_TELEPORTED_REQUEST_ACTUALY_NAME"] = ":exclamation:У вас уже есть <color=#C26D33>активный запрос</color> на телепортацию с игроком <color=#1F6BA0>{0}</color>\nЧтобы <color=#C26D33>отменить запрос</color> - используйте <color=#C26D33>/tpc</color>",
                ["CAN_REQUEST_TELEPORTATION_NOTHING_TELEPORT_ME"] = ":exclamation:Вы не можете телепортироваться сами к себе",
                ["CAN_REQUEST_TELEPORTATION_ALREADY_REQUEST_TARGET"] = ":exclamation:У игрока к которому вы отправляете запрос на телепортацию, уже имеется <color=#C26D33>активный запрос</color>\nДождитесь когда он примет или отменит свой запрос",
                ["CAN_REQUEST_TELEPORTATION_ONLY_REQUEST_FRIENDS"] = ":exclamation:Вы можете отправлять запрос <color=#C26D33>только к друзьям</color>",
                
                ["FIND_PLAYER_INFO_MATCHES"] = ":exclamation:По вашему поиску с ником <color=#1F6BA0>'{0}'</color>, было найдено несколько игроков : <color=#1F6BA0>{1}</color>",
                
                ["CAN_TELEPORT_PLAYER_NOT_FOUND_TP_ONE_PLAYER"] = ":exclamation:Игрок <color=#C26D33>которого</color> вы собираетесь телепортировать не найден",
                ["CAN_TELEPORT_PLAYER_NOT_FOUND_TP_TARGET_PLAYER_ONE"] = ":exclamation:Игрок <color=#C26D33>к которому</color> вы собираетесь телепортировать игрока <color=#C26D33>{0}</color> - не найден",
                ["CAN_TELEPORT_PLAYER_NOT_FOUND_TP_TARGET_PLAYER"] = ":exclamation:Игрок <color=#C26D33>к которому</color> вы собираетесь телепортироваться не найден",
                ["CAN_TELEPORT_PLAYER_ACCES_TP"] = ":yellowpin:Вы были телепортированы к игроку <color=#C26D33>{0}</color>",
                ["CAN_TELEPORT_PLAYER_NOT_SETTING_USE_FRIEND_HOME"] = ":exclamation:Друг <color=#C26D33>запретил</color> телепортацию на свои точки дома",
                ["CAN_TELEPORT_NULL_REASON"] = ":exclamation:Вы не можете выполнить телепортацию сейчас",
                ["CAN_TELEPORT_RAID_BLOCK"] = ":exclamation:Вы не можете выполнить телепортацию во время <color=#C26D33>рейдблока</color>",
                ["CAN_TELEPORT_TITILE_OTHER"] = ":exclamation:Вы не можете выполнить телепортацию находясь : <color=#C26D33>{0}</color>", 
                ["CAN_TELEPORT_IN_BUILDING_BLOCKED"] = "в чужой билдинг зоне",
                ["CAN_TELEPORT_IN_CARGO_SHIP"] = "на корабле",
                ["CAN_TELEPORT_IN_HOT_AIR_BALLOON"] = "на воздушном шаре",
                ["CAN_TELEPORT_MONUMENT_BLOCKED"] = ":exclamation:С данного монумента запрещено телепортироваться!\n<color=#C26D33>Покиньте монумент или отойдите от него подальше!</color>",
                ["CAN_TELEPORT_COOLDOWN"] = ":exclamation:Вы не можете выполнить данную телепортацию, перезарядка : <color=#C26D33>{0}</color>",
                ["CAN_TELEPORT_REQUEST_EXPIRED"] = ":exclamation:Ваш <color=#C26D33>запрос</color> на телепортацию <color=#C26D33>истек</color>, он был отменен",
                ["CAN_TELEPORT_ONLY_FRIEND"] = ":exclamation:Вы можете телепортироваться только к <color=#C26D33>друзья</color>\nТелепортация была отменена",
                ["CAN_TELEPORT_ONLY_FRIEND_TARGET"] = ":exclamation:Вы можете телепортировать к себе только <color=#C26D33>друзей</color>\nТелепортация была отменена",

                ["CAN_TELEPORT_HOME_FOUNDATION_DESTROYED"] = ":exclamation:Фундамент на котором расположена точка дома был уничтожен, вы не можете телепортироваться",
                ["CAN_TELEPORT_HOME_TUGBOAT_DESTROYED"] = ":exclamation:Буксир на котором расположена точка дома был уничтожен, вы не можете телепортироваться",
                ["CAN_TELEPORT_HOME_NOT_TUGBOAT"] = ":exclamation:Буксир на котором расположена точка дома <color=#1F6BA0>{0}</color> был <color=#C26D33>уничтожен</color>",
                ["CAN_TELEPORT_HOME_NOT_HOME"] = ":exclamation:Точки дома с названием <color=#1F6BA0>{0}</color> - не существует",
                ["CAN_TELEPORT_HOME_NOT_BUILDING_BLOCK"] = ":exclamation:Точка дома с названием <color=#1F6BA0>{0}</color> застроена или у нее отсутсвует поверхность на которой она была установлена\n<color=#C26D33>Точка дома была удалена</color>",
                ["CAN_TELEPORT_HOME_NOT_AUTH_BUILDING_PRIVILAGE"] = ":exclamation:Вы не авторизованы в строении где установлена точка дома с названием <color=#1F6BA0>{0}</color>\nТочка дома была удалена",
                ["CAN_TELEPORT_HOME_NOT_FRIEND"] = ":exclamation:Игрок <color=#1F6BA0>{0}</color> не является вашим другом\nЧтобы телепортироваться на дом друга, используйте : <color=#1F6BA0>/home НазваниеДома ИмяДруга</color>",
                ["CAN_TELEPORT_HOME_NOT_FOUND"] = ":exclamation:Игрок с именем <color=#1F6BA0>{0}</color> не найден!\nЧтобы телепортироваться на дом друга, используйте : <color=#1F6BA0>/home НазваниеДома ИмяДруга</color>",

                ["STATUS_PLAYER_TITLE"] = ":exclamation:Вы не можете выполнить это действие - <color=#C26D33>{0}</color>",
                ["STATUS_PLAYER_FLYING"] = "вы в невесомости",
                ["STATUS_PLAYER_WOUNDED"] = "вы ранены",
                ["STATUS_PLAYER_RADIATION"] = "вы облучены радиацией",
                ["STATUS_PLAYER_MOUNTED"] = "вы сидите в транспорте или на объекте",
                ["STATUS_PLAYER_IS_TUTORIAL"] = "вы на обучающем острове",
                ["STATUS_PLAYER_IS_SWIMMING"] = "вы плаваете",
                ["STATUS_PLAYER_IS_COLD"] = "вам холодно",
                ["STATUS_PLAYER_IS_DEAD"] = "вы мертвы",
                ["STATUS_PLAYER_IS_SLEEPING"] = "вы спите",
            }, this, "ru");
        }
        
        private Boolean IsValidPosOtherEntity(in Vector3 position, BuildingBlock buildingBlock) 
        {
            Vector3 rayOrigin = position + Vector3.up; 
            Vector3 rayDirection = Vector3.down;
            
            RaycastHit[] hits = new RaycastHit[3]; 
            Int32 numHits = Physics.SphereCastNonAlloc(rayOrigin, 0.3f, rayDirection, hits, radiusCheckLayerHome, homelayerMaskEntity);

            for (Int32 i = 0; i < numHits; i++)
            {
                BaseEntity entity = hits[i].GetEntity();
		   		 		  						  	   		   		 		  			 		  	   		  				
                if (entity && buildingBlock && entity != buildingBlock && !exceptionsBuildingBlockEntities.Contains(entity.ShortPrefabName)) 
                    return false;
            }
                
            return true;
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewConfiguration();

        [ConsoleCommand("tpa")]
        private void TpaConsoleCMD(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            
            AcceptRequestTeleportation(player);
        }
        
        
        
        [ChatCommand("homelist")]
        private void ChatCommand_HomeList(BasePlayer player)
        {
            Dictionary<String, Vector3> homeList = GetHomes(player.userID);
            if (homeList == null || homeList.Count == 0)
            {
                SendChat(GetLang("HOMELIST_COMMAND_EMPTY", player.UserIDString), player);
                return;
            }
            
            String homesPlayerOnCord = String.Empty;

            foreach (KeyValuePair<String, Vector3> homeInfo in homeList)
            {
                String cordMap = MapHelper.PositionToString(homeInfo.Value);
                homesPlayerOnCord += GetLang("HOMELIST_COMMAND_FORTMAT_HOME", player.UserIDString, homeInfo.Key, cordMap);
            }
            
            SendChat(GetLang("HOMELIST_COMMAND_ALL_LIST", player.UserIDString, homesPlayerOnCord), player);
        }
        
        private Dictionary<BasePlayer, SleepingBag> bagInstalled = new();
        
        
        
        
        [ChatCommand("mblock")]
        private void MBlockChatCMD(BasePlayer player)
        {
            if (!player.IsAdmin) return;
            
            if(localAllMonuments.Count == 0)
                ParseMonuments();

            MonumentInfo playerMonument = GetMonumentWherePlayerStand(player);
            if (playerMonument == null)
            {
                SendChat(GetLang("MONUMENT_BLOCKED_SETUP_NOT_CENTER", player.UserIDString), player, true); 
                return;
            }
            
            if (config.generalController.monumentBlockedTeleportation.Contains(playerMonument.name))
            {
                SendChat(GetLang("MONUMENT_BLOCKED_SETU_BLOCKED", player.UserIDString) , player, true); 
                return;
            }
		   		 		  						  	   		   		 		  			 		  	   		  				
            config.generalController.monumentBlockedTeleportation.Add(playerMonument.name);
            SendChat(GetLang("MONUMENT_BLOCKED_SETUP_ACCES", player.UserIDString), player);
            SaveConfig();
        }
        
        private void OnNewSave(String filename) => AutoClearData(true);
        
        [ChatCommand("removehome")]
        private void RemoveHomeChatCMD(BasePlayer player, String cmd, String[] arg)
        {
            if (arg.Length == 0)
            {
                SendChat(GetLang("SYNTAX_COMMAND_REMOVEHOME", player.UserIDString), player, true);
                return;
            }

            String homeName = arg[0];
            RemoveHome(player, homeName);
        }

        private IEnumerator ProcessTHome(BasePlayer player, PlayerHome pHome, Int32 timeTeleportation)
        {
            Vector3 position = pHome.positionHome;
            BaseEntity parentEntity = null;
            return ProcessTeleportation(
                player,
                () =>
                {
                    if (pHome.netIdEntity == 0)
                    {
                        BuildingBlock buildingBlock = GetBuildingBlock(position);
                        if (!buildingBlock)
                        {
                            SendChat(GetLang("CAN_TELEPORT_HOME_FOUNDATION_DESTROYED", player.UserIDString), player, true);
                            return true;
                        }

                        return false;
                    }

                    if (!tugboatsServer.TryGetValue(pHome.netIdEntity, out Tugboat tugboat) || !tugboat || tugboat.IsDestroyed)
                    {
                        SendChat(GetLang("CAN_TELEPORT_HOME_TUGBOAT_DESTROYED", player.UserIDString), player, true);
                        return true;
                    }

                    parentEntity = tugboat;
                    return false;
                }, 
                () => TeleportationHome(player, position, parentEntity),
                timeTeleportation
            );
        }
        private void RequestWarp(BasePlayer player, in Vector3 warpPosition)
        {
            if (!config.warpsContoller.useWarps)
                return;
            
            String requestError = CanTeleportation(player, UserRepository.TeleportType.Warp);
            if (!String.IsNullOrWhiteSpace(requestError))
            {
                SendChat(requestError, player, true);
                return;
            }

            Int32 timeTeleportation = config.warpsContoller.teleportWarpCountdown.GetCount(player);
            Coroutine routineTeleportation = ServerMgr.Instance.StartCoroutine(ProcessTWarp(player, warpPosition, timeTeleportation));
            localUsersRepository[player].ActiveCoroutineController(routineTeleportation);
            
            SendChat(GetLang("WARP_REQUEST_TELEPORTATION_PLAYER", player.UserIDString, timeTeleportation), player);
        }
        private Dictionary<UInt64, AutoTurret> turretsEx = new();
		   		 		  						  	   		   		 		  			 		  	   		  				
        private void OnEntityBuilt(Planner plan, GameObject go)
        {
            if (plan == null || go == null) return;
            BaseEntity entity = go.ToBaseEntity();
            if (entity == null) return;
            SleepingBag bag = entity as SleepingBag;
            if (bag == null) return;
            BasePlayer player = plan.GetOwnerPlayer();
            if (player == null) return;
            
            Dictionary<String, PlayerHome> pData = playerHomes[player.userID];
            if (pData.Count >= config.homeController.homeCount.GetCount(player, true)) return;

            bagInstalled[player] = bag;
            
            DrawUI_HomeSetup(player);
        }
        
        
        
        [ChatCommand("rh")]
        private void RemoveHomeShortChatCMD(BasePlayer player, String cmd, String[] arg) => RemoveHomeChatCMD(player, cmd, arg);
        
        
        
        public Boolean IsRaidBlocked(BasePlayer player)
        {
            Object isRB = Interface.Call("IsRaidBlocked", player);
            Boolean isRaidBlocked = isRB as Boolean? ?? false;
            
            return isRaidBlocked;
        }
        
        private void CreatePingPlayer(BasePlayer player, Vector3 position)
        {
            if (player == null || player.State == null)
                return;

            player.State.pings ??= new List<MapNote>();
            
            DestroyPing(player);
            
            MapNote note = Pool.Get<MapNote>();
            if (note == null)
                return;
               
            note.worldPosition = position;
            note.isPing = true;
            note.timeRemaining = note.totalDuration = 30f;
            note.colourIndex = 2;
            note.icon = 2;
            player.State.pings.Add(note);
            player.DirtyPlayerState();
            player.TeamUpdate(false);

            using MapNoteList mapNoteList = Pool.Get<MapNoteList>();
            mapNoteList.notes = Pool.Get<List<MapNote>>();
            if (mapNoteList?.notes == null)
                return;

            mapNoteList.notes.AddRange(player.State.pings);
            player.ClientRPC(RpcTarget.Player("Client_ReceivePings", player), mapNoteList); 
            mapNoteList.notes.Clear();
            
            playerPings.TryAdd(player, note);

            Pool.FreeUnmanaged(ref mapNoteList.notes);
            
            player.Invoke(() => DestroyPing(player), note.timeRemaining);
        }

        [ConsoleCommand("tpc")]
        private void CancellTeleportCmdConsole(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            CancellTeleportation(player);
        }
        private class PlayerHome
        {
            public Vector3 positionHome;
            public UInt64 netIdEntity;
        }

        private void MovePlayer(BasePlayer player, Vector3 position, BaseEntity parentEntity = null, BaseEntity parentHomePosition = null)
        {
            Vector3 resultPosition = parentHomePosition ? parentHomePosition.transform.TransformPoint(position) : position;
            resultPosition.y += 0.3f;
        
            Interface.Call("OnPlayerTeleported", player, player.transform.position, resultPosition);
        
            player.PauseFlyHackDetection();
            player.PauseSpeedHackDetection();
            player.EnsureDismounted();
            player.Server_CancelGesture();
            player.StartSleeping();
        
            player.ClientRPC(RpcTarget.Player("StartLoading_Quick", player), true);
        
            player.SetParent(null, true);
        
            if (parentEntity)
                player.SetParent(parentEntity, true);
        
            player.Teleport(resultPosition);
        
            player.ForceUpdateTriggers();
            player.ClientRPC(RpcTarget.Player("ForceViewAnglesTo", player), resultPosition);
        
            player.UpdateNetworkGroup();
            player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, true);
            player.SendNetworkUpdateImmediate();
        
            if (config.generalController.stopSleepingAfterTeleport)
                player.Invoke(player.EndSleeping, 0.5f);
        
            RunEffect(player, effectSoundTeleport);
        }
        
        
        private void ClearHomesPlayer(UInt64 userID, String pluginName)
        {
            if (!playerHomes.ContainsKey(userID)) return;
            playerHomes[userID].Clear();

            Puts(LanguageEn ? "" : $"{pluginName} : Все точки дома игрока {userID} были очищены");
        }
        
        
        
        private void RemoveHome(BasePlayer player, String homeName)
        {
            homeName = homeName.ToLower();
            Dictionary<String, PlayerHome> pData = playerHomes[player.userID];
            if (!pData.TryGetValue(homeName, out PlayerHome home))
            {
                SendChat(GetLang("CAN_REMOVE_HOME_NO_EXISTS", player.UserIDString, homeName), player, true);
                return;
            }
            
            Interface.Call("OnHomeRemoved", player, home.positionHome, homeName);
            
            pData.Remove(homeName);
            SendChat(GetLang("ACCESS_REMOVE_HOME", player.UserIDString, homeName), player);
        }

        private const Boolean LanguageEn = false;

        
        
        private void CancellTeleportation(BasePlayer player)
        {
            if (config.teleportationController.teleportSetting.suggetionAcceptedUI)
                DestroyUI(player, InterfaceBuilder.IQ_TELEPORT_UI_TELEPORT);
                
            UserRepository pData = localUsersRepository[player];
            if (playerTeleportationQueue.TryGetValue(player.userID, out TeleportationQueueInfo requester))
            {
                SendChat(GetLang("ACCESS_CANCELL_TELEPORTATION", player.UserIDString), player);
                
                if (requester.isActive)
                    SendChat(GetLang("ACCESS_CANCELL_TELEPORTATION", requester.player.UserIDString), requester.player);
            
                ClearQueue(player, requester.player);
                pData.DeActiveTeleportation();
                
                Interface.Call("OnTeleportRejected", player, requester.player);
                return;
            }

            if (pData.IsActiveTeleportation())
            {
                SendChat(GetLang("ACCESS_CANCELL_TELEPORTATION", player.UserIDString), player);
                pData.DeActiveTeleportation();
                
                Interface.Call("OnTeleportRejected", player, requester?.player);
		   		 		  						  	   		   		 		  			 		  	   		  				
                return;
            }
            
            SendChat(GetLang("CAN_CANCELL_TELEPORTATION_NOT_FOUNDS", player.UserIDString), player);
        }
        
        [ChatCommand("tpc")]
        private void CancellTeleportCmdChat(BasePlayer player) => CancellTeleportation(player);
        public class Configuration
        {
            [JsonProperty(LanguageEn ? "" : "Основные настройки плагина")]
            public GeneralController generalController = new GeneralController();
            [JsonProperty(LanguageEn ? "" : "Настройка телепортации к игроку")]
            public TeleportationController teleportationController = new TeleportationController();
            [JsonProperty(LanguageEn ? "" : "Настройка точек для дома")]
            public HomeController homeController = new HomeController();
            [JsonProperty(LanguageEn ? "" : "Настройка системы варпов")]
            public WarpsController warpsContoller = new WarpsController();
            internal class WarpsController
            {
                [JsonProperty(LanguageEn ? "" : "Включить поддержку варпов (true - да/false - нет)")]
                public Boolean useWarps;
                [JsonProperty(LanguageEn ? "" : "Настройка времени перезарядки телепортации на варп")]
                public PresetOtherSetting teleportWarpCooldown = new PresetOtherSetting();
                [JsonProperty(LanguageEn ? "" : "Настройка времени телепортации на варп")]
                public PresetOtherSetting teleportWarpCountdown = new PresetOtherSetting();
            }

            internal class GeneralController
            {
                [JsonProperty(LanguageEn ? "" : "Использовать логирование действий игроков в файл (true - да/false - нет)")]
                public Boolean useLogged;
                [JsonProperty(LanguageEn ? "" : "Использовать звуковые эффекты (true - да/false - нет)")]
                public Boolean useSoundEffects;
                [JsonProperty(LanguageEn ? "" : "Использовать GameTip сообщения, вместо сообщений в чате (true - да/false - нет)")]
                public Boolean useOnlyGameTip;
                [JsonProperty(LanguageEn ? "" : "Поднимать игрока сразу после телепортации, иначе он будет в состоянии `сна` (true - да/false - нет)")]
                public Boolean stopSleepingAfterTeleport;
                [JsonProperty(LanguageEn ? "" : "Список монументов с которых запрещено телепортироваться (Распространяется на точки дома/телепортацию к игрокам/варпы)")]
                public List<String> monumentBlockedTeleportation = new List<String>();
                [JsonProperty(LanguageEn ? "" : "Настройки IQChat")]
                public IQChatController iqchatSetting = new IQChatController();
                
                internal class IQChatController
                {
                    [JsonProperty(LanguageEn ? "IQChat : Custom prefix in the chat" : "IQChat : Кастомный префикс в чате")]
                    public String customPrefix;
                    [JsonProperty(LanguageEn ? "IQChat : Custom avatar in the chat (Steam64ID) (If required)" : "IQChat : Кастомный аватар в чате (Steam64ID) (Если требуется)")]
                    public String customAvatar;
                }
            }

            internal class TeleportationController
            {
                [JsonProperty(LanguageEn ? "" : "Настройка запросов на телепортацию")]
                public TeleportSetting teleportSetting = new TeleportSetting();
                [JsonProperty(LanguageEn ? "" : "Настройка времени перезарядки телепортации к игроку")]
                public PresetOtherSetting teleportCooldown = new PresetOtherSetting();
                [JsonProperty(LanguageEn ? "" : "Настройка времени телепортации к игроку")]
                public PresetOtherSetting teleportCountdown = new PresetOtherSetting();
                
                internal class TeleportSetting
                {
                    [JsonProperty(LanguageEn ? "" : "Предлагать принять запрос на телепортацию в UI (true - да/false - нет)")]
                    public Boolean suggetionAcceptedUI;
                    [JsonProperty(LanguageEn ? "" : "Режим телепортации, 1 (true) - телепортировать игрока на точку где был принят запрос, 2 (false) - телепортировать игрока к другому игроку не зависимо где был принят запрос")]
                    public Boolean teleportPosInAccept;
                    [JsonProperty(LanguageEn ? "" : "Разрешить игрокам отправлять запросы на телепортацию по G-Map (true - да/false - нет)")]
                    public Boolean useGMapTeleport;
                    [JsonProperty(LanguageEn ? "" : "Использовать моментальную телепортацию на точку через G-Map (true - да/false - нет) (требуются права администратора или разрешение iqteleportation.gmap)")]
                    public Boolean useGMapTeleportAdmin;
                    [JsonProperty(LanguageEn ? "" : "Отключить функции телепортации на сервере (tpr и tpa будут недоступны) (true - да/false - нет)")]
                    public Boolean disableTeleportationPlayer = false;
                    [JsonProperty(LanguageEn ? "" : "Запретить отправку и принятие запроса на телепортацию во время рейдблока (true - да/false - нет)")]
                    public Boolean noTeleportInRaidBlock = true;
                    [JsonProperty(LanguageEn ? "" : "Запретить отправку и принятие запроса на телепортацию когда игрок на корабле (true - да/false - нет)")]
                    public Boolean noTeleportCargoShip = true;
                    [JsonProperty(LanguageEn ? "" : "Запретить отправку и принятие запроса на телепортацию когда игрок на воздушном шаре (true - да/false - нет)")]
                    public Boolean noTeleportHotAirBalloon = true;
                    [JsonProperty(LanguageEn ? "" : "Запретить отправку и принятие запроса на телепортацию когда игроку холодно (true - да/false - нет)")]
                    public Boolean noTeleportFrozen = true;
                    [JsonProperty(LanguageEn ? "" : "Запретить отправку и принятие запроса на телепортацию когда игрок под радиацией (true - да/false - нет)")]
                    public Boolean noTeleportRadiation = true;
                    [JsonProperty(LanguageEn ? "" : "Запретить отправку и принятие запроса на телепортацию когда у игрока кровотечение(true - да/false - нет)")]
                    public Boolean noTeleportBlood = true;
                    [JsonProperty(LanguageEn ? "" : "Разрешать телепортацию только к друзьям (true - да/false - нет)")]
                    public Boolean onlyTeleportationFriends = true;
                }
            }
            
            internal class HomeController
            {
                [JsonProperty(LanguageEn ? "" : "Предлагать установку точки дома в UI после установки кровати или спальника (true - да/false - нет)")]
                public Boolean suggetionSetHomeAfterInstallBed;
                [JsonProperty(LanguageEn ? "" : "Добавлять визуальный эффект (пинг) на точку дома после ее установки (true - да/false - нет)")]
                public Boolean addedPingMarker;
                [JsonProperty(LanguageEn ? "" : "Добавлять маркер на G-Map игрока после установки дома (true - да/false - нет)")]
                public Boolean addedMapMarkerHome;
                [JsonProperty(LanguageEn ? "" : "Настройка разрешений на установку точек дома")]
                public SetupHome setupHomeController = new SetupHome();
                [JsonProperty(LanguageEn ? "" : "Настройка количества точек дома")]
                public PresetOtherSetting homeCount = new PresetOtherSetting();
                [JsonProperty(LanguageEn ? "" : "Настройка времени перезарядки телепортации на точку дома")]
                public PresetOtherSetting homeCooldown = new PresetOtherSetting();
                [JsonProperty(LanguageEn ? "" : "Настройка времени телепортации игрока на точку дома")]
                public PresetOtherSetting homeCountdown = new PresetOtherSetting();
                
                internal class SetupHome
                {
                    [JsonProperty(LanguageEn ? "" : "Запретить установку точки дома при рейдблоке (true - да/false - нет)")]
                    public Boolean noSetupInRaidBlock;
                    [JsonProperty(LanguageEn ? "" : "Разрешить установку точек дома на буксирах (true - да/false - нет)")]
                    public Boolean canSetupTugboatHome;
                    [JsonProperty(LanguageEn ? "" : "Разрешать установку точек дома только при наличии билдинг зоны (true - да/false - нет)")]
                    public Boolean onlyBuildingPrivilage;
                    [JsonProperty(LanguageEn ? "" : "Разрешать установку точек дома только при наличии авторизации в билдинг зоне (true - да/false - нет)")]
                    public Boolean onlyBuildingAuth;
                }
            }
            
            internal class PresetOtherSetting
            {
                [JsonProperty(LanguageEn ? "" : "Стандартное количество для игроков без разрешений")]
                public Int32 count;
                [JsonProperty(LanguageEn ? "" : "Настройка количества для игроков с разрешениями [Разрешение] = Количество")]
                public Dictionary<String, Int32> countPermissions;

                public Int32 GetCount(BasePlayer player, Boolean descending = false)
                {
                    foreach (KeyValuePair<String, Int32> countPermission in descending ? countPermissions.OrderByDescending(x => x.Value)
                                                                                       : countPermissions.OrderBy(x => x.Value))
                    {
                        if (_.permission.UserHasPermission(player.UserIDString, countPermission.Key))
                            return countPermission.Value;
                    }

                    return count;
                }
            }

            public static Configuration GetNewConfiguration()
            {
                return new Configuration
                {
                    generalController = new GeneralController
                    {
                        useSoundEffects = true,
                        useLogged = false,
                        useOnlyGameTip = false,
                        stopSleepingAfterTeleport = false,
                        monumentBlockedTeleportation = new List<String>()
                        {
                            
                        },
                        iqchatSetting = new GeneralController.IQChatController
                        {
                            customPrefix = "[IQTeleportation]",
                            customAvatar = "0"
                        }
                    },
                    warpsContoller = new WarpsController
                    {
                        useWarps = false,
                        teleportWarpCooldown = new PresetOtherSetting
                        {
                            count = 120,
                            countPermissions = new Dictionary<String, Int32>()
                            {
                                ["iqteleportation.vip"] = 100,
                                ["iqteleportation.premium"] = 80,
                                ["iqteleportation.gold"] = 60,
                            }
                        },
                        teleportWarpCountdown = new PresetOtherSetting
                        {
                            count = 30,
                            countPermissions = new Dictionary<String, Int32>()
                            {
                                ["iqteleportation.vip"] = 25,
                                ["iqteleportation.premium"] = 20,
                                ["iqteleportation.gold"] = 15,
                            }
                        }
                    },
                    teleportationController = new TeleportationController
                    {
                        teleportSetting = new TeleportationController.TeleportSetting
                        {
                            suggetionAcceptedUI = true,
                            teleportPosInAccept = false,
                            useGMapTeleport = true,
                            useGMapTeleportAdmin = true,
                            disableTeleportationPlayer = false,
                            noTeleportInRaidBlock = true,
                            noTeleportCargoShip = true,
                            noTeleportHotAirBalloon = true,
                            noTeleportBlood = true,
                            noTeleportFrozen = true,
                            noTeleportRadiation = true,
                            onlyTeleportationFriends = false,
                        },
                        teleportCooldown = new PresetOtherSetting
                        {
                            count = 60,
                            countPermissions = new Dictionary<String, Int32>()
                            {
                                ["iqteleportation.vip"] = 45,
                                ["iqteleportation.premium"] = 35,
                                ["iqteleportation.gold"] = 25,
                            }
                        },
                        teleportCountdown = new PresetOtherSetting()
                        {
                            count = 20,
                            countPermissions = new Dictionary<String, Int32>()
                            {
                                ["iqteleportation.vip"] = 15,
                                ["iqteleportation.premium"] = 10,
                                ["iqteleportation.gold"] = 5,
                            }
                        }
                    },
                    homeController = new HomeController()
                    {
                        suggetionSetHomeAfterInstallBed = true,
                        addedMapMarkerHome = true,
                        addedPingMarker = true,
                        setupHomeController = new HomeController.SetupHome
                        {
                            noSetupInRaidBlock = true,
                            canSetupTugboatHome = false,
                            onlyBuildingPrivilage = true,
                            onlyBuildingAuth = true,
                        },
                        homeCount = new PresetOtherSetting()
                        {
                            count = 2,
                            countPermissions = new Dictionary<String, Int32>()
                            {
                                ["iqteleportation.vip"] = 3,
                                ["iqteleportation.premium"] = 4,
                                ["iqteleportation.gold"] = 5,
                            }
                        },
                        homeCooldown = new PresetOtherSetting()
                        {
                            count = 30,
                            countPermissions = new Dictionary<String, Int32>()
                            {
                                ["iqteleportation.vip"] = 25,
                                ["iqteleportation.premium"] = 20,
                                ["iqteleportation.gold"] = 15,
                            }
                        },
                        homeCountdown = new PresetOtherSetting()
                        {
                            count = 20,
                            countPermissions = new Dictionary<String, Int32>()
                            {
                                ["iqteleportation.vip"] = 15,
                                ["iqteleportation.premium"] = 10,
                                ["iqteleportation.gold"] = 5,
                            }
                        },
                    }
                };
            }
        }

        
        
                
        
        private class ImageUI
        {
            private const String _path = "IQSystem/IQTeleportation/Images/";
            private const String _printPath = "data/" + _path;
            private readonly Dictionary<String, ImageData> _images = new()
            {
	             { "UI_IQTELEPORTATION_TEMPLATE", new ImageData() },
            };

            private enum ImageStatus
            {
                NotLoaded,
                Loaded,
                Failed
            }

            private class ImageData
            {
                public ImageStatus Status = ImageStatus.NotLoaded;
                public String Id { get; set; }
            }
		   		 		  						  	   		   		 		  			 		  	   		  				
            public String GetImage(String name)
            {
                if (_images.TryGetValue(name, out ImageData image) && image.Status == ImageStatus.Loaded)
                    return image.Id;
                return null;
            }

            public void DownloadImage()
            {
                KeyValuePair<String, ImageData>? image = null;
                foreach (KeyValuePair<String, ImageData> img in _images)
                {
                    if (img.Value.Status == ImageStatus.NotLoaded)
                    {
                        image = img;
                        break;
                    }
                }

                if (image != null)
                {
                    ServerMgr.Instance.StartCoroutine(ProcessDownloadImage(image.Value));
                }
                else
                {
                    List<String> failedImages = new List<String>();

                    foreach (KeyValuePair<String, ImageData> img in _images)
                    {
                        if (img.Value.Status == ImageStatus.Failed)
                        {
                            failedImages.Add(img.Key);
                        }
                    }

                    if (failedImages.Count > 0)
                    {
                        String images = String.Join(", ", failedImages);
                        _.PrintError(LanguageEn
                            ? $"Failed to load the following images: {images}. Perhaps you did not upload them to the '{_printPath}' folder. You can download it here - https://drive.google.com/drive/folders/1abiKOnLRx7m3YD7LHugPA7dSr2MCaMdi?usp=sharing" 
                            : $"Не удалось загрузить следующие изображения: {images}. Возможно, вы не загрузили их в папку '{_printPath}'. Скачать можно тут - https://drive.google.com/drive/folders/1abiKOnLRx7m3YD7LHugPA7dSr2MCaMdi?usp=sharing");
                        Interface.Oxide.UnloadPlugin(_.Name);
                    }
                    else
                    {
                        _.Puts(LanguageEn
                            ? $"{_images.Count} images downloaded successfully!"
                            : $"{_images.Count} изображений успешно загружено!");
                        
                        _interface = new InterfaceBuilder();
                    }
                }
            }
            
            public void UnloadImages()
            {
                foreach (KeyValuePair<String, ImageData> item in _images)
                    if(item.Value.Status == ImageStatus.Loaded)
                        if (item.Value?.Id != null)
                            FileStorage.server.Remove(uint.Parse(item.Value.Id), FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID);

                _images?.Clear();
            }

            private IEnumerator ProcessDownloadImage(KeyValuePair<String, ImageData> image)
            {
                String url = "file://" + Interface.Oxide.DataDirectory + "/" + _path + image.Key + ".png";

                using UnityWebRequest www = UnityWebRequestTexture.GetTexture(url);
                yield return www.SendWebRequest();

                if (www.result is UnityWebRequest.Result.ConnectionError or UnityWebRequest.Result.ProtocolError)
                {
                    image.Value.Status = ImageStatus.Failed;
                }
                else
                {
                    Texture2D tex = DownloadHandlerTexture.GetContent(www);
                    image.Value.Id = FileStorage.server.Store(tex.EncodeToPNG(), FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID).ToString();
                    image.Value.Status = ImageStatus.Loaded;
                    UnityEngine.Object.DestroyImmediate(tex);
                }

                DownloadImage();
            }
        }
        
        private static void DrawSphereAndText(BasePlayer player, in Vector3 position, String text, Single time = 30f)
        {
            player.SendConsoleCommand("ddraw.text", time, Color.green, position + Vector3.up, $"<size=35>{text}</size>");
            player.SendConsoleCommand("ddraw.sphere", time, Color.green, position, 0.5f);
        }
        private Dictionary<UInt64, SettingPlayer> playerSettings = new();
        
        [ChatCommand("tpa")]
        private void TpaChatCMD(BasePlayer player, String cmd, String[] arg) => AcceptRequestTeleportation(player);

        private void GenerateWarp()
        {
            cmd.AddChatCommand("warp", this, nameof(ChatCommandWarp));
            if (serverWarps.Keys.Count == 0)
                Puts(LanguageEn ? "" : "Варпы не были инициализированы, количество существующих варпов : 0");
            else
            {
                String warps = String.Join(", ", serverWarps.Keys);
                foreach ((String warpName, List<ServerWarp> value) in serverWarps)
                {
                    Boolean allHidden = value.All(warp => warp.hideWarp);
                    if (allHidden) continue;
                    
                    cmd.AddChatCommand(warpName, this, nameof(ChatCommandTeleportationWarp));
                    cmd.AddConsoleCommand(warpName, this, nameof(ConsoleCommandTeleportationWarp));
                }

                Puts(LanguageEn ? "" : $"Инициализировано {serverWarps.Keys.Count} варпов, для них зарезервированы команды : {warps}");
            }
        }
        
                
        
        private Boolean IsFriends(BasePlayer player, UInt64 targetID)
        {
            if (player.userID == targetID) return true;
            UInt64[] FriendList = GetFriendList(player);
            return FriendList != null && FriendList.Contains(targetID);
        }

                
                private static void DestroyUI(BasePlayer player, String elementName) => CommunityEntity.ServerInstance.ClientRPC<String>(RpcTarget.Player("DestroyUI", player.net.connection), elementName);
        private void OnPlayerConnected(BasePlayer player) => RegisteredUser(player);
        private const String tprLog = LanguageEn ? "" : "отправил запрос на телепортацию к";
        
        
        
        [PluginReference] Plugin IQChat, Clans, Friends;

        private String CanRequestTeleportHome(BasePlayer player, String homeName, String friendNameOrID, out UInt64 userIDFriend, out String friendName)
        {
            CheckAllHomes(player, homeName);

            userIDFriend = default;
            friendName = String.Empty;
            UInt64 userID = player.userID;

            String canTeleport = CanTeleportation(player, UserRepository.TeleportType.Home);
            if (!String.IsNullOrWhiteSpace(canTeleport))
                return canTeleport;

            if (playerTeleportationQueue.ContainsKey(player.userID))
            {
                return playerTeleportationQueue[player.userID].player != null
                    ? GetLang("CAN_REQUEST_TELEPORTATION_TELEPORTED_REQUEST_ACTUALY_NAME", player.UserIDString,
                        playerTeleportationQueue[player.userID].player.displayName)
                    : GetLang("CAN_REQUEST_TELEPORTATION_TELEPORTED_REQUEST_ACTUALY", player.UserIDString);
            }

            if (!String.IsNullOrWhiteSpace(friendNameOrID))
            {
                BasePlayer bPlayer = BasePlayer.FindAwakeOrSleeping(friendNameOrID); 
                if (bPlayer == null)
                    return GetLang("CAN_TELEPORT_HOME_NOT_FOUND", player.UserIDString, friendNameOrID);

                userIDFriend = bPlayer.userID;
                friendName = bPlayer.displayName;

                if (!IsFriends(player, userIDFriend))
                    return GetLang("CAN_TELEPORT_HOME_NOT_FRIEND", player.UserIDString, friendNameOrID);

                userID = userIDFriend;

                if (!playerSettings[userIDFriend].useTeleportationHomeFromFriends && userID != player.userID)
                    return GetLang("CAN_TELEPORT_PLAYER_NOT_SETTING_USE_FRIEND_HOME", player.UserIDString);
            }

            if (!playerHomes.TryGetValue(userID, out Dictionary<String, PlayerHome> pData) ||
                !pData.TryGetValue(homeName, out PlayerHome homePlayer))
                return GetLang("CAN_TELEPORT_HOME_NOT_HOME", player.UserIDString, homeName);

            if (Interface.Call("CanTeleportHome", player, homePlayer.positionHome) is String hookResult)
                return String.IsNullOrWhiteSpace(hookResult) ? GetLang("CAN_TELEPORT_NULL_REASON", player.UserIDString) : hookResult;
            
            if (homePlayer.netIdEntity != 0)
            {
                if (!tugboatsServer.TryGetValue(homePlayer.netIdEntity, out Tugboat tugboat) || tugboat == null || tugboat.IsDestroyed)
                    return GetLang("CAN_TELEPORT_HOME_NOT_TUGBOAT", player.UserIDString, homeName);
                
                return String.Empty;
            }

            BuildingBlock buildingBlock = GetBuildingBlock(homePlayer.positionHome);
            if (!buildingBlock)
            {
                pData.Remove(homeName);
                return GetLang("CAN_TELEPORT_HOME_NOT_BUILDING_BLOCK", player.UserIDString, homeName);
            }

            if (config.homeController.setupHomeController.onlyBuildingAuth)
            {
                BuildingPrivlidge privilege = buildingBlock.GetBuildingPrivilege();
                if (privilege != null && !privilege.IsAuthed(player))
                {
                    pData.Remove(homeName);
                    return GetLang("CAN_TELEPORT_HOME_NOT_AUTH_BUILDING_PRIVILAGE", player.UserIDString, homeName);
                }
            }

            return String.Empty;
        }
        private Dictionary<BasePlayer, Action> teleportationActions = new();
        
        private void RegisteredPermissions()
        {
            
            if (config.warpsContoller.useWarps)
            {
                foreach (String countWarpCooldownPermissions in config.warpsContoller.teleportWarpCooldown
                             .countPermissions.Keys)
                {
                    if (!permission.PermissionExists(countWarpCooldownPermissions, this))
                        permission.RegisterPermission(countWarpCooldownPermissions, this);
                }

                foreach (String countWarpCoutdownPermissions in config.warpsContoller.teleportWarpCountdown
                             .countPermissions.Keys)
                {
                    if (!permission.PermissionExists(countWarpCoutdownPermissions, this))
                        permission.RegisterPermission(countWarpCoutdownPermissions, this);
                }
            }
		   		 		  						  	   		   		 		  			 		  	   		  				
            
            
            foreach (String countTeleportCooldownPermissions in config.teleportationController.teleportCooldown
                         .countPermissions.Keys)
            {
                if (!permission.PermissionExists(countTeleportCooldownPermissions, this))
                    permission.RegisterPermission(countTeleportCooldownPermissions, this);
            }

            foreach (String countTeleportCoutdownPermissions in config.teleportationController.teleportCountdown
                         .countPermissions.Keys)
            {
                if (!permission.PermissionExists(countTeleportCoutdownPermissions, this))
                    permission.RegisterPermission(countTeleportCoutdownPermissions, this);
            }

            
            
            foreach (String countHomePermissions in config.homeController.homeCount.countPermissions.Keys)
            {
                if (!permission.PermissionExists(countHomePermissions, this))
                    permission.RegisterPermission(countHomePermissions, this);
            }

            foreach (String countHomeColldownPermissions in config.homeController.homeCooldown.countPermissions.Keys)
            {
                if (!permission.PermissionExists(countHomeColldownPermissions, this))
                    permission.RegisterPermission(countHomeColldownPermissions, this);
            }

            foreach (String countHomeCoutdownPermissions in config.homeController.homeCountdown.countPermissions.Keys)
            {
                if (!permission.PermissionExists(countHomeCoutdownPermissions, this))
                    permission.RegisterPermission(countHomeCoutdownPermissions, this);
            }

            
            if (!permission.PermissionExists(permissionGMapTeleport, this))
                permission.RegisterPermission(permissionGMapTeleport, this);

            if (!permission.PermissionExists(permissionTP, this))
                permission.RegisterPermission(permissionTP, this);
        }

                
        
        
        private void Init()
        {
            _ = this;
            ReadData();

            if (!config.homeController.addedPingMarker)
                Unsubscribe(nameof(OnPlayerDisconnected));
            
            if(!config.homeController.suggetionSetHomeAfterInstallBed)
                Unsubscribe(nameof(OnEntityBuilt));

            if (!config.homeController.setupHomeController.canSetupTugboatHome)
            {
                Unsubscribe(nameof(OnEntitySpawned));
                Unsubscribe(nameof(OnEntityKill));
            }

            if (!config.teleportationController.teleportSetting.useGMapTeleport &&
                !config.teleportationController.teleportSetting.useGMapTeleportAdmin)
                Unsubscribe(nameof(OnMapMarkerAdd));
        }
        private readonly LayerMask homelayerMaskEntity = LayerMask.GetMask("Default", "Deployed");

        
        
        private void ValidateWarps()
        {
            if (config.warpsContoller.useWarps)
            {
                foreach (KeyValuePair<String, List<ServerWarp>> allWarps in serverWarps)
                {
                    for (Int32 i = 0; i < allWarps.Value.Count; i++)
                    {
                        ServerWarp warp = allWarps.Value[i];
                        if (String.IsNullOrWhiteSpace(warp.monumentParent)) continue;
                        MonumentInfo monument = GetMonumentInName(warp.monumentParent);
                        if (monument != null)
                        {
                            serverWarps[allWarps.Key][i].hideWarp = false;
                            continue;
                        }
                        
                        serverWarps[allWarps.Key][i].hideWarp = true;
                    }
                }

                GenerateWarp();
            }
            else if (serverWarps.Keys.Count != 0)
            {
                foreach (String warpName in serverWarps.Keys)
                {
                    cmd.RemoveChatCommand(warpName, this);
                    cmd.RemoveConsoleCommand(warpName, this);
                }
            }
        }
        private const Single uiAlertFade = 0.222f;
		   		 		  						  	   		   		 		  			 		  	   		  				
        private String GetWarpPoints(String warpName)
        {
            String pointsKeys = String.Empty;
            if (!serverWarps.TryGetValue(warpName, out List<ServerWarp> warp)) return pointsKeys;
            for (Int32 i = 0; i < warp.Count; i++)
                pointsKeys += $"\n№{i}";

            return pointsKeys;
        }
        
        private void DrawUI_TeleportPlayer(BasePlayer player, BasePlayer targetPlayer)
        {
            if (_interface == null || !player || !targetPlayer) return;
            
            targetPlayer.Invoke(() =>
            {
                DestroyUI(targetPlayer, InterfaceBuilder.IQ_TELEPORT_UI_TELEPORT);
            }, 15f);
            
            String interfaceKey = $"{InterfaceBuilder.IQ_TELEPORT_UI_TELEPORT}_{targetPlayer.UserIDString}";
            List<String> cache = GetOrSetCacheUI(targetPlayer, interfaceKey);
            if (cache != null && cache.Count != 0)
            {
                foreach (String uiCached in cache)
                    AddUI(targetPlayer, uiCached);

                return;
            }
            
            String Interface = InterfaceBuilder.GetInterface(InterfaceBuilder.IQ_TELEPORT_UI_TELEPORT);
            if (Interface == null) return;

            String displayName = player.displayName.Length > 10 ? player.displayName.Substring(0, 7) + "..." : player.displayName;
            String titleRequest = GetLang("UI_TPR_REQUSET", targetPlayer.UserIDString, displayName.ToUpper());
		   		 		  						  	   		   		 		  			 		  	   		  				
            Interface = Interface.Replace("%TITILE_PANEL%", titleRequest);
            Interface = Interface.Replace("%COMMAND_YES%", "ui_teleportation_command tpa"); 
            Interface = Interface.Replace("%COMMAND_NO%", "ui_teleportation_command tpc"); 

            List<String> newUI = GetOrSetCacheUI(targetPlayer, interfaceKey, Interface);
            cache = newUI;
            
            foreach (String uiCached in cache)
                AddUI(targetPlayer, uiCached);
        }
        
                
        [ChatCommand("tpr")]
        private void TprChatCMD(BasePlayer player, String cmd, String[] arg)
        {
            if (config.teleportationController.teleportSetting.disableTeleportationPlayer)
            {
                SendChat(GetLang("CAN_REQUEST_TELEPORTATION_DISABLED", player.UserIDString), player, true);
                return;
            }
            
            if (arg.Length == 0 && !casheTeleportationLast.ContainsKey(player))
            {
                SendChat(GetLang("SYNTAX_COMMAND_TELEPORT_REQUEST", player.UserIDString), player, true);
                return;
            }
        
            RequestTeleportation(player, arg);
        }
        

                
        
        private String CheckStatusPlayer(BasePlayer player, Boolean canSethome = false)
        {
            if (!canSethome)
            {
                if (config.teleportationController.teleportSetting.noTeleportFrozen && player.metabolism.temperature.value < 0)
                    return GetLang("STATUS_PLAYER_TITLE", player.UserIDString, GetLang("STATUS_PLAYER_IS_COLD", player.UserIDString));

                if ((config.teleportationController.teleportSetting.noTeleportBlood && player.metabolism.bleeding.value > 0)|| player.IsWounded())
                    return GetLang("STATUS_PLAYER_TITLE", player.UserIDString, GetLang("STATUS_PLAYER_WOUNDED", player.UserIDString));
		   		 		  						  	   		   		 		  			 		  	   		  				
                if (config.teleportationController.teleportSetting.noTeleportRadiation && player.metabolism.radiation_poison.value > 0)
                    return GetLang("STATUS_PLAYER_TITLE", player.UserIDString, GetLang("STATUS_PLAYER_RADIATION", player.UserIDString));
            }

            if (player.IsDead())
                return GetLang("STATUS_PLAYER_TITLE", player.UserIDString, GetLang("STATUS_PLAYER_IS_DEAD", player.UserIDString));

            if (player.IsSleeping())
                return GetLang("STATUS_PLAYER_TITLE", player.UserIDString, GetLang("STATUS_PLAYER_IS_SLEEPING", player.UserIDString));

            if (player.IsSwimming())
                return GetLang("STATUS_PLAYER_TITLE", player.UserIDString, GetLang("STATUS_PLAYER_IS_SWIMMING", player.UserIDString));

            if (player.IsInTutorial)
                return GetLang("STATUS_PLAYER_TITLE", player.UserIDString, GetLang("STATUS_PLAYER_IS_TUTORIAL", player.UserIDString));

            if (player.IsFlying)
                return GetLang("STATUS_PLAYER_TITLE", player.UserIDString, GetLang("STATUS_PLAYER_FLYING", player.UserIDString));

            if (player.isMounted)
                return GetLang("STATUS_PLAYER_TITLE", player.UserIDString, GetLang("STATUS_PLAYER_MOUNTED", player.UserIDString));
            

            return String.Empty;
        }
		   		 		  						  	   		   		 		  			 		  	   		  				
        
        
        private void GMapTeleportTurn(BasePlayer player)
        {
            if (!playerSettings.TryGetValue(player.userID, out SettingPlayer setting)) return;
            setting.useTeleportGMap = !setting.useTeleportGMap;

            String message = setting.useTeleportGMap
                ? GetLang("GMAP_TELEPORT_TRUE", player.UserIDString)
                : GetLang("GMAP_TELEPORT_FALSE", player.UserIDString);
            
            SendChat(message, player);
        }
        
        private void ConsoleCommandTeleportationWarp(ConsoleSystem.Arg arg)
        {
            if (!config.warpsContoller.useWarps) return;
            BasePlayer player = arg.Player();
            if (player == null) return;
            
            if (!serverWarps.TryGetValue(arg.cmd.Name, out List<ServerWarp> warpPoints)) return;
            ServerWarp randomWarp = GetRandomWarp(warpPoints);
            if (randomWarp == null) return;
            Vector3 warpPoint = randomWarp.GetPositionWarp();
            if (warpPoint == default) return;
            
            RequestWarp(player, warpPoint);
        }
        
        private void RegisteredUser(BasePlayer player)
        {
            localUsersRepository.TryAdd(player, new UserRepository
            {
                activeTeleportation = null,
                cooldownHome = 0,
                cooldownTeleportation = 0
            });

            playerSettings.TryAdd(player.userID, new SettingPlayer
            {
                useTeleportationHomeFromFriends = true,
                useTeleportGMap = true,
                autoAcceptTeleportationFriends = false,
                firstConnection = DateTime.Now,
            });

            playerHomes.TryAdd(player.userID, new Dictionary<String, PlayerHome>());
        }
        
        [ConsoleCommand("tpr")]
        private void TprConsoleCMD(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            
            if (config.teleportationController.teleportSetting.disableTeleportationPlayer)
            {
                SendChat(GetLang("CAN_REQUEST_TELEPORTATION_DISABLED", player.UserIDString), player, true);
                return;
            }
            
            if (arg.Args.Length == 0 && !casheTeleportationLast.ContainsKey(player))
            {
                SendChat(GetLang("SYNTAX_COMMAND_TELEPORT_REQUEST", player.UserIDString), player, true);
                return;
            }
        
            RequestTeleportation(player, arg.Args);
        }
        
                
        
        private static StringBuilder sb = new StringBuilder();
        
        
        [ChatCommand("a.home")]
        private void ChatCommandAdminHome(BasePlayer player, String cmd, String[] arg)
        {
            if (player == null) return;
            if (!player.IsAdmin) return;

            String action = arg[0];
            String nameOrIdOrIp = arg[1];

            BasePlayer bPlayer = BasePlayer.FindAwakeOrSleeping(nameOrIdOrIp);
            if (bPlayer == null)
            {
                SendChat(GetLang("A_HOME_CHECK_PLAYER_NOT_FOUND", player.UserIDString), player, true);
                return;
            }

            if (!playerHomes.TryGetValue(bPlayer.userID, out Dictionary<String, PlayerHome> playerHome))
            {
                SendChat(GetLang("A_HOME_CHECK_NOT_HOME", player.UserIDString), player, true);
                return;
            }

            switch (action)
            {
                case "clear":
                {
                    playerHome.Clear();
                    SendChat(GetLang("A_HOME_CLEAR_HOMES", player.UserIDString), player);
                    break;
                }
                case "points":
                {
                    foreach (KeyValuePair<String, PlayerHome> pHome in playerHome)
                    {
                        Vector3 positionHome = pHome.Value.positionHome;
                        
                        if(pHome.Value.netIdEntity != 0)
                            if (tugboatsServer.TryGetValue(pHome.Value.netIdEntity, out Tugboat tugboat) && tugboat && !tugboat.IsDestroyed)
                                positionHome = tugboat.transform.TransformPoint(pHome.Value.positionHome);

                        DrawSphereAndText(player, positionHome, pHome.Key);
                    }
                    
                    SendChat(GetLang("A_HOME_SHOW_POINTS", player.UserIDString, bPlayer.displayName), player);
                    break;
                }
            }
        }

        [ConsoleCommand("tp")]
        private void TpConsoleCMD(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            if (!player.IsAdmin && !permission.UserHasPermission(player.UserIDString, permissionTP)) return;
            
            if (arg.Args.Length == 0 && !casheTeleportationLast.ContainsKey(player))
            {
                SendChat(GetLang("SYNTAX_COMMAND_TELEPORT", player.UserIDString), player, true);
                return;
            }

            String nameOrIDTarget = arg.Args[0];
            (BasePlayer, String) findPlayer = FindPlayerNameOrID(player, nameOrIDTarget);
            BasePlayer targetPlayer = null;
            if(!String.IsNullOrWhiteSpace(nameOrIDTarget))
                targetPlayer = findPlayer.Item1;
            
            String nameOrIDOnPlayer = String.Empty;
            BasePlayer onPlayer = null;

            if (arg.Args.Length >= 2)
            {
                nameOrIDOnPlayer = arg.Args[1];
                (BasePlayer, String) findOnPlayer = FindPlayerNameOrID(player, nameOrIDOnPlayer);

                if (!String.IsNullOrWhiteSpace(nameOrIDOnPlayer))
                {
                    onPlayer = targetPlayer;
                    targetPlayer = findOnPlayer.Item1;
                }

                if (onPlayer == null)
                {
                    SendChat(findOnPlayer.Item2 ?? GetLang("CAN_TELEPORT_PLAYER_NOT_FOUND_TP_ONE_PLAYER", player.UserIDString), player, true);
                    return;
                }
		   		 		  						  	   		   		 		  			 		  	   		  				
                if (targetPlayer == null)
                {
                    SendChat(findPlayer.Item2 ?? GetLang("CAN_TELEPORT_PLAYER_NOT_FOUND_TP_TARGET_PLAYER_ONE", player.UserIDString, nameOrIDTarget), player, true);
                    return;
                }
            }
            else onPlayer = player;
            
            if (targetPlayer == null)
            {
                SendChat(findPlayer.Item2 ?? GetLang("CAN_TELEPORT_PLAYER_NOT_FOUND_TP_TARGET_PLAYER", player.UserIDString), player, true);
                return;
            }
        
            MovePlayer(onPlayer, targetPlayer.transform.position);
            SendChat(GetLang("CAN_TELEPORT_PLAYER_ACCES_TP", onPlayer.UserIDString, targetPlayer.displayName), onPlayer);
        }

        private const String permissionGMapTeleport = "iqteleportation.gmap";
        
        [ConsoleCommand("gmap")]
        private void GMapTeleportConsoleCmd(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;

            GMapTeleportTurn(player);
        }
        
                
                
        
        private String CanTeleportation(BasePlayer player, UserRepository.TeleportType type, Boolean isSkipCooldown = false)
        {
            if (Interface.Call("CanTeleport", player) is String hookResult)
                return String.IsNullOrWhiteSpace(hookResult) ? GetLang("CAN_TELEPORT_NULL_REASON", player.UserIDString) : hookResult;
            
            if (Interface.Call("canTeleport", player) is String hookResultTwo)
                return String.IsNullOrWhiteSpace(hookResultTwo) ? GetLang("CAN_TELEPORT_NULL_REASON", player.UserIDString) : hookResultTwo;
            
            String statusPlayer = CheckStatusPlayer(player);
            if (!String.IsNullOrWhiteSpace(statusPlayer))
                return statusPlayer;

            if (config.teleportationController.teleportSetting.noTeleportInRaidBlock && IsRaidBlocked(player))
                return GetLang("CAN_TELEPORT_RAID_BLOCK", player.UserIDString);

            BaseEntity playerParentEntity = player.GetParentEntity();

            if (playerParentEntity)
            {
                if (config.teleportationController.teleportSetting.noTeleportHotAirBalloon && playerParentEntity is HotAirBalloon)
                    return GetLang("CAN_TELEPORT_TITILE_OTHER", player.UserIDString,
                        GetLang("CAN_TELEPORT_IN_HOT_AIR_BALLOON", player.UserIDString));

                if (config.teleportationController.teleportSetting.noTeleportCargoShip && playerParentEntity is CargoShip)
                    return GetLang("CAN_TELEPORT_TITILE_OTHER", player.UserIDString,
                        GetLang("CAN_TELEPORT_IN_CARGO_SHIP", player.UserIDString));
            }

            if (player.IsBuildingBlocked())
                return GetLang("CAN_TELEPORT_TITILE_OTHER", player.UserIDString,
                    GetLang("CAN_TELEPORT_IN_BUILDING_BLOCKED", player.UserIDString));
		   		 		  						  	   		   		 		  			 		  	   		  				
            if (IsPlayerWithinBlockedMonument(player))
                return GetLang("CAN_TELEPORT_MONUMENT_BLOCKED", player.UserIDString);

            if (isSkipCooldown) return String.Empty;
            
            UserRepository userRepository = localUsersRepository[player];
            String getCooldown = userRepository.GetCooldownTitle(player, type);
            return !String.IsNullOrWhiteSpace(getCooldown) ? GetLang("CAN_TELEPORT_COOLDOWN", player.UserIDString, getCooldown) : String.Empty;
        }
        
        [ConsoleCommand("removehome")]
        private void RemoveHomeConsoleCMD(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            
            if (arg.Args.Length == 0)
            {
                SendChat(GetLang("SYNTAX_COMMAND_REMOVEHOME", player.UserIDString), player, true);
                return;
            }

            String homeName = arg.Args[0];
            RemoveHome(player, homeName);
        }

        private String FormatTime(Double seconds, String userID = null)
        {
            TimeSpan time = TimeSpan.FromSeconds(seconds);
            String result = String.Empty;
    
            String daysLabel = GetLang("TITLE_FORMAT_DAYS", userID);
            String hoursLabel = GetLang("TITLE_FORMAT_HOURSE", userID);
            String minutesLabel = GetLang("TITLE_FORMAT_MINUTES", userID);
            String secondsLabel = GetLang("TITLE_FORMAT_SECONDS", userID);

            if (time.Days > 0)
                result += $"{Format(time.Days, daysLabel, daysLabel, daysLabel)} ";
    
            if (time.Hours > 0)
                result += $"{Format(time.Hours, hoursLabel, hoursLabel, hoursLabel)} ";
    
            if (time.Minutes > 0)
                result += $"{Format(time.Minutes, minutesLabel, minutesLabel, minutesLabel)} ";
    
            if (time.Seconds > 0 || string.IsNullOrEmpty(result)) 
                result += $"{Format(time.Seconds, secondsLabel, secondsLabel, secondsLabel)}";
		   		 		  						  	   		   		 		  			 		  	   		  				
            return result.Trim(); 
        }

        private void TeleportationPlayer(BasePlayer player, BasePlayer targetPlayer, Vector3 teleportationPosition)
        {
            if (!player.IsValid())
                return;

            ClearQueue(player, targetPlayer);

            String canTeleport = CanTeleportation(player, UserRepository.TeleportType.Teleportation);
            if (!String.IsNullOrWhiteSpace(canTeleport))
            {
                SendChat(canTeleport, player, true);
                return;
            }
		   		 		  						  	   		   		 		  			 		  	   		  				
            String canTeleportTarget = CanTeleportation(targetPlayer, UserRepository.TeleportType.Teleportation, true);
            if (!String.IsNullOrWhiteSpace(canTeleportTarget))
            {
                SendChat(canTeleportTarget, targetPlayer, true);
                return;
            }

            if (config.teleportationController.teleportSetting.onlyTeleportationFriends)
            {
                if (!IsFriends(player, targetPlayer.userID))
                {
                    SendChat(GetLang("CAN_TELEPORT_ONLY_FRIEND", player.UserIDString), player, true);
                    SendChat(GetLang("CAN_TELEPORT_ONLY_FRIEND_TARGET", player.UserIDString), targetPlayer, true);
                    return;
                }
            }
            
            if (teleportationPosition == default)
                teleportationPosition = targetPlayer.transform.position;
		   		 		  						  	   		   		 		  			 		  	   		  				
            localUsersRepository[player].SetupCooldown(player, UserRepository.TeleportType.Teleportation);
            
            MovePlayer(player, teleportationPosition, targetPlayer.GetParentEntity());
        }
        
                
        private class InterfaceBuilder
        {
            
            public static InterfaceBuilder Instance;
            public const String IQ_TELEPORT_UI_HOME = "IQ_TELEPORT_UI_HOME";
            public const String IQ_TELEPORT_UI_TELEPORT = "IQ_TELEPORT_UI_TELEPORT";
            public Dictionary<String, String> Interfaces;

            
            public InterfaceBuilder()
            {
                Instance = this;
                Interfaces = new Dictionary<String, String>();
                
                if (config.teleportationController.teleportSetting.suggetionAcceptedUI)
                    Building_PanelButton(IQ_TELEPORT_UI_TELEPORT);
                
                if (config.homeController.suggetionSetHomeAfterInstallBed)
                    Building_PanelButton(IQ_TELEPORT_UI_HOME);
            }

            public static void AddInterface(String name, String json)
            {
                if (Instance.Interfaces.ContainsKey(name))
                {
                    _.PrintError($"Error! Tried to add existing cui elements! -> {name}");
                    return;
                }

                Instance.Interfaces.Add(name, json);
            }

            public static String GetInterface(String name)
            {
                String json = String.Empty;
                if (Instance.Interfaces.TryGetValue(name, out json) == false)
                {
                    _.PrintWarning($"Warning! UI elements not found by name! -> {name}");
                }

                return json;
            }

            public static void DestroyAll()
            {
                for (Int32 i = 0; i < BasePlayer.activePlayerList.Count; i++)
                {
                    BasePlayer player = BasePlayer.activePlayerList[i];
                    DestroyUI(player, IQ_TELEPORT_UI_HOME);
                    DestroyUI(player, IQ_TELEPORT_UI_TELEPORT);
                }
            }
    
            private void Building_PanelButton(String templateParent)
            {
                CuiElementContainer container = new CuiElementContainer();
                
                container.Add(new CuiElement
                {
                    FadeOut = uiAlertFade,
                    DestroyUi = templateParent,
                    Name = templateParent,
                    Parent = "Overlay",
                    Components = {
                        new CuiRawImageComponent { FadeIn = uiAlertFade, Color = "1 1 1 1", Png = _imageUI.GetImage("UI_IQTELEPORTATION_TEMPLATE") },
                        new CuiRectTransformComponent { AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "-199.867 80.133", OffsetMax = "181.467 104.8" }
                    }
                });

                container.Add(new CuiElement
                {
                    FadeOut = uiAlertFade / 2f,
                    DestroyUi = "Title_Panel",
                    Name = "Title_Panel",
                    Parent = templateParent,
                    Components = {
                        new CuiTextComponent { FadeIn = uiAlertFade, Text = "%TITILE_PANEL%", Font = "robotocondensed-bold.ttf", FontSize = 12, Align = TextAnchor.MiddleCenter, Color = "0.8941177 0.854902 0.8196079 1" },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "23.502 1.1", OffsetMax = "-23.589 -1.135" }
                    }
                });

                container.Add(new CuiButton
                {
                    FadeOut = uiAlertFade,
                    Button = { FadeIn = uiAlertFade, Color = "0 0 0 0", Close = templateParent, Command = "%COMMAND_YES%" },
                    Text = { FadeIn = uiAlertFade, Text = "", Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "0 0 0 0" },
                    RectTransform = { AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "1.266 -11.234", OffsetMax = "23.502 11.198" }
                },templateParent,"Button_Setup", "Button_Setup");

                container.Add(new CuiButton
                {
                    FadeOut = uiAlertFade,
                    Button = { FadeIn = uiAlertFade, Color = "0 0 0 0", Close = templateParent, Command = "%COMMAND_NO%"},
                    Text = { FadeIn = uiAlertFade, Text = "", Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "0 0 0 0" },
                    RectTransform = { AnchorMin = "1 0.5", AnchorMax = "1 0.5", OffsetMin = "-23.589 -11.234", OffsetMax = "-1.028 11.198" }
                },templateParent,"Button_Setup_No", "Button_Setup_No");
                
                AddInterface(templateParent, container.ToJson());
            }
        }
		   		 		  						  	   		   		 		  			 		  	   		  				
        
                
                private static Configuration config = new Configuration();

        private const String effectSoundError = "assets/prefabs/weapons/toolgun/effects/repairerror.prefab";
        
        
        private void TeleportationHome(BasePlayer player, Vector3 position, BaseEntity pEntity)
        {
            if (!player.IsValid())
                return;

            String canTeleport = CanTeleportation(player, UserRepository.TeleportType.Home);
            if (!String.IsNullOrWhiteSpace(canTeleport))
            {
                SendChat(canTeleport, player, true);
                return;
            }
            
            localUsersRepository[player].SetupCooldown(player, UserRepository.TeleportType.Home);
            MovePlayer(player, position, pEntity, pEntity);
        }
        
        private readonly LayerMask homelayerMaskBuilding = LayerMask.GetMask("Construction"); 
        private const String effectSoundTeleport = "assets/prefabs/misc/halloween/lootbag/effects/loot_bag_upgrade.prefab";

        private String Format(Int32 units, String form1, String form2, String form3)
        {
            Int32 tmp = units % 10;

            if (units is >= 5 and <= 20 || tmp is >= 5 and <= 9 || tmp == 0)
                return $"{units}{form1}";

            return tmp is >= 2 and <= 4 ? $"{units}{form2}" : $"{units}{form3}";
        }
        
        
                
        private void ChatCommandTeleportationWarp(BasePlayer player, String cmd, String[] arg)
        {
            if (!config.warpsContoller.useWarps) return;
            if (!serverWarps.TryGetValue(cmd, out List<ServerWarp> warpPoints)) return;

            ServerWarp randomWarp = GetRandomWarp(warpPoints);
            if (randomWarp == null) return;
            Vector3 warpPoint = randomWarp.GetPositionWarp();
            if (warpPoint == default) return;
            RequestWarp(player, warpPoint);
        }
        
        private const Single checkIntervalPlayerTeleportation = 1f;
        public String GetLang(String LangKey, String userID = null, params Object[] args)
        {
            sb.Clear();
            if (args != null)
            {
                sb.AppendFormat(lang.GetMessage(LangKey, this, userID), args);
                return sb.ToString();
            }
            return lang.GetMessage(LangKey, this, userID);
        }
        private Dictionary<UInt64, TeleportationQueueInfo> playerTeleportationQueue = new();

                
        
        private void ClearQueue(BasePlayer player, BasePlayer targetPlayer)
        {
            if (player)
            {
                UserRepository pData = localUsersRepository[player];
                
                if(pData != null && pData.IsActiveTeleportation())
                    pData.DeActiveTeleportation();
            
                playerTeleportationQueue.Remove(player.userID);

                if (teleportationActions.TryGetValue(player, out Action action))
                {
                    player.CancelInvoke(action);
                    teleportationActions.Remove(player);
                }
            }
            
            if (targetPlayer)
            {
                UserRepository tData = localUsersRepository[targetPlayer];
                
                if(tData != null && tData.IsActiveTeleportation())
                    tData.DeActiveTeleportation();
                
                playerTeleportationQueue.Remove(targetPlayer.userID);
                
                if (teleportationActions.TryGetValue(targetPlayer, out Action actionTarget))
                {
                    targetPlayer.CancelInvoke(actionTarget);
                    teleportationActions.Remove(targetPlayer);
                }
            }
        }

        private enum TypeLog
        {
            RequestTeleportation,
            AcceptTeleportation,
            RequestHomeTeleportation,
        }
        private static InterfaceBuilder _interface;

        private void OnEntitySpawned(Tugboat tugboat)
        {
            if (tugboat == null) return;
            UInt64 netIDTugBoat = tugboat.net.ID.Value;
            
            tugboatsServer.TryAdd(netIDTugBoat, tugboat);
        }   


                
        private BuildingBlock GetBuildingBlock(in Vector3 position)
        {
            Vector3 rayOrigin = position  + Vector3.up; 
            Vector3 rayDirection = Vector3.down;
            
            if (!Physics.Raycast(rayOrigin, rayDirection, out RaycastHit hit, radiusCheckLayerHome, homelayerMaskBuilding)) return null;
            BuildingBlock buildingBlock = hit.GetEntity() as BuildingBlock;
        
            // if (buildingBlock == null)
            //     return null;

            return !IsValidPosOtherEntity(position, buildingBlock) ? null : buildingBlock;
        }
        private Dictionary<UInt64, Tugboat> tugboatsServer = new();
        private const String permissionTP = "iqteleportation.tp";

        [ConsoleCommand("home")]
        private void HomeConsoleCMD(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            if (arg.Args.Length == 0)
            {
                SendChat(GetLang("SYNTAX_COMMAND_HOME_TELEPORTATION", player.UserIDString), player, true);
                return;
            }

            RequestHome(player, arg.Args);
        }

        
                
        private IEnumerator ProcessTeleportation(BasePlayer player, Func<Boolean> additionalChecks, Action teleportationAction, Int32 timeTeleportation, BasePlayer targetPlayer = null)
        {
            Single elapsedTime = 0f;
            Single nextCheckTime = 0f;

            while (elapsedTime < timeTeleportation)
            {
                Single interval = !config.generalController.useSoundEffects ? 1f : (timeTeleportation - elapsedTime) switch
                {
                    >= 15 => 1.0f,
                    > 10 => 0.7f,
                    > 7 => 0.6f,
                    > 5 => 0.5f,
                    > 3 => 0.35f,
                    _ => 0.2f
                };
		   		 		  						  	   		   		 		  			 		  	   		  				
                if (elapsedTime >= nextCheckTime)
                {
                    if (!player)
                    {
                        ClearQueue(player, targetPlayer);
                        if (targetPlayer)
                            SendChat(GetLang("ACCESS_CANCELL_TELEPORTATION", targetPlayer.UserIDString, $"{GetLang("ACCESS_CANCELL_TELEPORTATION_DEAD_REQUESTER_DISCONNECTED", targetPlayer.UserIDString)}"), targetPlayer);
                        yield break;
                    }

                    if (player.IsDead())
                    {
                        ClearQueue(player, targetPlayer);
                        SendChat(GetLang("ACCESS_CANCELL_TELEPORTATION", player.UserIDString, $"{GetLang("ACCESS_CANCELL_TELEPORTATION_DEAD", player.UserIDString)}"), player);
                        if (targetPlayer)
                            SendChat(GetLang("ACCESS_CANCELL_TELEPORTATION", targetPlayer.UserIDString, $"{GetLang("ACCESS_CANCELL_TELEPORTATION_DEAD_REQUESTER_DEAD", targetPlayer.UserIDString)}"), targetPlayer);
                        yield break;
                    }
		   		 		  						  	   		   		 		  			 		  	   		  				
                    if (additionalChecks())
                        yield break;

                    nextCheckTime = elapsedTime + checkIntervalPlayerTeleportation;
                }

                RunEffect(player, effectSoundTimer);
                yield return new WaitForSeconds(interval);
                elapsedTime += interval;
            }

            teleportationAction();
        }

                private void SetHome(BasePlayer player, String homeName, SleepingBag bag = null)
        {
            homeName = homeName.ToLower();
            
            CheckAllHomes(player, homeName);

            Vector3 positionHome = player.transform.position;
            
            if (bag != null)
            {
                positionHome = bag.transform.position + new Vector3(0f, 0.5f, 0f);
                bag.niceName = homeName;
                bag.name = homeName;
                bag.SendNetworkUpdate();
            }
            
            BuildingBlock buildingBlock = GetBuildingBlock(positionHome);
            Tugboat tugboatEntity = player.GetParentEntity() as Tugboat;
            UInt64 netIdEntity = 0;
            
            if (tugboatEntity != null)
            {
                netIdEntity = tugboatEntity.net.ID.Value;
                positionHome = tugboatEntity.transform.InverseTransformPoint(positionHome);
            }
            
            String canSethome = CanSetHome(player, buildingBlock, homeName, positionHome, tugboatEntity);
            
            if (!String.IsNullOrWhiteSpace(canSethome))
            {
                SendChat(canSethome, player, true);
                return;
            }

            playerHomes[player.userID].Add(homeName, new PlayerHome()
            {
                netIdEntity = netIdEntity,
                positionHome = positionHome,
            });

            if (config.homeController.addedPingMarker)
                CreatePingPlayer(player, positionHome);

            if (config.homeController.addedMapMarkerHome)
                CreateMapMarkerPlayer(player, positionHome, homeName);
            
            SendChat(GetLang("ACCESS_SETUP_SETHOME", player.UserIDString, homeName), player);
            
            Interface.Call("OnHomeAdded", player, positionHome, homeName);
        }

        
        private void SendChat(String message, BasePlayer player, Boolean isError = false)
        {
            if (config.generalController.useOnlyGameTip)
                player.SendConsoleCommand("gametip.showtoast", new Object[]{ "1", message, "15" });
            else
            {
                if (IQChat)
                    IQChat?.Call("API_ALERT_PLAYER", player, message, config.generalController.iqchatSetting.customPrefix, config.generalController.iqchatSetting.customAvatar);
                else player.SendConsoleCommand("chat.add", Chat.ChatChannel.Global, 0, message);
            }

            RunEffect(player, isError ? effectSoundError : effectSoundAccess);
        }

        
        
        private void RequestHome(BasePlayer player, String[] arg)
        {
            String homeName = arg[0].ToLower();
            String friendNameOrID = arg.Length >= 2 ? arg[1] : String.Empty;
            
            String requestError = CanRequestTeleportHome(player, homeName, friendNameOrID, out UInt64 userIDFriend, out String friendName);
            if (!String.IsNullOrWhiteSpace(requestError))
            {
                SendChat(requestError, player, true);
                return;
            }
            
            Boolean isOtherID = userIDFriend != default && userIDFriend != player.userID;
            UInt64 userID = isOtherID ? userIDFriend : player.userID;

            PlayerHome pHome = playerHomes[userID][homeName];
            Int32 coutdownTeleportation = config.homeController.homeCountdown.GetCount(player);
            String formatCountdown = _.FormatTime(coutdownTeleportation, player.UserIDString);

            if (localUsersRepository[player].IsActiveTeleportation())
            {
                localUsersRepository[player].DeActiveTeleportation();
                SendChat(GetLang("ACCESS_CANCELL_TELEPORTATION_PLAYER", player.UserIDString), player); 
            }

            Int32 countdownTeleportation = config.homeController.homeCountdown.GetCount(player);
            Interface.Call("OnHomeAccepted", player, homeName, countdownTeleportation); 

            Coroutine routineTeleportation = ServerMgr.Instance.StartCoroutine(ProcessTHome(player, pHome, countdownTeleportation)); 
            localUsersRepository[player].ActiveCoroutineController(routineTeleportation);

            String resultMessage = !String.IsNullOrWhiteSpace(friendName) && isOtherID 
                ? GetLang("ACCESS_TELEPORTATION_HOME_FRIEND_NICK", player.UserIDString, friendName, homeName, formatCountdown)
                : String.IsNullOrWhiteSpace(friendName) && isOtherID
                    ? GetLang("ACCESS_TELEPORTATION_HOME_FRIEND", player.UserIDString, homeName, formatCountdown)
                    : GetLang("ACCESS_TELEPORTATION_HOME", player.UserIDString, homeName, formatCountdown);

            if (pHome.netIdEntity == 0)
                LogAction(player, TypeLog.RequestHomeTeleportation, default, pHome.positionHome, homeName);
            
            SendChat(resultMessage, player);
        }
        
        private String GetNextHomeName(Dictionary<String, PlayerHome> pData)
        {
            for (Int32 i = 1; i <= 99; i++)
            {
                String homeName = i.ToString();
        
                if (!pData.ContainsKey(homeName))
                    return homeName;
            }
    
            return null; 
        }

        
        
        private List<String> GetOrSetCacheUI(BasePlayer player, String additionalTitile, String interfaceJson = null)
        {
            String langKeyPlayer = lang.GetLanguage(player.UserIDString);
            String keyCache = $"{additionalTitile}_{langKeyPlayer}";

            if (cachedUI.TryGetValue(keyCache, out List<String> ui))
                return ui;

            if (interfaceJson == null) return null;

            List<String> newUI = new List<String> { interfaceJson };
            cachedUI[keyCache] = newUI;
            return newUI;
        }
        
        private ServerWarp GetRandomWarp(List<ServerWarp> warpList)
        {
            List<ServerWarp> warps = new List<ServerWarp>();
		   		 		  						  	   		   		 		  			 		  	   		  				
            foreach (ServerWarp serverWarp in warpList)
            {
                if (serverWarp.hideWarp) continue;
                warps.Add(serverWarp);
            }

            try
            {
                return warps.GetRandom();
            }
            finally
            {
                warps.Clear();
                warps = null;
            }
        }
        
        private static IQTeleportation _;
		   		 		  						  	   		   		 		  			 		  	   		  				
        private void RequestTeleportation(BasePlayer player, String[] arg)
        {
            String friendNameOrID = arg.Length >= 1 ? String.Join(" ", arg) : String.Empty;
            (BasePlayer, String) findInfo = new();
            
            BasePlayer targetPlayer;
            if (String.IsNullOrWhiteSpace(friendNameOrID))
            {
                casheTeleportationLast.TryGetValue(player, out BasePlayer oldPlayerTeleport);
                targetPlayer = oldPlayerTeleport; 
            }
            else
            {
                findInfo = FindPlayerNameOrID(player, friendNameOrID);
                targetPlayer = findInfo.Item1;
            }
            
            String requestError = CanRequestTeleportation(player, targetPlayer, findInfo.Item2);
            if (!String.IsNullOrWhiteSpace(requestError))
            {
                SendChat(requestError, player, true);
                return;
            }
            
            playerTeleportationQueue.TryAdd(targetPlayer.userID, new TeleportationQueueInfo
            {
                player = player,
                isActive = true,
                isAccepted = false
            });
            
            playerTeleportationQueue.TryAdd(player.userID, new TeleportationQueueInfo
            {
                player = targetPlayer,
                isActive = false,
                isAccepted = false
            });
            casheTeleportationLast[player] = targetPlayer;

            if (playerSettings[targetPlayer.userID].autoAcceptTeleportationFriends &&
                IsFriends(player, targetPlayer.userID))
            {
                if (!AcceptRequestTeleportation(targetPlayer, true))
                {
                    SendChat(GetLang("CAN_ACCEPT_TELEPORTATION_NOT_AUTO_ACCEPT", player.UserIDString), player);
                    ClearQueue(player, targetPlayer);
                    if (localUsersRepository[player].IsActiveTeleportation())
                        teleportationActions.Remove(player);
		   		 		  						  	   		   		 		  			 		  	   		  				
                    return;
                }
                SendChat(GetLang("CAN_ACCEPT_TELEPORTATION_YES_AUTO_ACCEPT", player.UserIDString), player);
            }
            else
            {
                if (config.teleportationController.teleportSetting.suggetionAcceptedUI)
                    DrawUI_TeleportPlayer(player, targetPlayer);

                SendChat(GetLang("CAN_REQUEST_TELEPORTATION_SEND", player.UserIDString, targetPlayer.displayName), player);
                SendChat(GetLang("CAN_REQUEST_TELEPORTATION_RECEIVE", targetPlayer.UserIDString, player.displayName), targetPlayer);
            }

            LogAction(player, TypeLog.RequestTeleportation, targetPlayer, default, default);

            Action teleportWaitAccept = () =>
            {
                if (localUsersRepository[player].IsActiveTeleportation())
                {
                    teleportationActions.Remove(player);
                    return;
                }
                
                ClearQueue(player, targetPlayer);
                SendChat(GetLang("CAN_TELEPORT_REQUEST_EXPIRED", player.UserIDString), player);
                SendChat(GetLang("CAN_TELEPORT_REQUEST_EXPIRED", targetPlayer.UserIDString), targetPlayer); 
            };

            teleportationActions[player] = teleportWaitAccept;
            
            player.Invoke(teleportWaitAccept, 15f);
        }
        
        private const String homeLog = LanguageEn ? "" : "отправился на точку дома";
        
        private void OnEntitySpawneds(AutoTurret turret)
        {
            if (turret == null) return;
            if(ItemIdCorrecteds.Contains(turret.net.ID.Value))
                turretsEx.TryAdd(turret.net.ID.Value, turret);
        }

        
        
        
        [ChatCommand("atp")]
        private void AutoAcceptTeleportChatCmd(BasePlayer player) => AutoTeleportTurn(player);

            }
}


// --- End of file: IQTeleportation-1.5.7.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/RPGFarm.cs ---
// --- Original Local Path: RPGFarm.cs ---

using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
namespace Oxide.Plugins
{
    [Info("RPGFarm", "Replace ServerRust", "0.1.1")]
    public class RPGFarm : RustPlugin
    {
        private static readonly string _permissionMax = "rpgfarm.max";


        Dictionary<ulong, string> playerResolution = new Dictionary<ulong, string>();


        readonly DynamicConfigFile dataFile = Interface.Oxide.DataFileSystem.GetFile("RPGFarm");

        Dictionary<ulong, UserStats> userStats;

        Dictionary<Skills, double> MaxRate = new Dictionary<Skills, double>
        {
            {Skills.Cutting, 10.0},
            {Skills.Mining, 10.0},
            {Skills.Skinning, 10.0}
        };

        Dictionary<Skills, int> MaxHits = new Dictionary<Skills, int>
        {
            {Skills.Cutting, 3000},
            {Skills.Mining, 2000},
            {Skills.Skinning, 1000}
        };

        Dictionary<Skills, string> SkillTranslate = new Dictionary<Skills, string>
        {
            {Skills.Cutting, "Дровосек"},
            {Skills.Mining, "Рудокоп"},
            {Skills.Skinning, "Охотник"}
        };

        Dictionary<Skills, string> skillColors = new Dictionary<Skills, string>
        {
            {Skills.Cutting, "0 0.6 1 0.8"},
            {Skills.Mining, "0.95 0.75 0.05 0.8"},
            {Skills.Skinning, "0.5 0.75 0 0.8"}
        };

        enum Skills
        {
            Cutting,
            Mining,
            Skinning
        }

        class UserStats
        {
            public Dictionary<Skills, int> Hits = new Dictionary<Skills, int>
            {
                {Skills.Cutting, 0},
                {Skills.Mining, 0},
                {Skills.Skinning, 0}
            };
        }

        private void OnServerInitialized()
        {
            permission.RegisterPermission(_permissionMax, this);
        }

        void Loaded()
        {

            try
            {
                userStats = dataFile.ReadObject<Dictionary<ulong, UserStats>>();
            }
            catch
            {
                userStats = new Dictionary<ulong, UserStats>();
            }



            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                OnPlayerConnected(player);
            }
        }

        void Unload()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, "StatsUI");
            }

            dataFile.WriteObject(userStats);
        }

        void OnServerSave()
        {
            dataFile.WriteObject(userStats);
        }

        void OnPlayerConnected(BasePlayer player)
        {
            if (player == null)
                return;

            if (player.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot))
            {
                timer.Once(2, () => OnPlayerConnected(player));
                return;
            }

            UserStats stats;

            if (!userStats.TryGetValue(player.userID, out stats))
            {
                userStats.Add(player.userID, new UserStats()); // #2 stats ?
            }

            if (permission.UserHasPermission(player.UserIDString, _permissionMax))
            {
                stats.Hits[Skills.Cutting] = MaxHits[Skills.Cutting];
                stats.Hits[Skills.Mining] = MaxHits[Skills.Mining];
                stats.Hits[Skills.Skinning] = MaxHits[Skills.Skinning];
            }
            RenderUI(player);
        }

        void OnUserPermissionGranted(string id, string perm)
        {
            if (perm == _permissionMax)
            {
                ulong userId = Convert.ToUInt64(id);

                UserStats stats; 

                if (userStats.TryGetValue(userId, out stats))
                {
                    stats.Hits[Skills.Cutting] = MaxHits[Skills.Cutting];
                    stats.Hits[Skills.Mining] = MaxHits[Skills.Mining];
                    stats.Hits[Skills.Skinning] = MaxHits[Skills.Skinning];

                    BasePlayer targetPlayer = BasePlayer.FindByID(userId);

                    if (targetPlayer != null)
                    {
                        if (targetPlayer.IsConnected)
                        {
                            RenderUI(targetPlayer);
                            SendReply(targetPlayer, "Вы подключили услугу «Полная прокачка RPG».");
                        }
                    }
                }
            }
        }

        void OnUserPermissionRevoked(string id, string perm)
        {
            if (perm == _permissionMax)
            {
                ulong userId = Convert.ToUInt64(id);
                UserStats stats;
                if (userStats.TryGetValue(userId, out stats))
                {
                    stats.Hits[Skills.Cutting] = 0;
                    stats.Hits[Skills.Mining] = 0;
                    stats.Hits[Skills.Skinning] = 0;

                    BasePlayer targetPlayer = BasePlayer.FindByID(userId);

                    if (targetPlayer != null)
                    {
                        if (targetPlayer.IsConnected)
                        {
                            RenderUI(targetPlayer);
                            SendReply(targetPlayer, "Срок действия услуги «Полная прокачка RPG» истек, продлите услугу.");
                        }
                    }
                }
            }
        }

        void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            BasePlayer player = entity as BasePlayer;
            if (player == null) return;

            switch ((int)dispenser.gatherType)
            {
                case 0:
                    RateHandler(player, item, Skills.Cutting);
                    break;
                case 1:
                    RateHandler(player, item, Skills.Mining);
                    break;
                case 2:
                    RateHandler(player, item, Skills.Skinning);
                    break;
            }
        }

        private void OnQuarryGather(MiningQuarry quarry, Item item)
        {
            if (userStats.Keys.Contains(quarry.OwnerID))
                item.amount = (int)(item.amount * GetCurrentRate(Skills.Mining, userStats[quarry.OwnerID].Hits[Skills.Mining]));
        }

        void OnCollectiblePickup(Item item, BasePlayer player)
        {
            switch (item.info.shortname.ToLower())
            {
                case "wood":
                    RateHandler(player, item, Skills.Cutting);
                    break;
                case "cloth":
                case "mushroom":
                case "corn":
                case "pumpkin":
                case "seed.pumpkin":
                case "seed.corn":
                    RateHandler(player, item, Skills.Skinning);
                    break;
                case "metal.ore":
                case "sulfur.ore":
                case "stones":
                    RateHandler(player, item, Skills.Mining);
                    break;
                default:
                    //Puts("Developer missed this item, which can be picked up: [" + item.info.shortname + "]. Let him know on Oxide forums!");
                    break;
            }
        }

        void RateHandler(BasePlayer player, Item item, Skills skill)
        {
            double oldRate = GetCurrentRate(skill, userStats[player.userID].Hits[skill]);
            double newRate = GetCurrentRate(skill, ++userStats[player.userID].Hits[skill]);

            item.amount = (int)(item.amount * newRate);

            if (oldRate != newRate)
                RenderUI(player);
        }

        private void RenderUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "StatsUI");



            var elements = new CuiElementContainer();

            var mainName = elements.Add(new CuiPanel
            {
                Image =
                {
                    Color = "0 0 0 0"
                },
                RectTransform =
                {
                    AnchorMin = "0.009 0.022",
                    AnchorMax = "0.1585 0.136"
                }
            }, "Hud", "StatsUI");

            int fontSize = 12;

            int SkillCount = Enum.GetValues(typeof(Skills)).Length;

            foreach (Skills skill in Enum.GetValues(typeof(Skills))) // rev — from end
            {
                FillElements(elements, skill, mainName, (int)skill + 1, SkillCount, userStats[player.userID], fontSize);
            }

            CuiHelper.AddUi(player, elements);
        }

        private void FillElements(CuiElementContainer elements, Skills skill, string mainPanel, int rowNumber, int maxRows, UserStats stats, int fontSize)
        {
            int percent = GetCurrentPercent(skill, stats.Hits[skill]);

            float value = 1 / (float)maxRows;

            float positionMin = 1 - (value * rowNumber); // xp line size
            float positionMax = 2 - (1 - (value * (1 - rowNumber)));

            var xpBarPlaceholder1 = new CuiElement
            {
                Name = CuiHelper.GetGuid(),
                Parent = mainPanel,
                Components =
                {
                    new CuiImageComponent { Color = "1 0.95 0.875 0.025" },
                    new CuiRectTransformComponent{ AnchorMin = "0 " + positionMin.ToString("0.####"), AnchorMax = "1 " + positionMax.ToString("0.####") }
                }
            };
            elements.Add(xpBarPlaceholder1);

            var innerXPBar1 = new CuiElement
            {
                Name = CuiHelper.GetGuid(),
                Parent = xpBarPlaceholder1.Name,
                Components =
                        {
                            new CuiImageComponent { Color = "0 0 0 0"},
                            new CuiRectTransformComponent{ AnchorMin = "0.02 0.12", AnchorMax = "0.97 0.8" }
                        }
            };
            elements.Add(innerXPBar1);

            if (percent != 0)
            {
                var innerXPBarProgress1 = new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = innerXPBar1.Name,
                    Components =
                        {
                            new CuiImageComponent() { Color = skillColors[skill]},
                            new CuiRectTransformComponent{ AnchorMin = "0 0", AnchorMax = (percent / 100.0).ToString() + " 1" }
                        }
                };
                elements.Add(innerXPBarProgress1);
            }

            var innerXPBarText1 = new CuiElement
            {
                Name = CuiHelper.GetGuid(),
                Parent = innerXPBar1.Name,
                Components =
                        {
                            new CuiTextComponent { Color = "1 1 1 1", Text = SkillTranslate[skill], FontSize = fontSize, Align = TextAnchor.MiddleCenter},
                            new CuiRectTransformComponent{ AnchorMin = "0 0", AnchorMax = "1 1" }
                        }
            };
            elements.Add(innerXPBarText1);

            var xpText1 = new CuiElement
            {
                Name = CuiHelper.GetGuid(),
                Parent = innerXPBar1.Name,
                Components =
                        {
                            new CuiTextComponent { Text = percent + "%", FontSize = fontSize, Align = TextAnchor.MiddleRight, Color = "1 1 1 1" },
                            new CuiRectTransformComponent{ AnchorMin = "0 0", AnchorMax = "0.98 1" }
                        }
            };
            elements.Add(xpText1);

            var lvText1 = new CuiElement
            {
                Name = CuiHelper.GetGuid(),
                Parent = innerXPBar1.Name,
                Components =
                        {
                            new CuiTextComponent { Text = "x" + GetCurrentRate(skill, stats.Hits[skill])  + "/x" + MaxRate[skill], FontSize = fontSize, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                            new CuiRectTransformComponent{ AnchorMin = "0.01 0", AnchorMax = "0.5 1" }
                        }
            };
            elements.Add(lvText1);
        }

        double GetCurrentRate(Skills skill, int Hits)
        {
            return Math.Round(1 + (MaxRate[skill] - 1) / MaxHits[skill] * Math.Min(Hits, MaxHits[skill]), 2); // стоит проверить правильность конвертации
        }

        int GetCurrentPercent(Skills skill, int Hits)
        {
            if (Hits == 0) return 0;
            return Convert.ToInt32((float)Math.Min(Hits, MaxHits[skill]) / MaxHits[skill] * 100);
        }

        int GetLeftHits(Skills skill, int Hits)
        {
            return Math.Max(MaxHits[skill] - Hits, -1);
        }
    }
}

// --- End of file: RPGFarm.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BrokenItemsCleaner.cs ---
// --- Original Local Path: BrokenItemsCleaner.cs ---

//#define TESTING
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using JetBrains.Annotations;
using UnityEngine;
using Debug = UnityEngine.Debug;

namespace Oxide.Plugins
{
    [Info("BrokenItemsCleaner", "EcoSmile/Vlad-00003", "1.3.5")]
    public class BrokenItemsCleaner : RustPlugin
    {
        [PluginReference("Backpacks")]
        private RustPlugin Backpacks;

        private Coroutine _cleanup;
        private CleanupData _cleanupData;

        private void Loaded()
        {
            _cleanupData = new CleanupData();
#if TESTING
            StopwatchWrapper.OnComplete = DebugMessage;
#endif
        }

        private void OnServerSave()
        {
            if(ServerMgr.Instance.IsInvoking(OnServerSave))
                ServerMgr.Instance.CancelInvoke(OnServerSave);

            if (_cleanup != null || SaveRestore.IsSaving)
            {
                ServerMgr.Instance.Invoke(OnServerSave, 5f);
                return;
            }

            _cleanup = ServerMgr.Instance.StartCoroutine(PreformCleanup());
        }
        
        private void Unload()
        {
            if (ServerMgr.Instance == null)
                return;
            ServerMgr.Instance.CancelInvoke(OnServerSave);

            if (_cleanup == null)
                return;
            ServerMgr.Instance.StopCoroutine(_cleanup);
            _cleanupData.Clear();
        }


        #region CleanupData

        private class CleanupData
        {
            private readonly Stopwatch _stopwatch = new Stopwatch();
            public readonly HashSet<ulong> HeldEntities = new HashSet<ulong>();
            public readonly Dictionary<ulong, Item[]> Items = new Dictionary<ulong, Item[]>();
            public int Removed;
            public int Repaired;

            public void Add(IItemGetter selector, BaseNetworkable[] array)
            {
                foreach (var entity in selector.Entities(array))
                {
                    if(!entity)
                        continue;
                    var items = selector.GetItems(entity);
                    if (items != null)
                        Items[entity.net.ID] = items.ToArray();
                }
            }

            public void Add(ulong userId, ItemContainer container)
            {
                var items = container?.itemList;
                if (items != null)
                    Items[userId] = items.ToArray();
            }

            public bool InvalidOrListed(HeldEntity entity)
            {
                return !entity || !entity.IsValid() || HeldEntities.Contains(entity.net.ID);
            }

            public void Clear()
            {
                HeldEntities.Clear();
                Items.Clear();
                Repaired = 0;
                Removed = 0;
            }

            public void StartNew()
            {
                _stopwatch.Restart();
            }

            public void Stop()
            {
                _stopwatch.Stop();
            }

            public override string ToString()
            {
                return $"Предметов удалено/Entity Removed: {Removed}\n" +
                       $"Предметов восстановлено/Entity Repaired: {Repaired}\n" +
                       $"Очистка заняла/Cleanup took:{_stopwatch.ElapsedMilliseconds}\n";
            }
        }

        #endregion

        #region Cleanup

        #region ItemGetter

        private interface IItemGetter
        {
            string TypeName { get; }
            IEnumerable<Item> GetItems(BaseNetworkable obj);
            IEnumerable<BaseNetworkable> Entities(BaseNetworkable[] array);
        }

        private class ItemGetter<T> : IItemGetter where T : BaseNetworkable
        {
            private readonly Func<T, IEnumerable<Item>> _getter;

            public ItemGetter(Func<T, IEnumerable<Item>> getter)
            {
                _getter = getter;
                TypeName = typeof(T).FullName;
            }

            [CanBeNull]
            public IEnumerable<Item> GetItems(BaseNetworkable obj)
            {
                IEnumerable<Item> result;
                try
                {
                    result = _getter(obj as T);
                }
                catch (Exception e)
                {
#if TESTING
                    Debug.LogErrorFormat("Can't get items from {0}",obj);
                    Debug.LogException(e);
#endif
                    return null;
                }

                return result;
            }

            public IEnumerable<BaseNetworkable> Entities(BaseNetworkable[] array)
            {
                return array.OfType<T>();
            }

            public string TypeName { get; }
        }

        #endregion


        private static readonly List<IItemGetter> ItemGetters = new List<IItemGetter>
        {
            new ItemGetter<StorageContainer>(x => x.inventory?.itemList),
            new ItemGetter<LootableCorpse>(x => x.containers?.SelectMany(y => y?.itemList)),
            new ItemGetter<DroppedItemContainer>(x => x.inventory?.itemList),
            new ItemGetter<ContainerIOEntity>(x => x.inventory?.itemList),
            new ItemGetter<BaseRidableAnimal>(x => x.inventory?.itemList),
            new ItemGetter<DroppedItem>(x => new[] {x.item}),
            new ItemGetter<BasePlayer>(x => x.inventory?.AllItems())
        };


        private void CheckLost(IEnumerable<Item> items)
        {
            foreach (var item in items)
            {
                if (item?.IsValid() != true)
                    continue;

                var held = item.GetHeldEntity() as HeldEntity;
                if (held?.IsValid() == true)
                {
                    _cleanupData.HeldEntities.Add(held.net.ID);
                    continue;
                }

                item.OnItemCreated();
                item.MarkDirty();
                held = item.GetHeldEntity() as HeldEntity;
                if (held?.IsValid() == true)
                {
                    _cleanupData.HeldEntities.Add(held.net.ID);
                    _cleanupData.Repaired++;
                }
            }
        }

        private IEnumerator PreformCleanup()
        {
            var enumerator = ActualCleanup();
            while (true)
            {
                object current;
                try
                {
                    if (enumerator.MoveNext() == false)
                        break;
                    current = enumerator.Current;
                }
                catch (Exception ex)
                {
                    OnCleanupComplete(ex);
                    yield break;
                }
                yield return current;
            }

            OnCleanupComplete();
        }

        private void OnCleanupComplete(Exception ex = null)
        {
            if (ex != null)
            {
                Debug.LogException(ex);
                PrintError("При очистке возникло исключение/Exception during cleanup:\n{0}",ex);
            }
            PrintWarning($"Очистка завершена/Cleanup Completed:\n{_cleanupData}");
            _cleanupData.Clear();
            _cleanup = null;
        }

        private IEnumerator ActualCleanup()
        {
            yield return CoroutineEx.waitForSeconds(2);

            PrintWarning("Очистка запущена/Cleaning started");

            var array = BaseNetworkable.serverEntities.Where(x=>!(x is MixingTable)).ToArray();
            yield return null;

            _cleanupData.StartNew();

            foreach (var itemGetter in ItemGetters)
            {
#if TESTING
                using (new StopwatchWrapper($"Lookup for items in entities of type {itemGetter.TypeName} took {{0}}ms."))
#endif
                {
                    _cleanupData.Add(itemGetter, array);
                }
            }
            yield return CoroutineEx.waitForEndOfFrame;
            //Backpacks workaround
#if TESTING
            using (new StopwatchWrapper($"Getting all items from existing backpacks took {{0}}ms."))
#endif
            {
                var backpacks = Backpacks?.CallHook("API_GetExistingBackpacks") as Dictionary<ulong, ItemContainer>;
                if (backpacks != null)
                {
                    foreach (var backpack in backpacks)
                    {
                        _cleanupData.Add(backpack.Key,backpack.Value);
                    }
                }
            }
            yield return CoroutineEx.waitForEndOfFrame;

#if TESTING
            using (new StopwatchWrapper("Checking all items took {0}ms."))
#endif
            {
                foreach (var item in _cleanupData.Items)
                {
                    CheckLost(item.Value);
                    yield return CoroutineEx.waitForEndOfFrame;
                }
            }

#if TESTING
            var text = "";
            using (new StopwatchWrapper("Clearing leftover HeldEntities took {0}ms."))
#endif
            {
                foreach (var entity in array.OfType<HeldEntity>())
                {
                    if (_cleanupData.InvalidOrListed(entity))
                        continue;
#if TESTING
                    var parentEntity = entity.GetParentEntity();
                    text +=
                        $"Removing entity {entity}, parent: {(parentEntity == null ? "null" : parentEntity.ToString())}, ";
#endif
                    entity.Kill();
#if TESTING
                    text += $"removed? {entity.IsDestroyed}\n";
#endif
                    _cleanupData.Removed++;
                    yield return null;
                }
            }
#if TESTING
            LogToFile("DeletedItems", text, this);
#endif
            _cleanupData.Stop();
            yield return null;
        }

        #endregion

        #region Testing functions

#if TESTING
        private void DebugMessage(string format, long time)
        {
            PrintWarning(format, time);
        }

        private class StopwatchWrapper : IDisposable
        {
            public StopwatchWrapper(string format)
            {
                Sw = new Stopwatch();
                Sw.Start();
                Format = format;
            }

            public static Action<string, long> OnComplete { private get; set; }

            private string Format { get; }
            private Stopwatch Sw { get; }

            public long Time { get; private set; }

            public void Dispose()
            {
                Sw.Stop();
                Time = Sw.ElapsedMilliseconds;
                OnComplete(Format, Time);
            }
        }

#endif

        #endregion
    }
}

// --- End of file: BrokenItemsCleaner.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Plagued.cs ---
// --- Original Local Path: Plagued.cs ---

using System.Reflection;
using System.Collections.Generic;
using System;

using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using Oxide.Ext.SQLite;

using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Plagued", "Wernesgruner", "0.3.3")]
    [Description("Everyone is infected.")]

    class Plagued : RustPlugin
    {
        private static int plagueRange = 20;
        private static int plagueIncreaseRate = 5;
        private static int plagueDecreaseRate = 1;
        private static int plagueMinAffinity = 6000;
        private static int affinityIncRate = 10;
        private static int affinityDecRate = 1;
        private static int maxKin = 2;
        private static int maxKinChanges = 3;
        private static int playerLayer;
        private static bool disableSleeperAffinity = false;

        private readonly FieldInfo serverinput = typeof(BasePlayer).GetField("serverInput", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));

        // Get the buffer size from the Vis class using relfection. It should always be 8ko, but it might change in the future
        private static readonly Collider[] colBuffer = (Collider[])typeof(Vis).GetField("colBuffer", (BindingFlags.Static | BindingFlags.NonPublic)).GetValue(null);

        //
        private Dictionary<ulong, PlayerState> playerStates;

        #region Hooks
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file (Plagued Mod)");

            Config.Clear();
            Config["plagueRange"] = 20;
            Config["plagueIncreaseRate"] = 5;
            Config["plagueDecreaseRate"] = 1;
            Config["plagueMinAffinity"] = 6000;
            Config["affinityIncRate"] = 10;
            Config["affinityDecRate"] = 1;
            Config["maxKin"] = 2;
            Config["maxKinChanges"] = 3;
            Config["disableSleeperAffinity"] = false;

            SaveConfig();
        }

        void Unload()
        {
            PlayerState.closeDatabase();
        }

        void OnServerInitialized()
        {
            PlayerState.setupDatabase(this);
            // Set the layer that will be used in the radius search. We only want human players in this case
            playerLayer = LayerMask.GetMask("Player (Server)");

            // Reload the player states
            playerStates = new Dictionary<ulong, PlayerState>();
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                playerStates.Add(player.userID, new PlayerState(player, null));
            }
            
            plagueRange = (int) Config["plagueRange"];
            plagueIncreaseRate = (int) Config["plagueIncreaseRate"];
            plagueDecreaseRate = (int) Config["plagueDecreaseRate"];
            plagueMinAffinity = (int) Config["plagueMinAffinity"];
            affinityIncRate = (int) Config["affinityIncRate"];
            affinityDecRate = (int) Config["affinityDecRate"];
            maxKin = (int) Config["maxKin"];
            maxKinChanges = (int) Config["maxKinChanges"];
            disableSleeperAffinity = (bool) Config["disableSleeperAffinity"];
        }

        void OnPlayerInit(BasePlayer player)
        {
            // Add the player to the player state list
            if (!playerStates.ContainsKey(player.userID))
            {
                PlayerState state = new PlayerState(player, stateRef => {
                    // The player was loaded in the current game session
                    playerStates.Add(player.userID, stateRef);
                    SendReply(player, "Welcome to plagued mod. Try the <color=#81F781>/plagued</color> command for more information.");
                    Puts(player.displayName + " has been plagued!");

                    // Add the proximity detector to the player
                    player.gameObject.AddComponent<ProximityDetector>();

                    return true;
                });
            } else
            {
                // Add the proximity detector to the player
                player.gameObject.AddComponent<ProximityDetector>();
            }
        }

        void OnPlayerDisconnected(BasePlayer player)
        {
            ProximityDetector proximityDetector = player.gameObject.GetComponent<ProximityDetector>();
            proximityDetector.disableProximityCheck();
            //Puts(player.displayName + " is no longer watched!");
        }

        void OnRunPlayerMetabolism(PlayerMetabolism metabolism)
        {
            // 0 - 1000 -> Decreased Health Regen
            // 1000 - 2000 -> Increased hunger
            // 2000 - 3000 -> Increased thirst
            // 3000 - 4000 -> No Health Regen
            // 4000 - 5000 -> No comfort
            // 5000 - 6000 -> Increased Hunger 2
            // 6000 - 7000 -> Increased Thirst 2
            // 7000 - 8000 -> Cold
            // 8000 - 9000 -> Bleeding
            // 9000+ -> Poison

            /*
             * -- ----------------------------
             * -- Rust default rates
             * -- ----------------------------
             * -- healthgain = 0.03
             * -- caloriesloss = 0 - 0.05
             * -- hydrationloss = 0 - 0.025
             * -- ----------------------------
             */
            BasePlayer player = metabolism.GetComponent<BasePlayer>();
            PlayerState state = playerStates[player.userID];
            int plagueLevel = state.getPlagueLevel();
            float defaultHealthGain = 0.03f;
            float defaultCaloriesLoss = 0.05f;
            float defaultHydrationLoss = 0.025f;


            //Interface.Oxide.LogInfo("Infection stage " + (plagueLevel / 1000).ToString());

            if (plagueLevel == 0) return;

            if (plagueLevel <= 1) return;
            //Interface.Oxide.LogInfo("Infection stage 1 " + player.displayName + " " + player.userID);
            metabolism.pending_health.value = metabolism.pending_health.value + (defaultHealthGain / 2f);

            if (plagueLevel <= 1000) return;
            //Interface.Oxide.LogInfo("Infection stage 2");
            metabolism.calories.value = metabolism.calories.value - ((defaultCaloriesLoss * 3f) + (metabolism.heartrate.value / 10f));

            if (plagueLevel <= 2000) return;
            //Interface.Oxide.LogInfo("Infection stage 3");
            metabolism.hydration.value = metabolism.hydration.value - ((defaultHydrationLoss * 3f) + (metabolism.heartrate.value / 10f));

            if (plagueLevel <= 3000) return;
            metabolism.pending_health.value = metabolism.pending_health.value - (defaultHealthGain / 2f);

            if (plagueLevel <= 4000) return;
            //Interface.Oxide.LogInfo("Infection stage 5");
            metabolism.comfort.value = -1;

            if (plagueLevel <= 5000) return;
            //Interface.Oxide.LogInfo("Infection stage 6");
            metabolism.calories.value = metabolism.calories.value - ((defaultCaloriesLoss * 5f) + (metabolism.heartrate.value / 10f));

            if (plagueLevel <= 6000) return;
            //Interface.Oxide.LogInfo("Infection stage 7");
            metabolism.hydration.value = metabolism.hydration.value - ((defaultHydrationLoss * 5f) + (metabolism.heartrate.value / 10f));

            if (plagueLevel <= 7000) return;
            ///Interface.Oxide.LogInfo("Infection stage 8");
            metabolism.temperature.value = metabolism.temperature.value - 0.05f;

            if (plagueLevel <= 8000) return;
            //Interface.Oxide.LogInfo("Infection stage 9");
            metabolism.bleeding.value = metabolism.bleeding.value + 0.2f;

            if (plagueLevel < 10000) return;
            //Interface.Oxide.LogInfo("Infection stage 10");
            metabolism.poison.value = 2;
        }

        void OnPlayerProximity(BasePlayer player, BasePlayer[] players)
        {
            if (playerStates.ContainsKey(player.userID))
            {
                playerStates[player.userID].increasePlaguePenalty(players);
                //Puts(player.displayName + " is close to " + (players.Length - 1).ToString() + " other players!");
            }
        }

        void OnPlayerAlone(BasePlayer player)
        {
            //Puts("OnPlayerAlone: "+ player.userID);
            if (playerStates.ContainsKey(player.userID))
            {
                playerStates[player.userID].decreasePlaguePenalty();
            }
        }
        #endregion

        #region Commands
        [ChatCommand("plagued")]
        void cmdPlagued(BasePlayer player, string command, string[] args)
        {
            if (args.Length == 0)
            {
                SendReply(player, "<color=#81F781>/plagued addkin</color> => <color=#D8D8D8> Add the player you are looking at to your kin list.</color>");
                SendReply(player, "<color=#81F781>/plagued delkin</color> => <color=#D8D8D8> Remove the player you are looking at from your kin list.</color>");
                SendReply(player, "<color=#81F781>/plagued delkin</color> <color=#F2F5A9> number </color> => <color=#D8D8D8> Remove a player from your kin list by kin number.</color>");
                SendReply(player, "<color=#81F781>/plagued lskin</color> => <color=#D8D8D8> Display your kin list.</color>");
                SendReply(player, "<color=#81F781>/plagued lsassociates</color> => <color=#D8D8D8> Display your associates list.</color>");
                SendReply(player, "<color=#81F781>/plagued info</color> => <color=#D8D8D8> Display information about the workings of this mod.</color>");

                return;
            }

            if (args.Length >= 1)
            {
                switch (args[0])
                {
                    case "addkin":
                        cmdAddKin(player);
                        break;
                    case "delkin":
                        if (args.Length == 2)
                        {
                            int position;
                            if (int.TryParse(args[1], out position))
                            {
                                cmdDelKin(player, position);
                            }
                            else
                            {
                                SendReply(player, "Kin position must be a valid number!");
                            }
                        } else
                        {
                            cmdDelKin(player);
                        }
                        break;
                    case "lskin":
                        cmdListKin(player);
                        break;
                    case "lsassociates":
                        cmdListAssociates(player);
                        break;
                    case "info":
                        cmdInfo(player);
                        break;
                    default:
                        SendReply(player, "Invalid Plagued mod command.");
                        break;
                }
            }
        }

        private void cmdAddKin(BasePlayer player)
        {
            BasePlayer targetPlayer;

            if (getPlayerLookedAt(player, out targetPlayer))
            {
                PlayerState state = playerStates[player.userID];
                PlayerState targetPlayerState = playerStates[targetPlayer.userID];

                if (state.isKinByUserID(targetPlayer.userID))
                {
                    SendReply(player, targetPlayer.displayName + " is already your kin!");
                    return;
                }

                if (state.hasKinRequest(targetPlayer.userID))
                {
                    state.addKin(targetPlayer.userID);
                    targetPlayerState.addKin(player.userID);
                    SendReply(player, "You are now kin with " + targetPlayer.displayName + "!");
                    SendReply(targetPlayer, "You are now kin with " + player.displayName + "!");

                    return;
                } else
                {
                    targetPlayerState.addKinRequest(player.userID);
                    SendReply(player, "You have requested to be " + targetPlayer.displayName + "'s kin!");
                    SendReply(targetPlayer, player.displayName + " has requested to be your kin. Add him back to become kin!");

                    return;
                }

                SendReply(player, targetPlayer.displayName + " could not be added to kin!");
            }

        }

        private bool cmdDelKin(BasePlayer player)
        {
            BasePlayer targetPlayer;

            if (getPlayerLookedAt(player, out targetPlayer))
            {
                PlayerState state = playerStates[player.userID];
                PlayerState targetPlayerState = playerStates[targetPlayer.userID];

                if (!state.isKinByUserID(targetPlayer.userID))
                {
                    SendReply(player, targetPlayer.displayName + " is not your kin!");

                    return false;
                }

                if (state.removeKin(targetPlayer.userID) && targetPlayerState.forceRemoveKin(player.userID))
                {
                    SendReply(player, targetPlayer.displayName + " was removed from you kin list!");
                    SendReply(targetPlayer, player.displayName + " was removed from you kin list!");

                    return true;
                }

                SendReply(player, targetPlayer.displayName + " could not be removed from kin list (Exceeded max kin changes per restart)!");
            }

            return false;
        }

        private bool cmdDelKin(BasePlayer player, int id)
        {
            PlayerState state = playerStates[player.userID];

            if (state.removeKinById(id))
            {
                foreach(var item in playerStates)
                {
                    if (item.Value.getId() == id)
                    {
                        item.Value.forceRemoveKin(player.userID);
                    }
                }
                SendReply(player, "Successfully removed kin.");
            } else
            {
                SendReply(player, "Could not remove kin.");
            }
            
            return false;
        }

        private void cmdListKin(BasePlayer player)
        {
            List<string> kinList = playerStates[player.userID].getKinList();

            displayList(player, "Kin", kinList);
        }

        private void cmdListAssociates(BasePlayer player)
        {
            List<string> associatesList = playerStates[player.userID].getAssociatesList();
            displayList(player, "Associates", associatesList);
        }

        private bool cmdInfo(BasePlayer player)
        {
            SendReply(player, " ===== Plagued mod ======");
            SendReply(player, "An unknown airborne pathogen has decimated most of the population. You find yourself on a deserted island, lucky to be among the few survivors. But the biological apocalypse is far from being over. It seems that the virus starts to express itself when certain hormonal changes are triggered by highly social behaviors. It has been noted that small groups of survivor seems to be relatively unaffected, but there isn't one single town or clan that wasn't decimated.");
            SendReply(player, "Workings: \n The longer you hang around others, the sicker you'll get. However, your kin are unaffected, add your friends as kin and you will be able to collaborate. Choose your kin wisely, there are no big families in this world.");
            SendReply(player, "Settings: \n > Max kin : " + maxKin.ToString() + "\n" + " > Max kin changes / Restart : " + maxKinChanges.ToString());

            return false;
        }

        #endregion

        #region Helpers
        public static void MsgPlayer(BasePlayer player, string format, params object[] args)
        {
            if (player?.net != null) player.SendConsoleCommand("chat.add", 0, args.Length > 0 ? string.Format(format, args) : format, 1f);
        }

        public void displayList(BasePlayer player, string listName, List<string> stringList)
        {
            if (stringList.Count == 0)
            {
                SendReply(player, "You have no "+ listName.ToLower()+".");
                return;
            }

            string answerMsg = listName + " list: \n";

            foreach (string text in stringList)
            {
                answerMsg += "> " + text + "\n";
            }

            SendReply(player, answerMsg);
        }

        #endregion

        #region Geometry

        private bool getPlayerLookedAt(BasePlayer player, out BasePlayer targetPlayer)
        {
            targetPlayer = null;

            Quaternion currentRot;
            if (!TryGetPlayerView(player, out currentRot))
            {
                SendReply(player, "Couldn't get player rotation");
                return false;
            }

            object closestEnt;
            Vector3 closestHitpoint;
            if (!TryGetClosestRayPoint(player.transform.position, currentRot, out closestEnt, out closestHitpoint)) return false;
            targetPlayer = ((Collider)closestEnt).GetComponentInParent<BasePlayer>();

            if (targetPlayer == null)
            {
                SendReply(player, "You aren't looking at a player");
                return false;
            }

            return true;
        }

        private bool TryGetClosestRayPoint(Vector3 sourcePos, Quaternion sourceDir, out object closestEnt, out Vector3 closestHitpoint)
        {
            /**
             * Credit: Nogrod (HumanNPC)
             */
            Vector3 sourceEye = sourcePos + new Vector3(0f, 1.5f, 0f);
            Ray ray = new Ray(sourceEye, sourceDir * Vector3.forward);

            var hits = Physics.RaycastAll(ray);
            float closestdist = 999999f;
            closestHitpoint = sourcePos;
            closestEnt = false;
            for (var i = 0; i < hits.Length; i++)
            {
                var hit = hits[i];
                if (hit.collider.GetComponentInParent<TriggerBase>() == null && hit.distance < closestdist)
                {
                    closestdist = hit.distance;
                    closestEnt = hit.collider;
                    closestHitpoint = hit.point;
                }
            }

            if (closestEnt is bool) return false;
            return true;
        }

        private bool TryGetPlayerView(BasePlayer player, out Quaternion viewAngle)
        {
            /**
             * Credit: Nogrod (HumanNPC)
             */
            viewAngle = new Quaternion(0f, 0f, 0f, 0f);
            var input = serverinput.GetValue(player) as InputState;
            if (input?.current == null) return false;
            viewAngle = Quaternion.Euler(input.current.aimAngles);
            return true;
        }

        #endregion

        #region Data
        /**
         * This class handles the in-memory state of a player.
         */
        public class PlayerState
        {
            private static readonly Oxide.Ext.SQLite.Libraries.SQLite sqlite = Interface.GetMod().GetLibrary<Ext.SQLite.Libraries.SQLite>();
            private static Core.Database.Connection sqlConnection;
            private BasePlayer player;
            private int id;
            private int plagueLevel;
            private int kinChangesCount;
            private bool pristine;
            private Dictionary<ulong, Association> associations;
            private Dictionary<ulong, Kin> kins;
            private List<ulong> kinRequests;

            private const string UpdateAssociation = "UPDATE associations SET level=@0 WHERE associations.id = @1;";
            private const string InsertAssociation = "INSERT INTO associations (player_id,associate_id,level) VALUES (@0,@1,@2);";
            private const string CheckAssociationExists = "SELECT id FROM associations WHERE player_id == @0 AND associate_id == @1;";
            private const string DeleteAssociation = "DELETE FROM associations WHERE id=@0";
            private const string InsertPlayer = "INSERT OR IGNORE INTO players (user_id, name, plague_level, kin_changes_count, pristine) VALUES (@0, @1,0,0,1);";
            private const string SelectPlayer = "SELECT * FROM players WHERE players.user_id == @0;";
            private const string UpdatePlayerPlagueLevel = "UPDATE players SET plague_level=@0,pristine=@1 WHERE players.user_id == @2;";
            private const string SelectAssociations = @"
                SELECT associations.id, associations.player_id, associations.associate_id, associations.level, players.user_id, players.name
                FROM associations
                JOIN players ON associations.associate_id = players.id
                WHERE associations.player_id = @0
            ";
            private const string SelectKinList = @"
                SELECT kin.self_id, kin.kin_id, players.name as kin_name, players.user_id as kin_user_id
                FROM kin
                JOIN players ON kin.kin_id = players.id
                WHERE kin.self_id = @0
            ";
            private const string InsertKin = "INSERT INTO kin (self_id,kin_id) VALUES (@0,@1);";
            private const string DeleteKin = "DELETE FROM kin WHERE self_id=@0 AND kin_id=@1";
            private const string SelectKinRequestList = @"";

            /**
             * Retrieves a player from database and restore its store or creates a new database entry
             */
            public PlayerState(BasePlayer newPlayer, Func<PlayerState,bool> callback)
            {
                player = newPlayer;
                Interface.Oxide.LogInfo("Loading player: " + player.displayName);

                var sql = new Oxide.Core.Database.Sql();
                sql.Append(InsertPlayer, player.userID, player.displayName);
                sqlite.Insert(sql, sqlConnection, create_results =>
                {
                    if (create_results == 1) Interface.Oxide.LogInfo("New user created!");

                    sql = new Oxide.Core.Database.Sql();
                    sql.Append(SelectPlayer, player.userID);

                    sqlite.Query(sql, sqlConnection, results =>
                    {
                        if (results == null) return;

                        if (results.Count > 0)
                        {
                            foreach (var entry in results)
                            {
                                id = Convert.ToInt32(entry["id"]);
                                plagueLevel = Convert.ToInt32(entry["plague_level"]);
                                kinChangesCount = Convert.ToInt32(entry["kin_changes_count"]);
                                pristine = Convert.ToBoolean(entry["pristine"]);
                                break;
                            }
                        }
                        else
                        {
                            Interface.Oxide.LogInfo("Something wrong has happened: Could not find the player with the given user_id!");
                        }

                        associations = new Dictionary<ulong, Association>();
                        kins = new Dictionary<ulong, Kin>();
                        kinRequests = new List<ulong>();

                        loadAssociations();
                        loadKinList();
                        //loadKinRequestList();
                        callback?.Invoke(this);
                    });
                });
            }

            public static void setupDatabase(RustPlugin plugin)
            {
                sqlConnection = sqlite.OpenDb($"Plagued.db", plugin);

                var sql = new Oxide.Core.Database.Sql();

                sql.Append(@"CREATE TABLE IF NOT EXISTS players (
                                 id INTEGER PRIMARY KEY   AUTOINCREMENT,
                                 user_id TEXT UNIQUE NOT NULL,
                                 name TEXT,
                                 plague_level INTEGER,
                                 kin_changes_count INTEGER,
                                 pristine INTEGER
                               );");

                sql.Append(@"CREATE TABLE IF NOT EXISTS associations (
                                id INTEGER PRIMARY KEY   AUTOINCREMENT,
                                player_id integer NOT NULL,
                                associate_id integer NOT NULL,
                                level INTEGER,
                                FOREIGN KEY (player_id) REFERENCES players(id),
                                FOREIGN KEY (associate_id) REFERENCES players(id)
                            );");

                sql.Append(@"CREATE TABLE IF NOT EXISTS kin (
                                self_id integer NOT NULL,
                                kin_id integer NOT NULL,
                                timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                                FOREIGN KEY (self_id) REFERENCES players(id),
                                FOREIGN KEY (kin_id) REFERENCES players(id),
                                PRIMARY KEY (self_id,kin_id)
                            );");

                sql.Append(@"CREATE TABLE IF NOT EXISTS kin_request (
                                requester_id integer NOT NULL,
                                target_id integer NOT NULL,
                                timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                                FOREIGN KEY (requester_id) REFERENCES players(id),
                                FOREIGN KEY (target_id) REFERENCES players(id),
                                PRIMARY KEY (requester_id,target_id)
                            );");


                sqlite.Insert(sql, sqlConnection);
            }

            public static void closeDatabase()
            {
                sqlite.CloseDb(sqlConnection);
            }

            /**
             * Increases the affinity of an associate and returns his new affinity
             */
            private Association increaseAssociateAffinity(BasePlayer associate)
            {
                if (associate == null) return null;
                if (player.userID == associate.userID) return null;
                if (disableSleeperAffinity && !BasePlayer.activePlayerList.Contains(associate)) return null;

                Association association = null;

                if (associations.ContainsKey(associate.userID))
                {
                    association = associations[associate.userID];
                    if ((association.level + affinityIncRate) < int.MaxValue) association.level += affinityIncRate;
                }
                else
                {
                    createAssociation(associate.userID, associationRef => {
                        if (associationRef != null)
                        {
                            association = associationRef;
                            associations.Add(associate.userID, associationRef);
                        }

                        return true;
                    });
                }

                //Interface.Oxide.LogInfo(player.displayName + " -> " + associate.displayName + " = " + associates[associate.userID].ToString());

                return association;
            }

            /**
             * Increases the affinity of all the associations in the list and increases the plague penalty if some associations are over the plague threshold
             * It also decreases the plague treshold if all the associates are kin or under the threshold
             */
            public void increasePlaguePenalty(BasePlayer[] associates)
            {
                int contagionVectorsCount = 0;
                var sql = new Oxide.Core.Database.Sql();

                foreach (BasePlayer associate in associates)
                {
                    if (isKinByUserID(associate.userID)) continue;

                    Association association = increaseAssociateAffinity(associate);

                    if (association == null) continue;
                    
                    sql.Append(UpdateAssociation, association.level, association.id);

                    if (association.level >= plagueMinAffinity)
                    {
                        contagionVectorsCount++;
                    }
                }

                sqlite.Update(sql, sqlConnection);


                if (contagionVectorsCount > 0)
                {
                    increasePlagueLevel(contagionVectorsCount);
                } else
                {
                    decreasePlagueLevel();
                }

                //Interface.Oxide.LogInfo(player.displayName + " -> " + plagueLevel);
            }

            /**
             * Decreases the affinity of all associations and decreases the plague level.
             */
            public void decreasePlaguePenalty()
            {
                decreaseAssociationsLevel();

                if (!pristine)
                {
                    decreasePlagueLevel();
                }
            }

            public void increasePlagueLevel(int contagionVectorCount)
            {
                if ((plagueLevel + (contagionVectorCount * plagueIncreaseRate)) <= 10000) {
                    plagueLevel += contagionVectorCount * plagueIncreaseRate;

                    if (pristine == true)
                    {
                        pristine = false;
                        MsgPlayer(player, "I don't feel so good.");
                        //Interface.Oxide.LogInfo(player.displayName + " is now sick.");
                    }

                    syncPlagueLevel();
                }

                //Interface.Oxide.LogInfo(player.displayName + "'s new plague level: " + plagueLevel.ToString());
            }

            public void decreasePlagueLevel()
            {
                if ((plagueLevel - plagueDecreaseRate) >= 0)
                {
                    plagueLevel -= plagueDecreaseRate;

                    if (plagueLevel == 0)
                    {
                        pristine = true;
                        MsgPlayer(player, "I feel a bit better now.");
                        //Interface.Oxide.LogInfo(player.displayName + " is now cured.");
                    }

                    syncPlagueLevel();
                }
            }

            public void decreaseAssociationsLevel()
            {
                if (associations.Count == 0) return;

                List<ulong> to_remove = new List<ulong>();
                var sql = new Oxide.Core.Database.Sql();

                foreach (ulong key in associations.Keys)
                {
                    Association association = associations[key];
                    int new_affinity = association.level - affinityDecRate;
                    if (new_affinity >= 1)
                    {
                        association.level = association.level - affinityDecRate;
                        sql.Append(UpdateAssociation, association.level, association.id);
                    } else if (new_affinity <= 0)
                    {
                        sql.Append(DeleteAssociation, association.id);
                        to_remove.Add(key);
                    }
                }

                foreach(ulong keyToRemove in to_remove)
                {
                    associations.Remove(keyToRemove);
                }

                sqlite.ExecuteNonQuery(sql, sqlConnection);
            }


            public bool isKinByUserID(ulong userID)
            {
                foreach(var item in kins)
                {
                    if (item.Value.kin_user_id == userID)
                    {
                        return true;
                    }
                }

                return false;
            }

            public bool hasKinRequest(ulong kinID)
            {
                return kinRequests.Contains(kinID);
            }

            public bool addKinRequest(ulong kinID)
            {
                if (!kinRequests.Contains(kinID))
                {
                    kinRequests.Add(kinID);

                    return true;
                }

                return false;
            }

            public bool addKin(ulong kinUserID) {
                if (kins.Count + 1 <= maxKin && !isKinByUserID(kinUserID))
                {
                    if (kinRequests.Contains(kinUserID)) kinRequests.Remove(kinUserID);
                    Kin newKin = createKin(kinUserID);
                    newKin.kin_user_id = kinUserID;
                    kins.Add(kinUserID, newKin);

                    return true;
                }

                return false;
            }

            public bool removeKinById(int id)
            {
                if ((kinChangesCount + 1) <= maxKinChanges)
                {
                    foreach(Kin kin in kins.Values)
                    {
                        if (kin.kin_id == id)
                        {
                            return forceRemoveKin(kin.kin_user_id);
                        }
                    }
                }

                return false;
            }

            public bool removeKin(ulong kinUserID)
            {
                if ((kinChangesCount + 1) <= maxKinChanges)
                {
                    return forceRemoveKin(kinUserID);
                }

                return false;
            }

            public bool forceRemoveKin(ulong kinUserID)
            {
                if (isKinByUserID(kinUserID))
                {
                    kinChangesCount++;
                    Kin kin = kins[kinUserID];

                    var sql = new Oxide.Core.Database.Sql();
                    sql.Append(DeleteKin, kin.self_id, kin.kin_id);
                    sqlite.ExecuteNonQuery(sql, sqlConnection);

                    kins.Remove(kinUserID);

                    return true;
                }

                return false;
            }

            public List<string> getKinList()
            {
                List<string> kinList = new List<string>();

                foreach (Kin kin in kins.Values)
                {
                    kinList.Add(String.Format("{0} (Id: {1})", kin.kin_name, kin.kin_id));
                }

                return kinList;
            }
            
            public List<string> getAssociatesList()
            {
                List<string> associatesList = new List<string>();

                foreach (Association association in associations.Values)
                {
                    associatesList.Add(String.Format("{0} (Id: {1} | Level: {2})", association.associate_name, association.associate_id, association.getAffinityLabel()));
                }

                return associatesList;
            }

            public int getPlagueLevel()
            {
                return plagueLevel;
            }

            public int getId()
            {
                return id;
            }

            public bool getPristine()
            {
                return pristine;
            }

            private Kin createKin(ulong kinUserId)
            {
                Kin kin = new Kin(id);

                var sql = new Oxide.Core.Database.Sql();
                sql.Append(SelectPlayer, kinUserId);

                sqlite.Query(sql, sqlConnection, list => {
                    if (list == null) return;

                    foreach (var user in list)
                    {
                        kin.kin_id = Convert.ToInt32(user["id"]);
                        kin.kin_name = Convert.ToString(user["name"]);
                        kin.kin_user_id = kinUserId;
                        break;
                    }

                    kin.create();
                });

                return kin;
            }

            private void createAssociation(ulong associate_user_id, Func<Association, bool> callback)
            {
                Association association = new Association();

                var sql = new Oxide.Core.Database.Sql();
                sql.Append(SelectPlayer, associate_user_id);
                sqlite.Query(sql, sqlConnection, list => {
                    if (list == null) return;
                    if (list.Count == 0) {
                        callback(null);
                        return;
                    };

                    foreach (var user in list)
                    {
                        association.player_id = id;
                        association.associate_id = Convert.ToInt32(user["id"]);
                        association.associate_user_id = associate_user_id;
                        association.associate_name = Convert.ToString(user["name"]);
                        association.level = 0;
                        break;
                    }

                    association.create();
                    callback(association);
                });
            }

            private void syncPlagueLevel()
            {
                var sql = new Oxide.Core.Database.Sql();
                sql.Append(UpdatePlayerPlagueLevel, plagueLevel, (pristine ? 1 : 0), player.userID);
                sqlite.Update(sql, sqlConnection);
            }

            private void loadAssociations()
            {
                var sql = new Oxide.Core.Database.Sql();
                sql.Append(SelectAssociations, id);
                sqlite.Query(sql, sqlConnection, results => {
                    if (results == null) return;

                    foreach (var association_result in results) {
                        Association association =  new Association();
                        association.load(association_result);
                        associations[association.associate_user_id] = association;
                    }
                });
            }

            private void loadKinList()
            {
                var sql = new Oxide.Core.Database.Sql();
                sql.Append(SelectKinList, id);
                sqlite.Query(sql, sqlConnection, results => {
                    if (results == null) return;

                    foreach (var kinResult in results)
                    {
                        Kin kin = new Kin(id);
                        kin.load(kinResult);
                        kins[kin.kin_user_id] = kin;
                    }
                });
            }

            private void loadKinRequestList()
            {
                var sql = new Oxide.Core.Database.Sql();
                sql.Append(SelectKinRequestList, id);
                sqlite.Query(sql, sqlConnection, results => {
                    if (results == null) return;

                    foreach (var kinRequest in results)
                    {
                        kinRequests.Add((ulong)Convert.ToInt64(kinRequest["user_id"]));
                    }
                });
            }

            private class Association
            {
                public int id;
                public int player_id;
                public int associate_id;
                public ulong associate_user_id;
                public string associate_name;
                public int level;

                public void create()
                {
                    var sql = new Oxide.Core.Database.Sql();
                    sql.Append(CheckAssociationExists, player_id, associate_id);

                    // Check if the relationship exists before creating it
                    sqlite.Query(sql, sqlConnection, check_results =>
                    {
                        if (check_results.Count > 0) return;

                        sql = new Oxide.Core.Database.Sql();

                        sql.Append(InsertAssociation, player_id, associate_id, level);
                        sqlite.Insert(sql, sqlConnection, result =>
                        {
                            if (result == null) return;
                            id = (int)sqlConnection.LastInsertRowId;
                        });
                    });
                }

                public void load(Dictionary<string, object> association)
                {
                    id = Convert.ToInt32(association["id"]);
                    associate_name = Convert.ToString(association["name"]);
                    associate_user_id = (ulong) Convert.ToInt64(association["user_id"]);
                    associate_id = Convert.ToInt32(association["associate_id"]);
                    player_id = Convert.ToInt32(association["player_id"]);
                    level = Convert.ToInt32(association["level"]);
                }

                public string getAffinityLabel()
                {
                    if (level >= plagueMinAffinity)
                    {
                        return "Associate";
                    } else
                    {
                        return "Acquaintance";
                    }
                }
            }

            private class Kin
            {
                public int self_id;
                public int kin_id;
                public ulong kin_user_id;
                public string kin_name;
                public int player_one_id;
                public int player_two_id;

                private Kin()
                {

                }

                public Kin(int p_self_id)
                {
                    self_id = p_self_id;
                }

                public void create()
                {
                    var sql = new Oxide.Core.Database.Sql();
                    sql.Append(InsertKin, self_id, kin_id);
                    sqlite.Insert(sql, sqlConnection);
                }

                public void load(Dictionary<string, object> kin)
                {
                    self_id = Convert.ToInt32(kin["self_id"]);
                    kin_id = Convert.ToInt32(kin["kin_id"]);
                    kin_name = Convert.ToString(kin["kin_name"]);
                    kin_user_id = (ulong)Convert.ToInt64(kin["kin_user_id"]);
                }
            }
        }

        #endregion

        #region Unity Components

        /**
         * This component adds a timers and collects all players colliders in a given radius. It then triggers custom hooks to reflect the situation of a given player
         */
        public class ProximityDetector : MonoBehaviour
        {
            public BasePlayer player;

            public void disableProximityCheck()
            {
                CancelInvoke("CheckProximity");
            }

            void Awake()
            {
                player = GetComponent<BasePlayer>();
                InvokeRepeating("CheckProximity", 0, 2.5f);
            }

            void OnDestroy()
            {
                disableProximityCheck();
            }

            void CheckProximity()
            {
                var count = Physics.OverlapSphereNonAlloc(player.transform.position, plagueRange, colBuffer, playerLayer);

                if (count > 1)
                {
                    BasePlayer[] playersNear = new BasePlayer[count];
                    for (int i = 0; i < count; i++)
                    {
                        var collider = colBuffer[i];
                        colBuffer[i] = null;
                        var collidingPlayer = collider.GetComponentInParent<BasePlayer>();
                        playersNear[i] = collidingPlayer;
                    }
                    notifyPlayerProximity(playersNear);
                } else
                {
                    notifyPlayerAlone();
                }
            }

            void notifyPlayerProximity(BasePlayer[] players)
            {
                Interface.Oxide.CallHook("OnPlayerProximity", player, players);
            }

            void notifyPlayerAlone()
            {
                Interface.Oxide.CallHook("OnPlayerAlone", player);
            }
        }
        #endregion
    }
}


// --- End of file: Plagued.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HydraBot.cs ---
// --- Original Local Path: HydraBot.cs ---

using System.Collections.Generic;
using Newtonsoft.Json;
using System.Linq;
using Oxide.Core.Libraries.Covalence;
using Random = Oxide.Core.Random;

namespace Oxide.Plugins
{
    [Info("HydraBot", "Deversive", "0.0.1", ResourceId = 1510)]
    [Description("Авто-оправка оповещений в чат для сервера - Hydra Rust")]
    internal class HydraBot : CovalencePlugin
    {
        private Configuration _config;
        private int _previousAdvert = -1;
        private ulong ImageID = 76561199039326412;

        #region Хук

        private void Loaded()
        {
            LoadConfig();
            
            Puts($"{Title} show ads every is {_config.AdvertInterval} minutes.");
            timer.Every(_config.AdvertInterval * 60, BroadcastNextAdvert);
        }

        #endregion

        #region Конфиг

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<Configuration>();
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            _config = Configuration.CreateDefault();
        }

        protected override void SaveConfig() => Config.WriteObject(_config);

        private class Configuration
        {
            [JsonProperty("Сообщение")]
            public List<string> Messages { get; private set; }

            [JsonProperty("Интервал сообщений( в минутах)")]
            public float AdvertInterval { get; private set; }  = 10;

            [JsonProperty("Оповещать в консоль? (true/false)")]
            public bool BroadcastToConsole { get; private set; } = true;

            [JsonProperty("Выбрать сообщение в случайном порядке (true/false)")]
            public bool ChooseMessageAtRandom { get; private set; } = false;

            public static Configuration CreateDefault()
            {
                return new Configuration
                {
                    Messages = new List<string>
                    {
                        "ДРУЗЬЯ НАПОМИНАЕМ ВАМ ЧТО СЕЙЧАС СЕРВЕР В ТЕСТОВОМ РЕЖИИМЕ",
                        "Хочешь узнать о сервере побольше?\nПерейди в группу <color=#9198bf>ВК</color> VK.COM/STORM.RUST.",
                        "Не забывай у нас есть бесплатная рулетка в магазине \nМагазин <color=#8e6874>STORMRUST.RU</color>",
                        "Не забудь подключить оповщение о рейде \n написав команду - <color=#8e6874>/raid</color>",
                        "Увидел читера или нарушителей?\nОтправляй жалобу, написав <color=#8e6874>/REPORT</color>",
                        "ДРУЗЬЯ НАПОМИНАЕМ ВАМ ЧТО СЕЙЧАС СЕРВЕР В ТЕСТОВОМ РЕЖИИМЕ",
                        "Хочешь увеличить рейты на своём персонаже? \n купи привилегию в магазине - <color=#8e6874>STORMRUST.RU</color>",
                        "Каждые 24 часа у нас активируется \n <color=#8e6874>Двойной фарм</color>",
                        "Хочешь иметь приемущество над игроками? \n купи привилегию в магазине - <color=#8e6874>STORMRUST.RU</color>",
                        "Не забудь подключить оповщение о рейде \n написав команду - <color=#8e6874>/raid</color>",
                        "У нас имеется свой дискорд сервер, где вы можете общаться \n <color=#8e6874>discord.gg/vzCD3ZBC3C</color>",
                        "ДРУЗЬЯ НАПОМИНАЕМ ВАМ ЧТО СЕЙЧАС СЕРВЕР В ТЕСТОВОМ РЕЖИИМЕ"
                    }
                };
            }
        }

        #endregion

        #region Методы помощи

        void OnServerInitialized()
        {
        }

        private void BroadcastNextAdvert()
        {
            if (_config.Messages.Count == 0)
                return;
            int advert = GetNextAdvertIndex();

            server.Broadcast(_config.Messages[advert]);

            if (_config.BroadcastToConsole)
                Puts(Formatter.ToPlaintext(_config.Messages[advert]));

            _previousAdvert = advert;
        }

        private int GetNextAdvertIndex()
        {
            if (!_config.ChooseMessageAtRandom)
                return (_previousAdvert + 1) % _config.Messages.Count;

            int advert;
            if (_config.Messages.Count > 1)
            {
                do advert = Random.Range(0, _config.Messages.Count);
                while (advert == _previousAdvert);
            }
            else
                advert = 0;

            return advert;
        }

        #endregion
    }
}

// --- End of file: HydraBot.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/LogoStorm.cs ---
// --- Original Local Path: LogoStorm.cs ---

﻿

using System;
using System.Collections.Generic;
using Network;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("StormLogo", "Ryamkk", "2.2.0")]
    public class LogoStorm : RustPlugin
    {
        [PluginReference] private Plugin ImageLibrary;

         string logo = "https://imgur.com/Ao6JTUA.png";
         string open = "https://i.imgur.com/kVda4YB.png";
       
         public static string Commnad1 = "/stat";
         public static string Commnad2 = "/store";
         public static string Commnad3 = "/block";
         public static string Commnad4 = "/report";
         
        
        #region ImageLibrary
        
        
        private string GetImage(string fileName, ulong skin = 0)
        {
            var imageId = (string)plugins.Find("ImageLibrary").CallHook("GetImage", fileName, skin);
            if (!string.IsNullOrEmpty(imageId))
                return imageId;
            return string.Empty;
        }
        public bool AddImage(string url, string shortname, ulong skin = 0) => (bool)ImageLibrary?.Call("AddImage", url, shortname, skin);
        
        

        void LoadImage()
        {
            AddImage(logo, "logo");
            AddImage(open, "open");
        }
        
        #endregion
        
        private const string Layer = "UI.Menu";
        
        List<string> MSGList = new List<string>
        {
            "Максимум человек в команде - <color=#8e6874>[ 4 ]</color>", 
            "Наша группа ВК - <color=#8e6874>vk.com/storm.rust</color>", 
            "Магазин/сайт сервера - <color=#8e6874>stormrust.store</color>",
            "Включи оповощение о рейде! - <color=#8e6874>/raid</color>",    
            "Отобразить статистику игроков <color=#8e6874>/stat</color>", 
            "<color=#8e6874>/report</color> - отправить жалобу на игрока"
        };

        private PluginData _data;

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(Name, _data);
        }

        private void LoadData()
        {
            try
            {
                _data = Interface.Oxide.DataFileSystem.ReadObject<PluginData>(Name);
            }
            catch (Exception e)
            {
                PrintError(e.ToString());
            }

            if (_data == null) _data = new PluginData();
        }

        private class PluginData
        {
            [JsonProperty(PropertyName = "Hided Players", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<ulong> HidedPlayers = new List<ulong>();

            public bool IsHided(BasePlayer player)
            {
                return HidedPlayers.Contains(player.userID);
            }

            public bool ChangeStatus(BasePlayer player)
            {
                if (player == null) return false;

                if (IsHided(player))
                {
                    HidedPlayers.Remove(player.userID);
                    return false;
                }

                HidedPlayers.Add(player.userID);
                return true;
            }
        }

        void Loaded()
        {

        }

        #region command

        [ChatCommand("online")]
        void CommanndOnline(BasePlayer sender, string command, string[] args) => CommandPlayers(sender, command, args);

        [ChatCommand("player")]
        void CommandPlayer(BasePlayer sender, string command, string[] args) => CommandPlayers(sender, command, args);

        [ChatCommand("players")]
        void CommandPlayers(BasePlayer sender, string command, string[] args)
        {
            string playerList = ("<color=#8e6874>Онлайн игроки:</color>");

            foreach (BasePlayer player in BasePlayer.activePlayerList)
                playerList += $"\n- {player.displayName}";

            if (BasePlayer.activePlayerList.Count < 20)
                PrintToChat(sender, playerList);
            else
                PrintToChat(sender, "Список игроков слишком длинный для чата. \n Нажмите F1, затем снова введите /players в чате, затем F1, чтобы посмотреть полный список игроков.");
            sender.Command("echo", $"{playerList}");
        }

        #endregion

        private void OnServerInitialized()
        {
            LoadData();
            LoadImage();
            timer.Every(20f, () =>
            {
                foreach(var player in BasePlayer.activePlayerList)
                {
                    DrawLower(player);
                }
            });


            foreach (var player in BasePlayer.activePlayerList)
            {
                OnPlayerConnected(player);
            }

            AddCovalenceCommand("hide", nameof(CmdMenuHide));
        }

        private void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, Layer);
            }
            
            SaveData();
        }

        void OnClientAuth(Connection connection)
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                timer.In(0.21f, RefreshOnline);
            }
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player == null) return;

            if (player.IsReceivingSnapshot)
            {
                timer.Once(2, () => OnPlayerConnected(player));
                return;
            }

            MainUi(player);
            DrawLower(player);
            RefreshOnline();
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            timer.In(0.21f, RefreshOnline);
        }

        private void CmdMenuHide(IPlayer cov, string command, string[] args)
        {
            var player = cov?.Object as BasePlayer;
            if (player == null) return;

            _data.ChangeStatus(player);

            MainUi(player);
        }

        private void MainUi(BasePlayer player)
        {
            var container = new CuiElementContainer();
            

            var SleepingPlayer = BasePlayer.sleepingPlayerList.Count;
            var OnlinePlayer = BasePlayer.activePlayerList.Count;
            var JoiningPlayer = ServerMgr.Instance.connectionQueue.Joining;
            
            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = "0 0 0 0" },
                RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "0 -68", OffsetMax = "190 -1" }
            }, "Hud", Layer);

            if (!_data.IsHided(player))
            {
                container.Add(new CuiElement
                {
                    Parent = Layer,
                    Name = Layer + ".Image",
                    FadeOut = 1f,
                    Components =
                    {
                        new CuiImageComponent {Png = GetImage("open") ,  Material = "assets/icons/greyout.mat" },
                        new CuiRectTransformComponent { AnchorMin = "0.2894738 0.175", AnchorMax = "0.9421054 0.8532338"}
                    }
                });

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.1732883 0.5392601", AnchorMax = "0.2969442 0.8725935" },
                    Text = 
                    {
                        Text = $"{JoiningPlayer + OnlinePlayer}", Color = HexToRustFormat("#9e5167FF"), FontSize = 9, 
                        Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf" 
                    }
                }, Layer + ".Image", Layer + ".Online");
                
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.7324276 0.5537528", AnchorMax = "0.8560835 0.8870862" },
                    Text = { Text = $"{SleepingPlayer}", FontSize = 9, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf" }
                }, Layer + ".Image", Layer + ".Sleepers");
                
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.4474816 0.5537528", AnchorMax = "0.5711375 0.8870862" },
                    Text = { Text = $"{JoiningPlayer}", FontSize = 9, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf" }
                }, Layer + ".Image", Layer + ".Joining");
                
                container.Add(new CuiButton
                {
                    Button = { Color = "0 0 0 0", Command = $"chat.say {Commnad1}" },
                    RectTransform = { AnchorMin = "0.188908 0.1773738", AnchorMax = "0.2856822 0.4382434" },
                    Text = { Text = "" }
                }, Layer + ".Image", Layer + ".Image.1");
            
                container.Add(new CuiButton
                {
                    Button = { Color = "0 0 0 0", Command = $"chat.say {Commnad2}" },
                    RectTransform = { AnchorMin = "0.3609509 0.1773738", AnchorMax = "0.457725 0.4382434" },
                    Text = { Text = "" }
                }, Layer + ".Image", Layer + ".Image.2");
            
                container.Add(new CuiButton
                {
                    Button = { Color = "0 0 0 0", Command = $"chat.say {Commnad3}" },
                    RectTransform = { AnchorMin = "0.5329937 0.1773738", AnchorMax = "0.6297679 0.4382434" },
                    Text = { Text = "" }
                }, Layer + ".Image", Layer + ".Image.3");
            
                container.Add(new CuiButton
                {
                    Button = { Color = "0 0 0 0", Command = $"chat.say {Commnad4}" },
                    RectTransform = { AnchorMin = "0.7050366 0.1918665", AnchorMax = "0.8018107 0.4527361" },
                    Text = { Text = "" }
                }, Layer + ".Image", Layer + ".Image.4");
            }

            container.Add(new CuiElement
            {
                Parent = Layer,
                Name = Layer + ".SummerImage",
                Components =
                {
                    new CuiImageComponent { Png = GetImage("logo") , Material = "assets/icons/greyout.mat" },
                    new CuiRectTransformComponent { AnchorMin = "-0.03859668 -0.08706465", AnchorMax = "0.3578931 1.186567" }
                }
            });

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0.96 1" },
                Text = { Text = "" },
                Button = { Color = "0 0 0 0", Command = "hide" }
            }, Layer + ".SummerImage");

            CuiHelper.DestroyUi(player, Layer);
            CuiHelper.AddUi(player, container);

        }

        private void RefreshOnline()
        {
            var container = new CuiElementContainer();
                
            var SleepingPlayer = BasePlayer.sleepingPlayerList.Count;
            var OnlinePlayer = BasePlayer.activePlayerList.Count;
            var JoiningPlayer = ServerMgr.Instance.connectionQueue.Joining;

                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.1732883 0.5392601", AnchorMax = "0.2969442 0.8725935" },
                    Text = 
                    {
                        Text = $"{JoiningPlayer + OnlinePlayer}", Color = HexToRustFormat("#9e5167FF"), FontSize = 9, 
                        Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf" 
                    }
                }, Layer + ".Image", Layer + ".Online");
                
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.7324276 0.5537528", AnchorMax = "0.8560835 0.8870862" },
                    Text = { Text = $"{SleepingPlayer}", FontSize = 9, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf" }
                }, Layer + ".Image", Layer + ".Sleepers");
                
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.4474816 0.5537528", AnchorMax = "0.5711375 0.8870862" },
                    Text = { Text = $"{JoiningPlayer}", FontSize = 9, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf" }
                }, Layer + ".Image", Layer + ".Joining");

            foreach (var player in BasePlayer.activePlayerList)
            {
                if (_data.IsHided(player)) continue;

                CuiHelper.DestroyUi(player, Layer + ".Online");
                CuiHelper.DestroyUi(player, Layer + ".Sleepers");
                CuiHelper.DestroyUi(player, Layer + ".Joining");
                CuiHelper.AddUi(player, container);
            }
        }

        private void DrawLower(BasePlayer player)
        {
            var container = new CuiElementContainer();
            
            container.Add(new CuiPanel
            {
                Image = { Color = HexToRustFormat("#00000000") },
                RectTransform = { AnchorMin = "0.3462664 0.003906242", AnchorMax = "0.6449488 0.02473958" },
                CursorEnabled = false,
            }, "Under", "DVLower");
            
            container.Add(new CuiElement
            {
                Parent = "DVLower",
                Components =
                {
                    new CuiTextComponent { Text = MSGList.GetRandom(), Align = TextAnchor.MiddleCenter, FontSize = 10, Font = "RobotoCondensed-regular.ttf"},
                    new CuiOutlineComponent { Color = "0 0 0 1", Distance = "0.5 0.5" },
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                }
            });

            CuiHelper.DestroyUi(player, "DVLower");
            CuiHelper.AddUi(player, container);
        }

        private static string HexToRustFormat(string hex)
        { 
            Color color;
            ColorUtility.TryParseHtmlString(hex, out color);
            return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
        }
    }
}

// --- End of file: LogoStorm.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/LastName.cs ---
// --- Original Local Path: LastName.cs ---

using System;
using System.Collections.Generic;
using System.Linq;

using Oxide.Core;
using Oxide.Core.Configuration;

namespace Oxide.Plugins
{
	[Info("LastName", "deer_SWAG", "0.1.15", ResourceId = 1227)]
	[Description("Stores all usernames")]
	public class LastName : RustPlugin
	{
		const string databaseName = "LastName";

		class StoredData
		{
			public HashSet<Player> Players = new HashSet<Player>();

			public StoredData() { }

			public void Add(Player player) => Players.Add(player);
		}

		class Player
		{
			public ulong userID;
			public HashSet<string> Names = new HashSet<string>();

			public Player() { }
			public Player(ulong userID) { this.userID = userID; }

			public void Add(string name) => Names.Add(name);
		}

		StoredData 		  data;
		DynamicConfigFile nameChangeData;

		protected override void LoadDefaultConfig()
		{
			Config.Clear();

			CheckConfig();

			Puts("Default config was saved and loaded");
		}

		private void OnPluginLoaded()
		{
			CheckConfig();

			data = Interface.GetMod().DataFileSystem.ReadObject<StoredData>(databaseName);

			if (data == null)
			{
				RaiseError("Unable to load data file");
				ConsoleSystem.Run.Server.Normal("oxide.unload LastName");
			}

			if (IsPluginExists("NameChange"))
				nameChangeData = Interface.GetMod().DataFileSystem.GetDatafile("NameChange");
		}

		private void OnPlayerConnected(Network.Message packet)
		{
			if ((bool)Config["ReplaceWithFirstName"] && data.Players.Count > 0)
			{
				if (nameChangeData != null)
				{
					foreach (KeyValuePair<string, object> item in nameChangeData)
					{
						if (Convert.ToUInt64(item.Key) != packet.connection.userid)
						{
							foreach (Player dataPlayer in data.Players)
							{
								if (packet.connection.userid == dataPlayer.userID)
								{
									packet.connection.username = dataPlayer.Names.First();
									goto end;
								}
							}
						}
					}
					end:;
				}
				else
				{
					foreach (Player dataPlayer in data.Players)
					{
						if (packet.connection.userid == dataPlayer.userID)
						{
							packet.connection.username = dataPlayer.Names.First();
							break;
						}
					}
				}
			}
		}

		private void OnPlayerInit(BasePlayer player)
		{
			if (data.Players.Count > 0)
			{
				bool found = false;
				bool newName = false;

				foreach (Player dataPlayer in data.Players)
				{
					if (dataPlayer.userID == player.userID)
					{
						found = true;

						foreach (string name in dataPlayer.Names)
						{
							if (name == player.displayName)
								break;
							else
								newName = true;
						}

						if (newName)
							dataPlayer.Add(player.displayName);

						break;
					}
				}

				if (!found)
				{
					Player p = new Player(player.userID);
					p.Add(player.displayName);

					data.Add(p);
				}
			}
			else
			{
				Player p = new Player(player.userID);
				p.Add(player.displayName);

				data.Add(p);
			}

			SaveData();
		}

		[ChatCommand("lastname")]
		private void cmdChat(BasePlayer player, string command, string[] args)
		{
			if (player.net.connection.authLevel >= (int)Config["CommandAuthLevel"])
				if (args.Length > 0)
					PrintToChat(player, GetNames(args));
				else
					PrintToChat(player, (string)Config["Message", "WrongQuery"]);
			else
				PrintToChat(player, (string)Config["Message", "NoAccess"]);
		}

		[ConsoleCommand("player.lastname")]
		private void cmdConsole(ConsoleSystem.Arg arg)
		{
			if (arg.HasArgs())
				Puts(GetNames(arg.Args));
			else
				Puts((string)Config["Message", "WrongQuery"]);
		}

		private string GetNames(string[] args)
		{
			string message = (string)Config["Message", "PlayerWasFound"];
			string name = string.Empty;

			try
			{
				ulong id = Convert.ToUInt64(args[0]);

				foreach (Player dataPlayer in data.Players)
				{
					if (dataPlayer.userID == id)
					{
						name = dataPlayer.Names.First();

						foreach (string n in dataPlayer.Names)
							message += n + ", ";

						break;
					}
				}
			}
			catch { }
			finally
			{
				if (name.Length > 0)
				{
					message = message.Substring(0, message.Length - 2).Replace("%name%", name).Replace("%id%", args[0]);
				}
				else
				{
					Player found = null;

					for (int i = 0; i < args.Length; i++)
						name += args[i] + " ";

					name = name.TrimEnd();

					foreach (Player dataPlayer in data.Players)
					{
						foreach (string s in dataPlayer.Names)
						{
							if (s.Equals(name, StringComparison.CurrentCultureIgnoreCase))
							{
								found = dataPlayer;
								goto end;
							}
							else if (s.StartsWith(name, StringComparison.CurrentCultureIgnoreCase))
							{
								found = dataPlayer;
								goto end;
							}
							else if (StringContains(s, name, StringComparison.CurrentCultureIgnoreCase))
							{
								found = dataPlayer;
								goto end;
							}
						}
					} end:;

					if (found != null)
					{
						foreach (string s in found.Names)
							message += s + ", ";

						message = message.Substring(0, message.Length - 2).Replace("%name%", name).Replace("%id%", found.userID.ToString());
					}
					else
					{
						message = (string)Config["Message", "NoPlayerFound"];
					}
				}
			}

			return message;
		}

		void SendHelpText(BasePlayer player)
		{
			if (player.net.connection.authLevel >= (int)Config["CommandAuthLevel"])
				PrintToChat(player, (string)Config["Message", "WrongQuery"]);
		}

		private void CheckConfig()
		{
			ConfigItem("ReplaceWithFirstName", false);
			ConfigItem("CommandAuthLevel", 0);
			ConfigItem("Message", "NoAccess", "You are don't have access for this command");
			ConfigItem("Message", "WrongQuery", "/lastname <name/steamID>");
			ConfigItem("Message", "NoPlayerFound", "No players found with that name/steamID");
			ConfigItem("Message", "PlayerWasFound", "%name%(%id%) was also known as: ");

			SaveConfig();
		}

		private void SaveData()
		{
			Interface.GetMod().DataFileSystem.WriteObject(databaseName, data);
		}

		// ----------------------------- UTILS -----------------------------
		// -----------------------------------------------------------------

		private void ConfigItem(string name, object defaultValue)
		{
			Config[name] = Config[name] ?? defaultValue;
		}

		private void ConfigItem(string name1, string name2, object defaultValue)
		{
			Config[name1, name2] = Config[name1, name2] ?? defaultValue;
		}

		private bool IsPluginExists(string name)
		{
			return Interface.GetMod().GetLibrary<Core.Libraries.Plugins>("Plugins").Exists(name);
		}

		private bool StringContains(string source, string value, StringComparison comparison)
		{
			return source.IndexOf(value, comparison) >= 0;
		}
	}
}

// --- End of file: LastName.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/XRestartUI.cs ---
// --- Original Local Path: XRestartUI.cs ---

using System.Collections.Generic;
using Oxide.Game.Rust.Cui;  
using UnityEngine;  
using System;
using Newtonsoft.Json;
using System.Linq;
using System.Collections;
  
namespace Oxide.Plugins 
{ 
    [Info("XRestartUI", "Monster.", "1.0.201")]
    class XRestartUI : RustPlugin
    {	 
		 
				
				
		private void TimerGameTip(BasePlayer player, string message, int seconds)
        {
			TimeSpan t = TimeSpan.FromSeconds(seconds);
            player.SendConsoleCommand("gametip.showgametip", string.Format(lang.GetMessage("RESTART", this, player.UserIDString), t.Minutes, t.Seconds, lang.GetMessage(message, this, player.UserIDString)));
        }		
 
        private class RestartConfig 
        {		  
			[JsonProperty("Настройка рестартов по расписанию [ Можно запланировать любую команду в любое время ]")] 
			public Dictionary<string, string> ARestart;			
			
			public static RestartConfig GetNewConfiguration()
            {
                return new RestartConfig  
                {
					Setting = new GeneralSetting      
					{ 
						Message = true,
						UI = true,
						GameTip = false,
						EffectTickUse = true,
						EffectWarningUse = true,
						EffectTick = "assets/bundled/prefabs/fx/notice/loot.drag.dropsuccess.fx.prefab",
						EffectWarning = "assets/bundled/prefabs/fx/item_unlock.prefab",
						SteamID = 0
					},    
					ListMessage = new List<string>
					{
						"M_DEFAULT", "M_1", "M_2"
					},
					ARestart = new Dictionary<string, string>
					{
						["08:00"] = "restart 300",
						["21:00"] = "restart 300 M_1"
					},
					Warning = new List<int>
					{
						60,
						45,
						30,
						15,
						10,
						5
					}
				};
			}
			
			[JsonProperty("Общие настройки")] 
            public GeneralSetting Setting;	
			[JsonProperty("Настройка предупреждений за N минут до рестарта")] 
			public List<int> Warning;			
			[JsonProperty("Список уникальных имен(ключей) причин рестарта - [ Настройка текста в lang ]")] 
			public List<string> ListMessage;			
		    internal class GeneralSetting
			{
				[JsonProperty("SteamID профиля для кастомной аватарки")] public ulong SteamID;
			    [JsonProperty("Использовать эффект тика")] public bool EffectTickUse;
			    [JsonProperty("Использовать UI уведомления")] public bool UI;
			    [JsonProperty("Используемый эффект тика")] public string EffectTick;
			    [JsonProperty("Использовать GameTip уведомления")] public bool GameTip;
			    [JsonProperty("Используемый эффект предупреждения")] public string EffectWarning;
			    [JsonProperty("Использовать сообщения в чате")] public bool Message;
			    [JsonProperty("Использовать эффект предупреждения")] public bool EffectWarningUse;
			}	 				 			
        } 
 
				
				 
		private void TimerGUI(BasePlayer player, string message, int seconds)
		{
			TimeSpan t = TimeSpan.FromSeconds(seconds);
			
			CuiHelper.DestroyUi(player, ".TimerGUI");
            CuiElementContainer container = new CuiElementContainer();
			 
			container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0.85", AnchorMax = "1 0.85", OffsetMin = "0 -25", OffsetMax = "0 25" },
                Image = { Color = "0.217 0.221 0.209 0.4", Material = "assets/icons/greyout.mat" }
            }, "Hud", ".TimerGUI");
			
			container.Add(new CuiElement 
			{ 
				Parent = ".TimerGUI", 
				Components =
				{
					new CuiTextComponent { Text = string.Format(lang.GetMessage("RESTART", this, player.UserIDString), t.Minutes, t.Seconds, lang.GetMessage(message, this, player.UserIDString)), Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 18, Color = "1 1 1 0.75" },
				    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
					new CuiOutlineComponent { Color = "0 0 0 1", Distance = "0.2 -0.2" }
				} 
			});	
			 
			CuiHelper.AddUi(player, container);
		}		
		   		 		  						  	   		  	 				   		 		  	 	 		   		 
		private void AutoRestart() 
		{
			string time = DateTime.Now.ToString("t");
			
			foreach(int minute in config.Warning)
			{
				string newtime = DateTime.Now.AddMinutes(minute).ToString("t");
				
				if(config.ARestart.ContainsKey(newtime) && config.ARestart[newtime].Contains("restart"))
				{
					TimeSpan t = TimeSpan.FromSeconds(minute * 60);
					
					if(config.Setting.Message)
						BasePlayer.activePlayerList.ToList().ForEach(x => Player.Reply(x, string.Format(lang.GetMessage("CHAT_WARNING_RESTART", this, x.UserIDString), t.Hours, t.Minutes, t.Seconds), config.Setting.SteamID));
					
					foreach(BasePlayer player in BasePlayer.activePlayerList)
					{
						if(config.Setting.UI)
							WarningGUI(player, t);
						if(config.Setting.GameTip)
							WarningGameTip(player, t);
						
						if(config.Setting.EffectWarningUse)
							EffectNetwork.Send(new Effect(config.Setting.EffectWarning, player, 0, new Vector3(), new Vector3()), player.Connection);
					}
					break;
				}
			}
			
			if(config.ARestart.ContainsKey(time))
				Server.Command(config.ARestart[time]);
		}		
		
		private IEnumerator Restart(string message, int seconds) 
		{
			if(config.Setting.Message)
			{
				TimeSpan t = TimeSpan.FromSeconds(seconds);
				BasePlayer.activePlayerList.ToList().ForEach(x => Player.Reply(x, string.Format(lang.GetMessage("CHAT_RESTART", this, x.UserIDString), t.Minutes, t.Seconds, lang.GetMessage(message, this, x.UserIDString)), config.Setting.SteamID));
			}
			
			for(int i = 0; i <= seconds; i++)
			{
				int sec = seconds - i;
				
				foreach(BasePlayer player in BasePlayer.activePlayerList)
				{
					if(config.Setting.UI)
						TimerGUI(player, message, sec);
					if(config.Setting.GameTip)
						TimerGameTip(player, message, sec);
					
					if(config.Setting.EffectTickUse)
						EffectNetwork.Send(new Effect(config.Setting.EffectTick, player, 0, new Vector3(), new Vector3()), player.Connection);
				}
				
				yield return CoroutineEx.waitForSeconds(1);
			}
			
			yield return CoroutineEx.waitForSeconds(1);
			
			BasePlayer.activePlayerList.ToList().ForEach(x => x.Kick("Server Restarting"));
			
			yield return CoroutineEx.waitForSeconds(2);
			
			ConsoleSystem.Run(ConsoleSystem.Option.Server, "quit", Array.Empty<object>());
			
			yield break;
		}
		 
		  
        private RestartConfig config; 
		  
		private void Unload()
		{
			if(_coroutine != null) 
				ServerMgr.Instance.StopCoroutine(_coroutine);
			
			foreach(BasePlayer player in BasePlayer.activePlayerList)
			{
				CuiHelper.DestroyUi(player, ".TimerGUI");
				player.SendConsoleCommand("gametip.hidegametip");
			}
		} 
        protected override void SaveConfig() => Config.WriteObject(config);
		 
		private object OnServerRestart(string message, int seconds)
		{ 
			if(_coroutine != null) 
				ServerMgr.Instance.StopCoroutine(_coroutine); 
			
			if(seconds > 0)
			{
				message = String.IsNullOrEmpty(message) ? "M_DEFAULT" : message;
			    _coroutine = ServerMgr.Instance.StartCoroutine(Restart(message, seconds)); 
			}
			else if(_coroutine != null) 
			{
				if(config.Setting.Message)
					BasePlayer.activePlayerList.ToList().ForEach(x => Player.Reply(x, lang.GetMessage("CANCELED_RESTART", this, x.UserIDString), config.Setting.SteamID));
				Unload(); 
				
				_coroutine = null;
			}
			
			return true;
		} 
  
        protected override void LoadConfig()
        {
            base.LoadConfig();
			
			try
			{
				config = Config.ReadObject<RestartConfig>(); 
			}
			catch
			{
				PrintWarning("Ошибка чтения конфигурации! Создание дефолтной конфигурации!");
				LoadDefaultConfig();
			}
			
			SaveConfig();
        }
		protected override void LoadDefaultConfig() => config = RestartConfig.GetNewConfiguration();
		private Coroutine _coroutine; 
		   		 		  						  	   		  	 				   		 		  	 	 		   		 
        		
				 
		private void OnServerInitialized()
		{ 
			PrintWarning("\n-----------------------------\n" + 
			"     Author - Monster\n" +
			"     VK - vk.com/idannopol\n" + 
			"     Discord - Monster#4837\n" +
			"     Config - v.3062\n" + 
			"-----------------------------"); 
			
			InitializeLang();
			timer.Every(60, () => AutoRestart());
		}
		
				
	      
        private void InitializeLang() 
        {	
			Dictionary<string, string> langen = new Dictionary<string, string>
			{
				["RESTART"] = "SERVER RESTART THROUGH: {0} MIN. {1} SEC.\n<size=12>{2}</size>",
				["CHAT_RESTART"] = "<color=#a3f0ff>SERVER RESTART THROUGH</color>: <color=orange>{0} MIN. {1} SEC.</color>\n<size=10>{2}</size>",
				["WARNING_RESTART"] = "SERVER RESTART WILL START IN: {0} HR. {1} MIN. {2} SEC.",
				["CHAT_WARNING_RESTART"] = "<size=13><color=#a3f0ff>SERVER RESTART WILL START IN</color>: <color=orange>{0} HR. {1} MIN. {2} SEC.</color></size>",
				["CANCELED_RESTART"] = "<color=#a3f0ff>RESTART CANCELED</color>"
			};		    
			 
			Dictionary<string, string> langru = new Dictionary<string, string>
			{
                ["RESTART"] = "РЕСТАРТ СЕРВЕРА ЧЕРЕЗ: {0} МИН. {1} СЕК.\n<size=12>{2}</size>",
                ["CHAT_RESTART"] = "<color=#a3f0ff>РЕСТАРТ СЕРВЕРА ЧЕРЕЗ</color>: <color=orange>{0} МИН. {1} СЕК.</color>\n<size=10>{2}</size>",				
                ["WARNING_RESTART"] = "РЕСТАРТ СЕРВЕРА НАЧНЕТСЯ ЧЕРЕЗ: {0} ЧАС. {1} МИН. {2} СЕК.",									
                ["CHAT_WARNING_RESTART"] = "<size=13><color=#a3f0ff>РЕСТАРТ СЕРВЕРА НАЧНЕТСЯ ЧЕРЕЗ</color>: <color=orange>{0} ЧАС. {1} МИН. {2} СЕК.</color></size>",									
				["CANCELED_RESTART"] = "<color=#a3f0ff>РЕСТАРТ ОТМЕНЕН</color>"				
			};				
			  
			Dictionary<string, string> langes = new Dictionary<string, string>
			{
                ["RESTART"] = "REINICIAR EL SERVIDOR A TRAVÉS: {0} MIN. {1} SEG.\n<size=12>{2}</size>",	
                ["CHAT_RESTART"] = "<color=#a3f0ff>REINICIAR EL SERVIDOR A TRAVÉS</color>: <color=orange>{0} MIN. {1} SEG.</color>\n<size=10>{2}</size>",				
                ["WARNING_RESTART"] = "EL REINICIO DEL SERVIDOR COMENZARÁ EN: {0} HR. {1} MIN. {2} SEG.",								
                ["CHAT_WARNING_RESTART"] = "<size=13><color=#a3f0ff>EL REINICIO DEL SERVIDOR COMENZARÁ EN</color>: <color=orange>{0} HR. {1} MIN. {2} SEG.</color></size>",								
				["CANCELED_RESTART"] = "<color=#a3f0ff>REINICIO CANCELADO</color>"
			};			
			
			foreach(var message in config.ListMessage)
			{
			   	langen.Add(message, "RESTART RESTART RESTART");
				langru.Add(message, "РЕСТАРТ РЕСТАРТ РЕСТАРТ");
				langes.Add(message, "REINICIAR REINICIAR REINICIAR");
			}
			
			lang.RegisterMessages(langen, this);
			lang.RegisterMessages(langru, this, "ru");
			lang.RegisterMessages(langes, this, "es-ES");
        }
		
		private void WarningGameTip(BasePlayer player, TimeSpan time)
        {
            player.SendConsoleCommand("gametip.showgametip", string.Format(lang.GetMessage("WARNING_RESTART", this, player.UserIDString), time.Hours, time.Minutes, time.Seconds));
            timer.Once(15f, () => player.SendConsoleCommand("gametip.hidegametip"));
        }
		
		private void WarningGUI(BasePlayer player, TimeSpan time)
		{
			CuiHelper.DestroyUi(player, ".TimerGUI");
            CuiElementContainer container = new CuiElementContainer();
			  
			container.Add(new CuiPanel
            {
				FadeOut = 2.5f,
                RectTransform = { AnchorMin = "0 0.85", AnchorMax = "1 0.85", OffsetMin = "0 -25", OffsetMax = "0 25" },
                Image = { Color = "0.217 0.221 0.209 0.4", Material = "assets/icons/greyout.mat", FadeIn = 2.5f }
            }, "Hud", ".TimerGUI");
			
			container.Add(new CuiElement 
			{ 
				Parent = ".TimerGUI", 
				Name = ".TimerGUIText", 
				FadeOut = 2.5f,
				Components =
				{
					new CuiTextComponent { Text = string.Format(lang.GetMessage("WARNING_RESTART", this, player.UserIDString), time.Hours, time.Minutes, time.Seconds), Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 20, Color = "1 1 1 0.75", FadeIn = 2.5f },
				    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
					new CuiOutlineComponent { Color = "0 0 0 1", Distance = "0.2 -0.2" }
				} 
			});	
			 
			CuiHelper.AddUi(player, container);
			player.Invoke(() => { CuiHelper.DestroyUi(player, ".TimerGUI"); CuiHelper.DestroyUi(player, ".TimerGUIText"); }, 15.0f);
		} 

        	}
}


// --- End of file: XRestartUI.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/XPEqualizer.cs ---
// --- Original Local Path: XPEqualizer.cs ---

using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Configuration;
using Rust.Xp;

namespace Oxide.Plugins
{
    [Info("XPEqualizer", "k1lly0u", "0.1.4", ResourceId = 2003)]
    class XPEqualizer : RustPlugin
    {
        #region Fields
        EqualizerData equalData;
        private DynamicConfigFile data;

        #endregion

        #region Oxide Hooks
        void Loaded()
        {
            data = Interface.Oxide.DataFileSystem.GetFile("XPEqualizer");
            lang.RegisterMessages(Messages, this);
        }
        void Unload() => SaveData();
        void OnServerInitialized()
        {
            LoadVariables();
            LoadData();            
            foreach (var player in BasePlayer.activePlayerList)
                OnPlayerInit(player);
            SaveLoop();
        }
        void OnPlayerInit(BasePlayer player)
        {
            if (configData.SkipAdminXP && player.IsAdmin()) return;
            if (player == null) return;

            if (!equalData.PlayerXP.ContainsKey(player.userID))
            {
                if (player.xp.CurrentLevel < 2)
                {
                    var avgXP = GetAverageStats();
                    if (avgXP > 1)
                    {
                        ResetPlayerLevel(player.userID, avgXP);
                        SendMSG(player, MSG("boostMessage", player.UserIDString));
                    }
                }
                else
                {
                    var playerxp = GetPlayerXP(player);
                    if (playerxp == null) playerxp = 0f;
                    equalData.PlayerXP.Add(player.userID, (float)playerxp);
                }
            }
        }
        void OnXpEarned(ulong playerid, float amount, string source)
        {
            var player = BasePlayer.FindByID(playerid);
            if (player != null)
            {
                if (configData.SkipAdminXP && player.IsAdmin()) return;                

                if (equalData.PlayerXP.ContainsKey(player.userID))
                    equalData.PlayerXP[player.userID] += amount;
                else
                {
                    var playerxp = GetPlayerXP(player);
                    if (playerxp == null) playerxp = 0f;
                    equalData.PlayerXP.Add(player.userID, (float)playerxp);
                }
            }
            else if (equalData.PlayerXP.ContainsKey(playerid))
                equalData.PlayerXP[playerid] += amount;            
        }
        #endregion

        #region Functions
        private float GetAverageStats()
        {            
            float xpAmount = 0;
            float count = 0;

            foreach (var player in equalData.PlayerXP)
            {
                if (player.Value < 1) continue;
                xpAmount += player.Value;
                count++;
            }
            if (xpAmount == 0 || count == 0) return 1;
                     
            var averageXP = xpAmount / count;
            return averageXP;
        }
        private object GetPlayerXP(BasePlayer player) => player.xp.SpentXp + player.xp.UnspentXp;
        
        private void ResetPlayerLevel(ulong userid, float amount, string message = null)
        {
            if (amount <= 1) return;
            var agent = BasePlayer.FindXpAgent(userid);
            agent?.Reset();
            agent?.Add(Definitions.Cheat, amount);

            if (equalData.PlayerXP.ContainsKey(userid))
                equalData.PlayerXP[userid] = amount;
            else equalData.PlayerXP.Add(userid, amount);

            if (!string.IsNullOrEmpty(message))
            {
                var player = BasePlayer.FindByID(userid);
                if (player != null)
                    SendMSG(player, message);
            }   
        }
        private BasePlayer FindPlayer(BasePlayer player, string arg)
        {
            var foundPlayers = new List<BasePlayer>();
            ulong steamid;
            ulong.TryParse(arg, out steamid);
            string lowerarg = arg.ToLower();

            foreach (var p in BasePlayer.activePlayerList)
            {
                if (p != null)
                {
                    if (steamid != 0L)
                        if (p.userID == steamid) return p;
                    string lowername = p.displayName.ToLower();
                    if (lowername.Contains(lowerarg))
                    {
                        foundPlayers.Add(p);
                    }
                }
            }
            if (foundPlayers.Count == 0)
            {
                foreach (var sleeper in BasePlayer.sleepingPlayerList)
                {
                    if (sleeper != null)
                    {
                        if (steamid != 0L)
                            if (sleeper.userID == steamid)
                            {
                                foundPlayers.Clear();
                                foundPlayers.Add(sleeper);
                                return foundPlayers[0];
                            }
                        string lowername = player.displayName.ToLower();
                        if (lowername.Contains(lowerarg))
                        {
                            foundPlayers.Add(sleeper);
                        }
                    }
                }
            }
            if (foundPlayers.Count == 0)
            {
                if (player != null)
                    SendMSG(player, "XP Equalizer: ", MSG("noPlayers", player.UserIDString));
                return null;
            }
            if (foundPlayers.Count > 1)
            {
                if (player != null)
                    SendMSG(player, "XP Equalizer: ", MSG("multiPlayers", player.UserIDString));
                return null;
            }

            return foundPlayers[0];
        }
        #endregion

        #region Chat Commands
        [ChatCommand("xpe")]
        private void cmdXPE(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin()) return;
            if (args == null || args.Length == 0)
            {
                SendMSG(player, "/xpe reset <playername>", MSG("resetName", player.UserIDString));
                SendMSG(player, "/xpe reset all", MSG("resetAll", player.UserIDString));
                SendMSG(player, "/xpe average", MSG("average", player.UserIDString));
            }
            var avgXP = GetAverageStats();
            if (args.Length == 1 && args[0].ToLower() == "average")
            {
                SendMSG(player, MSG("cAverage", player.UserIDString), $"{(int)avgXP} XP");
            }
            if (args.Length > 1)
            {
                
                if (args[1].ToLower() == "all")
                {
                    foreach (var p in BasePlayer.sleepingPlayerList)
                    {
                        if (p == null) continue;
                        if (p.IsAdmin() && configData.IgnoreAdmins_Reset) continue;
                        ResetPlayerLevel(p.userID, avgXP, MSG("resetMessage", p.UserIDString));
                    }
                    foreach (var p in BasePlayer.activePlayerList)
                    {
                        if (p == null) continue;
                        if (p.IsAdmin() && configData.IgnoreAdmins_Reset) continue;
                        ResetPlayerLevel(p.userID, avgXP, MSG("resetMessage", p.UserIDString));
                    }                        
                }
                else
                {
                    var target = FindPlayer(player, args[1]);
                    if (target != null)
                    {                       
                        ResetPlayerLevel(target.userID, avgXP, MSG("resetMessage", target.UserIDString));
                    }
                }
            }
        }
        #endregion

        #region Config        
        private ConfigData configData;
        class ConfigData
        {
            public string MSG_MainColor { get; set; }
            public string MSG_Color { get; set; }
            public bool IgnoreAdmins_Reset { get; set; }            
            public bool SkipAdminXP { get; set; }
        }
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                IgnoreAdmins_Reset = true,
                MSG_MainColor = "<color=orange>",
                MSG_Color = "<color=#939393>",
                SkipAdminXP = true
            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion

        #region Data Management
        void SaveLoop() => timer.Once(600, () => { SaveData(); SaveLoop(); });
        void SaveData() => data.WriteObject(equalData);
        void LoadData()
        {
            try
            {
                equalData = data.ReadObject<EqualizerData>();
            }
            catch
            {
                equalData = new EqualizerData();
            }
        }
        class EqualizerData
        {
            public Dictionary<ulong, float> PlayerXP = new Dictionary<ulong, float>();
        }
        #endregion

        #region Messaging
        private void SendMSG(BasePlayer player, string message, string message2 = "") => SendReply(player, $"{configData.MSG_MainColor}{message}</color>{configData.MSG_Color}{message2}</color>");
        private string MSG(string key, string playerid = null) => lang.GetMessage(key, this, playerid);

        Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            {"boostMessage", "Your XP has been boosted to the current server average" },
            {"resetMessage", "Your XP has been reset to the current server average" },
            {"noPlayers", "No players found" },
            {"multiPlayers", "Multiple players found with that name" },
            {"resetName", " - Resets the target players XP to the server average" },
            {"resetAll", " - Calculates the average server XP and sets all players to that amount" },
            {"average", " - Display the current average XP amount" },
            {"cAverage", "Current Average: " }
        };
        #endregion
    }
}


// --- End of file: XPEqualizer.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/DeathKick.cs ---
// --- Original Local Path: DeathKick.cs ---

using System;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("DeathKick", "k1lly0u", "0.1.2", ResourceId = 1779)]
    public class DeathKick : RustPlugin
    {        
        private Dictionary<ulong, double> deadPlayers = new Dictionary<ulong, double>();
        private List<Timer> Timers = new List<Timer>();
        private Dictionary<ulong, int> deathCounts = new Dictionary<ulong, int>();

        #region oxide hooks
        void Loaded() => lang.RegisterMessages(messages, this);
        void OnServerInitialized()
        {
            LoadVariables();
            permission.RegisterPermission("deathkick.exempt", this);
        }
        void Unload() => ClearData();
        #endregion

        #region functions
        void OnEntityDeath(BaseEntity entity, HitInfo hitinfo)
        {
            try
            {
                if (entity != null)
                    if (entity is BasePlayer)
                        ProcessDeath((BasePlayer)entity, hitinfo); 
            }
            catch (Exception ex)
            {
            }
        }
        private void ProcessDeath(BasePlayer player, HitInfo info, bool isBounty = false)
        {            
            if (!GetDeathType(player, info)) return;
            if (player.IsAdmin() || permission.UserHasPermission(player.UserIDString, "deathkick.exempt")) return;
            if (useBounty && !isBounty) return;

            if (!deathCounts.ContainsKey(player.userID))
                deathCounts.Add(player.userID, 0);
            deathCounts[player.userID]++;

            if (deathCounts[player.userID] >= deathLimit)
            {
                deadPlayers.Add(player.userID, GrabCurrentTime() + (cooldownTime * 60));
                Timers.Add(timer.Once(cooldownTime * 60, () => deadPlayers.Remove(player.userID)));
                Network.Net.sv.Kick(player.net.connection, string.Format(lang.GetMessage("died", this, player.UserIDString), cooldownTime, lang.GetMessage("minutes", this, player.UserIDString)));
                deathCounts.Remove(player.userID);
            }
        }
        public bool GetDeathType(BasePlayer player, HitInfo info)
        {
            if (info == null && useFall) return true;

            BaseEntity entity = info.Initiator;
            if (entity == null) return false;
            else if (entity.ToPlayer() != null)
            {
                if (info.damageTypes.GetMajorityDamageType().ToString() == "Suicide" && useSuicide) return true;
                if (usePlayers) return true;
            }
            else if (entity.name.Contains("patrolhelicopter.pr") && useHeli) return true;
            else if (entity.name.Contains("animals/") && useAnimals) return true;
            else if (entity.name.Contains("beartrap.prefab") && useBeartrap) return true;
            else if (entity.name.Contains("landmine.prefab") && useLandmine) return true;
            else if (entity.name.Contains("spikes.floor.prefab") && useFloorspikes) return true;
            else if (entity.name.Contains("autoturret_deployed.prefab") && useAutoturret) return true;
            else if ((entity.name.Contains("deployable/barricades") || entity.name.Contains("wall.external.high")) && useBarricades) return true;
            return false;
        }
        object CanClientLogin(Network.Connection connection)
        {
            if (deadPlayers.ContainsKey(connection.userid))
            {
                int remaining = (int)deadPlayers[connection.userid] - (int)GrabCurrentTime();                
                int time = remaining / 60;
                string timeMsg = lang.GetMessage("minutes", this, connection.userid.ToString());

                if (remaining <= 90)
                {
                    time = remaining;
                    timeMsg = lang.GetMessage("seconds", this, connection.userid.ToString());
                }

                return string.Format(lang.GetMessage("wait", this, connection.userid.ToString()), time, timeMsg);
            }
            return null;
        }
        void ClearData()
        {
            foreach (var entry in Timers)
                entry.Destroy();
            deadPlayers.Clear();
        }
        static double GrabCurrentTime()
        {
            return DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds;
        }
        #endregion

        #region config
        static int cooldownTime = 30;
        static int deathLimit = 1;
        static bool usePlayers = true;
        static bool useHeli = true;
        static bool useAnimals = true;
        static bool useBeartrap = true;
        static bool useLandmine = true;
        static bool useFloorspikes = true;
        static bool useBarricades = true;
        static bool useAutoturret = true;
        static bool useSuicide = true;
        static bool useFall = true;
        static bool useBounty = false;

        private bool changed;

        protected override void LoadDefaultConfig()
        {
            Puts("Creating a new config file");
            Config.Clear();
            LoadVariables();
        }
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        private void LoadConfigVariables()
        {
            CheckCfg("Death types - Players", ref usePlayers);
            CheckCfg("Death types - Helicopters", ref useHeli);
            CheckCfg("Death types - Animals", ref useAnimals);
            CheckCfg("Death types - Beartraps", ref useBeartrap);
            CheckCfg("Death types - Landmines", ref useLandmine);
            CheckCfg("Death types - Floorspikes", ref useFloorspikes);
            CheckCfg("Death types - Barricades", ref useBarricades);
            CheckCfg("Death types - Autoturrets", ref useAutoturret);
            CheckCfg("Death types - Suicide", ref useSuicide);
            CheckCfg("Death types - Fall", ref useFall);
            CheckCfg("Death Limit", ref deathLimit);
            CheckCfg("Bounty kills only", ref useBounty);
            CheckCfg("Timer - Amount of time a player is kicked for (minutes)", ref cooldownTime);            
        }
        private void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T)
                var = (T)Config[Key];
            else
                Config[Key] = var;
        }
        private void CheckCfgFloat(string Key, ref float var)
        {

            if (Config[Key] != null)
                var = Convert.ToSingle(Config[Key]);
            else
                Config[Key] = var;
        }
        object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                changed = true;
            }
            return value;
        }
        #endregion

        #region messages
        Dictionary<string, string> messages = new Dictionary<string, string>
        {
            { "died", "You died and must wait {0} {1} before reconnecting" },
            { "wait", "You must wait another {0} {1} before you can reconnect" },
            { "minutes", "minutes" },
            { "seconds", "seconds" }
        };
        #endregion
    }
}


// --- End of file: DeathKick.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Give.cs ---
// --- Original Local Path: Give.cs ---

// Reference: Oxide.Ext.Rust

using System;
using System.Collections.Generic;

using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Give", "Reneb", "2.1.2", ResourceId = 666)]
    class Give : RustPlugin
    {
        private bool Changed;

        private int giveBasic;
        private int giveAll;
        private int giveKit;
        private string itemNotFound;
        private string multiplePlayersFound;
        private string noPlayersFound;
        private string noAccess;
        private bool logAdmins;
        private bool Stackable;

        private Dictionary<string,string> displaynameToShortname;

        [PluginReference]
        Plugin Kits;
        
        void Loaded() 
        {
            LoadVariables();
            displaynameToShortname = new Dictionary<string, string>();
        }
        void OnServerInitialized()
        {
            InitializeTable();
        }

        private void InitializeTable () {
            displaynameToShortname.Clear ();
            List<ItemDefinition> ItemsDefinition = ItemManager.GetItemDefinitions () ;
            foreach (ItemDefinition itemdef in ItemsDefinition) {
                displaynameToShortname.Add (itemdef.displayName.english.ToString ().ToLower (), itemdef.shortname.ToString ());
            }
        }
        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }
        private void LoadVariables()
        {
            giveBasic = Convert.ToInt32(GetConfig("authLevel", "give", 1));
            giveAll = Convert.ToInt32(GetConfig("authLevel", "giveall", 2));
            giveKit = Convert.ToInt32(GetConfig("authLevel", "givekit", 1));
            logAdmins = Convert.ToBoolean(GetConfig("Give", "logAdmins", true));
            itemNotFound = Convert.ToString(GetConfig("Messages", "itemNotFound", "This item doesn't exist: "));
            multiplePlayersFound = Convert.ToString(GetConfig("Messages", "multiplePlayersFound", "Multiple Players Found"));
            noPlayersFound = Convert.ToString(GetConfig("Messages", "noPlayersFound", "No Players Found"));
            noAccess = Convert.ToString(GetConfig("Messages", "noAccess", "You are not allowed to use this command"));
            Stackable = Convert.ToBoolean(GetConfig("Give", "overrightStackable", false));
            if (Changed)
            {
                SaveConfig();
                Changed = false;
            }
        }
        protected override void LoadDefaultConfig()
        {
            Puts("Give: Creating a new config file");
            Config.Clear();
            LoadVariables();
        }
        bool hasAccess(BasePlayer player, string ttype)
        {
            if (ttype == "give" && player.net.connection.authLevel >= giveBasic)
                return true;
            if (ttype == "giveall" && player.net.connection.authLevel >= giveAll)
                return true;
            if (ttype == "givekit" && player.net.connection.authLevel >= giveKit)
                return true;
            return false;
        }
        private object FindPlayerByID(ulong steamid) {
            BasePlayer targetplayer = BasePlayer.FindByID(steamid);
            if (targetplayer != null)
            {
                return targetplayer;
            }
            targetplayer = BasePlayer.FindSleeping(steamid);
            if (targetplayer != null)
            {
                return targetplayer;
            }
            return null;
        }
        private object FindPlayer(string tofind)
        {
            if (tofind.Length == 17)
            {
                ulong steamid;
                if (ulong.TryParse(tofind.ToString(), out steamid))
                {
                    return FindPlayerByID(steamid);
                }
            }
            List<BasePlayer> onlineplayers = BasePlayer.activePlayerList as List<BasePlayer>;
            object targetplayer = null;
            foreach (BasePlayer player in onlineplayers.ToArray())
            {

                if (player.displayName.ToString() == tofind)
                    return player;
                else if (player.displayName.ToString().Contains(tofind))
                {
                    if (targetplayer == null)
                        targetplayer = player;
                    else
                        return multiplePlayersFound;
                }
            }
            if (targetplayer != null)
                return targetplayer;
            List<BasePlayer> offlineplayers = BasePlayer.sleepingPlayerList as List<BasePlayer>;
            foreach (BasePlayer player in offlineplayers.ToArray())
            {

                if (player.displayName.ToString() == tofind)
                    return player;
                else if (player.displayName.ToString().Contains(tofind))
                {
                    if (targetplayer == null)
                        targetplayer = player;
                    else
                        return multiplePlayersFound;
                }
            }
            if (targetplayer == null)
                return noPlayersFound;
            return targetplayer;
        }
        public object GiveItem(BasePlayer player, string itemname, int amount, ItemContainer pref, out string description)
        {
            description = itemname;
            itemname = itemname.ToLower();
            if (amount < 1) amount = 1;
            bool isBP = false;
            if (itemname.EndsWith(" bp"))
            {
                isBP = true;
                itemname = itemname.Substring(0, itemname.Length - 3);
            }
            if (displaynameToShortname.ContainsKey(itemname))
                itemname = displaynameToShortname[itemname];
            var definition = ItemManager.FindItemDefinition(itemname);
            if (definition == null)
                return string.Format("{0} {1}",itemNotFound,itemname);
            description = definition.displayName.english.ToString();
            int giveamount = 0;
            int stack = (int)definition.stackable;
            if (stack < 1) stack = 1;
            if (isBP)
            {
                stack = 1;
                description = description + " BP";
            }
            if (Stackable && !isBP)
            {
                player.inventory.GiveItem(ItemManager.CreateByItemID((int)definition.itemid, amount, isBP), pref);
                SendReply(player, string.Format("You've received {0} x {1}", description, amount.ToString()));
            }
            else
            {
                for (var i = amount; i > 0; i = i - stack)
                {
                    if (i >= stack)
                        giveamount = stack;
                    else
                        giveamount = i;
                    if (giveamount < 1) return true;
                    player.inventory.GiveItem(ItemManager.CreateByItemID((int)definition.itemid, giveamount, isBP), pref);
                    SendReply(player, string.Format("You've received {0} x {1}", description, giveamount.ToString()));
                }
            }
            return true;
        }
        bool hasKit(string args)
        {
            if (args.Contains(" kit"))
                return true;
            else if (args == "kit")
                return true;
            else if (args.StartsWith("kit "))
                return true;
            return false;
        }
       
        void GiveKit(object source, string[] Args, string ttype)
        {
            if (source is BasePlayer)
            {
                if (((BasePlayer)source).net.connection.authLevel < giveKit)
                {
                    SendTheReply(source, noAccess);
                    return;
                }
            }
            if(Kits == null)
            {
                SendTheReply(source, "You must have the Kits plugin to use this command");
                return;
            }
            if ((ttype == "all" && Args.Length <= 1) || (ttype == "self" && Args.Length <= 1) || (ttype == "player" && Args.Length <= 2))
            {
                SendTheReply(source, "===== Available kits to give =====");
                Kits?.Call ("SendList", source);
                return;
            }
            object target = false;
            if (ttype == "player")
                target = FindPlayer(Args[0]);
            else if (ttype == "self")
                target = source;
            else if (ttype == "all")
                target = true;

            if (target == null) {
                SendTheReply (source, "Couldn't find a player with the steam id " + Args [0].ToString ());
                return;
            }
            if (target is string)
            {
                SendTheReply(source, (string)target);
                return;
            }

            if (Args [Args.Length - 1].ToLower () == "online") {
                var targetPlayer = target as BasePlayer;
                if (!targetPlayer.IsConnected ()) {
                    SendTheReply (source, "Player needs to be online to receive the item!");
                    return;
                }
            }

            object targetkit;
            if (ttype == "player")
                targetkit = Args[2];
            else
                targetkit = Args[1];
            if (ttype == "all")
            {

                int sentkits = 0;
                List<BasePlayer> onlineplayers = BasePlayer.activePlayerList as List<BasePlayer>;
                foreach (BasePlayer onlineplayer in onlineplayers.ToArray())
                {
                    object trytogivekit = Kits?.Call("GiveKit", onlineplayer, targetkit);
                    if (trytogivekit == null || (trytogivekit is bool && (!(bool)trytogivekit)))
                    {
                        SendTheReply(source, "Couldn't give the kit, does it really exist?");
                        return;
                    }
                    sentkits++;
                }
                SendTheReply(source, string.Format("Kit {0} was given to {1} players",targetkit,sentkits.ToString()));
                if (logAdmins)
                    Puts(string.Format("GIVE: /giveall {0} was used", string.Join(" ", Args)));
            }
            else
            {
                object trytogivekit = Kits?.Call ("GiveKit", target, targetkit);
                if (trytogivekit == null || (trytogivekit is bool && (!(bool)trytogivekit)))
                {
                    SendTheReply(source, "Couldn't give the kit, does it really exist?");
                    return;
                }
                if (logAdmins)
                    Puts(string.Format("GIVE: /give {0} was used", string.Join(" ", Args)));
            }
        }
        void SendTheReply(object source, string message)
        {
            if(source is ConsoleSystem.Arg)
                SendReply((ConsoleSystem.Arg)source, message);
            else
                SendReply((BasePlayer)source, message);
        }
        void GivePlayer(object source, string[] Args)
        {
            if (Args.Length == 1)
            {
                SendTheReply(source, "You need to set an item to give");
                return;
            }
            int amount = 1;
            if (Args.Length > 2)
                int.TryParse(Args[2].ToString(), out amount);

            if (amount == 0)
                amount = 1;

            var target = FindPlayer(Args[0].ToString());
            if (target == null) {
                SendTheReply (source, "Couldn't find a player with the steam id " + Args [0].ToString ());
                return;
            }
            if (target is string)
            {
                SendTheReply(source, target.ToString());
                return;
            }

            if (Args [Args.Length - 1].ToLower() == "online") {
                var targetPlayer = target as BasePlayer;
                if (!targetPlayer.IsConnected()) {
                    SendTheReply (source, "Player needs to be online to receive the item!");
                    return;
                }
            }

            string description = Args[1];
            object error = GiveItem((BasePlayer)target, Args[1], amount, (ItemContainer)((BasePlayer)target).inventory.containerMain, out description);
            if (!(error is bool))
            {
                SendTheReply(source, error.ToString());
                return;
            }
            SendTheReply(source, string.Format("Gave {0} x {1} to {2}", description, amount.ToString(), ((BasePlayer)target).displayName.ToString()));
        }
        void GiveSelf(object source, BasePlayer player, string[] Args)
        {
            int amount = 1;
            if (Args.Length > 1)
                int.TryParse(Args[1].ToString(), out amount);

            string description = Args[0];
            object error = GiveItem(player, Args[0], amount, (ItemContainer)player.inventory.containerMain, out description);
            if (!(error is bool))
            {
                SendTheReply(source, error.ToString());
                return;
            }
            SendTheReply(source, string.Format("Gave {0} x {1} to {2}", description, amount.ToString(), player.displayName.ToString()));
        }
        private void GiveToAll(ConsoleSystem.Arg arg)
        {
            int playersSent = 0;
            int amount = 1;
            if (arg.Args.Length > 1)
            {
                int.TryParse(arg.Args[1].ToString(), out amount);
            }
            List<BasePlayer> onlineplayers = BasePlayer.activePlayerList as List<BasePlayer>;
            object error = false;
            string description = arg.Args[0].ToString();
            foreach (BasePlayer player in onlineplayers.ToArray())
            {
                playersSent++;
                error = GiveItem(player, arg.Args[0], amount, (ItemContainer)player.inventory.containerMain, out description);
            }
            if (!(error is bool))
            {
                SendTheReply(arg, error.ToString());
                return;
            }
            SendTheReply(arg, string.Format("Gave {0} x {1} to {2} inventories", description, amount.ToString(), playersSent.ToString()));
        }
        [ChatCommand("give")]
        void cmdChatGivePlayer(BasePlayer player, string command, string[] args)
        {
            if (hasKit(string.Join(" ", args)))
            {
                GiveKit(player, args, "player");
                return;
            }
            if (player.net.connection.authLevel < giveBasic)
            {
                SendReply(player, noAccess);
                return;
            }
            if ((args == null) || (args != null && args.Length == 0))
            {
                SendReply(player, "/give \"Name/SteamID\" \"Item/Kit\" \"Amount\" ");
                return;
            }
            if (logAdmins)
                Puts(string.Format("GIVE: {0} used /give {1}", player.displayName.ToString(), string.Join(" ", args)));
            GivePlayer(player, args);
        }
        [ChatCommand("giveme")]
        void cmdChatGiveMe(BasePlayer player, string command, string[] args)
        {
            if (hasKit(string.Join(" ", args)))
            {
                GiveKit(player, args, "self");
                return;
            }
            if (player.net.connection.authLevel < giveBasic)
            {
                SendReply(player, noAccess);
                return;
            }
            if ((args == null) || (args != null && args.Length == 0))
            {
                SendReply(player, "/giveme \"Item/Kit\" \"Amount\" ");
                return;
            }
            if (logAdmins)
                Puts(string.Format("GIVE: {0} used /giveme {1}", player.displayName.ToString(), string.Join(" ", args)));
            GiveSelf(player, player, args);
        }
        [ConsoleCommand("inv.giveplayer")]
        void cmdConsoleGivePlayer(ConsoleSystem.Arg arg)
        {
            if ((arg.Args == null) || (arg.Args != null && arg.Args.Length == 0))
            {
                SendReply(arg, "inv.giveplayer \"Name/SteamID\" \"Item/Kit\" \"Amount\"");
                return;
            }
            if (hasKit(arg.ArgsStr.ToString()))
            {
                GiveKit(arg, (string[])arg.Args, "player");
                return;
            }
            if (arg.connection != null)
            {
                if (arg.connection.authLevel < giveBasic)
                {
                    SendReply(arg, noAccess);
                    return;
                }
                if (logAdmins)
                    Puts(string.Format("GIVE: {0} used inv.giveplayer {1}", ((BasePlayer)arg.connection.player).displayName.ToString(), arg.ArgsStr.ToString()));
            }
            else
                if (logAdmins)
                    Puts(string.Format("GIVE: {0} used inv.giveplayer {1}", "CONSOLE", arg.ArgsStr.ToString()));
            GivePlayer(arg, arg.Args);
        }
        [ConsoleCommand("inv.give")]
        void cmdConsoleGive(ConsoleSystem.Arg arg)
        {
            if (arg.connection == null)
            {
                SendReply(arg, "You can't use this command from the console");
                return;
            }
            if ((arg.Args == null) || (arg.Args != null && arg.Args.Length == 0))
            {
                SendReply(arg, "inv.give \"Item/Kit\" \"Amount\"");
                return;
            }
            if (hasKit(arg.ArgsStr.ToString()))
            {
                GiveKit(arg, (string[])arg.Args, "self");
                return;
            }
            if (arg.connection != null)
            {
                if (arg.connection.authLevel < giveBasic)
                {
                    SendReply(arg, noAccess);
                    return;
                }
                if (logAdmins)
                    Puts(string.Format("GIVE: {0} used inv.give {1}", ((BasePlayer)arg.connection.player).displayName.ToString(), arg.ArgsStr.ToString()));
            }
            GiveSelf(arg, (BasePlayer)arg.connection.player, (string[])arg.Args);
        }
        [ConsoleCommand("inv.giveall")]
        void cmdConsoleGiveAll(ConsoleSystem.Arg arg)
        {
            if ((arg.Args == null) || (arg.Args != null && arg.Args.Length == 0))
            {
                SendReply(arg, "inv.giveall \"Item/Kit\" \"Amount\"");
                return;
            }
            if (hasKit(arg.ArgsStr.ToString()))
            {
                GiveKit(arg, (string[])arg.Args, "all");
                return;
            }
            if (arg.connection != null)
            {
                if (arg.connection.authLevel < giveAll)
                {
                    SendReply(arg, noAccess);
                    return;
                }
                if (logAdmins)
                    Puts(string.Format("GIVE: {0} used inv.giveall {1}", ((BasePlayer)arg.connection.player).displayName.ToString(), arg.ArgsStr.ToString()));
            }
            else
                if (logAdmins)
                    Puts(string.Format("GIVE: {0} used inv.giveall {1}", "CONSOLE", arg.ArgsStr.ToString()));
            GiveToAll(arg);
        }
    }
}

// --- End of file: Give.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/QuarryHealth.cs ---
// --- Original Local Path: QuarryHealth.cs ---

using System;

namespace Oxide.Plugins
{
    [Info("Quarry Health", "Waizujin", 1.0)]
    [Description("Changes the health value of quarries.")]
    public class QuarryHealth : RustPlugin
    {
        public float quarryHealth { get { return Config.Get<float>("quarry_health"); } }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file.");
            Config.Clear();

            Config["quarry_health"] = 2500f;

            SaveConfig();
        }

        void OnServerInitialized()
        {
            updateQuarries();
        }

        void OnEntityBuilt(Planner planner, UnityEngine.GameObject component)
        {
            ItemDefinition item = planner.GetOwnerItemDefinition();

            if (item.shortname == "mining.quarry")
            {
                updateQuarries();
            }
        }

        public void updateQuarries()
        {
            var quarries = UnityEngine.Object.FindObjectsOfType<MiningQuarry>();

            foreach (MiningQuarry quarry in quarries)
            {
                quarry.health = quarryHealth;
            }
        }
    }
}


// --- End of file: QuarryHealth.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HealthChange.cs ---
// --- Original Local Path: HealthChange.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("HealthChange", "CA$HR(discord: CASHR#6906)", "1.0.0")]
    internal class HealthChange : RustPlugin
    {
        #region Static

        private static HealthChange _;
        private Configuration _config;

        #endregion

        #region Config

        private class Configuration
        {
            [JsonProperty(PropertyName = "Список настроек хп по привилегиям", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, int> HPList = new Dictionary<string, int>()
            {
                ["heathchange.default"] = 100,
                ["heathchange.vip"] = 150,
                ["heathchange.elite"] = 200, 
            };
            
            [JsonProperty(PropertyName = "Список настроек урона по привилегиям", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, float> DamageList = new Dictionary<string, float>()
            {
                ["heathchange.default"] = 1,
                ["heathchange.vip"] = 1.2f,
                ["heathchange.elite"] = 1.5f,
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
                SaveConfig();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }

        protected override void LoadDefaultConfig()
        {
            _config = new Configuration();
        }

        #endregion

        #region OxideHooks

        private void OnServerInitialized()
        {
            _ = this;
            foreach (var check in _config.HPList)
            {
                permission.RegisterPermission(check.Key, this);
            }
            foreach (var check in _config.DamageList)
            {
                permission.RegisterPermission(check.Key, this);
            }
            PrintError("|-----------------------------------|");
            PrintWarning($"|  Plugin {Title} v{Version} is loaded  |");
            PrintWarning("|          Discord: CASHR#6906      |");
            PrintError("|-----------------------------------|");

        }

        private object OnEntityTakeDamage(BaseEntity entity, HitInfo info)
        {
            if (entity == null || info == null) return null;
            var attacker = info.InitiatorPlayer;
            if (attacker == null) return null;
            var damage = GetDamage(attacker);
            info.damageTypes.ScaleAll(damage);
            return null;
        }
        private void OnPlayerRespawned(BasePlayer player)
        {
            UpdateHealth(player, GetMaxHP(player));
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            UpdateHealth(player, GetMaxHP(player));
        }
        private void UpdateHealth(BasePlayer player,float amount)
        {
            var modifiers = new List<ModifierDefintion>();
            modifiers.Clear();

            float HealthPercent = 0;
            amount = amount < 0 ? 0 : amount;
            if (amount < 100)
                HealthPercent = (100f - amount) / 100f * -1;
            else
                HealthPercent = amount / 100f - 1;
            var modifier = new ModifierDefintion()
            {
                type = Modifier.ModifierType.Max_Health, duration = 86400, source = Modifier.ModifierSource.Tea,
                value = HealthPercent,
            };
            modifiers.Add(modifier);
            player.modifiers.Add(modifiers); 
        }
        private int GetMaxHP(BasePlayer player)
        {
            int damage = 100;
            foreach (var check in _config.HPList)
            {
                if(permission.UserHasPermission(player.UserIDString, check.Key))
                    damage = Math.Max(check.Value, damage);
            }
            return damage;
        }
        private float GetDamage(BasePlayer player)
        {
            float damage = 1f;
            foreach (var check in _config.DamageList)
            {
                if(permission.UserHasPermission(player.UserIDString, check.Key))
                    damage = Math.Max(check.Value, damage);
            }
            return damage;
        }
        private void Unload()
        {
            _ = null;
        }

        #endregion


        #region Function

        private void DestroyAll<T>()
        {
            var objects = UnityEngine.Object.FindObjectsOfType(typeof(T));
            objects?.ToList().ForEach(UnityEngine.Object.Destroy);
        }

        #endregion
    }
}

// --- End of file: HealthChange.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/NoNight.cs ---
// --- Original Local Path: NoNight.cs ---

using System.Collections.Generic;
using System;
using System.Reflection;
using System.Data;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;


namespace Oxide.Plugins {
    [Info("NoNight", "BaK", "1.0.2", ResourceId = 1279)]
    class NoNight : RustPlugin {
        public int sunsetHour = 16; // latest time allowed
        public int sunriseHour = 8; // hour to set after time exceeds sunsetHour
        [HookMethod("OnTick")]
        private void OnTick() {
            try {
                    if (TOD_Sky.Instance.Cycle.Hour <= sunsetHour && TOD_Sky.Instance.Cycle.Hour >= sunriseHour) {
                        // it's already day do nothing
                    }
                    else {
						// change time
						TOD_Sky.Instance.Cycle.Hour = sunriseHour;
						Puts("NoNight has changed the server time.");
                    } 
            }
            catch (Exception ex) {
                PrintError("OnTick failed: {0}", ex.Message);
            }
        }
    }
}


// --- End of file: NoNight.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/XPSystem (1).cs ---
// --- Original Local Path: XPSystem (1).cs ---

﻿using System;
using System.Globalization;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries;
using System.Collections.Generic;
using Oxide.Game.Rust.Cui;
using System.Linq;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using UnityEngine;
using VLB;

namespace Oxide.Plugins
{
    [Info("XPSystem", "http://topplugin.ru/", "0.0.8")]
	[Description("Добавляет на сервер XP Систему, благодаря которой, игроки смогут получать баланс в магазине за фарм.")]
    class XPSystem : RustPlugin
    {

        [PluginReference] Plugin ImageLibrary;
		private string Layer = "UI_XPSYSTEM";

        public ulong lastDamageName;
		
		private readonly Dictionary<string, int> playerInfo = new Dictionary<string, int>();
		private readonly List<uint> crateInfo = new List<uint>();
		private static Configuration Settings = new Configuration();
		
        #region Configuration [Конфиг] 
       
	    private class Configuration
        {
            public class API
            {
				[JsonProperty("APIKey (Секретный ключ)")] 
				public string SecretKey = "";
				[JsonProperty("ShopID (ИД магазина в сервисе)")]
				public string ShopID = "";
			}
			
			public class Balance
			{
				[JsonProperty("Сколько рублей на баланс магазина будет выдаваться")]
				public int Money = 5; 
			}
			
			public class Gather
			{
				[JsonProperty("Сколько игроку будет выдаваться XP за подбирание ресурсов")]
				public float CollectiblePickup = 0.15f; //Settings.GatherSettings.CollectiblePickup
				[JsonProperty("Сколько игроку будет выдаваться XP за подбирание плантации")]
				public float CropGather = 0.15f; //Settings.GatherSettings.CropGather
				[JsonProperty("Сколько игроку будет выдаваться XP за фарм бочек")]
				public float BarrelGather = 0.5f; //Settings.GatherSettings.BarrelGather
				[JsonProperty("Сколько игроку будет выдаваться XP за фарм ящиков")]
				public float CrateGather = 0.5f; //Settings.GatherSettings.CrateGather
                [JsonProperty("Сколько игроку будет выдаваться XP за убийство животного")]
				public float AnimalGather = 0.5f; //Settings.GatherSettings.AnimalGather
            }

            public class GathersOptions
			{
				[JsonProperty("Сколько игроку будет выдаваться XP за фарм дерева")]
				public float WoodGathers = 0.5f; //Settings.GathersSetting.WoodGathers
                [JsonProperty("Сколько игроку будет выдаваться XP за фарм обычного камня stones")]
				public float StonesGathers = 0.5f; //Settings.GathersSetting.StonesGathers
                [JsonProperty("Сколько игроку будет выдаваться XP за фарм металлического камня")]
				public float MetalOreGathers = 0.5f; //Settings.GathersSetting.MetalOreGathers
                [JsonProperty("Сколько игроку будет выдаваться XP за фарм серного камня")]
				public float SulfurGathers = 0.5f; //Settings.GathersSetting.SulfurGathers
                [JsonProperty("Сколько игроку будет выдаваться XP за фарм бонус МВК")]
				public float HQMGathers = 0.5f; //Settings.GathersSetting.HQMGathers						
			}
			
			public class GUI
			{
				[JsonProperty("Разрешение для использования команды /xp")]
				public string XpPermission = "xpsystem.use";
                [JsonProperty("Текст в основном блоке (возле аватарки)")]
                public string MainBlockText = "<color=#a5e664><b>XP</b></color> можно заработать путём:\n\n<color=#a5e664><b>—</b></color> Подбирания ресурсов\n<color=#a5e664><b>—</b></color> Фарма руды и деревьев\n<color=#a5e664><b>—</b></color> Выращивания еды (плантации)\n<color=#a5e664><b>—</b></color> Фарма бочек и ящиков\n<color=#a5e664><b>—</b></color> Охоты на людей и животных";	
                [JsonProperty("Текст во втором нижнем блоке")]
				public string SecondBlockText = "Перед выводом <color=#a5e664><b>XP</b></color> убедитесь, что Вы авторизованы в нашем магазине <color=#a5e664>SHOP.GAMESTORES.SU</color>";				
			}
			
			[JsonProperty("Настройки API плагина")]
            public API APISettings = new API();
            [JsonProperty("Настройка кол-ва выдачи баланса игроку")]
            public Balance BalanceSettings = new Balance();
			[JsonProperty("Настройка кол-ва выдачи XP с фарма ресурсов")]
            public Gather GatherSettings = new Gather();
            [JsonProperty("Более подробная настройка кол-ва выдачи XP с фарма ресурсов и животных")]
            public GathersOptions GathersSetting = new GathersOptions();
			[JsonProperty("Настройка интерфейса")]
            public GUI GUISettings = new GUI();
		}
		
        #endregion
		
		#region ConfigLoad / DataFiles [Загрузка конфига и информация в дате]
		
		protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                Settings = Config.ReadObject<Configuration>();
                if (Settings?.APISettings == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning($"Ошибка в конфиге... Создаю новую конфигурацию!");
                LoadDefaultConfig();
            }
            
            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig()
        { 
			PrintWarning(
			                           "Благодарю за приобретение плагина от разработчика плагина: " +
			                           "mabe. Если будут какие-то вопросы, писать - vk.com/zaebokuser");
            Settings = new Configuration();
        } 
        
        protected override void SaveConfig() => Config.WriteObject(Settings);
		
		private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            SaveData();
        }
		
		private void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, Layer);
            }
			SaveData();
        }
		
		public class Xp
		{
			[JsonProperty("Количество XP у игрока:")]
			public float XP { get; set; }
		}
			
		private Dictionary<ulong, Xp> XPS { get; set; }
		
		#endregion
        
        #region GameStores [Запрос в GameStores для обмена XP на рубли] 
		
		bool LogsPlayer = true;

        void MoneyPlus(ulong userId, int amount) {
			ApiRequestBalance(new Dictionary<string, string>() {
				{"action", "moneys"},
				{"type", "plus"},
				{"steam_id", userId.ToString()},
				{"amount", amount.ToString()},
                { "mess", "Обмен XP на рубли! Спасибо, что играете у нас!"}
			});
		}

		void ApiRequestBalance(Dictionary<string, string> args) {
			string url =
				$"https://gamestores.ru/api?shop_id={Settings.APISettings.ShopID}&secret={Settings.APISettings.SecretKey}{string.Join("", args.Select(arg => $"&{arg.Key}={arg.Value}").ToArray())}";
			webrequest.EnqueueGet(url,
				(i, s) => {
					if (i != 200 && i != 201) {
						PrintError($"{url}\nCODE {i}: {s}");

						if (LogsPlayer) {
							LogToFile("logError", $"({DateTime.Now.ToShortTimeString()}): {url}\nCODE {i}: {s}", this);
						}
					} else {
						if (LogsPlayer) {
							LogToFile("logWEB",
								$"({DateTime.Now.ToShortTimeString()}): "
							+ "Пополнение счета:"
							+ $"{string.Join(" ", args.Select(arg => $"{arg.Value}").ToArray()).Replace("moneys", "").Replace("plus", "")}",
								this);
						}
					}

					if (i == 201) {
						PrintWarning("Плагин не работает!");
						Interface.Oxide.UnloadPlugin(Title);
					}
				},
				this);
		}

        #endregion
		
		#region XPFromGather [Добыча]
        
        object OnCollectiblePickup(Item item, BasePlayer player)
        {
            XPS[player.userID].XP += Settings.GatherSettings.CollectiblePickup;
			
            return null;
        }
        
        object OnCropGather(GrowableEntity plant, Item item, BasePlayer player)
        {
            XPS[player.userID].XP += Settings.GatherSettings.CropGather;
			
            return null;
        }
        
        void OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            ProcessItem(player, item);
            return;
        }

        void ProcessItem(BasePlayer player, Item item)
        {
            switch (item.info.shortname)
            {
                case "wood":
                    XPS[player.userID].XP += Settings.GathersSetting.WoodGathers;
                    return;
                    break;
                case "stones":
                    XPS[player.userID].XP += Settings.GathersSetting.StonesGathers;
                    return;
                    break;
                case "metal.ore":
                    XPS[player.userID].XP += Settings.GathersSetting.MetalOreGathers;
                    return;
                    break;
                case "sulfur.ore":
                    XPS[player.userID].XP += Settings.GathersSetting.SulfurGathers;
                    return;
                    break;
                case "hq.metal.ore":
                    XPS[player.userID].XP += Settings.GathersSetting.HQMGathers;
                    return;
                    break;
            }
        }

        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (entity == null) { return; }
            if (info == null) { return; }
            if (info.InitiatorPlayer == null) { return; }
            if (entity is BaseAnimalNPC)
            {
                BasePlayer player = info.InitiatorPlayer;
                XPS[player.userID].XP += Settings.GatherSettings.AnimalGather;
                return;
            }
            if (entity.PrefabName.Contains("barrel"))
            {
                BasePlayer player = info?.InitiatorPlayer;
                XPS[player.userID].XP += Settings.GatherSettings.BarrelGather;
                return;
            }
        }

		private void OnLootEntity(BasePlayer player, BaseEntity entity)
        {
            if (!entity.ShortPrefabName.Contains("crate_") && entity.ShortPrefabName != "heli_crate")
                return;

            if (crateInfo.Contains(entity.net.ID))
                return;

            crateInfo.Add(entity.net.ID);
			XPS[player.userID].XP += Settings.GatherSettings.CrateGather;
        }
		
        #endregion

        #region Hooks [Хуки/проверка]

        private void OnServerInitialized()
        {   
		
			permission.RegisterPermission(Settings.GUISettings.XpPermission, this);
			
			PrintWarning(
			                           "Благодарю за скачивание плагинас форума: " +
			                           "https://topplugin.ru/");
									   
			if (Interface.Oxide.DataFileSystem.ExistsDatafile("XPSystem/Database"))
            { 
                XPS = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, Xp>>("XPSystem/Database");
            }
            else
            {
                XPS = new Dictionary<ulong, Xp>();
            }

            foreach (var player in BasePlayer.activePlayerList)
                GrowableEntity(player);
            SaveData();
        }
        
        private void GrowableEntity(BasePlayer player)
        {
            if (!XPS.ContainsKey(player.userID))
                XPS.Add(player.userID, new Xp { XP = 0 });
			SaveData();
        }

		private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject("XPSystem/Database", XPS);
        }
		
        #endregion

        #region Commands [Команды]

        [ChatCommand("xp")]
        void cmdXp(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, Settings.GUISettings.XpPermission))
            {
                SendReply(player, "У вас <color=#a5e664>недостаточно</color> прав для использования этой команды!");
                return;
            }

            DrawGUI(player);
        }
		
		[ConsoleCommand("xp")]
        private void cmdXp(ConsoleSystem.Arg args)
        {
            if (!args.Player()) return;
            DrawGUI(args.Player());
        }
		
		[ConsoleCommand("xpsell")]
        private void CmdXpSell(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Player();

                if (XPS[player.userID].XP >= 100)
                    {
                        SendReply(player,
							$"Перевод <color=#a5e664>XP в рубли</color> успешно произведён!\nПроверьте свой баланс в магазине.\n<color=#a5e664>В случае не поступления средств сообщите администрации!</color>");
                        XPS[player.userID].XP -= 100;
                        MoneyPlus(player.userID, Settings.BalanceSettings.Money);
                        return;
                    } 
					
				else
                    {
                        SendReply(player,
                            $"<color=#a5e664>Обмен не произведён!</color>\nДля обмена нужно иметь <color=#a5e664>100 XP</color>!\n У вас <color=#a5e664>{XPS[player.userID].XP} XP</color>!");
                        return;
                    }
        }
		
		[ConsoleCommand("xp.give")]
        private void CmdXpgv(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Player();

                BasePlayer target = BasePlayer.Find(args.Args[0]);
                if (target != null)
                {
                    if (XPS.ContainsKey(target.userID))
                    {
                        XPS[target.userID].XP += int.Parse(args.Args[1]);
                        Puts("Баланс успешно изменен");
                    }
                }
            
        }

        #endregion
		
		#region GUI [Интерфейс]
		
		private void DrawGUI(BasePlayer player)
		{	
			CuiHelper.DestroyUi(player, Layer);
			var container = new CuiElementContainer();			
            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Image = { Color = HexToRustFormat("#202020C1"), Material = "assets/content/ui/uibackgroundblur.mat" }
            }, "Overlay", Layer);
			container.Add(new CuiButton //Фононовое закрытие
            {
                RectTransform = { AnchorMin = "-1 -1", AnchorMax = "1.3 1.3", OffsetMax = "0 0" },
                Button = { Color = "0.1 0.1 0.1 0.3", Close = Layer },
                Text = { Text = "" }
            }, Layer);
			//Надпись
			container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0.83", AnchorMax = "1 1", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0" },
                Text = { Text = $"<size=29><b>ОБМЕН БОНУСОВ НА РУБЛИ В МАГАЗИН</b></size>\n<color=#e0e0e0>Здесь вы можете обменять накопленные бонусы XP на реальную валюты и вывести их в магазин.</color>", Color = "1 1 1 0.6313726", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf", FontSize = 15 }
            }, Layer);
            //Инфо-блок возле аватарки №1
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.37617 0.5315456", AnchorMax = $"0.7635456 0.7725456" }, //Max 0-Шырина 0-Высота
                Button = { Color = "1 1 1 0.03", Material = "assets/content/ui/uibackgroundblur.mat" }, 
                Text = { Text = $"<size=17>    ЗДРАВСТВУЙ, <color=#a5e664><b>{player.displayName}</b></color></size>\n\n"+ Settings.GUISettings.MainBlockText, Color = HexToRustFormat("#e0e0e0"), Font = "robotocondensed-regular.ttf", FontSize = 16, Align = TextAnchor.MiddleLeft, FadeIn = 1f }
            }, Layer);
            //Инфо-блок ниже №2
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.2355456 0.3605456", AnchorMax = $"0.7635456 0.4335456" },
                Button = { Color = "0 0 0 0" }, 
                Text = { Text = Settings.GUISettings.SecondBlockText, Color = HexToRustFormat("#e0e0e0"), Font = "robotocondensed-regular.ttf", FontSize = 16, Align = TextAnchor.MiddleCenter, FadeIn = 1f }
            }, Layer);
            //Ваш баланс
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.2355456 0.210", AnchorMax = $"0.7635456 0.250" },
                Button = { Color = "0 0 0 0" },
                Text = { Text = $"ВАШ БАЛАНС <b>XP</b>: <color=#a5e664>{XPS[player.userID].XP}</color>", Color = HexToRustFormat("#e0e0e0"), Font = "robotocondensed-regular.ttf", FontSize = 20, Align = TextAnchor.MiddleCenter, FadeIn = 1f }
            }, Layer);
            //Аватарка до 415 строчки
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.235 0.5315456", AnchorMax = $"0.3725456 0.772" }, //Max 0-Шырина 0-Высота
                Button = { Color = "1 1 1 0.03", Material = "assets/content/ui/uibackgroundblur.mat" },
                Text = { Text = "", FadeIn = 1f }
            }, Layer, "Avatar");

            container.Add(new CuiElement
            {
                Parent = "Avatar",
                Components =
                {
                    new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", player.UserIDString) },
                    new CuiRectTransformComponent { AnchorMin = "0.02 0.0215", AnchorMax = "0.9795 0.980", OffsetMax = "0 0" }
                }
            });
			container.Add(new CuiButton //КНОПКА ОБМЕНА
            {
                RectTransform = { AnchorMin = "0.3875456 0.130", AnchorMax = "0.6115456 0.197" }, //Max 0-Шырина 0-Высота
                Button = { Color = "0.4 0.67 0.41 0.9", Command = "xpsell", Close = Layer, Material = "assets/content/ui/uibackgroundblur.mat" },
                Text = { Text = "ОБМЕНЯТЬ НА РУБЛИ", Align = TextAnchor.MiddleCenter, FontSize = 25, Font = "robotocondensed-regular.ttf", Color = HexToRustFormat("#e0e0e0") }
            }, Layer); 
			
			CuiHelper.AddUi(player, container);
		}
		
		#endregion

        #region Helpers [Хелперы]

		private static string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);

            return $"{color.r:F2} {color.g:F2} {color.b:F2} {color.a:F2}";
        }
		
        #endregion
    }
}

// --- End of file: XPSystem (1).cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/FriendlyFire.cs ---
// --- Original Local Path: FriendlyFire.cs ---

﻿using Oxide.Core;
using Oxide.Core.Plugins;

using Rust;

using System;
using System.Collections.Generic;
using System.Text;

using UnityEngine;

namespace Oxide.Plugins
{
    [Info(FF, "Nogrod", "2.0.1", ResourceId = 687)]
    public class FriendlyFire : RustPlugin
    {
        private const string FF = "FriendlyFire";
        private readonly HashSet<ulong> bypass = new HashSet<ulong>();
        private readonly Dictionary<string, int> times = new Dictionary<string, int>();
        private Dictionary<ulong, bool> ffData;
        private ConfigData configData;

        [PluginReference]
        private Plugin Friends;
        [PluginReference]
        private Plugin Clans;

        class ConfigData
        {
            public bool FriendlyFire { get; set; }
        }

        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                FriendlyFire = false
            };
            Config.WriteObject(config, true);
        }

        private string _(string msgId, BasePlayer player, params object[] args)
        {
            return string.Format(lang.GetMessage(msgId, this, player.UserIDString), args);
        }

        private bool FriendlyFireEnabled(ulong userId)
        {
            if (bypass.Contains(userId)) return true;
            bool enabled;
            return ffData.TryGetValue(userId, out enabled) && enabled;
        }

        private void EnableFriendlyFire(ulong userId)
        {
            ffData[userId] = true;
            Interface.Oxide.DataFileSystem.WriteObject(FF, ffData);
        }

        private void DisableFriendlyFire(ulong userId)
        {
            ffData[userId] = false;
            Interface.Oxide.DataFileSystem.WriteObject(FF, ffData);
        }

        private void Init()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"CannotHurt", "{0} is your friend and cannot be hurt. To disable, type: <color=\"#33cccc\">/ff on</color>"},
                {"Usage", "Usage: <color=\"#33cccc\">/ff [on|off]</color>"},
                {"FFFriends", "Friendly fire is {0} for your friends:"},
                {"FFNotAvailable", "Friendly fire is not available."},
                {"FFEnabled", "<color=red>enabled</color>"},
                {"FFDisabled", "<color=green>disabled</color>"},
                {"NoFriends", "You do not have any friends."},
                {"FFToggle", "To toggle friendly fire on or off, type: <color=\"#33cccc\">/ff on|off</color>"},
                {"FFAlready", "Friendly fire for your friends is already {0}."},
                {"FFChanged", "You have {0} friendly fire for your friends."},
                {"FFHelp1", "<color=\"#33cccc\">/ff</color> - Displays your friendly fire status"},
                {"FFHelp2", "<color=\"#33cccc\">/ff on|off</color> - Toggles friendly fire <color=red>on</color> or <color=green>off</color>"}
            }, this);
            configData = Config.ReadObject<ConfigData>();
            try
            {
                ffData = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, bool>>(FF);
            }
            catch
            {
                ffData = new Dictionary<ulong, bool>();
            }
        }

        private object OnAttackInternal(BasePlayer attacker, BasePlayer victim, HitInfo hit)
        {
            if (configData.FriendlyFire || attacker == victim || FriendlyFireEnabled(attacker.userID))
                return null;
            var victimId = victim.userID;
            var attackerId = attacker.userID;
            var hasFriend = (bool)(Friends?.CallHook("HasFriend", attackerId, victimId) ?? false);
            if (!hasFriend)
            {
                hasFriend = (bool)(Clans?.CallHook("HasFriend", attacker.UserIDString, victim.UserIDString) ?? false);
                if (!hasFriend)
                    return null;
            }
            var now = Facepunch.Math.Epoch.Current;
            int time;
            var key = $"{attackerId}-{victimId}";
            if (!times.TryGetValue(key, out time) || time < now)
            {
                PrintToChat(attacker, _("CannotHurt", attacker, victim.displayName));
                times[key] = now + 10;
            }
            hit.damageTypes = new DamageTypeList();
            hit.DidHit = false;
            hit.HitEntity = null;
            hit.Initiator = null;
            hit.DoHitEffects = false;
            hit.HitMaterial = 0;
            return false;
        }

        void OnPlayerAttack(BasePlayer attacker, HitInfo hitInfo)
        {
            if (hitInfo?.HitEntity is BasePlayer)
                OnAttackInternal(attacker, (BasePlayer) hitInfo.HitEntity, hitInfo);
        }

        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
        {
            if (entity is BasePlayer && hitInfo?.Initiator is BasePlayer)
                OnAttackInternal((BasePlayer) hitInfo.Initiator, (BasePlayer) entity, hitInfo);
        }

        [ConsoleCommand("ff.toggle")]
        private void ccmdFFToggle(ConsoleSystem.Arg arg)
        {
            if (arg.connection != null && (arg.Player() == null || !arg.Player().IsAdmin())) return;
            configData.FriendlyFire = !configData.FriendlyFire;
            Config.WriteObject(configData, true);
        }

        [ChatCommand("ff")]
        private void cmdChatFF(BasePlayer player, string command, string[] args)
        {
            if (configData.FriendlyFire)
            {
                SendReply(player, _("FFNotAvailable", player));
                return;
            }
            if (args.Length > 1)
            {
                SendReply(player, _("Usage", player));
                return;
            }
            if (args.Length == 0)
            {
                var sb = new StringBuilder();
                sb.AppendLine(_("FFFriends", player, _(FriendlyFireEnabled(player.userID) ? "FFEnabled" : "FFDisabled", player)));
                var friendList = (string[]) Friends?.CallHook("GetFriendList", player.userID);
                if (friendList != null && friendList.Length > 0)
                    sb.AppendLine(string.Join(", ", friendList));
                else
                    sb.AppendLine(_("NoFriends", player));
                sb.Append(_("FFToggle", player));
                SendReply(player, sb.ToString());
                return;
            }
            switch (args[0])
            {
                case "1":
                case "on":
                case "true":
                case "yes":
                    if (FriendlyFireEnabled(player.userID))
                        SendReply(player, _("FFAlready", player, _("FFEnabled", player)));
                    else
                    {
                        EnableFriendlyFire(player.userID);
                        SendReply(player, _("FFChanged", player, _("FFEnabled", player)));
                    }
                    break;
                case "0":
                case "off":
                case "false":
                case "no":
                    if (!FriendlyFireEnabled(player.userID))
                        SendReply(player, _("FFAlready", player, _("FFDisabled", player)));
                    else
                    {
                        DisableFriendlyFire(player.userID);
                        SendReply(player, _("FFChanged", player, _("FFDisabled", player)));
                    }
                    break;
                default:
                    SendReply(player, _("Usage", player));
                    break;
            }
        }

        private void SendHelpText(BasePlayer player)
        {
            var sb = new StringBuilder();
            sb.Append("  ").AppendLine(_("FFHelp1", player));
            sb.Append("  ").Append(_("FFHelp2", player));
            player.ChatMessage(sb.ToString());
        }

        #region API Methods

        private bool EnableBypass(object userId)
        {
            if (userId == null)
                throw new ArgumentException(nameof(userId));
            if (userId is string)
                userId = Convert.ToUInt64((string) userId);
            return bypass.Add((ulong) userId);
        }

        private bool DisableBypass(object userId)
        {
            if (userId == null)
                throw new ArgumentException(nameof(userId));
            if (userId is string)
                userId = Convert.ToUInt64((string) userId);
            return bypass.Remove((ulong) userId);
        }

        #endregion
    }
}


// --- End of file: FriendlyFire.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BuildingOwners.cs ---
// --- Original Local Path: BuildingOwners.cs ---

using System.Collections.Generic;
using System;
using System.Reflection;
using System.Data;
using UnityEngine;
using Facepunch;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Building Owners", "Reneb", "3.0.2")]
    class BuildingOwners : RustPlugin
    {
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Static Fields
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////

        private Core.Configuration.DynamicConfigFile BuildingOwnersData;

        private static bool serverInitialized = false;
         
        int constructionLayer = LayerMask.GetMask("Construction", "Construction Trigger");

        string changeownerPermissions = "buildingowners.changeowner";


        //////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Oxide Hooks
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////

        void Loaded()
        {
            BuildingOwnersData = Interface.GetMod().DataFileSystem.GetDatafile("BuildingOwners");

            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"You don't have the permissions to use this command.","You don't have the permissions to use this command." },
                {"You are not allowed to use this command.","You are not allowed to use this command." },
                {"Syntax: /changeowner PLAYERNAME/STEAMID","Syntax: /changeowner PLAYERNAME/STEAMID" },
                {"Target player not found.","Target player not found." },
                {"New owner of this house is: {0}","New owner of this house is: {0}" },
                {"An admin gave you the ownership of this house","An admin gave you the ownership of this house" }
            }, this);
        }

        void OnServerInitialized() { serverInitialized = true; }

        void OnEntityBuilt(HeldEntity heldentity, GameObject gameobject)
        {
            if (!serverInitialized) return;

            var block = gameobject.GetComponent<BuildingBlock>();
            if (block == null) return;

            var player = heldentity.GetOwnerPlayer();
            if (player == null) return;

            var blockdata = FindBlockData(block);
            if (blockdata is string) return;

            SetBlockData(block, player.userID.ToString());
        }

        void OnServerSave()
        {
            SaveData();
        }
        void OnServerQuit()
        {
            SaveData();
        }

        void OnNewSave(string name)
        {
            Interface.Oxide.LogWarning("BuildingOwners: Wipe detected. Saving last buildingowners data in BuildingOwners_backup");

            var BuildingOwnersData_backup = Interface.GetMod().DataFileSystem.GetDatafile("BuildingOwners_backup");
            BuildingOwnersData_backup.Clear();
            var e = BuildingOwnersData.GetEnumerator();
            while(e.MoveNext())
            {
                BuildingOwnersData_backup[e.Current.Key] = e.Current.Value;
            }
            Interface.GetMod().DataFileSystem.SaveDatafile("BuildingOwners_backup");

            BuildingOwnersData = Interface.GetMod().DataFileSystem.GetDatafile("BuildingOwners");
            BuildingOwnersData.Clear();
            SaveData();
        }

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Data Management
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////

        void SaveData()
        {
            Interface.GetMod().DataFileSystem.SaveDatafile("BuildingOwners");
        }

        void SetBlockData(BuildingBlock block, string steamid)
        {
            BuildingOwnersData[block.buildingID.ToString()] = steamid;
        }

        object FindBlockData(BuildingBlock block)
        {
            var buildingid = block.buildingID.ToString();
            if (BuildingOwnersData[buildingid] != null) return BuildingOwnersData[buildingid];
            return false;
        }

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // General Methods
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////

        string GetMsg(string key, object steamid = null) { return lang.GetMessage(key, this, steamid == null ? null : steamid.ToString()); }
        string GetMsg(string key, BasePlayer player = null) { return GetMsg(key, player == null ? null : player.userID.ToString()); }
        bool hasAccess(BasePlayer player, string permissionName) { if (player.net.connection.authLevel > 1) return true; return permission.UserHasPermission(player.userID.ToString(), permissionName); }

        object FindBuilding(BasePlayer player, Vector3 sourcePos, Vector3 sourceDirection)
        {
            RaycastHit rayhit;
            if (!UnityEngine.Physics.Raycast(sourcePos, sourceDirection, out rayhit, constructionLayer))
            {
                return GetMsg("Couldn't find any constructions", player);
            }
            var entity = rayhit.GetEntity();
            if (entity == null)
            {
                return GetMsg("Couldn't find any constructions", player);
            }
            var block = entity.GetComponent<BuildingBlock>();
            if (block == null)
            {
                return GetMsg("Couldn't find any constructions", player);
            }
            return block;
        }

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Chat Command
        //////////////////////////////////////////////////////////////////////////////////////////////////////////////

        [ChatCommand("changeowner")]
        void cmdChatchangeowner(BasePlayer player, string command, string[] args)
        {
            if (!hasAccess(player, changeownerPermissions))
            {
                SendReply(player, GetMsg("You are not allowed to use this command.",player));
                return; 
            }
            if (args == null || args.Length < 1)
            {
                SendReply(player, GetMsg("Syntax: /changeowner PLAYERNAME/STEAMID", player));
                return;
            }
            var target = BasePlayer.Find(args[0].ToString());
            if (target == null || target.net == null || target.net.connection == null)
            {
                SendReply(player, GetMsg("Target player not found.",player));
            }
            else
            {
                object block = FindBuilding(player, player.eyes.position, player.eyes.rotation * Vector3.forward);
                if ( block is string )
                {
                    SendReply(player, (string)block);
                }
                else
                {
                    var buildingblock = (BuildingBlock)block;
                    var userid = target.userID.ToString();
                    SetBlockData(buildingblock, userid);
                    SendReply(player, string.Format(GetMsg("New owner of this house is: {0}",player),target.displayName));
                    SendReply(target, GetMsg("An admin gave you the ownership of this house",target));
                }
            }
        }
    }
}

// --- End of file: BuildingOwners.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/LadderAnywhere.cs ---
// --- Original Local Path: LadderAnywhere.cs ---

using System.Reflection;
using UnityEngine;
using System.Linq;
using Oxide.Core.Plugins;
using System.Text;

namespace Oxide.Plugins
{
    [Info("LadderAnywhere", "LadderAnywhere by Deicide666ra", "1.0.7", ResourceId = 1327)]
    public class LadderAnywhere : RustPlugin
    {
        class LadderConfig
        {
            public LadderConfig() { }

            public float maxDist = 5; // meters
            public int authLevel = 0; // 0= anyone, 1= moderator/owner, 2= owner only
            public bool radiationCheck = true; // true means players cannot place ladders in radiation areas

            // Item blacklist, if the object pointed contains these words, abort placement
            public string[] blacklist = new[] { "wall.external", "player", "ladder", "cupboard", "furnace", "barricade", "storage" };
        }

        private LadderConfig g_config;

        void Loaded() => LoadConfigValues();
        protected override void LoadDefaultConfig()
        {
            g_config = new LadderConfig();
            Config.WriteObject(g_config, true);
            Puts("New configuration file created.");
        }

        void LoadConfigValues()
        {
            try
            {
                g_config = Config.ReadObject<LadderConfig>();
            }
            catch
            {
                Puts("Could not read config, creating new default config.");
                LoadDefaultConfig();
            }
        }


        [HookMethod("SendHelpText")]
        private void SendHelpText(BasePlayer player)
        {
            var sb = new StringBuilder();
            sb.Append("<color=yellow>LadderAnywehre 1.0.2</color> Â· Bypass building privs with ladders\n");
            sb.Append("Usage: <color=lime>/ldr</color> with a ladder in hand places the ladder where you are pointing.\n");
            sb.Append($"Excluded items: {g_config.blacklist.ToSentence()}");
            player.ChatMessage(sb.ToString());
        }


        [ChatCommand("ldr")]
        void cmdLadder(BasePlayer player, string cmd, string[] args)
        {
            if (player.net.connection.authLevel < g_config.authLevel)
            {
                player.ChatMessage("You are not authorized to use this command.");
                return;
            }

            if (player.GetActiveItem() == null ||
                player.GetActiveItem().info.shortname != "ladder.wooden.wall")
            {
                player.ChatMessage($"You need to have a ladder in hand to do this. {player.GetActiveItem()?.info.shortname}");
                return;
            }

            RaycastHit hit;
            var hitSomething = Physics.Raycast(player.eyes.HeadRay(), out hit, g_config.maxDist);

            if (!hitSomething)
            {
                player.ChatMessage($"You need to be closer to the surface you wish to place the ladder on (max {g_config.maxDist}m).");
                return;
            }

            var prefab = hit.collider.transform.parent?.gameObject?.name;
            var entity = hit.GetEntity();

            if (g_config.radiationCheck && player.radiationLevel != 0)
            {
                player.ChatMessage("You cannot place ladders within radiation zones.");
                return;
            }
            
            if ((prefab == null && entity == null) ||
                (!string.IsNullOrEmpty(prefab) && g_config.blacklist.Any(e => prefab.Contains(e))) ||
                (entity != null && g_config.blacklist.Any(e => entity.LookupPrefabName().Contains(e))))
            {
                player.ChatMessage($"You cannot put a ladder on this item.");
                return;
            }


            Quaternion currentRot;
            if (!TryGetPlayerView(player, out currentRot))
                return;

            player.GetActiveItem().RemoveFromContainer();
            DoDeploy(player, hit.collider, currentRot, hit.point);
        }


       // Just a debug function to test if a ladder would fit there or not
       [ChatCommand("lt")]
        void cmdLt(BasePlayer player, string cmd, string[] args)
        {
            if (!player.IsAdmin())
            {
                player.ChatMessage("You are not authorized to use this command.");
                return;
            }

            RaycastHit hit;
            var hitSomething = Physics.Raycast(player.eyes.HeadRay(), out hit, g_config.maxDist);

            if (!hitSomething)
            {
                player.ChatMessage($"You need to be closer to the surface you wish to place the ladder on (max {g_config.maxDist}m).");
                return;
            }

            var entity = hit.GetEntity();
            if (entity != null)
                player.ChatMessage($"Entity: {entity.LookupPrefabName()}");

            var prefab = hit.GetCollider().transform.parent?.gameObject?.name;
            if (prefab != null)
                player.ChatMessage($"Prefab: {prefab}");
           
            if (g_config.radiationCheck && player.radiationLevel != 0)
            {
                player.ChatMessage("You cannot place ladders within radiation zones.");
                return;
            }

            if (!string.IsNullOrEmpty(prefab) && g_config.blacklist.Any(e => prefab.Contains(e)) ||
                (prefab == null && entity == null))
            {
                player.ChatMessage($"You cannot put a ladder on this item.");
                return;
            }

        }


        /////////////////////////////////////////////////////
        ///  DoDeploy(BuildPlayer buildplayer, BasePlayer player, Collider baseentity)
        ///  Deploy Deployables
        ///  FULL CREDIT TO RENEB, I TOTALLY STOLE THIS
        /////////////////////////////////////////////////////
        private void DoDeploy(BasePlayer player, Collider baseentity, Quaternion currentRot, Vector3 closestHitpoint)
        {
            var VectorUP = new Vector3(0f, 1f, 0f);
            var newPos = closestHitpoint + (VectorUP * 0f);
            var newRot = currentRot;
            newRot.x = 0f;
            newRot.z = 0f;
            SpawnDeployable("assets/prefabs/building/ladder.wall.wood/ladder.wooden.wall.prefab", newPos, newRot, player);
        }


        /////////////////////////////////////////////////////
        ///  SpawnDeployable()
        ///  Function to spawn a deployable
        ///  FULL CREDIT TO RENEB, I TOTALLY STOLE THIS
        /////////////////////////////////////////////////////
        private void SpawnDeployable(string prefab, Vector3 pos, Quaternion angles, BasePlayer player)
        {
            var newBaseEntity = GameManager.server.CreateEntity(prefab, pos, angles);
            if (newBaseEntity == null)
            {
                return;
            }
            newBaseEntity.SendMessage("SetDeployedBy", player, SendMessageOptions.DontRequireReceiver);
            newBaseEntity.SendMessage("InitializeItem", newBaseEntity, SendMessageOptions.DontRequireReceiver);
            newBaseEntity.Spawn(true);
            newBaseEntity.transform.RotateAround(newBaseEntity.transform.position, newBaseEntity.transform.up, 180f);
            newBaseEntity.SendNetworkUpdate();
        }


        /////////////////////////////////////////////////////
        ///  TryGetPlayerView( BasePlayer player, out Quaternion viewAngle )
        ///  Get the angle on which the player is looking at
        ///  Notice that this is very usefull for spectating modes as the default player.transform.rotation doesn't work in this case.
        ///  FULL CREDIT TO RENEB, I TOTALLY STOLE THIS
        /////////////////////////////////////////////////////
        static bool TryGetPlayerView(BasePlayer player, out Quaternion viewAngle)
        {
            viewAngle = new Quaternion(0f, 0f, 0f, 0f);

            var serverinput = typeof(BasePlayer).GetField("serverInput", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
            var input = serverinput.GetValue(player) as InputState;
            if (input == null)
                return false;
            if (input.current == null)
                return false;

            viewAngle = Quaternion.Euler(input.current.aimAngles);
            return true;
        }
    }
}

// --- End of file: LadderAnywhere.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/EventManagerNotifier.cs ---
// --- Original Local Path: EventManagerNotifier.cs ---

using Oxide.Core.Plugins;
using Oxide.Core.Libraries.Covalence;
using System.Linq;
using System.Collections.Generic;
using Oxide.Core;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("EventManagerNotifier", "M&B-Studios", "1.0.2")]
    public class EventManagerNotifier : RustPlugin
    {
        private ConfigData configData;

        class EventConfig
        {
            public bool MessagesActive { get; set; }
            public string EventName { get; set; }
            public string StartCommand { get; set; }
            public string StartMessage { get; set; }
        }

        class ConfigData
        {
            public List<EventConfig> Events { get; set; } = new List<EventConfig>();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            configData = new ConfigData
            {
                Events = new List<EventConfig>
                {
                    new EventConfig
                    {
                        MessagesActive = true,
                        EventName = "Airdrop",
                        StartCommand = "em_spawn assets/prefabs/misc/supply drop/supply_drop.prefab",
                        StartMessage = "Airdrop was <color=green>dropped</color>"
                    },
                    new EventConfig
                    { 
                        MessagesActive = true,
                        EventName = "Chinook 47",
                        StartCommand = "em_spawn assets/prefabs/npc/ch47/ch47scientists.entity.prefab",
                        StartMessage = "Chinook 47 has <color=green>started</color> and is making its rounds"
                    },
                    new EventConfig
                    {
                        MessagesActive = true,
                        EventName = "Cargoship",
                        StartCommand = "em_spawn assets/content/vehicles/boats/cargoship/cargoshiptest.prefab",
                        StartMessage = "CargoShip sets sail and has <color=green>started</color> the journey"
                    },
                    new EventConfig
                    {
                        MessagesActive = true,
                        EventName = "Helicopter",
                        StartCommand = "em_spawn assets/prefabs/npc/patrol helicopter/patrolhelicopter.prefab",
                        StartMessage = "Helicopter <color=green>started</color> the sightseeing flight"
                    }
                }
            };
            SaveConfig();
        }

        private void OnEventStarted(string eventname)
        {
            var @event = configData.Events.FirstOrDefault(x => x.EventName == eventname);
            if (@event != null)
                Server.Broadcast(@event.StartMessage);
        }
        
        void Init()
        {
            configData = Config.ReadObject<ConfigData>();
            if (configData == null || configData.Events == null || configData.Events.Count == 0)
            {
                LoadDefaultConfig();
            }

            foreach (var eventConfig in configData.Events)
            {
                cmd.AddChatCommand(eventConfig.StartCommand, this, nameof(CmdEventStart));
                cmd.AddConsoleCommand(eventConfig.StartCommand, this, nameof(cmdEventStartConsole));   
                // AddCovalenceCommand(eventConfig.StartCommand, "CmdEventStart");
            }
        }

        private void cmdEventStartConsole(ConsoleSystem.Arg arg) => CmdEventStart(arg.Player(), "", arg.Args);

        private void CmdEventStart(BasePlayer player, string command, string[] args)
        {
            var eventConfig = configData.Events.Find(e => e.StartCommand == command);
            if (eventConfig != null && eventConfig.MessagesActive)
            {
                Server.Broadcast(eventConfig.StartMessage);
            }
        }

        void SaveConfig() => Config.WriteObject(configData);
    }
}


// --- End of file: EventManagerNotifier.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/IQKits.cs ---
// --- Original Local Path: IQKits.cs ---

﻿using System;
using System.Collections;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using System.Linq;
using System.Text;
using ConVar;

namespace Oxide.Plugins
{
    [Info("IQKits", "Mercury", "0.0.3")]
    [Description("Лучшие наборы из всех,которые есть")]
    class IQKits : RustPlugin
    {
        /// <summary>
        /// Обновление 0.0.2
        /// - Добавил дополнительную проверку на юзера
        /// - Поправил удаление набора
        /// - Исправил шанс выпадения предмета
        /// - Добавлена возможность открывать набор после N дня вайпа
        /// - Добавлена возможность выдавать автоматический набор с учетом N дня вайпа
        /// 
        ///  /// Обновление 0.0.3
        /// - Исправил появление наборов после N дня вайпа
        /// </summary>

        #region Reference
        [PluginReference] Plugin ImageLibrary, IQPlagueSkill, IQChat;

        #region IQChat
        public void SendChat(BasePlayer player, string Message, Chat.ChatChannel channel = Chat.ChatChannel.Global)
        {
            var Chat = config.ReferenceSetting.IQChatSetting;
            if (IQChat)
                IQChat?.Call("API_ALERT_PLAYER", player, Message, Chat.CustomPrefix, Chat.CustomAvatar);
            else player.SendConsoleCommand("chat.add", channel, 0, Message);
        }
        #endregion

        #region ImageLibrary
        private string GetImage(string fileName, ulong skin = 0)
        {
            var imageId = (string)plugins.Find("ImageLibrary").CallHook("GetImage", fileName, skin);
            if (!string.IsNullOrEmpty(imageId))
                return imageId;
            return string.Empty;
        }
        public bool AddImage(string url, string shortname, ulong skin = 0) => (bool)ImageLibrary?.Call("AddImage", url, shortname, skin);
        public void SendImage(BasePlayer player, string imageName, ulong imageId = 0) => ImageLibrary?.Call("SendImage", player, imageName, imageId);
        public bool HasImage(string imageName) => (bool)ImageLibrary?.Call("HasImage", imageName);

        #endregion

        #region IQPlagueSkill
        bool IS_SKILL_COOLDOWN(BasePlayer player) => (bool)IQPlagueSkill?.CallHook("API_IS_COOLDOWN_SKILL_KITS", player);
        bool IS_SKILL_RARE(BasePlayer player) => (bool)IQPlagueSkill?.CallHook("API_IS_RARE_SKILL_KITS", player);
        int GET_SKILL_COOLDOWN_PERCENT() => (int)IQPlagueSkill?.CallHook("API_GET_COOLDOWN_IQKITS");
        int GET_SKILL_RARE_PERCENT() => (int)IQPlagueSkill?.CallHook("API_GET_RARE_IQKITS");
        #endregion

        #endregion

        #region Vars 
        public static DateTime TimeCreatedSave = SaveRestore.SaveCreatedTime.Date;
        public static DateTime RealTime = DateTime.Now.Date;
        public static int WipeTime = RealTime.Subtract(TimeCreatedSave).Days;

        enum TypeKits
        {
            Cooldown,
            Amount,
            Started,
            AmountCooldown,
        }
        enum ContainerItem
        {
            containerWear,
            containerBelt,
            containerMain
        }
        public Dictionary<BasePlayer, int> PagePlayers = new Dictionary<BasePlayer, int>();
        #endregion

        #region Configuration
        private static Configuration config = new Configuration();
        private class Configuration
        {
            [JsonProperty("Общие настройки")]
            public GeneralSettings GeneralSetting = new GeneralSettings();
            [JsonProperty("Настройки интерфейса")]
            public InterfaceSettings InterfaceSetting = new InterfaceSettings();
            [JsonProperty("Настройка наборов")]
            public Dictionary<string, Kits> KitList = new Dictionary<string, Kits>();
            [JsonProperty("Настройки плагинов совместимости")]
            public ReferenceSettings ReferenceSetting = new ReferenceSettings();
            internal class ReferenceSettings
            {
                [JsonProperty("Настройки IQChat")]
                public IQChatSettings IQChatSetting = new IQChatSettings();
                internal class IQChatSettings
                {
                    [JsonProperty("IQChat : Кастомный префикс в чате")]
                    public string CustomPrefix;
                    [JsonProperty("IQChat : Кастомный аватар в чате(Если требуется)")]
                    public string CustomAvatar;
                }
            }
            internal class GeneralSettings
            {
                [JsonProperty("Ключ стартового набора(Дается при возрождении)(если включен список нескольких наборов, данная функция отключается)")]
                public string StartKitKey;
                [JsonProperty("Использовать сразу несколько стартовых наборов(они будут выбираться случайно)")]
                public bool UseStartedKitList;
                [JsonProperty("Список ключей стартового набора(Дается при возрождении)")]
                public List<KitRandom> StartedKitList = new List<KitRandom>();
                internal class KitRandom
                {
                    [JsonProperty("Ключ набора")]
                    public string StartKitKey;
                    [JsonProperty("Права для набора(не оставляйте это поле пустым)")]
                    public string Permissions;
                }
            }
            internal class InterfaceSettings
            {
                [JsonProperty("HEX: Цвет заднего фона")]
                public string HEXBackground;
                [JsonProperty("HEX: Цвет текста")]
                public string HEXLabels;
                [JsonProperty("HEX: Кнопки с информацией")]
                public string HEXInfoItemButton;
                [JsonProperty("HEX: Цвет текста на кнопке с информацией")]
                public string HEXLabelsInfoItemButton;
                [JsonProperty("HEX: Цвет кнопки забрать")]
                public string HEXAccesButton;
                [JsonProperty("HEX: Цвет текста на кнопке забрать")]
                public string HEXLabelsAccesButton;
                [JsonProperty("HEX: Цвет полосы перезарядки")]
                public string HEXCooldowns;
                [JsonProperty("HEX: Цвет блоков с информацией")]
                public string HEXBlock;
                [JsonProperty("HEX: Цвет блоков на которых будут лежать предметы")]
                public string HEXBlockItemInfo;
                [JsonProperty("Время появления интерфейса(его плавность)")]
                public float InterfaceFadeOut;
                [JsonProperty("Время исчезновения интерфейса(его плавность)")]
                public float InterfaceFadeIn;
                [JsonProperty("PNG заднего фона с информацией о том,что находится в наборе")]
                public string PNGInfoPanel;
                [JsonProperty("PNG заднего фона уведомления")]
                public string PNGAlert;
            }
            internal class Kits
            {
                [JsonProperty("Тип набора(0 - С перезарядкой, 1 - Лимитированый, 2 - Стартовый(АвтоКит), 3 - Лимитированый с перезарядкой)")]
                public TypeKits TypeKit;
                [JsonProperty("Отображаемое имя")]
                public string DisplayName;
                [JsonProperty("Через сколько дней вайпа будет доступен набор")]
                public int WipeOpened;
                [JsonProperty("Права")]
                public string Permission;
                [JsonProperty("PNG(128x128)")]
                public string PNG;
                [JsonProperty("Sprite(Установится если отсутствует PNG)")]
                public string Sprite;
                [JsonProperty("Shortname(Установится если отсутствует PNG и Sprite)")]
                public string Shortname;
                [JsonProperty("Время перезарядки набора")]
                public int CoolDown;
                [JsonProperty("Количество сколько наборов можно взять")]
                public int Amount;
                [JsonProperty("Предметы , которые будут даваться в данном наборе")]
                public List<ItemsKit> ItemKits = new List<ItemsKit>();

                internal class ItemsKit
                {
                    [JsonProperty("Выберите контейнер в который будет перенесен предмет(0 - Одежда, 1 - Панель быстрого доступа, 2 - Рюкзак)")]
                    public ContainerItem ContainerItemType;
                    [JsonProperty("Название предмета")]
                    public string DisplayName;
                    [JsonProperty("Shortname предмета")]
                    public string Shortname;
                    [JsonProperty("Количество(Если это команда,так-же указывайте число)")]
                    public int Amount;
                    [JsonProperty("Шанс на выпадения предмета(Оставьте 0 - если не нужен шанс)")]
                    public int Rare;
                    [JsonProperty("SkinID предмета")]
                    public ulong SkinID;
                    [JsonProperty("PNG предмета(если установлена команда)")]
                    public string PNG;
                    [JsonProperty("Sprite(Если установлена команда и не установлен PNG)")]
                    public string Sprite;
                    [JsonProperty("Команда(%STEAMID% заменится на ID пользователя)")]
                    public string Command;
                }
            }

            public static Configuration GetNewConfiguration()
            {
                return new Configuration
                {
                    ReferenceSetting = new ReferenceSettings
                    {
                        IQChatSetting = new ReferenceSettings.IQChatSettings
                        {
                            CustomAvatar = "",
                            CustomPrefix = "",
                        }
                    },
                    GeneralSetting = new GeneralSettings
                    {
                        UseStartedKitList = false,
                       
                        StartedKitList = new List<GeneralSettings.KitRandom>
                        {
                            new GeneralSettings.KitRandom
                            {
                                Permissions = "iqkits.default",
                                StartKitKey = "start1"
                            },
                            new GeneralSettings.KitRandom
                            {
                                Permissions = "iqkits.vip",
                                StartKitKey = "hunter"
                            },
                        },
                        StartKitKey = "start1",
                    },
                    InterfaceSetting = new InterfaceSettings
                    {
                        HEXBackground = "#0000006A",
                        HEXBlock = "#646361A6",
                        HEXAccesButton = "#708a47",
                        HEXBlockItemInfo = "#3D492837",
                        HEXInfoItemButton = "#8a6347",
                        HEXCooldowns = "#708A47D8",
                        HEXLabels = "#FFFFFFFF",
                        HEXLabelsAccesButton = "#C9E39FFF",
                        HEXLabelsInfoItemButton = "#C9E39FFF",
                        InterfaceFadeIn = 0.35f,
                        InterfaceFadeOut = 0.35f,
                        PNGAlert = "https://i.imgur.com/g4Mzn9a.png",
                        PNGInfoPanel = "https://i.imgur.com/9kbOqHK.png",
                    }
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning($"Ошибка чтения #57 конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!!");
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewConfiguration();
        protected override void SaveConfig() => Config.WriteObject(config);
        #endregion

        #region Data
        [JsonProperty("Дата с информацией о игроках")]
        public Dictionary<ulong, DataKitsUser> DataKitsUserList = new Dictionary<ulong, DataKitsUser>();

        public class DataKitsUser
        {
            [JsonProperty("Информация о наборах игрока")]
            public Dictionary<string, InfoKits> InfoKitsList = new Dictionary<string, InfoKits>();
            internal class InfoKits
            {
                public int Amount;
                public int Cooldown;
            }
        }  
        void ReadData() => DataKitsUserList = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, DataKitsUser>>("IQKits/KitsData");
        void WriteData() => Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQKits/KitsData", DataKitsUserList);
        void RegisteredDataUser(BasePlayer player)
        {
            if (!DataKitsUserList.ContainsKey(player.userID))
                DataKitsUserList.Add(player.userID, new DataKitsUser
                {
                    InfoKitsList = new Dictionary<string, DataKitsUser.InfoKits> { }
                });

            foreach(var Kit in config.KitList.Where(x => !DataKitsUserList[player.userID].InfoKitsList.ContainsKey(x.Key)))
                DataKitsUserList[player.userID].InfoKitsList.Add(Kit.Key, new DataKitsUser.InfoKits { Amount = Kit.Value.Amount, Cooldown = 0 });
            
        }

        #endregion

        #region Metods 

        #region Images
        void LoadedImage()
        {
            var Interface = config.InterfaceSetting;
            foreach (var Kit in config.KitList.Where(k => !String.IsNullOrWhiteSpace(k.Value.PNG)))
            {
                if (!HasImage($"KIT_{Kit.Value.PNG}"))
                    AddImage(Kit.Value.PNG, $"KIT_{Kit.Value.PNG}");

                foreach (var img in Kit.Value.ItemKits.Where(i => !String.IsNullOrWhiteSpace(i.PNG)))
                {
                    if (!HasImage($"ITEM_KIT_PNG_{img.PNG}"))
                        AddImage(img.PNG, $"ITEM_KIT_PNG_{img.PNG}");
                }
            }
            if (!HasImage($"INFO_BACKGROUND_{Interface.PNGInfoPanel}"))
                AddImage(Interface.PNGInfoPanel, $"INFO_BACKGROUND_{Interface.PNGInfoPanel}");

            if (!HasImage($"INFO_ALERT_BACKGROUND_{Interface.PNGAlert}"))
                AddImage(Interface.PNGAlert, $"INFO_ALERT_BACKGROUND_{Interface.PNGAlert}");

            ServerMgr.Instance.StartCoroutine(DownloadImages());
        }
        private IEnumerator DownloadImages()
        {
            PrintError("AddImages SkyPlugins.ru...");
            foreach (var Kit in config.KitList)
                foreach (var img in Kit.Value.ItemKits.Where(i => !String.IsNullOrWhiteSpace(i.Shortname)))
                {
                    if (!HasImage($"{img.Shortname}_128px"))
                        AddImage($"http://rust.skyplugins.ru/getimage/{img.Shortname}/128", $"{img.Shortname}_128px");
                }
            yield return new WaitForSeconds(0.04f);
            PrintError("AddImages SkyPlugins.ru - completed..");
        }
        void CachingImage(BasePlayer player)
        {
            var Interface = config.InterfaceSetting;
            foreach (var Kit in config.KitList.Where(k => !String.IsNullOrWhiteSpace(k.Value.PNG)))
            {
                SendImage(player, $"KIT_{Kit.Value.PNG}");

                foreach (var ItemKit in Kit.Value.ItemKits.Where(ik => !String.IsNullOrWhiteSpace(ik.Shortname)))
                    SendImage(player, $"{ItemKit.Shortname}_128px");

                foreach (var img in Kit.Value.ItemKits.Where(i => !String.IsNullOrWhiteSpace(i.PNG)))
                    if (!HasImage($"ITEM_KIT_PNG_{img.PNG}"))
                        AddImage(img.PNG, $"ITEM_KIT_PNG_{img.PNG}");
                
            }
            SendImage(player, $"INFO_BACKGROUND_{Interface.PNGInfoPanel}");
            SendImage(player, $"INFO_ALERT_BACKGROUND_{Interface.PNGAlert}");
        }
        #endregion

        #region Registered Permissions
        void RegisteredPermissions()
        {
            var GeneralSettings = config.GeneralSetting;
            var KitList = config.KitList;

            foreach(var PermissionGeneral in GeneralSettings.StartedKitList)
                if (!permission.PermissionExists(PermissionGeneral.Permissions, this))
                    permission.RegisterPermission(PermissionGeneral.Permissions, this);

            foreach (var PermissionKits in KitList)
                if (!permission.PermissionExists(PermissionKits.Value.Permission, this))
                    permission.RegisterPermission(PermissionKits.Value.Permission, this);
        }
        #endregion

        #region AutoKit
        void AutoKitGive(BasePlayer player)
        {
            if (player == null) return;
            var GeneralSettings = config.GeneralSetting;
            var KitList = config.KitList;

            if (GeneralSettings.UseStartedKitList)
            {
                List<Configuration.GeneralSettings.KitRandom> RandomingKit = new List<Configuration.GeneralSettings.KitRandom>();
                foreach (var StartedKitList in GeneralSettings.StartedKitList.Where(k => permission.UserHasPermission(player.UserIDString, k.Permissions) && KitList.ContainsKey(k.StartKitKey) && WipeTime >= KitList[k.StartKitKey].WipeOpened))
                    RandomingKit.Add(StartedKitList);
                
                var RandomKit = RandomingKit.GetRandom();
                if (RandomKit == null) return;
                ParseAndGive(player, RandomKit.StartKitKey);
            }
            else
            {
                if (!KitList.ContainsKey(GeneralSettings.StartKitKey))
                {
                    PrintWarning("У вас не верно указан стартовый ключ, такого набора не существует! Игрок не получил его автоматически");
                    return;
                }
                ParseAndGive(player, GeneralSettings.StartKitKey);
            }
        }
        #endregion

        #region TakeKit
        void TakeKit(BasePlayer player, string KitKey)
        {
            var Kit = config.KitList[KitKey];
            var ItemKit = Kit.ItemKits;
            var Data = DataKitsUserList[player.userID].InfoKitsList[KitKey];

            if (Data.Cooldown >= CurrentTime()) return;

            int BeltAmount = ItemKit.Where(i => i.ContainerItemType == ContainerItem.containerBelt).Count();
            int WearAmount = ItemKit.Where(i => i.ContainerItemType == ContainerItem.containerWear).Count();
            int MainAmount = ItemKit.Where(i => i.ContainerItemType == ContainerItem.containerMain).Count();
            int Total = BeltAmount + WearAmount + MainAmount;
            if ((player.inventory.containerBelt.capacity - player.inventory.containerBelt.itemList.Count) < BeltAmount 
            || (player.inventory.containerWear.capacity - player.inventory.containerWear.itemList.Count) < WearAmount 
            || (player.inventory.containerMain.capacity - player.inventory.containerMain.itemList.Count) < MainAmount)
                if (Total > (player.inventory.containerMain.capacity - player.inventory.containerMain.itemList.Count))
                {
                    Interface_Alert_Kits(player, GetLang("UI_ALERT_FULL_INVENTORY", player.UserIDString));
                    return;
                }

            switch (Kit.TypeKit)
            {
                case TypeKits.Cooldown:
                    {
                        int Cooldown = IQPlagueSkill ? IS_SKILL_COOLDOWN(player) ? (Kit.CoolDown - (Kit.CoolDown / 100 * GET_SKILL_COOLDOWN_PERCENT())) : Kit.CoolDown : Kit.CoolDown;
                        Data.Cooldown = Convert.ToInt32(CurrentTime() + Cooldown);
                        break;
                    }
                case TypeKits.Amount:
                    {
                        Data.Amount--;
                        break;
                    }
                case TypeKits.AmountCooldown:
                    {
                        int Cooldown = IQPlagueSkill ? IS_SKILL_COOLDOWN(player) ? (Kit.CoolDown - (Kit.CoolDown / 100 * GET_SKILL_COOLDOWN_PERCENT())) : Kit.CoolDown : Kit.CoolDown;
                        Data.Amount--;
                        Data.Cooldown = Convert.ToInt32(CurrentTime() + Cooldown); break;
                    }
            }
            ParseAndGive(player, KitKey);
            DestroyKits(player);
            Interface_Loaded_Kits(player);
            Interface_Alert_Kits(player, GetLang("UI_ALERT_ACCES_KIT", player.UserIDString, Kit.DisplayName));
        }
        void ParseAndGive(BasePlayer player, string KitKey)
        {
            var Kit = config.KitList[KitKey];
            var ItemKit = Kit.ItemKits;
            foreach (var Item in ItemKit)
            {
                if (Item.Rare != 0)
                {
                    int Rare = IQPlagueSkill ? IS_SKILL_RARE(player) ? Item.Rare + GET_SKILL_RARE_PERCENT() : Item.Rare : Item.Rare;
                    if (!IsRareDrop(Rare)) continue;
                }

                if (!String.IsNullOrWhiteSpace(Item.Command))
                    rust.RunServerCommand(Item.Command.Replace("%STEAMID%", player.UserIDString));
                else
                {
                    Item item = ItemManager.CreateByName(Item.Shortname, Item.Amount > 1 ? Item.Amount : 1, Item.SkinID);
                    if (!String.IsNullOrWhiteSpace(Item.DisplayName))
                        item.name = Item.DisplayName;
                    GiveItem(player, item, Item.ContainerItemType == ContainerItem.containerBelt ? player.inventory.containerBelt : Item.ContainerItemType == ContainerItem.containerWear ? player.inventory.containerWear : player.inventory.containerMain);
                }
            }
        }
        private void GiveItem(BasePlayer player, Item item, ItemContainer cont = null)
        {
            if (item == null) return;
            var inv = player.inventory;

            var MovedContainer = item.MoveToContainer(cont) || item.MoveToContainer(inv.containerMain);
            if (!MovedContainer)
            {
                if (cont == inv.containerBelt)
                    MovedContainer = item.MoveToContainer(inv.containerWear);
                if (cont == inv.containerWear)
                    MovedContainer = item.MoveToContainer(inv.containerBelt);
            }

            if (!MovedContainer)
                item.Drop(player.GetCenter(), player.GetDropVelocity());
        }
        #endregion

        #region Kit Metods Admin

        #region Kit Add
        void CreateNewKit(BasePlayer player, string NameKit)
        {
            if (!player.IsAdmin) return;

            if (config.KitList.ContainsKey(NameKit))
            {
                SendChat(player, "Ключ данного набора уже существует!");
                return;
            }

            config.KitList.Add(NameKit, new Configuration.Kits
            {
                Amount = 0,
                CoolDown = 300,
                DisplayName = NameKit,
                Permission = "iqkits.setting",
                PNG = "",
                Shortname = "",
                Sprite = "assets/icons/gear.png",
                TypeKit = TypeKits.Cooldown,
                ItemKits = GetPlayerItems(player)
            });

            SaveConfig();
            SendChat(player, $"Набор с ключем {NameKit} успешно создан");
        }

        private List<Configuration.Kits.ItemsKit> GetPlayerItems(BasePlayer player)
        {
            List<Configuration.Kits.ItemsKit> kititems = new List<Configuration.Kits.ItemsKit>();
            foreach (Item item in player.inventory.containerWear.itemList)
            {
                if (item != null)
                {
                    var iteminfo = ItemToKit(item, ContainerItem.containerWear);
                    kititems.Add(iteminfo);
                }
            }
            foreach (Item item in player.inventory.containerMain.itemList)
            {
                if (item != null)
                {
                    var iteminfo = ItemToKit(item, ContainerItem.containerMain);
                    kititems.Add(iteminfo);
                }
            }
            foreach (Item item in player.inventory.containerBelt.itemList)
            {
                if (item != null)
                {
                    var iteminfo = ItemToKit(item, ContainerItem.containerBelt);
                    kititems.Add(iteminfo);
                }
            }
            return kititems;
        }
        private Configuration.Kits.ItemsKit ItemToKit(Item item, ContainerItem containerItem)
        {
            Configuration.Kits.ItemsKit ItemsKit = new Configuration.Kits.ItemsKit();

            ItemsKit.Amount = item.amount;
            ItemsKit.ContainerItemType = containerItem;
            ItemsKit.Shortname = item.info.shortname;
            ItemsKit.SkinID = item.skin;
            ItemsKit.Rare = 0;
            ItemsKit.PNG = "";
            ItemsKit.Sprite = "";
            ItemsKit.Command = "";
            ItemsKit.DisplayName = "";

            return ItemsKit;
        }
        #endregion

        #region Kit Remove
        void KitRemove(BasePlayer player, string NameKit)
        {
            if (!player.IsAdmin) return;

            if (!config.KitList.ContainsKey(NameKit))
            {
                SendChat(player, "Набора с таким ключем не существует!");
                return;
            }

            config.KitList.Remove(NameKit);
            SaveConfig();
            SendChat(player, $"Набора с ключем {NameKit} успешно удален");
        }

        #endregion

        #endregion
        public bool IsRareDrop(int Rare) => UnityEngine.Random.Range(0, 100) >= (100 - (Rare > 100 ? 100 : Rare));
        #endregion

        #region Hooks
        object OnPlayerRespawned(BasePlayer player)
        {
            player.inventory.Strip();
            AutoKitGive(player);
            return null;
        }
        private void OnServerInitialized()
        {
            RegisteredPermissions();
            ReadData();
            LoadedImage();

            foreach (BasePlayer p in BasePlayer.activePlayerList)
                OnPlayerConnected(p);

            WriteData();
        }
        void OnPlayerConnected(BasePlayer player)
        {
            CachingImage(player);
            RegisteredDataUser(player);
        }
        void Unload()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
                DestroyAll(player);

            ServerMgr.Instance.StopCoroutine(DownloadImages());

            WriteData();
        }
        #endregion

        #region Commands
        [ChatCommand("kit")]
        void IQKITS_ChatCommand(BasePlayer player, string cmd, string[] arg)
        {
            if (arg.Length < 2 || arg == null || arg == null)
            {
                PagePlayers[player] = 0;
                Interface_IQ_Kits(player);
                return;
            }

            switch (arg[0])
            {
                case "create":
                case "createkit":
                case "add":
                case "new":
                    {
                        string NameKit = arg[1];
                        if(string.IsNullOrWhiteSpace(NameKit))
                        {
                            SendChat(player, "Введите корректное название!");
                            return;
                        }
                        CreateNewKit(player, NameKit);
                        break;
                    }
                case "remove":
                case "delete":
                case "revoke":
                    {
                        string NameKit = arg[1];
                        if (string.IsNullOrWhiteSpace(NameKit))
                        {
                            SendChat(player, "Введите корректное название!");
                            return;
                        }
                        KitRemove(player, NameKit);
                        break;
                    }
            }
        }
        [ConsoleCommand("kit_ui_func")]
        void IQKITS_UI_Func(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if(player == null)
            {
                PrintWarning("Это консольная команда должна отыгрываться от игрока!");
                return;
            }
            string Key = arg.Args[0];
            switch(Key)
            {
                case "information": 
                    {
                        string KitKey = arg.Args[1];
                        Interface_Info_Kits(player, KitKey);
                        break;
                    }
                case "take.kit": 
                    {
                        string KitKey = arg.Args[1];
                        TakeKit(player, KitKey);
                        break;
                    }
                case "close.ui":
                    {
                        DestroyAll(player);
                        break;
                    }
                case "hide.info": 
                    {
                        DestroyInfoKits(player);
                        break;
                    }
                case "next.page": 
                    {
                        DestroyKits(player);
                        PagePlayers[player]++;
                        Interface_Loaded_Kits(player);
                        break;
                    }
                case "back.page":
                    {
                        DestroyKits(player);
                        PagePlayers[player]--;
                        Interface_Loaded_Kits(player);
                        break;
                    }
            }
            
        }
        #endregion

        #region Interface
        void DestroyAll(BasePlayer player)
        {
            DestroyAlert(player);
            DestroyInfoKits(player);
            DestroyKits(player);
            CuiHelper.DestroyUi(player, "CLOSE_BTN");
            CuiHelper.DestroyUi(player, "DESCRIPTION");
            CuiHelper.DestroyUi(player, "TITLE");
            CuiHelper.DestroyUi(player, IQKITS_OVERLAY);
            player.SetFlag(BaseEntity.Flags.Reserved3, false);
            ServerMgr.Instance.StopCoroutine(UI_UpdateCooldown(player));
        }
        void DestroyKits(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, $"BTN_BACK_BUTTON");
            CuiHelper.DestroyUi(player, $"BTN_NEXT_BUTTON");

            for (int i = 0; i < 4; i++)
            {
                CuiHelper.DestroyUi(player, $"WHAT_INFO_{i}");
                CuiHelper.DestroyUi(player, $"TAKE_KIT_{i}");
                CuiHelper.DestroyUi(player, $"COOLDOWN_LINE_{i}");
                CuiHelper.DestroyUi(player, $"COOLDOWN_TITLE{i}");
                CuiHelper.DestroyUi(player, $"COOLDOWN_PANEL_{i}");
                CuiHelper.DestroyUi(player, $"TITLE_KIT_{i}");
                CuiHelper.DestroyUi(player, $"DISPLAY_NAME_PANEL_{i}");
                CuiHelper.DestroyUi(player, $"AVATAR_{i}");
                CuiHelper.DestroyUi(player, $"AVATAR_PANEL_{i}");
                CuiHelper.DestroyUi(player, $"KIT_PANEL_{i}");
            }
        }
        void DestroyAlert(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, $"TITLE_ALERT");
            CuiHelper.DestroyUi(player, $"INFO_ALERT_BACKGROUND");
        }
        void DestroyInfoKits(BasePlayer player)
        {
            for (int i = 0; i < 40; i++)
            {
                CuiHelper.DestroyUi(player, $"KIT_ITEM_AMOUNT_{i}");
                CuiHelper.DestroyUi(player, $"RARE_LABEL_{i}");
                CuiHelper.DestroyUi(player, $"RARE_BACKGROUND_{i}");
                CuiHelper.DestroyUi(player, $"KIT_ITEM_{i}");
                CuiHelper.DestroyUi(player, $"ITEM_{i}");
            }
            CuiHelper.DestroyUi(player, $"TITLE_KIT_INFO");
            CuiHelper.DestroyUi(player, $"HIDE_INFO_BTN");
            CuiHelper.DestroyUi(player, $"INFO_BACKGROUND");
        }

        public static string IQKITS_OVERLAY = "IQKITS_OVERLAY";
        void Interface_IQ_Kits(BasePlayer player)
        {
            DestroyAll(player);
            player.SetFlag(BaseEntity.Flags.Reserved3, true);
            CuiElementContainer container = new CuiElementContainer();
            var Interface = config.InterfaceSetting;
            float FadeIn = Interface.InterfaceFadeIn;
            float FadeOut = Interface.InterfaceFadeOut;

            container.Add(new CuiPanel
            {
                FadeOut = FadeOut,
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Image = { FadeIn = FadeIn, Color = HexToRustFormat(Interface.HEXBackground), Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
            }, "Overlay", IQKITS_OVERLAY);

            container.Add(new CuiLabel
            {
                FadeOut = FadeOut,
                RectTransform = { AnchorMin = "0 0.915", AnchorMax = "1 1" },
                Text = { FadeIn = FadeIn, Text = GetLang("UI_TITLE", player.UserIDString), Color = HexToRustFormat(Interface.HEXLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            },  IQKITS_OVERLAY, "TITLE");

            container.Add(new CuiLabel
            {
                FadeOut = FadeOut,
                RectTransform = { AnchorMin = "0 0.8925912", AnchorMax = "1 0.9351871" },
                Text = { FadeIn = FadeIn, Text = GetLang("UI_DESCRIPTION", player.UserIDString), Color = HexToRustFormat(Interface.HEXLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            }, IQKITS_OVERLAY, "DESCRIPTION");

            container.Add(new CuiButton
            {
                FadeOut = FadeOut - 0.2f,
                RectTransform = { AnchorMin = "0.8718751568 0.9388889", AnchorMax = "1 1" },
                Button = { FadeIn = FadeIn, Command = $"kit_ui_func close.ui", Color = "0 0 0 0" },
                Text = { FadeIn = FadeIn, Text = GetLang("UI_CLOSE_BTN", player.UserIDString), Color = HexToRustFormat(Interface.HEXLabels), Align = TextAnchor.MiddleCenter }
            }, IQKITS_OVERLAY, "CLOSE_BTN");


            CuiHelper.AddUi(player, container);
            Interface_Loaded_Kits(player);
            ServerMgr.Instance.StartCoroutine(UI_UpdateCooldown(player));
        }

        #region LoadedKits
        void Interface_Loaded_Kits(BasePlayer player)
        {
            if(!DataKitsUserList.ContainsKey(player.userID))
                RegisteredDataUser(player);

            CuiElementContainer container = new CuiElementContainer();
            var Interface = config.InterfaceSetting;
            float FadeIn = Interface.InterfaceFadeIn;
            float FadeOut = Interface.InterfaceFadeOut;
            int CountKitPage = config.KitList.Where(k => (k.Value.TypeKit != TypeKits.Started && WipeTime >= k.Value.WipeOpened) && (((k.Value.TypeKit == TypeKits.Amount || k.Value.TypeKit == TypeKits.AmountCooldown) && DataKitsUserList[player.userID].InfoKitsList[k.Key].Amount > 0) || k.Value.TypeKit == TypeKits.Cooldown && permission.UserHasPermission(player.UserIDString, k.Value.Permission))).Skip(4 * (PagePlayers[player] + 1)).Take(4).Count();

            int x = 0, y = 0, i = 0;
            foreach (var Kit in config.KitList.Where(k => (k.Value.TypeKit != TypeKits.Started && WipeTime >= k.Value.WipeOpened) && (((k.Value.TypeKit == TypeKits.Amount || k.Value.TypeKit == TypeKits.AmountCooldown) && DataKitsUserList[player.userID].InfoKitsList[k.Key].Amount > 0) || k.Value.TypeKit == TypeKits.Cooldown && permission.UserHasPermission(player.UserIDString, k.Value.Permission))).Skip(4 * PagePlayers[player]).Take(4))
            {
                var Data = DataKitsUserList[player.userID].InfoKitsList[Kit.Key];

                container.Add(new CuiPanel
                {
                    FadeOut = FadeOut,
                    CursorEnabled = true,
                    RectTransform = { AnchorMin = $"{0.08385417 + (x * 0.52)} {0.5842593 - (y * 0.342)}", AnchorMax = $"{0.3916667 + (x * 0.52)} {0.8231534 - (y * 0.342)}" },
                    Image = { FadeIn = FadeIn, Color = "0 0 0 0" }
                }, IQKITS_OVERLAY, $"KIT_PANEL_{i}");

                #region Avatar
                container.Add(new CuiPanel
                {
                    FadeOut = FadeOut,
                    CursorEnabled = true,
                    RectTransform = { AnchorMin = $"0 0", AnchorMax = $"0.43654821568 1" },
                    Image = { FadeIn = FadeIn, Color = HexToRustFormat(Interface.HEXBlock) }
                }, $"KIT_PANEL_{i}", $"AVATAR_PANEL_{i}");

                if (String.IsNullOrWhiteSpace(Kit.Value.Sprite))
                {
                    var ComponentAvatar = !String.IsNullOrWhiteSpace(Kit.Value.PNG) ? new CuiRawImageComponent { FadeIn = FadeIn, Png = GetImage($"KIT_{Kit.Value.PNG}") } : new CuiRawImageComponent { FadeIn = FadeIn, Png = GetImage(Kit.Value.Shortname) };
                    container.Add(new CuiElement
                    {
                        FadeOut = FadeOut,
                        Parent = $"AVATAR_PANEL_{i}",
                        Name = $"AVATAR_{i}",
                        Components =
                    {
                        ComponentAvatar,
                        new CuiRectTransformComponent{ AnchorMin = "0.0775194 0.07364181", AnchorMax = $"0.9224806 0.9185845"},
                    }
                    });
                }
                else
                {
                    container.Add(new CuiElement
                    {
                        FadeOut = FadeOut,
                        Parent = $"AVATAR_PANEL_{i}",
                        Name = $"AVATAR_{i}",
                        Components =
                    {
                        new CuiImageComponent { FadeIn = FadeIn, Sprite = Kit.Value.Sprite },
                        new CuiRectTransformComponent{ AnchorMin = "0.0775194 0.07364181", AnchorMax = $"0.9224806 0.9185845"},
                    }
                    });
                }
                #endregion

                #region Name

                container.Add(new CuiPanel
                {
                    FadeOut = FadeOut,
                    CursorEnabled = true,
                    RectTransform = { AnchorMin = $"0.4602368 0.6472726", AnchorMax = $"1 1" },
                    Image = { FadeIn = FadeIn, Color = HexToRustFormat(Interface.HEXBlock) }
                }, $"KIT_PANEL_{i}", $"DISPLAY_NAME_PANEL_{i}");

                container.Add(new CuiLabel
                {
                    FadeOut = FadeOut,
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "0.965517 0.9449963" },
                    Text = { FadeIn = FadeIn, Text = GetLang("UI_DISPLAY_NAME_KIT", player.UserIDString, Kit.Value.DisplayName.ToUpper()), Color = HexToRustFormat(Interface.HEXLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperRight }

                }, $"DISPLAY_NAME_PANEL_{i}", $"TITLE_KIT_{i}");
                #endregion

                #region Cooldown
                container.Add(new CuiPanel
                {
                    FadeOut = FadeOut,
                    CursorEnabled = true,
                    RectTransform = { AnchorMin = $"0.4602368 0.2519316", AnchorMax = $"1 0.6046609" },
                    Image = { FadeIn = FadeIn, Color = HexToRustFormat(Interface.HEXBlock) }
                }, $"KIT_PANEL_{i}", $"COOLDOWN_PANEL_{i}");

                double XMax = Data.Cooldown >= CurrentTime() ? (double)((Data.Cooldown - CurrentTime()) * Math.Pow(Kit.Value.CoolDown, -1)) : Data.Amount != 0 ? (double)((Data.Amount) * Math.Pow(Kit.Value.Amount, -1)) : 1;
                container.Add(new CuiPanel
                {
                    FadeOut = FadeOut,
                    CursorEnabled = true,
                    RectTransform = { AnchorMin = $"0 0", AnchorMax = $"{XMax} 1", OffsetMin = "1 1", OffsetMax = "-2 -1" },
                    Image = { FadeIn = FadeIn, Color = HexToRustFormat(Interface.HEXCooldowns) }
                }, $"COOLDOWN_PANEL_{i}", $"COOLDOWN_LINE_{i}");

                string InfoAmountAndCooldown = Data.Cooldown >= CurrentTime() ? GetLang("UI_COOLDONW_KIT", player.UserIDString, FormatTime(TimeSpan.FromSeconds(Data.Cooldown - CurrentTime()))) : Data.Amount != 0 ? GetLang("UI_AMOUNT_KIT", player.UserIDString, Data.Amount) : GetLang("UI_COOLDONW_KIT_NO", player.UserIDString);
                container.Add(new CuiLabel
                {
                    FadeOut = FadeOut,
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "0.965517 0.9449963" },
                    Text = { FadeIn = FadeIn, Text = InfoAmountAndCooldown, Color = HexToRustFormat(Interface.HEXLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperRight }
                }, $"COOLDOWN_PANEL_{i}", $"COOLDOWN_TITLE{i}");
                #endregion

                #region Button

                container.Add(new CuiButton
                {
                    FadeOut = FadeOut - 0.2f,
                    RectTransform = { AnchorMin = "0.4653131568 0", AnchorMax = "0.7258883 0.2170733" },
                    Button = { FadeIn = FadeIn, Command = $"kit_ui_func information {Kit.Key}", Color = HexToRustFormat(Interface.HEXInfoItemButton), },
                    Text = { FadeIn = FadeIn, Text = GetLang("UI_BTN_WHAT_INFO", player.UserIDString), Color = HexToRustFormat(Interface.HEXLabelsInfoItemButton), Align = TextAnchor.MiddleCenter }
                }, $"KIT_PANEL_{i}", $"WHAT_INFO_{i}");

                string KeyLangTake = Data.Cooldown >= CurrentTime() ? GetLang("UI_BTN_TAKE_KIT_BLOCK", player.UserIDString) : Data.Amount != 0 ? GetLang("UI_BTN_TAKE_KIT", player.UserIDString, Data.Amount) : GetLang("UI_BTN_TAKE_KIT", player.UserIDString);
                string HexButtonTake = Data.Cooldown >= CurrentTime() ? Interface.HEXInfoItemButton : Data.Amount != 0 ? Interface.HEXAccesButton : Interface.HEXAccesButton;
                string HexButtonLabelTake = Data.Cooldown >= CurrentTime() ? Interface.HEXLabelsInfoItemButton : Data.Amount != 0 ? Interface.HEXLabelsAccesButton : Interface.HEXLabelsAccesButton;
                string CommandButtonTake = Data.Cooldown >= CurrentTime() ? "" : Data.Amount != 0 ? $"kit_ui_func take.kit {Kit.Key}" : $"kit_ui_func take.kit {Kit.Key}";
                container.Add(new CuiButton
                {
                    FadeOut = FadeOut - 0.2f,
                    RectTransform = { AnchorMin = "0.7394261 0", AnchorMax = "1 0.2170733" },
                    Button = { FadeIn = FadeIn, Command = CommandButtonTake, Color = HexToRustFormat(HexButtonTake) },
                    Text = { FadeIn = FadeIn, Text = KeyLangTake, Color = HexToRustFormat(HexButtonLabelTake), Align = TextAnchor.MiddleCenter }
                }, $"KIT_PANEL_{i}", $"TAKE_KIT_{i}");

                #endregion

                x++;
                if (x >= 2)
                {
                    x = 0;
                    y++;
                }
                i++;
                if (x == 2 && y == 1) break;
            }

            if (PagePlayers[player] != 0)
            {
                container.Add(new CuiButton
                {
                    FadeOut = FadeOut - 0.2f,
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "0.1015625 0.05462963" },
                    Button = { FadeIn = FadeIn, Command = "kit_ui_func back.page", Color = "0 0 0 0" },
                    Text = { FadeIn = FadeIn, Text = GetLang("UI_BACK_BTN", player.UserIDString), Color = HexToRustFormat(Interface.HEXLabels), Align = TextAnchor.MiddleCenter }
                },  IQKITS_OVERLAY, $"BTN_BACK_BUTTON");
            }
            if(CountKitPage != 0)
            {
                container.Add(new CuiButton
                {
                    FadeOut = FadeOut - 0.2f,
                    RectTransform = { AnchorMin = "0.89895 0", AnchorMax = "1 0.05462963" },
                    Button = { FadeIn = FadeIn, Command = $"kit_ui_func next.page", Color = "0 0 0 0" },
                    Text = { FadeIn = FadeIn, Text = GetLang("UI_NEXT_BTN", player.UserIDString), Color = HexToRustFormat(Interface.HEXLabels), Align = TextAnchor.MiddleCenter }
                }, IQKITS_OVERLAY, $"BTN_NEXT_BUTTON");
            }

            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region Update Cooldown
        private IEnumerator UI_UpdateCooldown(BasePlayer player)
        {
            var Interface = config.InterfaceSetting;

            while (player.HasFlag(BaseEntity.Flags.Reserved3))
            {
                int i = 0;
                foreach (var Kit in config.KitList.Where(k => k.Value.TypeKit != TypeKits.Started && (((k.Value.TypeKit == TypeKits.Amount || k.Value.TypeKit == TypeKits.AmountCooldown) && DataKitsUserList[player.userID].InfoKitsList[k.Key].Amount > 0) || k.Value.TypeKit == TypeKits.Cooldown && permission.UserHasPermission(player.UserIDString, k.Value.Permission))).Skip(4 * PagePlayers[player]).Take(4))
                {
                    CuiElementContainer container = new CuiElementContainer();

                    CuiHelper.DestroyUi(player, $"COOLDOWN_LINE_{i}");
                    CuiHelper.DestroyUi(player, $"COOLDOWN_TITLE{i}");

                    var Data = DataKitsUserList[player.userID].InfoKitsList[Kit.Key];

                    double XMax = Data.Cooldown >= CurrentTime() ? (double)((Data.Cooldown - CurrentTime()) * Math.Pow(Kit.Value.CoolDown, -1)) : Data.Amount != 0 ? (double)((Data.Amount) * Math.Pow(Kit.Value.Amount, -1)) : 1;
                    container.Add(new CuiPanel
                    {
                        CursorEnabled = true,
                        RectTransform = { AnchorMin = $"0 0", AnchorMax = $"{XMax} 1", OffsetMin = "1 1", OffsetMax = "-2 -1" },
                        Image = { Color = HexToRustFormat(Interface.HEXCooldowns) }
                    }, $"COOLDOWN_PANEL_{i}", $"COOLDOWN_LINE_{i}");

                    string InfoAmountAndCooldown = Data.Cooldown >= CurrentTime() ? GetLang("UI_COOLDONW_KIT", player.UserIDString, FormatTime(TimeSpan.FromSeconds(Data.Cooldown - CurrentTime()))) : Data.Amount != 0 ? GetLang("UI_AMOUNT_KIT", player.UserIDString, Data.Amount) : GetLang("UI_COOLDONW_KIT_NO", player.UserIDString);
                    container.Add(new CuiLabel
                    {
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "0.965517 0.9449963" },
                        Text = { Text = InfoAmountAndCooldown, Color = HexToRustFormat(Interface.HEXLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperRight }
                    }, $"COOLDOWN_PANEL_{i}", $"COOLDOWN_TITLE{i}");

                    i++;
                    CuiHelper.AddUi(player, container);
                }
                yield return new WaitForSeconds(1);
            }
        }
        #endregion

        #region Information Kits
        void Interface_Info_Kits(BasePlayer player, string KitKey)
        {
            DestroyInfoKits(player);
            CuiElementContainer container = new CuiElementContainer();
            var Interface = config.InterfaceSetting;
            float FadeIn = Interface.InterfaceFadeIn;
            float FadeOut = Interface.InterfaceFadeOut;
            var Kit = config.KitList[KitKey];
            container.Add(new CuiElement
            {
                FadeOut = FadeOut,
                Parent = IQKITS_OVERLAY,
                Name = $"INFO_BACKGROUND",
                Components =
                    {
                        new CuiRawImageComponent { FadeIn = FadeIn, Png = GetImage($"INFO_BACKGROUND_{Interface.PNGInfoPanel}"),Color = HexToRustFormat(Interface.HEXBlock) },
                        new CuiRectTransformComponent{ AnchorMin = "0.4005208 0.2416667", AnchorMax = $"0.5958334 0.825"},
                    }
            });

            container.Add(new CuiButton
            {
                FadeOut = FadeOut - 0.2f,
                RectTransform = { AnchorMin = "0.02933349 0.01269239", AnchorMax = "0.9706663 0.1111111" },
                Button = { FadeIn = FadeIn, Command = $"kit_ui_func hide.info", Color = HexToRustFormat(Interface.HEXInfoItemButton) },
                Text = { FadeIn = FadeIn, Text = GetLang("UI_HIDE_BTN", player.UserIDString), Color = HexToRustFormat(Interface.HEXLabelsInfoItemButton), Align = TextAnchor.MiddleCenter }
            }, $"INFO_BACKGROUND", $"HIDE_INFO_BTN");

            container.Add(new CuiLabel
            {
                FadeOut = FadeOut,
                RectTransform = { AnchorMin = "0.3916669 0.1444444", AnchorMax = "0.60625 0.237037" },
                Text = { FadeIn = FadeIn, Text = GetLang("UI_WHAT_INFO_TITLE", player.UserIDString, Kit.DisplayName.ToUpper()), Color = HexToRustFormat(Interface.HEXLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.UpperCenter }
            }, IQKITS_OVERLAY, $"TITLE_KIT_INFO");

            #region Centering
            int ItemCount = 0;
            float itemMinPosition = 219f;
            float itemWidth = 0.413646f - 0.24f; /// Ширина
            float itemMargin = 0.439895f - 0.415f; /// Расстояние между 
            int itemCount = Kit.ItemKits.Count;
            float itemMinHeight = 0.89f; // Сдвиг по вертикали
            float itemHeight = 0.1f; /// Высота
            int ItemTarget = 5;

            if (itemCount > ItemTarget)
            {
                itemMinPosition = 0.5f - ItemTarget / 2f * itemWidth - (ItemTarget - 1) / 2f * itemMargin;
                itemCount -= ItemTarget;
            }
            else itemMinPosition = 0.5f - itemCount / 2f * itemWidth - (itemCount - 1) / 2f * itemMargin;
            #endregion

            int i = 0;
            foreach (var Item in Kit.ItemKits.Take(35))
            {
                container.Add(new CuiElement
                {
                    FadeOut = FadeOut,
                    Parent = "INFO_BACKGROUND",
                    Name = $"KIT_ITEM_{i}",
                    Components = // debug
                    {
                        new CuiImageComponent { FadeIn = FadeIn, Color = HexToRustFormat("#37353E77") },
                        new CuiRectTransformComponent { AnchorMin = $"{itemMinPosition} {itemMinHeight}", AnchorMax = $"{itemMinPosition + itemWidth} {itemMinHeight + itemHeight}" },
                        new CuiOutlineComponent { Color = HexToRustFormat(Interface.HEXBlockItemInfo), Distance = "0 -1.5", UseGraphicAlpha = true }
                    }
                });

                if (String.IsNullOrWhiteSpace(Item.Sprite))
                {
                    var ComponentAvatar = !String.IsNullOrWhiteSpace(Item.PNG) ? new CuiRawImageComponent { FadeIn = FadeIn, Png = GetImage($"ITEM_KIT_PNG_{Item.PNG}") } : new CuiRawImageComponent { FadeIn = FadeIn, Png = GetImage($"{Item.Shortname}_128px") };
                    container.Add(new CuiElement
                    {
                        FadeOut = FadeOut,
                        Parent = $"KIT_ITEM_{i}",
                        Name = $"ITEM_{i}",
                        Components =
                    {
                        ComponentAvatar,
                        new CuiRectTransformComponent{ AnchorMin = "0 0", AnchorMax = $"1 1"},
                    }
                    });
                }
                else
                {
                    container.Add(new CuiElement
                    {
                        FadeOut = FadeOut,
                        Parent = $"KIT_ITEM_{i}",
                        Name = $"ITEM_{i}",
                        Components =
                    {
                        new CuiImageComponent { FadeIn = FadeIn, Sprite = Item.Sprite },
                        new CuiRectTransformComponent{ AnchorMin = "0 0", AnchorMax = $"1 1"},
                    }
                    });
                }

                if (Item.Rare != 0)
                {

                    int Rare = IQPlagueSkill ? IS_SKILL_RARE(player) ? Item.Rare + GET_SKILL_RARE_PERCENT() : Item.Rare : Item.Rare;
                    if (Rare >= 100) continue;
                    container.Add(new CuiPanel
                    {
                        FadeOut = FadeOut,
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                        Image = { FadeIn = FadeIn, Color = HexToRustFormat(Interface.HEXBackground) }
                    }, $"KIT_ITEM_{i}", $"RARE_BACKGROUND_{i}"); 

                    container.Add(new CuiLabel
                    {
                        FadeOut = FadeOut,
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                        Text = { FadeIn = FadeIn, Text = $"{Rare}%", FontSize = 10, Color = HexToRustFormat(Interface.HEXLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                    }, $"RARE_BACKGROUND_{i}", $"RARE_LABEL_{i}");
                }

                container.Add(new CuiLabel
                {
                    FadeOut = FadeOut,
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "0.930693 0.2688163" },
                    Text = { FadeIn = FadeIn, Text = $"x{Item.Amount}", FontSize = 10, Color = HexToRustFormat(Interface.HEXLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleRight }
                }, $"KIT_ITEM_{i}", $"KIT_ITEM_AMOUNT_{i}");

                #region Centring
                i++;
                ItemCount++;
                itemMinPosition += (itemWidth + itemMargin);
                if (ItemCount % ItemTarget == 0)
                {
                    itemMinHeight -= (itemHeight + (itemMargin * 1f));
                    if (itemCount > ItemTarget)
                    {
                        itemMinPosition = 0.5f - ItemTarget / 2f * itemWidth - (ItemTarget - 1) / 2f * itemMargin;
                        itemCount -= ItemTarget;
                    }
                    else itemMinPosition = 0.5f - itemCount / 2f * itemWidth - (itemCount - 1) / 2f * itemMargin;
                }
                #endregion
            }

            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region Alert Kits
        void Interface_Alert_Kits(BasePlayer player, string Message)
        {
            DestroyAlert(player);
            CuiElementContainer container = new CuiElementContainer();
            var Interface = config.InterfaceSetting;
            float FadeIn = Interface.InterfaceFadeIn;
            float FadeOut = Interface.InterfaceFadeOut;
            string AlertBackground = $"INFO_ALERT_BACKGROUND_{Interface.PNGAlert}";

            container.Add(new CuiElement
            {
                FadeOut = FadeOut,
                Parent = IQKITS_OVERLAY,
                Name = $"INFO_ALERT_BACKGROUND",
                Components =
                    {
                        new CuiRawImageComponent { FadeIn = FadeIn, Png = GetImage(AlertBackground), Color = HexToRustFormat(Interface.HEXBlock) },
                        new CuiRectTransformComponent{ AnchorMin = "0.3213542 0.01018518", AnchorMax = $"0.6958333 0.1101852"},
                    }
            });

            container.Add(new CuiLabel
            {
                FadeOut = FadeOut,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Text = { FadeIn = FadeIn, Text = Message.ToUpper(), Color = HexToRustFormat(Interface.HEXLabels), Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            }, "INFO_ALERT_BACKGROUND", "TITLE_ALERT");

            CuiHelper.AddUi(player, container);

            timer.Once(2.5f, () => { DestroyAlert(player); });
        }
        #endregion

        private static string HexToRustFormat(string hex)
        {
            Color color;
            ColorUtility.TryParseHtmlString(hex, out color);
            sb.Clear();
            return sb.AppendFormat("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a).ToString();
        }
        #endregion

        #region Lang
        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["UI_TITLE"] = "<size=45><b>KITS MENU</b></size>",
                ["UI_DESCRIPTION"] = "<size=25><b>Your available kits are displayed here</b></size>",

                ["UI_DISPLAY_NAME_KIT"] = "<size=12><b>DISPLAY NAME KIT</b></size>\n <size=30><b>{0}</b></size>",
                ["UI_COOLDONW_KIT_NO"] = "<size=12><b>COOLDOWN</b></size>\n <size=25><b>KIT AVAILABLE</b></size>",
                ["UI_COOLDONW_KIT"] = "<size=12><b>COOLDOWN</b></size>\n <size=30><b>{0}</b></size>",
                ["UI_AMOUNT_KIT"] = "<size=12><b>AMOUNT</b></size>\n <size=30><b>{0}</b></size>",
                ["UI_BTN_WHAT_INFO"] = "<size=12><b>WHAT IS INSIDE?</b></size>",
                ["UI_BTN_TAKE_KIT"] = "<size=12><b>PICK UP</b></size>",
                ["UI_BTN_TAKE_KIT_BLOCK"] = "<size=12><b>WAIT</b></size>",
                ["UI_WHAT_INFO_TITLE"] = "<size=25><b>ITEMS IN THE {0} SET</b></size>",
                ["UI_CLOSE_BTN"] = "<size=30><b>CLOSE</b></size>",
                ["UI_HIDE_BTN"] = "<size=30><b>HIDE</b></size>",
                ["UI_NEXT_BTN"] = "<size=30><b>NEXT</b></size>",
                ["UI_BACK_BTN"] = "<size=30><b>BACK</b></size>",
                ["UI_ALERT_ACCES_KIT"] = "<size=20><b>YOU SUCCESSFULLY RECEIVED THE KIT {0}</b></size>",
                ["UI_ALERT_FULL_INVENTORY"] = "<size=20><b>YOU CANNOT TAKE THE KIT, THE INVENTORY IS OVERFULL</b></size>",

            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["UI_TITLE"] = "<size=45><b>НАБОРЫ</b></size>",
                ["UI_DESCRIPTION"] = "<size=25><b>Здесь отображены ваши доступные наборы</b></size>",

                ["UI_DISPLAY_NAME_KIT"] = "<size=12><b>НАЗВАНИЕ НАБОРА</b></size>\n <size=30><b>{0}</b></size>",
                ["UI_COOLDONW_KIT"] = "<size=12><b>ПЕРЕЗАРЯДКА</b></size>\n <size=30><b>{0}</b></size>",
                ["UI_AMOUNT_KIT"] = "<size=12><b>КОЛИЧЕСТВО</b></size>\n <size=30><b>{0}</b></size>",
                ["UI_COOLDONW_KIT_NO"] = "<size=12><b>ПЕРЕЗАРЯДКА</b></size>\n <size=25><b>НАБОР ДОСТУПЕН</b></size>",
                ["UI_BTN_WHAT_INFO"] = "<size=12><b>ЧТО ВНУТРИ?</b></size>",
                ["UI_BTN_TAKE_KIT"] = "<size=12><b>ЗАБРАТЬ</b></size>",
                ["UI_BTN_TAKE_KIT_BLOCK"] = "<size=12><b>ОЖИДАЙТЕ</b></size>",
                ["UI_WHAT_INFO_TITLE"] = "<size=25><b>ПРЕДМЕТЫ В НАБОРЕ {0}</b></size>",
                ["UI_CLOSE_BTN"] = "<size=30><b>ЗАКРЫТЬ</b></size>",
                ["UI_HIDE_BTN"] = "<size=30><b>СКРЫТЬ</b></size>",
                ["UI_NEXT_BTN"] = "<size=30><b>ВПЕРЕД</b></size>",
                ["UI_BACK_BTN"] = "<size=30><b>НАЗАД</b></size>",
                ["UI_ALERT_ACCES_KIT"] = "<size=20><b>ВЫ УСПЕШНО ПОЛУЧИЛИ НАБОР {0}</b></size>",
                ["UI_ALERT_FULL_INVENTORY"] = "<size=20><b>ВЫ НЕ МОЖЕТЕ ВЗЯТЬ НАБОР, ИНВЕНТАРЬ ПЕРЕПОЛНЕН</b></size>",
            }, this, "ru");
            PrintWarning("Языковой файл загружен успешно");
        }

        public static StringBuilder sb = new StringBuilder();
        public string GetLang(string LangKey, string userID = null, params object[] args)
        {
            sb.Clear();
            if (args != null)
            {
                sb.AppendFormat(lang.GetMessage(LangKey, this, userID), args);
                return sb.ToString();
            }
            return lang.GetMessage(LangKey, this, userID);
        }
        #endregion

        #region Util
        static DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);
        static double CurrentTime() => DateTime.UtcNow.Subtract(epoch).TotalSeconds;
        public static string FormatTime(TimeSpan time)
        {
            string result = string.Empty;
            if (time.Days != 0)
                result = $"{Format(time.Days, "дней", "дня", "день")}";

            if (time.Hours != 0 && time.Days == 0)
                result = $"{Format(time.Hours, "часов", "часа", "час")}";

            if (time.Minutes != 0 && time.Hours == 0 && time.Days == 0)
                result = $"{Format(time.Minutes, "минут", "минуты", "минута")}";

            if (time.Seconds != 0 && time.Days == 0 && time.Minutes == 0 && time.Hours == 0)
                result = $"{Format(time.Seconds, "секунд", "секунды", "секунда")}";

            return result;
        }
        private static string Format(int units, string form1, string form2, string form3)
        {
            var tmp = units % 10;

            if (units >= 5 && units <= 20 || tmp >= 5 && tmp <= 9)
                return $"{units} {form1}";

            if (tmp >= 2 && tmp <= 4)
                return $"{units} {form2}";

            return $"{units} {form3}";
        }
        #endregion
    }
}


// --- End of file: IQKits.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Hotel.cs ---
// --- Original Local Path: Hotel.cs ---

// Reference: NLua

using System;
using System.Collections.Generic;
using System.Reflection;
using Oxide.Core;
using Oxide.Core.Plugins;
using UnityEngine;
using NLua;

namespace Oxide.Plugins
{
    [Info("Hotel", "Reneb", "1.1.4", ResourceId = 1298)]
    class Hotel : RustPlugin
    {

        ////////////////////////////////////////////////////////////
        // Plugin References
        ////////////////////////////////////////////////////////////

        [PluginReference]
        Plugin ZoneManager;

        [PluginReference("Economics")]
        Plugin Economics;

        //////////////////////////////////////////////////////////////////////////////////////
        // Workaround the Blocks of Economics. Hope This wont be needed in the future
        // THX MUGHISI ///////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////

        void OnServerInitialized()
        {
            LoadPermissions();
        }

        ////////////////////////////////////////////////////////////
        // Fields
        ////////////////////////////////////////////////////////////

        static int deployableColl = UnityEngine.LayerMask.GetMask(new string[] { "Deployed" });
        static int constructionColl = UnityEngine.LayerMask.GetMask(new string[] { "Construction", "Construction Trigger" });
        Oxide.Plugins.Timer hotelTimer;
        Hash<BasePlayer, Oxide.Plugins.Timer> playerguiTimers = new Hash<BasePlayer, Oxide.Plugins.Timer>();

        ////////////////////////////////////////////////////////////
        // cached Fields
        ////////////////////////////////////////////////////////////

        public static Dictionary<string, HotelData> EditHotel = new Dictionary<string, HotelData>();
        static DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);
        public static Vector3 Vector3UP = new Vector3(0f, 0.1f, 0f);
        public static Vector3 Vector3UP2 = new Vector3(0f, 1.5f, 0f);
        public FieldInfo fieldWhiteList;
        public FieldInfo serverinput;
        public static Quaternion defaultQuaternion = new Quaternion(0f, 0f, 0f, 0f);

        ////////////////////////////////////////////////////////////
        // Config Management
        ////////////////////////////////////////////////////////////

        static int authlevel = 2;
        static string MessageAlreadyEditing = "You are already editing a hotel. You must close or save it first.";
        static string MessageHotelNewHelp = "You must select a name for the new hotel: /hotel_new HOTELNAME";
        static string MessageHotelEditHelp = "You must select the name of the hotel you want to edit: /hotel_edit HOTELNAME";
        static string MessageHotelEditEditing = "You are editing the hotel named: {0}. Now say /hotel to continue configuring your hotel. Note that no one can register/leave the hotel while you are editing it.";
        static string MessageErrorAlreadyExist = "{0} is already the name of a hotel";
        static string MessageErrorNotAllowed = "You are not allowed to use this command";
        static string MessageErrorEditDoesntExist = "The hotel \"{0}\" doesn't exist";
        static string MessageMaintenance = "This Hotel is under maintenance by the admin, you may not open this door at the moment";
        static string MessageErrorUnavaibleRoom = "This room is unavaible, seems like it wasn't set correctly";
        static string MessageHotelNewCreated = "You've created a new Hotel named: {0}. Now say /hotel to continue configuring your hotel.";
        static string MessageErrorNotAllowedToEnter = "You are not allowed to enter this room, it's already been used my someone else";

        static string MessageErrorAlreadyGotRoom = "You already have a room in this hotel!";
        static string MessageErrorPermissionsNeeded = "You must have the {0} permission to rent a room here";
        static string MessageRentUnlimited = "You now have access to this room for an unlimited time";
        static string MessageRentTimeLeft = "You now have access to this room. You are allowed to keep this room for {0}";
        static string MessagePaydRent = "You payed for this room {0} coins";
        static string MessageErrorNotEnoughCoins = "This room costs {0} coins. You only have {1} coins";

        static string GUIBoardAdmin = "                             <color=green>HOTEL MANAGER</color> \n\nHotel Name:      {name} \n\nHotel Location: {loc} \nHotel Radius:     {hrad} \n\nRooms Radius:   {rrad} \nRooms:                {rnum} \n<color=red>Occupied:            {onum}</color>\nRent Price:                  {rp}";
        static string GUIBoardPlayer = "                             <color=green>{name}</color> \n\nRooms:        <color=green>{fnum}</color>/{rnum} ";
        static string GUIBoardPlayerRoom = "\n\n                        Your Room\nJoined:         {jdate}\nTimeleft:      {timeleft}.";
        static string GUIBoardPlayerMaintenance = "                             <color=green>{name}</color> \n\nHotel is under maintenance. Please wait couple seconds/minutes until the admin is finished.";
        static string xmin = "0.65";
        static string xmax = "1.0";
        static string ymin = "0.6";
        static string ymax = "0.9";
        static string pxmin = "0.3";
        static string pxmax = "0.6";
        static string pymin = "0.7";
        static string pymax = "0.95";
        static int pTimeOut = 10;

        static bool EnterZoneShowRoom = false;
        static bool EnterZoneShowPlayerGUI = false;
        static bool UseNPCShowRoom = true;
        static bool UseNPCShowPlayerGUI = true;
        static bool OpenDoorShowRoom = false;
        static bool OpenDoorPlayerGUI = true;

        public static string adminguijson = @"[  
			{ 
				""name"": ""HotelAdmin"",
				""parent"": ""Overlay"",
				""components"":
				[
					{
						 ""type"":""UnityEngine.UI.Image"",
						 ""color"":""0.1 0.1 0.1 0.7"",
					},
					{
						""type"":""RectTransform"",
						""anchormin"": ""{xmin} {ymin}"",
						""anchormax"": ""{xmax} {ymax}""
						
					}
				]
			},
			{
				""parent"": ""HotelAdmin"",
				""components"":
				[
					{
						""type"":""UnityEngine.UI.Text"",
						""text"":""{msg}"",
						""fontSize"":15,
						""align"": ""MiddleLeft"",
					},
					{
						""type"":""RectTransform"",
						""anchormin"": ""0.1 0.1"",
						""anchormax"": ""1 1""
					}
				]
			}
		]
		";

        public static string playerguijson = @"[  
			{ 
				""name"": ""HotelPlayer"",
				""parent"": ""Overlay"",
				""components"":
				[
					{
						 ""type"":""UnityEngine.UI.Image"",
						 ""color"":""0.1 0.1 0.1 0.7"",
					},
					{
						""type"":""RectTransform"",
						""anchormin"": ""{pxmin} {pymin}"",
						""anchormax"": ""{pxmax} {pymax}""
						
					}
				]
			},
			{
				""parent"": ""HotelPlayer"",
				""components"":
				[
					{
						""type"":""UnityEngine.UI.Text"",
						""text"":""{msg}"",
						""fontSize"":15,
						""align"": ""MiddleLeft"",
					},
					{
						""type"":""RectTransform"",
						""anchormin"": ""0.1 0.1"",
						""anchormax"": ""1 1""
					}
				]
			}
		]
		";

        protected override void LoadDefaultConfig() { }

        private void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T)
                var = (T)Config[Key];
            else
                Config[Key] = var;
        }

        void Init()
        {
            CheckCfg<int>("Configure - Level Required", ref authlevel);

            CheckCfg<string>("AdminMessage - Hotel - New - Help", ref MessageHotelNewHelp);
            CheckCfg<string>("AdminMessage - Hotel - New - Confirm", ref MessageHotelNewCreated);
            CheckCfg<string>("AdminMessage - Hotel - Edit - Help", ref MessageHotelEditHelp);
            CheckCfg<string>("AdminMessage - Hotel - Edit - Confirm", ref MessageHotelEditEditing);
            CheckCfg<string>("AdminMessage - Hotel - Error - Doesnt Exist", ref MessageErrorEditDoesntExist);
            CheckCfg<string>("AdminMessage - Hotel - Error - Already Exist", ref MessageErrorAlreadyExist);
            CheckCfg<string>("AdminMessage - Hotel - Error - Not Allowed", ref MessageErrorNotAllowed);
            CheckCfg<string>("AdminMessage - Hotel - Error - Already Editing Hotel", ref MessageAlreadyEditing);

            CheckCfg<string>("PlayerMessage - Hotel Maintenance", ref MessageMaintenance);
            CheckCfg<string>("PlayerMessage - Error - Unavaible Room", ref MessageErrorUnavaibleRoom);
            CheckCfg<string>("PlayerMessage - Error - Restricted", ref MessageErrorNotAllowedToEnter);
            CheckCfg<string>("PlayerMessage - Error - Already have a Room", ref MessageErrorAlreadyGotRoom);
            CheckCfg<string>("PlayerMessage - Error - Need Permissions", ref MessageErrorPermissionsNeeded);
            CheckCfg<string>("PlayerMessage - Unlimited Access", ref MessageRentUnlimited);
            CheckCfg<string>("PlayerMessage - Limited Access", ref MessageRentTimeLeft);
            CheckCfg<string>("PlayerMessage - Payd Rent", ref MessagePaydRent);
            CheckCfg<string>("PlayerMessage - Error - Not Enough Coins", ref MessageErrorNotEnoughCoins);
            
            CheckCfg<string>("GUI - Admin - Board Message", ref GUIBoardAdmin);
            CheckCfg<string>("GUI - Player - Board Message", ref GUIBoardPlayer);
            CheckCfg<string>("GUI - Player - Room Board Message ", ref GUIBoardPlayerRoom);
            CheckCfg<string>("GUI - Player - Maintenance Board Message", ref GUIBoardPlayerMaintenance);
            CheckCfg<string>("GUI - Player - minX", ref pxmin);
            CheckCfg<string>("GUI - Player - maxX", ref pxmax);
            CheckCfg<string>("GUI - Player - minY", ref pymin);
            CheckCfg<string>("GUI - Player - maxY", ref pymax);
            CheckCfg<int>("GUI - Player - Board Remove Timer", ref pTimeOut);
            CheckCfg<string>("GUI - Admin - minX", ref xmin);
            CheckCfg<string>("GUI - Admin - maxX", ref xmax);
            CheckCfg<string>("GUI - Admin - minY", ref ymin);
            CheckCfg<string>("GUI - Admin - maxY", ref ymax);
            CheckCfg<bool>("GUI - Player - Show Board When Entering Hotel Zone", ref EnterZoneShowPlayerGUI);
            CheckCfg<bool>("GUI - Player - Show Room When Entering Hotel Zone", ref EnterZoneShowRoom);
            CheckCfg<bool>("GUI - Player - Show Board When Talking To NPC", ref UseNPCShowPlayerGUI);
            CheckCfg<bool>("GUI - Player - Show Room When Talking To NPC", ref UseNPCShowRoom);
            CheckCfg<bool>("GUI - Player - Show Board When Opening Room Door", ref OpenDoorPlayerGUI);
            CheckCfg<bool>("GUI - Player - Show Room When Opening Room Door", ref OpenDoorShowRoom);
            SaveConfig();
        }


        ////////////////////////////////////////////////////////////
        // Data Management
        ////////////////////////////////////////////////////////////

        static StoredData storedData;

        class StoredData
        {
            public HashSet<HotelData> Hotels = new HashSet<HotelData>();

            public StoredData() { }
        }

        void OnServerSave() { SaveData(); }

        void SaveData() { Interface.GetMod().DataFileSystem.WriteObject("Hotel", storedData); }

        void LoadData()
        {
            try { storedData = Interface.GetMod().DataFileSystem.ReadObject<StoredData>("Hotel"); }
            catch { storedData = new StoredData(); }
        }

        public class DeployableItem
        {
            public string x;
            public string y;
            public string z;
            public string rx;
            public string ry;
            public string rz;
            public string rw;
            public string prefabname;

            Vector3 pos;
            Quaternion rot;

            public DeployableItem()
            {
            }

            public DeployableItem(Deployable deployable)
            {
                prefabname = StringPool.Get(deployable.prefabID).ToString();

                this.x = deployable.transform.position.x.ToString();
                this.y = deployable.transform.position.y.ToString();
                this.z = deployable.transform.position.z.ToString();

                this.rx = deployable.transform.rotation.x.ToString();
                this.ry = deployable.transform.rotation.y.ToString();
                this.rz = deployable.transform.rotation.z.ToString();
                this.rw = deployable.transform.rotation.w.ToString();
            }
            public Vector3 Pos()
            {
                if (pos == default(Vector3))
                    pos = new Vector3(float.Parse(x), float.Parse(y), float.Parse(z));
                return pos;
            }
            public Quaternion Rot()
            {
                if (rot.w == 0f)
                    rot = new Quaternion(float.Parse(rx), float.Parse(ry), float.Parse(rz), float.Parse(rw));
                return rot;
            }
        }
        public class Room
        {
            public string roomid;
            public string x;
            public string y;
            public string z;

            public List<DeployableItem> defaultDeployables;

            public string renter;
            public string checkingTime;
            public string checkoutTime;

            double intcheckoutTime;
            Vector3 pos;

            public Room()
            {
            }

            public Room(Vector3 position)
            {
                this.x = Math.Ceiling(position.x).ToString();
                this.y = Math.Ceiling(position.y).ToString();
                this.z = Math.Ceiling(position.z).ToString();
                this.roomid = string.Format("{0}:{1}:{2}", this.x, this.y, this.z);
            }

            public Vector3 Pos()
            {
                if (pos == default(Vector3))
                    pos = new Vector3(float.Parse(x), float.Parse(y), float.Parse(z));
                return pos;
            }

            public double CheckOutTime()
            {
                if (intcheckoutTime == default(double))
                    intcheckoutTime = Convert.ToDouble(checkoutTime);
                return intcheckoutTime;
            }

            public void Reset()
            {
                intcheckoutTime = default(double);
            }
        }

        public class HotelData
        {
            public string hotelname;
            public string x;
            public string y;
            public string z;
            public string r;
            public string rr;
            public string rd;
            public string npc;
            public string p;
            public string e;

            public Dictionary<string, Room> rooms;

            Vector3 pos;
            public bool enabled;
            public int price;

            public HotelData()
            {
                enabled = false;
                if (rooms == null) rooms = new Dictionary<string, Room>();
            }

            public HotelData(string hotelname)
            {
                this.hotelname = hotelname;
                this.x = "0";
                this.y = "0";
                this.z = "0";
                this.r = "60";
                this.rr = "10";
                this.rd = "86400";
                this.p = null;
                this.e = null;

                this.rooms = new Dictionary<string, Room>();
                enabled = false;
            }

            public Vector3 Pos()
            {
                if (this.x == "0" && this.y == "0" && this.z == "0")
                    return default(Vector3);
                if (pos == default(Vector3))
                    pos = new Vector3(float.Parse(x), float.Parse(y), float.Parse(z));
                return pos;
            }

            public void RefreshRooms()
            {
                if (Pos() == default(Vector3))
                    return;
                Dictionary<string, Room> detectedRooms = FindAllRooms(Pos(), Convert.ToSingle(this.r), Convert.ToSingle(this.rr));

                List<string> toAdd = new List<string>();
                List<string> toDelete = new List<string>();
                if (rooms == null) rooms = new Dictionary<string, Room>();
                if (rooms.Count > 0)
                {
                    foreach (KeyValuePair<string, Room> pair in rooms)
                    {
                        if (pair.Value.renter != null)
                        {
                            detectedRooms.Remove(pair.Key);
                            Debug.Log(string.Format("{0} is occupied and can't be edited", pair.Key));
                            continue;
                        }
                        if (!detectedRooms.ContainsKey(pair.Key))
                        {
                            toDelete.Add(pair.Key);
                        }
                    }
                }
                foreach (KeyValuePair<string, Room> pair in detectedRooms)
                {
                    if (!rooms.ContainsKey(pair.Key))
                    {
                        toAdd.Add(pair.Key);
                    }
                    else
                    {
                        rooms[pair.Key] = pair.Value;
                    }

                }
                foreach (string roomid in toDelete)
                {
                    rooms.Remove(roomid);
                    Debug.Log(string.Format("{0} doesnt exist anymore, removing this room", roomid));
                }
                foreach (string roomid in toAdd)
                {
                    Debug.Log(string.Format("{0} is a new room, adding it", roomid));
                    rooms.Add(roomid, detectedRooms[roomid]);
                }
            }
            public int Price()
            {
                if (this.e == null) return 0;
                return Convert.ToInt32(this.e);
            }
            public void Deactivate()
            {
                enabled = false;
            }
            public void Activate()
            {
                enabled = true;
            }

            public void AddRoom(Room newroom)
            {
                if (rooms.ContainsKey(newroom.roomid))
                    rooms.Remove(newroom.roomid);

                rooms.Add(newroom.roomid, newroom);
            }
        }

        ////////////////////////////////////////////////////////////
        // Random Methods
        ////////////////////////////////////////////////////////////

        static double LogTime() { return DateTime.UtcNow.Subtract(epoch).TotalSeconds; }

        static void CloseDoor(Door door)
        {
            door.SetFlag(BaseEntity.Flags.Open, false);
            door.SendNetworkUpdateImmediate(true);
        }
        static void OpenDoor(Door door)
        {
            door.SetFlag(BaseEntity.Flags.Open, true);
            door.SendNetworkUpdateImmediate(true);
        }
        static void LockLock(CodeLock codelock)
        {
            codelock.SetFlag(BaseEntity.Flags.Locked, true);
            codelock.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
        }
        static void UnlockLock(CodeLock codelock)
        {
            codelock.SetFlag(BaseEntity.Flags.Locked, false);
            codelock.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
        }

        void LoadPermissions()
        {
            if (!permission.PermissionExists("canhotel")) permission.RegisterPermission("canhotel", this);
            foreach (HotelData hotel in storedData.Hotels)
            {
                if (hotel.p == null) continue;
                if (!permission.PermissionExists(hotel.p)) permission.RegisterPermission(hotel.p, this);
            }
        }

        ////////////////////////////////////////////////////////////
        // Oxide Hooks
        ////////////////////////////////////////////////////////////

        void Unload()
        {
            SaveData();
            hotelTimer.Destroy();
        }

        void Loaded()
        {
            adminguijson = adminguijson.Replace("{xmin}", xmin).Replace("{xmax}", xmax).Replace("{ymin}", ymin).Replace("{ymax}", ymax);
            playerguijson = playerguijson.Replace("{pxmin}", pxmin).Replace("{pxmax}", pxmax).Replace("{pymin}", pymin).Replace("{pymax}", pymax);
            fieldWhiteList = typeof(CodeLock).GetField("whitelistPlayers", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
            serverinput = typeof(BasePlayer).GetField("serverInput", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
            hotelTimer = timer.Repeat(60f, 0, () => CheckTimeOutRooms());
            LoadData();
        }

        object CanUseDoor(BasePlayer player, BaseLock baselock)
        {
            if (baselock == null) return null;
            CodeLock codelock = baselock as CodeLock;
            if (codelock == null) return null;
            BaseEntity parententity = codelock.GetParentEntity();
            if (parententity == null) return null;
            if (parententity.HasFlag(BaseEntity.Flags.Open)) return null;

            string zonename = string.Empty;
            HotelData targethotel = null;
            foreach (HotelData hotel in storedData.Hotels)
            {
                //Check if the player is inside a hotel
                // Is this the best way to do it?
                // Might need to actually make a list of all codelocks that are used inside a hotel instead of this ...
                object isplayerinzone = ZoneManager.Call("isPlayerInZone", hotel.hotelname, player);
                if (isplayerinzone is bool && (bool)isplayerinzone) targethotel = hotel;
            }
            if (targethotel == null) return null;

            if (OpenDoorPlayerGUI)
                RefreshPlayerHotelGUI(player, targethotel);
            if (OpenDoorShowRoom)
                ShowPlayerRoom(player, targethotel);

            if (!targethotel.enabled)
            {
                SendReply(player, MessageMaintenance);
                return false;
            }

            Room room = FindRoomByDoorAndHotel(targethotel, parententity);
            if (room == null)
            {
                SendReply(player, MessageErrorUnavaibleRoom);
                return false;
            }

            if (room.renter == null)
            {
                if (!CanRentRoom(player, targethotel)) return false;
                ResetRoom(codelock, targethotel, room);
                NewRoomOwner(codelock, player, targethotel, room);
                if(targethotel.e != null && Economics)
                {
                    EconomicsWithdraw(player, targethotel.Price());
                }
            }

            LockLock(codelock);

            if (room.renter != player.userID.ToString())
            {
                SendReply(player, MessageErrorNotAllowedToEnter);
                return false;
            }

            return true;
        }



        ////////////////////////////////////////////////////////////
        // Room Management Functions
        ////////////////////////////////////////////////////////////
        void CheckTimeOutRooms()
        {
            double currenttime = LogTime();
            foreach (HotelData hotel in storedData.Hotels)
            {
                if (!hotel.enabled) continue;
                foreach (KeyValuePair<string, Room> pair in hotel.rooms)
                {
                    if (pair.Value.CheckOutTime() == 0.0) continue;
                    if (pair.Value.CheckOutTime() > currenttime) continue;

                    ResetRoom(hotel, pair.Value);
                }
            }
        }
        static List<Door> FindDoorsFromPosition(Vector3 position, float radius)
        {
            List<Door> listLocks = new List<Door>();
            foreach (Collider col in UnityEngine.Physics.OverlapSphere(position, radius, constructionColl))
            {
                Door door = col.GetComponentInParent<Door>();
                if (door == null) continue;
                if (!door.HasSlot(BaseEntity.Slot.Lock)) continue;
                if (door.GetSlot(BaseEntity.Slot.Lock) == null) continue;
                if (!(door.GetSlot(BaseEntity.Slot.Lock) is CodeLock)) continue;
                CloseDoor(door);
                listLocks.Add(door);
            }
            return listLocks;
        }

        static Dictionary<string, Room> FindAllRooms(Vector3 position, float radius, float roomradius)
        {
            List<Door> listLocks = FindDoorsFromPosition(position, radius);

            Hash<Deployable, string> deployables = new Hash<Deployable, string>();
            Dictionary<string, Room> tempRooms = new Dictionary<string, Room>();

            foreach (Door door in listLocks)
            {
                Vector3 pos = door.transform.position;
                Room newRoom = new Room(pos);
                newRoom.defaultDeployables = new List<DeployableItem>();
                List<Deployable> founditems = new List<Deployable>();

                foreach (Collider col in UnityEngine.Physics.OverlapSphere(pos, roomradius, deployableColl))
                {
                    Deployable deploy = col.GetComponentInParent<Deployable>();
                    if (deploy == null) continue;
                    if (founditems.Contains(deploy)) continue;
                    founditems.Add(deploy);

                    bool canReach = true;
                    foreach (RaycastHit rayhit in UnityEngine.Physics.RaycastAll(deploy.transform.position + Vector3UP, (pos + Vector3UP - deploy.transform.position).normalized, Vector3.Distance(deploy.transform.position, pos) - 0.2f, constructionColl))
                    {
                        if (rayhit.collider.GetComponentInParent<Door>() != null)
                        {
                            if (rayhit.collider.GetComponentInParent<Door>() == door)
                                continue;
                        }
                        canReach = false;
                        break;
                    }
                    if (!canReach) continue;

                    if (deployables[deploy] != null) deployables[deploy] = "0";
                    else deployables[deploy] = newRoom.roomid;
                }
                tempRooms.Add(newRoom.roomid, newRoom);
            }
            foreach (KeyValuePair<Deployable, string> pair in deployables)
            {
                if (pair.Value != "0")
                {
                    DeployableItem newDeployItem = new DeployableItem(pair.Key);
                    tempRooms[pair.Value].defaultDeployables.Add(newDeployItem);
                }
            }
            return tempRooms;
        }

        static Room FindRoomByDoorAndHotel(HotelData hotel, BaseEntity door)
        {
            string roomid = string.Format("{0}:{1}:{2}", Math.Ceiling(door.transform.position.x).ToString(), Math.Ceiling(door.transform.position.y).ToString(), Math.Ceiling(door.transform.position.z).ToString());
            if (!hotel.rooms.ContainsKey(roomid)) return null;

            return hotel.rooms[roomid];
        }
        void EconomicsWithdraw(BasePlayer player, int amount)
        {
            Economics?.Call("Withdraw", player.userID, amount);
            SendReply(player, string.Format("You payed for this room {0} coins", amount.ToString()));
        }

        bool CanRentRoom(BasePlayer player, HotelData hotel)
        {
            foreach (KeyValuePair<string, Room> pair in hotel.rooms)
            {
                if (pair.Value.renter == player.userID.ToString())
                {
                    SendReply(player, MessageErrorAlreadyGotRoom);
                    return false;
                }
            }
            if (hotel.p != null)
            {
                if (!permission.UserHasPermission(player.userID.ToString(), hotel.p))
                {
                    SendReply(player, string.Format(MessageErrorPermissionsNeeded, hotel.p));
                    return false;
                }
            }
            if(hotel.e != null && Economics != null)
            {
                int money = Convert.ToInt32((double)Economics.Call("GetPlayerMoney", player.userID));
                if(money < hotel.Price())
                {
                    SendReply(player, string.Format(MessageErrorNotEnoughCoins, hotel.e, money.ToString()));
                    return false;
                }
            }
            return true;
        }
        bool FindHotelAndRoomByPos(Vector3 position, out HotelData hoteldata, out Room roomdata)
        {
            hoteldata = null;
            roomdata = null;
            position.x = Mathf.Ceil(position.x);
            position.y = Mathf.Ceil(position.y);
            position.z = Mathf.Ceil(position.z);
            foreach (HotelData hotel in storedData.Hotels)
            {
                foreach (KeyValuePair<string, Room> pair in hotel.rooms)
                {
                    if (pair.Value.Pos() == position)
                    {
                        hoteldata = hotel;
                        roomdata = pair.Value;
                        return true;
                    }
                }
            }
            return false;

        }
        CodeLock FindCodeLockByRoomID(string roomid)
        {
            string[] rpos = roomid.Split(':');
            if (rpos.Length != 3) return null;

            return FindCodeLockByPos(new Vector3(Convert.ToSingle(rpos[0]), Convert.ToSingle(rpos[1]), Convert.ToSingle(rpos[2])));
        }
        CodeLock FindCodeLockByPos(Vector3 pos)
        {
            CodeLock findcode = null;
            foreach (Collider col in UnityEngine.Physics.OverlapSphere(pos, 2f, constructionColl))
            {
                if (col.GetComponentInParent<Door>() == null) continue;
                if (!col.GetComponentInParent<Door>().HasSlot(BaseEntity.Slot.Lock)) continue;

                BaseEntity slotentity = col.GetComponentInParent<Door>().GetSlot(BaseEntity.Slot.Lock);
                if (slotentity == null) continue;
                if (slotentity.GetComponent<CodeLock>() == null) continue;

                if (findcode != null)
                    if (Vector3.Distance(pos, findcode.GetParentEntity().transform.position) < Vector3.Distance(pos, col.transform.position))
                        continue;
                findcode = slotentity.GetComponent<CodeLock>();
            }
            return findcode;
        }
        void SpawnDeployable(string prefabname, Vector3 pos, Quaternion rot, BasePlayer player = null)
        {
            UnityEngine.GameObject newPrefab = GameManager.server.FindPrefab(prefabname);
            if (newPrefab == null) return;

            BaseEntity entity = GameManager.server.CreateEntity(newPrefab.name, pos, rot);
            if (entity == null) return;

            if (player != null)
                entity.SendMessage("SetDeployedBy", player, UnityEngine.SendMessageOptions.DontRequireReceiver);

            entity.Spawn(true);
        }

        void NewRoomOwner(CodeLock codelock, BasePlayer player, HotelData hotel, Room room)
        {
            BaseEntity door = codelock.GetParentEntity();
            Vector3 block = door.transform.position;

            EmptyDeployablesRoom(door, Convert.ToSingle(hotel.rr));

            foreach (DeployableItem deploy in room.defaultDeployables) { SpawnDeployable(deploy.prefabname, deploy.Pos(), deploy.Rot(), player); }

            List<ulong> whitelist = new List<ulong>();
            whitelist.Add(player.userID);
            fieldWhiteList.SetValue(codelock, whitelist);

            room.renter = player.userID.ToString();
            room.checkingTime = LogTime().ToString();

            room.checkoutTime = hotel.rd == "0" ? "0" : (LogTime() + double.Parse(hotel.rd)).ToString();
            room.Reset();

            LockLock(codelock);
            OpenDoor(door as Door);

            SendReply(player, hotel.rd == "0" ? MessageRentUnlimited : string.Format(MessageRentTimeLeft, ConvertSecondsToBetter(hotel.rd)));
        }
        void EmptyDeployablesRoom(BaseEntity door, float radius)
        {
            var founditems = new List<Deployable>();
            Vector3 doorpos = door.transform.position;
            foreach (Collider col in UnityEngine.Physics.OverlapSphere(doorpos, radius, deployableColl))
            {
                Deployable deploy = col.GetComponentInParent<Deployable>();
                if (deploy == null) continue;
                if (founditems.Contains(deploy)) continue;

                bool canReach = true;
                foreach (RaycastHit rayhit in UnityEngine.Physics.RaycastAll(deploy.transform.position + Vector3UP, (doorpos + Vector3UP - deploy.transform.position).normalized, Vector3.Distance(deploy.transform.position, doorpos) - 0.2f, constructionColl))
                {
                    if (rayhit.collider.GetComponentInParent<BaseEntity>() == door)
                        continue;
                    canReach = false;
                    break;
                }
                if (!canReach) continue;

                foreach (Collider col2 in UnityEngine.Physics.OverlapSphere(doorpos, radius, constructionColl))
                {
                    if (col2.GetComponentInParent<Door>() == null) continue;
                    if (col2.transform.position == doorpos) continue;

                    bool canreach2 = true;
                    foreach (RaycastHit rayhit in UnityEngine.Physics.RaycastAll(deploy.transform.position + Vector3UP, (col2.transform.position + Vector3UP - deploy.transform.position).normalized, Vector3.Distance(deploy.transform.position, col2.transform.position) - 0.2f, constructionColl)) { canreach2 = false; }
                    if (canreach2) { canReach = false; break; }
                }
                if (!canReach) continue;

                founditems.Add(deploy);
            }
            foreach (Deployable deploy in founditems)
            {
                if (!(deploy.GetComponentInParent<BaseEntity>().isDestroyed))
                    deploy.GetComponent<BaseEntity>().KillMessage();
            }
        }
        void ResetRoom(HotelData hotel, Room room)
        {
            CodeLock codelock = FindCodeLockByPos(room.Pos());
            if (codelock == null) return;
            ResetRoom(codelock, hotel, room);
        }
        void ResetRoom(CodeLock codelock, HotelData hotel, Room room)
        {
            BaseEntity door = codelock.GetParentEntity();
            Vector3 block = door.transform.position;

            EmptyDeployablesRoom(door, Convert.ToSingle(hotel.rr));
            foreach (DeployableItem deploy in room.defaultDeployables) { SpawnDeployable(deploy.prefabname, deploy.Pos(), deploy.Rot(), null); }

            fieldWhiteList.SetValue(codelock, new List<ulong>());

            UnlockLock(codelock);
            CloseDoor(door as Door);

            room.renter = null;
            room.checkingTime = null;
            room.checkoutTime = null;
            room.Reset();
        }

        void OnUseNPC(BasePlayer npc, BasePlayer player)
        {
            string npcid = npc.userID.ToString();
            foreach (HotelData hotel in storedData.Hotels)
            {
                if (hotel.npc == null) continue;
                if (hotel.npc != npcid) continue;

                if (UseNPCShowPlayerGUI)
                    RefreshPlayerHotelGUI(player, hotel);
                if (UseNPCShowRoom)
                    ShowPlayerRoom(player, hotel);
            }
        }
        void OnEnterZone(string zoneid, BasePlayer player)
        {
            foreach (HotelData hotel in storedData.Hotels)
            {
                if (hotel.hotelname == null) continue;
                if (hotel.hotelname != zoneid) continue;

                if (EnterZoneShowPlayerGUI)
                    RefreshPlayerHotelGUI(player, hotel);
                if (EnterZoneShowRoom)
                    ShowPlayerRoom(player, hotel);
            }
        }


        ////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// GUI
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////
        void RefreshAdminHotelGUI(BasePlayer player)
        {
            RemoveAdminHotelGUI(player);

            if (!EditHotel.ContainsKey(player.userID.ToString())) return;
            string Msg = CreateAdminGUIMsg(player);
            if (Msg == string.Empty) return;
            string send = adminguijson.Replace("{msg}", Msg);
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo() { connection = player.net.connection }, null, "AddUI", new Facepunch.ObjectList(send));
        }
        void RefreshPlayerHotelGUI(BasePlayer player, HotelData hotel)
        {
            RemovePlayerHotelGUI(player);
            string Msg = string.Empty;
            string send = string.Empty;

            if (!hotel.enabled)
            {

                Msg = CreatePlayerGUIMsg(player, hotel, GUIBoardPlayerMaintenance);
                send = playerguijson.Replace("{msg}", Msg);

            }
            else
            {
                Msg = CreatePlayerGUIMsg(player, hotel, GUIBoardPlayer);
                if (Msg == string.Empty) return;
                send = playerguijson.Replace("{msg}", Msg);
            }
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo() { connection = player.net.connection }, null, "AddUI", new Facepunch.ObjectList(send));
            playerguiTimers[player] = timer.Once(pTimeOut, () => RemovePlayerHotelGUI(player));
        }
        string ConvertSecondsToBetter(string seconds)
        {
            return ConvertSecondsToBetter(double.Parse(seconds));
        }
        string ConvertSecondsToBetter(double seconds)
        {
            TimeSpan t = TimeSpan.FromSeconds(seconds);
            return string.Format("{0:D2}d:{1:D2}h:{2:D2}m:{3:D2}s",
                t.Days,
                t.Hours,
                t.Minutes,
                t.Seconds);
        }
        string ConvertSecondsToDate(string seconds)
        {
            return ConvertSecondsToDate(double.Parse(seconds));
        }
        string ConvertSecondsToDate(double seconds)
        {
            return epoch.AddSeconds(seconds).ToLocalTime().ToString();
        }
        string CreatePlayerGUIMsg(BasePlayer player, HotelData hotel, string GUIMsg)
        {
            string newguimsg = string.Empty;

            string loc = hotel.x == null ? "None" : string.Format("{0} {1} {2}", hotel.x, hotel.y, hotel.z);
            string hrad = hotel.r == null ? "None" : hotel.r;
            string rrad = hotel.rr == null ? "None" : hotel.rr;
            string rnum = hotel.rooms == null ? "0" : hotel.rooms.Count.ToString();

            int onumint = 0;
            int fnumint = 0;
            string roomgui = string.Empty;
            if (hotel.rooms != null)
            {
                foreach (KeyValuePair<string, Room> pair in hotel.rooms)
                {
                    if (pair.Value.renter != null)
                    {
                        onumint++;
                        if (pair.Value.renter == player.userID.ToString())
                        {
                            roomgui = GUIBoardPlayerRoom.Replace("{jdate}", ConvertSecondsToDate(pair.Value.checkingTime)).Replace("{timeleft}", pair.Value.CheckOutTime() == 0.0 ? "Unlimited" : ConvertSecondsToBetter(pair.Value.CheckOutTime() - LogTime()));
                        }
                    }
                    else fnumint++;

                }
            }
            string onum = onumint.ToString();
            string fnum = fnumint.ToString();

            newguimsg = GUIMsg.Replace("{name}", hotel.hotelname).Replace("{loc}", loc).Replace("{hrad}", hrad).Replace("{rrad}", rrad).Replace("{rnum}", rnum).Replace("{onum}", onum).Replace("{fnum}", fnum) + roomgui;

            return newguimsg;
        }

        string CreateAdminGUIMsg(BasePlayer player)
        {
            string newguimsg = string.Empty;
            HotelData hoteldata = EditHotel[player.userID.ToString()];

            string loc = hoteldata.x == null ? "None" : string.Format("{0} {1} {2}", hoteldata.x, hoteldata.y, hoteldata.z);
            string hrad = hoteldata.r == null ? "None" : hoteldata.r;
            string rrad = hoteldata.rr == null ? "None" : hoteldata.rr;
            string rrp = hoteldata.e == null ? "None" : hoteldata.e;
            string rnum = hoteldata.rooms == null ? "0" : hoteldata.rooms.Count.ToString();

            int onumint = 0;
            int fnumint = 0;
            if (hoteldata.rooms != null)
            {
                foreach (KeyValuePair<string, Room> pair in hoteldata.rooms)
                {
                    if (pair.Value.renter != null) onumint++;
                    else fnumint++;
                }
            }
            string onum = onumint.ToString();
            string fnum = fnumint.ToString();

            newguimsg = GUIBoardAdmin.Replace("{name}", hoteldata.hotelname).Replace("{loc}", loc).Replace("{hrad}", hrad).Replace("{rrad}", rrad).Replace("{rnum}", rnum).Replace("{onum}", onum).Replace("{fnum}", fnum).Replace("{rp}", rrp);

            return newguimsg;
        }

        void RemoveAdminHotelGUI(BasePlayer player) { CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo() { connection = player.net.connection }, null, "DestroyUI", new Facepunch.ObjectList("HotelAdmin")); }
        void RemovePlayerHotelGUI(BasePlayer player)
        {
            if (player == null || player.net == null) return;
            if (playerguiTimers[player] != null)
                playerguiTimers[player].Destroy();
            CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo() { connection = player.net.connection }, null, "DestroyUI", new Facepunch.ObjectList("HotelPlayer"));
        }

        void ShowHotelGrid(BasePlayer player)
        {
            HotelData hoteldata = EditHotel[player.userID.ToString()];
            if (hoteldata.x != null && hoteldata.r != null)
            {
                Vector3 hpos = hoteldata.Pos();
                float hrad = Convert.ToSingle(hoteldata.r);
                player.SendConsoleCommand("ddraw.sphere", 5f, UnityEngine.Color.blue, hpos, hrad);
            }
            if (hoteldata.rooms == null) return;
            foreach (KeyValuePair<string, Room> pair in hoteldata.rooms)
            {
                List<DeployableItem> deployables = pair.Value.defaultDeployables;
                foreach (DeployableItem deployable in deployables)
                {
                    player.SendConsoleCommand("ddraw.arrow", 10f, UnityEngine.Color.green, pair.Value.Pos(), deployable.Pos(), 0.5f);
                }
            }
        }
        void ShowPlayerRoom(BasePlayer player, HotelData hotel)
        {
            Room foundroom = null;
            foreach (KeyValuePair<string, Room> pair in hotel.rooms)
            {
                if (pair.Value.renter == player.userID.ToString())
                {
                    foundroom = pair.Value;
                    break;
                }
            }
            if (foundroom == null) return;
            player.SendConsoleCommand("ddraw.arrow", 10f, UnityEngine.Color.green, player.transform.position, foundroom.Pos() + Vector3UP2, 0.5f);
        }

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// CHAT Related 
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////

        bool hasAccess(BasePlayer player)
        {
            if (player == null) return false;
            if (player.net.connection.authLevel >= authlevel) return true;
            return permission.UserHasPermission(player.userID.ToString(), "canhotel");
        }

        [ChatCommand("hotel_save")]
        void cmdChatHotelSave(BasePlayer player, string command, string[] args)
        {
            if (!hasAccess(player)) { SendReply(player, "You dont have access to this command"); return; }
            if (!EditHotel.ContainsKey(player.userID.ToString()))
            {
                SendReply(player, "You are not editing a hotel.");
                return;
            }
            HotelData editedhotel = EditHotel[player.userID.ToString()];

            HotelData removeHotel = null;
            foreach (HotelData hoteldata in storedData.Hotels)
            {
                if (hoteldata.hotelname.ToLower() == editedhotel.hotelname.ToLower())
                {
                    removeHotel = hoteldata;
                    break;
                }
            }
            if (removeHotel != null)
            {
                storedData.Hotels.Remove(removeHotel);
                removeHotel.Activate();
            }
            editedhotel.Activate();

            storedData.Hotels.Add(editedhotel);

            SaveData();
            LoadPermissions();

            EditHotel.Remove(player.userID.ToString());

            SendReply(player, "Hotel Saved and Closed.");

            RemoveAdminHotelGUI(player);
        }

        [ChatCommand("hotel_close")]
        void cmdChatHotelClose(BasePlayer player, string command, string[] args)
        {
            if (!hasAccess(player)) { SendReply(player, "You dont have access to this command"); return; }
            if (!EditHotel.ContainsKey(player.userID.ToString()))
            {
                SendReply(player, "You are not editing a hotel.");
                return;
            }
            HotelData editedhotel = EditHotel[player.userID.ToString()];
            foreach (HotelData hoteldata in storedData.Hotels)
            {
                if (hoteldata.hotelname.ToLower() == editedhotel.hotelname.ToLower())
                {
                    hoteldata.Activate();
                    break;
                }
            }

            EditHotel.Remove(player.userID.ToString());

            SendReply(player, "Hotel Closed without saving.");

            RemoveAdminHotelGUI(player);
        }

        [ChatCommand("hotel")]
        void cmdChatHotel(BasePlayer player, string command, string[] args)
        {
            if (!hasAccess(player)) { SendReply(player, "You dont have access to this command"); return; }
            if (!EditHotel.ContainsKey(player.userID.ToString()))
            {
                SendReply(player, "You are not editing a hotel. Create a new one with /hotel_new, or edit an existing one with /hotel_edit");
                return;
            }

            HotelData editedhotel = EditHotel[player.userID.ToString()];

            if (args.Length == 0)
            {
                SendReply(player, "==== Available options ====");
                SendReply(player, "/hotel location => sets the center hotel location where you stand");
                SendReply(player, "/hotel npc NPCID => sets the NPC that is hooked to this hotel (for UseNPC items)");
                SendReply(player, "/hotel permission PERMISSIONNAME => sets the oxide permissions that the player needs to rent a room here");
                SendReply(player, "/hotel radius XX => sets the radius of the hotel (the entire structure of the hotel needs to be covered by the zone");
                SendReply(player, "/hotel rentduration XX => Sets the duration of a default rent in this hotel. 0 is infinite.");
                SendReply(player, "/hotel rentprice XX => Sets the rentprice of a room. This requires Economics");
                SendReply(player, "/hotel reset => resets the hotel data (all players and rooms but keeps the hotel)");
                SendReply(player, "/hotel roomradius XX => sets the radius of the rooms");
                SendReply(player, "/hotel rooms => refreshs the rooms (detects new rooms, deletes rooms if they don't exist anymore, if rooms are in use they won't get taken in count)");
            }
            else
            {
                switch (args[0].ToLower())
                {
                    case "location":
                        string rad = editedhotel.r == null ? "20" : editedhotel.r;
                        string[] zoneargs = new string[] { "name", editedhotel.hotelname, "radius", rad };
                        ZoneManager.Call("CreateOrUpdateZone", editedhotel.hotelname, zoneargs, player.transform.position);

                        (EditHotel[player.userID.ToString()]).x = player.transform.position.x.ToString();
                        (EditHotel[player.userID.ToString()]).y = player.transform.position.y.ToString();
                        (EditHotel[player.userID.ToString()]).z = player.transform.position.z.ToString();

                        SendReply(player, string.Format("Location set to {0}", player.transform.position.ToString()));
                        break;
                    case "rentduration":
                        if (args.Length == 1)
                        {
                            SendReply(player, "/hotel rentduration XX");
                            return;
                        }
                        int rd = 86400;
                        int.TryParse(args[1], out rd);

                        (EditHotel[player.userID.ToString()]).rd = rd.ToString();
                        SendReply(player, string.Format("Rent Duration set to {0}", rd == 0 ? "Infinite" : rd.ToString()));
                        break;
                    case "rentprice":
                        if(Economics == null)
                        {
                            SendReply(player, "You don't have economics, so this is useless for you.");
                            return;
                        }
                        if (args.Length == 1)
                        {
                            SendReply(player, "/hotel rentprice XX");
                            return;
                        }
                        int rp = 0;
                        if(!int.TryParse(args[1], out rp))
                        {
                            SendReply(player, "/hotel rentprice XX");
                            return;
                        }
                        (EditHotel[player.userID.ToString()]).e = rp == 0 ? null : rp.ToString();
                        SendReply(player, string.Format("Rent Price set to {0}", rp == 0 ? "null" : rp.ToString()));
                        break;
                    case "roomradius":
                        if (args.Length == 1)
                        {
                            SendReply(player, "/hotel roomradius XX");
                            return;
                        }
                        int rad3 = 5;
                        int.TryParse(args[1], out rad3);
                        if (rad3 < 1) rad3 = 5;

                        (EditHotel[player.userID.ToString()]).rr = rad3.ToString();

                        SendReply(player, string.Format("RoomRadius set to {0}", args[1]));
                        break;
                    case "permission":
                        if (args.Length == 1)
                        {
                            SendReply(player, "/hotel permission PERMISSIONNAME => Sets a permission that the player must have to rent in this hotel. put null or false to cancel the permission");
                            return;
                        }
                        string setnewperm = (args[1].ToLower() == "null" || args[1].ToLower() == "false" || args[1].ToLower() == "0") ? null : args[1];
                        (EditHotel[player.userID.ToString()]).p = setnewperm;

                        SendReply(player, string.Format("Permissions set to {0}", setnewperm == null ? "null" : setnewperm));
                        break;
                    case "npc":
                        if (args.Length == 1)
                        {
                            SendReply(player, "/hotel npc NPCID");
                            return;
                        }
                        int npcid = 0;
                        int.TryParse(args[1], out npcid);
                        if (npcid < 1) return;

                        (EditHotel[player.userID.ToString()]).npc = npcid.ToString();
                        SendReply(player, string.Format("NPC ID hooked to this hotel: {0}", npcid.ToString()));
                        break;
                    case "rooms":
                        SendReply(player, "Rooms Refreshing ...");
                        (EditHotel[player.userID.ToString()]).RefreshRooms();

                        SendReply(player, "Rooms Refreshed");
                        break;
                    case "reset":
                        foreach (KeyValuePair<string, Room> pair in (EditHotel[player.userID.ToString()]).rooms)
                        {
                            CodeLock codelock = FindCodeLockByRoomID(pair.Key);
                            if (codelock == null) continue;
                            ResetRoom(codelock, (EditHotel[player.userID.ToString()]), pair.Value);
                        }
                        break;
                    case "radius":
                        if (args.Length == 1)
                        {
                            SendReply(player, "/hotel radius XX");
                            return;
                        }
                        int rad2 = 20;
                        int.TryParse(args[1], out rad2);
                        if (rad2 < 1) rad2 = 20;

                        string[] zoneargs2 = new string[] { "name", editedhotel.hotelname, "radius", rad2.ToString() };
                        ZoneManager.Call("CreateOrUpdateZone", editedhotel.hotelname, zoneargs2);

                        (EditHotel[player.userID.ToString()]).r = rad2.ToString();

                        SendReply(player, string.Format("Radius set to {0}", args[1]));
                        break;

                    default:
                        SendReply(player, string.Format("Wrong argument {0}", args[0]));
                        break;
                }
            }

            ShowHotelGrid(player);
            RefreshAdminHotelGUI(player);
        }
        [ChatCommand("hotel_list")]
        void cmdChatHotelList(BasePlayer player, string command, string[] args)
        {
            if (!hasAccess(player)) { SendReply(player, MessageErrorNotAllowed); return; }
            SendReply(player, "======= Hotel List ======");
            foreach (HotelData hotel in storedData.Hotels)
            {
                SendReply(player, string.Format("{0} - {1}", hotel.hotelname, hotel.rooms.Count.ToString()));
            }
        }

        [ChatCommand("hotel_edit")]
        void cmdChatHotelEdit(BasePlayer player, string command, string[] args)
        {
            if (!hasAccess(player)) { SendReply(player, MessageErrorNotAllowed); return; }
            if (EditHotel.ContainsKey(player.userID.ToString())) { SendReply(player, MessageAlreadyEditing); return; }
            if (args.Length == 0) { SendReply(player, MessageHotelEditHelp); return; }

            string hname = args[0];
            foreach (HotelData hotel in storedData.Hotels)
            {
                if (hotel.hotelname.ToLower() == hname.ToLower())
                {
                    hotel.Deactivate();
                    if (hotel.x != null && hotel.r != null)
                    {
                        foreach (Collider col in UnityEngine.Physics.OverlapSphere(hotel.Pos(), Convert.ToSingle(hotel.r), constructionColl))
                        {
                            Door door = col.GetComponentInParent<Door>();
                            if (door != null)
                            {
                                if (door.HasSlot(BaseEntity.Slot.Lock))
                                {
                                    door.SetFlag(BaseEntity.Flags.Open, false);
                                    door.SendNetworkUpdateImmediate(true);
                                }
                            }
                        }
                    }
                    EditHotel.Add(player.userID.ToString(), hotel);
                    break;
                }
            }

            if (!EditHotel.ContainsKey(player.userID.ToString())) { SendReply(player, string.Format(MessageErrorEditDoesntExist, args[0])); return; }

            SendReply(player, string.Format(MessageHotelEditEditing, EditHotel[player.userID.ToString()].hotelname));

            RefreshAdminHotelGUI(player);
        }

        [ChatCommand("hotel_remove")]
        void cmdChatHotelRemove(BasePlayer player, string command, string[] args)
        {
            if (!hasAccess(player)) { SendReply(player, MessageErrorNotAllowed); return; }
            if (EditHotel.ContainsKey(player.userID.ToString())) { SendReply(player, MessageAlreadyEditing); return; }
            if (args.Length == 0) { SendReply(player, MessageHotelEditHelp); return; }

            string hname = args[0];
            HotelData targethotel = null;
            foreach (HotelData hotel in storedData.Hotels)
            {
                if (hotel.hotelname.ToLower() == hname.ToLower())
                {
                    hotel.Deactivate();
                    targethotel = hotel;
                    break;
                }
            }
            if (targethotel == null) { SendReply(player, string.Format(MessageErrorEditDoesntExist, args[0])); return; }

            storedData.Hotels.Remove(targethotel);
            SaveData();
            SendReply(player, string.Format("Hotel Named: {0] was successfully removed", hname));

        }

        [ChatCommand("hotel_reset")]
        void cmdChatHotelReset(BasePlayer player, string command, string[] args)
        {
            if (!hasAccess(player)) { SendReply(player, MessageErrorNotAllowed); return; }
            if (EditHotel.ContainsKey(player.userID.ToString())) { SendReply(player, MessageAlreadyEditing); return; }

            storedData.Hotels = new HashSet<HotelData>();
            SaveData();
            SendReply(player, "Hotels were all deleted");

        }


        BuildingBlock FindBlockFromRay(Vector3 Pos, Vector3 Aim)
        {
            var hits = UnityEngine.Physics.RaycastAll(Pos, Aim);
            float distance = 100000f;
            BuildingBlock target = null;
            foreach (var hit in hits)
            {
                if (hit.collider.GetComponentInParent<BuildingBlock>() != null)
                {
                    if (hit.distance < distance)
                    {
                        distance = hit.distance;
                        target = hit.collider.GetComponentInParent<BuildingBlock>();
                    }
                }
            }
            return target;
        }
        Vector3 RayForDoor(BasePlayer player)
        {
            var input = serverinput.GetValue(player) as InputState;
            var currentRot = Quaternion.Euler(input.current.aimAngles);
            BuildingBlock target = FindBlockFromRay(player.eyes.position, currentRot * Vector3.forward);
            if (target == null) return default(Vector3);
            if (target.GetComponent<Door>() == null) return default(Vector3);
            return target.transform.position;
        }
        bool FindRoomByID(string roomid, out HotelData targethotel, out Room targetroom)
        {
            targethotel = null;
            targetroom = null;
            foreach (HotelData hotel in storedData.Hotels)
            {
                if(hotel.rooms.ContainsKey(roomid))
                {
                    targethotel = hotel;
                    targetroom = (hotel.rooms)[roomid];
                    return true;
                }
            }
            return false;
        }
        [ChatCommand("room")]
        void cmdChatRoom(BasePlayer player, string command, string[] args)
        {
            if (!hasAccess(player)) { SendReply(player, MessageErrorNotAllowed); return; }
            string roomid = string.Empty;
            int argsnum = 0;
            if (args.Length > 0)
            {
                string[] roomloc;
                roomloc = (args[0]).Split(':');
                if (roomloc.Length == 3)
                    roomid = args[0];
            }
            if (roomid == string.Empty)
            {
                Vector3 doorpos = RayForDoor(player);
                if (doorpos == default(Vector3))
                {
                    SendReply(player, "You must look at the door of the room or put the roomid");
                    return;
                }
                roomid = string.Format("{0}:{1}:{2}", Mathf.Ceil(doorpos.x).ToString(), Mathf.Ceil(doorpos.y).ToString(), Mathf.Ceil(doorpos.z).ToString());
            }
            else
                argsnum++;
            if (roomid == string.Empty)
            {
                SendReply(player, "Invalid room.");
                return;
            }
            HotelData targethotel = null;
            Room targetroom = null;
            if (!FindRoomByID(roomid, out targethotel, out targetroom))
            {
                SendReply(player, "No room was detected.");
                return;
            }
            if (args.Length - argsnum == 0)
            {
                SendReply(player, string.Format("Room ID is: {0} in hotel: {1}", targetroom.roomid, targethotel.hotelname));
                SendReply(player, "Options are:");
                SendReply(player, "/room \"optional:roomid\" reset => to reset this room");
                //SendReply(player, "/room \"optional:roomid\" give NAME/STEAMID => to give a player this room");
                SendReply(player, "/room \"optional:roomid\" duration XXXX => to set a new duration time for a player (from the time you set the duration)");
                return;
            }
            if (!targethotel.enabled)
            {
                SendReply(player, "This hotel is currently being edited by an admin, you can't manage a room from it");
                return;
            }
            switch (args[argsnum])
            {
                case "reset":
                    ResetRoom(targethotel, targetroom);
                    SendReply(player, string.Format("The room {0} was resetted", targetroom.roomid));
                break;

                case "duration":
                    if (targetroom.renter == null)
                    {
                        SendReply(player, string.Format("The room {0} has currently no renter, you can't set a duration for it", targetroom.roomid));
                        return;
                    }
                    if (args.Length == argsnum + 1)
                    {
                        double timeleft = targetroom.CheckOutTime() - LogTime();
                        SendReply(player, string.Format("The room {0} renter will expire in {1}", targetroom.roomid, targetroom.CheckOutTime() == 0.0 ? "Unlimited" : ConvertSecondsToBetter(timeleft)));
                        return;
                    }
                    double newtimeleft;
                    if (!double.TryParse(args[argsnum + 1], out newtimeleft))
                    {
                        SendReply(player, "/room \"optional:roomid\" duration NEWTIMELEFT");
                        return;
                    }
                    targetroom.checkoutTime = (newtimeleft + LogTime()).ToString();
                    SendReply(player, string.Format("New timeleft for room ID {0} is {1}s", targetroom.roomid, newtimeleft.ToString()));
                break;

                case "give":
                    if (targetroom.renter != null)
                    {
                        SendReply(player, string.Format("The room {0} is already rented by {1}, reset the room first to set a new renter", targetroom.roomid, targetroom.renter));
                        return;
                    }
                    if (args.Length == argsnum + 1)
                    {
                        SendReply(player, "/room \"optional:roomid\" give PLAYER/STEAMID");
                        return;
                    }

                break;

                default:
                    SendReply(player, "This is not a valid option, say /room \"optional:roomid\" to see the options");
                    break;
            }

        }

        [ChatCommand("hotel_new")]
        void cmdChatHotelNew(BasePlayer player, string command, string[] args)
        {
            if (!hasAccess(player)) { SendReply(player, MessageErrorNotAllowed); return; }
            if (EditHotel.ContainsKey(player.userID.ToString())) { SendReply(player, MessageAlreadyEditing); return; }
            if (args.Length == 0) { SendReply(player, MessageHotelNewHelp); return; }

            string hname = args[0];
            if (storedData.Hotels.Count > 0)
            { 
                foreach (HotelData hotel in storedData.Hotels)
                {
                    if (hotel.hotelname.ToLower() == hname.ToLower())
                    {
                        SendReply(player, string.Format(MessageErrorAlreadyExist, hname));
                        return;
                    }
                }
            }
            HotelData newhotel = new HotelData(hname);
            newhotel.Deactivate();
            EditHotel.Add(player.userID.ToString(), newhotel);

            SendReply(player, string.Format(MessageHotelNewCreated, hname));
            RefreshAdminHotelGUI(player);
        }
    }
}

// --- End of file: Hotel.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BuildingWrapper.cs ---
// --- Original Local Path: BuildingWrapper.cs ---

using System.Collections.Generic;
using System;
using System.Reflection;
using System.Linq;
using UnityEngine;
using Oxide.Core.Plugins;
using Facepunch;

namespace Oxide.Plugins
{
	[Info("BuildingWrapper", "ignignokt84", "0.1.3", ResourceId = 1798)]
	class BuildingWrapper : RustPlugin
	{
		/*
		BuildingWrapper helper plugin for ZoneManager
		
		Allows players to neatly and automatically wrap buildings in zones
		*/
		
		// load default messages to Lang
		void LoadDefaultMessages()
		{
			var messages = new Dictionary<string, string>
			{
				{"ChatCommand", "bw"},
				{"VersionString", "BuildingWrapper v. {0}"},
				
				{"UsageHeader", "---- BuildingWrapper usage ----"},
				{"CmdUsageWrap", "Wrap new or existing zone around the building being looked at"},
				{"CmdUsageRewrap", "Re-wrap all buildings within a zone"},
				{"CmdUsageExtend", "Extend an existing zone to include building being looked at"},
				{"CmdUsageParamZoneId", "Note: [zone_id] is required, but can be entered as \"auto\" for automatic generation"},
				
				{"NoZoneManager", "ZoneManager not detected - BuildingWrapper disabled"},
				{"ZoneManagerLoaded", "ZoneManager loaded - BuildingWrapper enabled"},
				{"ZoneManagerUnloaded", "ZoneManager unloaded - BuildingWrapper disabled"},
				{"NoPermission", "You do not have permission to use this command"},
				
				{"NotSupported", "The command \"{0}\" is not currently supported"},
				
				{"InvalidParameter", "Invalid Parameter: {0}"},
				{"MissingZoneId", "Missing value for required parameter zone_id (use \"auto\" for automatic assignment)"},
				{"NoAutoZoneId", "Zone ID cannot be auto generated for the command \"{0}\""},
				{"ZoneNotFound", "Zone with ID \"{0}\" could not be found"},
				{"InvalidBuffer", "Invalid buffer value: {0}"},
				{"NoBuilding", "No building detected"},
				
				{"ZoneWrapSuccess", "Successfully created/updated zone {0}"},
				{"ZoneWrapFailure", "Failed to create/update zone {0}"}
			};
			lang.RegisterMessages(messages, this);
		}
		
		// ZoneManager base permission
		private const string ZoneManagerPermZone = "zonemanager.zone";

		// link to ZoneManager
		[PluginReference]
		Plugin ZoneManager;
		
		static FieldInfo serverinput;
		private readonly FieldInfo instancesField = typeof(MeshColliderBatch).GetField("instances", BindingFlags.Instance | BindingFlags.NonPublic);
        private int layerMasks = LayerMask.GetMask("Construction", "Construction Trigger", "Trigger");
		// usage information string with formatting
		public string usageString;
		// command enum
		private enum Command { usage, wrap, rewrap, extend};
		// option enum
		private enum Option { box, sphere, undef };
		// vertical height adjustment
		private const float yAdjust = 2f;
		// collider buffer for finding building blocks
    	private Collider[] colBuffer;
		
		// load
		void Loaded()
		{
			colBuffer = new Collider[8192];
			LoadDefaultMessages();
			string chatCommand = GetMessage("ChatCommand");
			cmd.AddChatCommand(chatCommand, this, "cmdChatDelegator");
			
			// build usage string
			usageString = wrapSize(14, wrapColor("orange", GetMessage("UsageHeader"))) + "\n" +
						  wrapSize(12, wrapColor("cyan", "/" + chatCommand + " " + Command.wrap + " [zone_id] <box|sphere> <buffer>") + " - " + GetMessage("CmdUsageWrap") + "\n" +
						  wrapColor("cyan", "/" + chatCommand + " " + Command.rewrap + " [zone_id] <box|sphere> <buffer>") + " - " + GetMessage("CmdUsageRewrap") + "\n" +
						  wrapColor("cyan", "/" + chatCommand + " " + Command.extend + " [zone_id] <box|sphere> <buffer>") + " - " + GetMessage("CmdUsageExtend") + "\n" +
						  wrapColor("yellow", GetMessage("CmdUsageParamZoneId")));
			
			serverinput = typeof(BasePlayer).GetField("serverInput", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
		}
		
		// server initialized
		private void OnServerInitialized()
		{
			if(ZoneManager == null)
				PrintError(GetMessage("NoZoneManager"));
			// don't use popups yet
			//usePopups = (PopupNotifications != null);
		}
		
		// plugin loaded
		private void OnPluginLoaded(Plugin plugin)
		{
			if(plugin.Name == "ZoneManager")
			{
				ZoneManager = plugin;
				Puts(GetMessage("ZoneManagerLoaded"));
			}
		}
		
		// plugin unloaded
		private void OnPluginUnloaded(Plugin plugin)
		{
			if(plugin.Name == "ZoneManager")
			{
				ZoneManager = null;
				PrintWarning(GetMessage("ZoneManagerUnloaded"));
			}
		}

		// get message from Lang
		string GetMessage(string key, string userId = null) => lang.GetMessage(key, this, userId);
		
		// print usage string
		void showUsage(BasePlayer player)
		{
			SendReply(player, usageString);
		}
		
		// main delegator process - handles all commands
		void cmdChatDelegator(BasePlayer player, string command, string[] args)
		{
			if(ZoneManager == null)
			{
				SendReply(player, wrapSize(12, wrapColor("red", GetMessage("NoZoneManager"))));
				return;
			}
			if(!hasPermission(player, ZoneManagerPermZone))
			{
				SendReply(player, wrapSize(12, wrapColor("red", GetMessage("NoPermission"))));
				return;
			}
			if(args == null || args.Length == 0)
				showUsage(player);
			else if(!Enum.IsDefined(typeof(Command), args[0]))
				SendReply(player, wrapSize(12, wrapColor("red", String.Format(GetMessage("InvalidParameter"), args[0]))));
			else
			{
				Command cmd = (Command) Enum.Parse(typeof(Command), args[0]);
				if(cmd == Command.usage)
				{
					showUsage(player);
					return;
				}
				
				bool update = false;
				float buffer = 1.0f;
				Option opt = Option.undef;
				if(args.Length < 2 || args[1] == "")
				{
					SendReply(player, wrapSize(12, wrapColor("red", GetMessage("MissingZoneId"))));
					return;
				}
				
				// get zone ID
				string zoneId = args[1];
				if(zoneId == null || zoneId == "auto")
				{
					if(cmd == Command.extend)
					{
						SendReply(player, wrapSize(12, wrapColor("red", String.Format(GetMessage("NoAutoZoneId"), cmd.ToString()))));
						return;
					}
					zoneId = UnityEngine.Random.Range(1, 99999999).ToString();
				}
				int i = 2;
				
				// get option and buffer values if they exist
				if(i < args.Length)
					if(args[i] == "box" || args[i] == "sphere")
						opt = (Option) Enum.Parse(typeof(Option), args[i++]);
				if(i < args.Length)
					try {
						buffer = Convert.ToSingle(args[i++]);
					} catch(FormatException e) {
						SendReply(player, wrapSize(12, wrapColor("red", String.Format(GetMessage("InvalidBuffer"), args[i-1]))));
					}
				
				//float timestart = UnityEngine.Time.realtimeSinceStartup;
				WrapBuilding(player, zoneId, opt, buffer, cmd);
				//float timeend = UnityEngine.Time.realtimeSinceStartup;
				//Puts("wrap time: " + (timeend-timestart) + "s");
			}
		}
		
		// wrap building delegator
		void WrapBuilding(BasePlayer player, string zoneId, Option shape, float buffer, Command cmd)
		{
			HashSet<BuildingBlock> initialBlocks = new HashSet<BuildingBlock>();
			Option zoneShape = Option.undef;
			if(cmd == Command.rewrap)
			{
				// if rewrap, get BuildingBlocks inside zone
				initialBlocks = getZoneEntities(player, zoneId, out zoneShape);
				if(zoneShape == Option.undef)
					return; // failure in getZoneEntities
			}
			else
			{
				// default sphere
				zoneShape = Option.sphere;
				// raycast to find building
				object closestEntity;
				if(!GetRaycastTarget(player, out closestEntity))
				{
					SendReply(player, wrapSize(12, wrapColor("red", GetMessage("NoBuilding"))));
					return;
				}
				BuildingBlock initialBlock = closestEntity as BuildingBlock;
				if(initialBlock == null)
				{
					SendReply(player, wrapSize(12, wrapColor("red", GetMessage("NoBuilding"))));
					return;
				}
				initialBlocks.Add(initialBlock);
			}
			// retrieve structure
			HashSet<BuildingBlock> all_blocks;
			if(!GetStructure(initialBlocks, out all_blocks))
			{
				SendReply(player, wrapSize(12, wrapColor("red", GetMessage("NoBuilding"))));
				return;
			}
			
			if(cmd == Command.extend)
			{
				// if extend, merge structure block coordinates
				all_blocks.UnionWith(getZoneEntities(player, zoneId, out zoneShape));
				if(zoneShape == Option.undef)
					return; // failure in getZoneEntities
			}
			
			bool success = false;
			if(shape == Option.undef)
				shape = (Option) zoneShape;
			if(shape == Option.box)
				success = WrapBox(player, zoneId, all_blocks, buffer);
			else if(shape == Option.sphere)
				success = WrapSphere(zoneId, all_blocks, buffer);
			
			string str = success ? "Success" : "Failure";
			
			SendReply(player, wrapSize(12, wrapColor(success ? "cyan" : "red", String.Format(GetMessage("ZoneWrap"+str), zoneId))));
		}
		
		// get zone entities from existing zone, returning zoneShape "undef" signals failure
		HashSet<BuildingBlock> getZoneEntities(BasePlayer player, string zoneId, out Option zoneShape)
		{
			HashSet<BuildingBlock> structure = new HashSet<BuildingBlock>();
			// get zone information
			Dictionary<string,string> zoneInfo = (Dictionary<string, string>) ZoneManager?.Call("ZoneFieldList", new object[] {zoneId});
			if(zoneInfo == null || zoneInfo.Count() == 0)
			{
				// failed to find zone - send message, flag zoneShape as undef
				SendReply(player, wrapSize(12, wrapColor("red", String.Format(GetMessage("ZoneNotFound"), zoneId))));
				zoneShape = Option.undef;
				return null;
			}
			// get zone values
			Vector3 zoneLocation = parseVector3(zoneInfo["Location"]);
			Vector3 zoneSize = parseVector3(zoneInfo["size"]);
			Vector3 rotation = parseVector3(zoneInfo["rotation"]);
			float zoneRadius = Convert.ToSingle(zoneInfo["radius"]);
			
			List<BaseEntity> list = Pool.GetList<BaseEntity>();
			// find intersecting entities
			if(zoneSize != Vector3.zero)
			{
				zoneShape = Option.box;
				BoxEntities<BaseEntity>(zoneLocation, zoneSize/2f, Quaternion.Euler(rotation), list, layerMasks);
			}
			else
			{
				zoneShape = Option.sphere;
				Vis.Entities<BaseEntity>(zoneLocation, zoneRadius, list, layerMasks);
			}
			
			// add building blocks to structure set
			BuildingBlock fbuildingblock;
			for (int i = 0; i < list.Count; i++)
			{
				BaseEntity hit = list[i];
				if (hit.GetComponentInParent<BuildingBlock>() != null)
				{
					fbuildingblock = hit.GetComponentInParent<BuildingBlock>();
					if (!(structure.Contains(fbuildingblock)))
						structure.Add(fbuildingblock);
				}
			}
			
			return structure;
		}
		
		// parse Vector3 coordinates from a string in the format "(x, y, z)"
		Vector3 parseVector3(string str)
		{
			string[] strArray = str.Substring(1, str.Length - 2).Split(',');
			return new Vector3(float.Parse(strArray[0]), float.Parse(strArray[1]), float.Parse(strArray[2]));
		}
		
		// raycast and return the closest entity - returns false if a valid entity is not found
		// amalgamation of processes from CopyPaste, and some adjustments
		bool GetRaycastTarget(BasePlayer player, out object closestEntity)
		{
			closestEntity = false;
			var input = serverinput.GetValue(player) as InputState;
			if (input == null || input.current == null || input.current.aimAngles == Vector3.zero)
				return false;
			
			Vector3 sourceEye = player.transform.position + new Vector3(0f, 1.6f, 0f);
			Ray ray = new Ray(sourceEye, Quaternion.Euler(input.current.aimAngles) * Vector3.forward);
			
			var hits = Physics.RaycastAll(ray);
			float closestdist = 100f;
			foreach (var hit in hits)
			{
				if (hit.collider.isTrigger)
					continue;
				if (hit.distance < closestdist)
				{
					closestdist = hit.distance;
					closestEntity = hit.GetEntity();
				}
			}
			if (closestEntity is bool)
				return false;
			return true;
		}
		
		// get all BuildingBlock entities in structure
		// basic process replicated from CopyPaste, reduced to only handle BuildingBlocks
		bool GetStructure(HashSet<BuildingBlock> initialBlocks, out HashSet<BuildingBlock> structure)
		{
			structure = new HashSet<BuildingBlock>();
			List<Vector3> checkFrom = new List<Vector3>();
			BuildingBlock fbuildingblock;
			
			foreach(BuildingBlock block in initialBlocks)
			{
				checkFrom.Add(block.transform.position);
				structure.Add(block);
			}

			int current = 0;
			while (true)
			{
				current++;
				if (current > checkFrom.Count)
					break;
				List<BaseEntity> list = Pool.GetList<BaseEntity>();
				Vis.Entities<BaseEntity>(checkFrom[current - 1], 3f, list, layerMasks);
				for (int i = 0; i < list.Count; i++)
				{
					BaseEntity hit = list[i];
					if (hit.GetComponentInParent<BuildingBlock>() != null)
					{
						fbuildingblock = hit.GetComponentInParent<BuildingBlock>();
						if (!(structure.Contains(fbuildingblock)))
						{
							checkFrom.Add(fbuildingblock.transform.position);
							structure.Add(fbuildingblock);
						}
					}
				}
			}
			
			return true;
		}
		
		// wrap building in a box zone
		bool WrapBox(BasePlayer player, string zoneId, HashSet<BuildingBlock> blocks, float buffer)
		{
			float minY =  Mathf.Infinity;
			float maxY = -Mathf.Infinity;
			
			Vector2 origin = new Vector2(0f, 0f); // origin, for rotations
			
			float extents = 0f;
			HashSet<Vector2> points = new HashSet<Vector2>();
			for(int i=0; i<blocks.Count(); i++)
			{
				Bounds b = blocks.ElementAt(i).WorldSpaceBounds().ToBounds();
				//float d = b.max;
				Vector3 v = blocks.ElementAt(i).CenterPoint();
				
				if(v == Vector3.zero)
					continue; // cannot get position?
				
				float d = Mathf.Abs(Vector3.Distance(v, b.max))*2f;
				if(d > extents) extents = d; // set max extents for buffering zone
				
				// flatten point to horizontal plane
				points.Add(new Vector2(v.x, v.z));
				
				if (v.y < minY) minY = v.y;
				if (v.y > maxY) maxY = v.y;
			}
			// get height (vertical axis)
			float sizeY = maxY - minY;

			// calculate hull
			Vector2[] hull = constructHull(points.ToArray());
			// extract center point from hull
			Vector2 center2 = getCenterFromHull(hull);
			Vector3 center = new Vector3(center2.x, minY + sizeY/2f, center2.y);
			//drawHull(player, hull, center); // draw hull for debugging
			
			// finds the smallest rectangle by traversing each edge in the hull,
			// rotating the hull to align the edge with the x axis, then finding
			// the minimum and maximum x and y values, and computing the area
			float minArea = Mathf.Infinity;
			float bestX = 0f;
			float bestY = 0f;
			float bestAngle = 0f;
			Vector2 bestCenter = center2; // initial "best" center point
			for(int i=0; i<hull.Length; i++)
			{
				int j = i+1;
				if(j == hull.Length)
					j = 0; // wrap j to first hull point
				
				// determine angle of current line segment
				float angle = getAngle(hull[i], hull[j]);
				// translate all points by rotating them by the specified angle
				Vector2[] rPoints = rotateAll(hull, angle, origin);
				float min_X =  Mathf.Infinity;
				float max_X = -Mathf.Infinity;
				float min_Y =  Mathf.Infinity;
				float max_Y = -Mathf.Infinity;
				// find min and max x/y values from points
				for(int k = 0; k<rPoints.Length; k++)
				{
					if(rPoints[k].x < min_X) min_X = rPoints[k].x;
					if(rPoints[k].x > max_X) max_X = rPoints[k].x;
					if(rPoints[k].y < min_Y) min_Y = rPoints[k].y;
					if(rPoints[k].y > max_Y) max_Y = rPoints[k].y;
				}
				float x = max_X - min_X;
				float y = max_Y - min_Y;
				float area = x*y;
				if(area < minArea)
				{
					// smallest area so far - save key values
					minArea = area;
					bestX = x;
					bestY = y;
					bestAngle = angle;
					bestCenter = rotate(new Vector2(min_X + x/2f, min_Y + y/2f), -angle, origin);
					// draw box for debugging
					//drawHull(player, rotateAll(new Vector2[] {new Vector2(max_X, max_Y),
					//							   new Vector2(max_X, min_Y),
					//							   new Vector2(min_X, min_Y),
					//							   new Vector2(min_X, max_Y)}, -angle, origin), new Vector3(bestCenter.x, center.y, bestCenter.y));
				}
			}
			
			// add buffer value to extents
			extents += buffer;
			// convert angle to degrees
			bestAngle *= Mathf.Rad2Deg;
			// draw center point for debugging
			//drawCenter(player, new Vector3(bestCenter.x, center.y, bestCenter.y));
			
			// create zone with parameters: zoneId, args, position
			return (bool) ZoneManager?.Call("CreateOrUpdateZone", new object[] {zoneId,
																				new string[] { "size", (bestX+extents) + " " + (sizeY+extents) + " " + (bestY+extents),
																							   "rotation", bestAngle.ToString()},
																				new Vector3(bestCenter.x, center.y+yAdjust, bestCenter.y)
																				});
		}
		
		// wrap building in a sphere zone
		bool WrapSphere(string zoneId, HashSet<BuildingBlock> blocks, float buffer)
		{
			float minX =  Mathf.Infinity;
			float maxX = -Mathf.Infinity;
			float minY =  Mathf.Infinity;
			float maxY = -Mathf.Infinity;
			float minZ =  Mathf.Infinity;
			float maxZ = -Mathf.Infinity;
			for(int i=0; i<blocks.Count(); i++)
			{
				Vector3 v = blocks.ElementAt(i).CenterPoint();
				if(v == Vector3.zero)
					continue; // cannot get position?
				
				if (v.x < minX) minX = v.x;
				if (v.x > maxX) maxX = v.x;
				if (v.y < minY) minY = v.y;
				if (v.y > maxY) maxY = v.y;
				if (v.z < minZ) minZ = v.z;
				if (v.z > maxZ) maxZ = v.z;
			}
			
			float sizeX = maxX - minX;
			float sizeY = maxY - minY;
			float sizeZ = maxZ - minZ;

			// get center + yAdjust (y shift)
			Vector3 center = new Vector3(minX + sizeX / 2.0f, (minY + sizeY / 2.0f) + yAdjust, minZ + sizeZ / 2.0f);
			
			// find radius
			float radius = 0f;
			float extents = 0f;
			for(int i=0; i<blocks.Count(); i++)
			{
				Bounds b = blocks.ElementAt(i).WorldSpaceBounds().ToBounds();
				Vector3 v = blocks.ElementAt(i).CenterPoint();
				if(v == Vector3.zero)
					continue; // cannot get position?
				// get distance from center
				float d = Vector3.Distance(center, v);
				if(d > radius)
				{
					radius = d; // set radius = distance
					extents = Vector3.Distance(v, b.max);
				}
			}
			
			radius += extents + buffer; // add extents and buffer
			// create zone with parameters: zoneId, args, position
			return (bool) ZoneManager?.Call("CreateOrUpdateZone", new object[] {zoneId,
																				new string[] { "radius", radius.ToString(),
																							   "size", "0 0 0"},
																				center
																				});
		}
		
		// rotate all passed Vector2 (point) in the array around the center point to achieve the given angle
		private Vector2[] rotateAll(Vector2[] v, float angle, Vector2 center)
		{
			Vector2[] rotated = new Vector2[v.Length];
			for(int i=0; i<v.Length; i++)
				rotated[i] = rotate(v[i], angle, center);
			return rotated;
		}
		
		// rotate the passed Vector2 (point) around the center point to achieve the given angle
		private Vector2 rotate(Vector2 v, float angle, Vector2 center)
		{
			if(v == center || angle == 0f)
				return v;
			float x = center.x + (v.x-center.x)*Mathf.Cos(angle) - (v.y-center.y)*Mathf.Sin(angle);
			float y = center.y + (v.x-center.x)*Mathf.Sin(angle) + (v.y-center.y)*Mathf.Cos(angle);
			return new Vector2(x,y);

			//return new Vector2( (float)rx, (float)(v.x * sa + v.y * ca));
		}

		// calculate angle in radians of the line segment connnecting two points
		float getAngle(Vector2 p0, Vector2 p1)
		{
			return Mathf.Atan2(p1.x - p0.x,p1.y - p0.y);//*Mathf.Rad2Deg;
		}
		
		// construct 2d hull using Andrew's monotone chain 2d convex hull algorithm
		// converted from c++ algorithm implementation (c) softSurver/Dan Sunday
		// see http://geomalgorithms.com/a10-_hull-1.html#chainHull_2D() for c++
		Vector2[] constructHull(Vector2[] points)
		{
			if(points == null || points.Length == 0)
				return null;
			
			// sort points by x then y
			points = points.OrderBy(x => x.x).ThenBy(x => x.y).ToArray();
			
			int i; // array scan index
			
			Stack<Vector2> hullStack = new Stack<Vector2>();
			int minmin = 0;
			float xmin = points[0].x;
			
			for(i=1; i<points.Length; i++)
				if(points[i].x != xmin) break;
			int minmax = i-1;
			
			if(minmax == points.Length-1) // all x-coords = xmin
			{
				hullStack.Push(points[minmin]);
				if(points[minmax].y != points[minmin].y) // non-trivial segment
					hullStack.Push(points[minmax]);
				hullStack.Push(points[minmin]);
				return hullStack.ToArray();
			}
			
			int maxmax = points.Length-1;
			float xmax = points[points.Length-1].x;
			for(i=points.Length-2; i>=0; i--)
				if(points[i].x != xmax) break;
			int maxmin = i+1;
			
			// compute lower hull on stack
			hullStack.Push(points[minmin]);
			i = minmax;
			while(++i <= maxmin)
			{
				if(isLeft(points[minmin], points[maxmin], points[i]) >= 0 && i < maxmin)
					continue; // ignore point on or above lower line
				
				while(hullStack.Count > 1) // at least 2 points on stack
				{
					Vector2 topPoint = hullStack.Pop();
					if(isLeft(hullStack.Peek(), topPoint, points[i]) > 0)
					{
						hullStack.Push(topPoint); // new hull point
						break;
					}
				}
				hullStack.Push(points[i]); // push point to stack
			}
			
			// computer upper hull on stack
			if(maxmax != maxmin)
				hullStack.Push(points[maxmax]);
			int bot = hullStack.Count; // index for bottom of the stack
			i = maxmin;
			while(--i >= minmax)
			{
				if(isLeft(points[maxmax], points[minmax], points[i]) >= 0 && i > minmax)
					continue; // ignore point below or on upper line
				
				while(hullStack.Count > bot)
				{
					Vector2 topPoint = hullStack.Pop();
					if(isLeft(hullStack.Peek(), topPoint, points[i]) > 0)
					{
						hullStack.Push(topPoint); // new hull point
						break;
					}
				}
				hullStack.Push(points[i]);
			}
			
			if(minmax != minmin)
				hullStack.Push(points[minmin]);
			
			return hullStack.ToArray();
		}
		
		// tests if a point is left/on/right of a line
		// >0 p2 is left of line p0p1
		// =0 p2 on line p0p1
		// <0 p2 is right of line p0p1
		float isLeft(Vector2 p0, Vector2 p1, Vector2 p2)
		{
			return (p1.x - p0.x)*(p2.y - p0.y) - (p2.x - p0.x)*(p1.y - p0.y);
		}
		
		// gets the center point from a hull by finding the min/max x/y values and averaging them
		Vector2 getCenterFromHull(Vector2[] hull)
		{
			float min_X = Mathf.Infinity;
			float max_X = -Mathf.Infinity;
			float min_Y = Mathf.Infinity;
			float max_Y = -Mathf.Infinity;
			for(int i=0; i<hull.Length-1; i++)
			{
				if(hull[i].x < min_X) min_X = hull[i].x;
				if(hull[i].x > max_X) max_X = hull[i].x;
				if(hull[i].y < min_Y) min_Y = hull[i].y;
				if(hull[i].y > max_Y) max_Y = hull[i].y;
			}
			return new Vector2((min_X + max_X)/2f, (min_Y + max_Y)/2f);
		}
		
		// wrap a string in a <size> tag with the passed size
		static string wrapSize(int size, string input)
		{
			if(input == null || input == "")
				return input;
			return "<size=" + size + ">" + input + "</size>";
		}
		
		// wrap a string in a <color> tag with the passed color
		static string wrapColor(string color, string input)
		{
			if(input == null || input == "" || color == null || color == "")
				return input;
			return "<color=" + color + ">" + input + "</color>";
		}
		
		// draw hull, for debugging - assumes array is an ordered set of perimiter vertices
		void drawHull(BasePlayer player, Vector2[] hull, Vector3 center)
		{
			for(int i=0; i<hull.Length; i++)
			{
				Vector3 from = new Vector3(hull[i].x, center.y+1f, hull[i].y);
				int j = i+1;
				if(j==hull.Length) j = 0;
				Vector3 to = new Vector3(hull[j].x, center.y+1f, hull[j].y);
				player.SendConsoleCommand("ddraw.line", 10f, Color.cyan, from, to);
			}
		}
		
		// draw center point as xyz axis, for debugging
		void drawCenter(BasePlayer player, Vector3 center)
		{
			float length = 0.5f;
			Vector3 xP = new Vector3(length, 0, 0);
			Vector3 xN= new Vector3(-length, 0, 0);
			Vector3 yP = new Vector3(0, length, 0);
			Vector3 yN = new Vector3(0, -length, 0);
			Vector3 zP = new Vector3(0, 0, length);
			Vector3 zN = new Vector3(0, 0, -length);
			player.SendConsoleCommand("ddraw.line", 10f, Color.red, center+xN, center+xP);
			player.SendConsoleCommand("ddraw.line", 10f, Color.blue, center+yN, center+yP);
			player.SendConsoleCommand("ddraw.line", 10f, Color.green, center+zN, center+zP);
		}
		
		// check if player is admin (copied from ZoneManager)
		private static bool isAdmin(BasePlayer player)
		{
			if (player?.net?.connection == null) return true;
			return player.net.connection.authLevel > 0;
        }
        
		// check permissions (copied from ZoneManager)
		private bool hasPermission(BasePlayer player, string permname)
		{
			return isAdmin(player) || permission.UserHasPermission(player.UserIDString, permname);
        }
        
        public void BoxColliders<T>(Vector3 position, Vector3 halfExtents, Quaternion orientation, List<T> list, int layerMask = -1, QueryTriggerInteraction triggerInteraction = QueryTriggerInteraction.Collide)
		where T : Collider
		{
			layerMask = GamePhysics.HandleTerrainCollision(position, layerMask);
			int num = Physics.OverlapBoxNonAlloc(position, halfExtents, colBuffer, orientation, layerMask, triggerInteraction);
			if (num >= (int)colBuffer.Length)
			{
				Debug.LogWarning("Vis query is exceeding collider buffer length.");
			}
			for (int i = 0; i < num; i++)
			{
				T t = (T)(colBuffer[i] as T);
				colBuffer[i] = null;
				if (t != null)
				{
					if (!t.transform.CompareTag("MeshColliderBatch"))
					{
						list.Add(t);
					}
					else
					{
						t.transform.GetComponent<MeshColliderBatch>().LookupColliders<T>(position, 100f, list);
					}
				}
			}
		}
		public void BoxEntities<T>(Vector3 position, Vector3 halfExtents, Quaternion orientation, List<T> list, int layerMask = -1, QueryTriggerInteraction triggerInteraction = QueryTriggerInteraction.Collide)
		where T : BaseEntity
		{
			List<Collider> colliders = Pool.GetList<Collider>();
			BoxColliders<Collider>(position, halfExtents, orientation, colliders, layerMask, triggerInteraction);
			for (int i = 0; i < colliders.Count; i++)
			{
				T baseEntity = (T)(colliders[i].gameObject.ToBaseEntity() as T);
				if (baseEntity != null)
				{
					list.Add(baseEntity);
				}
			}
			Pool.FreeList<Collider>(ref colliders);
    	}
	}
}

// --- End of file: BuildingWrapper.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/InjectionSyringe.cs ---
// --- Original Local Path: InjectionSyringe.cs ---

using UnityEngine;
using Random = UnityEngine.Random;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;

namespace Oxide.Plugins
{
    [Info("InjectionSyringe", "Empty", "2.0.0")]
    public class InjectionSyringe : RustPlugin
    {
        #region НАСТРОЙКИ
        string pic1 = "https://i.imgur.com/vhclJVT.png";//ссылка на картинку шприца
        string pic2 = "https://imgur.com/BbycTX3.png";//ссылка на картинку колбы 1
        string pic3 = "https://imgur.com/e6L6X83.png";//ссылка на картинку колбы 2
        string pic4 = "https://imgur.com/undefined.png";//ссылка на картинку колбы 3
        string pic5 = "https://pic.moscow.ovh/images/2019/10/17/17e60544bac5a6e229887d9a6ac3fedc.png";//ссылка на картинку галочки
        string pic6 = "https://pic.moscow.ovh/images/2019/10/17/b3a73a1d6022495a8206fedf646157eb.png";//ссылка на картинку крестика
        ulong skinid1 = 1720697246;//скин айди шприца
        ulong skinid2 = 1767124720;//скин айди колбы 1
        ulong skinid3 = 1767132350;//скин айди колбы 2
        ulong skinid4 = 1767208385;//скин айди колбы 3

        #endregion
        [PluginReference] private Plugin ImageLibrary;
        void OnServerInitialized()
        {
            ImageLibrary.Call("AddImage", pic1, "shprits");
            ImageLibrary.Call("AddImage", pic2, "kolba1");
            ImageLibrary.Call("AddImage", pic3, "kolba2");
            ImageLibrary.Call("AddImage", pic4, "kolba3");
            ImageLibrary.Call("AddImage", pic5, "krest");
            ImageLibrary.Call("AddImage", pic6, "galka");
            PrintWarning("★★★★★★★ Autor - vk.com/zaharkotov ★★★★★★★");
        }

        #region Core

        object OnHealingItemUse(MedicalTool tool, BasePlayer player)
        {
            if (tool.skinID == 1720697246)
            {
                SendReply(player, "<color=red>Вы использовали инъекционный шприц</color>");
                player.health = 100;
            }
            return null;
        }
        void GiveMedical(BasePlayer player)
        {
            Item medical = ItemManager.CreateByItemID(1079279582, 1, skinid1);
            medical.name = "Инъекционный шприц";
            player.GiveItem(medical, BaseEntity.GiveItemReason.PickedUp);
        }

        [ConsoleCommand("syringe.add")]
        private void CmdHandler(ConsoleSystem.Arg args)
        {

            BasePlayer player = args.Player();
            var check1 = player.inventory.GetAmount(ItemManager.FindItemDefinition("xmas.decoration.gingerbreadmen").itemid);//красный
            var check2 = player.inventory.GetAmount(ItemManager.FindItemDefinition("xmas.decoration.pinecone").itemid);//зеленый
            var check3 = player.inventory.GetAmount(ItemManager.FindItemDefinition("xmas.decoration.baubels").itemid);//желтый

            if (check1 >= 1 && check2 >= 1 && check3 >= 1)
            {
                player.inventory.Take(null, ItemManager.FindItemDefinition("xmas.decoration.gingerbreadmen").itemid, 1);
                player.inventory.Take(null, ItemManager.FindItemDefinition("xmas.decoration.pinecone").itemid, 1);
                player.inventory.Take(null, ItemManager.FindItemDefinition("xmas.decoration.baubels").itemid, 1);

                GiveMedical(player);
            }
            else
            {
                SendReply(player, "Вам не хватает колб");
            }
        }

        
        #endregion

        #region ChatCommand
        [ChatCommand("medical")]
        void DrawUI(BasePlayer player)
        {
            var check1 = player.inventory.GetAmount(ItemManager.FindItemDefinition("xmas.decoration.gingerbreadmen").itemid);//красный
            var check2 = player.inventory.GetAmount(ItemManager.FindItemDefinition("xmas.decoration.pinecone").itemid);//зеленый
            var check3 = player.inventory.GetAmount(ItemManager.FindItemDefinition("xmas.decoration.baubels").itemid);//желтый
            string Layer = "page";
            CuiElementContainer container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0.4", Sprite = "Assets/Content/UI/UI.Background.Tile.psd", Material = "assets/content/ui/uibackgroundblur.mat", FadeIn = 0.20f },
                FadeOut = 0.20f
            }, "Overlay", Layer);// фон    
            container.Add(new CuiElement
            {
                Parent = Layer,
                Components =
                {
                    new CuiRawImageComponent() {  Png = (string) ImageLibrary.Call("GetImage", "krest"), Color = "1 1 1 1", },
                    new CuiRectTransformComponent(){  AnchorMin = "0.9781 0.9611", AnchorMax = "0.9947 0.9907", OffsetMin = "0 0", OffsetMax = "0 0" }
                }
            });//картинка крест на закрытие
            container.Add(new CuiElement
            {
                Parent = Layer,
                Components =
                {
                    new CuiRawImageComponent() {  Png = (string) ImageLibrary.Call("GetImage", "shprits"), Color = "1 1 1 1", },
                    new CuiRectTransformComponent(){  AnchorMin = "0.33 0.50", AnchorMax = "0.4862 0.776854", OffsetMin = "0 0", OffsetMax = "0 0" }
                }
            });//картинка шприца
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.9781 0.9611", AnchorMax = "0.9947 0.9907", OffsetMin = "0 0", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Close = Layer },
                Text = { Text = "", Align = TextAnchor.MiddleCenter, FontSize = 1 }
            }, Layer);//кнопка крест на закрытие
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.25 0.89", AnchorMax = "0.75 0.99", OffsetMin = "0 0", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0" },
                Text = { Text = "КРАФТ ИНЬЕКЦИОННОГО ШПРИЦА", Align = TextAnchor.MiddleCenter, FontSize = 40 }
            }, Layer);//надпись КРАФТ ИНЬЕКЦИОННОГО ШПРИЦА
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.39 0.0731", AnchorMax = "0.61 0.1509", OffsetMin = "0 0", OffsetMax = "0 0" },
                Button = { Color = "1 0 0 1", Command = "syringe.add", Close = Layer },
                Text = { Text = "СКРАФТИТЬ", Align = TextAnchor.MiddleCenter, FontSize = 40 }
            }, Layer);//кнопка скрафтить
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.3 0.8046", AnchorMax = "0.7 0.8787", OffsetMin = "0 0", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0" },
                Text = { Text = "ДЛЯ КРАФТА ИНЬЕКЦИОННОГО ШПРИЦА ТРЕБУЕТСЯ:", Align = TextAnchor.MiddleCenter, FontSize = 20 }
            }, Layer);//надпись ДЛЯ КРАФТА ИНЬЕКЦИОННОГО ШПРИЦА ТРЕБУЕТСЯ:
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.25 0.3509", AnchorMax = "0.75 0.4824", OffsetMin = "0 0", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0", Close = Layer },
                Text = { Text = "Чтобы сделать инъекционный шприц, нужно найти 3 колбы (красную, зеленую и желтую).\nНайти их можно в ящиках с компонентам.\nПолезное свойство шприца: полное восстановление здоровья", Align = TextAnchor.MiddleCenter, FontSize = 15 }
            }, Layer);//текст инфо
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.39 0.2", AnchorMax = "0.61 0.3314808", OffsetMin = "0 0", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0.4", Close = Layer },
                Text = { Text = "", Align = TextAnchor.MiddleCenter, FontSize = 1 }
            }, Layer);//фон под компоненты
            container.Add(new CuiElement
            {
                Parent = Layer,
                Components =
                {
                    new CuiRawImageComponent() {  Png = (string) ImageLibrary.Call("GetImage", "kolba1"), Color = "1 1 1 1", },
                    new CuiRectTransformComponent(){  AnchorMin = "0.3947 0.2055", AnchorMax = "0.4624 0.3259", OffsetMin = "0 0", OffsetMax = "0 0" }
                }
            });//картинка Колбы 1
            container.Add(new CuiElement
            {
                Parent = Layer,
                Components =
                {
                    new CuiRawImageComponent() {  Png = (string) ImageLibrary.Call("GetImage", "kolba2"), Color = "1 1 1 1", },
                    new CuiRectTransformComponent(){  AnchorMin = "0.4661 0.2055", AnchorMax = "0.5338 0.3259", OffsetMin = "0 0", OffsetMax = "0 0" }
                }
            });//картинка Колбы 2
            container.Add(new CuiElement
            {
                Parent = Layer,
                Components =
                {
                    new CuiRawImageComponent() {  Png = (string) ImageLibrary.Call("GetImage", "kolba3"), Color = "1 1 1 1", },
                    new CuiRectTransformComponent(){  AnchorMin = "0.5374 0.2055", AnchorMax = "0.6052 0.3259", OffsetMin = "0 0", OffsetMax = "0 0" }
                }
            });//картинка Колбы 3
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.5269 0.6668", AnchorMax = "0.8132 0.6968", OffsetMin = "0 0", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0" },
                Text = { Text = "1X КРАСНАЯ КОЛБА", Align = TextAnchor.MiddleLeft, FontSize = 19 }
            }, Layer);//Компонент 1
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.5269 0.6268", AnchorMax = "0.8132 0.6568", OffsetMin = "0 0", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0" },
                Text = { Text = "1X ЗЕЛЕНАЯ КОЛБА", Align = TextAnchor.MiddleLeft, FontSize = 19 }
            }, Layer);//Компонент 2
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.5269 0.5868", AnchorMax = "0.8132 0.6168", OffsetMin = "0 0", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0" },
                Text = { Text = "1X ЖЕЛТАЯ КОЛБА", Align = TextAnchor.MiddleLeft, FontSize = 19 }
            }, Layer);//Компонент 3
            #region Проверка на наличие в инвентаре 1
            if (check1 >= 1)
            {
                container.Add(new CuiElement
                {
                    Parent = Layer,
                    Components =
                {
                    new CuiRawImageComponent() {  Png = (string) ImageLibrary.Call("GetImage", "galka"), Color = "1 1 1 1", },
                    new CuiRectTransformComponent(){  AnchorMin = "0.5069 0.6668", AnchorMax = "0.5235 0.6968", OffsetMin = "0 0", OffsetMax = "0 0" }
                }
                });
            }
            else //0.0166
            {
                container.Add(new CuiElement
                {
                    Parent = Layer,
                    Components =
                {
                    new CuiRawImageComponent() {  Png = (string) ImageLibrary.Call("GetImage", "krest"), Color = "1 1 1 1", },
                    new CuiRectTransformComponent(){  AnchorMin = "0.5069 0.6668", AnchorMax = "0.5235 0.6968", OffsetMin = "0 0", OffsetMax = "0 0" }
                }
                });
            }
            #endregion
            #region Проверка на наличие в инвентаре 2
            if (check2 >= 1)
            {
                container.Add(new CuiElement
                {
                    Parent = Layer,
                    Components =
                {
                    new CuiRawImageComponent() {  Png = (string) ImageLibrary.Call("GetImage", "galka"), Color = "1 1 1 1", },
                    new CuiRectTransformComponent(){  AnchorMin = "0.5069 0.6268", AnchorMax = "0.5235 0.6568", OffsetMin = "0 0", OffsetMax = "0 0" }
                }
                });
            }
            else
            {
                container.Add(new CuiElement
                {
                    Parent = Layer,
                    Components =
                {
                    new CuiRawImageComponent() {  Png = (string) ImageLibrary.Call("GetImage", "krest"), Color = "1 1 1 1", },
                    new CuiRectTransformComponent(){  AnchorMin = "0.5069 0.6268", AnchorMax = "0.5235 0.6568", OffsetMin = "0 0", OffsetMax = "0 0" }
                }
                });
            }
            #endregion
            #region Проверка на наличие в инвентаре 3
            if (check3 >= 1)
            {
                container.Add(new CuiElement
                {
                    Parent = Layer,
                    Components =
                {
                    new CuiRawImageComponent() {  Png = (string) ImageLibrary.Call("GetImage", "galka"), Color = "1 1 1 1", },
                    new CuiRectTransformComponent(){  AnchorMin = "0.5069 0.5868", AnchorMax = "0.5235 0.6168", OffsetMin = "0 0", OffsetMax = "0 0" }
                }
                });
            }
            else
            {
                container.Add(new CuiElement
                {
                    Parent = Layer,
                    Components =
                {
                    new CuiRawImageComponent() {  Png = (string) ImageLibrary.Call("GetImage", "krest"), Color = "1 1 1 1", },
                    new CuiRectTransformComponent(){  AnchorMin = "0.5069 0.5868", AnchorMax = "0.5235 0.6168", OffsetMin = "0 0", OffsetMax = "0 0" }
                }
                });
            }
            #endregion
            CuiHelper.AddUi(player, container);
        }
        [ChatCommand("medicaladmin")]
        void AdminGive(BasePlayer player)
        {
            if (!player.IsAdmin)
            {
                return;
            }
            Item colb1 = ItemManager.CreateByItemID(-1667224349, 1, skinid2);
            colb1.name = "Красная колба";
            player.GiveItem(colb1, BaseEntity.GiveItemReason.PickedUp);
            Item colb2 = ItemManager.CreateByItemID(1686524871, 1, skinid3);
            colb2.name = "Зеленая колба";
            player.GiveItem(colb2, BaseEntity.GiveItemReason.PickedUp);
            Item colb3 = ItemManager.CreateByItemID(-129230242, 1, skinid4);
            colb3.name = "Желтая колба";
            player.GiveItem(colb3, BaseEntity.GiveItemReason.PickedUp);

        }
        #endregion
    }
        

}

// --- End of file: InjectionSyringe.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/ServerStats.cs ---
// --- Original Local Path: ServerStats.cs ---


using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

using Facepunch;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Rust;

using UnityEngine;
using WebSocketSharp;
using Random = UnityEngine.Random;

namespace Oxide.Plugins
{
    [Info("ServerStats", "TheRyuzaki & skyplugins.ru", "1.0.6")]
    public class ServerStats : CovalencePlugin
    {
        private static ServerStats _instance;
        private WSH _wsh;
        private FPSVisor ActiveVisor;

        public class WSH
        {
            public WebSocket client;
            public bool hasUnloaded = false;
            public bool networkStatus = false;
            public List<string> pool = new List<string>();
            public Coroutine coroutine;
            public WSH(string WS)
            {
                client = new WebSocket(WS);
                client.SslConfiguration.EnabledSslProtocols = System.Security.Authentication.SslProtocols.Tls12;

                client.OnMessage += OnSocketMessage;
                client.OnOpen += OnSocketConnected;
                client.OnClose += OnSocketDisconnected;
            }

            public void connect()
            {
                if (!this.hasUnloaded)
                {
                    _instance.PrintWarning("[WS] Trying to establish a connection to server...");
                    try
                    {
                        client.ConnectAsync();
                    }
                    catch (Exception ex)
                    {

                    }
                }
            }
            public void close()
            {
                this.hasUnloaded = true;
                client.CloseAsync();
            }
            public bool send(Dictionary<string, object> packet, bool networkIgnore = false)
            {
                return this.send(JsonConvert.SerializeObject(packet, Formatting.None), networkIgnore);
            }

            public bool send(string packet, bool networkIgnore = false)
            {
                if (this.networkStatus || networkIgnore)
                {
#if DEBUG
                    _instance.PrintWarning($"[DEBUG][WS][<-----]: {packet}");
#endif
                    client.SendAsync(packet, new Action<bool>((completed) =>
                    {
                        if (!completed)
                        {
                            _instance.PrintWarning($"[WS] Something went wrong! The message was not sent and was added to the pool!");
                            pool.Add(packet);
                        }
                    }));

                    return true;
                }

                _instance.PrintWarning($"[WS] Send error! We are not connected! The message has been added to the pool and will be sent later!");
                pool.Add(packet);

                return false;
            }

            private void OnSocketConnected(object sender, EventArgs e)
            {
                _instance.PrintWarning("[WS] Socket Connected!");
                this.networkStatus = true;

                NetworkWelcomePacket packet = Pool.Get<NetworkWelcomePacket>();        

                this.client.SendAsync(JsonConvert.SerializeObject(packet), (res) => { });

                Pool.Free(ref packet);
                if (pool.Count > 0)
                {
                    foreach (string packets in pool)
                        this.send(packets, true);

                    pool.Clear();
                }

                this.coroutine = Global.Runner.StartCoroutine(this.Sender());
            }

            private void OnSocketMessage(object sender, MessageEventArgs e)
            {
#if DEBUG
                _instance.PrintWarning($"[DEBUG][WS][----->]: {e.Data}");
#endif
                _instance.NextFrame(() =>
                {
                    try
                    {

                    }
                    catch (Exception ex)
                    {
                        _instance.PrintError($"Exception from OnSocketMessage: {ex}");
                    }
                });
            }

            private void OnSocketDisconnected(object sender, CloseEventArgs e)
            {
                if (e == null || string.IsNullOrEmpty(e.Reason))
                    _instance.PrintWarning("[WS] Socket Disconnected.");
                else
                    _instance.PrintError($"[WS] Socket Disconnected: {e.Reason}");

                this.networkStatus = false;

                if (this.coroutine != null)
                    Global.Runner.StopCoroutine(this.coroutine);

                if (!this.hasUnloaded)
                {
                    _instance.timer.Once(10, this.connect);
                }
            }
            private IEnumerator Sender()
            {
                yield return CoroutineEx.waitForSeconds(1f);

                while (true)
                {
                    _instance.QueueWorkerThread(_ =>
                    {
                        NetworkTickPacket packet = Pool.Get<NetworkTickPacket>();

                        var listPlugins = _instance.plugins.PluginManager.GetPlugins().ToArray();

                        for (var i = 0; i < listPlugins.Length; i++)
                        {
                            packet.ListPlugins.Add(new NetworkTickPacket.PluginItem
                            {
                                Name = listPlugins[i].Name,
                                Version = listPlugins[i].Version.ToString(),
                                Author = listPlugins[i].Author,
                                Hash = listPlugins[i].Name.GetHashCode(),
                                Time = listPlugins[i].TotalHookTime
                            });
                        }


                        client.SendAsync(JsonConvert.SerializeObject(packet), (res) => { });
                        Pool.Free(ref packet);
                    });
                    yield return CoroutineEx.waitForSeconds(1f);
                }
            }

        }


        private void Init()
        {
            _instance = this;
            _wsh = new WSH("wss://s1.server-stats.skyplugins.ru:5191/");

            Unsubscribe("OnPlayerConnected");
            Unsubscribe("OnPlayerDisconnected");
            Unsubscribe("OnPluginLoaded");
            Unsubscribe("OnPluginUnloaded");
        }

        private void OnServerInitialized()
        {
            _wsh.connect();
            this.ActiveVisor = Terrain.activeTerrain.gameObject.AddComponent<FPSVisor>();
        }

        private void Unload()
        {
            _wsh.close();
        }























































        private int MinimalFPS = 9999;

        protected override void LoadDefaultConfig()
        {
            this.Config["Password"] = Random.Range(1000, 999999);
            this.LogWarning("Config file ServerStats.json is not found, you new password: " + this.Config["Password"]);
            this.Config.Save();
        }

        public class FPSVisor : MonoBehaviour
        {
            private void Update()
            {
                if (_instance.MinimalFPS > (int)global::Performance.current.frameRate)
                    _instance.MinimalFPS = (int)global::Performance.current.frameRate;
            }
        }


        public class NetworkWelcomePacket : Pool.IPooled
        {

            [JsonProperty("method")]
            public string Method { get; } = "reg_server";

            [JsonProperty("ServerIp")]
            public string ServerIp { get; } = _instance.server.Address + ":" + _instance.server.Port;
            [JsonProperty("serverName")]
            public string ServerName { get; } = _instance.server.Name;
            [JsonProperty("password")]
            public string Password => _instance.Config["Password"].ToString();

            public void EnterPool()
            {

            }

            public void LeavePool()
            {

            }
        }


        public class NetworkTickPacket: Pool.IPooled
        {
            [JsonProperty("method")]
            public string Method { get; } = "tick_server";
            [JsonProperty("listPlugins")]
            public List<PluginItem> ListPlugins { get; } = Pool.GetList<PluginItem>();

            [JsonProperty("minfps")]
            public int MinimalFps
            {
                get
                {
                    int currentValue = _instance.MinimalFPS;
                    _instance.MinimalFPS = 9999;
                    return currentValue;
                }
            }
            [JsonProperty("fps")]
            public int Fps => Performance.current.frameRate;

            [JsonProperty("ent")]
            public int Ent => BaseNetworkable.serverEntities.Count;
            [JsonProperty("online")]
            public int Online => _instance.players.Connected.Count();
            [JsonProperty("SleepPlayer")]
            public int SleepPlayer => BasePlayer.sleepingPlayerList.Count;
            [JsonProperty("JoiningPlayer")]
            public int JoiningPlayer => ServerMgr.Instance.connectionQueue.Joining;
            [JsonProperty("QueuedPlayer")]
            public int QueuedPlayer => ServerMgr.Instance.connectionQueue.Queued;

            public void EnterPool()
            {
                this.ListPlugins.Clear();
            }

            public void LeavePool()
            {

            }

            public struct PluginItem
            {
                [JsonProperty("name")]
                public string Name
                {
                    get; set;
                }
                [JsonProperty("author")]
                public string Author
                {
                    get; set;
                }
                [JsonProperty("version")]
                public string Version
                {
                    get; set;
                }
                [JsonProperty("hash")]
                public int Hash
                {
                    get; set;
                }
                [JsonProperty("time")]
                public double Time
                {
                    get; set;
                }
            }
        }
    }
}

// --- End of file: ServerStats.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/NPCVendingManager.cs ---
// --- Original Local Path: NPCVendingManager.cs ---

﻿using System;
using System.Collections.Generic;
using Oxide.Core;
using UnityEngine;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System.Collections;
using System.Drawing;
using System.IO;
using System.Drawing.Imaging;
using Newtonsoft.Json.Converters;
using Facepunch;
using VLB;

using System.Linq;
using System.Text;
using System.Threading.Tasks;


namespace Oxide.Plugins
{
    [Info("NPCVendingManager", "EcoSmile", "1.0.0")]
    class NPCVendingManager : RustPlugin
    {
        static NPCVendingManager ins;
        PluginConfig config;

        public class PluginConfig
        {
            [JsonProperty("Настройка торговых автоматов")]
            public Dictionary<string, List<VendingOrder>> Vending { get; set; }
        }

        public class VendingOrder
        {
            [JsonProperty("Добавить товар?")]
            public bool AddItem;
            [JsonProperty("Название покупаемого товара")]
            public string ItemToBuy { get; set; }
            [JsonProperty("Максимальный стак покупаемого предмета за один раз")] 
            public int BuyngItemMaxAmount { get; set; }
            [JsonProperty("SKINID покупаемого предмета")]
            public ulong BuyngItemSkinID { get; set; }
            [JsonProperty("Количество покупаемого товара за раз")]
            public int BuyngItemAmount { get; set; }
            [JsonProperty("Покупаемый товар это чертёж")]
            public bool BuyngItemIsBP { get; set; }
            [JsonProperty("Название платёжного товара")]
            public string PayItemShortName { get; set; }
            [JsonProperty("Количество платёжного товара за раз")]
            public int PayItemAmount { get; set; }
            [JsonProperty("Платёжный товар это чертёж")]
            public bool PayItemIsBP { get; set; }
        } 

        protected override void LoadDefaultConfig()
        { 
            config = new PluginConfig
            {
                Vending = GetVendingList(),
            };
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
            if (config.Vending.Count == 0)
            {
                LoadDefaultConfig();
                SaveConfig();
            } 
        }

        protected override void SaveConfig()
        { 
            Config.WriteObject(config);
        }

        private void OnServerInitialized()
        {
            ins = this;
            LoadConfig();
            VendingInit();
        }

        void Unload()
        {

        } 

        public Dictionary<string, List<VendingOrder>> GetVendingList()
        {
            Dictionary<string, List<VendingOrder>> vendings = new Dictionary<string, List<VendingOrder>>();
            var vendingList = BaseNetworkable.serverEntities.OfType<NPCVendingMachine>().Where(x => x != null && x.OwnerID == 0).ToList();
            foreach (var vending in vendingList)
            {
                if (vendings.ContainsKey(vending.shopName)) continue;
                vendings.Add(vending.shopName, new List<VendingOrder>());
                vendings[vending.shopName].Add(new VendingOrder() { AddItem = false, ItemToBuy = "", BuyngItemMaxAmount = 10, BuyngItemAmount = 0, BuyngItemSkinID = 0, BuyngItemIsBP = false, PayItemShortName = "", PayItemAmount = 0, PayItemIsBP = false });

            }

            return vendings;
        }

        void VendingInit()
        {
            var vendingList = BaseNetworkable.serverEntities.OfType<NPCVendingMachine>().Where(x => x != null && x.OwnerID == 0).ToList();

            foreach (var vending in vendingList)
            {
                if (config.Vending.ContainsKey(vending.shopName))
                {
                    vending.CancelInvoke(vending.InstallFromVendingOrders);
                    vending.InstallFromVendingOrders();
                    foreach (var item in config.Vending[vending.shopName])
                    {
                        if (!item.AddItem) continue;
                        ItemDefinition itemDefinition = ItemManager.FindItemDefinition(item.ItemToBuy);
                        if(itemDefinition == null)
                        {
                            PrintError($"ItemDefinition from BuyItem ShortName {item.ItemToBuy} not found.");
                            continue;
                        }
                        ItemDefinition x = ItemManager.FindItemDefinition(item.PayItemShortName);
                        if(x==null)
                        {
                            PrintError($"ItemDefinition from PayItem ShortName {item.PayItemAmount} not found.");
                            continue;
                        }
                        AddItemForSale(vending, itemDefinition.itemid, item.BuyngItemAmount, x.itemid, item.PayItemAmount, vending.GetBPState(item.BuyngItemIsBP, item.PayItemIsBP), item.BuyngItemMaxAmount, item.BuyngItemSkinID);
                    }
                }
            }
        }
        
        public void AddItemForSale(VendingMachine vending, int itemID, int amountToSell, int currencyID, int currencyPerTransaction, byte bpState, int maxByStack, ulong SkinID)
        {
            vending.AddSellOrder(itemID, amountToSell, currencyID, currencyPerTransaction, bpState);
            vending.transactionActive = true;
            if (bpState == 1 || bpState == 3)
            {
                for (int i = 0; i < maxByStack; i++)
                {
                    global::Item item = ItemManager.CreateByItemID(vending.blueprintBaseDef.itemid, 1, 0UL);
                    item.blueprintTarget = itemID;
                    vending.inventory.Insert(item);
                }
            }
            else
            {   
                vending.inventory.AddItem(ItemManager.FindItemDefinition(itemID), amountToSell * maxByStack, SkinID);
            }
            vending.transactionActive = false;
            vending.RefreshSellOrderStockLevel(null);
        }
    }  
} 


// --- End of file: NPCVendingManager.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/MiningBow.cs ---
// --- Original Local Path: MiningBow.cs ---

using System;
using System.Collections.Generic;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("MiningBow", "Sempai#3239", "1.0.1")]
    public class MiningBow : RustPlugin
    {
        #region Config

        private PluginConfig cfg;

        public class PluginConfig
        {
            [JsonProperty("Настройки лука")]
            public bowsettings Bow = new bowsettings();
            [JsonProperty("Настройки дропа с лука")]
            public drop Drop = new drop();
        }

        public class bowdrop
        {
            [JsonProperty("Включить спавн лука в ящиках?")]
            public bool enabledropfromcrates = true;
            [JsonProperty("Shortprefabname ящика, шанс спавна")]
            public Dictionary<string, float> drop = new Dictionary<string, float>
            {
                ["crate_normal"] = 100f,
                ["crate_normal_2"] = 100f,
                ["crate_elite"] = 100f,
                ["crate_basic"] = 100f,
                ["crate_tools"] = 100f,
            };
        }

        public class bowsettings
        {
            [JsonProperty("SkinID лука")]
            public ulong skinid = 1731189052;
            [JsonProperty("Название лука")]
            public string name = "Mining Bow";
            [JsonProperty("Настройки спавна лука")]
            public bowdrop drop = new bowdrop();
        }

        public class drop
        {
            [JsonProperty("Shortprefabname предмета на который будет действовать лук")]
            public Dictionary<string, List<dropsettings>> bowdrop = new Dictionary<string, List<dropsettings>>
            {
                ["sulfur-ore"] = new List<dropsettings> { new dropsettings { shortname = "sulfur", skinid = 0, minamount = 50, maxamount = 100 }, new dropsettings { shortname = "stones", skinid = 0, minamount = 10, maxamount = 50 }, },
                ["metal-ore"] = new List<dropsettings> { new dropsettings { shortname = "metal.fragments", skinid = 0, minamount = 300, maxamount = 300 }, new dropsettings { shortname = "stones", skinid = 0, minamount = 10, maxamount = 50 }, },
                ["loot-barrel-1"] = new List<dropsettings> { new dropsettings { shortname = "scrap", skinid = 0, minamount = 50, maxamount = 100 }, new dropsettings { shortname = "hq.metal.ore", skinid = 0, minamount = 5, maxamount = 10 }, },
            };
        }

        public class dropsettings
        {
            [JsonProperty("Shortname создаваемого предмета после разрушения обьекта")]
            public string shortname;
            [JsonProperty("SkinID создаваемого предмета после разрушения обьекта")]
            public ulong skinid;
            [JsonProperty("Минимальное количество предмета для создания")]
            public int minamount;
            [JsonProperty("Максимальное количество предмета для создания")]
            public int maxamount;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                cfg = Config.ReadObject<PluginConfig>();
                if (cfg == null) throw new Exception();
            }
            catch
            {
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig() => cfg = new PluginConfig();

        protected override void SaveConfig() => Config.WriteObject(cfg);

        #endregion

        #region Hooks

        void OnLootSpawn(LootContainer container)
        {
            if (container == null || container.inventory == null) return;
            NextTick(() =>
            {
                if (container.ShortPrefabName == "stocking_large_deployed" ||
                container.ShortPrefabName == "stocking_small_deployed") return;
                if (!cfg.Bow.drop.enabledropfromcrates) return;
                foreach (var c in cfg.Bow.drop.drop)
                {
                    if (c.Key.Contains(container.ShortPrefabName))
                    {
                        if (UnityEngine.Random.Range(0f, 100f) < c.Value)
                        {
                            if (container.inventory.itemList.Count == container.inventory.capacity) container.inventory.capacity++;

                            Item x = ItemManager.CreateByName("bow.hunting", 1, cfg.Bow.skinid);
                            if (x == null) return;
                            x.name = cfg.Bow.name;
                            x.MoveToContainer(container.inventory);
                        }
                    }
                }
            });
        }

        void OnPlayerAttack(BasePlayer attacker, HitInfo info)
        {
            if (attacker == null || info == null || info.Initiator == null || info.InitiatorPlayer == null
                || info.InitiatorPlayer.IsNpc || info.Weapon == null) return;

            var entity = info.HitEntity;
            if (entity == null || info.Weapon.skinID != cfg.Bow.skinid) return;

            foreach (var item in cfg.Drop.bowdrop)
            {
                if (item.Key.Contains(entity.ShortPrefabName))
                {
                    NextTick(() =>
                    {
                        if (entity.IsDestroyed) return;
                        entity.Kill();
                    });
                    foreach (var drop in item.Value)
                    {
                        if (drop == null) return;
                        var random = UnityEngine.Random.Range(drop.minamount, drop.maxamount);
                        Item x = ItemManager.CreateByName(drop.shortname, random, drop.skinid);
                        if (x == null) return;
                        info.InitiatorPlayer.GiveItem(x);
                    }
                }
            }
        }

        #endregion

        #region Commands

        [ConsoleCommand("GiveMiningBow")]
        private void GiveMiningBow(ConsoleSystem.Arg arg)
        {
            var connection = arg.Connection;
            if (connection != null) return;
            if (!arg.HasArgs(1))
            {
                Puts(" [MiningBow callback] Command syntax error: GiveMiningBow SteamID");
                return;
            }
            else
            {
                var target = BasePlayer.FindByID(ulong.Parse(arg.Args[0]));
                if (target == null || ulong.Parse(arg.Args[0]) == 0)
                {
                    Puts(" [MiningBow callback] Player not found");
                    return;
                }
                Item x = ItemManager.CreateByName("bow.hunting", 1, cfg.Bow.skinid);
                if (x == null) return;
                x.name = cfg.Bow.name;
                target.GiveItem(x);
                Puts($" [MiningBow callback] Successful give 1x MiningBow to {target.displayName}/{target.UserIDString}");
            }
        }

        #endregion
    }
}

// --- End of file: MiningBow.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/IQSystemFragments.cs ---
// --- Original Local Path: IQSystemFragments.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Newtonsoft.Json;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("IQSystemFragments", "xуй", "0.0.4")]
    [Description("Система фрагментов")]
    class IQSystemFragments : RustPlugin
    {
        #region Vars
        public string ReplaceShortname = "skull.human";
        public string ReplaceShortnameFull = "skull.wolf";
        public enum TypeReward
        {
            Command,
            ItemList,
            IQEconomic,
            CommandList,
        }
        public enum TypeItem
        {
            Fragment,
            Full

        }
        #endregion

        #region Reference
        [PluginReference] Plugin IQChat, IQEconomic;
        public void SetBalance(ulong userID, int Balance) => IQEconomic?.Call("API_SET_BALANCE", userID, Balance);
        public void SendChat(BasePlayer player, string Message, Chat.ChatChannel channel = Chat.ChatChannel.Global)
        {
            var Chat = config.GeneralSetting.ChatSetting;
            if (IQChat)
                IQChat?.Call("API_ALERT_PLAYER", player, Message, Chat.CustomPrefix, Chat.CustomAvatar);
            else player.SendConsoleCommand("chat.add", channel, 0, Message);
        }
        #endregion

        #region Configuration

        private static Configuration config = new Configuration();
        private class Configuration
        {
            [JsonProperty("Настройка плагина")]
            public GeneralSettings GeneralSetting = new GeneralSettings();
            [JsonProperty("Настройка системы фрагментов")]
            public Dictionary<string, ItemSettings> ItemSetting = new Dictionary<string, ItemSettings>();

            internal class GeneralSettings
            {
                [JsonProperty("Настройки IQChat")]
                public ChatSettings ChatSetting = new ChatSettings();
                [JsonProperty("Настройки IQPlagueSkill")]
                public IQPlagueSkills IQPlagueSkill = new IQPlagueSkills();

                internal class ChatSettings
                {
                    [JsonProperty("IQChat : Кастомный префикс в чате")]
                    public string CustomPrefix;
                    [JsonProperty("IQChat : Кастомный аватар в чате(Если требуется)")]
                    public string CustomAvatar;
                }
                internal class IQPlagueSkills
                {
                    [JsonProperty("На сколько увеличить шанс выпадения фрагментов")]
                    public int RareUpFragments;
                    [JsonProperty("На сколько увеличить шанс выпадения полных частей")]
                    public int RareUpFull;
                }
            }

            internal class ItemSettings
            {
                [JsonProperty("Отображаемое имя привилегии")]
                public string DisplayName;
                [JsonProperty("Сколько требуется фрагментов на получение награды")]
                public int AmountFragmets;
                [JsonProperty("SkinID для полного комлпекта")]
                public ulong SkinID;
                [JsonProperty("Настройка фрагментов")]
                public FragmentSettings FragmentSetting = new FragmentSettings();
                [JsonProperty("Настройка награды")]
                public RewardSettings RewardSetting = new RewardSettings();
                [JsonProperty("Настройка выпадения целого фрагмента.[откуда] = шанс")]
                public Dictionary<string, int> DropListRareFull = new Dictionary<string, int>();
                internal class FragmentSettings
                {
                    [JsonProperty("Отображаемое имя фрагмента")]
                    public string DisplayName;
                    [JsonProperty("SkinID фрагмента")]
                    public ulong SkinID;
                    [JsonProperty("Настройка выпадения.[откуда] = шанс")]
                    public Dictionary<string, int> DropListRare = new Dictionary<string, int>();
                }
                internal class RewardSettings
                {
                    [JsonProperty("ТИП ПРИЗА : 0 - Команда  , 1 - Лист предметов, 2 - IQEconomic монеты, 3 - Список команд")]
                    public TypeReward typeReward;
                    [JsonProperty("Команда,которая отыграется,когда игрок заберет приз(ТИП ПРИЗА - 0) %USERID% - заменится на ID игрока")]
                    public string Command;
                    [JsonProperty("Список команд,которые отыграются,когда игрок заберет приз(ТИП ПРИЗА - 3) %USERID% - заменится на ID игрока")]
                    public List<string> CommandList;
                    [JsonProperty("Количество выдаваемых монет(ТИП ПРИЗА - 2)")]
                    public int Balance;
                    [JsonProperty("Настройка предметов из RUST'a(ТИП ПРИЗА - 1)")]
                    public List<ItemRewardSettings> ItemRewardSetting = new List<ItemRewardSettings>();

                    internal class ItemRewardSettings
                    {
                        [JsonProperty("Отображаемое имя(если это не кастомный предмет,оставьте пустым)")]
                        public string DisplayName;
                        [JsonProperty("Shortname предмета")]
                        public string Shortname;
                        [JsonProperty("SkinID предмета")]
                        public ulong SkinID;
                        [JsonProperty("Количество для выдачи")]
                        public int Amount;
                    }
                }
            }

            public static Configuration GetNewConfiguration()
            {
                return new Configuration
                {
                    GeneralSetting = new GeneralSettings
                    {
                        ChatSetting = new GeneralSettings.ChatSettings
                        {
                            CustomAvatar = "",
                            CustomPrefix = "[IQSystemFragments]",
                        },
                    },
                    ItemSetting = new Dictionary<string, ItemSettings>
                    {
                        ["vip"] = new ItemSettings
                        {
                            DisplayName = "ПРИВИЛЕГИЯ VIP",
                            AmountFragmets = 10,
                            SkinID = 2101501999,
                            FragmentSetting = new ItemSettings.FragmentSettings
                            {
                                DisplayName = "Фрагмент VIP",
                                SkinID = 2101501999,
                                DropListRare = new Dictionary<string, int>
                                {
                                    ["crate_normal"] = 50,
                                    ["crate_elite"] = 90,
                                }
                            },
                            DropListRareFull = new Dictionary<string, int>
                            {
                                ["crate_normal"] = 50,
                                ["crate_elite"] = 90,
                            },
                            RewardSetting = new ItemSettings.RewardSettings
                            {
                                typeReward = TypeReward.Command,
                                Command = "say GIVE VIP DURAKU",
                                CommandList = new List<string> { },
                                Balance = 0,
                                ItemRewardSetting = new List<ItemSettings.RewardSettings.ItemRewardSettings> { }
                            }
                        },
                        ["vipPrem"] = new ItemSettings
                        {
                            DisplayName = "НАБОР ПРИВИЛЕГИЙ",
                            AmountFragmets = 10,
                            SkinID = 2101501014,
                            FragmentSetting = new ItemSettings.FragmentSettings
                            {
                                DisplayName = "НАБОР ПРИВИЛЕГИЙ",
                                SkinID = 2101056280,
                                DropListRare = new Dictionary<string, int>
                                {
                                    ["crate_normal"] = 50,
                                    ["crate_elite"] = 90,
                                }
                            },
                            DropListRareFull = new Dictionary<string, int>
                            {
                                ["crate_normal"] = 50,
                                ["crate_elite"] = 90,
                            },
                            RewardSetting = new ItemSettings.RewardSettings
                            {
                                typeReward = TypeReward.CommandList,
                                Command = "",
                                CommandList = new List<string>
                                {
                                    "say 1",
                                    "say 2",
                                    "say 3",
                                },
                                Balance = 0,
                                ItemRewardSetting = new List<ItemSettings.RewardSettings.ItemRewardSettings> { }
                            }
                        },
                        ["recycle"] = new ItemSettings
                        {
                            DisplayName = "ПЕРЕРАБОТЧИК",
                            AmountFragmets = 20,
                            SkinID = 2101500645,
                            FragmentSetting = new ItemSettings.FragmentSettings
                            {
                                DisplayName = "Фрагмент ПЕРЕРАБОТЧИКА",
                                SkinID = 2101057099,
                                DropListRare = new Dictionary<string, int>
                                {
                                    ["crate_normal"] = 50,
                                    ["crate_elite"] = 90,
                                }
                            },
                            DropListRareFull = new Dictionary<string, int>
                            {
                                ["crate_normal"] = 50,
                                ["crate_elite"] = 90,
                            },
                            RewardSetting = new ItemSettings.RewardSettings
                            {
                                typeReward = TypeReward.Command,
                                Command = "say %STEAMID% give ПЕРЕРАБОТЧИК",
                                Balance = 0,
                                CommandList = new List<string> { },
                                ItemRewardSetting = new List<ItemSettings.RewardSettings.ItemRewardSettings> { }
                            }
                        },
                        ["weapons"] = new ItemSettings
                        {
                            DisplayName = "Оружейник",
                            AmountFragmets = 30,
                            SkinID = 2101500148,
                            FragmentSetting = new ItemSettings.FragmentSettings
                            {
                                DisplayName = "Фрагмент Оружейника",
                                SkinID = 2101057796,
                                DropListRare = new Dictionary<string, int>
                                {
                                    ["crate_normal"] = 50,
                                    ["crate_elite"] = 90,
                                }
                            },
                            DropListRareFull = new Dictionary<string, int>
                            {
                                ["crate_normal"] = 50,
                                ["crate_elite"] = 90,
                            },
                            RewardSetting = new ItemSettings.RewardSettings
                            {
                                typeReward = TypeReward.ItemList,
                                Command = "",
                                CommandList = new List<string> { },
                                Balance = 0,
                                ItemRewardSetting = new List<ItemSettings.RewardSettings.ItemRewardSettings>
                                {
                                   new ItemSettings.RewardSettings.ItemRewardSettings
                                   {
                                       DisplayName = "",
                                       Shortname = "rifle.ak",
                                       SkinID = 0,
                                       Amount = 1
                                   },
                                   new ItemSettings.RewardSettings.ItemRewardSettings
                                   {
                                       DisplayName = "",
                                       Shortname = "scrap",
                                       SkinID = 0,
                                       Amount = 1000
                                   },
                                }
                            }
                        },
                    }
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning("Ошибка " + $"чтения конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!!");
                LoadDefaultConfig();
            }
            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewConfiguration();
        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion

        #region Data
        [JsonProperty("Фрагменты игроков")] public Dictionary<ulong, Dictionary<string, int>> DataFragments = new Dictionary<ulong, Dictionary<string, int>>();
        void ReadData() => DataFragments = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, Dictionary<string, int>>>("IQSystemFragments/DataFragments");
        void WriteData() => timer.Every(200f, () => { Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQSystemFragments/DataFragments", DataFragments); });
        void RegisteredDataUser(ulong userID)
        {
            if (!DataFragments.ContainsKey(userID))
                DataFragments.Add(userID, new Dictionary<string, int> { });
        }
        void SendData(ulong userID, string Key, int Amount)
        {
            var Fragment = config.ItemSetting[Key];
            if (DataFragments[userID].ContainsKey(Key))
                DataFragments[userID][Key] += Amount;
            else DataFragments[userID].Add(Key, Amount);

            BasePlayer player = BasePlayer.FindByID(userID);
            if (player == null) return;
            SendChat(player, String.Format(lang.GetMessage("NEW_FRAGMENT_USE", this, userID.ToString()), Fragment.DisplayName, (Fragment.AmountFragmets - DataFragments[userID][Key])));
            if (DataFragments[userID][Key] >= Fragment.AmountFragmets)
                FragmentGoToFull(player, Key);
        }
        #endregion

        #region Hooks
        void OnEntitySpawned(BaseNetworkable entity)
        {
            System.Random rnd = new System.Random();
            var values = Enum.GetValues(typeof(TypeItem));
            var myEnumRandom = (TypeItem)values.GetValue(rnd.Next(values.Length));
            SpawnMetods(myEnumRandom, entity);
        }
        object OnItemAction(Item item, string action, BasePlayer player)
        {
            if (item == null || action == null || action != "crush")
                return null;
            if (player == null)
                return null;

            if (item.info.shortname == ReplaceShortname)
            {
                var Fragment = config.ItemSetting.FirstOrDefault(x => x.Value.FragmentSetting.SkinID == item.skin);
                if (Fragment.Value == null)
                {
                    PrintError("Сообщите разработчику");
                    return false;
                }
                SendData(player.userID, Fragment.Key, 1);
            }
            else if (item.info.shortname == ReplaceShortnameFull)
            {
                var Fragment = config.ItemSetting.FirstOrDefault(x => x.Value.SkinID == item.skin);
                if(Fragment.Value == null)
                {
                    PrintError("Сообщите разработчику");
                    return false;
                }
                UnwrapFragmentFull(player, Fragment.Key);
            }
            NextTick(() => { player.inventory.Take(null, ItemManager.FindItemDefinition("bone.fragments").itemid, 20); });
            ItemRemovalThink(item, player, 1);

            return false;
        }
        private static void ItemRemovalThink(Item item, BasePlayer player, int itemsToTake)
        {
            if (item.amount == itemsToTake)
            {
                item.RemoveFromContainer();
                item.Remove();
            }
            else
            {
                item.amount = item.amount - itemsToTake;
                player.inventory.SendSnapshot();
            }
        }
        private void OnServerInitialized()
        {
            ReadData();
            foreach (var p in BasePlayer.activePlayerList)
                OnPlayerConnected(p);
            WriteData();
        }
        void OnPlayerConnected(BasePlayer player) => RegisteredDataUser(player.userID);
        #endregion

        #region Commands

        [ConsoleCommand("iqsf")]
        void ConsoleCommandIQSF(ConsoleSystem.Arg arg)
        {
            if (arg.Args == null || arg.Args.Length == 0)
            {
                PrintWarning("Ошибка синтаксиса#439");
                PrintToConsole("Ошибка синтаксиса");
                return;
            }
            if (String.IsNullOrEmpty(arg.Args[0]) || arg.Args[0] == null || arg.Args[0].Length == 0)
            {
                PrintWarning("Ошибка синтаксиса.Используйте - iqsf give STEAMID fragments/complete KEY");
                return;
            }
            switch (arg.Args[0].ToLower())
            {
                case "give":
                    {
                        ulong SteamID = ulong.Parse(arg.Args[1]);
                        string CaseKey = arg.Args[2];
                        string Key = arg.Args[3];
                        int Amount = Convert.ToInt32(arg.Args[4]);
                        switch (CaseKey)
                        {
                            case "fragments":
                                {
                                    BasePlayer player = BasePlayer.FindByID(SteamID);
                                    if (player == null)
                                    {
                                        PrintWarning("Игрок не в сети!");
                                        return;
                                    }
                                    var Fragment = config.ItemSetting[Key];
                                    var Fragments = (Item)CreateFragment(Fragment.FragmentSetting.DisplayName, Fragment.FragmentSetting.SkinID, ReplaceShortname, Amount);
                                    player.GiveItem(Fragments);

                                    break;
                                }
                            case "complete":
                                {
                                    BasePlayer player = BasePlayer.FindByID(SteamID);
                                    if (player == null)
                                    {
                                        PrintWarning("Игрок не в сети!");
                                        return;
                                    }
                                    var Fragment = config.ItemSetting[Key];
                                    var FragmentsFull = (Item)CreateFragment(Fragment.DisplayName, Fragment.SkinID, ReplaceShortnameFull, Amount);
                                    player.GiveItem(FragmentsFull);
                                    break;
                                }
                        }
                        break;
                    }
                case "debug":
                    {
                        BasePlayer player = arg.Player();
                        if (player == null)
                        {
                            PrintWarning("Данную команду нужно прописывать в игровой консоли");
                            return;
                        }
                        foreach (var Fragment in config.ItemSetting)
                        {
                            var Fragments = (Item)CreateFragment(Fragment.Value.FragmentSetting.DisplayName, Fragment.Value.FragmentSetting.SkinID, ReplaceShortname, 10);
                            player.GiveItem(Fragments);
                            var FragmentsFull = (Item)CreateFragment(Fragment.Value.DisplayName, Fragment.Value.SkinID, ReplaceShortnameFull, 1);
                            player.GiveItem(FragmentsFull);
                        }
                        break;
                    }
            }
        }

        #endregion

        #region Metods
        void SpawnMetods(TypeItem Types, BaseNetworkable entity)
        {
            int RandomIndex = UnityEngine.Random.Range(0, config.ItemSetting.Count);
            var RandomElement = config.ItemSetting.ElementAt(RandomIndex).Value;
            var DropList = Types == TypeItem.Fragment ? RandomElement.FragmentSetting.DropListRare : RandomElement.DropListRareFull;
            if (DropList == null) return;
            if (!DropList.ContainsKey(entity.ShortPrefabName)) return;
            if (!IsRandom(DropList[entity.ShortPrefabName])) return;

            var Item = Types == TypeItem.Fragment ? (Item)CreateFragment(RandomElement.FragmentSetting.DisplayName, RandomElement.FragmentSetting.SkinID, ReplaceShortname, 1)
                                                  : (Item)CreateFragment(RandomElement.DisplayName, RandomElement.SkinID, ReplaceShortnameFull, 1);
            Item?.MoveToContainer(entity.GetComponent<LootContainer>().inventory);
        }
        void FragmentGoToFull(BasePlayer player, string Key)
        {
            var FragmentFull = config.ItemSetting[Key];
            var FragmentsFull = (Item)CreateFragment(FragmentFull.DisplayName, FragmentFull.SkinID, ReplaceShortnameFull);
            player.GiveItem(FragmentsFull);

            if (DataFragments[player.userID].ContainsKey(Key))
                DataFragments[player.userID].Remove(Key);
            SendChat(player, String.Format(lang.GetMessage("NEW_FRAGMENT_FULL", this, player.UserIDString), FragmentFull.DisplayName));
        }
        void UnwrapFragmentFull(BasePlayer player, string Key)
        {
            var Reward = config.ItemSetting[Key].RewardSetting;
            
            switch(Reward.typeReward)
            {
                case TypeReward.Command:
                    {
                        rust.RunServerCommand(Reward.Command.Replace("%USERID%", player.userID.ToString()));
                        break;
                    }
                case TypeReward.ItemList:
                    {
                        foreach (var Item in Reward.ItemRewardSetting)
                        {
                            Item itemS = ItemManager.CreateByName(Item.Shortname, Item.Amount, Item.SkinID);
                            if (!String.IsNullOrEmpty(Item.DisplayName))
                                itemS.name = Item.DisplayName;

                            if (player.inventory.containerMain.itemList.Count < 24)
                                player.GiveItem(itemS);
                            else itemS.Drop(player.transform.position, Vector3.zero);
                        }
                        break;
                    }
                case TypeReward.IQEconomic:
                    {
                        if (!IQEconomic)
                        {
                            PrintWarning("У вас не установлен IQEconomic,плагин работает неккоректно");
                            return;
                        }
                        SetBalance(player.userID, Reward.Balance);
                        break;
                    }
                case TypeReward.CommandList:
                    {
                        foreach (var Command in Reward.CommandList)
                            rust.RunServerCommand(Command.Replace("%USERID%", player.userID.ToString()));
                        break;
                    }
            }
        }

        #region HelpMetods
        public bool IsRandom(int Rare)
        {
            if (Oxide.Core.Random.Range(0, 100) >= (100 - Rare))
                return true;
            else return false;
        }
        private Item CreateFragment(string DisplayName,ulong SkinID, string Shortname, int Amount = 1)
        {
            Item itemS = ItemManager.CreateByName(Shortname, Amount, SkinID);
            itemS.name = DisplayName;
            itemS.info.stackable = 1;
            return itemS;
        }
        private Item OnItemSplit(Item item, int amount)
        {
            if (plugins.Find("Stacks") || plugins.Find("CustomSkinsStacksFix") || plugins.Find("SkinBox")) return null;
            var Item = config.ItemSetting;
            if (item.info.shortname == ReplaceShortname)
            {
                var Fragment = Item.FirstOrDefault(x => x.Value.FragmentSetting.SkinID == item.skin);
                    if (item.skin == Fragment.Value.FragmentSetting.SkinID)
                    {
                        Item x = ItemManager.CreateByPartialName(ReplaceShortname, amount);
                        x.name = Fragment.Value.FragmentSetting.DisplayName;
                        x.skin = Fragment.Value.FragmentSetting.SkinID;
                        x.amount = amount;
                        item.amount -= amount;
                        return x;
                    }
            }
            else if (item.info.shortname == ReplaceShortnameFull)
            {
                var Fragment = Item.FirstOrDefault(x => x.Value.SkinID == item.skin);

                if (item.skin == Fragment.Value.SkinID)
                    {
                        Item x = ItemManager.CreateByPartialName(ReplaceShortnameFull, amount);
                        x.name = Fragment.Value.DisplayName;
                        x.skin = Fragment.Value.SkinID;
                        x.amount = amount;
                        item.amount -= amount;
                        return x;
                    }
            }
            return null;
        }
        object CanCombineDroppedItem(DroppedItem item, DroppedItem targetItem)
        {
            if (item.GetItem().skin != targetItem.GetItem().skin) return false;
            return null;
        }
        object CanStackItem(Item item, Item targetItem)
        {
            if (item.skin != targetItem.skin) return false;
            return null;
        }
        #endregion

        #endregion

        #region Lang
        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NEW_FRAGMENT_USE"] = "You have successfully used the fragment {0}\nTo complete the set you need {1} more fragments",
                ["NEW_FRAGMENT_FULL"] = "You have successfully assembled the kit {0}",

            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NEW_FRAGMENT_USE"] = "Вы успешно использовали фрагмент {0}\nДля полного комплекта вам нужно еще {1} фрагментов",
                ["NEW_FRAGMENT_FULL"] = "Вы успешно собрали комплект {0}",

            }, this, "ru");
            PrintWarning("Языковой файл загружен успешно");
        }
        #endregion
    }
}


// --- End of file: IQSystemFragments.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/SetupFurnaces.cs ---
// --- Original Local Path: SetupFurnaces.cs ---

using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("SetupFurnaces", "Sempai", "1.1.0")]
    internal class SetupFurnaces : RustPlugin
    {
        #region Static

        private const string Layer = "UI_SetupFurnaces";
        private const string perm = "setupfurnaces.use";
        private Configuration _config;
        private Dictionary<string, FurnaceDefenition> furnacesSlots = new Dictionary<string, FurnaceDefenition>
        {
            ["campfire"] = new FurnaceDefenition()
            {
                InputType = "raw",
                OutputAmount = 2,
                SlotsType = new List<SlotType>
                {
                    SlotType.FUEL,
                    SlotType.INPUT,
                    SlotType.OUTPUT,
                    SlotType.OUTPUT,
                }
            },
            ["bbq.deployed"] = new FurnaceDefenition()
            {
                InputType = "raw",
                OutputAmount = 8,
                SlotsType = new List<SlotType>
                {
                    SlotType.FUEL,
                    SlotType.INPUT,
                    SlotType.INPUT,
                    SlotType.INPUT,
                    SlotType.OUTPUT,
                    SlotType.OUTPUT,
                    SlotType.OUTPUT,
                    SlotType.OUTPUT,
           