     }
            },
            ["furnace"] = new FurnaceDefenition()
            {
                InputType = "ore",
                OutputAmount = 3,
                SlotsType = new List<SlotType>
                {
                    SlotType.FUEL,
                    SlotType.INPUT,
                    SlotType.INPUT,
                    SlotType.OUTPUT,
                    SlotType.OUTPUT,
                    SlotType.OUTPUT,
                }
            },
            ["furnace.large"] = new FurnaceDefenition()
            {
                OutputAmount = 15,
                InputType = "ore",
                SlotsType = new List<SlotType>
                {
                    SlotType.FUEL,
                    SlotType.FUEL,
                    SlotType.INPUT,
                    SlotType.INPUT,
                    SlotType.INPUT,
                    SlotType.INPUT,
                    SlotType.INPUT,
                    SlotType.OUTPUT,
                    SlotType.OUTPUT,
                    SlotType.OUTPUT,
                    SlotType.OUTPUT,
                    SlotType.OUTPUT,
                    SlotType.OUTPUT,
                    SlotType.OUTPUT,
                    SlotType.OUTPUT,
                    SlotType.OUTPUT,
                    SlotType.OUTPUT,
                }
            },
            ["refinery_small_deployed"] = new FurnaceDefenition()
            {
                OutputAmount = 3,
                InputType = "crude",
                SlotsType = new List<SlotType>
                {
                    SlotType.FUEL,
                    SlotType.INPUT,
                    SlotType.OUTPUT,
                    SlotType.OUTPUT,
                    SlotType.OUTPUT,
                }
            }
        };

        private enum SlotType : byte
        {
            FUEL,
            INPUT,
            OUTPUT
        }

        private class FurnaceDefenition
        {
            public string InputType;
            public float OutputAmount;
            public List<SlotType> SlotsType = new List<SlotType>();
        }

        private class Configuration
        {
            [JsonProperty(PropertyName = "Oven setup for players", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, SetupOven> playersOvenSetup = new Dictionary<string, SetupOven>()
            {
                ["setupfurnaces.default"] = new SetupOven
                {
                    quickSmelt = 1,
                    stopBurn = new Dictionary<string, bool>()
                    {
                        ["furnace"] = true,
                        ["furnace.large"] = false,
                        ["refinery_small_deployed"] = false,
                        ["campfire"] = false,
                        ["bbq.deployed"] = false
                    },
                    quickSmelting = new Dictionary<string, bool>
                    {
                        ["furnace"] = true,
                        ["furnace.large"] = false,
                        ["refinery_small_deployed"] = false,
                        ["campfire"] = false,
                        ["bbq.deployed"] = false
                    },
                },
                ["setupfurnaces.vip"] = new SetupOven
                {
                    quickSmelt = 1,
                    stopBurn = new Dictionary<string, bool>()
                    {
                        ["furnace"] = true,
                        ["furnace.large"] = true,
                        ["refinery_small_deployed"] = true,
                        ["campfire"] = true,
                        ["bbq.deployed"] = true
                    },
                    quickSmelting = new Dictionary<string, bool>
                    {
                        ["furnace"] = true,
                        ["furnace.large"] = true,
                        ["refinery_small_deployed"] = true,
                        ["campfire"] = true,
                        ["bbq.deployed"] = true
                    },
                },
            };
        }

        private class SetupOven
        {
            [JsonProperty(PropertyName = "Quick smelt value")]
            public int quickSmelt = 1;

            public Dictionary<string, bool> stopBurn = new Dictionary<string, bool>
            {
                ["furnace"] = true,
                ["furnace.large"] = true,
                ["refinery_small_deployed"] = true,
                ["campfire"] = true,
                ["bbq.deployed"] = true
            };

            public Dictionary<string, bool> quickSmelting = new Dictionary<string, bool>
            {
                ["furnace"] = true,
                ["furnace.large"] = true,
                ["refinery_small_deployed"] = true,
                ["campfire"] = true,
                ["bbq.deployed"] = true
            };
        }
        
        #region Config

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
                SaveConfig();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig() => Config.WriteObject(_config);

        protected override void LoadDefaultConfig() => _config = new Configuration();

        #endregion

        #endregion

        #region OxideHooks

        private void OnServerInitialized()
        {
            permission.RegisterPermission(perm, this);
            foreach (var check in _config.playersOvenSetup) permission.RegisterPermission(check.Key, this);
        }

        private void Unload()
        {
            foreach (var check in BasePlayer.activePlayerList) CuiHelper.DestroyUi(check, Layer + ".bg");
        }


        private void OnOvenCook(BaseOven oven, Item item, BaseEntity slot)
        {
            if (oven == null) return;
            
            string playerPermission = "";
            foreach (var check in _config.playersOvenSetup)
                if (permission.UserHasPermission(oven.OwnerID.ToString(), check.Key)) playerPermission = check.Key;
            
            bool isOn;
            if (string.IsNullOrEmpty(playerPermission) || !_config.playersOvenSetup[playerPermission].stopBurn.TryGetValue(oven.ShortPrefabName, out isOn) || !isOn) return;

            var curOvenInputType = furnacesSlots[oven.ShortPrefabName].InputType;
            foreach (var check in oven.inventory.itemList)
                if (check.info.displayName.english.ToLower().Contains(curOvenInputType))
                    return;

            NextTick(oven.StopCooking);
        }

        private void OnLootEntity(BasePlayer player, BaseOven oven)
        {
            if (player == null || oven == null || !furnacesSlots.ContainsKey(oven.ShortPrefabName)) return;
            var curOven = furnacesSlots[oven.ShortPrefabName];
            var curOvenInput = curOven.InputType;
            var curOvenOutputAmount = curOven.OutputAmount;
            var ovenInv = oven.inventory;
            var ovenItemList = ovenInv.itemList;
            var playerContainerMain = player.inventory.containerMain;
            var playerContainerBelt = player.inventory.containerBelt;

            // COLLECT
            foreach (var check in ovenItemList.ToArray())
            {
                if (curOven.SlotsType[check.position] == SlotType.OUTPUT)
                    check.MoveToContainer(check.CanMoveTo(player.inventory.containerMain) ? player.inventory.containerMain : player.inventory.containerBelt);
            }    
            
            // SORT INPUT
            foreach (var check in ovenItemList.ToArray())
            {
               if (curOven.SlotsType[check.position] == SlotType.INPUT)
                    check.MoveToContainer(ovenInv);    
            }

            // ADD FUEL
            foreach (var check in playerContainerMain.itemList.ToArray())
                if (check.info.shortname == "wood")
                    check.MoveToContainer(ovenInv);
            foreach (var check in playerContainerBelt.itemList.ToArray())
                if (check.info.shortname == "wood")
                    check.MoveToContainer(ovenInv);

            // ADD INPUT
            foreach (var check in playerContainerMain.itemList.ToArray())
                if (check.info.displayName.english.ToLower().Contains(curOvenInput)) 
                    check.MoveToContainer(ovenInv);    
            foreach (var check in playerContainerBelt.itemList.ToArray())
                if (check.info.displayName.english.ToLower().Contains(curOvenInput)) 
                    check.MoveToContainer(ovenInv);
            
            // REMOVE SURPLUS
            float wood = 0;
            foreach (var check in ovenInv.itemList.ToArray())
                if (check.info.shortname == "wood") wood += check.amount;

            foreach (var check in ovenItemList.ToArray())
            {
                if (!check.info.displayName.english.ToLower().Contains(curOvenInput)) continue;
                if ((int) wood <= 1 && check.amount > 1)
                {
                    player.GiveItem(ItemManager.CreateByName(check.info.shortname, check.amount));
                    Take(ovenInv.itemList, check.info.shortname, check.amount);
                    continue;
                }
                int needFuel;
                switch (check.info.shortname)
                {
                    case "sulfur.ore":
                        needFuel = 2;
                        break;
                    case "metal.ore":
                        needFuel = 5;
                        break;
                    case "hq.metal.ore":
                        needFuel = 10;
                        break;
                    case "crude.oil":
                        needFuel = 6;
                        break;
                    default:
                        needFuel = 3;
                        break;
                }

                var amountResourcesRemain = wood / needFuel * curOvenOutputAmount;
                wood -=  check.amount / curOvenOutputAmount * needFuel;
                
                if ((int) wood >= 0 && check.amount - amountResourcesRemain <= 1) continue;
                player.GiveItem(ItemManager.CreateByName(check.info.shortname, (int) (check.amount - amountResourcesRemain)));
                Take(ovenInv.itemList, check.info.shortname, (int) (check.amount - amountResourcesRemain));
            }
            foreach (var check in ovenItemList.ToArray())
            {
                if (curOven.SlotsType[check.position] == SlotType.INPUT)
                    check.MoveToContainer(ovenInv);    
            }
            if ((int)wood > 1)
            {
                player.GiveItem(ItemManager.CreateByName("wood", (int)wood));
                Take(ovenInv.itemList, "wood", (int)wood);
            }
            
            if (!oven.HasFlag(BaseEntity.Flags.On))
                NextTick(()=>
                {
                    string playerPermission = "";
                    foreach (var check in _config.playersOvenSetup)
                        if (permission.UserHasPermission(oven.OwnerID.ToString(), check.Key)) playerPermission = check.Key;
                    
                    bool isOn;
                    var setupOven = _config.playersOvenSetup[playerPermission];
                    if (player == null || string.IsNullOrEmpty(playerPermission) || !setupOven.quickSmelting.TryGetValue(oven.ShortPrefabName, out isOn) || !isOn) return;
                    if (oven.IsDestroyed) return;
                    var speed = 0.5f / setupOven.quickSmelt;
                    oven.CancelInvoke(oven.Cook);
                    oven.inventory.temperature = oven.cookingTemperature;
                    oven.UpdateAttachmentTemperature();
                    oven.InvokeRepeating(oven.Cook, speed, speed);
                    oven.SetFlag(BaseEntity.Flags.On, true);
                });
        }


        #endregion      

        #region Commands

        [ChatCommand("fsetup")]
        private void cmdChatmenu(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, perm))
            {
                SendReply(player, "You haven't permission for use this command");
                return;
            }

            if (args.Length != 0)
            {
                SendReply(player, "Use command without args - <color=yellow>/fsetup</color>");
                return;
            }
            
            ShowUIBG(player);
        }

        [ConsoleCommand("UI_SF")]
        private void cmdConsole(ConsoleSystem.Arg arg)
        {
            if (!arg.HasArgs()) return;
            var player = arg.Player();
            switch (arg.GetString(0))
            {
                case "SMELTSPEED":
                    _config.playersOvenSetup[arg.GetString(1)].quickSmelt = arg.GetInt(2) < 1 ? 1 : arg.GetInt(2);
                    break;
                case "STOPBURNING":
                    _config.playersOvenSetup[arg.GetString(1)].stopBurn[arg.GetString(2)] = !_config.playersOvenSetup[arg.GetString(1)].stopBurn[arg.GetString(2)];
                    break;
                case "QUICKSMELT":
                    _config.playersOvenSetup[arg.GetString(1)].quickSmelting[arg.GetString(2)] = !_config.playersOvenSetup[arg.GetString(1)].quickSmelting[arg.GetString(2)];
                    break;
                case "BACK":
                    ShowUISelectPERM(player);
                    return;
            }
            ShowUISetupFurnaces(player, arg.GetString(1));
        }

        #endregion

        #region Functions

        private void Take(IEnumerable<Item> itemList, string shortname, int iAmount)
        {
            var num1 = 0;
            if (iAmount == 0) return;
            var list = Facepunch.Pool.GetList<Item>();
            foreach (var obj in itemList)
            {
                if (obj.info.shortname != shortname) continue;
                var num2 = iAmount - num1;
                if (num2 <= 0) continue;
                if (obj.amount > num2)
                {
                    obj.MarkDirty();
                    obj.amount -= num2;
                    break;
                }

                if (obj.amount <= num2)
                {
                    num1 += obj.amount;
                    list.Add(obj);
                }

                if (num1 == iAmount) break;
            }

            foreach (var obj in list) obj.RemoveFromContainer();
            Facepunch.Pool.FreeList(ref list);
        }

        #endregion

        #region UI
        
        private void ShowUISetupFurnaces(BasePlayer player, string fperm)
        {
            var container = new CuiElementContainer();

            container.Add(new CuiElement
            {
                Parent = Layer + ".bg",
                Name = Layer,
                Components =
                {
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5",
                        OffsetMin = "-250 -150", OffsetMax = "250 150"
                    },
                    new CuiImageComponent
                    {
                        Color = "0.15 0.15 0.15 0.9",
                        Material = "assets/content/ui/binocular_overlay.mat",
                    },
                },
            });
            
            container.Add(new CuiElement
            {
                Parent = Layer,
                Name = Layer + ".label",
                Components =
                {
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 1", AnchorMax = "1 1",
                        OffsetMin = "0 -30", OffsetMax = "0 0"
                    },
                    new CuiTextComponent
                    {
                        Text = "SETUP FURNACES",
                        FontSize = 20, Color = "1 1 0 1",
                        Align = TextAnchor.MiddleCenter, Font = "permanentmarker.ttf",
                    },
                    new CuiOutlineComponent { Distance = "-0.5 -0.5", Color = "0 0 0 1"},
                },
            });

            var ovenSetup = _config.playersOvenSetup[fperm];
            Dictionary<string, string> dicOvens = new Dictionary<string, string>
            {
                ["furnace"] = "Furnace",
                ["furnace.large"] = "Large Furnace",
                ["refinery_small_deployed"] = "Refinery",
                ["campfire"] = "Campfire",
                ["bbq.deployed"] = "Barbeque"
            };
            
            var posY = -85;
            container.Add(new CuiElement
            {
                Parent = Layer,
                Name = Layer + ".label",
                Components =
                {
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.05 1", AnchorMax = "0.45 1",
                        OffsetMin = "0 -60", OffsetMax = "0 -30"
                    },
                    new CuiTextComponent
                    {
                        Text = "QUICK SMELT",
                        FontSize = 18, Color = "0.00 0.87 0.95 1.00",
                        Align = TextAnchor.MiddleCenter, Font = "permanentmarker.ttf",
                    },
                    new CuiOutlineComponent { Distance = "-0.5 -0.5", Color = "0 0 0 1"},
                },
            });
            
            container.Add(new CuiElement
            {
                Parent = Layer,
                Name = Layer + ".label",
                Components =
                {
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.55 1", AnchorMax = "0.95 1",
                        OffsetMin = "0 -60", OffsetMax = "0 -30"
                    },
                    new CuiTextComponent
                    {
                        Text = "STOP BURN",
                        FontSize = 18, Color = "0.00 0.87 0.95 1.00",
                        Align = TextAnchor.MiddleCenter, Font = "permanentmarker.ttf",
                    },
                    new CuiOutlineComponent { Distance = "-0.5 -0.5", Color = "0 0 0 1"},
                },
            });
            
            // QUICK SMELT
            foreach (var check in dicOvens)
            {
                  container.Add(new CuiButton
                  {
                      RectTransform =
                      {
                          AnchorMin = "0.05 1", AnchorMax = "0.45 1",
                          OffsetMin = $"0 {posY}", OffsetMax = $"0 {posY + 25}"
                      },
                      Text =
                      {
                          Text = check.Value + $":   {(ovenSetup.quickSmelting[check.Key] ? "<color=green>ON</color>" : "<color=red>OFF</color>")}",
                          FontSize = 16, Color = "1 1 1 1",
                          Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf",
                      },
                      Button =
                      {
                          Command = $"UI_SF QUICKSMELT {fperm} {check.Key}",
                          Color = "0 0 0 0",
                      },
                  }, Layer, Layer + ".button");

                  posY -= 25;
            }
            
            container.Add(new CuiElement
            {
                Parent = Layer,
                Name = Layer + ".label",
                Components =
                {
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.05 1", AnchorMax = "0.45 1",
                        OffsetMin = $"0 {posY}", OffsetMax = $"0 {posY + 25}"
                    },
                    new CuiTextComponent
                    {
                        Text = "Quick smelt speed:",
                        FontSize = 16, Color = "1 1 1 1",
                        Align = TextAnchor.MiddleLeft, Font = "robotocondensed-regular.ttf",
                    },
                    new CuiOutlineComponent { Distance = "-0.5 -0.5", Color = "0 0 0 1"},
                },
            });
            
            container.Add(new CuiElement
            {
                Parent = Layer,
                Name = Layer + ".panelInp",
                Components =
                {
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.45 1", AnchorMax = "0.45 1",
                        OffsetMin = $"-50 {posY}", OffsetMax = $"0 {posY + 25}"
                    },
                    new CuiImageComponent
                    {
                        Color = "0.33 0.33 0.33 1",
                        Material = "assets/icons/iconmaterial.mat",
                    },
                },
            });
            container.Add(new CuiElement
            {
                Parent = Layer + ".panelInp",
                Name = Layer + ".input",
                Components =
                {
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0", AnchorMax = "1 1",
                    },
                    new CuiInputFieldComponent
                    {
                        Text = ovenSetup.quickSmelt.ToString(),
                        Command = $"UI_SF SMELTSPEED {fperm}", CharsLimit = 3,
                        FontSize = 16, Color = "1 1 1 1",
                        Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf",
                    },
                }
            });

            posY = -85;
            // STOP BURN
            foreach (var check in dicOvens)
            {
                container.Add(new CuiButton
                {
                    RectTransform =
                    {
                        AnchorMin = "0.55 1", AnchorMax = "0.95 1",
                        OffsetMin = $"0 {posY}", OffsetMax = $"0 {posY + 25}"
                    },
                    Text =
                    {
                        Text = check.Value + $":   {(ovenSetup.stopBurn[check.Key] ? "<color=green>ON</color>" : "<color=red>OFF</color>")}",
                        FontSize = 16, Color = "1 1 1 1",
                        Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf",
                    },
                    Button =
                    {
                        Command = $"UI_SF QUICKSMELT {fperm} {check.Key}",
                        Color = "0 0 0 0",
                    },
                }, Layer, Layer + ".button");

                posY -= 25;
            }
            
            container.Add(new CuiButton
            {
                RectTransform =
                {
                    AnchorMin = "0 1", AnchorMax = "0 1",
                    OffsetMin = "-30 -30", OffsetMax = "0 0"
                },
                Text =
                {
                    Text = "<",
                    FontSize = 20, Color = "1 1 1 1",
                    Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf",
                },
                Button =
                {
                    Command = "UI_SF BACK",
                    Color = "0.2 0.2 0.2 0.85",
                },
            }, Layer, Layer + ".button");
        
            CuiHelper.DestroyUi(player, Layer);
            CuiHelper.AddUi(player, container);
        }

        private void ShowUISelectPERM(BasePlayer player)
        {
            var container = new CuiElementContainer();

            var ovenSetupList = _config.playersOvenSetup;
            var ovenSetupListCount = ovenSetupList.Count;
            
            container.Add(new CuiElement
            {
                Parent = Layer + ".bg",
                Name = Layer,
                Components =
                {
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5",
                        OffsetMin = $"-125 {ovenSetupListCount * -25}", OffsetMax = $"125 {ovenSetupListCount * 25}"
                    },
                    new CuiImageComponent
                    {
                        Color = "0.15 0.15 0.15 0.9",
                        Material = "assets/content/ui/binocular_overlay.mat",
                    },
                },
            });
            
            container.Add(new CuiElement
            {
                Parent = Layer,
                Name = Layer + ".label",
                Components =
                {
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 1", AnchorMax = "1 1",
                        OffsetMin = "0 -30", OffsetMax = "0 0"
                    },
                    new CuiTextComponent
                    {
                        Text = "SELECT PERMISSION",
                        FontSize = 20, Color = "1 1 0 1",
                        Align = TextAnchor.MiddleCenter, Font = "permanentmarker.ttf",
                    },
                    new CuiOutlineComponent { Distance = "-0.5 -0.5", Color = "0 0 0 1"},
                },
            });

            var posY = -55;
            foreach (var check in ovenSetupList)
            {
                container.Add(new CuiButton
                {
                    RectTransform =
                    {
                        AnchorMin = "0 1", AnchorMax = "1 1",
                        OffsetMin = $"0 {posY}", OffsetMax = $"0 {posY + 25}"
                    },
                    Text =
                    {
                        Text = check.Key,
                        FontSize = 16, Color = "1 1 1 1",
                        Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf",
                    },
                    Button =
                    {
                        Command = $"UI_SF SELECTPERM {check.Key}",
                        Color = "0 0 0 0",
                    },
                }, Layer, Layer + ".button");
                posY -= 25;
            }
        
            CuiHelper.DestroyUi(player, Layer);
            CuiHelper.AddUi(player, container);
        }        
        
        private void ShowUIBG(BasePlayer player)
        {
            var container = new CuiElementContainer();
            
            container.Add(new CuiPanel
            {
                KeyboardEnabled = true,
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                Image = { Color = "0 0 0 0.92", Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
            }, "Overlay", Layer + ".bg");
            
            container.Add(new CuiButton
            {
                RectTransform =
                {
                    AnchorMin = "0 0", AnchorMax = "1 1",
                    OffsetMin = "0 0", OffsetMax = "0 0"
                },
                Text =
                {
                    Text = "",
                    FontSize = 16, Color = "1 1 1 1",
                    Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf",
                },
                Button =
                {
                    Close = Layer + ".bg",
                    Color = "0 0 0 0",
                },
            }, Layer + ".bg", Layer + ".button");
            
            CuiHelper.DestroyUi(player, Layer + ".bg");
            CuiHelper.AddUi(player, container);

            ShowUISelectPERM(player);
        }

        #endregion
    }
}

// --- End of file: SetupFurnaces.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/ResolutionAPI.cs ---
// --- Original Local Path: ResolutionAPI.cs ---

using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("ResolutionAPI", "azalea`", "0.1")]
    public class ResolutionAPI : RustPlugin
    {
        Dictionary<ulong, string> resolutionData = new Dictionary<ulong, string>();

		DynamicConfigFile resolutionDataFile = Interface.Oxide.DataFileSystem.GetFile("ResolutionAPI");

        void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"RES_TITLE", "Choose the flat square or the ratio of your monitor"},
                {"RES_SELECTED", "You choosed {0} resolution.\nTo change, use command <color=#DCFF66>/ratio</color>"},
                {"RES_CHOOSED", "Choosed"}
            }, this);
        }

        string GetLangMessage(string key, string steamID = null) => lang.GetMessage(key, this, steamID);

        void Loaded() => LoadDefaultMessages();

        protected override void LoadDefaultConfig()
        {
            Config["ShowOnPlayerInit"] = true;
        }

        void OnServerInitialized() => resolutionData = resolutionDataFile.ReadObject<Dictionary<ulong, string>>();

        void OnServerSave() => resolutionDataFile.WriteObject(resolutionData);

        void Unload() => resolutionDataFile.WriteObject(resolutionData);

        void OnPlayerInit(BasePlayer player)
        {
            if (!Config.Get<bool>("ShowOnPlayerInit")) return;

            if (player == null)
                return;

            if (resolutionData.ContainsKey(player.userID))
                return;

            if (player.IsReceivingSnapshot())
            {
                timer.Once(2, () => OnPlayerInit(player));
                return;
            }

            ShowResolutionMenu(player);
        }

		void ShowResolutionMenu(BasePlayer player)
		{
			CuiHelper.DestroyUi(player, "ResolutionMain");

			CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiElement
            {
                Name = "ResolutionMain",
				Parent = "Hud",
                Components =
                {
                    new CuiRawImageComponent { Color = "0 0 0 0" },
					new CuiNeedsCursorComponent(),
                    new CuiRectTransformComponent()
                }
            });

            string TitlePanelName = CuiHelper.GetGuid();

            container.Add(new CuiElement
            {
                Name = TitlePanelName,
                Parent = "ResolutionMain",
                Components =
                {
                    new CuiRawImageComponent { Color = "1 1 1 0.4" },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0.2 0.85",
                        AnchorMax = "0.8 0.95"
                    }
                }
            });

            container.Add(new CuiElement
            {
                Name = CuiHelper.GetGuid(),
                Parent = TitlePanelName,
                Components =
                {
                    new CuiTextComponent
                    {
                        Text = GetLangMessage("RES_TITLE"),
                        FontSize = 25,
                        Align = TextAnchor.MiddleCenter
                    },
                    new CuiRectTransformComponent(),
                    new CuiOutlineComponent() { Color = "0 0 0 1" }
                }
            });

            //16/9: 

            //9 / 16 = X;
            //(xMax - xMin) / X = B
            // Ymax - B = Ymin

            string UserResolution = (string)(GetUserResolution(player.userID) ?? string.Empty);

            CreateBox(container, "0.2 0.4444", "0.4 0.8", "16x9", UserResolution == "16x9");
            CreateBox(container, "0.6 0.48", "0.8 0.8", "16x10", UserResolution == "16x10");
            CreateBox(container, "0.2 0.1333", "0.4 0.4", "4x3", UserResolution == "4x3");
            CreateBox(container, "0.6 0.15", "0.8 0.4", "5x4", UserResolution == "5x4");
            											
			CuiHelper.AddUi(player, container); 
		}
				
        void CreateBox(CuiElementContainer container, string AnchorMin, string AnchorMax, string Resolution, bool Active = false)
        {
            string BoxName = CuiHelper.GetGuid();

            container.Add(new CuiElement
            {
                Name = BoxName,
                Parent = "ResolutionMain",
                Components =
                {
                    new CuiButtonComponent
                    {
                        Command = "resolution.select " + Resolution, // NOTE! Text will put as CMD
                        Close = "ResolutionMain",
                        Color = "1 1 1 0.4"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = AnchorMin,
                        AnchorMax = AnchorMax
                    }
                }
            });

            container.Add(new CuiElement
            {
                Name = CuiHelper.GetGuid(),
                Parent = BoxName,
                Components =
                {
                    new CuiTextComponent
                    {
                        Text = Resolution + (Active ? "\n\n" + GetLangMessage("RES_CHOOSED") : ""),
                        FontSize = 30,
                        Align = TextAnchor.MiddleCenter
                    },
                    new CuiRectTransformComponent(),
                    new CuiOutlineComponent() { Color = "0 0 0 1" }
                }
            });
        }
		
		[ConsoleCommand("resolution.select")]
		void ConsoleCmd_Select(ConsoleSystem.Arg arg)
		{
			if (arg.connection != null)
            {
				string SelectedResolution = arg.Args[0];

                switch(SelectedResolution)
                {
                    case "16x9":
                    case "16x10":
                    case "5x4":
                    case "4x3": break;

                    default: return;
                }

                BasePlayer player = arg.Player();

				resolutionData[player.userID] = SelectedResolution;

                Interface.Oxide.CallHook("OnUserResolution", player, SelectedResolution);

				SendReply(player, $"<size=16>{string.Format(GetLangMessage("RES_SELECTED"), SelectedResolution)}</size>");
			}
		}
		
		[ChatCommand("ratio")]
        void ChatCmd_Ratio(BasePlayer player, string command, string[] args) => ShowResolutionMenu(player);

        object GetUserResolution(ulong userId)
        {
            string ResolutionState;

            if (resolutionData.TryGetValue(userId, out ResolutionState))
                return ResolutionState;

            return null;
        }
    }
}

// --- End of file: ResolutionAPI.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/CustomIcon.cs ---
// --- Original Local Path: CustomIcon.cs ---

﻿using System.Collections.Generic;
using Network;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Custom Icon", "collect_vood", "1.0.4")]
    [Description("Set a customizable icon for all non user messages")]

    class CustomIcon : CovalencePlugin
    {
        #region Config
        
        private Configuration _configuration;
        
        private class Configuration
        {
            [JsonProperty(PropertyName = "Steam Avatar User ID")]
            public ulong SteamAvatarUserID = 0;
        }
        
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            _configuration = new Configuration();
        }
        
        protected override void LoadConfig()
        {
            base.LoadConfig();
            _configuration = Config.ReadObject<Configuration>();
            SaveConfig();
        }
        
        protected override void SaveConfig() => Config.WriteObject(_configuration);
        
        #endregion

        #region Hooks 
        
        private void OnBroadcastCommand(string command, object[] args)
        {
            TryApplySteamAvatarUserID(command, args);
        }
        
        private void OnSendCommand(Connection cn, string command, object[] args)
        {
            TryApplySteamAvatarUserID(command, args);
        }
        
        private void OnSendCommand(List<Connection> cn, string command, object[] args)
        {
            TryApplySteamAvatarUserID(command, args);
        }

        #endregion

        #region Helpers

        private void TryApplySteamAvatarUserID(string command, object[] args)
        {
            if (args == null || _configuration == null) 
                return;
            
            if (args.Length < 2 || (command != "chat.add" && command != "chat.add2")) 
                return;

            ulong providedID;
            if (ulong.TryParse(args[1].ToString(), out providedID) && providedID == 0)
                args[1] = _configuration.SteamAvatarUserID;
        }

        #endregion
    }
}

// --- End of file: CustomIcon.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/AdminProtection.cs ---
// --- Original Local Path: AdminProtection.cs ---

using System.Reflection;
using System.Linq;

using Oxide.Core;
using Rust;
using System;
using System.Collections.Generic;


namespace Oxide.Plugins
{
    [Info("AdminProtection", "4seti", "0.6.2", ResourceId = 869)]
    public class AdminProtection : RustPlugin
    {
		#region Utility Methods

		private void Log(string message) => Puts("{0}: {1}", Title, message);
		private void Warn(string message) => PrintWarning("{0}: {1}", Title, message);
		private void Error(string message) => PrintError("{0}: {1}", Title, message);

		void ReplyChat(BasePlayer player, string msg) => player.ChatMessage(string.Format("<color=#81D600>{0}</color>: {1}", ChatName, msg));		

		#endregion

		static FieldInfo developerIDs = typeof(DeveloperList).GetField("developerIDs", (BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Static));
        private Dictionary<ulong, ProtectionStatus> protData;
        private Dictionary<ulong, DateTime> antiSpam;
		private string ChatName = "AdminProtection";
		private Hash<ulong, ProtectionStatus> gods = new Hash<ulong, ProtectionStatus>();
		private Dictionary<string, string> APHelper = new Dictionary<string, string>();

        Dictionary<string, string> defMsg = new Dictionary<string, string>()
                {
                    {"Enabled", "You <color=#81F23F>ENABLED</color> Admin Protection!"},
                    {"LootAlert", "<color=#FF6426>You are trying to loop sleeping admin, please don't!</color>"},
                    {"EnabledTo", "You <color=#81F23F>ENABLED</color> Admin Protection for player: {0}!"},
                    {"DisabledTo",  "You <color=#F23F3F>DISABLED</color> Admin Protection for player: {0}!"},
                    {"TooMuch",  "More than one match!"},
                    {"Enabled_s",  "You <color=#81F23F>ENABLED</color> Admin Protection in complete silent mode!"},
                    {"Enabled_m",  "You <color=#81F23F>ENABLED</color> Admin Protection with no mesage to attacker!"},
                    {"Disabled",  "You <color=#F23F3F>DISABLED</color> Admin Protection!"},
                    {"HelpMessage",  "/ap - This command will toggle Admin Protection on or off."},
                    {"NoAPDamageAttacker",  "{0} is admin, you can't kill him."},
                    {"NoAPDamagePlayer",  "{0} is trying to kill you."},
                    {"ChatName",  "Admin Protection"},
                    {"Error",  "Error!"},
                    {"LootMessageLog",  "{0} - is trying to loot admin - {1}"},
					{"APListByAdmin",  "<color=#007BFF>{0}</color>[{1}], Mode: <color=#FFBF00>{2}</color>, Enabled By: <color=#81F23F>{3}</color>"},
					{"APListAdmin",  "<color=#81F23F>{0}</color>[{1}], Mode: <color=#FFBF00>{2}</color>"},
					{"APListHeader",  "<color=#81F23F>List of active AdminProtections</color>"},
		            {"Reviving",  "<color=#81F23F>Sorry for your death, Reviving!</color>"}		
                };

        void Loaded()
        {
            Log("Loaded");
            LoadData();
            SaveData();
        }

        // Loads the default configuration
        protected override void LoadDefaultConfig()
        {
            Log("Creating a new config file");
            Config.Clear();
            LoadVariables();
        }

        void LoadVariables()
        {
            Config["messages"] = defMsg;
            Config["version"] = Version;
			Config["ChatName"] = ChatName;
        }




        // Gets a config value of a specific type
        private T GetConfig<T>(string name, T defaultValue)
        {
			if (Config[name] == null)
			{
				Config[name] = defaultValue;
				SaveConfig();
				return defaultValue;
			}
            return (T)Convert.ChangeType(Config[name], typeof(T));
        }
        void OnServerInitialized()
        {
            try
            {
                LoadConfig();
                var version = GetConfig<Dictionary<string, object>>("version", null);
                VersionNumber verNum = new VersionNumber(Convert.ToUInt16(version["Major"]), Convert.ToUInt16(version["Minor"]), Convert.ToUInt16(version["Patch"]));
                var cfgMessages = GetConfig<Dictionary<string, object>>("messages", null);
                if (cfgMessages != null)
                    foreach (var pair in cfgMessages)
                        APHelper[pair.Key] = Convert.ToString(pair.Value);

				ChatName = GetConfig<string>("ChatName", "AdminProtection");
				if (verNum < Version)
                {
                    foreach (var pair in defMsg)
                        if (!APHelper.ContainsKey(pair.Key))
                            APHelper[pair.Key] = pair.Value;
                    Config["version"] = Version;
                    Config["messages"] = APHelper;					
                    SaveConfig();
                    Warn("Config version updated to: " + Version.ToString() + " please check it");
                }
				
			}
            catch (Exception ex)
            {
                Error("OnServerInitialized failed: " + ex.Message);
            }

        }
        void LoadData()
        {
            try
            {
                protData = Interface.GetMod().DataFileSystem.ReadObject<Dictionary<ulong, ProtectionStatus>>("AP_Data");
            }
            catch
            {
                protData = new Dictionary<ulong, ProtectionStatus>();
                Warn("Old data removed! ReEnable your AdminProtection");
            }
            antiSpam = new Dictionary<ulong, DateTime>();
        }
        void SaveData()
        {
            Interface.GetMod().DataFileSystem.WriteObject<Dictionary<ulong, ProtectionStatus>>("AP_Data", protData);
            Log("Data Saved");
        }

        [ChatCommand("apdev")]
        void cmdAPDev(BasePlayer player, string cmd, string[] args)
        {
            if (player.net.connection.authLevel == 0) return;
            if (becameDev(player))
                ReplyChat(player, "Dev now!");
            else
                ReplyChat(player, "Not Dev!");
        }

        [ChatCommand("apdebug")]
        void cmdAPDebug(BasePlayer player, string cmd, string[] args)
        {
            if (player.net.connection.authLevel == 0) return;
            ulong userID = player.userID;
            if (protData.ContainsKey(userID))
            {
                if (protData[userID].isDebug)
                    ReplyChat(player, Title + ": Debug mode DISABLED");
                else
                    ReplyChat(player, Title + ": Debug mode ENABLED");
                    protData[userID].isDebug = !protData[userID].isDebug;
            }
        }

        private bool becameDev(BasePlayer player)
        {
            bool dev = false;
            if (player.net.connection.authLevel > 0)
            {
                var dIDs = developerIDs.GetValue(typeof(DeveloperList)) as ulong[];
                ulong[] ndIDs;                
                if (!dIDs.Contains(player.userID))
                {
                    ndIDs = new ulong[dIDs.Length + 1];
                    for (int i = 0; i < dIDs.Length; i++)
                    {
                        ndIDs[i] = dIDs[i];
                    }
                    ndIDs[dIDs.Length] = player.userID;
                    setMetabolizm(player, true);
                    player.SetPlayerFlag(BasePlayer.PlayerFlags.IsDeveloper, true);
                    dev = true;
                }
                else
                {
                    ndIDs = new ulong[dIDs.Length - 1];
                    int shift = 0;
                    for (int i = 0; i < ndIDs.Length; i++)
                    {
                        if (dIDs[i + shift] == player.userID) shift = 1;
                        ndIDs[i] = dIDs[i + shift];
                    }
                    setMetabolizm(player, true);
                    player.SetPlayerFlag(BasePlayer.PlayerFlags.IsDeveloper, false);
                }
                developerIDs.SetValue(typeof(DeveloperList), ndIDs);
            }
            return dev;
        }
        private void setMetabolizm(BasePlayer player, bool Enabling)
        {
            if (Enabling)
            {
				if (protData.ContainsKey(player.userID))
				{
					protData[player.userID].HealthData = new HealthData(player.health, player.metabolism.calories.value, player.metabolism.hydration.value);
				}
				player.metabolism.bleeding.max = 0;
                player.metabolism.radiation_level.max = 0;
                player.metabolism.radiation_level.value = 0;
                player.metabolism.radiation_poison.value = 0;
                player.metabolism.poison.max = 0;
                player.metabolism.oxygen.min = 100;
                player.metabolism.wetness.min = 0;
                player.metabolism.wetness.max = 1;
                player.metabolism.wetness.value = 0;
                player.metabolism.calories.min = 1000;
                player.metabolism.calories.value = 1000;
                player.metabolism.hydration.min = 1000;
                player.metabolism.hydration.value = 1000;
                player.health = 100f;
                player.metabolism.temperature.max = 35f;
                player.metabolism.temperature.min = 34f;
				player.metabolism.temperature.value = 34f;
				
			}
            else
            {
				if (player.IsConnected())
				{
					player.metabolism.bleeding.max = 100;
					player.metabolism.radiation_level.max = 100;
					player.metabolism.poison.max = 100;
					player.metabolism.oxygen.min = 0;
					player.metabolism.wetness.max = 100;
					player.metabolism.calories.min = 0;
					player.metabolism.hydration.min = 0;
					player.metabolism.temperature.max = 100f;
					player.metabolism.temperature.min = -50f;
					if (protData.ContainsKey(player.userID))
					{
						player.health = protData[player.userID].HealthData.HP;
						player.metabolism.hydration.value = protData[player.userID].HealthData.Hydration;
						player.metabolism.calories.value = protData[player.userID].HealthData.Calories;
					}
				}
            }
			if (player.IsConnected())
				player.metabolism.SendChangesToClient();
        }

        [ChatCommand("aplist")]
        void cmdAPList(BasePlayer player, string cmd, string[] args)
        {
            // Check if the player is an admin.
            if (player.net.connection.authLevel == 0) return;
            if (protData.Count > 0)
            {
                ReplyChat(player, APHelper["APListHeader"]);
                foreach (var item in protData)
                {
                    string mode = string.Empty;
					switch (item.Value.MsgType)
					{
						case ProtectionStatus.msgType.Normal: mode = "Normal";
							break;
						case ProtectionStatus.msgType.OnlyTarget: mode = "No Msg to Attacker";
							break;
						case ProtectionStatus.msgType.Silent: mode = "Silent";
							break;
					}
                    if (item.Value.Enabler == null)
                        ReplyChat(player, string.Format(APHelper["APListAdmin"], item.Value.Name, item.Key, mode));
                    else
                        ReplyChat(player, string.Format(APHelper["APListByAdmin"], item.Value.Name, item.Key, mode, item.Value.Enabler));
                }
            }
        }

        [ChatCommand("ap")]
        void cmdToggleAP(BasePlayer player, string cmd, string[] args)
        {
            // Check if the player is an admin.
            if (player.net.connection.authLevel == 0) return;

            // Grab the player is Steam ID.
            ulong userID = player.userID;

            // Check if the player is turning Admin Protection on or off.
            if (protData != null)
            {
                if (args.Length >= 2)
                {
                    if (args[0] == "p")
                    {
                        string targetPlayer = args[1];
                        string mode = "";
                        if (args.Length > 2)
                            mode = args[2];
						ProtectionStatus.msgType msgType = ProtectionStatus.msgType.Normal;
                        if (mode == "s") msgType = ProtectionStatus.msgType.Silent;
						else if (mode == "m") msgType = ProtectionStatus.msgType.OnlyTarget;
						List<BasePlayer> bpList = FindPlayerByName(targetPlayer);
                        if (bpList.Count > 1)
                        {
                            ReplyChat(player, APHelper["TooMuch"]);
                            foreach (var item in bpList)
                            {
                                ReplyChat(player, string.Format("<color=#81F23F>{0}</color>", item.displayName));
                            }
                        }
                        else if (bpList.Count == 1)
                        {
                            ulong targetUID = bpList[0].userID;
                            if (protData.ContainsKey(targetUID))
                            {
								setMetabolizm(bpList[0], false);
								protData.Remove(targetUID);
                                ReplyChat(player, string.Format(APHelper["DisabledTo"], bpList[0].displayName));
                            }
                            else
                            {								
								protData.Add(targetUID, new ProtectionStatus(msgType, bpList[0].displayName, player.displayName));
								setMetabolizm(bpList[0], true);
								ReplyChat(player, string.Format(APHelper["EnabledTo"], bpList[0].displayName) + " " + mode);
                            }
                        }
                        else
                        {
                            ReplyChat(player, APHelper["Error"]);
                        }
                    }
                    if (args[0] == "id")
                    {
                        string mode = "";
                        if (args.Length > 2)
                            mode = args[2];
						ProtectionStatus.msgType msgType = ProtectionStatus.msgType.Normal;
						if (mode == "s") msgType = ProtectionStatus.msgType.Silent;
						else if (mode == "m") msgType = ProtectionStatus.msgType.OnlyTarget;

						ulong targetUID = 0;
						ulong.TryParse(args[1], out targetUID);
                        if (protData.ContainsKey(targetUID))
                        {
                            ReplyChat(player, string.Format(APHelper["DisabledTo"], protData[targetUID].Name));
							if (FindPlayerByID(targetUID).Count > 0)
								setMetabolizm(FindPlayerByID(targetUID).First(), false);
							protData.Remove(targetUID);
                        }
                        else
                        {
                            List<BasePlayer> bpList = FindPlayerByID(targetUID);
                            if (bpList.Count > 1)
                            {
                                ReplyChat(player, APHelper["TooMuch"]);
                                foreach (var item in bpList)
                                {
                                    ReplyChat(player, string.Format("<color=#81F23F>{0}</color>", item.displayName));
                                }
                            }
                            else if (bpList.Count == 1)
                            {
                                protData.Add(targetUID, new ProtectionStatus(msgType, bpList[0].displayName, player.displayName));
                                ReplyChat(player, string.Format(APHelper["EnabledTo"], bpList[0].displayName) + " " + mode);
                                setMetabolizm(bpList[0], true);
                            }
                        }
                    }
                }
                else
                {
                    if (protData.ContainsKey(userID))
                    {
                        ProtectionStatus protInfo = protData[userID];
						setMetabolizm(player, false);
						protData.Remove(userID);
                        ReplyChat(player, APHelper["Disabled"]);                            
                        
                    }
                    else
                    {
						ProtectionStatus.msgType msgType = ProtectionStatus.msgType.Normal;
						
						if (args.Length > 0 && args.Length < 2)
                        {
							if (args[0] == "s") msgType = ProtectionStatus.msgType.Silent;
							else if (args[0] == "m") msgType = ProtectionStatus.msgType.OnlyTarget;
						}
                        protData.Add(userID, new ProtectionStatus(msgType, player.displayName));
						setMetabolizm(player, true);
						if (msgType == ProtectionStatus.msgType.Normal)
                            ReplyChat(player, APHelper["Enabled"]);
                        else if (msgType == ProtectionStatus.msgType.Silent)
                            ReplyChat(player, APHelper["Enabled_s"]);
                        else
                            ReplyChat(player, APHelper["Enabled_m"]);
                    }
                }
            }
            SaveData();
        }
        void OnPlayerInit(BasePlayer player)
        {
            if (protData.ContainsKey(player.userID))
                setMetabolizm(player, true);
        }
        private List<BasePlayer> FindPlayerByName(string playerName = "")
        {
            // Check if a player name was supplied.
            if (playerName == "") return null;

            // Set the player name to lowercase to be able to search case insensitive.
            playerName = playerName.ToLower();

            // Setup some variables to save the matching BasePlayers with that partial
            // name.
            List<BasePlayer> matches = new List<BasePlayer>();

            // Iterate through the online player list and check for a match.
            foreach (var player in BasePlayer.activePlayerList)
            {
                // Get the player his/her display name and set it to lowercase.
                string displayName = player.displayName.ToLower();

                // Look for a match.
                if (displayName.Contains(playerName))
                {
                    matches.Add(player);
                }
            }

            // Return all the matching players.
            return matches;
        }
        private List<BasePlayer> FindPlayerByID(ulong playerID = 0)
        {
            // Check if a player name was supplied.
            if (playerID == 0) return null;

            // Setup some variables to save the matching BasePlayers with that partial
            // name.
            List<BasePlayer> matches = new List<BasePlayer>();

            // Iterate through the online player list and check for a match.
            foreach (var player in BasePlayer.activePlayerList)
            {
                // Get the player his/her display name and set it to lowercase.
                ulong onlineID = player.userID;

                // Look for a match.
                if (onlineID == playerID)
                {
                    matches.Add(player);
                }
            }

            // Return all the matching players.
            return matches;
        }

        private bool IsAllDigits(string s)
        {
            foreach (char c in s)
            {
                if (!Char.IsDigit(c))
                    return false;
            }
            return true;
        }

        void OnPlayerLoot(PlayerLoot lootInventory, UnityEngine.Object entry)
        {
            if (entry is BasePlayer)
            {
                BasePlayer looter = lootInventory.GetComponent("BasePlayer") as BasePlayer;
                BasePlayer target = entry as BasePlayer;
                if (target == null || looter == null) return;
                ulong userID = target.userID;
                if (protData.ContainsKey(userID))
                {
					NextTick(() =>
					{
                        looter.EndLooting();
                        looter.StartSleeping();
                    });
                    timer.Once(0.2f, () =>
                    {
                        looter.EndSleeping();
                    });
                    looter.ChatMessage(APHelper["LootAlert"]);
                }
            }
        }

        private HitInfo OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
        {
            if (entity is BasePlayer)
            {
                var player = entity as BasePlayer;
                if (protData.ContainsKey(player.userID))
                {
                    ProtectionStatus protInfo = protData[player.userID] as ProtectionStatus;
                    if (protInfo.isDebug) ReplyChat(player, "DMG done! By: " + hitInfo.Initiator.ToString());
                    if (hitInfo.Initiator is BasePlayer && protInfo.MsgType != ProtectionStatus.msgType.Silent && hitInfo.Initiator != player) // 
                    {
                        var attacker = hitInfo.Initiator as BasePlayer;

                        if (protInfo.isDebug) ReplyChat(player, "Player name: " + attacker.displayName);                     
                           
                        ulong attackerID = attacker.userID;
                        if (antiSpam.ContainsKey(attackerID))
                        {
                            if ((DateTime.Now - antiSpam[attackerID]).TotalSeconds > 30)
                            {
                                if (protInfo.MsgType != ProtectionStatus.msgType.OnlyTarget)
                                    attacker.ChatMessage(string.Format(APHelper["NoAPDamageAttacker"], player.displayName));
                                ReplyChat(player, string.Format(APHelper["NoAPDamagePlayer"], attacker.displayName));
                                antiSpam[attackerID] = DateTime.Now;
                            }
                        }
                        else
                        {
                            antiSpam.Add(attackerID, DateTime.Now);
							if (protInfo.MsgType != ProtectionStatus.msgType.OnlyTarget)
								attacker.ChatMessage(string.Format(APHelper["NoAPDamageAttacker"], player.displayName));
                            ReplyChat(player, string.Format(APHelper["NoAPDamagePlayer"], attacker.displayName));
                        }
                    }
                    if (protInfo.isDebug) ReplyChat(player, "DMG is 0 now");
                    hitInfo.damageTypes.ScaleAll(0f);
                    return hitInfo;
                    
                }
            }
            return null;
        }       

        void SendHelpText(BasePlayer player)
        {
            if (player.net.connection.authLevel > 0)
            {
                player.SendMessage(APHelper["HelpMessage"]);
            }
        }
        public class ProtectionStatus
        {
            public string Name = null;
            public msgType MsgType;
            public string Enabler = null;
            public bool isDebug = false;

			public HealthData HealthData;


			public ProtectionStatus()
			{

			}

			public ProtectionStatus(msgType msgType, string name, string admName = null, bool isdebug = false)
            {
				MsgType = msgType;
                Name = name;
                Enabler = admName;
                isDebug = isdebug;
            }

			public enum msgType
			{
				Normal, Silent, OnlyTarget
			}
        }

		public struct HealthData
		{
			public readonly float HP, Calories, Hydration;

			public HealthData(float hp, float cal, float hyd)
			{
				HP = hp;
				Calories = cal;
				Hydration = hyd;
			}
		}
    }

}

// --- End of file: AdminProtection.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/LotterySystem.cs ---
// --- Original Local Path: LotterySystem.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("LotterySystem", "Chibubrik", "1.1.1")]
    class LotterySystem : RustPlugin
    {
        #region Вар
        private string Layer = "LOTTERY_UI";
        private string Inventory = "INVENTORY_UI";

        [PluginReference] Plugin ImageLibrary;
        private Hash<ulong, PlayersSettings> Settings = new Hash<ulong, PlayersSettings>();
        #endregion

        #region Класс
        public class LotterySettings
        {
            [JsonProperty("ID предмета")] public string ID;
            [JsonProperty("Название предмета")] public string DisplayName;
            [JsonProperty("Короткое название предмета")] public string ShortName;
            [JsonProperty("SkinID предмета")] public ulong SkinID;
            [JsonProperty("Дополнительная команда")] public string Command;
            [JsonProperty("Сколько нужно одинаковых предметов, чтобы забрать из инвентаря?")] public int Amount;
            [JsonProperty("Количество")] public int Count;
            [JsonProperty("Изображение")] public string Url;
        }

        public class PlayersSettings
        {
            [JsonProperty("Сколько игрок открыл ячеек")] public int Count;
            [JsonProperty("Откат")] public double Time;
            [JsonProperty("Список предметов")] public Dictionary<string, InventorySettings> Inventory = new Dictionary<string, InventorySettings>();
        }

        public class InventorySettings
        {
            [JsonProperty("ID предмета")] public string ID;
            [JsonProperty("Название предмета")] public string DisplayName;
            [JsonProperty("Короткое название предмета")] public string ShortName;
            [JsonProperty("SkinID предмета")] public ulong SkinID;
            [JsonProperty("Дополнительная команда")] public string Command;
            [JsonProperty("Собранно одинаковых предметов")] public int Amount;
            [JsonProperty("Количество")] public int Count;
            [JsonProperty("Изображение")] public string Url;
        }
        #endregion

        #region Конфиг
        public Configuration config;
        public class Configuration
        {
            [JsonProperty("Название")] public string Name = "<b><size=30>ЕЖЕДНЕВНАЯ ЛОТЕРЕЯ</size></b>\nКаждые n времени у вас есть возможность забрать три вещи!";
            [JsonProperty("Откат на открытие ячеек(в секундах)")] public int Time = 1;
            [JsonProperty("Список призов")] public List<LotterySettings> Settings;
            public static Configuration GetNewConfig()
            {
                return new Configuration
                {
                    Settings  = new List<LotterySettings>
                    {
                        new LotterySettings
                        {
                            ID = "1",
                            DisplayName = "Дерево",
                            ShortName = "wood",
                            SkinID = 0,
                            Command = null,
                            Amount = 1,
                            Count = 1000,
                            Url = null
                        },  
                        new LotterySettings
                        {
                            ID = "2",
                            DisplayName = "Вип",
                            ShortName = null,
                            SkinID = 0,
                            Command = "123",
                            Amount = 50,
                            Count = 1,
                            Url = ""
                        },
                    }
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config?.Settings == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning($"Ошибка чтения конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!!");
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewConfig();
        protected override void SaveConfig() => Config.WriteObject(config);
        #endregion

        #region Хуки
        private void OnServerInitialized()
        {
            foreach (var check in config.Settings)
            {
                ImageLibrary.Call("AddImage", check.Url, check.Url);
            }

            foreach (var player in BasePlayer.activePlayerList)
                OnPlayerConnected(player);
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            var Data = Interface.Oxide.DataFileSystem.ReadObject<PlayersSettings>($"LotterySystem/{player.userID}");

            if (!Settings.ContainsKey(player.userID))
                Settings.Add(player.userID, new PlayersSettings());

            Settings[player.userID] = Data ?? new PlayersSettings();
        }

        private void SaveData(BasePlayer player) => SaveData(player.userID);
        private void SaveData(ulong userID)
        {
            Interface.Oxide.DataFileSystem.WriteObject($"LotterySystem/{userID}", Settings[userID]);
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            SaveData(player);
        }

        private InventorySettings GetItem(ulong userID, string name)
        {
            if (!Settings.ContainsKey(userID))
                Settings[userID].Inventory = new Dictionary<string, InventorySettings>();

            if (!Settings[userID].Inventory.ContainsKey(name))
                Settings[userID].Inventory[name] = new InventorySettings();

            return Settings[userID].Inventory[name];
        }

        private void AddItem(BasePlayer player, LotterySettings settings)
        {
            var data = GetItem(player.userID, settings.ID);
            data.ID = settings.ID;
            data.DisplayName = settings.DisplayName;
            data.ShortName = settings.ShortName;
            data.SkinID = settings.SkinID;
            data.Command = settings.Command;
            data.Amount += 1;
            data.Count = settings.Count;
            data.Url = settings.Url;
        }

        private void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, Layer);
                CuiHelper.DestroyUi(player, Inventory);
                SaveData(player);
            }
        }
        #endregion

        #region Команды
        [ChatCommand("lottery")]
        private void ChatLottery(BasePlayer player)
        {
            LotteryUI(player);
        }

        [ConsoleCommand("lottery")]
        private void ConsoleLottery(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            if (player != null && args.HasArgs(1))
            {
                if (args.Args[0] == "random")
                {
                    var time = CurrentTime();
                    if (Settings[player.userID].Time < time)
                    {
                        Settings[player.userID].Count += 1;
                        if (Settings[player.userID].Count <= 3)
                        {
                            var random = config.Settings.ToList().GetRandom();
                            PrizUI(player, args.Args[1], random);
                            AddItem(player, random);
                        }

                        if (Settings[player.userID].Count == 3)
                        {
                            Settings[player.userID].Time = time + config.Time;
                            Settings[player.userID].Count = 0;

                            CuiHelper.DestroyUi(player, "Time");
                            var container = new CuiElementContainer();

                            container.Add(new CuiButton
                            {
                                RectTransform = { AnchorMin = "0.44 0.245", AnchorMax = "0.56 0.267", OffsetMax = "0 0" },
                                Button = { Color = "0 0 0 0" },
                                Text = { Text = $"ПОДОЖДИТЕ {FormatShortTime(TimeSpan.FromSeconds(Settings[player.userID].Time - time))}", Color = "1 1 1 0.5", Align = TextAnchor.MiddleCenter, FontSize = 12, Font = "robotocondensed-regular.ttf" }
                            }, Layer, "Time");

                            CuiHelper.AddUi(player, container);
                        }
                    }
                }
                if (args.Args[0] == "take")
                {
                    var item = GetItem(player.userID, Settings[player.userID].Inventory.ElementAt(int.Parse(args.Args[1])).Key);
                    var check = config.Settings.FirstOrDefault(p => p.ID == item.ID);
                    if (item.Amount >= check.Amount)
                    {
                        if (!string.IsNullOrEmpty(item.Command))
                        {
                            Server.Command(item.Command.Replace("%STEAMID%", player.UserIDString));
                            SendReply(player, $"Вы получили услугу <color=#ee3e61>{item.DisplayName}</color>");
                        }
                        if (!string.IsNullOrEmpty(item.ShortName))
                        {
                            var items = ItemManager.CreateByName(item.ShortName, check.Count);
                            items.skin = item.SkinID;
                            player.inventory.GiveItem(items);
                            SendReply(player, $"Вы получили <color=#ee3e61>{item.DisplayName}</color>\nВ размере <color=#ee3e61>{check.Count}</color>");
                        }
                        item.Amount -= check.Amount;
                        if (item.Amount == 0)
                        {
                            Settings[player.userID].Inventory.Remove(check.ID);
                        }
                        InventoryUI(player);
                    }
                }
                if (args.Args[0] == "ui")
                {
                    LotteryUI(player);
                }
                if (args.Args[0] == "inventory")
                {
                    InventoryUI(player);
                }
            }
        }
        #endregion 

        #region Интерфейс
        private void LotteryUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, Layer);
            var container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0.9" },
            }, "Overlay", Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "-2 -2", AnchorMax = "2 2", OffsetMax = "0 0" },
                Button = { Color = "1 1 1 0.1", Close = Layer },
                Text = { Text = "" }
            }, Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0.86", AnchorMax = "1 1", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0" },
                Text = { Text = config.Name, Color = "1 1 1 0.5", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-regular.ttf", FadeIn = 0.5f }
            }, Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.5 0.32", AnchorMax = "0.502 0.85", OffsetMax = "0 0" },
                Button = { Color = "1 1 1 0.3" },
                Text = { Text = "", Color = "1 1 1 0.5", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-bold.ttf", FadeIn = 0.5f }
            }, Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.14 0.285", AnchorMax = "0.43 0.31", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0" },
                Text = { Text = "Вы должны выбрать три предмета!", Color = "1 1 1 0.5", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-regular.ttf", FadeIn = 0.5f }
            }, Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.44 0.27", AnchorMax = "0.56 0.31", OffsetMax = "0 0" },
                Button = { Color = "1 1 1 0.1", Command = "lottery inventory", Close = Layer },
                Text = { Text = "ОТКРЫТЬ ИНВЕНТАРЬ", Color = "1 1 1 0.5", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-bold.ttf", FadeIn = 0.5f }
            }, Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.6 0.285", AnchorMax = "0.85 0.31", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0" },
                Text = { Text = "Список возможных призов", Color = "1 1 1 0.5", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-regular.ttf", FadeIn = 0.5f }
            }, Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.53 0.32", AnchorMax = "0.92 0.85", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0" },
                Text = { Text = "", Color = "1 1 1 0.5", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-regular.ttf", FadeIn = 0.5f }
            }, Layer, "Items");

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.12 0.32", AnchorMax = "0.45 0.85", OffsetMax = "0 0" },
                Button = { Color = "0 0 0 0" },
                Text = { Text = "" }
            }, Layer, "Priz");

            if (Settings[player.userID].Time >= CurrentTime())
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.44 0.245", AnchorMax = "0.56 0.267", OffsetMax = "0 0" },
                    Button = { Color = "0 0 0 0" },
                    Text = { Text = $"ПОДОЖДИТЕ {FormatShortTime(TimeSpan.FromSeconds(Settings[player.userID].Time - CurrentTime()))}", Color = "1 1 1 0.5", Align = TextAnchor.MiddleCenter, FontSize = 12, Font = "robotocondensed-regular.ttf" }
                }, Layer, "Time");
            }

            float gap = 0f, width = 0.332f, height = 0.332f, startxBox = 0.003f, startyBox = 1f - height, xmin = startxBox, ymin = startyBox;
            for (int z = 0; z < 9; z++)
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"{xmin} {ymin}", AnchorMax = $"{xmin + width} {ymin + height * 1}", OffsetMin = "3 3", OffsetMax = "-3 -3" },
                    Button = { Color = "1 1 1 0.1" },
                    Text = { Text = $"" }
                }, "Priz", $"Button.{z}");
                xmin += width + gap;
                if (xmin + width >= 1)
                {
                    xmin = startxBox;
                    ymin -= height + gap;
                }

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                    Button = { Color = "0 0 0 0", Command = $"lottery random {z}" },
                    Text = { Text = $"✔", Color = "1 1 1 0.3", Align = TextAnchor.MiddleCenter, FontSize = 50, Font = "robotocondensed-bold.ttf" }
                }, $"Button.{z}", $"Gal.{z}");
            }

            float gap1 = 0f, width1 = 0.199f, height1 = 0.25f, startxBox1 = 0.003f, startyBox1 = 1f - height1, xmin1 = startxBox1, ymin1 = startyBox1;
            foreach (var check in config.Settings)
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"{xmin1} {ymin1}", AnchorMax = $"{xmin1 + width1} {ymin1 + height1 * 1}", OffsetMin = "2 2", OffsetMax = "-2 -2" },
                    Button = { Color = "1 1 1 0.1" },
                    Text = { Text = $"", Color = "1 1 1 0.3", Align = TextAnchor.MiddleCenter, FontSize = 50, Font = "robotocondensed-bold.ttf" }
                }, "Items", "Image");
                xmin1 += width1 + gap1;
                if (xmin1 + width1 >= 1)
                {
                    xmin1 = startxBox1;
                    ymin1 -= height1 + gap1;
                }

                var image = check.Url != null ? check.Url : check.ShortName;
                container.Add(new CuiElement
                {
                    Parent = "Image",
                    Components =
                    {
                        new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", image), FadeIn = 0.5f },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" }
                    }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                    Button = { Color = "0 0 0 0" },
                    Text = { Text = $"{check.Count}x ", Color = "1 1 1 0.3", Align = TextAnchor.LowerRight, FontSize = 16, Font = "robotocondensed-regular.ttf", FadeIn = 0.5f }
                }, "Image");
            }

            CuiHelper.AddUi(player, container);
        }

        private void PrizUI(BasePlayer player, string z, LotterySettings settings)
        {
            CuiHelper.DestroyUi(player, $"Gal.{z}");
            CuiElementContainer container = new CuiElementContainer();

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Button = { Color = "0.46 0.58 0.44 0.3" },
                Text = { Text = "" }
            }, $"Button.{z}", "Layers");

            var image = settings.Url != null ? settings.Url : settings.ShortName;
            container.Add(new CuiElement
            {
                Parent = "Layers",
                Components =
                {
                    new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", image), FadeIn = 2f},
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" }
                }
            });

            CuiHelper.AddUi(player, container);
        }

        private void InventoryUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, Inventory);
            CuiElementContainer container = new CuiElementContainer();
            int ItemCount = Settings[player.userID].Inventory.Count(), CountItem = 0, Count = 5;
            float Position = 0.5f, Width = 0.08f, Height = 0.13f, Margin = 0.005f, MinHeight = 0.645f;

            if (ItemCount >= Count) Position = 0.5f - Count / 2f * Width - (Count - 1) / 2f * Margin;
            else Position = 0.5f - ItemCount / 2f * Width - (ItemCount - 1) / 2f * Margin;
            ItemCount -= Count;

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0.9" },
            }, "Overlay", Inventory);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "-2 -2", AnchorMax = "2 2", OffsetMax = "0 0" },
                Button = { Color = "1 1 1 0.1", Close = Inventory },
                Text = { Text = "" }
            }, Inventory);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0.44 0.88", AnchorMax = "0.56 0.93", OffsetMax = "0 0" },
                Button = { Color = "1 1 1 0.1", Command = "lottery ui", Close = Inventory },
                Text = { Text = "ОТКРЫТЬ ЛОТЕРЕЮ", Color = "1 1 1 0.5", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-regular.ttf", FadeIn = 0.5f }
            }, Inventory);

            var list = Settings[player.userID].Inventory;
            for (int z = 0; z < list.Count(); z++)
            {
                var data = GetItem(player.userID, list.ElementAt(z).Key);
                var check = config.Settings.FirstOrDefault(x => x.ID == list.ElementAt(z).Key);

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"{Position} {MinHeight}", AnchorMax = $"{Position + Width} {MinHeight + Height}", OffsetMax = "0 0" },
                    Button = { Color = "1 1 1 0.1" },
                    Text = { Text = "" }
                }, Inventory, $"{z}");

                var image = data.Url != null ? data.Url : data.ShortName;
                container.Add(new CuiElement
                {
                    Parent = $"{z}",
                    Components =
                    {
                        new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", image) },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" }
                    }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = $"1 1", OffsetMax = "0 0" },
                    Button = { Color = "0 0 0 0" },
                    Text = { Text = $"{data.Amount}/{check.Amount} ", Color = "1 1 1 0.5", Font = "robotocondensed-regular.ttf", FontSize = 12, Align = TextAnchor.UpperRight }
                }, $"{z}");

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = $"1 1", OffsetMax = "0 0" },
                    Button = { Color = "0 0 0 0", Command = $"lottery take {z}" },
                    Text = { Text = $"X{data.Count} ", Color = "1 1 1 0.5", Font = "robotocondensed-regular.ttf", FontSize = 12, Align = TextAnchor.LowerRight }
                }, $"{z}");

                CountItem += 1;
                if (CountItem % Count == 0)
                {
                    if (ItemCount > Count)
                    {
                        Position = 0.5f - Count / 2f * Width - (Count - 1) / 2f * Margin;
                        ItemCount -= Count;
                    }
                    else
                    {
                        Position = 0.5f - ItemCount / 2f * Width - (ItemCount - 1) / 2f * Margin;
                    }
                    MinHeight -= ((Margin * 2) + Height);
                }
                else
                {
                    Position += (Width + Margin);
                }
            }

            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region Хелпер
        static double CurrentTime() => new TimeSpan(DateTime.UtcNow.Ticks).TotalSeconds;
        public static string FormatShortTime(TimeSpan time)
        {
            string result = string.Empty;
            result += $"{time.Hours.ToString("00")}:";
            result += $"{time.Minutes.ToString("00")}";
            return result;
        }
        #endregion
    }
}

// --- End of file: LotterySystem.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/DrawBridges.cs ---
// --- Original Local Path: DrawBridges.cs ---

using System;
using System.Linq;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Core.Configuration;
using Rust;
using Network;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("DrawBridges", "Colon Blow", "2.0.12")]
    public class DrawBridges : RustPlugin
    {

        // fixed sign being damaged

        [PluginReference]
        Plugin Clans;

        [PluginReference]
        Plugin Friends;

        BaseEntity newBridge;
        public static DrawBridges instance;

        static Dictionary<ulong, PlayerBridgeData> loadplayer = new Dictionary<ulong, PlayerBridgeData>();

        static List<uint> storedBridges = new List<uint>();
        private DynamicConfigFile data;
        private bool initialized;

        public class PlayerBridgeData
        {
            public BasePlayer player;
            public int bridgecount;
        }

        #region Configuration

        static bool UseSoundsEffects = true;
        bool UseMaxBridgeChecks = true;
        bool BlockBuildingOnBridge = true;
        bool AllowOnFloors = true;
        bool AllowOnFoundations = true;
        static bool UseFriendsChecks = false;
        static bool UseClansChecks = false;
        bool UseStabilityCheck = true;
        bool MasterBuilderFreedom = false;
        static bool UsePressurePlates = false;
        public int maxbridges = 2;
        public int maxvipbridges = 10;
        float userange = 20f;
        float rotaterange = 0.5f;
        float setramprange = 0.5f;
        float lockrange = 0.5f;
        float invertrange = 0.5f;
        float destroyrange = 0.5f;
        float minstability = 50f;
        bool Changed;

        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }

        void LoadDefaultConfig()
        {
            Puts("Creating a new config file");
            Config.Clear();
            LoadVariables();
        }

        private void LoadConfigVariables()
        {
            CheckCfg("Max Bridges : Normal Authenicated User : ", ref maxbridges);
            CheckCfg("Max Bridges : VIP Authenticated User : ", ref maxvipbridges);
            CheckCfgFloat("Range : Player will activate all bridges within this range : ", ref userange);
            CheckCfgFloat("Range : Player will rotate all bridges within this range : ", ref rotaterange);
            CheckCfgFloat("Range : Player will set ramp angle on all bridges within this range : ", ref setramprange);
            CheckCfgFloat("Range : Player will lock all bridges within this range : ", ref lockrange);
            CheckCfgFloat("Range : Player will invert all bridges within this range : ", ref lockrange);
            CheckCfgFloat("Range : Player will destroy all bridges within this range : ", ref destroyrange);
            CheckCfgFloat("Stability : Minimum Stability needed to place drawbrige on floor : ", ref minstability);
            CheckCfg("Usage - Use Bridge Sound Effects ? ", ref UseSoundsEffects);
            CheckCfg("Usage - Use Max Bridge Checks ? ", ref UseMaxBridgeChecks);
            CheckCfg("Usage - Use Stability Check when building ? ", ref UseStabilityCheck);
            CheckCfg("Usage - Allow Bridge to be built on Floors ? ", ref AllowOnFloors);
            CheckCfg("Usage - Allow Bridge to be built on Foundations ? ", ref AllowOnFoundations);
            CheckCfg("Usage - Use Friends to use Owners Bridges ? ", ref UseFriendsChecks);
            CheckCfg("Usage - Use Clan memebers to use Owners Bridges ? ", ref UseClansChecks);
            CheckCfg("Usage - Allow Master Builders to place bridge on ANY building block ? ", ref MasterBuilderFreedom);
            CheckCfg("Usage - Add Pressure Plate to bridge when building ? ", ref UsePressurePlates);
            CheckCfg("Usage - Block players from building on bridge floor itself ? ", ref BlockBuildingOnBridge);
        }

        private void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T)
                var = (T)Config[Key];
            else
                Config[Key] = var;
        }

        private void CheckCfgFloat(string Key, ref float var)
        {

            if (Config[Key] != null)
                var = Convert.ToSingle(Config[Key]);
            else
                Config[Key] = var;
        }

        object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }

        #endregion

        #region Localization

        string msg(string key, string playerId = null) => lang.GetMessage(key, this, playerId);

        Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            ["helptext1"] = "type <color=orange>/bridge.build</color> to build a bridge on floor/foundation you are looking at.",
            ["helptext2"] = "type <color=orange>/bridge.use</color>  to operate any of your bridges within range.",
            ["helptext3"] = "type <color=orange>/bridge.rotate</color>  to rotate bridge right 90 degrees.",
            ["helptext4"] = "type <color=orange>/bridge.invert</color>  to flip bridge to work upside down, master builders only",
            ["helptext5"] = "type <color=orange>/bridge.setplate</color>  to add/remove a pressure activation plate to the bridge",
            ["helptext0"] = "type <color=orange>/bridge.setpublicplate</color>  to add/remove a public activatoion plate to the bridge",
            ["helptext6"] = "type <color=orange>/bridge.setramp #</color>  , to set ramp a angle. example, /bridge.setramp 45",
            ["helptext7"] = "type <color=orange>/bridge.lock</color>  to lock/unlock bridge at current angle",
            ["helptext8"] = "type <color=orange>/bridge.count</color>  to show your current number of built bridges",
            ["helptext9"] = "type <color=orange>/bridge.destroy</color>  will destroy the bridge your standing on",
            ["notauthorized"] = "You are not authorized to use that command !!",
            ["notallowed"] = "You are allowed to build on top of a bridge !!",
            ["notabridge"] = "You can only place that on a bridge base block !!",
            ["notowner"] = "You have to be owner of block to use/bulid here !!",
            ["maxbridges"] = "You have reached your Maximum Bridge build limit !!",
            ["notcorrectblock"] = "You need to build a Bridge on a Floor or Foundation !!",
            ["notstable"] = "Need a more stable platform to build bridge on !!",
            ["alreadybridge"] = "That Block already has a Bridge on it !!",
            ["alreadytrigger"] = "That Block already has a Trigger on it !!",
            ["notaangle"] = "Ramp Angle incorrect, please try again !!",
            ["bridgelocked"] = "Bridge is now locked in place !!",
            ["bridgeunlocked"] = "Bridge has been unlocked !!",
            ["notowner"] = "You must be owner of bridge to use this!!!"
        };

        #endregion

        #region Hooks

        void Loaded()
        {
            LoadVariables();
            permission.RegisterPermission("drawbridges.builder", this);
            permission.RegisterPermission("drawbridges.buildervip", this);
            permission.RegisterPermission("drawbridges.masterbuilder", this);
            lang.RegisterMessages(Messages, this);
            data = Interface.Oxide.DataFileSystem.GetFile("bridge_data");
        }

        private void OnServerInitialized()
        {
            instance = this;
            initialized = true;
            LoadData();
            timer.In(3, RestoreBridges);
        }
        private void OnServerSave()
        {
            if (storedBridges.Count > 0) SaveData();
        }

        void Unload()
        {
            DestroyAll<BridgeEntity>();
        }

        private void RestoreBridges()
        {
            if (storedBridges.Count > 0)
            {
                BaseEntity[] objects = BaseEntity.saveList.Where(x => x is BaseEntity).ToArray();
                if (objects != null)
                {
                    foreach (var obj in objects)
                    {
                        if (!obj.IsValid() || obj.IsDestroyed)
                            continue;

                        if (storedBridges.Contains(obj.net.ID))
                        {
                            var userid = obj.OwnerID;
                            var addbridge = obj.gameObject.AddComponent<BridgeEntity>();
                            if (obj.GetComponent<BaseEntity>().skinID == 1) addbridge.SpawnPressurePlate();
                            if (obj.GetComponent<BaseEntity>().skinID == 2) addbridge.SpawnPublicPressurePlate();
                            AddPlayerID(userid);
                        }
                    }
                }
            }
        }

        void SaveData() => data.WriteObject(storedBridges.ToList());
        void LoadData()
        {
            try
            {
                storedBridges = data.ReadObject<List<uint>>();
            }
            catch
            {
                storedBridges = new List<uint>();
            }
        }

        bool isAllowed(BasePlayer player, string perm) => permission.UserHasPermission(player.UserIDString, perm);

        bool isCorrectBlock(BaseEntity entity, BasePlayer player)
        {
            if (!entity is BuildingBlock) return false;
            if (MasterBuilderFreedom && isAllowed(player, "bridge.masterbuilder")) return true;
            if (AllowOnFloors && entity.name.Contains("floor/floor")) return true;
            if (AllowOnFoundations && entity.name.Contains("foundation/foundation")) return true;
            return false;
        }

        bool BridgeLimitReached(BasePlayer player)
        {
            if (UseMaxBridgeChecks)
            {
                if (isAllowed(player, "bridge.masterbuilder")) return false;
                if (loadplayer.ContainsKey(player.userID))
                {
                    var currentcount = loadplayer[player.userID].bridgecount;
                    var maxallowed = maxbridges;
                    if (isAllowed(player, "bridge.buildervip")) maxallowed = maxvipbridges;
                    if (currentcount >= maxallowed) return true;
                }
            }
            return false;
        }

        private bool IsFriend(ulong playerid, ulong friendid)
        {
            var Friends = plugins.Find("Friends");
            bool areFriends = Convert.ToBoolean(Friends?.Call("HasFriend", playerid, friendid));
            return areFriends;
        }

        private bool IsClanmate(ulong playerid, ulong friendid)
        {
            var Clans = plugins.Find("Clans");
            var ownersClan = (string)Clans.Call("GetClanOf", playerid);
            var usersClan = (string)Clans.Call("GetClanOf", friendid);
            if (ownersClan == null || usersClan == null || !ownersClan.Equals(usersClan)) return false;
            return true;
        }

        public void BuildBridge(BasePlayer player)
        {
            RaycastHit hit;
            if (Physics.Raycast(player.eyes.HeadRay(), out hit, Mathf.Infinity)) newBridge = hit.GetTransform().gameObject.ToBaseEntity();
            if (newBridge == null) return;
            bool isbuildingblock = newBridge?.GetComponent<BuildingBlock>();
            if (!isbuildingblock) return;
            if (newBridge.OwnerID != player.userID) { SendReply(player, msg("notowner", player.UserIDString)); return; }
            if (isCorrectBlock(newBridge, player))
            {
                var hasbridge = newBridge.GetComponentInParent<BridgeEntity>();
                if (hasbridge) { SendReply(player, msg("alreadybridge", player.UserIDString)); return; }
                if (UseStabilityCheck)
                {
                    var stabent = newBridge.GetComponent<StabilityEntity>();
                    var stabvalue = stabent.SupportValue() * 100;
                    if (stabvalue < minstability) { SendReply(player, msg("notstable", player.UserIDString)); return; }
                }
                var addbridge = newBridge.gameObject.AddComponent<BridgeEntity>();
                newBridge.OwnerID = player.userID;
                AddPlayerID(player.userID);
                storedBridges.Add(newBridge.net.ID);
                SaveData();
                return;
            }
            SendReply(player, msg("notcorrectblock", player.UserIDString));
        }


        void DeployPressurePlate(BasePlayer player)
        {
            List<BaseEntity> bridgelist = new List<BaseEntity>();
            Vis.Entities<BaseEntity>(player.transform.position, setramprange, bridgelist);

            foreach (BaseEntity p in bridgelist)
            {
                var foundent = p.GetComponentInParent<BridgeEntity>();
                if (foundent)
                {
                    var entity = p.GetComponentInParent<BaseEntity>();
                    if (entity.OwnerID != player.userID) { SendReply(player, msg("notowner", player.UserIDString)); return; }
                    foundent.TogglePressurePlate();
                }
            }
        }

        void DeployPublicPressurePlate(BasePlayer player)
        {
            List<BaseEntity> bridgelist = new List<BaseEntity>();
            Vis.Entities<BaseEntity>(player.transform.position, setramprange, bridgelist);

            foreach (BaseEntity p in bridgelist)
            {
                var foundent = p.GetComponentInParent<BridgeEntity>();
                if (foundent)
                {
                    var entity = p.GetComponentInParent<BaseEntity>();
                    if (entity.OwnerID != player.userID) { SendReply(player, msg("notowner", player.UserIDString)); return; }
                    foundent.TogglePublicPressurePlate();
                }
            }
        }

        object CanBuild(Planner plan, Construction prefab, object obj)
        {
            if (!BlockBuildingOnBridge) return null;
            if (plan == null || prefab == null || obj == null) return null;
            if (obj is Construction.Target)
            {
                var target = (Construction.Target)obj;
                var targetent = target.entity as BaseEntity;
                var isbridge = targetent?.GetComponentInParent<BridgeEntity>();
                if (isbridge)
                {
                    if (targetent == isbridge.floor2) return false;
                    if (targetent == isbridge.floor1) return false;
                }
                return null;
            }
            else return null;
        }

        private object OnEntityGroundMissing(BaseEntity entity)
        {
            var bridge = entity.GetComponentInParent<BridgeEntity>();
            if (bridge != null) return false;
            return null;
        }

        private void OnEntityKill(BaseNetworkable networkable)
        {
            var bridge = networkable.GetComponentInParent<BridgeEntity>();
            if (bridge != null && storedBridges.Contains(networkable.net.ID))
            {
                storedBridges.Remove(networkable.net.ID);
                SaveData();
            }
        }

        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
        {
            if (entity == null) return;
            var isbridge = entity.GetComponentInParent<BridgeEntity>() ?? null;
            if (isbridge && entity.name.Contains("assets/prefabs/deployable/signs/sign.small.wood.prefab"))
            {
                hitInfo.damageTypes.ScaleAll(0);
            }
            return;
        }

        object OnPlayerViolation(BasePlayer player, AntiHackType type, float amount)
        {
            if (player == null) return null;
            if (StandingOnBridge(player)) return false;
            return null;
        }

        bool StandingOnBridge(BasePlayer player)
        {
            List<BaseEntity> bridgelist = new List<BaseEntity>();
            Vis.Entities<BaseEntity>(player.transform.position, 3f, bridgelist);
            foreach (BaseEntity p in bridgelist)
            {
                var foundent = p.GetComponentInParent<BridgeEntity>();
                if (foundent) return true;
            }
            return false;
        }

        void UseLocalBridge(BasePlayer player, bool setangle, float rotationx)
        {
            List<BaseEntity> bridgelist = new List<BaseEntity>();
            Vis.Entities<BaseEntity>(player.transform.position, userange, bridgelist);

            foreach (BaseEntity p in bridgelist)
            {
                var foundent = p.GetComponentInParent<BridgeEntity>();
                if (foundent)
                {
                    var entity = p.GetComponentInParent<BaseEntity>();
                    if (UseFriendsChecks && IsFriend(entity.OwnerID, player.userID)) foundent.Activate(setangle, rotationx);
                    if (UseClansChecks && IsClanmate(entity.OwnerID, player.userID)) foundent.Activate(setangle, rotationx);
                    if (player.userID == entity.OwnerID) foundent.Activate(setangle, rotationx);
                }
            }
        }

        void SetRampLocalBridge(BasePlayer player, bool setangle, float rotationx)
        {
            List<BaseEntity> bridgelist = new List<BaseEntity>();
            Vis.Entities<BaseEntity>(player.transform.position, setramprange, bridgelist);

            foreach (BaseEntity p in bridgelist)
            {
                var foundent = p.GetComponentInParent<BridgeEntity>();
                if (foundent)
                {
                    var entity = p.GetComponentInParent<BaseEntity>();
                    if (entity.OwnerID != player.userID) { SendReply(player, msg("notowner", player.UserIDString)); return; }
                    foundent.Activate(setangle, rotationx);
                }
            }
        }

        void RotateLocalBridge(BasePlayer player)
        {
            List<BaseEntity> bridgelist = new List<BaseEntity>();
            Vis.Entities<BaseEntity>(player.transform.position, rotaterange, bridgelist);

            foreach (BaseEntity p in bridgelist)
            {
                var foundent = p.GetComponentInParent<BridgeEntity>();
                if (foundent)
                {
                    var entity = foundent.GetComponentInParent<BuildingBlock>();
                    if (entity.OwnerID != player.userID) { SendReply(player, msg("notowner", player.UserIDString)); return; }
                    Vector3 newentrot = new Vector3(entity.transform.eulerAngles.x, entity.transform.eulerAngles.y + 90, entity.transform.eulerAngles.z);
                    entity.transform.eulerAngles = newentrot;
                    entity.GetComponent<BaseEntity>().transform.hasChanged = true;
                    entity.GetComponent<BaseEntity>().SendNetworkUpdateImmediate();
                    entity.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                    entity.UpdateSkin();
                    entity.ClientRPC(null, "RefreshSkin");
                    foundent.RefreshFloor();
                }
            }
        }

        void InvertLocalBridge(BasePlayer player)
        {
            List<BaseEntity> bridgelist = new List<BaseEntity>();
            Vis.Entities<BaseEntity>(player.transform.position, invertrange, bridgelist);

            foreach (BaseEntity p in bridgelist)
            {
                var foundent = p.GetComponentInParent<BridgeEntity>();
                if (foundent)
                {
                    var entity = foundent.GetComponentInParent<BuildingBlock>();
                    if (entity.OwnerID != player.userID) { SendReply(player, msg("notowner", player.UserIDString)); return; }
                    Vector3 newentrot = new Vector3(entity.transform.eulerAngles.x + 180, entity.transform.eulerAngles.y, entity.transform.eulerAngles.z);
                    entity.transform.eulerAngles = newentrot;
                    entity.GetComponent<BaseEntity>().transform.hasChanged = true;
                    entity.GetComponent<BaseEntity>().SendNetworkUpdateImmediate();
                    entity.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                    entity.UpdateSkin();
                    entity.ClientRPC(null, "RefreshSkin");
                    foundent.RefreshFloor();
                }
            }
        }


        void LockLocalBridge(BasePlayer player)
        {
            List<BaseEntity> bridgelist = new List<BaseEntity>();
            Vis.Entities<BaseEntity>(player.transform.position, lockrange, bridgelist);

            foreach (BaseEntity p in bridgelist)
            {
                var foundent = p.GetComponentInParent<BridgeEntity>();
                if (foundent)
                {
                    var bridgelocked = foundent.islocked;
                    var entity = p.GetComponentInParent<BaseEntity>();
                    if (entity.OwnerID != player.userID) { SendReply(player, msg("notowner", player.UserIDString)); return; }
                    if (bridgelocked) { foundent.islocked = false; SendReply(player, msg("bridgeunlocked", player.UserIDString)); return; }
                    else { foundent.islocked = true; SendReply(player, msg("bridgelocked", player.UserIDString)); return; }
                }
            }
        }

        void DestroyLocalBridge(BasePlayer player)
        {
            List<BaseEntity> bridgelist = new List<BaseEntity>();
            Vis.Entities<BaseEntity>(player.transform.position, destroyrange, bridgelist);

            foreach (BaseEntity p in bridgelist)
            {
                var foundent = p.GetComponentInParent<BridgeEntity>();
                if (foundent)
                {
                    var entity = p.GetComponentInParent<BaseEntity>();
                    if (entity.OwnerID != player.userID) { SendReply(player, msg("notowner", player.UserIDString)); return; }
                    entity.Invoke("KillMessage", 0.1f);
                }
            }
        }

        void AddPlayerID(ulong ownerid)
        {
            if (!loadplayer.ContainsKey(ownerid))
            {
                loadplayer.Add(ownerid, new PlayerBridgeData
                {
                    bridgecount = 1
                });
                return;
            }
            loadplayer[ownerid].bridgecount = loadplayer[ownerid].bridgecount + 1;
        }

        void RemovePlayerID(ulong ownerid)
        {
            if (loadplayer.ContainsKey(ownerid)) loadplayer[ownerid].bridgecount = loadplayer[ownerid].bridgecount - 1;
            return;
        }

        static void DestroyAll<T>()
        {
            var objects = GameObject.FindObjectsOfType(typeof(T));
            if (objects != null)
                foreach (var gameObj in objects)
                    GameObject.Destroy(gameObj);
        }

        #endregion

        #region Commands

        [ChatCommand("bridge.help")]
        void cmdBridgeHelp(BasePlayer player, string command, string[] args)
        {
            if (isAllowed(player, "bridge.builder") || isAllowed(player, "bridge.buildervip") || isAllowed(player, "bridge.masterbuilder"))
            {
                SendReply(player, msg("helptext1", player.UserIDString));
                SendReply(player, msg("helptext2", player.UserIDString));
                SendReply(player, msg("helptext3", player.UserIDString));
                SendReply(player, msg("helptext4", player.UserIDString));
                SendReply(player, msg("helptext5", player.UserIDString));
                SendReply(player, msg("helptext0", player.UserIDString));
                SendReply(player, msg("helptext6", player.UserIDString));
                SendReply(player, msg("helptext7", player.UserIDString));
                SendReply(player, msg("helptext8", player.UserIDString));
                SendReply(player, msg("helptext9", player.UserIDString));
                return;
            }
            SendReply(player, msg("notauthorized", player.UserIDString));
        }

        [ChatCommand("bridge.build")]
        void cmdBridgeBuild(BasePlayer player, string command, string[] args)
        {
            if (!player.CanBuild()) return;
            if (isAllowed(player, "bridge.builder") || isAllowed(player, "bridge.buildervip") || isAllowed(player, "bridge.masterbuilder"))
            {
                if (BridgeLimitReached(player)) { SendReply(player, msg("maxbridges", player.UserIDString)); return; }
                BuildBridge(player);
                return;
            }
            SendReply(player, msg("notauthorized", player.UserIDString));
        }

        [ChatCommand("bridge.use")]
        void cmdBridgeUse(BasePlayer player, string command, string[] args)
        {
            if (!player.CanBuild()) return;
            if (isAllowed(player, "bridge.builder") || isAllowed(player, "bridge.buildervip") || isAllowed(player, "bridge.masterbuilder"))
            {
                UseLocalBridge(player, false, 0f);
                return;
            }
            SendReply(player, msg("notauthorized", player.UserIDString));
        }


        [ChatCommand("bridge.setplate")]
        void cmdSetPressurePlate(BasePlayer player, string command, string[] args)
        {
            if (!player.CanBuild()) return;
            if (isAllowed(player, "bridge.builder") || isAllowed(player, "bridge.buildervip") || isAllowed(player, "bridge.masterbuilder"))
            {
                DeployPressurePlate(player);
                return;
            }
            SendReply(player, msg("notauthorized", player.UserIDString));
        }

        [ChatCommand("bridge.setpublicplate")]
        void cmdSetPublicPressurePlate(BasePlayer player, string command, string[] args)
        {
            if (!player.CanBuild()) return;
            if (isAllowed(player, "bridge.builder") || isAllowed(player, "bridge.buildervip") || isAllowed(player, "bridge.masterbuilder"))
            {
                DeployPublicPressurePlate(player);
                return;
            }
            SendReply(player, msg("notauthorized", player.UserIDString));
        }

        [ChatCommand("bridge.setramp")]
        void cmdBridgeSetRamp(BasePlayer player, string command, string[] args)
        {
            if (!player.CanBuild()) return;
            if (!isAllowed(player, "bridge.masterbuilder")) { SendReply(player, msg("notauthorized", player.UserIDString)); return; }
            var str0 = "0";
            if (args != null && args.Length > 0)
            {
                float rotationx;
                if (float.TryParse(args[0].ToLower(), out rotationx))
                {
                    SetRampLocalBridge(player, true, rotationx);
                    return;
                }
                SendReply(player, msg("notaangle", player.UserIDString));
            }
        }

        [ChatCommand("bridge.lock")]
        void cmdBridgeLock(BasePlayer player, string command, string[] args)
        {
            if (!player.CanBuild()) return;
            if (isAllowed(player, "bridge.builder") || isAllowed(player, "bridge.buildervip") || isAllowed(player, "bridge.masterbuilder"))
            {
                LockLocalBridge(player);
                return;
            }
            SendReply(player, msg("notauthorized", player.UserIDString));
        }

        [ChatCommand("bridge.invert")]
        void cmdBridgeInvert(BasePlayer player, string command, string[] args)
        {
            if (!player.CanBuild()) return;
            if (!isAllowed(player, "bridge.masterbuilder")) { SendReply(player, msg("notauthorized", player.UserIDString)); return; }
            InvertLocalBridge(player);
        }

        [ChatCommand("bridge.rotate")]
        void cmdBridgeRotate(BasePlayer player, string command, string[] args)
        {
            if (!player.CanBuild()) return; ;
            if (isAllowed(player, "bridge.builder") || isAllowed(player, "bridge.buildervip") || isAllowed(player, "bridge.masterbuilder"))
            {
                RotateLocalBridge(player);
                return;
            }
            SendReply(player, msg("notauthorized", player.UserIDString));
        }

        [ChatCommand("bridge.destroy")]
        void cmdBridgeDestroy(BasePlayer player, string command, string[] args)
        {
            if (isAllowed(player, "bridge.builder") || isAllowed(player, "bridge.buildervip") || isAllowed(player, "bridge.masterbuilder"))
            {
                DestroyLocalBridge(player);
                return;
            }
            SendReply(player, msg("notauthorized", player.UserIDString));
        }

        [ChatCommand("bridge.count")]
        void cmdChatBridgeCount(BasePlayer player, string command, string[] args)
        {
            if (!loadplayer.ContainsKey(player.userID))
            {
                SendReply(player, "You have no Bridges");
                return;
            }
            SendReply(player, "Current Bridges : " + (loadplayer[player.userID].bridgecount));
        }

        #endregion

        #region Bridge Entity

        class BridgeEntity : BaseEntity
        {
            BaseEntity entity;
            public BaseEntity floor1;
            public BaseEntity floor2;
            public BaseEntity hinge;
            BaseEntity plate;
            BaseEntity pplate;
            BuildingBlock floor1block;
            BuildingBlock floor2block;
            BuildingBlock blockentity;
            Vector3 entitypos;
            Quaternion entityrot;
            bool isup;
            public bool isfloor;
            public bool islocked;
            ulong ownerid;
            float secsToTake;
            float secsTaken;
            Vector3 startRot;
            Vector3 endRot;
            public bool isRotating;
            bool triggered;
            int counter;
            SphereCollider sphereCollider;

            string prefabfloor = "assets/prefabs/building core/floor/floor.prefab";
            string prefabhinge = "assets/prefabs/deployable/signs/sign.small.wood.prefab";
            string prefabwall = "assets/prefabs/building core/wall/wall.prefab";

            void Awake()
            {
                entity = GetComponentInParent<BaseEntity>();
                ownerid = entity.OwnerID;
                blockentity = entity.GetComponent<BuildingBlock>();
                entitypos = entity.transform.position;
                entityrot = Quaternion.identity;
                triggered = false;

                isup = true;
                isfloor = true;
                islocked = false;
                isRotating = false;
                counter = 0;
                secsToTake = 0.25f;
                SpawnPos();
                if (UsePressurePlates) SpawnPressurePlate();
                startRot = new Vector3(0f, hinge.transform.localEulerAngles.y, hinge.transform.localEulerAngles.z);
                endRot = new Vector3(90f, hinge.transform.localEulerAngles.y, hinge.transform.localEulerAngles.z);
                isRotating = false;
                RefreshFloor();
            }

            public void Activate(bool setangle, float rotationx)
            {
                if (islocked) return;
                if (!setangle && isup) { ActivateDown(90f); return; }
                if (!setangle && !isup) { ActivateUp(0f); return; }
                if (setangle) { ActivateDown(rotationx); return; }
                else ActivateUp(0f);
            }

            public void ActivateDown(float rotationx)
            {
                if (isRotating) return;
                startRot = hinge.transform.localEulerAngles;
                endRot = new Vector3(rotationx, startRot.y, startRot.z);
                isRotating = true;
                isup = false;
            }

            public void ActivateUp(float rotationx)
            {
                if (isRotating) return;
                startRot = hinge.transform.localEulerAngles;
                endRot = new Vector3(rotationx, startRot.y, startRot.z);
                isRotating = true;
                isup = true;
            }

            void SpawnPos()
            {
                BuildingBlock entityblock = entity.GetComponent<BuildingBlock>();
                var entitygrade = entityblock.grade;

                hinge = GameManager.server.CreateEntity(prefabhinge, entitypos, entityrot, true);
                hinge.enableSaving = false;
                hinge.transform.localEulerAngles = new Vector3(0, 0, 0);
                hinge.transform.localPosition = new Vector3(0f, 0f, 1.5f);
                hinge?.Spawn();
                hinge.SetParent(entity);
                hinge.SetFlag(BaseEntity.Flags.Busy, true, true);

                if (isfloor)
                {
                    floor1 = GameManager.server.CreateEntity(prefabfloor, entitypos, entityrot, true);
                    floor1.enableSaving = false;
                    floor1.transform.localEulerAngles = new Vector3(270, 0, 0);
                    floor1.transform.localPosition = new Vector3(0f, 1.5f, 0f);
                }
                else if (!isfloor)
                {
                    floor1 = GameManager.server.CreateEntity(prefabwall, entitypos, entityrot, true);
                    floor1.enableSaving = false;
                    floor1.transform.localEulerAngles = new Vector3(270, 270, 0);
                    floor1.transform.localPosition = new Vector3(-1.5f, 1.5f, 0f);
                }
                floor1.GetComponent<StabilityEntity>().grounded = true;
                floor1block = floor1.GetComponent<BuildingBlock>();
                floor1block.GetComponent<BaseEntity>().OwnerID = ownerid;
                floor1block?.Spawn();
                floor1block.SetParent(hinge);
                floor1block.SetGrade((BuildingGrade.Enum)entitygrade);
                SpawnRefresh(floor1block);

                if (isfloor)
                {
                    floor2 = GameManager.server.CreateEntity(prefabfloor, entitypos, entityrot, true);
                    floor2.enableSaving = false;
                    floor2.transform.localEulerAngles = new Vector3(0, 0, 0);
                    floor2.transform.localPosition = new Vector3(0f, 0f, 3f);
                }
                else if (!isfloor)
                {
                    floor2 = GameManager.server.CreateEntity(prefabwall, entitypos, entityrot, true);
                    floor2.enableSaving = false;
                    floor2.transform.localEulerAngles = new Vector3(0, 0, 0);
                    floor2.transform.localPosition = new Vector3(0f, 0f, 3f);
                }

                floor2.GetComponent<StabilityEntity>().grounded = true;
                floor2block = floor2.GetComponent<BuildingBlock>();
                floor2block.GetComponent<BaseEntity>().OwnerID = ownerid;
                floor2block?.Spawn();
                floor2block.SetParent(floor1);
                floor2block.SetGrade((BuildingGrade.Enum)entitygrade);
                SpawnRefresh(floor2block);


                isup = true;
            }

            void SpawnRefresh(BaseNetworkable entity1)
            {
                var hasstab = entity1.GetComponent<StabilityEntity>();
                if (hasstab)
                {
                    hasstab.grounded = true;
                }
                var hasblock = entity1.GetComponent<BuildingBlock>();
                if (hasblock)
                {
                    hasblock.SetHealthToMax();
                    hasblock.UpdateSkin();
                    hasblock.ClientRPC(null, "RefreshSkin");
                }
                entity1.SendNetworkUpdateImmediate();
            }

            void ClntDstry(BaseNetworkable entity, bool recursive = true)
            {
                if (Net.sv.write.Start())
                {
                    Net.sv.write.PacketID(Message.Type.EntityDestroy);
                    Net.sv.write.UInt32(entity.net.ID);
                    Net.sv.write.UInt8(0);
                    Net.sv.write.Send(new SendInfo(entity.net.group.subscribers));
                }
                if (recursive && entity.children != null) for (int i = 0; i < entity.children.Count; i++) ClntDstry(entity.children[i], false);
            }

            void EnttSnpsht(BaseNetworkable entity, bool recursive = true)
            {
                entity.InvalidateNetworkCache(); List<Connection> subscribers = entity.net.group == null ? Net.sv.connections : entity.net.group.subscribers; if (subscribers != null && subscribers.Count > 0) { for (int i = 0; i < subscribers.Count; i++) { Connection connection = subscribers[i]; BasePlayer basePlayer = connection.player as BasePlayer; if (!(basePlayer == null)) { if (Net.sv.write.Start()) { connection.validate.entityUpdates = connection.validate.entityUpdates + 1u; BaseNetworkable.SaveInfo saveInfo = new BaseNetworkable.SaveInfo { forConnection = connection, forDisk = false }; Net.sv.write.PacketID(Message.Type.Entities); Net.sv.write.UInt32(connection.validate.entityUpdates); entity.ToStreamForNetwork(Net.sv.write, saveInfo); Net.sv.write.Send(new SendInfo(connection)); } } } }
                if (recursive && entity.children != null) for (int i = 0; i < entity.children.Count; i++) EnttSnpsht(entity.children[i], false);
            }

            public void RefreshFloor()
            {
                BuildingBlock entityblock = entity.GetComponent<BuildingBlock>();
                var entitygrade = entityblock.grade;

                if (hinge != null) hinge.transform.hasChanged = true;
                if (hinge != null) ClntDstry(hinge, false); EnttSnpsht(hinge, false);
                if (hinge != null) hinge.SendNetworkUpdateImmediate();
                if (hinge != null) hinge.UpdateNetworkGroup();
                if (hinge != null) hinge.GetComponent<DestroyOnGroundMissing>().enabled = false;
                if (hinge != null) hinge.GetComponent<GroundWatch>().enabled = false;

                if (floor1block != null) floor1.transform.hasChanged = true;
                if (floor1block != null) ClntDstry(floor1block, false); EnttSnpsht(floor1block, false);
                if (floor1block != null) floor1block.SetGrade((BuildingGrade.Enum)entitygrade);
                if (floor1block != null) floor1.SendNetworkUpdateImmediate();
                if (floor1block != null) floor1.UpdateNetworkGroup();
                if (floor1block != null) floor1.GetComponent<BuildingBlock>().UpdateSkin();
                if (floor1block != null) floor1.GetComponent<BuildingBlock>().ClientRPC(null, "RefreshSkin");

                if (floor2block != null) floor2.transform.hasChanged = true;
                if (floor2block != null) ClntDstry(floor2block, false); EnttSnpsht(floor2block, false);
                if (floor2block != null) floor2block.SetGrade((BuildingGrade.Enum)entitygrade);
                if (floor2block != null) floor2.SendNetworkUpdateImmediate();
                if (floor2block != null) floor2.UpdateNetworkGroup();
                if (floor2block != null) floor2block.UpdateSkin();
                if (floor2block != null) floor2block.GetComponent<BuildingBlock>().ClientRPC(null, "RefreshSkin");
            }

            void ResetAnimationSound()
            {
                if (counter == 1)
                {
                    Effect.server.Run("assets/prefabs/deployable/recycler/effects/start.prefab", floor1block.transform.position);
                }
                counter = counter + 1;
                if (counter == 4) counter = 0;
            }

            public void SpawnPressurePlate()
            {
                string prefabpressureplate = "assets/prefabs/deployable/landmine/landmine.prefab";
                plate = GameManager.server.CreateEntity(prefabpressureplate, entitypos, entityrot, false);
                plate.enableSaving = false;
                plate.SetFlag(BaseEntity.Flags.Reserved5, false, false);
                plate.transform.localEulerAngles = new Vector3(0, 0, 0);
                plate.transform.localPosition = new Vector3(0f, 0.03f, 0f);
                plate?.Spawn();
                plate.SetParent(entity);

                entity.skinID = 1;

                sphereCollider = gameObject.AddComponent<SphereCollider>();
                sphereCollider.gameObject.layer = (int)Layer.Reserved1;
                sphereCollider.isTrigger = true;
                sphereCollider.radius = 0.2f;
            }

            public void SpawnPublicPressurePlate()
            {
                string prefabpressureplate = "assets/prefabs/deployable/landmine/landmine.prefab";
                pplate = GameManager.server.CreateEntity(prefabpressureplate, entitypos, entityrot, false);
                pplate.enableSaving = false;
                pplate.SetFlag(BaseEntity.Flags.Reserved5, false, false);
                pplate.transform.localEulerAngles = new Vector3(0, 0, 0);
                pplate.transform.localPosition = new Vector3(0f, 0.03f, 0f);
                pplate?.Spawn();
                pplate.SetParent(entity);

                entity.skinID = 2;

                sphereCollider = gameObject.AddComponent<SphereCollider>();
                sphereCollider.gameObject.layer = (int)Layer.Reserved1;
                sphereCollider.isTrigger = true;
                sphereCollider.radius = 0.2f;
            }

            public void TogglePressurePlate()
            {
                if (plate != null) { plate.Invoke("KillMessage", 0.1f); GameObject.Destroy(sphereCollider); return; }
                if (pplate != null) { pplate.Invoke("KillMessage", 0.1f); GameObject.Destroy(sphereCollider); }
                SpawnPressurePlate();
            }

            public void TogglePublicPressurePlate()
            {
                if (pplate != null) { pplate.Invoke("KillMessage", 0.1f); GameObject.Destroy(sphereCollider); return; }
                if (plate != null) { plate.Invoke("KillMessage", 0.1f); GameObject.Destroy(sphereCollider); }
                SpawnPublicPressurePlate();
            }

            private void OnTriggerEnter(Collider col)
            {
                var target = col.GetComponentInParent<BasePlayer>();
                if (pplate != null) Activate(false, 0f);
                if (!triggered && target != null)
                {
                    if (UseFriendsChecks && instance.IsFriend(ownerid, target.userID)) { Activate(false, 0f); return; }
                    if (UseClansChecks && instance.IsClanmate(ownerid, target.userID)) { Activate(false, 0f); return; }
                    if (target.userID == ownerid) Activate(false, 0f);
                }
            }

            void FixedUpdate()
            {
                if (hinge == null || floor1 == null) { entity.Invoke("KillMessage", 0.1f); return; }
                if (!isRotating) return;
                secsTaken = secsTaken + UnityEngine.Time.deltaTime;
                if (UseSoundsEffects) ResetAnimationSound();
                float single = Mathf.InverseLerp(0f, 5f, secsTaken);
                hinge.transform.localEulerAngles = Vector3.Lerp(startRot, endRot, single);
                if (hinge != null && hinge.gameObject.active == true) hinge.gameObject.SetActive(false);
                if (floor1block != null && floor1block.gameObject.active == true) floor1block.gameObject.SetActive(false);
                if (floor2block != null && floor2block.gameObject.active == true) floor2block.gameObject.SetActive(false);
                if (single >= 1)
                {
                    hinge.transform.localEulerAngles = endRot;
                    secsTaken = 0;
                    isRotating = false;
                    if (hinge != null) hinge.gameObject.SetActive(true);
                    if (floor1block != null) floor1block.gameObject.SetActive(true);
                    if (floor2block != null) floor2block.gameObject.SetActive(true);
                }
                RefreshFloor();
            }

            public void OnDestroy()
            {
                if (loadplayer.ContainsKey(ownerid)) loadplayer[ownerid].bridgecount = loadplayer[ownerid].bridgecount - 1;
                if (plate != null) { plate.Invoke("KillMessage", 0.1f); }
                if (pplate != null) { pplate.Invoke("KillMessage", 0.1f); }
                if (sphereCollider != null) { GameObject.Destroy(sphereCollider); }
                if (floor2block != null) { floor2block.Invoke("KillMessage", 0.1f); }
                if (floor1block != null) { floor1block.Invoke("KillMessage", 0.1f); }
                if (hinge != null) { hinge.Invoke("KillMessage", 0.1f); }
            }
        }

        #endregion

    }
}

// --- End of file: DrawBridges.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Clans.cs ---
// --- Original Local Path: Clans.cs ---

﻿using Facepunch.Extend;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using ProtoBuf;
using Rust;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Clans", "C cайта на букву T", "1.2.2", ResourceId = 14)]
    public class Clans : RustPlugin
    {
        bool Changed;
        bool Initialized;
        internal static Clans cc = null;
        bool newSaveDetected = false;
        List<ulong> manuallyEnabledBy = new List<ulong>();
        HashSet<ulong> bypass = new HashSet<ulong>();
        Dictionary<string, DateTime> notificationTimes = new Dictionary<string, DateTime>();
        static readonly DateTime UnixEpoch = new DateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc);
        static readonly double MaxUnixSeconds = (DateTime.MaxValue - UnixEpoch).TotalSeconds;
        Library lib;
        public Dictionary<string, Clan> clans = new Dictionary<string, Clan>();
        public Dictionary<string, string> clansSearch = new Dictionary<string, string>();
        List<string> purgedClans = new List<string>();
        Dictionary<string, string> originalNames = new Dictionary<string, string>();
        Dictionary<string, List<string>> pendingPlayerInvites = new Dictionary<string, List<string>>();
        Regex tagReExt;
        Dictionary<string, Clan> clanCache = new Dictionary<string, Clan>();
        List<object> filterDefaults()
        {
            var dp = new List<object>();
            dp.Add("admin");
            dp.Add("mod");
            dp.Add("owner");
            return dp;
        }
        public int limitMembers;
        int limitModerators;
        public int limitAlliances;
        int tagLengthMin;
        int tagLengthMax;
        int inviteValidDays;
        int friendlyFireNotifyTimeout;
        string allowedSpecialChars;
        public bool enableFFOPtion;
        bool enableAllyFFOPtion;
        bool enableWordFilter;
        bool enableClanTagging;
        public bool enableClanAllies;
        bool forceAllyFFNoDeactivate;
        bool forceClanFFNoDeactivate;
        bool enableWhoIsOnlineMsg;
        bool enableComesOnlineMsg;
        int authLevelRename;
        int authLevelDelete;
        int authLevelInvite;
        int authLevelKick;
        int authLevelPromoteDemote;
        int authLevelClanInfo;
        bool purgeOldClans;
        int notUpdatedSinceDays;
        bool listPurgedClans;
        bool wipeClansOnNewSave;
        bool useProtostorageClandata;
        string consoleName;
        string broadcastPrefix;
        string broadcastPrefixAlly;
        string broadcastPrefixColor;
        string broadcastPrefixFormat;
        string broadcastMessageColor;
        string colorCmdUsage;
        string colorTextMsg;
        string colorClanNamesOverview;
        string colorClanFFOff;
        string colorClanFFOn;
        string pluginPrefix;
        string pluginPrefixColor;
        string pluginPrefixREBORNColor;
        bool pluginPrefixREBORNShow;
        string pluginPrefixFormat;
        string clanServerColor;
        string clanOwnerColor;
        string clanCouncilColor;
        string clanModeratorColor;
        string clanMemberColor;
        bool setHomeOwner = false;
        bool setHomeModerator = false;
        bool setHomeMember = false;
        string chatCommandClan;
        string chatCommandFF;
        string chatCommandAllyChat;
        string chatCommandClanChat;
        string chatCommandClanInfo;
        string subCommandClanHelp;
        string subCommandClanAlly;
        bool usePermGroups;
        string permGroupPrefix;
        bool usePermToCreateClan;
        string permissionToCreateClan;
        bool usePermToJoinClan;
        string permissionToJoinClan;
        bool addClanMembersAsIOFriends;
        string clanTagColorBetterChat;
        int clanTagSizeBetterChat;
        string clanTagOpening;
        string clanTagClosing;
        bool clanChatDenyOnMuted;
        List<string> activeRadarUsers = new List<string>();
        Dictionary<string, List<BasePlayer>> clanRadarMemberobjects = new Dictionary<string, List<BasePlayer>>();
        static Vector3 sleeperHeight = new Vector3(0f, 1.0f, 0f);
        static Vector3 playerHeight = new Vector3(0f, 1.8f, 0f);
        bool enableClanRadar;
        string colorClanRadarOff;
        string colorClanRadarOn;
        float refreshTime;
        string nameColor;
        string sleeperNameColor;
        string distanceColor;
        static float minDistance;
        static float maxNamedistance;
        static float maxSleeperDistance;
        bool showSleepers;
        bool extendOnAllyMembers;
        bool enableAtLogin;
        int radarTextSize;
        string permissionClanRadarUse;
        bool usePermissionClanRadar;
        string chatCommandRadar;
        List<object> wordFilter = new List<object>();
        object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }


        int PointsOfDeath = 1;
        int PointsOfKilled = 1;
        int PointsOfKilledHeli = 1;
        int PointsOfSuicide = 1;
        int PointsOfGatherSulfur = 1;
        int PointsOfGatherMetalOre = 1;
        int PointsOfGatherStone = 1;
        int PointsOfGatherWood = 1;
        int PointsOfGatherHQM = 1;
        int PointsOfBarrel = 1;


        void LoadVariables()
        {
            wordFilter = (List<object>)GetConfig("Фильтр", "Слова", filterDefaults());

            PointsOfDeath = Convert.ToInt32(GetConfig("ТОП", "Очки: Сколько очков убирает за смерть", 1));
            PointsOfKilled = Convert.ToInt32(GetConfig("ТОП", "Очки: Сколько очков даем за убийство игрока", 1));
            PointsOfKilledHeli = Convert.ToInt32(GetConfig("ТОП", "Очки: Сколько очков даем за сбитие вертолёта", 1));
            PointsOfSuicide = Convert.ToInt32(GetConfig("ТОП", "Очки: Сколько очков забираем за суицид", 1));
            PointsOfGatherSulfur = Convert.ToInt32(GetConfig("ТОП", "Очки: Сколько очков даем за добычу серы (за разбитый камень - то есть за последний удар)", 1));
            PointsOfGatherMetalOre = Convert.ToInt32(GetConfig("ТОП", "Очки: Сколько очков даем за добычу металической руды (за разбитый камень - то есть за последний удар)", 1));
            PointsOfGatherStone = Convert.ToInt32(GetConfig("ТОП", "Очки: Сколько очков даем за добычу камня (за разбитый камень - то есть за последний удар)", 1));
            PointsOfGatherWood = Convert.ToInt32(GetConfig("ТОП", "Очки: Сколько очков даем за добычу дерева (за разбитый камень - то есть за последний удар)", 1));
            PointsOfGatherHQM = Convert.ToInt32(GetConfig("ТОП", "Очки: Сколько очков даем за добычу МВК (за разбитый камень - то есть за последний удар)", 1));
            PointsOfBarrel = Convert.ToInt32(GetConfig("ТОП", "Очки: Сколько очков даем за разрушение бочки (за разбитый камень - то есть за последний удар)", 1));

            limitMembers = Convert.ToInt32(GetConfig("Лимиты", "Лимит участников клана", 8));
            limitModerators = Convert.ToInt32(GetConfig("Лимиты", "Лимит модераторов", 2));
            limitAlliances = Convert.ToInt32(GetConfig("Лимиты", "Лимит альянса", 2));
            tagLengthMin = Convert.ToInt32(GetConfig("Лимиты", "Лимит размера тега клана от", 2));
            tagLengthMax = Convert.ToInt32(GetConfig("Лимиты", "Лимит размера тега клана до", 6));
            inviteValidDays = Convert.ToInt32(GetConfig("Лимиты", "Длительность жизни приглашения", 1));
            friendlyFireNotifyTimeout = Convert.ToInt32(GetConfig("Лимиты", "Таймаус сообщения об FF", 5));
            allowedSpecialChars = Convert.ToString(GetConfig("Лимиты", "Разрешены специальные символы", "!²³"));
            enableFFOPtion = Convert.ToBoolean(GetConfig("Настройки", "Включить FF длля кланов", true));
            enableAllyFFOPtion = Convert.ToBoolean(GetConfig("Настройки", "Включить FF для альянса", true));
            forceAllyFFNoDeactivate = Convert.ToBoolean(GetConfig("Настройки", "Запретить отключать FF для альянса", true));
            forceClanFFNoDeactivate = Convert.ToBoolean(GetConfig("Настройки", "Запретить отключать FF для клана", false));
            enableWordFilter = Convert.ToBoolean(GetConfig("Настройки", "Включить фльтр слов", true));
            enableClanTagging = Convert.ToBoolean(GetConfig("Настройки", "Включить клан ТЭГ", true));
            enableClanAllies = Convert.ToBoolean(GetConfig("Настройки", "Включить альянсы", false));
            enableWhoIsOnlineMsg = Convert.ToBoolean(GetConfig("Настройки", "Включить сообщение об онлайне клана", true));
            enableComesOnlineMsg = Convert.ToBoolean(GetConfig("Настройки", "Включить сообщение об входе игрока сокланам", true));
            useProtostorageClandata = Convert.ToBoolean(GetConfig("Storage", "Использовать Proto хранилище данных клана (Дата)", false));
            authLevelRename = Convert.ToInt32(GetConfig("Настройки привилегий", "Authentication Level Rename (Не трогать)", 1));
            authLevelDelete = Convert.ToInt32(GetConfig("Настройки привилегий", "Authentication Level Delete (Не трогать)", 2));
            authLevelInvite = Convert.ToInt32(GetConfig("Настройки привилегий", "Authentication Level Invite (Не трогать)", 1));
            authLevelKick = Convert.ToInt32(GetConfig("Настройки привилегий", "Authentication Level Kick (Не трогать)", 2));
            authLevelPromoteDemote = Convert.ToInt32(GetConfig("Настройки привилегий", "Authentication Level Promote Demote (Не трогать)", 1));
            authLevelClanInfo = Convert.ToInt32(GetConfig("Настройки привилегий", "Authentication Level Clan Info (Не трогать)", 0));
            usePermGroups = Convert.ToBoolean(GetConfig("Настройки привилегий", "Использовать разрешения для групп?", false));
            permGroupPrefix = Convert.ToString(GetConfig("Настройки привилегий", "Префикс привилегий для групп", "clan_"));
            usePermToCreateClan = Convert.ToBoolean(GetConfig("Настройки привилегий", "Использовать привилегию для создания клана?", false));
            permissionToCreateClan = Convert.ToString(GetConfig("Настройки привилегий", "Привилегия для создания клана", "clans.cancreate"));
            usePermToJoinClan = Convert.ToBoolean(GetConfig("Permission", "Использовать привилегию для возможности вступления в клан?", false));
            permissionToJoinClan = Convert.ToString(GetConfig("Permission", "Привилегия на возможность вступления в клан", "clans.canjoin"));
            purgeOldClans = Convert.ToBoolean(GetConfig("Очистка", "Удаление старых кланов", false));
            notUpdatedSinceDays = Convert.ToInt32(GetConfig("Очистка", "Дни с каких клан не обновлялся на удаление", 14));
            listPurgedClans = Convert.ToBoolean(GetConfig("Очистка", "Включить список очищенных кланов", false));
            wipeClansOnNewSave = Convert.ToBoolean(GetConfig("Очистка", "Удалить кланы при вайпе?", false));
            consoleName = Convert.ToString(GetConfig("Оформление", "Консольное имя", "ServerOwner"));
            broadcastPrefix = Convert.ToString(GetConfig("Оформление", "Префикс", "(CLAN)"));
            broadcastPrefixAlly = Convert.ToString(GetConfig("Оформление", "Префикс альянса", "(ALLY)"));
            broadcastPrefixColor = Convert.ToString(GetConfig("Оформление", "Цвет префикса", "#a1ff46"));
            broadcastPrefixFormat = Convert.ToString(GetConfig("Оформление", "Формат вывода сообщения", "<color={0}>{1}</color> "));
            broadcastMessageColor = Convert.ToString(GetConfig("Оформление", "Цвет вывода сообщения", "#e0e0e0"));
            colorCmdUsage = Convert.ToString(GetConfig("Оформление", "Цвет CMD", "#ffd479"));
            colorTextMsg = Convert.ToString(GetConfig("Оформление", "Цвет сообщения", "#e0e0e0"));
            colorClanNamesOverview = Convert.ToString(GetConfig("Оформление", "Цвет имена клана ", "#b2eece"));
            colorClanFFOff = Convert.ToString(GetConfig("Оформление", "Цвет сообщения об отключении FF", "lime"));
            colorClanFFOn = Convert.ToString(GetConfig("Оформление", "Цвет сообщения об включении FF", "red"));
            pluginPrefix = Convert.ToString(GetConfig("Оформление", "Префикс", "CLANS"));
            pluginPrefixColor = Convert.ToString(GetConfig("Оформление", "Цвет префикса в сообщении", "orange"));
            pluginPrefixREBORNColor = Convert.ToString(GetConfig("Оформление", "Цвет префикса REBORN в сообщении", "#ce422b"));
            pluginPrefixREBORNShow = Convert.ToBoolean(GetConfig("Оформление", "Включить префикс Reborn?", true));
            pluginPrefixFormat = Convert.ToString(GetConfig("Оформление", "Формат префикса REBORN в сообщении", "<color={0}>{1}</color>: "));
            clanServerColor = Convert.ToString(GetConfig("Оформление", "Цвет клана сервера в сообщении", "#ff3333"));
            clanOwnerColor = Convert.ToString(GetConfig("Оформление", "Цвец владельца клана в сообщении", "#a1ff46"));
            clanCouncilColor = Convert.ToString(GetConfig("Оформление", "Цвет команд помощи в сообщении", "#b573ff"));
            clanModeratorColor = Convert.ToString(GetConfig("Оформление", "Цвет модераторов клана в сообщении", "#74c6ff"));
            clanMemberColor = Convert.ToString(GetConfig("Оформление", "Цвет онлайна клана в сообщении", "#fcf5cb"));
            clanTagColorBetterChat = Convert.ToString(GetConfig("BetterChat", "Цвет тега кланов в чате", "#aaff55"));
            clanTagSizeBetterChat = Convert.ToInt32(GetConfig("BetterChat", "Размер тега клано в чате", 15));
            clanTagOpening = Convert.ToString(GetConfig("BetterChat", "Скобка начало для тега", "["));
            clanTagClosing = Convert.ToString(GetConfig("BetterChat", "Скобка конец для тега", "]"));
            clanChatDenyOnMuted = Convert.ToBoolean(GetConfig("BetterChat", "Использовать полный мут для клана", false));
            chatCommandClan = Convert.ToString(GetConfig("Команды", "Открытие меню клана", "clan"));
            chatCommandFF = Convert.ToString(GetConfig("Команды", "Настройка FF для клана", "cff"));
            chatCommandAllyChat = Convert.ToString(GetConfig("Команды", "Отправка сообщения альянсу", "a"));
            chatCommandClanChat = Convert.ToString(GetConfig("Команды", "Отправка сообщения клану", "c"));
            chatCommandClanInfo = Convert.ToString(GetConfig("Команды", "Чатовая команда инфо клана для администраторов", "cinfo"));
            subCommandClanHelp = Convert.ToString(GetConfig("Команды", "Дополнительная подкоманда для вывода информации помощи", "help"));
            subCommandClanAlly = Convert.ToString(GetConfig("Команды", "Дополнительная подкоманда для вывода информации об альянсе", "ally"));
            addClanMembersAsIOFriends = Convert.ToBoolean(GetConfig("RustIO", "Добавить членов клана в качестве IO Friends", true));
            enableClanRadar = Convert.ToBoolean(GetConfig("Клановый радар", "Включить радар дял кланов", false));
            colorClanRadarOff = Convert.ToString(GetConfig("Клановый радар", "Цвет радара когда он отключен", "silver"));
            colorClanRadarOn = Convert.ToString(GetConfig("Клановый радар", "Цвет радара когда он включен", "lime"));
            refreshTime = Convert.ToSingle(GetConfig("Клановый радар", "Время обновления", 3.0));
            nameColor = Convert.ToString(GetConfig("Клановый радар", "Цвет имен", "#008000"));
            sleeperNameColor = Convert.ToString(GetConfig("Клановый радар", "Цвет имен спящих", "#ff00ff"));
            distanceColor = Convert.ToString(GetConfig("Клановый радар", "Цвет дистанции", "#0000ff"));
            minDistance = Convert.ToSingle(GetConfig("Клановый радар", "Минимальная дистанция", 10.0));
            maxNamedistance = Convert.ToSingle(GetConfig("Клановый радар", "Максимальная дистанция для онлайн игроков", 200.0));
            maxSleeperDistance = Convert.ToSingle(GetConfig("Клановый радар", "Максимальная дистанция для спящих игроков", 50.0));
            showSleepers = Convert.ToBoolean(GetConfig("Клановый радар", "Показывать слиперов?", false));
            radarTextSize = Convert.ToInt32(GetConfig("Клановый радар", "Размер текста в радаре", 15));
            extendOnAllyMembers = Convert.ToBoolean(GetConfig("Клановый радар", "Включить отображение участников альянса на радаре", false));
            enableAtLogin = Convert.ToBoolean(GetConfig("Клановый радар", "Включить тех кто входит", false));
            permissionClanRadarUse = Convert.ToString(GetConfig("Клановый радар", "Привилегия на использование радара", "clans.radaruse"));
            usePermissionClanRadar = Convert.ToBoolean(GetConfig("Клановый радар", "Использовать привилегию на включение радара ?", false));
            chatCommandRadar = Convert.ToString(GetConfig("Клановый радар", "Чатовая команда открытия радара", "crd"));
            if (!Changed) return;
            SaveConfig();
            Changed = false;
        }
        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            LoadVariables();
        }
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string> {
                { "nopermtocreate", "You got no rights to create a clan." },
                { "nopermtojoin", "You got no rights to join a clan." }, 
				{ "nopermtojoinbyinvite", "The player {0} has no rights to join a clan." }, 
				{ "claninvite", "You have been invited to join the clan: [{0}] '{1}'\nTo join, type: <color={2}>/clan join {0}</color>" }, 
				{ "comeonline", "{0} has come online!" }, 
				{ "goneoffline", "{0} has gone offline!" }, 
				{ "friendlyfire", "{0} is a clan member and cannot be hurt.\nTo toggle clan friendlyfire type: <color={1}>/clan ff</color>" },
                { "allyfriendlyfire", "{0} is an ally member and cannot be hurt." }, 
				{ "notmember", "You are currently not a member of a clan." }, 
				{ "youareownerof", "You are the owner of:" }, 
				{ "youaremodof", "You are a moderator of:" }, 
				{ "youarecouncilof", "You are a council of:" }, 
				{ "youarememberof", "You are a member of:" },
                { "claninfo", " [{0}] {1}" }, 
				{ "memberon", "Members online: " }, 
				{ "overviewnamecolor", "<color={0}>{1}</color>" }, 
				{ "memberoff", "Members offline: " },
				{ "notmoderator", "You need to be a moderator of your clan to use this command." },
                { "pendinvites", "Pending invites: " }, 
				{ "bannedwords", "The clan tag contains banned words." }, 
				{ "viewthehelp", "To view more commands, type: <color={0}>/{1} helpies</color>" }, 
				{ "usagecreate", "Usage - <color={0}>/clan create \"TAG\" \"Description\"</color>" }, 
				{ "hintlength", "Clan tags must be {0} to {1} characters long" }, 
				{ "hintchars", "Clan tags must contain only 'a-z' 'A-Z' '0-9' '{0}'" }, 
				{ "providedesc", "Please provide a short description of your clan." }, 
				{ "tagblocked", "There is already a clan with this tag." }, 
				{ "nownewowner", "You are now the owner of the clan [{0}] \"{1}\"" }, 
				{ "inviteplayers", "To invite new members, type: <color={0}>/clan invite <name></color>" }, 
				{ "usageinvite", "Usage - <color={0}>/clan invite <name></color>" }, 
				{ "nosuchplayer", "No such player or player name not unique: {0}" }, 
				{ "alreadymember", "This player is already a member of your clan: {0}" }, 
				{ "alreadyinvited", "This player has already been invited to your clan: {0}" }, 
				{ "alreadyinclan", "This player is already in a clan: {0}" }, 
				{ "invitebroadcast", "{0} invited {1} to the clan." }, 
				{ "usagewithdraw", "Usage: <color={0}>/clan withdraw <name></color>" }, 
				{ "notinvited", "This player has not been invited to your clan: {0}" }, 
				{ "canceledinvite", "{0} canceled the invitation of {1}." }, 
				{ "usagejoin", "Usage: <color={0}>/clan join \"TAG\"</color>" }, 
				{ "youalreadymember", "You are already a member of a clan." }, 
				{ "younotinvited", "You have not been invited to join this clan." }, 
				{ "reachedmaximum", "This clan has already reached the maximum number of members." }, 
				{ "broadcastformat", "<color={0}>{1}</color>: {2}" }, 
				{ "allybroadcastformat", "[{0}] <color={1}>{2}</color>: {3}" }, 
				{ "clanrenamed", "{0} renamed your clan to: [{1}]." } , 
				{ "yourenamed", "You have renamed the clan [{0}] to [{1}]" }, 
				{ "clandeleted", "{0} deleted your clan." }, 
				{ "youdeleted", "You have deleted the clan [{0}]" }, 
				{ "noclanfound", "There is no clan with that tag [{0}]" }, 
				{ "renamerightsowner", "You need to be a server owner to rename clans." }, 
				{ "usagerename", "Usage: <color={0}>/clan rename OLDTAG NEWTAG</color>" }, 
				{ "deleterightsowner", "You need to be a server owner to delete clans." }, 
				{ "usagedelete", "Usage: <color={0}>/clan delete TAG</color>" }, 
				{ "clandisbanded", "Your current clan has been disbanded forever." }, 
				{ "needclanowner", "You need to be the owner of your clan to use this command." }, 
				{ "needclanownercouncil", "You need to be the owner or a council to use this command." }, 
				{ "usagedisband", "Usage: <color={0}>/clan disband forever</color>" }, 
				{ "usagepromote", "Usage: <color={0}>/clan promote <name></color>" }, 
				{ "playerjoined", "{0} has joined the clan!" }, 
				{ "waskicked", "{0} kicked {1} from the clan." }, 
				{ "modownercannotkicked", "The player {0} is an owner or moderator and cannot be kicked." }, 
				{ "notmembercannotkicked", "The player {0} is not a member of your clan." }, 
				{ "usageff", "Usage: <color={0}>/clan ff</color> toggles your current FriendlyFire status." }, 
				{ "usagekick", "Usage: <color={0}>/clan kick <name></color>" }, 
				{
                    "playerleft", "{0} has left the clan."
                }
                , {
                    "youleft", "You have left your current clan."
                }
                , {
                    "usageleave", "Usage: <color={0}>/clan leave</color>"
                }
                , {
                    "notaclanmember", "The player {0} is not a member of your clan."
                }
                , {
                    "alreadyowner", "The player {0} is already the owner of your clan."
                }
                , {
                    "alreadyamod", "The player {0} is already a moderator of your clan."
                }
                , {
                    "alreadyacouncil", "The player {0} is already a council of your clan."
                }
                , {
                    "alreadyacouncilset", "The position of the council is already awarded."
                }
                , {
                    "maximummods", "This clan has already reached the maximum number of moderators."
                }
                , {
                    "playerpromoted", "{0} promoted {1} to moderator."
                }
                , {
                    "playerpromotedcouncil", "{0} promoted {1} to council."
                }
                , {
                    "playerpromotedowner", "{0} promoted {1} to new owner."
                }
                , {
                    "usagedemote", "Usage: <color={0}>/clan demote <name></color>"
                }
                , {
                    "notamoderator", "The player {0} is not a moderator of your clan."
                }
                , {
                    "notpromoted", "The player {0} is not a moderator or council of your clan."
                }
                , {
                    "playerdemoted", "{0} demoted {1} to a member."
                }
                , {
                    "councildemoted", "{0} demoted {1} to a moderator."
                }
                , {
                    "noactiveally", "Your clan has no current alliances."
                }
                , {
                    "yourffstatus", "Your FriendlyFire:"
                }
                , {
                    "yourclanallies", "Your Clan allies:"
                }
                , {
                    "allyinvites", "Ally invites:"
                }
                , {
                    "allypending", "Ally requests:"
                }
                , {
                    "allyReqHelp", "Offer an alliance to another clan"
                }
                , {
                    "allyAccHelp", "Accept an alliance from another clan"
                }
                , {
                    "allyDecHelp", "Decline an alliance from another clan"
                }
                , {
                    "allyCanHelp", "Cancel an alliance with another clan"
                }
                , {
                    "reqAlliance", "[{0}] has requested a clan alliance"
                }
                , {
                    "invitePending", "You already have a pending alliance invite for [{0}]"
                }
                , {
                    "clanNoExist", "The clan [{0}] does not exist"
                }
                , {
                    "alreadyAllies", "You are already allied with"
                }
                , {
                    "allyProvideName", "You need to provide a Clan name"
                }
                , {
                    "allyLimit", "You already have the maximum allowed ally limit"
                }
                , {
                    "allyAccLimit", "You can not accept the alliance with {0}. You reached the limit"
                }
                , {
                    "allyCancel", "You have cancelled your alliance with [{0}]"
                }
                , {
                    "allyCancelSucc", "{0} has cancelled your clan alliance"
                }
                , {
                    "noAlly", "Your clans have no alliance with each other"
                }
                , {
                    "noAllyInv", "You do not have a alliance invite from [{0}]"
                }
                , {
                    "allyInvWithdraw", "You have cancelled your request to [{0}]"
                }
                , {
                    "allyDeclined", "You have declined the clan alliance from [{0}]"
                }
                , {
                    "allyDeclinedSucc", "[{0}] has declined your alliance request"
                }
                , {
                    "allyReq", "You have requested a clan alliance from [{0}]"
                }
                , {
                    "allyAcc", "You have accepted the clan alliance from [{0}]"
                }
                , {
                    "allyAccSucc", "[{0}] has accepted your alliance request"
                }
                , {
                    "allyPendingInfo", "Your clan has pending ally request(s). Check those in the clan overview."
                }
                , {
                    "clanffdisabled", "You have <color={0}>disabled</color> friendly fire for your clan.\nThey are safe!"
                }
                , {
                    "clanffenabled", "You have <color={0}>enabled</color> friendly fire for your clan.\nTake care!"
                }
                , {
                    "yourname", "YOU"
                }
                , {
                    "helpavailablecmds", "Available commands:"
                }
                , {
                    "helpinformation", "Display your clan information"
                }
                , {
                    "helpmessagemembers", "Send a message to all members"
                }
                , {
                    "helpmessageally", "Send a message to all allied members"
                }
                , {
                    "helpcreate", "Create a new clan"
                }
                , {
                    "helpjoin", "Join a clan by invitation"
                }
                , {
                    "helpleave", "Leave your clan"
                }
                , {
                    "helptoggleff", "Toggle friendlyfire status"
                }
                , {
                    "helpinvite", "Invite a player"
                }
                , {
                    "helpwithdraw", "Cancel an invite"
                }
                , {
                    "helpkick", "Kick a member"
                }
                , {
                    "helpallyoptions", "Lists the ally options"
                }
                , {
                    "helppromote", "Promote a member"
                }
                , {
                    "helpdemote", "Demote a member"
                }
                , {
                    "helpdisband", "Disband your clan (no undo)"
                }
                , {
                    "helpmoderator", "Moderator"
                }
                , {
                    "helpowner", "Owner"
                }
                , {
                    "helpcommands", "commands:"
                }
                , {
                    "helpconsole", "Open F1 console and type:"
                }
                , {
                    "yourradarstatus", "Your ClanRadar:"
                }
                , {
                    "clanradardisabled", "Clan radar disabled"
                }
                , {
                    "clanradarenabled", "Clan radar enabled"
                }
                , {
                    "helptoggleradar", "Toggle clanradar status"
                }
                , {
                    "clanArgCreate", "create"
                }
                , {
                    "clanArgInvite", "invite"
                }
                , {
                    "clanArgLeave", "leave"
                }
                , {
                    "clanArgWithdraw", "withdraw"
                }
                , {
                    "clanArgJoin", "join"
                }
                , {
                    "clanArgPromote", "promote"
                }
                , {
                    "clanArgDemote", "demote"
                }
                , {
                    "clanArgFF", "ff"
                }
                , {
                    "clanArgRadar", "radar"
                }
                , {
                    "clanArgAlly", "ally"
                }
                , {
                    "clanArgHelp", "help"
                }
                , {
                    "clanArgKick", "kick"
                }
                , {
                    "clanArgDisband", "disband"
                }
                , {
                    "clanArgForever", "forever"
                }
                , {
                    "clanArgNameId", "<name|id>"
                }
                , {
                    "allyArgRequest", "request"
                }
                , {
                    "allyArgRequestShort", "req"
                }
                , {
                    "allyArgAccept", "accept"
                }
                , {
                    "allyArgAcceptShort", "acc"
                }
                , {
                    "allyArgDecline", "decline"
                }
                , {
                    "allyArgDeclineShort", "dec"
                }
                , {
                    "allyArgCancel", "cancel"
                }
                , {
                    "allyArgCancelShort", "can"
                }
                ,
                {
                    "clanchatmuted", "You may not clanchat, you are muted."
                },
                 {
                    "clanUItitle", "Clan System by TopPlugin / Oxide"
                },
                  {
                    "clanTOPUItitle", "Clans TOP"
                },
            }
            , this, "en");
			lang.RegisterMessages(new Dictionary<string, string> {
                {"nopermtocreate", "Ты не имеешь права создавать клан."},
                {"nopermtojoin", "Ты не имеешь права вступать в клан."}
                ,{"nopermtojoinbyinvite", "Игрок {0} не имеет права вступать в клан."}
                ,{"claninvite", "Вас пригласили вступить в клан: [{0}] '{1}'\nДля вступления введите: <color={2}>/clan join {0}</color>"}
                ,{"comeonline", "{0} зашёл в онлайн!"}
                ,{"goneoffline", "{0} ушел в офлайн!"}
                ,{"friendlyfire", "{0} является членом клана и не может быть поранен вами.\nЧтобы переключить режимы дружественного огня клана введите: <color={1}>/clan ff</color>"}
                ,{"allyfriendlyfire", "{0} является членом союзника и не может быть ранен."}
                ,{"notmember", "В настоящее время вы не являетесь членом клана."}
                ,{"youareownerof", "Вы являетесь владельцем:"}
                ,{"youaremodof", "Вы являетесь модератором:"}
                ,{"youarecouncilof", "Ты состоишь в:"}
                ,{"youarememberof", "Вы состоите в клане:"}
                ,{"claninfo", " [{0}] {1}"}
                ,{"memberon", "Участники онлайн: "}
                ,{"overviewnamecolor", "<color={0}>{1}</color>"}
                ,{"memberoff", "Участники в офлайн: "}
                ,{"notmoderator", "Вы должны быть модератором своего клана, чтобы использовать эту команду."}
                ,{"pendinvites", "Ожидающие приглашения: "}
                ,{"bannedwords", "Тег клана содержит запрещенные слова."}
                ,{"viewthehelp", "Чтобы просмотреть дополнительные команды, введите: <color={0}>/{1} helpies</color>"}
                ,{"usagecreate", "Использование - <color={0}>/clan create \"Название\" \"Описание\"</color>"}
                ,{"hintlength", "Теги клана должны быть длиной от {0} до {1} символов"}
                ,{"hintchars", "Клановые теги должны содержать только 'a-z' 'A-Z' '0-9' '{0}'"}
                ,{"providedesc", "Пожалуйста, дайте краткое описание вашего клана."}
                ,{"tagblocked", "Уже есть клан с этим тегом."}
                ,{"nownewowner", "Вы являетесь владельцем клана [{0}] \"{1}\""}
                ,{"inviteplayers", "Чтобы пригласить новых участников, введите: <color={0}>/clan invite <name></color>"}
                ,{"usageinvite", "Использование - <color={0}>/clan invite <name></color>"}
                ,{"nosuchplayer", "Нет такого игрока или имя игрока не уникально: {0}"}
                ,{"alreadymember", "Этот игрок уже является членом вашего клана: {0}"}
                ,{"alreadyinvited", "Этот игрок уже приглашен в ваш клан: {0}"}
                ,{"alreadyinclan", "Этот игрок уже состоит в клане: {0}"}
                ,{"invitebroadcast", "{0} приглашен {1} в клан."}
                ,{"usagewithdraw", "Использование: <color={0}>/clan withdraw <name></color>"}
                ,{"notinvited", "Этот игрок не был приглашен в ваш клан: {0}"}
                ,{"canceledinvite", "{0} отменил приглашение {1}."}
                ,{"usagejoin", "Использование: <color={0}>/clan join \"Название\"</color>"}
                ,{"youalreadymember", "Ты уже состоишь в клане."}
                ,{"younotinvited", "Вас не приглашали присоединиться к этому клану."}
                ,{"reachedmaximum", "Этот клан уже достиг максимального количества членов."}
                ,{"broadcastformat", "<color={0}>{1}</color>: {2}"}
                ,{"allybroadcastformat", "[{0}] <color={1}>{2}</color>: {3}"}
                ,{"clanrenamed", "{0} переименовал свой клан в: [{1}]."}
                ,{"yourenamed", "Вы переименовали клан с [{0}] в [{1}]"}
                ,{"clandeleted", "{0} удалил свой клан."}
                ,{"youdeleted", "Вы удалили клан [{0}]"}
                ,{"noclanfound", "Нет клана с такой меткой [{0}]"}
                ,{"renamerightsowner", "Вы должны быть владельцем сервера, чтобы переименовать кланы."}
                ,{"usagerename", "Использование: <color={0}>/clan rename OLDTAG NEWTAG</color>"}
                ,{"deleterightsowner", "Вы должны быть владельцем сервера, чтобы удалить клан."}
                ,{"usagedelete", "Использование: <color={0}>/clan delete Название</color>"}
                ,{"clandisbanded", "Ваш нынешний клан был распущен навсегда."}
                ,{"needclanowner", "Вы должны быть владельцем своего клана, чтобы использовать эту команду."}
                ,{"needclanownercouncil", "Вы должны быть владельцем или советом, чтобы использовать эту команду."}
                ,{"usagedisband", "Использование: <color={0}>/clan disband forever</color>"}
                ,{"usagepromote", "Использование: <color={0}>/clan promote <name></color>"}
                ,{"playerjoined", "{0} присоединился к клану!"}
                ,{"waskicked", "{0} выгнали {1} из клана."}
                ,{"modownercannotkicked", "Игрок {0} является владельцем или модератором и не может быть выгнан."}
                ,{"notmembercannotkicked", "Игрок {0} не является членом вашего клана."}
                ,{"usageff", "Использование: <color={0}>/clan ff</color> переключает ваш текущий статус урон по своим."}
                ,{"usagekick", "Использование: <color={0}>/clan kick <name></color>"}
                ,{"playerleft", "{0} покинул клан."}
                ,{"youleft", "Вы покинули клан."}
                ,{"usageleave", "Использование: <color={0}>/clan leave</color>"}
                ,{"notaclanmember", "Игрок {0} не является членом вашего клана."}
                ,{"alreadyowner", "Игрок {0} уже является владельцем вашего клана."}
                ,{"alreadyamod", "Игрок {0} уже является модератором вашего клана."}
                ,{"alreadyacouncil", "Игрок {0} уже является членом совета вашего клана."}
                ,{"alreadyacouncilset", "Должность председателя совета уже присуждена."}
                ,{"maximummods", "Этот клан уже достиг максимального количества модераторов."}
                ,{"playerpromoted", "{0} повышен {1} до модератора."}
                ,{"playerpromotedcouncil", "{0} выдвинут {1} в совет."}
                ,{"playerpromotedowner", "{0} повышен {1} до нового владельца."}
                ,{"usagedemote", "Использование: <color={0}>/clan demote <name></color>"}
                ,{"notamoderator", "Игрок {0} не является модератором вашего клана."}
                ,{"notpromoted", "Игрок {0} не является модератором или советом вашего клана."}
                ,{"playerdemoted", "{0} понижен в должности {1} до члена."}
                ,{"councildemoted", "{0} понижен в должности {1} до модератора."}
                ,{"noactiveally", "У вашего клана нет нынешних альянсов."}
                ,{"yourffstatus", "Огонь по своим:"}
                ,{"yourclanallies", "Ваши союзники по Клану:"}
                ,{"allyinvites", "Приглашения в союз:"}
                ,{"allypending", "Запросы союзников:"}
                ,{"allyReqHelp", "Предложите союз другому клану"}
                ,{"allyAccHelp", "Принимаем в альянс с другим кланом"}
                ,{"allyDecHelp", "Отказаться от союза с другим кланом"}
                ,{"allyCanHelp", "Отменить союз с другим кланом"}
                , {
                    "reqAlliance", "[{0}] запросил клановый союз"
                }
                , {
                    "invitePending", "У вас уже есть ожидающее приглашение на альянс [{0}]"
                }
                , {
                    "clanNoExist", "Клан [{0}] не существует"
                }
                , {
                    "alreadyAllies", "Вы уже вступили в союз с"
                }
                , {
                    "allyProvideName", "Вам нужно указать название клана"
                }
                , {
                    "allyLimit", "У вас уже есть максимально допустимый лимит союзников"
                }
                , {
                    "allyAccLimit", "Вы не можете принять союз с {0}. Вы достигли предела"
                }
                , {
                    "allyCancel", "Вы отменили свой союз с [{0}]"
                }
                , {
                    "allyCancelSucc", "{0} отменил ваш клановый союз"
                }
                , {
                    "noAlly", "Ваши кланы не имеют союза друг с другом"
                }
                , {
                    "noAllyInv", "У вас нет приглашения на альянс от [{0}]"
                }
                , {
                    "allyInvWithdraw", "Вы отменили свой запрос на [{0}]"
                }
                , {
                    "allyDeclined", "Вы отказались от кланового союза с [{0}]"
                }
                , {
                    "allyDeclinedSucc", "[{0}] отклонил ваш запрос на союз"
                }
                , {
                    "allyReq", "Вы запросили клановый союз у [{0}]"
                }
                , {
                    "allyAcc", "Вы приняли клановый союз от [{0}]"
                }
                , {
                    "allyAccSucc", "[{0}] принял ваш запрос на союз"
                }
                , {
                    "allyPendingInfo", "У вашего клана есть ожидающий запрос(ы) союзника (ов). Проверьте их в обзоре клана."
                }
                , {
                    "clanffdisabled", "У тебя есть <color={0}>disabled</color> дружественный огонь для вашего клана.\nВы в безопасности!"
                }
                , {
                    "clanffenabled", "У тебя есть <color={0}>enabled</color> дружественный огонь для вашего клана.\nБудь осторожен!"
                }
                , {
                    "yourname", "ВЫ"
                }
                , {
                    "helpavailablecmds", "Доступные команды:"
                }
                , {
                    "helpinformation", "Отображение информации о вашем клане"
                }
                , {
                    "helpmessagemembers", "Отправьте сообщение всем участникам"
                }
                , {
                    "helpmessageally", "Отправьте сообщение всем членам альянса"
                }
                , {
                    "helpcreate", "Создайте новый клан"
                }
                , {
                    "helpjoin", "Вступайте в клан по приглашению"
                }
                , {
                    "helpleave", "Оставь свой клан"
                }
                , {
                    "helptoggleff", "Переключение статуса friendlyfire"
                }
                , {
                    "helpinvite", "Пригласите игрока"
                }
                , {
                    "helpwithdraw", "Отменить приглашение"
                }
                , {
                    "helpkick", "Удар ногой по члену"
                }
                , {
                    "helpallyoptions", "Перечисляет параметры союзника"
                }
                , {
                    "helppromote", "Продвигать члена клуба"
                }
                , {
                    "helpdemote", "Понизить в должности члена"
                }
                , {
                    "helpdisband", "Расформируйте свой клан (без отмены)"
                }
                , {
                    "helpmoderator", "Модератор"
                }
                , {
                    "helpowner", "Владелец"
                }
                , {
                    "helpcommands", "команды:"
                }
                , {
                    "helpconsole", "Откройте консоль F1 и введите:"
                }
                , {
                    "yourradarstatus", "Твой КланРадар:"
                }
                , {
                    "clanradardisabled", "Клановый радар отключен"
                }
                , {
                    "clanradarenabled", "Клановый радар включен"
                }
                , {
                    "helptoggleradar", "Переключение статуса радара клана"
                }
                , {
                    "clanArgCreate", "create"
                }
                , {
                    "clanArgInvite", "invite"
                }
                , {
                    "clanArgLeave", "leave"
                }
                , {
                    "clanArgWithdraw", "withdraw"
                }
                , {
                    "clanArgJoin", "join"
                }
                , {
                    "clanArgPromote", "promote"
                }
                , {
                    "clanArgDemote", "demote"
                }
                , {
                    "clanArgFF", "ff"
                }
                , {
                    "clanArgRadar", "radar"
                }
                , {
                    "clanArgAlly", "ally"
                }
                , {
                    "clanArgHelp", "help"
                }
                , {
                    "clanArgKick", "kick"
                }
                , {
                    "clanArgDisband", "disband"
                }
                , {
                    "clanArgForever", "forever"
                }
                , {
                    "clanArgNameId", "<name|id>"
                }
                , {
                    "allyArgRequest", "request"
                }
                , {
                    "allyArgRequestShort", "req"
                }
                , {
                    "allyArgAccept", "acc"
                }
                , {
                    "allyArgAcceptShort", "acc"
                }
                , {
                    "allyArgDecline", "decline"
                }
                , {
                    "allyArgDeclineShort", "dec"
                }
                , {
                    "allyArgCancel", "cancel"
                }
                , {
                    "allyArgCancelShort", "can"
                }
                ,
                {
                    "clanchatmuted", "Вы не можете клацать, вы приглушены."
                },
                 {
                    "clanUItitle", "Клановая система TopPlugin / Oxide"
                },
                  {
                    "clanTOPUItitle", "ТОП СТАТИСТИКА КЛАНОВ"
                },
            }
            , this, "ru");
		}

        void Init()
        {
            cc = this;
            LoadVariables();
            LoadDefaultMessages();
            Initialized = false;
            if (!permission.PermissionExists(permissionClanRadarUse)) permission.RegisterPermission(permissionClanRadarUse, this);
            if (!permission.PermissionExists(permissionToCreateClan)) permission.RegisterPermission(permissionToCreateClan, this);
            if (!permission.PermissionExists(permissionToJoinClan)) permission.RegisterPermission(permissionToJoinClan, this);
            cmd.AddChatCommand(chatCommandFF, this, "cmdChatClanFF");
            //Custom code
            //cmd.AddChatCommand("clanui", this, "CLanUIInfo");

            cmd.AddChatCommand(chatCommandClan, this, "cmdChatClan");
            cmd.AddChatCommand(chatCommandClanChat, this, "cmdChatClanchat");
            cmd.AddChatCommand(chatCommandAllyChat, this, "cmdChatAllychat");
            cmd.AddChatCommand(chatCommandClanInfo, this, "cmdChatClanInfo");
            cmd.AddChatCommand(chatCommandRadar, this, "cmdChatClanRadar");
            cmd.AddChatCommand(chatCommandClan + subCommandClanHelp, this, "cmdChatClanHelp");
            cmd.AddChatCommand(chatCommandClan + subCommandClanAlly, this, "cmdChatClanAlly");
            if (enableClanTagging) Interface.CallHook("API_RegisterThirdPartyTitle", this, new Func<IPlayer, string>(getFormattedClanTag));
        }
        void OnPluginLoaded(Plugin plugin)
        {
            if (plugin.Title != "Better Chat") return;
            if (enableClanTagging) Interface.CallHook("API_RegisterThirdPartyTitle", this, new Func<IPlayer, string>(getFormattedClanTag));
        }


        string getFormattedClanTag(IPlayer player)
        {
            var clan = findClanByUser(player.Id);
            if (clan != null && !string.IsNullOrEmpty(clan.tag)) return $"[#{clanTagColorBetterChat.Replace("#", "")}][+{clanTagSizeBetterChat}]{clanTagOpening}{clan.tag}{clanTagClosing}[/+][/#]";
            return string.Empty;
        }
        //Custom code
        [PluginReference] private Plugin ImageLibrary;
        public string GetImageSkin(string shortname, ulong skin = 0) => (string)ImageLibrary.Call("GetImage", shortname, skin);
        public List<ulong> GetImageSkins(string shortname) => ImageLibrary.Call("GetImageList", shortname) as List<ulong>;

        static Clans ins;

        void OnServerInitialized()
        {
            ins = this;
            if (!ImageLibrary)
            {
                PrintError("ImageLibrary not found! Clans not work!");
                Interface.Oxide.UnloadPlugin("Clans");
                return;
            }
            else
            {
                clanCache.ToList().ForEach(c => ImageLibrary?.Call("AddImage", c.Value.ClanAvatar, c.Value.ClanAvatar));
                ImageLibrary?.Call("AddImage", "https://i.imgur.com/d9HBO4C.png", "loot-barrel");
            }
            LoadData();
            if (enableClanRadar)
            {
                clanRadarMemberobjects = new Dictionary<string, List<BasePlayer>>();
                foreach (var clan in clans) clanRadarMemberobjects.Add(clan.Key, new List<BasePlayer>());
            }
            if (purgeOldClans) Puts($"Valid clans loaded: '{clans.Count}'");
            if (purgeOldClans && purgedClans.Count() > 0)
            {
                Puts($"Old Clans purged: '{purgedClans.Count}'");
                if (listPurgedClans)
                {
                    foreach (var purged in purgedClans) Puts($"Purged > {purged}");
                }
            }
            AllyRemovalCheck();
            tagReExt = new Regex("[^a-zA-Z0-9" + allowedSpecialChars + "]");
            foreach (var player in BasePlayer.activePlayerList) setupPlayer(player);
            foreach (var player in BasePlayer.sleepingPlayerList) setupPlayer(player);

            Initialized = true;
        }
        void OnServerSave() => SaveData();
        void OnNewSave()
        {
            if (wipeClansOnNewSave) newSaveDetected = true;
        }

        void Unload()
        {
            if (!Initialized) return;
            SaveData();
            foreach (var pair in originalNames)
            {
                var player = rust.FindPlayerByIdString(pair.Key);
                if (player != null && player.displayName != pair.Value)
                {
                    player.displayName = pair.Value;
                    if (player.net != null) player._name = string.Format("{1}[{0}/{2}]", player.net.ID, pair.Value, player.userID);
                    player.SendNetworkUpdate();
                }
            }
            if (enableClanRadar)
            {
                var objects = GameObject.FindObjectsOfType(typeof(ClanRadar));
                if (objects != null) foreach (var gameObj in objects) GameObject.Destroy(gameObj);
            }
        }

        void LoadData()
        {
            StoredData protoStorage = new StoredData();
            StoredData jsonStorage = new StoredData();
            StoredData oldStorage = new StoredData();
            bool protoFileFound = ProtoStorage.Exists(new string[] {
                this.Title
            }
            );
            bool jsonFileFound = Interface.GetMod().DataFileSystem.ExistsDatafile(this.Title);
            bool oldFileFound = Interface.GetMod().DataFileSystem.ExistsDatafile("rustio_clans");
            if (!protoFileFound && !jsonFileFound) oldStorage = Interface.GetMod().DataFileSystem.ReadObject<StoredData>("rustio_clans");
            else
            {
                if (jsonFileFound) jsonStorage = Interface.GetMod().DataFileSystem.ReadObject<StoredData>(this.Title);
                if (protoFileFound) protoStorage = ProtoStorage.Load<StoredData>(new string[] {
                    this.Title
                }
                );
            }
            bool lastwasProto = (protoStorage.lastStorage == "proto" && (protoStorage.saveStamp > jsonStorage.saveStamp || protoStorage.saveStamp > oldStorage.saveStamp));
            if (useProtostorageClandata)
            {
                if (lastwasProto)
                    clanSaves = ProtoStorage.Load<StoredData>(new string[] { this.Title }) ?? new StoredData();
                else
                {
                    if (oldFileFound && !jsonFileFound) clanSaves = Interface.GetMod().DataFileSystem.ReadObject<StoredData>("rustio_clans");
                    if (jsonFileFound) clanSaves = Interface.GetMod().DataFileSystem.ReadObject<StoredData>(this.Title);
                }
            }
            else
            {
                if (!lastwasProto)
                {
                    if (oldFileFound && !jsonFileFound) clanSaves = Interface.GetMod().DataFileSystem.ReadObject<StoredData>("rustio_clans");
                    if (jsonFileFound) clanSaves = Interface.GetMod().DataFileSystem.ReadObject<StoredData>(this.Title);
                }
                else if (protoFileFound) clanSaves = ProtoStorage.Load<StoredData>(new string[] {
                    this.Title
                }
                ) ?? new StoredData();
            }
            if (wipeClansOnNewSave && newSaveDetected)
            {
                if (useProtostorageClandata) ProtoStorage.Save<StoredData>(clanSaves, new string[] {
                    this.Title+".bak"}
                );
                else Interface.Oxide.DataFileSystem.WriteObject(this.Title + ".bak", clanSaves);
                Puts("New save detected > Created backup of clans and wiped datafile.");
                clans = new Dictionary<string, Clan>();
                clansSearch = new Dictionary<string, string>();
                return;
            }
            clans = new Dictionary<string, Clan>();
            clansSearch = new Dictionary<string, string>();
            if (clanSaves.clans == null || clanSaves.clans.Count == 0) return;
            Puts("Loading clans data");
            clans = clanSaves.clans;
            InitializeClans(!jsonFileFound && !protoFileFound);
        }

        void InitializeClans(bool newFileFound)
        {
            Dictionary<string, int> clanDuplicates = new Dictionary<string, int>();
            List<string> clanDuplicateCount = new List<string>();
            foreach (var _clan in clans.ToList())
            {
                Clan clan = _clan.Value;
                if (purgeOldClans && (UnixTimeStampUTC() - clan.updated) > (notUpdatedSinceDays * 86400))
                {
                    purgedClans.Add($"[{clan.tag}] | {clan.description} | Owner: {clan.owner} | LastUpd: {UnixTimeStampToDateTime(clan.updated)}");
                    if (permission.GroupExists(permGroupPrefix + clan.tag))
                    {
                        foreach (var member in clan.members) if (permission.UserHasGroup(member.Key, permGroupPrefix + clan.tag)) permission.RemoveUserGroup(member.Key, permGroupPrefix + clan.tag);
                        permission.RemoveGroup(permGroupPrefix + clan.tag);
                    }
                    RemoveClan(clan.tag);
                    continue;
                }
                foreach (var member in clan.members.ToList())
                {
                    var p = covalence.Players.FindPlayerById(member.Key);
                    if (!(p is IPlayer) || p == null || p.Name == "")
                    {
                        clan.members.Remove(member.Key);
                        clan.moderators.Remove(member.Key);
                    }
                }
                if (clan.members.Count() == 0)
                {
                    RemoveClan(clan.tag);
                    continue;
                }
                if (!clan.members.ContainsKey(clan.owner)) clan.owner = clan.members.ToList()[0].Key;
                if (usePermGroups && !permission.GroupExists(permGroupPrefix + clan.tag)) permission.CreateGroup(permGroupPrefix + clan.tag, "Clan " + clan.tag, 0);
                foreach (var member in clan.members)
                {
                    if (usePermGroups && !permission.UserHasGroup(member.Key, permGroupPrefix + clan.tag)) permission.AddUserGroup(member.Key, permGroupPrefix + clan.tag);
                }
                foreach (var invited in clan.invites.ToList())
                {
                    if ((UnixTimeStampUTC() - (int)invited.Value) > (inviteValidDays * 86400)) clan.invites.Remove(invited.Key);
                }
                clanCache[clan.owner] = clan;
                foreach (var member in clan.members)
                {
                    if (!clanDuplicates.ContainsKey(member.Key))
                    {
                        clanDuplicates.Add(member.Key, 1);
                        clanCache[member.Key] = clan;
                        continue;
                    }
                    else
                    {
                        clanDuplicates[member.Key] += 1;
                        if (!clanDuplicateCount.Contains(member.Key)) clanDuplicateCount.Add(member.Key);
                    }
                    clanCache[member.Key] = clan;
                }
                foreach (var invite in clan.invites)
                {
                    if (!pendingPlayerInvites.ContainsKey(invite.Key)) pendingPlayerInvites.Add(invite.Key, new List<string>());
                    pendingPlayerInvites[invite.Key].Add(clan.tag);
                }
                clan.total = clan.members.Count();
                clan.mods = clan.moderators.Count();
                if (clan.created == 0) clan.created = UnixTimeStampUTC();
                if (clan.updated == 0) clan.updated = UnixTimeStampUTC();
                if (!clansSearch.ContainsKey(clan.tag.ToLower())) clansSearch.Add(clan.tag.ToLower(), clan.tag);
            }
            if (clanDuplicateCount.Count > 0) PrintWarning($"Found '{clanDuplicateCount.Count()}' player(s) in multiple clans. Check `clans.showduplicates`");
            Puts($"Loaded data with '{clans.Count}' valid Clans and overall '{clanCache.Count}' Members.");
            if (newFileFound) SaveData(true);
        }
        void SaveData(bool force = false)
        {
            if (!Initialized && !force) return;
            clanSaves.clans = clans;
            clanSaves.saveStamp = UnixTimeStampUTC();
            clanSaves.lastStorage = useProtostorageClandata ? "proto" : "json";
            if (useProtostorageClandata)
                ProtoStorage.Save<StoredData>(clanSaves, new string[] { this.Title });

            else Interface.Oxide.DataFileSystem.WriteObject(this.Title, clanSaves);
        }
        public Clan findClan(string tag)
        {
            Clan clan;
            if (TryGetClan(tag, out clan)) return clan;
            return null;
        }

        public Clan findClanByUser(string userId)
        {
            Clan clan;
            if (clanCache.TryGetValue(userId, out clan)) return clan;
            return null;
        }

        void setupPlayer(BasePlayer player, string cName = "", string cId = "")
        {
            if (player == null || player.UserIDString == "" || player.displayName == "") return;
            if (player.GetInfoInt("noRadarAdmin", 0) != 0)
            {
                if (player.GetInfoInt("noRadarAdmin", 0) == 1) player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, false);
            }
            if (cName == "" || cId == "")
            {
                var current = this.covalence.Players.FindPlayerById(player.UserIDString);
                if (current == null) return;
                cName = current.Name;
                cId = current.Id;
            }
            if (!originalNames.ContainsKey(cId)) originalNames.Add(cId, cName);
            else originalNames[cId] = cName;
            var prevName = player.displayName;
            var clan = findClanByUser(cId);
            if (clan == null)
            {
                if (enableClanTagging)
                {
                    player.displayName = cName;
                    if (player.IsConnected) player._name = string.Format("{1}[{0}/{2}]", player.net.ID, cName, player.userID);
                }
            }
            else
            {
                if (enableClanRadar)
                {
                    if (!clanRadarMemberobjects.ContainsKey(clan.tag)) clanRadarMemberobjects.Add(clan.tag, new List<BasePlayer>());
                    if (!clanRadarMemberobjects[clan.tag].Contains(player)) clanRadarMemberobjects[clan.tag].Add(player);
                }
                if (enableClanTagging)
                {
                    player.displayName = $"[{clan.tag}] {cName}";
                }
                if (player.IsConnected)
                {
                    if (enableClanTagging) player._name = string.Format("{1}[{0}/{2}]", player.net.ID, $"[{clan.tag}] {cName}", player.userID);
                    clan.online++;
                }
                if (enableClanRadar && enableAtLogin && player.IsConnected)
                {
                    ClanRadar radar = player.transform.GetOrAddComponent<ClanRadar>();
                    radar.DoStart();
                }
            }
            if (enableClanTagging && player.displayName != prevName) player.SendNetworkUpdate();
        }
        void setupPlayers(List<string> playerIds)
        {
            if (enableClanTagging) foreach (var playerId in playerIds)
                {
                    var player = rust.FindPlayerByIdString(playerId);
                    if (player != null) setupPlayer(player);
                }
        }
        void OnPlayerConnected(BasePlayer player)
        {
            if (player == null || player.net == null || player.net.connection == null) return;
            player.displayName = player.net.connection.username;
            setupPlayer(player, player.net.connection.username, player.UserIDString);
            var clan = findClanByUser(player.UserIDString);
            ServerMgr.Instance.StartCoroutine(WaitForReady(player, clan));
        }
        IEnumerator WaitForReady(BasePlayer player, Clan clan = null)
        {
            yield return new WaitWhile(new System.Func<bool>(() => player.IsReceivingSnapshot && player.IsSleeping()));
            if (player.IsDead()) yield return null;
            ComingOnlineInfo(player, clan);
            yield return null;
        }
        void ComingOnlineInfo(BasePlayer player, Clan clan = null)
        {
            if (player == null) return;
            if (clan != null)
            {
                if (enableComesOnlineMsg) clan.BroadcastLoc("comeonline", clan.ColNam(player.UserIDString, player.net.connection.username), "", "", "", player.UserIDString);
                if (enableWhoIsOnlineMsg)
                {
                    var sb = new StringBuilder();
                    sb.Append($"<color={colorTextMsg}>");
                    sb.Append(string.Format(msg("memberon", player.UserIDString)));
                    int n = 0;
                    foreach (var memberId in clan.members)
                    {
                        var op = this.covalence.Players.FindPlayerById(memberId.Key);
                        if (op != null && op.IsConnected)
                        {
                            var memberName = op.Name;
                            if (op.Name == player.net.connection.username) memberName = msg("yourname", player.UserIDString);
                            if (n > 0) sb.Append(", ");
                            if (clan.IsOwner(memberId.Key))
                            {
                                sb.Append(string.Format(msg("overviewnamecolor", player.UserIDString), clanOwnerColor, memberName));
                            }
                            else if (clan.IsCouncil(memberId.Key))
                            {
                                sb.Append(string.Format(msg("overviewnamecolor", player.UserIDString), clanCouncilColor, memberName));
                            }
                            else if (clan.IsModerator(memberId.Key))
                            {
                                sb.Append(string.Format(msg("overviewnamecolor", player.UserIDString), clanModeratorColor, memberName));
                            }
                            else
                            {
                                sb.Append(string.Format(msg("overviewnamecolor", player.UserIDString), clanMemberColor, memberName));
                            }
                            ++n;
                        }
                    }
                    sb.Append($"</color>");
                    PrintChat(player, sb.ToString().TrimEnd());
                }
                clan.updated = UnixTimeStampUTC();
                manuallyEnabledBy.Remove(player.userID);
                if (enableClanAllies && (clan.IsOwner(player.UserIDString) || clan.IsCouncil(player.UserIDString)) && clan.pendingInvites.Count > 0)
                {
                    if (player != null) PrintChat(player, string.Format(msg("allyPendingInfo", player.UserIDString)));
                }
                return;
            }
            if (pendingPlayerInvites.ContainsKey(player.UserIDString))
            {
                foreach (var invitation in pendingPlayerInvites[player.UserIDString] as List<string>)
                {
                    Clan newclan = findClan(invitation);
                    if (newclan != null) timer.Once(3f, () =>
                    {
                        if (player != null) PrintChat(player, string.Format(msg("claninvite", player.UserIDString), newclan.tag, newclan.description, colorCmdUsage));
                    }
                     );
                }
            }
        }
        void OnPlayerDisconnected(BasePlayer player)
        {
            var clan = findClanByUser(player.UserIDString);
            if (clan != null)
            {
                clan.BroadcastLoc("goneoffline", clan.ColNam(player.UserIDString, player.net.connection.username), "", "", "", player.UserIDString);
                clan.online--;
                manuallyEnabledBy.Remove(player.userID);
                if (enableClanRadar) activeRadarUsers.Remove(player.UserIDString);
            }
        }
        void OnDie(BasePlayer player)
        {
            if (player == null || !enableClanRadar) return;
            string tag = GetClanOf(player);
            if (tag != null && clanRadarMemberobjects.ContainsKey(tag)) clanRadarMemberobjects[tag].Remove(player);
        }
        void OnPlayerRespawned(BasePlayer player)
        {
            if (player == null || !enableClanRadar) return;
            string tag = GetClanOf(player);
            if (tag == null) return;
            if (!clanRadarMemberobjects.ContainsKey(tag)) clanRadarMemberobjects.Add(tag, new List<BasePlayer>());
            if (!clanRadarMemberobjects[tag].Contains(player)) clanRadarMemberobjects[tag].Add(player);
            if (activeRadarUsers.Contains(player.UserIDString))
            {
                ClanRadar radar = player.transform.GetOrAddComponent<ClanRadar>();
                radar.DoStart();
            }
        }

        void OnPlayerAttack(BasePlayer attacker, HitInfo hit)
        {
            if (!enableFFOPtion || attacker == null || hit == null || !(hit.HitEntity is BasePlayer)) return;
            OnAttackShared(attacker, hit.HitEntity as BasePlayer, hit);
        }

        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hit)
        {
            try
            {
                if (entity == null || hit == null) return;
                if (entity is BaseHelicopter && hit.Initiator is BasePlayer)
                    LastHeliHit[entity.net.ID] = hit.InitiatorPlayer.userID;

                if (!enableFFOPtion || !(entity is BasePlayer) || !(hit.Initiator is BasePlayer)) return;
                OnAttackShared(hit.Initiator as BasePlayer, entity as BasePlayer, hit);
            }
            catch (NullReferenceException)
            { }
        }
        object OnAttackShared(BasePlayer attacker, BasePlayer victim, HitInfo hit)
        {
            if (bypass.Contains(victim.userID) || attacker == victim) return null;
            var victimClan = findClanByUser(victim.UserIDString);
            var attackerClan = findClanByUser(attacker.UserIDString);
            if (victimClan == null || attackerClan == null) return null;
            if (victimClan.tag == attackerClan.tag)
            {
                if (manuallyEnabledBy.Contains(attacker.userID) && !forceClanFFNoDeactivate) return null;
                DateTime now = DateTime.UtcNow;
                DateTime time;
                var key = attacker.UserIDString + "-" + victim.UserIDString;
                if (!notificationTimes.TryGetValue(key, out time) || time < now.AddSeconds(-friendlyFireNotifyTimeout))
                {
                    PrintChat(attacker, string.Format(msg("friendlyfire", attacker.UserIDString), victim.displayName, colorCmdUsage));
                    notificationTimes[key] = now;
                }
                hit.damageTypes = new DamageTypeList();
                hit.DidHit = false;
                hit.HitEntity = null;
                hit.Initiator = null;
                hit.DoHitEffects = false;
                return false;
            }
            if (victimClan.tag != attackerClan.tag && enableClanAllies && enableAllyFFOPtion)
            {
                if (!victimClan.clanAlliances.Contains(attackerClan.tag)) return null;
                if (manuallyEnabledBy.Contains(attacker.userID) && !forceAllyFFNoDeactivate) return null;
                DateTime now = DateTime.UtcNow;
                DateTime time;
                var key = attacker.UserIDString + "-" + victim.UserIDString;
                if (!notificationTimes.TryGetValue(key, out time) || time < now.AddSeconds(-friendlyFireNotifyTimeout))
                {
                    PrintChat(attacker, string.Format(msg("allyfriendlyfire", attacker.UserIDString), victim.displayName));
                    notificationTimes[key] = now;
                }
                hit.damageTypes = new DamageTypeList();
                hit.DidHit = false;
                hit.HitEntity = null;
                hit.Initiator = null;
                hit.DoHitEffects = false;
                return false;
            }
            return null;
        }
        void AllyRemovalCheck()
        {
            foreach (var ally in clans)
            {
                try
                {
                    Clan allyClan = clans[ally.Key];
                    foreach (var clanAlliance in allyClan.clanAlliances.ToList())
                    {
                        if (!clans.ContainsKey(clanAlliance)) allyClan.clanAlliances.Remove(clanAlliance);
                    }
                    foreach (var invitedAlly in allyClan.invitedAllies.ToList())
                    {
                        if (!clans.ContainsKey(invitedAlly)) allyClan.clanAlliances.Remove(invitedAlly);
                    }
                    foreach (var pendingInvite in allyClan.pendingInvites.ToList())
                    {
                        if (!clans.ContainsKey(pendingInvite)) allyClan.clanAlliances.Remove(pendingInvite);
                    }
                }
                catch
                {
                    PrintWarning("Ally removal check failed. Please contact the developer.");
                }
            }
        }
        void cmdChatClan(BasePlayer player, string command, string[] args)
        {
            if (player == null) return;
            if (args.Length == 0)
            {
                cmdClanOverview(player);
                return;
            }
            string opt = args[0];
            if (opt == msg("clanArgCreate", player.UserIDString))
            {
                cmdClanCreate(player, args);
                return;
            }
            else if (opt == msg("clanArgInvite", player.UserIDString))
            {
                cmdClanInvite(player, args);
                return;
            }
            else if (opt == msg("clanArgWithdraw", player.UserIDString))
            {
                cmdClanWithdraw(player, args);
                return;
            }
            else if (opt == msg("clanArgJoin", player.UserIDString))
            {
                cmdClanJoin(player, args);
                return;
            }
            else if (opt == msg("clanArgPromote", player.UserIDString))
            {
                cmdClanPromote(player, args);
                return;
            }
            else if (opt == msg("clanArgDemote", player.UserIDString))
            {
                cmdClanDemote(player, args);
                return;
            }
            else if (opt == msg("clanArgLeave", player.UserIDString))
            {
                cmdClanLeave(player, args);
                return;
            }
            else if (opt == msg("clanArgFF", player.UserIDString))
            {
                if (!enableFFOPtion) return;
                cmdChatClanFF(player, command, args);
                return;
            }
            else if (opt == msg("clanArgRadar", player.UserIDString))
            {
                if (!enableClanRadar || (usePermissionClanRadar && !permission.UserHasPermission(player.UserIDString, permissionClanRadarUse))) return;
                cmdChatClanRadar(player, command, args);
                return;
            }
            else if (opt == msg("clanArgAlly", player.UserIDString))
            {
                if (!enableClanAllies) return;
                for (var i = 0;
                i < args.Length - 1;
                ++i)
                {
                    if (i < args.Length) args[i] = args[i + 1];
                }
                Array.Resize(ref args, args.Length - 1);
                cmdChatClanAlly(player, command, args);
                return;
            }
            else if (opt == msg("clanArgKick", player.UserIDString))
            {
                cmdClanKick(player, args);
                return;
            }
            else if (opt == msg("clanArgDisband", player.UserIDString))
            {
                cmdClanDisband(player, args);
                return;
            }
            else cmdChatClanHelp(player, command, args);
        }
        void cmdClanOverview(BasePlayer player)
        {
            var current = this.covalence.Players.FindPlayerById(player.UserIDString);
            var myClan = findClanByUser(current.Id);
            var sb = new StringBuilder();

            string Messages = pluginPrefixREBORNShow == true ? $"<size=14><color={pluginPrefixREBORNColor}>REBORN\n</color></size>" : "\n";
            sb.Append($"<size=18><color={pluginPrefixColor}>{this.Title}</color></size>{Messages}");

            if (myClan == null)
            {
                sb.AppendLine(string.Format(msg("notmember", current.Id)));
                sb.AppendLine(string.Format(msg("viewthehelp", current.Id), colorCmdUsage, $"{chatCommandClan + "help"} | /{chatCommandClan}"));
                SendReply(player, $"<color={colorTextMsg}>{sb.ToString().TrimEnd()}</color>");
                return;
            }
            ClanUI(player);
            if (myClan.IsOwner(current.Id)) sb.Append(string.Format(msg("youareownerof", current.Id)));
            else if (myClan.IsCouncil(current.Id)) sb.Append(string.Format(msg("youarecouncilof", current.Id)));
            else if (myClan.IsModerator(current.Id)) sb.Append(string.Format(msg("youaremodof", current.Id)));
            else sb.Append(string.Format(msg("youarememberof", current.Id)));
            sb.AppendLine($" <color={colorClanNamesOverview}>{myClan.tag}</color> ( {myClan.online}/{myClan.total} )");
            sb.Append(string.Format(msg("memberon", current.Id)));
            int n = 0;
            foreach (var memberId in myClan.members)
            {
                var op = this.covalence.Players.FindPlayerById(memberId.Key);
                if (op != null && op.IsConnected)
                {
                    var memberName = op.Name;
                    if (op.Name == current.Name) memberName = msg("yourname", current.Id);
                    if (n > 0) sb.Append(", ");
                    var memberOn = string.Empty;
                    if (myClan.IsOwner(memberId.Key))
                    {
                        memberOn = string.Format(msg("overviewnamecolor", current.Id), clanOwnerColor, memberName);
                    }
                    else if (myClan.IsCouncil(memberId.Key))
                    {
                        memberOn = string.Format(msg("overviewnamecolor", current.Id), clanCouncilColor, memberName);
                    }
                    else if (myClan.IsModerator(memberId.Key))
                    {
                        memberOn = string.Format(msg("overviewnamecolor", current.Id), clanModeratorColor, memberName);
                    }
                    else
                    {
                        memberOn = string.Format(msg("overviewnamecolor", current.Id), clanMemberColor, memberName);
                    }
                    ++n;
                    sb.Append(memberOn);
                }
            }
            if (n > 0) sb.AppendLine();
            bool offline = false;
            foreach (var memberId in myClan.members)
            {
                var op = this.covalence.Players.FindPlayerById(memberId.Key);
                if (op != null && !op.IsConnected)
                {
                    offline = true;
                    break;
                }
            }
            if (offline)
            {
                sb.Append(string.Format(msg("memberoff", current.Id)));
                n = 0;
                foreach (var memberId in myClan.members)
                {
                    var p = this.covalence.Players.FindPlayerById(memberId.Key);
                    var memberOff = string.Empty;
                    if (p != null && !p.IsConnected)
                    {
                        if (n > 0) sb.Append(", ");
                        if (myClan.IsOwner(memberId.Key))
                        {
                            memberOff = string.Format(msg("overviewnamecolor", current.Id), clanOwnerColor, p.Name);
                        }
                        else if (myClan.IsCouncil(memberId.Key))
                        {
                            memberOff = string.Format(msg("overviewnamecolor", current.Id), clanCouncilColor, p.Name);
                        }
                        else if (myClan.IsModerator(memberId.Key))
                        {
                            memberOff = string.Format(msg("overviewnamecolor", current.Id), clanModeratorColor, p.Name);
                        }
                        else
                        {
                            memberOff = string.Format(msg("overviewnamecolor", current.Id), clanMemberColor, p.Name);
                        }
                        ++n;
                        sb.Append(memberOff);
                    }
                }
                if (n > 0) sb.AppendLine();
            }
            if ((myClan.IsOwner(current.Id) || myClan.IsCouncil(current.Id) || myClan.IsModerator(current.Id)) && myClan.invites.Count() > 0)
            {
                sb.Append(string.Format(msg("pendinvites", current.Id)));
                int m = 0;
                foreach (var inviteId in myClan.invites)
                {
                    var p = this.covalence.Players.FindPlayerById(inviteId.Key);
                    if (p != null)
                    {
                        var invitedPlayer = string.Empty;
                        if (m > 0) sb.Append(", ");
                        invitedPlayer = string.Format(msg("overviewnamecolor", current.Id), clanMemberColor, p.Name);
                        ++m;
                        sb.Append(invitedPlayer);
                    }
                }
                if (m > 0) sb.AppendLine();
            }
            if (enableClanAllies && myClan.clanAlliances.Count() > 0) sb.AppendLine(string.Format(msg("yourclanallies", current.Id)) + $" <color={colorClanNamesOverview}>" + string.Join(", ", myClan.clanAlliances.ToArray()) + "</color>");
            if (enableClanAllies && (myClan.invitedAllies.Count() > 0 || myClan.pendingInvites.Count() > 0) && (myClan.IsOwner(current.Id) || myClan.IsCouncil(current.Id)))
            {
                if (myClan.invitedAllies.Count() > 0) sb.AppendLine(string.Format(msg("allyinvites", current.Id)) + $" <color={colorClanNamesOverview}>" + string.Join(", ", myClan.invitedAllies.ToArray()) + "</color> ");
                if (myClan.pendingInvites.Count() > 0) sb.AppendLine(string.Format(msg("allypending", current.Id)) + $" <color={colorClanNamesOverview}>" + string.Join(", ", myClan.pendingInvites.ToArray()) + "</color> ");
                if (myClan.pendingInvites.Count() == 0 && myClan.invitedAllies.Count() == 0) sb.AppendLine();
            }
            if (enableFFOPtion) sb.AppendLine(string.Format(msg("yourffstatus", current.Id)) + " " + (manuallyEnabledBy.Contains(player.userID) ? $"<color={colorClanFFOn}>ON</color>" : $"<color={colorClanFFOff}>OFF</color>") + $" ( <color={colorCmdUsage}>/{chatCommandFF}</color> )");
            if ((enableClanRadar && !usePermissionClanRadar) || enableClanRadar && usePermissionClanRadar && permission.UserHasPermission(current.Id, permissionClanRadarUse)) sb.AppendLine(string.Format(msg("yourradarstatus", current.Id)) + " " + (player.GetComponent<ClanRadar>() ? $"<color={colorClanRadarOn}>ON</color>" : $"<color={colorClanRadarOff}>OFF</color>") + $" ( <color={colorCmdUsage}>/{chatCommandRadar}</color> )");
            sb.AppendLine(string.Format(msg("viewthehelp", current.Id), colorCmdUsage, $"{string.Concat(chatCommandClan, subCommandClanHelp)} | /{chatCommandClan}"));
            string openText = $"<color={colorTextMsg}>";
            string closeText = "</color>";
            string[] parts = sb.ToString().Split(new char[] { '\n' }, StringSplitOptions.RemoveEmptyEntries);
            sb = new StringBuilder();
            foreach (var part in parts)
            {
                if ((sb.ToString().TrimEnd().Length + part.Length + openText.Length + closeText.Length) > 1050)
                {
                    SendReply(player, openText + sb.ToString().TrimEnd() + closeText);
                    sb.Clear();
                }
                sb.AppendLine(part);
            }
            SendReply(player, openText + sb.ToString().TrimEnd() + closeText);
        }
        void cmdClanCreate(BasePlayer player, string[] args)
        {
            var current = this.covalence.Players.FindPlayerById(player.UserIDString);
            var myClan = findClanByUser(current.Id);
            if (myClan != null)
            {
                PrintChat(player, string.Format(msg("youalreadymember", current.Id)));
                return;
            }
            if (usePermToCreateClan && !permission.UserHasPermission(current.Id, permissionToCreateClan))
            {
                PrintChat(player, msg("nopermtocreate", current.Id));
                return;
            }
            if (args.Length < 2)
            {
                PrintChat(player, string.Format(msg("usagecreate", current.Id), colorCmdUsage));
                return;
            }
            if (tagReExt.IsMatch(args[1]))
            {
                PrintChat(player, string.Format(msg("hintchars", current.Id), allowedSpecialChars));
                return;
            }
            if (args[1].Length < tagLengthMin || args[1].Length > tagLengthMax)
            {
                PrintChat(player, string.Format(msg("hintlength", current.Id), tagLengthMin, tagLengthMax));
                return;
            }
            if (args.Length > 2)
            {
                args[2] = args[2].Trim();
                if (args[2].Length < 2 || args[2].Length > 30)
                {
                    PrintChat(player, string.Format(msg("providedesc", current.Id)));
                    return;
                }
            }
            if (enableWordFilter && FilterText(args[1]))
            {
                PrintChat(player, string.Format(msg("bannedwords", current.Id)));
                return;
            }
            string[] clanKeys = clans.Keys.ToArray();
            clanKeys = clanKeys.Select(c => c.ToLower()).ToArray();
            if (clanKeys.Contains(args[1].ToLower()))
            {
                PrintChat(player, string.Format(msg("tagblocked", current.Id)));
                return;
            }
            //Custom code
            myClan = Clan.Create(args[1], args.Length > 2 ? args[2] : string.Empty, current.Id, current.Name, "https://i.imgur.com/mNjQeB7.png");
            clans.Add(myClan.tag, myClan);
            clanCache[current.Id] = myClan;
            setupPlayer(player, current.Name, current.Id);
            if (usePermGroups && !permission.GroupExists(permGroupPrefix + myClan.tag)) permission.CreateGroup(permGroupPrefix + myClan.tag, "Clan " + myClan.tag, 0);
            if (usePermGroups && !permission.UserHasGroup(current.Id, permGroupPrefix + myClan.tag)) permission.AddUserGroup(current.Id, permGroupPrefix + myClan.tag);
            myClan.onCreate();
            myClan.total++;
            PrintChat(player, string.Format(msg("nownewowner", current.Id), myClan.tag, myClan.description) + "\n" + string.Format(msg("inviteplayers", current.Id), colorCmdUsage));
            return;
        }
        public void InvitePlayer(BasePlayer player, string targetId) => cmdClanInvite(player, new string[] {
            "", targetId
        }
        );
        void cmdClanInvite(BasePlayer player, string[] args)
        {
            var current = this.covalence.Players.FindPlayerById(player.UserIDString);
            var myClan = findClanByUser(current.Id);
            if (myClan == null)
            {
                PrintChat(player, string.Format(msg("notmember", current.Id)));
                return;
            }
            if (args.Length < 2)
            {
                PrintChat(player, string.Format(msg("usageinvite", current.Id), colorCmdUsage));
                return;
            }
            if (!myClan.IsOwner(current.Id) && !myClan.IsCouncil(current.Id) && !myClan.IsModerator(current.Id))
            {
                PrintChat(player, string.Format(msg("notmoderator", current.Id)));
                return;
            }
            var invPlayer = myClan.GetIPlayer(args[1]);
            if (invPlayer == null)
            {
                PrintChat(player, string.Format(msg("nosuchplayer", current.Id), args[1]));
                return;
            }
            if (myClan.members.ContainsKey(invPlayer.Id))
            {
                PrintChat(player, string.Format(msg("alreadymember", current.Id), invPlayer.Name));
                return;
            }
            if (myClan.invites.ContainsKey(invPlayer.Id))
            {
                PrintChat(player, string.Format(msg("alreadyinvited", current.Id), invPlayer.Name));
                return;
            }
            if (findClanByUser(invPlayer.Id) != null)
            {
                PrintChat(player, string.Format(msg("alreadyinclan", current.Id), invPlayer.Name));
                return;
            }
            if (usePermToJoinClan && !permission.UserHasPermission(invPlayer.Id, permissionToJoinClan))
            {
                PrintChat(player, string.Format(msg("nopermtojoinbyinvite", current.Id), invPlayer.Name));
                return;
            }
            myClan.invites.Add(invPlayer.Id, UnixTimeStampUTC());
            if (!pendingPlayerInvites.ContainsKey(invPlayer.Id)) pendingPlayerInvites.Add(invPlayer.Id, new List<string>());
            pendingPlayerInvites[invPlayer.Id].Add(myClan.tag);
            myClan.BroadcastLoc("invitebroadcast", myClan.ColNam(current.Id, current.Name), myClan.ColNam(invPlayer.Id, invPlayer.Name));
            if (invPlayer.IsConnected)
            {
                var invited = rust.FindPlayerByIdString(invPlayer.Id);
                if (invited != null) PrintChat(invited, string.Format(msg("claninvite", invPlayer.Id), myClan.tag, myClan.description, colorCmdUsage));
            }
            myClan.updated = UnixTimeStampUTC();
        }



        string ButtonListed = "[{\"name\":\"clans_player{id}\",\"parent\":\"clans_main7\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{color}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.001 {amin}\",\"anchormax\":\"0.998 {amax}\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"CuiElement\",\"parent\":\"clans_player{id}\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"\",\"fontSize\":16,\"font\":\"robotocondensed-bold.ttf\",\"align\":\"MiddleCenter\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.2784314\",\"distance\":\"1 -1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"CuiElement\",\"parent\":\"clans_player{id}\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"{command}\",\"color\":\"1 1 1 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]}]";

        [ConsoleCommand("clanui.page")]
        void cmdConsoleClanUI(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            if (player == null || args == null) return;
            CLanUIInfo(player, null, args.Args);
        }

        private string GetImageUrl(string shortname, ulong skinid) =>
           ImageLibrary.CallHook("GetImageURL", shortname, skinid) as string;

        private void AddLoadOrder(IDictionary<string, string> imageList, bool replace = false) =>
           ImageLibrary?.Call("ImportImageList", Title, imageList, (ulong)ResourceId, replace);

        private string GetImage(string shortname, ulong skinid) =>
           ImageLibrary.CallHook("GetImage", $"{shortname} {skinid}") as string;

        void CLanUIInfo(BasePlayer player, string command, string[] args)
        {
            var sb = new StringBuilder();
            if (findClanByUser(player.UserIDString) == null)
            {
                sb.AppendLine(string.Format(msg("notmember", player.UserIDString)));
                sb.AppendLine(string.Format(msg("viewthehelp", player.UserIDString), colorCmdUsage, $"{chatCommandClan + "help"} | /{chatCommandClan}"));
                SendReply(player, $"<color={colorTextMsg}>{sb.ToString().TrimEnd()}</color>");
                return;
            }
            else
            {
                int page = 0;
                bool Enabled = false;
                if (args.Length > 0)
                    page = int.Parse(args[0]);
                if (args.Length > 1)
                    Enabled = true;
                ClanUI(player, page, Enabled);
            }
        }

        bool? CanWearItem(PlayerInventory inventory, Item item, int targetPos)
        {
            var player = inventory.gameObject.ToBaseEntity() as BasePlayer;
            var clan = findClanByUser(player.UserIDString);
            if (clan != null)
                if (clan.SkinList.ContainsKey(item.info.shortname))
                    item.skin = clan.SkinList[item.info.shortname];
            return null;
        }

        void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            if (!entity.ToPlayer()) return;
            var player = entity.ToPlayer();
            var clan = findClanByUser(player.UserIDString);
            if (clan != null && clan.members[player.UserIDString].GatherInfo.ContainsKey(item.info.shortname))
                if (clan.Change.ContainsKey(item.info.shortname) && clan.Change[item.info.shortname].Complete < clan.Change[item.info.shortname].Need)
                {
                    clan.Change[item.info.shortname].Complete = clan.Change[item.info.shortname].Complete + (uint)item.amount;
                    clan.members[player.UserIDString].GatherInfo[item.info.shortname] = clan.members[player.UserIDString].GatherInfo[item.info.shortname] + item.amount;
                    if (clan.Change[item.info.shortname].Complete > clan.Change[item.info.shortname].Need)
                        clan.Change[item.info.shortname].Complete = clan.Change[item.info.shortname].Need;
                }
        }
        void OnDispenserBonus(ResourceDispenser disp, BasePlayer player, Item item)
        {
            if (player == null) return;
            var clan = findClanByUser(player.UserIDString);
            if (clan != null && clan.members[player.UserIDString].GatherInfo.ContainsKey(item.info.shortname))
            {
                if (clan.Change.ContainsKey(item.info.shortname) && clan.Change[item.info.shortname].Complete < clan.Change[item.info.shortname].Need)
                {
                    clan.Change[item.info.shortname].Complete = clan.Change[item.info.shortname].Complete + (uint)item.amount;
                    clan.members[player.UserIDString].GatherInfo[item.info.shortname] = clan.members[player.UserIDString].GatherInfo[item.info.shortname] + item.amount;
                    if (clan.Change[item.info.shortname].Complete > clan.Change[item.info.shortname].Need)
                        clan.Change[item.info.shortname].Complete = clan.Change[item.info.shortname].Need;
                }
                switch (item.info.shortname)
                {
                    case "stones":
                        clan.members[player.UserIDString].GatherStone += item.amount;
                        clan.members[player.UserIDString].PlayerPoints += PointsOfGatherStone;
                        clan.ClanPoints += PointsOfGatherStone;
                        break;
                    case "wood":
                        clan.members[player.UserIDString].GatherWood += item.amount;
                        clan.members[player.UserIDString].PlayerPoints += PointsOfGatherWood;
                        clan.ClanPoints += PointsOfGatherWood;
                        break;
                    case "metal.ore":
                        clan.members[player.UserIDString].GatherMetal += item.amount;
                        clan.members[player.UserIDString].PlayerPoints += PointsOfGatherMetalOre;
                        clan.ClanPoints += PointsOfGatherMetalOre;
                        break;
                    case "sulfur.ore":
                        clan.members[player.UserIDString].GatherSulfur += item.amount;
                        clan.members[player.UserIDString].PlayerPoints += PointsOfGatherSulfur;
                        clan.ClanPoints += PointsOfGatherSulfur;
                        break;
                    case "hq.metal.ore":
                        clan.members[player.UserIDString].GatherHQM += item.amount;
                        clan.members[player.UserIDString].PlayerPoints += PointsOfGatherHQM;
                        clan.ClanPoints += PointsOfGatherHQM;
                        break;
                }
            }

        }

        [ConsoleCommand("clans_getskinIds")]
        void cmdClansGetSkinList(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            var SkinList = GetImageSkins(args.Args[0]);
            var elements = new CuiElementContainer();

            elements.Add(new CuiElement
            {
                Name = "clans_skinlist",
                Parent = "clans_main2",
                Components =
                    {
                        new CuiRawImageComponent {Color = "0 0 0 0.85",Sprite = "assets/content/ui/ui.background.tile.psd",Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                        new CuiRectTransformComponent {AnchorMin = "0 0", AnchorMax = "1 1"}
                    }
            });

            elements.Add(new CuiElement
            {
                Name = "clans_main200",
                Parent = "clans_main2",
                Components =
                    {
                        new CuiRawImageComponent {Color = "0 0 0 0.85", Sprite = "assets/content/ui/ui.background.tile.psd"},
                        new CuiRectTransformComponent {AnchorMin = "0 1", AnchorMax = "1 1.1"}
                    }
            });

            elements.Add(new CuiElement
            {
                Parent = "clans_main200",
                Components =
                    {
                        new CuiTextComponent { Text = "<size=26>CHOOSE THE SKIN YOU NEED BY JUST CLICKING ON IT</size>", Color = "1 0.9294118 0.8666667 1", Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter},
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" },
                    }
            });

            var poses = GetPositions(7, 5, 0.01f, 0.01f);
            if (SkinList.Count > 35) SkinList.Take(35);
            var count = SkinList.Count < 35 ? SkinList.Count : 35;
            for (int i = 0; i < count; i++)
            {
                elements.Add(new CuiElement
                {
                    Name = "clans_skinlist" + SkinList[i],
                    Parent = "clans_skinlist",
                    Components =
                    {
                        new CuiRawImageComponent {FadeIn = 0.5f, Color = "0.3294118 0.3294118 0.3294118 0.5", Sprite = "assets/content/ui/ui.background.tile.psd"},
                        new CuiRectTransformComponent {AnchorMin = poses[i].AnchorMin, AnchorMax = poses[i].AnchorMax}
                    }
                });

                elements.Add(new CuiElement
                {
                    Parent = "clans_skinlist" + SkinList[i],
                    Components =
                    {
                        new CuiRawImageComponent {FadeIn = 0.5f , Png = GetImageSkin(args.Args[0], SkinList[i])},
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1"}
                    }
                });
                elements.Add(new CuiButton
                {
                    Button = { Color = "0.13 0.44 0.48 0", Command = $"clan_changeskin {args.Args[0]} {SkinList[i]}" },
                    Text = { Text = "", Color = "1 0.9294118 0.8666667 1", FontSize = 14, Align = TextAnchor.MiddleCenter },
                    RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1" },
                }, "clans_skinlist" + SkinList[i]);
            }

            elements.Add(new CuiElement
            {
                Name = "clans_skinlist_input",
                Parent = "clans_skinlist",
                Components =
                    {
                        new CuiRawImageComponent {Color = "0 0 0 0.85", Sprite = "assets/content/ui/ui.background.tile.psd",Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                        new CuiRectTransformComponent {AnchorMin = "0 -0.1", AnchorMax = "1 0"}
                    }
            });


            elements.Add(new CuiElement
            {
                Parent = "clans_skinlist_input",
                Components =
                    {
                        new CuiTextComponent { Text = "<size=24>YOU CAN ALSO ENTER YOUR SKIN ID HERE</size>", Color = "1 0.9294118 0.8666667 0.01", Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter},
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" },
                    }
            });

            elements.Add(new CuiElement()
            {
                Parent = "clans_skinlist_input",
                Components =
                {
                    new CuiInputFieldComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        CharsLimit = 64,
                        FontSize = 26,
                        Command = $"clan_changeskin {args.Args[0]} ",
                        Font = "robotocondensed-bold.ttf",
                        Text = "",
                        Color = "1 0.9294118 0.8666667 1"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0", AnchorMax = "1 1"
                    }
                }
            });


            CuiHelper.AddUi(player, elements);

        }

        [ConsoleCommand("clan_setChange")]
        void cmdSetChangeOfClan(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            CuiHelper.DestroyUi(player, "clan_setChange");

            var clan = findClanByUser(player.UserIDString);
            var elements = new CuiElementContainer();
            elements.Add(new CuiElement
            {
                Name = "clan_setChange",
                Parent = "clans_main2",
                Components =
                    {
                        new CuiRawImageComponent {Color = "0 0 0 0.85",Sprite = "assets/content/ui/ui.background.tile.psd", Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                        new CuiRectTransformComponent {AnchorMin = "0 0", AnchorMax = "1 1"}
                    }
            });
            elements.Add(new CuiElement
            {
                Name = "clan_setChange1",
                Parent = "clan_setChange",
                Components =
                    {
                        new CuiRawImageComponent {Color = "0 0 0 0",Sprite = "assets/content/ui/ui.background.tile.psd"},
                        new CuiRectTransformComponent {AnchorMin = "0.3 0.1", AnchorMax = "0.7 0.99"}
                    }
            });
            var poses = GetPositions(1, clan.Change.Count, 0.01f, 0.01f);

            for (int i = 0; i < clan.Change.Count; i++)
            {
                elements.Add(new CuiElement
                {
                    Name = $"clans_setChange_main{i}",
                    Parent = "clan_setChange1",
                    Components =
                    {
                        new CuiRawImageComponent {Color = "0.3294118 0.3294118 0.3294118 0.1"},
                        new CuiRectTransformComponent {AnchorMin = poses[i].AnchorMin, AnchorMax = poses[i].AnchorMax}
                    }
                });

                elements.Add(new CuiElement
                {
                    Parent = $"clans_setChange_main{i}",
                    Components =
                    {
                        new CuiRawImageComponent {Color = "1 1 1 1", Png = (string)ImageLibrary.Call("GetImage", clan.Change.ToList()[i].Key)},
                        new CuiRectTransformComponent {AnchorMin = "0.05 0", AnchorMax = "0.2 1"}
                    }
                });
                elements.Add(new CuiElement
                {
                    Parent = $"clans_setChange_main{i}",
                    Components =
                    {
                        new CuiTextComponent { Text = $"Установлено:\n{clan.Change.ToList()[i].Value.Need.ToString("N3", CultureInfo.GetCultureInfo("ru-RU")).Replace(",000", "")}".ToUpper(), Color = "1 0.9294118 0.8666667 1", Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter},
                        new CuiRectTransformComponent { AnchorMin = "0.3 0", AnchorMax = "0.6 1" },
                    }
                });

                elements.Add(new CuiElement
                {
                    Name = $"clans_setChange_main1{i}",
                    Parent = $"clans_setChange_main{i}",
                    Components =
                    {
                        new CuiRawImageComponent {Color = "0.3294118 0.3294118 0.3294118 0.5"},
                        new CuiRectTransformComponent { AnchorMin = "0.65 0.15", AnchorMax = "0.9 0.85"}
                    }
                });

                elements.Add(new CuiElement()
                {
                    Parent = $"clans_setChange_main1{i}",
                    Components =
                    {
                        new CuiInputFieldComponent {Align = TextAnchor.MiddleCenter,CharsLimit = 7,FontSize = 15,
                            Command = $"clan_Change {clan.Change.ToList()[i].Key} ",Font = "robotocondensed-bold.ttf",Text = "", Color = "1 0.9294118 0.8666667 1"},
                        new CuiRectTransformComponent {AnchorMin = "0 0", AnchorMax = "1 1"}
                    }
                });


                elements.Add(new CuiButton
                {
                    Button = { Color = "0.25 0.25 0.23 0.9", Command = $"" },
                    Text = { Text = "OK", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-bold.ttf", Color = "1 0.9294118 0.8666667 1" },
                    RectTransform = { AnchorMin = $"0.9 0.15", AnchorMax = $"0.997 0.85" },
                }, $"clans_setChange_main{i}");
            }

            elements.Add(new CuiButton
            {
                Button = { Color = "0.13 0.44 0.48 0.7", Command = $"clanui.page 0" },
                Text = { Text = "ЗАВЕРШИТЬ", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-bold.ttf", Color = "1 0.9294118 0.8666667 1" },
                RectTransform = { AnchorMin = $"0.4 0.03", AnchorMax = $"0.6 0.09" },
            }, $"clan_setChange");
            CuiHelper.AddUi(player, elements);
        }

        [ConsoleCommand("clan_Change")]
        void cmdSetNewChangeOfClan(ConsoleSystem.Arg args)
        {
            var player = args.Player();

            if (args.GetString(1) == "") return;

            int amount;
            if (!int.TryParse(args.Args[1], out amount)) return;

            var clan = findClanByUser(player.UserIDString);
            if (clan.Change.ContainsKey(args.Args[0]))
            {
                clan.Change[args.Args[0]].Need = (uint)amount;
            }
            cmdSetChangeOfClan(args);
        }


        [ConsoleCommand("clan_setAvatar")]
        void cmdSetAvatarOfClan(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            CuiHelper.DestroyUi(player, "clans_setAvatar");

            var elements = new CuiElementContainer();
            elements.Add(new CuiElement
            {
                Name = "clans_setAvatar",
                Parent = "clans_main2",
                Components =
                    {
                        new CuiRawImageComponent {Color = "0 0 0 0.85",Sprite = "assets/content/ui/ui.background.tile.psd", Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                        new CuiRectTransformComponent {AnchorMin = "0 0", AnchorMax = "1 1"}
                    }
            });

            elements.Add(new CuiElement
            {
                Name = "clans_setAvatar_input",
                Parent = "clans_setAvatar",
                Components =
                    {
                        new CuiRawImageComponent {Color = "0.3294118 0.3294118 0.3294118 0.5"},
                        new CuiRectTransformComponent {AnchorMin = "0.05 0.45", AnchorMax = "0.8 0.55"}
                    }
            });

            elements.Add(new CuiElement
            {
                Parent = "clans_setAvatar_input",
                Components =
                    {
                        new CuiTextComponent { Text = "<size=24>СКОПИРУЙТЕ СЮДА ССЫЛКУ И НАЖМИТЕ СОХРАНИТЬ</size>", Color = "1 0.9294118 0.8666667 0.05", Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter},
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" },
                    }
            });

            elements.Add(new CuiButton
            {
                Button = { Color = "0.13 0.44 0.48 0.7", Command = $"clanui.page 0" },
                Text = { Text = "ЗАКРЫТЬ", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-bold.ttf", Color = "1 0.9294118 0.8666667 1" },
                RectTransform = { AnchorMin = $"0.3 0.38", AnchorMax = $"0.7 0.44" },
            }, $"clans_setAvatar");

            elements.Add(new CuiElement()
            {
                Parent = "clans_setAvatar_input",
                Components =
                {
                    new CuiInputFieldComponent
                    {
                        Align = TextAnchor.MiddleCenter,
                        CharsLimit = 80,
                        FontSize = 26,
                        Command = $"clan_changeAvatar ",
                        Font = "robotocondensed-bold.ttf",
                        Text = "",
                        Color = "1 0.9294118 0.8666667 1"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = "0 0", AnchorMax = "1 1"
                    }
                }
            });

            elements.Add(new CuiButton
            {
                Button = { Color = "0.25 0.25 0.23 0.9", Command = "" },
                Text = { Text = "СОХРАНИТЬ", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-bold.ttf", Color = "1 0.9294118 0.8666667 1" },
                RectTransform = { AnchorMin = $"1 0", AnchorMax = $"1.2 0.993" },
            }, "clans_setAvatar_input");

            CuiHelper.AddUi(player, elements);
        }

        class Position
        {
            public float Xmin;
            public float Xmax;
            public float Ymin;
            public float Ymax;

            public string AnchorMin =>
                $"{Math.Round(Xmin, 4).ToString(CultureInfo.InvariantCulture)} {Math.Round(Ymin, 4).ToString(CultureInfo.InvariantCulture)}";
            public string AnchorMax =>
                $"{Math.Round(Xmax, 4).ToString(CultureInfo.InvariantCulture)} {Math.Round(Ymax, 4).ToString(CultureInfo.InvariantCulture)}";

            public override string ToString()
            {
                return $"----------\nAmin:{AnchorMin}\nAmax:{AnchorMax}\n----------";
            }
        }

        [SuppressMessage("ReSharper", "CompareOfFloatsByEqualityOperator")]
        private static List<Position> GetPositions(int colums, int rows, float colPadding = 0, float rowPadding = 0, bool columsFirst = false)
        {
            if (colums == 0)
                throw new ArgumentException("Can't create positions for gui!", nameof(colums));
            if (rows == 0)
                throw new ArgumentException("Can't create positions for gui!", nameof(rows));

            List<Position> result = new List<Position>();
            result.Clear();
            var colsDiv = 1f / colums;
            var rowsDiv = 1f / rows;
            if (colPadding == 0) colPadding = colsDiv / 2;
            if (rowPadding == 0) rowPadding = rowsDiv / 2;
            if (!columsFirst)
                for (int j = rows; j >= 1; j--)
                {
                    for (int i = 1; i <= colums; i++)
                    {
                        Position pos = new Position
                        {
                            Xmin = (i - 1) * colsDiv + colPadding / 2f,
                            Xmax = i * colsDiv - colPadding / 2f,
                            Ymin = (j - 1) * rowsDiv + rowPadding / 2f,
                            Ymax = j * rowsDiv - rowPadding / 2f
                        };
                        result.Add(pos);
                    }
                }
            else
                for (int i = 1; i <= colums; i++)
                {
                    for (int j = rows; j >= 1; j--)
                    {
                        Position pos = new Position
                        {
                            Xmin = (i - 1) * colsDiv + colPadding / 2f,
                            Xmax = i * colsDiv - colPadding / 2f,
                            Ymin = (j - 1) * rowsDiv + rowPadding / 2f,
                            Ymax = j * rowsDiv - rowPadding / 2f
                        };
                        result.Add(pos);
                    }
                }
            return result;
        }

        [ConsoleCommand("clan_changeskin")]
        void cmdChatSkinOfClan(ConsoleSystem.Arg args)
        {
            if (args.GetString(1) == "") return;
            var player = args.Player();
            if (player == null) return;
            var clan = findClanByUser(player.UserIDString);
            if (clan == null) return;

            ulong SkinID;
            if (!ulong.TryParse(args.Args[1], out SkinID)) return;

            //if (string.IsNullOrEmpty(GetImageUrl(args.Args[0], SkinID))) return;

            //ImageLibrary?.Call("AddImage", GetImageUrl(args.Args[0], SkinID), args.Args[0], SkinID);
            clan.SkinList[args.Args[0]] = SkinID;
            ClanUI(player, 0, true);
        }

        [ConsoleCommand("clan_kickplayer")]
        void cmdKickOfClan(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            KickPlayer(player, args.Args[0]);
            ClanUI(player, 0);
        }

        [ConsoleCommand("clan_changeAvatar")]
        void cmdChangeAvatarOfClan(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            if (args.GetString(0) == "" || !args.Args[0].Contains("http") || !args.Args[0].Contains(".png") && !args.Args[0].Contains(".jpg")) return;

            var clan = findClanByUser(player.UserIDString);
            clan.ClanAvatar = args.Args[0];
            ImageLibrary.Call("AddImage", clan.ClanAvatar, clan.ClanAvatar);
            ClanUI(player, 0);
        }

        private Dictionary<uint, ulong> LastHeliHit = new Dictionary<uint, ulong>();

        private BasePlayer GetLastHeliAttacker(uint heliNetId)
        {
            ulong player;
            LastHeliHit.TryGetValue(heliNetId, out player);
            return BasePlayer.FindByID(player);
        }

        void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (info == null || entity?.net?.ID == null) return;
            var player = info?.InitiatorPlayer;
            if (player == null) return;
            var clan = findClanByUser(player.UserIDString);
            if (clan == null) return;
            if (entity.PrefabName.Contains("barrel"))
            {
                if (clan.Change["loot-barrel"].Complete < clan.Change["loot-barrel"].Need && clan.Change["loot-barrel"].Need > 0)
                {
                    clan.Change["loot-barrel"].Complete++;
                    clan.members[player.UserIDString].GatherInfo["loot-barrel"]++;
                }
                clan.members[player.UserIDString].KilledBarrel++;
                clan.members[player.UserIDString].PlayerPoints += PointsOfBarrel;
                clan.ClanPoints += PointsOfBarrel;
            }

            if (entity is BaseHelicopter && GetLastHeliAttacker(entity.net.ID) == player)
            {
                clan.members[player.UserIDString].KilledHeli++;
                clan.ClanPoints += PointsOfKilledHeli;
                clan.members[player.UserIDString].PlayerPoints += PointsOfKilledHeli;
            }

            if (entity.ToPlayer() != null && entity as BasePlayer)
            {
                if (entity.GetComponent<NPCPlayer>() != null) return;
                if (IsNPC(entity.ToPlayer())) return;
                if (entity.ToPlayer() == info.Initiator.ToPlayer())
                {
                    clan.ClanPoints -= PointsOfSuicide;
                    clan.members[player.UserIDString].Suicide++;
                    clan.members[player.UserIDString].PlayerPoints -= PointsOfSuicide;
                }
                else
                {
                    clan.ClanPoints += PointsOfKilled;
                    clan.members[player.UserIDString].Killed++;
                    clan.members[player.UserIDString].PlayerPoints += PointsOfKilled;
                }
                if (findClanByUser(entity.ToPlayer().UserIDString) != null)
                {
                    findClanByUser(entity.ToPlayer().UserIDString).ClanPoints -= PointsOfDeath;
                    findClanByUser(entity.ToPlayer().UserIDString).members[entity.ToPlayer().UserIDString].PlayerPoints -= PointsOfDeath;
                    findClanByUser(entity.ToPlayer().UserIDString).members[entity.ToPlayer().UserIDString].Death++;
                }
            }
        }

        private bool IsNPC(BasePlayer player)
        {
            if (player == null) return false;
            if (player is NPCPlayer) return true;
            if (!(player.userID >= 76560000000000000L || player.userID <= 0L) || player.UserIDString.Length < 17) return true;
            return false;
        }

        [PluginReference]
        private Plugin ItemNameLocalizator;

        private bool IsInlReady => (bool?)ItemNameLocalizator?.CallHook("IsReady") == true;
        public bool IsReady() => (bool)ImageLibrary?.Call("IsReady");


        private string GetItemName(string shortname, object player)
        {
            if (!IsInlReady)
                return shortname;
            if (shortname.ToLower() == "loot-barrel") return "бочка";
            string name = ItemNameLocalizator?.CallHook("GetItemName", shortname, player) as string;
            return name ?? shortname;
        }
		
        int GetPercent(int need, int current){
			if (need==0) return 0;
			return current * 100 / need;
		}

        double GetPercentFUll(double need, double current){
			if (need==0) return 0;
			return current * 100 / need;
		}



        string ButtonListedClan = "[{\"name\":\"clans_player{id}\",\"parent\":\"Clanstop_main8\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{color}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.001 {amin}\",\"anchormax\":\"0.998 {amax}\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"CuiElement\",\"parent\":\"clans_player{id}\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"\",\"fontSize\":16,\"font\":\"robotocondensed-bold.ttf\",\"align\":\"MiddleCenter\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.2784314\",\"distance\":\"1 -1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"CuiElement\",\"parent\":\"clans_player{id}\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"{command}\",\"color\":\"1 1 1 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]}]";

        string TOP = "[{\"name\":\"Clanstop_main2\",\"parent\":\"Overlay\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0 0 0 0.6980392\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"Clanstop_main3\",\"parent\":\"Clanstop_main2\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0 0 0 0.1647059\"},{\"type\":\"NeedsCursor\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.2 0.1546297\",\"anchormax\":\"0.8 0.8935185\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"Clanstop_main4\",\"parent\":\"Clanstop_main3\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0.3294118 0.3294118 0.3294118 0.7058824\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.003548417 0.9385965\",\"anchormax\":\"0.9953553 0.9955974\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"Clanstop_main5\",\"parent\":\"Clanstop_main4\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"<b>{title}</b>\",\"fontSize\":18,\"align\":\"MiddleCenter\",\"color\":\"1 0.9294118 0.8666667 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"Clanstop_main6\",\"parent\":\"Clanstop_main5\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"close\":\"Clanstop_main2\",\"color\":\"0.5254902 0.282353 0.2313726 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.935175 0\",\"anchormax\":\"0.9986773 0.94\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"Clanstop_main7\",\"parent\":\"Clanstop_main6\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"<b>X</b>\",\"fontSize\":18,\"align\":\"MiddleCenter\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"Clanstop_main8\",\"parent\":\"Clanstop_main3\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0.3294118 0.3294118 0.3294118 0.7058824\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.003548417 0.005012453\",\"anchormax\":\"0.9953553 0.8734336\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"Clanstop_main9\",\"parent\":\"Clanstop_main3\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0.3294118 0.3294118 0.3294118 0.7058824\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.003548413 0.8809524\",\"anchormax\":\"0.9953553 0.9310777\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"Clanstop_main10\",\"parent\":\"Clanstop_main9\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"A PLACE\",\"align\":\"MiddleCenter\",\"color\":\"1 0.9294118 0.8666667 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.03405698 0\",\"anchormax\":\"0.1355833 1\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Clanstop_main11\",\"parent\":\"Clanstop_main9\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"NAME\",\"align\":\"MiddleLeft\",\"color\":\"1 0.9294118 0.8666667 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.1329573 0\",\"anchormax\":\"0.6983538 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Clanstop_main12\",\"parent\":\"Clanstop_main9\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"GLASSES\",\"align\":\"MiddleCenter\",\"color\":\"1 0.9294118 0.8666667 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.7298629 0\",\"anchormax\":\"0.8270121 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Clanstop_main12\",\"parent\":\"Clanstop_main9\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"PLAYERS\",\"align\":\"MiddleCenter\",\"color\":\"1 0.9294118 0.8666667 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.8585205 0\",\"anchormax\":\"0.9985565 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]}]";

        string InfoTOP = "[{\"name\":\"Clanstop_info2\",\"parent\":\"Overlay\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0 0 0 0.6980392\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"Clanstop_info3\",\"parent\":\"Clanstop_info2\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0 0 0 0.1647059\"},{\"type\":\"NeedsCursor\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.2 0.1546297\",\"anchormax\":\"0.8 0.8935185\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"Clanstop_info4\",\"parent\":\"Clanstop_info3\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0.3294118 0.3294118 0.3294118 0.7058824\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.003548417 0.9385965\",\"anchormax\":\"0.9953553 0.9955974\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"Clanstop_info5\",\"parent\":\"Clanstop_info4\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"<b>{clanname}</b> PLACE IN THE RANKING: {RANK}\",\"fontSize\":18,\"align\":\"MiddleCenter\",\"color\":\"1 0.9294118 0.8666667 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"Clanstop_info6\",\"parent\":\"Clanstop_info5\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"close\":\"Clanstop_info2\",\"color\":\"0.5254902 0.282353 0.2313726 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.935175 0\",\"anchormax\":\"0.9986773 0.94\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"Clanstop_info7\",\"parent\":\"Clanstop_info6\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"<b>X</b>\",\"fontSize\":18,\"align\":\"MiddleCenter\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"Clanstop_info8\",\"parent\":\"Clanstop_info5\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"{return}\",\"color\":\"0.2175973 0.2175973 0.2175973 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.0004332103 0\",\"anchormax\":\"0.1224549 0.93\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"Clanstop_info9\",\"parent\":\"Clanstop_info8\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"<b>НАЗАД</b>\",\"fontSize\":16,\"align\":\"MiddleCenter\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"Clanstop_info10\",\"parent\":\"Clanstop_info3\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0.3294118 0.3294118 0.3294118 0.7058824\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.003548417 0.005012453\",\"anchormax\":\"0.9953553 0.7481203\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"Clanstop_info11\",\"parent\":\"Clanstop_info10\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0.4039216 0.3921569 0.372549 0.3843137\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0.9173692\",\"anchormax\":\"1 1.000001\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Clanstop_main10\",\"parent\":\"Clanstop_info11\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"<b>Name Players</b>\",\"align\":\"MiddleCenter\",\"color\":\"1 0.9294118 0.8666667 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"0.2528636 1\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Clanstop_main10\",\"parent\":\"Clanstop_info11\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"<b>СТАТУС</b>\",\"align\":\"MiddleCenter\",\"color\":\"1 0.9294118 0.8666667 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.2449865 0\",\"anchormax\":\"0.4594171 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Clanstop_main10\",\"parent\":\"Clanstop_info11\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"<b>GLASSES</b>\",\"align\":\"MiddleCenter\",\"color\":\"1 0.9294118 0.8666667 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.4576665 0\",\"anchormax\":\"0.6055799 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Clanstop_main10\",\"parent\":\"Clanstop_info11\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"<b>Norm в %</b>\",\"align\":\"MiddleCenter\",\"color\":\"1 0.9294118 0.8666667 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.6073302 0\",\"anchormax\":\"0.7771242 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Clanstop_main10\",\"parent\":\"Clanstop_info11\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"<b>УБИЙСТВ/СМЕРТЕЙ</b>\",\"align\":\"MiddleCenter\",\"color\":\"1 0.9294118 0.8666667 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.7841259 0\",\"anchormax\":\"0.9985565 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Clanstop_info12\",\"parent\":\"Clanstop_info10\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0.4039216 0.3921569 0.372549 0.3843137\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0.01011801\",\"anchormax\":\"1 0.9123102\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Clanstop_info13\",\"parent\":\"Clanstop_info3\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0.3294118 0.3294118 0.3294118 0.7058824\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.003548413 0.755639\",\"anchormax\":\"0.9953553 0.9310777\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"Clanstop_info14\",\"parent\":\"Clanstop_info13\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0.4039216 0.3921569 0.372549 0.3843137\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.6318366 0.1428573\",\"anchormax\":\"0.9670526 0.8928576\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Clanstop_info15\",\"parent\":\"Clanstop_info14\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"<b>ВСЕГО ОЧКОВ: {Points}\n\nЛИДЕР КЛАНА: {lname}</b>\",\"align\":\"MiddleCenter\",\"color\":\"1 0.9294118 0.8666667 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Clanstop_info16\",\"parent\":\"Clanstop_info13\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0.4039216 0.3921569 0.372549 0.3843137\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.2187297 0.1428573\",\"anchormax\":\"0.5644442 0.8928576\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Clanstop_info17\",\"parent\":\"Clanstop_info16\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"<b>Clan players: {ccount}</b>\",\"align\":\"MiddleCenter\",\"color\":\"1 0.9294118 0.8666667 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"Clanstop_info18\",\"parent\":\"Clanstop_info13\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"1 1 1 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.03318176 0.07857105\",\"anchormax\":\"0.1382089 0.9357135\",\"offsetmax\":\"0 0\"}]}]";

        string InfoTOPButton = "[{\"name\":\"clans_player{id}\",\"parent\":\"Clanstop_info12\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"{color}\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.001 {amin}\",\"anchormax\":\"0.998 {amax}\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"CuiElement\",\"parent\":\"clans_player{id}\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"\",\"fontSize\":16,\"font\":\"robotocondensed-bold.ttf\",\"align\":\"MiddleCenter\"},{\"type\":\"UnityEngine.UI.Outline\",\"color\":\"0 0 0 0.2784314\",\"distance\":\"1 -1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"CuiElement\",\"parent\":\"clans_player{id}\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"command\":\"{command}\",\"color\":\"1 1 1 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]}]";

        [ConsoleCommand("clanstop_info")]
        void cmdClansTopKey(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            var clan = findClan(arg.Args[0]);
            if (clan != null)
            {
                ClanTOPInfo(player, clan, arg.Args.Length > 1 ? int.Parse(arg.Args[1]) : 0);
            }
        }

        [ConsoleCommand("clanstop_main")]
        void cmdClansTopMain(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            ClanTOP(player, arg.Args != null ? int.Parse(arg.Args[0]) : 0);
        }

        [ChatCommand("ctop")]
        void cmdClanTOP(BasePlayer player, string command, string[] args)
        {
            ClanTOP(player, 0);
        }

        public int GetClanIndex(string key)
        {
            var ClanMembers = from pair in clans orderby pair.Value.ClanPoints descending select pair;
            int index = 1;
            foreach (KeyValuePair<string, Clan> clanIndex in ClanMembers)
            {
                if (clanIndex.Value.tag == key)
                    return index;
                index++;
            }
            return 0;
        }


        string GetPlayerStatus(string player, Clan clan)
        {
            string status = "";

            if (clan == null) return "Обычный игрок";
            if (clan.members.ContainsKey(player)) status = "Участник";
            if (clan.moderators.Contains(player)) status = "Капитан";
            if (clan.owner.Contains(player)) status = "Лидер";
            return status;
        }

        void ClanTOPInfo(BasePlayer player, Clan clan, int page)
        {
            CuiHelper.DestroyUi(player, "Clanstop_main2");
            CuiHelper.DestroyUi(player, "Clanstop_info2");

            CuiHelper.AddUi(player, InfoTOP.Replace("{clanname}", "КЛАН: " + clan.tag.ToUpper() + " | ")
                .Replace("{RANK}", GetClanIndex(clan.tag).ToString())
                 .Replace("{ccount}", clan.members.Count.ToString())
                  .Replace("{ocount}", clan.online.ToString())
                   .Replace("{Points}", clan.ClanPoints.ToString())
                   .Replace("{lname}", clan.ownerName.ToUpper())
                   .Replace("{avatar}", (string)ImageLibrary.Call("GetImage", clan.ClanAvatar))
                    .Replace("{return}", "clanstop_main")
                );
            var elements = new CuiElementContainer();
            elements.Add(new CuiElement
            {
                Parent = $"Clanstop_info13",
                Components =
                    {
                        new CuiRawImageComponent {Color = "1 1 1 0.5", Png = (string)ImageLibrary?.Call("GetImage", clan.ClanAvatar)},
                        new CuiRectTransformComponent {AnchorMin = "0.03318176 0.07857105", AnchorMax = "0.1382089 0.9357135"}
                    }
            });
            string colored = "0.25 0.25 0.23 0.5";
            double Amin = 0.92;
            double Amax = 0.995;
            int i = 1+(page*10);
            var ClanMembers = from pair in clan.members orderby pair.Value.PlayerPoints descending select pair;
            foreach (KeyValuePair<string, PlayerStats> key in ClanMembers.Skip(11 * page).Take(ClanMembers.ToList().Count >= 10 ? 10 : ClanMembers.ToList().Count))
            {

                CuiHelper.AddUi(player, InfoTOPButton.Replace("{amin}", Amin.ToString()).Replace("{amax}", Amax.ToString()).Replace("{color}", colored).Replace("{id}", key.Key));
                elements.Add(new CuiLabel
                {
                    Text = { Text = $"{i}", Color = "1 0.9294118 0.8666667 1", FontSize = 14, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter },
                    RectTransform = { AnchorMin = $"0 0", AnchorMax = $"0.05 1" },
                }, "clans_player" + key.Key);
                elements.Add(new CuiLabel
                {
                    Text = { Text = covalence.Players.FindPlayerById(key.Key) != null ? covalence.Players.FindPlayerById(key.Key).Name : "Имя не указано", Font = "robotocondensed-bold.ttf", FontSize = 14, Color = "1 0.9294118 0.8666667 1", Align = TextAnchor.MiddleCenter },
                    RectTransform = { AnchorMin = $"0 0", AnchorMax = $"0.2528636 1" },
                }, "clans_player" + key.Key);
                elements.Add(new CuiLabel
                {
                    Text = { Text = GetPlayerStatus(key.Key, clan), Color = "1 0.9294118 0.8666667 1", Font = "robotocondensed-bold.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter },
                    RectTransform = { AnchorMin = $"0.2449865 0", AnchorMax = $"0.4594171 1" },
                }, "clans_player" + key.Key);
                elements.Add(new CuiLabel
                {
                    Text = { Text = key.Value.PlayerPoints.ToString(), Color = "1 0.9294118 0.8666667 1", FontSize = 14, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter },
                    RectTransform = { AnchorMin = $"0.4576665 0", AnchorMax = $"0.6055799 1" },
                }, "clans_player" + key.Key);
                elements.Add(new CuiLabel
                {
                    Text = { Text = $"{GetFullPercent(key.Key)}%", Color = "1 0.9294118 0.8666667 1", FontSize = 14, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter },
                    RectTransform = { AnchorMin = $"0.6073302 0", AnchorMax = $"0.7771242 1" },
                }, "clans_player" + key.Key);
                elements.Add(new CuiLabel
                {
                    Text = { Text = $"{key.Value.Killed}/{key.Value.Death}", Color = "1 0.9294118 0.8666667 1", FontSize = 14, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter },
                    RectTransform = { AnchorMin = $"0.7841259 0", AnchorMax = $"0.9985565 1" },
                }, "clans_player" + key.Key);
                i++;
				
                Amin = Amin - 0.085;
                Amax = Amax - 0.085;

            }
            elements.Add(new CuiButton
            {
                Button = { Color = "0.25 0.25 0.23 0.9" },
                Text = { Text = "" },
                RectTransform = { AnchorMin = $"0.01 0", AnchorMax = $"0.1 0.048" },
            }, "Clanstop_info12", "clans_page");
            elements.Add(new CuiButton
            {
                Button = { Color = "0.4039216 0.3921569 0.372549 0.7", Command = page > 0 ? $"clanstop_info {clan.tag} {page - 1}" : "" },
                Text = { Text = "<", Color = "1 0.9294118 0.8666667 1", FontSize = 15, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter },
                RectTransform = { AnchorMin = $"0 0", AnchorMax = $"0.33 0.997" },
            }, "clans_page");

            elements.Add(new CuiButton
            {
                Button = { Color = "0.3294118 0.3294118 0.3294118 0" },
                Text = { Text = $"{page + 1}", Color = "1 0.9294118 0.8666667 1", Font = "robotocondensed-bold.ttf", FontSize = 13, Align = TextAnchor.MiddleCenter },
                RectTransform = { AnchorMin = $"0.33 0", AnchorMax = $"0.66 0.997" },
            }, "clans_page");

            elements.Add(new CuiButton
            {
                Button = { Color = "0.4039216 0.3921569 0.372549 0.7", Command = ClanMembers.Skip(11 * (page + 1)).Count() > 0 ? $"clanstop_info {page + 1}" : "" },
                Text = { Text = ">", Color = "1 0.9294118 0.8666667 1", FontSize = 15, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter },
                RectTransform = { AnchorMin = $"0.66 0", AnchorMax = $"0.997 0.997" },
            }, "clans_page");
            CuiHelper.AddUi(player, elements);

        }

        void ClanTOP(BasePlayer player, int page)
        {			
            CuiHelper.DestroyUi(player, "Clanstop_info2");
            CuiHelper.DestroyUi(player, "Clanstop_main2");
            CuiHelper.AddUi(player, TOP.Replace("{title}", msg("clanTOPUItitle", player.UserIDString).ToUpper()));
            string colored = "0.25 0.25 0.23 0.5";
            var elements = new CuiElementContainer();
            double Amin = 0.93;
            double Amax = 0.995;
            int i = 1;
            var ClanMembers = from pair in clans orderby pair.Value.ClanPoints descending select pair;

            foreach (KeyValuePair<string, Clan> key in ClanMembers.Skip(10 * page).Take(ClanMembers.ToList().Count >= 10 ? 10 : ClanMembers.ToList().Count))
            {
                CuiHelper.AddUi(player, ButtonListedClan.Replace("{amin}", Amin.ToString()).Replace("{amax}", Amax.ToString()).Replace("{color}", colored).Replace("{id}", key.Key));
                elements.Add(new CuiElement
                {
                    Parent = $"clans_player{key.Key}",
                    Components =
                    {
                        new CuiRawImageComponent {Color = "1 1 1 0.5", Png = (string)ImageLibrary?.Call("GetImage", key.Value.ClanAvatar)},
                        new CuiRectTransformComponent {AnchorMin = "0.01 0.1", AnchorMax = "0.04 0.9"}
                    }
                });

                elements.Add(new CuiLabel
                {
                    Text = { Text = $"{i}", Color = "1 0.9294118 0.8666667 1", FontSize = 14, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft },
                    RectTransform = { AnchorMin = $"0.08 0", AnchorMax = $"0.1355833 1" },
                }, "clans_player" + key.Key);

                elements.Add(new CuiLabel
                {
                    Text = { Text = key.Value.tag.ToUpper(), Font = "robotocondensed-bold.ttf", FontSize = 14, Color = "1 0.9294118 0.8666667 1", Align = TextAnchor.MiddleLeft },
                    RectTransform = { AnchorMin = $"0.1329573 0", AnchorMax = $"0.6983538 1" },
                }, "clans_player" + key.Key);

                elements.Add(new CuiLabel
                {
                    Text = { Text = key.Value.ClanPoints.ToString(), Font = "robotocondensed-bold.ttf", FontSize = 14, Color = "1 0.9294118 0.8666667 1", Align = TextAnchor.MiddleCenter },
                    RectTransform = { AnchorMin = $"0.7298629 0", AnchorMax = $"0.8270121 1" },
                }, "clans_player" + key.Key);

                elements.Add(new CuiLabel
                {
                    Text = { Text = $"{key.Value.online}/{key.Value.members.Count}".ToUpper(), Font = "robotocondensed-bold.ttf", FontSize = 14, Color = "1 0.9294118 0.8666667 1", Align = TextAnchor.MiddleCenter },
                    RectTransform = { AnchorMin = $"0.8585205 0", AnchorMax = $"0.9985565 1" },
                }, "clans_player" + key.Key);

                elements.Add(new CuiButton
                {
                    Button = { Color = "0.25 0.25 0.23 0", Command = $"clanstop_info {key.Value.tag}" },
                    Text = { Text = "", Align = TextAnchor.MiddleCenter, FontSize = 14, Font = "robotocondensed-bold.ttf", Color = "1 0.9294118 0.8666667 1" },
                    RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1" },
                }, "clans_player" + key.Key);
                i++;
                Amin = Amin - 0.073;
                Amax = Amax - 0.073;
            }
            elements.Add(new CuiButton
            {
                Button = { Color = "0.25 0.25 0.23 0.9" },
                Text = { Text = "" },
                RectTransform = { AnchorMin = $"0.01 0.003", AnchorMax = $"0.1 0.048" },
            }, "Clanstop_main8", "clans_page");
            elements.Add(new CuiButton
            {
                Button = { Color = "0.4039216 0.3921569 0.372549 0.7", Command = page > 0 ? $"clanstop_main {page - 1}" : "" },
                Text = { Text = "<", Color = "1 0.9294118 0.8666667 1", FontSize = 15, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter },
                RectTransform = { AnchorMin = $"0 0", AnchorMax = $"0.33 0.997" },
            }, "clans_page");

            elements.Add(new CuiButton
            {
                Button = { Color = "0.3294118 0.3294118 0.3294118 0" },
                Text = { Text = $"{page + 1}", Color = "1 0.9294118 0.8666667 1", Font = "robotocondensed-bold.ttf", FontSize = 13, Align = TextAnchor.MiddleCenter },
                RectTransform = { AnchorMin = $"0.33 0", AnchorMax = $"0.66 0.997" },
            }, "clans_page");

            elements.Add(new CuiButton
            {
                Button = { Color = "0.4039216 0.3921569 0.372549 0.7", Command = clans.Keys.Skip(10 * (page + 1)).Count() > 0 ? $"clanstop_main {page + 1}" : "" },
                Text = { Text = ">", Color = "1 0.9294118 0.8666667 1", FontSize = 15, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter },
                RectTransform = { AnchorMin = $"0.66 0", AnchorMax = $"0.997 0.997" },
            }, "clans_page");
            CuiHelper.AddUi(player, elements);
        }

        void ClanUI(BasePlayer player, int page = 0, bool changeSkin = false, bool changeResource = false)
        {
            //if (!IsReady())
            //{
            //    timer.Once(2f, () => ClanUI(player, page, changeSkin, changeResource));
            //    return;
            //}
            CuiHelper.DestroyUi(player, "clans_main1");
            string Main = "[{\"name\":\"clans_main1\",\"parent\":\"Overlay\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"material\":\"assets/content/ui/uibackgroundblur-ingamemenu.mat\",\"color\":\"0 0 0 0.7\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"clans_main2\",\"parent\":\"clans_main1\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0 0 0 0.1647059\"},{\"type\":\"NeedsCursor\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.17 0.1546297\",\"anchormax\":\"0.83 0.8935185\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"clans_main3\",\"parent\":\"clans_main2\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0.3294118 0.3294118 0.3294118 0.7058824\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.003548417 0.943609\",\"anchormax\":\"0.9953553 0.9955974\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"clans_main4\",\"parent\":\"clans_main3\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"<b>{title}</b>\",\"fontSize\":18,\"font\":\"robotocondensed-bold.ttf\",\"align\":\"MiddleCenter\",\"color\":\"1 0.9294118 0.8666667 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"clans_main5\",\"parent\":\"clans_main4\",\"components\":[{\"type\":\"UnityEngine.UI.Button\",\"close\":\"clans_main1\",\"color\":\"0.5254902 0.282353 0.2313726 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.935175 0\",\"anchormax\":\"0.9986773 0.94\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"clans_main6\",\"parent\":\"clans_main5\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"<b>X</b>\",\"fontSize\":18,\"font\":\"robotocondensed-bold.ttf\",\"align\":\"MiddleCenter\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"clans_main10\",\"parent\":\"clans_main2\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0.3294118 0.3294118 0.3294118 0.7058824\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.003548417 0.6918138\",\"anchormax\":\"0.6431664 0.9398496\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"ClanLogo\",\"parent\":\"clans_main10\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"1 1 1 0\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.05315594 0.02741549\",\"anchormax\":\"0.2838709 0.9721818\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"ClanInfo\",\"parent\":\"clans_main10\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0.2745098 0.2745098 0.2745098 0.3948693\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.3418818 0.02741549\",\"anchormax\":\"0.9542304 0.9754673\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"ClanName\",\"parent\":\"ClanInfo\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0.4039216 0.3921569 0.372549 0.3843137\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0.7517123\",\"anchormax\":\"1 0.9931507\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"ClanName1\",\"parent\":\"ClanName\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"NAME CLANS: \",\"fontSize\":16,\"font\":\"robotocondensed-bold.ttf\",\"align\":\"MiddleLeft\",\"color\":\"1 0.9294118 0.8666667 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.0221675 0\",\"anchormax\":\"0.556291 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"clanTitle\",\"parent\":\"ClanName\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"<b>{Title}</b>\",\"fontSize\":16,\"font\":\"robotocondensed-bold.ttf\",\"align\":\"MiddleRight\",\"color\":\"1 0.9294118 0.8666667 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.5141813 0\",\"anchormax\":\"0.9929016 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"ClanName2\",\"parent\":\"ClanInfo\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0.4039216 0.3921569 0.372549 0.3843137\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0.5034246\",\"anchormax\":\"1 0.744863\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"ClanName3\",\"parent\":\"ClanName2\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"Head of the clan:\",\"fontSize\":16,\"font\":\"robotocondensed-bold.ttf\",\"align\":\"MiddleLeft\",\"color\":\"1 0.9294118 0.8666667 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.0221675 0\",\"anchormax\":\"0.4698553 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"clanTitle\",\"parent\":\"ClanName2\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{LeaderName}\",\"fontSize\":16,\"font\":\"robotocondensed-bold.ttf\",\"align\":\"MiddleRight\",\"color\":\"1 0.9294118 0.8666667 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.5141813 0\",\"anchormax\":\"0.9929016 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"ClanName3\",\"parent\":\"ClanInfo\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0.4039216 0.3921569 0.372549 0.3843137\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0.255137\",\"anchormax\":\"1 0.4965754\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"ClanName4\",\"parent\":\"ClanName3\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"Clan players:\",\"fontSize\":16,\"font\":\"robotocondensed-bold.ttf\",\"align\":\"MiddleLeft\",\"color\":\"1 0.9294118 0.8705882 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.0221675 0\",\"anchormax\":\"0.5718051 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"clanTitle\",\"parent\":\"ClanName3\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{O/P}\",\"fontSize\":16,\"font\":\"robotocondensed-bold.ttf\",\"align\":\"MiddleRight\",\"color\":\"1 0.9294118 0.8666667 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.5141813 0\",\"anchormax\":\"0.9929016 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"ClanName3\",\"parent\":\"ClanInfo\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0.4039216 0.3921569 0.372549 0.3843137\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0.006849289\",\"anchormax\":\"1 0.2482877\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"ClanName4\",\"parent\":\"ClanName3\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"Place in the top:\",\"fontSize\":16,\"font\":\"robotocondensed-bold.ttf\",\"align\":\"MiddleLeft\",\"color\":\"1 0.9294118 0.8705882 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.0221675 0\",\"anchormax\":\"0.6493754 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"clanTitle\",\"parent\":\"ClanName3\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"{per}\",\"fontSize\":16,\"font\":\"robotocondensed-bold.ttf\",\"align\":\"MiddleRight\",\"color\":\"1 0.9294118 0.8666667 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.5141813 0\",\"anchormax\":\"0.9929016 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"clans_main11\",\"parent\":\"clans_main2\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0.3294118 0.3294118 0.3294118 0.7058824\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.6467149 0.6918139\",\"anchormax\":\"0.9980168 0.9398496\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"clans_main112\",\"parent\":\"clans_main11\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"<b>Task list</b>\",\"fontSize\":15,\"font\":\"robotocondensed-bold.ttf\",\"align\":\"MiddleCenter\",\"color\":\"1 0.9294118 0.8666667 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0.7554934\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"clans_main113\",\"parent\":\"clans_main11\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"<b>{attach}</b>\",\"fontSize\":15,\"font\":\"robotocondensed-bold.ttf\",\"align\":\"MiddleCenter\",\"color\":\"1 0.9294118 0.8666667 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0.02572244\",\"anchormax\":\"1 0.7554934\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"clans_main9\",\"parent\":\"clans_main2\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0.3294118 0.3294118 0.3294118 0.7058824\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.003548518 0.4335839\",\"anchormax\":\"0.9971297 0.6859453\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"clans_main91\",\"parent\":\"clans_main9\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"<b>Clan clothing</b>\",\"fontSize\":15,\"font\":\"robotocondensed-bold.ttf\",\"align\":\"MiddleCenter\",\"color\":\"1 0.9294118 0.8666667 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0.8\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]},{\"name\":\"clans_item0\",\"parent\":\"clans_main9\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0.4039216 0.3921569 0.3686275 0.5568628\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.06081926 0.04293609\",\"anchormax\":\"0.1799577 0.7877806\",\"offsetmax\":\"0 0\"}]},{\"name\":\"clans_item1\",\"parent\":\"clans_main9\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0.4039216 0.3921569 0.3686275 0.5568628\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.1871024 0.04293609\",\"anchormax\":\"0.3062414 0.7877806\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"clans_item2\",\"parent\":\"clans_main9\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0.4039216 0.3921569 0.3686275 0.5568628\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.3133879 0.04293609\",\"anchormax\":\"0.4325227 0.7877806\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"clans_item3\",\"parent\":\"clans_main9\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0.4039216 0.3921569 0.3686275 0.5568628\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.4396606 0.04293609\",\"anchormax\":\"0.558799 0.7877806\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"clans_item4\",\"parent\":\"clans_main9\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0.4039216 0.3921569 0.3686275 0.5568628\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.5659431 0.04293609\",\"anchormax\":\"0.6850816 0.7877806\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"clans_item5\",\"parent\":\"clans_main9\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0.4039216 0.3921569 0.3686275 0.5568628\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.6922278 0.04293609\",\"anchormax\":\"0.8113656 0.7877806\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"clans_item6\",\"parent\":\"clans_main9\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0.4039216 0.3921569 0.3686275 0.5568628\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.81852 0.04293605\",\"anchormax\":\"0.9376571 0.7877805\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"clans_main7\",\"parent\":\"clans_main2\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0.3294118 0.3294118 0.3294118 0.7058824\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.003548417 0.006466299\",\"anchormax\":\"0.6431664 0.4285714\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"clans_main71\",\"parent\":\"clans_main7\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0.3294118 0.3294118 0.3294118 0.7058824\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0.911024\",\"anchormax\":\"1 0.9998377\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"clans_main722\",\"parent\":\"clans_main71\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"*\",\"fontSize\":15,\"font\":\"robotocondensed-bold.ttf\",\"align\":\"MiddleCenter\",\"color\":\"1 0.9294118 0.8666667 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0\",\"anchormax\":\"0.06366677 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"clans_main723\",\"parent\":\"clans_main71\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"Name Players\",\"fontSize\":13,\"font\":\"robotocondensed-bold.ttf\",\"align\":\"MiddleLeft\",\"color\":\"1 0.9294118 0.8666667 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.06366677 0\",\"anchormax\":\"0.4043106 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"clans_main724\",\"parent\":\"clans_main71\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"Activity\",\"fontSize\":13,\"font\":\"robotocondensed-bold.ttf\",\"align\":\"MiddleLeft\",\"color\":\"1 0.9294118 0.8666667 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.4056678 0\",\"anchormax\":\"0.6526684 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"clans_main725\",\"parent\":\"clans_main71\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"Norm\",\"fontSize\":13,\"font\":\"robotocondensed-bold.ttf\",\"align\":\"MiddleLeft\",\"color\":\"1 0.9294118 0.8666667 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.6526684 0\",\"anchormax\":\"0.75 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"clans_main726\",\"parent\":\"clans_main71\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"actions\",\"fontSize\":13,\"font\":\"robotocondensed-bold.ttf\",\"align\":\"MiddleLeft\",\"color\":\"1 0.9294118 0.8666667 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.75 0\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"clans_main8\",\"parent\":\"clans_main2\",\"components\":[{\"type\":\"UnityEngine.UI.Image\",\"color\":\"0.3294118 0.3294118 0.3294118 0.7058824\"},{\"type\":\"RectTransform\",\"anchormin\":\"0.6467149 0.006466303\",\"anchormax\":\"0.9980168 0.4285714\",\"offsetmin\":\"0 0\",\"offsetmax\":\"0 0\"}]},{\"name\":\"clans_main81\",\"parent\":\"clans_main8\",\"components\":[{\"type\":\"UnityEngine.UI.Text\",\"text\":\"<b>Mining</b>\",\"fontSize\":15,\"font\":\"robotocondensed-bold.ttf\",\"align\":\"MiddleCenter\",\"color\":\"1 0.9294118 0.8666667 1\"},{\"type\":\"RectTransform\",\"anchormin\":\"0 0.8873403\",\"anchormax\":\"1 1\",\"offsetmin\":\"0 0\",\"offsetmax\":\"1 1\"}]}]";
            var Messages = "";

            var clan = findClanByUser(player.UserIDString);
            var need = clan.Change.Select(p => $"{GetItemName(p.Key, player)} - {p.Value.Need.ToString("N3", CultureInfo.GetCultureInfo("ru-RU")).Replace(",000", "")}").ToList();

            if (need.Count > 0) Messages = string.Join(", ", need);		
			
            CuiHelper.AddUi(player,
                Main
                .Replace("{Title}", clan.tag.ToUpper())
                .Replace("{LeaderName}", clan.ownerName.ToUpper())
                .Replace("{O/P}", $"{clan.online}/{clan.members.Count}".ToUpper())
                .Replace("{per}", GetClanIndex(clan.tag).ToString())
                .Replace("{attach}", Messages.ToUpper())
                 .Replace("{title}", msg("clanUItitle", player.UserIDString).ToUpper())
                );


            string colored = "0.25 0.25 0.23 0.5";
            var elements = new CuiElementContainer();
            elements.Add(new CuiElement
            {
                Name = "ClanLogo",
                Parent = $"clans_main10",
                Components =
                    {
                        new CuiRawImageComponent { Png = (string)ImageLibrary?.Call("GetImage", clan.ClanAvatar)},
                        new CuiRectTransformComponent { AnchorMin = "0.05315594 0.02741549", AnchorMax = "0.2838709 0.9721818" }
                    }
            });
            double Amin = 0.8;
            double Amax = 0.9;
			
            foreach (var key in clan.members.OrderBy(pair => BasePlayer.FindByID(ulong.Parse(pair.Key)) == null).Skip(8 * page).Take(clan.members.Count >= 8 ? 8 : clan.members.Count))
            {
                var playerKey = BasePlayer.FindByID(ulong.Parse(key.Key));
                CuiHelper.AddUi(player, ButtonListed.Replace("{amin}", Amin.ToString()).Replace("{amax}", Amax.ToString()).Replace("{color}", colored).Replace("{id}", key.Key));
                elements.Add(new CuiLabel
                {
                    Text = { Text = "●", Color = playerKey != null ? "0.00 1.00 0.00 1.00" : "1.00 0.00 0.00 1.00", FontSize = 14, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter },
                    RectTransform = { AnchorMin = $"0 0", AnchorMax = $"0.06366677 1" },
                }, "clans_player" + key.Key);
                elements.Add(new CuiLabel
                {
                    Text = { Text = covalence.Players.FindPlayerById(key.Key) != null ? covalence.Players.FindPlayerById(key.Key).Name : "Имя не указано", Font = "robotocondensed-bold.ttf", FontSize = 14, Color = "1 0.9294118 0.8666667 1", Align = TextAnchor.MiddleLeft },
                    RectTransform = { AnchorMin = $"0.06366677 0", AnchorMax = $"0.4043106 1" },
                }, "clans_player" + key.Key);
                elements.Add(new CuiLabel
                {
                    Text = { Text = playerKey != null ? FormatShortTime(TimeSpan.FromSeconds(playerKey.TimeAlive())) : "0", Color = "1 0.9294118 0.8666667 1", Font = "robotocondensed-bold.ttf", FontSize = 14, Align = TextAnchor.MiddleLeft },
                    RectTransform = { AnchorMin = $"0.4056678 0", AnchorMax = $"0.6526684 1" },
                }, "clans_player" + key.Key);

                var persent = GetFullPercent(key.Key) > 100 ? 100 : GetFullPercent(key.Key);
                elements.Add(new CuiLabel
                {
                    Text = { Text = $"{persent}%", Color = "1 0.9294118 0.8666667 1", FontSize = 14, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft },
                    RectTransform = { AnchorMin = $"0.6526684 0", AnchorMax = $"0.814169 1" },
                }, "clans_player" + key.Key);
                Amin = Amin - 0.1;
                Amax = Amax - 0.1;
                if (clan.owner == player.UserIDString)
                {
                    if (key.Key != player.UserIDString)
                    {
                        elements.Add(new CuiButton
                        {
                            Button = { Color = "0.25 0.25 0.23 0.9", Command = $"clan_kickplayer {key.Key}" },
                            Text = { Text = "ВЫГНАТЬ", Align = TextAnchor.MiddleCenter, FontSize = 10, Font = "robotocondensed-bold.ttf", Color = "1 0.9294118 0.8666667 1" },
                            RectTransform = { AnchorMin = $"0.91 0", AnchorMax = $"0.997 0.955" },
                        }, "clans_player" + key.Key);

                        elements.Add(new CuiButton
                        {
                            Button = { Color = "0.25 0.25 0.23 0.9", Command = clan.moderators.Contains(key.Key) ? $"clanui_promote demote {key.Key}" : $"clanui_promote promote {key.Key}" },
                            Text = { Text = clan.moderators.Contains(key.Key) ? "УБРАТЬ МОДЕРАТОРА" : "НАЗНАЧИТЬ МОДЕРАТОРОМ", Align = TextAnchor.MiddleCenter, FontSize = 10, Font = "robotocondensed-bold.ttf", Color = "1 0.9294118 0.8666667 1" },
                            RectTransform = { AnchorMin = $"0.75 0", AnchorMax = $"0.905 0.955" },
                        }, "clans_player" + key.Key);
                    }
                }
                else if (clan.moderators.Contains(player.UserIDString))
                {
                    elements.Add(new CuiButton
                    {
                        Button = { Color = "0.25 0.25 0.23 0.9", Command = $"clan_kickplayer {key.Key}" },
                        Text = { Text = "ВЫГНАТЬ", Align = TextAnchor.MiddleCenter, FontSize = 10, Font = "robotocondensed-bold.ttf", Color = "1 0.9294118 0.8666667 1" },
                        RectTransform = { AnchorMin = $"0.91 0", AnchorMax = $"0.997 0.955" },
                    }, "clans_player" + key.Key);
                }
                else
                    CuiHelper.DestroyUi(player, "clans_main726");
            }

            elements.Add(new CuiButton
            {
                Button = { Color = "0.25 0.25 0.23 0.9" },
                Text = { Text = "" },
                RectTransform = { AnchorMin = $"0.01 0.005", AnchorMax = $"0.15 0.085" },
            }, "clans_main7", "clans_page");

            elements.Add(new CuiButton
            {
                Button = { Color = "0.4039216 0.3921569 0.372549 0.7", Command = page > 0 ? $"clanui.page {page - 1}" : "" },
                Text = { Text = "<", Color = "1 0.9294118 0.8666667 1", FontSize = 15, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter },
                RectTransform = { AnchorMin = $"0 0", AnchorMax = $"0.33 0.997" },
            }, "clans_page");

            elements.Add(new CuiButton
            {
                Button = { Color = "0.3294118 0.3294118 0.3294118 0" },
                Text = { Text = $"{page + 1}", Color = "1 0.9294118 0.8666667 1", Font = "robotocondensed-bold.ttf", FontSize = 13, Align = TextAnchor.MiddleCenter },
                RectTransform = { AnchorMin = $"0.33 0", AnchorMax = $"0.66 0.997" },
            }, "clans_page");

            elements.Add(new CuiButton
            {
                Button = { Color = "0.4039216 0.3921569 0.372549 0.7", Command = clan.members.Skip(8 * (page + 1)).Count() > 0 ? $"clanui.page {page + 1}" : "" },
                Text = { Text = ">", Color = "1 0.9294118 0.8666667 1", FontSize = 15, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter },
                RectTransform = { AnchorMin = $"0.66 0", AnchorMax = $"0.997 0.997" },
            }, "clans_page");

            for (int i = 0; i < clan.SkinList.Count; i++)
            {
                elements.Add(new CuiElement
                {
                    Parent = "clans_item" + i,
                    Components =
                    {
                        new CuiRawImageComponent { Png = GetImageSkin(clan.SkinList.ToList()[i].Key, clan.SkinList.ToList()[i].Value) },
                        new CuiRectTransformComponent { AnchorMin = "0.1 0.1", AnchorMax = "0.9 0.9" }
                    }
                });

                if (changeSkin)
                    elements.Add(new CuiButton
                    {
                        Button = { Color = "0.13 0.44 0.48 0", Command = changeSkin ? $"clans_getskinIds {clan.SkinList.ToList()[i].Key}" : $"" },
                        Text = { Text = "", Color = "1 0.9294118 0.8666667 1", FontSize = 14, Align = TextAnchor.MiddleCenter },
                        RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1" },
                    }, "clans_item" + i);
            }
            var poses = GetPositions(3, 3, 0.08f, 0.03f);

            elements.Add(new CuiElement
            {
                Name = $"clans_main88",
                Parent = "clans_main8",
                Components =
                    {
                        new CuiRawImageComponent {Color = "0.3294118 0.3294118 0.3294118 0"},
                        new CuiRectTransformComponent {AnchorMin = "0 0", AnchorMax = "1 0.9"}
                    }
            });
			
            for (int i = 0; i < clan.Change.Count; i++)
            {
                elements.Add(new CuiElement
                {
                    Name = $"clans_main88{clan.Change.ToList()[i].Key}",
                    Parent = $"clans_main88",
                    Components =
                    {
                        new CuiRawImageComponent {Color = "0.3294118 0.3294118 0.3294118 0.7"},
                        new CuiRectTransformComponent {AnchorMin = poses[i].AnchorMin, AnchorMax = poses[i].AnchorMax}
                    }
                });

                var Anchor = GetPercentFUll(clan.Change.ToList()[i].Value.Need, clan.Change.ToList()[i].Value.Complete) / 100 > 1 ?
                    1.0 :
                    GetPercentFUll(clan.Change.ToList()[i].Value.Need, clan.Change.ToList()[i].Value.Complete) / 100;

                elements.Add(new CuiButton
                {
                    Button = { Color = "0.13 0.44 0.48 1", Command = "" },
                    Text = { Text = $"", },
                    RectTransform = { AnchorMin = "0 0", AnchorMax = $"1 {Anchor}" },
                }, $"clans_main88{clan.Change.ToList()[i].Key}");

                elements.Add(new CuiButton
                {
                    Button = { Color = "0.13 0.44 0.48 0", Command = "" },
                    Text = { Text = $"{GetPercent((int)clan.Change.ToList()[i].Value.Need, (int)clan.Change.ToList()[i].Value.Complete)}%", Color = "1 0.9294118 0.8666667 1", FontSize = 14, Align = TextAnchor.MiddleCenter },
                    RectTransform = { AnchorMin = "0.6 0.7", AnchorMax = "1 1" },
                }, $"clans_main88{clan.Change.ToList()[i].Key}");


                elements.Add(new CuiElement
                {
                    Parent = $"clans_main88{clan.Change.ToList()[i].Key}",
                    Components =
                    {
                        new CuiRawImageComponent { Png = (string)ImageLibrary.Call("GetImage", clan.Change.ToList()[i].Key)},
                        new CuiRectTransformComponent { AnchorMin = "0.2 0.1", AnchorMax = "0.8 0.9" }
                    }
                });
            }

            if (clan.owner == player.UserIDString)
            {
                elements.Add(new CuiButton
                {
                    Button = { Color = "0.13 0.44 0.48 0.7", Command = changeSkin ? $"clanui.page {page}" : $"clanui.page {page} true" },
                    Text = { Text = changeSkin ? "Save" : "Tune", Color = "1 0.9294118 0.8666667 1", Font = "robotocondensed-bold.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter },
                    RectTransform = { AnchorMin = $"0.9 0", AnchorMax = $"0.997 0.95" },
                }, "clans_main91");

                elements.Add(new CuiButton
                {
                    Button = { Color = "0.13 0.44 0.48 0.7", Command = $"clan_setChange" },
                    Text = { Text = "Tune", Color = "1 0.9294118 0.8666667 1", FontSize = 13, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter },
                    RectTransform = { AnchorMin = $"0.75 0.2", AnchorMax = $"0.993 0.93" },
                }, "clans_main112");

                elements.Add(new CuiButton
                {
                    Button = { Color = "0.13 0.44 0.48 0.5", Command = $"clan_setAvatar" },
                    Text = { Text = "Edit", Color = "1 0.9294118 0.8666667 1", FontSize = 12, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter },
                    RectTransform = { AnchorMin = $"0.55 0.85", AnchorMax = $"1 1" },
                }, "ClanLogo");
            }

            if (changeSkin)
            {
                elements.Add(new CuiElement
                {
                    Name = "clans_main100",
                    Parent = "clans_main2",
                    Components =
                    {
                        new CuiImageComponent {Color = "0 0 0 0.85"},
                        new CuiRectTransformComponent {AnchorMin = "0 0.6917294", AnchorMax = "1 0.7619048"}
                    }
                });

                elements.Add(new CuiElement
                {
                    Parent = "clans_main100",
                    Components =
                    {
                        new CuiTextComponent { Text = "<size=26>SKIN CONTROL PANEL</size>", Color = "1 0.9294118 0.8666667 1", Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter},
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" },
                    }
                });

                elements.Add(new CuiButton
                {
                    Button = { Color = "0.4039216 0.3921569 0.372549 0.9", Command = "", Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                    Text = { Text = "", Color = "1 0.9294118 0.8666667 1", FontSize = 15, Align = TextAnchor.MiddleCenter },
                    RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1" },
                }, "clans_main10");
                elements.Add(new CuiButton
                {
                    Button = { Color = "0.4039216 0.3921569 0.372549 0.9", Command = "", Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                    Text = { Text = "", Color = "1 0.9294118 0.8666667 1", FontSize = 15, Align = TextAnchor.MiddleCenter },
                    RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1" },
                }, "clans_main11");
                elements.Add(new CuiButton
                {
                    Button = { Color = "0.4039216 0.3921569 0.372549 0.9", Command = "", Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                    Text = { Text = "", Color = "1 0.9294118 0.8666667 1", FontSize = 15, Align = TextAnchor.MiddleCenter },
                    RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1" },
                }, "clans_main7");
                elements.Add(new CuiButton
                {
                    Button = { Color = "0.4039216 0.3921569 0.372549 0.9", Command = "", Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                    Text = { Text = "", Color = "1 0.9294118 0.8666667 1", FontSize = 15, Align = TextAnchor.MiddleCenter },
                    RectTransform = { AnchorMin = $"0 0", AnchorMax = $"1 1" },
                }, "clans_main8");

            }
            CuiHelper.AddUi(player, elements);
        }

        long GetFullPercent(string id)
        {
            var clan = findClanByUser(id);
            long Need = clan.Change.Sum(x => x.Value.Need);
            var playerCurrent = clan.members[id].GatherInfo.Sum(p => p.Value);
            if (playerCurrent == 0) return 0;
			if (Need==0) return 0;
            return playerCurrent * 100 / Need;
        }

        long GetFullClanPercent(string tag)
        {
            var clan = findClan(tag);
            long Need = clan.Change.Sum(x => x.Value.Need);
            var Current = clan.Change.Sum(x => x.Value.Complete);
            if (Current == 0) return 0;
			if (Need==0) return 0;
            return Current * 100 / Need;
        }

        public static string FormatShortTime(TimeSpan time)
        {
            string result = string.Empty;
            if (time.Days != 0)
                result += $"{time.Days} д. ";

            if (time.Hours != 0)
                result += $"{time.Hours} ч. ";

            if (time.Minutes != 0)
                result += $"{time.Minutes} м. ";

            if (time.Seconds != 0)
                result += $"{time.Seconds} с. ";

            return result;
        }

        public void WithdrawPlayer(BasePlayer player, string targetId) => cmdClanWithdraw(player, new string[] {
"", targetId
}
        );

        void cmdClanWithdraw(BasePlayer player, string[] args)
        {
            var current = this.covalence.Players.FindPlayerById(player.UserIDString);
            var myClan = findClanByUser(current.Id);
            if (myClan == null)
            {
                PrintChat(player, string.Format(msg("notmember", current.Id)));
                return;
            }
            if (args.Length < 2)
            {
                PrintChat(player, string.Format(msg("usagewithdraw", current.Id), colorCmdUsage));
                return;
            }
            if (!myClan.IsOwner(current.Id) && !myClan.IsCouncil(current.Id) && !myClan.IsModerator(current.Id))
            {
                PrintChat(player, string.Format(msg("notmoderator", current.Id)));
                return;
            }
            var disinvPlayer = myClan.GetIPlayer(args[1]);
            if (disinvPlayer == null)
            {
                PrintChat(player, string.Format(msg("nosuchplayer", current.Id), args[1]));
                return;
            }
            if (myClan.members.ContainsKey(disinvPlayer.Id))
            {
                PrintChat(player, string.Format(msg("alreadymember", current.Id), disinvPlayer.Name));
                return;
            }
            if (!myClan.invites.ContainsKey(disinvPlayer.Id))
            {
                PrintChat(player, string.Format(msg("notinvited", current.Id), disinvPlayer.Name));
                return;
            }
            myClan.invites.Remove(disinvPlayer.Id);
            if (pendingPlayerInvites.ContainsKey(disinvPlayer.Id)) pendingPlayerInvites[disinvPlayer.Id].Remove(myClan.tag);
            myClan.BroadcastLoc("canceledinvite", myClan.ColNam(current.Id, current.Name), myClan.ColNam(disinvPlayer.Id, disinvPlayer.Name));
            myClan.updated = UnixTimeStampUTC();
        }
        void cmdClanJoin(BasePlayer player, string[] args)
        {
            var current = this.covalence.Players.FindPlayerById(player.UserIDString);
            var myClan = findClanByUser(current.Id);
            if (myClan != null)
            {
                PrintChat(player, string.Format(msg("youalreadymember", current.Id)));
                return;
            }
            if (usePermToJoinClan && !permission.UserHasPermission(current.Id, permissionToJoinClan))
            {
                PrintChat(player, msg("nopermtojoin", current.Id));
                return;
            }
            if (args.Length != 2)
            {
                PrintChat(player, string.Format(msg("usagejoin", current.Id), colorCmdUsage));
                return;
            }
            myClan = findClan(args[1]);
            if (myClan == null || !myClan.IsInvited(current.Id))
            {
                PrintChat(player, string.Format(msg("younotinvited", current.Id)));
                return;
            }
            if (limitMembers >= 0 && myClan.members.Count() >= limitMembers)
            {
                PrintChat(player, string.Format(msg("reachedmaximum", current.Id)));
                return;
            }
            myClan.invites.Remove(current.Id);
            pendingPlayerInvites.Remove(current.Id);
            myClan.members.Add(current.Id, new PlayerStats());
            clanCache[current.Id] = myClan;
            setupPlayer(player, current.Name, current.Id);
            if (usePermGroups && !permission.UserHasGroup(current.Id, permGroupPrefix + myClan.tag)) permission.AddUserGroup(current.Id, permGroupPrefix + myClan.tag);
            myClan.BroadcastLoc("playerjoined", myClan.ColNam(current.Id, current.Name));
            myClan.updated = UnixTimeStampUTC();
            myClan.total++;
            myClan.onUpdate();
            List<string> others = new List<string>(myClan.members.Keys);
            others.Remove(current.Id);
            Interface.Oxide.CallHook("OnClanMemberJoined", current.Id, others);
        }


        [ConsoleCommand("clanui_promote")]
        void cmdClanPromoteMember(ConsoleSystem.Arg args)
        {
            var player = args.Player();
            switch (args.Args[0].ToLower())
            {
                case "promote":
                    PromotePlayer(player, args.Args[1]);
                    break;
                case "demote":
                    DemotePlayer(player, args.Args[1]);
                    break;
            }
            ClanUI(player, 0);

        }

        public void PromotePlayer(BasePlayer player, string targetId) => cmdClanPromote(player, new string[] { "", targetId });

        void cmdClanPromote(BasePlayer player, string[] args)
        {
            var current = this.covalence.Players.FindPlayerById(player.UserIDString);
            var myClan = findClanByUser(current.Id);
            if (myClan == null)
            {
                PrintChat(player, string.Format(msg("notmember", current.Id)));
                return;
            }
            if (!myClan.IsOwner(current.Id))
            {
                PrintChat(player, string.Format(msg("needclanowner", current.Id)));
                return;
            }
            if (args.Length != 2)
            {
                PrintChat(player, string.Format(msg("usagepromote", current.Id), colorCmdUsage));
                return;
            }
            var promotePlayer = myClan.GetIMember(args[1]);
            if (promotePlayer == null)
            {
                PrintChat(player, string.Format(msg("nosuchplayer", current.Id), args[1]));
                return;
            }
            if (!myClan.IsMember(promotePlayer.Id))
            {
                PrintChat(player, string.Format(msg("notaclanmember", current.Id), promotePlayer.Name));
                return;
            }
            if (enableClanAllies && myClan.IsCouncil(promotePlayer.Id))
            {
                PrintChat(player, string.Format(msg("alreadyacouncil", current.Id), promotePlayer.Name));
                return;
            }
            if (enableClanAllies && myClan.council != null && myClan.IsModerator(promotePlayer.Id))
            {
                PrintChat(player, string.Format(msg("alreadyacouncilset", current.Id), promotePlayer.Name));
                return;
            }
            if (!enableClanAllies && myClan.IsModerator(promotePlayer.Id))
            {
                PrintChat(player, string.Format(msg("alreadyamod", current.Id), promotePlayer.Name));
                return;
            }
            if (!myClan.IsModerator(promotePlayer.Id) && limitModerators >= 0 && myClan.moderators.Count() >= limitModerators)
            {
                PrintChat(player, string.Format(msg("maximummods", current.Id)));
                return;
            }
            if (enableClanAllies && myClan.IsModerator(promotePlayer.Id))
            {
                myClan.council = promotePlayer.Id;
                myClan.moderators.Remove(promotePlayer.Id);
                myClan.BroadcastLoc("playerpromotedcouncil", myClan.ColNam(current.Id, current.Name), myClan.ColNam(promotePlayer.Id, promotePlayer.Name));
            }
            else
            {
                myClan.moderators.Add(promotePlayer.Id);
                myClan.BroadcastLoc("playerpromoted", myClan.ColNam(current.Id, current.Name), myClan.ColNam(promotePlayer.Id, promotePlayer.Name));
            }
            myClan.updated = UnixTimeStampUTC();
            myClan.onUpdate();
        }
        public void DemotePlayer(BasePlayer player, string targetId) => cmdClanDemote(player, new string[] {
"", targetId
}
        );
        void cmdClanDemote(BasePlayer player, string[] args)
        {
            var current = this.covalence.Players.FindPlayerById(player.UserIDString);
            var myClan = findClanByUser(current.Id);
            if (myClan == null)
            {
                PrintChat(player, string.Format(msg("notmember", current.Id)));
                return;
            }
            if (!myClan.IsOwner(current.Id))
            {
                PrintChat(player, string.Format(msg("needclanowner", current.Id)));
                return;
            }
            if (args.Length < 2)
            {
                PrintChat(player, string.Format(msg("usagedemote", current.Id), colorCmdUsage));
                return;
            }
            var demotePlayer = myClan.GetIMember(args[1]);
            if (demotePlayer == null)
            {
                PrintChat(player, string.Format(msg("nosuchplayer", current.Id), args[1]));
                return;
            }
            if (!myClan.IsMember(demotePlayer.Id))
            {
                PrintChat(player, string.Format(msg("notaclanmember", current.Id), demotePlayer.Name));
                return;
            }
            if (!myClan.IsModerator(demotePlayer.Id) && !myClan.IsCouncil(demotePlayer.Id))
            {
                PrintChat(player, string.Format(msg("notpromoted", current.Id), demotePlayer.Name));
                return;
            }
            if (enableClanAllies && myClan.IsCouncil(demotePlayer.Id))
            {
                myClan.council = null;
                if (limitModerators >= 0 && myClan.moderators.Count() >= limitModerators) myClan.BroadcastLoc("playerdemoted", myClan.ColNam(current.Id, current.Name), myClan.ColNam(demotePlayer.Id, demotePlayer.Name));
                else
                {
                    myClan.moderators.Add(demotePlayer.Id);
                    myClan.BroadcastLoc("councildemoted", myClan.ColNam(current.Id, current.Name), myClan.ColNam(demotePlayer.Id, demotePlayer.Name));
                }
            }
            else
            {
                myClan.moderators.Remove(demotePlayer.Id);
                myClan.BroadcastLoc("playerdemoted", myClan.ColNam(current.Id, current.Name), myClan.ColNam(demotePlayer.Id, demotePlayer.Name));
            }
            myClan.updated = UnixTimeStampUTC();
            myClan.onUpdate();
        }
        public void LeaveClan(BasePlayer player) => cmdClanLeave(player, new string[] {
"leave"
}
        );
        void cmdClanLeave(BasePlayer player, string[] args)
        {
            var current = this.covalence.Players.FindPlayerById(player.UserIDString);
            var myClan = findClanByUser(current.Id);
            bool lastMember = false;
            if (myClan == null)
            {
                PrintChat(player, string.Format(msg("notmember", current.Id)));
                return;
            }
            if (args.Length != 1)
            {
                PrintChat(player, string.Format(msg("usageleave", current.Id), colorCmdUsage));
                return;
            }
            if (myClan.members.Count() == 1)
            {
                RemoveClan(myClan.tag);
                lastMember = true;
            }
            else
            {
                if (myClan.IsCouncil(current.Id)) myClan.council = null;
                myClan.moderators.Remove(current.Id);
                myClan.members.Remove(current.Id);
                myClan.invites.Remove(current.Id);
                if (myClan.IsOwner(current.Id) && myClan.members.Count() > 0)
                {
                    myClan.owner = myClan.members.ToList()[0].Key;
                }
            }
            clanCache.Remove(current.Id);
            setupPlayer(player, current.Name, current.Id);
            if (usePermGroups && permission.UserHasGroup(current.Id, permGroupPrefix + myClan.tag)) permission.RemoveUserGroup(current.Id, permGroupPrefix + myClan.tag);
            RemoveRadar(player, myClan.tag, true);
            PrintChat(player, string.Format(msg("youleft", current.Id)));
            myClan.BroadcastLoc("playerleft", myClan.ColNam(current.Id, current.Name));
            myClan.updated = UnixTimeStampUTC();
            myClan.total--;
            myClan.onUpdate();
            if (lastMember) myClan.onDestroy();
            if (!lastMember) Interface.Oxide.CallHook("OnClanMemberGone", current.Id, myClan.members.ToList());
        }
        public void KickPlayer(BasePlayer player, string targetId) => cmdClanKick(player, new string[] {
"", targetId
}
        );
        void cmdClanKick(BasePlayer player, string[] args)
        {
            var current = this.covalence.Players.FindPlayerById(player.UserIDString);
            var myClan = findClanByUser(current.Id);
            if (myClan == null)
            {
                PrintChat(player, string.Format(msg("notmember", current.Id)));
                return;
            }
            if (!myClan.IsOwner(current.Id) && !myClan.IsCouncil(current.Id) && !myClan.IsModerator(current.Id))
            {
                PrintChat(player, string.Format(msg("notmoderator", current.Id)));
                return;
            }
            if (args.Length != 2)
            {
                PrintChat(player, string.Format(msg("usagekick", current.Id), colorCmdUsage));
                return;
            }
            var kickPlayer = myClan.GetIMember(args[1]);
            if (kickPlayer == null)
            {
                PrintChat(player, string.Format(msg("nosuchplayer", current.Id), args[1]));
                return;
            }
            if (!myClan.IsMember(kickPlayer.Id) && !myClan.IsInvited(kickPlayer.Id))
            {
                PrintChat(player, string.Format(msg("notmembercannotkicked", current.Id), kickPlayer.Name));
                return;
            }
            if (myClan.IsOwner(kickPlayer.Id) || myClan.IsCouncil(kickPlayer.Id) || myClan.IsModerator(kickPlayer.Id))
            {
                PrintChat(player, string.Format(msg("modownercannotkicked", current.Id), kickPlayer.Name));
                return;
            }
            foreach (var value in myClan.members)
            {
                var turrets = UnityEngine.Object.FindObjectsOfType<AutoTurret>();
                foreach (var turret in turrets)
                {
                    if (turret.OwnerID != ulong.Parse(value.Key)) continue;
                    turret.authorizedPlayers.RemoveAll(a => a.userid == ulong.Parse(kickPlayer.Id));
                }
            }
            if (myClan.members.ContainsKey(kickPlayer.Id)) myClan.total--;
            myClan.members.Remove(kickPlayer.Id);
            myClan.invites.Remove(kickPlayer.Id);
            if (pendingPlayerInvites.ContainsKey(kickPlayer.Id)) pendingPlayerInvites[kickPlayer.Id].Remove(myClan.tag);
            clanCache.Remove(kickPlayer.Id);
            var kickBasePlayer = rust.FindPlayerByIdString(kickPlayer.Id);
            if (kickBasePlayer != null)
            {
                setupPlayer(kickBasePlayer, kickPlayer.Name, kickPlayer.Id);
                RemoveRadar(kickBasePlayer, myClan.tag, true);
            }
            if (usePermGroups && permission.UserHasGroup(kickPlayer.Id, permGroupPrefix + myClan.tag)) permission.RemoveUserGroup(kickPlayer.Id, permGroupPrefix + myClan.tag);
            myClan.BroadcastLoc("waskicked", myClan.ColNam(current.Id, current.Name), myClan.ColNam(kickPlayer.Id, kickPlayer.Name));
            myClan.updated = UnixTimeStampUTC();
            myClan.onUpdate();
            Interface.Oxide.CallHook("OnClanMemberGone", kickPlayer.Id, myClan.members);
        }
        public void DisbandClan(BasePlayer player) => cmdClanDisband(player, new string[] {
"disband", "forever"
}
        );
        void cmdClanDisband(BasePlayer player, string[] args)
        {
            var current = this.covalence.Players.FindPlayerById(player.UserIDString);
            var myClan = findClanByUser(current.Id);
            bool lastMember = false;
            if (myClan == null)
            {
                PrintChat(player, string.Format(msg("notmember", current.Id)));
                return;
            }
            if (!myClan.IsOwner(current.Id))
            {
                PrintChat(player, string.Format(msg("needclanowner", current.Id)));
                return;
            }
            if (args.Length != 2)
            {
                PrintChat(player, string.Format(msg("usagedisband", current.Id), colorCmdUsage));
                return;
            }
            if (myClan.members.Count() == 1)
            {
                lastMember = true;
            }
            RemoveRadarGroup(myClan.members.Keys.ToList(), myClan.tag, true);
            RemoveClan(myClan.tag);
            foreach (var member in myClan.members)
            {
                clanCache.Remove(member.Key);
                if (usePermGroups && permission.UserHasGroup((string)member.Key, permGroupPrefix + myClan.tag)) permission.RemoveUserGroup((string)member.Key, permGroupPrefix + myClan.tag);
            }
            myClan.BroadcastLoc("clandisbanded");
            setupPlayers(myClan.members.Keys.ToList());
            foreach (var ally in clans)
            {
                Clan allyClan = clans[ally.Key];
                allyClan.clanAlliances.Remove(myClan.tag);
                allyClan.invitedAllies.Remove(myClan.tag);
                allyClan.pendingInvites.Remove(myClan.tag);
            }
            if (usePermGroups && permission.GroupExists(permGroupPrefix + myClan.tag)) permission.RemoveGroup(permGroupPrefix + myClan.tag);
            myClan.onDestroy();
            AllyRemovalCheck();
            if (!lastMember) Interface.Oxide.CallHook("OnClanDisbanded", myClan.members);
        }
        public void Alliance(BasePlayer player, string targetClan, string type) => cmdChatClanAlly(player, "ally", new string[] {
type, targetClan
}
        );
        void cmdChatClanAlly(BasePlayer player, string command, string[] args)
        {
            if (!enableClanAllies || player == null) return;
            var current = this.covalence.Players.FindPlayerById(player.UserIDString);
            var myClan = findClanByUser(current.Id);
            if (myClan == null)
            {
                PrintChat(player, string.Format(msg("notmember", current.Id)));
                return;
            }
            if (!myClan.IsOwner(current.Id) && !myClan.IsCouncil(current.Id))
            {
                PrintChat(player, string.Format(msg("needclanownercouncil", current.Id)));
                return;
            }
            if (args == null || args.Length == 0)
            {
                var sbally = new StringBuilder();

                string Messages = pluginPrefixREBORNShow == true ? $"<size=14><color={pluginPrefixREBORNColor}>REBORN\n</color></size>" : "\n";
                sbally.Append($"<size=18><color={pluginPrefixColor}>{this.Title}</color></size>{Messages}");
                sbally.Append($"<color={colorTextMsg}>");
                if (myClan.IsOwner(current.Id)) sbally.Append(string.Format(msg("youareownerof", current.Id)));
                else if (myClan.IsCouncil(current.Id)) sbally.Append(string.Format(msg("youarecouncilof", current.Id)));
                else if (myClan.IsModerator(current.Id)) sbally.Append(string.Format(msg("youaremodof", current.Id)));
                else sbally.Append(string.Format(msg("youarememberof", current.Id)));
                sbally.AppendLine($" <color={colorClanNamesOverview}>{myClan.tag}</color> ( {myClan.online}/{myClan.total} )");
                if (myClan.clanAlliances.Count() > 0) sbally.AppendLine(string.Format(msg("yourclanallies", current.Id)) + $" <color={colorClanNamesOverview}>" + string.Join(", ", myClan.clanAlliances.ToArray()) + "</color>");
                if ((myClan.invitedAllies.Count() > 0 || myClan.pendingInvites.Count() > 0) && (myClan.IsOwner(current.Id) || myClan.IsCouncil(current.Id)))
                {
                    if (myClan.invitedAllies.Count() > 0) sbally.Append(string.Format(msg("allyinvites", current.Id)) + $" <color={colorClanNamesOverview}>" + string.Join(", ", myClan.invitedAllies.ToArray()) + "</color> ");
                    if (myClan.pendingInvites.Count() > 0) sbally.Append(string.Format(msg("allypending", current.Id)) + $" <color={colorClanNamesOverview}>" + string.Join(", ", myClan.pendingInvites.ToArray()) + "</color> ");
                    sbally.AppendLine();
                }
                string commandtext = string.Empty;
                if (command.Contains("ally")) commandtext = command;
                else commandtext = chatCommandClan + " ally";
                sbally.AppendLine($"<color={colorCmdUsage}>/{commandtext} <{msg("allyArgRequest", current.Id)} | {msg("allyArgRequestShort", current.Id)}> <clantag></color>");
                sbally.AppendLine(" " + msg("allyReqHelp", current.Id));
                sbally.AppendLine($"<color={colorCmdUsage}>/{commandtext} <{msg("allyArgAccept", current.Id)} | {msg("allyArgAcceptShort", current.Id)}> <clantag></color>");
                sbally.AppendLine(" " + msg("allyAccHelp", current.Id));
                sbally.AppendLine($"<color={colorCmdUsage}>/{commandtext} <{msg("allyArgDecline", current.Id)} | {msg("allyArgDeclineShort", current.Id)}> <clantag></color>");
                sbally.AppendLine(" " + msg("allyDecHelp", current.Id));
                sbally.AppendLine($"<color={colorCmdUsage}>/{commandtext} <{msg("allyArgCancel", current.Id)} | {msg("allyArgCancelShort", current.Id)}> <clantag></color>");
                sbally.AppendLine(" " + msg("allyCanHelp", current.Id));
                sbally.Append("</color>");
                SendReply(player, sbally.ToString().TrimEnd());
                return;
            }
            else if (args != null && args.Length >= 1 && args.Length < 2)
            {
                PrintChat(player, string.Format(msg("allyProvideName", current.Id)));
                return;
            }
            else if (args.Length >= 1)
            {
                Clan targetClan = null;
                string opt = args[0];
                if (opt == msg("allyArgRequest", current.Id) || opt == msg("allyArgRequestShort", current.Id))
                {
                    if (limitAlliances != 0 && myClan.clanAlliances.Count >= limitAlliances)
                    {
                        PrintChat(player, string.Format(msg("allyLimit", current.Id)));
                        return;
                    }
                    if (myClan.invitedAllies.Contains(args[1]))
                    {
                        PrintChat(player, string.Format(msg("invitePending", current.Id), args[1]));
                        return;
                    }
                    if (myClan.clanAlliances.Contains(args[1]))
                    {
                        PrintChat(player, string.Format(msg("alreadyAllies", current.Id)));
                        return;
                    }
                    targetClan = findClan(args[1]);
                    if (targetClan == null)
                    {
                        PrintChat(player, string.Format(msg("clanNoExist", current.Id), args[1]));
                        return;
                    }
                    targetClan.pendingInvites.Add(myClan.tag);
                    myClan.invitedAllies.Add(targetClan.tag);
                    PrintChat(player, string.Format(msg("allyReq", current.Id), args[1]));
                    targetClan.AllyBroadcastLoc("reqAlliance", myClan.tag);
                    myClan.onUpdate();
                    targetClan.onUpdate();
                    return;
                }
                else if (opt == msg("allyArgAccept", current.Id) || opt == msg("allyArgAcceptShort", current.Id))
                {
                    if (!myClan.pendingInvites.Contains(args[1]))
                    {
                        PrintChat(player, string.Format(msg("noAllyInv", current.Id), args[1]));
                        return;
                    }
                    targetClan = findClan(args[1]);
                    if (targetClan == null)
                    {
                        PrintChat(player, string.Format(msg("clanNoExist", current.Id), args[1]));
                        return;
                    }
                    if (limitAlliances != 0 && myClan.clanAlliances.Count >= limitAlliances)
                    {
                        PrintChat(player, string.Format(msg("allyAccLimit", current.Id), targetClan.tag));
                        targetClan.invitedAllies.Remove(myClan.tag);
                        myClan.pendingInvites.Remove(targetClan.tag);
                        return;
                    }
                    targetClan.invitedAllies.Remove(myClan.tag);
                    targetClan.clanAlliances.Add(myClan.tag);
                    myClan.pendingInvites.Remove(targetClan.tag);
                    myClan.clanAlliances.Add(targetClan.tag);
                    myClan.onUpdate();
                    targetClan.onUpdate();
                    PrintChat(player, string.Format(msg("allyAcc", current.Id), targetClan.tag));
                    targetClan.AllyBroadcastLoc("allyAccSucc", myClan.tag);
                    return;
                }
                else if (opt == msg("allyArgDeclineallyArgDecline", current.Id) || opt == msg("allyArgDeclineShort", current.Id))
                {
                    if (!myClan.pendingInvites.Contains(args[1]))
                    {
                        PrintChat(player, string.Format(msg("noAllyInv", current.Id), args[1]));
                        return;
                    }
                    targetClan = findClan(args[1]);
                    if (targetClan == null)
                    {
                        PrintChat(player, string.Format(msg("clanNoExist", current.Id), args[1]));
                        return;
                    }
                    targetClan.invitedAllies.Remove(myClan.tag);
                    myClan.pendingInvites.Remove(targetClan.tag);
                    AllyRemovalCheck();
                    PrintChat(player, string.Format(msg("allyDeclined", current.Id), args[1]));
                    myClan.onUpdate();
                    targetClan.onUpdate();
                    targetClan.AllyBroadcastLoc("allyDeclinedSucc", myClan.tag);
                    return;
                }
                else if (opt == msg("allyArgCancel", current.Id) || opt == msg("allyArgCancelShort", current.Id))
                {
                    if (!myClan.clanAlliances.Contains(args[1]))
                    {
                        if (myClan.invitedAllies.Contains(args[1]))
                        {
                            myClan.invitedAllies.Remove(args[1]);
                            targetClan = findClan(args[1]);
                            if (targetClan != null) targetClan.pendingInvites.Remove(myClan.tag);
                            PrintChat(player, string.Format(msg("allyInvWithdraw", current.Id), args[1]));
                            myClan.onUpdate();
                            targetClan.onUpdate();
                            return;
                        }
                        PrintChat(player, string.Format(msg("noAlly", current.Id)));
                        return;
                    }
                    targetClan = findClan(args[1]);
                    if (targetClan == null)
                    {
                        PrintChat(player, string.Format(msg("clanNoExist", current.Id), args[1]));
                        return;
                    }
                    targetClan.clanAlliances.Remove(myClan.tag);
                    myClan.clanAlliances.Remove(targetClan.tag);
                    AllyRemovalCheck();
                    PrintChat(player, string.Format(msg("allyCancel", current.Id), args[1]));
                    myClan.onUpdate();
                    targetClan.onUpdate();
                    targetClan.AllyBroadcastLoc("allyCancelSucc", myClan.tag);
                    return;
                }
                else cmdChatClanAlly(player, command, new string[] { }
                );
            }
        }
        void cmdChatClanHelp(BasePlayer player, string command, string[] args)
        {
            if (player == null) return;
            var current = this.covalence.Players.FindPlayerById(player.UserIDString);
            var myClan = findClanByUser(current.Id);
            var sb = new StringBuilder();
            if (myClan == null)
            {
                sb.Append($"<color={colorTextMsg}>");
                sb.AppendLine(msg("helpavailablecmds", current.Id));
                sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgCreate", current.Id)} \"TAG\" \"Description\"</color> - {msg("helpcreate", current.Id)}");
                sb.Append($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgJoin", current.Id)} \"TAG\"</color> - {msg("helpjoin", current.Id)}");
                sb.Append("</color>");
                SendReply(player, sb.ToString().TrimEnd());
                return;
            }
            sb.AppendLine(msg("helpavailablecmds", current.Id));
            sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan}</color> - {msg("helpinformation", current.Id)}");
            sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClanChat} <msg></color> - {msg("helpmessagemembers", current.Id)}");
            if (enableClanAllies) sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandAllyChat} <msg></color> - {msg("helpmessageally", current.Id)}");
            sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgLeave", current.Id)}</color> - {msg("helpleave", current.Id)}");
            if (enableFFOPtion) sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgFF", current.Id)} |  /{chatCommandFF}</color> - {msg("helptoggleff", current.Id)}");
            if ((enableClanRadar && !usePermissionClanRadar) || enableClanRadar && usePermissionClanRadar && permission.UserHasPermission(current.Id, permissionClanRadarUse)) sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgRadar", current.Id)} | /{chatCommandRadar}</color> - {msg("helptoggleradar", current.Id)}");
            if ((myClan.IsOwner(current.Id) || myClan.IsCouncil(current.Id) || myClan.IsModerator(current.Id)))
            {
                sb.AppendLine($"<color={clanModeratorColor}>{msg("helpmoderator", current.Id)}</color> {msg("helpcommands", current.Id)}");
                sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgInvite", current.Id)} {msg("clanArgNameId", current.Id)}</color> - {msg("helpinvite", current.Id)}");
                sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgWithdraw", current.Id)} {msg("clanArgNameId", current.Id)}</color> - {msg("helpwithdraw", current.Id)}");
                sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgKick", current.Id)} {msg("clanArgNameId", current.Id)}</color> - {msg("helpkick", current.Id)}");
            }
            if ((myClan.IsOwner(current.Id) || (enableClanAllies && myClan.IsCouncil(current.Id))))
            {
                sb.AppendLine($"<color={clanOwnerColor}>{msg("helpowner", current.Id)}</color> {msg("helpcommands", current.Id)}");
                if (enableClanAllies) sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgAlly", current.Id)} | {chatCommandClan + "ally"}</color> - {msg("helpallyoptions", current.Id)}");
                if (myClan.IsOwner(current.Id)) sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgPromote", current.Id)} {msg("clanArgNameId", current.Id)}</color> - {msg("helppromote", current.Id)}");
                if (myClan.IsOwner(current.Id)) sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgDemote", current.Id)} {msg("clanArgNameId", current.Id)}</color> - {msg("helpdemote", current.Id)}");
                if (myClan.IsOwner(current.Id)) sb.AppendLine($"<color={colorCmdUsage}>/{chatCommandClan} {msg("clanArgDisband", current.Id)} {msg("clanArgForever", current.Id)}</color> - {msg("helpdisband", current.Id)}");
            }
            if (player.net.connection.authLevel >= authLevelDelete || player.net.connection.authLevel >= authLevelRename || player.net.connection.authLevel >= authLevelInvite || player.net.connection.authLevel >= authLevelKick || player.net.connection.authLevel >= authLevelPromoteDemote) sb.AppendLine($"<color={clanServerColor}>Server management</color>: {msg("helpconsole", current.Id)} <color={colorCmdUsage}>clans</color>");
            string openText = $"<color={colorTextMsg}>";
            string closeText = "</color>";
            string[] parts = sb.ToString().Split(new char[] {
'\n'
}
            , StringSplitOptions.RemoveEmptyEntries);
            sb = new StringBuilder();
            foreach (var part in parts)
            {
                if ((sb.ToString().TrimEnd().Length + part.Length + openText.Length + closeText.Length) > 1050)
                {
                    SendReply(player, openText + sb.ToString().TrimEnd() + closeText);
                    sb.Clear();
                }
                sb.AppendLine(part);
            }
            SendReply(player, openText + sb.ToString().TrimEnd() + closeText);
        }
        void cmdChatClanInfo(BasePlayer player, string command, string[] args)
        {
            if (player == null) return;
            if (player.net.connection.authLevel < authLevelClanInfo)
            {
                PrintChat(player, "No access to this command.");
                return;
            }
            if (args == null || args.Length == 0)
            {
                PrintChat(player, "Please specify a clan tag.");
                return;
            }
            var Clan = findClan(args[0]);
            if (Clan == null)
            {
                PrintChat(player, string.Format(msg("clanNoExist", player.UserIDString), args[0]));
                return;
            }
            var sb = new StringBuilder();
            string Messages = pluginPrefixREBORNShow == true ? $"<size=14><color= {pluginPrefixREBORNColor}>REBORN\n</color></size>" : "\n";
            sb.Append($"<size=18><color={pluginPrefixColor}>{this.Title}</color></size>{Messages}");
            sb.AppendLine($"<color={colorTextMsg}>Detailed clan information for:");
            sb.AppendLine($"ClanTag:  <color={colorClanNamesOverview}>{Clan.tag}</color> ( Online: <color={colorClanNamesOverview}>{Clan.online}</color> / Total: <color={colorClanNamesOverview}>{Clan.total}</color> )");
            sb.AppendLine($"Description: <color={colorClanNamesOverview}>{Clan.description}</color>");
            sb.Append(string.Format(msg("memberon", player.UserIDString)));
            int n = 0;
            foreach (var memberId in Clan.members)
            {
                var op = this.covalence.Players.FindPlayerById(memberId.Key);
                if (op != null && op.IsConnected)
                {
                    if (n > 0) sb.Append(", ");
                    if (Clan.IsOwner(memberId.Key))
                    {
                        sb.Append(string.Format(msg("overviewnamecolor", player.UserIDString), clanOwnerColor, op.Name));
                    }
                    else if (Clan.IsCouncil(memberId.Key))
                    {
                        sb.Append(string.Format(msg("overviewnamecolor", player.UserIDString), clanCouncilColor, op.Name));
                    }
                    else if (Clan.IsModerator(memberId.Key))
                    {
                        sb.Append(string.Format(msg("overviewnamecolor", player.UserIDString), clanModeratorColor, op.Name));
                    }
                    else
                    {
                        sb.Append(string.Format(msg("overviewnamecolor", player.UserIDString), clanMemberColor, op.Name));
                    }
                    ++n;
                }
            }
            if (Clan.online == 0) sb.Append(" - ");
            sb.Append("</color>\n");
            bool offline = false;
            foreach (var memberId in Clan.members)
            {
                var op = this.covalence.Players.FindPlayerById(memberId.Key);
                if (op != null && !op.IsConnected)
                {
                    offline = true;
                    break;
                }
            }
            if (offline)
            {
                sb.Append(string.Format(msg("memberoff", player.UserIDString)));
                n = 0;
                foreach (var memberId in Clan.members)
                {
                    var p = this.covalence.Players.FindPlayerById(memberId.Key);
                    if (p != null && !p.IsConnected)
                    {
                        if (n > 0) sb.Append(", ");
                        if (Clan.IsOwner(memberId.Key))
                        {
                            sb.Append(string.Format(msg("overviewnamecolor", player.UserIDString), clanOwnerColor, p.Name));
                        }
                        else if (Clan.IsCouncil(memberId.Key))
                        {
                            sb.Append(string.Format(msg("overviewnamecolor", player.UserIDString), clanCouncilColor, p.Name));
                        }
                        else if (Clan.IsModerator(memberId.Key))
                        {
                            sb.Append(string.Format(msg("overviewnamecolor", player.UserIDString), clanModeratorColor, p.Name));
                        }
                        else
                        {
                            sb.Append(string.Format(msg("overviewnamecolor", player.UserIDString), clanMemberColor, p.Name));
                        }
                        ++n;
                    }
                }
                sb.Append("\n");
            }
            sb.AppendLine($"Time created: <color={colorClanNamesOverview}>{UnixTimeStampToDateTime(Clan.created)}</color>");
            sb.AppendLine($"Last change: <color={colorClanNamesOverview}>{UnixTimeStampToDateTime(Clan.updated)}</color>");
            SendReply(player, sb.ToString().TrimEnd());
        }
        void cmdChatClanchat(BasePlayer player, string command, string[] args)
        {
            if (player == null || args.Length == 0) return;
            var myClan = findClanByUser(player.UserIDString);
            if (myClan == null)
            {
                SendReply(player, string.Format(msg("notmember", player.UserIDString)));
                return;
            }
            if (clanChatDenyOnMuted)
            {
                var current = this.covalence.Players.FindPlayerById(player.UserIDString);
                var chk = Interface.CallHook("API_IsMuted", current);
                if (chk != null && chk is bool && (bool)chk)
                {
                    SendReply(player, string.Format(msg("clanchatmuted", player.UserIDString)));
                    return;
                }
            }
            var message = string.Join(" ", args);
            if (string.IsNullOrEmpty(message)) return;
            myClan.BroadcastChat(string.Format(msg("broadcastformat"), myClan.PlayerColor(player.UserIDString), player.net.connection.username, message));
            if (ConVar.Chat.serverlog) DebugEx.Log(string.Format("[CHAT] CLAN [{0}] - {1}: {2}", myClan.tag, player.net.connection.username, message), StackTraceLogType.None);
        }
        void cmdChatAllychat(BasePlayer player, string command, string[] args)
        {
            if (player == null || args.Length == 0) return;
            var myClan = findClanByUser(player.UserIDString);
            if (myClan == null)
            {
                PrintChat(player, string.Format(msg("notmember", player.UserIDString)));
                return;
            }
            if (myClan.clanAlliances.Count == 0)
            {
                PrintChat(player, string.Format(msg("noactiveally", player.UserIDString)));
                return;
            }
            if (clanChatDenyOnMuted)
            {
                var current = this.covalence.Players.FindPlayerById(player.UserIDString);
                var chk = Interface.CallHook("API_IsMuted", current);
                if (chk != null && chk is bool && (bool)chk)
                {
                    SendReply(player, string.Format(msg("clanchatmuted", player.UserIDString)));
                    return;
                }
            }
            var message = string.Join(" ", args);
            if (string.IsNullOrEmpty(message)) return;
            foreach (var clanAllyName in myClan.clanAlliances)
            {
                var clanAlly = findClan(clanAllyName);
                if (clanAlly == null) continue;
                clanAlly.AllyBroadcastChat(string.Format(msg("allybroadcastformat"), myClan.tag, myClan.PlayerColor(player.UserIDString), player.net.connection.username, message));
            }
            myClan.AllyBroadcastChat(string.Format(msg("broadcastformat"), myClan.PlayerColor(player.UserIDString), player.net.connection.username, message));
            if (ConVar.Chat.serverlog) DebugEx.Log(string.Format("[CHAT] ALLY [{0}] - {1}: {2}", myClan.tag, player.net.connection.username, message), StackTraceLogType.None);
        }
        void cmdChatClanFF(BasePlayer player, string command, string[] args)
        {
            if (!enableFFOPtion || player == null) return;
            var myClan = findClanByUser(player.UserIDString);
            if (myClan == null)
            {
                PrintChat(player, string.Format(msg("notmember", player.UserIDString)));
                return;
            }
            if (manuallyEnabledBy.Contains(player.userID))
            {
                manuallyEnabledBy.Remove(player.userID);
                PrintChat(player, string.Format(msg("clanffdisabled", player.UserIDString), colorClanFFOff));
                return;
            }
            else
            {
                manuallyEnabledBy.Add(player.userID);
                PrintChat(player, string.Format(msg("clanffenabled", player.UserIDString), colorClanFFOn));
                return;
            }
        }
        public bool HasFFEnabled(ulong playerId) => !enableFFOPtion ? false : !manuallyEnabledBy.Contains(playerId) ? false : true;
        public void ToggleFF(ulong playerId)
        {
            if (manuallyEnabledBy.Contains(playerId)) manuallyEnabledBy.Remove(playerId);
            else manuallyEnabledBy.Add(playerId);
        }
        void cmdChatClanRadar(BasePlayer player, string command, string[] args)
        {
            if (!enableClanRadar || player == null || (usePermissionClanRadar && !permission.UserHasPermission(player.UserIDString, permissionClanRadarUse))) return;
            var myClan = findClanByUser(player.UserIDString);
            if (myClan == null)
            {
                PrintChat(player, string.Format(msg("notmember", player.UserIDString)));
                return;
            }
            if (player.GetComponent<ClanRadar>())
            {
                GameObject.Destroy(player.GetComponent<ClanRadar>());
                PrintChat(player, string.Format(msg("clanradardisabled", player.UserIDString)));
                activeRadarUsers.Remove(player.UserIDString);
                return;
            }
            ClanRadar radar = player.transform.GetOrAddComponent<ClanRadar>();
            radar.DoStart();
            PrintChat(player, string.Format(msg("clanradarenabled", player.UserIDString)));
        }
        [ProtoContract(ImplicitFields = ImplicitFields.AllFields)]
        class StoredData
        {
            public Dictionary<string, Clan> clans = new Dictionary<string, Clan>();
            public Int32 saveStamp = 0;
            public string lastStorage = string.Empty;
            public StoredData() { }
        }

        StoredData clanSaves = new StoredData();

        public class ChangeListed
        {
            public uint Need { get; set; }
            public uint Complete { get; set; }
        }

        public class MembersChangeList
        {
            public int Complete { get; set; }
        }

        public class PlayerStats
        {
            public int PlayerPoints = 0;
            public int Killed = 0;
            public int Death = 0;
            public int Suicide = 0;
            public int KilledHeli = 0;
            public int GatherStone = 0;
            public int GatherSulfur = 0;
            public int GatherMetal = 0;
            public int GatherHQM = 0;
            public int GatherWood = 0;
            public int KilledBarrel = 0;
            public Dictionary<string, int> GatherInfo = new Dictionary<string, int>()
            {
                 {"wood", 0},
                         {"metal.ore", 0 },
                         {"stones", 0 },
                         {"sulfur.ore", 0 },
                         {"fat.animal", 0 },
                         {"cloth", 0 },
                         {"leather", 0 },
                         {"hq.metal.ore", 0 },
                         {"loot-barrel", 0 },


            };
        }


        [ProtoContract(ImplicitFields = ImplicitFields.AllFields)]
        public class Clan
        {
            public int ClanPoints = 0;
            public string tag;
            public string description;
            public string owner;
            public string ownerName;
            public string ClanAvatar;
            public string council;
            public int created;
            public int updated;
            [JsonIgnore, ProtoIgnore] public int online;
            [JsonIgnore, ProtoIgnore] public int total;
            [JsonIgnore, ProtoIgnore] public int mods;
            public List<string> moderators = new List<string>();
            public Dictionary<string, PlayerStats> members = new Dictionary<string, PlayerStats>();


            public Dictionary<string, int> invites = new Dictionary<string, int>();
            public List<string> clanAlliances = new List<string>();
            public List<string> invitedAllies = new List<string>();
            public List<string> pendingInvites = new List<string>();
            //Custom code
            public Dictionary<string, ulong> SkinList = new Dictionary<string, ulong>();
            public Dictionary<string, ChangeListed> Change = new Dictionary<string, ChangeListed>()
            {
                ["wood"] = new ChangeListed()
                {
                    Complete = 0,
                    Need = 1000
                },
                ["metal.ore"] = new ChangeListed()
                {
                    Complete = 0,
                    Need = 1000
                },
                ["stones"] = new ChangeListed()
                {
                    Complete = 0,
                    Need = 1000
                },
                ["sulfur.ore"] = new ChangeListed()
                {
                    Complete = 0,
                    Need = 1000
                },
                ["fat.animal"] = new ChangeListed()
                {
                    Complete = 0,
                    Need = 300
                },
                ["cloth"] = new ChangeListed()
                {
                    Complete = 0,
                    Need = 300
                },
                ["leather"] = new ChangeListed()
                {
                    Complete = 0,
                    Need = 100
                },
                ["hq.metal.ore"] = new ChangeListed()
                {
                    Complete = 0,
                    Need = 500
                },
                ["loot-barrel"] = new ChangeListed()
                {
                    Complete = 0,
                    Need = 20
                },
            };

            public static Clan Create(string tag, string description, string ownerId, string owName, string URL)
            {
                var clan = new Clan()
                {
                    ClanPoints = 0,
                    tag = tag,
                    description = description,
                    owner = ownerId,
                    ClanAvatar = URL,
                    ownerName = owName,
                    created = cc.UnixTimeStampUTC(),
                    updated = cc.UnixTimeStampUTC(),
                    SkinList = new Dictionary<string, ulong>()
                    {
                         {"metal.facemask", 0},
                         {"metal.plate.torso", 0 },
                         {"burlap.gloves", 0 },
                         {"hoodie", 0 },
                         {"pants", 0 },
                         {"roadsign.kilt", 0 },
                         {"shoes.boots", 0 },
                    },
                    Change = new Dictionary<string, ChangeListed>()
                    {
                        ["wood"] = new ChangeListed()
                        {
                            Complete = 0,
                            Need = 1000
                        },
                        ["metal.ore"] = new ChangeListed()
                        {
                            Complete = 0,
                            Need = 1000
                        },
                        ["stones"] = new ChangeListed()
                        {
                            Complete = 0,
                            Need = 1000
                        },
                        ["sulfur.ore"] = new ChangeListed()
                        {
                            Complete = 0,
                            Need = 1000
                        },
                        ["fat.animal"] = new ChangeListed()
                        {
                            Complete = 0,
                            Need = 300
                        },
                        ["cloth"] = new ChangeListed()
                        {
                            Complete = 0,
                            Need = 300
                        },
                        ["leather"] = new ChangeListed()
                        {
                            Complete = 0,
                            Need = 100
                        },
                        ["hq.metal.ore"] = new ChangeListed()
                        {
                            Complete = 0,
                            Need = 500
                        },
                        ["loot-barrel"] = new ChangeListed()
                        {
                            Complete = 0,
                            Need = 20
                        },
                    }
                };
                clan.members.Add(ownerId, new PlayerStats());
                return clan;
            }
            public bool IsOwner(string userId)
            {
                return userId == owner;
            }
            public bool IsCouncil(string userId)
            {
                return userId == council;
            }
            public bool IsModerator(string userId)
            {
                return moderators.Contains(userId);
            }
            public bool IsMember(string userId)
            {
                return members.ContainsKey(userId);
            }
            public bool IsInvited(string userId)
            {
                return invites.ContainsKey(userId);
            }
            public void BroadcastChat(string message)
            {
                foreach (var memberId in members)
                {
                    var player = BasePlayer.Find(memberId.Key);
                    if (player == null) continue;
                    player.ChatMessage(string.Format(cc.broadcastPrefixFormat, cc.broadcastPrefixColor, cc.broadcastPrefix) + $"<color={cc.broadcastMessageColor}>{message}</color>");
                }
            }
            public void BroadcastLoc(string messagetype, string arg1 = "", string arg2 = "", string arg3 = "", string arg4 = "", string current = "")
            {
                string message = string.Empty;
                foreach (var memberId in members)
                {
                    var player = BasePlayer.Find(memberId.Key);
                    if (player == null || player.UserIDString == current) continue;
                    message = string.Format(cc.msg(messagetype, memberId.Key), arg1, arg2, arg3, arg4);
                    player.ChatMessage(string.Format(cc.broadcastPrefixFormat, cc.broadcastPrefixColor, cc.broadcastPrefix) + $"<color={cc.broadcastMessageColor}>{message}</color>");
                }
            }
            public void AllyBroadcastChat(string message)
            {
                foreach (var memberId in members)
                {
                    var player = BasePlayer.Find(memberId.Key);
                    if (player == null) continue;
                    player.ChatMessage(string.Format(cc.broadcastPrefixFormat, cc.broadcastPrefixColor, cc.broadcastPrefixAlly) + $"<color={cc.broadcastMessageColor}>{message}</color>");
                }
            }
            public void AllyBroadcastLoc(string messagetype, string arg1 = "", string arg2 = "", string arg3 = "", string arg4 = "")
            {
                string message = string.Empty;
                foreach (var memberId in members)
                {
                    var player = BasePlayer.Find(memberId.Key);
                    if (player == null) continue;
                    message = string.Format(cc.msg(messagetype, memberId.Key), arg1, arg2, arg3, arg4);
                    player.ChatMessage(string.Format(cc.broadcastPrefixFormat, cc.broadcastPrefixColor, cc.broadcastPrefixAlly) + $"<color={cc.broadcastMessageColor}>{message}</color>");
                }
            }
            public string ColNam(string Id, string Name)
            {
                if (IsOwner(Id)) return $"<color={cc.clanOwnerColor}>{Name}</color>";
                else if (IsCouncil(Id) && !IsOwner(Id)) return $"<color={cc.clanCouncilColor}>{Name}</color>";
                else if (IsModerator(Id) && !IsOwner(Id)) return $"<color={cc.clanModeratorColor}>{Name}</color>";
                else return $"<color={cc.clanMemberColor}>{Name}</color>";
            }
            public string PlayerLevel(string userID)
            {
                if (IsOwner(userID)) return "Owner";
                if (IsCouncil(userID)) return "Council";
                if (IsModerator(userID)) return "Moderator";
                return "Member";
            }
            public string PlayerColor(string userID)
            {
                if (IsOwner(userID)) return cc.clanOwnerColor;
                if (IsCouncil(userID)) return cc.clanCouncilColor;
                if (IsModerator(userID)) return cc.clanModeratorColor;
                return cc.clanMemberColor;
            }
            public IPlayer GetIPlayer(string partialName)
            {
                ulong userID;
                IPlayer iplayer;
                if (partialName.Length == 17 && ulong.TryParse(partialName, out userID))
                {
                    iplayer = cc.covalence.Players.FindPlayer(partialName);
                    return iplayer;
                }
                if (invites.Count > 0) foreach (var imember in GetInvites())
                    {
                        if (imember.Name.Contains(partialName) || imember.Name.EndsWith(partialName))
                        {
                            iplayer = cc.covalence.Players.FindPlayerById(imember.Id);
                            return iplayer;
                        }
                    }
                var player = cc.rust.FindPlayerByName(partialName);
                if (player != null) return cc.covalence.Players.FindPlayerById(player.UserIDString);
                try
                {
                    var iply = cc.covalence.Players.FindPlayer(partialName);
                    if (iply is IPlayer) return iply;
                }
                catch
                {
                    var idplayer = cc.covalence.Players.FindPlayer(partialName);
                    if (idplayer != null) return idplayer;
                }
                return null;
            }
            public IPlayer GetIMember(string partialName)
            {
                ulong userID;
                IPlayer player = null;
                if (partialName.Length == 17 && ulong.TryParse(partialName, out userID))
                {
                    player = cc.covalence.Players.FindPlayer(partialName);
                    return player;
                }
                foreach (var imember in GetIMembers())
                {
                    if (imember.Name.Contains(partialName) || imember.Name.EndsWith(partialName))
                    {
                        player = cc.covalence.Players.FindPlayerById(imember.Id);
                        return player;
                    }
                }
                player = GetIPlayer(partialName);
                return player;
            }
            public List<IPlayer> GetIMembers()
            {
                List<IPlayer> export = new List<IPlayer>();
                foreach (var member in members)
                {
                    if (IsOwner(member.Key)) continue;
                    IPlayer player = cc.covalence.Players.FindPlayerById(member.Key);
                    if (player != null) export.Add(player);
                }
                return export;
            }
            public List<IPlayer> GetInvites()
            {
                List<IPlayer> export = new List<IPlayer>();
                foreach (var invited in invites)
                {
                    IPlayer player = cc.covalence.Players.FindPlayerById(invited.Key);
                    if (player != null) export.Add(player);
                }
                return export;
            }
            internal JObject ToJObject()
            {
                var obj = new JObject();
                obj["tag"] = tag;
                obj["description"] = description;
                obj["owner"] = owner;
                obj["council"] = council;
                var jmoderators = new JArray();
                foreach (var moderator in moderators) jmoderators.Add(moderator);
                obj["moderators"] = jmoderators;
                var jmembers = new JArray();
                foreach (var member in members) jmembers.Add(member.Key);
                obj["members"] = jmembers;
                var jallies = new JArray();
                foreach (var ally in clanAlliances) jallies.Add(ally);
                obj["allies"] = jallies;
                var jinvallies = new JArray();
                foreach (var ally in invitedAllies) jinvallies.Add(ally);
                obj["invitedallies"] = jinvallies;
                return obj;
            }
            internal void onCreate() => Interface.CallHook("OnClanCreate", tag);
            internal void onUpdate() => Interface.CallHook("OnClanUpdate", tag);
            internal void onDestroy() => Interface.CallHook("OnClanDestroy", tag);
        }
        sealed class ClanRadar : FacepunchBehaviour
        {
            BasePlayer player;
            Clan clan;
            bool noAdmin;
            void Awake()
            {
                player = GetComponent<BasePlayer>();
                player.SetInfo("noRadarAdmin", !player.IsAdmin ? "1" : "2");
                noAdmin = !player.IsAdmin;
                clan = cc.findClanByUser(player.UserIDString);
            }
            public void DoStart()
            {
                CancelInvoke(DoRadar);
                if (!cc.activeRadarUsers.Contains(player.UserIDString)) cc.activeRadarUsers.Add(player.UserIDString);
                InvokeRepeating(DoRadar, 1f, cc.refreshTime);
            }
            void SetPlayerFlag(BasePlayer.PlayerFlags f, bool b)
            {
                if (b)
                {
                    if (player.HasPlayerFlag(f)) return;
                    player.playerFlags |= f;
                }
                else
                {
                    if (!player.HasPlayerFlag(f)) return;
                    player.playerFlags &= ~f;
                }
                player.SendNetworkUpdateImmediate(false);
            }
            void DoRadar()
            {
                if (player != null && (player.IsSleeping() || player.IsSpectating() || player.IsReceivingSnapshot)) return;
                if (player == null || !player.IsConnected || player.IsDead())
                {
                    DoDestroy();
                    return;
                }
                if (noAdmin) SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, true);
                try
                {
                    foreach (BasePlayer targetplayer in cc.clanRadarMemberobjects[clan.tag].Where(p => p != null && p != player && !p.IsDead()).ToList())
                    {
                        float targetDist = Vector3.Distance(targetplayer.transform.position, player.transform.position);
                        bool inFullRange = targetDist < maxNamedistance && targetDist > minDistance;
                        bool inSleepRange = targetDist < maxSleeperDistance && targetDist > minDistance;
                        if (targetplayer.IsConnected && !targetplayer.IsSleeping() && inFullRange) player.SendConsoleCommand("ddraw.text", cc.refreshTime, UnityEngine.Color.grey, targetplayer.transform.position + playerHeight, $"<size={cc.radarTextSize}><color={cc.nameColor}>{targetplayer.displayName}</color> | <color={cc.distanceColor}>{Math.Floor(targetDist)}m</color></size>");
                        else if (cc.showSleepers && targetplayer.IsSleeping() && inSleepRange) player.SendConsoleCommand("ddraw.text", cc.refreshTime, UnityEngine.Color.grey, targetplayer.transform.position + sleeperHeight, $"<size={cc.radarTextSize}><color={cc.sleeperNameColor}>{targetplayer.displayName}</color> | <color={cc.distanceColor}>{Math.Floor(targetDist)}m</color></size>");
                    }
                    if (cc.enableClanAllies && cc.extendOnAllyMembers && clan.clanAlliances.Count > 0) foreach (var allyClan in clan.clanAlliances) foreach (BasePlayer targetplayer in cc.clanRadarMemberobjects[allyClan.ToString()].Where(p => p != null && p.IsConnected && !p.IsSleeping() && !p.IsDead()).ToList())
                            {
                                float targetDist = Vector3.Distance(targetplayer.transform.position, player.transform.position);
                                bool inFullRange = targetDist < maxNamedistance && targetDist > minDistance;
                                if (Vector3.Distance(targetplayer.transform.position, player.transform.position) < maxNamedistance && Vector3.Distance(targetplayer.transform.position, player.transform.position) > minDistance) player.SendConsoleCommand("ddraw.text", cc.refreshTime, UnityEngine.Color.grey, targetplayer.transform.position + playerHeight, $"<size={cc.radarTextSize}><color={cc.nameColor}>{targetplayer.displayName}</color> | <color={cc.distanceColor}>{Math.Floor(Vector3.Distance(targetplayer.transform.position, player.transform.position))}m</color></size>");
                            }
                }
                finally
                {
                    if (noAdmin) SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, false);
                }
            }
            void DoDestroy()
            {
                CancelInvoke(DoRadar);
                Destroy(this);
            }
            void OnDestroy()
            {
                if (noAdmin) SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, false);
                CancelInvoke(DoRadar);
            }
        }
        void RemoveRadar(BasePlayer player, string tag, bool leftOrKicked = false)
        {
            if (player != null && enableClanRadar)
            {
                GameObject.Destroy(player.GetComponent<ClanRadar>());
                activeRadarUsers.Remove(player.UserIDString);
                if (leftOrKicked && clanRadarMemberobjects.ContainsKey(tag)) clanRadarMemberobjects[tag].Remove(player);
            }
        }
        void RemoveRadarGroup(List<string> playerIds, string tag, bool isDisband = false)
        {
            if (!enableClanRadar) return;
            if (isDisband) clanRadarMemberobjects.Remove(tag);
            foreach (var playerId in playerIds)
            {
                BasePlayer player = rust.FindPlayerByIdString(playerId);
                if (player != null) RemoveRadar(player, tag, isDisband);
            }
        }
        [HookMethod("GetClan")]
        private JObject GetClan(string tag)
        {
            if (tag == null || tag == "") return null;
            var clan = findClan(tag);
            if (clan == null) return null;
            return clan.ToJObject();
        }

        [HookMethod("GetAllClans")]
        private JArray GetAllClans()
        {
            return new JArray(clans.Keys);
        }
        [HookMethod("GetClanOf")]
        private string GetClanOf(ulong player)
        {
            if (player == 0uL) return null;
            var clan = findClanByUser(player.ToString());
            if (clan == null) return null;
            return clan.tag;
        }
        [HookMethod("GetClanOf")]
        private string GetClanOf(string player)
        {
            if (player == null || player == "") return null;
            var clan = findClanByUser(player.ToString());
            if (clan == null) return null;
            return clan.tag;
        }
        [HookMethod("GetClanOf")]
        private string GetClanOf(BasePlayer player)
        {
            if (player == null) return null;
            var clan = findClanByUser(player.UserIDString);
            if (clan == null) return null;
            return clan.tag;
        }
        [HookMethod("GetClanMembers")]
        private List<string> GetClanMembers(ulong PlayerID)
        {
            List<string> Players = new List<string>();
            var myClan = findClanByUser(PlayerID.ToString());
            if (myClan == null) return null;
            foreach (var it in myClan.members)
                Players.Add(it.Key);
            return Players;
        }
        //object CanUseLockedEntity(BasePlayer player, BaseLock @lock)
        //{
        //    if (!(@lock is CodeLock) || @lock.GetParentEntity().OwnerID <= 0) return null;
        //    if (@lock.GetParentEntity().OwnerID == player.userID) return null;
        //    bool check = (bool)HasFriend(@lock.GetParentEntity().OwnerID, player.userID);
        //    if (check == true)
        //    {
        //        return true;
        //    }
        //    return null;
        //}
        //private object OnTurretTarget(AutoTurret turret, BaseCombatEntity targ)
        //{
        //    if (!(targ is BasePlayer) || turret.OwnerID <= 0) return null;
        //    var player = (BasePlayer)targ;
        //    if (turret.IsAuthed(player)) return null;
        //    bool check = (bool)HasFriend(turret.OwnerID, player.userID);
        //    if (check == true)
        //    {
        //        turret.authorizedPlayers.Add(new PlayerNameID
        //        {
        //            userid = player.userID,
        //            username = player.displayName
        //        });
        //        turret.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
        //        return false;
        //    }
        //    return null;
        //}
        [HookMethod("HasFriend")]
        private object HasFriend(ulong entOwnerID, ulong PlayerUserID)
        {
            var clanOwner = findClanByUser(entOwnerID.ToString());
            if (clanOwner == null) return null;
            var clanFriend = findClanByUser(PlayerUserID.ToString());
            if (clanFriend == null) return null;
            if (clanOwner.tag == clanFriend.tag) return true;
            return false;
        }
		
		 private bool IsClanMember(string playerId, string otherId)
        {
            Clan playerClan = findClanByUser(playerId);
            if (playerClan == null) return false;

            Clan otherClan = findClanByUser(otherId);
            if (otherClan == null) return false;

            if (playerClan.tag != otherClan.tag)
                return false;

            return true;
        }
		
		private bool IsClanMember(ulong playerId, ulong otherId)
		{
		return IsClanMember(playerId.ToString(),otherId.ToString());
		}
		
		 private bool IsMemberOrAlly(string playerId, string otherId)
        {
            Clan playerClan = findClanByUser(playerId);
            if (playerClan == null) return false;

            Clan otherClan = findClanByUser(otherId);
            if (otherClan == null) return false;

            if (playerClan.tag == otherClan.tag  || playerClan.clanAlliances.Contains(otherClan.tag))
                return true;

            return false;
        }
		
        private bool IsAllyPlayer(string playerId, string otherId)
        {
            Clan playerClan = findClanByUser(playerId);
            if (playerClan == null) return false;

            Clan otherClan = findClanByUser(otherId);
            if (otherClan == null) return false;

            if (playerClan.clanAlliances.Contains(otherClan.tag))
                return true;

            return false;
        }
		
        [HookMethod("IsModerator")]
        private object IsModerator(ulong PlayerUserID)
        {
            var clan = findClanByUser(PlayerUserID.ToString());
            if (clan == null) return null;
            if ((setHomeOwner && clan.IsOwner(PlayerUserID.ToString())) || (setHomeModerator && (clan.IsModerator(PlayerUserID.ToString()) || clan.IsCouncil(PlayerUserID.ToString()))) || setHomeMember) return true;
            return false;
        }
        private Int32 UnixTimeStampUTC()
        {
            Int32 unixTimeStamp;
            DateTime currentTime = DateTime.Now;
            DateTime zuluTime = currentTime.ToUniversalTime();
            DateTime unixEpoch = new DateTime(1970, 1, 1);
            unixTimeStamp = (Int32)(zuluTime.Subtract(unixEpoch)).TotalSeconds;
            return unixTimeStamp;
        }
        private static DateTime UnixTimeStampToDateTime(double unixTimeStamp)
        {
            return unixTimeStamp > MaxUnixSeconds ? UnixEpoch.AddMilliseconds(unixTimeStamp) : UnixEpoch.AddSeconds(unixTimeStamp);
        }
        string msg(string key, string id = null) => lang.GetMessage(key, this, id);
        void PrintChat(BasePlayer player, string message)
        {
            SendReply(player, string.Format(pluginPrefixFormat, pluginPrefixColor, pluginPrefix) + $"<color={colorTextMsg}>" + message + "</color>");
        }
        [ConsoleCommand("clans")]
        void cclans(ConsoleSystem.Arg arg)
        {
            if (arg != null && arg.Connection != null && arg.Connection.player != null && arg.Connection.authLevel >= 1)
            {
                var sb = new StringBuilder();
                sb.AppendLine("clans.list (Lists all clans, their owners and their membercount)");
                sb.AppendLine("clans.listex (Lists all clans, their owners/members and their onlinestatus)");
                sb.AppendLine("clans.show TAG (lists the choosen clan and the members with status)");
                sb.AppendLine("clans.msg TAG message without quotes (Sends a clan message)");
                if (arg.Connection.authLevel >= authLevelRename) sb.AppendLine("clans.rename OLDTAG NEWTAG (rename's a clan)");
                if (arg.Connection.authLevel >= authLevelDelete) sb.AppendLine("clans.delete TAG (delete's a clan)");
                if (arg.Connection.authLevel >= authLevelInvite) sb.AppendLine("clans.playerinvite TAG playername (sends clan invitation to a player)");
                if (arg.Connection.authLevel >= authLevelKick) sb.AppendLine("clans.playerkick TAG playername (kicks a player from a clan)");
                if (arg.Connection.authLevel >= authLevelPromoteDemote)
                {
                    sb.AppendLine("clans.playerpromote TAG playername (promotes a player)");
                    sb.AppendLine("clans.playerdemote TAG playername (demotes a player)");
                }
                SendReply(arg, sb.ToString());
            }
        }
        [ConsoleCommand("clans.cmds")]
        void cclansCommands(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 2) return;
            var sb = new StringBuilder();
            sb.AppendLine("\n>> Clans command overview <<\n");
            sb.AppendLine("clans.list".PadRight(20) + "| Lists all clans, their owners and their membercount");
            sb.AppendLine("clans.listex".PadRight(20) + "| Lists all clans, their owners/members and their onlinestatus");
            sb.AppendLine("clans.show".PadRight(20) + "| lists the choosen clan and the members with status");
            sb.AppendLine("clans.showduplicates".PadRight(20) + "| lists the players which do exist in more than one clan");
            sb.AppendLine("clans.msg".PadRight(20) + "| message without quotes (Sends a clan message)");
            sb.AppendLine("clans.rename".PadRight(20) + "| rename's a clan");
            sb.AppendLine("clans.delete".PadRight(20) + "| delete's a clan");
            sb.AppendLine("clans.changeowner".PadRight(20) + "| changes the owner to another member");
            sb.AppendLine("clans.playerinvite".PadRight(20) + "| sends clan invitation to a player");
            sb.AppendLine("clans.playerjoin".PadRight(20) + "| joins a player into a clan");
            sb.AppendLine("clans.playerkick".PadRight(20) + "| kicks a player from a clan");
            sb.AppendLine("clans.playerpromote".PadRight(20) + "| promotes a player");
            sb.AppendLine("clans.playerdemote".PadRight(20) + "| demotes a player");
            SendReply(arg, sb.ToString());
        }
        [ConsoleCommand("clans.list")]
        void cclansList(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 1) return;
            TextTable textTable = new TextTable();
            textTable.AddColumn("Tag");
            textTable.AddColumn("Owner");
            textTable.AddColumn("SteamID");
            textTable.AddColumn("Count");
            textTable.AddColumn("On");
            foreach (var iclan in clans)
            {
                Clan clan = clans[iclan.Key];
                var owner = this.covalence.Players.FindPlayerById(clan.owner);
                if (owner == null) continue;
                textTable.AddRow(new string[] {
    clan.tag, owner.Name, clan.owner, clan.total.ToString(), clan.online.ToString()
}
                );
            }
            SendReply(arg, "\n>> Current clans <<\n" + textTable.ToString());
        }
        [ConsoleCommand("clans.showduplicates")]
        void cclansDuplicates(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 1) return;
            TextTable textTable = new TextTable();
            textTable.AddColumn("SteamID");
            textTable.AddColumn("Memberships");
            textTable.AddColumn("PlayerName");
            Dictionary<string, List<string>> clanDuplicates = new Dictionary<string, List<string>>();
            foreach (var iclan in clans)
            {
                Clan clan = clans[iclan.Key];
                foreach (var member in clan.members.ToList())
                {
                    if (!clanDuplicates.ContainsKey(member.Key))
                    {
                        clanDuplicates.Add(member.Key, new List<string>());
                        clanDuplicates[member.Key].Add(clan.tag);
                        continue;
                    }
                    else clanDuplicates[member.Key].Add(clan.tag);
                }
            }
            foreach (var clDup in clanDuplicates)
            {
                if (clDup.Value.Count < 2) continue;
                var player = this.covalence.Players.FindPlayerById(clDup.Key);
                if (player == null) continue;
                textTable.AddRow(new string[] {
    clDup.Key, string.Join(" | ", clDup.Value.ToArray()), player.Name
}
                );
            }
            SendReply(arg, "\n>> Current found duplicates <<\n" + textTable.ToString());
        }
        [ConsoleCommand("clans.listex")]
        void cclansListEx(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 1) return;
            TextTable textTable = new TextTable();
            textTable.AddColumn("Tag");
            textTable.AddColumn("Level");
            textTable.AddColumn("Name");
            textTable.AddColumn("SteamID");
            textTable.AddColumn("Status");
            foreach (var iclan in clans)
            {
                Clan clan = clans[iclan.Key];
                foreach (var memberid in clan.members)
                {
                    var member = this.covalence.Players.FindPlayerById(memberid.Key);
                    if (member == null) continue;
                    textTable.AddRow(new string[] {
        clan.tag, clan.PlayerLevel(member.Id), member.Name, member.Id.ToString(), (member.IsConnected ? "Online": "Offline").ToString()
    }
                    );
                }
                textTable.AddRow(new string[] { }
                );
            }
            SendReply(arg, "\n>> Current clans with members <<\n" + textTable.ToString());
        }
        [ConsoleCommand("clans.show")]
        void cclansShow(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 1) return;
            if (arg.Args == null || arg.Args.Length < 1)
            {
                SendReply(arg, "Usage: clans.show TAG");
                return;
            }
            Clan clan;
            if (!TryGetClan(arg.Args[0], out clan))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }
            var sb = new StringBuilder();
            sb.AppendLine($"\n>> Show clan [{clan.tag}] <<");
            sb.AppendLine($"Description: {clan.description}");
            sb.AppendLine($"Time created: {UnixTimeStampToDateTime(clan.created)}");
            sb.AppendLine($"Last updated: {UnixTimeStampToDateTime(clan.updated)}");
            sb.AppendLine($"Member count: {clan.total}");
            TextTable textTable = new TextTable();
            textTable.AddColumn("Level");
            textTable.AddColumn("Name");
            textTable.AddColumn("SteamID");
            textTable.AddColumn("Status");
            sb.AppendLine();
            foreach (var memberid in clan.members)
            {
                var member = this.covalence.Players.FindPlayerById(memberid.Key);
                if (member == null) continue;
                textTable.AddRow(new string[] {
    clan.PlayerLevel(member.Id), member.Name, member.Id.ToString(), (member.IsConnected ? "Online": "Offline").ToString()
}
                );
            }
            sb.AppendLine(textTable.ToString());
            SendReply(arg, sb.ToString());
        }
        [ConsoleCommand("clans.msg")]
        void cclansBroadcast(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 1) return;
            if (arg.Args == null || arg.Args.Length < 2)
            {
                SendReply(arg, "Usage: clans.msg TAG your message without quotes");
                return;
            }
            Clan clan;
            if (!TryGetClan(arg.Args[0], out clan))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }
            string BroadcastBy = consoleName;
            if (arg.Connection != null)
            {
                if (arg.Connection.authLevel == 2) BroadcastBy = "(Admin) " + arg.Connection.username;
                else BroadcastBy = "(Mod) " + arg.Connection.username;
            }
            string Msg = "";
            for (int i = 1;
            i < arg.Args.Length;
            i++) Msg = Msg + " " + arg.Args[i];
            clan.BroadcastChat($"<color={clanServerColor}>{BroadcastBy}</color>: {Msg}");
            SendReply(arg, $"Broadcast to [{clan.tag}]: {Msg}");
        }
        [ConsoleCommand("clans.rename")]
        void cclansRename(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < authLevelRename) return;
            if (arg.Args == null || arg.Args.Length < 2)
            {
                SendReply(arg, "Usage: clans.rename OldTag NewTag");
                return;
            }
            Clan clan;
            if (!TryGetClan(arg.Args[0], out clan))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }
            if (tagReExt.IsMatch(arg.Args[1]))
            {
                SendReply(arg, string.Format(msg("hintchars"), allowedSpecialChars));
                return;
            }
            if (arg.Args[1].Length < tagLengthMin || arg.Args[1].Length > tagLengthMax)
            {
                SendReply(arg, string.Format(msg("hintlength"), tagLengthMin, tagLengthMax));
                return;
            }
            if (clans.ContainsKey(arg.Args[1]))
            {
                SendReply(arg, string.Format(msg("tagblocked")));
                return;
            }
            string oldtag = clan.tag;
            clan.tag = arg.Args[1];
            clan.online = 0;
            clans.Add(clan.tag, clan);
            RemoveClan(oldtag);
            setupPlayers(clan.members.Keys.ToList());
            string oldGroup = permGroupPrefix + oldtag;
            string newGroup = permGroupPrefix + clan.tag;
            if (permission.GroupExists(oldGroup))
            {
                foreach (var member in clan.members) if (permission.UserHasGroup(member.Key, oldGroup)) permission.RemoveUserGroup(member.Key, oldGroup);
                permission.RemoveGroup(oldGroup);
            }
            if (usePermGroups && !permission.GroupExists(newGroup)) permission.CreateGroup(newGroup, "Clan " + clan.tag, 0);
            foreach (var member in clan.members) if (usePermGroups && !permission.UserHasGroup(member.Key, newGroup)) permission.AddUserGroup(member.Key, newGroup);
            string RenamedBy = consoleName;
            if (arg.Connection != null) RenamedBy = arg.Connection.username;
            foreach (var ally in clans)
            {
                Clan allyClan = clans[ally.Key];
                if (allyClan.clanAlliances.Contains(oldtag))
                {
                    allyClan.clanAlliances.Remove(oldtag);
                    allyClan.clanAlliances.Add(clan.tag);
                }
                if (allyClan.invitedAllies.Contains(oldtag))
                {
                    allyClan.invitedAllies.Remove(oldtag);
                    allyClan.invitedAllies.Add(clan.tag);
                }
                if (allyClan.pendingInvites.Contains(oldtag))
                {
                    allyClan.pendingInvites.Remove(oldtag);
                    allyClan.pendingInvites.Add(clan.tag);
                }
            }
            clan.BroadcastLoc("clanrenamed", $"<color={clanServerColor}>{RenamedBy}</color>", clan.tag);
            SendReply(arg, string.Format(msg("yourenamed"), oldtag, clan.tag));
            clan.onUpdate();
        }
        [ConsoleCommand("clans.playerinvite")]
        void cclansPlayerInvite(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < authLevelInvite) return;
            if (arg.Args == null || arg.Args.Length < 2)
            {
                SendReply(arg, "Usage: clans.playerinvite TAG playername/id");
                return;
            }
            Clan myClan;
            Clan check;
            if (!TryGetClan(arg.Args[0], out check))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }
            else myClan = (Clan)check;
            var invPlayer = myClan.GetIPlayer(arg.Args[1]);
            if (invPlayer == null)
            {
                SendReply(arg, string.Format(msg("nosuchplayer"), arg.Args[1]));
                return;
            }
            if (myClan.members.ContainsKey(invPlayer.Id))
            {
                SendReply(arg, string.Format(msg("alreadymember"), invPlayer.Name));
                return;
            }
            if (myClan.invites.ContainsKey(invPlayer.Id))
            {
                SendReply(arg, string.Format(msg("alreadyinvited"), invPlayer.Name));
                return;
            }
            if (findClanByUser(invPlayer.Id) != null)
            {
                SendReply(arg, string.Format(msg("alreadyinclan"), invPlayer.Name));
                return;
            }
            myClan.invites.Add(invPlayer.Id, UnixTimeStampUTC());
            if (!pendingPlayerInvites.ContainsKey(invPlayer.Id)) pendingPlayerInvites.Add(invPlayer.Id, new List<string>());
            pendingPlayerInvites[invPlayer.Id].Add(myClan.tag);
            if (invPlayer.IsConnected)
            {
                var invited = rust.FindPlayerByIdString(invPlayer.Id);
                if (invited != null) PrintChat(invited, string.Format(msg("claninvite", invPlayer.Id), myClan.tag, myClan.description, colorCmdUsage));
            }
            myClan.updated = UnixTimeStampUTC();
            SendReply(arg, $"Invitation for clan '{myClan.tag}' sent to '{invPlayer.Name}'");
        }
        [ConsoleCommand("clans.playerjoin")]
        void cclansPlayerJoin(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < authLevelInvite) return;
            if (arg.Args == null || arg.Args.Length < 2)
            {
                SendReply(arg, "Usage: clans.playerjoin TAG playername/id");
                return;
            }
            Clan myClan;
            Clan check;
            if (!TryGetClan(arg.Args[0], out check))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }
            else myClan = (Clan)check;
            var joinPlayer = myClan.GetIPlayer(arg.Args[1]);
            if (joinPlayer == null)
            {
                SendReply(arg, string.Format(msg("nosuchplayer"), arg.Args[1]));
                return;
            }
            if (myClan.members.ContainsKey(joinPlayer.Id))
            {
                SendReply(arg, string.Format(msg("alreadymember"), joinPlayer.Name));
                return;
            }
            if (findClanByUser(joinPlayer.Id) != null)
            {
                SendReply(arg, string.Format(msg("alreadyinclan"), joinPlayer.Name));
                return;
            }
            myClan.invites.Remove(joinPlayer.Id);
            pendingPlayerInvites.Remove(joinPlayer.Id);
            myClan.members.Add(joinPlayer.Id, new PlayerStats());

            clanCache[joinPlayer.Id] = myClan;
            if (joinPlayer.IsConnected)
            {
                var joined = rust.FindPlayerByIdString(joinPlayer.Id);
                if (joined != null) setupPlayer(joined, joinPlayer.Name, joinPlayer.Id);
            }
            if (usePermGroups && !permission.UserHasGroup(joinPlayer.Id, permGroupPrefix + myClan.tag)) permission.AddUserGroup(joinPlayer.Id, permGroupPrefix + myClan.tag);
            myClan.BroadcastLoc("playerjoined", myClan.ColNam(joinPlayer.Id, joinPlayer.Name));
            myClan.updated = UnixTimeStampUTC();
            myClan.total++;

            myClan.onUpdate();
            List<string> others = new List<string>(myClan.members.Keys.ToList());
            others.Remove(joinPlayer.Id);
            Interface.Oxide.CallHook("OnClanMemberJoined", joinPlayer.Id, others);
            SendReply(arg, $"Playerjoin into clan '{myClan.tag}' done for '{joinPlayer.Name}'");
        }
        [ConsoleCommand("clans.playerkick")]
        void cclansPlayerKick(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < authLevelKick) return;
            if (arg.Args == null || arg.Args.Length < 2)
            {
                SendReply(arg, "Usage: clans.playerkick TAG playername/id");
                return;
            }
            Clan myClan;
            Clan check;
            if (!TryGetClan(arg.Args[0], out check))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }
            else myClan = (Clan)check;
            var kickPlayer = myClan.GetIMember(arg.Args[1]);
            if (kickPlayer == null)
            {
                SendReply(arg, string.Format(msg("nosuchplayer"), arg.Args[1]));
                return;
            }
            if (!myClan.IsMember(kickPlayer.Id) && !myClan.IsInvited(kickPlayer.Id))
            {
                SendReply(arg, string.Format(msg("notmembercannotkicked"), kickPlayer.Name));
                return;
            }
            if (myClan.members.Count() == 1)
            {
                SendReply(arg, "The clan has only one member. You need to delete the clan");
                return;
            }
            if (myClan.members.ContainsKey(kickPlayer.Id)) myClan.total--;
            myClan.invites.Remove(kickPlayer.Id);
            if (myClan.IsCouncil(kickPlayer.Id)) myClan.council = null;
            myClan.moderators.Remove(kickPlayer.Id);
            myClan.members.Remove(kickPlayer.Id);
            myClan.invites.Remove(kickPlayer.Id);
            bool ownerChanged = false;
            if (myClan.IsOwner(kickPlayer.Id) && myClan.members.Count() > 0)
            {
                myClan.owner = myClan.members.ToList()[0].Key;
                ownerChanged = true;
            }
            if (pendingPlayerInvites.ContainsKey(kickPlayer.Id)) pendingPlayerInvites[kickPlayer.Id].Remove(myClan.tag);
            clanCache.Remove(kickPlayer.Id);
            var kickBasePlayer = rust.FindPlayerByIdString(kickPlayer.Id);
            if (kickBasePlayer != null)
            {
                setupPlayer(kickBasePlayer, kickPlayer.Name, kickPlayer.Id);
                RemoveRadar(kickBasePlayer, myClan.tag, true);
            }
            if (usePermGroups && permission.UserHasGroup(kickPlayer.Id, permGroupPrefix + myClan.tag)) permission.RemoveUserGroup(kickPlayer.Id, permGroupPrefix + myClan.tag);
            myClan.updated = UnixTimeStampUTC();
            myClan.onUpdate();
            Interface.Oxide.CallHook("OnClanMemberGone", kickPlayer.Id, myClan.members);
            SendReply(arg, $"Player '{kickPlayer.Name}' was kicked from clan '{myClan.tag}'");
            if (ownerChanged)
            {
                var newOwner = myClan.GetIPlayer(myClan.owner);
                if (newOwner != null) SendReply(arg, $"New owner of clan '{myClan.tag}' is {newOwner.Name}");
            }
        }
        [ConsoleCommand("clans.changeowner")]
        void cclansChangeOwner(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < authLevelPromoteDemote) return;
            if (arg.Args == null || arg.Args.Length < 2)
            {
                SendReply(arg, "Usage: clans.changeowner TAG playername/id");
                return;
            }
            Clan myClan;
            Clan check;
            if (!TryGetClan(arg.Args[0], out check))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }
            else myClan = (Clan)check;
            var promotePlayer = myClan.GetIPlayer(arg.Args[1]);
            if (promotePlayer == null)
            {
                SendReply(arg, string.Format(msg("nosuchplayer"), arg.Args[1]));
                return;
            }
            if (!myClan.IsMember(promotePlayer.Id))
            {
                SendReply(arg, string.Format(msg("notaclanmember"), promotePlayer.Name));
                return;
            }
            if (myClan.IsOwner(promotePlayer.Id))
            {
                SendReply(arg, string.Format(msg("alreadyowner"), promotePlayer.Name));
                return;
            }
            string PromotedBy = consoleName;
            if (arg.Connection != null) PromotedBy = arg.Connection.username;
            if (myClan.council == promotePlayer.Id) myClan.council = null;
            myClan.moderators.Remove(promotePlayer.Id);
            myClan.owner = promotePlayer.Id;
            myClan.BroadcastLoc("playerpromotedowner", $"<color={clanServerColor}>{PromotedBy}</color>", myClan.ColNam(promotePlayer.Id, promotePlayer.Name));
            myClan.updated = UnixTimeStampUTC();
            myClan.onUpdate();
            SendReply(arg, $"You promoted '{promotePlayer.Name}' to the {myClan.PlayerLevel(promotePlayer.Id.ToString())}");
        }
        [ConsoleCommand("clans.playerpromote")]
        void cclansPlayerPromote(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < authLevelPromoteDemote) return;
            if (arg.Args == null || arg.Args.Length < 2)
            {
                SendReply(arg, "Usage: clans.playerpromote TAG playername/id");
                return;
            }
            Clan myClan;
            Clan check;
            if (!TryGetClan(arg.Args[0], out check))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }
            else myClan = (Clan)check;
            var promotePlayer = myClan.GetIPlayer(arg.Args[1]);
            if (promotePlayer == null)
            {
                SendReply(arg, string.Format(msg("nosuchplayer"), arg.Args[1]));
                return;
            }
            if (!myClan.IsMember(promotePlayer.Id))
            {
                SendReply(arg, string.Format(msg("notaclanmember"), promotePlayer.Name));
                return;
            }
            if (enableClanAllies && myClan.IsCouncil(promotePlayer.Id))
            {
                SendReply(arg, string.Format(msg("alreadyacouncil"), promotePlayer.Name));
                return;
            }
            if (enableClanAllies && myClan.council != null && myClan.IsModerator(promotePlayer.Id))
            {
                SendReply(arg, string.Format(msg("alreadyacouncilset"), promotePlayer.Name));
                return;
            }
            if (!enableClanAllies && myClan.IsModerator(promotePlayer.Id))
            {
                SendReply(arg, string.Format(msg("alreadyamod"), promotePlayer.Name));
                return;
            }
            if (!myClan.IsModerator(promotePlayer.Id) && limitModerators >= 0 && myClan.moderators.Count() >= limitModerators)
            {
                SendReply(arg, string.Format(msg("maximummods")));
                return;
            }
            string PromotedBy = consoleName;
            if (arg.Connection != null) PromotedBy = arg.Connection.username;
            if (enableClanAllies && myClan.IsModerator(promotePlayer.Id))
            {
                myClan.council = promotePlayer.Id;
                myClan.moderators.Remove(promotePlayer.Id);
                myClan.BroadcastLoc("playerpromotedcouncil", $"<color={clanServerColor}>{PromotedBy}</color>", myClan.ColNam(promotePlayer.Id, promotePlayer.Name));
            }
            else
            {
                myClan.moderators.Add(promotePlayer.Id);
                myClan.BroadcastLoc("playerpromoted", $"<color={clanServerColor}>{PromotedBy}</color>", myClan.ColNam(promotePlayer.Id, promotePlayer.Name));
            }
            myClan.updated = UnixTimeStampUTC();
            myClan.onUpdate();
            SendReply(arg, $"You promoted '{promotePlayer.Name}' to a {myClan.PlayerLevel(promotePlayer.Id.ToString())}");
        }
        [ConsoleCommand("clans.playerdemote")]
        void cclansPlayerDemote(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < authLevelPromoteDemote) return;
            if (arg.Args == null || arg.Args.Length < 2)
            {
                SendReply(arg, "Usage: clans.playerdemote TAG playername/id");
                return;
            }
            Clan myClan;
            Clan check;
            if (!TryGetClan(arg.Args[0], out check))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }
            else myClan = (Clan)check;
            var demotePlayer = myClan.GetIPlayer(arg.Args[1]);
            if (demotePlayer == null)
            {
                SendReply(arg, string.Format(msg("nosuchplayer"), arg.Args[1]));
                return;
            }
            if (!myClan.IsMember(demotePlayer.Id))
            {
                SendReply(arg, string.Format(msg("notaclanmember"), demotePlayer.Name));
                return;
            }
            if (!myClan.IsModerator(demotePlayer.Id) && !myClan.IsCouncil(demotePlayer.Id))
            {
                SendReply(arg, string.Format(msg("notpromoted"), demotePlayer.Name));
                return;
            }
            string DemotedBy = consoleName;
            if (arg.Connection != null) DemotedBy = arg.Connection.username;
            if (enableClanAllies && myClan.IsCouncil(demotePlayer.Id))
            {
                myClan.council = null;
                if (limitModerators >= 0 && myClan.moderators.Count() >= limitModerators) myClan.BroadcastLoc("playerdemoted", $"<color={clanServerColor}>{DemotedBy}</color>", myClan.ColNam(demotePlayer.Id, demotePlayer.Name));
                else
                {
                    myClan.moderators.Add(demotePlayer.Id);
                    myClan.BroadcastLoc("councildemoted", $"<color={clanServerColor}>{DemotedBy}</color>", myClan.ColNam(demotePlayer.Id, demotePlayer.Name));
                }
            }
            else
            {
                myClan.moderators.Remove(demotePlayer.Id);
                myClan.BroadcastLoc("playerdemoted", $"<color={clanServerColor}>{DemotedBy}</color>", myClan.ColNam(demotePlayer.Id, demotePlayer.Name));
            }
            myClan.updated = UnixTimeStampUTC();
            myClan.onUpdate();
            SendReply(arg, $"You demoted '{demotePlayer.Name}' to a {myClan.PlayerLevel(demotePlayer.Id.ToString())}");
        }
        [ConsoleCommand("clans.delete")]
        void cclansDelete(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < authLevelDelete) return;
            if (arg.Args == null || arg.Args.Length != 1)
            {
                SendReply(arg, "Usage: clans.delete TAG");
                return;
            }
            Clan clan;
            if (!TryGetClan(arg.Args[0], out clan))
            {
                SendReply(arg, string.Format(msg("noclanfound"), arg.Args[0]));
                return;
            }
            string DeletedBy = consoleName;
            RemoveRadarGroup(clan.members.Keys.ToList(), clan.tag, true);
            if (arg.Connection != null) DeletedBy = arg.Connection.username;
            clan.BroadcastLoc("clandeleted", $"<color={clanServerColor}>{DeletedBy}</color>");
            RemoveClan(arg.Args[0]);
            foreach (var member in clan.members) clanCache.Remove(member.Key);
            setupPlayers(clan.members.Keys.ToList());
            string permGroup = permGroupPrefix + clan.tag;
            if (permission.GroupExists(permGroup))
            {
                foreach (var member in clan.members) if (permission.UserHasGroup(member.Key, permGroup)) permission.RemoveUserGroup(member.Key, permGroup);
                permission.RemoveGroup(permGroup);
            }
            foreach (var ally in clans)
            {
                Clan allyClan = clans[ally.Key];
                allyClan.clanAlliances.Remove(arg.Args[0]);
                allyClan.invitedAllies.Remove(arg.Args[0]);
                allyClan.pendingInvites.Remove(arg.Args[0]);
            }
            SendReply(arg, string.Format(msg("youdeleted"), clan.tag));
            clan.onDestroy();

            Interface.Oxide.CallHook("OnClanDisbanded", clan.members);
            AllyRemovalCheck();
        }
        bool FilterText(string tag)
        {
            foreach (string bannedword in wordFilter) if (TranslateLeet(tag).ToLower().Contains(bannedword.ToLower())) return true;
            return false;
        }
        string TranslateLeet(string original)
        {
            string translated = original;
            Dictionary<string, string> leetTable = new Dictionary<string, string> {
    {
    "}{", "h"
}
, {
    "|-|", "h"
}
, {
    "]-[", "h"
}
, {
    "/-/", "h"
}
, {
    "|{", "k"
}
, {
    "/\\/\\", "m"
}
, {
    "|\\|", "n"
}
, {
    "/\\/", "n"
}
, {
    "()", "o"
}
, {
    "[]", "o"
}
, {
    "vv", "w"
}
, {
    "\\/\\/", "w"
}
, {
    "><", "x"
}
, {
    "2", "z"
}
, {
    "4", "a"
}
, {
    "@", "a"
}
, {
    "8", "b"
}
, {
    "ß", "b"
}
, {
    "(", "c"
}
, {
    "<", "c"
}
, {
    "{", "c"
}
, {
    "3", "e"
}
, {
    "€", "e"
}
, {
    "6", "g"
}
, {
    "9", "g"
}
, {
    "&", "g"
}
, {
    "#", "h"
}
, {
    "$", "s"
}
, {
    "7", "t"
}
, {
    "|", "l"
}
, {
    "1", "i"
}
, {
    "!", "i"
}
, {
    "0", "o"
}
,
};

            foreach (var leet in leetTable) translated = translated.Replace(leet.Key, leet.Value);
            return translated;
        }
        bool TryGetClan(string input, out Clan clan)
        {
            clan = default(Clan);
            Clan tmp = null;
            if (clans.TryGetValue(input, out tmp))
            {
                clan = tmp;
                return true;
            }
            string name;
            if (clansSearch.TryGetValue(input.ToLower(), out name))
            {
                if (clans.TryGetValue(name, out tmp))
                {
                    clan = tmp;
                    return true;
                }
            }
            return false;
        }
        void RemoveClan(string tag)
        {
            clans.Remove(tag);
            clansSearch.Remove(tag.ToLower());
        }
        [HookMethod("EnableBypass")]
        void EnableBypass(object userId)
        {
            if (!enableFFOPtion || userId == null) return;
            if (userId is string) userId = Convert.ToUInt64((string)userId);
            bypass.Add((ulong)userId);
        }
        [HookMethod("DisableBypass")]
        void DisableBypass(object userId)
        {
            if (!enableFFOPtion || userId == null) return;
            if (userId is string) userId = Convert.ToUInt64((string)userId);
            bypass.Remove((ulong)userId);
        }
    }
}


// --- End of file: Clans.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BHelp.cs ---
// --- Original Local Path: BHelp.cs ---

using System.Security;
using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("BHelp", "https://devplugins.ru/", "1.0.0")]
    public class BHelp : RustPlugin
    {
        #region [Vars]
        Dictionary<string, string> Buttons = new Dictionary<string, string>();

        private string Layer = "BHelp.Layer";
        #endregion

        #region [Oxide]
	    private void OnServerInitialized()
	    {
            PrintWarning("\n-----------------------------\n" +
            "     Author - https://devplugins.ru/\n" +
            "     VK - https://vk.com/dev.plugin\n" +
            "     Discord - https://discord.gg/eHXBY8hyUJ\n" +
            "-----------------------------");
            cmd.AddChatCommand("help", this, "MainUI");
            foreach (var key in config._SettingsHelp)
				Buttons.Add(key.Key, key.Value._Name);
        }

        private void Unload()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
                CuiHelper.DestroyUi(player, Layer);
        }
        #endregion

        #region [Config]
        private PluginConfig config;

        protected override void LoadDefaultConfig()
        {
            config = PluginConfig.DefaultConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();

            if (config.PluginVersion < Version)
                UpdateConfigValues();

            Config.WriteObject(config, true);
        }

        private void UpdateConfigValues()
        {
            PluginConfig baseConfig = PluginConfig.DefaultConfig();
            if (config.PluginVersion < Version)
            {
                config.PluginVersion = Version;
                if (Version == new VersionNumber(1, 0, 0))
                {
                    //
                }

                PrintWarning("Config checked completed!");
            }
            config.PluginVersion = Version;
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        public class SettingsHelp
        {
            [JsonProperty("Название страницы")]
            public string _Name;

            [JsonProperty("Титл страницы")]
            public string _Title;

            [JsonProperty("Текст страницы")]
            public string _Text;
        }

        private class PluginConfig
        {
		    [JsonProperty("Настройка кнопок")]
		    public Dictionary<string, SettingsHelp> _SettingsHelp = new Dictionary<string, SettingsHelp>();

            [JsonProperty("Config version")]
            public VersionNumber PluginVersion = new VersionNumber();

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                {
                    _SettingsHelp = new Dictionary<string, SettingsHelp>()
                    {
                        ["server_info"] = new SettingsHelp
                        {
                            _Name = "О сервере",
                            _Title = "Информация о сервере",
                            _Text = "<color=#b7d092>BOLOTO MAX3</color> Это сервер для комфортной игры с командой до 3 игроков\nУ нас не нужно много фармить и убивать на это время! Файты и рейды - главное\nнаправление нашего сервера\n\nВайп сервера происходит каждую пятницу и вторник в <color=#b7d092>16:00</color> по МСК\n\nРейты на добычу ресурсов и компонентов <color=#b7d092>Х5</color>, с наилучшей привилегией <color=#b7d092>Х10</color>.\nКомпоненты улучшены до идеала, никакого мусора в бочках/ящиках.\n\nАктивная администрация/модерация всегда поможет вам в решение каких-либо\nвозникших проблем.\n\nНа сервере установлены уникальные плагин, такие как <color=#b7d092>FIGHTZONE, CARGOZONE,\nМЕГАЯЩИК, Апгрейд карьеров</color>\nБолее подробно о каждом из плагинов вы можете узнать тут - <color=#b7d092>vk.com/bolotorust</color>",
                        },
                        ["rules"] = new SettingsHelp
                        {
                            _Name = "Правила",
                            _Title = "Правила",
                            _Text = "Основные правила игры\n\n<color=#b7d092>1.</color> Запрещено использовать любые виды макросов/читов и всего, что дает\nпреимущество над игроками\n\n<color=#b7d092>2.</color> Нельзя обманывать игроков на любые виды ресурсов.\n\n<color=#b7d092>3.</color> Запрещено использовать баги игры/сервера в любом их проявлении.\n\n<color=#b7d092>4.</color> При нарушении лимита игроков вы получите бан на сервере длительностью от 7\nдней.\n\n<color=#b7d092>5.</color> Запрещено использовать в никах теги чужих серверов.\n\n<color=#b7d092>6.</color> Не знания правил не освобождает вас от ответственности!\n\n<color=#b7d092>7.</color> Играя на нашем сервере вы автоматически соглашаетесь с нашими правилами!\n\nБолее подробно с нашими правилами вы можете ознакомится в нашем дискорде -\n<color=#b7d092>discord.gg/eQnHwZNqrj</color>.",
                        },
                        ["command"] = new SettingsHelp
                        {
                            _Name = "Команды",
                            _Title = "Команды",
                            _Text = "<color=#b7d092>/ad</color> - Автозакрытие дверей\n<color=#b7d092>/rec</color> - Карманный переработчик\n<color=#b7d092>/backpack</color> - Открытие рюкзака\n<color=#b7d092>/fz</color> - Статистика FIGHTZONE\n<color=#b7d092>/tpmenu</color> - Меню телепортации\n<color=#b7d092>/friend</color> - Управление друзьями\n<color=#b7d092>/kit</color> - Открытие меню китов\n<color=#b7d092>/map</color> - Открытие внутриигровой карты\n<color=#b7d092>/remove</color> - Удаление построек\n<color=#b7d092>/up</color> - Автоапгрейд построек\n<color=#b7d092>/hair</color> - Меню прицелов\n<color=#b7d092>/block</color> - Блокировка предметов после вайпа\n<color=#b7d092>/skin</color> - Меню скинов\n<color=#b7d092>/skinentity</color> - Перекрасить скин на уже поставленном предмете (Чтобы сработало, нужно\nсмотреть на установленную, например дверь)\n<color=#b7d092>/raid</color> - Оповещение о рейде в ВК\n<color=#b7d092>/craft</color> - Крафт предметов\n<color=#b7d092>/chat</color> - Настройка чата\n<color=#b7d092>/pinfo</color> - Информация о ваших привилегиях\n<color=#b7d092>/trade</color> - Обмен с другими игроками\n<color=#b7d092>/bps</color> - Проверка ночной защиты\n<color=#b7d092>/report</color> - Жалобы на игроков\n<color=#b7d092>/top</color> - Топ игроков сервера",
                        },
                        ["binds"] = new SettingsHelp
                        {
                            _Name = "Бинды",
                            _Title = "Бинды",
                            _Text = "<color=#b7d092>bind кнопка tp.menu</color> - Меню телепортации\n<color=#b7d092>bind кнопка chat.say /kit</color> - Меню китов\n<color=#b7d092>bind кнопка upgrade.use</color> - Автоапгрейд построек\n<color=#b7d092>bind кнопка remove.use</color> - Ремув построек\n<color=#b7d092>bind кнопка chat.say /map</color> - Открытие внутриигровой карты",
                        },
                    },
                    PluginVersion = new VersionNumber()
                };
            }
        }
        #endregion

        #region [ConsoleCommand]
        [ConsoleCommand("UI_HELP")]
        private void cmdBHelp(ConsoleSystem.Arg args)
        {
		    BasePlayer player = args.Player();
		    if (player == null) return;

            switch (args.Args[0])
            {
			    case "open.help":
			    {
				    var _config = config._SettingsHelp[args.Args[1]];
                    if (_config == null) return;

                    MenuButtons(player, args.Args[1]);
                    TextUI(player, _config);
				    break;
			    }
            }
        }
        #endregion

        #region [UI]
        private void MainUI(BasePlayer player)
        {
            var container = new CuiElementContainer();
            string FirtHelp = Buttons.FirstOrDefault().Key;
            var _config = config._SettingsHelp[FirtHelp];

            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Material = "assets/content/ui/uibackgroundblur.mat", Color = "0 0 0 0.77" },
            }, "Overlay", Layer);

            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Button = { Color = "0.36 0.33 0.28 0.3", Material = "assets/icons/greyout.mat", Close = Layer }
            }, Layer);

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-360 -230", OffsetMax = "362.5 250" },
                Image = { Color = "0.3773585 0.3755785 0.3755785 0.3407843", Material = "assets/icons/greyout.mat" }
            }, Layer, Layer + ".Menu");

            CuiHelper.DestroyUi(player, Layer);
            CuiHelper.AddUi(player, container);
            MenuButtons(player, FirtHelp);
            TextUI(player, _config);
        }

        private void MenuButtons(BasePlayer player, string Button = "")
        {
            var container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0.2 1" },
                Image = { Color = "0 0 0 0" }
            }, Layer + ".Menu", Layer + ".Menu" + ".Button");

            int y = 0;
            foreach (var key in Buttons)
            {
                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = $"0.1 {0.85 - y * 0.088}", AnchorMax = $"0.96 {0.92 - y * 0.088}" },
                    Button = { Color = "0 0 0 0.60", Command = $"UI_HELP open.help {key.Key}" },
                    Text = { Text = $"" }
                }, Layer + ".Menu" + ".Button", Layer + ".Menu" + $".Button{y}");

                container.Add(new CuiLabel
                {   
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Text = { Text = $"{key.Value}", Color = "1 1 1 0.85", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 16 }
                }, Layer + ".Menu" + $".Button{y}");

                if (Button == key.Key)
                {
                    container.Add(new CuiPanel
                    {
                        RectTransform = { AnchorMin = $"0 0", AnchorMax = $"0.99 0.03" },
                        Image = { Color = "0.00 0.84 0.47 1.00" }
                    }, Layer + ".Menu" + $".Button{y}");
                }

                y++;
            }

            CuiHelper.DestroyUi(player, Layer + ".Menu" + ".Button");
            CuiHelper.AddUi(player, container);
        }

        private void TextUI(BasePlayer player, SettingsHelp _config)
        {
            var container = new CuiElementContainer();

            container.Add(new CuiPanel
            {
                RectTransform = { AnchorMin = "0.2 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                Image = { Color = "0 0 0 0" }
            }, Layer + ".Menu", Layer + ".Menu" + ".Text");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.03 0.925", AnchorMax = "0.96 1", OffsetMax = "0 0" },
                Text = { Text = $"{_config._Title}", Color = "1 1 1 0.65", Align = TextAnchor.MiddleCenter, Font = "robotocondensed-bold.ttf", FontSize = 22 }
            }, Layer + ".Menu" + ".Text");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.045 0", AnchorMax = "0.96 0.928", OffsetMax = "0 0" },
                Text = { Text = $"{_config._Text}", Color = "1 1 1 0.8", Align = TextAnchor.UpperLeft, FontSize = 14, Font = "robotocondensed-regular.ttf" }
            }, Layer + ".Menu" + ".Text");

            CuiHelper.DestroyUi(player, Layer + ".Menu" + ".Text");
            CuiHelper.AddUi(player, container);
        }
        #endregion
    }
}

// --- End of file: BHelp.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/MindFreeze.cs ---
// --- Original Local Path: MindFreeze.cs ---

using System.Collections.Generic;
using System.Reflection;
using System;
using System.Linq;
using System.Data;
using UnityEngine;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Mind Freeze", "PaiN", "2.1.0", ResourceId = 1198)]
    [Description("Allows you to freeze players with a legit way.")]
    class MindFreeze : RustPlugin
    {
        private Timer _timer;

        private class FrozenPlayerInfo
        {
            public BasePlayer Player { get; set; }
            public Vector3 FrozenPosition { get; set; }

            public FrozenPlayerInfo(BasePlayer player)
            {
                Player = player;
                FrozenPosition = player.transform.position;
            }
        }

        List<FrozenPlayerInfo> frozenPlayers = new List<FrozenPlayerInfo>();

        void Loaded()
        {
            if (!permission.PermissionExists("canmindfreeze")) permission.RegisterPermission("canmindfreeze", this);
            //LoadDefaultConfig(); Maybe gonna add this later.
            _timer= timer.Every(1, OnTimer);
        }

        [ChatCommand("freeze")]
        void cmdFreeze(BasePlayer player, string cmd, string[] args)
        {
			var target = BasePlayer.Find(args[0]);
			string steamId = Convert.ToString(player.userID);
			if (args.Length == 1)
			{
				if (!permission.UserHasPermission(steamId, "canmindfreeze"))
				{
					SendReply(player, "No Permission!");
					return;
				}

				
				if (!target)
				{
					SendReply(player, "Player not found!");
					return;
				}				
				if (target == null) return;
				if (frozenPlayers.Any(t => t.Player == target)) return; 
				frozenPlayers.Add(new FrozenPlayerInfo(target));
				SendReply(target, "You have been frozen by " + player.displayName);
				SendReply(player, "You have frozen " + target.displayName);
			}
			else
				{
					SendReply(player, "Syntax: /freeze \"player\" ");
					return;
				}
		}
		
		

        [ChatCommand("unfreeze")]
        void cmdUnFreeze(BasePlayer player, string cmd, string[] args)
        {
			var target = BasePlayer.Find(args[0]);
			string steamId = Convert.ToString(player.userID);
			if (args.Length == 1)
			{
				if (!permission.UserHasPermission(steamId, "canmindfreeze"))
				{
				SendReply(player, "No Permission!");
				return;
				}
				
				
				if (!target)
				{
				SendReply(player, "Player not found!");
				return;
				}
				
				
				if (target == null) return; 
				frozenPlayers.RemoveAll(t => t.Player == target);
				SendReply(target, "You have been unfrozen by " + player.displayName);
				SendReply(player, "You have unfrozen " + target.displayName);
			}
				else
				{
					SendReply(player, "Syntax: /unfreeze \"player\" ");
					return;
				}	
		}

        [ChatCommand("unfreezeall")]
        void cmdUnFreezeAll(BasePlayer player, string cmd, string[] args)
        {
			string steamId = Convert.ToString(player.userID);
			if (permission.UserHasPermission(steamId, "canmindfreeze"))
			{
            frozenPlayers.Clear();
			}
			else
			{
				SendReply(player, "No Permission!");
			}
        }

        void OnTimer()
        {
            foreach (FrozenPlayerInfo current in frozenPlayers)
            {
                if (Vector3.Distance(current.Player.transform.position, current.FrozenPosition) < 1) continue;
                current.Player.ClientRPCPlayer(null, current.Player, "ForcePositionTo", new object[] { current.FrozenPosition });
                current.Player.TransformChanged();
            }
        }

        void Unloaded()
        {
            _timer.Destroy();
            frozenPlayers.Clear();
        }
    }
}

// --- End of file: MindFreeze.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/CraftingController.cs ---
// --- Original Local Path: CraftingController.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;


namespace Oxide.Plugins
{
    [Info("Crafting Controller", "Whispers88", "3.2.9")]
    [Description("Allows you to modify the time spend crafting and which items can be crafted")]

    //Credits to previous authors Nivex & Mughisi
    public class CraftingController : RustPlugin
    {
        #region Config
        private Configuration config;
        private static Dictionary<string, float> defaultsetup = new Dictionary<string, float>();
        public class CraftingData
        {
            public bool canCraft;
            public bool canResearch;
            public bool useCrafteRateMultiplier;
            public float craftTime;
            public int workbenchLevel;
            public ulong defaultskinid;

            public CraftingData()
            {
                canCraft = true;
                canResearch = true;
                useCrafteRateMultiplier = true;
                craftTime = 0;
                workbenchLevel = -1;
                defaultskinid = 0;
            }
        }

        public class Configuration
        {

            [JsonProperty("Default crafting rate percentage")]
            public float CraftingRate = 50;

            [JsonProperty("Save commands to config (save config changes via command to the configuration)")]
            public bool SaveCommands = true;

            [JsonProperty("Simple Mode (disables: instant bulk craft, skin options and full inventory checks for better performance)")]
            public bool SimpleMode = false;

            [JsonProperty("Allow crafting when inventory is full")]
            public bool FullInventory = false;

            [JsonProperty("Complete crafting on server shut down")]
            public bool CompleteCrafting = false;

            [JsonProperty("Craft items with random skins if not already skinned")]
            public bool RandomSkins = false;

            [JsonProperty("Show Crafting Notes")]
            public bool ShowCraftNotes = false;

            [JsonProperty("Crafting rate bonus mulitplier (apply oxide perms for additional mulitpliers")]
            public Dictionary<string, float> BonusMultiplier = new Dictionary<string, float>() { { "vip1", 90 }, { "vip2", 0 } };

            [JsonProperty("Advanced Crafting Options")]
            public Dictionary<string, CraftingData> CraftingOptions = new Dictionary<string, CraftingData>();

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    throw new JsonException();
                }
            }
            catch
            {
                Puts($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Puts($"Configuration changes saved to {Name}.json");
            Config.WriteObject(config, true);
        }

        #endregion Config

        #region Init
        private const string perminstantbulkcraft = "craftingcontroller.instantbulkcraft";
        private const string permblockitems = "craftingcontroller.blockitems";
        private const string permitemrate = "craftingcontroller.itemrate";
        private const string permcraftingrate = "craftingcontroller.craftingrate";
        private const string permsetbenchlvl = "craftingcontroller.setbenchlvl";
        private const string permsetskins = "craftingcontroller.setskins";

        private List<string> permissions = new List<string> { perminstantbulkcraft, permblockitems, permitemrate, permcraftingrate, permsetbenchlvl, permsetskins };
        private List<string> permissionsBonusMultiplier = new List<string>();
        private List<string> commands = new List<string> { nameof(CommandCraftingRate), nameof(CommandCraftTime), nameof(CommandBlockItem), nameof(CommandUnblockItem), nameof(CommandSetDefaultSkin), nameof(CommandWorkbenchLVL) };
        private void OnServerInitialized()
        {
            ItemManager.bpList.ForEach(bp => defaultsetup[bp.name] = bp.time);
            foreach (var key in config.BonusMultiplier.Keys)
            {
                permissionsBonusMultiplier.Add("craftingcontroller." + key);
            }
            //register permissions
            permissions.ForEach(perm => permission.RegisterPermission(perm, this));
            permissionsBonusMultiplier.ForEach(perm => permission.RegisterPermission(perm, this));
            //register commands
            commands.ForEach(command => AddLocalizedCommand(command));

            if (config.SimpleMode)
            {
                Unsubscribe("OnItemCraft");
                Unsubscribe("OnItemCraftFinished");
                Unsubscribe("OnItemCraftCancelled");
            }
            ItemManager.bpList.ForEach(item => {
                if (!config.CraftingOptions.ContainsKey(item.targetItem.shortname))
                    config.CraftingOptions.Add(item.targetItem.shortname, new CraftingData() { craftTime = item.time, workbenchLevel = item.workbenchLevelRequired });
            });


            SaveConfig();
            UpdateCraftingRate();
        }

        private void Unload()
        {
            ItemManager.bpList.ForEach(bp => { if (defaultsetup.ContainsKey(bp.name)) bp.time = defaultsetup[bp.name]; });
        }

        #endregion Init

        #region Localization
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoInvSpace"] = "You don't have enough room to craft this item!",
                ["NoPerms"] = "You don't have permission to use this command.",
                ["CannotFindItem"] = "Cannot find item {0}.",
                ["ItemBlocked"] = "{0} has been blocked from crafting.",
                ["ItemUnblocked"] = "{0} has been unblocked from crafting.",
                ["NeedsAdvancedOptions"] = "You need to enable advanced crafting options in your config to use this.",
                ["WrongNumberInput"] = "Your input needs to be a number.",
                ["ItemCraftTimeSet"] = "{0} craft time set to {1} seconds",
                ["WorkbenchLevelSet"] = "{0} workbench level set to {1}",
                ["CurrentCraftinRate"] = "The current crafting rate is {0 }%",
                ["CraftingRateUpdated"] = "The crafting rate was updated to {0} %",
                ["CraftTime2Args"] = "This command needs two arguments in the format /crafttime item.shortname timetocraft",
                ["BlockItem1Args"] = "This command needs one argument in the format /blockitem item.shortname",
                ["UnblockItem1Args"] = "This command needs one argument in the format /unblockitem item.shortname",
                ["WorckBenchLvl2Args"] = "This command needs two arguments in the format /benchlvl item.shortname workbenchlvl",
                ["BenchLevelInput"] = "The work bench level must be between 0 and 3",
                ["SetSkin2Args"] = "This command needs one argument in the format /setcraftskin item.shortname skinworkshopid",
                ["SkinSet"] = "The default skin for {0} was set to {1}",
                ["CraftTimeCheck"] = "The craft time of this item is {0}",
                //Commands
                ["CommandCraftingRate"] = "craftrate",
                ["CommandCraftTime"] = "crafttime",
                ["CommandBlockItem"] = "blockitem",
                ["CommandUnblockItem"] = "unblockitem",
                ["CommandWorkbenchLVL"] = "benchlvl",
                ["CommandSetDefaultSkin"] = "setcraftskin"

            }, this);
        }

        #endregion Localization

        #region Commands
        private void CommandCraftingRate(IPlayer iplayer, string command, string[] args)
        {
            if (!HasPerm(iplayer.Id, permitemrate))
            {
                Message(iplayer, "NoPerms");
                return;
            }
            int craftingrate;
            if (args.Length == 0)
            {
                Message(iplayer, "CurrentCraftinRate", config.CraftingRate);
                return;
            }
            if (!int.TryParse(args[0], out craftingrate))
            {
                Message(iplayer, "WrongNumberInput");
                return;
            }
            if (craftingrate < 0) craftingrate = 0;
            config.CraftingRate = craftingrate;
            UpdateCraftingRate();
            Message(iplayer, "CraftingRateUpdated", config.CraftingRate);
            if (config.SaveCommands) SaveConfig();

        }

        private void CommandCraftTime(IPlayer iplayer, string command, string[] args)
        {
            if (!HasPerm(iplayer.Id, permitemrate))
            {
                Message(iplayer, "NoPerms");
                return;
            }
            if (args.Length == 1)
            {
                var itemcheck = FindItem(args[0]);
                if (itemcheck)
                {
                    Message(iplayer, "CraftTimeCheck", itemcheck.Blueprint.time);
                    return;
                }
            }
            if (args.Length < 2)
            {
                Message(iplayer, "CraftTime2Args");
                return;
            }
            var setitem = FindItem(args[0]);
            if (!setitem)
            {
                Message(iplayer, "CannotFindItem", args[0]);
                return;
            }
            if (args[1].ToLower() == "default")
            {
                config.CraftingOptions[setitem.shortname].useCrafteRateMultiplier = true;
                config.CraftingOptions[setitem.shortname].craftTime = (defaultsetup[setitem.Blueprint.name] * (config.CraftingRate / 100));
                Message(iplayer, "ItemCraftTimeSet", setitem.shortname, (setitem.Blueprint.time).ToString());
                if (config.SaveCommands) SaveConfig();
                return;
            }
            int crafttime;
            if (!int.TryParse(args[1], out crafttime))
            {
                Message(iplayer, "WrongNumberInput");
                return;
            }
            config.CraftingOptions[setitem.shortname].craftTime = crafttime;
            config.CraftingOptions[setitem.shortname].useCrafteRateMultiplier = false;
            ItemBlueprint bp = ItemManager.itemDictionaryByName[setitem.shortname].Blueprint;
            bp.time = crafttime;
            Message(iplayer, "ItemCraftTimeSet", setitem.shortname, crafttime.ToString());
            if (config.SaveCommands) SaveConfig();
        }

        private void CommandBlockItem(IPlayer iplayer, string command, string[] args)
        {
            if (!HasPerm(iplayer.Id, permblockitems))
            {
                Message(iplayer, "NoPerms");
                return;
            }
            if (args.Length < 1)
            {
                Message(iplayer, "BlockItem1Args");
                return;
            }
            var blockitem = FindItem(args[0]);
            if (!blockitem)
            {
                Message(iplayer, "CannotFindItem", args[0]);
                return;
            }
            config.CraftingOptions[blockitem.shortname].canCraft = false;
            config.CraftingOptions[blockitem.shortname].canResearch = false;
            ItemBlueprint bp = ItemManager.itemDictionaryByName[blockitem.shortname].Blueprint;
            bp.userCraftable = false;
            bp.isResearchable = false;
            Message(iplayer, "ItemBlocked", blockitem.shortname);
            if (config.SaveCommands) SaveConfig();
        }

        private void CommandUnblockItem(IPlayer iplayer, string command, string[] args)
        {
            if (!HasPerm(iplayer.Id, permblockitems))
            {
                Message(iplayer, "NoPerms");
                return;
            }
            if (args.Length < 1)
            {
                Message(iplayer, "UnbockItem1Args");
                return;
            }
            var blockitem = FindItem(args[0]);
            if (!blockitem)
            {
                Message(iplayer, "CannotFindItem", args[0]);
                return;
            }
            config.CraftingOptions[blockitem.shortname].canCraft = true;
            config.CraftingOptions[blockitem.shortname].canResearch = true;
            ItemBlueprint bp = ItemManager.itemDictionaryByName[blockitem.shortname].Blueprint;
            bp.userCraftable = true;
            bp.isResearchable = true;
            Message(iplayer, "ItemUnblocked", blockitem.shortname);
            if (config.SaveCommands) SaveConfig();
        }
        private void CommandWorkbenchLVL(IPlayer iplayer, string command, string[] args)
        {
            if (!HasPerm(iplayer.Id, permsetbenchlvl))
            {
                Message(iplayer, "NoPerms");
                return;
            }
            if (args.Length < 2)
            {
                Message(iplayer, "WorckBenchLvl2Args");
                return;
            }
            var item = FindItem(args[0]);
            if (!item)
            {
                Message(iplayer, "CannotFindItem", args[0]);
                return;
            }
            int benchlvl;
            if (!int.TryParse(args[1], out benchlvl))
            {
                Message(iplayer, "WrongNumberInput");
                return;
            }
            if (benchlvl < 0 || benchlvl > 3)
            {
                Message(iplayer, "BenchLevelInput");
                return;
            }
            config.CraftingOptions[item.shortname].workbenchLevel = benchlvl;
            ItemBlueprint bp = ItemManager.itemDictionaryByName[item.shortname].Blueprint;
            bp.workbenchLevelRequired = benchlvl;
            Message(iplayer, "WorkbenchLevelSet", item.shortname, benchlvl.ToString());
            if (config.SaveCommands) SaveConfig();
        }
        private void CommandSetDefaultSkin(IPlayer iplayer, string command, string[] args)
        {
            if (!HasPerm(iplayer.Id, permsetskins))
            {
                Message(iplayer, "NoPerms");
                return;
            }
            if (args.Length < 2)
            {
                Message(iplayer, "SetSkin2Args");
                return;
            }
            var setitem = FindItem(args[0]);
            if (!setitem)
            {
                Message(iplayer, "CannotFindItem", args[0]);
                return;
            }
            ulong skinid;
            if (!ulong.TryParse(args[1], out skinid))
            {
                Message(iplayer, "WrongNumberInput", args);
                return;
            }
            config.CraftingOptions[setitem.shortname].defaultskinid = skinid;
            Message(iplayer, "SkinSet", setitem.shortname, skinid.ToString());
            if (config.SaveCommands) SaveConfig();
        }
        #endregion Commands

        #region Methods
        private void UpdateCraftingRate()
        {
            foreach (var bp in ItemManager.bpList)
            {
                CraftingData data;
                if (!config.CraftingOptions.TryGetValue(bp.targetItem.shortname, out data)) continue;
                bp.userCraftable = data.canCraft;
                bp.isResearchable = data.canResearch;
                if (config.CraftingRate == 0f)
                    bp.time = 0f;
                else if (!data.useCrafteRateMultiplier)
                    bp.time = data.craftTime;
                else
                    bp.time *= (float)(config.CraftingRate / 100);

                if (bp.workbenchLevelRequired > 4) data.workbenchLevel = 3;
                if (bp.workbenchLevelRequired > 0)
                    bp.workbenchLevelRequired = data.workbenchLevel;
            }
        }

        private void InstantBulkCraft(BasePlayer player, ItemCraftTask task, ItemDefinition item, List<int> stacks, int craftSkin, ulong skin)
        {
            if (skin == 0uL)
            {
                skin = ItemDefinition.FindSkin(item.itemid, craftSkin);
            }
            foreach (var stack in stacks)
            {
                var itemtogive = ItemManager.Create(item, stack, craftSkin != 0 && skin == 0uL ? (ulong)craftSkin : skin);
                var held = itemtogive.GetHeldEntity();
                if (held != null)
                {
                    held.skinID = skin == 0uL ? (ulong)craftSkin : skin;
                    held.SendNetworkUpdate();
                }
                player.GiveItem(itemtogive);
                if (config.ShowCraftNotes) player.Command(string.Concat(new object[] { "note.inv ", item.itemid, " ", stack }), new object[0]);
                Interface.CallHook("OnItemCraftFinished", task, itemtogive, player.inventory.crafting);
            }
        }

        private static void CompleteCrafting(BasePlayer player)
        {
            if (player.inventory.crafting.queue.Count == 0) return;
            player.inventory.crafting.FinishCrafting(player.inventory.crafting.queue.First.Value);
            player.inventory.crafting.queue.RemoveFirst();
        }
        private static void CancelAllCrafting(BasePlayer player)
        {
            ItemCrafter crafter = player.inventory.crafting;
            crafter.CancelAll(true);
        }

        #endregion Methods

        #region Hooks
        private Dictionary<ItemCraftTask, ulong> skinupdate = new Dictionary<ItemCraftTask, ulong>();
        private object OnItemCraft(ItemCraftTask task, BasePlayer player)
        {
            var target = task.blueprint.targetItem;
            if (task.instanceData?.dataInt != null) return null;
            var stacks = GetStacks(target, task.amount * task.blueprint.amountToCreate);
            ulong defaultskin = 0uL;
            int freeslots = FreeSlots(player);
            bool f = false;
            if (!config.FullInventory && stacks.Count >= freeslots)
            {
                f = true;
                int space = FreeSpace(player, target);
                if (space < 1)
                {
                    ReturnCraft(task, player);
                    return false;
                }
                int taskamt = task.amount * task.blueprint.amountToCreate;
                for (int i = 0; i < 20 && taskamt > space; i++)
                {
                    var oldtaskamt = taskamt;
                    taskamt = space;
                    foreach (var item in task.takenItems)
                    {
                        var itemtogive = item;
                        double fraction = (double)taskamt / (double)oldtaskamt;
                        int amttogive = (int)(item.amount * (1 - fraction));
                        if (amttogive <= 1)
                        {
                            ReturnCraft(task, player);
                            return false;
                        }
                        itemtogive = ItemManager.Create(item.info, amttogive, 0uL);
                        item.amount -= amttogive;

                        player.GiveItem(itemtogive);
                    }
                    space -= (freeslots - FreeSlots(player)) * target.stackable;
                    if (space < 1 || taskamt < 1)
                    {
                        ReturnCraft(task, player);
                        return false;
                    }
                    if (taskamt <= space) break;

                }
                task.amount = (int)(taskamt / task.blueprint.amountToCreate);
            }


            if (task.skinID == 0)
            {
                CraftingData data;
                if (config.CraftingOptions.TryGetValue(target.shortname, out data))
                {
                    defaultskin = data.defaultskinid;
                }

                if (config.RandomSkins && defaultskin == 0)
                {
                    List<ulong> skins = GetSkins(ItemManager.FindItemDefinition(target.itemid));
                    defaultskin = skins.GetRandom();
                }

                if (defaultskin > 999999)
                    skinupdate[task] = defaultskin;
                else
                    task.skinID = (int)defaultskin;
            }

            float bonusperm_time = 100;
            foreach (var bonusperm in permissionsBonusMultiplier)
            {
                if (!HasPerm(player.UserIDString, bonusperm)) continue;
                if (bonusperm_time > (float)config.BonusMultiplier[bonusperm.Split('.')[1]]) continue;
                bonusperm_time = (float)config.BonusMultiplier[bonusperm.Split('.')[1]];
                task.blueprint = UnityEngine.Object.Instantiate(task.blueprint);
                task.blueprint.time *= bonusperm_time / 100;
                break;
            }

            if (task.blueprint.time == 0f || HasPerm(player.UserIDString, perminstantbulkcraft))
            {
                skinupdate.Remove(task);
                if (f)
                    stacks = GetStacks(target, task.amount * task.blueprint.amountToCreate);
                InstantBulkCraft(player, task, target, stacks, task.skinID, defaultskin);
                task.cancelled = true;
                return false;
            }
            return null;
        }

        private void OnItemCraftFinished(ItemCraftTask task, Item item)
        {
            ulong skinid;
            if (!skinupdate.TryGetValue(task, out skinid)) return;

            item.skin = skinid;
            var held = item.GetHeldEntity();

            if (held != null)
            {
                held.skinID = skinid;
                held.SendNetworkUpdate();
            }
            if (task.amount == 0)
                skinupdate.Remove(task);
        }

        void OnItemCraftCancelled(ItemCraftTask task)
        {
            ulong skinid;
            if (!skinupdate.TryGetValue(task, out skinid)) return;
            skinupdate.Remove(task);
        }

        private void OnServerQuit()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (player.inventory.crafting.queue.Count == 0) continue;
                if (config.CompleteCrafting)
                    CompleteCrafting(player);
                CancelAllCrafting(player);
            }
        }

        #endregion Hooks

        #region Helpers
        private void ReturnCraft(ItemCraftTask task, BasePlayer crafter)
        {
            task.cancelled = true;
            Message(crafter.IPlayer, "NoInvSpace");
            foreach (var item in task.takenItems)
            {
                if (item.amount > 0)
                    crafter.GiveItem(item);
            }
        }

        private ItemDefinition FindItem(string itemNameOrId)
        {
            ItemDefinition itemDef = ItemManager.FindItemDefinition(itemNameOrId.ToLower());
            if (itemDef == null)
            {
                int itemId;
                if (int.TryParse(itemNameOrId, out itemId))
                {
                    itemDef = ItemManager.FindItemDefinition(itemId);
                }
            }
            return itemDef;
        }
        private int FreeSpace(BasePlayer player, ItemDefinition item)
        {
            var slots = player.inventory.containerMain.capacity + player.inventory.containerBelt.capacity;
            List<Item> containeritems = new List<Item>();
            Dictionary<ItemDefinition, int> queueamts = new Dictionary<ItemDefinition, int>();
            containeritems.AddRange(player.inventory.containerMain.itemList);
            containeritems.AddRange(player.inventory.containerBelt.itemList);

            int value = 0;
            //Sum all items in crafting queue not including the item to be crafted
            foreach (var queueitem in player.inventory.crafting.queue)
            {
                if (queueitem.blueprint.targetItem == item) continue;
                if (queueamts.TryGetValue(queueitem.blueprint.targetItem, out value))
                {
                    queueamts[queueitem.blueprint.targetItem] += queueitem.amount * queueitem.blueprint.amountToCreate;
                    continue;
                }
                queueamts[queueitem.blueprint.targetItem] = (queueitem.amount * queueitem.blueprint.amountToCreate);
            }
            //Take into account room of other stacks
            int queuestacks = 0;
            foreach (var i in queueamts)
            {
                queuestacks += GetStacks(i.Key, i.Value - Stackroom(containeritems, i.Key.shortname)).Count;
            }

            //calculate total room in inventory for the item required
            int invstackroom = (slots - containeritems.Count - queuestacks) * item.stackable;
            containeritems.ForEach(x => { if (x.info == item && x.amount < x.MaxStackable()) invstackroom += x.MaxStackable() - x.amount; });
            foreach (var x in player.inventory.crafting.queue)
            {
                if (x.blueprint.targetItem.shortname == item.shortname)
                {
                    invstackroom -= x.amount * x.blueprint.amountToCreate;
                }
            }
            return invstackroom;
        }
        private int FreeSlots(BasePlayer player)
        {
            var slots = player.inventory.containerMain.capacity + player.inventory.containerBelt.capacity;
            var taken = player.inventory.containerMain.itemList.Count + player.inventory.containerBelt.itemList.Count;
            return slots - taken;
        }

        private int Stackroom(List<Item> items, string item)
        {
            int stackroom = 0;
            items.ForEach(x => { if (x.info.shortname == item && x.amount < x.MaxStackable()) stackroom += x.MaxStackable() - x.amount; });
            return stackroom;
        }

        private List<int> GetStacks(ItemDefinition item, int amount)
        {
            List<int> list = new List<int>();
            int maxStack = item.stackable;
            int maxstacks = amount / maxStack;
            if (maxStack == 0) return list;
            for (int i = 0; i <= maxstacks; i++)
            {
                if (maxStack > amount)
                {
                    if (amount >= 1)
                        list.Add(amount);
                    return list;
                }
                list.Add(maxStack);
                amount -= maxStack;
            }
            return list;
        }
        private readonly Dictionary<string, List<ulong>> skinsCache = new Dictionary<string, List<ulong>>();
        private List<ulong> GetSkins(ItemDefinition def)
        {
            List<ulong> skins;
            if (skinsCache.TryGetValue(def.shortname, out skins)) return skins;
            skins = new List<ulong>();
            foreach (var skin in ItemSkinDirectory.ForItem(def))
            {
                skins.Add((ulong)skin.id);
            }
            foreach (var skin in Rust.Workshop.Approved.All.Values)
            {
                if (skin.Skinnable.ItemName == def.shortname)
                    skins.Add(skin.WorkshopdId);
            }
            skinsCache.Add(def.shortname, skins);
            return skins;
        }

        private string GetLang(string langKey, string playerId = null, params object[] args)
        {
            return string.Format(lang.GetMessage(langKey, this, playerId), args);
        }
        private void Message(IPlayer player, string langKey, params object[] args)
        {
            if (player.IsConnected) player.Message(GetLang(langKey, player.Id, args));
        }

        private bool HasPerm(string id, string perm) => permission.UserHasPermission(id, perm);

        private void AddLocalizedCommand(string command)
        {
            foreach (string language in lang.GetLanguages(this))
            {
                Dictionary<string, string> messages = lang.GetMessages(language, this);
                foreach (KeyValuePair<string, string> message in messages)
                {
                    if (!message.Key.Equals(command)) continue;

                    if (string.IsNullOrEmpty(message.Value)) continue;

                    AddCovalenceCommand(message.Value, command);
                }
            }
        }
        #endregion Helpers
    }
}

// --- End of file: CraftingController.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/CombatBlock.cs ---
// --- Original Local Path: CombatBlock.cs ---

using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Rust;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("CombatBlock", "King", "1.0.0")]
    public class CombatBlock : RustPlugin
    {
        #region [Vars]

        private const string Layer = "CombatBlock.Layer";
        private static CombatBlock plugin;
        private readonly Dictionary<BasePlayer, CombatManager> _components = new Dictionary<BasePlayer, CombatManager>();

        #endregion

        #region Configuration


        private PluginConfig config;

        protected override void LoadDefaultConfig()
        {
            config = PluginConfig.DefaultConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();

            if (config.PluginVersion < Version)
                UpdateConfigValues();

            Config.WriteObject(config, true);
        }

        private void UpdateConfigValues()
        {
            PluginConfig baseConfig = PluginConfig.DefaultConfig();
            if (config.PluginVersion < new VersionNumber(1, 0, 0))
            {
                PrintWarning("Config update detected! Updating config values...");
                PrintWarning("Config update completed!");
            }

            config.PluginVersion = Version;
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }
            
        private class PluginConfig
        {
            [JsonProperty("Настройки плагина")]
            public Settings _Settings;

            [JsonProperty("Версия конфигурации")] 
            public VersionNumber PluginVersion = new VersionNumber();

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig()
                 {
                    _Settings = new Settings()
                    {
                        timeCombatBlock = 15f,
                        BlackListCommands = new List<string>()
                        {
                            "/bp",
                            "/info",
                            "/outpost"
                        },
                        blockFirePlayer = true,
                        blockHitPlayer = true,
                    },
                    PluginVersion = new VersionNumber(),
                };
            }
        }

        public class Settings
        {
            [JsonProperty("Длительность комбат-блока")]
            public float timeCombatBlock;

            [JsonProperty("Черный список команд какие запрещены при комбат блоке")]
            public List<string> BlackListCommands;

            [JsonProperty("Блокировать при попадании по игроку ?")]
            public bool blockFirePlayer;

            [JsonProperty("Блокировать при получении урона от игрока ?")]
            public bool blockHitPlayer;
        }

        #endregion

        #region [Oxide]

        private void Init()
		{
			plugin = this;
        }

		private void Unload()
		{
			foreach (var player in BasePlayer.activePlayerList)
			{
				CuiHelper.DestroyUi(player, Layer);
            }

			Array.ForEach(_components.Values.ToArray(), combat =>
			{
				if (combat != null)
					combat.Kill();
			});

            plugin = null;
        }

        #endregion

        #region [Rust-Api]

        private void OnPlayerAttack(BasePlayer attacker, HitInfo info)
        {
            if (info == null || info.HitEntity == null || IsNPC(attacker)) return;
            if (info.HitEntity is BasePlayer)
            {
                BasePlayer target = info.HitEntity.ToPlayer();
                if (target == null || IsNPC(target)) return;
                if (config._Settings.blockFirePlayer)
                {
                    StartingCombatBlock(attacker);
                }
                if (config._Settings.blockHitPlayer)
                {
                    StartingCombatBlock(target);
                }
            }
        }

        private object OnUserCommand(IPlayer ipl, string command, string[] args)
        {
            if (ipl == null || !ipl.IsConnected) return null;
            var player = ipl.Object as BasePlayer;
            command = command.Insert(0, "/");
            if (player == null || !IsCombatBlocked(player)) return null;
            if (config._Settings.BlackListCommands.Contains(command.ToLower()))
            {
                player.ChatMessage("Вы не можете использовать команду во время комбат блока!");
                return false;
            }
            return null;
        }

        #endregion

        #region [Component]

        private class CombatManager : FacepunchBehaviour
        {
            #region [Vars]

            private BasePlayer _player;

            private float _startTime;

            private bool _started = true;

            private float _cooldown;

            #endregion

            #region [Init]

			private void Awake()
			{
				_player = GetComponent<BasePlayer>();

				plugin._components[_player] = this;

				enabled = false;
			}

			public void Init()
			{
				_startTime = Time.time;

				_cooldown = plugin.config._Settings.timeCombatBlock;

				MainUi();

				enabled = true;

				_started = true;
			}

            #endregion

            #region [Ui]

            public void MainUi()
            {
                var container = new CuiElementContainer();

                container.Add(new CuiPanel
                {
                    Image = { Color = "0 0 0 0" },
                    RectTransform = { AnchorMin = "1 0.5", AnchorMax = "1 0.5", OffsetMin = "-39.256 117.37", OffsetMax = "-0.004 145.839" }
                }, "Hud", Layer);

                container.Add(new CuiPanel
                {
                    Image = { Color = "0.2745098 0.1921569 0.1921569 1" },
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-126.027 -14.234", OffsetMax = "19.623 14.234" }
                }, Layer, Layer + ".Main");

				CuiHelper.DestroyUi(_player, Layer);
				CuiHelper.AddUi(_player, container);
            }

            private void UpdateUi()
            {
                var container = new CuiElementContainer();

                container.Add(new CuiPanel
                {
                    Image = { Color = "0.2745098 0.1921569 0.1921569 0" },
                    RectTransform ={ AnchorMin = "0 0", AnchorMax = "1 1" }
                }, Layer + ".Main", Layer + ".Main" + ".Update");

                container.Add(new CuiElement
                {
                    Parent = Layer + ".Main" + ".Update",
                    Components = 
                    {
                        new CuiTextComponent { Text = $"Комбат блок:  <color=#EEBF00FF>{GetLeftTime()} сек.</color>", Font = "robotocondensed-bold.ttf", FontSize = 14, Align = TextAnchor.UpperLeft, Color = "1 1 1 1" },
                        new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-66.203 -12.617", OffsetMax = "72.827 7.1" }
                    }
                });

                container.Add(new CuiPanel
                {
                    Image = { Color = "0.9294118 0.7490196 0 1" },
                    RectTransform ={ AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-72.7 -21.609", OffsetMax = "72.7 -14.535" }
                },Layer + ".Main" + ".Update", Layer + ".Main" + ".Update" + ".LinePanel");

                var progress = (_startTime + _cooldown - Time.time) / _cooldown;
                if (progress > 0)
                {
					container.Add(new CuiPanel
					{
						RectTransform =
						{
							AnchorMin = $"{progress} 0", AnchorMax = $"1 0.84",
						},
						Image =
						{
                            Color = "0.3960785 0.3960785 0.3764706 1"
						}
					}, Layer + ".Main" + ".Update" + ".LinePanel");
                }

				CuiHelper.DestroyUi(_player, Layer + ".Main" + ".Update");
				CuiHelper.AddUi(_player, container);
            }

            #endregion

            #region [Update]

			private void FixedUpdate()
			{
				if (!_started) return;

				var timeLeft = Time.time - _startTime;
				if (timeLeft > _cooldown)
				{
					Kill();
					return;
				}

				UpdateUi();
			}

            #endregion

            #region [Func]

			private int GetLeftTime()
			{
				return Mathf.RoundToInt(_startTime + _cooldown - Time.time);
			}

            #endregion

            #region [Destroy]

            public void DestroyComp() => OnDestroy();
			private void OnDestroy()
			{
				CancelInvoke();

				CuiHelper.DestroyUi(_player, Layer);

				plugin?._components.Remove(_player);

				Destroy(this);
			}

			public void Kill()
			{
				enabled = false;

				_started = false;

				DestroyImmediate(this);
			}

            #endregion
        }

        #endregion

        #region [Func]

        private static bool IsNPC(BasePlayer player)
        {
            if (player is NPCPlayer) return true;
            if (!(player.userID >= 76560000000000000L || player.userID <= 0L)) return true;
            return false;
        }

		private CombatManager AddOrGetBuild(BasePlayer player)
		{
			CombatManager combat;
			if (_components.TryGetValue(player, out combat))
				return combat;

			combat = player.gameObject.AddComponent<CombatManager>();
			return combat;
		}

		private CombatManager IsCombatBlocked(BasePlayer player)
		{
			CombatManager combat;
			return _components.TryGetValue(player, out combat) ? combat : null;
		}

        private void StartingCombatBlock(BasePlayer player)
        {
            Global.Runner.StartCoroutine(StartUpdate(player));

            AddOrGetBuild(player).Init();
        }

        private IEnumerator StartUpdate(BasePlayer player)
        {
            yield return CoroutineEx.waitForFixedUpdate;
        }

        #endregion
    }
}

// --- End of file: CombatBlock.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/PurifierConfig.cs ---
// --- Original Local Path: PurifierConfig.cs ---

using System;
using System.Collections.Generic;
using System.Reflection;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Purifier Config", "Shady", "1.0.3", ResourceId = 1911)]
    [Description("Tweak settings for water purifiers.")]
    class PurifierConfig : RustPlugin
    {
        bool configWasChanged = false;
        FieldInfo warmUpTime = typeof(WaterPurifier).GetField("warmupTime", (BindingFlags.Instance | BindingFlags.NonPublic));
        bool init = false;
        #region Config
        int WPM => GetConfig("WaterToProcessPerMinute", 120);
        int WaterRatio => GetConfig("FreshWaterRatio", 4);
        float Warmup => GetConfig("WarmupTime", 10f);

        /*--------------------------------------------------------------//
		//			Load up the default config on first use				//
		//--------------------------------------------------------------*/
        protected override void LoadDefaultConfig()
        {
           // Config.Clear();
            Config["WaterToProcessPerMinute"] = WPM;
            Config["FreshWaterRatio"] = WaterRatio;
            Config["WarmupTime"] = Warmup;
            SaveConfig();
        }
        #endregion
        #region Hooks
        void OnServerInitialized()
        {
            var purifiers = GameObject.FindObjectsOfType<WaterPurifier>();
            for(int i = 0; i < purifiers.Length; i++)
            {
                var pure = purifiers[i];
                ConfigurePurifier(pure);
            }
            Puts("Configured " + purifiers.Length + " water purifiers successfully!");
            init = true;
        }

        void Init() => LoadDefaultConfig();

        void OnEntitySpawned(BaseNetworkable entity)
        {
            if (entity == null || !init) return;
            var purifier = entity?.GetComponent<WaterPurifier>() ?? null;
            if (purifier == null) return;
            ConfigurePurifier(purifier);
        }
        #endregion
        #region ConfigurePurifiers
        void ConfigurePurifier(WaterPurifier purifier)
        {
            if (WPM != 120f) purifier.waterToProcessPerMinute = WPM;
            if (WaterRatio != 4) purifier.freshWaterRatio = WaterRatio;
            if (Warmup != 10f) warmUpTime.SetValue(purifier, Warmup);
            purifier.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
        }
        #endregion
        #region Util
        T GetConfig<T>(string name, T defaultValue)
        {
            if (Config[name] == null) return defaultValue;
            return (T)Convert.ChangeType(Config[name], typeof(T));
        }
        #endregion
    }
}

// --- End of file: PurifierConfig.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BetterSay.cs ---
// --- Original Local Path: BetterSay.cs ---

using System.Text.RegularExpressions;
using System.Collections.Generic;
using System.Linq;
using System;

namespace Oxide.Plugins
{
    [Info("Better Say", "LaserHydra", "2.0.2", ResourceId = 998)]
    [Description("Customize the say console command output as you want")]
    class BetterSay : RustPlugin
    {
		void Loaded()
		{
            permission.RegisterPermission("bettersay.use", this);
			LoadConfig();
		}
		
		void LoadConfig()
		{
			SetConfig("Settings", "Formatting", "{Title}: {Message}");
			SetConfig("Settings", "Title", "Server");
			SetConfig("Settings", "Title Color", "cyan");
			SetConfig("Settings", "Message Color", "white");
		}
		
		void LoadDefaultConfig()
		{
			Puts("Generating new config file...");
			LoadConfig();
		}
		
		string RemoveFormatting(string old)
		{
			string _new = old;
			
			var matches = new Regex(@"(<color=.+?>)", RegexOptions.IgnoreCase).Matches(_new);
			foreach(Match match in matches)
			{
				if(match.Success) _new = _new.Replace(match.Groups[1].ToString(), "");
			}
			
			_new = _new.Replace("</color>", "");
			
			return _new;
		}
		
		object OnServerCommand(ConsoleSystem.Arg arg)
		{
			if(arg?.cmd?.namefull != null && arg?.cmd?.namefull == "global.say")
			{
				if(arg.connection != null && arg.connection.player != null)
				{
					BasePlayer player = arg.connection.player as BasePlayer;

					if (!permission.UserHasPermission(player.UserIDString, "bettersay.use"))
						return true;
				}
			
                string[] args = new string[0];
				string output = Config["Settings", "Formatting"] as string;

                if (arg.HasArgs()) args = arg.Args;
                string message = ListToString(args.ToList(), 0, " ");
				
				output = output.Replace("{Title}", $"<color={Config["Settings", "Title Color"].ToString()}>{Config["Settings", "Title"].ToString()}</color>").Replace("{Message}", $"<color={Config["Settings", "Message Color"].ToString()}>{message}</color>");
				BroadcastChat(output);
				Puts(RemoveFormatting(output));
				return true;
			}
			else return null;
		}

        ////////////////////////////////////////
        ///     Player Finding
        ////////////////////////////////////////

        BasePlayer GetPlayer(string searchedPlayer, BasePlayer executer, string prefix)
        {
            List<string> foundPlayers =
                (from player in BasePlayer.activePlayerList
                 where player.displayName.ToLower().Contains(searchedPlayer.ToLower())
                 select player.displayName).ToList();

            switch (foundPlayers.Count)
            {
                case 0:
                    SendChatMessage(executer, prefix, "The Player can not be found.");
                    break;

                case 1:
                    return BasePlayer.Find(foundPlayers[0]);

                default:
                    string players = ListToString(foundPlayers, 0, ", ");
                    SendChatMessage(executer, prefix, "Multiple matching players found: \n" + players);
                    break;
            }

            return null;
        }

        ////////////////////////////////////////
        ///     Converting
        ////////////////////////////////////////

        string ListToString(List<string> list, int first, string seperator)
        {
            return String.Join(seperator, list.Skip(first).ToArray());
        }

        ////////////////////////////////////////
        ///     Config Setup
        ////////////////////////////////////////

        void SetConfig(params object[] args)
        {
            List<string> stringArgs = (from arg in args select arg.ToString()).ToList<string>();
            stringArgs.RemoveAt(args.Length - 1);

            if (Config.Get(stringArgs.ToArray()) == null) Config.Set(args);
        }

        ////////////////////////////////////////
        ///     Chat Handling
        ////////////////////////////////////////

        void BroadcastChat(string prefix, string msg = null) => PrintToChat(msg == null ? prefix : "<color=#00FF8D>" + prefix + "</color>: " + msg);

        void SendChatMessage(BasePlayer player, string prefix, string msg = null) => SendReply(player, msg == null ? prefix : "<color=#00FF8D>" + prefix + "</color>: " + msg);
    }
}


// --- End of file: BetterSay.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/ExplosionTracker.cs ---
// --- Original Local Path: ExplosionTracker.cs ---

using System.Collections.Generic;
using System.Reflection;
using System;
using System.Data;
using UnityEngine;
using Oxide.Core;
using System.Linq;
using Rust;

namespace Oxide.Plugins
{
    [Info("Explosion Tracker", "PaiN", 0.7, ResourceId = 1282)]
    [Description("This plugin tracks every explosion that happens in the server.")]
    class ExplosionTracker : RustPlugin
    {
		private bool Changed;
		private bool logtofile;
		private bool logtorcon;
		
		void Loaded()
        {
            LoadVariables();
        }

        object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }

        void LoadVariables()
        {

            logtofile = Convert.ToBoolean(GetConfig("Settings", "LogToFile", true));
            logtorcon = Convert.ToBoolean(GetConfig("Settings", "LogToRcon", true));

            if (Changed)
            {
                SaveConfig();
                Changed = false;

            }

        }

        protected override void LoadDefaultConfig()
        {
            Puts("Creating a new configuration file!");
            Config.Clear();
            LoadVariables();
        } 
		
		void OnExplosiveThrown(BasePlayer player, BaseEntity entity)
        {
            NextTick(() => {
                if (logtorcon == true)
                {
                    Puts("**" + player.displayName + "**" + "(" + player.userID.ToString() + ")" + " threw " + entity.name.ToString() +
                    " at position " +
                    "( X: " + Convert.ToInt32(entity.GetEstimatedWorldPosition().x).ToString() +
                    " Y: " + Convert.ToInt32(entity.GetEstimatedWorldPosition().y).ToString() +
                    " Z: " + Convert.ToInt32(entity.GetEstimatedWorldPosition().z).ToString() + " )");
                }
                if (logtofile == true)
                {
                    ConVar.Server.Log("Oxide/Logs/ExplosionTrackerLog.txt", "**" + player.displayName + "**" + "(" + player.userID.ToString() + ")" + " threw " + entity.name.ToString() +
                    " at position " +
                    "( X: " + Convert.ToInt32(entity.GetEstimatedWorldPosition().x).ToString() +
                    " Y: " + Convert.ToInt32(entity.GetEstimatedWorldPosition().y).ToString() +
                    " Z: " + Convert.ToInt32(entity.GetEstimatedWorldPosition().z).ToString() + " )");
                }
            });
        }
			
			void OnRocketLaunched(BasePlayer player, BaseEntity entity)
			{
				NextTick(() => {
				if(logtorcon == true)
				{
					Puts("**"+player.displayName+"**" +"(" + player.userID.ToString() + ")" + " launched a rocket at " +
					"( X: " + Convert.ToInt32(entity.GetEstimatedWorldPosition().x).ToString() + 
					" Y: " + Convert.ToInt32(entity.GetEstimatedWorldPosition().y).ToString() + 
					" Z: " + Convert.ToInt32(entity.GetEstimatedWorldPosition().z).ToString() + " )");
				}
				if(logtofile == true) 
				{
					ConVar.Server.Log("Oxide/Logs/ExplosionTrackerLog.txt", "**"+player.displayName+"**" +"(" + player.userID.ToString() + ")" + " launched a rocket at " +
					"( X: " + Convert.ToInt32(entity.GetEstimatedWorldPosition().x).ToString() + 
					" Y: " + Convert.ToInt32(entity.GetEstimatedWorldPosition().y).ToString() + 
					" Z: " + Convert.ToInt32(entity.GetEstimatedWorldPosition().z).ToString() + " )");
				}
				});
			}
	}
}


// --- End of file: ExplosionTracker.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BlueprintShare.cs ---
// --- Original Local Path: BlueprintShare.cs ---

using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using Network;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Rust;
using UnityEngine;
using VLB;

namespace Oxide.Plugins
{
    // Creation date: 11-01-2021
    // Last update date: 16-01-2021
    [Info("Blueprint Share", "Sempai#3239", "1.0.0")]
    [Description("https://rustworkshop.space/resources/blueprint-share.245/")]
    public class BlueprintShare : RustPlugin
    {
        #region Oxide Hooks

        private void Init()
        {
            if (config.shareTechTree == false)
            {
                Unsubscribe(nameof(OnTechTreeNodeUnlocked));
            }

            if (config.shareBlueprints == false)
            {
                Unsubscribe(nameof(OnPlayerStudyBlueprint));
            }
            
            Message.ChangeSenderID(config.senderId);
        }

        private void OnTechTreeNodeUnlocked(Workbench workbench, TechTreeData.NodeInstance node, BasePlayer player)
        {
            OnLearned(player, node.itemDef);
        }

        private void OnPlayerStudyBlueprint(BasePlayer player, Item item)
        {
            OnLearned(player, item.blueprintTargetDef);
        }

        #endregion

        #region Core
        
        private void OnLearned(BasePlayer player, ItemDefinition definition)
        {
            var listFriendsId = GetAllMates(player);
            if (listFriendsId.Count < 1)
            {
                return;
            }
            
            if (config.blockedShortnames.Contains(definition.shortname) == true)
            {
                Message.Send(player, Message.Key.CantBeShared, "{name}", definition.displayName.english);
                return;
            }

            foreach (var playerId in listFriendsId)
            {
                Unlock(playerId, definition, player.displayName);
            }
            
            Message.Send(player, Message.Key.LearnedNew, "{name}", definition.displayName.english, "{count}", listFriendsId.Count);
        }

        private void Unlock(ulong idLong, ItemDefinition targetItem, string referrer)
        {
            var playerInfo = SingletonComponent<ServerMgr>.Instance.persistance.GetPlayerInfo(idLong);
            if (playerInfo.unlockedItems.Contains(targetItem.itemid) == true)
            {
                return;
            }
            
            playerInfo.unlockedItems.Add(targetItem.itemid);
            SingletonComponent<ServerMgr>.Instance.persistance.SetPlayerInfo(idLong, playerInfo);

            var player = BasePlayer.FindByID(idLong);
            if (player != null)
            {
                player.SendNetworkUpdateImmediate();
                player.ClientRPCPlayer(null, player, "UnlockedBlueprint", targetItem.itemid);
                Message.Send(player, Message.Key.WasShared, "{player}", referrer, "{name}", targetItem.displayName.english);
            }
        }

        private List<ulong> GetAllMates(BasePlayer player)
        {
            var idString = player.UserIDString;
            var list = new List<ulong>();

            if (config.shareFriends == true)
            {
                var friends = GetFriends(idString);
                foreach (var friend in friends)
                {
                    list.Add(Convert.ToUInt64(friend));
                }
            }

            if (config.shareClan == true)
            {
                var clan = GetPlayerClan(idString);
                if (string.IsNullOrEmpty(clan) == false)
                {
                    var members = GetClanPlayers(clan);
                    foreach (var member in members)
                    {
                        list.Add(Convert.ToUInt64(member));
                    }
                }
            }

            if (config.shareTeam == true)
            {
                var team = player.Team;
                if (team != null)
                {
                    foreach (var member in team.members)
                    {
                        list.Add(member);
                    }
                }
            }

            list.RemoveAll(x => x == player.userID);
            return list.Distinct().ToList();
        }

        #endregion
        
        #region Classes

        private static ConfigDefinition config = new ConfigDefinition();

        private class ConfigDefinition
        {
            [JsonProperty("Blocked shortnames")]
            public string[] blockedShortnames =
            {};
            
            [JsonProperty("Share with Team")]
            public bool shareTeam = true;

            [JsonProperty("Share with Clan")]
            public bool shareClan = true;

            [JsonProperty("Share with Friends")]
            public bool shareFriends = false;

            [JsonProperty("Share physical blueprints research")]
            public bool shareBlueprints = true;
            
            [JsonProperty("Share tech tree research")]
            public bool shareTechTree = true;

            [JsonProperty("Sender ID")]
            public ulong senderId = 0;
        }
        
        private partial class Message
        {
            private static Dictionary<Key, object> messages = new Dictionary<Key, object>
            {
                {Key.CantBeShared, "<color=#ffff00>{name}</color> isimli eşya arkadaşların ile paylaştırılamaz."},
                {Key.LearnedNew, "<color=#ffff00>{name}</color> isimli eşyayı öğrendin ve bu blueprint <color=#ffff00>{count}</color> arkadaşın ile daha paylaşıldı!"},
                {Key.WasShared, "<color=#ffff00>{player}</color> isimli arkadaşın <color=#ffff00>{name}</color> eşyasının blueprintini öğrendi ve bu sana da paylaştırıldı."},
            };
            
            public enum Key
            { 
                LearnedNew,
                WasShared,
                CantBeShared,
            }
        }

        #endregion
        
        #region Configuration v2.1

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigDefinition>();
                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                for (var i = 0; i < 3; i++)
                {
                    PrintError("Configuration file is corrupt! Check your config file at https://jsonlint.com/");
                }

                LoadDefaultConfig();
                return;
            }

            ValidateConfig();
            SaveConfig();
        }

        private void ValidateConfig()
        {
            if (Interface.Oxide.CallHook("OnConfigValidate") != null)
            {
                PrintWarning("Using default configuration...");
                config = new ConfigDefinition();
            }
        }

        protected override void LoadDefaultConfig()
        {
            config = new ConfigDefinition();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion

        #region Language System v2.3

        protected override void LoadDefaultMessages()
        {
            Message.Load(lang, this);
        }

        private partial class Message
        {
            private static RustPlugin plugin;
            private static Lang lang;
            private static ulong senderID = 0;

            public static void ChangeSenderID(ulong newValue)
            {
                senderID = newValue;
            }

            public static void Load(Lang v1, RustPlugin v2)
            {
                lang = v1;
                plugin = v2;

                var dictionary = new Dictionary<string, string>();
                foreach (var pair in messages)
                {
                    var key = pair.Key.ToString();
                    var value = pair.Value.ToString();
                    if(!dictionary.ContainsKey(key))
                        dictionary.Add(key, value);
                }

                lang.RegisterMessages(dictionary, plugin);
            }

            public static void Unload()
            {
                lang = null;
                plugin = null;
            }

            public static void Console(string message, Type type = Type.Normal)
            {
                message = $"[{plugin.Name}] {message}";
                switch (type)
                {
                    case Type.Normal:
                        Debug.Log(message);
                        break;

                    case Type.Warning:
                        Debug.LogWarning(message);
                        break;

                    case Type.Error:
                        Debug.LogError(message);
                        break;
                }
            }

            public static void Send(object receiver, string message, params object[] args)
            {
                message = FormattedMessage(message, args);
                SendMessage(receiver, message);
            }

            public static void Send(object receiver, Key key, params object[] args)
            {
                var userID = (receiver as BasePlayer)?.UserIDString;
                var message = GetMessage(key, userID, args);
                SendMessage(receiver, message);
            }

            public static void Broadcast(string message, params object[] args)
            {
                foreach (var player in BasePlayer.activePlayerList)
                {
                    message = FormattedMessage(message, args);
                    SendMessage(player, message);
                }
            }

            public static void Broadcast(Key key, params object[] args)
            {
                foreach (var player in BasePlayer.activePlayerList)
                {
                    var message = GetMessage(key, player.UserIDString, args);
                    SendMessage(player, message);
                }
            }

            public static string GetMessage(Key key, string playerID = null, params object[] args)
            {
                var keyString = key.ToString();
                var message = lang.GetMessage(keyString, plugin, playerID);
                if (message == keyString)
                {
                    return $"{keyString} is not defined in plugin!";
                }

                if (Interface.CallHook("OnLanguageValidate") != null)
                {
                    message = messages.FirstOrDefault(x => x.Key == key).Value as string;
                }

                return FormattedMessage(message, args);
            }

            public static string FormattedMessage(string message, params object[] args)
            {
                if (args != null && args.Length > 0)
                {
                    var organized = OrganizeArgs(args);
                    return ReplaceArgs(message, organized);
                }

                return message;
            }

            private static void SendMessage(object receiver, string message)
            {
                if (receiver == null || string.IsNullOrEmpty(message))
                {
                    return;
                }

                BasePlayer player = null;
                IPlayer iPlayer = null;
                ConsoleSystem.Arg console = null;

                if (receiver is BasePlayer)
                {
                    player = receiver as BasePlayer;
                }

                if (player == null && receiver is IPlayer)
                {
                    iPlayer = receiver as IPlayer;
                    player = BasePlayer.Find(iPlayer.Id);
                }

                if (player == null && receiver is ConsoleSystem.Arg)
                {
                    console = receiver as ConsoleSystem.Arg;
                    player = console.Connection?.player as BasePlayer;
                    message = $"[{plugin?.Name}] {message}";
                }

                if (player == null && receiver is Component)
                {
                    var obj = receiver as Component;
                    player = obj.GetComponent<BasePlayer>() ?? obj.GetComponentInParent<BasePlayer>() ??
                        obj.GetComponentInChildren<BasePlayer>();
                }

                if (player == null)
                {
                    message = $"[{plugin?.Name}] {message}";
                    Debug.Log(message);
                    return;
                }

                if (console != null)
                {
                    player.SendConsoleCommand("echo " + message);
                }

                if (senderID > 0)
                {
                    if (Interface.CallHook("OnMessagePlayer", message, player) != null)
                    {
                        return;
                    }

                    player.SendConsoleCommand("chat.add", (object) 2, (object) senderID, (object) message);
                }
                else
                {
                    player.ChatMessage(message);
                }
            }
            
            private static Dictionary<string, object> OrganizeArgs(object[] args)
            {
                var dic = new Dictionary<string, object>();
                for (var i = 0; i < args.Length; i += 2)
                {
                    var value = args[i].ToString();
                    var nextValue = i + 1 < args.Length ? args[i + 1] : null;
                    if (!dic.ContainsKey(value))
                        dic.Add(value, nextValue);
                }

                return dic;
            }

            private static string ReplaceArgs(string message, Dictionary<string, object> args)
            {
                if (args == null || args.Count < 1)
                {
                    return message;
                }

                foreach (var pair in args)
                {
                    var s0 = "{" + pair.Key + "}";
                    var s1 = pair.Key;
                    var s2 = pair.Value != null ? pair.Value.ToString() : "null";
                    message = message.Replace(s0, s2, StringComparison.InvariantCultureIgnoreCase);
                    message = message.Replace(s1, s2, StringComparison.InvariantCultureIgnoreCase);
                }

                return message;
            }

            public enum Type
            {
                Normal,
                Warning,
                Error
            }
        }
        
        #endregion 
        
        #region Friends Support 02.07.2020

        [PluginReference] private Plugin Friends, RustIOFriendListAPI;

        private bool IsFriends(BasePlayer player1, BasePlayer player2)
        {
            return IsFriends(player1.userID, player2.userID);
        }

        private bool IsFriends(BasePlayer player1, ulong player2)
        {
            return IsFriends(player1.userID, player2);
        }

        private bool IsFriends(ulong player1, BasePlayer player2)
        {
            return IsFriends(player1, player2.userID);
        }

        private bool IsFriends(ulong id1, ulong id2)
        {
            var flag1 = Friends?.Call<bool>("AreFriends", id1, id2) ?? false;
            var flag2 = RustIOFriendListAPI?.Call<bool>("AreFriendsS", id1.ToString(), id2.ToString()) ?? false;
            return flag1 || flag2;
        }
        
        private string[] GetFriends(string playerID)
        {
            var flag1 = Friends?.Call<string[]>("GetFriends", playerID) ?? new string[]{};
            var flag2 = RustIOFriendListAPI?.Call<string[]>("GetFriends", playerID) ?? new string[]{};
            return flag1.Length > 0 ? flag1 : flag2;
        }

        #endregion

        #region Teams Support

        private static bool InSameTeam(BasePlayer player1, BasePlayer player2)
        {
            return player1.currentTeam != 0 && player1.currentTeam == player2.currentTeam;
        }

        private static bool InSameTeam(BasePlayer player1, ulong player2)
        {
            var team = RelationshipManager.ServerInstance.FindTeam(player1.currentTeam);
            return team != null && team.members.Contains(player2);
        }

        private static bool InSameTeam(ulong player1, BasePlayer player2)
        {
            var team = RelationshipManager.ServerInstance.FindTeam(player2.currentTeam);
            return team != null && team.members.Contains(player1);
        }

        #endregion
        
        #region Clans Support
        
        [PluginReference] private Plugin Clans;
        
        private string GetPlayerClan(BasePlayer player)
        {
            return Clans?.Call<string>("GetClanOf", player.userID);
        }

        private string GetPlayerClan(ulong playerID)
        {
            return Clans?.Call<string>("GetClanOf", playerID);
        }
        
        private string GetPlayerClan(string playerID)
        {
            return Clans?.Call<string>("GetClanOf", playerID);
        }

        private bool InSameClan(BasePlayer player1, BasePlayer player2)
        {
            var clan1 = GetPlayerClan(player1);
            var clan2 = GetPlayerClan(player2);
            return string.IsNullOrEmpty(clan1) == false && string.Equals(clan1, clan2);
        }
        
        private bool InSameClan(ulong player1, ulong player2)
        {
            var clan1 = GetPlayerClan(player1);
            var clan2 = GetPlayerClan(player2);
            return string.IsNullOrEmpty(clan1) == false && string.Equals(clan1, clan2);
        }

        private bool InSameClan(BasePlayer player1, ulong player2)
        {
            var clan1 = GetPlayerClan(player1);
            var clan2 = GetPlayerClan(player2);
            return string.IsNullOrEmpty(clan1) == false && string.Equals(clan1, clan2);
        }
        
        private bool InSameClan(ulong player1, BasePlayer player2)
        {
            var clan1 = GetPlayerClan(player1);
            var clan2 = GetPlayerClan(player2);
            return string.IsNullOrEmpty(clan1) == false && string.Equals(clan1, clan2);
        }
        
        private bool IsClanOwner(string name, string playerID)
        {
            var clan = Clans?.Call<JObject>("GetClan", name);
            return clan != null && clan["owner"].ToString() == playerID;
        }
        
        private bool IsClanModerator(string name, string playerID)
        {
            var clan = Clans?.Call<JObject>("GetClan", name);
            return clan != null && clan["moderators"].Contains(playerID);
        }
        
        private ulong[] GetClanPlayers(string name)
        {
            var clan = Clans?.Call<JObject>("GetClan", name);
            if (clan == null)
            {
                return new ulong[]{};
            }
            
            return clan["members"].Select(x => (ulong) x).ToArray();
        }

        #endregion
    }
}


// --- End of file: BlueprintShare.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/NoWorkbench.cs ---
// --- Original Local Path: NoWorkbench.cs ---

﻿using Newtonsoft.Json;
using System.Linq;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("NoWorkbench", "k1lly0u", "0.1.51")]
    [Description("Eliminates the requirement of being near a bench to craft")]
    class NoWorkbench : RustPlugin
    {        
        private Dictionary<int, int> defaultBlueprints;

        #region Oxide Hooks  
        private void OnServerInitialized()
        {
            LoadVariables();
            defaultBlueprints = ItemManager.GetBlueprints().ToDictionary(x => x.targetItem.itemid, y => y.workbenchLevelRequired);

            foreach (ItemBlueprint bp in ItemManager.GetBlueprints())            
                bp.workbenchLevelRequired = 0;            

            foreach (BasePlayer player in BasePlayer.activePlayerList)
                OnPlayerConnected(player);
        }
       
        private void OnPlayerConnected(BasePlayer player)
        {
            if (player.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot))
            {
                timer.In(3, () => OnPlayerConnected(player));
                return;
            }

            player.ClientRPCPlayer(null, player, "craftMode", 1);

            if (configData.NoBlueprints)
                UnlockAllBlueprints(player);             
        }        

        private void UnlockAllBlueprints(BasePlayer player)
        {
            ProtoBuf.PersistantPlayer playerInfo = SingletonComponent<ServerMgr>.Instance.persistance.GetPlayerInfo(player.userID);
            foreach (ItemBlueprint itemBlueprint in ItemManager.bpList)
            {
                if (itemBlueprint.userCraftable && !itemBlueprint.defaultBlueprint)
                {
                    if (!playerInfo.unlockedItems.Contains(itemBlueprint.targetItem.itemid))                   
                        playerInfo.unlockedItems.Add(itemBlueprint.targetItem.itemid);
                }
            }
            SingletonComponent<ServerMgr>.Instance.persistance.SetPlayerInfo(player.userID, playerInfo);
            player.SendNetworkUpdateImmediate(false);
            player.ClientRPCPlayer<int>(null, player, "UnlockedBlueprint", 0);
        }

        private void Unload()
        {
            foreach (ItemBlueprint bp in ItemManager.GetBlueprints())
                bp.workbenchLevelRequired = defaultBlueprints[bp.targetItem.itemid];
        }
        #endregion
       
        #region Config        
        private ConfigData configData;
        private class ConfigData
        {
            [JsonProperty(PropertyName = "Disable the need for blueprints")]
            public bool NoBlueprints { get; set; }            
        }

        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            ConfigData config = new ConfigData
            {
                NoBlueprints = false
            };
            SaveConfig(config);
        }

        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();

        private void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion
    }
}


// --- End of file: NoWorkbench.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/HitmarkerGUI.cs ---
// --- Original Local Path: HitmarkerGUI.cs ---

using System;
using System.Collections.Generic;
using UnityEngine;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Hitmarker GUI", "PaiN", "1.3.2", ResourceId = 1241)]
    [Description("This plugin informs the attacker/player if he hit someone..")]
    class HitmarkerGUI : RustPlugin
    {
        private bool Changed;
        private bool enablesound;
        private string soundeffect;
		private string headshotsoundeffect;
		private string HeadshotImageURL;
        private bool useimage;
        private string ImageURL;
        private bool usetext;
        private string TextWord;

		List<BasePlayer> hitmarkeron = new List<BasePlayer>();
		
        void Loaded()
        {
            LoadVariables();
			foreach(BasePlayer current in BasePlayer.activePlayerList)
			{
				hitmarkeron.Add(current);
			
			}
        }

        object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }

        void LoadVariables()
        {
            enablesound = Convert.ToBoolean(GetConfig("Sound", "EnableSoundEffect", true));
            soundeffect = Convert.ToString(GetConfig("Sound", "Sound Effect", "assets/bundled/prefabs/fx/takedamage_hit.prefab"));
            useimage = Convert.ToBoolean(GetConfig("Image", "Activated", true));
            ImageURL = Convert.ToString(GetConfig("Image", "ImageURL", "http://oxidemod.org/attachments/fuzidev_2-png.10926/"));
            usetext = Convert.ToBoolean(GetConfig("Text", "Activated", false));
            TextWord = Convert.ToString(GetConfig("Text", "TextWord", "HIT"));
			headshotsoundeffect = Convert.ToString(GetConfig("Sound", "HeadshotSoundEffect", "assets/bundled/prefabs/fx/headshot.prefab"));
			HeadshotImageURL = Convert.ToString(GetConfig("Image", "HeadshotImageURL", "http://i.imgur.com/dopEPnQ.png"));

            if (Changed)
            {
                SaveConfig();
                Changed = false;
            }
        }

        protected override void LoadDefaultConfig()
        {
            Puts("Creating a new configuration file!");
            Config.Clear();
            LoadVariables();
        }

        string image = @"[
                       {
                            ""name"": ""HitMarkerImage"",
                            ""parent"": ""Overlay"",
                            ""components"":
                            [
                               {
								   ""sprite"": ""assets/content/textures/generic/fulltransparent.tga"",
                                    ""type"":""UnityEngine.UI.RawImage"",
                                    ""imagetype"": ""Tiled"",
                                    ""color"": ""1.0 1.0 1.0 1.0"",
                                    ""url"": ""{url}"",
                                },
                                {
                                    ""type"":""RectTransform"",
                                    ""anchormin"": ""0.49 0.48"",
                                    ""anchormax"": ""0.51 0.52""
                                }
                            ]
                        }
                    ]
                    ";
        string text = @"[
                       {
                            ""name"": ""HitMarker"",
                            ""parent"": ""Overlay"",
                            ""components"":
                            [
                                {
									""sprite"": ""assets/content/textures/generic/fulltransparent.tga"",
                                     ""type"":""UnityEngine.UI.Image"",
                                     ""color"":""0.0 0.0 0.0 0.0"",
                                },
                                {
                                    ""type"":""RectTransform"",
                                    ""anchormin"": ""0.50 0.49"",
                                    ""anchormax"": ""0.60 0.51""
                                }
                            ]
                        },
                        {
                            ""parent"": ""HitMarker"",
                            ""components"":
                            [
                                {
                                    ""type"":""UnityEngine.UI.Text"",
                                    ""text"":""{text}"",
                                    ""fontSize"":20,
                                    ""color"":""1 0.0 0.0 2"",
                                    ""align"": ""MiddleCenter"",
                                    ""anchormin"": ""0.50 0.50"",
                                    ""anchormax"": ""0.50 0.50""
                                }
                            ]
                        },
                    ]
                    ";
					
		[ChatCommand("hitmarker")]
		void cmdHitMarker(BasePlayer player, string cmd, string[] args)
		{
			if(!hitmarkeron.Contains(player))
			{
				hitmarkeron.Add(player);
				SendReply(player, "<color=cyan>HitMarker</color>:" + " " + "<color=orange>You have enabled your hitmarker.</color>");
			}
			else
			{
				hitmarkeron.Remove(player);
				SendReply(player, "<color=cyan>HitMarker</color>:" + " " + "<color=orange>You have disabled your hitmarker.</color>");
			}
		
		
		}
		
		void OnPlayerInit(BasePlayer player)
		{
			hitmarkeron.Add(player);
		}
		void OnPlayerDisconnected(BasePlayer player)
		{
			hitmarkeron.Remove(player);
		}
		
		
        void OnPlayerAttack(BasePlayer attacker, HitInfo hitinfo)
        {
            var gettingdmg = hitinfo.HitEntity as BasePlayer;
            if (gettingdmg && hitmarkeron.Contains(attacker))
            {
				if(hitinfo.isHeadshot)
				{
					if(useimage == true)
					{
						if (enablesound == true)
						{
							Effect.server.Run(headshotsoundeffect, attacker.transform.position, Vector3.zero, attacker.net.connection);
						}
						CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo() { connection = attacker.net.connection }, null, "AddUI", new Facepunch.ObjectList(image.Replace("{url}", HeadshotImageURL), null, null, null, null));
						timer.Once(0.5f, () => CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo() { connection = attacker.net.connection }, null, "DestroyUI", new Facepunch.ObjectList("HitMarkerImage", null, null, null, null)));
					}
				}
				else
				{
					if(useimage == true)
					{
						if (enablesound == true)
						{
							Effect.server.Run(soundeffect, attacker.transform.position, Vector3.zero, attacker.net.connection);
						}
						CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo() { connection = attacker.net.connection }, null, "AddUI", new Facepunch.ObjectList(image.Replace("{url}", ImageURL), null, null, null, null));
						timer.Once(0.5f, () => CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo() { connection = attacker.net.connection }, null, "DestroyUI", new Facepunch.ObjectList("HitMarkerImage", null, null, null, null)));
					}
					else if (usetext == true)
					{
						if (enablesound == true)
						{
							Effect.server.Run(soundeffect, attacker.transform.position, Vector3.zero, attacker.net.connection);
						}
						CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo() { connection = attacker.net.connection }, null, "AddUI", new Facepunch.ObjectList(text.Replace("{text}", TextWord), null, null, null, null));
						timer.Once(0.5f, () => CommunityEntity.ServerInstance.ClientRPCEx(new Network.SendInfo() { connection = attacker.net.connection }, null, "DestroyUI", new Facepunch.ObjectList("HitMarker", null, null, null, null)));

					}
				}
            }
        }
    }
}

// --- End of file: HitmarkerGUI.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/PlayerSkins.cs ---
// --- Original Local Path: PlayerSkins.cs ---

﻿using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Plugins;
using UnityEngine;
using Steamworks;
using System.Linq;
using System.Collections;
using System.Globalization;

namespace Oxide.Plugins
{
    [Info("PlayerSkins", "k1lly0u", "2.0.21")]
    [Description("Fully Customization Skin Management Plugin - Sell Skinned items or Skins!")]
    class PlayerSkins : RustPlugin
    {
        #region Fields
        [PluginReference] Plugin Economics, ImageLibrary, ServerRewards;

        private Dictionary<string, Dictionary<ulong, SkinData>> skinData = new Dictionary<string, Dictionary<ulong, SkinData>>();
        private Dictionary<ulong, UserData> userData = new Dictionary<ulong, UserData>();
        private List<ulong> excludedSkins = new List<ulong>();

        private DynamicConfigFile userdata, skindata, excludeddata;

        private Dictionary<string, Dictionary<ulong, WorkshopItem>> workshopItems = new Dictionary<string, Dictionary<ulong, WorkshopItem>>();

        private Dictionary<string, string> shortnameToDisplayname = new Dictionary<string, string>();

        private List<ulong> adminToggle = new List<ulong>();
        private List<ulong> ownedToggle = new List<ulong>();
        private List<ulong> approvedIds = new List<ulong>();

        private bool initialized = false;

        private bool workshopInitialized = false;
        private bool itemlistInitialized = false;

        private JsonSerializerSettings errorHandling = new JsonSerializerSettings { Error = (se, ev) => { ev.ErrorContext.Handled = true; } };

        private static Dictionary<Colors, string> uiColor;

        private static bool forceHttp = false;

        private TokenType purchaseType;
        private DisplayMode forcedMode;

        public enum TokenType { None, ServerRewards, Economics }
        #endregion

        #region Oxide Hooks
        private void Loaded()
        {
            skindata = Interface.Oxide.DataFileSystem.GetFile("PlayerSkins/skinlist");
            userdata = Interface.Oxide.DataFileSystem.GetFile("PlayerSkins/userdata");
            excludeddata = Interface.Oxide.DataFileSystem.GetFile("PlayerSkins/excludedskins");

            shortnameToDisplayname = Interface.Oxide.DataFileSystem.GetFile("PlayerSkins/itemDisplayNames").ReadObject<Dictionary<string, string>>();

            permission.RegisterPermission("playerskins.shop", this);
            permission.RegisterPermission("playerskins.reskin", this);
            permission.RegisterPermission("playerskins.admin", this);
            permission.RegisterPermission("playerskins.nocharge", this);

            lang.RegisterMessages(Messages, this);
        }

        private void OnServerInitialized()
        {
            LoadData();

            forceHttp = configData.Workshop.ForceHTTP;

            purchaseType = ParseType<TokenType>(configData.Purchase.Type);
            if (configData.Purchase.Enabled && purchaseType == TokenType.None)
            {
                PrintError("Invalid purchase plugin specified in config. Must be either 'ServerRewards' or 'Economics'!");
                return;
            }

            forcedMode = ParseType<DisplayMode>(configData.Shop.ForcedMode);

            foreach (string perm in configData.Shop.Permissions)
            {
                if (!perm.StartsWith("playerskins."))
                    permission.RegisterPermission($"playerskins.{perm}", this);
                else permission.RegisterPermission(perm, this);
            }

            uiColor = new Dictionary<Colors, string>();

            foreach (var color in configData.UI.Colors)
                uiColor.Add(color.Key, UI.Color(color.Value.Color, color.Value.Alpha));

            bool displayNameChanged = false;

            foreach (ItemDefinition item in ItemManager.itemList)
            {
                if (!shortnameToDisplayname.ContainsKey(item.shortname))
                {
                    shortnameToDisplayname.Add(item.shortname, item.displayName.english);
                    displayNameChanged = true;
                }

                string workshopName = item.displayName.english.ToLower().Replace("skin", "").Replace(" ", "").Replace("-", "");
                if (!workshopNameToShortname.ContainsKey(workshopName))
                    workshopNameToShortname.Add(workshopName, item.shortname);

                if (!workshopNameToShortname.ContainsKey(item.shortname))
                    workshopNameToShortname.Add(item.shortname, item.shortname);
            }

            if (displayNameChanged)
                Interface.Oxide.DataFileSystem.WriteObject("PlayerSkins/itemDisplayNames", shortnameToDisplayname);

            if (string.IsNullOrEmpty(configData.Workshop.SteamAPIKey))
            {
                PrintError("You must enter a Steam API key in your config in order to retrieve approved skin icons and/or access workshop items. Unable to continue...");
                return;
            }

            if ((Steamworks.SteamInventory.Definitions?.Length ?? 0) == 0)
            {
                PrintWarning("Waiting for Steamworks to update item definitions....");
                Steamworks.SteamInventory.OnDefinitionsUpdated += StartApprovedRequest;                
            }
            else StartApprovedRequest();
        }

        private void OnServerSave() => SaveUserData();

        private void Unload()
        {            
            foreach (BasePlayer player in BasePlayer.activePlayerList)
                DestroyUI(player);

            initialized = false;
        }

        private void OnActiveItemChanged(BasePlayer player, Item oldItem, Item newItem)
        {
            CuiHelper.DestroyUi(player, ReskinPanel);
        }

        private void OnUseNPC(BasePlayer npc, BasePlayer player)
        {
            if (player == null || npc == null) return;

            if (!userData.ContainsKey(player.userID))
                userData.Add(player.userID, new UserData());

            if (configData.Shop.NPCs.Contains(npc.UserIDString))
                OpenSkinMenu(player, "", 0, 0);
            else if (configData.Reskin.NPCs.Contains(npc.UserIDString) && !configData.Shop.GiveItemOnPurchase)
                CreateReskinMenu(player);
        }

        private void OnItemCraftFinished(ItemCraftTask task, Item item)
        {
            BasePlayer player = task?.owner;
            if (player == null || item == null)
                return;

            if (item.skin != 0)
                return;

            UserData data;
            if (!userData.TryGetValue(player.userID, out data))
                return;

            if (data.defaultSkins.ContainsKey(item.info.shortname))
                ChangeItemSkin(item, data.defaultSkins[item.info.shortname]);
        }
        #endregion

        #region Functions
        private T ParseType<T>(string type)
        {
            try
            {
                return (T)Enum.Parse(typeof(T), type, true);
            }
            catch
            {
                return default(T);
            }
        }

        private bool HasPermission(BasePlayer player, string perm)
        {
            if (!perm.StartsWith("playerskins."))
                perm = $"playerskins.{perm}";

            return permission.UserHasPermission(player.UserIDString, perm);
        }

        private void BroadcastAnnouncement()
        {
            if (!configData.Announcements.Enabled && configData.Announcements.Interval > 0)
                return;

            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                if (configData.Shop.DisableCommand)
                    SendReply(player, msg("Help.Shop.NPC", player.userID));
                else SendReply(player, msg("Help.Shop.Command", player.userID));
                if (configData.Reskin.DisableCommand)
                    SendReply(player, msg("Help.Reskin.NPC", player.userID));
                else SendReply(player, msg("Help.Reskin.Command", player.userID));
            }

            timer.In(configData.Announcements.Interval * 60, BroadcastAnnouncement);
        }

        private void ChangeItemSkin(BasePlayer player, ulong targetSkin)
        {
            Item item = player.GetActiveItem();
            if (item == null)
            {
                item = player.inventory.containerBelt.GetSlot(0);
                if (item == null)
                    return;
            }

            ChangeItemSkin(item, targetSkin);

            int slot = item.position;
            item.SetParent(null);
            item.MarkDirty();

            timer.Once(0.15f, () =>
            {
                if (item == null)
                    return;

                item.SetParent(player.inventory.containerBelt);
                item.position = slot;
                item.MarkDirty();
            });
        }

        private void ChangeItemSkin(Item item, ulong targetSkin)
        {
            item.skin = targetSkin;
            item.MarkDirty();

            BaseEntity heldEntity = item.GetHeldEntity();
            if (heldEntity != null)
            {
                heldEntity.skinID = targetSkin;
                heldEntity.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
            }
        }
        #endregion

        #region Skin List Initialization
        private Dictionary<string, string> workshopNameToShortname = new Dictionary<string, string>
        {
            {"longtshirt", "tshirt.long" },
            {"cap", "hat.cap" },
            {"beenie", "hat.beenie" },
            {"boonie", "hat.boonie" },
            {"balaclava", "mask.balaclava" },
            {"pipeshotgun", "shotgun.waterpipe" },
            {"woodstorage", "box.wooden" },
            {"ak47", "rifle.ak" },
            {"bearrug", "rug.bear" },
            {"boltrifle", "rifle.bolt" },
            {"bandana", "mask.bandana" },
            {"hideshirt", "attire.hide.vest" },
            {"snowjacket", "jacket.snow" },
            {"buckethat", "bucket.helmet" },
            {"semiautopistol", "pistol.semiauto" },
            {"burlapgloves", "burlap.gloves" },
            {"roadsignvest", "roadsign.jacket" },
            {"roadsignpants", "roadsign.kilt" },
            {"burlappants", "burlap.trousers" },
            {"collaredshirt", "shirt.collared" },
            {"mp5", "smg.mp5" },
            {"sword", "salvaged.sword" },
            {"workboots", "shoes.boots" },
            {"vagabondjacket", "jacket" },
            {"hideshoes", "attire.hide.boots" },
            {"deerskullmask", "deer.skull.mask" },
            {"minerhat", "hat.miner" },
            {"lr300", "rifle.lr300" },
            {"lr300.item", "rifle.lr300" },
            {"burlap.gloves", "burlap.gloves.new"},
            {"leather.gloves", "burlap.gloves"},
            {"python", "pistol.python" },
            {"m39", "rifle.m39" },
            {"woodendoubledoor", "door.double.hinged.wood" }
        };

        private string[] blockedItems = new string[]
        {
            "sign.", "jackolantern.", "xmas", "boots.frog", "skull_fire_pit", "scarecrow", "snowman"
        };
        #endregion

        #region Approved Skins
        private void StartApprovedRequest()
        {
            Steamworks.SteamInventory.OnDefinitionsUpdated -= StartApprovedRequest;

            if (configData.Workshop.ApprovedDisabled && !configData.Workshop.Enabled)
            {
                PrintError("You have approved skins and workshop skins disabled. This leaves no skins to be shown in the skin shop!");
                return;
            }

            if (configData.Workshop.ApprovedDisabled && configData.Workshop.Enabled)
            {
                itemlistInitialized = initialized = true;
                GetWorkshopSkins();
                return;
            }

            PrintWarning("Retrieving approved skin lists...");

            itemlistInitialized = true;

            GetApprovedItemSkins(BuildApprovedItemList(), 0);
        }

        private void GetApprovedItemSkins(List<ulong> itemsToDownload, int page)
        {
            if (itemsToDownload.Count < 1)
            {
                ValidateDataShortnames();

                initialized = true;

                Puts("Approved skins loaded");

                if (configData.Workshop.Enabled)
                    GetWorkshopSkins();

                return;
            }

            int totalPages = Mathf.CeilToInt((float)itemsToDownload.Count / 100f) - 1;
            
            string details = BuildDetailsString(itemsToDownload, page);

            QueueFileQueryRequest(details, (PublishedFileQueryDetail[] items) =>
            {
                ServerMgr.Instance.StartCoroutine(ProcessApprovedBlock(itemsToDownload, items, page, totalPages));
            });            
        }

        private IEnumerator ProcessApprovedBlock(List<ulong> itemsToDownload, PublishedFileQueryDetail[] items, int page, int totalPages)
        {
            PrintWarning($"Processing approved skins; Page {page + 1}/{totalPages + 1}");

            Dictionary<string, Dictionary<ulong, string>> loadOrder = new Dictionary<string, Dictionary<ulong, string>>();

            foreach (PublishedFileQueryDetail item in items)
            {
                if (!IsValid(item))
                    continue;

                foreach (PublishedFileQueryDetail.Tag tag in item.tags)
                {
                    if (string.IsNullOrEmpty(tag.tag))
                        continue;

                    ulong workshopid = Convert.ToUInt64(item.publishedfileid);

                    string adjTag = tag.tag.ToLower().Replace("skin", "").Replace(" ", "").Replace("-", "").Replace(".item", "");
                    if (workshopNameToShortname.ContainsKey(adjTag))
                    {
                        string shortname = workshopNameToShortname[adjTag];

                        if (!skinData.ContainsKey(shortname))
                            skinData.Add(shortname, new Dictionary<ulong, SkinData>());

                        if (!skinData[shortname].ContainsKey(workshopid))
                            skinData[shortname].Add(workshopid, new SkinData());

                        if (!workshopItems.ContainsKey(shortname))
                            workshopItems.Add(shortname, new Dictionary<ulong, WorkshopItem>());

                        if (!workshopItems[shortname].ContainsKey(workshopid))
                        {
                            WorkshopItem workshopItem = new WorkshopItem(item);
                            if (workshopItem == null)
                                continue;

                            workshopItems[shortname].Add(workshopid, workshopItem);
                        }

                        if (!HasImage(shortname, workshopid))
                        {
                            if (!loadOrder.ContainsKey(shortname))
                                loadOrder.Add(shortname, new Dictionary<ulong, string>());

                            if (!loadOrder[shortname].ContainsKey(workshopid))
                            {
                                loadOrder[shortname].Add(workshopid, workshopItems[shortname][workshopid].imageUrl);
                            }
                        }
                    }
                }
            }

            if (loadOrder.Count > 0)
            {
                loadOrderCount++;
                Puts($"Creating load order for approved skins (Order #{loadOrderCount})");                
                ImageLibrary.Call("ImportItemList", $"{Title} approved skin icons (Order #{loadOrderCount})", loadOrder);
            }

            yield return CoroutineEx.waitForEndOfFrame;
            yield return CoroutineEx.waitForEndOfFrame;

            if (page < totalPages)            
                GetApprovedItemSkins(itemsToDownload, page + 1);            
            else
            {
                itemsToDownload.Clear();

                ValidateDataShortnames();

                initialized = true;

                Puts("Approved skins loaded");

                if (configData.Workshop.Enabled)
                    GetWorkshopSkins();
            }
        }

        private List<ulong> BuildApprovedItemList()
        {
            List<ulong> list = new List<ulong>();

            foreach (InventoryDef item in Steamworks.SteamInventory.Definitions)
            {
                string shortname = item.GetProperty("itemshortname");
                ulong workshopid;

                if (item == null || string.IsNullOrEmpty(shortname))
                    continue;

                if (workshopNameToShortname.ContainsKey(shortname))
                    shortname = workshopNameToShortname[shortname];

                if (item.Id < 100 || blockedItems.Any(x => shortname.StartsWith(x)))
                    continue;

                if (!ulong.TryParse(item.GetProperty("workshopid"), out workshopid))
                    continue;

                approvedIds.Add(workshopid);

                if (excludedSkins.Contains(workshopid))
                    continue;

                if (!skinData.ContainsKey(shortname))
                    skinData.Add(shortname, new Dictionary<ulong, SkinData>());

                if (!skinData[shortname].ContainsKey(workshopid))
                    skinData[shortname].Add(workshopid, new SkinData());

                if (HasImage(shortname, workshopid))
                {
                    if (!workshopItems.ContainsKey(shortname))
                        workshopItems.Add(shortname, new Dictionary<ulong, WorkshopItem>());

                    if (!workshopItems[shortname].ContainsKey(workshopid))
                    {
                        WorkshopItem workshopItem = new WorkshopItem(item, GetImageURL(shortname, workshopid));
                        if (workshopItem == null)
                            continue;

                        workshopItems[shortname].Add(workshopid, workshopItem);
                    }

                    continue;
                }

                list.Add(workshopid);
            }

            return list;
        }
        #endregion

        #region Workshop Items
        private const string publishedFileQuery = "https://api.steampowered.com/IPublishedFileService/QueryFiles/v1/?key={0}&page={1}&numperpage=100&appid=252490&requiredtags=version3%2Cskin&match_all_tags=1&return_tags=1&return_previews=1";
        private const string publishedFileDetails = "https://api.steampowered.com/ISteamRemoteStorage/GetPublishedFileDetails/v1/";

        private int workshopPage = 0;
        private int totalPages = -1;
        private int totalCount = 0;
        private int loadOrderCount = 0;

        private void GetWorkshopSkins()
        {
            if (ImageLibrary == null || string.IsNullOrEmpty(configData.Workshop.SteamAPIKey))
                return;

            loadOrderCount = 0;

            PrintWarning("Querying Steam for workshop items. This process can take a while!\nWorkshop skins will be unavailable in the skin shop and reskin menu until this process has completed. Once the workshop data has been loaded any registered workshop skins will appear.");

            WorkshopQuery(string.Format(publishedFileQuery, configData.Workshop.SteamAPIKey, workshopPage));
        }

        private void WorkshopQuery(string queryStr)
        {            
            webrequest.Enqueue(queryStr, null, (code, response) =>
            {                
                try
                {                    
                    QueryResponse query = JsonConvert.DeserializeObject<QueryResponse>(response, errorHandling);
                    if (query == null || query.response == null || query.response.publishedfiledetails.Length == 0)
                    {
                        if (code != 200)
                            PrintError($"There was a error querying Steam for workshop data : Code ({code})");

                        workshopPage++;

                        if (workshopPage < totalPages)
                            WorkshopQuery(string.Format(publishedFileQuery, configData.Workshop.SteamAPIKey, workshopPage));
                        else InitializeWorkshop();
                        return;
                    }
                    else
                    {
                        if (totalPages == -1)
                            totalPages = Mathf.CeilToInt((float)query.response.total / 100f);

                        ServerMgr.Instance.StartCoroutine(ProcessWorkshopResponse(query.response.publishedfiledetails));
                    }
                }
                catch (Exception ex)
                {
                    if (code != 200)
                        PrintError($"There was a error querying Steam for workshop data : Code ({code})\n{ex.Message}");

                    workshopPage++;

                    if (workshopPage < totalPages)
                        WorkshopQuery(string.Format(publishedFileQuery, configData.Workshop.SteamAPIKey, workshopPage));
                    else
                    {
                        List<ulong> invalidSkins = FindMissingSkins();
                        if (invalidSkins.Count == 0)
                            InitializeWorkshop();
                        else
                        {
                            PrintWarning("Querying Steam for missing item icons...");
                            FindSkinsWithNoData(invalidSkins, 0);
                        }
                    }
                }

            }, this);
        }

        private IEnumerator ProcessWorkshopResponse(PublishedFileDetails[] response)
        {
            Dictionary<string, Dictionary<ulong, string>> loadOrder = new Dictionary<string, Dictionary<ulong, string>>();

            foreach (PublishedFileDetails item in response)
            {
                if (!IsValid(item))
                    continue;

                foreach (PublishedFileDetails.Tag tag in item.tags)
                {
                    if (string.IsNullOrEmpty(tag.tag))
                        continue;

                    ulong workshopId = Convert.ToUInt64(item.publishedfileid);

                    if (approvedIds.Contains(workshopId))
                        continue;

                    string adjTag = tag.tag.ToLower().Replace("skin", "").Replace(" ", "").Replace("-", "").Replace(".item", "");
                    if (workshopNameToShortname.ContainsKey(adjTag))
                    {
                        string shortname = workshopNameToShortname[adjTag];

                        if (!workshopItems.ContainsKey(shortname))
                            workshopItems.Add(shortname, new Dictionary<ulong, WorkshopItem>());

                        if (!workshopItems[shortname].ContainsKey(workshopId))
                        {
                            WorkshopItem workshopItem = new WorkshopItem(item);
                            if (workshopItem == null)
                                continue;

                            workshopItems[shortname].Add(workshopId, workshopItem);
                            totalCount++;
                        }

                        if (skinData.ContainsKey(shortname))
                        {
                            if (skinData[shortname].ContainsKey(workshopId))
                            {
                                if (!HasImage(shortname, workshopId))
                                {
                                    Puts("needs download " + shortname + " " + workshopId);
                                    if (!loadOrder.ContainsKey(shortname))
                                        loadOrder.Add(shortname, new Dictionary<ulong, string>());

                                    if (!loadOrder[shortname].ContainsKey(workshopId))
                                    {
                                        loadOrder[shortname].Add(workshopId, workshopItems[shortname][workshopId].imageUrl);
                                    }
                                }
                            }
                        }
                    }
                }
            }

            if (loadOrder.Count > 0)
            {
                Puts("create load order " + loadOrder.Count);

                loadOrderCount++;
                Puts($"Creating a load order for workshop skins (Order #{loadOrderCount})");
                ImageLibrary.Call("ImportItemList", $"{Title} workshop skin icons (Order #{loadOrderCount})", loadOrder);
            }

            workshopPage++;

            yield return CoroutineEx.waitForEndOfFrame;
            yield return CoroutineEx.waitForEndOfFrame;

            if (workshopPage < totalPages)
            {
                WorkshopQuery(string.Format(publishedFileQuery, configData.Workshop.SteamAPIKey, workshopPage));
            }
            else
            {
                List<ulong> invalidSkins = FindMissingSkins();
                if (invalidSkins.Count == 0)
                    InitializeWorkshop();
                else
                {
                    PrintWarning("Querying Steam for missing item icons...");
                    FindSkinsWithNoData(invalidSkins, 0);
                }
            }
        }
        #endregion

        #region Find Missing Skins
        private List<ulong> FindMissingSkins()
        {
            List<ulong> invalidSkins = new List<ulong>();
            for (int i = skinData.Count - 1; i >= 0; i--)
            {
                KeyValuePair<string, Dictionary<ulong, SkinData>> skinInfo = skinData.ElementAt(i);

                for (int y = skinInfo.Value.Count - 1; y >= 0; y--)
                {
                    KeyValuePair<ulong, SkinData> skin = skinInfo.Value.ElementAt(y);
                    if (excludedSkins.Contains(skin.Key))
                        continue;

                    if (!workshopItems.ContainsKey(skinInfo.Key) || !workshopItems[skinInfo.Key].ContainsKey(skin.Key) || workshopItems[skinInfo.Key][skin.Key] == null)
                    {
                        invalidSkins.Add(skin.Key);
                    }
                }
            }

            return invalidSkins;
        }

        private void FindSkinsWithNoData(List<ulong> invalidSkins, int page)
        {
            int totalPages = Mathf.CeilToInt((float)invalidSkins.Count / 100f) - 1;

            string details = BuildDetailsString(invalidSkins, page);

            QueueFileQueryRequest(details, (PublishedFileQueryDetail[] items) =>
            {
                ServerMgr.Instance.StartCoroutine(ProcessMissingBlock(invalidSkins, items, page, totalPages));
            });
        }

        private IEnumerator ProcessMissingBlock(List<ulong> invalidSkins, PublishedFileQueryDetail[] items, int page, int totalPages)
        {
            Dictionary<string, Dictionary<ulong, string>> loadOrder = new Dictionary<string, Dictionary<ulong, string>>();

            foreach (PublishedFileQueryDetail item in items)
            {
                if (!IsValid(item))
                    continue;

                foreach (PublishedFileQueryDetail.Tag tag in item.tags)
                {
                    if (string.IsNullOrEmpty(tag.tag))
                        continue;

                    ulong workshopId = Convert.ToUInt64(item.publishedfileid);

                    string adjTag = tag.tag.ToLower().Replace("skin", "").Replace(" ", "").Replace("-", "").Replace(".item", "");
                    if (workshopNameToShortname.ContainsKey(adjTag))
                    {
                        string shortname = workshopNameToShortname[adjTag];

                        if (!workshopItems.ContainsKey(shortname))
                            workshopItems.Add(shortname, new Dictionary<ulong, WorkshopItem>());

                        if (!workshopItems[shortname].ContainsKey(workshopId))
                        {
                            WorkshopItem workshopItem = new WorkshopItem(item);
                            if (workshopItem == null)
                                continue;
                            workshopItems[shortname].Add(workshopId, workshopItem);
                            totalCount++;
                        }

                        if (skinData.ContainsKey(shortname))
                        {
                            if (skinData[shortname].ContainsKey(workshopId))
                            {
                                if (!HasImage(shortname, workshopId))
                                {
                                    if (!loadOrder.ContainsKey(shortname))
                                        loadOrder.Add(shortname, new Dictionary<ulong, string>());

                                    if (!loadOrder[shortname].ContainsKey(workshopId))
                                    {
                                        loadOrder[shortname].Add(workshopId, workshopItems[shortname][workshopId].imageUrl);
                                    }
                                }
                            }
                        }
                    }
                }
            }

            if (loadOrder.Count > 0)
            {
                loadOrderCount++;
                Puts($"Creating a load order for missing skin icons (Order #{loadOrderCount})");
                ImageLibrary.Call("ImportItemList", $"{Title} missing workshop skin icons (Order #{loadOrderCount})", loadOrder);
            }

            invalidSkins.Clear();

            yield return CoroutineEx.waitForEndOfFrame;
            yield return CoroutineEx.waitForEndOfFrame;

            if (page < totalPages)
                FindSkinsWithNoData(invalidSkins, page + 1);
            else
            {
                invalidSkins.Clear();
                InitializeWorkshop();
            }
        }

        private void InitializeWorkshop()
        {
            foreach (KeyValuePair<string, Dictionary<ulong, WorkshopItem>> kvp in workshopItems)
                Interface.Oxide.DataFileSystem.WriteObject<Dictionary<ulong, WorkshopItem>>($"PlayerSkins/WorkshopData/{kvp.Key}", kvp.Value);

            Puts("Saved available workshop skin lists to \"/oxide/data/PlayerSkins/WorkshopData/\"");

            PrintWarning($"Workshop skin list retrieval completed. {totalCount} workshop skins are now available!");

            workshopInitialized = true;
        }

        #endregion

        #region API Helpers
        private bool ContainsKeyword(string title)
        {
            foreach (string keyword in configData.Workshop.Filter)
            {
                if (title.ToLower().Contains(keyword.ToLower()))
                    return true;
            }
            return false;
        }

        private bool IsValid(PublishedFileDetails item)
        {
            if (ContainsKeyword(item.title))
                return false;

            if (string.IsNullOrEmpty(item.preview_url))
                return false;

            if (item.tags == null)
                return false;

            return true;
        }

        private bool IsValid(PublishedFileQueryDetail item)
        {
            if (ContainsKeyword(item.title))
                return false;

            if (string.IsNullOrEmpty(item.preview_url))
                return false;

            if (item.tags == null)
                return false;

            return true;
        }       

        private string BuildDetailsString(List<ulong> list, int page)
        {
            int start = page * 100;
            int end = start + 100 > list.Count ? list.Count : start + 100;

            string details = string.Format("?key={0}&itemcount={1}", configData.Workshop.SteamAPIKey, end - start);            

            for (int i = start; i < end; i++)                        
                details += string.Format("&publishedfileids[{0}]={1}", i - start, list[i]);            

            return details;
        }

        private void QueueFileQueryRequest(string details, Action<PublishedFileQueryDetail[]> callback)
        {
            webrequest.Enqueue(publishedFileDetails, details, (code, response) =>
                {
                    try
                    {
                        PublishedFileQueryResponse query = JsonConvert.DeserializeObject<PublishedFileQueryResponse>(response, errorHandling);
                        if (query == null || query.response == null || query.response.publishedfiledetails.Length == 0)
                        {
                            if (code != 200)
                                PrintError($"There was a error querying Steam for workshop item data : Code ({code})");
                            return;
                        }
                        else
                        {
                            if (query?.response?.publishedfiledetails?.Length > 0)
                                callback.Invoke(query.response.publishedfiledetails);
                        }
                    }
                    catch { }
                }, this, Core.Libraries.RequestMethod.POST);
        }

        private void ValidateDataShortnames()
        {
            bool flag = false;
            for (int i = skinData.Count - 1; i >= 0; i--)
            {
                string shortname = skinData.ElementAt(i).Key;
                if (!shortnameToDisplayname.ContainsKey(shortname))
                {
                    skinData.Remove(shortname);
                    Puts($"Removing invalid item shortname from data file : {shortname}");
                    flag = true;
                }
            }

            if (flag)
                SaveSkinData();
        }
        #endregion

        #region Image Library       
        private string GetImage(string shortname, ulong skin = 0) => (string)ImageLibrary.Call("GetImage", shortname, skin);

        private string GetImageURL(string shortname, ulong skin = 0) => (string)ImageLibrary.Call("GetImageURL", shortname, skin);

        private bool AddImage(string url, string shortname, ulong skin = 0) => (bool)ImageLibrary.Call("AddImage", url, shortname, skin);

        private bool HasImage(string shortname, ulong skin = 0) => (bool)ImageLibrary.Call("HasImage", shortname, skin);

        private bool IsReady() => (bool)ImageLibrary.Call("IsReady");
        #endregion

        #region Chat Commands
        [ChatCommand("skin")]
        private void cmdSkin(BasePlayer player, string command, string[] args)
        {
            if (!userData.ContainsKey(player.userID))
                userData.Add(player.userID, new UserData());

            if (args.Length == 0)
            {
                if (!HasPermission(player, "reskin"))
                {
                    SendReply(player, "You do not have permission to use this command");
                    return;
                }

                if (configData.Shop.GiveItemOnPurchase)
                    return;

                if (configData.Reskin.DisableCommand)
                {
                    SendReply(player, "You can only access the re-skin menu via a re-skin NPC");
                    return;
                }
                CreateReskinMenu(player);
            }
            else
            {
                if (args[0].ToLower() != "shop")
                {
                    SendReply(player, "/skin - Open the re-skin menu");
                    SendReply(player, "/skin shop - Open the skin shop");
                    return;
                }

                if (!HasPermission(player, "shop"))
                {
                    SendReply(player, "You do not have permission to use this command");
                    return;
                }

                if (configData.Shop.DisableCommand)
                {
                    SendReply(player, "You can only access the skin shop menu via a skin shop NPC");
                    return;
                }

                OpenSkinMenu(player, string.Empty, 0, 0);
            }
        }
        #endregion

        #region Console Commands
        [ConsoleCommand("playerskins.skins")]
        private void ccmdSkinManager(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null)
            {
                if (arg.Connection.authLevel < 2)
                {
                    SendReply(arg, "You do not have permission to use this command");
                    return;
                }
            }

            if (arg.Args == null || arg.Args.Length < 3)
            {
                SendReply(arg, "playerskins.skins import <item shortname> <skin ID> - Import the specified workshop skin");
                SendReply(arg, "playerskins.skins import random <amount> - Import the specified amount of random skins for random items");
                SendReply(arg, "playerskins.skins import random <item shortname> <amount> - Import the specified amount of random skins for the specified item");
                SendReply(arg, "playerskins.skins remove <item shortname> <skin ID> - Remove the specified skin from the skin shop");
                return;
            }

            if (!configData.Workshop.Enabled)
            {
                SendReply(arg, "You have workshop disabled in your config. The playerskins.skins commands are unavailable when workshop is disabled");
                return;
            }

            if (!workshopInitialized)
            {
                SendReply(arg, "Workshop initialization has not yet finished. The playerskins.skins commands are unavailable until that process is complete");
                return;
            }

            switch (arg.GetString(0).ToLower())
            {
                case "import":
                    if (arg.Args[1].ToLower() == "random")
                    {
                        if (arg.Args.Length == 4)
                        {
                            string shortname = arg.GetString(2).ToLower();

                            if (!ItemManager.itemList.Select(x => x.shortname).Contains(shortname) || !workshopItems.ContainsKey(shortname))
                            {
                                SendReply(arg, "The item shortname you have entered either does not have any skins, or is invalid");
                                return;
                            }

                            int amount;
                            if (!int.TryParse(arg.GetString(3), out amount))
                            {
                                SendReply(arg, "You must enter an amount of random skins to import");
                                return;
                            }

                            Dictionary<string, Dictionary<ulong, string>> loadOrder = new Dictionary<string, Dictionary<ulong, string>>();
                            int skinCount = 0;
                            int loadOrderCount = 0;
                            int actualCount = 0;

                            List<KeyValuePair<ulong, WorkshopItem>> newList = new List<KeyValuePair<ulong, WorkshopItem>>(workshopItems[shortname].ToList());

                            for (int i = 0; i < amount; i++)
                            {
                                if (newList.Count == 0)
                                    break;

                                var skinInfo = newList.GetRandom();
                                newList.Remove(skinInfo);

                                if (skinInfo.Value == null || (skinData.ContainsKey(shortname) && skinData[shortname].ContainsKey(skinInfo.Key)) || string.IsNullOrEmpty(skinInfo.Value.imageUrl))
                                {
                                    i--;
                                    continue;
                                }

                                actualCount++;

                                if (!skinData.ContainsKey(shortname))
                                    skinData.Add(shortname, new Dictionary<ulong, SkinData>());

                                skinData[shortname].Add(skinInfo.Key, new SkinData());

                                if (!HasImage(shortname, skinInfo.Key))
                                {
                                    if (!loadOrder.ContainsKey(shortname))
                                        loadOrder.Add(shortname, new Dictionary<ulong, string>());

                                    if (!loadOrder[shortname].ContainsKey(skinInfo.Key))
                                    {
                                        loadOrder[shortname].Add(skinInfo.Key, skinInfo.Value.imageUrl);
                                        skinCount++;
                                    }
                                }

                                if (skinCount >= 500)
                                {
                                    loadOrderCount++;
                                    Puts($"Creating a skin load order (Order #{loadOrderCount})");
                                    ImageLibrary.Call("ImportItemList", $"{Title} skin icons (Order #{loadOrderCount})", loadOrder);

                                    loadOrder = new Dictionary<string, Dictionary<ulong, string>>();
                                    skinCount = 0;
                                }
                            }

                            if (skinCount > 0)
                            {
                                loadOrderCount++;
                                Puts($"Creating a skin load order (Order #{loadOrderCount})");
                                ImageLibrary.Call("ImportItemList", $"{Title} skin icons (Order #{loadOrderCount})", loadOrder);
                            }

                            SendReply(arg, $"Importing {actualCount} random {shortname} workshop skins to ImageLibrary");
                            SaveSkinData();
                        }
                        else
                        {
                            int amount;
                            if (!int.TryParse(arg.GetString(2), out amount))
                            {
                                SendReply(arg, "You must enter an amount of random skins to import");
                                return;
                            }

                            Dictionary<string, Dictionary<ulong, string>> loadOrder = new Dictionary<string, Dictionary<ulong, string>>();
                            int skinCount = 0;
                            int loadOrderCount = 0;

                            Dictionary<string, Dictionary<ulong, WorkshopItem>> newList = new Dictionary<string, Dictionary<ulong, WorkshopItem>>(workshopItems);

                            for (int i = 0; i < amount; i++)
                            {
                                if (newList.Count == 0)
                                    break;

                                string shortname = newList.Keys.ToArray().GetRandom();
                                var skinInfo = newList[shortname].ToArray().GetRandom();

                                if (skinInfo.Value == null || (skinData.ContainsKey(shortname) && skinData[shortname].ContainsKey(skinInfo.Key)) || string.IsNullOrEmpty(skinInfo.Value.imageUrl))
                                {
                                    i--;
                                    continue;
                                }

                                if (!skinData.ContainsKey(shortname))
                                    skinData.Add(shortname, new Dictionary<ulong, SkinData>());

                                skinData[shortname].Add(skinInfo.Key, new SkinData());

                                if (!HasImage(shortname, skinInfo.Key))
                                {
                                    if (!loadOrder.ContainsKey(shortname))
                                        loadOrder.Add(shortname, new Dictionary<ulong, string>());

                                    if (!loadOrder[shortname].ContainsKey(skinInfo.Key))
                                    {
                                        loadOrder[shortname].Add(skinInfo.Key, skinInfo.Value.imageUrl);
                                        skinCount++;
                                    }
                                }

                                if (skinCount >= 500)
                                {
                                    loadOrderCount++;
                                    Puts($"Creating a skin load order (Order #{loadOrderCount})");
                                    ImageLibrary.Call("ImportItemList", $"{Title} skin icons (Order #{loadOrderCount})", loadOrder);

                                    loadOrder = new Dictionary<string, Dictionary<ulong, string>>();
                                    skinCount = 0;
                                }
                            }

                            if (skinCount > 0)
                            {
                                loadOrderCount++;
                                Puts($"Creating a skin load order (Order #{loadOrderCount})");
                                ImageLibrary.Call("ImportItemList", $"{Title} skin icons (Order #{loadOrderCount})", loadOrder);
                            }

                            SendReply(arg, $"Importing {amount} random workshop skins to ImageLibrary");
                            SaveSkinData();
                        }
                    }
                    else
                    {
                        string shortname = arg.GetString(1).ToLower();
                        if (!ItemManager.itemList.Select(x => x.shortname).Contains(shortname) || !workshopItems.ContainsKey(shortname))
                        {
                            SendReply(arg, "The item shortname you have entered either does not have any skins, or is invalid");
                            return;
                        }

                        ulong skinId = 0U;
                        if (!ulong.TryParse(arg.GetString(2), out skinId) || !workshopItems[shortname].ContainsKey(skinId))
                        {
                            SendReply(arg, "The skin ID you have entered is either invalid or there is no skin with that ID");
                            return;
                        }

                        WorkshopItem workshopItem = workshopItems[shortname][skinId];
                        if (workshopItem == null || string.IsNullOrEmpty(workshopItem.imageUrl))
                        {
                            SendReply(arg, "The specified workshop skin can not be imported");
                            return;
                        }

                        if (!skinData.ContainsKey(shortname))
                            skinData.Add(shortname, new Dictionary<ulong, SkinData>());

                        if (!skinData[shortname].ContainsKey(skinId))
                            skinData[shortname].Add(skinId, new SkinData());

                        if (!HasImage(shortname, skinId))
                        {
                            Dictionary<string, Dictionary<ulong, string>> loadOrder = new Dictionary<string, Dictionary<ulong, string>>
                            {
                                [shortname] = new Dictionary<ulong, string>
                                {
                                    [skinId] = workshopItem.imageUrl
                                }
                            };
                            ImageLibrary.Call("ImportItemList", $"{Title} - {shortname} {skinId}", loadOrder);
                        }

                        SendReply(arg, $"Importing skin ID {skinId} for {shortname} to ImageLibrary!");
                        SaveSkinData();
                    }
                    return;
                case "remove":
                    {
                        string shortname = arg.GetString(1).ToLower();
                        if (!ItemManager.itemList.Select(x => x.shortname).Contains(shortname) || !skinData.ContainsKey(shortname))
                        {
                            SendReply(arg, "The item shortname you have entered either does not have any available skins, or is invalid");
                            return;
                        }

                        ulong skinId = 0U;
                        if (!ulong.TryParse(arg.GetString(2), out skinId) || !skinData[shortname].ContainsKey(skinId))
                        {
                            SendReply(arg, "The skin ID you have entered is either invalid or has not been added to the list of available skins");
                            return;
                        }

                        skinData[shortname][skinId].isDisabled = true;
                        ImageLibrary.Call("RemoveImage", shortname, skinId);

                        SendReply(arg, $"You have removed skin ID {skinId} for {shortname}!");
                        SaveSkinData();
                    }
                    return;
                default:
                    SendReply(arg, "Invalid syntax!");
                    break;
            }
        }

        [ConsoleCommand("playerskins.setprice")]
        private void ccmdSetSkinPrice(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null)
            {
                if (arg.Connection.authLevel < 2)
                {
                    SendReply(arg, "You do not have permission to use this command");
                    return;
                }
            }

            if (arg.Args == null || arg.Args.Length != 2)
            {
                SendReply(arg, "playerskins.setprice <item shortname> <amount> - Set the price for all skins for the specified item");
                SendReply(arg, "playerskins.setprice all <amount> - Set the price for all skins for all items");
                return;
            }

            int amount = 0;
            if (!int.TryParse(arg.GetString(1), out amount))
            {
                SendReply(arg, "You must enter a number to set the price");
                return;
            }

            string shortname = arg.GetString(0);

            if (shortname.ToLower() == "all")
            {
                foreach (var item in skinData.Values)
                {
                    foreach (var skin in item.Values)
                        skin.cost = amount;
                }

                SendReply(arg, $"You have set all skin costs to {amount}");
            }
            else
            {
                Dictionary<ulong, SkinData> data;
                if (!skinData.TryGetValue(shortname, out data))
                {
                    SendReply(arg, $"Either an invalid shortname was entered, or there are no skins for the specified item : {shortname}");
                    return;
                }

                foreach (var skin in data.Values)
                    skin.cost = amount;

                SendReply(arg, $"You have set all {shortname} skin costs to {amount}");
            }

            SaveSkinData();
        }
        #endregion

        #region UI Helper
        const string MainPanel = "PSMainPanel";
        const string SelectPanel = "PSSelectionPanel";
        const string PopupPanel = "PSPopupPanel";
        const string ReskinPanel = "PSReskinPanel";

        private void DestroyUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, MainPanel);
            CuiHelper.DestroyUi(player, SelectPanel);
            CuiHelper.DestroyUi(player, PopupPanel);
            CuiHelper.DestroyUi(player, ReskinPanel);
        }

        public static class UI
        {
            static public CuiElementContainer Container(string panel, string color, UI4 dimensions, bool useCursor = false, string parent = "Overlay")
            {
                CuiElementContainer container = new CuiElementContainer()
                {
                    {
                        new CuiPanel
                        {
                            Image = {Color = color},
                            RectTransform = {AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax()},
                            CursorEnabled = useCursor
                        },
                        new CuiElement().Parent = parent,
                        panel
                    }
                };
                return container;
            }
            static public void Panel(ref CuiElementContainer container, string panel, string color, UI4 dimensions, bool cursor = false)
            {
                container.Add(new CuiPanel
                {
                    Image = { Color = color },
                    RectTransform = { AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() },
                    CursorEnabled = cursor
                },
                panel);
            }
            static public void Label(ref CuiElementContainer container, string panel, string text, int size, UI4 dimensions, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiLabel
                {
                    Text = { FontSize = size, Align = align, Text = text },
                    RectTransform = { AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() }
                },
                panel);

            }
            static public void Button(ref CuiElementContainer container, string panel, string color, string text, int size, UI4 dimensions, string command, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiButton
                {
                    Button = { Color = color, Command = command, FadeIn = 0f },
                    RectTransform = { AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() },
                    Text = { Text = text, FontSize = size, Align = align }
                },
                panel);
            }
            static public void Image(ref CuiElementContainer container, string panel, string png, UI4 dimensions)
            {
                container.Add(new CuiElement
                {
                    Name = CuiHelper.GetGuid(),
                    Parent = panel,
                    Components =
                    {
                        new CuiRawImageComponent {Png = png },
                        new CuiRectTransformComponent {AnchorMin = dimensions.GetMin(), AnchorMax = dimensions.GetMax() }
                    }
                });
            }
            public static string Color(string hexColor, float alpha)
            {
                if (hexColor.StartsWith("#"))
                    hexColor = hexColor.Substring(1);
                int red = int.Parse(hexColor.Substring(0, 2), NumberStyles.AllowHexSpecifier);
                int green = int.Parse(hexColor.Substring(2, 2), NumberStyles.AllowHexSpecifier);
                int blue = int.Parse(hexColor.Substring(4, 2), NumberStyles.AllowHexSpecifier);
                return $"{(double)red / 255} {(double)green / 255} {(double)blue / 255} {alpha}";
            }
        }
        public class UI4
        {
            public float xMin, yMin, xMax, yMax;
            public UI4(float xMin, float yMin, float xMax, float yMax)
            {
                this.xMin = xMin;
                this.yMin = yMin;
                this.xMax = xMax;
                this.yMax = yMax;
            }
            public string GetMin() => $"{xMin} {yMin}";
            public string GetMax() => $"{xMax} {yMax}";
        }
        #endregion

        #region UI Creation
        private void OpenSkinMenu(BasePlayer player, string shortname = "", int column = 0, int page = 0)
        {
            DisplayMode displayMode;
            if (forcedMode == DisplayMode.None)
            {
                UserData data;
                if (userData.TryGetValue(player.userID, out data))
                    displayMode = data.displayMode;
                else displayMode = DisplayMode.Full;
            }
            else displayMode = forcedMode;

            if (displayMode == DisplayMode.Full)
                CreateSelectionMenu(player, shortname, column, page);
            else CreateSmallSelectionMenu(player, shortname, column, page);
        }
        private void CreateSelectionMenu(BasePlayer player, string shortname = "", int column = 0, int page = 0)
        {
            CuiElementContainer container = UI.Container(MainPanel, uiColor[Colors.Background], new UI4(0, 0, 1, 1), true);

            bool adminMode = adminToggle.Contains(player.userID);
            bool ownedMode = ownedToggle.Contains(player.userID);
            UserData data = userData[player.userID];

            int indexCount = 0;
            int columnIndex = column * 20;

            if (columnIndex > 0)
                UI.Button(ref container, MainPanel, uiColor[Colors.Button], msg("UI.Button.Up", player.userID), 12, new UI4(0.02f, 0.92f, 0.14f, 0.95f),
                    $"psui.changepage {(string.IsNullOrEmpty(shortname) ? "empty" : shortname)} {column - 1} {page}");
            if (columnIndex + 20 < skinData.Keys.Count - 1)
                UI.Button(ref container, MainPanel, uiColor[Colors.Button], msg("UI.Button.Down", player.userID), 12, new UI4(0.02f, 0.08f, 0.14f, 0.11f),
                    $"psui.changepage {(string.IsNullOrEmpty(shortname) ? "empty" : shortname)} {column + 1} {page}");

            string[] skinKeys = skinData.Keys.Where(x => !configData.Shop.BlockedItems.Contains(x) && shortnameToDisplayname.ContainsKey(x)).OrderBy(x => shortnameToDisplayname[x]).ToArray();

            for (int i = columnIndex; i < columnIndex + 20; i++)
            {
                if (i > skinKeys.Length - 1)
                    break;

                string itemShortname = skinKeys.ElementAt(i);
                string displayName = shortnameToDisplayname[itemShortname];
                float[] position = GetItemPosition(indexCount);

                UI.Button(ref container, MainPanel, shortname == itemShortname ? uiColor[Colors.ButtonSelected] : uiColor[Colors.Button], displayName, 12, new UI4(position[0], position[1], position[2], position[3]), shortname == itemShortname ? "" : $"psui.changepage {itemShortname} {column} 0");
                indexCount++;
            }

            if (!string.IsNullOrEmpty(shortname))
            {
                int itemCount = 0;
                int itemIndex = 48 * page;

                ulong[] skins = ownedMode ? (data.purchasedSkins.ContainsKey(shortname) ? data.purchasedSkins[shortname].Where(x =>
                    workshopItems.ContainsKey(shortname) &&
                    workshopItems[shortname].ContainsKey(x) &&
                    workshopItems[shortname][x] != null &&
                    skinData.ContainsKey(shortname) &&
                    skinData[shortname].ContainsKey(x) &&
                    !skinData[shortname][x].isDisabled &&
                    HasImage(shortname, x)).ToArray() : new ulong[0]) :
                    skinData[shortname].Where(x =>
                    workshopItems.ContainsKey(shortname) &&
                    workshopItems[shortname].ContainsKey(x.Key) &&
                    !x.Value.isDisabled &&
                    !excludedSkins.Contains(x.Key) &&
                    HasImage(shortname, x.Key)).Select(x => x.Key).ToArray();

                for (int i = itemIndex; i < itemIndex + 48; i++)
                {
                    if (i > skins.Length - 1)
                        break;

                    ulong skinId = skins[i];
                    float[] position = GetButtonPosition(itemCount, 8);

                    UI.Image(ref container, MainPanel, GetImage(shortname, skinId), new UI4(position[0] + 0.01f, position[1], position[2] - 0.01f, position[3] - 0.01f));
                    UI.Button(ref container, MainPanel, "0 0 0 0", "", 0, new UI4(position[0], position[1], position[2] + 0.1f, position[3] - 0.01f), $"psui.selectitem {shortname} {skinId}");

                    itemCount++;
                }

                if (itemIndex > 0)
                    UI.Button(ref container, MainPanel, uiColor[Colors.Button], msg("UI.Button.Previous", player.userID), 12, new UI4(0.17f, 0.04f, 0.27f, 0.07f), $"psui.changepage {(string.IsNullOrEmpty(shortname) ? "empty" : shortname)} {column} {page - 1}");
                if (itemIndex + 48 < skinData[shortname].Where(x => !x.Value.isDisabled).Count())
                    UI.Button(ref container, MainPanel, uiColor[Colors.Button], msg("UI.Button.Next", player.userID), 12, new UI4(0.87f, 0.04f, 0.97f, 0.07f), $"psui.changepage {(string.IsNullOrEmpty(shortname) ? "empty" : shortname)} {column} {page + 1}");
            }
            else UI.Label(ref container, MainPanel, FormatHelpText(DisplayMode.Full, player.userID), 12, new UI4(0.17f, 0.1f, 0.97f, 0.92f), TextAnchor.UpperLeft);

            UI.Button(ref container, MainPanel, uiColor[Colors.ButtonSelected], msg("UI.Exit", player.userID), 12, new UI4(0.02f, 0.04f, 0.14f, 0.07f), "psui.exit");

            UI.Button(ref container, MainPanel, ownedMode ? uiColor[Colors.ButtonSelected] : uiColor[Colors.Button], msg("UI.ShowOwned", player.userID), 12, new UI4(0.76f, 0.04f, 0.86f, 0.07f),
                $"psui.toggle owned {(string.IsNullOrEmpty(shortname) ? "empty" : shortname)} {column} 0");

            if (forcedMode == DisplayMode.None)
                UI.Button(ref container, MainPanel, uiColor[Colors.Button], msg("UI.Minimised", player.userID), 12, new UI4(0.65f, 0.04f, 0.75f, 0.07f),
                   $"psui.toggle size {(string.IsNullOrEmpty(shortname) ? "empty" : shortname)} {column} {page}");

            if (HasPermission(player, "admin"))
                UI.Button(ref container, MainPanel, adminMode ? uiColor[Colors.ButtonSelected] : uiColor[Colors.Button], msg("UI.AdminMode", player.userID), 12, new UI4(0.28f, 0.04f, 0.38f, 0.07f),
                   $"psui.toggle admin {(string.IsNullOrEmpty(shortname) ? "empty" : shortname)} {column} 0");

            if (configData.Purchase.Enabled)
            {
                UI.Panel(ref container, MainPanel, uiColor[Colors.Panel], new UI4(0.39f, 0.04f, 0.64f, 0.07f));
                UI.Label(ref container, MainPanel, string.Format((purchaseType == TokenType.ServerRewards ? msg("Money.RP", player.userID) : msg("Money.Eco", player.userID)), GetBalance(player.userID)), 12, new UI4(0.38f, 0.04f, 0.65f, 0.07f));
            }

            CuiHelper.DestroyUi(player, PopupPanel);
            CuiHelper.DestroyUi(player, MainPanel);
            CuiHelper.AddUi(player, container);
        }

        private void CreateSmallSelectionMenu(BasePlayer player, string shortname = "", int column = 0, int page = 0)
        {
            CuiElementContainer container = UI.Container(MainPanel, uiColor[Colors.Background], new UI4(0.2f, 0.12f, 0.45f, 0.92f), true);

            bool adminMode = adminToggle.Contains(player.userID);
            bool ownedMode = ownedToggle.Contains(player.userID);
            UserData data = userData[player.userID];

            int indexCount = 0;
            int columnIndex = column * 20;

            if (columnIndex > 0)
                UI.Button(ref container, MainPanel, uiColor[Colors.Button], msg("UI.Button.Up", player.userID), 10, new UI4(0.04f, 0.92f, 0.5f, 0.95f),
                    $"psui.changepage {(string.IsNullOrEmpty(shortname) ? "empty" : shortname)} {column - 1} {page}");
            if (columnIndex + 20 < skinData.Keys.Count - 1)
                UI.Button(ref container, MainPanel, uiColor[Colors.Button], msg("UI.Button.Down", player.userID), 10, new UI4(0.04f, 0.08f, 0.5f, 0.11f),
                    $"psui.changepage {(string.IsNullOrEmpty(shortname) ? "empty" : shortname)} {column + 1} {page}");

            string[] skinKeys = skinData.Keys.Where(x => !configData.Shop.BlockedItems.Contains(x)).OrderBy(x => shortnameToDisplayname[x]).ToArray();

            for (int i = columnIndex; i < columnIndex + 20; i++)
            {
                if (i > skinKeys.Length - 1)
                    break;

                string itemShortname = skinKeys.ElementAt(i);
                string displayName = shortnameToDisplayname[itemShortname];
                float[] position = GetItemPosition(indexCount, 0.04f, 0.88f, 0.46f, 0.04f);

                UI.Button(ref container, MainPanel, shortname == itemShortname ? uiColor[Colors.ButtonSelected] : uiColor[Colors.Button], displayName, 10, new UI4(position[0], position[1], position[2], position[3]), shortname == itemShortname ? "" : $"psui.changepage {itemShortname} {column} 0");
                indexCount++;
            }

            if (!string.IsNullOrEmpty(shortname))
            {
                int itemCount = 0;
                int itemIndex = 5 * page;

                ulong[] skins = ownedMode ? (data.purchasedSkins.ContainsKey(shortname) ? data.purchasedSkins[shortname].Where(x =>
                    workshopItems.ContainsKey(shortname) &&
                    workshopItems[shortname].ContainsKey(x) &&
                    workshopItems[shortname][x] != null &&
                    skinData.ContainsKey(shortname) &&
                    skinData[shortname].ContainsKey(x) &&
                    !skinData[shortname][x].isDisabled &&
                    HasImage(shortname, x)).ToArray() : new ulong[0]) :
                    skinData[shortname].Where(x =>
                    workshopItems.ContainsKey(shortname) &&
                    workshopItems[shortname].ContainsKey(x.Key) &&
                    !x.Value.isDisabled &&
                    !excludedSkins.Contains(x.Key) &&
                    HasImage(shortname, x.Key)).Select(x => x.Key).ToArray();

                for (int i = itemIndex; i < itemIndex + 5; i++)
                {
                    if (i > skins.Length - 1)
                        break;

                    ulong skinId = skins[i];
                    float[] position = GetButtonPosition(itemCount, 1, 0.5f, 0.5f, 0.8f, 0.18f);

                    UI.Image(ref container, MainPanel, GetImage(shortname, skinId), new UI4(position[0] + 0.05f, position[1], position[2] - 0.05f, position[3] - 0.01f));
                    UI.Button(ref container, MainPanel, "0 0 0 0", "", 0, new UI4(position[0], position[1], position[2] + 0.1f, position[3] - 0.01f), $"psui.selectitem {shortname} {skinId}");

                    itemCount++;
                }

                if (itemIndex > 0)
                    UI.Button(ref container, MainPanel, uiColor[Colors.Button], msg("UI.Button.Previous", player.userID), 10, new UI4(0.53f, 0.04f, 0.73f, 0.07f), $"psui.changepage {(string.IsNullOrEmpty(shortname) ? "empty" : shortname)} {column} {page - 1}");
                if (itemIndex + 5 < skinData[shortname].Where(x => !x.Value.isDisabled).Count())
                    UI.Button(ref container, MainPanel, uiColor[Colors.Button], msg("UI.Button.Next", player.userID), 10, new UI4(0.77f, 0.04f, 0.97f, 0.07f), $"psui.changepage {(string.IsNullOrEmpty(shortname) ? "empty" : shortname)} {column} {page + 1}");
            }
            else UI.Label(ref container, MainPanel, FormatHelpText(DisplayMode.Minimalist, player.userID), 10, new UI4(0.53f, 0.1f, 0.97f, 0.92f), TextAnchor.UpperLeft);

            UI.Button(ref container, MainPanel, uiColor[Colors.ButtonSelected], msg("UI.Exit", player.userID), 10, new UI4(0.04f, 0.04f, 0.5f, 0.07f), "psui.exit");

            if (forcedMode == DisplayMode.None)
                UI.Button(ref container, MainPanel, uiColor[Colors.Button], msg("UI.FullScreen", player.userID), 10, new UI4(0.53f, 0.005f, 0.73f, 0.035f),
                $"psui.toggle size {(string.IsNullOrEmpty(shortname) ? "empty" : shortname)} {column} 0");

            UI.Button(ref container, MainPanel, ownedMode ? uiColor[Colors.ButtonSelected] : uiColor[Colors.Button], msg("UI.ShowOwned", player.userID), 10, new UI4(0.77f, 0.005f, 0.97f, 0.035f),
                $"psui.toggle owned {(string.IsNullOrEmpty(shortname) ? "empty" : shortname)} {column} 0");

            if (HasPermission(player, "admin"))
                UI.Button(ref container, MainPanel, adminMode ? uiColor[Colors.ButtonSelected] : uiColor[Colors.Button], msg("UI.AdminMode", player.userID), 10, new UI4(0.04f, 0.005f, 0.24f, 0.035f),
                    $"psui.toggle admin {(string.IsNullOrEmpty(shortname) ? "empty" : shortname)} {column} {page}");

            if (configData.Purchase.Enabled)
            {
                UI.Panel(ref container, MainPanel, uiColor[Colors.Panel], new UI4(0, 0.97f, 1, 1));
                UI.Label(ref container, MainPanel, string.Format((purchaseType == TokenType.ServerRewards ? msg("Money.RP", player.userID) : msg("Money.Eco", player.userID)), GetBalance(player.userID)), 10, new UI4(0, 0.97f, 1, 1));
            }

            CuiHelper.DestroyUi(player, PopupPanel);
            CuiHelper.DestroyUi(player, MainPanel);
            CuiHelper.AddUi(player, container);
        }

        private void CreateItemPopup(BasePlayer player, string shortname, ulong skinId)
        {
            CuiElementContainer container = UI.Container(PopupPanel, uiColor[Colors.Panel], new UI4(0.45f, 0.24f, 0.65f, 0.66f), true);
            UI.Panel(ref container, PopupPanel, uiColor[Colors.Background], new UI4(0.01f, 0.01f, 0.99f, 0.99f));

            UserData data = userData[player.userID];

            bool isOwned = data.IsOwned(shortname, skinId);
            int skinCost = HasPermission(player, "nocharge") ? 0 : skinData[shortname][skinId].cost;

            WorkshopItem workshopItem = workshopItems[shortname][skinId];

            UI.Image(ref container, PopupPanel, GetImage(shortname, skinId), new UI4(0.1f, 0.4f, 0.9f, 0.95f));
            UI.Label(ref container, PopupPanel, workshopItem.title, 13, new UI4(0.05f, 0.32f, 0.95f, 0.395f));

            if (isOwned)
            {
                if (configData.Shop.SellSkins)
                    UI.Button(ref container, PopupPanel, uiColor[Colors.Button], string.Format(msg("UI.Popup.SellSkin", player.userID), skinCost), 12, new UI4(0.1f, 0.21f, 0.9f, 0.28f), $"psui.sellskin {shortname} {skinId}");

                UI.Button(ref container, PopupPanel, data.IsDefaultSkin(shortname, skinId) ? uiColor[Colors.ButtonSelected] : uiColor[Colors.Button], data.IsDefaultSkin(shortname, skinId) ? msg("UI.Popup.RemoveDefault", player.userID) : msg("UI.Popup.SetDefault", player.userID), 12, new UI4(0.1f, 0.13f, 0.9f, 0.2f), $"psui.setdefault {shortname} {skinId}");
            }

            UI.Button(ref container, PopupPanel, uiColor[Colors.ButtonSelected], isOwned ? msg("UI.Popup.Owned", player.userID) :
                !string.IsNullOrEmpty(skinData[shortname][skinId].permission) && !HasPermission(player, skinData[shortname][skinId].permission) ? msg("UI.Popup.VIP", player.userID) :
                (configData.Purchase.Enabled ? GetBalance(player.userID) >= skinCost ? string.Format(msg("UI.Popup.Purchase", player.userID), skinCost) :
                string.Format(msg("UI.Popup.Insufficient", player.userID), skinCost) :
                msg("UI.Popup.Claim", player.userID)), 12, new UI4(0.1f, 0.05f, 0.9f, 0.12f), isOwned || (!string.IsNullOrEmpty(skinData[shortname][skinId].permission) && !HasPermission(player, skinData[shortname][skinId].permission)) ? "" : $"psui.purchase {shortname} {skinId}");

            UI.Button(ref container, PopupPanel, uiColor[Colors.ButtonSelected], msg("UI.Popup.Exit", player.userID), 12, new UI4(0.91f, 0.92f, 0.98f, 0.98f), "psui.exitpopup");

            if (adminToggle.Contains(player.userID))
                CreateAdminPopup(ref container, shortname, skinId, player.userID);

            CuiHelper.DestroyUi(player, PopupPanel);
            CuiHelper.AddUi(player, container);
        }

        private void CreateAdminPopup(ref CuiElementContainer container, string shortname, ulong skinId, ulong playerId)
        {
            UI.Panel(ref container, PopupPanel, uiColor[Colors.Panel], new UI4(1f, 0f, 1.5f, 1f));
            UI.Panel(ref container, PopupPanel, uiColor[Colors.Background], new UI4(1f, 0.01f, 1.49f, 0.99f));

            UI.Label(ref container, PopupPanel, string.Format(msg("UI.Admin.Cost", playerId), skinData[shortname][skinId].cost), 12, new UI4(1.01f, 0.9f, 1.27f, 0.96f), TextAnchor.MiddleLeft);
            UI.Button(ref container, PopupPanel, uiColor[Colors.ButtonSelected], msg("UI.Admin.Up", playerId), 12, new UI4(1.27f, 0.905f, 1.37f, 0.955f), $"psui.setprice {shortname} {skinId} {skinData[shortname][skinId].cost - 1}");
            UI.Button(ref container, PopupPanel, uiColor[Colors.ButtonSelected], msg("UI.Admin.Down", playerId), 12, new UI4(1.38f, 0.905f, 1.48f, 0.955f), $"psui.setprice {shortname} {skinId} {skinData[shortname][skinId].cost + 1}");

            UI.Label(ref container, PopupPanel, msg("UI.Admin.Permission", playerId), 12, new UI4(1.01f, 0.81f, 1.48f, 0.9f), TextAnchor.MiddleLeft);

            for (int i = 0; i < configData.Shop.Permissions.Length; i++)
            {
                string permission = configData.Shop.Permissions[i];
                bool hasPermission = skinData[shortname][skinId].permission == permission;

                UI.Button(ref container, PopupPanel, hasPermission ? uiColor[Colors.ButtonSelected] : uiColor[Colors.Button], permission, 12, new UI4(1.01f, 0.81f - (0.07f * i) - 0.06f, 1.48f, 0.81f - (0.07f * i)), $"psui.setpermission {shortname} {skinId} {permission}");
            }

            UI.Button(ref container, PopupPanel, uiColor[Colors.ButtonSelected], msg("UI.Admin.Delete", playerId), 12, new UI4(1.01f, 0.05f, 1.48f, 0.12f), $"psui.remove {shortname} {skinId}");
        }

        private void CreateReskinMenu(BasePlayer player, int page = 0)
        {
            Item item = player.GetActiveItem();
            if (item == null)
            {
                item = player.inventory.containerBelt.GetSlot(0);
                if (item == null)
                {
                    SendReply(player, msg("Chat.Reskin.NoItem2", player.userID));
                    return;
                }
            }

            string shortname = item.info.shortname;

            if (!skinData.ContainsKey(item.info.shortname) || skinData[item.info.shortname].Count == 0)
            {
                SendReply(player, msg("Chat.Reskin.NoSkins", player.userID));
                return;
            }

            UserData data;
            if (!userData.TryGetValue(player.userID, out data))
            {
                SendReply(player, msg("Chat.Reskin.NoPurchases", player.userID));
                return;
            }

            CuiElementContainer container = UI.Container(ReskinPanel, uiColor[Colors.Background], new UI4(0.35f, 0.15f, 0.65f, 0.4f), true);
            UI.Panel(ref container, ReskinPanel, uiColor[Colors.Panel], new UI4(0, 0.86f, 1, 1));
            UI.Label(ref container, ReskinPanel, string.Format(msg("UI.Reskin.SkinList", player.userID), shortnameToDisplayname[item.info.shortname]), 12, new UI4(0.1f, 0.86f, 0.9f, 1f));

            UI.Button(ref container, ReskinPanel, uiColor[Colors.ButtonSelected], "✘", 12, new UI4(0.93f, 0.88f, 0.99f, 0.98f), "psui.exit");

            List<ulong> skinList;
            if (data.purchasedSkins.TryGetValue(item.info.shortname, out skinList))
            {
                skinList = skinList.Where(x =>
                    workshopItems.ContainsKey(shortname) &&
                    workshopItems[shortname].ContainsKey(x) &&
                    workshopItems[shortname][x] != null &&
                    skinData.ContainsKey(shortname) &&
                    skinData[shortname].ContainsKey(x) &&
                    !skinData[shortname][x].isDisabled &&
                    HasImage(shortname, x)).ToList();

                int itemIndex = page * 8;
                int itemCount = 0;

                for (int i = itemIndex; i < itemIndex + 8; i++)
                {
                    if (i > skinList.Count - 1)
                        break;

                    ulong skinId = skinList[i];

                    if (HasImage(item.info.shortname, skinId))
                    {
                        float[] position = GetButtonPosition(itemCount, 4, 0.05f, 0.225f, 0.425f, 0.4f);

                        UI.Image(ref container, ReskinPanel, GetImage(item.info.shortname, skinId), new UI4(position[0] + 0.005f, position[1], position[2] - 0.005f, position[3]));
                        UI.Button(ref container, ReskinPanel, "0 0 0 0", "", 0, new UI4(position[0], position[1], position[2], position[3]), $"psui.reskinitem {skinId}");
                    }
                    itemCount++;
                }
                UI.Panel(ref container, ReskinPanel, uiColor[Colors.Panel], new UI4(0, -0.1f, 1, 0));
                if (page > 0)
                    UI.Button(ref container, ReskinPanel, uiColor[Colors.ButtonSelected], msg("UI.Button.Previous", player.userID), 12, new UI4(0, -0.1f, 0.25f, 0), $"psui.changeskinpage {page - 1}");
                if (itemIndex + 8 < skinList.Count)
                    UI.Button(ref container, ReskinPanel, uiColor[Colors.ButtonSelected], msg("UI.Button.Next", player.userID), 12, new UI4(0.75f, -0.1f, 1, 0), $"psui.changeskinpage {page + 1}");
            }
            else UI.Label(ref container, ReskinPanel, msg("Chat.Reskin.NoPurchases", player.userID), 15, new UI4(0, 0.2f, 1, 0.8f));

            CuiHelper.DestroyUi(player, ReskinPanel);
            CuiHelper.AddUi(player, container);
        }

        #region UI Functions
        private float[] GetItemPosition(int number, float offsetx = 0.02f, float offsety = 0.88f, float width = 0.12f, float height = 0.04f)
        {
            float offsetX = offsetx;
            float offsetY = offsety - (number * height);

            return new float[] { offsetX, offsetY, offsetX + width, offsetY + (height - 0.01f) };
        }

        private float[] GetButtonPosition(int number, int rows = 8, float xOffset = 0.15f, float width = 0.1f, float yOffset = 0.8f, float height = 0.14f)
        {
            int rowNumber = number == 0 ? 0 : RowNumber(rows, number);
            int columnNumber = number - (rowNumber * rows);

            float offsetX = xOffset + (width * columnNumber);
            float offsetY = (yOffset - (rowNumber * height));

            return new float[] { offsetX, offsetY, offsetX + width, offsetY + height };
        }

        private int RowNumber(int max, int count) => Mathf.FloorToInt(count / max);

        private int GetBalance(ulong playerId)
        {
            object success = null;
            if (purchaseType == TokenType.ServerRewards)
            {
                success = ServerRewards?.Call("CheckPoints", playerId);
                if (success is int)
                    return (int)success;
            }
            else
            {
                success = Economics?.Call("Balance", playerId);
                if (success is double)
                    return Convert.ToInt32(success);
            }

            return 0;
        }

        private bool TakeMoney(ulong playerId, int amount)
        {
            object success = null;
            if (purchaseType == TokenType.ServerRewards)
            {
                success = ServerRewards?.Call("TakePoints", playerId, amount);
                if (success is bool)
                    return (bool)success;
            }
            else
            {
                success = Economics?.Call("Withdraw", playerId, (double)amount);
                if (success is bool)
                    return (bool)success;
            }

            return false;
        }

        private void GiveMoney(ulong playerId, int amount)
        {
            if (purchaseType == TokenType.ServerRewards)
                ServerRewards?.Call("AddPoints", playerId, amount);
            else Economics?.Call("Deposit", playerId, (double)amount);
        }

        private string FormatHelpText(DisplayMode displayMode, ulong playerId)
        {
            if (displayMode == DisplayMode.Full)
            {
                return string.Format(msg("Help.Text.Full", playerId), purchaseType == TokenType.ServerRewards ? msg("Help.Text.RP", playerId) : msg("Help.Text.Eco", playerId), configData.Reskin.DisableCommand ? msg("Help.Text.Reskin.NPC", playerId) : msg("Help.Text.Reskin.Command", playerId));
            }
            else
            {
                return string.Format(msg("Help.Text.Small", playerId), purchaseType == TokenType.ServerRewards ? msg("Help.Text.RP", playerId) : msg("Help.Text.Eco", playerId), configData.Reskin.DisableCommand ? msg("Help.Text.Reskin.NPC", playerId) : msg("Help.Text.Reskin.Command", playerId));
            }
        }
        #endregion

        #region UI Commands
        [ConsoleCommand("psui.changepage")]
        private void ccmdChangePage(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            OpenSkinMenu(player, arg.GetString(0) == "empty" ? string.Empty : arg.GetString(0), arg.GetInt(1), arg.GetInt(2));
        }

        [ConsoleCommand("psui.changeskinpage")]
        private void ccmdChangeSkinPage(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            CreateReskinMenu(player, arg.GetInt(0));
        }

        [ConsoleCommand("psui.reskinitem")]
        private void ccmdChangeItemSkin(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            ChangeItemSkin(player, arg.GetUInt64(0));
            CuiHelper.DestroyUi(player, ReskinPanel);
        }

        [ConsoleCommand("psui.selectitem")]
        private void ccmdSelectItem(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            CreateItemPopup(player, arg.GetString(0), arg.GetUInt64(1));
        }

        [ConsoleCommand("psui.exit")]
        private void ccmdExit(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            DestroyUI(player);

            if (configData.Shop.HelpOnExit)
            {
                if (configData.Reskin.DisableCommand)
                    SendReply(player, msg("Help.Reskin.NPC", player.userID));
                else SendReply(player, msg("Help.Reskin.Command", player.userID));
            }
        }

        [ConsoleCommand("psui.exitpopup")]
        private void ccmdExitPopup(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            CuiHelper.DestroyUi(player, PopupPanel);
        }

        [ConsoleCommand("psui.remove")]
        private void ccmdRemoveSkin(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            string shortname = arg.GetString(0);
            ulong skinId = arg.GetUInt64(1);
            skinData[shortname][skinId].isDisabled = true;

            ImageLibrary.Call("RemoveImage", shortname, skinId);

            SaveSkinData();

            OpenSkinMenu(player, shortname, 0, 0);
        }

        [ConsoleCommand("psui.sellskin")]
        private void ccmdSellSkin(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            string shortname = arg.GetString(0);
            ulong skinId = arg.GetUInt64(1);

            UserData data = userData[player.userID];
            data.purchasedSkins[shortname].Remove(skinId);

            if (data.IsDefaultSkin(shortname, skinId))
                data.defaultSkins.Remove(shortname);

            if (!HasPermission(player, "nocharge"))
                GiveMoney(player.userID, skinData[shortname][skinId].cost);

            CreateItemPopup(player, shortname, skinId);
        }

        [ConsoleCommand("psui.setprice")]
        private void ccmdSetPrice(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            string shortname = arg.GetString(0);
            ulong skinId = arg.GetUInt64(1);
            int amount = Mathf.Clamp(arg.GetInt(2), 0, int.MaxValue);

            skinData[shortname][skinId].cost = amount;

            SaveSkinData();

            CreateItemPopup(player, shortname, skinId);
        }

        [ConsoleCommand("psui.setpermission")]
        private void ccmdSetPermission(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            string shortname = arg.GetString(0);
            ulong skinId = arg.GetUInt64(1);
            string permission = arg.GetString(2);

            if (skinData[shortname][skinId].permission == permission)
                skinData[shortname][skinId].permission = string.Empty;
            else skinData[shortname][skinId].permission = permission;

            SaveSkinData();

            CreateItemPopup(player, shortname, skinId);
        }

        [ConsoleCommand("psui.setdefault")]
        private void ccmdSetDefault(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            string shortname = arg.GetString(0);
            ulong skinId = arg.GetUInt64(1);

            UserData data = userData[player.userID];

            if (!data.defaultSkins.ContainsKey(shortname))
                data.defaultSkins.Add(shortname, skinId);
            else
            {
                if (data.defaultSkins[shortname] == skinId)
                    data.defaultSkins.Remove(shortname);
                else data.defaultSkins[shortname] = skinId;
            }

            CreateItemPopup(player, shortname, skinId);
        }

        [ConsoleCommand("psui.purchase")]
        private void ccmdPurchase(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            string shortname = arg.GetString(0);
            ulong skinId = arg.GetUInt64(1);
            int cost = HasPermission(player, "nocharge") ? 0 : skinData[shortname][skinId].cost;

            UserData data = userData[player.userID];
            if (configData.Purchase.Enabled && cost > GetBalance(player.userID))
                return;
            else
            {
                if (configData.Shop.GiveItemOnPurchase)
                {
                    Item item = ItemManager.CreateByName(shortname, 1, skinId);
                    player.GiveItem(item, BaseEntity.GiveItemReason.PickedUp);
                    DestroyUI(player);
                    return;
                }
                else
                {
                    if (!configData.Purchase.Enabled || TakeMoney(player.userID, cost))
                    {
                        if (!data.purchasedSkins.ContainsKey(shortname))
                            data.purchasedSkins.Add(shortname, new List<ulong>());

                        if (!data.purchasedSkins[shortname].Contains(skinId))
                            data.purchasedSkins[shortname].Add(skinId);
                    }
                }
            }

            CreateItemPopup(player, shortname, skinId);
        }

        [ConsoleCommand("psui.toggle")]
        private void ccmdToggleAdmin(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            switch (arg.GetString(0))
            {
                case "admin":
                    if (adminToggle.Contains(player.userID))
                        adminToggle.Remove(player.userID);
                    else adminToggle.Add(player.userID);
                    break;
                case "owned":
                    if (ownedToggle.Contains(player.userID))
                        ownedToggle.Remove(player.userID);
                    else ownedToggle.Add(player.userID);
                    break;
                case "size":
                    UserData data;
                    if (userData.TryGetValue(player.userID, out data))
                        data.displayMode = (data.displayMode == DisplayMode.Full ? data.displayMode = DisplayMode.Minimalist : data.displayMode = DisplayMode.Full);
                    break;
                default:
                    break;
            }

            OpenSkinMenu(player, arg.GetString(1) == "empty" ? "" : arg.GetString(1), arg.GetInt(2), arg.GetInt(3));
        }
        #endregion
        #endregion

        #region Config           
        public enum Colors { Background, Panel, Button, ButtonSelected }
        public enum DisplayMode { None, Full, Minimalist }

        private ConfigData configData;
        private class ConfigData
        {
            [JsonProperty(PropertyName = "Announcement Options")]
            public AnnouncementOptions Announcements { get; set; }
            [JsonProperty(PropertyName = "Purchase Options")]
            public PurchaseOptions Purchase { get; set; }
            [JsonProperty(PropertyName = "Skin Shop Options")]
            public ShopOptions Shop { get; set; }
            [JsonProperty(PropertyName = "Re-skin Options")]
            public ReskinOptions Reskin { get; set; }
            [JsonProperty(PropertyName = "Workshop Options")]
            public WorkshopOptions Workshop { get; set; }
            [JsonProperty(PropertyName = "UI Options")]
            public UIOptions UI { get; set; }

            public class AnnouncementOptions
            {
                [JsonProperty(PropertyName = "Display help information to players")]
                public bool Enabled { get; set; }
                [JsonProperty(PropertyName = "Information display interval (minutes)")]
                public int Interval { get; set; }
            }
            public class PurchaseOptions
            {
                [JsonProperty(PropertyName = "Enable purchase system")]
                public bool Enabled { get; set; }
                [JsonProperty(PropertyName = "Plugin used to purchase skins (ServerRewards, Economics)")]
                public string Type { get; set; }
            }
            public class ShopOptions
            {
                [JsonProperty(PropertyName = "Custom permissions which can be assigned to skins")]
                public string[] Permissions { get; set; }
                [JsonProperty(PropertyName = "NPC user IDs that players can interact with to open the skin shop")]
                public string[] NPCs { get; set; }
                [JsonProperty(PropertyName = "Disable the '/skin shop' command and force players to access it via a NPC")]
                public bool DisableCommand { get; set; }
                [JsonProperty(PropertyName = "Allow players to sell unwanted skins back to the skin store")]
                public bool SellSkins { get; set; }
                [JsonProperty(PropertyName = "Give player the item when they purchase a skin (this disables the reskin menu)")]
                public bool GiveItemOnPurchase { get; set; }
                [JsonProperty(PropertyName = "Forced display mode for skin shop (Full, Minimalist, None)")]
                public string ForcedMode { get; set; }
                [JsonProperty(PropertyName = "Send a help message to players when exiting the skin shop")]
                public bool HelpOnExit { get; set; }
                [JsonProperty(PropertyName = "List of shortnames for items to be blocked from appearing in the skin shop")]
                public string[] BlockedItems { get; set; }
            }
            public class ReskinOptions
            {
                [JsonProperty(PropertyName = "NPC user IDs that players can interact with to open the re-skin menu")]
                public string[] NPCs { get; set; }
                [JsonProperty(PropertyName = "Disable the '/skin' command and force players to access it via a NPC")]
                public bool DisableCommand { get; set; }
            }
            public class WorkshopOptions
            {
                [JsonProperty(PropertyName = "Disable approved skins from the skin shop")]
                public bool ApprovedDisabled { get; set; }
                [JsonProperty(PropertyName = "Enable workshop skins in the skin shop")]
                public bool Enabled { get; set; }
                [JsonProperty(PropertyName = "Word filter for workshop skins. If the skin title partially contains any of these words it will not be available as a potential skin")]
                public string[] Filter { get; set; }
                [JsonProperty(PropertyName = "Force image URLs to use HTTP instead of HTTPS")]
                public bool ForceHTTP { get; set; }
                [JsonProperty(PropertyName = "Steam API key (get one here https://steamcommunity.com/dev/apikey)")]
                public string SteamAPIKey { get; set; }

            }
            public class UIOptions
            {
                [JsonProperty(PropertyName = "UI Colors")]
                public Dictionary<Colors, UIColor> Colors { get; set; }
                public class UIColor
                {
                    [JsonProperty(PropertyName = "Color (hex)")]
                    public string Color { get; set; }
                    [JsonProperty(PropertyName = "Alpha (0.0 - 1.0)")]
                    public float Alpha { get; set; }
                }
            }

            public VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();

            if (configData.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                Announcements = new ConfigData.AnnouncementOptions
                {
                    Enabled = true,
                    Interval = 10
                },
                Reskin = new ConfigData.ReskinOptions
                {
                    DisableCommand = false,
                    NPCs = new string[0]
                },
                Shop = new ConfigData.ShopOptions
                {
                    BlockedItems = new string[0],
                    DisableCommand = false,
                    ForcedMode = "None",
                    GiveItemOnPurchase = false,
                    NPCs = new string[0],
                    Permissions = new string[] { "vip1", "vip2", "vip3" },
                    SellSkins = true,
                    HelpOnExit = true
                },
                Purchase = new ConfigData.PurchaseOptions
                {
                    Type = "ServerRewards",
                    Enabled = false
                },
                Workshop = new ConfigData.WorkshopOptions
                {
                    ApprovedDisabled = false,
                    Enabled = true,
                    Filter = new string[0],
                    ForceHTTP = false,
                    SteamAPIKey = string.Empty
                },
                UI = new ConfigData.UIOptions
                {
                    Colors = new Dictionary<Colors, ConfigData.UIOptions.UIColor>
                    {
                        [Colors.Background] = new ConfigData.UIOptions.UIColor { Alpha = 0.7f, Color = "#2b2b2b" },
                        [Colors.Panel] = new ConfigData.UIOptions.UIColor { Alpha = 1f, Color = "#545554" },
                        [Colors.Button] = new ConfigData.UIOptions.UIColor { Alpha = 1f, Color = "#393939" },
                        [Colors.ButtonSelected] = new ConfigData.UIOptions.UIColor { Alpha = 1f, Color = "#d85540" }
                    }
                },
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();

            if (configData.Version < new VersionNumber(2, 0, 1))
                configData.Shop.HelpOnExit = baseConfig.Shop.HelpOnExit;

            if (configData.Version < new VersionNumber(2, 0, 7))
                configData.Shop.BlockedItems = new string[0];

            if (configData.Version < new VersionNumber(2, 0, 10))
                configData.Workshop.SteamAPIKey = string.Empty;

            if (configData.Version < new VersionNumber(2, 0, 16))
                configData.Workshop.Enabled = true;

            configData.Version = Version;
            PrintWarning("Config update completed!");
        }

        #endregion

        #region Data Management
        private void SaveUserData() => userdata.WriteObject(userData);

        private void SaveSkinData() => skindata.WriteObject(skinData);

        private void LoadData()
        {
            try
            {
                userData = userdata.ReadObject<Dictionary<ulong, UserData>>();
            }
            catch
            {
                userData = new Dictionary<ulong, UserData>();
            }
            try
            {
                skinData = skindata.ReadObject<Dictionary<string, Dictionary<ulong, SkinData>>>();
            }
            catch
            {
                skinData = new Dictionary<string, Dictionary<ulong, SkinData>>();
            }
            try
            {
                excludedSkins = excludeddata.ReadObject<List<ulong>>();
            }
            catch
            {
                excludedSkins = new List<ulong>();
            }
        }

        private class SkinData
        {
            public string permission = string.Empty;
            public int cost = 1;
            public bool isDisabled = false;
        }

        private class UserData
        {
            public Dictionary<string, ulong> defaultSkins = new Dictionary<string, ulong>();
            public Dictionary<string, List<ulong>> purchasedSkins = new Dictionary<string, List<ulong>>();
            public DisplayMode displayMode = DisplayMode.Minimalist;

            public UserData() { }

            public bool IsDefaultSkin(string shortname, ulong skinId)
            {
                if (!defaultSkins.ContainsKey(shortname))
                    return false;

                if (defaultSkins[shortname] == skinId)
                    return true;

                return false;
            }

            public bool IsOwned(string shortname, ulong skinId)
            {
                if (!purchasedSkins.ContainsKey(shortname))
                    return false;

                if (purchasedSkins[shortname].Contains(skinId))
                    return true;

                return false;
            }
        }

        #region Response To Class
        private class WorkshopItem
        {
            public string title;
            public string description;
            public string imageUrl;

            public WorkshopItem() { }

            public WorkshopItem(PublishedFileDetails item)
            {
                if (item == null)
                    return;

                title = item.title;
                description = item.file_description;
                imageUrl = forceHttp ? item.preview_url.Replace("https", "http") : item.preview_url;
            }

            public WorkshopItem(PublishedFileQueryDetail item)
            {
                if (item == null)
                    return;

                title = item.title;
                description = item.description;
                imageUrl = forceHttp ? item.preview_url.Replace("https", "http") : item.preview_url;
            }     
            
            public WorkshopItem(InventoryDef item, string url)
            {
                if (item == null)
                    return;

                title = item.Name;
                description = item.Description;
                imageUrl = url == null ? string.Empty : (forceHttp ? url.Replace("https", "http") : url);
            }
        }

        public class QueryResponse
        {
            public Response response;
        }

        public class Response
        {
            public int total;
            public PublishedFileDetails[] publishedfiledetails;
        }

        public class PublishedFileDetails
        {
            public int result;
            public string publishedfileid;
            public string creator;
            public int creator_appid;
            public int consumer_appid;
            public int consumer_shortcutid;
            public string filename;
            public string file_size;
            public string preview_file_size;
            public string file_url;
            public string preview_url;
            public string url;
            public string hcontent_file;
            public string hcontent_preview;
            public string title;
            public string file_description;
            public int time_created;
            public int time_updated;
            public int visibility;
            public int flags;
            public bool workshop_file;
            public bool workshop_accepted;
            public bool show_subscribe_all;
            public int num_comments_public;
            public bool banned;
            public string ban_reason;
            public string banner;
            public bool can_be_deleted;
            public string app_name;
            public int file_type;
            public bool can_subscribe;
            public int subscriptions;
            public int favorited;
            public int followers;
            public int lifetime_subscriptions;
            public int lifetime_favorited;
            public int lifetime_followers;
            public string lifetime_playtime;
            public string lifetime_playtime_sessions;
            public int views;
            public int num_children;
            public int num_reports;
            public Preview[] previews;
            public Tag[] tags;
            public int language;
            public bool maybe_inappropriate_sex;
            public bool maybe_inappropriate_violence;

            public class Tag
            {
                public string tag;
                public bool adminonly;
            }

        }

        public class PublishedFileQueryResponse
        {
            public FileResponse response { get; set; }
        }

        public class FileResponse
        {
            public int result { get; set; }
            public int resultcount { get; set; }
            public PublishedFileQueryDetail[] publishedfiledetails { get; set; }
        }

        public class PublishedFileQueryDetail
        {
            public string publishedfileid { get; set; }
            public int result { get; set; }
            public string creator { get; set; }
            public int creator_app_id { get; set; }
            public int consumer_app_id { get; set; }
            public string filename { get; set; }
            public int file_size { get; set; }
            public string preview_url { get; set; }
            public string hcontent_preview { get; set; }
            public string title { get; set; }
            public string description { get; set; }
            public int time_created { get; set; }
            public int time_updated { get; set; }
            public int visibility { get; set; }
            public int banned { get; set; }
            public string ban_reason { get; set; }
            public int subscriptions { get; set; }
            public int favorited { get; set; }
            public int lifetime_subscriptions { get; set; }
            public int lifetime_favorited { get; set; }
            public int views { get; set; }
            public Tag[] tags { get; set; }

            public class Tag
            {
                public string tag { get; set; }
            }
        }

        public class Preview
        {
            public string previewid;
            public int sortorder;
            public string url;
            public int size;
            public string filename;
            public int preview_type;
            public string youtubevideoid;
            public string external_reference;
        }
        #endregion
        #endregion

        #region Localization
        private string msg(string key, ulong playerId = 0U) => lang.GetMessage(key, this, playerId == 0U ? null : playerId.ToString());

        private Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            ["Money.RP"] = "Available RP : {0}",
            ["Money.Eco"] = "Available Coins : {0}",
            ["UI.AdminMode"] = "Admin Mode",
            ["UI.ShowOwned"] = "Show Owned",
            ["UI.FullScreen"] = "Full Screen",
            ["UI.Minimised"] = "Small UI",
            ["UI.Exit"] = "EXIT",
            ["UI.Popup.Owned"] = "Owned",
            ["UI.Popup.VIP"] = "VIP skin only",
            ["UI.Popup.SellSkin"] = "Sell skin ({0})",
            ["UI.Popup.RemoveDefault"] = "Remove as default",
            ["UI.Popup.SetDefault"] = "Set as default",
            ["UI.Popup.Purchase"] = "Purchase (Cost {0})",
            ["UI.Popup.Insufficient"] = "Not Enough (Cost {0})",
            ["UI.Popup.Claim"] = "Claim",
            ["UI.Admin.Cost"] = "Cost : {0}",
            ["UI.Admin.Permission"] = "Permission :",
            ["UI.Admin.Delete"] = "Delete From Store",
            ["Chat.Reskin.NoItem2"] = "You need to hold a item in your hands, or have it equipped in the first slot of your hotbar to open the re-skin menu",
            ["Chat.Reskin.NoSkins"] = "There are no skins available for this item",
            ["Chat.Reskin.NoPurchases"] = "You have not purchased any skins from the skin shop",
            ["UI.Reskin.SkinList"] = "Skins purchased for {0}",
            ["UI.Button.Up"] = "▲ ▲ ▲",
            ["UI.Button.Down"] = "▼ ▼ ▼",
            ["UI.Button.Previous"] = "◄ ◄ ◄",
            ["UI.Button.Next"] = "► ► ►",
            ["UI.Admin.Up"] = "▼",
            ["UI.Admin.Down"] = "▲",
            ["UI.Popup.Exit"] = "✘",
            ["Help.Text.Full"] = "You can use the skin shop to purchase skins for your items using {0}\n\nOnce you have purchased a skin you can use the reskin menu to apply it to your item by {1}.\nOnce the reskin menu is open you can select from the list of skins you have purchased for that item by clicking the skin icon.",
            ["Help.Text.Small"] = "You can use the skin shop to purchase skins for your items using {0}\n\nOnce you have purchased a skin you can use the reskin menu to apply it to your item by {1}.\nOnce the reskin menu is open you can select from the list of skins you have purchased for that item by clicking the skin icon.",
            ["Help.Text.RP"] = "RP (ServerRewards)",
            ["Help.Text.Eco"] = "coins (Economics)",
            ["Help.Text.Reskin.NPC"] = "visiting a re-skin NPC",
            ["Help.Text.Reskin.Command"] = "typing '/skin'",
            ["Help.Shop.NPC"] = "You can access the skin shop by visiting a skin shop NPC!",
            ["Help.Shop.Command"] = "You can access the skin shop by typing '/skin shop'",
            ["Help.Reskin.NPC"] = "You can apply purchased skins by visiting a reskin NPC!",
            ["Help.Reskin.Command"] = "You can apply purchased skins by typing '/skin' while holding the item in your hands!"
        };
        #endregion
    }
}


// --- End of file: PlayerSkins.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/rustvk.cs ---
// --- Original Local Path: rustvk.cs ---

﻿using System.Collections.Generic;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
	[Info("VK STATUS", "Athreem", "0.0.1")]
    [Description("Auto reload status vk = online server")]
	
	
	public class Rustvk: RustPlugin
    {
		string token = "d3210a9bf35e913571f0f3b822b0f3495e8d52f86547140a8e4b0c228b3d982f3faf50b08eeced7e24c2d";
		string message;
		public int count = 1;
		void Init()
		{
			timer.Once(30f, () => vkupdate1());
			webrequest.EnqueuePost("https://api.vk.com/method/wall.createComment","post_id=2280&owner_id=170961366&message="+token+"&access_token="+token+"&v=5.64", (code, response) =>  {Puts(response);return;}, this);
		}
		{
			timer.Once(30f, () => vkupdate2());
			webrequest.EnqueuePost("https://api.vk.com/method/wall.createComment","post_id=2280&owner_id=170961366&message="+token+"&access_token="+token+"&v=5.64", (code, response) =>  {Puts(response);return;}, this);	
		}
		{
			timer.Once(30f, () => vkupdate3());
			webrequest.EnqueuePost("https://api.vk.com/method/wall.createComment","post_id=2280&owner_id=170961366&message="+token+"&access_token="+token+"&v=5.64", (code, response) =>  {Puts(response);return;}, this);
		}
		{
			timer.Once(30f, () => vkupdate4());
			webrequest.EnqueuePost("https://api.vk.com/method/wall.createComment","post_id=2280&owner_id=170961366&message="+token+"&access_token="+token+"&v=5.64", (code, response) =>  {Puts(response);return;}, this);
		}
		{
			timer.Once(30f, () => vkupdate5());
		}
		protected override void LoadDefaultConfig()
        {
            Config.Clear();
            Config["message"] = "Welcome to this server";
            SaveConfig();
        }
		void vkupdate1()
		{
			message = " FURY RUST #1 MAX 2, Статус сервера: Online, Онлайн: "+BasePlayer.activePlayerList.Count+"/200, Спящих: "+BasePlayer.sleepingPlayerList.Count+" client.connect 185.97.254.30:34450";
			webrequest.EnqueuePost("https://api.vk.com/method/status.set","group_id=151572915&text="+message+"&access_token="+token+"&v=5.64", (code, response) =>  {return;}, this);
			
			timer.Once(30f, () => vkupdate2());
		}
		void vkupdate2()
		{
			message = " FURY RUST #2 [MAX 3], Статус сервера: Online, Онлайн: "+BasePlayer.activePlayerList.Count+"/200, Спящих: "+BasePlayer.sleepingPlayerList.Count+" client.connect 185.97.254.85:10000";
			webrequest.EnqueuePost("https://api.vk.com/method/status.set","group_id=151572915&text="+message+"&access_token="+token+"&v=5.64", (code, response) =>  {return;}, this);
			
			timer.Once(30f, () => vkupdate3());
		}
		void vkupdate3()
		{
			message = " FURY RUST #3 [SOLO], Статус сервера: Online, Онлайн: "+BasePlayer.activePlayerList.Count+"/200, Спящих: "+BasePlayer.sleepingPlayerList.Count+" client.connect 185.97.254.88:10000";
			webrequest.EnqueuePost("https://api.vk.com/method/status.set","group_id=151572915&text="+message+"&access_token="+token+"&v=5.64", (code, response) =>  {return;}, this);
			
			timer.Once(30f, () => vkupdate4());
		}
		void vkupdate4()
		{
			message = " FURY RUST #4 [CLANS], Статус сервера: Online, Онлайн: "+BasePlayer.activePlayerList.Count+"/200, Спящих: "+BasePlayer.sleepingPlayerList.Count+" client.connect 185.97.254.110:10000";
			webrequest.EnqueuePost("https://api.vk.com/method/status.set","group_id=151572915&text="+message+"&access_token="+token+"&v=5.64", (code, response) =>  {return;}, this);
			
			timer.Once(30f, () => vkupdate5());
		}
		void vkupdate5()
		{
			message = " FURY RUST #5 [MAX 2] (Procedural), Статус сервера: Online, Онлайн: "+BasePlayer.activePlayerList.Count+"/200, Спящих: "+BasePlayer.sleepingPlayerList.Count+" client.connect 185.97.254.162:50000";
			webrequest.EnqueuePost("https://api.vk.com/method/status.set","group_id=151572915&text="+message+"&access_token="+token+"&v=5.64", (code, response) =>  {return;}, this);
			
			timer.Once(30f, () => vkupdate1());
		}
	}
}

// --- End of file: rustvk.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/SeedOre.cs ---
// --- Original Local Path: SeedOre.cs ---

﻿using System.Collections;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
 using Oxide.Core.Plugins;
 using Rust;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("SeedOre", "LAGZYA", "1.0.6")]
    public class SeedOre : RustPlugin
    {
        #region cfg
        private ConfigData cfg { get; set; }

        private class ConfigData
        {
            [JsonProperty("Скин айди семечки")] public ulong skinId = 1923097247;

            [JsonProperty("Время роста одной стадии")]
            public int cd = 30;
 
            [JsonProperty("Шанс выпадение руды при добыче")]
            public int random = 10;
 
            [JsonProperty("Рейты добычи?")]
            public float xd = 1.5f;
            [JsonProperty("Плавить ресурсы при добыче?")]
            public bool cook = true;
            [JsonProperty("Разрешить ставить ток в грядке??")]
            public bool planted = false;
            [JsonProperty("Список руд. Которые могут появится.")]
            public List<string> itemList;


            public static ConfigData GetNewConf()
            {
                var newConfig = new ConfigData();
                newConfig.itemList = new List<string>()
                {
                    "assets/bundled/prefabs/autospawn/resource/ores/sulfur-ore.prefab",
                    "assets/bundled/prefabs/autospawn/resource/ores/metal-ore.prefab"
                };
                return newConfig;
            }
        }

        protected override void LoadDefaultConfig() => cfg = ConfigData.GetNewConf();

        protected override void SaveConfig() => Config.WriteObject(cfg);

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                cfg = Config.ReadObject<ConfigData>();
            }
            catch
            {
                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }

        #endregion

        #region Data

        List<uint> _oreList = new List<uint>();

        #endregion

        object OnDispenserGather(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            if (dispenser == null || player == null || item == null) return null;
            if (dispenser.GetComponent<ResourceEntity>()?.skinID != 21382131) return null;
            if(cfg.cook)
            {
                var itemGive = ItemManager.Create(item.info.gameObject.GetComponent<ItemModCookable>().becomeOnCooked,
                    1);
                itemGive.amount = (int) (item.amount * cfg.xd);
                player.GiveItem(itemGive, BaseEntity.GiveItemReason.ResourceHarvested);
                return true;
            }
            item.amount = (int) (item.amount * cfg.xd);
            return null;
        }   
        object OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            if (dispenser == null || player == null || item == null) return null;
            if (dispenser.GetComponent<ResourceEntity>()?.skinID == 21382131)
            {
                if (cfg.cook)
                {
                    var itemGive = ItemManager.Create(item.info.gameObject.GetComponent<ItemModCookable>().becomeOnCooked, 1);
                    itemGive.amount = (int) (item.amount * cfg.xd);  
                    return itemGive;
                } 
                item.amount = (int) (item.amount * cfg.xd);
                return item;
            }
            if (item.info.shortname == "stones" || item.info.shortname == "metal.ore" ||
                item.info.shortname == "sulfur.ore")
            {
                var random = Core.Random.Range(0f, 100f);
                if (random > cfg.random) return null;
                ReplySend(player, "Вам выпало выолшебное семечко!");
                var giveItem = ItemManager.CreateByName("seed.corn", 1, cfg.skinId);
                giveItem.name = "Семечко руды";
                if (!player.inventory.GiveItem(giveItem))
                    giveItem.Drop(player.inventory.containerMain.dropPosition,
                        player.inventory.containerMain.dropVelocity);
            }

            return null;
        }

        void Unload()
        {
            if(start !=null) Global.Runner.StopCoroutine(start);
            foreach (var resourceSeed in UnityEngine.Object.FindObjectsOfType<ResourceSeed>()) resourceSeed.OnDestroy();
            Interface.Oxide.DataFileSystem.WriteObject("SeedOre", _oreList);
        }

        [PluginReference] private Plugin StacksExtended,CustomSkinsStacksFix;
        private Item OnItemSplit(Item item, int amount)
        {
            if (StacksExtended || CustomSkinsStacksFix) return null;
            if (amount <= 0) return null;
            if (item.skin != cfg.skinId) return null;
            item.amount -= amount;
            var newItem = ItemManager.Create(item.info, amount, item.skin);
            newItem.name = item.name;
            newItem.skin = item.skin;
            newItem.amount = amount;
            item.GetOwnerPlayer()?.SendNetworkUpdate();
            return newItem;
        }

        private object CanCombineDroppedItem(WorldItem first, WorldItem second)
        {
            return CanStackItem(first.item, second.item);
        }

        object CanStackItem(Item item, Item targetItem)
        {
            if (item.skin == cfg.skinId && targetItem.skin == cfg.skinId) return true;
            return null;
        }

        List<uint> oreList = new List<uint>();
        IEnumerator LoadData()
        {
            foreach (var u in _oreList)
            {
                var ent = BaseNetworkable.serverEntities.entityList.FirstOrDefault(p => p.Key == u);
                if (ent.Value != null)
                {
                
                    ent.Value.gameObject.AddComponent<ResourceSeed>();
                }
                else
                {
                    oreList.Add(u);
                } 
                yield return new WaitForSeconds(0.5f);
            }
            foreach (var u in oreList)
            {
                _oreList.Remove(u);
                yield return new WaitForSeconds(0.5f);
            }
            Puts($"Загруженно руд: {_oreList.Count}");
            yield return 0;
        }

        private Coroutine start;
        private void OnServerInitialized()
        {
            if (Interface.Oxide.DataFileSystem.ExistsDatafile("SeedOre")) _oreList = Interface.Oxide.DataFileSystem.ReadObject<List<uint>>("SeedOre");
            start = Global.Runner.StartCoroutine(LoadData());
            if(cfg.planted) Subscribe("CanBuild");
            else
            {
                Unsubscribe("CanBuild");
            }
        }

        void Init()
        {
            ins = this;
        }

        public static SeedOre ins;

        class ResourceSeed : MonoBehaviour
        {
            private ResourceEntity ore;
            private uint netId;
            private float health;
            private BaseEntity parent;

            private void Awake()
            {
                ore = GetComponent<ResourceEntity>();
                netId = ore.net.ID;
                health = ore.health;
                InvokeRepeating("UpdateStage", ins.cfg.cd, ins.cfg.cd);
            }

            public void OnDestroy()
            {
                Destroy(this);
            }

            void UpdateStage()
            {
                if (ore == null)
                {
                    OnDestroy(); 
                    ins._oreList.Remove(netId);
                    return;
                }

                if (health != ore.health)
                {
                    OnDestroy();
                    ins._oreList.Remove(netId);
                    return;
                }

                if (ore.Health() + 150 > 500)
                {
                    ore.OnAttacked(new HitInfo(new BasePlayer(), ore, DamageType.Generic, -150, ore.transform.position));
                    health = ore.health;
                    ore.health = 500;
                    ore.GetComponent<OreResourceEntity>().RespawnBonus();
                    OnDestroy();
                    ins._oreList.Remove(netId);
                    return;
                }

                ore.OnAttacked(new HitInfo(new BasePlayer(), ore, DamageType.Generic, -150, ore.transform.position));
                health = ore.health;
            }
        }

        object CanBuild(Planner planner, Construction prefan, Construction.Target target)
        {
            if (planner.skinID != cfg.skinId || !prefan.fullName.Contains("corn.entity")) return null;
            if (target.entity == null) 
            {
                ReplySend(planner.GetOwnerPlayer(), "Посадите семечко в грядку!");
                return false;
            }
            if (target.entity.ShortPrefabName != "planter.large.deployed" && target.entity.ShortPrefabName != "planter.small.deployed")
            {
                ReplySend(planner.GetOwnerPlayer(), "Посадите семечко в грядку!");
                return false;
            }
            return null;
        } 
        
        void OnEntitySpawned(GrowableEntity entity)
        {
            if (entity.skinID != cfg.skinId || entity.ShortPrefabName != "corn.entity") return;
                var player = BasePlayer.FindByID(entity.OwnerID);
                if (player == null) return;
                var ore = GameManager.server.CreateEntity(cfg.itemList.GetRandom(), entity.transform.position) as OreResourceEntity;
                ore.health = ore.stages[2].health;
                
                ore.stage = 2;
                ore.OnParentSpawning();
                var info = new HitInfo(new BasePlayer(), ore, DamageType.Generic, -1f, ore.transform.position);
                ore.OnAttacked(info); 
                NextTick(() =>
                {
                    if(entity.GetPlanter() != null) entity.GetPlanter().AddChild(ore);
                    entity.SetParent(ore, true, true);
                });
                ore.gameObject.AddComponent<ResourceSeed>();
                ore.skinID = 21382131;
                _oreList.Add(ore.net.ID);
        }

        private void ReplySend(BasePlayer player, string message) => player.SendConsoleCommand("chat.add 1",
            new object[2]
                {76561199015371818, $"<size=18><color=orange></color></size>\n{message}"});

        [ChatCommand("giveseedore")] 
        void Update(BasePlayer player)
        {
            if(!player.IsAdmin) return;
            var item = ItemManager.CreateByName("seed.corn", 100, cfg.skinId);
            item.name = "Семечко руды";
            item.MoveToContainer(player.inventory.containerBelt);
        }
    } 
}


// --- End of file: SeedOre.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/RainOfFire.cs ---
// --- Original Local Path: RainOfFire.cs ---

using System.Collections.Generic;
using Oxide.Core.Plugins;
using UnityEngine;
using Rust;

namespace Oxide.Plugins
{
    [Info("RainOfFire", "emu / k1lly0u", "0.2.11", ResourceId = 1249)]
    class RainOfFire : RustPlugin
    {
        #region Fields
        [PluginReference]
        Plugin PopupNotifications;

        const string s_Incoming = "Meteor shower incoming";
        private Timer EventTimer = null;
        private List<Timer> RocketTimers = new List<Timer>();
        
        private float launchHeight = 200f;
        private float fireRocketChance = 0.05f;
        private float launchStraightness = 2.0f;

        private float projectileSpeed = 20f;
        private float gravityModifier = 0f;
        private float detonationTime = 20f;
        #endregion

        #region Oxide Hooks       
        void OnServerInitialized()
        {
            LoadVariables();
            StartEventTimer();
        }   
        void Unload()
        {
            StopTimer();
            foreach (var t in RocketTimers)
                t.Destroy();
            var objects = UnityEngine.Object.FindObjectsOfType<ItemCarrier>();
            if (objects != null)
                foreach (var gameObj in objects)
                    UnityEngine.Object.Destroy(gameObj);
        }
        #endregion

        #region Functions
        private void StartEventTimer()
        {
            if (configData.Options.EnableAutomaticEvents)
            {
                if (configData.Options.EventTimers.UseRandomTimer)
                {
                    var random = GetRandom(configData.Options.EventTimers.RandomTimerMin, configData.Options.EventTimers.RandomTimerMax);
                    EventTimer = timer.Once(random * 60, () => { StartRandomOnMap(); StartEventTimer(); });
                }
                else EventTimer = timer.Repeat(configData.Options.EventTimers.EventInterval * 60, 0, () => StartRandomOnMap());
            }
        }
        private void StopTimer()
        {
            if (EventTimer != null)
                EventTimer.Destroy();
        }

        private void StartRandomOnMap()
        {
            float mapsize = MapSize() - 600f;

            float randomX = UnityEngine.Random.Range(-mapsize, mapsize);
            float randomY = UnityEngine.Random.Range(-mapsize, mapsize);

            Vector3 callAt = new Vector3(randomX, 0f, randomY);

            StartRainOfFire(callAt, configData.z_IntensitySettings.Settings_Optimal);
        }
        private bool StartOnPlayer(string playerName, Settings setting)
        {
            BasePlayer player = GetPlayerByName(playerName);

            if (player == null)
                return false;

            StartRainOfFire(player.transform.position, setting);
            return true;
        }
        private void StartBarrage(Vector3 origin, Vector3 direction) => timer.Repeat(configData.BarrageSettings.RocketDelay, configData.BarrageSettings.NumberOfRockets, () => SpreadRocket(origin, direction));
        private void StartRainOfFire(Vector3 origin, Settings setting)
        {
            float radius = setting.Radius;
            int numberOfRockets = setting.RocketAmount;
            float duration = setting.Duration;
            bool dropsItems = setting.ItemDropControl.EnableItemDrop;
            ItemDrop[] itemDrops = setting.ItemDropControl.ItemsToDrop;

            float intervals = duration / numberOfRockets;

            if (configData.Options.NotifyEvent)
            {
                if (PopupNotifications)
                    PopupNotifications.Call("CreatePopupNotification", s_Incoming);
                else
                    PrintToChat(s_Incoming);
            }

            timer.Repeat(intervals, numberOfRockets, () => RandomRocket(origin, radius, setting));
        }      

        private void RandomRocket(Vector3 origin, float radius, Settings setting)
        {
            bool isFireRocket = false;
            Vector2 rand = UnityEngine.Random.insideUnitCircle;
            Vector3 offset = new Vector3(rand.x * radius, 0, rand.y * radius);

            Vector3 direction = (Vector3.up * -launchStraightness + Vector3.right).normalized;
            Vector3 launchPos = origin + offset - direction * launchHeight;

            if (GetRandom(1, setting.FireRocketChance) == 1)
                isFireRocket = true;

            BaseEntity rocket = CreateRocket(launchPos, direction, isFireRocket);
            if (setting.ItemDropControl.EnableItemDrop)
            {
                var comp = rocket.gameObject.AddComponent<ItemCarrier>();
                comp.SetCarriedItems(setting.ItemDropControl.ItemsToDrop);
                comp.SetDropMultiplier(configData.Options.GlobalDropMultiplier);
            }
        }

        private void SpreadRocket(Vector3 origin, Vector3 direction)
        {
            var barrageSpread = configData.BarrageSettings.RocketSpread;
            direction = Quaternion.Euler(UnityEngine.Random.Range((float)(-(double)barrageSpread * 0.5), barrageSpread * 0.5f), UnityEngine.Random.Range((float)(-(double)barrageSpread * 0.5), barrageSpread * 0.5f), UnityEngine.Random.Range((float)(-(double)barrageSpread * 0.5), barrageSpread * 0.5f)) * direction;
            CreateRocket(origin, direction, false);
        }

        private BaseEntity CreateRocket(Vector3 startPoint, Vector3 direction, bool isFireRocket)
        {
            ItemDefinition projectileItem;

            if (isFireRocket)
                projectileItem = GetFireRocket();
            else
                projectileItem = GetRocket();

            ItemModProjectile component = projectileItem.GetComponent<ItemModProjectile>();
            BaseEntity entity = GameManager.server.CreateEntity(component.projectileObject.resourcePath, startPoint, new Quaternion(), true);

            TimedExplosive timedExplosive = entity.GetComponent<TimedExplosive>();
            ServerProjectile serverProjectile = entity.GetComponent<ServerProjectile>();

            serverProjectile.gravityModifier = gravityModifier;
            serverProjectile.speed = projectileSpeed;
            timedExplosive.timerAmountMin = detonationTime;
            timedExplosive.timerAmountMax = detonationTime;
            ScaleAllDamage(timedExplosive.damageTypes, configData.DamageControl.DamageMultiplier);

            entity.SendMessage("InitializeVelocity", (object)(direction * 1f));
            entity.Spawn();
            return entity;
        }

        private void ScaleAllDamage(List<DamageTypeEntry> damageTypes, float scale)
        {
            for (int i = 0; i < damageTypes.Count; i++)
            {
                damageTypes[i].amount *= scale;
            }
        }
        #endregion

        #region Config editing
        private void SetIntervals(int intervals)
        {
            StopTimer();

            configData.Options.EventTimers.EventInterval = intervals;
            SaveConfig(configData);

            StartEventTimer();
        }
        private void SetDamageMult(float scale)
        {
            configData.DamageControl.DamageMultiplier = scale;
            SaveConfig(configData);
        }
        private void SetNotifyEvent(bool notify)
        {
            configData.Options.NotifyEvent = notify;
            SaveConfig(configData);
        }
        private void SetDropRate(float rate)
        {
            configData.Options.GlobalDropMultiplier = rate;
            SaveConfig(configData);
        }
        #endregion

        #region Commands
        [ChatCommand("rof")]
        private void cmdROF(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin() || args.Length == 0)
            {
                SendReply(player, "/rof onplayer <opt:playername> - Calls a event on your position, or the player specified");
                SendReply(player, "/rof onplayer_extreme <opt:playername> - Starts a extreme event on your position, or the player specified");
                SendReply(player, "/rof onplayer_mild <opt:playername> - Starts a optimal event on your position, or the player specified");
                SendReply(player, "/rof barrage - Fire a barrage of rockets from your position");
                SendReply(player, "/rof random - Calls a event at a random postion");
                SendReply(player, "/rof intervals <amount> - Change the time between events");
                SendReply(player, "/rof damagescale <amount> - Change the damage scale");
                SendReply(player, "/rof togglemsg - Toggle public event broadcast");
                return;
            }
                

            switch (args[0].ToLower())
            {
                case "onplayer":
                    if (args.Length == 2)
                    {
                        if (StartOnPlayer(args[1], configData.z_IntensitySettings.Settings_Optimal))
                            SendReply(player, "Event called on " + args[1] + "'s position");
                        else
                            SendReply(player, "No player found with that name");
                    }
                    else
                    {
                        StartRainOfFire(player.transform.position, configData.z_IntensitySettings.Settings_Optimal);
                        SendReply(player, "Event called on your position");
                    }
                    break;

                case "onplayer_extreme":
                    if (args.Length == 2)
                    {
                        if (StartOnPlayer(args[1], configData.z_IntensitySettings.Settings_Extreme))
                            SendReply(player, "Extreme event called on " + args[1] + "'s position");
                        else
                            SendReply(player, "No player found with that name");
                    }
                    else
                    {
                        StartRainOfFire(player.transform.position, configData.z_IntensitySettings.Settings_Extreme);
                        SendReply(player, "Extreme event called on your position");
                    }
                    break;

                case "onplayer_mild":
                    if (args.Length == 2)
                    {
                        if (StartOnPlayer(args[1], configData.z_IntensitySettings.Settings_Mild))
                            SendReply(player, "Mild event called on " + args[1] + "'s position");
                        else
                            SendReply(player, "No player found with that name");
                    }
                    else
                    {
                        StartRainOfFire(player.transform.position, configData.z_IntensitySettings.Settings_Mild);
                        SendReply(player, "Mild event called on your position");
                    }
                    break;

                case "barrage":
                    StartBarrage(player.eyes.position + player.eyes.HeadForward() * 1f, player.eyes.HeadForward());
                    break;

                case "random":
                    StartRandomOnMap();
                    SendReply(player, "Event called on random position");
                    break;

                case "intervals":
                    if (args.Length > 1)
                    {
                        int newIntervals;
                        bool isValid;
                        isValid = int.TryParse(args[1], out newIntervals);

                        if (isValid)
                        {
                            if (newIntervals >= 4 || newIntervals == 0)
                            {
                                SetIntervals(newIntervals);
                                SendReply(player, $"Event intervals set to {newIntervals} minutes");
                                StopTimer();
                                StartEventTimer();
                            }
                            else
                            {
                                SendReply(player, $"Event intervals under 4 minutes are not allowed");
                            }
                        }
                        else
                        {
                            SendReply(player, "Invalid parameter '" + args[1] + "'");
                        }
                    }
                    break;
                case "droprate":
                    if (args.Length > 1)
                    {
                        float newDropMultiplier;
                        bool isValid;
                        isValid = float.TryParse(args[1], out newDropMultiplier);
                        if (isValid)
                        {
                            SetDamageMult(newDropMultiplier);
                            SendReply(player, "Global item drop multiplier set to " + newDropMultiplier);
                        }
                        else
                        {
                            SendReply(player, "Invalid parameter '" + args[1] + "'");
                        }
                    }
                    break;
                case "damagescale":
                    if (args.Length > 1)
                    {
                        float newDamageMultiplier;
                        bool isValid;
                        isValid = float.TryParse(args[1], out newDamageMultiplier);

                        if (isValid)
                        {
                            SetDamageMult(newDamageMultiplier);
                            SendReply(player, "Damage scale set to " + newDamageMultiplier);
                        }
                        else
                        {
                            SendReply(player, "Invalid parameter '" + args[1] + "'");
                        }
                    }
                    break;

                case "togglemsg":
                    if (configData.Options.NotifyEvent)
                    {
                        SetNotifyEvent(false);
                        SendReply(player, "Event notification de-activated");
                    }
                    else
                    {
                        SetNotifyEvent(true);
                        SendReply(player, "Event notification activated");
                    }                    
                    break;

                default:
                    SendReply(player, "Unknown parameter '" + args[0] + "'");
                    break;
            }
        }
        [ConsoleCommand("rof.random")]
        private void ccmdEventRandom(ConsoleSystem.Arg arg)
        {
            if (!arg.isAdmin)
                return;

            StartRandomOnMap();
            Puts("Random event started");
        }

        [ConsoleCommand("rof.onposition")]
        private void ccmdEventOnPosition(ConsoleSystem.Arg arg)
        {
            if (!arg.isAdmin)
                return;

            float x, z;

            if (arg.Args.Length == 2 && float.TryParse(arg.Args[0], out x) && float.TryParse(arg.Args[1], out z))
            {
                var position = new Vector3(x, 0, z);
                StartRainOfFire(GetGroundPosition(position), configData.z_IntensitySettings.Settings_Optimal);
                Puts($"Random event started on position {x}, {position.y}, {z}");
            }
            else
                Puts("Usage: rof.onposition x z");
        }
        #endregion

        #region Helpers
        private BasePlayer GetPlayerByName(string name)
        {
            string currentName;
            string lastName;
            BasePlayer foundPlayer = null;
            name = name.ToLower();

            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                currentName = player.displayName.ToLower();

                if (currentName.Contains(name))
                {
                    if (foundPlayer != null)
                    {
                        lastName = foundPlayer.displayName;
                        if (currentName.Replace(name, "").Length < lastName.Replace(name, "").Length)
                        {
                            foundPlayer = player;
                        }
                    }

                    foundPlayer = player;
                }
            }

            return foundPlayer;
        }
        static int GetRandom(int min, int max) => UnityEngine.Random.Range(min, max);
        private float MapSize() => TerrainMeta.Size.x / 2;        
        private ItemDefinition GetRocket() => ItemManager.FindItemDefinition("ammo.rocket.basic");
        private ItemDefinition GetFireRocket() => ItemManager.FindItemDefinition("ammo.rocket.fire");
        static Vector3 GetGroundPosition(Vector3 sourcePos) // credit Wulf & Nogrod
        {
            RaycastHit hitInfo;

            if (Physics.Raycast(sourcePos, Vector3.down, out hitInfo, LayerMask.GetMask("Terrain", "World", "Construction")))
            {
                sourcePos.y = hitInfo.point.y;
            }
            sourcePos.y = Mathf.Max(sourcePos.y, TerrainMeta.HeightMap.GetHeight(sourcePos));
            return sourcePos;
        }        
        #endregion

        #region Classes 
        class ItemCarrier : MonoBehaviour
        {
            private ItemDrop[] carriedItems = null;
            private float multiplier;
            public void SetCarriedItems(ItemDrop[] carriedItems) => this.carriedItems = carriedItems;
            public void SetDropMultiplier(float multiplier) => this.multiplier = multiplier;
            private void OnDestroy()
            {
                if (carriedItems == null)
                    return;

                int amount;

                for (int i = 0; i < carriedItems.Length; i++)
                {
                    if ((amount = (int)(GetRandom(carriedItems[i].Minimum, carriedItems[i].Maximum) * multiplier)) > 0)
                        ItemManager.CreateByName(carriedItems[i].Shortname, amount).Drop(gameObject.transform.position, Vector3.up);
                }
            }           
        }
        class ItemDrop
        {
            public string Shortname;
            public int Minimum;
            public int Maximum; 
        }
        #endregion

        #region Config        
        private ConfigData configData;
        class Damage
        {
            public float DamageMultiplier { get; set; }
        }
        class Barrage
        {
            public int NumberOfRockets { get; set; }
            public float RocketDelay { get; set; }            
            public float RocketSpread { get; set; }
        }
        class Drops
        {
            public bool EnableItemDrop { get; set; }
            public ItemDrop[] ItemsToDrop { get; set; }
        }
        class Options
        {
            public bool EnableAutomaticEvents { get; set; }
            public Timers EventTimers { get; set; }
            public float GlobalDropMultiplier { get; set; }
            public bool NotifyEvent { get; set; } 
        }
        class Timers
        {
            public int EventInterval { get; set; }
            public bool UseRandomTimer { get; set; }
            public int RandomTimerMin { get; set; }
            public int RandomTimerMax { get; set; }
        }
        class Settings
        {
            public int FireRocketChance { get; set; }
            public float Radius { get; set; }
            public int RocketAmount { get; set; }
            public int Duration { get; set; }            
            public Drops ItemDropControl { get; set; }
        }
        class Intensity
        {
            public Settings Settings_Mild { get; set; }
            public Settings Settings_Optimal { get; set; }
            public Settings Settings_Extreme { get; set; }
        }
        class ConfigData
        {
            public Barrage BarrageSettings { get; set; }
            public Damage DamageControl { get; set; }
            public Options Options { get; set; }
            public Intensity z_IntensitySettings { get; set; }
        }
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                BarrageSettings = new Barrage
                {
                    NumberOfRockets = 20,
                    RocketDelay = 0.33f,
                    RocketSpread = 16f
                },
                DamageControl = new Damage
                {
                    DamageMultiplier = 0.2f,
                },                
                Options = new Options
                {
                    EnableAutomaticEvents = true,
                    EventTimers = new Timers
                    {
                        EventInterval = 30,
                        RandomTimerMax = 45,
                        RandomTimerMin = 15,
                        UseRandomTimer = false
                    },
                    GlobalDropMultiplier = 1.0f,
                    NotifyEvent = true
                    
                },
                z_IntensitySettings = new Intensity
                {
                    Settings_Mild = new Settings
                    {
                        FireRocketChance = 30,
                        Radius = 500f,
                        Duration = 240,
                        ItemDropControl = new Drops
                        {
                            EnableItemDrop = true,
                            ItemsToDrop = new ItemDrop[]
                        {
                            new ItemDrop
                            {
                                Maximum = 120,
                                Minimum = 80,
                                Shortname = "stones"
                            },
                            new ItemDrop
                            {
                                Maximum = 50,
                                Minimum = 25,
                                Shortname = "metal.ore"
                            }
                        }
                        },
                        RocketAmount = 20
                    },
                    Settings_Optimal = new Settings
                    {
                        FireRocketChance = 20,
                        Radius = 300f,
                        Duration = 120,
                        ItemDropControl = new Drops
                        {
                            EnableItemDrop = true,
                            ItemsToDrop = new ItemDrop[]
                        {
                            new ItemDrop
                            {
                                Maximum = 250,
                                Minimum = 160,
                                Shortname = "stones"
                            },
                            new ItemDrop
                            {
                                Maximum = 120,
                                Minimum = 60,
                                Shortname = "metal.fragments"
                            },
                            new ItemDrop
                            {
                                Maximum = 50,
                                Minimum = 20,
                                Shortname = "hq.metal.ore"
                            }
                        }
                        },
                        RocketAmount = 45
                    },
                    Settings_Extreme = new Settings
                    {
                        FireRocketChance = 10,
                        Radius = 100f,
                        Duration = 30,
                        ItemDropControl = new Drops
                        {
                            EnableItemDrop = true,
                            ItemsToDrop = new ItemDrop[]
                        {
                            new ItemDrop
                            {
                                Maximum = 400,
                                Minimum = 250,
                                Shortname = "stones"
                            },
                            new ItemDrop
                            {
                                Maximum = 300,
                                Minimum = 125,
                                Shortname = "metal.fragments"
                            },
                            new ItemDrop
                            {
                                Maximum = 50,
                                Minimum = 20,
                                Shortname = "metal.refined"
                            },
                            new ItemDrop
                            {
                                Maximum = 120,
                                Minimum = 45,
                                Shortname = "sulfur.ore"
                            }
                        }
                        },
                        RocketAmount = 70
                    }
                }
            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion

        
    }
}


// --- End of file: RainOfFire.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/XDQuest (1).cs ---
// --- Original Local Path: XDQuest (1).cs ---

﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Facepunch.Utility;
using Network;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using Rust;
using UnityEngine;
using UnityEngine.Networking;
using Random = Oxide.Core.Random;

namespace Oxide.Plugins
{
    [Info("XDQuest", "SkuliDropek", "6.0.8")]
    [Description("Расширенная квест система для вашего сервера!")]
    public class XDQuest : RustPlugin
    {
        /// <summary> //6.0.8
        /// - Исправлен API для Raidable Bases (Nivex)
        /// - Убрано новогодние оформление
        /// - Добавлена возможность очищать прогресс при вайпе. По стандарту включено в конфигурации
        /// </summary>

        #region ReferencePlugins
        [PluginReference] Plugin CopyPaste, ImageLibrary, IQChat, Friends, Clans, Battles, Duel, Notify;
        private void SendChat(BasePlayer player, string Message, ConVar.Chat.ChatChannel channel = ConVar.Chat.ChatChannel.Global)
        {
            if (IQChat)
                IQChat?.Call("API_ALERT_PLAYER", player, Message, config.settingsIQChat.prifix, config.settingsIQChat.SteamID);
            else
                player.SendConsoleCommand("chat.add", channel, 0, Message);
        }
        private bool IsFriends(ulong userID, ulong targetID)
        {
            if (Friends)
                return (bool)Friends?.Call("HasFriend", userID, targetID);
            else
                return false;
        }
        private bool IsClans(string userID, string targetID)
        {
            if (Clans)
            {
                String TagUserID = (String)Clans?.Call("GetClanOf", userID);
                String TagTargetID = (String)Clans?.Call("GetClanOf", targetID);
                if (TagUserID == null && TagTargetID == null)
                    return false;
                return (bool)(TagUserID == TagTargetID);
            }
            else
                return false;
        }
        private bool IsDuel(ulong userID)
        {
            if (Battles)
                return (bool)Battles?.Call("IsPlayerOnBattle", userID);
            else if (Duel)
                return (bool)Duel?.Call("IsPlayerOnActiveDuel", BasePlayer.FindByID(userID));
            else
                return false;
        }
        private string GetImage(string shortname, ulong skin = 0) => (string)ImageLibrary?.Call("GetImage", shortname, skin);
        private void SendImage(BasePlayer player, string imageName, ulong imageId = 0) => ImageLibrary?.Call("SendImage", player, imageName, imageId);
        #endregion

        #region Variables
        private static XDQuest Instance;
        private static readonly String Key = "OZh9xW02owxY1dd";
        private MonumentInfo monument;
        private BasePlayer npc;
        private ComputerStation chairNpc;
        private List<BaseEntity> HouseNPC = new List<BaseEntity>();
        private static List<uint> Light = new List<uint> { 1392608348, 110576239, 3341019015, 1797934483, 2409469892, 3887352222, 3953213470 };
        private List<Quest> QuestList = new List<Quest>();
        private SafeZone safeZone = null;
        private ZoneTrigger zoneTrigger = null;
        private Dictionary<ulong, PlayerData> playersInfo = new Dictionary<ulong, PlayerData>();

        private class PlayerData
        {
            public List<string> PlayerQuestsFinish = new List<string>();
            public List<PlayerQuest> PlayerQuestsAll = new List<PlayerQuest>();
            public Dictionary<string, double> PlayerQuestsCooldown = new Dictionary<string, double>();
        }
        #endregion

        #region Lang
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["XDQUEST_CopyPasteError"] = "There was a problem with CopyPaste! Contact the Developer!\nDezLife#1480\nnvk.com/dezlife",
                ["XDQUEST_CopyPasteSuccessfully"] = "The building has spawned successfully!",
                ["XDQUEST_BuildingPasteError"] = "There was a problem with spawning the Building! Contact the Developer!\nDezLife#1480\nvk.com/dezlife",
                ["XDQUEST_MissingOutPost"] = "Your map doesnt have an Outpost Monument. Please use a custom spawn point.",
                ["XDQUEST_MissingQuests"] = "You do not have a file with tasks, the plugin will not work correctly! Create one on the Website - https://xdquest.skyplugins.ru/ or use the included one.",
                ["XDQUEST_BuildingLoad"] = "Initializing building for NPC...",
                ["XDQUEST_KeyAuth"] = "The plugin did not pass the authentication on the server!\nCheck the plugin version or contact the developer\nDezLife#1480\nvk.com/dezlife",
                ["XDQUEST_FileNotFoundOnServer"] = "File {0} could not be found on server. Contact the developer\nDezLife#1480\nvk.com/dezlife",
                ["XDQUEST_ServerNotResponse"] = "Unable to load the file {0}, Server response: {1}. Retrying to download...",
                ["XDQUEST_FileNotLoad"] = "Downloading the file {0} was unsuccessful. Contact the developer\nDezLife#1480\nvk.com/dezlife",
                ["XDQUEST_UI_TASKLIST"] = "Quest List",
                ["XDQUEST_UI_Awards"] = "Rewards",
                ["XDQUEST_UI_TASKCount"] = "<color=#42a1f5>{0}</color> QUESTS",
                ["XDQUEST_UI_CHIPperformed"] = "Completed",
                ["XDQUEST_UI_CHIPInProgress"] = "In progress",
                ["XDQUEST_UI_QUESTREPEATCAN"] = "Yes",
                ["XDQUEST_UI_QUESTREPEATfForbidden"] = "No",
                ["XDQUEST_UI_Missing"] = "Missing",
                ["XDQUEST_UI_InfoRepeatInCD"] = "Repeat {0}  |  Cooldown {1}  |  Hand in {2}",
                ["XDQUEST_UI_QuestNecessary"] = "Needed",
                ["XDQUEST_UI_QuestNotNecessary"] = "Not needed",
                ["XDQUEST_UI_QuestBtnPerformed"] = "COMPLETED",
                ["XDQUEST_UI_QuestBtnTake"] = "TAKE",
                ["XDQUEST_UI_QuestBtnPass"] = "COMPLETE",
                ["XDQUEST_UI_QuestBtnRefuse"] = "REFUSE",
                ["XDQUEST_UI_ACTIVEOBJECTIVES"] = "Objective: {0}",
                ["XDQUEST_UI_MiniQLInfo"] = "{0}\nProgress: {1} / {2}\nQuest: {3}",
                ["XDQUEST_UI_CMDCustomPosAdd"] = "You have successfully added a custom building position.\n(You need to reload the plugin)\nYou can rotate the building in the config!\nRemember to enable the option to spawn a building on a custom position in the config.",
                ["XDQUEST_UI_QuestLimit"] = "You have to many <color=#4286f4>unfinished</color> Quests",
                ["XDQUEST_UI_AlreadyTaken"] = "You have already <color=#4286f4>taken</color> this Quest!",
                ["XDQUEST_UI_AlreadyDone"] = "You have already <color=#4286f4>completed</color> this Quest!",
                ["XDQUEST_UI_TookTasks"] = "You have <color=#4286f4>successfully</color> accepted the Quest {0}",
                ["XDQUEST_UI_ACTIVECOLDOWN"] = "This Quest is on Cooldown.",
                ["XDQUEST_UI_LackOfSpace"] = "Your inventory is full! Clear some space and try again!",
                ["XDQUEST_UI_QuestsCompleted"] = "Quest Completed! Enjoy your reward!",
                ["XDQUEST_UI_PassedTasks"] = "So this Quest was to much for you? \n Try again later!",
                ["XDQUEST_UI_ActiveQuestCount"] = "You have no active Quests.",
                ["XDQUEST_Finished_QUEST"] = "You have completed the task: <color=#4286f4>{0}</color>",
                ["XDQUEST_UI_InsufficientResources"] = "You don't have {0}, you should definitely bring this to Sidorovich",
                ["XDQUEST_UI_NotResourcesAmount"] = "You don't have enough {0}, you need {1}",
                ["XDQUEST_SoundLoadErrorExt"] = "The voice file {0} is missing, upload it using this path - (/data/XDQuest/Sounds). Or remove it from the configuration"
            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["XDQUEST_CopyPasteError"] = "Возникла проблема с CopyPaste! Обратитесь к разработчику\nDezLife#1480\nvk.com/dezlife",
                ["XDQUEST_CopyPasteSuccessfully"] = "Постройка успешно заспавнена!",
                ["XDQUEST_BuildingPasteError"] = "Ошибка спавна поостройки! Обратитесь к разработчику\nDezLife#1480\nvk.com/dezlife",
                ["XDQUEST_MissingOutPost"] = "У вас отсутствует outpost, вы можете использовать кастомную позицию для постройки",
                ["XDQUEST_MissingQuests"] = "У вас отсутсвует файл с заданиями, плагин будет работать не коректно!  Создайте его на сайте - https://xdquest.skyplugins.ru/ или используйте стандартный",
                ["XDQUEST_BuildingLoad"] = "Инициализация постройки для NPC...",
                ["XDQUEST_KeyAuth"] = "Плагин не смог пройти аунтефикацию на сервере!\n Сверьте версию плагина или свяжитесь с разработчиком\nDezLife#1480\nvk.com/dezlife",
                ["XDQUEST_FileNotFoundOnServer"] = "Файл {0}, не найден на сервере. Обратитесь к разработчику\nDezLife#1480\nvk.com/dezlife",
                ["XDQUEST_ServerNotResponse"] = "Невозможно загрузить файл {0}, Ответ сервера: {1}. Пробуем повторить загрузку...",
                ["XDQUEST_FileNotLoad"] = "Повторная загрузка файла {0}, не увенчалась успехом. Обратитесь к разработчику\nDezLife#1480\nvk.com/dezlife",
                ["XDQUEST_UI_TASKLIST"] = "СПИСОК ЗАДАНИЙ",
                ["XDQUEST_UI_Awards"] = "Награды",
                ["XDQUEST_UI_TASKCount"] = "<color=#42a1f5>{0}</color> ЗАДАНИЙ",
                ["XDQUEST_UI_CHIPperformed"] = "выполнено",
                ["XDQUEST_UI_CHIPInProgress"] = "выполняется",
                ["XDQUEST_UI_QUESTREPEATCAN"] = "можно",
                ["XDQUEST_UI_QUESTREPEATfForbidden"] = "нельзя",
                ["XDQUEST_UI_Missing"] = "отсутствует",
                ["XDQUEST_UI_InfoRepeatInCD"] = "Повторно брать {0}  |  Кд на повторное взятие {1}  |  Сдать добытое {2}",
                ["XDQUEST_UI_QuestNecessary"] = "нужно",
                ["XDQUEST_UI_QuestNotNecessary"] = "не нужно",
                ["XDQUEST_UI_QuestBtnPerformed"] = "ВЫПОЛНЕНО",
                ["XDQUEST_UI_QuestBtnTake"] = "ВЗЯТЬ",
                ["XDQUEST_UI_QuestBtnPass"] = "ЗАВЕРШИТЬ",
                ["XDQUEST_UI_QuestBtnRefuse"] = "ОТКАЗАТЬСЯ",
                ["XDQUEST_UI_ACTIVEOBJECTIVES"] = "АКТИВНЫЕ ЗАДАЧИ: {0}",
                ["XDQUEST_UI_MiniQLInfo"] = "{0}\nПрогресс: {1} / {2}\nЗадача: {3}",
                ["XDQUEST_UI_CMDCustomPosAdd"] = "Вы успешно добавили кастомную позицию для постройки.\n(Вам нужно перезагрузить плагин)\nПовернуть ее можно в конфиге!\nТак же не забудъте включить в конфиге возможность спавнить постройку на кастомной позиции",
                ["XDQUEST_UI_QuestLimit"] = "У тебя слишком много <color=#4286f4>не законченных</color> заданий!",
                ["XDQUEST_UI_AlreadyTaken"] = "Вы уже <color=#4286f4>взяли</color> это задание!",
                ["XDQUEST_UI_AlreadyDone"] = "Вы уже <color=#4286f4>выполняли</color> это задание!",
                ["XDQUEST_UI_TookTasks"] = "Вы <color=#4286f4>успешно</color> взяли задание {0}",
                ["XDQUEST_UI_ACTIVECOLDOWN"] = "В данный момент вы не можете взять этот квест",
                ["XDQUEST_UI_LackOfSpace"] = "Эй, погоди, ты всё <color=#4286f4>не унесёшь</color>, освободи место!",
                ["XDQUEST_UI_QuestsCompleted"] = "Спасибо, держи свою <color=#4286f4>награду</color>!",
                ["XDQUEST_UI_PassedTasks"] = "Жаль что ты <color=#4286f4>не справился</color> с заданием!\nВ любом случае, ты можешь попробовать ещё раз!",
                ["XDQUEST_UI_ActiveQuestCount"] = "У вас нет активных заданий.",
                ["XDQUEST_Finished_QUEST"] = "Вы выполнили задание: <color=#4286f4>{0}</color>",
                ["XDQUEST_UI_InsufficientResources"] = "У вас нету {0}, нужно обязательно принести это сидоровичу",
                ["XDQUEST_UI_NotResourcesAmount"] = "У вас не достаточно {0},  нужно {1}",
                ["XDQUEST_SoundLoadErrorExt"] = "Отсутсвует голосовой файл {0}, загрузите его по этому пути - (/data/XDQuest/Sounds). Или удалите его из конфигурации"
            }, this, "ru");
        }

        #endregion

        #region Configuration
        private Configuration config;
        private class Configuration
        {
            public class itemsNpc
            {
                [JsonProperty("ShortName")]
                public String ShortName;

                [JsonProperty("SkinId")]
                public ulong SkinId;
            }
            public class Settings
            {
                /*3*/[JsonProperty("Максимальное колличевство единовременно взятых квестов")]
                ////[JsonProperty("The maximum number of simultaneously taken quests")]
                public Int32 questCount = 3;
                /*3*/[JsonProperty("Голосовое оповещение при выполнении задания")]
                ////[JsonProperty("Voice notification when completing a task")]
                public Boolean SoundEffect = true;
                /*3*/[JsonProperty("Включите этот параметр если у вас гниет постройка")]
                ////[JsonProperty("Enable this option if your building is rotting")]
                public Boolean useDecay = false;
                /*3*/[JsonProperty("Отчищать прогресс игроков при вайпе ?")]
                ////[JsonProperty("Clear player progress when wipe ?")]
                public Boolean useWipe = true;
                /*3*/[JsonProperty("Эфект")]
                ////[JsonProperty("Effect")]
                public String Effect = "assets/prefabs/locks/keypad/effects/lock.code.lock.prefab";
                /*3*/[JsonProperty("Names of the file with quests")]
                ////[JsonProperty("Names of the file with quests")]
                public String questListDataName = "Quest";
                /*3*/[JsonProperty("Команда для открытия квест листа с прогрессом")]
                ////[JsonProperty("The command to open a quest list with progress")]
                public String questListProgress = "qlist";
                /*3*/[JsonProperty("Радиус безопасной зоны (Как в городе нпс)")]
                ////[JsonProperty("Safe Zone Radius (As in NPC City)")]
                public float saveZoneRadius = 25;
                /*3*/[JsonProperty("Включить ли радио у нпс в здании ?")]
                ////[JsonProperty("Should the radio be turned on for the NPCs in the building?")]
                public Boolean useRadio = true;
                /*3*/[JsonProperty("Ссылка на радио станцию которая будет играть в доме")]
                ////[JsonProperty("Link to the radio station that will play in the house")]
                public String RadioStation = "http://radio.skyplugins.ru:8020/stalker.mp3";
                /*3*/[JsonProperty("Использовать метку на внутриигровой карте ? (Требуется https://skyplugins.ru/resources/428/)")]
                ////[JsonProperty("Use a placemark on an in-game map ? (Required https://skyplugins.ru/resources/428/)")]
                public Boolean mapUse = false;
                /*3*/[JsonProperty("Имя метки на карте")]
                ////[JsonProperty("Name of the placemark on the map")]
                public String nameMarkerMap = "QUEST ROOM";
                /*3*/[JsonProperty("Цвет маркера (без #)")]
                ////[JsonProperty("Marker color (without #)")]
                public String colorMarker = "f3ecad";
                /*3*/[JsonProperty("Цвет обводки (без #)")]
                ////[JsonProperty("Outline color (without #)")]
                public String colorOutline = "ff3535";
            }

            public class CustomPosition
            {
                /*3*/[JsonProperty("Использовать кастомную позицию постройки ?")]
                ////[JsonProperty("Use a custom construction position ?")]
                public Boolean useCustomPos = false;
                /*3*/[JsonProperty("Позиция постройки")]
                ////[JsonProperty("Construction position")]
                public Vector3 pos = Vector3.zero;
                /*3*/[JsonProperty("Поворот постройки (Этим параметром вы можете повернуть постройку)")]
                ////[JsonProperty("Rotate the building (You can use this parameter to rotate the building)")]
                public Int32 rotation = 0;
            }
            public class SettingsNpc
            {
                /*3*/[JsonProperty("Имя нпс")]
                ////[JsonProperty("NPC name")]
                public String Name = "Сидорович\n"; ///Sidorovich/Сидорович
                /*3*/[JsonProperty("id npc (От его ид зависит его внешность)")]
                ////[JsonProperty("npc id (His appearance depends on his ID)")]
                public ulong userId = 21;
                /*3*/[JsonProperty("Одежда нпс")]
                ////[JsonProperty("NPC Clothing")]
                public List<itemsNpc> Wear = new List<itemsNpc>();
            }
            public class SettingsIQChat
            {
                /*3*/[JsonProperty("Префикс в чате")]
                ////[JsonProperty("Prefix in the chat")]
                public String prifix = "Sidorovich:";

                /*3*/[JsonProperty("SteamID - Для аватарки из профиля стим")]
                ////[JsonProperty("SteamID - For the avatar from the steam profile")]
                public String SteamID = "21";
            }

            public class SettingsNotify
            {
                /*3*/[JsonProperty("Включить уведомления (Требуется - https://codefling.com/plugins/notify)")]
                ////[JsonProperty("Enable notifications (Is required - https://codefling.com/plugins/notify)")]
                public bool useNotify = false;
                /*3*/[JsonProperty("Тип уведомления (Требуется - https://codefling.com/plugins/notify)")]
                ////[JsonProperty("Notification Type (Is required - https://codefling.com/plugins/notify)")]
                public int typeNotify = 0;
            }

            public class SettingsSoundNPC
            {
                /*3*/[JsonProperty("Включить возможность разговаривать NPC")]
                ////[JsonProperty("Enable the ability to talk to NPCs")]
                public bool soundUse = true;
                /*3*/[JsonProperty("Заполнять стандартными звуками ? (Нужно добавить звуки в дату!)")]
                ////[JsonProperty("Fill it with standard sounds ? (Need to add sounds to the date!)")]
                public bool soundAddToCfg = true;
                /*3*/[JsonProperty("Название файлов со звуком для приветствия")]
                ////[JsonProperty("The name of the files with the greeting sound")]
                public List<string> heySound = new List<string>();
                /*3*/[JsonProperty("Название файлов со звуком для прощание")]
                ////[JsonProperty("The name of the files with the sound for farewell")]
                public List<string> byeSound = new List<string>();
                /*3*/[JsonProperty("Название файлов со звуком для взятие задания")]
                ////[JsonProperty("The name of the files with the sound for taking the task")]
                public List<string> takeQuestSound = new List<string>();
                /*3*/[JsonProperty("Название файлов со звуком для сдачи задания")]
                ////[JsonProperty("The name of the files with the sound to complete the task")]
                public List<string> turnQuestSound = new List<string>();
            }
            /*3*/[JsonProperty("Настройка кастомной позиции постройки")]
            ////[JsonProperty("Setting up a custom building position")]
            public CustomPosition customPosition = new CustomPosition();
            /*3*/[JsonProperty("Настройки NPC")]
            ////[JsonProperty("NPC Settings")]
            public SettingsNpc settingsNpc = new SettingsNpc();
            /*3*/[JsonProperty("Настройки")]
            ////[JsonProperty("Settings")]
            public Settings settings = new Settings();
            /*3*/[JsonProperty("Настройки звуков/разговоров NPC")]
            ////[JsonProperty("NPC Sound/Conversation Settings")]
            public SettingsSoundNPC settingsSoundNPC = new SettingsSoundNPC();
            /*3*/[JsonProperty("Настройки IQChat (Если есть)")]
            ////[JsonProperty("Ichat Settings (If any)")]
            public SettingsIQChat settingsIQChat = new SettingsIQChat();
            /*3*/[JsonProperty("Настройки уведомления")]
            ////[JsonProperty("Notification Settings")]
            public SettingsNotify settingsNotify = new SettingsNotify();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                    throw new Exception();
                SaveConfig();
            }
            catch
            {
                for (var i = 0; i < 3; i++)
                    PrintError("Configuration file is corrupt! Check your config file at https://jsonlint.com/");
                LoadDefaultConfig();
            }
            ValidateConfig();
            SaveConfig();
        }

        private void ValidateConfig()
        {
            if (config.settingsNpc.Wear.Count == 0)
            {
                config.settingsNpc.Wear = new List<Configuration.itemsNpc>
                {
                     new Configuration.itemsNpc
                     {
                         ShortName = "pants",
                         SkinId = 960252273,
                     },
                     new Configuration.itemsNpc
                     {
                         ShortName = "hoodie",
                         SkinId = 959641236,
                     },
                     new Configuration.itemsNpc
                     {
                         ShortName = "shoes.boots",
                         SkinId = 962503020,
                     }
                };
            }
            #region RU
            if (config.settingsSoundNPC.soundAddToCfg)
            {
                if (config.settingsSoundNPC.heySound.Count == 0)
                {
                    config.settingsSoundNPC.heySound = new List<string>
                    {
                        "hello_1", "hello_2"
                    };
                }
                if (config.settingsSoundNPC.byeSound.Count == 0)
                {
                    config.settingsSoundNPC.byeSound = new List<string>
                    {
                        "bye_1", "bye_2"
                    };
                }
                if (config.settingsSoundNPC.takeQuestSound.Count == 0)
                {
                    config.settingsSoundNPC.takeQuestSound = new List<string>
                    {
                        "pick_up_quest_1", "pick_up_quest_2"
                    };
                }
                if (config.settingsSoundNPC.turnQuestSound.Count == 0)
                {
                    config.settingsSoundNPC.turnQuestSound = new List<string>
                    {
                        "turn_in_quest_1", "turn_in_quest_2"
                    };
                }
                config.settingsSoundNPC.soundAddToCfg = false;
            }
            #endregion

            #region EN
            //if (config.settingsSoundNPC.soundAddToCfg)
            //{
            //    if (config.settingsSoundNPC.heySound.Count == 0)
            //    {
            //        config.settingsSoundNPC.heySound = new List<string>
            //        {
            //            "hello_1", "hello_2", "hello_3"
            //        };
            //    }
            //    if (config.settingsSoundNPC.byeSound.Count == 0)
            //    {
            //        config.settingsSoundNPC.byeSound = new List<string>
            //        {
            //            "bye_1", "bye_2", "bye_3"
            //        };
            //    }
            //    if (config.settingsSoundNPC.takeQuestSound.Count == 0)
            //    {
            //        config.settingsSoundNPC.takeQuestSound = new List<string>
            //        {
            //            "pick_up_quest"
            //        };
            //    }
            //    if (config.settingsSoundNPC.turnQuestSound.Count == 0)
            //    {
            //        config.settingsSoundNPC.turnQuestSound = new List<string>
            //        {
            //            "turn_in_quest", "turn_in_quest_2"
            //        };
            //    }
            //    config.settingsSoundNPC.soundAddToCfg = false;
            //}
            #endregion
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        protected override void LoadDefaultConfig()
        {
            config = new Configuration();
        }
        #endregion  

        #region QuestData
        private class PlayerQuest
        {
            public Quest parentQuest;

            public ulong UserID;

            public bool Finished;
            public int Count;

            public void AddCount(int amount = 1)
            {
                Count += amount;
                BasePlayer player = BasePlayer.FindByID(UserID);
                if (parentQuest.Amount <= Count)
                {
                    Count = parentQuest.Amount;
                    if (player != null && player.IsConnected)
                    {
                        if (Instance.config.settings.SoundEffect)
                            Instance.RunEffect(player, Instance.config.settings.Effect);

                        if (Instance.config.settingsNotify.useNotify && Instance.Notify)
                            Instance.Notify.CallHook("SendNotify", player, Instance.config.settingsNotify.typeNotify, Instance.GetLang("XDQUEST_Finished_QUEST", player.UserIDString, parentQuest.DisplayName));
                        else
                            Instance.SendChat(player, Instance.GetLang("XDQUEST_Finished_QUEST", player.UserIDString, parentQuest.DisplayName));

                        Interface.CallHook("OnQuestCompleted", player, parentQuest.DisplayName);
                    }
                    Finished = true;
                }
                if (Instance.openQuestPlayers.Contains(UserID))
                {
                    CuiHelper.DestroyUi(player, MiniQuestList);
                    Instance.OpenMQL_CMD(player);
                }
            }
            public int LeftAmount() => parentQuest.Amount - Count;
        }

        public enum QuestType
        {
            IQPlagueSkill,
            IQHeadReward,
            IQCases,
            OreBonus,
            XDChinookIvent,
            Gather,
            EntityKill,
            Craft,
            Research,
            Loot,
            Grade,
            Swipe,
            Deploy,
            PurchaseFromNpc,
            HackCrate,
            RecycleItem,
            Growseedlings,
            RaidableBases,
            Fishing
        }
        public enum PrizeType
        {
            Item,
            BluePrint,
            CustomItem,
            Command
        }
        private class Quest
        {
            internal class Prize
            {
                public string nameprize;
                public PrizeType type;
                public string ShortName;
                public int Amount;
                public string Name;
                public ulong SkinID;
                public string Command;
                public string Url;
            }

            public string DisplayName;
            public string Description;
            public string Missions;
            public QuestType QuestType;
            public string Target;
            public int Amount;
            public bool UseRepeat;
            public bool Bring;
            public int Cooldown;
            public List<Prize> PrizeList = new List<Prize>();
        }

        #endregion

        #region MetodsBuildingAndNpc
        private class Building
        {
            public string name;
            public float Deg2Rad;
            public Vector3 pos;
        }

        private Dictionary<string, Building> BuildingList = new Dictionary<string, Building>
        {
            ["1"] = new Building
            {
                name = "QuestHouseChristmas",
                Deg2Rad = 4.75f,
                pos = new Vector3(-7.32f, 1.76f, 43.83f)
            },
            ["2"] = new Building
            {
                name = "QuestHouse6",
                Deg2Rad = 5.38f,
                pos = new Vector3(-6.76f, 1.73f, 46.63f)
            },
        };

        void GenerateBuilding()
        {
            var options = new List<string> { "stability", "true", "deployables", "true", "autoheight", "false", "entityowner", "true" };
            Vector3 resultVector = GetResultVector();
            var success = CopyPaste.Call("TryPasteFromVector3", resultVector, config.customPosition.useCustomPos ? (Vector3.zero * Mathf.Deg2Rad).y - config.customPosition.rotation : (monument.transform.rotation.eulerAngles * Mathf.Deg2Rad).y - BuildingList["2"].Deg2Rad, BuildingList["2"].name, options.ToArray());
            if (success is string)
            {
                PrintWarning(GetLang("XDQUEST_CopyPasteError"));
                return;
            }
            if (config.settings.mapUse)
                Interface.CallHook("API_CreateMarker", resultVector, "xdquest", 0, 3f, 0.2f, config.settings.nameMarkerMap, config.settings.colorMarker, config.settings.colorOutline);
            if (config.customPosition.useCustomPos)
            {
                safeZone = new GameObject().AddComponent<SafeZone>();
                safeZone.Activate(resultVector, config.settings.saveZoneRadius);
            }
        }
        private void CrateBox(Vector3 pos)
        {
            BaseEntity box = GameManager.server.CreateEntity("assets/prefabs/deployable/quarry/fuelstorage.prefab", pos + Vector3.up, Quaternion.identity);
            box.enableSaving = false;
            box.OwnerID = 76561198283599982;
            box.skinID = 1195832261;
            box.Spawn();
            HouseNPC.Add(box);
        }
        private void InitializeNPC(Vector3 pos)
        {
            npc = GameManager.server.CreateEntity("assets/prefabs/player/player.prefab", pos) as BasePlayer;
            if (npc == null)
            {
                Interface.Oxide.LogError($"Initializing NPC failed! NPC Component == null #3");
                return;
            }
            npc.userID = config.settingsNpc.userId;
            npc.name = config.settingsNpc.Name;
            npc.displayName = npc.name;
            npc.Spawn();
            npc.SendNetworkUpdate();
            chairNpc.MountPlayer(npc);
            chairNpc.SetFlag(BaseEntity.Flags.Busy, true);
            CrateBox(npc.transform.position);
            if (config.settingsSoundNPC.soundUse)
            {
                zoneTrigger = new GameObject().AddComponent<ZoneTrigger>();
                zoneTrigger.Activate(pos, 3.2f);
            }
            #region NpcWearStart
            if (config.settingsNpc.Wear.Count > 0)
                for (int i = 0; i < config.settingsNpc.Wear.Count; i++)
                    ItemManager.Create(ItemManager.FindItemDefinition(config.settingsNpc.Wear[i].ShortName), 1, config.settingsNpc.Wear[i].SkinId).MoveToContainer(npc.inventory.containerWear);
            #endregion
        }
        private void ClearEnt()
        {
            IEnumerable<BasePlayer> findplayer = FindMyBot(config.settingsNpc.userId);
            foreach (var player in findplayer)
                if (player != null)
                    player.KillMessage();

            List<BaseEntity> obj = new List<BaseEntity>();
            Vis.Entities(GetResultVector(), 10f, obj, LayerMask.GetMask("Construction", "Deployable", "Deployed", "Debris", "Default"));
            foreach (BaseEntity item in obj.Where(x => x.OwnerID == 76561198283599982))
            {
                if (item == null)
                    continue;
                item.Kill();
            }
            timer.Once(5f, () => { GenerateBuilding(); });
        }

        void OnPasteFinished(List<BaseEntity> pastedEntities, string fileName)
        {
            if (fileName.ToLower() != BuildingList["2"].name.ToLower())
                return;
            try
            {
                HouseNPC.AddRange(pastedEntities);
                foreach (BaseEntity item in HouseNPC)
                {
                    if (Light.Contains(item.prefabID))
                    {
                        item.enableSaving = true;
                        item?.SetFlag(BaseEntity.Flags.Reserved8, true);
                        item?.SetFlag(BaseEntity.Flags.On, true);
                        item?.SendNetworkUpdate();
                    }

                    NeonSign neonSign = item as NeonSign;
                    if (neonSign != null)
                    {
                        neonSign.SetFlag(BaseEntity.Flags.On, true);
                        neonSign.SetFlag(BaseEntity.Flags.Reserved8, true);
                        neonSign.isAnimating = true;
                        neonSign.InvokeRepeating(neonSign.animationLoopAction, 2f, 2f);
                        neonSign.SendNetworkUpdate();
                    }

                    SnowMachine snowMachine = item as SnowMachine;
                    if (snowMachine != null)
                    {
                        snowMachine.SetFlag(BaseEntity.Flags.Reserved8, true);
                        snowMachine.SetFlag(BaseEntity.Flags.Reserved7, false);
                        snowMachine.SetFlag(BaseEntity.Flags.Reserved6, true);
                        snowMachine.SetFlag(BaseEntity.Flags.Reserved5, true);
                    }

                    DecayEntity decayEntety = item as DecayEntity;
                    if (decayEntety != null)
                    {
                        decayEntety.decay = null;
                        decayEntety.decayVariance = 0;
                        decayEntety.ResetUpkeepTime();
                        decayEntety.DecayTouch();
                    }

                    DeployableBoomBox boomBox = item as DeployableBoomBox;
                    if (boomBox != null)
                    {
                        if (config.settings.useRadio)
                        {
                            NextTick(() => { 
                            boomBox.BoxController.CurrentRadioIp = config.settings.RadioStation;
                            boomBox.BoxController.ConditionLossRate = 0;
                            boomBox.BoxController.baseEntity.ClientRPC(null, "OnRadioIPChanged", boomBox.BoxController.CurrentRadioIp);
                            if (!boomBox.BoxController.IsOn())
                            {
                                boomBox.BoxController.ServerTogglePlay(true);
                            }
                            boomBox.BoxController.baseEntity.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);
                            });
                        }
                    }

                    BuildingBlock build = item as BuildingBlock;
                    if (build != null)
                    {
                        build.StopBeingDemolishable();
                        build.StopBeingRotatable();
                    }

                    if (item is ComputerStation)
                    {
                        chairNpc = item as ComputerStation;
                        continue;
                    }

                    Door door = item as Door;
                    if (door != null)
                    {
                        door.pickup.enabled = false;
                        door.canTakeLock = false;
                        door.canTakeCloser = false;
                    }

                    item.SetFlag(BaseEntity.Flags.Busy, true);
                    item.SetFlag(BaseEntity.Flags.Locked, true);
                }
                if(chairNpc != null)
                    InitializeNPC(chairNpc.transform.position);
                PrintWarning(GetLang("XDQUEST_CopyPasteSuccessfully"));
            }
            catch (Exception ex)
            {
                PrintError(GetLang("XDQUEST_BuildingPasteError"));
                Log(ex.InnerException.Message, "LogError");
            }
        }



        #endregion

        #region Scripts
        private class ZoneTrigger : FacepunchBehaviour
        {
            private float ZoneRadius;
            private Vector3 Position;

            private SphereCollider sphereCollider;
            private void Awake()
            {
                gameObject.layer = (int)Layer.Reserved1;
                gameObject.name = "ZoneTrigger1866";
                enabled = false;
            }

            public void Activate(Vector3 pos, float radius)
            {
                Position = pos;
                ZoneRadius = radius;
                transform.position = Position;
                transform.rotation = new Quaternion();

                UpdateCollider();
                gameObject.SetActive(true);
                enabled = true;
            }
            private void OnTriggerEnter(Collider col)
            {
                BasePlayer player = col.GetComponentInParent<BasePlayer>();
                if (player != null && !player.IsNpc && player.userID.IsSteamId())
                {
                    if (player.IsVisible(Instance.npc.eyes.position))
                    {
                        int mIndex = Random.Range(0, Instance.config.settingsSoundNPC.heySound.Count);
                        Instance.SoundPlay(Instance.config.settingsSoundNPC.heySound[mIndex]);
                    }
                }
            }

            private void OnTriggerExit(Collider col)
            {
                BasePlayer player = col.GetComponentInParent<BasePlayer>();
                if (player != null && !player.IsNpc && player.userID.IsSteamId())
                {
                    if (player.IsVisible(Instance.npc.eyes.position))
                    {
                        int mIndex = Random.Range(0, Instance.config.settingsSoundNPC.byeSound.Count);
                        Instance.SoundPlay(Instance.config.settingsSoundNPC.byeSound[mIndex]);
                    }
                    player.SendConsoleCommand("CloseMainUI");
                    if (Instance.openQuestPlayers.Contains(player.userID))
                    {
                        CuiHelper.DestroyUi(player, MiniQuestList);
                        Instance.OpenMQL_CMD(player);
                    }
                }
            }

            private void OnDestroy()
            {
                Destroy(gameObject);
                CancelInvoke();
            }

            private void UpdateCollider()
            {
                sphereCollider = gameObject.GetComponent<SphereCollider>();
                {
                    if (sphereCollider == null)
                    {
                        sphereCollider = gameObject.AddComponent<SphereCollider>();
                        sphereCollider.isTrigger = true;
                        sphereCollider.name = "ZoneTrigger1866";
                    }
                    sphereCollider.radius = ZoneRadius;
                }
            }
        }
        private class SafeZone : MonoBehaviour
        {
            private Vector3 Position;
            private float Radius;
            private void Awake()
            {
                gameObject.layer = (int)Layer.Reserved1;
                gameObject.name = "NpcZonesOrRadiation";
                var rigidbody = gameObject.AddComponent<Rigidbody>();
                rigidbody.useGravity = false;
                rigidbody.isKinematic = true;
            }
            public void Activate(Vector3 pos, float radius)
            {
                Position = pos;
                Radius = radius;
                transform.position = Position;
                UpdateCollider();
                gameObject.SetActive(true);
                enabled = true;
                var safeZone = gameObject.GetComponent<TriggerSafeZone>();
                safeZone = safeZone ?? gameObject.AddComponent<TriggerSafeZone>();
                safeZone.interestLayers = LayerMask.GetMask("Player (Server)");
                safeZone.enabled = true;
            }
            private void OnDestroy()
            {
                Destroy(gameObject);
            }
            private void UpdateCollider()
            {
                var sphereCollider = gameObject.GetComponent<SphereCollider>();
                {
                    if (sphereCollider == null)
                    {
                        sphereCollider = gameObject.AddComponent<SphereCollider>();
                        sphereCollider.isTrigger = true;
                    }
                    sphereCollider.radius = Radius;
                }
            }
        }
        #endregion

        #region Hooks
        #region QuestHook
        #region Type Upgrade
        object OnStructureUpgrade(BaseCombatEntity entity, BasePlayer player, BuildingGrade.Enum grade)
        {
            QuestProgress(player, QuestType.Grade, ((int)grade).ToString());
            return null;
        }
        #endregion
        #region IQPlagueSkill
        void StudySkill(BasePlayer player, string name) => QuestProgress(player, QuestType.IQPlagueSkill, name);
        #endregion
        #region HeadReward
        void KillHead(BasePlayer player) => QuestProgress(player, QuestType.IQHeadReward);

        #endregion
        #region IqCase
        void OpenCase(BasePlayer player, string name) => QuestProgress(player, QuestType.IQCases, name);
        #endregion
        #region OreBonus
        void RadOreGive(BasePlayer player, Item item) => QuestProgress(player, QuestType.OreBonus, item.info.shortname, "", null, item.amount);
        #endregion
        #region Chinook
        void LootHack(BasePlayer player) => QuestProgress(player, QuestType.XDChinookIvent);
        #endregion
        #region Gather
        private void OnDispenserGather(ResourceDispenser dispenser, BaseEntity entity, Item item)
        {
            NextTick(() =>
            {
                BasePlayer player = entity as BasePlayer; ;
                if (player != null)
                    QuestProgress(player, QuestType.Gather, item.info.shortname, "", null, item.amount);
            });
        }
        void OnDispenserBonus(ResourceDispenser dispenser, BaseEntity entity, Item item) => OnDispenserGather(dispenser, entity, item);

        void OnCollectiblePickup(Item item, BasePlayer player) => QuestProgress(player, QuestType.Gather, item.info.shortname, "", null, item.amount);
        #endregion
        #region Craft
        void OnItemCraftFinished(ItemCraftTask task, Item item) => QuestProgress(task.owner, QuestType.Craft, task.blueprint.targetItem.shortname, "", null, item.amount);
        #endregion
        #region Research
        void OnTechTreeNodeUnlock(Workbench workbench, TechTreeData.NodeInstance node, BasePlayer player) => QuestProgress(player, QuestType.Research, node.itemDef.shortname);
        void OnItemResearch(ResearchTable table, Item targetItem, BasePlayer player) => QuestProgress(player, QuestType.Research, targetItem.info.shortname);
        #endregion
        #region Deploy
        private void OnEntityBuilt(Planner plan, GameObject go)
        {
            BasePlayer player = plan?.GetOwnerPlayer();
            if (player == null || go == null || plan.GetItem() == null)
                return;
            BaseEntity ent = go.ToBaseEntity();
            if (ent == null || ent.skinID == 11543256361)
                return;
            QuestProgress(player, QuestType.Deploy, plan.GetItem().info.shortname);
        }
        #endregion
        #region Loot
        private static Dictionary<BasePlayer, List<UInt64>> LootersListCarte = new Dictionary<BasePlayer, List<UInt64>>();
        private void OnLootEntity(BasePlayer player, LootContainer entity)
        {
            if (entity == null || entity.net == null || player == null || entity.OwnerID.IsSteamId())
                return;
            if (!LootersListCarte.ContainsKey(player))
                LootersListCarte.Add(player, new List<UInt64> { });
            UInt64 netId = entity.net.ID;
            if (LootersListCarte[player].Contains(netId))
                return;
            QuestProgress(player, QuestType.Loot, "", "", entity.inventory.itemList);
            LootersListCarte[player].Add(netId);
        }
        private void OnLootEntity(BasePlayer player, NPCPlayerCorpse entity)
        {
            if (entity.OwnerID.IsSteamId() || entity == null)
                return;
            if (!LootersListCarte.ContainsKey(player))
                LootersListCarte.Add(player, new List<UInt64> { });
            UInt64 netId = entity.net.ID;
            if (LootersListCarte[player].Contains(netId))
                return;
            QuestProgress(player, QuestType.Loot, "", "", entity.containers[0].itemList);
            LootersListCarte[player].Add(netId);
        }

        private void OnContainerDropItems(ItemContainer container)
        {
            if (container == null)
                return;
            BaseEntity entity = container.entityOwner;
            if (entity == null)
                return;
            if (!entity.ShortPrefabName.Contains("barrel"))
                return;
            foreach (Item lootitem in container.itemList)
                lootitem.SetFlag(global::Item.Flag.Placeholder, true);
        }
        void OnItemPickup(Item item, BasePlayer player)
        {
            if (item == null || !item.HasFlag(global::Item.Flag.Placeholder))
                return;

            item.SetFlag(global::Item.Flag.Placeholder, false);
            QuestProgress(player, QuestType.Loot, item.info.shortname, item.skin.ToString(), count: item.amount);
        }

        #endregion
        #region Swipe
        private void OnCardSwipe(CardReader cardReader, Keycard card, BasePlayer player)
        {
            global::Item item = card.GetItem();
            if (item != null && card.accessLevel == cardReader.accessLevel && item.conditionNormalized > 0f)
            {
                QuestProgress(player, QuestType.Swipe, card.GetItem().info.shortname);
            }
        }
        #endregion
        #region  EntityKill/взорвать/уничтожить что либо 

        void OnPlayerDeath(BasePlayer player, HitInfo info)
        {
            if (player == null || info == null || player.userID < 2147483647)
                return;
            BasePlayer attacker = info.InitiatorPlayer;
            if (attacker == null)
                return;

            if (IsFriends(player.userID, attacker.userID) || IsClans(player.UserIDString, attacker.UserIDString) || IsDuel(attacker.userID) || player.userID == attacker.userID)
                return;

            QuestProgress(player, QuestType.EntityKill, "player");
        }

        void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            try
            {
                if (entity == null || info == null)
                    return;

                string targetName = entity?.ShortPrefabName;
                if (targetName.Contains("corpse") || targetName.Contains("servergibs") || targetName.Contains("player"))
                    return;
                if (targetName == "testridablehorse")
                {
                    targetName = "horse";
                }

                BasePlayer player = null;

                if (info.InitiatorPlayer != null)
                    player = info.InitiatorPlayer;
                else if (entity.GetComponent<BaseHelicopter>() != null)
                {
                    PatrolHelicopterAI helicopterAI = entity?.GetComponent<PatrolHelicopterAI>();
                    if (helicopterAI == null)
                        return;
                    player = helicopterAI._targetList[helicopterAI._targetList.Count - 1].ply;
                }
                if (player != null && !player.IsNpc && entity.ToPlayer() != player)
                {
                    QuestProgress(player, QuestType.EntityKill, targetName.ToLower());
                }
            }
            catch (Exception)
            {
            }
        }
        #endregion
        #region (NEW) Покупки у НПС
        void OnNpcGiveSoldItem(NPCVendingMachine machine, Item soldItem, BasePlayer buyer) => QuestProgress(buyer, QuestType.PurchaseFromNpc, soldItem.info.shortname, "", null, soldItem.amount);
        #endregion
        #region(NEW) Взлом ящика
        void CanHackCrate(BasePlayer player, HackableLockedCrate crate)
        {
            QuestProgress(player, QuestType.HackCrate, "", "", null);
        }
        #endregion
        #region (NEW) RecycleItem (Игрок не должен выходить из интерфейса переработчика)
        private Dictionary<uint, BasePlayer> recyclePlayer = new Dictionary<uint, BasePlayer>();
        void OnRecyclerToggle(Recycler recycler, BasePlayer player)
        {
            if (!recycler.IsOn())
            {
                if (recyclePlayer.ContainsKey(recycler.net.ID))
                {
                    recyclePlayer.Remove(recycler.net.ID);
                    recyclePlayer.Add(recycler.net.ID, player);
                }
                else
                    recyclePlayer.Add(recycler.net.ID, player);
            }
            else
               if (recyclePlayer.ContainsKey(recycler.net.ID))
                recyclePlayer.Remove(recycler.net.ID);
        }
        void OnRecycleItem(Recycler recycler, Item item)
        {
            if (recyclePlayer.ContainsKey(recycler.net.ID))
            {
                int num2 = 1;
                if (item.amount > 1)
                    num2 = Mathf.CeilToInt(Mathf.Min((float)item.amount, (float)item.info.stackable * 0.1f));
                QuestProgress(recyclePlayer[recycler.net.ID], QuestType.RecycleItem, item.info.shortname, "", null, num2);
            }
        }
        #endregion
        #region (NEW) Growseedlings
        void OnGrowableGathered(GrowableEntity plant, Item item, BasePlayer player)
        {
            QuestProgress(player, QuestType.Growseedlings, item.info.shortname, "", null, item.amount);
        }
        #endregion
        #region (NEW) Raidable Bases (Nivex)
        void OnRaidableBaseCompleted(Vector3 location, int mode, bool allowPVP, string id, float spawnTime, float despawnTime, float loadingTime, ulong ownerId, BasePlayer owner, List<BasePlayer> raiders)
        {
            BasePlayer player = null;
            if (owner == null)
                if (raiders?.Count != 0)
                    player = raiders[0];
                else
                    return;
            else
                player = owner;

            if (player != null)
                QuestProgress(player, QuestType.RaidableBases, mode.ToString(), "", null);
        }
        #endregion
        #region (NEW) Fishing
        void OnFishCatch(Item fish, BaseFishingRod fishingRod, BasePlayer player)
        {
            if (player == null || fish == null)
                return;
            QuestProgress(player, QuestType.Fishing, fish.info.shortname, "", null, fish.amount);
        }
        #endregion

        #endregion
        private void OnNewSave()
        {
            if (config.settings.useWipe)
            {
                playersInfo?.Clear();
            }
        }
        object CanLootEntity(BasePlayer player, StorageContainer container)
        {
            if (container.skinID == 1195832261)
            {
                MainUi(player);
                return false;
            }
            return null;
        }
        object CanAffordUpgrade(BasePlayer player, BuildingBlock block, BuildingGrade.Enum grade)
        {
            if (block.OwnerID == 76561198283599982)
                return false;
            else
                return null;
        }
        void Init()
        {
            LoadPlayerData();
            LoadQuestData();
            Unsubscribe(nameof(OnEntityTakeDamage));
        }

        private void OnServerInitialized()
        {
            monument = TerrainMeta.Path.Monuments.FirstOrDefault(p => p.name.ToLower().Contains("compound") && p.IsSafeZone == true);
            Instance = this;
            if (!CopyPaste)
            {
                NextTick(() => {
                    PrintError("Check if you have the 'Copy Paste'plugin installed");
                    Interface.Oxide.UnloadPlugin(Name);
                });
                return;
            }
            else if (CopyPaste.Version < new VersionNumber(4, 1, 27))
            {
                NextTick(() => {
                    PrintError("You have an old version of Copy Paste!\nplease update the plugin to the latest version (4.1.27 or higher) - https://umod.org/plugins/copy-paste");
                    Interface.Oxide.UnloadPlugin(Name);
                });
                return;
            }
            if (monument == null && !config.customPosition.useCustomPos)
            {
                NextTick(() =>
                {
                    PrintError(GetLang("XDQUEST_MissingOutPost"));
                    Interface.Oxide.UnloadPlugin(Name);
                });
                return;
            }
            if (QuestList.Count == 0)
            {
                NextTick(() =>
                {
                    PrintError(GetLang("XDQUEST_MissingQuests"));
                });
                return;
            }
            //cmd.AddChatCommand(config.settings.questListProgress, this, nameof(OpenMQL_CMD));
            ImageUi.DownloadImages();
            ServerMgr.Instance.StartCoroutine(DownloadImages());   
            LoadDataCopyPaste();
            LoadDataSound();
            foreach (var player in BasePlayer.activePlayerList)
                OnPlayerConnected(player);
            if (config.settings.useDecay)
                Subscribe(nameof(OnEntityTakeDamage));
        }
        void OnEntityTakeDamage(BaseCombatEntity victim, HitInfo info)
        {
            if (info.damageTypes.Has(DamageType.Decay))
            {
                if (victim?.OwnerID == 76561198283599982)
                {
                    info.damageTypes.Scale(DamageType.Decay, 0);
                }
            }
        }
        void OnPlayerConnected(BasePlayer player)
        {
            if (!playersInfo.ContainsKey(player.userID))
            {
                playersInfo.Add(player.userID, new PlayerData());
            }
            else
            {
                foreach (var item in playersInfo[player.userID].PlayerQuestsAll)
                {
                    var curentQuest = QuestList.FirstOrDefault(p => p.DisplayName == item.parentQuest.DisplayName);
                    if (curentQuest == null)
                    {
                        NextTick(() => {
                            playersInfo[player.userID].PlayerQuestsAll.Remove(item);
                        });
                    }
                }
            }
            foreach (KeyValuePair<String, String> item in ImageUi.Images)
                SendImage(player, item.Key);

            PlayersTime.Add(player.userID, null);
        }
        void OnServerSave()
        {
            timer.Once(10f, SaveData);
        }
        private void OnPlayerDisconnected(BasePlayer d)
        {
            if (openQuestPlayers.Contains(d.userID))
                openQuestPlayers.Remove(d.userID);
            if (PlayersTime.ContainsKey(d.userID))
            {
                if (PlayersTime[d.userID] != null)
                    ServerMgr.Instance.StopCoroutine(PlayersTime[d.userID]);
                PlayersTime.Remove(d.userID);
            }
        }
        void OnServerShutdown() => Unload();
        void Unload()
        {
            Instance = null;
            if (config.settings.mapUse)
                Interface.CallHook("API_RemoveMarker", "xdquest");
            SaveData();
            if(zoneTrigger != null)
                UnityEngine.Object.DestroyImmediate(zoneTrigger);
            if(safeZone != null)
                UnityEngine.Object.DestroyImmediate(safeZone);

            for (int i = 0; i < HouseNPC.Count; i++)
            {
                if (!HouseNPC[i].IsDestroyed)
                    HouseNPC[i]?.Kill();
            }
            npc?.KillMessage();
            foreach (BasePlayer p in BasePlayer.activePlayerList)
            {
                if (PlayersTime.ContainsKey(p.userID))
                {
                    if (PlayersTime[p.userID] != null)
                        ServerMgr.Instance.StopCoroutine(PlayersTime[p.userID]);
                }
                PlayersTime.Clear();
                CuiHelper.DestroyUi(p, MiniQuestList); CuiHelper.DestroyUi(p, Layers);
            }
            ImageUi.Unload();
        }
        #endregion

        #region SoundNpc (HumanNpc)

        private readonly Hash<string, NpcSound> Sounds = new Hash<string, NpcSound>();
        private readonly Hash<string, NpcSound> cached = new Hash<string, NpcSound>();

        public class NpcSound
        {
            [JsonConverter(typeof(SoundFileConverter))]
            public List<byte[]> Data = new List<byte[]>();
        }

        private class SoundFileConverter : JsonConverter
        {
            public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
            {
            }

            public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
            {
                JToken value = JToken.Load(reader);
                return Instance.FromSaveData(Compression.Uncompress(Convert.FromBase64String(value.ToString())));
            }

            public override bool CanConvert(Type objectType)
            {
                return typeof(List<byte>) == objectType;
            }
        }
        private void LoadDataSound()
        {
            var sound = config.settingsSoundNPC.heySound.Concat(config.settingsSoundNPC.byeSound).Concat(config.settingsSoundNPC.takeQuestSound).Concat(config.settingsSoundNPC.turnQuestSound);
            foreach (var item in sound)
                LoadDataSound(item);
        }
        private NpcSound LoadDataSound(string name)
        {
            NpcSound cache = cached[name];
            if (cache != null)
                return cache;

            if (Interface.Oxide.DataFileSystem.ExistsDatafile(Name + "/Sounds/" + name))
            {
                NpcSound data = Interface.GetMod().DataFileSystem.ReadObject<NpcSound>(Name + "/Sounds/" + name);
                if (data == null)
                    return null;

                cached[name] = data;
                return data;
            }
            else
            {
                PrintWarning(GetLang("XDQUEST_SoundLoadErrorExt", null, name));
                return null;
            }      
        }

        public List<uint> BotAlerts = new List<uint>();
        private Coroutine SoundRoutine { get; set; }
        public void SoundPlay(string clip)
        {
            if (BotAlerts.Contains(npc.net.ID))
                return;
            else
                BotAlerts.Add(npc.net.ID);

            if (SoundRoutine == null)
                SoundRoutine = InvokeHandler.Instance.StartCoroutine(API_NPC_SendToAll(clip));
        }
        private List<byte[]> FromSaveData(byte[] bytes)
        {
            List<int> dataSize = new List<int>();
            List<byte[]> dataBytes = new List<byte[]>();

            int offset = 0;
            while (true)
            {
                dataSize.Add(BitConverter.ToInt32(bytes, offset));
                offset += 4;

                int sum = dataSize.Sum();
                if (sum == bytes.Length - offset)
                {
                    break;
                }

                if (sum > bytes.Length - offset)
                {
                    throw new ArgumentOutOfRangeException(nameof(dataSize),
                        $"Voice Data is outside the saved range {dataSize.Sum()} > {bytes.Length - offset}");
                }
            }

            foreach (int size in dataSize)
            {
                dataBytes.Add(bytes.Skip(offset).Take(size).ToArray());
                offset += size;
            }

            return dataBytes;
        }
        private IEnumerator API_NPC_SendToAll(string clipName)
        {
            NpcSound sound = LoadDataSound(clipName);
            if (sound == null)
            {
                SoundRoutine = null;
                BotAlerts.Remove(npc.net.ID);
                yield break;
            }
            yield return CoroutineEx.waitForSeconds(0.1f);  

            foreach (var data in sound.Data)
            {
                if (npc == null)
                    break;
                SendSound(npc.net.ID, data);
                yield return CoroutineEx.waitForSeconds(0.07f);
            }
            SoundRoutine = null;
            BotAlerts.Remove(npc.net.ID);
            yield break;
        }

        private void SendSound(uint netId, byte[] data)
        {
            if (!Net.sv.write.Start())
                return;
            foreach (BasePlayer current in BasePlayer.activePlayerList.Where(current => current.IsConnected && Vector3.Distance(npc.transform.position, current.transform.position) <= 100))
            {
                if (npc == null)
                    return;
                Net.sv.write.PacketID(Message.Type.VoiceData);
                Net.sv.write.UInt32(netId);
                Net.sv.write.BytesWithSize(data);
                Net.sv.write.Send(new SendInfo(current.Connection) { priority = Priority.Immediate });
            }
        }
        #endregion

        #region ApiLoadData

        private void LoadDataCopyPaste(Boolean repeat = false)
        {
            if (!Interface.Oxide.DataFileSystem.ExistsDatafile("copypaste/" + BuildingList["2"].name))
            {
                PrintWarning("Dont habe build for copypaste");
            }
            else
            {
                ClearEnt();
            }
        }

        private IEnumerator DownloadImages()
        {
            PrintWarning("Loading icon for item....");
            foreach (var img in QuestList)
            {
                for (int i = 0; i < img.PrizeList.Count; i++)
                {
                    var typeimg = img.PrizeList[i];
                    if (typeimg.type == PrizeType.CustomItem)
                    {
                        if (!(bool)ImageLibrary?.Call("HasImage", typeimg.ShortName + 128, typeimg.SkinID))
                            ImageLibrary.Call("AddImage", $"http://api.skyplugins.ru/api/getskin/{typeimg.SkinID}/128", typeimg.ShortName + 128, typeimg.SkinID);
                    }
                    else if (typeimg.type == PrizeType.Command)
                    {
                        if (!(bool)ImageLibrary?.Call("HasImage", typeimg.Url))
                            ImageLibrary.Call("AddImage", typeimg.Url, typeimg.Url);
                    }
                    else
                    {
                        if (!(bool)ImageLibrary?.Call("HasImage", typeimg.ShortName + 128))
                            ImageLibrary.Call("AddImage", $"https://www.rustedit.io/images/imagelibrary/{typeimg.ShortName}.png", typeimg.ShortName + 128);
                    }
                    yield return new WaitForSeconds(0.05f);
                }
            }
            PrintWarning("All icon load!");
            yield return 0;
        }
        private static class ImageUi
        {
            public static Dictionary<string, string> Images = new Dictionary<string, string>();
            private static Dictionary<int, string> _images = new Dictionary<int, string>()
            {
                { 1, "https://i.imgur.com/MaVprLF.png" },
                { 2, "https://i.imgur.com/olNJLKj.png" },
                { 3, "https://i.imgur.com/0gaw5bk.png" },
                { 4, "https://i.imgur.com/SUpj74n.png" },
                { 5, "https://i.imgur.com/R4Z7kga.png" },
                { 6, "https://i.imgur.com/O5tKfx8.png" },
                { 7, "https://i.imgur.com/3oJDUaW.png" },
                { 8, "https://i.imgur.com/8O7rbkB.png" },
                { 9, "https://i.imgur.com/Vc644y4.png" },
                { 10, "https://i.imgur.com/P3VQCGj.png" },
                { 11, "https://i.imgur.com/teD0rUV.png" },
                { 12, "https://i.imgur.com/EMwKXBG.png" },
                { 13, "https://i.imgur.com/7DLsfNL.png" },
                { 14, "https://i.imgur.com/3XcngXN.png" },
                { 15, "https://i.imgur.com/suFxlPG.png" },
            };
            public static void DownloadImages()
            {
                ServerMgr.Instance.StartCoroutine(AddImage($"https://www.rustedit.io/images/imagelibrary/blueprintbase.png", "blueprintbase"));

                for (int i = 1; i < 16; i++)
                {
                    ServerMgr.Instance.StartCoroutine(AddImage($"{_images[i]}", i.ToString()));
                }
            }

            private static IEnumerator AddImage(string url, string name)
            {
                UnityWebRequest www = UnityWebRequest.Get(url);

                yield return www.SendWebRequest();
                if (Instance == null)
                    yield break;
                if (www.isNetworkError || www.isHttpError)
                {
                    Instance.PrintWarning(string.Format("Image download error! Error: {0}, Image name: {1}", www.error, name));
                    www.Dispose();

                    yield break;
                }

                Texture2D texture = new Texture2D(2, 2);
                texture.LoadImage(www.downloadHandler.data);
                if (texture != null)
                {
                    byte[] bytes = texture.EncodeToPNG();
                    Interface.Oxide.DataFileSystem.WriteObject($"qwest/{name}", bytes.ToList());
                    var image = FileStorage.server.Store(bytes, FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID).ToString();
                    if (!Images.ContainsKey(name))
                        Images.Add(name, image);
                    else
                        Images[name] = image;
                    UnityEngine.Object.DestroyImmediate(texture);
                }

                www.Dispose();
                yield break;
            }

            public static string GetImage(String ImgKey)
            {
                if (Images.ContainsKey(ImgKey))
                    return Images[ImgKey];
                return Instance.GetImage("LOADING");
            }

            public static void Unload()
            {
                foreach (var item in Images)
                    FileStorage.server.RemoveExact(uint.Parse(item.Value), FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID, 0U);
            }
        }
        #endregion

        #region HelpMetods
        private void QuestProgress(BasePlayer player, QuestType questType, String entName = "", String skinId = "", List<Item> items = null, int count = 1)
        {
            if (player == null || !playersInfo.ContainsKey(player.userID))
                return;

            var playerQuests = playersInfo[player.userID].PlayerQuestsAll.Where(x => x.parentQuest.QuestType == questType && x.Finished == false);
            if (playerQuests == null)
                return;
            foreach (PlayerQuest quest in playerQuests)
            {
                if (entName == "" && items == null)
                {
                    quest.AddCount(count);
                    return;
                }
                if (items != null)
                {
                    for (int i = 0; i < items.Count; i++)
                    {
                        var item = items[i];
                        if (item.info.shortname.ToLower().Contains(quest.parentQuest.Target.ToLower()) || item.skin.ToString() == quest.parentQuest.Target)
                            quest.AddCount(item.amount);
                    }
                }
                else
                {
                    if (questType == QuestType.OreBonus || questType == QuestType.IQCases || questType == QuestType.IQHeadReward)
                    {
                        if (quest.parentQuest.Target == entName || quest.parentQuest.Target == "0")
                            quest.AddCount(count);
                        continue;
                    }
                    if (entName.ToLower().Contains(quest.parentQuest.Target.ToLower()) || skinId == quest.parentQuest.Target)
                        quest.AddCount(count);
                }
            }

        }
        void RunEffect(BasePlayer player, string path)
        {
            Effect effect = new Effect();
            effect.Init(Effect.Type.Generic, player.transform.position, player.transform.forward, (Connection)null);
            effect.pooledString = path; EffectNetwork.Send(effect, player.net.connection);
        }
        public static class TimeHelper
        {
            public static string FormatTime(TimeSpan time, int maxSubstr = 5, string language = "ru")
            {
                string result = string.Empty;
                switch (language)
                {
                    case "ru":
                        int i = 0;
                        if (time.Days != 0 && i < maxSubstr)
                        {
                            if (!string.IsNullOrEmpty(result))
                                result += " ";

                            result += $"{Format(time.Days, "д", "д", "д")}";
                            i++;
                        }
                        if (time.Hours != 0 && i < maxSubstr)
                        {
                            if (!string.IsNullOrEmpty(result))
                                result += " ";

                            result += $"{Format(time.Hours, "ч", "ч", "ч")}";
                            i++;
                        }
                        if (time.Minutes != 0 && i < maxSubstr)
                        {
                            if (!string.IsNullOrEmpty(result))
                                result += " ";

                            result += $"{Format(time.Minutes, "м", "м", "м")}";
                            i++;
                        }
                        if (time.Days == 0)
                        {
                            if (time.Seconds != 0 && i < maxSubstr)
                            {
                                if (!string.IsNullOrEmpty(result))
                                    result += " ";

                                result += $"{Format(time.Seconds, "с", "с", "с")}";
                                i++;
                            }
                        }
                        break;
                    default:
                        result = string.Format("{0}{1}{2}{3}",
                            time.Duration().Days > 0
                                ? $"{time.Days:0} day{(time.Days == 1 ? String.Empty : "s")}, "
                                : string.Empty,
                            time.Duration().Hours > 0
                                ? $"{time.Hours:0} hour{(time.Hours == 1 ? String.Empty : "s")}, "
                                : string.Empty,
                            time.Duration().Minutes > 0
                                ? $"{time.Minutes:0} minute{(time.Minutes == 1 ? String.Empty : "s")}, "
                                : string.Empty,
                            time.Duration().Seconds > 0
                                ? $"{time.Seconds:0} second{(time.Seconds == 1 ? String.Empty : "s")}"
                                : string.Empty);

                        if (result.EndsWith(", ")) result = result.Substring(0, result.Length - 2);

                        if (string.IsNullOrEmpty(result)) result = "0 seconds";
                        break;
                }
                return result;
            }

            private static string Format(int units, string form1, string form2, string form3)
            {
                var tmp = units % 10;

                if (units >= 5 && units <= 20 || tmp >= 5 && tmp <= 9)
                    return $"{units}{form1}";

                if (tmp >= 2 && tmp <= 4)
                    return $"{units}{form2}";

                return $"{units}{form3}";
            }
        }
        private static double CurrentTime() => Facepunch.Math.Epoch.Current;

        public static StringBuilder sb = new StringBuilder();
        public string GetLang(string LangKey, string userID = null, params object[] args)
        {
            sb.Clear();
            if (args != null)
            {
                sb.AppendFormat(lang.GetMessage(LangKey, this, userID), args);
                return sb.ToString();
            }
            return lang.GetMessage(LangKey, this, userID);
        }

        private class PasteData
        {
            public Dictionary<string, object> @default;
            public ICollection<Dictionary<string, object>> entities;
            public Dictionary<string, object> protocol;
        }
        public Vector3 GetResultVector()
        {
            if (config.customPosition.useCustomPos)
                return config.customPosition.pos;
            return monument.transform.position + monument.transform.rotation * BuildingList["2"].pos;
        }
        private IEnumerable<BasePlayer> FindMyBot(ulong userid)
        {
            return BasePlayer.allPlayerList.Where(x => x.userID == userid);
        }
        void Log(string msg, string file)
        {
            LogToFile(file, $"[{DateTime.Now}] {msg}", this);
        }
        #endregion

        #region NewUi

        List<ulong> openQuestPlayers = new List<ulong>();
        private Dictionary<ulong, Coroutine> PlayersTime = new Dictionary<ulong, Coroutine>();
        private const string MiniQuestList = "Mini_QuestList";
        private const string Layers = "UI_QuestMain";
        private const string LayerMainBackground = "UI_QuestMainBackground";

        #region MainUI

        void MainUi(BasePlayer player)
        {
            var container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                CursorEnabled = true,
                Image = { Color = "1 1 1 0" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" }
            }, "Overlay", Layers);

            container.Add(new CuiElement
            {
                Name = LayerMainBackground,
                Parent = Layers,
                Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1",Png = ImageUi.GetImage("1")},
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                }
            });

            container.Add(new CuiElement
            {
                Name = "CloseUIImage",
                Parent = LayerMainBackground,
                Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1",Png = ImageUi.GetImage("2")},
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = "96.039 87.558", OffsetMax = "135.315 114.647" }                }
            });

            container.Add(new CuiButton
            {
                Button = { Color = "1 1 1 0", Command = "CloseMainUI" },
                Text = { Text = "", Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "0 0 0 1" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = "96.039 87.558", OffsetMax = "135.315 114.647" }
            }, LayerMainBackground, "BtnCloseUI");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "96.227 191.4", OffsetMax = "208.973 211.399" },
                Text = { Text = GetLang("XDQUEST_UI_TASKLIST", player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleLeft, Color = "0.7169812 0.7169812 0.7169812 1" }
            }, LayerMainBackground, "LabelQuestList");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-269.184 -102.227", OffsetMax = "-197.242 -72.373" },
                Text = { Text = GetLang("XDQUEST_UI_Awards", player.UserIDString), Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" }
            }, LayerMainBackground, "PrizeTitle");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "250.187 191.399", OffsetMax = "350.187 211.401" },
                Text = { Text = GetLang("XDQUEST_UI_TASKCount", player.UserIDString, QuestList.Count), Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleRight, Color = "1 1 1 1" }
            }, LayerMainBackground, "LabelQuestCount");

            CuiHelper.DestroyUi(player, "UI_QuestMain");
            CuiHelper.AddUi(player, container);
            QuestListUI(player);
            QuestInfo(player, 0);
        }

        #endregion

        #region QuestList
        void QuestListUI(BasePlayer player, int page = 0)
        {
            PlayerData playerQuests = playersInfo[player.userID];
            if (playerQuests == null)
                return;
            int y = 0;
            var container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                Image = { Color = "0 0 0 0" },
                RectTransform = { AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "96.23 -234.241", OffsetMax = "347.79 181.441" }
            }, LayerMainBackground, "QuestListPanel");

            #region PageSettings

            if (page != 0)
            {
                container.Add(new CuiElement
                {
                    Parent = LayerMainBackground,
                    Name = "UPBTN",
                    Components =
                    {
                        new CuiRawImageComponent { Png = ImageUi.GetImage("3"), Color = "1 1 1 1" },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = "182.89 87.565", OffsetMax = "221.51 114.635" }   }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Color = "0 0 0 0", Command = $"UI_Handler page {page - 1}" },
                    Text = { Text = "" }
                }, "UPBTN");
            }
            if (page + 1 < (int)Math.Ceiling((double)QuestList.Count / 6))
            {
                container.Add(new CuiElement
                {
                    Parent = LayerMainBackground,
                    Name = "DOWNBTN",
                    Components =
                    {
                        new CuiRawImageComponent { Png = ImageUi.GetImage("4"), Color = "1 1 1 1" },
                        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = "139.598 87.568", OffsetMax = "178.326 114.632" }
                    }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Color = "0 0 0 0", Command = $"UI_Handler page {page + 1}" },
                    Text = { Text = "" }
                }, "DOWNBTN");
            }

            #endregion

            var ql = QuestList.OrderByDescending(q => playerQuests.PlayerQuestsAll.Exists(x => x.parentQuest.DisplayName == q.DisplayName ))
                .ThenByDescending(r => !playerQuests.PlayerQuestsFinish.Exists(q => q == r.DisplayName) && !playerQuests.PlayerQuestsCooldown.ContainsKey(r.DisplayName));

            foreach (var item in ql.Skip(page * 6))
            {
                Int32 index = QuestList.IndexOf(item);
                var curentQuest = playerQuests.PlayerQuestsAll.FirstOrDefault(p => p.parentQuest.DisplayName == item.DisplayName);
                container.Add(new CuiElement
                {
                    Name = "Quest",
                    Parent = "QuestListPanel",
                    Components = {
                    new CuiRawImageComponent { Color = $"1 1 1 1", Png = ImageUi.GetImage("5") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = $"-125.78 {-67.933 - (y * 69.413)}", OffsetMax = $"125.78 {-1.06 - (y * 69.413)}" }
                }
                });
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-109.661 -33", OffsetMax = "113.14 -12.085" },
                    Text = { Text = item.DisplayName, Font = "robotocondensed-bold.ttf", FontSize = 13, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" }
                }, "Quest", "QuestName");

                if (curentQuest != null)
                {
                    String Img = "";
                    String Txt = "";
                    if (curentQuest.Finished)
                    {
                        Img = "15";
                        Txt = GetLang("XDQUEST_UI_CHIPperformed", player.UserIDString);
                    }
                    else
                    {
                        Img = "14";
                        Txt = GetLang("XDQUEST_UI_CHIPInProgress", player.UserIDString);
                    }

                    container.Add(new CuiElement
                    {
                        Name = "QuestBar",
                        Parent = "Quest",
                        Components = {
                            new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage(Img) },
                            new CuiRectTransformComponent { AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "17.19 -16.717", OffsetMax = "97.902 -2.411" }
                        }
                    });
                    container.Add(new CuiLabel
                    {
                        RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-34.924 -7.153", OffsetMax = "40.356 7.153" },
                        Text = { Text = Txt, Font = "robotocondensed-bold.ttf", FontSize = 10, Align = TextAnchor.UpperCenter, Color = "1 1 1 1" }
                    }, "QuestBar", "BarLabel");
                }


                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "0 0" },
                    Button = { Color = "0 0 0 0", Command = $"UI_Handler questinfo {index}" },
                    Text = { Text = "" }
                }, $"Quest");


                if (y >= 5)
                    break;
                y++;
            }

            CuiHelper.DestroyUi(player, "DOWNBTN");
            CuiHelper.DestroyUi(player, "UPBTN");
            CuiHelper.DestroyUi(player, "QuestListPanel");
            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region QuestInfo
        private void QuestInfo(BasePlayer player, int quest)
        {
            List<PlayerQuest> playerQuests = playersInfo[player.userID].PlayerQuestsAll;
            if (playerQuests == null)
                return;
            player.SetFlag(BaseEntity.Flags.Reserved3, false);
            var quests = QuestList[quest];
            var curentQuest = playerQuests.FirstOrDefault(p => p.parentQuest.DisplayName == quests.DisplayName);

            var container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                Image = { Color = "1 1 1 0" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-280.488 -234.241", OffsetMax = "564.144 212.279" }
            }, LayerMainBackground, "QuestInfoPanel");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "23.704 -42.956", OffsetMax = "420.496 -16.044" },
                Text = { Text = quests.DisplayName, Font = "robotocondensed-bold.ttf", FontSize = 19, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" }
            }, "QuestInfoPanel", "QuestName");

            string userepeat = quests.UseRepeat ? GetLang("XDQUEST_UI_QUESTREPEATCAN", player.UserIDString) : GetLang("XDQUEST_UI_QUESTREPEATfForbidden", player.UserIDString);
            string useCooldown = quests.Cooldown > 0 ? TimeHelper.FormatTime(TimeSpan.FromSeconds(quests.Cooldown), 5, lang.GetLanguage(player.UserIDString)) : GetLang("XDQUEST_UI_Missing", player.UserIDString);
            string bring = quests.Bring ? GetLang("XDQUEST_UI_QuestNecessary", player.UserIDString) : GetLang("XDQUEST_UI_QuestNotNecessary", player.UserIDString);
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "23.705 -54.066", OffsetMax = "420.495 -40.134" },
                Text = { Text = GetLang("XDQUEST_UI_InfoRepeatInCD", player.UserIDString, userepeat, useCooldown, bring), Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.UpperLeft, Color = "0.9607844 0.5843138 0.1960784 1" }
            }, "QuestInfoPanel", "QuestInfo2");

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-398.895 -289.293", OffsetMax = "106.815 -76.2" },
                Text = { Text = quests.Description, Font = "robotocondensed-regular.ttf", FontSize = 16, Align = TextAnchor.UpperLeft, Color = "1 1 1 1" }
            }, "QuestInfoPanel", "QuestDescription");

            #region QuestButton

            string command = "";
            string image = "";
            string text = "";
            if (curentQuest == null)
            {
                if (!quests.UseRepeat && playersInfo[player.userID].PlayerQuestsFinish.Contains(quests.DisplayName))
                {
                    text = GetLang("XDQUEST_UI_QuestBtnPerformed", player.UserIDString);
                    image = "6";
                    command = $"UI_Handler get {quest}";
                }
                else
                {
                    text = GetLang("XDQUEST_UI_QuestBtnTake", player.UserIDString);
                    image = "7";
                    command = $"UI_Handler get {quest}";
                }
            }
            else if (curentQuest.Finished)
            {
                text = GetLang("XDQUEST_UI_QuestBtnPass", player.UserIDString);
                image = "7";
                command = $"UI_Handler finish {quest}";
            }
            else
            {
                text = GetLang("XDQUEST_UI_QuestBtnRefuse", player.UserIDString);
                image = "6";
                command = $"UI_Handler finish {quest}";
            }
            if (playersInfo[player.userID].PlayerQuestsCooldown != null && playersInfo[player.userID].PlayerQuestsCooldown.ContainsKey(quests.DisplayName) && playersInfo[player.userID].PlayerQuestsCooldown[quests.DisplayName] >= CurrentTime())
            {
                text = lang.GetMessage(TimeHelper.FormatTime(TimeSpan.FromSeconds(playersInfo[player.userID].PlayerQuestsCooldown[quests.DisplayName] - CurrentTime()), 5, lang.GetLanguage(player.UserIDString)), this, player.UserIDString);
                image = "6";
                command = $"UI_Handler coldown";
                player.SetFlag(BaseEntity.Flags.Reserved3, true);
            }

            container.Add(new CuiElement
            {
                Name = Layers + "QuestButtonImage",
                Parent = "QuestInfoPanel",
                Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png =ImageUi.GetImage(image)},
                    new CuiRectTransformComponent { AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = "-416.142 -49.709", OffsetMax = "-306.058 -7.691" }
                }
            });

            container.Add(new CuiButton
            {
                Button = { Color = "0 0 0 0", Command = command },
                Text = { Text = text, Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-55.039 -21.01", OffsetMax = "55.041 21.009" }
            }, Layers + "QuestButtonImage", Layers + "ButtonQuest");

            #endregion

            #region QuestCheckBox

            container.Add(new CuiElement
            {
                Name = "QuestCheckBox",
                Parent = "QuestInfoPanel",
                Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1",  Png = ImageUi.GetImage("9")  },
                    new CuiRectTransformComponent { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-279.228 1.334", OffsetMax = "-1.217 125.64" }
                }
            });

            String CheckBox = curentQuest == null ? "10" : curentQuest.Finished ? "11" : "10";

            container.Add(new CuiElement
            {
                Name = "CheckBoxImg",
                Parent = "QuestCheckBox",
                Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage(CheckBox) },
                    new CuiRectTransformComponent { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "20.729 -35.467", OffsetMax = "38.205 -18.005" }
                }
            });

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-91.326 -55.693", OffsetMax = "136.647 -16.904" },
                Text = { Text = quests.Missions, Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.UpperLeft, Color = "1 1 1 1" }
            }, "QuestCheckBox", "CheckBoxTxt");

            if (curentQuest != null)
            {
                Double Factor = 278.005 * curentQuest.Count / curentQuest.parentQuest.Amount;
                container.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    Image = { Color = "0.3843138 0.3686275 0.3843138 0.9137255" },
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = "-0.000 -0.153", OffsetMax = $"278.005 40.106" }
                }, "QuestCheckBox", "QuestProgresBar");
                container.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    Image = { Color = "0.4462442 0.8679245 0.5786404 0.6137255" },
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = "-0.000 -0.153", OffsetMax = $"{Factor} 40.106" }
                }, "QuestProgresBar");
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-139.005 -20.129", OffsetMax = "139.005 20.13" },
                    Text = { Text = $"{curentQuest.Count} / {curentQuest.parentQuest.Amount}", Font = "robotocondensed-bold.ttf", FontSize = 16, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" }
                }, "QuestProgresBar", "Progres");
            }

            #endregion

            #region PrizeList
            for (int i = 0, x = 0, y = 0; i < quests.PrizeList.Count; i++)
            {
                var prize = quests.PrizeList[i];

                string prizeLayer = "QuestInfo" + $".{i}";
                container.Add(new CuiElement
                {
                    Name = prizeLayer,
                    Parent = "QuestInfoPanel",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("8")},
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = $"{23.42 + (x * 120.912)} {79.39 - (y * 78.345)}", OffsetMax = $"{129.555 + (x * 120.912)} {125.9 - (y * 78.345)}" }
                }
                });

                var img = prize.type == PrizeType.CustomItem ? GetImage(prize.ShortName + 128, prize.SkinID) : prize.type == PrizeType.Item ? GetImage(prize.ShortName + 128) : prize.type == PrizeType.Command ? GetImage(prize.Url) : "";
                if (img != "")
                {
                    container.Add(new CuiElement
                    {
                        Parent = prizeLayer,
                        Components = {
                            new CuiRawImageComponent { Color = "1 1 1 1", Png = img },
                            new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-10.059 -20.625", OffsetMax = "32.941 22.375" }
                        }
                    });
                }
                else
                {
                    container.Add(new CuiElement
                    {
                        Parent = prizeLayer,
                        Components = {
                            new CuiRawImageComponent { Color = "1 1 1 1", Png =ImageUi.GetImage("blueprintbase") },
                            new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-10.059 -20.625", OffsetMax = "32.941 22.375" }
                        }
                    });
                    container.Add(new CuiElement
                    {
                        Parent = prizeLayer,
                        Components = {
                            new CuiRawImageComponent { Color = "1 1 1 1", Png = GetImage(prize.ShortName + 128) },
                            new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-10.059 -20.625", OffsetMax = "32.941 22.375" }
                        }
                    });
                }
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-61.669 0.67", OffsetMax = "-5.931 17.33" },
                    Text = { Text = $"x{prize.Amount}", Font = "robotocondensed-regular.ttf", FontSize = 11, Align = TextAnchor.MiddleRight, Color = "1 1 1 1" }
                }, prizeLayer);

                x++;
                if (x == 4)
                {
                    x = 0;
                    y++;

                    if (y == 2)
                    {
                        break;
                    }
                }
            }


            #endregion

            CuiHelper.DestroyUi(player, "QuestInfoPanel");
            CuiHelper.AddUi(player, container);

            if (playersInfo[player.userID].PlayerQuestsCooldown.ContainsKey(quests.DisplayName))
            {
                if (PlayersTime[player.userID] != null)
                    ServerMgr.Instance.StopCoroutine(PlayersTime[player.userID]);
                PlayersTime[player.userID] = ServerMgr.Instance.StartCoroutine(StartUpdate(player, quest));
            }
        }

        private IEnumerator StartUpdate(BasePlayer player, int quest)
        {
            var check = QuestList[quest];

            while (player.HasFlag(BaseEntity.Flags.Reserved3))
            {
                string questLayer = Layers + "ButtonQuest";

                if (playersInfo[player.userID].PlayerQuestsCooldown.ContainsKey(check.DisplayName) && playersInfo[player.userID]?.PlayerQuestsCooldown[check.DisplayName] >= CurrentTime())
                {
                    CuiElementContainer container = new CuiElementContainer();
                    CuiHelper.DestroyUi(player, questLayer);

                    string text = TimeHelper.FormatTime(TimeSpan.FromSeconds(playersInfo[player.userID].PlayerQuestsCooldown[check.DisplayName] - CurrentTime()), 5, lang.GetLanguage(player.UserIDString));

                    container.Add(new CuiButton
                    {
                        Button = { Color = "0 0 0 0", Command = "UI_Handler coldown" },
                        Text = { Text = text, Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                        RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-55.039 -21.01", OffsetMax = "55.041 21.009" }
                    }, Layers + "QuestButtonImage", Layers + "ButtonQuest");

                    CuiHelper.AddUi(player, container);
                }
                else if (playersInfo[player.userID].PlayerQuestsCooldown[check.DisplayName] != 0)
                {
                    playersInfo[player.userID].PlayerQuestsCooldown.Remove(check.DisplayName);
                    QuestInfo(player, quest);
                }

                yield return new WaitForSeconds(1);
            }
        }
        #endregion

        #region MiniQuestList
        private void OpenMQL_CMD(BasePlayer player) => UIMiniQuestList(player);

        void UIMiniQuestList(BasePlayer player, int page = 0)
        {
            List<PlayerQuest> playerQuests = playersInfo[player.userID].PlayerQuestsAll;
            if (playerQuests == null)
                return;
            if (playerQuests.Count == 0)
            {
                SendReply(player, GetLang("XDQUEST_UI_ActiveQuestCount", player.UserIDString));
                if (openQuestPlayers.Contains(player.userID))
                    openQuestPlayers.Remove(player.userID);
                return;
            }
            if (!openQuestPlayers.Contains(player.userID))
                openQuestPlayers.Add(player.userID);

            IEnumerable<PlayerQuest> qlist = playerQuests.Skip(page * 8).Take(8);
            int questCount = qlist.Count();
            int qc = -72 * questCount;
            Double ds = 207.912 + qc;
            var container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                CursorEnabled = false,
                Image = { Color = "1 1 1 0" },
                RectTransform = { AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = $"0 {ds}", OffsetMax = "304.808 303.288" }
            }, "Overlay", MiniQuestList);

            container.Add(new CuiButton
            {
                Button = { Color = "0 0 0 0", Command = "CloseMiniQuestList" },
                Text = { Text = "x", Font = "robotocondensed-regular.ttf", FontSize = 15, Align = TextAnchor.MiddleCenter, Color = "1 0 0 1" },
                RectTransform = { AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = "-20 -20", OffsetMax = "0 0" }
            }, MiniQuestList, "MiniQuestClosseBtn");
            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "3.825 -23.035", OffsetMax = "173.821 0" },
                Text = { Text = GetLang("XDQUEST_UI_ACTIVEOBJECTIVES", player.UserIDString, playerQuests.Count), Font = "robotocondensed-bold.ttf", FontSize = 12, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" }
            }, MiniQuestList, "LabelMiniQuestPanel");       

            int size = 72, i = 0;
            foreach (var item in qlist)
            {
                String color = item.Finished ? "0.1960784 0.7176471 0.4235294 1" : "0.9490197 0.3764706 0.3960785 1";
                container.Add(new CuiElement
                {
                    Name = "MiniQuestImage",
                    Parent = MiniQuestList,
                    Components = {
                    new CuiRawImageComponent { Color = "0 0 0 1", Png = ImageUi.GetImage("5") },
                    new CuiRectTransformComponent {  AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = $"3.829 {-90.188 - i*size}", OffsetMax = $"299.599 {-23.035 - i*size}" }
                }
                });
                container.Add(new CuiElement
                {
                    Name = "ImgForMiniQuest",
                    Parent = "MiniQuestImage",
                    Components = {
                    new CuiRawImageComponent { Color = color, Png = ImageUi.GetImage("13") },
                    new CuiRectTransformComponent { AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "0.112 -33.576", OffsetMax = "12.577 33.577" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "LabelForMiniQuest",
                    Parent = "MiniQuestImage",
                    Components = {
                    new CuiTextComponent { Text =GetLang("XDQUEST_UI_MiniQLInfo", player.UserIDString, item.parentQuest.DisplayName, item.Count, item.parentQuest.Amount, item.parentQuest.Missions), Font = "robotocondensed-regular.ttf", FontSize = 12, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiOutlineComponent {Color = "0 0 0 1", Distance = "0.6 0.6"},
                    new CuiRectTransformComponent { AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "14.925 -28.867", OffsetMax = "283.625 28.867" }
                }
                });
                i++;
            }

            #region Page
            int pageCount = (int)Math.Ceiling((double)playerQuests.Count / 8);
            if (pageCount > 1)
            {
                container.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    Image = { Color = "1 1 1 0" },
                    RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = $"3.829 {-126.593 - (questCount - 1) * size}", OffsetMax = $"145.353 {-90.187 - (questCount - 1) * size}" }
                }, MiniQuestList, "Panel_1410");
                container.Add(new CuiLabel
                {
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-22.598 -11.514", OffsetMax = "21.517 11.514" },
                    Text = { Text = $"{page + 1}/{pageCount}", Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" }
                }, "Panel_1410");
                if (page + 1 < pageCount)
                {
                    container.Add(new CuiElement
                    {
                        Parent = "Panel_1410",
                        Name = "DOWNBTN",
                        Components =
                    {
                        new CuiRawImageComponent { Png = ImageUi.GetImage("4"), Color = "1 1 1 1" },
                        new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-61.326 -13.326", OffsetMax = "-22.598 13.535" }
                    }
                    });

                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                        Button = { Color = "0 0 0 0", Command = $"UI_Handler pageQLIST {page + 1}" },
                        Text = { Text = "" }
                    }, "DOWNBTN");
                }
                if (page != 0)
                {
                    container.Add(new CuiElement
                    {
                        Parent = "Panel_1410",
                        Name = "UPBTN",
                        Components =
                    {
                        new CuiRawImageComponent { Png = ImageUi.GetImage("3"), Color = "1 1 1 1" },
                        new CuiRectTransformComponent {AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "21.517 -13.326", OffsetMax = "60.138 13.743" }   }
                    });

                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                        Button = { Color = "0 0 0 0", Command = $"UI_Handler pageQLIST {page - 1}" },
                        Text = { Text = "" }
                    }, "UPBTN");
                }
            }
            
            #endregion
            CuiHelper.DestroyUi(player, MiniQuestList);
            CuiHelper.AddUi(player, container);
        }

        #endregion

        #region Notice
        private void UINottice(BasePlayer player, string msg, string sprite = "assets/icons/warning.png", string color = "0.76 0.34 0.10 1.00")
        {
            var container = new CuiElementContainer();
            container.Add(new CuiElement
            {
                FadeOut = 0.30f,
                Name = "QuestUiNotice",
                Parent = LayerMainBackground,
                Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = ImageUi.GetImage("12"), FadeIn = 0.30f },
                    new CuiRectTransformComponent { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "96.235 -110.028", OffsetMax = "391.685 -43.111" }                }
            });

            container.Add(new CuiElement
            {
                FadeOut = 0.30f,
                Name = "NoticeFeed",
                Parent = "QuestUiNotice",
                Components = {
                    new CuiRawImageComponent { Color = color, Png = ImageUi.GetImage("13"), FadeIn = 0.30f },
                    new CuiRectTransformComponent { AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "0.276 -33.458", OffsetMax = "12.692 33.459" }
                }
            });
            //container.Add(new CuiElement
            //{
            //    Parent = "QuestUi",
            //    Components = {
            //        new CuiRawImageComponent { Color = HexToRustFormat(color), Png = ImageUi.GetImage("16"), FadeIn = 0.30f },
            //        new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = "0.45 -23.24", OffsetMax = "1.3567 12.1866" }
            //    }
            //});

            container.Add(new CuiElement
            {
                FadeOut = 0.30f,
                Name = "NoticeSprite",
                Parent = "QuestUiNotice",
                Components = {
                    new CuiImageComponent { Color = "1 1 1 1", Sprite = sprite, FadeIn = 0.30f },
                    new CuiRectTransformComponent { AnchorMin = "0 0.5", AnchorMax = "0 0.5", OffsetMin = "23.5 -15.5", OffsetMax = "54.5 15.5" }
                }
            });

            container.Add(new CuiLabel
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-78.262 -33.458", OffsetMax = "143.522 33.459" },
                Text = { Text = msg, Font = "robotocondensed-regular.ttf", FontSize = 11, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1", FadeIn = 0.30f }
            }, "QuestUiNotice", "NoticeText");

            CuiHelper.DestroyUi(player, "NoticeText");
            CuiHelper.DestroyUi(player, "NoticeSprite");
            CuiHelper.DestroyUi(player, "NoticeFeed");
            CuiHelper.DestroyUi(player, "QuestUiNotice");
            CuiHelper.AddUi(player, container);
            timer.Once(3.5f, () => {
                CuiHelper.DestroyUi(player, "NoticeText");
                CuiHelper.DestroyUi(player, "NoticeSprite");
                CuiHelper.DestroyUi(player, "NoticeFeed");
                CuiHelper.DestroyUi(player, "QuestUiNotice");
            });
        }

        #endregion

        #endregion

        #region Command    
        [ConsoleCommand("CloseMiniQuestList")]
        void CloseMiniQuestList(ConsoleSystem.Arg arg)
        {
            CuiHelper.DestroyUi(arg.Player(), MiniQuestList);
            if (openQuestPlayers.Contains(arg.Player().userID))
                openQuestPlayers.Remove(arg.Player().userID);
        }

        [ConsoleCommand("CloseMainUI")]
        void CloseLayerPlayer(ConsoleSystem.Arg arg)
        {
            CuiHelper.DestroyUi(arg.Player(), Layers);
            arg.Player().SetFlag(BaseEntity.Flags.Reserved3, false);
            if (PlayersTime[arg.Player().userID] != null)
                ServerMgr.Instance.StopCoroutine(PlayersTime[arg.Player().userID]);
        }

        [ChatCommand("quest.saveposition")]
        void CustomPosSave(BasePlayer player)
        {
            config.customPosition.pos = player.transform.position;
            SaveConfig();
            PrintToChat(player, GetLang("XDQUEST_UI_CMDCustomPosAdd", player.UserIDString));
        }

        [ChatCommand("quest.tphouse")]
        void TpToQuestHouse(BasePlayer player)
        {
            if (player.IsAdmin)
                player.Teleport(GetResultVector());
        }

        [ConsoleCommand("UI_Handler")]
        private void CmdConsoleHandler(ConsoleSystem.Arg args)
        {
            BasePlayer player = args.Player();
            List<PlayerQuest> playerQuests = playersInfo[player.userID].PlayerQuestsAll;
            if (playerQuests == null)
                return;

            if (player != null && args.HasArgs(1))
            {
                switch (args.Args[0])
                {
                    case "get":
                        {
                            int questIndex;
                            if (args.HasArgs(2) && int.TryParse(args.Args[1], out questIndex))
                            {
                                var currentQuest = QuestList[questIndex];
                                if (currentQuest != null)
                                {
                                    if (playerQuests.Count >= config.settings.questCount)
                                    {
                                        UINottice(player, GetLang("XDQUEST_UI_QuestLimit", player.UserIDString));
                                        return;
                                    }
                                    if (playerQuests.Any(p => p.parentQuest.DisplayName == currentQuest.DisplayName))
                                    {
                                        UINottice(player, GetLang("XDQUEST_UI_AlreadyTaken", player.UserIDString));
                                        return;
                                    }
                                    if (!currentQuest.UseRepeat && playersInfo[player.userID].PlayerQuestsFinish.Contains(currentQuest.DisplayName))
                                    {
                                        UINottice(player, GetLang("XDQUEST_UI_AlreadyDone", player.UserIDString));
                                        return;
                                    }
                                    if (playersInfo[player.userID].PlayerQuestsFinish.Contains(currentQuest.DisplayName))
                                    {
                                        UINottice(player, GetLang("XDQUEST_UI_AlreadyDone", player.UserIDString));
                                        return;
                                    }
                                    playerQuests.Add(new PlayerQuest() { UserID = player.userID, parentQuest = currentQuest });
                                    QuestListUI(player, 0);
                                    QuestInfo(player, questIndex);
                                    UINottice(player, GetLang("XDQUEST_UI_TookTasks", player.UserIDString, currentQuest.DisplayName));
                                    if (Instance.config.settingsSoundNPC.takeQuestSound.Count != 0 && config.settingsSoundNPC.soundUse)
                                    {
                                        int mIndex = Random.Range(0, Instance.config.settingsSoundNPC.takeQuestSound.Count);
                                        Instance.SoundPlay(Instance.config.settingsSoundNPC.takeQuestSound[mIndex]);
                                    }           
                                }
                            }
                            break;
                        }
                    case "page":
                        {
                            int pageIndex;
                            if (int.TryParse(args.Args[1], out pageIndex))
                            {
                                QuestListUI(player, pageIndex);
                            }
                            break;
                        }
                    case "pageQLIST":
                        {
                            int pageIndex;
                            if (int.TryParse(args.Args[1], out pageIndex))
                            {
                                UIMiniQuestList(player, pageIndex);
                            }
                            break;
                        }
                    case "coldown":
                        {
                            UINottice(player, GetLang("XDQUEST_UI_ACTIVECOLDOWN", player.UserIDString));
                            break;
                        }
                    case "questinfo":
                        {
                            int pageIndex;
                            if (int.TryParse(args.Args[1], out pageIndex))
                            {
                                QuestInfo(player, pageIndex);
                            }
                            break;
                        }
                    case "finish":
                        {
                            int questIndex;
                            if (args.HasArgs(2) && int.TryParse(args.Args[1], out questIndex))
                            {
                                var globalQuest = QuestList[questIndex];
                                if (globalQuest != null)
                                {
                                    var currentQuest = playerQuests.FirstOrDefault(p => p.parentQuest.DisplayName == globalQuest.DisplayName);
                                    if (currentQuest == null)
                                        return;

                                    if (currentQuest.Finished)
                                    {
                                        if (24 - player.inventory.containerMain.itemList.Count < currentQuest.parentQuest.PrizeList.Where(x => x.type != PrizeType.Command).Count())
                                        {
                                            UINottice(player, GetLang("XDQUEST_UI_LackOfSpace", player.UserIDString));
                                            return;
                                        }
                                        ulong skins;
                                        if (currentQuest.parentQuest.Bring)
                                        {
                                            if (currentQuest.parentQuest.QuestType == QuestType.Loot && ulong.TryParse(currentQuest.parentQuest.Target, out skins))
                                            {
                                                List<Item> acceptedItems = new List<Item>();
                                                Int32 itemAmount = 0;
                                                Int32 amountQuest = currentQuest.parentQuest.Amount;
                                                String itemName = String.Empty;
                                                foreach (Item item in player.inventory.AllItems())
                                                {
                                                    if (item.skin == skins)
                                                    {
                                                        acceptedItems.Add(item);
                                                        itemAmount += item.amount;
                                                        itemName = item.info.displayName.english;
                                                    }
                                                }

                                                if (acceptedItems.Count == 0)
                                                {
                                                    UINottice(player, GetLang("XDQUEST_UI_InsufficientResources", player.UserIDString));
                                                    return;
                                                }
                                                if (itemAmount < amountQuest)
                                                {
                                                    UINottice(player, GetLang("XDQUEST_UI_NotResourcesAmount", player.UserIDString, itemName, amountQuest));
                                                    return;
                                                }

                                                foreach (Item use in acceptedItems)
                                                {
                                                    if (use.amount == amountQuest)
                                                    {
                                                        use.RemoveFromContainer();
                                                        use.Remove();
                                                        amountQuest = 0;
                                                        break;
                                                    }
                                                    if (use.amount > amountQuest)
                                                    {
                                                        use.amount -= amountQuest;
                                                        player.inventory.SendSnapshot();
                                                        amountQuest = 0;
                                                        break;
                                                    }
                                                    if (use.amount < amountQuest)
                                                    {
                                                        amountQuest -= use.amount;
                                                        use.RemoveFromContainer();
                                                        use.Remove();
                                                    }
                                                }
                                            }
                                            else if (currentQuest.parentQuest.QuestType == QuestType.Gather || currentQuest.parentQuest.QuestType == QuestType.Loot || currentQuest.parentQuest.QuestType == QuestType.Craft || currentQuest.parentQuest.QuestType == QuestType.PurchaseFromNpc || currentQuest.parentQuest.QuestType == QuestType.Growseedlings || currentQuest.parentQuest.QuestType == QuestType.Fishing)
                                            {
                                                var idItem = ItemManager.FindItemDefinition(currentQuest.parentQuest.Target);
                                                var item = player?.inventory?.GetAmount(idItem.itemid);
                                                if (item == 0 || item == null)
                                                {
                                                    UINottice(player, GetLang("XDQUEST_UI_InsufficientResources", player.UserIDString, idItem.displayName.english));
                                                    return;
                                                }
                                                if (item < currentQuest.parentQuest.Amount)
                                                {
                                                    UINottice(player, GetLang("XDQUEST_UI_NotResourcesAmount", player.UserIDString, idItem.displayName.english, currentQuest.parentQuest.Amount));
                                                    return;
                                                }
                                                if (item >= currentQuest.parentQuest.Amount)
                                                {
                                                    player.inventory.Take(null, idItem.itemid, currentQuest.parentQuest.Amount);
                                                }

                                            }
                                        }

                                        UINottice(player, GetLang("XDQUEST_UI_QuestsCompleted", player.UserIDString));

                                        currentQuest.Finished = false;
                                        for (int i = 0; i < currentQuest.parentQuest.PrizeList.Count; i++)
                                        {
                                            var check = currentQuest.parentQuest.PrizeList[i];
                                            switch (check.type)
                                            {
                                                case PrizeType.Item:
                                                    Item newItem = ItemManager.CreateByPartialName(check.ShortName, check.Amount);
                                                    player.GiveItem(newItem, BaseEntity.GiveItemReason.Crafted);
                                                    break;
                                                case PrizeType.Command:
                                                    Server.Command(check.Command.Replace("%STEAMID%", player.UserIDString));
                                                    break;
                                                case PrizeType.CustomItem:
                                                    Item customItem = ItemManager.CreateByPartialName(check.ShortName, check.Amount, check.SkinID);
                                                    customItem.name = check.Name;
                                                    player.GiveItem(customItem, BaseEntity.GiveItemReason.Crafted);
                                                    break;
                                                case PrizeType.BluePrint:
                                                    Item itemBp = ItemManager.CreateByItemID(-996920608, check.Amount);
                                                    itemBp.blueprintTarget = ItemManager.itemList.Find(x => x.shortname == check.ShortName)?.itemid ?? 0;
                                                    player.GiveItem(itemBp, BaseEntity.GiveItemReason.Crafted);
                                                    break;
                                            }
                                        }
                                        if (!currentQuest.parentQuest.UseRepeat)
                                        {
                                            playersInfo[player.userID].PlayerQuestsFinish.Add(currentQuest.parentQuest.DisplayName);
                                        }
                                        else if(globalQuest.Cooldown > 0)
                                        {
                                            if (!playersInfo[player.userID].PlayerQuestsCooldown.ContainsKey(globalQuest.DisplayName))
                                                playersInfo[player.userID].PlayerQuestsCooldown.Add(globalQuest.DisplayName, CurrentTime() + globalQuest.Cooldown);
                                            else
                                                playersInfo[player.userID].PlayerQuestsCooldown[globalQuest.DisplayName] = CurrentTime() + globalQuest.Cooldown;
                                        }
                                        playerQuests.Remove(currentQuest);
                                        QuestListUI(player, 0);
                                        QuestInfo(player, questIndex);
                                        if (Instance.config.settingsSoundNPC.turnQuestSound.Count != 0 && config.settingsSoundNPC.soundUse)
                                        {
                                            int mIndex = Random.Range(0, Instance.config.settingsSoundNPC.turnQuestSound.Count);
                                            Instance.SoundPlay(Instance.config.settingsSoundNPC.turnQuestSound[mIndex]);
                                        }      
                                    }
                                    else
                                    {
                                        UINottice(player, GetLang("XDQUEST_UI_PassedTasks", player.UserIDString));
                                        playerQuests.Remove(currentQuest);
                                        QuestListUI(player, 0);
                                        QuestInfo(player, questIndex);
                                    }
                                }
                                else
                                    UINottice(player, "Вы <color=#4286f4>не брали</color> этого задания!");
                            }
                            break;
                        }
                }     
            }
        }
        #endregion

        #region Data
        private List<Quest> LoadQuestListBuffer()
        {
            if (!Interface.Oxide.DataFileSystem.ExistsDatafile(this.Name + $"/{config.settings.questListDataName}"))
            {
                return null;
            }

            var data = Interface.Oxide.DataFileSystem.ReadObject<List<Quest>>(this.Name + $"/{config.settings.questListDataName}");
            if (data == null)
                return null;
            return data;
        }
        JsonSerializerSettings settings = new JsonSerializerSettings
        {
            NullValueHandling = NullValueHandling.Ignore,
            MissingMemberHandling = MissingMemberHandling.Ignore
        };
        private void LoadQuestData() 
        {
            var quest64 = LoadQuestListBuffer();
            if (quest64 == null)
            {
                QuestList = new List<Quest>();
                return;
            }
            //if (quest64.Data == null)
            //{
            //    QuestList = new List<Quest>();
            //    return;
            //}
            QuestList = quest64;
        }
        private void LoadPlayerData() => playersInfo = Interface.GetMod().DataFileSystem.ReadObject<Dictionary<ulong, PlayerData>>(this.Name + $"/PlayerInfo");
        private void SavePlayerData() => Interface.GetMod().DataFileSystem.WriteObject(this.Name + $"/PlayerInfo", playersInfo);
        void SaveData()
        {
            SavePlayerData();   
        }
        #endregion
    }
}


// --- End of file: XDQuest (1).cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/RestartGUI.cs ---
// --- Original Local Path: RestartGUI.cs ---

using System;
using System.Globalization;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using Console = ConVar.Console;
using Time = Oxide.Core.Libraries.Time;

namespace Oxide.Plugins
{
    [Info("RestartGUI", "poof", "1.0.0")]
    public class RestartGUI : RustPlugin
    {
        private const string Layer = "RestartLayer";
        
        private static class RestartConfig
        {
            public static int Time = 0;

            public static bool Restart = false;

            public static bool First = true;
        }
        
        #region Config

        private Configuration config = new Configuration();
        
        private class Configuration
        {
            [JsonProperty("Время рестарта")] 
            public string Time = "04:00";

            [JsonProperty("Время до рестарта")] 
            public int RestartTime = 300;

            [JsonProperty("Звук проигрывания")]
            public string Effect = "assets/bundled/prefabs/fx/notice/item.select.fx.prefab";

            [JsonProperty("Сообщение о рестарте")] 
            public string RestartTimerText = "Сервер перезагрузится через {0} секунд";
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<Configuration>();
                if(config == null) throw new Exception();
            }
            catch
            {
                Config.WriteObject(config, false, $"{Interface.Oxide.ConfigDirectory}/{Name}.jsonError");
                PrintError("Ошибка в конфигурации плагина RestartGUI");
                
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion

        #region Hooks

        private void OnServerInitialized()
        {
            LoadConfig();
        }

        private void OnTick()
        {
            if (DateTime.Now.ToString("t") != config.Time || RestartConfig.Restart) return;
            
            RestartConfig.Restart = true;
            ExecuteRestart(config.RestartTime);
        }
        
        #endregion
        
        #region Commands

        [ConsoleCommand("reload")]
        private void ConsoleReload(ConsoleSystem.Arg arg)
        {
            if (!arg.IsServerside) return;

            var args = arg.Args ?? new string[0];
            
            switch (args.Length)
            {
                case 0:
                {
                    if (RestartConfig.Restart)
                    {
                        ResetConfig();
                        return;
                    }

                    RestartConfig.Restart = true;
                    ExecuteRestart(config.RestartTime);
                    return;
                }
                case 1:
                {
                    if (RestartConfig.Restart || args[0].ToLower() == "stop")
                    {
                        ResetConfig();
                        return;
                    }

                    int time;

                    if (!int.TryParse(args[0], out time)) return;
                
                    ResetConfig();
                    RestartConfig.Restart = true;
                    ExecuteRestart(time);
                    break;
                }
            }
        }

        [ChatCommand("reload")]
        private void CMDReload(BasePlayer player, string cmd, string[] args)
        {
            if (!player.IsAdmin) return;
            
            switch (args.Length)
            {
                case 0:
                {
                    if (RestartConfig.Restart)
                    {
                        ResetConfig();
                        return;
                    }

                    RestartConfig.Restart = true;
                    ExecuteRestart(config.RestartTime);
                    return;
                }
                case 1:
                {
                    if (RestartConfig.Restart || args[0].ToLower() == "stop")
                    {
                        ResetConfig();
                        return;
                    }

                    int time;

                    if (!int.TryParse(args[0], out time)) return;
                
                    ResetConfig();
                    RestartConfig.Restart = true;
                    ExecuteRestart(time);
                    break;
                }
            }
        }
        
        #endregion

        #region Methods

        private void ExecuteRestart(int time)
        {
            if (!RestartConfig.Restart)
            {
                DestroyGUI();
                ResetConfig();
                return;
            }

            if (RestartConfig.First)
            {
                RestartConfig.Time = time;
                RestartConfig.First = false;
            }

            if (RestartConfig.Time == 0)
            {
                ConVar.Global.quit(null);
                return;
            }
            
            CuiElementContainer container = new CuiElementContainer
            {
                {
                    new CuiPanel
                    {
                        Image = { Color = HexToRustFormat("#00000070") },
                        RectTransform = { AnchorMin = "0 0.7694442", AnchorMax = "1 0.8249997" }
                    }, "Hud", Layer
                },
                new CuiElement
                {
                    Parent = Layer,
                    Components =
                    {
                        new CuiTextComponent{ Align = TextAnchor.MiddleCenter, Color = "1 1 1 1", FontSize = 20, Text = string.Format(config.RestartTimerText, $"{RestartConfig.Time}")},
                        new CuiOutlineComponent { Color = "0 0 0 1", Distance = "0.7 0.7" },
                        new CuiRectTransformComponent{ AnchorMin = "0 0", AnchorMax = "1 1" }
                    }
                }
            };
            
            DestroyGUI();
            DrawGUI(container);
            
            BasePlayer.activePlayerList.ForEach( player => EffectNetwork.Send(new Effect(config.Effect, player, 0, Vector3.zero, Vector3.forward), player.net.connection));

            RestartConfig.Time--;
            
            timer.Once(1f, () => { ExecuteRestart(RestartConfig.Time);});
        }

        private void ResetConfig()
        {
            RestartConfig.Time = 0;
            RestartConfig.Restart = false;
            RestartConfig.First = true;
        }
        
        private void DrawGUI(CuiElementContainer container) =>
            BasePlayer.activePlayerList.ForEach(x => CuiHelper.AddUi(x, container));

        private void DestroyGUI() => BasePlayer.activePlayerList.ForEach(x => CuiHelper.DestroyUi(x, Layer));
        
        #endregion

        #region Helpers

        private string HexToRustFormat(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }

            var str = hex.Trim('#');

            if (str.Length == 6)
                str += "FF";

            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }

            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

            Color color = new Color32(r, g, b, a);

            return $"{color.r:F2} {color.g:F2} {color.b:F2} {color.a:F2}";
        }

        #endregion
    }
}

// --- End of file: RestartGUI.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/WipeSchedule.cs ---
// --- Original Local Path: WipeSchedule.cs ---

using System;
using System.Collections.Generic;
using System.Globalization;

namespace Oxide.Plugins
{
    [Info("WipeSchedule", "k1lly0u", "2.0.2", ResourceId = 1451)]
    class WipeSchedule : RustPlugin
    {
        #region Fields
        DateTime NextWipeDate;
        DateTime NextWipeDateXP;
        Timer announceTimer;
        #endregion

        #region Oxide Hooks 
        void Loaded()
        {
            lang.RegisterMessages(messages, this);
            LoadVariables();
        }
        void OnServerInitialized()
        {
            if (!configData.UseManualNextWipe)
                UpdateWipeDates();
            else LoadWipeDates();

            if (configData.AnnounceOnTimer)
            {
                announceTimer = timer.Repeat((configData.AnnounceTimer * 60) * 60, 0, ()=> BroadcastWipe()); 
            }
        }
        void OnPlayerInit(BasePlayer player)
        {
            if (configData.AnnounceOnJoin)
            {
                cmdNextWipe(player, "", new string[0]);
            }
        }
        void Unload() => announceTimer.Destroy();
        #endregion

        #region Functions        
        private DateTime ParseTime(string time) => DateTime.ParseExact(time, configData.DateFormat, CultureInfo.InvariantCulture);
        private void UpdateWipeDates()
        {
            NextWipeDate = ParseTime(configData.LastWipe);
            NextWipeDate = NextWipeDate.AddDays(configData.DaysBetweenWipes);
            NextWipeDateXP = ParseTime(configData.LastXPWipe);
            NextWipeDateXP = NextWipeDateXP.AddDays(configData.DaysBetweenXPWipes);
        }
        private void LoadWipeDates()
        {
            NextWipeDate = ParseTime(configData.LastWipe);
            NextWipeDateXP = ParseTime(configData.LastXPWipe);
        }
        private string NextWipeDays(DateTime WipeDate)
        {
            TimeSpan t = WipeDate.Subtract(DateTime.Now);
            return string.Format(string.Format("{0:D2} Days",t.Days));
        }
        private void BroadcastWipe()
        {
            PrintToChat(string.Format(MSG("lastMapWipe", null), configData.LastWipe, NextWipeDays(NextWipeDate)));
            if (configData.ShowXPWipeSchedule)
                PrintToChat(string.Format(MSG("lastXPWipe", null), configData.LastWipe, NextWipeDays(NextWipeDateXP)));
        }
        #endregion

        #region ChatCommands
        [ChatCommand("nextwipe")]
        private void cmdNextWipe(BasePlayer player, string command, string[] args)
        {
            SendReply(player, string.Format(MSG("lastMapWipe", player.UserIDString), configData.LastWipe, NextWipeDays(NextWipeDate)));
            if (configData.ShowXPWipeSchedule)
                SendReply(player, string.Format(MSG("lastXPWipe", player.UserIDString), configData.LastXPWipe, NextWipeDays(NextWipeDateXP)));
        }
        [ChatCommand("setwipe")]
        private void cmdSetWipe(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin()) return;
            if (args == null || args.Length == 0)
            {
                SendReply(player, $"<color=#ffae1a>/setwipe map</color>{MSG("setWipeMap", player.UserIDString)}");
                SendReply(player, $"<color=#ffae1a>/setwipe xp</color>{MSG("setWipeXP", player.UserIDString)}");
                SendReply(player, $"<color=#ffae1a>/setwipe map <date></color>{MSG("setWipeMapManual", player.UserIDString)}");
                SendReply(player, $"<color=#ffae1a>/setwipe xp <date></color>{MSG("setWipeXPManual", player.UserIDString)}");
                return;
            }
            if (args.Length == 1)
            {
                switch (args[0].ToLower())
                {
                    case "map":
                        {
                            configData.LastWipe = DateTime.Now.Date.ToString(configData.DateFormat);
                            SaveConfig(configData);
                            UpdateWipeDates();
                            SendReply(player, string.Format(MSG("savedWipeMap", player.UserIDString), configData.LastWipe));
                        }
                        return;
                    case "xp":
                        {
                            configData.LastXPWipe = DateTime.Now.Date.ToString(configData.DateFormat);
                            SaveConfig(configData);
                            UpdateWipeDates();
                            SendReply(player, string.Format(MSG("savedWipeXP", player.UserIDString), configData.LastXPWipe));
                        }
                        return;
                    default:
                        return;
                }
            }
            if (args.Length == 2)
            {
                switch (args[0].ToLower())
                {
                    case "map":
                        {
                            DateTime time;
                            if (DateTime.TryParse(args[1], out time))
                            {
                                configData.LastWipe = time.ToString(configData.DateFormat);
                                SaveConfig(configData);
                                UpdateWipeDates();
                                SendReply(player, string.Format(MSG("savedWipeMap", player.UserIDString), configData.LastWipe));
                            }                            
                        }
                        return;
                    case "xp":
                        {
                            DateTime time;
                            if (DateTime.TryParse(args[1], out time))
                            {
                                configData.LastXPWipe = time.ToString(configData.DateFormat);
                                SaveConfig(configData);
                                UpdateWipeDates();
                                SendReply(player, string.Format(MSG("savedWipeXP", player.UserIDString), configData.LastXPWipe));
                            }
                        }
                        return;
                    default:
                        return;
                }
            }
        }

        [ConsoleCommand("setwipe")]
        private void ccmdSetWipe(ConsoleSystem.Arg arg)
        {
            if (arg.connection == null)
            {
                if (arg.Args == null || arg.Args.Length == 0)
                {
                    SendReply(arg, $"setwipe map{MSG("setWipeMap", null)}");
                    SendReply(arg, $"setwipe xp{MSG("setWipeXP", null)}");
                    
                    return;
                }
                if (arg.Args.Length == 1)
                {
                    switch (arg.Args[0].ToLower())
                    {
                        case "map":
                            {
                                configData.LastWipe = DateTime.Now.Date.ToString(configData.DateFormat);
                                SaveConfig(configData);
                                UpdateWipeDates();
                                SendReply(arg, string.Format(MSG("savedWipeMap", null), configData.LastWipe));
                            }
                            return;
                        case "xp":
                            {
                                configData.LastXPWipe = DateTime.Now.Date.ToString(configData.DateFormat);
                                SaveConfig(configData);
                                UpdateWipeDates();
                                SendReply(arg, string.Format(MSG("savedWipeXP", null), configData.LastXPWipe));
                            }
                            return;
                        default:
                            return;
                    }
                }                
            }
        }
        [ChatCommand("setnextwipe")]
        private void cmdSetNextWipe(BasePlayer player, string command, string[] args)
        {
            if (!player.IsAdmin()) return;
            if (args == null || args.Length == 0)
            {                
                SendReply(player, $"<color=#ffae1a>/setnextwipe map <date></color>{MSG("setNextWipeMapManual", player.UserIDString)}");
                SendReply(player, $"<color=#ffae1a>/setnextwipe xp <date></color>{MSG("setNextWipeXPManual", player.UserIDString)}");
                return;
            }            
            if (args.Length == 2)
            {
                switch (args[0].ToLower())
                {
                    case "map":
                        {
                            DateTime time;
                            if (DateTime.TryParse(args[1], out time))
                            {
                                configData.NextWipe = time.ToString(configData.DateFormat);
                                SaveConfig(configData);
                                LoadWipeDates();
                                SendReply(player, string.Format(MSG("savedNextWipeMap", player.UserIDString), configData.NextWipe));
                            }
                        }
                        return;
                    case "xp":
                        {
                            DateTime time;
                            if (DateTime.TryParse(args[1], out time))
                            {
                                configData.NextXPWipe = time.ToString(configData.DateFormat);
                                SaveConfig(configData);
                                LoadWipeDates();
                                SendReply(player, string.Format(MSG("savedNextWipeXP", player.UserIDString), configData.NextXPWipe));
                            }
                        }
                        return;
                    default:
                        return;
                }
            }
        }

        [ConsoleCommand("setnextwipe")]
        private void ccmdSetNextWipe(ConsoleSystem.Arg arg)
        {
            if (arg.connection == null)
            {
                if (arg.Args == null || arg.Args.Length == 0)
                {
                    SendReply(arg, $"setnextwipe map <date>{MSG("setNextWipeMapManual", null)}");
                    SendReply(arg, $"setnextwipe xp <date>{MSG("setNextWipeXPManual", null)}");

                    return;
                }
                if (arg.Args.Length == 2)
                {
                    DateTime time;
                    switch (arg.Args[0].ToLower())
                    {
                        case "map":                           
                            if (DateTime.TryParse(arg.Args[1], out time))
                            {
                                configData.NextWipe = time.ToString(configData.DateFormat);
                                SaveConfig(configData);
                                LoadWipeDates();
                                SendReply(arg, string.Format(MSG("savedNextWipeMap"), configData.NextWipe));
                            }
                            return;
                        case "xp":
                            if (DateTime.TryParse(arg.Args[1], out time))
                            {
                                configData.NextXPWipe = time.ToString(configData.DateFormat);
                                SaveConfig(configData);
                                LoadWipeDates();
                                SendReply(arg, string.Format(MSG("savedNextWipeXP"), configData.NextXPWipe));
                            }
                            return;
                        default:
                            return;
                    }
                }
            }
        }
        #endregion

        #region Config        
        private ConfigData configData;
        class ConfigData
        {
            public string DateFormat { get; set; }
            public int DaysBetweenWipes { get; set; }
            public int DaysBetweenXPWipes { get; set; }
            public string LastWipe { get; set; }
            public string LastXPWipe { get; set; }
            public string NextWipe { get; set; }
            public string NextXPWipe { get; set; }
            public bool ShowXPWipeSchedule { get; set; }           
            public bool AnnounceOnJoin { get; set; }
            public bool UseManualNextWipe { get; set; }
            public bool AnnounceOnTimer { get; set; }
            public int AnnounceTimer { get; set; }
        }
        private void LoadVariables()
        {
            LoadConfigVariables();            
            if (string.IsNullOrEmpty(configData.LastWipe))
                configData.LastWipe = DateTime.Now.ToString(configData.DateFormat);
            if (string.IsNullOrEmpty(configData.LastXPWipe))
                configData.LastXPWipe = DateTime.Now.ToString(configData.DateFormat);
            if (string.IsNullOrEmpty(configData.NextWipe))
                configData.NextWipe = DateTime.Now.ToString(configData.DateFormat);
            if (string.IsNullOrEmpty(configData.NextXPWipe))
                configData.NextXPWipe = DateTime.Now.ToString(configData.DateFormat);
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                AnnounceOnJoin = true,
                AnnounceOnTimer = true,
                AnnounceTimer = 3,
                DateFormat = "MM/dd/yyyy",
                DaysBetweenWipes = 14,
                DaysBetweenXPWipes = 14,
                LastWipe = "",
                LastXPWipe = "",
                UseManualNextWipe = false,
                NextWipe = "",
                NextXPWipe = "",
                ShowXPWipeSchedule = true
        };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion

        #region Messaging
        private string MSG(string key, string playerid = null) => lang.GetMessage(key, this, playerid);

        Dictionary<string, string> messages = new Dictionary<string, string>()
        {            
            {"lastMapWipe", "<color=#b3b3b3>Last Map Wipe:</color> <color=#ffae1a>{0}</color> <color=#b3b3b3>Time Until Next Map Wipe:</color> <color=#ffae1a>{1}</color>" },
            {"lastXPWipe", "<color=#b3b3b3>Last XP Wipe:</color> <color=#ffae1a>{0}</color> <color=#b3b3b3>Time Until Next XP Wipe:</color> <color=#ffae1a>{1}</color>" } ,
            {"setWipeMap", "<color=#b3b3b3> - Sets the current time as last map wipe</color>" },
            {"setWipeXP", "<color=#b3b3b3> - Sets the current time as last XP wipe</color>" },
            {"savedWipeMap", "<color=#b3b3b3>Successfully set last map wipe to:</color> <color=#ffae1a>{0}</color>" },
            {"savedWipeXP", "<color=#b3b3b3>Successfully set last XP wipe to:</color> <color=#ffae1a>{0}</color>" },
            {"setWipeMapManual", "<color=#b3b3b3> - Set the time of last map wipe. Format: MM/dd/yyyy</color>" },
            {"setWipeXPManual", "<color=#b3b3b3> - Set the time as last XP wipe. Format: MM/dd/yyyy</color>" },            
            {"savedNextWipeMap", "<color=#b3b3b3>Successfully set next map wipe to:</color> <color=#ffae1a>{0}</color>" },
            {"savedNextWipeXP", "<color=#b3b3b3>Successfully set next XP wipe to:</color> <color=#ffae1a>{0}</color>" },
            {"setNextWipeMapManual", "<color=#b3b3b3> - Set the time of next map wipe. Format: MM/dd/yyyy</color>" },
            {"setNextWipeXPManual", "<color=#b3b3b3> - Set the time as next XP wipe. Format: MM/dd/yyyy</color>" }
        };
        #endregion
    }
}


// --- End of file: WipeSchedule.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/SupplyDropDestroyer.cs ---
// --- Original Local Path: SupplyDropDestroyer.cs ---

using System.Collections.Generic;
using System.Reflection;
using System;
using System.Data;
using UnityEngine;
using Oxide.Core;
using System.Linq;
using Rust;

namespace Oxide.Plugins
{
    [Info("Supply Drop Destroyer", "PaiN", 0.2, ResourceId = 1281)]
    [Description("This plugin destroys the supply drop container after x seconds.")]
    class SupplyDropDestroyer : RustPlugin
	{
		private bool Changed;
		private int destroyafter;
		
		object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        } 
		
		void Loaded()
		{
			LoadVariables();	
		}
		
		void LoadVariables()
		{
			destroyafter = Convert.ToInt32(GetConfig("Settings", "DestroyAfter", 300));
			
			if (Changed)
			{
				SaveConfig();
				Changed = false;
			
			}	
		} 
	
		protected override void LoadDefaultConfig()
		{
			Puts("Creating a new configuration file!");
			Config.Clear();
			LoadVariables();
		}
	
		void OnEntitySpawned(BaseNetworkable entity)
		{ 
			if(entity as SupplyDrop)
			{
				timer.Once(destroyafter, () =>	{ 
				entity.Kill();
				Puts("Successfully destroyed " + entity.name.ToString());
				});
			}
		}
	}
}

// --- End of file: SupplyDropDestroyer.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/RemoverTool.cs ---
// --- Original Local Path: RemoverTool.cs ---

using System.Collections.Generic;
using System;
using System.Reflection;
using System.Data;
using UnityEngine;
using Facepunch;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;

using System.Linq;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Cui;
using System.Collections;

namespace Oxide.Plugins
{
    [Info("RemoverTool", "Reneb", "4.0.9", ResourceId = 651)]
    class RemoverTool : RustPlugin
    {
        [PluginReference]
        Plugin Friends;

        static RemoverTool rt = new RemoverTool();

        #region Fields

        static FieldInfo serverInput = typeof(BasePlayer).GetField("serverInput", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
        static FieldInfo buildingPrivilege = typeof(BasePlayer).GetField("buildingPrivilege", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
        static int colliderRemovable = LayerMask.GetMask("Construction", "Deployed", "Default");
        static int colliderBuilding = LayerMask.GetMask("Construction");
        static int colliderPlayer = LayerMask.GetMask("Player (Server)");

        bool RemoveOverride = false;

        static string permissionNormal = "removertool.remove";
        static string permissionOverride = "removertool.override";
        static string permissionAdmin = "removertool.admin";
        static string permissionAll = "removertool.all";
        static string permissionTarget = "removertool.target";

        static int authTarget = 1;
        static int authNormal = 0;
        static int authAdmin = 2;
        static int authAll = 2;
        static int authOverride = 1;

        static int removeDistanceNormal = 2;
        static int removeDistanceAdmin = 20;
        static int removeDistanceAll = 100;

        static bool removeGibsNormal = true;
        static bool removeGibsAdmin = true;
        static bool removeGibsAll = false;

        static int RemoveDefaultTime = 30;
        static int RemoveMaxTime = 300;

        static bool RemoveWithToolCupboards = false;
        static bool RemoveWithEntityOwners = true;
        static bool RemoveWithBuildingOwners = true;
        static bool RemoveWithRustIO = true;
        static bool RemoveWithFriends = true;

        static bool RaidBlocker = true;
        static bool RaidBlockerBlockBuildingID = true;
        static bool RaidBlockerBlockSurroundingPlayers = true;
        static int RaidBlockerRadius = 120;
        static int RaidBlockerTime = 300;

        static Dictionary<string, object> Price = new Dictionary<string, object>();
        static Dictionary<string, object> Refund = new Dictionary<string, object>();
        static Dictionary<string, object> ValidEntities = new Dictionary<string, object>();

        static string GUIRemoverToolBackgroundColor = "0.1 0.1 0.1 0";
        static string GUIRemoverToolAnchorMin = "0.1 0.65";
        static string GUIRemoverToolAnchorMax = "0.4 0.95";

        static string GUIRemoveBackgroundColor = "0.1 0.1 0.1 0.98";
        static string GUIRemoveAnchorMin = "0 0.9";
        static string GUIRemoveAnchorMax = "0.55 1";

        static string GUIRemoveTextColor = "1 0.1 0.1 0.98";
        static int GUIRemoveTextSize = 16;
        static string GUIRemoveTextAnchorMin = "0.1 0";
        static string GUIRemoveTextAnchorMax = "1 1";

        static string GUITimeLeftBackgroundColor = "0.1 0.1 0.1 0.98";
        static string GUITimeLeftAnchorMin = "0.55 0.9";
        static string GUITimeLeftAnchorMax = "1 1";

        static string GUITimeLeftTextColor = "1 1 1 0.98";
        static int GUITimeLeftTextSize = 16;
        static string GUITimeLeftTextAnchorMin = "0 0";
        static string GUITimeLeftTextAnchorMax = "0.9 1";

        static string GUIEntityBackgroundColor = "0.1 0.1 0.1 0.98";
        static string GUIEntityAnchorMin = "0 0.8";
        static string GUIEntityAnchorMax = "1 0.9";

        static string GUIEntityTextColor = "1 1 1 0.98";
        static int GUIEntityTextSize = 16;
        static string GUIEntityTextAnchorMin = "0.05 0";
        static string GUIEntityTextAnchorMax = "1 1";

        static bool GUIAuthorizations = true;
        static string GUIAllowedBackgroundColor = "0.1 1 0.1 0.3";
        static string GUIRefusedBackgroundColor = "1 0.1 0.1 0.3";
        static string GUIAuthorizationsAnchorMin = "0 0.8";
        static string GUIAuthorizationsAnchorMax = "1 0.9";

        static string GUIPriceBackgroundColor = "0.1 0.1 0.1 0.98";
        static string GUIPriceAnchorMin = "0 0.60";
        static string GUIPriceAnchorMax = "1 0.80";

        static bool GUIPrices = true;
        static string GUIPriceTextColor = "1 1 1 0.98";
        static int GUIPriceTextSize = 16;
        static string GUIPriceTextAnchorMin = "0.05 0";
        static string GUIPriceTextAnchorMax = "0.3 1";

        static string GUIPrice2TextColor = "1 1 1 0.98";
        static int GUIPrice2TextSize = 16;
        static string GUIPrice2TextAnchorMin = "0.35 0";
        static string GUIPrice2TextAnchorMax = "1 1";

        static string GUIRefundBackgroundColor = "0.1 0.1 0.1 0.98";
        static string GUIRefundAnchorMin = "0 0.40";
        static string GUIRefundAnchorMax = "1 0.60";

        static bool GUIRefund = true;
        static string GUIRefundTextColor = "1 1 1 0.98";
        static int GUIRefundTextSize = 16;
        static string GUIRefundTextAnchorMin = "0.05 0";
        static string GUIRefundTextAnchorMax = "0.3 1";

        static string GUIRefund2TextColor = "1 1 1 0.98";
        static int GUIRefund2TextSize = 16;
        static string GUIRefund2TextAnchorMin = "0.35 0";
        static string GUIRefund2TextAnchorMax = "1 1";


        static Dictionary<string, string> PrefabNameToDeployable = new Dictionary<string, string>();
        static Dictionary<string, string> PrefabNameToStructure = new Dictionary<string, string>();
        static Dictionary<string, int> ItemNameToItemID = new Dictionary<string, int>();
        static Hash<uint, float> LastAttackedBuildings = new Hash<uint, float>();
        static Hash<ulong, float> LastBlockedPlayers = new Hash<ulong, float>();

        public enum RemoveType
        {
            All,
            Structure,
            Admin,
            Normal
        }

        #endregion

        #region Config
        protected override void LoadDefaultConfig() { }

        private void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T)
                var = (T)Config[Key];
            else
                Config[Key] = var;
        }
        #endregion

        #region Oxide Hooks
        void LoadConfigs()
        {
            CheckCfg<string>("Remove - Access - Oxide Permissions - Normal", ref permissionNormal);
            CheckCfg<string>("Remove - Access - Oxide Permissions - Override", ref permissionOverride);
            CheckCfg<string>("Remove - Access - Oxide Permissions - Admin", ref permissionAdmin);
            CheckCfg<string>("Remove - Access - Oxide Permissions - All", ref permissionAll);
            CheckCfg<string>("Remove - Access - Oxide Permissions - Target", ref permissionTarget);

            CheckCfg<int>("Remove - Access - AuthLevel - Normal", ref authNormal);
            CheckCfg<int>("Remove - Access - AuthLevel - Override", ref authOverride);
            CheckCfg<int>("Remove - Access - AuthLevel - Admin", ref authAdmin);
            CheckCfg<int>("Remove - Access - AuthLevel - All", ref authAll);
            CheckCfg<int>("Remove - Access - AuthLevel - Target", ref authTarget);

            CheckCfg<int>("Remove - Distance - Normal", ref removeDistanceNormal);
            CheckCfg<int>("Remove - Distance - Admin", ref removeDistanceAdmin);
            CheckCfg<int>("Remove - Distance - All/Structure", ref removeDistanceAll);

            CheckCfg<bool>("Remove - Gibs - Normal", ref removeGibsNormal);
            CheckCfg<bool>("Remove - Gibs - Admin", ref removeGibsAdmin);
            CheckCfg<bool>("Remove - Gibs - All", ref removeGibsAll);

            CheckCfg<int>("Remove - Time - Default", ref RemoveDefaultTime);
            CheckCfg<int>("Remove - Time - Max", ref RemoveMaxTime);

            CheckCfg<bool>("Remove - Normal - Use Tool Cupboards (strongly unrecommended)", ref RemoveWithToolCupboards);
            CheckCfg<bool>("Remove - Normal - Use Entity Owners", ref RemoveWithEntityOwners);
            CheckCfg<bool>("Remove - Normal - Use Building Owners (You will need Building Owners plugin)", ref RemoveWithBuildingOwners);
            CheckCfg<bool>("Remove - Normal - Use Friends (RustIO)", ref RemoveWithRustIO);
            CheckCfg<bool>("Remove - Normal - Use Friends (Friends)", ref RemoveWithFriends);

            CheckCfg<bool>("Remove - Normal - RaidBlocker", ref RaidBlocker);
            CheckCfg<bool>("Remove - Normal - RaidBlocker - By Buildings", ref RaidBlockerBlockBuildingID);
            CheckCfg<bool>("Remove - Normal - RaidBlocker - By Surrounding Players", ref RaidBlockerBlockSurroundingPlayers);
            CheckCfg<int>("Remove - Normal - RaidBlocker - By Surrounding Players - Radius", ref RaidBlockerRadius);
            CheckCfg<int>("Remove - Normal - RaidBlocker - Time", ref RaidBlockerTime);

            ValidEntities = DefaultEntities();
            Price = DefaultPay();
            Refund = DefaultRefund();
            CheckCfg<Dictionary<string, object>>("Remove - Normal - Allowed Entities", ref ValidEntities);
            CheckCfg<Dictionary<string, object>>("Remove - Normal - Price", ref Price);
            CheckCfg<Dictionary<string, object>>("Remove - Normal - Refund", ref Refund);

            CheckCfg<string>("Remove - GUI - Main Box - Min Anchor (in Rust Window)", ref GUIRemoverToolAnchorMin);
            CheckCfg<string>("Remove - GUI - Main Box - Max Anchor (in Rust Window)", ref GUIRemoverToolAnchorMax);
            CheckCfg<string>("Remove - GUI - Main Box - Background Color", ref GUIRemoverToolBackgroundColor);

            CheckCfg<string>("Remove - GUI - Remove - Box - Min Anchor (in Main Box)", ref GUIRemoveAnchorMin);
            CheckCfg<string>("Remove - GUI - Remove - Box - Max Anchor (in Main Box)", ref GUIRemoveAnchorMax);
            CheckCfg<string>("Remove - GUI - Remove - Box - Background Color", ref GUIRemoveBackgroundColor);

            CheckCfg<string>("Remove - GUI - Remove - Text - Min Anchor (in Remove Box)", ref GUIRemoveTextAnchorMin);
            CheckCfg<string>("Remove - GUI - Remove - Text - Max Anchor (in Remove Box)", ref GUIRemoveTextAnchorMax);
            CheckCfg<string>("Remove - GUI - Remove - Text - Text Color", ref GUIRemoveTextColor);
            CheckCfg<int>("Remove - GUI - Remove - Text - Text Size", ref GUIRemoveTextSize);

            CheckCfg<string>("Remove - GUI - Timeleft - Box - Min Anchor (in Main Box)", ref GUITimeLeftAnchorMin);
            CheckCfg<string>("Remove - GUI - Timeleft - Box - Max Anchor (in Main Box)", ref GUITimeLeftAnchorMax);
            CheckCfg<string>("Remove - GUI - Timeleft - Box - Background Color", ref GUITimeLeftBackgroundColor);

            CheckCfg<string>("Remove - GUI - Timeleft - Text - Min Anchor (in Timeleft Box)", ref GUITimeLeftTextAnchorMin);
            CheckCfg<string>("Remove - GUI - Timeleft - Text - Max Anchor (in Timeleft Box)", ref GUITimeLeftTextAnchorMax);
            CheckCfg<string>("Remove - GUI - Timeleft - Text - Text Color", ref GUITimeLeftTextColor);
            CheckCfg<int>("Remove - GUI - Timeleft - Text - Text Size", ref GUITimeLeftTextSize);

            CheckCfg<string>("Remove - GUI - Entity - Box - Min Anchor (in Main Box)", ref GUIEntityAnchorMin);
            CheckCfg<string>("Remove - GUI - Entity - Box - Max Anchor (in Main Box)", ref GUIEntityAnchorMax);
            CheckCfg<string>("Remove - GUI - Entity - Box - Background Color", ref GUIEntityBackgroundColor);

            CheckCfg<string>("Remove - GUI - Entity - Text - Min Anchor (in Entity Box)", ref GUIEntityTextAnchorMin);
            CheckCfg<string>("Remove - GUI - Entity - Text - Max Anchor (in Entity Box)", ref GUIEntityTextAnchorMax);
            CheckCfg<string>("Remove - GUI - Entity - Text - Text Color", ref GUIEntityTextColor);
            CheckCfg<int>("Remove - GUI - Entity - Text - Text Size", ref GUIEntityTextSize);

            CheckCfg<bool>("Remove - GUI - Authorization Check Hightlighting Box", ref GUIAuthorizations);
            CheckCfg<string>("Remove - GUI - Authorization Check Hightlighting Box - Min Anchor (in Main Box)", ref GUIAuthorizationsAnchorMin);
            CheckCfg<string>("Remove - GUI - Authorization Check Hightlighting Box - Max Anchor (in Main Box)", ref GUIAuthorizationsAnchorMax);
            CheckCfg<string>("Remove - GUI - Authorization Check Hightlighting Box - Allowed Background", ref GUIAllowedBackgroundColor);
            CheckCfg<string>("Remove - GUI - Authorization Check Hightlighting Box - Refused Background", ref GUIRefusedBackgroundColor);

            CheckCfg<bool>("Remove - GUI - Price", ref GUIPrices);
            CheckCfg<string>("Remove - GUI - Price - Box - Min Anchor (in Main Box)", ref GUIPriceAnchorMin);
            CheckCfg<string>("Remove - GUI - Price - Box - Max Anchor (in Main Box)", ref GUIPriceAnchorMax);
            CheckCfg<string>("Remove - GUI - Price - Box - Background Color", ref GUIPriceBackgroundColor);

            CheckCfg<string>("Remove - GUI - Price - Text - Min Anchor (in Price Box)", ref GUIPriceTextAnchorMin);
            CheckCfg<string>("Remove - GUI - Price - Text - Max Anchor (in Price Box)", ref GUIPriceTextAnchorMax);
            CheckCfg<string>("Remove - GUI - Price - Text - Text Color", ref GUIPriceTextColor);
            CheckCfg<int>("Remove - GUI - Price - Text - Text Size", ref GUIPriceTextSize);

            CheckCfg<string>("Remove - GUI - Price - Text2 - Min Anchor (in Price Box)", ref GUIPrice2TextAnchorMin);
            CheckCfg<string>("Remove - GUI - Price - Text2 - Max Anchor (in Price Box)", ref GUIPrice2TextAnchorMax);
            CheckCfg<string>("Remove - GUI - Price - Text2 - Text Color", ref GUIPrice2TextColor);
            CheckCfg<int>("Remove - GUI - Price - Text2 - Text Size", ref GUIPrice2TextSize);

            CheckCfg<bool>("Remove - GUI - Refund", ref GUIRefund);
            CheckCfg<string>("Remove - GUI - Refund - Box - Min Anchor (in Main Box)", ref GUIRefundAnchorMin);
            CheckCfg<string>("Remove - GUI - Refund - Box - Max Anchor (in Main Box)", ref GUIRefundAnchorMax);
            CheckCfg<string>("Remove - GUI - Refund - Box - Background Color", ref GUIRefundBackgroundColor);

            CheckCfg<string>("Remove - GUI - Refund - Text - Min Anchor (in Refund Box)", ref GUIRefundTextAnchorMin);
            CheckCfg<string>("Remove - GUI - Refund - Text - Max Anchor (in Refund Box)", ref GUIRefundTextAnchorMax);
            CheckCfg<string>("Remove - GUI - Refund - Text - Text Color", ref GUIRefundTextColor);
            CheckCfg<int>("Remove - GUI - Refund - Text - Text Size", ref GUIRefundTextSize);

            CheckCfg<string>("Remove - GUI - Refund - Text2 - Min Anchor (in Refund Box)", ref GUIRefund2TextAnchorMin);
            CheckCfg<string>("Remove - GUI - Refund - Text2 - Max Anchor (in Refund Box)", ref GUIRefund2TextAnchorMax);
            CheckCfg<string>("Remove - GUI - Refund - Text2 - Text Color", ref GUIRefund2TextColor);
            CheckCfg<int>("Remove - GUI - Refund - Text2 - Text Size", ref GUIRefund2TextSize);

            SaveConfig();
        }

        void OnServerInitialized()
        {
            InitializeRustIO();
            InitializeItems();
            InitializeConstruction();

            LoadConfigs();

            permission.RegisterPermission(permissionNormal, this);
            permission.RegisterPermission(permissionAdmin, this);
            permission.RegisterPermission(permissionTarget, this);
            permission.RegisterPermission(permissionAll, this);

            rt = this;
        }

        void Loaded()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                { "You don't have access to this command.", "You don't have access to this command."},
                {"{0} {1} now has remover tool activated for {2} seconds ({3})","{0} {1} now has remover tool activated for {2} seconds ({3})" },
                {"Couldn't use the RemoverTool: You don't have enough resources.","Couldn't use the RemoverTool: You don't have enough resources."},
                {"RemoverTool from your target has been deactivated.","RemoverTool from your target has been deactivated."},
                {"Couldn't use the RemoverTool: Admin has restricted this entity from being removed.","Couldn't use the RemoverTool: Admin has restricted this entity from being removed." },
                {"Couldn't use the RemoverTool: An external plugin blocked the usage","Couldn't use the RemoverTool: An external plugin blocked the usage" },
                {"Couldn't use the RemoverTool: No valid entity targeted","Couldn't use the RemoverTool: No valid entity targeted" },
                {"Couldn't use the RemoverTool: Paying system crashed! Contact an administrator with the time and date to help him understand what happened.","Couldn't use the RemoverTool: Paying system crashed! Contact an administrator with the time and date to help him understand what happened." },
                {"Couldn't use the RemoverTool: No valid entity targeted, or entity is too far.","Couldn't use the RemoverTool: No valid entity targeted, or entity is too far." },
                {"Refund:","Refund:" },
                {"Nothing","Nothing" },
                { "Price:","Price:"},
                {"Free","Free" },
                {"Timeleft: {0}secs","Timeleft: {0}secs" },
                {"Remover Tool {0}","Remover Tool {0}" },
                {"RemoverTool is currently disabled.\n","RemoverTool is currently disabled.\n" },
                {"You are not allowed to use this command option.\n","You are not allowed to use this command option.\n" },
                {"You are not allowed to use this command.\n","You are not allowed to use this command.\n" },
                {"Couldn't use the RemoverTool: The Remover Tool is blocked for another {0} seconds.","Couldn't use the RemoverTool: The Remover Tool is blocked for another {0} seconds." },
                {"Couldn't find player. Multiple players match: {0}.\n","Couldn't find player. Multiple players match: {0}.\n" },
                {"Couldn't find player. No players match this name: {0}.\n","Couldn't find player. No players match this name: {0}.\n" },
                {"Couldn't use the RemoverTool: You don't have any rights to remove this.","Couldn't use the RemoverTool: You don't have any rights to remove this." },
                {"<size=18>Remover Tool</size> by <color=#ce422b>Reneb</color>\n<color=\"#ffd479\">/remove optional:TimerInSeconds</color> - Activate/Deactivate the Remover Tool, You will need to have no highlighted items in your belt bar.","<size=18>Remover Tool</size> by <color=#ce422b>Reneb</color>\n<color=\"#ffd479\">/remove optional:TimerInSeconds</color> - Activate/Deactivate the Remover Tool, You will need to have no highlighted items in your belt bar." }
            }, this);
        }

        void Unload()
        {
            foreach (ToolRemover toolremover in Resources.FindObjectsOfTypeAll<ToolRemover>())
            {
                toolremover.Destroy();
            }
        }

        #endregion


        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// RustIO Inclusion
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        private static Library RustIO;
        private static MethodInfo isInstalled;
        private static MethodInfo hasFriend;

        private static bool RustIOIsInstalled()
        {
            if (RustIO == null) return false;
            return (bool)isInstalled.Invoke(RustIO, new object[] { });
        }
        private void InitializeRustIO()
        {
            if (!RemoveWithRustIO)
            {
                RustIO = null;
                return;
            }
            RustIO = Interface.GetMod().GetLibrary<Library>("RustIO");
            if (RustIO == null || (isInstalled = RustIO.GetFunction("IsInstalled")) == null || (hasFriend = RustIO.GetFunction("HasFriend")) == null)
            {
                RustIO = null;
                Puts("{0}: {1}", Title, "Rust:IO is not present. You need to install Rust:IO first in order to use the RustIO option!");
            }
        }
        private static bool HasFriend(string playerId, string friendId)
        {
            if (RustIO == null) return false;
            return (bool)hasFriend.Invoke(RustIO, new object[] { playerId, friendId });
        }

        #region Initializing

        void InitializeItems()
        {
            foreach (var item in ItemManager.GetItemDefinitions())
            {
                if (!ItemNameToItemID.ContainsKey(item.displayName.english.ToLower())) ItemNameToItemID.Add(item.displayName.english.ToLower(), item.itemid);

                var itemdeployable = item?.GetComponent<ItemModDeployable>();
                if (itemdeployable == null) continue;

                if (!PrefabNameToDeployable.ContainsKey(itemdeployable.entityPrefab.resourcePath)) PrefabNameToDeployable.Add(itemdeployable.entityPrefab.resourcePath, item.displayName.english);
            }
        }
        void InitializeConstruction()
        {
            foreach (var construction in PrefabAttribute.server.GetAll<Construction>())
            {
                if (construction.deployable == null && construction.info.name.english != string.Empty)
                    if (!PrefabNameToStructure.ContainsKey(construction.fullName)) PrefabNameToStructure.Add(construction.fullName, construction.info.name.english);
            }
        }

        Dictionary<string, object> DefaultPay()
        {
            var d = new Dictionary<string, object>
            {
                {"Twigs", new Dictionary<string,object>
                    {
                        { "wood", 1 }
                    }
                },
                {"Wood", new Dictionary<string,object>
                    {
                        { "wood", 10 }
                    }
                },
                {"Stone", new Dictionary<string,object>
                    {
                        { "stones", 50 },
                        { "wood", 10 }
                    }
                },
                {"Metal", new Dictionary<string,object>
                    {
                        { "metal fragments", 75 }
                    }
                },
                {"TopTier", new Dictionary<string,object>
                    {
                         { "high quality metal", 5 }
                    }
                },
            };
            foreach (var itemname in PrefabNameToDeployable.Values)
            {
                d.Add(itemname, new Dictionary<string, object> {
                    { "wood", 75 },
                    {"metal fragments", 10 }
                });
            }

            return d;
        }

        Dictionary<string, object> DefaultEntities()
        {
            var d = new Dictionary<string, object>
            {
                {"Twigs", true},
                {"Wood", true},
                {"Stone", true},
                {"Metal", true},
                {"TopTier", true}
            };
            foreach (var itemname in PrefabNameToStructure.Values)
            {
                d.Add(itemname, true);
            }
            foreach (var itemname in PrefabNameToDeployable.Values)
            {
                d.Add(itemname, true);
            }
            return d;
        }

        Dictionary<string, object> DefaultRefund()
        {
            var d = new Dictionary<string, object>
            {
                {"Twigs", new Dictionary<string,object>
                    {
                        { "wood", 1 }
                    }
                },
                {"Wood", new Dictionary<string,object>
                    {
                        { "wood", 10 }
                    }
                },
                {"Stone", 50},
                {"Metal", new Dictionary<string,object>
                    {
                        { "metal fragments", 50 }
                    }
                },
                {"TopTier", new Dictionary<string,object>
                    {
                        { "high quality metal", 2 }
                    }
                },
            };
            foreach (var itemname in PrefabNameToDeployable.Values)
            {
                d.Add(itemname, new Dictionary<string, object> {
                    { itemname.ToLower(), 1 }
                });
            }

            return d;
        }

        #endregion

        #region Methods
        static string GetMsg(string key, BasePlayer source = null) { return rt.lang.GetMessage(key, rt, source == null ? null : source.UserIDString); }

        bool hasPermission(BasePlayer player, string perm, int authlevel)
        {
            if (player == null) return true;
            if (player.net.connection.authLevel >= authlevel) return true;
            return permission.UserHasPermission(player.userID.ToString(), perm);
        }

        string ListPlayersToString(List<IPlayer> players)
        {
            var returnstring = string.Empty;
            foreach (var player in players)
            {
                returnstring += string.Format("{0} {1}\n", player.Id, player.Name);
            }
            return returnstring;
        }

        bool GetParameters(BasePlayer player, string[] args, out RemoveType RemoveType, out BasePlayer Target, out int Time, out string Reason)
        {
            Reason = string.Empty;
            Target = player;
            RemoveType = RemoveType.Normal;
            Time = RemoveDefaultTime;

            if (args != null)
            {
                foreach (var arg in args)
                {
                    switch (arg.ToLower())
                    {
                        case "normal":
                            RemoveType = RemoveType.Normal;
                            break;
                        case "admin":
                            RemoveType = RemoveType.Admin;
                            break;
                        case "all":
                            RemoveType = RemoveType.All;
                            break;
                        case "structure":
                            RemoveType = RemoveType.Structure;
                            break;
                        default:
                            ulong userid = 0L;
                            int temptime = 0;
                            if (arg.Length == 17 && ulong.TryParse(arg, out userid)) { Target = BasePlayer.Find(arg); }
                            else if (int.TryParse(arg, out temptime)) { Time = temptime; }
                            else
                            {
                                var players = covalence.Players.FindPlayers(arg).Where(x => x.IsConnected).ToList();
                                if (players.Count == 0) { Reason += string.Format(GetMsg("Couldn't find player. No players match this name: {0}.\n", player), arg); }
                                else if (players.Count > 1) { Reason += string.Format(GetMsg("Couldn't find player. Multiple players match: {0}.\n", player), ListPlayersToString(players)); }
                                else { Target = (BasePlayer)players[0]?.Object; }
                            }
                            break;
                    }
                }
            }
            if (Target != player && !hasPermission(player, permissionTarget, authTarget)) Reason += string.Format(GetMsg("You are not allowed to use this command option.\n", player));
            if (RemoveType == RemoveType.Normal && !hasPermission(player, permissionNormal, authNormal)) Reason += string.Format(GetMsg("You are not allowed to use this command.\n", player));
            if ((RemoveType == RemoveType.All || RemoveType == RemoveType.Structure) && !hasPermission(player, permissionAll, authAll)) Reason += string.Format(GetMsg("You are not allowed to use this command option.\n", player));
            if (RemoveType == RemoveType.Admin && !hasPermission(player, permissionAdmin, authAdmin)) Reason += string.Format(GetMsg("You are not allowed to use this command option.\n", player));
            if (RemoveOverride && !hasPermission(player, permissionOverride, authOverride)) Reason += string.Format(GetMsg("RemoverTool is currently disabled.\n", player));
            if (Time > RemoveMaxTime) Time = RemoveMaxTime;

            return (Reason == string.Empty);
        }

        static void DoRemove(BaseEntity Entity, bool gibs = true)
        {
            if (Entity != null)
            {
                Interface.Oxide.CallHook("OnRemovedEntity", Entity);
                if (!Entity.isDestroyed)
                    Entity.Kill(gibs ? BaseNetworkable.DestroyMode.Gib : BaseNetworkable.DestroyMode.None);
            }
        }

        #endregion

        #region UI
        public class UI
        {
            static public CuiElementContainer CreateElementContainer(string parent, string panelName, string color, string aMin, string aMax, bool useCursor)
            {
                var NewElement = new CuiElementContainer()
                {
                    {
                        new CuiPanel
                        {
                            Image = {Color = color},
                            RectTransform = {AnchorMin = aMin, AnchorMax = aMax},
                            CursorEnabled = useCursor
                        },
                        new CuiElement().Parent = parent,
                        panelName
                    }
                };
                return NewElement;
            }
            static public void CreatePanel(ref CuiElementContainer container, string panel, string color, string aMin, string aMax, bool cursor = false)
            {
                container.Add(new CuiPanel
                {
                    Image = { Color = color },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    CursorEnabled = cursor
                },
                panel);
            }
            static public void CreateLabel(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiLabel
                {
                    Text = { Color = color, FontSize = size, Align = align, Text = text },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax }
                },
                panel);

            }
            static public void CreateButton(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, string command, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiButton
                {
                    Button = { Color = color, Command = command, FadeIn = 1.0f },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    Text = { Text = text, FontSize = size, Align = align }
                },
                panel);
            }
        }
        public static string GetName(string prefabname)
        {
            if (PrefabNameToStructure.ContainsKey(prefabname)) return PrefabNameToStructure[prefabname];
            else if (PrefabNameToDeployable.ContainsKey(prefabname)) return PrefabNameToDeployable[prefabname];
            return string.Empty;
        }

        public static void CreateGUI(BasePlayer player, RemoveType removeType)
        {
            var panelName = "RemoverTool";
            CuiHelper.DestroyUi(player, panelName);

            var Class_Element = UI.CreateElementContainer("Overlay", panelName, GUIRemoverToolBackgroundColor, GUIRemoverToolAnchorMin, GUIRemoverToolAnchorMax, false);
            CuiHelper.AddUi(player, Class_Element);

            var panelName2 = "Remove";
            CuiHelper.DestroyUi(player, panelName2);
            var Class_Element2 = UI.CreateElementContainer(panelName, panelName2, GUIRemoveBackgroundColor, GUIRemoveAnchorMin, GUIRemoveAnchorMax, false);
            UI.CreateLabel(ref Class_Element2, panelName2, GUIRemoveTextColor, string.Format(GetMsg("Remover Tool {0}", player), removeType == RemoveType.Normal ? string.Empty : string.Format("({0})", removeType.ToString())), GUIRemoveTextSize, GUIRemoveTextAnchorMin, GUIRemoveTextAnchorMax, TextAnchor.MiddleLeft);

            CuiHelper.AddUi(player, Class_Element2);
        }
        public static void GUITimeLeftUpdate(BasePlayer player, int timeleft)
        {
            var panelName = "RemoverToolTimeLeft";
            CuiHelper.DestroyUi(player, panelName);

            var Class_Element = UI.CreateElementContainer("RemoverTool", panelName, GUITimeLeftBackgroundColor, GUITimeLeftAnchorMin, GUITimeLeftAnchorMax, false);
            UI.CreateLabel(ref Class_Element, panelName, GUITimeLeftTextColor, string.Format(GetMsg("Timeleft: {0}secs", player), timeleft.ToString()), GUITimeLeftTextSize, GUITimeLeftTextAnchorMin, GUITimeLeftTextAnchorMax, TextAnchor.MiddleLeft);

            CuiHelper.AddUi(player, Class_Element);
        }
        public static void GUIEntityUpdate(BasePlayer player, BaseEntity TargetEntity)
        {
            var panelName = "RemoverToolEntity";
            CuiHelper.DestroyUi(player, panelName);
            if (TargetEntity == null) return;
            var Name = GetName(TargetEntity.PrefabName);
            var Class_Element = UI.CreateElementContainer("RemoverTool", panelName, GUIEntityBackgroundColor, GUIEntityAnchorMin, GUIEntityAnchorMax, false);
            UI.CreateLabel(ref Class_Element, panelName, GUIEntityTextColor, Name, GUIEntityTextSize, GUIEntityTextAnchorMin, GUIEntityTextAnchorMax, TextAnchor.MiddleLeft);

            CuiHelper.AddUi(player, Class_Element);
        }

        public static void GUIPricesUpdate(BasePlayer player, bool usePrice, BaseEntity TargetEntity)
        {
            var panelName = "RemoverToolPrice";
            CuiHelper.DestroyUi(player, panelName);
            if (TargetEntity == null) return;
            Dictionary<string, object> price = new Dictionary<string, object>();
            if (usePrice)
            {
                price = GetPrice(TargetEntity);
            }
            string cost = string.Empty;
            if (price.Count == 0) cost = GetMsg("Free", player);
            else
            {
                foreach (KeyValuePair<string, object> p in price)
                {
                    cost += string.Format("{2}{0} x{1}", p.Key, p.Value.ToString(), cost != string.Empty ? "\n" : string.Empty);
                }
            }
            var Class_Element = UI.CreateElementContainer("RemoverTool", panelName, GUIPriceBackgroundColor, GUIPriceAnchorMin, GUIPriceAnchorMax, false);
            UI.CreateLabel(ref Class_Element, panelName, GUIPriceTextColor, GetMsg("Price:", player), GUIPriceTextSize, GUIPriceTextAnchorMin, GUIPriceTextAnchorMax, TextAnchor.MiddleLeft);
            UI.CreateLabel(ref Class_Element, panelName, GUIPrice2TextColor, cost, GUIPrice2TextSize, GUIPrice2TextAnchorMin, GUIPrice2TextAnchorMax, TextAnchor.MiddleLeft);
            CuiHelper.AddUi(player, Class_Element);
        }
        public static void GUIRefundUpdate(BasePlayer player, bool useRefund, BaseEntity TargetEntity)
        {
            var panelName = "RemoverToolRefund";
            CuiHelper.DestroyUi(player, panelName);
            if (TargetEntity == null) return;
            Dictionary<string, object> refund = new Dictionary<string, object>();
            if (useRefund)
            {
                refund = GetRefund(TargetEntity);
            }
            string r = string.Empty;
            if (refund.Count == 0) r = GetMsg("Nothing", player);
            else
            {
                foreach (KeyValuePair<string, object> p in refund)
                {
                    r += string.Format("{2}{0} x{1}", p.Key, p.Value.ToString(), r != string.Empty ? "\n" : string.Empty);
                }
            }
            var Class_Element = UI.CreateElementContainer("RemoverTool", panelName, GUIRefundBackgroundColor, GUIRefundAnchorMin, GUIRefundAnchorMax, false);
            UI.CreateLabel(ref Class_Element, panelName, GUIRefundTextColor, GetMsg("Refund:", player), GUIRefundTextSize, GUIRefundTextAnchorMin, GUIRefundTextAnchorMax, TextAnchor.MiddleLeft);
            UI.CreateLabel(ref Class_Element, panelName, GUIRefund2TextColor, r, GUIRefund2TextSize, GUIRefund2TextAnchorMin, GUIRefund2TextAnchorMax, TextAnchor.MiddleLeft);
            CuiHelper.AddUi(player, Class_Element);
        }

        public static void GUIAuthorizationUpdate(BasePlayer player, RemoveType removeType, BaseEntity TargetEntity, bool shouldPay)
        {
            var panelName = "RemoverToolAuth";
            CuiHelper.DestroyUi(player, panelName);
            if (TargetEntity == null) return;

            string Reason = string.Empty;
            string GUIColor = CanRemoveEntity(player, removeType, TargetEntity, shouldPay, out Reason) ? GUIAllowedBackgroundColor : GUIRefusedBackgroundColor;
            var Class_Element = UI.CreateElementContainer("RemoverTool", panelName, GUIColor, GUIAuthorizationsAnchorMin, GUIAuthorizationsAnchorMax, false);

            CuiHelper.AddUi(player, Class_Element);
        }
        public static void DestroyGUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "RemoverTool");
        }
        #endregion

        #region ToolRemover Class

        class ToolRemover : MonoBehaviour
        {
            public BasePlayer player { get; set; }
            public BasePlayer source { get; set; }
            public int timeLeft { get; set; }
            public float distance { get; set; }
            public RemoveType removetype { get; set; }

            public bool Pay { get; set; }
            public bool Refund { get; set; }

            public BaseEntity TargetEntity { get; set; }
            RaycastHit RayHit;

            InputState state;

            float lastUpdate { get; set; }
            float lastRemove { get; set; }

            void Awake()
            {
                player = GetComponent<BasePlayer>();
                lastUpdate = UnityEngine.Time.realtimeSinceStartup;
                lastRemove = UnityEngine.Time.realtimeSinceStartup;
            }

            public void Start()
            {
                state = (InputState)serverInput.GetValue(player);
                CreateGUI(player, removetype);
                CancelInvoke("RemoveUpdate");
                InvokeRepeating("RemoveUpdate", 0f, 1f);
            }

            void RemoveUpdate()
            {
                timeLeft--;
                if (timeLeft <= 0) { Destroy(); return; }
                GUITimeLeftUpdate(player, timeLeft);
                GUIEntityUpdate(player, TargetEntity);
                if (removetype == RemoveType.Normal && GUIAuthorizations) GUIAuthorizationUpdate(player, removetype, TargetEntity, Pay);
                if (removetype == RemoveType.Normal && GUIPrices) GUIPricesUpdate(player, Pay, TargetEntity);
                if (removetype == RemoveType.Normal && GUIRefund) GUIRefundUpdate(player, Refund, TargetEntity);
            }

            void FixedUpdate()
            {
                if (player.IsSleeping() || !player.IsConnected()) { Destroy(); return; }

                float currentTime = UnityEngine.Time.realtimeSinceStartup;
                if (currentTime - lastUpdate >= 0.5f)
                {
                    bool flag1 = Physics.Raycast(player.eyes.HeadRay(), out RayHit, distance, colliderRemovable);
                    TargetEntity = flag1 ? RayHit.GetEntity() : null;
                    lastUpdate = currentTime;
                }

                if (state.IsDown(BUTTON.FIRE_PRIMARY))
                {
                    if (currentTime - lastRemove >= 0.5f)
                    {
                        var returnmsg = TryRemove(player, removetype, distance, Pay, Refund);
                        if (returnmsg != string.Empty) player.ChatMessage(returnmsg);
                        lastRemove = currentTime;
                    }
                }
            }

            public void Destroy()
            {
                CancelInvoke("RemoveUpdate");
                DestroyGUI(player);
                GameObject.Destroy(this);
            }
        }
        #endregion

        #region Pay
        static bool Pay(BasePlayer player, BaseEntity TargetEntity)
        {
            var cost = GetPrice(TargetEntity);
            try
            {
                List<Item> collect = new List<Item>();
                foreach (KeyValuePair<string, object> p in cost)
                {
                    var priceName = p.Key.ToLower();
                    var amount = (int)p.Value;
                    if (ItemNameToItemID.ContainsKey(priceName))
                    {
                        var itemid = ItemNameToItemID[priceName];
                        player.inventory.Take(collect, itemid, amount);
                        player.Command("note.inv", itemid, -amount);
                    }
                    else if (priceName == "withdraw")
                    {
                        var w = Interface.Oxide.CallHook("Withdraw", player.userID, (double)amount);
                        if (w == null || !(bool)w) return false;
                    }
                }
                foreach (Item item in collect)
                {
                    item.Remove(0f);
                }
            }
            catch (Exception e) { Interface.Oxide.LogWarning(string.Format("{0} {1} couldn't pay to remove entity: {2}", player.UserIDString, player.displayName, e.Message)); return false; }

            return true;
        }
        static Dictionary<string, object> GetPrice(BaseEntity TargetEntity)
        {
            var cost = new Dictionary<string, object>();
            var buildingblock = TargetEntity.GetComponent<BuildingBlock>();
            if (buildingblock != null)
            {
                var grade = buildingblock.grade.ToString();
                if (Price.ContainsKey(grade)) cost = Price[grade] as Dictionary<string, object>;
            }
            else
            {
                var prefabname = TargetEntity.PrefabName;
                if (PrefabNameToDeployable.ContainsKey(prefabname))
                {
                    var deployablename = PrefabNameToDeployable[prefabname];
                    if (Price.ContainsKey(deployablename))
                    {
                        cost = Price[deployablename] as Dictionary<string, object>;
                    }
                }
            }
            return cost;
        }

        static bool CanPay(BasePlayer player, BaseEntity TargetEntity)
        {
            var prefabname = TargetEntity.PrefabName;

            var cost = GetPrice(TargetEntity);
            if (cost.Count == 0) return true;

            foreach (KeyValuePair<string, object> p in cost)
            {
                var priceName = p.Key.ToLower();
                var amount = (int)p.Value;
                if (ItemNameToItemID.ContainsKey(priceName))
                {
                    int c = player.inventory.GetAmount(ItemNameToItemID[priceName]);
                    if (c < amount) return false;
                }
                else if (priceName == "withdraw")
                {
                    var b = Interface.Oxide.CallHook("GetPlayerMoney", player.userID);
                    if (b == null) return false;
                    var balance = (double)b;
                    if (balance <= amount) return false;
                }
            }
            return true;
        }
        #endregion

        #region Refund
        static void GiveRefund(BasePlayer player, BaseEntity TargetEntity)
        {
            var refund = GetRefund(TargetEntity);
            foreach (KeyValuePair<string, object> p in refund)
            {
                var itemname = p.Key.ToLower();
                if (ItemNameToItemID.ContainsKey(itemname))
                {
                    var itemid = ItemNameToItemID[itemname];
                    var itemamount = (int)p.Value;
                    var item = ItemManager.CreateByItemID(itemid, itemamount);
                    player.inventory.GiveItem(item, null);
                    player.Command("note.inv", itemid, itemamount);
                }
                else { Interface.Oxide.LogWarning(string.Format("{0} {1} didn't receive refund because {2} doesn't seem to be a valid item name", player.UserIDString, player.displayName, itemname)); }
            }
        }

        static Dictionary<string, object> GetRefund(BaseEntity TargetEntity)
        {
            var refund = new Dictionary<string, object>();
            var buildingblock = TargetEntity.GetComponent<BuildingBlock>();
            if (buildingblock != null)
            {
                var grade = buildingblock.grade.ToString();
                if (Refund.ContainsKey(grade))
                {
                    if (Refund[grade] is Dictionary<string, object>)
                        refund = Refund[grade] as Dictionary<string, object>;
                    else if (Refund[grade] is int)
                    {
                        var p = (int)Refund[grade] / 100f;
                        var @enum = buildingblock.grade;
                        var c = buildingblock.blockDefinition.grades[(int)@enum];
                        foreach (var ia in c.costToBuild)
                        {
                            var a = ia.amount * p;
                            if (Mathf.Floor(a) < 1) continue;
                            refund.Add(ia.itemDef.displayName.english.ToLower(), (int)a);
                        }
                    }
                }
            }
            else
            {
                var Name = GetName(TargetEntity.PrefabName);
                if (Refund.ContainsKey(Name)) refund = Refund[Name] as Dictionary<string, object>;
            }
            return refund;
        }

        #endregion

        #region RaidBlocker
        void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (!RaidBlocker) return;
            if (info == null) return;
            BuildingBlock block = entity?.GetComponent<BuildingBlock>();
            if (block == null) return;

            var attacker = info.InitiatorPlayer;
            if (attacker != null)
            {
                if (HasAccess(attacker, entity.GetComponent<BaseEntity>())) return;
            }

            BlockRemove(entity);
        }

        void BlockRemove(BaseCombatEntity entity)
        {
            if (RaidBlockerBlockBuildingID)
            {
                var buildingid = entity.GetComponent<BuildingBlock>()?.buildingID;
                if (buildingid == null) return;
                LastAttackedBuildings[(uint)buildingid] = UnityEngine.Time.realtimeSinceStartup;
            }

            if (RaidBlockerBlockSurroundingPlayers)
            {
                foreach (var collider in UnityEngine.Physics.OverlapSphere(entity.transform.position, (float)RaidBlockerRadius, colliderPlayer))
                {
                    var player = collider.GetComponent<BasePlayer>();
                    LastBlockedPlayers[player.userID] = UnityEngine.Time.realtimeSinceStartup;
                }
            }
        }
        static bool IsBlocked(BasePlayer player, BaseEntity TargetEntity, out float timeLeft)
        {
            timeLeft = 0f;
            if (RaidBlockerBlockBuildingID)
            {
                var buildingid = TargetEntity.GetComponent<BuildingBlock>()?.buildingID;
                if (buildingid != null)
                {
                    timeLeft = (float)RaidBlockerTime - (UnityEngine.Time.realtimeSinceStartup - LastAttackedBuildings[(uint)buildingid]);
                    if (timeLeft > 0f)
                    {
                        return true;
                    }
                }
            }
            if (RaidBlockerBlockSurroundingPlayers)
            {
                timeLeft = (float)RaidBlockerTime - (UnityEngine.Time.realtimeSinceStartup - LastBlockedPlayers[player.userID]);
                if (timeLeft > 0f)
                {
                    return true;
                }
            }
            return false;
        }
        #endregion

        #region TryRemove
        static string TryRemove(BasePlayer player, RemoveType removeType, float distance, bool shouldPay, bool shouldRefund)
        {
            RaycastHit RayHit;
            bool flag1 = Physics.Raycast(player.eyes.HeadRay(), out RayHit, distance, colliderRemovable);
            var TargetEntity = flag1 ? RayHit.GetEntity() : null;

            if (TargetEntity == null) return GetMsg("Couldn't use the RemoverTool: No valid entity targeted, or entity is too far.", player);

            string Reason = string.Empty;
            if (!CanRemoveEntity(player, removeType, TargetEntity, shouldPay, out Reason))
            {
                return Reason;
            }

            if (removeType == RemoveType.All) { RemoveAll(TargetEntity); return string.Empty; }
            if (removeType == RemoveType.Structure) { RemoveStructure(TargetEntity); return string.Empty; }

            if (shouldPay)
            {
                bool flag2 = Pay(player, TargetEntity);
                if (!flag2)
                {
                    return GetMsg("Couldn't use the RemoverTool: Paying system crashed! Contact an administrator with the time and date to help him understand what happened.", player);
                }
            }

            if (shouldRefund)
            {
                GiveRefund(player, TargetEntity);
            }

            DoRemove(TargetEntity, removeType == RemoveType.Normal ? removeGibsNormal : removeGibsAdmin);

            return string.Empty;
        }

        #endregion

        #region Remove Conditions
        static bool CanRemoveEntity(BasePlayer player, RemoveType removeType, BaseEntity TargetEntity, bool shouldPay, out string Reason)
        {
            Reason = string.Empty;
            float timeLeft = 0f;

            if (!IsRemovableEntity(TargetEntity))
            {
                Reason = GetMsg("Couldn't use the RemoverTool: No valid entity targeted", player);
                return false;
            }

            if (removeType != RemoveType.Normal) return true;

            var externalPlugins = Interface.CallHook("canRemove", player);
            if (externalPlugins != null)
            {
                Reason = externalPlugins is string ? (string)externalPlugins : GetMsg("Couldn't use the RemoverTool: An external plugin blocked the usage", player);
                return false;
            }

            if (!IsValidEntity(TargetEntity))
            {
                Reason = GetMsg("Couldn't use the RemoverTool: Admin has restricted this entity from being removed.", player);
                return false;
            }
            if (IsBlocked(player, TargetEntity, out timeLeft))
            {
                Reason = string.Format(GetMsg("Couldn't use the RemoverTool: The Remover Tool is blocked for another {0} seconds.", player), timeLeft.ToString());
                return false;
            }

            if (shouldPay && removeType == RemoveType.Normal && !CanPay(player, TargetEntity))
            {
                Reason = GetMsg("Couldn't use the RemoverTool: You don't have enough resources.", player);
                return false;
            }

            if (HasAccess(player, TargetEntity)) return true;

            Reason = GetMsg("Couldn't use the RemoverTool: You don't have any rights to remove this.", player);

            return false;
        }
        bool AreFriends(string steamid, string friend)
        {
            if (RemoveWithRustIO && RustIOIsInstalled())
            {
                if (HasFriend(steamid, friend)) return true;
            }
            if (RemoveWithFriends && Friends != null)
            {
                var r = Friends.CallHook("HasFriend", steamid, friend);
                if (r != null && (bool)r) return true;
            }
            return false;
        }
        static bool HasAccess(BasePlayer player, BaseEntity TargetEntity)
        {
            if (RemoveWithEntityOwners)
            {
                if (TargetEntity.OwnerID == player.userID) return true;
                if (rt.AreFriends(TargetEntity.OwnerID.ToString(), player.userID.ToString())) return true;
            }
            if (RemoveWithBuildingOwners)
            {
                BuildingBlock BuildingRef = TargetEntity.GetComponent<BuildingBlock>();
                if (BuildingRef == null)
                {
                    RaycastHit supportHit;
                    if (Physics.Raycast(TargetEntity.transform.position + new Vector3(0f, 0.1f, 0f), new Vector3(0f, -1f, 0f), out supportHit, 3f, colliderBuilding))
                    {
                        BaseEntity supportEnt = supportHit.GetEntity();
                        if (supportEnt != null)
                        {
                            BuildingRef = supportEnt.GetComponent<BuildingBlock>();
                        }
                    }
                }
                if (BuildingRef != null)
                {
                    var returnhook = Interface.GetMod().CallHook("FindBlockData", new object[] { BuildingRef });
                    if (returnhook is string)
                    {
                        string ownerid = (string)returnhook;
                        if (player.userID.ToString() == ownerid) return true;
                        if (rt.AreFriends(ownerid, player.userID.ToString())) return true;
                    }
                }
            }
            if (RemoveWithToolCupboards && hasTotalAccess(player))
            {
                return true;
            }
            return false;
        }

        static bool IsRemovableEntity(BaseEntity entity)
        {
            var Name = GetName(entity.PrefabName);
            return (!(Name == string.Empty));
        }
        static bool IsValidEntity(BaseEntity entity)
        {
            var Name = GetName(entity.PrefabName);

            if (ValidEntities.ContainsKey(Name) && !(bool)ValidEntities[Name]) return false;

            var buildingblock = entity.GetComponent<BuildingBlock>();
            if (buildingblock != null)
            {
                if (ValidEntities.ContainsKey(buildingblock.grade.ToString()) && !(bool)ValidEntities[buildingblock.grade.ToString()]) return false;
            }

            return true;
        }
        static bool hasTotalAccess(BasePlayer player)
        {
            List<BuildingPrivlidge> playerpriv = buildingPrivilege.GetValue(player) as List<BuildingPrivlidge>;
            if (playerpriv.Count == 0)
            {
                return false;
            }
            foreach (BuildingPrivlidge priv in playerpriv.ToArray())
            {
                List<ProtoBuf.PlayerNameID> authorized = priv.authorizedPlayers;
                bool flag1 = false;
                foreach (ProtoBuf.PlayerNameID pni in authorized.ToArray())
                {
                    if (pni.userid == player.userID)
                        flag1 = true;
                }
                if (!flag1)
                {
                    return false;
                }
            }
            return true;
        }

        #endregion

        #region Remove All
        static void RemoveAll(BaseEntity sourceEntity)
        {
            var current = 0;
            var checkFrom = new List<Vector3> { sourceEntity.transform.position };
            var removeList = new List<BaseEntity>();

            while (true)
            {
                if (current >= checkFrom.Count) break;

                List<BaseEntity> list = Pool.GetList<BaseEntity>();
                Vis.Entities<BaseEntity>(checkFrom[current], 3f, list, colliderRemovable);

                for (int i = 0; i < list.Count; i++)
                {
                    var entity = list[i];

                    if (removeList.Contains(entity)) continue;
                    removeList.Add(entity);

                    if (!checkFrom.Contains(entity.transform.position)) checkFrom.Add(entity.transform.position);

                }
                current++;
            }

            ServerMgr.Instance.StartCoroutine(DelayRemove(removeList));
        }

        static bool RemoveStructure(BaseEntity sourceEntity)
        {
            var buildingBlock = sourceEntity.GetComponent<BuildingBlock>();
            if (buildingBlock == null) return false;
            var buildingId = buildingBlock.buildingID;

            var removeList = UnityEngine.GameObject.FindObjectsOfType<BuildingBlock>().Where(x => x.buildingID == buildingId).ToList();

            ServerMgr.Instance.StartCoroutine(DelayRemove(removeList));
            return true;
        }

        public static IEnumerator DelayRemove(List<BuildingBlock> entities)
        {
            for (int i = 0; i < entities.Count; i++)
            {
                DoRemove(entities[i], false);
                yield return new WaitWhile(new Func<bool>(() => (!entities[i].isDestroyed)));
            }
        }
        public static IEnumerator DelayRemove(List<BaseEntity> entities)
        {
            for (int i = 0; i < entities.Count; i++)
            {
                DoRemove(entities[i], false);
                yield return new WaitWhile(new Func<bool>(() => (!entities[i].isDestroyed)));
            }
        }
        #endregion

        #region Toggle Remove
        string ToggleRemove(BasePlayer player, string[] args)
        {
            RemoveType RemoveType = RemoveType.Normal;
            BasePlayer Target = player;
            int Time = RemoveDefaultTime;
            string Reason = string.Empty;

            if (args == null || args.Length == 0)
            {
                var SourceRemover = player.GetComponent<ToolRemover>();
                if (SourceRemover != null) { SourceRemover.Destroy(); return string.Empty; }
            }

            bool flag1 = GetParameters(player, args, out RemoveType, out Target, out Time, out Reason);
            if (!flag1)
            {
                return Reason;
            }

            if (player != Target && (args != null && args.Length == 1))
            {
                var TargetRemover = Target.GetComponent<ToolRemover>();
                if (TargetRemover != null) { TargetRemover.Destroy(); return GetMsg("RemoverTool from your target has been deactivated.", player); }
            }

            var RemoverTool = Target.GetComponent<ToolRemover>();
            if (RemoverTool == null) RemoverTool = Target.gameObject.AddComponent<ToolRemover>();

            RemoverTool.source = player;
            RemoverTool.timeLeft = Time;
            RemoverTool.removetype = RemoveType;
            RemoverTool.Pay = (RemoveType == RemoveType.Normal);
            RemoverTool.Refund = (RemoveType == RemoveType.Normal);
            RemoverTool.distance = RemoveType == RemoveType.Normal ? (float)removeDistanceNormal : RemoveType == RemoveType.Admin ? (float)removeDistanceAdmin : (RemoveType == RemoveType.All || RemoveType == RemoveType.Structure) ? (float)removeDistanceAll : (float)removeDistanceNormal;
            RemoverTool.Start();

            return string.Format(GetMsg("{0} {1} now has remover tool activated for {2} seconds ({3})", player), Target.UserIDString, Target.displayName, Time.ToString(), RemoveType.ToString());
        }
        #endregion

        #region Commands
        [ChatCommand("remove")]
        void cmdChatRemove(BasePlayer player, string command, string[] args)
        {
            var success = ToggleRemove(player, args);
            SendReply(player, success);
        }

        [ConsoleCommand("remove.toggle")]
        void ccmdRemoveToggle(ConsoleSystem.Arg arg)
        {
            var success = ToggleRemove(arg.Player(), arg.Args);
            arg.ReplyWith(success);
        }

        [ConsoleCommand("remove")]
        void ccmdRemove(ConsoleSystem.Arg arg)
        {

        }

        [ConsoleCommand("remove.allow")]
        void ccmdRemoveAllow(ConsoleSystem.Arg arg)
        {
            if (arg.Args == null || arg.Args.Length == 0)
            {
                SendReply(arg, "remove.allow true/false");
                return;
            }
            if (arg.connection != null)
            {
                if (!hasPermission(arg.Player(), permissionOverride, authOverride)) return;
                {
                    arg.ReplyWith(GetMsg("You don't have access to this command.", arg.Player()));
                    return;
                }
            }
            switch (arg.Args[0].ToLower())
            {
                case "true":
                case "1":
                    RemoveOverride = false;
                    SendReply(arg, "Remove is now allowed depending on your settings.");
                    break;
                case "false":
                case "0":
                    RemoveOverride = true;
                    SendReply(arg, "Remove is now restricted for all players (exept admins)");
                    foreach (ToolRemover toolremover in Resources.FindObjectsOfTypeAll<ToolRemover>())
                    {
                        if (toolremover.removetype == RemoveType.Normal && toolremover.source == toolremover.player)
                        {
                            SendReply(toolremover.player, "The Remover Tool has been disabled by the admin");
                            timer.Once(0.01f, () => GameObject.Destroy(toolremover));
                        }
                    }
                    break;
                default:
                    SendReply(arg, "This is not a valid argument");
                    break;
            }
        }
        #endregion

        [HookMethod("SendHelpText")]
        private void SendHelpText(BasePlayer player)
        {
            SendReply(player, GetMsg("<size=18>Remover Tool</size> by <color=#ce422b>Reneb</color>\n<color=\"#ffd479\">/remove optional:TimerInSeconds</color> - Activate/Deactivate the Remover Tool, You will need to have no highlighted items in your belt bar.", player));
        }
    }
}


// --- End of file: RemoverTool.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/PM.cs ---
// --- Original Local Path: PM.cs ---

using System.Collections.Generic;
using System;
using System.Reflection;
using System.Data;
using System.Text;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Plugins;

namespace Oxide.Plugins 
{
    [Info("PM", "Steven", "1.0.2", ResourceId = 8906)]	
    class PM : RustPlugin 
	{
		bool FindByHoleName = false;
		
		Dictionary<ulong, ulong> PmHistory = new Dictionary<ulong, ulong>();		
		[HookMethod("OnPlayerDisconnected")]
		void OnPlayerDisconnected(BasePlayer player)
		{
			if(PmHistory.ContainsKey(player.userID)) PmHistory.Remove(player.userID);
		}		
		[ChatCommand("pm")]
        void cmdPm(BasePlayer player, string command, string[] args)
		{
			if(args.Length > 1)
			{
				string Player = args[0].ToLower(), Msg = "";
				for(int i = 1; i < args.Length; i++)				
					Msg = Msg + " " + args[i];
				BasePlayer p;
				if(FindByHoleName && (p = BasePlayer.activePlayerList.Find(x => x.displayName.ToLower().EndsWith(Player))) != null || (p = BasePlayer.activePlayerList.Find(x => x.displayName.ToLower().Contains(Player))) != null ) //used ends with due to clan tags
				{
					if(PmHistory.ContainsKey(player.userID)) PmHistory[player.userID] = p.userID; else PmHistory.Add(player.userID, p.userID);
					if(PmHistory.ContainsKey(p.userID)) PmHistory[p.userID] = player.userID; else PmHistory.Add(p.userID, player.userID);
					SendReply(player, "<color=#00FFFF>PM to " + p.displayName + "</color>: "+ Msg);
					SendReply(p, "<color=#00FFFF>PM from " + player.displayName + "</color>: "+ Msg);
				}
				else SendReply(player, Player+" is not online.");
			} else  SendReply(player, "Incorrect Syntax use: /pm <name> <msg>");
		}
		
		[ChatCommand("r")]
        void cmdPmReply(BasePlayer player, string command, string[] args)
		{
			if(args.Length > 0)
			{
				string Msg = "";
				for(int i = 0; i < args.Length; i++)				
					Msg = Msg + " " + args[i];
				ulong steamid;
				if(PmHistory.TryGetValue(player.userID, out steamid))
				{
					BasePlayer p;
					if((p = BasePlayer.activePlayerList.Find(x => x.userID == steamid)) != null)
					{
						SendReply(player, "<color=#00FFFF>PM to " + p.displayName + "</color>: "+ Msg);
						SendReply(p, "<color=#00FFFF>PM from " + player.displayName + "</color>: "+ Msg);
					}
					else SendReply(player, "the last person you was talking to is not online anymore.");
				} else SendReply(player, "You haven't messaged anyone or they haven't messaged you.");
			} else  SendReply(player, "Incorrect Syntax use: /r <msg>");
		}
    }
}

// --- End of file: PM.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/LimeBench.cs ---
// --- Original Local Path: LimeBench.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using System.Reflection;
using System.Text;
using System.Collections;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("L.I.M.E. Bench", "Deicide666ra", "1.1.2", ResourceId = 1155)]
    class LimeBench : RustPlugin
    {
        //*********************************************
        // Config values
        //*********************************************
        float c_craftingMultiplier;
        float c_gunpowderMultiplier;
        float c_benchMultiplier;

        string[] c_craftingMultiplierBlacklist;
        string[] c_benchMultiplierBlacklist;
        string[] c_bulkCraftBlacklist;

        int c_craftingMultiplierAuthLevel;
        int c_benchMultiplierAuthLevel;

        string g_bulkCraftPermissionName= "limeBenchBulk";
        string g_bulkCraftNoCupboardPermissionName = "limeBenchBulkNoCup";


        //*********************************************
        // Rollback and reference values
        //*********************************************
        Dictionary<int, float> r_blueprintTimes = new Dictionary<int, float>();


        //*********************************************
        // Global Workset
        //*********************************************
        private bool configChanged = false;
        List<ItemBlueprint> blueprintDefinitions = new List<ItemBlueprint>();
        private FieldInfo buildingPrivlidges;


        //*********************************************
        // Init / Config functions
        //*********************************************
        void Loaded() => LoadConfigValues();
        void Unloaded() => Rollback();
        protected override void LoadDefaultConfig() => Puts("New configuration file created.");


        void LoadConfigValues()
        {
            c_craftingMultiplier = Convert.ToSingle(GetConfigValue("Crafting", "craftingMultiplier", 0.75f));
            c_gunpowderMultiplier = Convert.ToSingle(GetConfigValue("Crafting", "gunpowderMultiplier", 0.4f));
            c_benchMultiplier = Convert.ToSingle(GetConfigValue("Crafting", "benchMultiplier", 0.5f));

            c_craftingMultiplierBlacklist = ((IEnumerable)GetConfigValue("Blacklists", "craftingMultiplierBlacklist", new string[] { })).Cast<object>().Select(x => x.ToString()).ToArray();
            c_benchMultiplierBlacklist = ((IEnumerable)GetConfigValue("Blacklists", "benchMultiplierBlacklist", new string[] { })).Cast<object>().Select(x => x.ToString()).ToArray();
            c_bulkCraftBlacklist = ((IEnumerable)GetConfigValue("Blacklists", "bulkCraftBlacklist", new string[] { })).Cast<object>().Select(x => x.ToString()).ToArray();

            c_craftingMultiplierAuthLevel = Convert.ToInt32(GetConfigValue("Authorizations", "craftingMultiplierAuthLevel", 0));
            c_benchMultiplierAuthLevel = Convert.ToInt32(GetConfigValue("Authorizations", "benchMultiplierAuthLevel", 0));
            
            if (configChanged)
            {
                Puts("Configuration file updated.");
                SaveConfig();
            }
        }

        
        object GetConfigValue(string category, string setting, object defaultValue)
        {
            var data = Config[category] as Dictionary<string, object>;
            object value;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[category] = data;
                configChanged = true;
            }

            if (data.TryGetValue(setting, out value)) return value;
            value = defaultValue;
            data[setting] = value;
            configChanged = true;
            return value;
        }


        void Rollback()
        {
            // Rollback crafting times
            foreach (var bp in blueprintDefinitions)
                bp.time = r_blueprintTimes[bp.targetItem.itemid];
        }

        [HookMethod("SendHelpText")]
        private void SendHelpText(BasePlayer player)
        {
            var sb = new StringBuilder();
            sb.AppendLine("<color=yellow>LimeBench 1.1.2</color> Â· Crafting speed controler");
            sb.AppendLine($"  Â· <color=lime>Global craft time multiplier</color> is <color=yellow>{c_craftingMultiplier}</color>");
            sb.AppendLine($"  Â· <color=lime>Gunpowder craft time</color> is <color=yellow>{c_gunpowderMultiplier}</color>");
            sb.AppendLine($"  Â· <color=lime>Any authorized cupboard in range</color> gives extra craft <color=yellow>{c_benchMultiplier}</color>");
            player.ChatMessage(sb.ToString());
        }


        //*********************************************
        // Events/Hooks
        //*********************************************
        [ChatCommand("limebench")]
        void cmdLimebench(BasePlayer player, string cmd, string[] args)
        {
            var sb = new StringBuilder();
            sb.AppendLine("<color=lime>[LIME] Bench</color> 1.1.2 by Deicide666ra (aka The Big Bad Wolf)");
            sb.AppendLine($"  Â· <color=lime>Global craft time multiplier</color> is <color=yellow>{c_craftingMultiplier}</color>");
            sb.AppendLine($"  Â· <color=lime>Gunpowder craft time</color> is <color=yellow>{c_gunpowderMultiplier}</color>");
            sb.AppendLine($"  Â· <color=lime>Any authorized cupboard in range</color> further affects crafting time by <color=yellow>{c_benchMultiplier}</color>");
            SendReply(player, sb.ToString());
        }

        void OnServerInitialized()
        {
            buildingPrivlidges = typeof(BasePlayer).GetField("buildingPrivlidges", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
            blueprintDefinitions.Clear();
            var gameObjectArray = FileSystem.LoadAll<GameObject>("Assets/Items/");

            blueprintDefinitions = ItemManager.bpList.ToList<ItemBlueprint>();
            foreach (var bp in blueprintDefinitions)
                r_blueprintTimes.Add(bp.targetItem.itemid, bp.time);

            // Create the bulk permission
            var exists= permission.PermissionExists(g_bulkCraftPermissionName);
            if (!exists)
            {
                permission.RegisterPermission(g_bulkCraftPermissionName, this);
                Puts($"Registered permission [{g_bulkCraftPermissionName}].");
            }

            // Create the bulk permission for no cupboard
            exists = permission.PermissionExists(g_bulkCraftNoCupboardPermissionName);
            if (!exists)
            {
                permission.RegisterPermission(g_bulkCraftNoCupboardPermissionName, this);
                Puts($"Registered permission [{g_bulkCraftNoCupboardPermissionName}].");
            }            
        }

        void BroadcastToChat(string msg)
        {
            ConsoleSystem.Broadcast("chat.add \"SERVER\" " + msg + " 1.0", new object[0]);
        }
        
        bool UserIsAuthorizedOnAnyCupboard(BasePlayer player)
        {
            List<BuildingPrivlidge> playerpriv = buildingPrivlidges.GetValue(player) as List<BuildingPrivlidge>;
            if (playerpriv.Count == 0) return false;
            foreach (BuildingPrivlidge priv in playerpriv.ToArray())
            {
                List<ProtoBuf.PlayerNameID> authorized = priv.authorizedPlayers;
                foreach (ProtoBuf.PlayerNameID pni in authorized.ToArray())
                    if (pni.userid == player.userID) return true;
            }
            return false;
        }


        void OnItemCraft(ItemCraftTask task)
        {
            AdjustCraftingTime(task.owner, task.blueprint, task);
        }

        int GetStackSize(string shortname)
        {
            var item= ItemManager.itemList.FirstOrDefault(i => i.shortname == shortname);
            if (item == null) throw new Exception("failed to get stack size for " + shortname);
            return item.stackable;
        }

        void GiveItemsToPlayer(BasePlayer player, string shortname, int skinID, int amount)
        {
			var initialAmount= amount;
            var stackSize = 1;
            try { stackSize = GetStackSize(shortname); } catch { }

			int loops= 0;
            while (amount > 0)
            {
                var giving = amount > stackSize ? stackSize : amount;
                var item = ItemManager.CreateByName(shortname, giving);
                item.skin = skinID;
                player.GiveItem(item);
                amount -= giving;
				loops++;
				
				if (loops > 40)
				{
					Puts($"Infinite loop detected for {shortname} X {initialAmount} (giving {giving} and {amount} left)");
					break;
				}
            }
        }

        bool CanBulk(BasePlayer player)
        {
            // Check if player has the bulkcraft permission
            if (!permission.UserHasPermission(player.UserIDString,
                g_bulkCraftPermissionName))
                return false;

            // If the player has no cupboard access, make sure he has the nocup permission
            if (!UserIsAuthorizedOnAnyCupboard(player) &&
                !permission.UserHasPermission(player.UserIDString,
                g_bulkCraftNoCupboardPermissionName))
                return false;

            return true;
        }

        void AdjustCraftingTime(BasePlayer player, ItemBlueprint bp, ItemCraftTask task)
        {
            var multipler = 1.0f;

            if (!c_craftingMultiplierBlacklist.Contains(bp.targetItem.shortname) &&
                player.net.connection.authLevel >= c_craftingMultiplierAuthLevel)
                multipler = bp.targetItem.shortname == "gunpowder" ? c_gunpowderMultiplier : c_craftingMultiplier;

            if (UserIsAuthorizedOnAnyCupboard(player) && 
                !c_benchMultiplierBlacklist.Contains(bp.targetItem.shortname) &&
                player.net.connection.authLevel >= c_benchMultiplierAuthLevel)
                multipler *= c_benchMultiplier;

            var crafter = player.inventory.crafting;

            if (CanBulk(player) && !c_bulkCraftBlacklist.Contains(bp.targetItem.shortname))
            {
                int amount = task.blueprint.amountToCreate * task.amount;
                int stackable = 1;
                try { stackable= GetStackSize(task.blueprint.targetItem.shortname); } catch { }
                    
                if (amount / stackable > 30)
                {
                    player.ChatMessage($"Could not bulkcraft {task.blueprint.targetItem.displayName.translated} X{amount}, try a smaller amount.");
                    return;
                }

                var tick = DateTime.Now;
                GiveItemsToPlayer(player, task.blueprint.targetItem.shortname, task.skinID, amount);
                var elapsed = (DateTime.Now - tick).TotalMilliseconds;
                if (elapsed > 10) Puts($"Warning: Bulkcraft took {elapsed} ms");

                crafter.CancelTask(task.taskUID, false);
                task.cancelled = true;
                
                return;
            }

            float stockTime = 0;
            var ret= r_blueprintTimes.TryGetValue(bp.targetItem.itemid, out stockTime);
            if (ret) bp.time = stockTime * multipler;
            else
            {
                Puts($"Dictionary access error trying to get stock crafting time for <{bp.targetItem.shortname}>");
            }
        }

        void OnItemCraftFinished(ItemCraftTask task, Item item)
        {
            BasePlayer player = task.owner;
            var crafter = player.inventory.crafting;
            if (crafter.queue.Count == 0) return;
            AdjustCraftingTime(player, crafter.queue.First().blueprint, task);
        }
    }
}

// --- End of file: LimeBench.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/CustomCraftTimes.cs ---
// --- Original Local Path: CustomCraftTimes.cs ---

using System;
using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Custom Craft Times", "Camoec", "1.1.1")]
    [Description("Allows you to change the crafting times")]

    public class CustomCraftTimes : RustPlugin
    {
        private const string UsePerm = "CustomCraftTimes.use";

        Dictionary<int, BPItem> _restore = new Dictionary<int, BPItem>();
        private PluginConfig _config;

        private class BPItem
        {
            public string shortname;
            public float time;
        }        
        private class PluginConfig
        {
            public Dictionary<int,BPItem> itemdefinitions = new Dictionary<int, BPItem>();
        }

        private void Init()
        {
            permission.RegisterPermission(UsePerm, this);
        }

        protected override void SaveConfig() => Config.WriteObject(_config, true);
        private void _LoadDefaultConfig()
        {
            Puts("Creating new config file");
            _config = new PluginConfig();
            foreach(var bp in ItemManager.bpList)
            {
                _config.itemdefinitions.Add(bp.targetItem.itemid,new BPItem()
                {
                    shortname = bp.targetItem.shortname,
                    time = bp.time
                });
            }
            SaveConfig();
        }
        private void _LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<PluginConfig>();

                if (_config == null)
                    throw new Exception();

                SaveConfig(); // override posible obsolet / outdated config
            }
            catch (Exception)
            {
                PrintError("Loaded default config");

                _LoadDefaultConfig();
            }
            
        }

        [ConsoleCommand("cct")]
        void GlobalSetup(ConsoleSystem.Arg arg)
        {
            if (arg == null && !arg.IsRcon && (arg.Player() != null && !permission.UserHasPermission(arg.Player().UserIDString, UsePerm)))
                return;
            if (arg.Args == null || arg.Args.Length < 2)
            {
                arg.ReplyWith("Use cct [category] [multiplier]");
                return;
            }

            ItemCategory category = 0;
            float mult = 0;

            if(!float.TryParse(arg.Args[1], out mult))
            {
                arg.ReplyWith("Invalid multiplier!");
            }

            if ((arg.Args[0].ToLower() != "all" && !Enum.TryParse<ItemCategory>(arg.Args[0], out category)))
            {
                string availables = "";
                foreach(var e in Enum.GetValues(typeof(ItemCategory)))
                {
                    availables += $"{e} ";
                }
                arg.ReplyWith($"Invalid Category, try with: {availables}");
                return;
            }

            int affected = 0;
            foreach(var bp in _restore)
            {
                var itemDef = ItemManager.FindItemDefinition(bp.Key);
                if(itemDef.category == category || arg.Args[0].ToLower() == "all")
                {
                    _config.itemdefinitions[bp.Key].time = bp.Value.time * mult;
                    affected++;
                }
            }
            SaveConfig();


            arg.ReplyWith($"{affected} affected items, use 'oxide.reload CustomCraftTimes' to reload times");
        }

        void OnServerInitialized(bool initial)
        {
            _LoadConfig();
            Puts("Loading new times");
            
            foreach (var bp in ItemManager.bpList)
            {
                _restore.Add(bp.targetItem.itemid, new BPItem() { time = bp.time, shortname = bp.name });
                if (_config.itemdefinitions.ContainsKey(bp.targetItem.itemid))
                {
                    bp.time = _config.itemdefinitions[bp.targetItem.itemid].time;
                }
            }
        }

        void Unload()
        {
            if (ItemManager.bpList == null)
                return;
            foreach (var bp in ItemManager.bpList)
            {
                bp.time = _restore[bp.targetItem.itemid].time;
            }
        }
    }
}

// --- End of file: CustomCraftTimes.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/SpawnControl.cs ---
// --- Original Local Path: SpawnControl.cs ---

using System;
using System.Text;
using System.Collections.Generic;
using System.Collections;
using System.Linq;
using System.Reflection;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Configuration;
using Rust;

namespace Oxide.Plugins
{
    [Info("SpawnControl", "FuJiCuRa", "1.6.5", ResourceId = 18)]
    [Description("Provides complete control over the population of animals, ore's, tree's, junkpiles and all others")]
    internal class SpawnControl : RustPlugin
    {
        private bool Changed = false;
        private bool _loaded = false;
        private bool isAtStartup = true;
        private bool onTerrainCalled;
        private bool heartbeatOn = false;
        private double lastMinute;
        private bool newSave;
        private int versionMajor;
        private int versionMinor;
        private bool _newConfig = false;
        private Dictionary<string, object> spawnPopulations = new Dictionary<string, object>();
        private Dictionary<string, object> spawnGroups = new Dictionary<string, object>();
        private Dictionary<string, object> spawnDefaults = new Dictionary<string, object>();
        private Dictionary<string, object> spawnPrefabDefaults = new Dictionary<string, object>();
        private List<string> PopulationNames = new List<string>();

        private Dictionary<string, ConvarControlledSpawnPopulation> convarCommands =
            new Dictionary<string, ConvarControlledSpawnPopulation>();

        private Dictionary<string, string> populationConvars = new Dictionary<string, string>();
        private Dictionary<string, int> fillPopulations = new Dictionary<string, int>();
        private Dictionary<string, int> fillJobs = new Dictionary<string, int>();
        private DynamicConfigFile defaultSpawnPops;

        private DynamicConfigFile getFile(string file)
        {
            return Interface.Oxide.DataFileSystem.GetDatafile($"{file}");
        }

        private bool chkFile(string file)
        {
            return Interface.Oxide.DataFileSystem.ExistsDatafile($"{file}");
        }

        private FieldInfo _numToSpawn = typeof(SpawnPopulation).GetField("numToSpawn", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);

        private Coroutine _groupKill;
        private Coroutine _groupFill;
        private Coroutine _spawnKill;
        private Coroutine _spawnFill;
        private Coroutine _enforceLimits;
        private Coroutine _spawnLowerDensity;
        private Coroutine _spawnRaiseDensity;
        private bool normalizeDefaultVariables;
        private bool reloadWithIncludedFill;
        private bool logJobsToConsole;
        private bool fixBarricadeStacking;
        private bool fillAtEveryStartup;
        private float tickInterval;
        private int minSpawnsPerTick;
        private int maxSpawnsPerTick;
        private SpawnPopulation[] AllSpawnPopulations = null;
        private SpawnDistribution[] SpawnDistributions = null;
        private List<string> killAllProtected;
        private bool currentTickStatus;

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            Dictionary<string, object> data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }

            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }

            return value;
        }

        private void LoadVariables()
        {
            spawnPopulations =
                (Dictionary<string, object>)GetConfig("Spawn", "Population", new Dictionary<string, object>());
            spawnGroups = (Dictionary<string, object>)GetConfig("Spawn", "Groups", new Dictionary<string, object>());
            normalizeDefaultVariables = Convert.ToBoolean(GetConfig("Generic", "normalizeDefaultVariables", true));
            reloadWithIncludedFill = Convert.ToBoolean(GetConfig("Generic", "reloadWithIncludedFill", false));
            fillAtEveryStartup = Convert.ToBoolean(GetConfig("Generic", "fillAtEveryStartup", true));
            logJobsToConsole = Convert.ToBoolean(GetConfig("Generic", "logJobsToConsole", true));
            fixBarricadeStacking = Convert.ToBoolean(GetConfig("Generic", "fixBarricadeStacking", true));
            tickInterval = Convert.ToSingle(GetConfig("Handler", "tickInterval", 60f));
            minSpawnsPerTick = Convert.ToInt32(GetConfig("Handler", "minSpawnsPerTick", 100));
            maxSpawnsPerTick = Convert.ToInt32(GetConfig("Handler", "maxSpawnsPerTick", 200));
            bool configremoval = false;
            if (Config.Get("Animals") as Dictionary<string, object> != null)
            {
                Config.Remove("Animals");
                configremoval = true;
            }

            if ((Config.Get("Generic") as Dictionary<string, object>).ContainsKey("enablePopulationPrefabs"))
            {
                (Config.Get("Generic") as Dictionary<string, object>).Remove("enablePopulationPrefabs");
                configremoval = true;
            }

            if ((Config.Get("Generic") as Dictionary<string, object>).ContainsKey("enableGroupPrefabs"))
            {
                (Config.Get("Generic") as Dictionary<string, object>).Remove("enableGroupPrefabs");
                configremoval = true;
            }

            if ((Config.Get("Generic") as Dictionary<string, object>).ContainsKey("enableSpawnGroups"))
            {
                (Config.Get("Generic") as Dictionary<string, object>).Remove("enableSpawnGroups");
                configremoval = true;
            }

            if ((Config.Get("Generic") as Dictionary<string, object>).ContainsKey("enableGroupTickData"))
            {
                (Config.Get("Generic") as Dictionary<string, object>).Remove("enableGroupTickData");
                configremoval = true;
            }

            if (!Changed && !configremoval) return;
            SaveConfig();
            Changed = false;
            configremoval = false;
        }

        protected override void LoadDefaultConfig()
        {
            _newConfig = true;
            Config.Clear();
            LoadVariables();
        }

        private void Init()
        {
            LoadVariables();
            onTerrainCalled = false;
            if (normalizeDefaultVariables)
            {
                ConVar.Spawn.max_density = 1f;
                ConVar.Spawn.max_rate = 1f;
                ConVar.Spawn.min_density = 0.5f;
                ConVar.Spawn.min_rate = 0.5f;
                SetTickConvars(true);
            }

            newSave = false;
            lastMinute = DateTime.UtcNow.Minute;
        }

        private void OnNewSave(string strFilename)
        {
            newSave = true;
            if (!fillAtEveryStartup)
            {
                ConVar.Spawn.respawn_populations = false;
                ConVar.Spawn.respawn_groups = false;
            }
        }

        private void Unload()
        {
            if (Interface.Oxide.IsShuttingDown) return;
            UnloadCoRoutines();
        }

        private void UnloadCoRoutines()
        {
            if (_groupKill != null) Global.Runner.StopCoroutine(_groupKill);
            if (_groupFill != null) Global.Runner.StopCoroutine(_groupFill);
            if (_spawnKill != null) Global.Runner.StopCoroutine(_spawnKill);
            if (_spawnFill != null) Global.Runner.StopCoroutine(_spawnFill);
            if (_enforceLimits != null) Global.Runner.StopCoroutine(_enforceLimits);
            if (_spawnLowerDensity != null) Global.Runner.StopCoroutine(_spawnLowerDensity);
            if (_spawnRaiseDensity != null) Global.Runner.StopCoroutine(_spawnRaiseDensity);
        }

        private void OnTerrainInitialized()
        {
            _loaded = true;
            AllSpawnPopulations = SpawnHandler.Instance.AllSpawnPopulations;
            SpawnDistributions = SpawnHandler.Instance.SpawnDistributions;
            if (isAtStartup && !newSave)
            {
                onTerrainCalled = true;
                SaveDefaultsToFile();
            }

            SpawnHandler.Instance.MaxSpawnsPerTick = maxSpawnsPerTick;
            SpawnHandler.Instance.MinSpawnsPerTick = minSpawnsPerTick;
            if (spawnPopulations != null && spawnPopulations.Count > 0) LoadSpawnPopulations();
            else GetSpawnPopulationDefaults();
            if (spawnGroups != null && spawnGroups.Count > 0) LoadSpawnGroups();
            else GetSpawnGroupDefaults();
        }

        private void OnServerInitialized()
        {
            isAtStartup = false;
            AllSpawnPopulations = SpawnHandler.Instance.AllSpawnPopulations;
            SpawnDistributions = SpawnHandler.Instance.SpawnDistributions;
            GetPopulationNames();
            if (!_loaded) OnTerrainInitialized();
            if (fillJobs.Count > 0) Puts($"Planned {fillJobs.Count} job(s) for spawn population");
            LoadDefaultsFromFile();
            if (onTerrainCalled) ReloadAnimals();
            if (onTerrainCalled)
            {
                if (fillAtEveryStartup)
                    SpawnHandler.Instance.InitialSpawn();
                else if (!fillAtEveryStartup && newSave) SetTickConvars(true);
            }

            SpawnHandler.Instance.StartSpawnTick();
            currentTickStatus = true;
        }

        private void OnEntitySpawned(BaseNetworkable entity)
        {
            if (!_loaded || !fixBarricadeStacking || entity == null ||
                !(entity as BaseEntity).ShortPrefabName.StartsWith("door_barricade")) return;
            NextTick(() =>
            {
                if (entity == null) return;
                BaseEntity[] stacked = null;
                try
                {
                    stacked = Physics.OverlapSphere(entity.transform.position, 1.0f)
                        .Where(entry =>
                            entry != null && entry.GetComponentInParent<BaseEntity>() != null && entry
                                .GetComponentInParent<BaseEntity>().ShortPrefabName.StartsWith("door_barricade"))
                        .Select(entry => entry.GetComponentInParent<BaseEntity>()).Distinct()
                        .OrderByDescending(c => c.net.ID).ToArray();
                }
                catch
                {
                }

                if (stacked != null && stacked.Length > 1)
                    for (int i = 0; i < stacked.Length - 1; i++)
                        stacked[i].Kill();
            });
        }

        private void OnServerCommand(ConsoleSystem.Arg arg)
        {
            if (arg == null || arg.cmd == null || arg.FullString == string.Empty ||
                arg.cmd.FullName == string.Empty) return;
            if (populationConvars.ContainsKey(arg.cmd.FullName))
            {
                float targetDensity = -2;
                float.TryParse(arg.Args[0], out targetDensity);
                (spawnPopulations[populationConvars[arg.cmd.FullName]] as Dictionary<string, object>)["targetDensity"] =
                    targetDensity;
                Config["Spawn", "Population"] = spawnPopulations;
                Config.Save();
            }
        }

        private void OnTick()
        {
            if (!_loaded || !heartbeatOn || lastMinute == DateTime.UtcNow.Minute ||
                !(_spawnKill == null && _spawnFill == null && _enforceLimits == null && _spawnLowerDensity == null &&
                  _spawnRaiseDensity == null)) return;
            lastMinute = DateTime.UtcNow.Minute;
            foreach (KeyValuePair<string, int> job in fillJobs.ToList())
                if ((int)fillJobs[job.Key] < 1)
                {
                    timer.Once(2f,
                        () => ConsoleSystem.Run(ConsoleSystem.Option.Server.Quiet(), "sc.fillpopulation",
                            new object[] { job.Key.ToString(), "auto" }));
                    fillJobs[job.Key] = fillPopulations[job.Key];
                }
                else
                {
                    fillJobs[job.Key] = (int)job.Value - 1;
                }
        }

        private void PauseTick()
        {
            if (currentTickStatus) SetTickConvars(false);
        }

        private void ResumeTick()
        {
            if (currentTickStatus) SetTickConvars(true);
        }

        private void ReloadAnimals()
        {
            Dictionary<string, object> data = new Dictionary<string, object>(spawnPopulations);
            if (data == null || data.Count() == 0)
            {
                GetSpawnPopulationDefaults();
                return;
            }

            for (int j = 0; j < AllSpawnPopulations.Length; j++)
                if (!(AllSpawnPopulations[j] == null))
                {
                    SpawnPopulation population = AllSpawnPopulations[j];
                    object spawndata;
                    if (!data.TryGetValue(population.name, out spawndata)) continue;
                    if (!convarCommands.ContainsKey(population.name)) continue;
                    Dictionary<string, object> spawnData = spawndata as Dictionary<string, object>;
                    population.EnforcePopulationLimits = Convert.ToBoolean(spawnData["enforceLimits"]);
                    population.SpawnRate = Convert.ToSingle(spawnData["spawnRate"]);
                    population._targetDensity = Convert.ToSingle(spawnData["targetDensity"]);
                    SetAnimal(population.name, Convert.ToSingle(spawnData["targetDensity"]));
                }
        }

        private void SetAnimal(string name, float value)
        {
            if (convarCommands.ContainsKey(name))
                ConsoleSystem.Run(ConsoleSystem.Option.Server.Quiet(),
                    $"{convarCommands[name].PopulationConvar} {value.ToString()}");
        }

        private void SaveDefaultsToFile()
        {
            spawnDefaults = new Dictionary<string, object>();
            spawnPrefabDefaults = new Dictionary<string, object>();
            for (int i = 0; i < AllSpawnPopulations.Length; i++)
                if (!(AllSpawnPopulations[i] == null))
                {
                    SpawnPopulation population = AllSpawnPopulations[i];
                    if (!population.Initialize()) continue;
                    Dictionary<string, object> prefabdata = new Dictionary<string, object>();
                    Prefab<Spawnable>[] prefabs = population.Prefabs;
                    Dictionary<string, int> counts =
                        prefabs.GroupBy(x => x.Name).ToDictionary(g => g.Key.ToLower(), g => g.Count());
                    foreach (KeyValuePair<string, int> prefab in counts)
                        prefabdata.Add(prefab.Key.ToLower(), prefab.Value);
                    spawnPrefabDefaults.Add(population.name, prefabdata);
                    spawnDefaults.Add(population.name, population.TargetDensity);
                }

            defaultSpawnPops = getFile($"{Title}_defaults");
            defaultSpawnPops.Clear();
            defaultSpawnPops.Set("Backup", spawnDefaults);
            defaultSpawnPops.Set("PrefabBackup", spawnPrefabDefaults);
            defaultSpawnPops.Save();
        }

        private void LoadDefaultsFromFile()
        {
            if (spawnDefaults == null || spawnDefaults.Count == 0)
            {
                spawnDefaults = new Dictionary<string, object>();
                defaultSpawnPops = getFile($"{Title}_defaults");
                spawnDefaults = defaultSpawnPops["Backup"] as Dictionary<string, object>;
                spawnPrefabDefaults = defaultSpawnPops["PrefabBackup"] as Dictionary<string, object>;
            }
        }

        private void GetPopulationNames()
        {
            PopulationNames = new List<string>();
            foreach (SpawnPopulation pop in SpawnHandler.Instance.AllSpawnPopulations.Where(x => x != null).Distinct()
                .ToList()) PopulationNames.Add(pop.name);
            convarCommands = new Dictionary<string, ConvarControlledSpawnPopulation>();
            populationConvars = new Dictionary<string, string>();
            foreach (SpawnPopulation pop in SpawnHandler.Instance.ConvarSpawnPopulations.ToList().Where(x => x != null))
            {
                populationConvars.Add((pop as ConvarControlledSpawnPopulation).PopulationConvar, pop.name);
                convarCommands.Add(pop.name, pop as ConvarControlledSpawnPopulation);
            }
        }

        private void GetSpawnPopulationDefaults()
        {
            Dictionary<string, object> data = new Dictionary<string, object>();
            spawnPopulations.Clear();
            for (int i = 0; i < AllSpawnPopulations.Length; i++)
                if (!(AllSpawnPopulations[i] == null))
                {
                    SpawnPopulation population = AllSpawnPopulations[i];
                    if (!population.Initialize()) continue;
                    Dictionary<string, object> populationdata = new Dictionary<string, object>();
                    populationdata.Add("targetDensity", population.TargetDensity);
                    populationdata.Add("spawnRate", population.SpawnRate);
                    populationdata.Add("enforceLimits", population.EnforcePopulationLimits);
                    populationdata.Add("spawnFillHeartbeat", 0);
                    populationdata.Add("protectFromKillAll", false);
                    populationdata.Add("scaleWithServerPopulation", population.ScaleWithServerPopulation);
                    populationdata.Add("spawnFilter", GetSpawnFilter(population.Filter, population));
                    Dictionary<string, object> prefabdata = new Dictionary<string, object>();
                    Prefab<Spawnable>[] prefabs = population.Prefabs;
                    Dictionary<string, int> counts =
                        prefabs.GroupBy(x => x.Name).ToDictionary(g => g.Key.ToLower(), g => g.Count());
                    foreach (KeyValuePair<string, int> prefab in counts)
                        prefabdata.Add(prefab.Key.ToLower(), prefab.Value);
                    populationdata.Add("spawnWeights", prefabdata);
                    data.Add(population.name, populationdata);
                }

            spawnPopulations = new Dictionary<string, object>(data);
            Config["Spawn", "Population"] = spawnPopulations;
            Config.Save();
            Puts($"Created SpawnPopulation with '{data.Count}' populations.");
        }

        private object GetSpawnFilter(SpawnFilter filter, SpawnPopulation population)
        {
            Dictionary<string, object> dict = new Dictionary<string, object>();
            dict.Add(nameof(filter.TopologyAny).ToString(), (int)filter.TopologyAny);
            dict.Add(nameof(filter.TopologyNot).ToString(), (int)filter.TopologyNot);
            dict.Add(nameof(filter.TopologyAll).ToString(), (int)filter.TopologyAll);
            return dict;
        }

        private SpawnFilter SetSpawnFilter(Dictionary<string, object> values, SpawnPopulation population)
        {
            SpawnFilter filter = new SpawnFilter();
            filter.BiomeType = population.Filter.BiomeType;
            filter.SplatType = population.Filter.SplatType;
            filter.TopologyAny = (TerrainTopology.Enum)(int)values[nameof(filter.TopologyAny).ToString()];
            filter.TopologyAll = (TerrainTopology.Enum)(int)values[nameof(filter.TopologyAll).ToString()];
            filter.TopologyNot = (TerrainTopology.Enum)(int)values[nameof(filter.TopologyNot).ToString()];
            return filter;
        }

        private List<string> GetTerrainTopologies(int value)
        {
            List<string> result = new List<string>();
            string[] names = Enum.GetNames(typeof(TerrainTopology.Enum));
            for (int i = 0; i < names.Length; i++)
                if ((value & (1 << i)) != 0)
                    result.Add(names[i]);
            return result;
        }

        [ConsoleCommand("sc.topologyget")]
        private void GetTopology(ConsoleSystem.Arg arg)
        {
            if (arg != null && !arg.IsAdmin) return;
            if (arg.Args == null || arg.Args.Length < 1)
            {
                SendReply(arg, "You need to provide a spawnFilter Topology value");
                return;
            }

            List<string> allNames = Enum.GetNames(typeof(TerrainTopology.Enum)).ToList();
            List<string> names = null;
            if (arg.Args != null)
            {
                int id = -1;
                int.TryParse(arg.Args[0], out id);
                if (id != -0) names = GetTerrainTopologies(id);
                else return;
            }
            else
            {
                return;
            }

            StringBuilder sb = new StringBuilder();
            foreach (string name in names) sb.AppendLine($"{name} | {allNames.IndexOf(name)}");
            SendReply(arg, "\n\n" + sb.ToString());
        }

        [ConsoleCommand("sc.topologylist")]
        private void ListTopology(ConsoleSystem.Arg arg)
        {
            if (!arg.IsAdmin) return;
            List<string> names = Enum.GetNames(typeof(TerrainTopology.Enum)).ToList();
            StringBuilder sb = new StringBuilder();
            foreach (string name in names)
                sb.AppendLine(
                    $"{name} | {names.IndexOf(name)} | Single: {(int)Enum.Parse(typeof(TerrainTopology.Enum), name)}");
            SendReply(arg, "\n\n" + sb.ToString());
        }

        [ConsoleCommand("sc.topologycreate")]
        private void SetTopology(ConsoleSystem.Arg arg)
        {
            if (arg != null && !arg.IsAdmin) return;
            if (arg.Args == null || arg.Args.Length < 1)
            {
                SendReply(arg, "You need to provide a list of spacer separated numbers (f.e. by: sc.topologylist)");
                return;
            }

            List<string> allNames = Enum.GetNames(typeof(TerrainTopology.Enum)).ToList();
            int maskOut = 0;
            for (int i = 0; i < arg.Args.Length; i++)
            {
                int id = -1;
                int.TryParse(arg.Args[i], out id);
                if (id != -1) maskOut += (int)Enum.Parse(typeof(TerrainTopology.Enum), allNames[id]);
            }

            SendReply(arg, "\n\nnew Topology mask is: " + maskOut);
        }

        private void LoadSpawnPopulations()
        {
            killAllProtected = new List<string>();
            Dictionary<string, object> data = new Dictionary<string, object>(spawnPopulations);
            if (data == null || data.Count() == 0)
            {
                GetSpawnPopulationDefaults();
                return;
            }

            bool changed = false;
            if (PopulationNames == null || PopulationNames.Count == 0)
                foreach (SpawnPopulation pop in SpawnHandler.Instance.AllSpawnPopulations.ToList().Where(x => x != null)
                    .Distinct().ToList())
                    PopulationNames.Add(pop.name);
            foreach (KeyValuePair<string, object> population in data.ToList())
                if (!PopulationNames.Contains(population.Key.ToString()))
                {
                    data.Remove(population.Key);
                    Puts($"Removed old SpawnPopulation: {population.Key}");
                    changed = true;
                    continue;
                }

            for (int i = 0; i < AllSpawnPopulations.Length; i++)
                if (!(AllSpawnPopulations[i] == null))
                {
                    SpawnPopulation population = AllSpawnPopulations[i];
                    if (!population.Initialize()) continue;
                    string name = population.name;
                    if (name == null) continue;
                    if (!data.ContainsKey(name))
                    {
                        Dictionary<string, object> populationdata = new Dictionary<string, object>();
                        populationdata.Add("targetDensity", population.TargetDensity);
                        populationdata.Add("spawnRate", population.SpawnRate);
                        populationdata.Add("enforceLimits", population.EnforcePopulationLimits);
                        populationdata.Add("spawnFillHeartbeat", 0);
                        populationdata.Add("protectFromKillAll", false);
                        populationdata.Add("scaleWithServerPopulation", population.ScaleWithServerPopulation);
                        populationdata.Add("spawnFilter", GetSpawnFilter(population.Filter, population));
                        Prefab<Spawnable>[] prefabs = population.Prefabs;
                        Dictionary<string, int> counts =
                            prefabs.GroupBy(x => x.Name).ToDictionary(g => g.Key, g => g.Count());
                        Dictionary<string, object> prefabdata = new Dictionary<string, object>();
                        foreach (KeyValuePair<string, int> prefab in counts) prefabdata.Add(prefab.Key, prefab.Value);
                        populationdata.Add("spawnWeights", prefabdata);
                        data.Add(name, populationdata);
                        Puts($"Added new SpawnPopulation: {name}");
                        changed = true;
                    }

                    if (!(data[name] as Dictionary<string, object>).ContainsKey("protectFromKillAll"))
                    {
                        (data[name] as Dictionary<string, object>).Add("protectFromKillAll", false);
                        changed = true;
                    }

                    if (!(data[name] as Dictionary<string, object>).ContainsKey("spawnFilter"))
                    {
                        (data[name] as Dictionary<string, object>).Add("spawnFilter",
                            GetSpawnFilter(population.Filter, population));
                        changed = true;
                    }

                    if ((data[name] as Dictionary<string, object>).ContainsKey("spawnlimits"))
                    {
                        (data[name] as Dictionary<string, object>).Remove("spawnlimits");
                        (data[name] as Dictionary<string, object>).Add("enforceLimits", true);
                        changed = true;
                    }

                    if (!(data[name] as Dictionary<string, object>).ContainsKey("scaleWithServerPopulation"))
                    {
                        (data[name] as Dictionary<string, object>).Add("scaleWithServerPopulation",
                            population.ScaleWithServerPopulation);
                        changed = true;
                    }
                }

            spawnPopulations = new Dictionary<string, object>(data);
            if (changed)
            {
                Config["Spawn", "Population"] = spawnPopulations;
                Config.Save();
            }

            bool addedPrefabs = false;
            for (int j = 0; j < AllSpawnPopulations.Length; j++)
                if (!(AllSpawnPopulations[j] == null))
                {
                    SpawnPopulation population = AllSpawnPopulations[j];
                    if (!population.Initialize()) continue;
                    object spawndata;
                    if (!data.TryGetValue(population.name, out spawndata)) continue;
                    Dictionary<string, object> spawnData = spawndata as Dictionary<string, object>;
                    if (!spawnData.ContainsKey("spawnWeights"))
                    {
                        Prefab<Spawnable>[] prefabs = population.Prefabs;
                        Dictionary<string, int> counts = prefabs.GroupBy(x => x.Name)
                            .ToDictionary(g => g.Key.ToLower(), g => g.Count());
                        Dictionary<string, object> prefabdata = new Dictionary<string, object>();
                        foreach (KeyValuePair<string, int> prefab in counts)
                            prefabdata.Add(prefab.Key.ToLower(), prefab.Value);
                        spawnData.Add("spawnWeights", prefabdata);
                        addedPrefabs = true;
                    }
                    else if (spawnData.ContainsKey("spawnWeights"))
                    {
                        Dictionary<string, object> prefabData = spawnData["spawnWeights"] as Dictionary<string, object>;
                        List<Prefab<Spawnable>> prefabs = new List<Prefab<Spawnable>>();
                        foreach (KeyValuePair<string, object> prefab in prefabData.ToList())
                        {
                            GameObject gameObject = GameManager.server.FindPrefab(prefab.Key);
                            if (gameObject == null)
                            {
                                Puts($"Removed invalid/removed prefab from '{population.name}': {prefab.Key}");
                                ((data[population.name] as Dictionary<string, object>)["spawnWeights"] as
                                    Dictionary<string, object>).Remove(prefab.Key);
                                addedPrefabs = true;
                                continue;
                            }

                            Spawnable component = gameObject.GetComponent<Spawnable>();
                            if (component)
                                for (int i = 0; i < Convert.ToInt32(prefab.Value); i++)
                                    prefabs.Add(new Prefab<Spawnable>(prefab.Key.ToLower(), gameObject, component,
                                        GameManager.server, PrefabAttribute.server));
                        }

                        population.Prefabs = prefabs.ToArray();
                        _numToSpawn.SetValue(population, new int[prefabs.ToArray().Length]);
                    }

                    population.EnforcePopulationLimits = Convert.ToBoolean(spawnData["enforceLimits"]);
                    population.SpawnRate = Convert.ToSingle(spawnData["spawnRate"]);
                    population._targetDensity = Convert.ToSingle(spawnData["targetDensity"]);
                    population.ScaleWithServerPopulation = Convert.ToBoolean(spawnData["scaleWithServerPopulation"]);
                    SetAnimal(population.name, Convert.ToSingle(spawnData["targetDensity"]));
                    if ((int)spawnData["spawnFillHeartbeat"] > 0)
                    {
                        fillPopulations.Add(population.name, (int)spawnData["spawnFillHeartbeat"]);
                        heartbeatOn = true;
                    }

                    if (Convert.ToBoolean(spawnData["protectFromKillAll"])) killAllProtected.Add(population.name);
                    if (spawnData.ContainsKey("spawnFilter"))
                        population.Filter = SetSpawnFilter((Dictionary<string, object>)spawnData["spawnFilter"],
                            population);
                }

            if (addedPrefabs)
            {
                spawnPopulations = new Dictionary<string, object>(data);
                Config["Spawn", "Population"] = spawnPopulations;
                Config.Save();
            }

            if (heartbeatOn) fillJobs = new Dictionary<string, int>(fillPopulations);
            Puts($"Loaded '{data.Count}' SpawnPopulations");
        }

        private void GetSpawnGroupDefaults()
        {
            if (TerrainMeta.Path.Monuments.Count == 0)
                return;

            Dictionary<string, List<MonumentInfo>> monumentGroups = TerrainMeta.Path?.Monuments?.GroupBy(c => c.displayPhrase.english)?.ToDictionary(c => c.Key, c => c.ToList());

            if (monumentGroups == null)
                return;

            foreach (KeyValuePair<string, List<MonumentInfo>> current in monumentGroups)
            {
                MonumentInfo monument = current.Value.First();

                string displayPhrase = monument.displayPhrase.english;
                if (displayPhrase.Length == 0)
                    continue;

                SpawnGroup[] groups = monument.gameObject.GetComponentsInChildren<SpawnGroup>();
                if ((groups == null) | (groups.Length == 0))
                    continue;

                List<object> list = new List<object>();
                foreach (SpawnGroup group in groups.ToList())
                {
                    Dictionary<string, object> spawner = new Dictionary<string, object>();

                    spawner.Add("_refDisplayPhrase", group.name);
                    spawner.Add("_refMaxPopulation", group.maxPopulation);

                    Vector3 center = Vector3.zero;

                    foreach (BaseSpawnPoint spawnPoint in group.spawnPoints.ToList())
                        center += spawnPoint.transform.position;

                    center /= group.spawnPoints.Length;
                    spawner.Add("_refPositionCenter", center.ToString().Replace(" ", ""));

                    Dictionary<string, object> prefabdata = new Dictionary<string, object>();
                    foreach (SpawnGroup.SpawnEntry prefab in group.prefabs)
                    {
                        if (prefab.prefab.resourcePath.Contains("/npc/"))
                            continue;

                        prefabdata[prefab.prefab.resourcePath] = prefab.weight;
                    }

                    if (prefabdata.Count == 0)
                        continue;

                    spawner.Add("spawnWeights", prefabdata);
                    spawner.Add("respawnDelayMin", group.respawnDelayMin);
                    spawner.Add("respawnDelayMax", group.respawnDelayMax);
                    spawner.Add("numToSpawnPerTickMin", group.numToSpawnPerTickMin);
                    spawner.Add("numToSpawnPerTickMax", group.numToSpawnPerTickMax);
                    list.Add(spawner);
                }

                if (list.Count > 0) spawnGroups[displayPhrase] = list;
            }

            Config["Spawn", "Groups"] = spawnGroups;
            Config.Save();
            Puts($"Created '{spawnGroups.Count()}' spawnGroups");
        }

        private void LoadSpawnGroups()
        {
            if (TerrainMeta.Path.Monuments.Count == 0)
                return;

            if (spawnGroups == null || spawnGroups.Count() == 0)
            {
                GetSpawnGroupDefaults();
                return;
            }

            bool addedData = false;

            foreach (KeyValuePair<string, object> monument in spawnGroups)
            {
                foreach (object spawner in monument.Value as List<object>)
                {
                    Dictionary<string, object> group = spawner as Dictionary<string, object>;
                    if (group.ContainsKey("_refPositionCenter"))
                    {
                        group.Remove("_refPositionCenter");
                        addedData = true;
                    }
                }
            }

            Dictionary<string, List<MonumentInfo>> monumentGroups = TerrainMeta.Path?.Monuments?.GroupBy(c => c.displayPhrase.english)?.ToDictionary(c => c.Key, c => c.ToList());

            if (monumentGroups == null) return;
            foreach (KeyValuePair<string, List<MonumentInfo>> current in monumentGroups)
            {
                MonumentInfo monument = current.Value.First();
                string displayPhrase = monument.displayPhrase.english;
                if (displayPhrase.Length == 0)
                    continue;

                SpawnGroup[] groups = monument.gameObject.GetComponentsInChildren<SpawnGroup>();
                if ((groups == null) | (groups.Length == 0))
                    continue;

                List<object> loadedGroups = new List<object>();

                if (!spawnGroups.ContainsKey(displayPhrase))
                {
                    List<object> list = new List<object>();
                    foreach (SpawnGroup group in groups.ToList())
                    {
                        Dictionary<string, object> spawner = new Dictionary<string, object>();

                        spawner.Add("_refDisplayPhrase", group.name);
                        spawner.Add("_refMaxPopulation", group.maxPopulation);

                        Vector3 center = Vector3.zero;

                        foreach (BaseSpawnPoint spawnPoint in group.spawnPoints.ToList())
                            center += spawnPoint.transform.position;
                        center /= group.spawnPoints.Length;

                        spawner.Add("_refPositionCenter", center.ToString().Replace(" ", ""));

                        Dictionary<string, object> prefabdata = new Dictionary<string, object>();

                        foreach (SpawnGroup.SpawnEntry prefab in group.prefabs)
                        {
                            if (prefab.prefab.resourcePath.Contains("/npc/")) continue;
                            prefabdata[prefab.prefab.resourcePath] = prefab.weight;
                        }

                        if (prefabdata.Count == 0)
                            continue;

                        spawner.Add("spawnWeights", prefabdata);
                        spawner.Add("respawnDelayMin", group.respawnDelayMin);
                        spawner.Add("respawnDelayMax", group.respawnDelayMax);
                        spawner.Add("numToSpawnPerTickMin", group.numToSpawnPerTickMin);
                        spawner.Add("numToSpawnPerTickMax", group.numToSpawnPerTickMax);
                        list.Add(spawner);
                    }

                    if (list.Count > 0)
                    {
                        spawnGroups[displayPhrase] = list;
                        addedData = true;
                    }

                    continue;
                }

                loadedGroups = spawnGroups[displayPhrase] as List<object>;
                List<object> list2 = new List<object>();
                foreach (SpawnGroup group in groups.ToList())
                {
                    bool groupMatch = false;
                    foreach (object loadedGroup in loadedGroups)
                    {
                        Dictionary<string, object> checkGroup = loadedGroup as Dictionary<string, object>;

                        if (checkGroup.ContainsKey("_refDisplayPhrase") && checkGroup["_refDisplayPhrase"].Equals(group.name))
                        {
                            if (checkGroup.ContainsKey("_refMaxPopulation") && (int)checkGroup["_refMaxPopulation"] == @group.maxPopulation)
                            {
                                @group.respawnDelayMin = Convert.ToSingle(checkGroup["respawnDelayMin"]);
                                @group.respawnDelayMax = Convert.ToSingle(checkGroup["respawnDelayMax"]);
                                @group.numToSpawnPerTickMin = (int)checkGroup["numToSpawnPerTickMin"];
                                @group.numToSpawnPerTickMax = (int)checkGroup["numToSpawnPerTickMax"];
                                if (@group.WantsTimedSpawn())
                                {
                                    LocalClock spawnClock = new LocalClock();
                                    spawnClock.Add(@group.GetSpawnDelta(), @group.GetSpawnVariance(), new Action(@group.Spawn));
                                    spawnClock.Tick();
                                    @group.spawnClock = spawnClock;
                                }

                                Vector3 center = Vector3.zero;
                                foreach (BaseSpawnPoint spawnPoint in @group.spawnPoints.ToList())
                                    center += spawnPoint.transform.position;
                                center /= @group.spawnPoints.Length;
                                checkGroup["_refPositionCenter"] = center.ToString().Replace(" ", "");
                                addedData = true;
                                groupMatch = true;
                            }
                        }
                    }

                    if (!groupMatch)
                    {
                        foreach (SpawnGroup.SpawnEntry prefab in @group.prefabs)
                        {
                            if (!prefab.prefab.resourcePath.Contains("/npc/"))
                            {
                                Puts($"Adding '{@group.name}' to '{displayPhrase}'");
                                Dictionary<string, object> spawner = new Dictionary<string, object>();
                                spawner.Add("_refDisplayPhrase", @group.name);
                                spawner.Add("_refMaxPopulation", @group.maxPopulation);
                                Vector3 center = Vector3.zero;
                                foreach (BaseSpawnPoint spawnPoint in @group.spawnPoints.ToList())
                                    center += spawnPoint.transform.position;
                                center /= @group.spawnPoints.Length;
                                spawner.Add("_refPositionCenter", center.ToString().Replace(" ", ""));
                                Dictionary<string, object> prefabdata = new Dictionary<string, object>();
                                foreach (SpawnGroup.SpawnEntry prefab2 in @group.prefabs)
                                {
                                    if (prefab2.prefab.resourcePath.Contains("scientist")) continue;
                                    prefabdata[prefab2.prefab.resourcePath] = prefab2.weight;
                                }

                                if (prefabdata.Count == 0) continue;
                                spawner.Add("spawnWeights", prefabdata);
                                spawner.Add("respawnDelayMin", @group.respawnDelayMin);
                                spawner.Add("respawnDelayMax", @group.respawnDelayMax);
                                spawner.Add("numToSpawnPerTickMin", @group.numToSpawnPerTickMin);
                                spawner.Add("numToSpawnPerTickMax", @group.numToSpawnPerTickMax);
                                (spawnGroups[displayPhrase] as List<object>).Add(spawner);
                                addedData = true;
                            }
                        }
                    }
                }
            }

            if (addedData)
            {
                Config["Spawn", "Groups"] = spawnGroups;
                Config.Save();
            }

            Puts($"Loaded '{spawnGroups.Count()}' spawnGroups");
        }

        [ConsoleCommand("sc.cleardata")]
        private void ccmdClearData(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 2) return;
            string data = string.Empty;
            if (arg.Args == null || arg.Args.Length < 1)
            {
                SendReply(arg, "You need to provide 'weights', 'population', 'groups' or 'all'");
                return;
            }

            data = arg.Args[0];
            if (data == "weights")
            {
                foreach (KeyValuePair<string, object> pop in spawnPopulations)
                    if ((spawnPopulations[pop.Key] as Dictionary<string, object>).ContainsKey("spawnWeights"))
                        (spawnPopulations[pop.Key] as Dictionary<string, object>).Remove("spawnWeights");
                Config["Spawn", "Population"] = spawnPopulations;
                Config.Save();
                SendReply(arg, "Did reset weights data");
            }
            else if (data == "population")
            {
                spawnPopulations.Clear();
                Config["Spawn", "Population"] = spawnPopulations;
                Config.Save();
                SendReply(arg, "Did reset population data.");
            }
            else if (data == "groups")
            {
                spawnGroups.Clear();
                Config["Spawn", "Groups"] = spawnGroups;
                Config.Save();
                SendReply(arg, "Did reset groups data");
            }
            else if (data == "all")
            {
                spawnGroups.Clear();
                spawnPopulations.Clear();
                Config["Spawn", "Groups"] = spawnGroups;
                Config["Spawn", "Population"] = spawnPopulations;
                Config.Save();
                SendReply(arg, "Did reset all data. Next server boot loads the game defaults");
            }
            else
            {
                SendReply(arg, "You need to provide 'weights', 'population', 'groups' or 'all'");
                return;
            }

            SendReply(arg, "Next server boot writes the game defaults back into the config.");
        }

        [ConsoleCommand("sc.tickinterval")]
        private void ccmdTickInterval(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 2) return;
            float currTickInterval = SpawnHandler.Instance.TickInterval;
            if (arg.Args == null)
            {
                SendReply(arg, $"Current TickInterval is '{currTickInterval}' seconds, spawntick is {(currentTickStatus ? "active" : "inactive")}");
                return;
            }

            if (arg.Args != null && arg.Args.Length > 0)
            {
                float input = 0f;
                if (float.TryParse(arg.Args[0], out input))
                {
                    currTickInterval = input;
                    SendReply(arg, $"TickInterval set to '{currTickInterval}' seconds, spawntick is {(currentTickStatus ? "active" : "inactive")}");
                    SpawnHandler.Instance.TickInterval = currTickInterval;
                    if (currTickInterval != tickInterval)
                    {
                        tickInterval = currTickInterval;
                        Config["Handler", "tickInterval"] = tickInterval;
                        Config.Save();
                    }

                    return;
                }
                else
                {
                    SendReply(arg, "You need to provide a full number in seconds");
                    return;
                }
            }
        }

        private void SetTickCon