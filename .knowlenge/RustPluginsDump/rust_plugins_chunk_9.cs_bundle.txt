vars(bool status)
        {
            ConVar.Spawn.respawn_populations = status;
            ConVar.Spawn.respawn_groups = status;
            ConVar.Spawn.respawn_individuals = status;
        }

        [ConsoleCommand("sc.spawnticktoggle")]
        private void ccmdToggleSpawnTick(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 2) return;
            currentTickStatus = !currentTickStatus;
            SetTickConvars(currentTickStatus);
            SendReply(arg, $"Spawntick is now: {(currentTickStatus ? "active" : "inactive")}");
        }

        [ConsoleCommand("sc.fillpopulation")]
        private void ccmdSpawnFill(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 2) return;
            string populationname = string.Empty;
            bool single = false;
            if (arg.Args != null && arg.Args.Length > 0)
            {
                populationname = arg.Args[0];
                single = true;
            }

            if (_spawnFill != null)
            {
                SendReply(arg, "Action aborted: another task is still running!");
                return;
            }

            PauseTick();
            _spawnFill = Global.Runner.StartCoroutine(SpawnFill(populationname, single, arg));
        }

        private IEnumerator SpawnFill(string populationname, bool single, ConsoleSystem.Arg arg)
        {
            yield return new WaitWhile(() =>
                _spawnKill != null || _enforceLimits != null || _spawnLowerDensity != null ||
                _spawnRaiseDensity != null);
            bool findany = false;
            if (single)
            {
                bool fullMatch = false;
                for (int i = 0; i < AllSpawnPopulations.Length; i++)
                    if (!(AllSpawnPopulations[i] == null))
                        if ((AllSpawnPopulations[i].name.Equals(populationname, StringComparison.OrdinalIgnoreCase) ||
                             AllSpawnPopulations[i].name
                                 .StartsWith(populationname, StringComparison.OrdinalIgnoreCase) ||
                             AllSpawnPopulations[i].name
                                 .EndsWith(populationname, StringComparison.OrdinalIgnoreCase)) && !fullMatch)
                        {
                            if (AllSpawnPopulations[i].name == populationname) fullMatch = true;
                            int oldCount =
                                SpawnHandler.Instance.GetCurrentCount(AllSpawnPopulations[i], SpawnDistributions[i]);
                            yield return CoroutineEx.waitForEndOfFrame;
                            SpawnHandler.Instance.SpawnInitial(AllSpawnPopulations[i], SpawnDistributions[i]);
                            yield return CoroutineEx.waitForEndOfFrame;
                            if (arg.Args.Length > 1 && arg.Args[1] == "auto")
                                if (logJobsToConsole)
                                    SendReply(arg,
                                        $"Timed population of '{AllSpawnPopulations[i].name}' | Old: {oldCount} | New: {SpawnHandler.Instance.GetCurrentCount(AllSpawnPopulations[i], SpawnDistributions[i])}");
                            if (arg.Args.Length == 1)
                                SendReply(arg,
                                    $"Forced population of '{AllSpawnPopulations[i].name}' | Old: {oldCount} | New: {SpawnHandler.Instance.GetCurrentCount(AllSpawnPopulations[i], SpawnDistributions[i])}");
                            findany = true;
                        }

                if (!findany) SendReply(arg, $"SpawnPopulation '{populationname}' not found");
            }
            else
            {
                int oldCount = 0;
                int newCount = 0;
                SendReply(arg, "Filling All SpawnPopulations");
                for (int i = 0; i < AllSpawnPopulations.Length; i++)
                    if (!(AllSpawnPopulations[i] == null))
                    {
                        oldCount += SpawnHandler.Instance.GetCurrentCount(AllSpawnPopulations[i],
                            SpawnDistributions[i]);
                        SpawnHandler.Instance.SpawnInitial(AllSpawnPopulations[i], SpawnDistributions[i]);
                        yield return CoroutineEx.waitForEndOfFrame;
                        newCount += SpawnHandler.Instance.GetCurrentCount(AllSpawnPopulations[i],
                            SpawnDistributions[i]);
                        yield return CoroutineEx.waitForEndOfFrame;
                    }

                SendReply(arg, $"Filled SpawnPopulations | Old: {oldCount} | New: {newCount}");
            }

            _spawnFill = null;
            ResumeTick();
            yield break;
        }

        [ConsoleCommand("sc.raisedensity")]
        private void ccmdSpawnRaiseDensity(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 2) return;
            float percentage = 0f;
            string populationname = string.Empty;
            if (arg.Args == null || arg.Args.Length < 2)
            {
                SendReply(arg, "You need to provide a number as percantage and a valid SpawnPopulation name");
                return;
            }

            float percent = -1;
            if (float.TryParse(arg.Args[0], out percent))
            {
                percentage = percent;
            }
            else
            {
                SendReply(arg, "You need to provide a number as percentage");
                return;
            }

            if (percentage > 100f)
            {
                percentage = 100f;
                SendReply(arg, "Percentage was limited to 100% to avoid server freezes");
            }

            if (_spawnRaiseDensity != null)
            {
                SendReply(arg, "Action aborted: another task is still running!");
                return;
            }

            populationname = arg.Args[1];
            bool raiseAll = false;
            if (populationname == "all") raiseAll = true;
            SendReply(arg, $"Calling raise of density with '{percentage}' percent for '{populationname}'");
            PauseTick();
            _spawnRaiseDensity =
                Global.Runner.StartCoroutine(SpawnRaiseDensity(percentage, populationname, raiseAll, arg));
        }

        private IEnumerator SpawnRaiseDensity(float percentage, string populationname, bool raiseAll,
            ConsoleSystem.Arg arg)
        {
            yield return new WaitWhile(() =>
                _spawnKill != null || _spawnFill != null || _enforceLimits != null || _spawnLowerDensity != null);
            bool findany = false;
            if (!raiseAll)
            {
                bool fullMatch = false;
                for (int i = 0; i < AllSpawnPopulations.Length; i++)
                    if (!(AllSpawnPopulations[i] == null))
                        if ((AllSpawnPopulations[i].name.Equals(populationname, StringComparison.OrdinalIgnoreCase) ||
                             AllSpawnPopulations[i].name
                                 .StartsWith(populationname, StringComparison.OrdinalIgnoreCase) ||
                             AllSpawnPopulations[i].name
                                 .EndsWith(populationname, StringComparison.OrdinalIgnoreCase)) && !fullMatch)
                        {
                            if (AllSpawnPopulations[i].name == populationname) fullMatch = true;
                            float oldDensity = AllSpawnPopulations[i].TargetDensity;
                            float increaseDensity = 0f;
                            if (oldDensity > 0f)
                            {
                                increaseDensity = AllSpawnPopulations[i].TargetDensity / 100 * percentage;
                            }
                            else
                            {
                                object backupDensity = null;
                                if (spawnDefaults.TryGetValue(AllSpawnPopulations[i].name, out backupDensity))
                                    increaseDensity = Convert.ToSingle(backupDensity) / 100 * percentage;
                                else increaseDensity = AllSpawnPopulations[i].TargetDensity / 100 * percentage;
                            }

                            float newDensity = (float)Math.Round((double)(oldDensity + increaseDensity));
                            AllSpawnPopulations[i]._targetDensity = newDensity;
                            SetAnimal(AllSpawnPopulations[i].name, newDensity);
                            yield return CoroutineEx.waitForEndOfFrame;
                            (spawnPopulations[AllSpawnPopulations[i].name] as Dictionary<string, object>)
                                ["targetDensity"] = AllSpawnPopulations[i].TargetDensity;
                            SendReply(arg,
                                $"Raised density of '{AllSpawnPopulations[i].name}' | Old: {oldDensity} | New: {newDensity}");
                            findany = true;
                        }

                if (!findany)
                {
                    SendReply(arg, $"SpawnPopulation '{populationname}' not found");
                }
                else
                {
                    SendReply(arg, "New raised density's set and saved.");
                    Config["Spawn", "Population"] = spawnPopulations;
                    Config.Save();
                    string type = arg.Args[1];
                    arg.Args = new string[] { type };
                    ccmdSpawnFill(arg);
                }
            }
            else
            {
                SendReply(arg, $"Raising all SpawnPopulation density's by '{percentage}' percent");
                for (int i = 0; i < AllSpawnPopulations.Length; i++)
                    if (!(AllSpawnPopulations[i] == null))
                    {
                        float oldDensity = AllSpawnPopulations[i].TargetDensity;
                        float increaseDensity = AllSpawnPopulations[i].TargetDensity / 100 * percentage;
                        float newDensity = (float)Math.Round((double)(oldDensity + increaseDensity));
                        AllSpawnPopulations[i]._targetDensity = newDensity;
                        SetAnimal(AllSpawnPopulations[i].name, newDensity);
                        yield return CoroutineEx.waitForEndOfFrame;
                        (spawnPopulations[AllSpawnPopulations[i].name] as Dictionary<string, object>)["targetDensity"] =
                            AllSpawnPopulations[i].TargetDensity;
                    }

                SendReply(arg, "New raised density's set and saved.");
                Config["Spawn", "Population"] = spawnPopulations;
                Config.Save();
                arg.Args = null;
                ccmdSpawnFill(arg);
            }

            _spawnRaiseDensity = null;
            ResumeTick();
            yield break;
        }

        [ConsoleCommand("sc.lowerdensity")]
        private void ccmdSpawnLowerDensity(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 2) return;
            float percentage = 0f;
            string populationname = string.Empty;
            if (arg.Args == null || arg.Args.Length < 2)
            {
                SendReply(arg, "You need to provide a percentage number and a valid SpawnPopulation name");
                return;
            }

            float percent = -1;
            if (float.TryParse(arg.Args[0], out percent))
            {
                percentage = percent;
            }
            else
            {
                SendReply(arg, "You need to provide a number as percentage");
                return;
            }

            populationname = arg.Args[1];
            bool lowerAll = false;
            if (populationname == "all") lowerAll = true;
            if (percentage > 100f)
            {
                percentage = 100f;
                SendReply(arg, "Percentage was limited to 100%");
            }

            bool force = false;
            if (arg.Args.Length >= 3 && arg.Args[2] == "force") force = true;
            if (lowerAll && percentage == 100f && !force)
            {
                SendReply(arg, "Canceled: Lowering all by 100% would set all to zero pop");
                SendReply(arg, "You need to add 'force' as additional argument!");
                return;
            }

            if (_spawnLowerDensity != null)
            {
                SendReply(arg, "Action aborted: another task is still running!");
                return;
            }

            SendReply(arg, $"Calling lower with '{percentage}' percent for '{populationname}'");
            PauseTick();
            _spawnLowerDensity =
                Global.Runner.StartCoroutine(SpawnLowerDensity(percentage, populationname, lowerAll, arg));
        }

        private IEnumerator SpawnLowerDensity(float percentage, string populationname, bool lowerAll,
            ConsoleSystem.Arg arg)
        {
            yield return new WaitWhile(() =>
                _spawnKill != null || _spawnFill != null || _enforceLimits != null || _spawnRaiseDensity != null);
            bool findany = false;
            if (!lowerAll)
            {
                bool fullMatch = false;
                for (int i = 0; i < AllSpawnPopulations.Length; i++)
                    if (!(AllSpawnPopulations[i] == null))
                        if ((AllSpawnPopulations[i].name.Equals(populationname, StringComparison.OrdinalIgnoreCase) ||
                             AllSpawnPopulations[i].name
                                 .StartsWith(populationname, StringComparison.OrdinalIgnoreCase) ||
                             AllSpawnPopulations[i].name
                                 .EndsWith(populationname, StringComparison.OrdinalIgnoreCase)) && !fullMatch)
                        {
                            if (AllSpawnPopulations[i].name == populationname) fullMatch = true;
                            float oldDensity = AllSpawnPopulations[i].TargetDensity;
                            float decreaseDensity = AllSpawnPopulations[i].TargetDensity / 100 * percentage;
                            float newDensity = -1f;
                            if (percentage == 100f) newDensity = 0f;
                            else newDensity = (float)Math.Round((double)(oldDensity - decreaseDensity));
                            AllSpawnPopulations[i]._targetDensity = newDensity;
                            SetAnimal(AllSpawnPopulations[i].name, newDensity);
                            yield return CoroutineEx.waitForEndOfFrame;
                            (spawnPopulations[AllSpawnPopulations[i].name] as Dictionary<string, object>)
                                ["targetDensity"] = AllSpawnPopulations[i].TargetDensity;
                            SendReply(arg,
                                $"Lowered density of '{AllSpawnPopulations[i].name}' | Old: {oldDensity} | New: {newDensity}");
                            findany = true;
                        }

                if (!findany)
                {
                    SendReply(arg, $"SpawnPopulation '{populationname}' not found");
                }
                else
                {
                    SendReply(arg, $"New lowered density's set and saved.");
                    Config["Spawn", "Population"] = spawnPopulations;
                    Config.Save();
                    ccmdEnforceLimits(arg);
                }
            }
            else
            {
                SendReply(arg, $"Lowering all SpawnPopulation density's by '{percentage}' percent");
                for (int i = 0; i < AllSpawnPopulations.Length; i++)
                    if (!(AllSpawnPopulations[i] == null))
                    {
                        float oldDensity = AllSpawnPopulations[i].TargetDensity;
                        float decreaseDensity = AllSpawnPopulations[i].TargetDensity / 100 * percentage;
                        float newDensity = -1f;
                        if (percentage == 100f) newDensity = 0f;
                        else newDensity = (float)Math.Round((double)(oldDensity - decreaseDensity));
                        AllSpawnPopulations[i]._targetDensity = newDensity;
                        SetAnimal(AllSpawnPopulations[i].name, newDensity);
                        yield return CoroutineEx.waitForEndOfFrame;
                        (spawnPopulations[AllSpawnPopulations[i].name] as Dictionary<string, object>)["targetDensity"] =
                            AllSpawnPopulations[i].TargetDensity;
                    }

                SendReply(arg, $"New lowered density's set and saved");
                Config["Spawn", "Population"] = spawnPopulations;
                Config.Save();
                ccmdEnforceLimits(arg);
            }

            _spawnLowerDensity = null;
            ResumeTick();
            yield break;
        }

        [ConsoleCommand("sc.killpopulation")]
        private void ccmdSpawnKill(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 2) return;
            string populationname = string.Empty;
            if (arg.Args == null || arg.Args.Length < 1)
            {
                SendReply(arg, $"You need to provide a valid SpawnPopulation name");
                return;
            }

            if (_spawnKill != null)
            {
                SendReply(arg, "Action aborted: another task is still running!");
                return;
            }

            SendReply(arg, $"Calling kill for '{arg.Args[0]}'");
            PauseTick();
            _spawnKill = Global.Runner.StartCoroutine(SpawnKill(arg.Args[0], arg.Args[0] == "all" ? true : false, arg));
        }

        private IEnumerator SpawnKill(string populationname, bool killAll, ConsoleSystem.Arg arg)
        {
            yield return new WaitWhile(() =>
                _spawnFill != null || _enforceLimits != null || _spawnLowerDensity != null ||
                _spawnRaiseDensity != null);
            bool findany = false;
            int countDeleted = 0;
            bool fullMatch = false;
            bool junkPiles = false;
            for (int i = 0; i < AllSpawnPopulations.Length; i++)
                if (!(AllSpawnPopulations[i] == null))
                {
                    if (killAll && killAllProtected.Contains(AllSpawnPopulations[i].name)) continue;
                    if (AllSpawnPopulations[i].name.Equals(populationname, StringComparison.OrdinalIgnoreCase) ||
                        AllSpawnPopulations[i].name.StartsWith(populationname, StringComparison.OrdinalIgnoreCase) ||
                        AllSpawnPopulations[i].name.EndsWith(populationname, StringComparison.OrdinalIgnoreCase) &&
                        !fullMatch || killAll)
                    {
                        if (AllSpawnPopulations[i].name == populationname) fullMatch = true;
                        Spawnable[] array = SpawnHandler.Instance.FindAll(AllSpawnPopulations[i]);
                        int count = array.Length;
                        foreach (Spawnable current in array.ToList())
                        {
                            BaseEntity baseEntity = current.gameObject.ToBaseEntity();
                            if (baseEntity.IsValid())
                            {
                                if (baseEntity is JunkPile)
                                {
                                    JunkPile junk = baseEntity as JunkPile;
                                    for (int j = 0; j < junk.spawngroups.Length; j++) junk.spawngroups[j].Clear();
                                    junk.CheckEmpty();
                                    junk.SinkAndDestroy();
                                    junkPiles = true;
                                    yield return CoroutineEx.waitForEndOfFrame;
                                }
                                else
                                {
                                    if (baseEntity is OreResourceEntity)
                                        (baseEntity as OreResourceEntity).CleanupBonus();
                                    baseEntity.Kill(BaseNetworkable.DestroyMode.None);
                                }

                                countDeleted++;
                            }
                            else
                            {
                                GameManager.Destroy(current.gameObject, 0f);
                                countDeleted++;
                            }

                            if (countDeleted % 25 == 0) yield return CoroutineEx.waitForEndOfFrame;
                        }

                        if (!killAll)
                        {
                            if (junkPiles)
                                SendReply(arg,
                                    $"Forced deletion of '{AllSpawnPopulations[i].name}' | Old: {count} | New: {SpawnHandler.Instance.GetCurrentCount(AllSpawnPopulations[i], SpawnDistributions[i])}(DELAYED)");
                            else
                                SendReply(arg,
                                    $"Forced deletion of '{AllSpawnPopulations[i].name}' | Old: {count} | New: {SpawnHandler.Instance.GetCurrentCount(AllSpawnPopulations[i], SpawnDistributions[i])}");
                        }

                        findany = true;
                        yield return CoroutineEx.waitForFixedUpdate;
                    }
                }

            if (!findany && !killAll) SendReply(arg, $"SpawnPopulation '{populationname}' not found");
            if (findany && killAll) SendReply(arg, $"SpawnPopulation > cleaned the map of '{countDeleted}' objects");
            _spawnKill = null;
            ResumeTick();
            yield break;
        }

        [ConsoleCommand("sc.killgroups")]
        private void ccmdGroupKill(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 2) return;
            if (arg.Args == null || arg.Args.Length < 1)
            {
                SendReply(arg, $"You need to confirm the action with 'force'");
                return;
            }

            if (_groupKill != null)
            {
                SendReply(arg, "Action aborted: another task is still running!");
                return;
            }

            SendReply(arg, $"Calling kill for SpawnGroups");
            _groupKill = Global.Runner.StartCoroutine(GroupKill(arg));
        }

        private IEnumerator GroupKill(ConsoleSystem.Arg arg)
        {
            PauseTick();
            int countDeleted = 0;
            bool success;
            for (int i = 0; i < SpawnHandler.Instance.SpawnGroups.Count; i++)
            {
                success = false;
                try
                {
                    countDeleted += (SpawnHandler.Instance.SpawnGroups[i] as SpawnGroup).currentPopulation;
                    (SpawnHandler.Instance.SpawnGroups[i] as SpawnGroup).Clear();
                    success = true;
                }
                catch
                {
                }

                if (success) yield return CoroutineEx.waitForEndOfFrame;
            }

            if (arg != null) SendReply(arg, $"Killed '{countDeleted}' SpawnGroup objects");
            ResumeTick();
            _groupKill = null;
            yield break;
        }

        [ConsoleCommand("sc.fillgroups")]
        private void ccmdGroupFill(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 2) return;
            if (_groupFill != null)
            {
                SendReply(arg, "Action aborted: another task is still running!");
                return;
            }

            SendReply(arg, $"Calling fill for SpawnGroups");
            _groupFill = Global.Runner.StartCoroutine(GroupFill(arg));
        }

        private IEnumerator GroupFill(ConsoleSystem.Arg arg)
        {
            PauseTick();
            int countFilled = 0;
            bool success;
            for (int i = 0; i < SpawnHandler.Instance.SpawnGroups.Count; i++)
            {
                success = false;
                try
                {
                    SpawnGroup group = SpawnHandler.Instance.SpawnGroups[i] as SpawnGroup;
                    countFilled += @group.maxPopulation - @group.currentPopulation;
                    group.Fill();
                    success = true;
                }
                catch
                {
                }

                if (success) yield return CoroutineEx.waitForEndOfFrame;
            }

            if (arg != null) SendReply(arg, $"Filled '{countFilled}' SpawnGroup objects");
            ResumeTick();
            _groupFill = null;
            yield break;
        }

        [ConsoleCommand("sc.enforcelimits")]
        private void ccmdEnforceLimits(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 2) return;
            bool forceAll = false;
            if (arg.Args != null && arg.Args.Length > 0)
                if (arg.Args[0].ToLower() == "all")
                    forceAll = true;
            SendReply(arg, $"Enforcing population limits");
            if (_enforceLimits != null)
            {
                SendReply(arg, "Action aborted: another task is still running!");
                return;
            }

            PauseTick();
            _enforceLimits = Global.Runner.StartCoroutine(EnforceLimits(forceAll, arg));
        }

        private IEnumerator EnforceLimits(bool forceAll, ConsoleSystem.Arg arg)
        {
            yield return new WaitWhile(() =>
                _spawnKill != null || _spawnFill != null || _spawnLowerDensity != null || _spawnRaiseDensity != null);
            int countDeleted = 0;
            for (int i = 0; i < AllSpawnPopulations.Length; i++)
            {
                if (!(AllSpawnPopulations[i] == null))
                {
                    SpawnPopulation population = AllSpawnPopulations[i];
                    SpawnDistribution distribution = SpawnDistributions[i];
                    if (forceAll || population.EnforcePopulationLimits)
                    {
                        int targetCount = SpawnHandler.Instance.GetTargetCount(population, distribution);
                        Spawnable[] array = SpawnHandler.Instance.FindAll(population);
                        if (array.Length <= targetCount) continue;
                        int num = array.Length - targetCount;
                        foreach (Spawnable current in array.Take(num).ToList())
                        {
                            BaseEntity baseEntity = current.gameObject.ToBaseEntity();
                            if (baseEntity.IsValid())
                            {
                                if (baseEntity is JunkPile)
                                {
                                    (baseEntity as JunkPile).SinkAndDestroy();
                                    yield return CoroutineEx.waitForEndOfFrame;
                                }
                                else
                                {
                                    if (baseEntity is OreResourceEntity)
                                        (baseEntity as OreResourceEntity).CleanupBonus();
                                    baseEntity.Kill(BaseNetworkable.DestroyMode.None);
                                }

                                countDeleted++;
                            }
                            else
                            {
                                GameManager.Destroy(current.gameObject, 0f);
                                countDeleted++;
                            }

                            if (countDeleted % 25 == 0) yield return CoroutineEx.waitForEndOfFrame;
                        }
                    }
                }

                yield return CoroutineEx.waitForFixedUpdate;
            }

            if (arg != null) SendReply(arg, $"Enforced limits on '{countDeleted}' objects");
            _enforceLimits = null;
            ResumeTick();
            yield break;
        }

        [ConsoleCommand("sc.reloadconfig")]
        private void ccmdSpawnReload(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 2) return;
            UnloadCoRoutines();
            NextTick(() =>
            {
                LoadConfig();
                LoadVariables();
                fillPopulations.Clear();
                fillJobs.Clear();
                killAllProtected.Clear();
                heartbeatOn = false;
                GetPopulationNames();
                LoadSpawnPopulations();
                LoadSpawnGroups();
                SpawnHandler.Instance.StartSpawnTick();
                if (normalizeDefaultVariables) SetTickConvars(true);
                currentTickStatus = true;
                if (reloadWithIncludedFill)
                {
                    SpawnHandler.Instance.FillGroups();
                    SpawnHandler.Instance.FillPopulations();
                }

                if (fillJobs.Count > 0) SendReply(arg, $"Planned {fillJobs.Count} job(s) for spawn population");
                if (reloadWithIncludedFill)
                    SendReply(arg, $"Updated and initially filled SpawnPopulations and spawnGroups");
                else SendReply(arg, $"Updated SpawnPopulation and SpawnGroup settings");
            });
        }

        [ConsoleCommand("sc.populationreport")]
        private void ccmdGetPopulationReport(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 2) return;
            NextTick(() =>
            {
                PauseTick();
                TextTable textTable = new TextTable();
                textTable.AddColumn("SpawnPopulation");
                textTable.AddColumn("Current");
                textTable.AddColumn("Limits");
                int totalCurrent = 0;
                int totalLimits = 0;
                for (int i = 0; i < AllSpawnPopulations.Length; i++)
                    if (!(AllSpawnPopulations[i] == null))
                    {
                        SpawnPopulation population = AllSpawnPopulations[i];
                        SpawnDistribution spawnDistribution = SpawnDistributions[i];
                        if (population != null)
                            if (spawnDistribution != null)
                            {
                                int curr = SpawnHandler.Instance.GetCurrentCount(population, spawnDistribution);
                                int lmt = SpawnHandler.Instance.GetTargetCount(population, spawnDistribution);
                                textTable.AddRow(new string[]
                                    {population.name.ToString(), curr.ToString(), lmt.ToString()});
                                totalCurrent += curr;
                                totalLimits += lmt;
                            }
                    }

                textTable.AddRow(new string[] { "TOTAL:", totalCurrent.ToString(), totalLimits.ToString() });
                SendReply(arg, "\n\n>> Report:\n" + textTable.ToString());
                ResumeTick();
            });
        }

        [ConsoleCommand("sc.populationsettings")]
        private void ccmdGetPopulations(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 2) return;
            NextFrame(() =>
            {
                PauseTick();
                TextTable textTable = new TextTable();
                textTable.AddColumn("Name");
                textTable.AddColumn("Density");
                textTable.AddColumn("Rate");
                textTable.AddColumn("Limiting");
                textTable.AddColumn("Prefabs");
                textTable.AddColumn("Scale");
                for (int i = 0; i < AllSpawnPopulations.Length; i++)
                    if (!(AllSpawnPopulations[i] == null))
                    {
                        SpawnPopulation population = AllSpawnPopulations[i];
                        Prefab<Spawnable>[] prefabs = population.Prefabs;
                        textTable.AddRow(new string[]
                        {
                            population.name.ToString(), population.TargetDensity.ToString(),
                            population.SpawnRate.ToString(), population.EnforcePopulationLimits.ToString(),
                            prefabs.Length.ToString(), population.ScaleWithServerPopulation.ToString(),
                        });
                    }

                SendReply(arg, "\n\n>> SpawnPopulations:\n" + textTable.ToString());
                ResumeTick();
            });
        }

        [ConsoleCommand("sc.restorepopulationdensities")]
        private void ccmdRestoreDensities(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 2) return;
            NextTick(() =>
            {
                PauseTick();
                if (spawnDefaults == null || spawnDefaults.Count == 0)
                {
                    spawnDefaults = new Dictionary<string, object>();
                    defaultSpawnPops = getFile($"{Title}_defaults");
                    spawnDefaults = defaultSpawnPops["Backup"] as Dictionary<string, object>;
                }

                if (spawnDefaults == null || spawnDefaults.Count == 0)
                {
                    SendReply(arg, "Default SpawnPopulations not found or file missing.");
                    return;
                }

                for (int i = 0; i < AllSpawnPopulations.Length; i++)
                    if (!(AllSpawnPopulations[i] == null))
                    {
                        string name = AllSpawnPopulations[i].name;
                        float newDensity = Convert.ToSingle(spawnDefaults[name]);
                        AllSpawnPopulations[i]._targetDensity = newDensity;
                        SetAnimal(name, newDensity);
                        (spawnPopulations[AllSpawnPopulations[i].name] as Dictionary<string, object>)["targetDensity"] =
                            newDensity;
                    }

                Config["Spawn", "Population"] = spawnPopulations;
                Config.Save();
                SendReply(arg, "Reverted SpawnPopulation density's to their defaults");
                _enforceLimits = Global.Runner.StartCoroutine(EnforceLimits(true, arg));
            });
        }

        [ConsoleCommand("sc.restorepopulationweights")]
        private void ccmdRestoreWeights(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 2) return;
            NextTick(() =>
            {
                PauseTick();
                if (spawnPrefabDefaults == null || spawnPrefabDefaults.Count == 0)
                {
                    spawnPrefabDefaults = new Dictionary<string, object>();
                    defaultSpawnPops = getFile($"{Title}_defaults");
                    spawnPrefabDefaults = defaultSpawnPops["PrefabBackup"] as Dictionary<string, object>;
                }

                if (spawnPrefabDefaults == null || spawnPrefabDefaults.Count == 0)
                {
                    SendReply(arg, "Default SpawnPopulationWeights not found or file missing");
                    return;
                }

                for (int i = 0; i < AllSpawnPopulations.Length; i++)
                    if (!(AllSpawnPopulations[i] == null))
                    {
                        Dictionary<string, object> prefabData =
                            spawnPrefabDefaults[AllSpawnPopulations[i].name] as Dictionary<string, object>;
                        List<Prefab<Spawnable>> prefabs = new List<Prefab<Spawnable>>();
                        foreach (KeyValuePair<string, object> prefab in prefabData)
                        {
                            GameObject gameObject = GameManager.server.FindPrefab(prefab.Key);
                            Spawnable component = gameObject?.GetComponent<Spawnable>();
                            if (component == null) continue;
                            for (int j = 0; j < Convert.ToInt32(prefab.Value); j++)
                                prefabs.Add(new Prefab<Spawnable>(prefab.Key.ToLower(), gameObject, component,
                                    GameManager.server, PrefabAttribute.server));
                        }

                        AllSpawnPopulations[i].Prefabs = prefabs.ToArray();
                        _numToSpawn.SetValue(AllSpawnPopulations[i], new int[prefabs.ToArray().Length]);
                        (spawnPopulations[AllSpawnPopulations[i].name] as Dictionary<string, object>)["spawnWeights"] =
                            prefabData;
                    }

                Config["Spawn", "Population"] = spawnPopulations;
                Config.Save();
                SendReply(arg, "Reverted SpawnPopulation weights's to their defaults");
                _enforceLimits = Global.Runner.StartCoroutine(EnforceLimits(true, arg));
            });
        }

        [ConsoleCommand("sc.groupsettings")]
        private void ccmdGetGroups(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 2)
                return;

            Dictionary<string, List<MonumentInfo>> monumentGroups = TerrainMeta.Path?.Monuments?.GroupBy(c => c.displayPhrase.english)?.ToDictionary(c => c.Key, c => c.ToList());
            if (monumentGroups == null)
                return;

            PauseTick();
            TextTable textTable = new TextTable();
            textTable.AddColumn("Monument");
            textTable.AddColumn("Group");
            textTable.AddColumn("DelayMin");
            textTable.AddColumn("DelayMax");
            textTable.AddColumn("PerTick");
            textTable.AddColumn("CenterPosition");
            foreach (KeyValuePair<string, List<MonumentInfo>> current in monumentGroups)
            {
                MonumentInfo monument = current.Value.First();
                string displayPhrase = monument.displayPhrase.english;
                if (displayPhrase.Length == 0) continue;
                SpawnGroup[] groups = monument.gameObject.GetComponentsInChildren<SpawnGroup>();
                if ((groups == null) | (groups.Length == 0)) continue;
                bool firstLine = true;
                foreach (SpawnGroup group in groups.ToList())
                {
                    Vector3 center = Vector3.zero;
                    foreach (BaseSpawnPoint spawnPoint in group.spawnPoints.ToList())
                        center += spawnPoint.transform.position;
                    center /= group.spawnPoints.Length;
                    Dictionary<string, object> prefabdata = new Dictionary<string, object>();
                    foreach (SpawnGroup.SpawnEntry prefab in group.prefabs)
                    {
                        if (prefab.prefab.resourcePath.Contains("/npc/")) continue;
                        prefabdata[prefab.prefab.resourcePath] = prefab.weight;
                    }

                    if (prefabdata.Count == 0) continue;
                    if (firstLine) firstLine = false;
                    else displayPhrase = string.Empty;
                    textTable.AddRow(new string[]
                    {
                        displayPhrase, group.name, group.respawnDelayMin.ToString(), group.respawnDelayMax.ToString(),
                        group.numToSpawnPerTickMin.ToString() + " / " + group.numToSpawnPerTickMax.ToString(),
                        center.ToString().Replace(" ", "")
                    });
                }
            }

            SendReply(arg, "\n\n>> GroupSpawners:\n" + textTable.ToString());
            ResumeTick();
        }

        [ConsoleCommand("sc.dumpresources")]
        private void ccmdDumpResources(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 2) return;
            NextFrame(() =>
            {
                PauseTick();
                TextTable textTable = new TextTable();
                textTable.AddColumn("Name");
                textTable.AddColumn("Count");
                textTable.AddColumn("Type");
                foreach (KeyValuePair<string, int> t in GetCollectibles())
                    textTable.AddRow(new string[] { t.Key.ToString(), t.Value.ToString(), "Collectible" });
                foreach (KeyValuePair<string, IGrouping<string, BaseEntity>> t in GetOreNodes())
                    textTable.AddRow(new string[] { t.Key.ToString(), t.Value.Count().ToString(), "Ore" });
                foreach (KeyValuePair<string, IGrouping<string, BaseEntity>> t in GetAnimals())
                    textTable.AddRow(new string[] { t.Key.ToString(), t.Value.Count().ToString(), "Animals" });
                SendReply(arg, "\n>> Resources:\n" + textTable.ToString());
                ResumeTick();
            });
        }

        [ConsoleCommand("sc.dumploot")]
        private void ccmdDumpLoot(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 2) return;
            NextFrame(() =>
            {
                PauseTick();
                TextTable textTable = new TextTable();
                textTable.AddColumn("Name");
                textTable.AddColumn("Count");
                textTable.AddColumn("Type");
                foreach (KeyValuePair<string, IGrouping<string, BaseEntity>> t in GetLootContainers())
                    textTable.AddRow(new string[] { t.Key.ToString(), t.Value.Count().ToString(), "Loot" });
                SendReply(arg, "\n>> Loot:\n" + textTable.ToString());
                ResumeTick();
            });
        }

        [ConsoleCommand("sc.cmds")]
        private void ccmdComandsList(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null && arg.Connection.authLevel < 2) return;
            StringBuilder sb = new StringBuilder();
            sb.AppendLine("\n==== Command List ================\n");
            sb.AppendLine($"sc.cleardata".PadRight(30) +
                          "| Clear Population and/or Group data by 'all', 'population' or 'groups");
            sb.AppendLine($"sc.tickinterval".PadRight(30) + "| Show or set the Population tick interval in 'seconds'");
            sb.AppendLine($"sc.spawnticktoggle".PadRight(30) + "| Does pause or resume the spawnhandler ticks'");
            sb.AppendLine($"sc.fillpopulation".PadRight(30) + "| Fill all Populations or choosen one's by 'filter'");
            sb.AppendLine($"sc.killpopulation".PadRight(30) + "| Kill 'all' Populations or choosen one's by 'filter'");
            sb.AppendLine($"sc.fillgroups".PadRight(30) + "| Fill all SpawnGroups");
            sb.AppendLine($"sc.killgroups".PadRight(30) + "| Kill all SpawnGroups");
            sb.AppendLine($"sc.raisedensity".PadRight(30) +
                          "| Raise Populations in 'percent' for 'all' or choosen one's by 'filter'");
            sb.AppendLine($"sc.lowerdensity".PadRight(30) +
                          "| Lower Populations in 'percent' for 'all' or choosen one's by 'filter'");
            sb.AppendLine($"sc.enforcelimits".PadRight(30) + "| Enforce object limits on all Populations");
            sb.AppendLine($"sc.reloadconfig".PadRight(30) + "| Reload the plugin after config changes");
            sb.AppendLine(
                $"sc.populationreport".PadRight(30) + "| Display current Population objects with their limits");
            sb.AppendLine($"sc.populationsettings".PadRight(30) + "| Display current Population settings");
            sb.AppendLine($"sc.restorepopulationdensities".PadRight(30) +
                          "| Restore Population densities to their defaults");
            sb.AppendLine(
                $"sc.restorepopulationweights".PadRight(30) + "| Restore Population weights to their defaults");
            sb.AppendLine($"sc.groupsettings".PadRight(30) + "| Display SpawnGroup settings");
            sb.AppendLine($"sc.dumpresources".PadRight(30) +
                          "| Dump current server resource amount (for information only)");
            sb.AppendLine($"sc.dumploot".PadRight(30) + "| Dump current server loot amount (for information only)");
            sb.AppendLine($"sc.topologyget".PadRight(30) + "| List all entries of a Topology mask");
            sb.AppendLine($"sc.topologylist".PadRight(30) + "| List all possible Topology mask entries");
            sb.AppendLine($"sc.topologycreate".PadRight(30) + "| To create a new Topology mask");
            SendReply(arg, sb.ToString());
        }

        private Dictionary<string, int> GetCollectibles()
        {
            return UnityEngine.Object.FindObjectsOfType<CollectibleEntity>()
                .Where(c => !c.ShortPrefabName.Contains("mushroom")).GroupBy(c => c.ShortPrefabName)
                .ToDictionary(c => c.Key.Remove(c.Key.Length - 12), c => c.Count());
        }

        private Dictionary<string, IGrouping<string, BaseEntity>> GetOreNodes()
        {
            return UnityEngine.Object.FindObjectsOfType<ResourceEntity>().Where(c => c.name.Contains("-ore"))
                .Cast<BaseEntity>().GroupBy(c => c.ShortPrefabName).ToDictionary(c => c.Key, c => c);
        }

        private Dictionary<string, IGrouping<string, BaseEntity>> GetLootContainers()
        {
            return UnityEngine.Object.FindObjectsOfType<LootContainer>().Cast<BaseEntity>()
                .GroupBy(c => c.ShortPrefabName)
                .ToDictionary(c => c.Key, c => c);
        }

        private Dictionary<string, IGrouping<string, BaseEntity>> GetAnimals()
        {
            return UnityEngine.Object.FindObjectsOfType<BaseNpc>().Cast<BaseEntity>().GroupBy(c => c.ShortPrefabName)
                .ToDictionary(c => c.Key, c => c);
        }

        private string PrefabCut(string name)
        {
            return Oxide.Core.ExtensionMethods.Basename(name, ".prefab");
        }

        private void FixBarricades()
        {
            if (fixBarricadeStacking) return;
            PauseTick();
            List<BaseEntity> spawns = UnityEngine.Object.FindObjectsOfType<BaseEntity>()
                .Where(c => c.ShortPrefabName.StartsWith("door_barricade")).OrderBy(c => c.transform.position.x)
                .ThenBy(c => c.transform.position.z).ThenBy(c => c.transform.position.z).ToList();
            int count = spawns.Count();
            int racelimit = count * count;
            int antirace = 0;
            int deleted = 0;
            for (int i = 0; i < count; i++)
            {
                BaseEntity box = spawns[i];
                int next = i + 1;
                Vector2 pos = new Vector2(box.transform.position.x, box.transform.position.z);
                if (++antirace > racelimit) return;
                while (next < count)
                {
                    BaseEntity box2 = spawns[next];
                    Vector2 pos2 = new Vector2(box2.transform.position.x, box2.transform.position.z);
                    float distance = Vector2.Distance(pos, pos2);
                    if (++antirace > racelimit) return;
                    if (distance < 1.0f)
                    {
                        spawns.RemoveAt(next);
                        count--;
                        (box2 as BaseEntity).Kill();
                        deleted++;
                    }
                    else
                    {
                        break;
                    }
                }
            }

            ResumeTick();
            if (deleted > 0) Puts($"Removed {deleted} stacked DoorBarricades.");
        }
    }
}

// --- End of file: SpawnControl.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/XHorsePlus.cs ---
// --- Original Local Path: XHorsePlus.cs ---

using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("XHorsePlus", "SkuliDropek", "1.0.1")]
    class XHorsePlus : RustPlugin
    {	
	    #region Configuration

        private HorseConfig config;

        private class HorseConfig
        {								
			internal class HorseSetting
            {				    
				[JsonProperty("SkinID: 2236993578 - 1, 2236994498 - 2")] 
                public ulong HorseSkinID;				
				[JsonProperty("Имя")] 
                public string HorseName;			
            }			
			
			internal class WorkSetting
            {				    
				[JsonProperty("Количество дополнительных мест. True - 1, False - 2")] 
                public bool ChairValue;				
				[JsonProperty("Отрисовывать стул")] 
                public bool Chair;			
            }			
            						
			[JsonProperty("Настройки лошади")]
            public HorseSetting Horse = new HorseSetting();			
			[JsonProperty("Общее")]
            public WorkSetting Settings = new WorkSetting();			
			
			public static HorseConfig GetNewConfiguration()
            {
                return new HorseConfig
                {
					Settings = new WorkSetting
					{
						ChairValue = false,
						Chair = true
					},
					Horse = new HorseSetting
					{
						HorseSkinID = 2236994498,
						HorseName = "ЛОШАДКА"
					}
				};
			}
        }

        protected override void LoadDefaultConfig()
        {
            config = HorseConfig.GetNewConfiguration();

            PrintWarning("Создание начальной конфигурации плагина!!!");
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();

            config = Config.ReadObject<HorseConfig>();
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion
		
		#region Commands
		
		[ConsoleCommand("h_give")]
        void cmdConsoleCommand(ConsoleSystem.Arg args)
        {
			if (args.Player() != null) return;
			
			BasePlayer player = BasePlayer.FindByID(ulong.Parse(args.Args[0]));
			
			if (player == null) return;
			
			Item item = ItemManager.CreateByName("woodcross", int.Parse(args.Args[1]), config.Horse.HorseSkinID);
            item.name = config.Horse.HorseName;
			
            player.GiveItem(item);
        }

        #endregion	
	
        #region Hooks
		
		private void OnServerInitialized()
		{		
			PrintWarning("\n-----------------------------\n" +
			"     Author - SkuliDropek\n" +
			"     VK - vk.com/idannopol\n" +
			"    Discord - Skuli Dropek#4816 - KINGSkuliDropek#4837\n" +
			"     Config - v.1459\n" +
			"-----------------------------");
		}
		
        private void OnEntitySpawned(RidableHorse horse)
        {
            if (horse.mountPoints.Count < 2 && horse.ShortPrefabName == "testridablehorse")
            {
				if (config.Settings.ChairValue)
				{
					horse.mountPoints.Add(SpawnPassenger(horse, new Vector3(0.02f, 1.0f, -0.5f), new Vector3(0, 0, 0)));
				}
				else
				{
					horse.mountPoints.Add(SpawnPassenger(horse, new Vector3(0.625f, 0.5f, -0.35f), new Vector3(0, 90, 0)));
                    horse.mountPoints.Add(SpawnPassenger(horse, new Vector3(-0.625f, 0.5f, -0.35f), new Vector3(0, 270, 0)));
				}

                if (config.Settings.Chair)
				{
                    if (config.Settings.ChairValue)
				    {
				    	ChairOne(horse, new Vector3(0.02f, 1.0f, -0.5f), new Vector3(0, 0, 0));
				    }
				    else
				    {
					    ChairOne(horse, new Vector3(0.625f, 0.5f, -0.35f), new Vector3(0, 90, 0));
		                ChairTwo(horse, new Vector3(-0.625f, 0.5f, -0.35f), new Vector3(0, 270, 0));
					}
				}
            }
        }
		
		private void OnEntityBuilt(Planner plan, GameObject go)
        {
            SpawnEntity(go.ToBaseEntity());
        }
		
        #endregion

        #region Entity
		
		private void SpawnEntity(BaseEntity entity)
        {
            if (entity == null) return;
			
            if (entity.skinID == config.Horse.HorseSkinID)
			{
				var horse = GameManager.server.CreateEntity("assets/rust.ai/nextai/testridablehorse.prefab", entity.transform.position, entity.transform.rotation = Quaternion.Euler(new Vector3(0f, 0f, 0f)));
                                
                horse.Spawn(); 						
				NextTick(() => { entity.Kill(); });
			}			
        }

        void ChairOne(RidableHorse horse, Vector3 position, Vector3 rotation)
        {
            BaseEntity entity = GameManager.server.CreateEntity("assets/prefabs/vehicle/seats/passengerchair.prefab");
			
            if (entity == null) return;
			
            entity.transform.localPosition = position;
			entity.transform.localRotation = Quaternion.Euler(rotation);

			entity.SetParent(horse);
			entity.Spawn();
        }        
		
		void ChairTwo(RidableHorse horse, Vector3 position, Vector3 rotation)
        {
            BaseEntity entity = GameManager.server.CreateEntity("assets/prefabs/vehicle/seats/passengerchair.prefab");
			
            if (entity == null) return;
			
            entity.transform.localPosition = position;
			entity.transform.localRotation = Quaternion.Euler(rotation);

			entity.SetParent(horse);
			entity.Spawn();
        }            

        RidableHorse.MountPointInfo SpawnPassenger(RidableHorse horse, Vector3 position, Vector3 rotation)
        {
            return new RidableHorse.MountPointInfo
            {
				pos = position,
                rot = rotation,
                prefab = horse.mountPoints[0].prefab,
                mountable = horse.mountPoints[0].mountable,
            };
        }
			
        #endregion
    }
}

// --- End of file: XHorsePlus.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/InstantBuy.cs ---
// --- Original Local Path: InstantBuy.cs ---

﻿
namespace Oxide.Plugins
{
    [Info("Instant Buy", "Apple", "1.0.3")]
    [Description("Vending Machine has no delay")]

    public class InstantBuy : CovalencePlugin
    {
        private object OnBuyVendingItem(VendingMachine machine, BasePlayer player, int sellOrderID, int amount)
        {
            if (machine == null || player == null) return null;
            
            if (player.inventory.containerMain.IsFull() && player.inventory.containerBelt.IsFull()) return null;

            machine.ClientRPC<int>(null, "CLIENT_StartVendingSounds", sellOrderID);
            machine.DoTransaction(player, sellOrderID, amount);
            return false;
        }
    }
}

// --- End of file: InstantBuy.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BlueprintChecker.cs ---
// --- Original Local Path: BlueprintChecker.cs ---

using System;
using System.Collections.Generic;
using Oxide.Core;

namespace Oxide.Plugins
{

    [ Info(        "Blueprint Checker", "Dablin", "1.0.6"                                     )]
    [ Description( "Check how many blueprints an online player has learnt and what they are." )]
		
    class BlueprintChecker : RustPlugin {
			
		// [ Required CONSTANTS ] ---------------------------------------------
		
		private const string	CREDIT_TITLE					= "<color=green>BluePrint Checker</color>";
		private const string	CREDIT_AUTHOR					= "<color=lime>Dablin</color>";
		private const string	CREDIT_VERSION					= "1.0.6</color>";
		private const string	CREDIT_EMAIL					= "mail@paulmoffat.net";
		private const string	CREDIT_WEBSITE					= "www.paulmoffat.net";
		private const string	CREDIT_BY						= "by";
		private const string	CREDIT_V						= "(<color=yellow>v";
		private const string	CREDIT_OPEN						= "<color=lime>-=[ </color>";
		private const string	CREDIT_CLOSE					= ") <color=lime>]=-</color>";
								
		// [ Required Variables ] ---------------------------------------------
		
		private string 			ARG_ListInScon 					= "";
		private string 			ARG_ListInChat 					= "";
		private string 			ARG_Help						= "";
		private string 			ARG_Knows						= "";
		
		private	string			CDV								= "OL25S12";

		private int 			CFG_AuthorityLevelRequired		= 0;
		private bool			CFG_UpdatePlayerOnConnect		= true;
		private	bool			CFG_UpdatePlayerOnStudy			= true;
		private bool			CFG_UpdatePlayerVerbose			= true;

		private string			MSG_AccessDenied				= "";
		private string			MSG_CommandLine					= "";
		private string			MSG_Help						= "";
		private string			MSG_Knows						= "";
		private string			MSG_KnowsThis					= "";
		private string			MSG_KnowsCount					= "";
		private string			MSG_KnowsNot					= "";
		private string			MSG_LogWithArg					= "";
		private string			MSG_LogNoArg					= "";
		private string			MSG_MultiplePlayersFound		= "";
		private string			MSG_PlayerNotFound				= "";
		private string			MSG_What						= "";
				
		// Database Variables
		
		private List<int>		Player_BPKeys					= null;
		private string			Player_ID						= "";
		private int				Player_KnownBP					= 0;
		private string			Player_Name						= "";
		
		// Misc - Don't Store
		private int		 		BPMax 							= 0;
		private bool			ConfigMismatch					= false;
		private bool			ConfigMissing					= false;
		private string			CRNL							= "";
		private bool			PlayerOfflineData				= false;
		private BasePlayer 		PlayerChecker 					= null;
		private BasePlayer 		PlayerToCheck 					= null;
		private Data			PlayerBPData					= null;
		private string			SPC								= "";
		private int				SteamIDLength					= 0;
		
		// DEBUGGING VARIABLES
		private const string	DBG_PLAYERBPKEYS				= "dbg_playerbpkeys";
		private const string	DBG_MAXBP						= "dbg_maxbp";
		private bool			DEBUG							= false;

		
// [ SUB-CLASSES ] -------------------------------------------------------------
		
		class Data {
					
			public string Version = "";
			public List< PlayerData > PlayerBPData;
			
			public Data(){
			
				PlayerBPData = new List< PlayerData >();
				
			}
		
		}
		
		class PlayerData {
		
			public string 		UserID;
			public string 		UserName;
			public int  		KnownBP;
			public List<int> 	BlueprintKeys;
			
            public PlayerData(){
			
				UserID 			= "";
				UserName 		= "";
				KnownBP 		= 0;
				BlueprintKeys 	= new List<int>();
			
			}
											
        }

// [ PRIVATE FUNCTIONS ] -------------------------------------------------------

		// Check calling Player has required security level to use this command
		private bool AuthenticatedPlayer( BasePlayer PLAYER, int AUTHORITYLEVEL ){
		
            // Player Does
			if( PLAYER.net.connection.authLevel >= AUTHORITYLEVEL )
                return true;
				
            // Player Does NOT!
			SendReply( PLAYER, MSG_AccessDenied );
            return false;
			
        }

		// BPCheck Chat Command Hooking Function
		[ ChatCommand( "bpcheck" )]
        private void BPCheck( BasePlayer PLAYER, string COMMAND, string[] ARGS ){
		
            // Log command call in server console and check for required security level
            if( ARGS != null )
				Puts( MSG_LogWithArg, PLAYER.displayName, string.Join( SPC, ARGS ));
			else
				Puts( MSG_LogNoArg, PLAYER.displayName );
				
			PlayerChecker = PLAYER;
			if( !AuthenticatedPlayer( PLAYER, CFG_AuthorityLevelRequired )) return;
			
			if( ARGS != null && ARGS.Length > 0 ){
			
				// Display Help Information
				if( ARGS[ 0 ].ToString().ToLower() == ARG_Help ){
				
					SendReply( PlayerChecker, Credit() + CRNL + MSG_Help );
					return;
					
				}
				
				if( ARGS[ 0 ].ToString().ToLower() == DBG_MAXBP ){
				
						Debug( "BPMax = " + BPMax);
						return;
						
				}
												
				// Check for player online/within database
				if( !(PlayerToCheck = GetPlayer( ARGS[ 0 ], PlayerChecker )))
					if( !PlayerOfflineData )
						return;
								
			} else {
			
				// No Player name given, so display the Credits instead
				SendReply( PlayerChecker, string.Format( Credit() + MSG_CommandLine ));
				return;
				
			}
							
			var ItemDefinitions = ItemManager.GetItemDefinitions();	// List of all available in game items
			bool BPCheck		= false;
			int	BPState			= 0;
			string BPLongname	= "";

			if( !PlayerOfflineData ){
			
				if( ARGS.Length == 1 	)
						SendReply( PlayerChecker, string.Format( 	MSG_KnowsCount,
																	PlayerToCheck.displayName,
																	PlayerBPCount( PlayerToCheck.displayName, PlayerChecker ),
																	BPMax 														));			
																															
				if( ARGS.Length > 1 && ARGS.Length < 3 ){
				
					if( ARGS[ 1 ].ToString().ToLower() == ARG_ListInScon )
						Puts( PlayerBPList( PlayerToCheck.displayName, PlayerChecker ));
				
					if( ARGS[ 1 ].ToString().ToLower() == ARG_ListInChat )
						PrintToChat( PlayerChecker, PlayerBPList( PlayerToCheck.displayName, PlayerChecker ));
						
					if( ARGS[ 1 ].ToString().ToLower() == DBG_PLAYERBPKEYS )
						Debug( PlayerToCheck.displayName + " BP Key States: " + GetBPKeyState( PlayerToCheck, ref Player_BPKeys ));
							
				}
				
				if( ARGS.Length > 2 && ARGS.Length < 4 )					
					if( ARGS[ 1 ].ToString() == ARG_Knows ){	// Perform a check on a specific blueprint
					
						BPCheck = true;
						BPState = PlayerBPCheck( PlayerToCheck.displayName, PlayerChecker, ARGS[ 2 ].ToString(), ref BPLongname );
						
					}
				
				if( BPCheck ){
									
					if( BPState == -1 )
						SendReply( PlayerChecker, string.Format( MSG_What, 		ARGS[ 2 ].ToString() 					));
					if( BPState == 0  )
						SendReply( PlayerChecker, string.Format( MSG_KnowsNot, 	PlayerToCheck.displayName, BPLongname	));
					if( BPState == 1  )
						SendReply( PlayerChecker, string.Format( MSG_KnowsThis, PlayerToCheck.displayName, BPLongname 	));
												
				}
				
			} else {
			
				if( ARGS.Length == 1 	)
						SendReply( PlayerChecker, string.Format( 	MSG_KnowsCount,
																	Player_Name + " (offline)",
																	PlayerBPCount( Player_Name, PlayerChecker ),
																	BPMax 												));			
																																																			
				if( ARGS.Length > 1 && ARGS.Length < 3 ){
				
					if( ARGS[ 1 ].ToString().ToLower() == ARG_ListInScon )
						Puts( PlayerBPList( Player_Name, PlayerChecker ));
				
					if( ARGS[ 1 ].ToString().ToLower() == ARG_ListInChat )
						PrintToChat( PlayerChecker, PlayerBPList( Player_Name, PlayerChecker ));
																												
				}
				
				if( ARGS.Length > 2 && ARGS.Length < 4 )					
					if( ARGS[ 1 ].ToString() == ARG_Knows ){	// Perform a check on a specific blueprint{
					
						BPCheck = true;
						BPState = PlayerBPCheck( Player_Name, PlayerChecker, ARGS[ 2 ].ToString(), ref BPLongname );
						
					}

				if( BPCheck ){
								
					if( BPState == -1 )
						SendReply( PlayerChecker, string.Format( MSG_What, 		ARGS[ 2 ].ToString() 	));
					if( BPState == 0  )
						SendReply( PlayerChecker, string.Format( MSG_KnowsNot, 	Player_Name + " (offline)", BPLongname	));
					if( BPState == 1  )
						SendReply( PlayerChecker, string.Format( MSG_KnowsThis, Player_Name + " (offline)", BPLongname 	));
					
				}
																						
			}
				
			PlayerToCheck = null;
				
        }
		
        private void Loaded(){
		
			try {
			
				PlayerBPData = Interface.Oxide.DataFileSystem.ReadObject< Data >( "BlueprintChecker" );
				
			} catch {
						
				PrintWarning( "[Loaded] Database load error. Possible invalid or corrupted data entries. Please check/delete database file/entries then reload Blueprint Checker" );
				return;
				
			}
			
			if( PlayerBPData.Version != CDV ){
			
				PrintWarning( "[Loaded] Database found from previous version '" + PlayerBPData.Version + "', updating for current version '" + CDV + "'" );
				PlayerBPData.Version = CDV;
				Interface.Oxide.DataFileSystem.WriteObject( "BlueprintChecker", PlayerBPData );
				
			}
				
        }
		
		private int CountBP(){
		
			var ItemDefinitions = ItemManager.GetItemDefinitions();
			var CountBP 		= 0;
			
			foreach( var ItemCheck in ItemDefinitions )
				CountBP++;
							
			return CountBP;
		
		}
		
		private string Credit(){
		
			return CREDIT_OPEN + CREDIT_TITLE + SPC + CREDIT_BY + SPC + CREDIT_AUTHOR + SPC + CREDIT_V + CREDIT_VERSION + CREDIT_CLOSE;
		
		}
		
		private string CrNl( int LINENUMBER ){
				
			string crnl = CRNL;
			
			if( LINENUMBER > 1 )
				crnl += CrNl( LINENUMBER - 1 );
			
			return crnl;			
		
		}
				
		private void Debug( string MESSAGE ){
		
			if( DEBUG )
				PrintWarning( "<DEBUG> " + MESSAGE );
		
		}

		private string GetBPKeyState( BasePlayer PLAYER, ref List<int> STATEKEYRING ){
				
			//Debug( "[GetBPKeyState] Started");
			
			var 	ItemDefinitions 	= ItemManager.GetItemDefinitions();
			var 	BPID				= 0;
			string	BPKeys				= "";
			
			foreach( var ItemCheck in ItemDefinitions ){
			
				BPID++;
						
				if(  PLAYER.blueprints.CanCraft( ItemCheck.itemid, 0 ))
					BPKeys += "1";
				else
					BPKeys += "0";
				
				if( STATEKEYRING.Count < BPID ) {
				
					if( PLAYER.blueprints.CanCraft( ItemCheck.itemid, 0 ))
						STATEKEYRING.Add( 1 );
					else
						STATEKEYRING.Add( 0 );
					
					//Debug (" STATEKEYRING.Count < BPID ");
					
				} else {
				
					if( PLAYER.blueprints.CanCraft( ItemCheck.itemid, 0 ))
						STATEKEYRING[ BPID - 1 ] = 1;
					else
						STATEKEYRING[ BPID - 1 ] = 0;
					
					//Debug (" !STATEKEYRING.Count < BPID ");
					
				}
									
			}
			
			//Debug( "[GetBPKeyState] Keyring Size: " + STATEKEYRING.Count );
			
			return BPKeys;
		
		}
				
		private object GetConfig( string KEY, object DEFAULTVALUE ){
		
			if( Config[ KEY ] != null )			
				return Config[ KEY ];
			
			ConfigMismatch = true;
			
			Config[ KEY ] = DEFAULTVALUE;
			return Config[ KEY ];
		
		}
		
		private BasePlayer GetPlayer( string PLAYERTOCHECK, BasePlayer PLAYERCHECKER ){
					
			PlayerOfflineData = false;
			
			// Search for absolute player name or steamid
			BasePlayer PlayerToCheck = BasePlayer.Find( PLAYERTOCHECK );
			
			if( PlayerToCheck )
				return PlayerToCheck;
		
			// Perform a partial playername search
			
			List<string> PlayersFound = new List<string>();
			
			string PlayerCheck = PLAYERTOCHECK.ToLower();
			
			foreach( BasePlayer PLAYER in BasePlayer.activePlayerList )
				if( PLAYER.displayName.ToLower().Contains( PlayerCheck ))
					PlayersFound.Add( PLAYER.displayName );
					
			if( PlayersFound.Count == 1 )
				return BasePlayer.Find( PlayersFound[ 0 ] );
				
			if( PlayersFound.Count > 1 )
				SendReply( PLAYERCHECKER, MSG_MultiplePlayersFound );	
			else {
							
				// Perform a secondary database search for the player				
				
				//Debug( "[GetPlayer] Searching Database... " );
				
				List<int> PlayersFoundOffline = new List<int>();
				
				//Debug( "[GetPlayer] PlayerBPData.PlayerBPData.Count = " + Convert.ToString( PlayerBPData.PlayerBPData.Count ));
				
				for( int _key = 0; _key < PlayerBPData.PlayerBPData.Count; _key++ ){
				
					//Debug( "[GetPlayer] _key = " + Convert.ToString( _key ));
				
					// This should occur within normal situations but while I was developing the database functions some usernames were reset to null
					if( PlayerBPData.PlayerBPData[ _key ].UserName == null )
						continue;
						
					//Debug( "[GetPlayer] Playername found = " + PlayerBPData.PlayerBPData[ _key ].UserName );
					
					if( PlayerBPData.PlayerBPData[ _key ].UserName.ToLower().Contains( PLAYERTOCHECK.ToLower() 	)||
						PlayerBPData.PlayerBPData[ _key ].UserID.ToLower().Contains( PLAYERTOCHECK.ToLower() 	)){
						
							PlayersFoundOffline.Add( _key );
							
					}
						
				}
							
				//Debug( "[GetPlayer] PlayersFoundOffline.Count = " + Convert.ToString( PlayersFoundOffline.Count ));
							
				if( PlayersFoundOffline.Count > 1 )				
					SendReply( PLAYERCHECKER, MSG_MultiplePlayersFound );
				else
					if( PlayersFoundOffline.Count == 1 ){				
														
						//Debug( "[GetPlayer] " + PLAYERTOCHECK + " found in database" );
						
						PlayerOfflineData = true;
						
						Player_ID			= PlayerBPData.PlayerBPData[ PlayersFoundOffline[0] ].UserID;
						Player_Name			= PlayerBPData.PlayerBPData[ PlayersFoundOffline[0] ].UserName;
						Player_KnownBP 		= PlayerBPData.PlayerBPData[ PlayersFoundOffline[0] ].KnownBP;
						Player_BPKeys		= PlayerBPData.PlayerBPData[ PlayersFoundOffline[0] ].BlueprintKeys;
					
					} else
						SendReply( PLAYERCHECKER, string.Format( MSG_PlayerNotFound, PLAYERTOCHECK )); // Player not found online or in database

			}
												
			return null;
		
		}

		private void OnConsumableUse( Item ITEM ){
										
			if( CFG_UpdatePlayerOnStudy && ITEM.GetOwnerPlayer() && ITEM.IsBlueprint() ){
				
				//Debug( "[OnConsumableUse] '" + ITEM.info.shortname + "' blueprint studied by " + ITEM.GetOwnerPlayer().displayName );
					
				if( CFG_UpdatePlayerVerbose )
					Puts( "[OnConsumableUse] Updating Database for <" + ITEM.GetOwnerPlayer().UserIDString + "> : " + ITEM.GetOwnerPlayer().displayName );
					
				UpdatePlayer( ITEM.GetOwnerPlayer() );
				
			}
		
		}

		private void OnPlayerInit( BasePlayer PLAYER ){
		
			//Debug( "[OnPlayerInit] New Player Connected: " + PLAYER.displayName );
				
			if( CFG_UpdatePlayerOnConnect ){
			
				if( CFG_UpdatePlayerVerbose )
					Puts( "[OnPlayerInit] Updating Database for <" + PLAYER.UserIDString + "> : " + PLAYER.displayName );
			
				UpdatePlayer( PLAYER );
			
			}
				
		}
		
		private int PlayerBPCheck( string PLAYERID, BasePlayer PLAYERCHECKER, string BLUEPRINTID, ref string BPLONGNAME ){
		
			//Debug( BLUEPRINTID );
			
			var ItemDefinitions 	= ItemManager.GetItemDefinitions();
			bool BPKnows 			= false;							// Does the player know that specific blueprint
			bool BPNotFound 		= false;							// Does that specific blueprint even exist
			int	 BPID				= 0;
				
			foreach( var ItemCheck in ItemDefinitions                       ){
				
				if( BLUEPRINTID.ToLower() == ItemCheck.shortname.ToLower() || BLUEPRINTID.ToLower() == ItemCheck.displayName.translated.ToLower() ){
				
					BPNotFound = false;
					BPLONGNAME = ItemCheck.displayName.translated;
					
					if( !PlayerOfflineData) {
					
						if( PlayerToCheck.blueprints.CanCraft( ItemCheck.itemid, 0 ))
							BPKnows = true;
						else
							BPKnows = false;
						
					} else {
											
						if( Player_BPKeys[ BPID ] == 1 )
							BPKnows = true;
						else
							BPKnows = false;
					
					}
						
					break; // Item found, break out of item check loop
					
				} else
					BPNotFound = true;
				
				++BPID;
					
			}
			
			if( BPNotFound )
				return -1;
			else			
				if( !BPKnows )
					return 0;
				else
					return 1;
		
		}
		
		private int PlayerBPCount( string PLAYERID, BasePlayer PLAYERCHECKER ){
		
			BasePlayer Player = GetPlayer( PLAYERID, PLAYERCHECKER );

			if( !PlayerOfflineData ){
			
				//Debug( "[PlayerBPCount] Return Online Data" );
				
				var ItemDefinitions = ItemManager.GetItemDefinitions();
				var BPCount 		= 0;
				
				foreach( var ItemCheck in ItemDefinitions )
					if( Player.blueprints.CanCraft( ItemCheck.itemid, 0 ))
						BPCount++;
						
					Player_KnownBP = BPCount;
					return Player_KnownBP;
				
			} else {
			
				//Debug( "[PlayerBPCount] Return Offline Data" );
			
				return Player_KnownBP;
				
			}
						
		}
		
		private string PlayerBPList( string PLAYERID, BasePlayer PLAYERCHECKER ){
		
			BasePlayer Player 	= GetPlayer( PLAYERID, PLAYERCHECKER );
			var ItemDefinitions = ItemManager.GetItemDefinitions();
			string BPChatList	= "";
			int BPID			= 0;
			
			foreach( var ItemCheck in ItemDefinitions                       ){
																				
				if( !PlayerOfflineData ){

					// If the blueprints are to be listed, forward the list into the requested display output
					if( Player.blueprints.CanCraft( ItemCheck.itemid, 0 )){
																
						if( BPChatList != "" )
							BPChatList += " | ";
								
						if( BPChatList == "" )
							BPChatList += Player.displayName + SPC + MSG_Knows + "..." + CrNl( 2 );

						BPChatList += ItemCheck.displayName.translated;
							
					}
				
				} else {

					// If the blueprints are to be listed, forward the list into the requested display output
					if( Player_BPKeys[ BPID ] == 1 ){
																
						if( BPChatList != "" )
							BPChatList += " | ";
								
						if( BPChatList == "" )
							BPChatList += Player_Name + SPC + "(offline)" + SPC + MSG_Knows + "..." + CrNl( 2 );

						BPChatList += ItemCheck.displayName.translated;
						
					}
							
				}

				++BPID;
								
			}
			
			return BPChatList;
		
		}
		
		private void PrintToChat( BasePlayer PLAYERCHECKER, string MESSAGE ){
		
			//Debug( "[PrintToChat] Message Length = " + Convert.ToString( MESSAGE.Length ));
			
			if( MESSAGE.Length < 1000 ){
			
				SendReply( PLAYERCHECKER, MESSAGE );
			
			} else {
			
				//Debug( "[PrintToChat] Displaying Multiple Messages..." );
			
				int MESSAGEPARTS = ( MESSAGE.Length / 1000 );
				
				if( Convert.ToDecimal( MESSAGEPARTS ) < Convert.ToDecimal( MESSAGE.Length ) / 1000 )
					++MESSAGEPARTS;
					
				string MessagePart = "";
				
				//Debug( "[PrintToChat] MessageParts = " + Convert.ToString( MESSAGEPARTS ));
				
				for( int _printMessage = 0; _printMessage < MESSAGEPARTS; ++_printMessage ){
				
					if( _printMessage != ( MESSAGEPARTS - 1 ))
						MessagePart = MESSAGE.Substring( ( _printMessage * 1000 ), 1000 );
					else
						MessagePart = MESSAGE.Substring( _printMessage * 1000 );
						
					//Debug( "[PrintToChat] Next Message Length = " + Convert.ToString( MessagePart.Length ));
					SendReply( PLAYERCHECKER, MessagePart );						
				
				}
					
			}
		
		}
		
		private void OnServerInitialized(){
		
			PrintWarning( "[OnServerInitialized] Loading Configuration Data..." );
			
			LoadConfig();
			
			// Transfer loaded variables to their internal counterparts
			
			string CDVCheck;
			
			CDVCheck						= Convert.ToString(	 Config[ "CDV"							]);
			ARG_ListInScon 					= Convert.ToString(  Config[ "ARG_ListInScon" 				]);
			ARG_ListInChat 					= Convert.ToString(  Config[ "ARG_ListInChat" 				]);
			ARG_Help 						= Convert.ToString(  Config[ "ARG_Help" 					]);
			ARG_Knows 						= Convert.ToString(  Config[ "ARG_Knows" 					]);
			CFG_AuthorityLevelRequired 		= Convert.ToInt32(   Config[ "CFG_AuthorityLevelRequired" 	]);
			CFG_UpdatePlayerOnConnect 		= Convert.ToBoolean( Config[ "CFG_UpdatePlayerOnConnect" 	]);
			CFG_UpdatePlayerOnStudy			= Convert.ToBoolean( Config[ "CFG_UpdatePlayerOnStudy" 		]);
			CFG_UpdatePlayerVerbose 		= Convert.ToBoolean( Config[ "CFG_UpdatePlayerVerbose" 		]);
			MSG_AccessDenied 				= Convert.ToString(  Config[ "MSG_AccessDenied" 			]);
			MSG_CommandLine 				= Convert.ToString(  Config[ "MSG_CommandLine" 				]);
			MSG_Help 						= Convert.ToString(  Config[ "MSG_Help" 					]);
			MSG_Knows 						= Convert.ToString(  Config[ "MSG_Knows" 					]);
			MSG_KnowsThis 					= Convert.ToString(  Config[ "MSG_KnowsThis" 				]);
			MSG_KnowsCount 					= Convert.ToString(  Config[ "MSG_KnowsCount" 				]);
			MSG_KnowsNot 					= Convert.ToString(  Config[ "MSG_KnowsNot" 				]);
			MSG_LogWithArg 					= Convert.ToString(  Config[ "MSG_LogWithArg" 				]);
			MSG_LogNoArg 					= Convert.ToString(  Config[ "MSG_LogNoArg" 				]);
			MSG_MultiplePlayersFound 		= Convert.ToString(  Config[ "MSG_MultiplePlayersFound" 	]);
			MSG_PlayerNotFound 				= Convert.ToString(  Config[ "MSG_PlayerNotFound" 			]);
			MSG_What 						= Convert.ToString(  Config[ "MSG_What" 					]);
					
			if( CDVCheck != CDV )
				ConfigMismatch = true;
			
			if( ConfigMismatch && !ConfigMissing ){
			
				PrintWarning( "[OnServerInitialized] Existing configuration version mismatch found - updating for current version '" + CDV + "'" );
				LoadDefaultConfig();
								
				ConfigMismatch = false;
				ConfigMissing = false;
				
			}
			
			// Other variables initialization - Not Stored
			
			BPMax 			= CountBP();
			CRNL			= "\n";
			Player_BPKeys	= new List<int>();
			
			if( PlayerBPData == null ){
			
				PrintWarning( "[OnServerInitialized] BP Database not found, creating a new one" );
				new Data();
				
			} else
				PrintWarning( "[OnServerInitialized] Loading existing BP Database with " + PlayerBPData.PlayerBPData.Count + " player records" );
				
			SPC				= " ";
			SteamIDLength 	= 17;
				
		}
		
		private void UpdateDatabase( string PLAYERID, string PLAYERNAME ){
		
			//Debug( "[UpdateDatabase] Players currently stored in database: " + Convert.ToString( PlayerBPData.PlayerBPData.Count ));
			
			PlayerData UpdatedPlayerData 	= new PlayerData();
			UpdatedPlayerData.UserID 		= PLAYERID;
			UpdatedPlayerData.UserName 		= PLAYERNAME;			
			UpdatedPlayerData.BlueprintKeys = Player_BPKeys;			
			
			if( !PlayerOfflineData )
				UpdatedPlayerData.KnownBP 		= PlayerBPCount( PLAYERID, null ); // God I hope that null value doesn't come back to bite me in the arse
			else
				UpdatedPlayerData.KnownBP 		= Player_KnownBP;

			
			if( PlayerBPData.PlayerBPData.Count == 0 ){
			
				if( CFG_UpdatePlayerVerbose )
					PrintWarning( "[UpdateDatabase] Database empty. Adding first player entry: " + PLAYERID );
				
				PlayerBPData.PlayerBPData.Add( UpdatedPlayerData );
				
			} else {
			
				bool PlayerFound = false;
			
				for( int key = 0; key < PlayerBPData.PlayerBPData.Count; key++ ){
				
					if( PlayerBPData.PlayerBPData[ key ].UserID == PLAYERID ){

						//Debug( "[UpdateDatabase] Updating database for " + PLAYERID );
						PlayerBPData.PlayerBPData[ key ] = UpdatedPlayerData;
						PlayerFound = true;
						
					}

				}
				
				if( !PlayerFound ){

					if( CFG_UpdatePlayerVerbose )
						PrintWarning( "[UpdateDatabase] " + PLAYERID + " not found, adding to database" );				
						
					PlayerBPData.PlayerBPData.Add( UpdatedPlayerData );

				}
			
			}
			
			PlayerBPData.Version = CDV;
			Interface.Oxide.DataFileSystem.WriteObject( "BlueprintChecker", PlayerBPData );
				
		}
				
		private void UpdateKeyring( BasePlayer PLAYER, ref List<int> STATEKEYRING ){
		
			//Debug( "[UpdateKeyring] Started" );
			
			GetBPKeyState( PLAYER, ref Player_BPKeys );
					
		}
		
		private void UpdatePlayer( BasePlayer PLAYER ){
		
			Player_ID = PLAYER.UserIDString;
			Player_Name = PLAYER.displayName;
			
			//Debug( "[UpdatePlayer] Player_ID = " + Player_ID );
			
			UpdateKeyring( PLAYER, ref Player_BPKeys );
			UpdateDatabase( Player_ID, Player_Name );

		}
		
// [ PROTECTED FUNCTIONS ] -----------------------------------------------------

		protected override void LoadDefaultConfig() {
		
			if( !ConfigMismatch )
				ConfigMissing = true;
		
            if( ConfigMissing ){
			
				PrintWarning( "[LoadDefaultConfig] Configuration file not found - Creating a new one with default values." );
				Config.Clear();
				GetConfig( "CDV", CDV );
			
			} else
				Config[ "CDV" ] = CDV;
			
			// Create new configuration keys with default values
			
			GetConfig( "ARG_ListInScon", 				"listincon" 																	); 
			GetConfig( "ARG_ListInScon", 				"listincon" 																	); 
            GetConfig( "ARG_ListInChat", 				"listinchat" 																	);
            GetConfig( "ARG_Help",						"help" 																			);
            GetConfig( "ARG_Knows",						"knows" 																		);
            GetConfig( "CFG_AuthorityLevelRequired",	2 																				);
            GetConfig( "CFG_UpdatePlayerOnConnect", 	true 																			);
            GetConfig( "CFG_UpdatePlayerOnStudy",		true 																			);
            GetConfig( "CFG_UpdatePlayerVerbose",		true 																			);
            GetConfig( "MSG_AccessDenied",				"You are not allowed to use this command!" 										);
            GetConfig( "MSG_CommandLine", 				"\nType /bpcheck 'username or steamid' or\n\t     /bpcheck help for more info" 	);
			
            GetConfig( "MSG_Help", 						"/bpcheck 'username' : Count Known BPs\n/bpcheck 'username' knows 'itemname' : Confirm player has specific BP\n/bpcheck 'username' listinchat : Display known BPs in Chat\n/bpcheck 'username' listincon : Display known BPs in Server Console" );
			
			GetConfig( "MSG_Knows",						"Knows" 																		);
            GetConfig( "MSG_KnowsThis", 				"YES, '{0}' does know the {1} BP" 												);
            GetConfig( "MSG_KnowsCount", 				"'{0}' knows {1} of {2} BPs" 													);
            GetConfig( "MSG_KnowsNot", 					"NO, '{0}' does NOT know the {1} BP" 											);
            GetConfig( "MSG_LogWithArg", 				"{0} used /bpcheck {1}" 														);
            GetConfig( "MSG_LogNoArg", 					"{0} used /bpcheck" 															);
            GetConfig( "MSG_MultiplePlayersFound",		"Multiple Players Found - Please be more specific"								);
            GetConfig( "MSG_PlayerNotFound",			"Player '{0}' not online or found in database " 								);
            GetConfig( "MSG_What", 						"Um, what the hell is a '{0}'?" 												);
            
			SaveConfig();
				
        }
																				
    }
	
}

// --- End of file: BlueprintChecker.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/SafeHomes.cs ---
// --- Original Local Path: SafeHomes.cs ---

using System;
using Rust;
using System.Reflection;
using System.Collections.Generic;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
     [Info("SafeHomes", "Vypr/Phoenix", "1.0.0")]
     class SafeHomes : RustPlugin
     {
      	

         static DamageTypeList emptyDamage = new DamageTypeList();
      	//public bool playerBuild = player.CanBuild();
             /*public BasePlayer player;
 			public bool BuildingPrivilegeBool = player.CanBuild();*/
        //public player = it.Current:GetComponent("BasePlayer");
 


     	bool BuildingPrivilege(BasePlayer player)
		{
			if (player.CanBuild()) return false;
			return true;
		}

	 void CancelDamage(HitInfo hitinfo)
        {
            hitinfo.damageTypes = emptyDamage;
            hitinfo.HitEntity = null;
        }
		

     	void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
		  {
			      if(entity is BuildingBlock && info.Initiator is BasePlayer) {
              BasePlayer player = (BasePlayer) entity.ToPlayer();
              BasePlayer victim = (BasePlayer) info.Initiator;
               if(BuildingPrivilege(victim)){
                  CancelDamage(info);  
                  SendReply(victim, "ERROR: You do not have access to damage this.");
               }




            }

            
                      // CancelDamage(info);    
            
            
		  }


  }
        
}

// --- End of file: SafeHomes.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Clans (1).cs ---
// --- Original Local Path: Clans (1).cs ---

﻿using CompanionServer;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Plugins;
using ProtoBuf;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Clans", "k1lly0u", "3.0.24")]
    class Clans : RustPlugin
    {
        #region Fields
        [PluginReference] private Plugin DiscordClans;

        internal StoredData storedData;

        private bool wipeData;
        private bool isInitialized = false;
        private Coroutine initClansRoutine;

        private Regex tagFilter;
        private Regex hexFilter;

        private int[] customTagMinValue;
        private int[] customTagMaxValue;

        private HashSet<ulong> friendlyFireDisabled = new HashSet<ulong>();

        public static Clans Instance { get; private set; }

        private static DateTime Epoch = new DateTime(1970, 1, 1);
        private static double MaxUnixSeconds = (DateTime.MaxValue - Epoch).TotalSeconds;

        private const string COLORED_LABEL = "<color={0}>{1}</color>";

        private enum MessageType { Create, Invite, InviteReject, InviteWithdrawn, Join, Leave, Kick, Promote, Demote, Disband, AllianceInvite, AllianceInviteReject, AllianceInviteWithdrawn, AllianceAccept, AllianceWithdrawn, TeamChat, ClanChat, AllyChat }
        #endregion

        #region Oxide Hooks
        private void Loaded()
        {
            Instance = this;

            permission.RegisterPermission(configData.Permissions.PermissionCreate, this);
            permission.RegisterPermission(configData.Permissions.PermissionJoin, this);
            permission.RegisterPermission(configData.Permissions.PermissionLeave, this);
            permission.RegisterPermission(configData.Permissions.PermissionDisband, this);
            permission.RegisterPermission(configData.Permissions.PermissionKick, this);

            lang.RegisterMessages(Messages, this);

            cmd.AddChatCommand(configData.Commands.FFCommand, this, cmdClanFF);
            cmd.AddChatCommand(configData.Commands.AFFCommand, this, cmdAllyFF);
            cmd.AddChatCommand(configData.Commands.ClanCommand, this, cmdChatClan);
            cmd.AddChatCommand(configData.Commands.AllyChatCommand, this, cmdAllianceChat);
            cmd.AddChatCommand(configData.Commands.ClanChatCommand, this, cmdClanChat);
            cmd.AddChatCommand(configData.Commands.ClanInfoCommand, this, cmdChatClanInfo);
            cmd.AddChatCommand(configData.Commands.ClanHelpCommand, this, cmdChatClanHelp);
            cmd.AddChatCommand(configData.Commands.ClanAllyCommand, this, cmdChatClanAlly);

            _tags.Add(new KeyValuePair<string, string>(configData.Tags.TagOpen, configData.Tags.TagClose));

            tagFilter = new Regex($"[^a-zA-Z0-9{configData.Tags.AllowedCharacters}]");
            hexFilter = new Regex("^([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$");

            SetMinMaxColorRange();

            if (!configData.Tags.EnabledBC)
                Unsubscribe(nameof(OnPluginLoaded));

            if (!configData.Clans.MemberFF && !configData.Clans.Alliance.AllyFF)
                Unsubscribe(nameof(OnEntityTakeDamage));                        
           
            if (configData.Clans.Teams.Enabled)
                RelationshipManager.maxTeamSize = configData.Clans.MemberLimit;            

            LoadData();
        }

        private void OnServerInitialized()
        {
            initClansRoutine = ServerMgr.Instance.StartCoroutine(InitializeClans());
        }

        private void OnNewSave(string str) => wipeData = configData.Purge.WipeOnNewSave;

        private void OnServerSave() => SaveData();

        private void OnPluginLoaded(Plugin plugin)
        {
            if (configData.Tags.EnabledBC && plugin?.Title == "Better Chat")
                Interface.CallHook("API_RegisterThirdPartyTitle", this, new Func<Oxide.Core.Libraries.Covalence.IPlayer, string>(BetterChat_FormattedClanTag));
        }

        private void OnPlayerConnected(BasePlayer player)
        {            
            if (player.currentTeam != 0UL)
            {
                if (configData.Clans.Teams.Enabled)
                {
                    player.ClearTeam();
                    RelationshipManager.ServerInstance.playerToTeam.Remove(player.userID);
                }
                else
                {
                    RelationshipManager.PlayerTeam playerTeam = RelationshipManager.ServerInstance.FindTeam(player.currentTeam);                   
                    if (playerTeam == null || !playerTeam.members.Contains(player.userID))
                    {
                        player.ClearTeam();
                        RelationshipManager.ServerInstance.playerToTeam.Remove(player.userID);
                    }
                }
            }

            Clan clan = storedData?.FindClanByID(player.userID);
            if (clan != null)
            {
                clan.OnPlayerConnected(player);
            }
            else
            {
                List<string> invites;
                if (storedData.playerInvites.TryGetValue(player.userID, out invites))
                {
                    player.ChatMessage(string.Format(msg("Notification.PendingInvites", player.UserIDString), invites.ToSentence(), configData.Commands.ClanCommand));
                }
            }
        }

        private void OnPlayerDisconnected(BasePlayer player) => storedData?.FindClanByID(player.userID)?.OnPlayerDisconnected(player);

        private object OnPlayerChat(BasePlayer player, string message, ConVar.Chat.ChatChannel channel)
        {
            if (channel != ConVar.Chat.ChatChannel.Team)
                return null;

            Clan clan = storedData.FindClanByID(player.userID);
            if (clan == null)
                return null;

            if (configData.Options.DenyOnMuted)
            {                
                object success = Interface.CallHook("API_IsMuted", player.IPlayer);
                if ((success is bool && (bool)success) || player.HasPlayerFlag(BasePlayer.PlayerFlags.ChatMute))
                {
                    player.ChatMessage(msg("Chat.IsMuted", player.UserIDString));
                    return false;                    
                }
            }

            Instance.DiscordClans?.CallHook("LogMessage", $"{player.displayName} : {message}", (int)MessageType.TeamChat);

            Interface.CallHook("OnClanChat", player, message, clan.Tag);
            return null;
        }

        private object OnTeamCreate(BasePlayer player)
        {
            if (!configData.Clans.Teams.Enabled)
                return null;

            player.ChatMessage(msg("Notification.Create.NoNativeCreate", player.UserIDString));
            return true;
        }

        private object OnTeamKick(RelationshipManager.PlayerTeam playerTeam, BasePlayer player, ulong targetId)
        {
            if (!configData.Clans.Teams.Enabled || string.IsNullOrEmpty(playerTeam.teamName))
                return null;

            if (!configData.Clans.Teams.AllowKick)
                return false;

            KickPlayer(player, targetId);
            return true;
        }
        
        private object OnTeamInvite(BasePlayer player, BasePlayer other)
        {
            if (!configData.Clans.Teams.Enabled)
                return null;

            if (!configData.Clans.Teams.AllowInvite)
                return false;

            if (other != null && !other.userID.IsSteamId())            
                return false;
            
            InvitePlayer(player, other);
            return true;
        }

        private object OnTeamAcceptInvite(RelationshipManager.PlayerTeam playerTeam, BasePlayer player)
        {
            if (!configData.Clans.Teams.Enabled || string.IsNullOrEmpty(playerTeam.teamName))
                return null;

            JoinClan(player, playerTeam.teamName);
            return true;
        }

        private object OnTeamRejectInvite(BasePlayer player, RelationshipManager.PlayerTeam playerTeam)
        {
            if (!configData.Clans.Teams.Enabled || string.IsNullOrEmpty(playerTeam.teamName))
                return null;

            RejectInvite(player, playerTeam.teamName);
            return true;
        }

        private object OnTeamLeave(RelationshipManager.PlayerTeam playerTeam, BasePlayer player)
        {
            if (!configData.Clans.Teams.Enabled || string.IsNullOrEmpty(playerTeam.teamName))
                return null;

            if (!configData.Clans.Teams.AllowLeave)
                return false;

            LeaveClan(player);
            return true;
        }

        private object OnTeamPromote(RelationshipManager.PlayerTeam playerTeam, BasePlayer player)
        {
            if (!configData.Clans.Teams.Enabled || string.IsNullOrEmpty(playerTeam.teamName))
                return null;

            if (!configData.Clans.Teams.AllowPromote)
                return false;

            PromotePlayer(BasePlayer.FindByID(playerTeam.teamLeader), player.userID);
            return true;
        }

        private object OnTeamDisband(RelationshipManager.PlayerTeam playerTeam)
        {
            if (!configData.Clans.Teams.Enabled || string.IsNullOrEmpty(playerTeam.teamName))
                return null;

            Clan clan = storedData.FindClan(playerTeam.teamName);
            if (clan != null)
                clan.DisbandClan();

            return true;
        }
                
        private object OnEntityTakeDamage(BasePlayer player, HitInfo info)
        {
            if (player == null || info?.InitiatorPlayer == null)
                return null;

            if (player == info.InitiatorPlayer)
                return null;

            Clan victimClan = storedData.FindClanByID(player.userID);
            if (victimClan == null)
                return null;

            Clan attackerClan = storedData.FindClanByID(info.InitiatorPlayer.userID);
            if (attackerClan == null)
                return null;

            Clan.Member member = storedData.FindMemberByID(info.InitiatorPlayer.userID);
            if (member == null)
                return null;

            if (friendlyFireDisabled.Contains(player.userID))
                return null;

            if (victimClan.Tag.Equals(attackerClan.Tag) && configData.Clans.MemberFF && member.MemberFFEnabled)
            {
                member.OnClanMemberHit(string.Format(COLORED_LABEL, victimClan.GetRoleColor(player.userID), player.displayName));
                return true;
            }

            if (victimClan.IsAlliedClan(attackerClan.Tag) && configData.Clans.Alliance.Enabled && configData.Clans.Alliance.AllyFF && member.AllyFFEnabled)
            {
                member.OnAllyMemberHit(string.Format(COLORED_LABEL, victimClan.GetRoleColor(player.userID), player.displayName));
                return true;
            }

            return null;
        }

        private void Unload()
        {
            if (isInitialized)
            {
                SaveData();

                foreach (Clan clan in storedData.clans.Values)
                    clan.OnUnload();
            }
            else
            {
                if (initClansRoutine != null)
                    ServerMgr.Instance.StopCoroutine(initClansRoutine);
            }

            configData = null;
            Instance = null;
        }
        #endregion

        #region Functions
        private IEnumerator InitializeClans()
        {            
            Puts("Initializing Clans...");

            if (configData.Clans.Teams.Enabled)
            {
                RelationshipManager.ServerInstance.playerToTeam.Clear();

                foreach(KeyValuePair<ulong, RelationshipManager.PlayerTeam> kvp in RelationshipManager.ServerInstance.teams)
                {
                    RelationshipManager.PlayerTeam playerTeam = kvp.Value;
                    ClearTeam(ref playerTeam);
                }

                RelationshipManager.ServerInstance.teams.Clear();
                RelationshipManager.ServerInstance.lastTeamIndex = 1;
            }

            if (wipeData)
            {
                storedData.clans.Clear();
                storedData.playerInvites.Clear();
                SaveData();
            }
            else
            {
                List<string> purgedClans = Facepunch.Pool.GetList<string>();

                foreach (KeyValuePair<string, Clan> kvp in storedData.clans)
                {
                    Clan clan = kvp.Value;

                    if (clan.ClanMembers.Count == 0 || (configData.Purge.Enabled && UnixTimeStampUTC() - clan.LastOnlineTime > (configData.Purge.OlderThanDays * 86400)))
                    {
                        purgedClans.Add(kvp.Key);
                        continue;
                    }

                    if (configData.Clans.Alliance.Enabled)
                    {
                        for (int i = clan.AllianceInvites.Count - 1; i >= 0; i--)
                        {
                            KeyValuePair<string, double> allianceInvite = clan.AllianceInvites.ElementAt(i);

                            if (!storedData.clans.ContainsKey(allianceInvite.Key) || (UnixTimeStampUTC() - allianceInvite.Value > configData.Clans.Invites.AllianceInviteExpireTime))
                                clan.AllianceInvites.Remove(allianceInvite.Key);
                        }

                        for (int i = clan.Alliances.Count - 1; i >= 0; i--)
                        {
                            string allyTag = clan.Alliances.ElementAt(i);

                            if (!storedData.clans.ContainsKey(allyTag))
                                clan.Alliances.Remove(allyTag);
                        }
                    }

                    for (int i = clan.MemberInvites.Count - 1; i >= 0; i--)
                    {
                        KeyValuePair<ulong, Clan.MemberInvite> memberInvite = clan.MemberInvites.ElementAt(i);

                        if (UnixTimeStampUTC() - memberInvite.Value.ExpiryTime > configData.Clans.Invites.MemberInviteExpireTime)
                            clan.MemberInvites.Remove(memberInvite.Key);
                    }

                    foreach (KeyValuePair<ulong, Clan.Member> member in clan.ClanMembers)
                        storedData.RegisterPlayer(member.Key, clan.Tag);

                    if (configData.Permissions.PermissionGroups)
                        permission.CreateGroup(configData.Permissions.PermissionGroupPrefix + clan.Tag, "Clan " + clan.Tag, 0);

                    yield return null;
                }

                if (purgedClans.Count > 0)
                {
                    Puts($"Purging {purgedClans.Count} expired or invalid clans");

                    StringBuilder str = new StringBuilder();

                    for (int i = 0; i < purgedClans.Count; i++)
                    {
                        string tag = purgedClans[i];
                        Clan clan = storedData.clans[tag];
                        if (clan == null)
                            continue;

                        permission.RemoveGroup(configData.Permissions.PermissionGroupPrefix + clan.Tag);

                        str.Append($"{(i > 0 ? "\n" : "")}Purged - [{tag}] | {clan.Description} | Owner: {clan.OwnerID} | Last Online: {UnixTimeStampToDateTime(clan.LastOnlineTime)}");

                        storedData.clans.Remove(tag);
                    }

                    if (configData.Purge.ListPurgedClans)
                    {
                        Puts(str.ToString());

                        if (configData.Options.LogChanges)
                            LogToFile(Title, str.ToString(), this);
                    }
                }

                Puts($"Loaded {storedData.clans.Count} clans!");

                Facepunch.Pool.FreeList(ref purgedClans);
            }

            if (configData.Tags.EnabledBC)
                Interface.CallHook("API_RegisterThirdPartyTitle", this, new Func<Oxide.Core.Libraries.Covalence.IPlayer, string>(BetterChat_FormattedClanTag));

            isInitialized = true;
            initClansRoutine = null;

            foreach (BasePlayer player in BasePlayer.activePlayerList)
                OnPlayerConnected(player);            
        }
        #endregion

        #region Clan Tag Colors
        private void SetMinMaxColorRange()
        {
            customTagMinValue = new int[3];
            customTagMaxValue = new int[3];

            if (configData.Tags.CustomTagColorMin.StartsWith("#"))
                configData.Tags.CustomTagColorMin = configData.Tags.CustomTagColorMin.Substring(1);

            if (configData.Tags.CustomTagColorMax.StartsWith("#"))
                configData.Tags.CustomTagColorMax = configData.Tags.CustomTagColorMax.Substring(1);

            customTagMinValue[0] = int.Parse(configData.Tags.CustomTagColorMin.Substring(0, 2), NumberStyles.AllowHexSpecifier);
            customTagMinValue[1] = int.Parse(configData.Tags.CustomTagColorMin.Substring(2, 2), NumberStyles.AllowHexSpecifier);
            customTagMinValue[2] = int.Parse(configData.Tags.CustomTagColorMin.Substring(3, 2), NumberStyles.AllowHexSpecifier);

            customTagMaxValue[0] = int.Parse(configData.Tags.CustomTagColorMax.Substring(0, 2), NumberStyles.AllowHexSpecifier);
            customTagMaxValue[1] = int.Parse(configData.Tags.CustomTagColorMax.Substring(2, 2), NumberStyles.AllowHexSpecifier);
            customTagMaxValue[2] = int.Parse(configData.Tags.CustomTagColorMax.Substring(3, 2), NumberStyles.AllowHexSpecifier);
        }

        private bool TagColorIsBlocked(string color)
        {
            if (color.StartsWith("#"))
                color = color.Substring(1);

            if (configData.Tags.BlockedTagColors.Contains(color, TagEqualityComparer.Instance))
                return true;

            return false;
        }

        private bool TagColorWithinRange(string color)
        {
            if (color.StartsWith("#"))
                color = color.Substring(1);

            int red = int.Parse(color.Substring(0, 2), NumberStyles.AllowHexSpecifier);
            int green = int.Parse(color.Substring(2, 2), NumberStyles.AllowHexSpecifier);
            int blue = int.Parse(color.Substring(4, 2), NumberStyles.AllowHexSpecifier);

            return red >= customTagMinValue[0] && red <= customTagMaxValue[0] &&
                   green >= customTagMinValue[1] && green <= customTagMaxValue[1] &&
                   blue >= customTagMinValue[2] && blue <= customTagMaxValue[2];
        }     
        
        public class TagEqualityComparer : IEqualityComparer<string>
        {
            private static TagEqualityComparer _instance;
            public static TagEqualityComparer Instance 
            { 
                get
                {
                    if (_instance == null)
                        _instance = new TagEqualityComparer();
                    return _instance;
                } 
            }

            public bool Equals(string a, string b)
            {
                return a.Equals(b, StringComparison.OrdinalIgnoreCase);
            }

            public int GetHashCode(string obj)
            {
                return obj.GetHashCode();
            }
        }
        #endregion

        #region Helpers
        private string BetterChat_FormattedClanTag(Oxide.Core.Libraries.Covalence.IPlayer player)
        {
            Clan clan = storedData.FindClanByID(player.Id);
            if (clan == null)
                return string.Empty;

            return $"[#{(string.IsNullOrEmpty(clan.TagColor) || !configData.Tags.CustomColors ? configData.Tags.TagColor.Replace("#", "") : clan.TagColor.Replace("#", ""))}][+{configData.Tags.TagSize}]{configData.Tags.TagOpen}{clan.Tag}{configData.Tags.TagClose}[/+][/#]";
        }

        private static int UnixTimeStampUTC() => (int)DateTime.UtcNow.Subtract(Epoch).TotalSeconds;

        private static DateTime UnixTimeStampToDateTime(double unixTimeStamp)
        {
            return unixTimeStamp > MaxUnixSeconds
                ? Epoch.AddMilliseconds(unixTimeStamp)
                : Epoch.AddSeconds(unixTimeStamp);
        }

        private bool ContainsBlockedWord(string tag)
        {
            for (int i = 0; i < configData.Tags.BlockedWords.Length; i++)
            {
                if (TranslateLeet(tag).ToLower().Contains(configData.Tags.BlockedWords[i].ToLower()))
                    return true;
            }
            return false;
        }

        private string TranslateLeet(string original)
        {
            string translated = original;

            foreach (KeyValuePair<string, string> leet in leetTable)
                translated = translated.Replace(leet.Key, leet.Value);
            return translated;
        }

        private bool ClanTagExists(string tag)
        {
            ICollection<string> collection = storedData.clans.Keys;
            for (int i = 0; i < collection.Count; i++)
            {
                if (collection.ElementAt(i).Equals(tag, StringComparison.OrdinalIgnoreCase))
                    return true;
            }

            return false;
        }

        private string FormatTime(double time)
        {
            TimeSpan dateDifference = TimeSpan.FromSeconds((float)time);
            int days = dateDifference.Days;
            int hours = dateDifference.Hours + (days * 24);

            int mins = dateDifference.Minutes;
            int secs = dateDifference.Seconds;

            if (hours > 0)
                return string.Format("{0:00}h:{1:00}m:{2:00}s", hours, mins, secs);
            else if (mins > 0)
                return string.Format("{0:00}m:{1:00}s", mins, secs);
            else return string.Format("{0:00}s", secs);
        }

        private BasePlayer FindPlayer(string partialNameOrID) => BasePlayer.allPlayerList.FirstOrDefault<BasePlayer>((BasePlayer x) => x.displayName.Equals(partialNameOrID, StringComparison.OrdinalIgnoreCase)) ?? 
                                                                 BasePlayer.allPlayerList.FirstOrDefault<BasePlayer>((BasePlayer x) => x.displayName.Contains(partialNameOrID, CompareOptions.OrdinalIgnoreCase)) ??
                                                                 BasePlayer.allPlayerList.FirstOrDefault<BasePlayer>((BasePlayer x) => x.UserIDString == partialNameOrID);

        private static void RemoveFromTeam(RelationshipManager.PlayerTeam playerTeam, BasePlayer player)
        {
            playerTeam.members.Remove(player.userID);
            RelationshipManager.ServerInstance.playerToTeam.Remove(player.userID);
            
            player.ClearTeam();
        }

        private static void RemoveFromTeam(RelationshipManager.PlayerTeam playerTeam, ulong playerId)
        {
            playerTeam.members.Remove(playerId);
            RelationshipManager.ServerInstance.playerToTeam.Remove(playerId);

            RelationshipManager.FindByID(playerId)?.ClearTeam();
        }

        private static void ClearTeam(ref RelationshipManager.PlayerTeam playerTeam)
        {
            playerTeam.invites.Clear();
            playerTeam.members.Clear();
            playerTeam.onlineMemberConnections.Clear();
            playerTeam.teamID = 0UL;
            playerTeam.teamLeader = 0UL;
            playerTeam.teamName = string.Empty;

            Facepunch.Pool.Free(ref playerTeam);
        }

        private static string RemoveTags(string str)
        {
            foreach (KeyValuePair<string, string> kvp in _tags)
            {
                if (str.StartsWith(kvp.Key) && str.Contains(kvp.Value) && str.Length > str.IndexOf(kvp.Value))
                {
                    str = str.Substring(str.IndexOf(kvp.Value) + 1).Trim();
                }
            }
            return str;
        }

        private static List<KeyValuePair<string, string>> _tags = new List<KeyValuePair<string, string>>
        {
            new KeyValuePair<string, string>("[", "]"),
            new KeyValuePair<string, string>("{", "}"),
            new KeyValuePair<string, string>("(", ")"),
            new KeyValuePair<string, string>("<", ">"),
        };
        #endregion

        #region Clan Management        
        internal void CreateClan(BasePlayer player, string tag, string description)
        {
            if (player == null)
                return;

            if (storedData.FindClanByID(player.userID) != null)
            {
                player.ChatMessage(msg("Notification.Create.InExistingClan", player.UserIDString));
                return;
            }

            if (configData.Permissions.UsePermissionCreate && !permission.UserHasPermission(player.UserIDString, configData.Permissions.PermissionCreate))
            {
                player.ChatMessage(msg("Notification.Create.NoPermission", player.UserIDString));
                return;
            }

            if (tag.Length < configData.Tags.TagLength.Minimum || tag.Length > configData.Tags.TagLength.Maximum)
            {
                player.ChatMessage(string.Format(msg("Notification.Create.InvalidTagLength", player.UserIDString), configData.Tags.TagLength.Minimum, configData.Tags.TagLength.Maximum));
                return;
            }

            if (tagFilter.IsMatch(tag) || ContainsBlockedWord(tag))
            {
                player.ChatMessage(msg("Notification.Create.InvalidCharacters", player.UserIDString));
                return;
            }

            if (ClanTagExists(tag))
            {
                player.ChatMessage(msg("Notification.Create.ClanExists", player.UserIDString));
                return;
            }

            if (configData.Clans.Teams.Enabled && player.currentTeam != 0UL)
            {
                RelationshipManager.PlayerTeam playerTeam = RelationshipManager.ServerInstance.FindTeam(player.currentTeam);
                if (playerTeam != null)                
                    RemoveFromTeam(playerTeam, player);                

                RelationshipManager.ServerInstance.playerToTeam.Remove(player.userID);
                player.ClearTeam();
            }

            storedData.clans[tag] = new Clan(player, tag, description);
            storedData.RegisterPlayer(player.userID, tag);

            player.ChatMessage(string.Format(msg("Notification.Create.Success", player.UserIDString), tag));

            Interface.CallHook("OnClanCreate", tag);

            if (configData.Options.LogChanges)
                LogToFile(Title, $"{player.displayName} created the clan [{tag}]", this);

            DiscordClans?.CallHook("LogMessage", $"{player.displayName} has created the clan {tag}", (int)MessageType.Create);
        }

        internal bool InvitePlayer(BasePlayer inviter, ulong targetId)
        {
            BasePlayer invitee = (covalence.Players.FindPlayerById(targetId.ToString())?.Object as BasePlayer) ?? null;
            if (invitee == null)
            {
                inviter.ChatMessage(string.Format(msg("Notification.Generic.UnableToFindPlayer", inviter.UserIDString), targetId));
                return false;
            }

            return InvitePlayer(inviter, invitee);
        }

        internal bool InvitePlayer(BasePlayer inviter, BasePlayer invitee)
        {
            if (inviter == null || invitee == null)
                return false;
                       
            Clan clan = storedData.FindClanByID(inviter.userID);
            if (clan == null)
            {
                inviter.ChatMessage(msg("Notification.Generic.NoClan", inviter.UserIDString));
                return false;
            }

            Clan other = storedData.FindClanByID(invitee.userID);
            if (other != null)
            {
                inviter.ChatMessage(string.Format(msg("Notification.Invite.InClan", inviter.UserIDString), invitee.displayName));
                return false;
            }

            if (configData.Permissions.UsePermissionJoin && !permission.UserHasPermission(invitee.UserIDString, configData.Permissions.PermissionJoin))
            {
                inviter.ChatMessage(msg("Notification.Invite.NoPermission", inviter.UserIDString));
                return false;
            }
            
            return clan.InvitePlayer(inviter, invitee);
        }

        internal bool WithdrawInvite(BasePlayer player, string partialNameOrID)
        {
            if (player == null)
                return false;

            Clan clan = storedData.FindClanByID(player.userID);
            if (clan == null)
            {
                player.ChatMessage(msg("Notification.Generic.NoClan", player.UserIDString));
                return false;
            }

            if (!clan.IsOwner(player.userID) && !clan.IsModerator(player.userID) && !clan.IsCouncil(player.userID))
            {
                player.ChatMessage(msg("Notification.WithdrawInvite.NoPermissions", player.UserIDString));
                return false;
            }

            ulong targetId;
            if (!ulong.TryParse(partialNameOrID, out targetId))
                targetId = 0UL;

            foreach(KeyValuePair<ulong, Clan.MemberInvite> invite in clan.MemberInvites)
            {
                if ((targetId != 0UL && targetId.Equals(invite.Key)) || invite.Value.DisplayName.Contains(partialNameOrID))
                {
                    storedData.RevokePlayerInvite(targetId, clan.Tag);

                    clan.MemberInvites.Remove(invite.Key);
                    clan.Broadcast("Notification.WithdrawInvite.Success", player.displayName, invite.Value.DisplayName);

                    DiscordClans?.CallHook("LogMessage", $"{player.displayName} has withdrawn a clan invite for {invite.Value.DisplayName}", (int)MessageType.InviteWithdrawn);
                    return true;
                }
            }

            if (configData.Clans.Teams.Enabled)
                player.ClearPendingInvite();

            player.ChatMessage(string.Format(msg("Notification.WithdrawInvite.UnableToFind", player.UserIDString), partialNameOrID));
            return false;
        }

        internal bool RejectInvite(BasePlayer player, string tag)
        {
            if (player == null)
                return false;

            Clan clan = storedData.FindClan(tag);
            if (clan == null)
            {
                player.ChatMessage(string.Format(msg("Notification.Generic.InvalidClan", player.UserIDString), tag));
                return false;
            }

            if (!clan.MemberInvites.ContainsKey(player.userID))
            {
                player.ChatMessage(string.Format(msg("Notification.RejectInvite.InvalidInvite", player.UserIDString), tag));
                return false;
            }

            clan.MemberInvites.Remove(player.userID);

            storedData.OnInviteRejected(player.userID, clan.Tag);

            if (configData.Clans.Teams.Enabled)            
                clan.PlayerTeam.RejectInvite(player);
            
            clan.Broadcast("Notification.RejectInvite.Message", player.displayName);
            player.ChatMessage(string.Format(msg("Notification.RejectInvite.PlayerMessage", player.UserIDString), tag));

            if (configData.Options.LogChanges)
                Instance.LogToFile(Instance.Title, $"{player.displayName} rejected their invite to [{tag}]", Instance);

            return true;
        }

        internal bool JoinClan(BasePlayer player, string tag)
        {
            if (player == null || string.IsNullOrEmpty(tag))
                return false;

            if (configData.Permissions.UsePermissionJoin && !permission.UserHasPermission(player.UserIDString, configData.Permissions.PermissionJoin))
            {
                player.ChatMessage(msg("Notification.Join.NoPermission", player.UserIDString));
                return false;
            }

            Clan clan = storedData.FindClanByID(player.userID);
            if (clan != null)
            {
                player.ChatMessage(msg("Notification.Join.InExistingClan", player.UserIDString));
                return false;
            }

            clan = storedData.FindClan(tag);
            if (clan == null)
                return false;

            return clan.JoinClan(player);
        }

        internal bool LeaveClan(BasePlayer player)
        {
            if (player == null)
                return false;

            Clan clan = storedData.FindClanByID(player.userID);
            if (clan == null)
            {
                player.ChatMessage(msg("Notification.Generic.NoClan", player.UserIDString));
                return false;
            }

            if (configData.Permissions.UsePermissionLeave && !permission.UserHasPermission(player.UserIDString, configData.Permissions.PermissionLeave))
            {
                player.ChatMessage(msg("Notification.Leave.NoPermission", player.UserIDString));
                return false;
            }

            return clan.LeaveClan(player);
        }

        internal bool KickPlayer(BasePlayer player, ulong playerId)
        {
            if (player == null)
                return false;

            Clan clan = storedData.FindClanByID(player.userID);
            if (clan == null)
            {
                player.ChatMessage(msg("Notification.Generic.NoClan", player.UserIDString));
                return false;
            }

            if (configData.Permissions.UsePermissionKick && !permission.UserHasPermission(player.UserIDString, configData.Permissions.PermissionKick))
            {
                player.ChatMessage(msg("Notification.Kick.NoPermission", player.UserIDString));
                return false;
            }

            return clan.KickMember(player, playerId);
        }

        internal bool PromotePlayer(BasePlayer promoter, ulong targetId)
        {
            if (promoter == null)
                return false;

            Clan clan = storedData.FindClanByID(promoter.userID);
            if (clan == null)
            {
                promoter.ChatMessage(msg("Notification.Generic.NoClan", promoter.UserIDString));
                return false;
            }

            Clan other = storedData.FindClanByID(targetId);
            if (other == null || !clan.Tag.Equals(other.Tag))
            {
                string displayName = covalence.Players.FindPlayer(targetId.ToString())?.Name ?? targetId.ToString();

                promoter.ChatMessage(string.Format(msg("Notification.Promotion.TargetNoClan", promoter.UserIDString), displayName));
                return false;
            }

            return clan.PromotePlayer(promoter, targetId);
        }

        internal bool DemotePlayer(BasePlayer demoter, ulong targetId)
        {
            if (demoter == null)
                return false;

            Clan clan = storedData.FindClanByID(demoter.userID);
            if (clan == null)
            {
                demoter.ChatMessage(msg("Notification.Generic.NoClan", demoter.UserIDString));
                return false;
            }

            Clan other = storedData.FindClanByID(targetId);
            if (other == null || !clan.Tag.Equals(other.Tag))
            {
                string displayName = covalence.Players.FindPlayer(targetId.ToString())?.Name ?? targetId.ToString();

                demoter.ChatMessage(string.Format(msg("Notification.Promotion.TargetNoClan", demoter.UserIDString), displayName));
                return false;
            }

            return clan.DemotePlayer(demoter, targetId);
        }

        internal bool DisbandClan(BasePlayer player)
        {
            Clan clan = storedData.FindClanByID(player.userID);

            if (clan == null)
            {
                player.ChatMessage(msg("Notification.Generic.NoClan", player.UserIDString));
                return false;
            }

            if (!clan.IsOwner(player.userID))
            {
                player.ChatMessage(msg("Notification.Disband.NotOwner", player.UserIDString));
                return false;
            }

            if (configData.Permissions.UsePermissionDisband && !permission.UserHasPermission(player.UserIDString, configData.Permissions.PermissionDisband))
            {
                player.ChatMessage(msg("Notification.Disband.NoPermission", player.UserIDString));
                return false;
            }

            string tag = clan.Tag;

            clan.Broadcast("Notification.Disband.Message", Array.Empty<object>());
            clan.DisbandClan();

            player.ChatMessage(string.Format(msg("Notification.Disband.Success", player.UserIDString), tag));

            return true;
        }
        #endregion

        #region Alliance Management
        internal bool OfferAlliance(BasePlayer player, string tag)
        {
            if (!configData.Clans.Alliance.Enabled)
                return false;

            Clan clan = storedData.FindClanByID(player.userID);
            if (clan == null)
            {
                player.ChatMessage(msg("Notification.Generic.NoClan", player.UserIDString));
                return false;
            }

            Clan alliedClan = storedData.FindClan(tag);
            if (alliedClan == null)
            {
                player.ChatMessage(string.Format(msg("Notification.Generic.InvalidClan", player.UserIDString), tag));
                return false;
            }

            if (!clan.IsOwner(player.userID) && !clan.IsCouncil(player.userID))
            {
                player.ChatMessage(msg("Notification.Alliance.NoPermissions", player.UserIDString));
                return false;
            }

            if (clan.AllianceInvites.ContainsKey(tag) && (UnixTimeStampUTC() - clan.AllianceInvites[tag] < configData.Clans.Invites.AllianceInviteExpireTime))
            {
                player.ChatMessage(string.Format(msg("Notification.Alliance.PendingInvite", player.UserIDString), tag));
                return false;
            }

            if (clan.AllianceInviteCount >= configData.Clans.Invites.AllianceInviteLimit)
            {
                player.ChatMessage(msg("Notification.Alliance.MaximumInvites", player.UserIDString));
                return false;
            }

            if (clan.AllianceCount >= configData.Clans.Alliance.AllianceLimit)
            {
                player.ChatMessage(msg("Notification.Alliance.MaximumAlliances", player.UserIDString));
                return false;
            }

            clan.AllianceInvites[tag] = UnixTimeStampUTC();
            alliedClan.IncomingAlliances.Add(clan.Tag);

            player.ChatMessage(string.Format(msg("Notification.Alliance.InviteSent", player.UserIDString), tag, FormatTime(configData.Clans.Invites.AllianceInviteExpireTime)));

            alliedClan.Broadcast("Notification.Alliance.InviteReceived", clan.Tag, FormatTime(configData.Clans.Invites.AllianceInviteExpireTime), configData.Commands.ClanAllyCommand);

            Instance.DiscordClans?.CallHook("LogMessage", $"{player.displayName} has offered an alliance to [{tag}]", (int)MessageType.AllianceInvite);
            return true;
        }

        internal bool WithdrawAlliance(BasePlayer player, string tag)
        {
            if (!configData.Clans.Alliance.Enabled)
                return false;

            Clan clan = storedData.FindClanByID(player.userID);
            if (clan == null)
            {
                player.ChatMessage(msg("Notification.Generic.NoClan", player.UserIDString));
                return false;
            }

            Clan alliedClan = storedData.FindClan(tag);
            if (alliedClan == null)
            {
                player.ChatMessage(string.Format(msg("Notification.Generic.InvalidClan", player.UserIDString), tag));
                return false;
            }

            if (!clan.IsOwner(player.userID) && !clan.IsCouncil(player.userID))
            {
                player.ChatMessage(msg("Notification.Alliance.NoPermissions", player.UserIDString));
                return false;
            }

            if (!clan.AllianceInvites.ContainsKey(tag))
            {
                player.ChatMessage(string.Format(msg("Notification.Alliance.NoActiveInvite", player.UserIDString), tag));
                return false;
            }

            clan.AllianceInvites.Remove(tag);
            alliedClan.IncomingAlliances.Remove(clan.Tag);

            clan.Broadcast("Notification.Alliance.WithdrawnClan", player.displayName, tag);
            alliedClan.Broadcast("Notification.Alliance.WithdrawnTarget", clan.Tag);

            clan.MarkDirty();

            Instance.DiscordClans?.CallHook("LogMessage", $"{player.displayName} has withdrawn their alliance offer to [{tag}]", (int)MessageType.AllianceInviteWithdrawn);
            return true;
        }

        internal bool AcceptAlliance(BasePlayer player, string tag)
        {
            if (!configData.Clans.Alliance.Enabled)
                return false;

            Clan clan = storedData.FindClanByID(player.userID);
            if (clan == null)
            {
                player.ChatMessage(msg("Notification.Generic.NoClan", player.UserIDString));
                return false;
            }

            Clan alliedClan = storedData.FindClan(tag);
            if (alliedClan == null)
            {
                player.ChatMessage(string.Format(msg("Notification.Generic.InvalidClan", player.UserIDString), tag));
                return false;
            }

            if (!clan.IsOwner(player.userID) && !clan.IsCouncil(player.userID))
            {
                player.ChatMessage(msg("Notification.Alliance.NoPermissions", player.UserIDString));
                return false;
            }

            bool noActiveInvite = false;
            if (!alliedClan.AllianceInvites.ContainsKey(clan.Tag))
                noActiveInvite = true;

            if ((UnixTimeStampUTC() - alliedClan.AllianceInvites[clan.Tag] > configData.Clans.Invites.AllianceInviteExpireTime))
            {
                alliedClan.AllianceInvites.Remove(clan.Tag);
                noActiveInvite = true;
            }

            if (noActiveInvite)
            {
                player.ChatMessage(string.Format(msg("Notification.Alliance.NoActiveInviteFrom", player.UserIDString), tag));
                return false;
            }

            if (alliedClan.AllianceCount >= configData.Clans.Alliance.AllianceLimit)
            {
                player.ChatMessage(string.Format(msg("Notification.Alliance.AtLimitTarget", player.UserIDString), tag));
                return false;
            }

            if (clan.AllianceCount >= configData.Clans.Alliance.AllianceLimit)
            {
                player.ChatMessage(string.Format(msg("Notification.Alliance.AtLimitSelf", player.UserIDString), tag));
                return false;
            }

            clan.Alliances.Add(tag);
            clan.IncomingAlliances.Remove(tag);

            alliedClan.Alliances.Add(clan.Tag);
            alliedClan.AllianceInvites.Remove(clan.Tag);

            clan.MarkDirty();
            alliedClan.MarkDirty();

            clan.Broadcast("Notification.Alliance.Formed", clan.Tag, alliedClan.Tag);
            alliedClan.Broadcast("Notification.Alliance.Formed", clan.Tag, alliedClan.Tag);

            Interface.Oxide.CallHook("OnClanUpdate", clan.Tag);
            Interface.Oxide.CallHook("OnClanUpdate", alliedClan.Tag);

            Instance.DiscordClans?.CallHook("LogMessage", $"{player.displayName} has accepted a alliance offer from [{tag}]", (int)MessageType.AllianceAccept);

            return true;
        }

        internal bool RejectAlliance(BasePlayer player, string tag)
        {
            if (!configData.Clans.Alliance.Enabled)
                return false;

            Clan clan = storedData.FindClanByID(player.userID);
            if (clan == null)
            {
                player.ChatMessage(string.Format(msg("Notification.Generic.InvalidClan", player.UserIDString), tag));
                return false;
            }

            Clan alliedClan = storedData.FindClan(tag);
            if (alliedClan == null)
            {
                player.ChatMessage(msg("Notification.Generic.InvalidClan", player.UserIDString));
                return false;
            }

            if (!clan.IsOwner(player.userID) && !clan.IsCouncil(player.userID))
            {
                player.ChatMessage(msg("Notification.Alliance.NoPermissions", player.UserIDString));
                return false;
            }

            if (!alliedClan.AllianceInvites.ContainsKey(clan.Tag) || (UnixTimeStampUTC() - alliedClan.AllianceInvites[clan.Tag] > configData.Clans.Invites.AllianceInviteExpireTime))
            {
                player.ChatMessage(string.Format(msg("Notification.Alliance.NoActiveInvite", player.UserIDString), tag));
                return false;
            }

            clan.IncomingAlliances.Remove(tag);

            alliedClan.AllianceInvites.Remove(clan.Tag);
            alliedClan.MarkDirty();

            clan.Broadcast("Notification.Alliance.Rejected", clan.Tag, alliedClan.Tag);
            alliedClan.Broadcast("Notification.Alliance.Rejected", clan.Tag, alliedClan.Tag);

            Instance.DiscordClans?.CallHook("LogMessage", $"{player.displayName} has rejected a alliance offer from [{tag}]", (int)MessageType.AllianceInviteReject);
            return true;
        }

        internal bool RevokeAlliance(BasePlayer player, string tag)
        {
            if (!configData.Clans.Alliance.Enabled)
                return false;

            Clan clan = storedData.FindClanByID(player.userID);
            if (clan == null)
            {
                player.ChatMessage(string.Format(msg("Notification.Generic.InvalidClan", player.UserIDString), tag));
                return false;
            }

            Clan alliedClan = storedData.FindClan(tag);
            if (alliedClan == null)
            {
                player.ChatMessage(msg("Notification.Generic.InvalidClan", player.UserIDString));
                return false;
            }

            if (!clan.IsOwner(player.userID) && !clan.IsCouncil(player.userID))
            {
                player.ChatMessage(msg("Notification.Alliance.NoPermissions", player.UserIDString));
                return false;
            }

            if (!clan.Alliances.Contains(alliedClan.Tag))
            {
                player.ChatMessage(string.Format(msg("Notification.Alliance.NoActiveAlliance", player.UserIDString), alliedClan.Tag));
                return false;
            }

            alliedClan.Alliances.Remove(clan.Tag);
            clan.Alliances.Remove(alliedClan.Tag);

            alliedClan.MarkDirty();
            clan.MarkDirty();

            clan.Broadcast("Notification.Alliance.Revoked", clan.Tag, alliedClan.Tag);
            alliedClan.Broadcast("Notification.Alliance.Revoked", clan.Tag, alliedClan.Tag);

            Instance.DiscordClans?.CallHook("LogMessage", $"{player.displayName} has withdrawn their alliance to [{tag}]", (int)MessageType.AllianceWithdrawn);
            return true;
        }
        #endregion

        #region Chat
        private void ClanChat(BasePlayer player, string message)
        {
            if (player == null)
                return;

            Clan clan = storedData.FindClanByID(player.userID);
            if (clan == null)
                return;

            if (configData.Options.DenyOnMuted)
            {
                object success = Interface.CallHook("API_IsMuted", player.IPlayer);
                if ((success is bool && (bool)success) || player.HasPlayerFlag(BasePlayer.PlayerFlags.ChatMute))
                {
                    player.ChatMessage(msg("Chat.IsMuted", player.UserIDString));
                    return;
                }
            }

            string str = string.Format(msg("Chat.Alliance.Format"), clan.Tag, clan.GetRoleColor(player.userID), player.net.connection.username, message);

            clan.Broadcast(string.Format(msg("Chat.Clan.Prefix"), str));

            if (ConVar.Chat.serverlog)
            {
                ServerConsole.PrintColoured(ConsoleColor.White, "[CLAN] ", ConsoleColor.DarkYellow, player.displayName + ": ", ConsoleColor.DarkGreen, message);
                DebugEx.Log(string.Format("[CLAN CHAT] {0}", str));
            }

            Instance.DiscordClans?.CallHook("LogMessage", $"{player.displayName} : {message}", (int)MessageType.ClanChat);

            Interface.CallHook("OnClanChat", player, message, clan.Tag);
        }

        private void AllianceChat(BasePlayer player, string message)
        {
            Clan clan = storedData.FindClanByID(player.userID);
            if (clan == null)
                return;

            if (configData.Options.DenyOnMuted)
            {
                object success = Interface.CallHook("API_IsMuted", player.IPlayer);
                if ((success is bool && (bool)success) || player.HasPlayerFlag(BasePlayer.PlayerFlags.ChatMute))
                {
                    player.ChatMessage(msg("Chat.IsMuted", player.UserIDString));
                    return;
                }
            }

            string str = string.Format(msg("Chat.Alliance.Format"), clan.Tag, clan.GetRoleColor(player.userID), player.net.connection.username, message);

            clan.Broadcast(string.Format(msg("Chat.Alliance.Prefix"), str));

            for (int i = 0; i < clan.AllianceCount; i++)
            {
                Clan alliedClan = storedData.FindClan(clan.Alliances.ElementAt(i));
                if (alliedClan != null)
                {
                    alliedClan.Broadcast(string.Format(msg("Chat.Alliance.Prefix"), str));                                   
                }
            }

            if (ConVar.Chat.serverlog)
            {
                ServerConsole.PrintColoured(ConsoleColor.White, "[ALLY] ", ConsoleColor.DarkYellow, player.displayName + ": ", ConsoleColor.DarkGreen, message);
                DebugEx.Log(string.Format("[ALLY CHAT] {0}", str));
            }

            Instance.DiscordClans?.CallHook("LogMessage", $"{player.displayName} : {message}", (int)MessageType.AllyChat);

            Interface.CallHook("OnAllianceChat", player, message, clan.Tag);
        }
        #endregion

        #region Chat Commands
        private void cmdAllianceChat(BasePlayer player, string command, string[] args)
        {
            if (!configData.Clans.Alliance.Enabled || args.Length == 0)
                return;

            AllianceChat(player, string.Join(" ", args));
        }

        private void cmdClanChat(BasePlayer player, string command, string[] args)
        {
            if (args.Length == 0)
                return;

            ClanChat(player, string.Join(" ", args));
        }

        private void cmdClanFF(BasePlayer player, string command, string[] args)
        {
            if (!configData.Clans.MemberFF)
                return;

            Clan.Member member = storedData.FindMemberByID(player.userID);
            if (member == null)
                return;

            if (configData.Clans.OwnerFF && member.Role >= Clan.Member.MemberRole.Moderator)
            {
                player.ChatMessage(msg("Notification.FF.ToggleNotOwner", player.UserIDString));
                return;
            }

            member.MemberFFEnabled = !member.MemberFFEnabled;

            if (configData.Clans.OwnerFF)
            {
                Clan clan = storedData.FindClanByID(player.userID);

                foreach(KeyValuePair<ulong, Clan.Member> kvp in clan.ClanMembers)
                {
                    if (kvp.Key.Equals(player.userID))
                        continue;

                    kvp.Value.MemberFFEnabled = member.MemberFFEnabled;

                    BasePlayer memberPlayer = kvp.Value.Player;

                    if (memberPlayer != null && memberPlayer.IsConnected)
                    {
                        memberPlayer.ChatMessage(string.Format(msg("Notification.FF.OwnerToggle", memberPlayer.UserIDString),
                            string.Format(COLORED_LABEL, clan.GetRoleColor(member.Role), player.displayName),
                            !kvp.Value.MemberFFEnabled ? msg("Notification.FF.MemberEnabled", memberPlayer.UserIDString) : msg("Notification.FF.MemberDisabled", memberPlayer.UserIDString)));
                    }
                }
            }

            player.ChatMessage(!member.MemberFFEnabled ? msg("Notification.FF.MemberEnabled", player.UserIDString) : msg("Notification.FF.MemberDisabled", player.UserIDString));
        }

        private void cmdAllyFF(BasePlayer player, string command, string[] args)
        {
            if (!configData.Clans.Alliance.AllyFF || !configData.Clans.Alliance.Enabled)
                return;

            Clan.Member member = storedData.FindMemberByID(player.userID);
            if (member == null)
                return;

            if (configData.Clans.Alliance.OwnerFF && member.Role >= Clan.Member.MemberRole.Moderator)
            {
                player.ChatMessage(msg("Notification.FF.ToggleNotOwner", player.UserIDString));
                return;
            }

            member.AllyFFEnabled = !member.AllyFFEnabled;

            if (configData.Clans.Alliance.OwnerFF)
            {
                Clan clan = storedData.FindClanByID(player.userID);

                foreach (KeyValuePair<ulong, Clan.Member> kvp in clan.ClanMembers)
                {
                    if (kvp.Key.Equals(player.userID))
                        continue;

                    kvp.Value.AllyFFEnabled = member.AllyFFEnabled;

                    BasePlayer memberPlayer = kvp.Value.Player;

                    if (memberPlayer != null && memberPlayer.IsConnected)
                    {
                        memberPlayer.ChatMessage(string.Format(msg("Notification.FF.OwnerAllyToggle", memberPlayer.UserIDString),
                            string.Format(COLORED_LABEL, clan.GetRoleColor(member.Role), player.displayName),
                            !kvp.Value.MemberFFEnabled ? msg("Notification.FF.MemberEnabled", memberPlayer.UserIDString) : msg("Notification.FF.MemberDisabled", memberPlayer.UserIDString)));
                    }
                }
            }

            player.ChatMessage(!member.AllyFFEnabled ? msg("Notification.FF.AllyEnabled", player.UserIDString) : msg("Notification.FF.AllyDisabled", player.UserIDString));
        }
        
        private void cmdChatClanInfo(BasePlayer player, string command, string[] args)
        {
            if (player.net.connection.authLevel < configData.Permissions.ClanInfoAuthLevel)
            {
                player.ChatMessage(msg("Notification.Generic.NoPermissions", player.UserIDString));
                return;
            }

            if (args.Length == 0)
            {
                player.ChatMessage(msg("Notification.Generic.SpecifyClanTag", player.UserIDString));
                return;
            }

            Clan clan = storedData.FindClan(args[0]);
            if (clan == null)
            {
                player.ChatMessage(string.Format(msg("Notification.Generic.InvalidClan", player.UserIDString), args[0]));
                return;
            }

            clan.PrintClanInfo(player);
        }

        private void cmdChatClanHelp(BasePlayer player, string command, string[] args)
        {
            StringBuilder sb = new StringBuilder();

            Clan clan = storedData.FindClanByID(player.userID);
            if (clan == null)
            {
                sb.Append(msg("Notification.ClanInfo.Title", player.UserIDString));
                sb.Append(string.Format(msg("Notification.ClanHelp.NoClan", player.UserIDString), configData.Commands.ClanCommand));
                player.ChatMessage(sb.ToString());
                return;
            }
                       
            sb.Append(msg("Notification.ClanInfo.Title", player.UserIDString));
            sb.Append(string.Format(msg("Notification.ClanHelp.Basic2", player.UserIDString), configData.Commands.ClanCommand, configData.Commands.ClanChatCommand));

            if (configData.Clans.MemberFF)
                sb.Append(string.Format(msg("Notification.ClanHelp.MFF", player.UserIDString), configData.Commands.FFCommand));

            if (configData.Clans.Alliance.Enabled && configData.Clans.Alliance.AllyFF)
                sb.Append(string.Format(msg("Notification.ClanHelp.AFF", player.UserIDString), configData.Commands.AFFCommand));


            if (clan.IsModerator(player.userID) || clan.IsCouncil(player.userID) || clan.OwnerID.Equals(player.userID))
            {
                if (configData.Clans.Alliance.Enabled && (clan.IsCouncil(player.userID) || clan.OwnerID.Equals(player.userID)))
                    sb.Append(string.Format(msg("Notification.ClanHelp.Alliance", player.UserIDString), configData.Commands.ClanAllyCommand));

                sb.Append(string.Format(msg("Notification.ClanHelp.Moderator", player.UserIDString), configData.Commands.ClanCommand));
            }

            if (clan.OwnerID.Equals(player.userID))
            {
                sb.Append(string.Format(msg("Notification.ClanHelp.Owner", player.UserIDString), configData.Commands.ClanCommand));

                if (configData.Tags.CustomColors)
                    sb.Append(string.Format(msg("Notification.ClanHelp.TagColor", player.UserIDString), configData.Commands.ClanCommand));
            }

            player.ChatMessage(sb.ToString());

        }

        private void cmdChatClanAlly(BasePlayer player, string command, string[] args)
        {
            if (!configData.Clans.Alliance.Enabled)
                return;

            if (args.Length < 2)
            {
                player.ChatMessage(string.Format(msg("Notification.ClanHelp.Alliance", player.UserIDString), configData.Commands.ClanAllyCommand));
                return;
            }

            string tag = args[1];

            switch (args[0].ToLower())
            {
                case "invite":
                    OfferAlliance(player, tag);
                    return;
                case "withdraw":
                    WithdrawAlliance(player, tag);
                    return;
                case "accept":
                    AcceptAlliance(player, tag);
                    return;
                case "reject":
                    RejectAlliance(player, tag);
                    return;
                case "revoke":
                    RevokeAlliance(player, tag);
                    return;
                default:
                    player.ChatMessage(string.Format(msg("Notification.ClanHelp.Alliance", player.UserIDString), configData.Commands.ClanAllyCommand));
                    return;
            }
        }

        private void cmdChatClan(BasePlayer player, string command, string[] args)
        {
            Clan clan = storedData.FindClanByID(player.userID);
            
            if (args.Length == 0)
            {
                StringBuilder sb = new StringBuilder();
                if (clan == null)
                {                    
                    sb.Append(msg("Notification.ClanInfo.Title", player.UserIDString));
                    sb.Append(msg("Notification.Clan.NotInAClan", player.UserIDString));
                    sb.Append(string.Format(msg("Notification.Clan.Help", player.UserIDString), configData.Commands.ClanHelpCommand));
                    player.ChatMessage(sb.ToString());
                    sb.Clear();
                }
                else
                {
                    sb.Append(msg("Notification.ClanInfo.Title", player.UserIDString));
                    sb.Append(string.Format(msg((clan.IsOwner(player.userID) ? "Notification.Clan.OwnerOf" : clan.IsCouncil(player.userID) ? "Notification.Clan.CouncilOf" : clan.IsModerator(player.userID) ? "Notification.Clan.ModeratorOf" : "Notification.Clan.MemberOf"), player.UserIDString), clan.Tag, clan.OnlineCount, clan.MemberCount));
                    sb.Append(string.Format(msg("Notification.Clan.MembersOnline", player.UserIDString), clan.GetMembersOnline()));
                                        
                    if (configData.Clans.MemberFF)
                    {
                        bool isOn = clan.ClanMembers[player.userID].MemberFFEnabled;

                        sb.Append(string.Format(msg("Notification.Clan.MFF", player.UserIDString), isOn ? msg("Notification.FF.IsEnabled") : msg("Notification.FF.IsDisabled"), configData.Commands.FFCommand));
                    }

                    if (configData.Clans.Alliance.Enabled && configData.Clans.Alliance.AllyFF)
                    {
                        bool isOn = clan.ClanMembers[player.userID].AllyFFEnabled;

                        sb.Append(string.Format(msg("Notification.Clan.AFF", player.UserIDString), isOn ? msg("Notification.FF.IsEnabled") : msg("Notification.FF.IsDisabled"), configData.Commands.AFFCommand));
                    }

                    sb.Append(string.Format(msg("Notification.Clan.Help", player.UserIDString), configData.Commands.ClanHelpCommand));
                    player.ChatMessage(sb.ToString());
                    sb.Clear();
                }
                return;
            }

            string tag = clan?.Tag ?? string.Empty;

            switch (args[0].ToLower())
            {
                case "create":
                    if (args.Length < 2)
                    {
                        player.ChatMessage(string.Format(msg("Notification.Clan.CreateSyntax", player.UserIDString), configData.Commands.ClanCommand));
                        return;
                    }

                    CreateClan(player, args[1], args.Length > 2 ? string.Join(" ", args.Skip(2)) : string.Empty);
                    return;
                                   
                case "leave":
                    LeaveClan(player);
                    return;

                case "invite":
                    if (args.Length < 2)
                    {
                        player.ChatMessage(string.Format(msg("Notification.Clan.InviteSyntax", player.UserIDString), configData.Commands.ClanCommand));
                        return;
                    }

                    BasePlayer invitee = FindPlayer(args[1]);
                    if (invitee == null)
                    {
                        player.ChatMessage(string.Format(msg("Notification.Generic.UnableToFindPlayer", player.UserIDString), args[1]));
                        return;
                    }

                    if (invitee == player)
                    {
                        player.ChatMessage(msg("Notification.Generic.CommandSelf", player.UserIDString));
                        return;
                    }

                    InvitePlayer(player, invitee);
                    return;

                case "withdraw":
                    if (args.Length < 2)
                    {
                        player.ChatMessage(string.Format(msg("Notification.Clan.WithdrawSyntax", player.UserIDString), configData.Commands.ClanCommand));
                        return;
                    }

                    WithdrawInvite(player, args[1]);
                    return;

                case "accept":
                    if (args.Length < 2)
                    {
                        player.ChatMessage(string.Format(msg("Notification.Clan.AcceptSyntax", player.UserIDString), configData.Commands.ClanCommand));
                        return;
                    }

                    JoinClan(player, args[1]);
                    return;

                case "reject":
                    if (args.Length < 2)
                    {
                        player.ChatMessage(string.Format(msg("Notification.Clan.RejectSyntax", player.UserIDString), configData.Commands.ClanCommand));
                        return;
                    }

                    RejectInvite(player, args[1]);
                    return;

                case "kick":
                    if (args.Length < 2)
                    {
                        player.ChatMessage(string.Format(msg("Notification.Clan.KickSyntax", player.UserIDString), configData.Commands.ClanCommand));
                        return;
                    }

                    ulong target = clan.FindPlayer(args[1]);
                    if (target == 0UL)
                    {
                        player.ChatMessage(msg("Notification.Kick.NoPlayerFound", player.UserIDString));
                        return;
                    }

                    if (target == player.userID)
                    {
                        player.ChatMessage(msg("Notification.Generic.CommandSelf", player.UserIDString));
                        return;
                    }

                    KickPlayer(player, target);
                    return;

                case "promote":
                    if (args.Length < 2)
                    {
                        player.ChatMessage(string.Format(msg("Notification.Clan.PromoteSyntax", player.UserIDString), configData.Commands.ClanCommand));
                        return;
                    }

                    ulong promotee = clan.FindPlayer(args[1]);
                    if (promotee == 0UL)
                    {
                        player.ChatMessage(string.Format(msg("Notification.Generic.UnableToFindPlayer", player.UserIDString), args[1]));
                        return;
                    }

                    if (promotee == player.userID)
                    {
                        player.ChatMessage(msg("Notification.Generic.CommandSelf", player.UserIDString));
                        return;
                    }

                    PromotePlayer(player, promotee);
                    return;

                case "demote":
                    if (args.Length < 2)
                    {
                        player.ChatMessage(string.Format(msg("Notification.Clan.DemoteSyntax", player.UserIDString), configData.Commands.ClanCommand));
                        return;
                    }

                    ulong demotee = clan.FindPlayer(args[1]);
                    if (demotee == 0UL)
                    {
                        player.ChatMessage(string.Format(msg("Notification.Generic.UnableToFindPlayer", player.UserIDString), args[1]));
                        return;
                    }

                    if (demotee == player.userID)
                    {
                        player.ChatMessage(msg("Notification.Generic.CommandSelf", player.UserIDString));
                        return;
                    }

                    DemotePlayer(player, demotee);
                    return;

                case "disband":
                    if (args.Length < 2 || !args[1].Equals("forever", StringComparison.OrdinalIgnoreCase))
                    {
                        player.ChatMessage(string.Format(msg("Notification.Clan.DisbandSyntax", player.UserIDString), configData.Commands.ClanCommand));
                        return;
                    }
                                            
                    if (clan == null)
                    {
                        player.ChatMessage(msg("Notification.Generic.NoClan", player.UserIDString));
                        return;
                    }

                    if (!clan.IsOwner(player.userID))
                    {
                        player.ChatMessage(msg("Notification.Disband.NotOwner", player.UserIDString));
                        return;
                    }

                    if (configData.Permissions.UsePermissionDisband && !permission.UserHasPermission(player.UserIDString, configData.Permissions.PermissionDisband))
                    {
                        player.ChatMessage(msg("Notification.Disband.NoPermission", player.UserIDString));
                        return;
                    }

                    clan.Broadcast("Notification.Disband.Message", Array.Empty<object>());
                    clan.DisbandClan();

                    player.ChatMessage(string.Format(msg("Notification.Disband.Success", player.UserIDString), tag));
                    return;

                case "tagcolor":
                    if (!configData.Tags.CustomColors)
                    {
                        player.ChatMessage(msg("Notification.Clan.TagColorDisabled", player.UserIDString));
                        return;
                    }

                    if (args.Length < 2)
                    {
                        player.ChatMessage(string.Format(msg("Notification.Clan.TagColorSyntax", player.UserIDString), configData.Commands.ClanCommand));
                        return;
                    }

                    if (!clan.IsOwner(player.userID))
                    {
                        player.ChatMessage(msg("Notification.Disband.NotOwner", player.UserIDString));
                        return;
                    }

                    string hexColor = args[1].ToUpper();

                    if (hexColor.Equals("RESET"))
                    {
                        clan.TagColor = string.Empty;
                        player.ChatMessage(msg("Notification.Clan.TagColorReset", player.UserIDString));
                        return;
                    }

                    if (hexColor.Length < 6 || hexColor.Length > 6 || !hexFilter.IsMatch(hexColor))
                    {
                        player.ChatMessage(msg("Notification.Clan.TagColorFormat", player.UserIDString));
                        return;
                    }

                    if (TagColorIsBlocked(hexColor))
                    {
                        player.ChatMessage(string.Format(msg("Notification.Clan.TagColorBlocked", player.UserIDString), hexColor));
                        return;
                    }

                    if (!TagColorWithinRange(hexColor))
                    {
                        player.ChatMessage(string.Format(msg("Notification.Clan.TagColorOutOfRange", player.UserIDString), hexColor, configData.Tags.CustomTagColorMin, configData.Tags.CustomTagColorMax));
                        return;
                    }

                    clan.TagColor = hexColor;
                    player.ChatMessage(string.Format(msg("Notification.Clan.TagColorSet", player.UserIDString), clan.TagColor));                    
                    return;

                default:
                    player.ChatMessage(string.Format(msg("Notification.Clan.Help", player.UserIDString), configData.Commands.ClanHelpCommand));
                    return;
            }
        }

        #endregion

        #region API
        private void DisableBypass(ulong userId) => friendlyFireDisabled.Add(userId);

        private void EnableBypass(ulong userId) => friendlyFireDisabled.Remove(userId);

        private JObject GetClan(string tag)
        {
            if (!string.IsNullOrEmpty(tag))            
                return storedData.FindClan(tag)?.ToJObject(); 

            return null;
        }

        private JArray GetAllClans() => new JArray(storedData.clans.Keys);
        

        private string GetClanOf(ulong playerId) => storedData.FindClanByID(playerId)?.Tag ?? null;

        private string GetClanOf(BasePlayer player) => GetClanOf(player?.userID ?? 0UL);

        private string GetClanOf(string playerId) => GetClanOf(ulong.Parse(playerId));


        private List<string> GetClanMembers(ulong playerId) => storedData.FindClanByID(playerId)?.ClanMembers.Keys.Select(x => x.ToString()).ToList() ?? new List<string>();
        
        private List<string> GetClanMembers(string playerId) => GetClanMembers(ulong.Parse(playerId));
        

        private object HasFriend(ulong ownerId, ulong playerId)
        {
            Clan clanOwner = storedData.FindClanByID(ownerId);
            if (clanOwner == null)
                return null;

            Clan clanFriend = storedData.FindClanByID(playerId);
            if (clanFriend == null)
                return null;
            
            return clanOwner.Tag.Equals(clanFriend.Tag);
        }        

        private object HasFriend(string ownerId, string playerId) => HasFriend(ulong.Parse(ownerId), ulong.Parse(playerId));


        private bool IsClanMember(ulong playerId, ulong otherId)
        {
            Clan clanPlayer = storedData.FindClanByID(playerId);
            if (clanPlayer == null)
                return false;

            Clan clanOther = storedData.FindClanByID(otherId);
            if (clanOther == null)
                return false;

            return clanPlayer.Tag.Equals(clanOther.Tag);
        }

        private bool IsClanMember(string playerId, string otherId) => IsClanMember(ulong.Parse(playerId), ulong.Parse(otherId));
        

        private bool IsMemberOrAlly(ulong playerId, ulong otherId)
        {
            Clan playerClan = storedData.FindClanByID(playerId);
            if (playerClan == null)
                return false;

            Clan otherClan = storedData.FindClanByID(otherId);
            if (otherClan == null)
                return false;

            if ((playerClan.Tag.Equals(otherClan.Tag)) || playerClan.Alliances.Contains(otherClan.Tag))
                return true;

            return false;
        }

        private bool IsMemberOrAlly(string playerId, string otherId) => IsMemberOrAlly(ulong.Parse(playerId), ulong.Parse(otherId));
       

        private bool IsAllyPlayer(ulong playerId, ulong otherId)
        {
            Clan playerClan = storedData.FindClanByID(playerId);
            if (playerClan == null)
                return false;

            Clan otherClan = storedData.FindClanByID(otherId);
            if (otherClan == null)
                return false;

            if (playerClan.Alliances.Contains(otherClan.Tag))
                return true;

            return false;
        }

        private bool IsAllyPlayer(string playerId, string otherId) => IsAllyPlayer(ulong.Parse(playerId), ulong.Parse(otherId));

        
        private List<string> GetClanAlliances(ulong playerId)
        {
            Clan clan = storedData.FindClanByID(playerId);
            if (clan == null)
                return new List<string>();

            return new List<string>(clan.Alliances);
        }
        
        private List<string> GetClanAlliances(string playerId) => GetClanAlliances(ulong.Parse(playerId));


        [HookMethod("ToggleFF")]
        public void ToggleFF(ulong playerId)
        {
            Clan.Member member = storedData.FindMemberByID(playerId);
            if (member == null)
                return;

            member.MemberFFEnabled = !member.MemberFFEnabled;
        }

        [HookMethod("HasFFEnabled")]
        public bool HasFFEnabled(ulong playerId)
        {
            Clan.Member member = storedData.FindMemberByID(playerId);
            if (member == null)
                return false;

            return member.MemberFFEnabled;
        }
        #endregion

        #region Clan
        [Serializable, ProtoContract]
        public class Clan
        {
            [ProtoMember(1)]
            public string Tag { get; set; }

            [ProtoMember(2)]
            public string Description { get; set; }

            [ProtoMember(3)]
            public ulong OwnerID { get; set; }

            [ProtoMember(4)]
            public double CreationTime { get; set; }

            [ProtoMember(5)]
            public double LastOnlineTime { get; set; }

            [ProtoMember(6)]
            public Hash<ulong, Member> ClanMembers { get; internal set; } = new Hash<ulong, Member>();

            [ProtoMember(7)]
            public Hash<ulong, MemberInvite> MemberInvites { get; internal set; } = new Hash<ulong, MemberInvite>();

            [ProtoMember(8)]
            public HashSet<string> Alliances { get; internal set; } = new HashSet<string>();

            [ProtoMember(9)]
            public Hash<string, double> AllianceInvites { get; internal set; } = new Hash<string, double>();

            [ProtoMember(10)]
            public HashSet<string> IncomingAlliances { get; internal set; } = new HashSet<string>();

            [ProtoMember(11)]
            public string TagColor { get; internal set; } = string.Empty;

            [JsonIgnore, ProtoIgnore]
            internal int OnlineCount { get; private set; }

            [JsonIgnore, ProtoIgnore]
            internal ulong CouncilID
            {
                get
                {
                    foreach (KeyValuePair<ulong, Member> kvp in ClanMembers)
                    {
                        if (kvp.Value.Role == Member.MemberRole.Council)
                            return kvp.Key;
                    }
                    return 0UL;
                }
            }

            [JsonIgnore, ProtoIgnore]
            internal int ModeratorCount => ClanMembers.Where(x => x.Value.Role == Member.MemberRole.Moderator).Count();

            [JsonIgnore, ProtoIgnore]
            internal int MemberCount => ClanMembers.Count;

            [JsonIgnore, ProtoIgnore]
            internal int MemberInviteCount => MemberInvites.Count;

            [JsonIgnore, ProtoIgnore]
            internal int AllianceCount => Alliances.Count;

            [JsonIgnore, ProtoIgnore]
            internal int AllianceInviteCount => AllianceInvites.Count;

            [JsonIgnore, ProtoIgnore]
            private RelationshipManager.PlayerTeam _playerTeam;

            [JsonIgnore, ProtoIgnore]
            internal RelationshipManager.PlayerTeam PlayerTeam
            {
                get
                {
                    if (!configData.Clans.Teams.Enabled)
                        return null;

                    if (_playerTeam == null)
                    {                       
                        _playerTeam = Facepunch.Pool.Get<RelationshipManager.PlayerTeam>();
                        _playerTeam.teamID = FindRandomTeamID;
                        _playerTeam.teamStartTime = Time.realtimeSinceStartup;                        
                        _playerTeam.invites.Clear();
                        _playerTeam.members.Clear();
                        _playerTeam.onlineMemberConnections.Clear();

                        RelationshipManager.ServerInstance.teams.Add(_playerTeam.teamID, _playerTeam);

                        foreach (ulong playerId in ClanMembers.Keys)
                        {
                            BasePlayer player = RelationshipManager.FindByID(playerId);
                            if (player != null)
                            {
                                if (player.currentTeam != 0UL && player.currentTeam != _playerTeam.teamID)
                                {
                                    RelationshipManager.PlayerTeam oldTeam = RelationshipManager.ServerInstance.FindTeam(player.currentTeam);
                                    if (oldTeam != null)
                                    {
                                        oldTeam.members.Remove(player.userID);
                                        player.ClearTeam();
                                    }
                                }

                                player.currentTeam = _playerTeam.teamID;
                                player.SendNetworkUpdate();
                                player.TeamUpdate();
                            }

                            _playerTeam.members.Add(playerId);

                            RelationshipManager.ServerInstance.playerToTeam.Remove(playerId);
                            RelationshipManager.ServerInstance.playerToTeam.Add(playerId, _playerTeam);                            
                        }

                        _playerTeam.teamName = Tag;
                        _playerTeam.SetTeamLeader(OwnerID);

                        _playerTeam.MarkDirty();
                    }
                    return _playerTeam;
                }
            }

            private static ulong FindRandomTeamID
            {
                get
                {
                    START_AGAIN:
                    ulong teamId = (ulong)UnityEngine.Random.Range(10000, long.MaxValue);
                    if (RelationshipManager.ServerInstance.teams.ContainsKey(teamId))
                        goto START_AGAIN;

                    return teamId;
                }
            }

            public Clan() { }

            public Clan(BasePlayer player, string tag, string description)
            {
                this.Tag = tag;
                this.Description = description;
                CreationTime = LastOnlineTime = UnixTimeStampUTC();
                OwnerID = player.userID;
                ClanMembers.Add(player.userID, new Member(Member.MemberRole.Owner, this));
                OnPlayerConnected(player);
            }

            #region Connection
            internal void OnPlayerConnected(BasePlayer player)
            {
                if (player == null)
                    return;

                Member member;
                if (ClanMembers.TryGetValue(player.userID, out member))
                {
                    member.DisplayName = RemoveTags(string.IsNullOrEmpty(player.IPlayer?.Name) ? player.displayName : player.IPlayer?.Name);
                    member.Player = player;
                    
                    if (configData.Tags.Enabled)
                    {
                        string newDisplayname = $"{configData.Tags.TagOpen}{Tag}{configData.Tags.TagClose} {member.DisplayName}";
                        player.displayName = newDisplayname;
                        player._name = string.Format("{1}[{0}/{2}]", player.net.ID, newDisplayname, player.userID);
                    }

                    if (configData.Clans.Teams.Enabled)
                    {
                        if (player.currentTeam != 0UL && player.currentTeam != PlayerTeam.teamID)
                        {
                            RelationshipManager.PlayerTeam oldTeam = RelationshipManager.ServerInstance.FindTeam(player.currentTeam);
                            if (oldTeam != null)
                            {
                                oldTeam.members.Remove(player.userID);
                                player.ClearTeam();
                            }                            
                        }

                        player.currentTeam = PlayerTeam.teamID;

                        if (!PlayerTeam.members.Contains(player.userID))
                            PlayerTeam.members.Add(player.userID);

                        RelationshipManager.ServerInstance.playerToTeam.Remove(player.userID);
                        RelationshipManager.ServerInstance.playerToTeam.Add(player.userID, PlayerTeam);

                        player.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                        player.TeamUpdate();

                        if (member.Role == Member.MemberRole.Owner)                        
                            PlayerTeam.teamLeader = player.userID;

                        PlayerTeam.MarkDirty();
                    }

                    player.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);

                    if (configData.Permissions.PermissionGroups)
                        Instance.permission.AddUserGroup(player.UserIDString, configData.Permissions.PermissionGroupPrefix + Tag);
                    
                    LastOnlineTime = UnixTimeStampUTC();
                    OnlineCount++;
                }

                MarkDirty();
            }

            internal void OnPlayerDisconnected(BasePlayer player)
            {
                if (player == null)
                    return;
                
                Member member;
                if (ClanMembers.TryGetValue(player.userID, out member))
                {
                    if (configData.Tags.Enabled)
                    {
                        player.displayName = member.DisplayName;
                        player._name = string.Format("{1}[{0}/{2}]", player.net.ID, member.DisplayName, player.userID);

                        player.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
                    }

                    if (configData.Permissions.PermissionGroups)
                        Instance.permission.RemoveUserGroup(player.UserIDString, configData.Permissions.PermissionGroupPrefix + Tag);
                    
                    member.Player = null;

                    LastOnlineTime = UnixTimeStampUTC();
                    OnlineCount--;
                }

                MarkDirty();
            }
            #endregion

            #region Clan Management
            internal bool InvitePlayer(BasePlayer inviter, BasePlayer invitee)
            {
                if (!IsOwner(inviter.userID) && !IsCouncil(inviter.userID) && !IsModerator(inviter.userID))
                {
                    inviter.ChatMessage(msg("Notification.Invite.NoPermissions", inviter.UserIDString));
                    return false;
                }

                if (ClanMembers.ContainsKey(invitee.userID))
                {
                    inviter.ChatMessage(string.Format(msg("Notification.Invite.IsMember", inviter.UserIDString), invitee.displayName));
                    return false;
                }

                if (MemberInvites.ContainsKey(invitee.userID))
                {
                    inviter.ChatMessage(string.Format(msg("Notification.Invite.HasPending", inviter.UserIDString), invitee.displayName));
                    return false;
                }

                if (MemberCount >= configData.Clans.MemberLimit)
                {
                    inviter.ChatMessage(msg("Notification.Generic.ClanFull", inviter.UserIDString));
                    return false;
                }

                if (MemberInviteCount >= configData.Clans.Invites.MemberInviteLimit)
                {
                    inviter.ChatMessage(msg("Notification.Invite.InviteLimit", inviter.UserIDString));
                    return false;
                }

                MemberInvites[invitee.userID] = new MemberInvite(invitee);

                Instance.storedData.AddPlayerInvite(invitee.userID, Tag);

                if (configData.Clans.Teams.Enabled)
                    PlayerTeam.SendInvite(invitee);

                invitee.ChatMessage(string.Format(msg("Notification.Invite.SuccesTarget", invitee.UserIDString), Tag, Description, configData.Commands.ClanCommand));
                Broadcast("Notification.Invite.SuccessClan", inviter.displayName, invitee.displayName);

                if (configData.Options.LogChanges)
                    Instance.LogToFile(Instance.Title, $"{inviter.displayName} invited {invitee.displayName} to [{Tag}]", Instance);

                Instance.DiscordClans?.CallHook("LogMessage", $"{inviter.displayName} invited {invitee.displayName} to [{Tag}]", (int)MessageType.Invite);
                return true;
            }

            internal bool JoinClan(BasePlayer player)
            {
                if (!MemberInvites.ContainsKey(player.userID))
                    return false;                

                if ((UnixTimeStampUTC() - MemberInvites[player.userID].ExpiryTime > configData.Clans.Invites.AllianceInviteExpireTime))
                {
                    MemberInvites.Remove(player.userID);
                    player.ChatMessage(string.Format(msg("Notification.Join.ExpiredInvite", player.UserIDString), Tag));
                    return false;
                }

                if (MemberCount >= configData.Clans.MemberLimit)
                {
                    player.ChatMessage(msg("Notification.Generic.ClanFull", player.UserIDString));
                    return false;
                }

                Instance.storedData.OnInviteAccepted(player.userID, Tag);

                MemberInvites.Remove(player.userID);
                List<ulong> currentMembers = ClanMembers.Keys.ToList();

                ClanMembers.Add(player.userID, new Member(Member.MemberRole.Member, this));

                Instance.storedData.RegisterPlayer(player.userID, Tag);

                OnPlayerConnected(player);

                Broadcast("Notification.Join.Message", player.displayName);

                Interface.Oxide.CallHook("OnClanMemberJoined", player.userID, Tag);
                Interface.Oxide.CallHook("OnClanMemberJoined", player.userID, currentMembers);

                Interface.Oxide.CallHook("OnClanUpdate", Tag);

                if (configData.Options.LogChanges)
                    Instance.LogToFile(Instance.Title, $"{player.displayName} joined [{Tag}]", Instance);

                Instance.DiscordClans?.CallHook("LogMessage", $"{player.displayName} joined [{Tag}]", (int)MessageType.Join);
                return true;
            }

            internal bool LeaveClan(BasePlayer player)
            {         
                if (!ClanMembers.ContainsKey(player.userID))                
                    return false;

                if (configData.Clans.Teams.Enabled && _playerTeam != null)                
                    RemoveFromTeam(_playerTeam, player);                
                
                OnPlayerDisconnected(player);
                
                ClanMembers.Remove(player.userID);
                Instance.storedData.UnregisterPlayer(player.userID);                
                                
                player.ChatMessage(string.Format(msg("Notification.Leave.PlayerMessage", player.UserIDString), Tag));
                Broadcast("Notification.Leave.Message", player.displayName);

                MarkDirty();

                if (ClanMembers.Count == 0)
                {
                    Interface.Oxide.CallHook("OnClanMemberGone", player.userID, Tag);
                    Interface.Oxide.CallHook("OnClanMemberGone", player.userID, ClanMembers.Keys.ToList());

                    if (configData.Options.LogChanges)
                        Instance.LogToFile(Instance.Title, $"{player.displayName} has left [{Tag}]", Instance);

                    DisbandClan();
                    return true;
                }

                if (OwnerID == player.userID)
                {
                    ulong councilId = CouncilID;
                    if (councilId != 0UL)
                    {
                        OwnerID = councilId;
                        ClanMembers[councilId].Role = Member.MemberRole.Owner;
                    }
                    else 
                    {
                        foreach (KeyValuePair<ulong, Member> kvp in ClanMembers.OrderBy(x => x.Value.Role))
                        {
                            OwnerID = kvp.Key;
                            kvp.Value.Role = Member.MemberRole.Owner;
                            break;
                        }
                    }

                    if (configData.Clans.Teams.Enabled)
                        PlayerTeam.SetTeamLeader(OwnerID);

                    Broadcast("Notification.Leave.NewOwner", ClanMembers[OwnerID].DisplayName);
                }

                Interface.Oxide.CallHook("OnClanMemberGone", player.userID, ClanMembers.Keys.ToList());
                Interface.Oxide.CallHook("OnClanMemberGone", player.userID, Tag);
                Interface.Oxide.CallHook("OnClanUpdate", Tag);

                if (configData.Options.LogChanges)
                    Instance.LogToFile(Instance.Title, $"{player.displayName} has left [{Tag}]", Instance);

                Instance.DiscordClans?.CallHook("LogMessage", $"{player.displayName} has left [{Tag}]", (int)MessageType.Leave);

                return true;
            }

            internal bool KickMember(BasePlayer player, ulong targetId)
            {                
                if (!ClanMembers.ContainsKey(targetId))
                {
                    player.ChatMessage(msg("Notification.Kick.NotClanmember", player.UserIDString));
                    return false;
                }

                if (IsOwner(targetId))
                {
                    player.ChatMessage(msg("Notification.Kick.IsOwner", player.UserIDString));
                    return false;
                }

                if (!IsOwner(player.userID) && !IsModerator(player.userID) && !IsCouncil(player.userID))
                {
                    player.ChatMessage(msg("Notification.Kick.NoPermissions", player.UserIDString));
                    return false;
                }

                if ((IsOwner(targetId) || IsModerator(targetId) || IsCouncil(targetId)) && OwnerID != player.userID)
                {
                    player.ChatMessage(msg("Notification.Kick.NotEnoughRank", player.UserIDString));
                    return false;
                }

                Member member = ClanMembers[targetId];

                if (configData.Clans.Teams.Enabled && _playerTeam != null)
                    RemoveFromTeam(_playerTeam, targetId);

                if (member.IsConnected && member.Player != null)
                {
                    member.Player.ChatMessage(string.Format(msg("Notification.Kick.PlayerMessage", member.Player.UserIDString), player.displayName));

                    OnPlayerDisconnected(member.Player);                   
                }

                ClanMembers.Remove(targetId);
                Instance.storedData.UnregisterPlayer(targetId);

                Broadcast("Notification.Kick.Message", player.displayName, member.DisplayName);

                Interface.Oxide.CallHook("OnClanMemberGone", targetId, ClanMembers.Keys.ToList());
                Interface.Oxide.CallHook("OnClanMemberGone", targetId, Tag);
                Interface.Oxide.CallHook("OnClanUpdate", Tag);

                if (configData.Options.LogChanges)
                    Instance.LogToFile(Instance.Title, $"{member.DisplayName} was kicked from [{Tag}] by {player.displayName}", Instance);

                Instance.DiscordClans?.CallHook("LogMessage", $"{member.DisplayName} was kicked from [{Tag}] by {player.displayName}", (int)MessageType.Kick);
                return true;
            }

            internal bool PromotePlayer(BasePlayer promoter, ulong targetId)
            {
                if (!IsOwner(promoter.userID))
                {
                    promoter.ChatMessage(msg("Notification.Promotion.NoPermissions", promoter.UserIDString));
                    return false;
                }

                if (IsOwner(targetId))
                {
                    promoter.ChatMessage(msg("Notification.Promotion.IsOwner", promoter.UserIDString));
                    return false;
                }

                if (configData.Clans.Alliance.Enabled)
                {
                    if (IsCouncil(targetId))
                    {
                        promoter.ChatMessage(msg("Notification.Promotion.IsCouncil", promoter.UserIDString));
                        return false;
                    }

                    if (IsModerator(targetId) && HasCouncil())
                    {
                        promoter.ChatMessage(msg("Notification.Promotion.CouncilTaken", promoter.UserIDString));
                        return false;
                    }
                }
                else
                {
                    if (IsModerator(targetId))
                    {
                        promoter.ChatMessage(msg("Notification.Promotion.IsModerator", promoter.UserIDString));
                        return false;
                    }
                }

                if (IsMember(targetId) && ModeratorCount >= configData.Clans.ModeratorLimit)
                {
                    promoter.ChatMessage(msg("Notification.Promotion.ModeratorLimit", promoter.UserIDString));
                    return false;
                }

                Member member = ClanMembers[targetId];
                member.Role = (Member.MemberRole)((int)member.Role - 1);

                MarkDirty();

                Broadcast("Notification.Promotion.Message", member.DisplayName, string.Format(COLORED_LABEL, GetRoleColor(member.Role), member.Role), string.Format(COLORED_LABEL, GetRoleColor(promoter.userID), promoter.displayName));
                Interface.Oxide.CallHook("OnClanUpdate", Tag);

                if (configData.Options.LogChanges)
                    Instance.LogToFile(Instance.Title, $"{member.DisplayName} was promototed to {member.Role} by {promoter.displayName}", Instance);

                Instance.DiscordClans?.CallHook("LogMessage", $"{member.DisplayName} was promototed to {member.Role} by {promoter.displayName}", (int)MessageType.Promote);
                return true;
            }

            internal bool DemotePlayer(BasePlayer demoter, ulong targetId)
            {
                if (!IsOwner(demoter.userID))
                {
                    demoter.ChatMessage(msg("Notification.Demotion.NoPermissions", demoter.UserIDString));
                    return false;
                }

                Member member = ClanMembers[targetId];
                if (IsMember(targetId))
                {
                    demoter.ChatMessage(string.Format(msg("Notification.Demotion.IsMember", demoter.UserIDString), member.DisplayName));
                    return false;
                }
                
                member.Role = member.Role == Member.MemberRole.Council ? (ModeratorCount >= configData.Clans.ModeratorLimit ? Member.MemberRole.Member : Member.MemberRole.Moderator) : (Member.MemberRole)((int)member.Role + 1);

                MarkDirty();

                Broadcast("Notification.Demotion.Message", member.DisplayName, string.Format(COLORED_LABEL, GetRoleColor(member.Role), member.Role), string.Format(COLORED_LABEL, GetRoleColor(demoter.userID), demoter.displayName));

                Interface.Oxide.CallHook("OnClanUpdate", Tag);

                if (configData.Options.LogChanges)
                    Instance.LogToFile(Instance.Title, $"{member.DisplayName} was demoted to {member.Role} by {demoter.displayName}", Instance);

                Instance.DiscordClans?.CallHook("LogMessage", $"{member.DisplayName} was demoted to {member.Role} by {demoter.displayName}", (int)MessageType.Demote);
                return true;
            }

            internal void DisbandClan()
            {
                List<ulong> clanMembers = ClanMembers.Keys.ToList();
                
                OnUnload();

                Instance.storedData.clans.Remove(Tag);

                foreach (KeyValuePair<string, Clan> kvp in Instance.storedData.clans)
                    kvp.Value.OnClanDisbanded(Tag);

                if (configData.Options.LogChanges)
                    Instance.LogToFile(Instance.Title, $"The clan [{Tag}] was disbanded", Instance);

                Instance.DiscordClans?.CallHook("LogMessage", $"The clan [{Tag}] was disbanded", (int)MessageType.Disband);

                Interface.CallHook("OnClanDisbanded", clanMembers);
                Interface.CallHook("OnClanDisbanded", Tag);
            }

            internal void OnClanDisbanded(string tag)
            {
                Alliances.Remove(tag);
                AllianceInvites.Remove(tag);
                IncomingAlliances.Remove(tag);
            }

            internal void OnUnload()
            {
                foreach (KeyValuePair<ulong, Member> kvp in ClanMembers)
                {
                    Instance.storedData.UnregisterPlayer(kvp.Key);

                    if (configData.Clans.Teams.Enabled && _playerTeam != null)
                    {
                        _playerTeam.members.Remove(kvp.Key);
                        RelationshipManager.ServerInstance.playerToTeam.Remove(kvp.Key);

                        BasePlayer basePlayer = (kvp.Value.Player ?? RelationshipManager.FindByID(kvp.Key));
                        if (basePlayer != null)
                        {
                            basePlayer.ClearTeam();
                            basePlayer.BroadcastAppTeamRemoval();
                        }
                    }

                    if (kvp.Value.Player != null)
                        OnPlayerDisconnected(kvp.Value.Player);
                }

                if (_playerTeam != null)
                {
                    RelationshipManager.ServerInstance.teams.Remove(_playerTeam.teamID);
                    ClearTeam(ref _playerTeam);
                }
            }

            internal bool IsAlliedClan(string otherClan) => Alliances.Contains(otherClan);

            internal void MarkDirty()
            {
                cachedClanInfo = string.Empty;
                membersOnline = string.Empty;
                serializedClanObject = null;                
            }
            #endregion

            #region Clan Chat
            internal void Broadcast(string message)
            {
                foreach (Member member in ClanMembers.Values)
                    member.Player?.ChatMessage(message);
            }

            internal void Broadcast(string key, params object[] args)
            {
                foreach (Member member in ClanMembers.Values)
                    member.Player?.ChatMessage(string.Format(msg(key, member.Player.UserIDString), args));
            }
            #endregion

            #region Clan Info
            [JsonIgnore, ProtoIgnore]
            private string cachedClanInfo = string.Empty;

            [JsonIgnore, ProtoIgnore]
            private string membersOnline = string.Empty;

            internal void PrintClanInfo(BasePlayer player)
            {
                if (string.IsNullOrEmpty(cachedClanInfo))
                {
                    StringBuilder str = new StringBuilder();
                    str.Append(msg("Notification.ClanInfo.Title"));
                    str.Append(string.Format(msg("Notification.ClanInfo.Tag"), Tag));

                    if (!string.IsNullOrEmpty(Description))                    
                        str.Append(string.Format(msg("Notification.ClanInfo.Description"), Description));

                    if (configData.Commands.ClanInfoOptions.MemberCount)
                        str.Append(string.Format(msg("Notification.ClanInfo.TotalMembers"), MemberCount));

                    if (configData.Commands.ClanInfoOptions.Players)
                    {
                        List<string> online = Facepunch.Pool.GetList<string>();
                        List<string> offline = Facepunch.Pool.GetList<string>();

                        foreach (KeyValuePair<ulong, Member> kvp in ClanMembers)
                        {
                            string member = string.Format(COLORED_LABEL, GetRoleColor(kvp.Key), kvp.Value.DisplayName);

                            if (kvp.Value.IsConnected)
                                online.Add(member);
                            else offline.Add(member);
                        }

                        if (online.Count > 0)
                            str.Append(string.Format(msg("Notification.ClanInfo.Online"), online.ToSentence()));

                        if (offline.Count > 0)
                            str.Append(string.Format(msg("Notification.ClanInfo.Offline"), offline.ToSentence()));

                        Facepunch.Pool.FreeList(ref online);
                        Facepunch.Pool.FreeList(ref offline);
                    }

                    

                    str.Append(string.Format(msg("Notification.ClanInfo.Established"), UnixTimeStampToDateTime(CreationTime)));

                    if (configData.Commands.ClanInfoOptions.LastOnline)
                        str.Append(string.Format(msg("Notification.ClanInfo.LastOnline"), UnixTimeStampToDateTime(LastOnlineTime)));

                    if (configData.Clans.Alliance.Enabled)
                    {
                        if (configData.Commands.ClanInfoOptions.AllianceCount)
                            str.Append(string.Format(msg("Notification.ClanInfo.TotalAlliances"), AllianceCount));

                        if (configData.Commands.ClanInfoOptions.Alliances)
                            str.Append(string.Format(msg("Notification.ClanInfo.Alliances"), Alliances.Count > 0 ? Alliances.ToSentence() : msg("Notification.ClanInfo.Alliances.None")));
                    }

                    cachedClanInfo = str.ToString();
                }

                player.ChatMessage(cachedClanInfo);
            }

            internal string GetMembersOnline()
            {
                if (string.IsNullOrEmpty(membersOnline))
                {
                    List<string> list = Facepunch.Pool.GetList<string>();

                    foreach (KeyValuePair<ulong, Member> kvp in ClanMembers)
                    {
                        if (kvp.Value.IsConnected)
                        {
                            string member = string.Format(COLORED_LABEL, GetRoleColor(kvp.Key), kvp.Value.DisplayName);
                            list.Add(member);
                        }
                    }

                    membersOnline = list.ToSentence();

                    Facepunch.Pool.FreeList(ref list);
                }
                return membersOnline;
            }
            #endregion

            #region Roles
            internal bool IsOwner(ulong playerId) => ClanMembers[playerId].Role == Member.MemberRole.Owner;

            internal bool IsCouncil(ulong playerId) => ClanMembers[playerId].Role == Member.MemberRole.Council;

            internal bool IsModerator(ulong playerId) => ClanMembers[playerId].Role == Member.MemberRole.Moderator;

            internal bool IsMember(ulong playerId) => ClanMembers[playerId].Role == Member.MemberRole.Member;

            internal Member GetOwner() => ClanMembers[OwnerID];

            internal bool HasCouncil()
            {
                foreach(Member member in ClanMembers.Values)
                {
                    if (member.Role == Member.MemberRole.Council)
                        return true;
                }
                return false;
            }

            internal string GetRoleColor(ulong userID) => GetRoleColor(ClanMembers[userID].Role);
           
            internal string GetRoleColor(Member.MemberRole role)
            {
                if (role == Member.MemberRole.Owner)
                    return configData.Colors.Owner;

                if (role == Member.MemberRole.Council)
                    return configData.Colors.Council;

                if (role == Member.MemberRole.Moderator)
                    return configData.Colors.Moderator;

                return configData.Colors.Member;
            }
            #endregion

            [Serializable, ProtoContract]
            public class Member
            {
                [JsonIgnore, ProtoIgnore]
                public BasePlayer Player { get; set; }

                [ProtoMember(1)]
                public string DisplayName { get; set; } = string.Empty;

                [ProtoMember(2)]
                public MemberRole Role { get; set; }

                [ProtoMember(3)]
                public bool MemberFFEnabled { get; set; }

                [ProtoMember(4)]
                public bool AllyFFEnabled { get; set; }

                [JsonIgnore, ProtoIgnore]
                internal bool IsConnected => Player != null ? Player.IsConnected : false;

                [JsonIgnore, ProtoIgnore]
                internal float lastFFAttackTime;

                [JsonIgnore, ProtoIgnore]
                internal float lastAFFAttackTime;

                public Member() { }

                public Member(MemberRole role, Clan clan)
                {
                    this.Role = role;

                    if (role == MemberRole.Owner)
                    {
                        MemberFFEnabled = configData.Clans.DefaultEnableFF;
                        AllyFFEnabled = configData.Clans.Alliance.DefaultEnableFF;
                    }
                    else
                    {
                        MemberFFEnabled = configData.Clans.OwnerFF ? clan.GetOwner().MemberFFEnabled : configData.Clans.DefaultEnableFF;
                        AllyFFEnabled = configData.Clans.Alliance.OwnerFF ? clan.GetOwner().AllyFFEnabled : configData.Clans.Alliance.DefaultEnableFF;
                    }                    
                }

                public Member(MemberRole role, bool memberFFEnabled, bool allyFFEnabled)
                {
                    this.Role = role;

                    MemberFFEnabled = memberFFEnabled;
                    AllyFFEnabled = allyFFEnabled;
                }

                public void OnClanMemberHit(string victimName)
                {
                    if (Time.time - lastFFAttackTime > 3f)
                    {
                        Player.ChatMessage(string.Format(msg("Notification.FF.OnHitClanMember", Player.UserIDString), victimName, configData.Commands.FFCommand));
                        lastFFAttackTime = Time.time;
                    }                    
                }

                public void OnAllyMemberHit(string victimName)
                {
                    if (Time.time - lastAFFAttackTime > 3f)
                    {
                        Player.ChatMessage(string.Format(msg("Notification.FF.OnHitAllyMember", Player.UserIDString), victimName, configData.Commands.AFFCommand));
                        lastAFFAttackTime = Time.time;
                    }
                }

                public enum MemberRole { Owner, Council, Moderator, Member }
            }

            [Serializable, ProtoContract]
            public class MemberInvite
            {
                [ProtoMember(1)]
                public string DisplayName { get; set; }

                [ProtoMember(2)]
                public double ExpiryTime { get; set; }

                public MemberInvite() { }

                public MemberInvite(BasePlayer player)
                {
                    DisplayName = player.displayName;
                    ExpiryTime = UnixTimeStampUTC();
                }
            }

            [JsonIgnore, ProtoIgnore]
            private JObject serializedClanObject;

            internal JObject ToJObject()
            {
                if (serializedClanObject != null)
                    return serializedClanObject;
                
                serializedClanObject = new JObject();
                serializedClanObject["tag"] = Tag;
                serializedClanObject["description"] = Description;
                serializedClanObject["owner"] = OwnerID;
                serializedClanObject["council"] = CouncilID;

                JArray jmoderators = new JArray();
                JArray jmembers = new JArray();

                foreach (KeyValuePair<ulong, Member> kvp in ClanMembers)
                {
                    if (kvp.Value.Role == Member.MemberRole.Moderator)
                        jmoderators.Add(kvp.Key);

                    jmembers.Add(kvp.Key);
                }

                serializedClanObject["moderators"] = jmoderators;
                serializedClanObject["members"] = jmembers;

                JArray jallies = new JArray();

                foreach (string ally in Alliances)
                    jallies.Add(ally);

                serializedClanObject["allies"] = jallies;

                JArray jinvallies = new JArray();

                foreach (KeyValuePair<string, double> ally in AllianceInvites)                                   
                    jinvallies.Add(ally.Key);
                
                serializedClanObject["invitedallies"] = jinvallies;

                return serializedClanObject;
            }

            internal ulong FindPlayer(string partialNameOrID)
            {
                foreach(KeyValuePair<ulong, Member> kvp in ClanMembers)
                {
                    if (kvp.Key.Equals(partialNameOrID))
                        return kvp.Key;

                    if (kvp.Value.DisplayName.Contains(partialNameOrID, CompareOptions.OrdinalIgnoreCase))
                        return kvp.Key;
                }

                return 0UL;
            }
        }
        #endregion

        #region Console Commands        
        [ConsoleCommand("clans")]
        private void ccmdClans(ConsoleSystem.Arg arg)
        {
            bool isRcon = arg.Connection == null;
            if (isRcon || (arg.Connection?.player != null && arg.Connection?.authLevel > 0))
            {
                if (arg.Args == null || arg.Args.Length == 0)
                {
                    StringBuilder sb = new StringBuilder();
                    sb.AppendLine("> Clans command overview <");
                    sb.AppendLine("clans list (Lists all clans, their owners and their member-count)");
                    sb.AppendLine("clans listex (Lists all clans, their owners/members and their on-line status)");
                    sb.AppendLine("clans show \'tag|partialNameOrId\' (lists the chosen clan (or clan by user) and the members with status)");
                    sb.AppendLine("clans msg \'tag\' \'message without quotes\' (Sends a clan message)");

                    if (isRcon || arg.Connection.authLevel >= configData.Commands.Auth.Create)
                        sb.AppendLine("clans create \'tag(case-sensitive)\' \'steam-id(owner)\' \'desc(optional)\'");

                    if (isRcon || arg.Connection.authLevel >= configData.Commands.Auth.Rename)
                        sb.AppendLine("clans rename \'old tag\' \'new tag\' (renames a clan | case-sensitive)");

                    if (isRcon || arg.Connection.authLevel >= configData.Commands.Auth.Disband)
                        sb.AppendLine("clans disband \'tag\' (disbands a clan)");

                    if (isRcon || arg.Connection.authLevel >= configData.Commands.Auth.Invite)
                    {
                        sb.AppendLine("clans invite \'tag\' \'partialNameOrId\' (sends clan invitation to a player)");
                        sb.AppendLine("clans join \'tag\' \'partialNameOrId\' (joins a player into a clan)");
                    }

                    if (isRcon || arg.Connection.authLevel >= configData.Commands.Auth.Kick)
                        sb.AppendLine("clans kick \'tag\' \'partialNameOrId\' (kicks a member from a clan | deletes invite)");

                    if (isRcon || arg.Connection.authLevel >= configData.Commands.Auth.Promote)
                    {
                        sb.AppendLine("clans owner \'tag\' \'partialNameOrId\' (sets a new owner)");
                        sb.AppendLine("clans promote \'tag\' \'partialNameOrId\' (promotes a member)");
                        sb.AppendLine("clans demote \'tag\' \'partialNameOrId\' (demotes a member)");
                    }

                    SendReply(arg, sb.ToString());
                    return;
                }

                int authLevel = isRcon ? 2 : (int)arg.Connection.authLevel;
                switch (arg.Args[0].ToLower())
                {
                    case "list":
                        {
                            TextTable textTable = new TextTable();
                            textTable.AddColumn("Tag");
                            textTable.AddColumn("Owner");
                            textTable.AddColumn("SteamID");
                            textTable.AddColumn("Count");
                            textTable.AddColumn("On");

                            foreach (Clan clan in storedData.clans.Values)
                            {
                                string ownerName = clan.ClanMembers.FirstOrDefault(x => x.Value.Role == Clan.Member.MemberRole.Owner).Value?.DisplayName ?? string.Empty;
                                textTable.AddRow(new string[] { clan.Tag, ownerName, clan.OwnerID.ToString(), clan.MemberCount.ToString(), clan.OnlineCount.ToString()});
                            }

                            SendReply(arg, "\n>> Current clans <<\n" + textTable.ToString());
                        }
                        return;
                    case "listex":
                        {
                            TextTable textTable = new TextTable();
                            textTable.AddColumn("Tag");
                            textTable.AddColumn("Role");
                            textTable.AddColumn("Name");
                            textTable.AddColumn("SteamID");
                            textTable.AddColumn("Status");
                            foreach (Clan clan in storedData.clans.Values)
                            {
                                foreach (KeyValuePair<ulong, Clan.Member> kvp in clan.ClanMembers)
                                {                                    
                                    textTable.AddRow(new string[] { clan.Tag, kvp.Value.Role.ToString(), kvp.Value.DisplayName, kvp.Key.ToString(), kvp.Value.Player != null ? "Online" : "Offline" });
                                }

                                textTable.AddRow(new string[] { });
                            }

                            SendReply(arg, "\n>> Current clans with members <<\n" + textTable.ToString());
                        }
                        return;
                    case "show":
                        {
                            if (arg.Args.Length < 2)
                            {
                                SendReply(arg, "Usage: clans show \'tag|partialNameOrId\'");
                                return;
                            }

                            Clan clan = storedData.FindClan(arg.Args[1]);
                            if (clan == null)
                            {
                                Oxide.Core.Libraries.Covalence.IPlayer iPlayer = covalence.Players.FindPlayer(arg.Args[1]);
                                if (iPlayer != null)
                                {
                                    clan = storedData.FindClanByID(ulong.Parse(iPlayer.Id));
                                }
                            }
                            
                            if (clan == null)
                            {
                                SendReply(arg, $"No clan or player found with: {arg.Args[1]}");
                                return;
                            }

                            StringBuilder sb = new StringBuilder();
                            sb.AppendLine($"\n>> Show clan [{clan.Tag}] <<");
                            sb.AppendLine($"Description: {clan.Description}");
                            sb.AppendLine($"Time created: {UnixTimeStampToDateTime(clan.CreationTime)}");
                            sb.AppendLine($"Last online: {UnixTimeStampToDateTime(clan.LastOnlineTime)}");
                            sb.AppendLine($"Member count: {clan.MemberCount}");

                            TextTable textTable = new TextTable();
                            textTable.AddColumn("Role");
                            textTable.AddColumn("Name");
                            textTable.AddColumn("SteamID");
                            textTable.AddColumn("Status");
                            sb.AppendLine();
                            foreach (KeyValuePair<ulong, Clan.Member> kvp in clan.ClanMembers)
                            {
                                textTable.AddRow(new string[] { clan.Tag, kvp.Value.Role.ToString(), kvp.Value.DisplayName, kvp.Key.ToString(), kvp.Value.Player != null ? "Online" : "Offline" });
                            }

                            sb.AppendLine(textTable.ToString());
                            SendReply(arg, sb.ToString());
                            SendReply(arg, $"Allied Clans: {clan.Alliances.ToSentence()}");                            
                        }
                        return;
                    case "msg":
                        {
                            if (arg.Args.Length < 3)
                            {
                                SendReply(arg, "Usage: clans.msg \'tag\' \'your message without quotes\'");
                                return;
                            }

                            Clan clan = storedData.FindClan(arg.Args[1]);
                            if (clan == null)
                            {
                                SendReply(arg, $"Unable to find a clan with the tag: {arg.Args[1]}");
                                return;
                            }

                            string message = string.Join(" ", arg.Args.Skip(2));

                            clan.Broadcast("Admin.BroadcastToClan", message);
                            SendReply(arg, $"Broadcast to [{clan.Tag}]: {message}");
                        }
                        return;
                    case "create":
                        if (authLevel >= configData.Commands.Auth.Create)
                        {
                            if (arg.Args.Length < 3)
                            {
                                SendReply(arg, "Usage: clans create \'tag(case-sensitive)\' \'steamid(owner)\' \'desc(optional)\'");
                                return;
                            }

                            string tag = arg.Args[1];

                            if (tag.Length < configData.Tags.TagLength.Minimum || tag.Length > configData.Tags.TagLength.Maximum)
                            {
                                SendReply(arg, $"Invalid tag length, it must be between {configData.Tags.TagLength.Minimum} and {configData.Tags.TagLength.Maximum} characters long");
                                return;
                            }

                            if (tagFilter.IsMatch(tag) || ContainsBlockedWord(tag))
                            {
                                SendReply(arg, "Invalid characters or blocked words detected in tag");
                                return;
                            }

                            if (ClanTagExists(tag))
                            {
                                SendReply(arg, "A clan with that tag already exists");
                                return;
                            }

                            Core.Libraries.Covalence.IPlayer owner = covalence.Players.FindPlayerById(arg.Args[2]);
                            if (owner == null)
                            {
                                SendReply(arg, "No player found with that ID");
                                return;
                            }

                            BasePlayer ownerPlayer = owner.Object as BasePlayer;
                            ulong ownerID = ulong.Parse(owner.Id);

                            if (storedData.FindClanByID(ownerID) != null)
                            {
                                SendReply(arg, "The specified owner is already in a clan");
                                return;
                            }

                            string description = arg.Args.Length > 3 ? string.Join(" ", arg.Args.Skip(3)) : string.Empty;

                            storedData.clans[tag] = ownerPlayer != null ? new Clan(ownerPlayer, tag, description) : 
                                new Clan() { Tag = tag, Description = description, OwnerID = ownerID, CreationTime = UnixTimeStampUTC(), LastOnlineTime = UnixTimeStampUTC(), ClanMembers = new Hash<ulong, Clan.Member>() { [ownerID] = new Clan.Member() { Role = Clan.Member.MemberRole.Owner } } };
                        
                            storedData.RegisterPlayer(ownerID, tag);

                            if (ownerPlayer != null)
                            {
                                ownerPlayer.ChatMessage(string.Format(msg("Notification.Create.Success", ownerPlayer.UserIDString), tag));
                                OnPlayerConnected(ownerPlayer);
                            }

                            Interface.CallHook("OnClanCreate", tag);

                            if (configData.Options.LogChanges)
                                LogToFile(Title, $"Server ({(isRcon ? "ADMIN" : (arg.Connection.player as BasePlayer).displayName)}) created the clan [{tag}] for {owner.Name}", this);

                            SendReply(arg, $"You created the clan {tag} and set {owner.Name} as the owner");
                        }
                        return;
                    case "rename":
                        if (authLevel >= configData.Commands.Auth.Rename)
                        {
                            if (arg.Args.Length < 3)
                            {
                                SendReply(arg, "Usage: clans rename \'oldtag(case-sensitive)\' \'newtag(case-sensitive)\'");
                                return;
                            }

                            string oldTag = arg.Args[1];
                            Clan clan = storedData.FindClan(oldTag);
                            if (clan == null)
                            {
                                SendReply(arg, "No clan found with the specified tag");
                                return;
                            }

                            string newTag = arg.Args[2];

                            if (newTag.Length < configData.Tags.TagLength.Minimum || newTag.Length > configData.Tags.TagLength.Maximum)
                            {
                                SendReply(arg, $"Invalid tag length, it must be between {configData.Tags.TagLength.Minimum} and {configData.Tags.TagLength.Maximum} characters long");
                                return;
                            }

                            if (ClanTagExists(newTag))
                            {
                                SendReply(arg, "A clan with that tag already exists");
                                return;
                            }

                            clan.Tag = newTag;
                            storedData.clans[newTag] = clan;
                            storedData.clans.Remove(oldTag);

                            foreach(Clan otherClan in storedData.clans.Values)
                            {
                                if (otherClan == clan)
                                    continue;

                                if (otherClan.Alliances.Contains(oldTag))
                                {
                                    otherClan.Alliances.Remove(oldTag);
                                    otherClan.Alliances.Add(newTag);
                                    otherClan.MarkDirty();
                                }

                                if (otherClan.AllianceInvites.ContainsKey(oldTag))
                                {
                                    double time = otherClan.AllianceInvites[oldTag];
                                    otherClan.AllianceInvites.Remove(oldTag);
                                    otherClan.AllianceInvites.Add(newTag, time);
                                }
                            }

                            if (configData.Permissions.PermissionGroups)
                            {
                                permission.RemoveGroup(configData.Permissions.PermissionGroupPrefix + oldTag);
                                permission.CreateGroup(configData.Permissions.PermissionGroupPrefix + newTag, "Clan " + newTag, 0);
                            }

                            foreach (KeyValuePair<ulong, Clan.Member> kvp in clan.ClanMembers)
                            {
                                storedData.RegisterPlayer(kvp.Key, newTag);
                                if (kvp.Value.Player != null)
                                    OnPlayerConnected(kvp.Value.Player);
                            }

                            clan.Broadcast("Admin.Rename", newTag);
                            SendReply(arg, $"You have changed {oldTag} tag to {newTag}");

                            clan.MarkDirty();

                            if (configData.Options.LogChanges)
                                LogToFile(Title, $"Server ({(isRcon ? "ADMIN" : (arg.Connection.player as BasePlayer).displayName)}) renamed clan tag {oldTag} to {newTag}", this);
                        }
                        return;
                    case "disband":
                        if (authLevel >= configData.Commands.Auth.Disband)
                        {
                            if (arg.Args.Length < 2)
                            {
                                SendReply(arg, "Usage: clans disband \'tag(case-sensitive)\'");
                                return;
                            }

                            Clan clan = storedData.FindClan(arg.Args[1]);
                            if (clan == null)
                            {
                                SendReply(arg, "No clan found with the specified tag");
                                return;
                            }

                            clan.Broadcast("Admin.Disband");
                            clan.DisbandClan();

                            if (configData.Options.LogChanges)
                                LogToFile(Title, $"Server ({(isRcon ? "ADMIN" : (arg.Connection.player as BasePlayer).displayName)}) disbanded the clan {arg.Args[1]}", this);
                        }
                        return;
                    case "invite":
                        if (authLevel >= configData.Commands.Auth.Invite)
                        {
                            if (arg.Args.Length < 3)
                            {
                                SendReply(arg, "Usage: clans invite \'tag(case-sensitive)\' \'partialNameOrId\'");
                                return;
                            }

                            Clan clan = storedData.FindClan(arg.Args[1]);
                            if (clan == null)
                            {
                                SendReply(arg, "No clan found with the specified tag");
                                return;
                            }

                            BasePlayer player = FindPlayer(arg.Args[2]);
                            if (player == null)
                            {
                                SendReply(arg, "Unable to find a player with the specified name or ID");
                                return;
                            }

                            if (storedData.FindClanByID(player.userID) != null)
                            {
                                SendReply(arg, "The specified player is already a member of a clan");
                                return;
                            }

                            if (clan.ClanMembers.ContainsKey(player.userID))
                            {
                                SendReply(arg, "The specified player is already a member of that clan");
                                return;
                            }

                            if (clan.MemberInvites.ContainsKey(player.userID))
                            {
                                SendReply(arg, "The specified player already has a invitation to join that clan");
                                return;
                            }

                            if (clan.MemberCount >= configData.Clans.MemberLimit)
                            {
                                SendReply(arg, "The specified clan is already at capacity");
                                return;
                            }

                            if (clan.MemberInviteCount >= configData.Clans.Invites.MemberInviteLimit)
                            {
                                SendReply(arg, "The specified clan already has the maximum amount of invitations");
                                return;
                            }

                            clan.MemberInvites[player.userID] = new Clan.MemberInvite(player);

                            if (configData.Clans.Teams.Enabled)
                                clan.PlayerTeam.SendInvite(player);

                            player.ChatMessage(string.Format(msg("Notification.Invite.SuccesTarget", player.UserIDString), clan.Tag, clan.Description, configData.Commands.ClanCommand));
                            clan.Broadcast("Admin.Invite", player.displayName);

                            if (configData.Options.LogChanges)
                                LogToFile(Title, $"Server ({(isRcon ? "ADMIN" : (arg.Connection.player as BasePlayer).displayName)}) invited {player.displayName} to the clan {arg.Args[1]}", this);
                        }
                        return;
                    case "join":
                        if (authLevel >= configData.Commands.Auth.Invite)
                        {
                            if (arg.Args.Length < 3)
                            {
                                SendReply(arg, "Usage: clans join \'tag(case-sensitive)\' \'partialNameOrId\'");
                                return;
                            }

                            string tag = arg.Args[1];

                            Clan clan = storedData.FindClan(tag);
                            if (clan == null)
                            {
                                SendReply(arg, "No clan found with the specified tag");
                                return;
                            }

                            BasePlayer player = FindPlayer(arg.Args[2]);
                            if (player == null)
                            {
                                SendReply(arg, "Unable to find a player with the specified name or ID");
                                return;
                            }

                            Clan otherClan = storedData.FindClanByID(player.userID);
                            if (otherClan != null)
                            {
                                SendReply(arg, "The specified player is already in a clan");
                                return;
                            }

                            if (!clan.MemberInvites.ContainsKey(player.userID))
                            {
                                SendReply(arg, "The specified player does not have a invite to that clan");
                                return;
                            }

                            if ((UnixTimeStampUTC() - clan.MemberInvites[player.userID].ExpiryTime > configData.Clans.Invites.AllianceInviteExpireTime))
                            {
                                clan.MemberInvites.Remove(player.userID);
                                SendReply(arg, "The specified players clan invite has expired");
                                return;
                            }

                            if (clan.MemberCount >= configData.Clans.MemberLimit)
                            {
                                SendReply(arg, "The specified clan is already at member capacity");
                                return;
                            }

                            clan.MemberInvites.Remove(player.userID);

                            List<string> currentMembers = clan.ClanMembers.Select(x => x.Key.ToString()).ToList();

                            clan.ClanMembers.Add(player.userID, new Clan.Member(Clan.Member.MemberRole.Member, clan));

                            Instance.storedData.RegisterPlayer(player.userID, tag);

                            OnPlayerConnected(player);

                            player.ChatMessage(string.Format(msg("Admin.Join", player.UserIDString), tag));
                            clan.Broadcast("Notification.Join.Message", player.displayName);

                            clan.MarkDirty();

                            Interface.Oxide.CallHook("OnClanMemberJoined", player.UserIDString, tag);
                            Interface.Oxide.CallHook("OnClanMemberJoined", player.UserIDString, currentMembers);

                            Interface.Oxide.CallHook("OnClanUpdate", tag);

                            if (configData.Options.LogChanges)
                                LogToFile(Title, $"Server ({(isRcon ? "ADMIN" : (arg.Connection.player as BasePlayer).displayName)}) forced {player.displayName} to join the clan {arg.Args[1]}", this);
                        }
                        return;
                    case "kick":
                        if (authLevel >= configData.Commands.Auth.Kick)
                        {
                            if (arg.Args.Length < 3)
                            {
                                SendReply(arg, "Usage: clans kick \'tag(case-sensitive)\' \'partialNameOrId\'");
                                return;
                            }

                            string tag = arg.Args[1];
                            Clan clan = storedData.FindClan(tag);
                            if (clan == null)
                            {
                                SendReply(arg, "No clan found with the specified tag");
                                return;
                            }

                            BasePlayer player = FindPlayer(arg.Args[2]);
                            if (player == null)
                            {
                                SendReply(arg, "Unable to find a player with the specified name or ID");
                                return;
                            }

                            if (!clan.ClanMembers.ContainsKey(player.userID))
                            {
                                SendReply(arg, "The specified user is not in that clan");
                                return;
                            }

                            if (configData.Clans.Teams.Enabled && clan.PlayerTeam != null)
                                RemoveFromTeam(clan.PlayerTeam, player);

                            OnPlayerDisconnected(player);
                            clan.ClanMembers.Remove(player.userID);
                            storedData.UnregisterPlayer(player.userID);

                            player.ChatMessage(string.Format(msg("Admin.Kick", player.UserIDString), tag));
                            clan.Broadcast("Admin.Kick.Broadcast", player.displayName);

                            clan.MarkDirty();

                            Interface.Oxide.CallHook("OnClanMemberGone", player.UserIDString, tag);
                            Interface.Oxide.CallHook("OnClanMemberGone", player.UserIDString, clan.ClanMembers.Select(x => x.Key.ToString()).ToList());

                            Interface.Oxide.CallHook("OnClanUpdate", tag);

                            if (configData.Options.LogChanges)
                                LogToFile(Title, $"Server ({(isRcon ? "ADMIN" : (arg.Connection.player as BasePlayer).displayName)}) kicked {player.displayName} from the clan {tag}", this);
                        }
                        return;
                    case "owner":
                        if (authLevel >= configData.Commands.Auth.Promote)
                        {
                            if (arg.Args.Length < 3)
                            {
                                SendReply(arg, "Usage: clans owner \'tag(case-sensitive)\' \'partialNameOrId\'");
                                return;
                            }

                            string tag = arg.Args[1];

                            Clan clan = storedData.FindClan(tag);
                            if (clan == null)
                            {
                                SendReply(arg, "No clan found with the specified tag");
                                return;
                            }

                            BasePlayer player = FindPlayer(arg.Args[2]);
                            if (player == null)
                            {
                                SendReply(arg, "Unable to find a player with the specified name or ID");
                                return;
                            }

                            if (!clan.ClanMembers.ContainsKey(player.userID))
                            {
                                SendReply(arg, "The specified player is not a member of that clan");
                                return;
                            }

                            if (clan.IsOwner(player.userID))
                            {
                                SendReply(arg, "The specified player is already the clan owner");
                                return;
                            }

                            Clan.Member currentOwner = clan.ClanMembers[clan.OwnerID];
                            currentOwner.Role = Clan.Member.MemberRole.Member;

                            Clan.Member member = clan.ClanMembers[player.userID];
                            member.Role = Clan.Member.MemberRole.Owner;
                            clan.OwnerID = player.userID;

                            if (configData.Clans.Teams.Enabled)
                                clan.PlayerTeam?.SetTeamLeader(player.userID);

                            clan.Broadcast("Admin.SetOwner", string.Format(COLORED_LABEL, clan.GetRoleColor(Clan.Member.MemberRole.Owner), player.displayName));

                            clan.MarkDirty();

                            Interface.Oxide.CallHook("OnClanUpdate", tag);

                            if (configData.Options.LogChanges)
                                LogToFile(Title, $"Server ({(isRcon ? "ADMIN" : (arg.Connection.player as BasePlayer).displayName)}) set {player.displayName} as the owner of the clan {tag}", this);
                        }
                        return;
                    case "promote":
                        if (authLevel >= configData.Commands.Auth.Promote)
                        {
                            if (arg.Args.Length < 3)
                            {
                                SendReply(arg, "Usage: clans promote \'tag(case-sensitive)\' \'partialNameOrId\'");
                                return;
                            }

                            string tag = arg.Args[1];

                            Clan clan = storedData.FindClan(tag);
                            if (clan == null)
                            {
                                SendReply(arg, "No clan found with the specified tag");
                                return;
                            }

                            BasePlayer player = FindPlayer(arg.Args[2]);
                            if (player == null)
                            {
                                SendReply(arg, "Unable to find a player with the specified name or ID");
                                return;
                            }

                            if (!clan.ClanMembers.ContainsKey(player.userID))
                            {
                                SendReply(arg, "The specified player is not a member of that clan");
                                return;
                            }

                            if (clan.IsOwner(player.userID))
                            {
                                SendReply(arg, "The specified player is already the clan owner");
                                return;
                            }

                            if (configData.Clans.Alliance.Enabled)
                            {
                                if (clan.IsCouncil(player.userID))
                                {
                                    SendReply(arg, "The specified player is already the highest rank they can be");
                                    return;
                                }

                                if (clan.IsModerator(player.userID) && clan.HasCouncil())
                                {
                                    SendReply(arg, "The specified player is already the highest rank they can be");
                                    return;
                                }
                            }
                            else
                            {
                                if (clan.IsModerator(player.userID))
                                {
                                    SendReply(arg, "The specified player is already the highest rank they can be");
                                    return;
                                }
                            }

                            if (clan.IsMember(player.userID) && clan.ModeratorCount >= configData.Clans.ModeratorLimit)
                            {
                                SendReply(arg, "The specified player is already the highest rank they can be");
                                return;
                            }

                            Clan.Member member = clan.ClanMembers[player.userID];
                            member.Role = (Clan.Member.MemberRole)((int)member.Role - 1);

                            clan.MarkDirty();

                            clan.Broadcast("Admin.Promote", player.displayName, string.Format(COLORED_LABEL, clan.GetRoleColor(member.Role), member.Role));
                            Interface.Oxide.CallHook("OnClanUpdate", tag);

                            if (configData.Options.LogChanges)
                                LogToFile(Title, $"Server ({(isRcon ? "ADMIN" : (arg.Connection.player as BasePlayer).displayName)}) promoted {player.displayName} to the rank of {member.Role} in the clan {tag}", this);
                        }
                        return;
                    case "demote":
                        if (authLevel >= configData.Commands.Auth.Promote)
                        {
                            if (arg.Args.Length < 3)
                            {
                                SendReply(arg, "Usage: clans demote \'tag(case-sensitive)\' \'partialNameOrId\'");
                                return;
                            }

                            string tag = arg.Args[1];

                            Clan clan = storedData.FindClan(tag);
                            if (clan == null)
                            {
                                SendReply(arg, "No clan found with the specified tag");
                                return;
                            }

                            BasePlayer player = FindPlayer(arg.Args[2]);
                            if (player == null)
                            {
                                SendReply(arg, "Unable to find a player with the specified name or ID");
                                return;
                            }

                            if (clan.IsOwner(player.userID))
                            {
                                SendReply(arg, "You can not demote the clan owner");
                                return;
                            }

                            if (clan.IsMember(player.userID))
                            {
                                SendReply(arg, "The specified player is already at the lowest rank");
                                return;
                            }

                            Clan.Member member = clan.ClanMembers[player.userID];
                            member.Role = member.Role == Clan.Member.MemberRole.Council ? (clan.ModeratorCount >= configData.Clans.ModeratorLimit ? Clan.Member.MemberRole.Member : Clan.Member.MemberRole.Moderator) : (Clan.Member.MemberRole)((int)member.Role + 1);

                            clan.MarkDirty();

                            clan.Broadcast("Admin.Demote", player.displayName, string.Format(COLORED_LABEL, clan.GetRoleColor(member.Role), member.Role));

                            Interface.Oxide.CallHook("OnClanUpdate", tag);
                            if (configData.Options.LogChanges)
                                LogToFile(Title, $"Server ({(isRcon ? "ADMIN" : (arg.Connection.player as BasePlayer).displayName)}) demoted {player.displayName} to the rank of {member.Role} in the clan {tag}", this);
                        }
                        return;
                    default:
                        SendReply(arg, "Invalid syntax! Type \"clans\" in console to see available commands");
                        return;
                }
            }
        }
        #endregion

        #region Config        
        internal static ConfigData configData;

        internal class ConfigData
        {
            [JsonProperty(PropertyName = "Clan Options")]
            public ClanOptions Clans { get; set; }

            [JsonProperty(PropertyName = "Command Options")]
            public CommandOptions Commands { get; set; }

            [JsonProperty(PropertyName = "Role Colors")]
            public ColorOptions Colors { get; set; }

            [JsonProperty(PropertyName = "Clan Tag Options")]
            public TagOptions Tags { get; set; }

            [JsonProperty(PropertyName = "Permission Options")]
            public PermissionOptions Permissions { get; set; }

            [JsonProperty(PropertyName = "Purge Options")]
            public PurgeOptions Purge { get; set; }

            [JsonProperty(PropertyName = "Settings")]
            public OtherOptions Options { get; set; }

            public class ClanOptions
            {         
                [JsonProperty(PropertyName = "Member limit")]
                public int MemberLimit { get; set; }

                [JsonProperty(PropertyName = "Moderator limit")]
                public int ModeratorLimit { get; set; }
               
                [JsonProperty(PropertyName = "Allow friendly fire toggle (clan members)")]
                public bool MemberFF { get; set; }

                [JsonProperty(PropertyName = "Enable friendly fire by default (clan members)")]
                public bool DefaultEnableFF { get; set; }

                [JsonProperty(PropertyName = "Only allow clan owner and council to toggle friendly fire (clan members)")]
                public bool OwnerFF { get; set; }

                [JsonProperty(PropertyName = "Alliance Options")]
                public AllianceOptions Alliance { get; set; }

                [JsonProperty(PropertyName = "Invite Options")]
                public InviteOptions Invites { get; set; }

                [JsonProperty(PropertyName = "Rust Team Options")]
                public TeamOptions Teams { get; set; }
                
                public class AllianceOptions
                {
                    [JsonProperty(PropertyName = "Enable clan alliances")]
                    public bool Enabled { get; set; }

                    [JsonProperty(PropertyName = "Alliance limit")]
                    public int AllianceLimit { get; set; }

                    [JsonProperty(PropertyName = "Allow friendly fire toggle (allied clans)")]
                    public bool AllyFF { get; set; }

                    [JsonProperty(PropertyName = "Enable friendly fire by default (allied clans)")]
                    public bool DefaultEnableFF { get; set; }

                    [JsonProperty(PropertyName = "Only allow clan owner and council to toggle friendly fire (allied clans)")]
                    public bool OwnerFF { get; set; }
                }

                public class InviteOptions
                {
                    [JsonProperty(PropertyName = "Maximum allowed member invites at any given time")]
                    public int MemberInviteLimit { get; set; }

                    [JsonProperty(PropertyName = "Member invite expiry time (seconds)")]
                    public int MemberInviteExpireTime { get; set; }

                    [JsonProperty(PropertyName = "Maximum allowed alliance invites at any given time")]
                    public int AllianceInviteLimit { get; set; }

                    [JsonProperty(PropertyName = "Alliance invite expiry time (seconds)")]
                    public int AllianceInviteExpireTime { get; set; }
                }

                public class TeamOptions
                {
                    [JsonProperty(PropertyName = "Automatically create and manage Rust team's for each clan")]
                    public bool Enabled { get; set; }

                    [JsonProperty(PropertyName = "Allow players to leave their clan by using Rust's leave team button")]
                    public bool AllowLeave { get; set; }

                    [JsonProperty(PropertyName = "Allow players to kick members from their clan using Rust's kick member button")]
                    public bool AllowKick { get; set; }

                    [JsonProperty(PropertyName = "Allow players to invite other players to their clan via Rust's team invite system")]
                    public bool AllowInvite { get; set; }

                    [JsonProperty(PropertyName = "Allow players to promote other clan members via Rust's team promote button")]
                    public bool AllowPromote { get; set; }
                }
            }

            public class ColorOptions
            {
                [JsonProperty(PropertyName = "Clan owner color (hex)")]
                public string Owner { get; set; }

                [JsonProperty(PropertyName = "Clan council color (hex)")]
                public string Council { get; set; }

                [JsonProperty(PropertyName = "Clan moderator color (hex)")]
                public string Moderator { get; set; }

                [JsonProperty(PropertyName = "Clan member color (hex)")]
                public string Member { get; set; }

                [JsonProperty(PropertyName = "General text color (hex)")]
                public string TextColor { get; set; }
            }

            public class TagOptions
            {
                [JsonProperty(PropertyName = "Enable clan tags (Display Name)")]
                public bool Enabled { get; set; }

                [JsonProperty(PropertyName = "Enable clan tags (BetterChat)")]
                public bool EnabledBC { get; set; }

                [JsonProperty(PropertyName = "Tag opening character")]
                public string TagOpen { get; set; }

                [JsonProperty(PropertyName = "Tag closing character")]
                public string TagClose { get; set; }
                                
                [JsonProperty(PropertyName = "Tag color (hex) (BetterChat)")]
                public string TagColor { get; set; }

                [JsonProperty(PropertyName = "Allow clan leaders to set custom tag colors (BetterChat only)")]
                public bool CustomColors { get; set; }

                [JsonProperty(PropertyName = "Custom tag color minimum value (hex)")]
                public string CustomTagColorMin { get; set; }

                [JsonProperty(PropertyName = "Custom tag color maximum value (hex)")]
                public string CustomTagColorMax { get; set; }

                [JsonProperty(PropertyName = "Blacklisted tag colors (hex without the # at the start)")]
                public string[] BlockedTagColors { get; set; }

                [JsonProperty(PropertyName = "Tag size (BetterChat)")]
                public int TagSize { get; set; }

                [JsonProperty(PropertyName = "Tag character limits")]
                public Range TagLength { get; set; }

                [JsonProperty(PropertyName = "Special characters allowed in tags")]
                public string AllowedCharacters { get; set; }

                [JsonProperty(PropertyName = "Words/characters not allowed in tags")]
                public string[] BlockedWords { get; set; }
            }

            public class CommandOptions
            {
                [JsonProperty(PropertyName = "Ally chat command")]
                public string AllyChatCommand { get; set; }

                [JsonProperty(PropertyName = "Clan chat command")]
                public string ClanChatCommand { get; set; }

                [JsonProperty(PropertyName = "Clan command")]
                public string ClanCommand { get; set; }

                [JsonProperty(PropertyName = "Clan info command")]
                public string ClanInfoCommand { get; set; }

                [JsonProperty(PropertyName = "Ally friendly fire command")]
                public string AFFCommand { get; set; }

                [JsonProperty(PropertyName = "Friendly fire command")]
                public string FFCommand { get; set; }

                [JsonProperty(PropertyName = "Clan ally command")]
                public string ClanAllyCommand { get; set; }

                [JsonProperty(PropertyName = "Clan help command")]
                public string ClanHelpCommand { get; set; }

                [JsonProperty(PropertyName = "Required auth-levels to use admin console command")]
                public AdminAuth Auth { get; set; }

                [JsonProperty(PropertyName = "Clan info options")]
                public ClanInfo ClanInfoOptions { get; set; }

                public class ClanInfo
                {
                    [JsonProperty(PropertyName = "Show online/offline players")]
                    public bool Players { get; set; }

                    [JsonProperty(PropertyName = "Show clan alliances")]
                    public bool Alliances { get; set; }

                    [JsonProperty(PropertyName = "Show last online time")]
                    public bool LastOnline { get; set; }

                    [JsonProperty(PropertyName = "Show member count")]
                    public bool MemberCount { get; set; }

                    [JsonProperty(PropertyName = "Show alliance count")]
                    public bool AllianceCount { get; set; }
                }

                public class AdminAuth
                {
                    [JsonProperty(PropertyName = "Create clan")]
                    public int Create { get; set; }

                    [JsonProperty(PropertyName = "Rename clan")]
                    public int Rename { get; set; }

                    [JsonProperty(PropertyName = "Disband clan")]
                    public int Disband { get; set; }

                    [JsonProperty(PropertyName = "Invite member to clan")]
                    public int Invite { get; set; }

                    [JsonProperty(PropertyName = "Kick member from clan")]
                    public int Kick { get; set; }

                    [JsonProperty(PropertyName = "Promote/Demote member in clan")]
                    public int Promote { get; set; }
                }
            }

            public class PermissionOptions
            {
                [JsonProperty(PropertyName = "Minimum auth level required to view clan info (0 = player, 1 = moderator, 2 = owner)")]
                public int ClanInfoAuthLevel { get; set; }

                [JsonProperty(PropertyName = "Use permission groups")]
                public bool PermissionGroups { get; set; }

                [JsonProperty(PropertyName = "Permission group prefix")]
                public string PermissionGroupPrefix { get; set; }

                [JsonProperty(PropertyName = "Use permission to create a clan")]
                public bool UsePermissionCreate { get; set; }

                [JsonProperty(PropertyName = "Clan creation permission")]
                public string PermissionCreate { get; set; }

                [JsonProperty(PropertyName = "Use permission to join a clan")]
                public bool UsePermissionJoin { get; set; }

                [JsonProperty(PropertyName = "Clan join permission")]
                public string PermissionJoin { get; set; }

                [JsonProperty(PropertyName = "Use permission to leave a clan")]
                public bool UsePermissionLeave { get; set; }

                [JsonProperty(PropertyName = "Clan leave permission")]
                public string PermissionLeave { get; set; }

                [JsonProperty(PropertyName = "Use permission to disband a clan")]
                public bool UsePermissionDisband { get; set; }

                [JsonProperty(PropertyName = "Clan disband permission")]
                public string PermissionDisband { get; set; }

                [JsonProperty(PropertyName = "Use permission to kick a clan member")]
                public bool UsePermissionKick { get; set; }

                [JsonProperty(PropertyName = "Clan kick permission")]
                public string PermissionKick { get; set; }
            }

            public class PurgeOptions
            {
                [JsonProperty(PropertyName = "Enable clan purging")]
                public bool Enabled { get; set; }

                [JsonProperty(PropertyName = "Purge clans that havent been online for x amount of day")]
                public int OlderThanDays { get; set; }

                [JsonProperty(PropertyName = "List purged clans in console when purging")]
                public bool ListPurgedClans { get; set; }

                [JsonProperty(PropertyName = "Wipe clans on new map save")]
                public bool WipeOnNewSave { get; set; }
            }

            public class OtherOptions
            {
                [JsonProperty(PropertyName = "Block clan/ally chat when muted")]
                public bool DenyOnMuted { get; set; }

                [JsonProperty(PropertyName = "Log clan and member changes")]
                public bool LogChanges { get; set; }

                [JsonProperty(PropertyName = "Use ProtoBuf data storage")]
                public bool UseProtoStorage { get; set; }
            }

            public class Range
            {
                public int Minimum { get; set; }
                public int Maximum { get; set; }

                public Range() { }

                public Range(int minimum, int maximum)
                {
                    this.Minimum = minimum;
                    this.Maximum = maximum;
                }
            }

            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();

            if (configData.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                Clans = new ConfigData.ClanOptions
                {
                    Alliance = new ConfigData.ClanOptions.AllianceOptions
                    {
                        AllianceLimit = 2,
                        AllyFF = true,
                        DefaultEnableFF = false,
                        OwnerFF = false,
                        Enabled = true
                    },
                    Invites = new ConfigData.ClanOptions.InviteOptions
                    {
                        AllianceInviteExpireTime = 86400,
                        AllianceInviteLimit = 2,
                        MemberInviteExpireTime = 86400,
                        MemberInviteLimit = 8
                    },
                    MemberFF = true,
                    DefaultEnableFF = false,
                    OwnerFF = false,
                    MemberLimit = 8,
                    ModeratorLimit = 2,
                    Teams = new ConfigData.ClanOptions.TeamOptions
                    {
                        AllowInvite = true,
                        AllowKick = true,
                        AllowLeave = true,
                        AllowPromote = true,
                        Enabled = true
                    }
                },
                Colors = new ConfigData.ColorOptions
                {
                    Council = "#b573ff",
                    Member = "#fcf5cb",
                    Moderator = "#74c6ff",
                    Owner = "#a1ff46",
                    TextColor = "#e0e0e0"
                },
                Commands = new ConfigData.CommandOptions
                {
                    AllyChatCommand = "a",
                    ClanChatCommand = "c",
                    ClanAllyCommand = "clanally",
                    ClanCommand = "clan",
                    ClanHelpCommand = "clanhelp",
                    ClanInfoCommand = "cinfo",
                    FFCommand = "cff",
                    AFFCommand = "aff",
                    Auth = new ConfigData.CommandOptions.AdminAuth
                    {
                        Create = 2,
                        Disband = 2,
                        Invite = 1,
                        Kick = 2,
                        Promote = 1,
                        Rename = 1
                    },
                    ClanInfoOptions = new ConfigData.CommandOptions.ClanInfo
                    {
                        Alliances = true,
                        LastOnline = true,
                        Players = true,
                        AllianceCount = false,
                        MemberCount = false
                    }
                },
                Options = new ConfigData.OtherOptions
                {
                    LogChanges = false,
                    UseProtoStorage = false,
                    DenyOnMuted = false,
                },
                Permissions = new ConfigData.PermissionOptions
                {
                    ClanInfoAuthLevel = 0,
                    PermissionCreate = "clans.cancreate",
                    PermissionDisband = "clans.candisband",
                    PermissionGroupPrefix = "clan_",
                    PermissionGroups = false,
                    PermissionJoin = "clans.canjoin",
                    PermissionLeave = "clans.canleave",
                    PermissionKick = "clans.cankick",
                    UsePermissionDisband = false,
                    UsePermissionLeave = false,
                    UsePermissionCreate = false,
                    UsePermissionJoin = false,
                    UsePermissionKick = false,
                },
                Purge = new ConfigData.PurgeOptions
                {
                    Enabled = true,
                    ListPurgedClans = true,
                    OlderThanDays = 14,
                    WipeOnNewSave = false
                },
                Tags = new ConfigData.TagOptions
                {
                    AllowedCharacters = "!²³",
                    BlockedWords = new string[] {"admin", "mod", "owner"},
                    CustomColors = false,
                    Enabled = true,
                    TagClose = "]",
                    TagColor = "#aaff55",
                    TagLength = new ConfigData.Range(2, 5),
                    TagOpen = "[",
                    TagSize = 15,
                    CustomTagColorMin = "000000",
                    CustomTagColorMax = "FFFFFF"
                },                
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private void UpdateConfigValues()
        {            
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();

            if (configData.Version < new VersionNumber(3, 0, 0))
                configData = baseConfig;

            if (configData.Version < new VersionNumber(3, 0, 1))
                configData.Tags.TagColor = baseConfig.Tags.TagColor;

            if (configData.Version < new VersionNumber(3, 0, 13))
            {
                configData.Tags.CustomTagColorMin = baseConfig.Tags.CustomTagColorMin;
                configData.Tags.CustomTagColorMax = baseConfig.Tags.CustomTagColorMax;
            }

            if (configData.Version < new VersionNumber(3, 0, 14))
            {
                configData.Permissions.UsePermissionLeave = baseConfig.Permissions.UsePermissionLeave;
                configData.Permissions.UsePermissionDisband = baseConfig.Permissions.UsePermissionDisband;
                configData.Permissions.PermissionDisband = baseConfig.Permissions.PermissionDisband;
                configData.Permissions.PermissionLeave = baseConfig.Permissions.PermissionLeave;
            }

            if (configData.Version < new VersionNumber(3, 0, 15))
            {
                configData.Permissions.UsePermissionKick = baseConfig.Permissions.UsePermissionKick;
                configData.Permissions.PermissionKick = baseConfig.Permissions.PermissionKick;
            }

            if (configData.Version < new VersionNumber(3, 0, 23))
            {
                configData.Tags.Enabled = configData.Tags.EnabledBC = true;
                configData.Commands.ClanInfoOptions = baseConfig.Commands.ClanInfoOptions;
                configData.Tags.BlockedTagColors = new string[0];
            }

            configData.Version = Version;
            PrintWarning("Config update completed!");
        }
        #endregion

        #region Data Management
        private void SaveData()
        {
            storedData.timeSaved = UnixTimeStampUTC();

            if (configData.Options.UseProtoStorage)
                ProtoStorage.Save<StoredData>(storedData, Title);
            else Interface.Oxide.DataFileSystem.WriteObject(Title, storedData);
        }

        private void LoadData()
        {
            try
            {
                StoredData protoStorage = ProtoStorage.Exists(Title) ? ProtoStorage.Load<StoredData>(new string[] { Title }) : null;
                StoredData jsonStorage = Interface.GetMod().DataFileSystem.ExistsDatafile(Title) ? Interface.GetMod().DataFileSystem.ReadObject<StoredData>(Title) : null;

                if (protoStorage == null && jsonStorage == null)
                {
                    Puts("No data file found! Creating new data file");
                    storedData = new StoredData();
                }
                else
                {
                    if (protoStorage == null && jsonStorage != null)
                        storedData = jsonStorage;                        
                    else if (protoStorage != null && jsonStorage == null)
                        storedData = protoStorage;                       
                    else
                    {
                        if (protoStorage.timeSaved > jsonStorage.timeSaved)
                        {
                            storedData = protoStorage;
                            Puts("Multiple data files found! ProtoBuf storage time stamp is newer than JSON storage. Loading ProtoBuf data file");
                        }
                        else
                        {
                            storedData = jsonStorage;
                            Puts("Multiple data files found! JSON storage time stamp is newer than ProtoBuf storage. Loading JSON data file");
                        }
                    }
                }

                if (wipeData)
                {
                    Puts("Backing up data file for data wipe...");
                    if (configData.Options.UseProtoStorage)
                    {
                        ProtoStorage.Save<StoredData>(storedData, Title + ".bak");
                        Puts($"Saved data file backup as {Title}.bak.data");
                    }
                    else
                    {
                        Interface.Oxide.DataFileSystem.WriteObject<StoredData>(Title + ".bak", storedData);
                        Puts($"Saved data file backup as {Title}.bak.json");
                    }

                    storedData.clans.Clear();
                }
            }
            catch { }

            if (storedData?.clans == null)
                storedData = new StoredData();
        }

        [ConsoleCommand("clans.convertdata")]
        private void ConvertFromOldData(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null)
                return;

            if (arg.Args == null || arg.Args.Length == 0)
            {
                SendReply(arg, "clans.convertdata <filename> - Load an old Clans data file and convert it to the new data structure\nThe file name is the name of the file without the extension, it must be a old .json or .proto file, and it must be in your /oxide/data/ folder");
                return;
            }

            string filename = arg.Args[0];

            if (!Interface.GetMod().DataFileSystem.ExistsDatafile(filename) && !ProtoStorage.Exists(new string[] { filename }))
            {
                SendReply(arg, "Unable to find a valid data file with that name");
                return;
            }

            OldDataStructure oldDataStructure = Interface.GetMod().DataFileSystem.ReadObject<OldDataStructure>(filename) ?? ProtoStorage.Load<OldDataStructure>(new string[] { filename });
            if (oldDataStructure == null)
            {
                SendReply(arg, $"Failed to deserialize old data file with the name {filename}");
                return;
            }

            ConvertFromOldData(arg, oldDataStructure);
        }

        private void ConvertFromOldData(ConsoleSystem.Arg arg, OldDataStructure oldData)
        {
            if (oldData.clans.Count == 0)
            {
                SendReply(arg, "No clans exist in the specified data file");
                return;
            }

            SendReply(arg, $"Converting {oldData.clans.Count} old clans to new data structure...");

            storedData = new StoredData();

            foreach(KeyValuePair<string, OldClan> kvp in oldData.clans)
            {               
                OldClan oldClan = kvp.Value;

                if (string.IsNullOrEmpty(oldClan.tag) || string.IsNullOrEmpty(oldClan.owner))
                    continue;

                Clan clan = new Clan();
                clan.Tag = oldClan.tag;
                clan.Description = oldClan.description ?? string.Empty;
                clan.OwnerID = ulong.Parse(oldClan.owner);

                clan.CreationTime = clan.LastOnlineTime = UnixTimeStampUTC();
                
                oldClan.clanAlliances.ForEach((string x) => clan.Alliances.Add(x));

                oldClan.invitedAllies.ForEach((string x) => clan.AllianceInvites.Add(x, UnixTimeStampUTC()));

                foreach (KeyValuePair<string, int> invite in oldClan.invites)
                    clan.MemberInvites.Add(ulong.Parse(invite.Key), new Clan.MemberInvite() { DisplayName = string.Empty, ExpiryTime = invite.Value });

                oldClan.members.ForEach((string x) => 
                    clan.ClanMembers.Add(ulong.Parse(x), 
                    new Clan.Member(!string.IsNullOrEmpty(oldClan.owner) && oldClan.owner.Equals(x) ? Clan.Member.MemberRole.Owner : 
                                    !string.IsNullOrEmpty(oldClan.council) && oldClan.council.Equals(x) ? Clan.Member.MemberRole.Council :
                                    oldClan.moderators.Contains(x) ? Clan.Member.MemberRole.Moderator : Clan.Member.MemberRole.Member, 
                                    configData.Clans.DefaultEnableFF, configData.Clans.Alliance.DefaultEnableFF)));

                storedData.clans[kvp.Key] = clan;
            }

            SaveData();

            SendReply(arg, $"Successfully converted {storedData.clans.Count} old clans to new data structure");

            if (initClansRoutine != null)
                ServerMgr.Instance.StopCoroutine(initClansRoutine);

            isInitialized = false;
            initClansRoutine = ServerMgr.Instance.StartCoroutine(InitializeClans());            
        }

        [Serializable, ProtoContract]
        internal class StoredData
        {
            [ProtoMember(1)]
            public Hash<string, Clan> clans = new Hash<string, Clan>();

            [ProtoMember(2)]
            public int timeSaved;

            [ProtoMember(3)]
            public Hash<ulong, List<string>> playerInvites = new Hash<ulong, List<string>>();

            [JsonIgnore,ProtoIgnore]
            private Hash<ulong, string> playerLookup = new Hash<ulong, string>();

            [JsonIgnore, ProtoIgnore]
            private Hash<string, string> clanLookup = new Hash<string, string>();

            internal Clan FindClan(string tag)
            {
                Clan clan;
                if (clans.TryGetValue(tag, out clan))
                    return clan;

                string lower = tag.ToLower();

                foreach(KeyValuePair<string, Clan> kvp in clans)
                {
                    if (kvp.Key.ToLower().Equals(lower))
                        return kvp.Value;
                }

                return null;
            }

            internal Clan FindClanByID(ulong playerId)
            {
                string tag;
                if (!playerLookup.TryGetValue(playerId, out tag))
                    return null;

                return FindClan(tag);
            }

            internal Clan FindClanByID(string playerId) => FindClanByID(ulong.Parse(playerId));

            internal Clan.Member FindMemberByID(ulong playerId)
            {
                Clan.Member member = null;
                FindClanByID(playerId)?.ClanMembers.TryGetValue(playerId, out member);
                return member;
            }

            internal void RegisterPlayer(ulong playerId, string tag) => playerLookup[playerId] = tag;

            internal void UnregisterPlayer(ulong playerId) => playerLookup.Remove(playerId);

            internal void AddPlayerInvite(ulong target, string tag)
            {
                List<string> invites;
                if (!playerInvites.TryGetValue(target, out invites))
                    invites = playerInvites[target] = new List<string>();

                if (!invites.Contains(tag))
                    invites.Add(tag);
            }

            internal void RevokePlayerInvite(ulong target, string tag)
            {
                List<string> invites;
                if (!playerInvites.TryGetValue(target, out invites))
                    return;

                invites.Remove(tag);

                if (invites.Count == 0)
                    playerInvites.Remove(target);
            }

            internal void OnInviteAccepted(ulong target, string tag)
            {
                List<string> invites;
                if (!playerInvites.TryGetValue(target, out invites))
                    return;

                for (int i = invites.Count - 1; i >= 0; i--)
                {
                    string t = invites[i];

                    if (!t.Equals(tag))
                        FindClan(t)?.MemberInvites.Remove(target);

                    invites.RemoveAt(i);
                }

                if (invites.Count == 0)                
                    playerInvites.Remove(target);                
            }

            internal void OnInviteRejected(ulong target, string tag)
            {
                List<string> invites;
                if (!playerInvites.TryGetValue(target, out invites))
                    return;

                invites.Remove(tag);

                if (invites.Count == 0)
                    playerInvites.Remove(target);
            }
        }    
        
        private class OldDataStructure
        {
            public Dictionary<string, OldClan> clans = new Dictionary<string, OldClan>();
            public int saveStamp = 0;
            public string lastStorage = string.Empty;
        }

        public class OldClan
        {
            public string tag;
            public string description;
            public string owner;
            public string council;
            public int created;
            public int updated;

            public List<string> moderators = new List<string>();
            public List<string> members = new List<string>();
            public Dictionary<string, int> invites = new Dictionary<string, int>();
            public List<string> clanAlliances = new List<string>();
            public List<string> invitedAllies = new List<string>();
            public List<string> pendingInvites = new List<string>();
        }
        #endregion

        #region Localization
        private static string msg(string key, string playerId = null) => string.Format(COLORED_LABEL, configData.Colors.TextColor, Instance.lang.GetMessage(key, Instance, playerId));

        Dictionary<string, string> Messages = new Dictionary<string, string>
        {            
            ["Notification.ClanInfo.Title"] = "<size=18><color=#ffa500>Clans</color></size><size=14><color=#ce422b> REBORN</color></size>",
            ["Notification.ClanInfo.Tag"] = "\nClanTag: <color=#b2eece>{0}</color>",
            ["Notification.ClanInfo.Description"] = "\nDescription: <color=#b2eece>{0}</color>",
            ["Notification.ClanInfo.Online"] = "\nMembers Online: {0}",
            ["Notification.ClanInfo.Offline"] = "\nMembers Offline: {0}",
            ["Notification.ClanInfo.Established"] = "\nEstablished: <color=#b2eece>{0}</color>",
            ["Notification.ClanInfo.LastOnline"] = "\nLast Online: <color=#b2eece>{0}</color>",
            ["Notification.ClanInfo.Alliances"] = "\nAlliances: <color=#b2eece>{0}</color>",
            ["Notification.ClanInfo.Alliances.None"] = "None",
            ["Notification.ClanInfo.TotalMembers"] = "\nMembers: <color=#b2eece>{0}</color>",
            ["Notification.ClanInfo.TotalAlliances"] = "\nAlliances: <color=#b2eece>{0}</color>",

            ["Notification.Create.InExistingClan"] = "You are already a member of a clan",
            ["Notification.Create.NoPermission"] = "You do not have permission to create a clan",
            ["Notification.Create.InvalidTagLength"] = "The tag you have chosen is invalid. It must be between {0} and {1} characters long",
            ["Notification.Create.InvalidCharacters"] = "The tag you have chosen contains words/characters that are not allowed to be used",
            ["Notification.Create.ClanExists"] = "A clan with that tag already exists",
            ["Notification.Create.NoNativeCreate"] = "You must create a clan using /clan create <tag> <description>",
            ["Notification.Create.Success"] = "You have formed the clan <color=#aaff55>[{0}]</color>",

            ["Notification.Kick.IsOwner"] = "You can not kick the clan owner",
            ["Notification.Kick.NoPermissions"] = "You do not have sufficient permission to kick clan members",
            ["Notification.Kick.NotClanmember"] = "The target is not a member of your clan",
            ["Notification.Kick.Self"] = "You can not kick yourself",
            ["Notification.Kick.NotEnoughRank"] = "Only the clan owner can kick another ranking member",
            ["Notification.Kick.NoPlayerFound"] = "Unable to find a player with the specified name of ID",
            ["Notification.Kick.Message"] = "{0} kicked {1} from the clan!",
            ["Notification.Kick.PlayerMessage"] = "{0} kicked you from the clan!",
            ["Notification.Kick.NoPermission"] = "You do not have permission to kick clan members",

            ["Notification.Leave.Message"] = "{0} has left the clan!",
            ["Notification.Leave.PlayerMessage"] = "You have left the clan <color=#aaff55>[{0}]</color>!",
            ["Notification.Leave.NewOwner"] = "{0} is now the clan leader!",
            ["Notification.Leave.NoPermission"] = "You do not have permission to leave this clan",

            ["Notification.Join.NoPermission"] = "You do not have permission to join a clan",
            ["Notification.Join.ExpiredInvite"] = "Your invite to {0} has expired!",
            ["Notification.Join.InExistingClan"] = "You are already a member of another clan",
            ["Notification.Join.Message"] = "{0} has joined the clan!",

            ["Notification.Invite.NoPermissions"] = "You do not have sufficient permissions to invite other players",
            ["Notification.Invite.InviteLimit"] = "You already have the maximum number of invites allowed",
            ["Notification.Invite.HasPending"] = "{0} all ready has a pending clan invite",
            ["Notification.Invite.IsMember"] = "{0} is already a clan member",
            ["Notification.Invite.InClan"] = "{0} is already a member of another clan",
            ["Notification.Invite.NoPermission"] = "{0} does not have the required permission to join a clan",
            ["Notification.Invite.SuccesTarget"] = "You have been invited to join the clan: <color=#aaff55>[{0}]</color> '{1}'\nTo join, type: <color=#ffd479>/{2} accept {0}</color>",
            ["Notification.Invite.SuccessClan"] = "{0} has invited {1} to join the clan",
            ["Notification.PendingInvites"] = "You have pending clan invites from: {0}\nYou can join a clan type: <color=#ffd479>/{1} accept <tag></color>",

            ["Notification.WithdrawInvite.NoPermissions"] = "You do not have sufficient permissions to withdraw member invites",
            ["Notification.WithdrawInvite.UnableToFind"] = "Unable to find a invite for the player with {0}",
            ["Notification.WithdrawInvite.Success"] = "{0} revoked the member invitation for {0}",

            ["Notification.RejectInvite.InvalidInvite"] = "You do not have a invite to join <color=#aaff55>[{0}]</color>",
            ["Notification.RejectInvite.Message"] = "{0} has rejected their invition to join your clan",
            ["Notification.RejectInvite.PlayerMessage"] = "You have rejected the invitation to join <color=#aaff55>[{0}]</color>",

            ["Notification.Promotion.NoPermissions"] = "You do not have sufficient permissions to promote other players",
            ["Notification.Promotion.TargetNoClan"] = "{0} is not a member of your clan",
            ["Notification.Promotion.IsOwner"] = "You can not promote the clan leader",
            ["Notification.Promotion.IsCouncil"] = "You can not promote higher than the rank of council",
            ["Notification.Promotion.CouncilTaken"] = "The rank of council has already been awarded",
            ["Notification.Promotion.ModeratorLimit"] = "You already have the maximum amount of moderators",
            ["Notification.Promotion.IsModerator"] = "You can not promote higher than the rank of moderator",
            ["Notification.Promotion.Message"] = "{0} was promoted to rank of {1} by {2}",

            ["Notification.Demotion.NoPermissions"] = "You do not have sufficient permissions to demote other players",
            ["Notification.Demotion.IsOwner"] = "You can not demote the clan leader",
            ["Notification.Demotion.IsMember"] = "{0} is already at the lowest rank",
            ["Notification.Demotion.Message"] = "{0} was demoted to rank of {1} by {2}",

            ["Notification.Alliance.NoPermissions"] = "You do not have sufficient permissions to manage alliances",
            ["Notification.Alliance.PendingInvite"] = "<color=#aaff55>[{0}]</color> already has a pending alliance invite",
            ["Notification.Alliance.MaximumInvites"] = "You already have the maximum amount of alliance invites allowed",
            ["Notification.Alliance.MaximumAlliances"] = "You already have the maximum amount of alliances formed",
            ["Notification.Alliance.InviteSent"] = "You have sent a clan alliance invitation to <color=#aaff55>[{0}]</color>\nThe invitation will expire in: {1}",
            ["Notification.Alliance.InviteReceived"] = "You have received a clan alliance invitation from <color=#aaff55>[{0}]</color>\nTo accept, type: <color=#ffd479>/{2} accept {0}</color>\nThe invitation will expire in: {1}",  
            ["Notification.Alliance.NoActiveInvite"] = "You do not have an active alliance invitation for <color=#aaff55>[{0}]</color>",
            ["Notification.Alliance.NoActiveInviteFrom"] = "You do not have an active alliance invitation from <color=#aaff55>[{0}]</color>",
            ["Notification.Alliance.WithdrawnClan"] = "{0} has withdrawn an alliance invitation to <color=#aaff55>[{1}]</color>",
            ["Notification.Alliance.WithdrawnTarget"] = "<color=#aaff55>[{0}]</color> has withdrawn their alliance invitation",
            ["Notification.Alliance.AtLimitTarget"] = "<color=#aaff55>[{0}]</color> currently has the maximum amount of alliances allowed",
            ["Notification.Alliance.AtLimitSelf"] = "Your clan currently has the maximum amount of alliances allowed",
            ["Notification.Alliance.Formed"] = "<color=#aaff55>[{0}]</color> has formed an alliance with <color=#aaff55>[{1}]</color>",
            ["Notification.Alliance.Rejected"] = "<color=#aaff55>[{0}]</color> has rejected calls to form an alliance with <color=#aaff55>[{1}]</color>",
            ["Notification.Alliance.Revoked"] = "<color=#aaff55>[{0}]</color> has revoked their alliance with <color=#aaff55>[{1}]</color>",
            ["Notification.Alliance.NoActiveAlliance"] = "You do not currently have an alliance with <color=#aaff55>[{0}]</color>",

            ["Notification.FF.MemberEnabled"] = "Clanmates <color=#ffd479>will</color> take damage from friendly fire",
            ["Notification.FF.MemberDisabled"] = "Clanmates <color=#ffd479>won't</color> take damage from friendly fire",
            ["Notification.FF.AllyEnabled"] = "Allies <color=#ffd479>will</color> take damage from friendly fire",
            ["Notification.FF.AllyDisabled"] = "Allies <color=#ffd479>won't</color> take damage from friendly fire",           
            ["Notification.FF.IsEnabled"] = "<color=#aaff55>Enabled</color>",
            ["Notification.FF.IsDisabled"] = "<color=#ce422b>Disabled</color>",
            ["Notification.FF.OnHitClanMember"] = "{0} is a clan member and can not be hurt.\nTo toggle clan friendly fire type: <color=#ffd479>/{1}</color>",
            ["Notification.FF.OnHitAllyMember"] = "{0} is a member of an allied clan and can not be hurt.\nTo toggle ally friendly fire type: <color=#ffd479>/{1}</color>",
            ["Notification.FF.ToggleNotOwner"] = "Only the clan Owner or Council can toggle friendly fire",
            ["Notification.FF.OwnerToggle"] = "{0} has toggled friendly fire.\n{1}",
            ["Notification.FF.OwnerAllyToggle"] = "{0} has toggled allied friendly fire.\n{1}",

            ["Notification.ClanHelp.NoClan"] = "\nAvailable Commands:\n<color=#ffd479>/{0} create <tag> \"description\"</color> - Create a new clan\n<color=#ffd479>/{0} accept <tag></color> - Join a clan by invitation\n<color=#ffd479>/{0} reject <tag></color> - Reject a clan invitation",
            ["Notification.ClanHelp.Basic2"] = "\nAvailable Commands:\n<color=#ffd479>/{0}</color> - Display your clan information\n<color=#ffd479>/{1} <message></color> - Send a message via clan chat\n<color=#ffd479>/{0} leave</color> - Leave your current clan",
            ["Notification.ClanHelp.MFF"] = "\n<color=#ffd479>/{0}</color> - Toggle friendly fire against other clan mates",
            ["Notification.ClanHelp.AFF"] = "\n<color=#ffd479>/{0}</color> - Toggle friendly fire against allied clan members",
            ["Notification.ClanHelp.Alliance"] = "\n\n<color=#45b6fe><size=14>Alliance Commands:</size></color>\n<color=#ffd479>/{0} invite <tag></color> - Invite a clan to become allies\n<color=#ffd479>/{0} withdraw <tag></color> - Withdraw an alliance invitation\n<color=#ffd479>/{0} accept <tag></color> - Accept an alliance invitation\n<color=#ffd479>/{0} reject <tag></color> - Reject an alliance invitation\n<color=#ffd479>/{0} revoke <tag></color> - Revoke an alliance",
            ["Notification.ClanHelp.Moderator"] = "\n\n<color=#b573ff><size=14>Moderator Commands:</size></color>\n<color=#ffd479>/{0} invite <name or ID></color> - Invite a player to your clan\n<color=#ffd479>/{0} withdraw <name or ID></color> - Revoke a invitation\n<color=#ffd479>/{0} kick <name or ID></color> - Kick a member from your clan",
            ["Notification.ClanHelp.Owner"] = "\n\n<color=#a1ff46><size=14>Owner Commands:</size></color>\n<color=#ffd479>/{0} promote <name or ID></color> - Promote a clan member\n<color=#ffd479>/{0} demote <name or ID></color> - Demote a clan member\n<color=#ffd479>/{0} disband forever</color> - Disband your clan",

            ["Notification.ClanHelp.TagColor"] = "\n<color=#ffd479>/{0} tagcolor <hex></color> - Sets a custom clan tag color\n<color=#ffd479>/{0} tagcolor reset</color> - Restores the default clan tag color",

            ["Notification.Clan.NotInAClan"] = "\nYou are currently not a member of a clan",
            ["Notification.Clan.Help"] = "\nTo see available commands type: <color=#ffd479>/{0}</color>",
            ["Notification.Clan.OwnerOf"] = "\nYou are the owner of: <color=#aaff55>{0}</color> ({1}/{2})",
            ["Notification.Clan.CouncilOf"] = "\nYou are the council of: <color=#aaff55>{0}</color> ({1}/{2})",
            ["Notification.Clan.ModeratorOf"] = "\nYou are a moderator of: <color=#aaff55>{0}</color> ({1}/{2})",
            ["Notification.Clan.MemberOf"] = "\nYou are a member of: <color=#aaff55>{0}</color> ({1}/{2})",
            ["Notification.Clan.MembersOnline"] = "\nMembers Online: {0}",
            ["Notification.Clan.MFF"] = "\nClan FF Status: {0} (<color=#ffd479>/{1}</color>)",
            ["Notification.Clan.AFF"] = "\nAlly FF Status: {0} (<color=#ffd479>/{1}</color>)",

            ["Notification.Clan.CreateSyntax"] = "<color=#ffd479>/{0} create <tag> \"description\"</color> - Create a new clan",
            ["Notification.Clan.InviteSyntax"] = "<color=#ffd479>/{0} invite <partialNameOrID></color> - Invite a player to your clan",
            ["Notification.Clan.WithdrawSyntax"] = "<color=#ffd479>/{0} withdraw <partialNameOrID></color> - Revoke a member invitation",
            ["Notification.Clan.AcceptSyntax"] = "<color=#ffd479>/{0} accept <tag></color> - Join a clan by invitation",
            ["Notification.Clan.RejectSyntax"] = "<color=#ffd479>/{0} reject <tag></color> - Reject a clan invitation",
            ["Notification.Clan.PromoteSyntax"] = "<color=#ffd479>/{0} promote <partialNameOrID></color> - Promote a clanFreb member to the next rank",
            ["Notification.Clan.DemoteSyntax"] = "<color=#ffd479>/{0} demote <partialNameOrID></color> - Demote a clan member to the next lowest rank",
            ["Notification.Clan.DisbandSyntax"] = "<color=#ffd479>/{0} disband forever</color> - Disband your clan (this can not be undone)",
            ["Notification.Clan.KickSyntax"] = "<color=#ffd479>/{0} kick <partialNameOrID></color> - Kick a member from your clan",

            ["Notification.Clan.TagColorSyntax"] = "<color=#ffd479>/{0} tagcolor <hex (XXXXXX)></color> - Set a custom clan tag color",
            ["Notification.Clan.TagColorFormat"] = "<color=#ffd479>The hex string must be 6 characters long, and be a valid hex color</color>",
            ["Notification.Clan.TagColorReset"] = "<color=#ffd479>You have reset your clan's tag color</color>",
            ["Notification.Clan.TagColorSet"] = "<color=#ffd479>You have set your clan's tag color to</color> <color=#{0}>{0}</color>",
            ["Notification.Clan.TagColorDisabled"] = "<color=#ffd479>Custom tag colors are disabled on this server</color>",
            ["Notification.Clan.TagColorBlocked"] = "<color=#ffd479>The color <color=#{0}>{0}</color> is blacklisted for use by clans.",
            ["Notification.Clan.TagColorOutOfRange"] = "<color=#ffd479>The color <color=#{0}>{0}</color> is out of the allowed color range. You must pick a color between <color=#{1}>{1}</color> and <color=#{2}>{2}</color></color>",

            ["Notification.Disband.NotOwner"] = "You must be the clan owner to use this command",
            ["Notification.Disband.Success"] = "You have disbanded the clan <color=#aaff55>[{0}]</color>",
            ["Notification.Disband.Message"] = "The clan has been disbanded",
            ["Notification.Disband.NoPermission"] = "You do not have permission to disband this clan",

            ["Notification.Generic.ClanFull"] = "The clan is already at maximum capacity",
            ["Notification.Generic.NoClan"] = "You are not a member of a clan",
            ["Notification.Generic.InvalidClan"] = "The clan <color=#aaff55>[{0}]</color> does not exist!",
            ["Notification.Generic.NoPermissions"] = "You have insufficient permission to use that command",
            ["Notification.Generic.SpecifyClanTag"] = "Please specify a clan tag",
            ["Notification.Generic.UnableToFindPlayer"] = "Unable to find a player with the name or ID {0}",
            ["Notification.Generic.CommandSelf"] = "You can not use this command on yourself",

            ["Chat.IsMuted"] = "You are currently muted",
            ["Chat.Alliance.Prefix"] = "<color=#a1ff46>[ALLY CHAT]</color>: {0}",
            ["Chat.Clan.Prefix"] = "<color=#a1ff46>[CLAN CHAT]</color>: {0}",
            ["Chat.Alliance.Format"] = "[{0}] <color={1}>{2}</color>: {3}",

            ["Admin.BroadcastToClan"] = "<color=#ff3333>[ADMIN]</color>: {0}",
            ["Admin.Rename"] = "An administrator changed your clan tag to <color=#aaff55>[{0}]</color>",
            ["Admin.Disband"] = "An administrator has disbanded your clan",
            ["Admin.Invite"] = "An administrator has invited {0} to join your clan",
            ["Admin.Join"] = "An administrator has forced you to join <color=#aaff55>[{0}]</color>",
            ["Admin.Kick"] = "An administrator has kicked you from <color=#aaff55>[{0}]</color>",
            ["Admin.SetOwner"] = "An administrator has set {0} as the clan leader",
            ["Admin.Promote"] = "An administrator has promoted {0} to the rank of {1}",
            ["Admin.Demote"] = "An administrator has demoted {0} to the rank of {1}",
        };

        private Dictionary<string, string> leetTable = new Dictionary<string, string>
        {
            { "}{", "h" },
            { "|-|", "h" },
            { "]-[", "h" },
            { "/-/", "h" },
            { "|{", "k" },
            { "/\\/\\", "m" },
            { "|\\|", "n" },
            { "/\\/", "n" },
            { "()", "o" },
            { "[]", "o" },
            { "vv", "w" },
            { "\\/\\/", "w" },
            { "><", "x" },
            { "2", "z" },
            { "4", "a" },
            { "@", "a" },
            { "8", "b" },
            { "ß", "b" },
            { "(", "c" },
            { "<", "c" },
            { "{", "c" },
            { "3", "e" },
            { "€", "e" },
            { "6", "g" },
            { "9", "g" },
            { "&", "g" },
            { "#", "h" },
            { "$", "s" },
            { "7", "t" },
            { "|", "l" },
            { "1", "i" },
            { "!", "i" },
            { "0", "o" },
        };
        #endregion
    }
}


// --- End of file: Clans (1).cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/Kits.cs ---
// --- Original Local Path: Kits.cs ---

﻿using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Kits", "OMHOMHOM", 0.1)]

    class Kits: RustPlugin
    {
        #region Fields

        private string Layer = "UI.Kits";
        private string LayerBlur = "UI.Kits.Blur";
        private string LayerBlurKitsInfo = "UI.Kits.Blur";
        

        #endregion 

        #region Hooks
        
        object OnPlayerRespawned(BasePlayer player)
        { 
            player.inventory.Strip();
 
            foreach (var kitItem in _config.spawnKit)
            {
                var item = ItemManager.CreateByName(kitItem.shortname, kitItem.amount, kitItem.skinID);

                if (kitItem.place == "Одежда")
                {
                    item.MoveToContainer(player.inventory.containerWear);
                    
                    continue; 
                }

                if (kitItem.place == "Панель")
                {
                    item.MoveToContainer(player.inventory.containerBelt);
                    continue;
                }

                item.MoveToContainer(player.inventory.containerMain);
            }
            
            return null;
        }

        void Loaded()
        {
            LoadData();
			AddImage("https://static.moscow.ovh/images/games/rust//plugins/ultimate_ui/exit.png", "Kits_img_exit");
        }

        void OnServerInitialized()
        {
            timer.Every(310f, SaveData);
            
            foreach (var kit in _config.kits)
            {
                if (string.IsNullOrEmpty(kit.privilege)) continue;
                
                permission.RegisterPermission(kit.privilege, this);
            }
                        
            SaveConfig();
        }

        private KitsInfo GetKitsInfo(BasePlayer player)
        {
            KitsInfo result;
            if (!storedData.players.TryGetValue(player.userID, out result))
            {
                result = storedData.players[player.userID] = new KitsInfo();
            }

            return result;
        }

        private KitData GetKitData(KitsInfo kitsInfo, KitInfo kitInfo)
        {
            KitData result;
            if (!kitsInfo.kits.TryGetValue(kitInfo.kitName, out result))
            {
                result = kitsInfo.kits[kitInfo.kitName] = new KitData()
                {
                    amount = kitInfo.maxUse,
                    cooldown = 0
                };
            }

            return result;
        }

        void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, Layer);
                CuiHelper.DestroyUi(player, LayerBlur);
            }
            
            SaveData();
        }

        #endregion

        #region Commands
        
        [ChatCommand("createkit")]
        private void CreateKit(BasePlayer player, string command, string[] args)
        {
            if (player.Connection.authLevel < 2) return;
            
            if (_config.kits.Exists(x => x.kitName == args[0]))
            {
                SendReply(player, "Название уже кита уже существует!");
                return;
            }

            _config.kits.Add(new KitInfo()
            {
                kitName = args[0],
                cooldownKit = 0,
                items = GetPlayerItems(player),
                maxUse = -1,
                privilege = ""
            });
            
            permission.RegisterPermission($"kits.default", this); 
            SendReply(player, $"Создали кит с именем {args[0]}");
            SaveConfig();
        }

        [ConsoleCommand("UI_KITS")]
        private void cmdConsoleHandler(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();

            if (!arg.HasArgs(1)) return;

            var cmd = arg.GetString(0);

            var kits = GetKitsForPlayer(player);
            var kitsInfo = GetKitsInfo(player);
            
            switch (cmd)
            {
                case "prev":
                {
                    player.SendConsoleCommand("UI_KITS showavailablekits");
                    break;
                }
                case "close":
                {
                    CuiHelper.DestroyUi(player, Layer);
                    CuiHelper.DestroyUi(player, LayerBlur);
                    break;
                }
                case "showinfokit":
                {
                    var targetNameKit = arg.GetString(1);
                    if (arg.HasArgs(3)) targetNameKit += $" {arg.GetString(2)}";
                    var kitInfo = _config.kits.FirstOrDefault(x => x.kitName.Equals(targetNameKit));
                    if (kitInfo == null) return;

                    CuiHelper.DestroyUi(player, Layer);

                    var container = new CuiElementContainer();
                    
                    container.Add(new CuiPanel
                    {
                        CursorEnabled = true,
                        Image =
                    {
                        FadeIn = 0.2f,
                        Sprite = "assets/content/ui/ui.background.transparent.radial.psd",
                        Color = "0 0 0 1"
                    }
                    }, "Overlay", Layer);
                    container.Add(new CuiPanel
                    {
                    Image =
                    {
                        FadeIn = 0.2f,
                        Color = "0.2 0.2 0.17 0.7",
                        Material = "assets/content/ui/uibackgroundblur.mat"
                    }
                    }, Layer);
                    
                    container.Add(new CuiLabel
                    {
                        Text = { Text = targetNameKit.ToUpper(), Align = TextAnchor.UpperCenter, FontSize = 40, Font = "robotocondensed-bold.ttf" },
                        RectTransform = { AnchorMin = "0.3 1", AnchorMax = "0.7 1", OffsetMin = "0 -155", OffsetMax = "0 -91.6" }
                    }, Layer);
                    container.Add(new CuiLabel
                    {
                        Text = { Text = "Данный набор содержит следующие предметы:", Align = TextAnchor.UpperCenter, FontSize = 18, Font = "robotocondensed-regular.ttf" },
                        RectTransform = { AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin = "0 -155", OffsetMax = "0 -133" }
                    }, Layer);

                    container.Add(new CuiElement
                    {
                        Parent = Layer,
                        Components =
                        {
                            GetImageComponent("https://static.moscow.ovh/images/games/rust//plugins/ultimate_ui/exit.png", "Kits_img_exit"),
                            new CuiRectTransformComponent {AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-73.9 20", OffsetMax = "-28.6 80"},
                        }
                    });
                    container.Add(new CuiElement
                    {
                        Parent = Layer,
                        Components =
                        {
                            new CuiImageComponent {Color = "0.33 0.87 0.59 0.6"},
                            new CuiRectTransformComponent {AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-291.3 22.6", OffsetMax = "-108 25.2"}
                        }
                    });
                    container.Add(new CuiButton
                    {
                        Button =
                        {
                            Color = "0 0 0 0",
                            Command = "UI_KITS prev",
                            Close = Layer
                        },
                        Text = { Text = "Вернуться назад", Align = TextAnchor.UpperCenter, FontSize = 18 },
                        RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-291.3 22.6", OffsetMax = "-108 49.2" },
                    }, Layer);
                    container.Add(new CuiButton
                    {
                        Button =
                        {
                            Color = "0 0 0 0",
                            Command = "UI_KITS prev",
                            Close = Layer
                        },
                        Text = { Text = "" },
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    }, Layer);

                    var itemSize = 103.3f;
                    var itemSep = 6.6f;
                    var num = Mathf.Min(6, kitInfo.items.Count);
                    var posX = -(itemSize * num + itemSep * (num - 1)) / 2f;
                    var posY = 0f;
                    
                    for (var i = 0; i < kitInfo.items.Count;)
                    {
                        var item = kitInfo.items[i];
                        container.Add(new CuiPanel
                        {
                            RectTransform =
                            {
                                AnchorMin = "0.5 0.65", AnchorMax = "0.5 0.65", OffsetMin = $"{posX} {posY - itemSize}", OffsetMax = $"{posX + itemSize} {posY}"
                            },
                            Image = { Color = "0 0 0 0.6" }
                        }, Layer, Layer + $".Item{i}");
                        
                        container.Add(new CuiElement
                        {
                            Parent = Layer + $".Item{i}",
                            Components =
                            {
                                GetItemImageComponent(item.shortname),
                                new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "5 5", OffsetMax = "-5 -5" },
                            }
                        });

                        if (item.amount > 1)
                        {
                            container.Add(new CuiLabel()
                            {
                                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMax = "-3 -3" },
                                Text = { Text = $"x{item.amount}", Font = "RobotoCondensed-Bold.ttf", Align = TextAnchor.LowerRight, FontSize = 14 }
                            }, Layer + $".Item{i}");
                        }

                        if (++i % 6 == 0)
                        {
                            posY -= itemSize + itemSep;
                            num = Mathf.Min(6, kitInfo.items.Count - i);
                            posX = -(itemSize * num + itemSep * (num - 1)) / 2f;
                        }
                        else posX += itemSize + itemSep;
                    }
                    CuiHelper.AddUi(player, container);

                    break;
                }
                case "showavailablekits":
                {
                    CuiHelper.DestroyUi(player, Layer);

                    var container = new CuiElementContainer();

                    container.Add(new CuiPanel
                    {
                        CursorEnabled = true,
                        Image =
                        {
                            FadeIn = 0.2f,
                            Sprite = "assets/content/ui/ui.background.transparent.radial.psd",
                            Color = "0 0 0 1"
                        }
                    }, "Overlay", Layer);
                    container.Add(new CuiPanel
                    {
                        Image =
                        {
                            FadeIn = 0.2f,
                            Color = "0.2 0.2 0.17 0.7",
                            Material = "assets/content/ui/uibackgroundblur.mat"
                        }
                    }, Layer);

                    container.Add(new CuiLabel
                    {
                        Text = { Text = "НАБОРЫ", Align = TextAnchor.UpperCenter, FontSize = 40, Font = "robotocondensed-bold.ttf" },
                        RectTransform = { AnchorMin = "0.3 1", AnchorMax = "0.7 1", OffsetMin = "0 -155", OffsetMax = "0 -91.6" }
                    }, Layer);
                    container.Add(new CuiLabel
                    {
                        Text = { Text = "Вы можете забрать наборы", Align = TextAnchor.UpperCenter, FontSize = 18, Font = "robotocondensed-regular.ttf" },
                        RectTransform = { AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin = "0 -155", OffsetMax = "0 -133" }
                    }, Layer);

                    container.Add(new CuiElement
                    {
                        Parent = Layer,
                        Components =
                        {
                            GetImageComponent("https://static.moscow.ovh/images/games/rust//plugins/ultimate_ui/exit.png", "Kits_img_exit"),
                            new CuiRectTransformComponent {AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-73.9 20", OffsetMax = "-28.6 80"},
                        }
                    });
                    container.Add(new CuiElement
                    {
                        Parent = Layer,
                        Components =
                        {
                            new CuiImageComponent {Color = "0.33 0.87 0.59 0.6"},
                            new CuiRectTransformComponent {AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-291.3 22.6", OffsetMax = "-108 25.2"}
                        }
                    });
                    container.Add(new CuiButton
                    {
                        Button =
                        {
                            Color = "0 0 0 0",
                            Command = "UI_KITS close",
                            Close = Layer
                        },
                        Text = { Text = "Покинуть страницу", Align = TextAnchor.UpperCenter, FontSize = 18 },
                        RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-291.3 22.6", OffsetMax = "-108 49.2" },
                    }, Layer);
                    container.Add(new CuiButton
                    {
                        Button =
                        {
                            Color = "0 0 0 0",
                            Command = "UI_KITS close",
                            Close = Layer
                        },
                        Text = { Text = "" },
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    }, Layer);

                        var kitSizeX = 183.3f;
                    var kitSizeY = 46.6f;
                    var kitSepX = 13.3f;
                    var kitSepY = 24f;
                    var num = Mathf.Min(5, kits.Count);
                    var posX = -(kitSizeX * num + kitSepX * (num - 1)) / 2f;
                    var posY = 0f;
                    
                    for (var i = 0; i < kits.Count;)
                    {
                        var kit = kits.ElementAt(i);
                        var dataPlayer = GetKitData(kitsInfo, kit);
                        var time = dataPlayer.cooldown - TimeHelper.GetTimeStamp();

                        container.Add(new CuiButton
                        {
                            RectTransform = { AnchorMin = "0.5 0.65", AnchorMax = "0.5 0.65", OffsetMin = $"{posX} {posY - kitSizeY}", OffsetMax = $"{posX + kitSizeX} {posY}"},
                            Text =
                            {
                                Align = TextAnchor.MiddleCenter,
                                FontSize = 18,
                                Text = kit.kitName
                            },
                            Button =
                            {
                                Color = "0 0 0 0.6",
                                Command = $"UI_KITS givekit {kit.kitName} {i}"
                            }
                        }, Layer, Layer + $".Kits{i}");
                        
                        container.Add(new CuiButton
                        {
                            RectTransform = { AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = "-16 -16", OffsetMax = "0 0" },
                            Text =
                            {
                                Text = "?",
                                FontSize = 12,
                                Align = TextAnchor.MiddleCenter
                            },
                            Button =
                            {
                                Color = "0 0 0 0.6",
                                Command = $"UI_KITS showinfokit {kit.kitName}"
                            }
                        }, Layer + $".Kits{i}");

                        if (time < 0)
                        {
                            container.Add(new CuiPanel
                            {
                                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0", OffsetMin = "0 0", OffsetMax = "0 4.6" },
                                Image = { Color = "0.33 0.87 0.59 0.6" }
                            }, Layer + $".Kits{i}", Layer + $".Kits{i}.Status");
                        }
                        else
                        {
                            container.Add(new CuiLabel
                            {
                                Text =
                                {
                                    Align = TextAnchor.LowerCenter,
                                    FontSize = 13,
                                    Font = "RobotoCondensed-Regular.ttf",
                                    Text = TimeHelper.FormatTime(TimeSpan.FromSeconds(time), 2)
                                },
                                RectTransform = { AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin = "0 2", OffsetMax = $"0 {kitSepY}" }
                            }, Layer + $".Kits{i}", Layer + $".Kits{i}.Status.Text");
                                container.Add(new CuiPanel
                            {
                                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0", OffsetMin = "0 0", OffsetMax = "0 4.6" },
                                Image = { Color = "0.87 0.33 0.33 0.5" }
                            }, Layer + $".Kits{i}", Layer + $".Kits{i}.Status");
                        }
                        if (++i % 5 == 0)
                        {
                            posY -= kitSizeY + kitSepY;
                            num = Mathf.Min(5, kits.Count - i);
                            posX = -(kitSizeX * num + kitSepX * (num - 1)) / 2f;
                        }
                        else posX += kitSizeX + kitSepX;
                    }

                    CuiHelper.AddUi(player, container);

                    break;
                }
                case "givekit":
                {
                    var nameKit = arg.GetString(1, "text");

                    int idKit;

                    if (arg.HasArgs(4))
                    {
                        idKit = arg.GetInt(3);
                        nameKit += " " + arg.GetString(2);
                    }
                    else idKit = arg.GetInt(2);

                    var kitInfo1 = _config.kits.Find(kit => kit.kitName == nameKit);
                    if (kitInfo1 == null) return;

                    var playerData = GetKitData(kitsInfo, kitInfo1);

                    var kitData = _config.kits.First(x => x.kitName == nameKit);
                    if (playerData != null)
                    {
                        if (playerData.cooldown > TimeHelper.GetTimeStamp()) return;

                        if (playerData.amount != -1)
                        {
                            if (playerData.amount == 0) return;
                        }

                        GiveItems(player, kitData);
                        playerData.cooldown = TimeHelper.GetTimeStamp() + kitData.cooldownKit;

                        CuiHelper.DestroyUi(player, Layer + $".Kits{idKit}.Status.Text");
                        CuiHelper.DestroyUi(player, Layer + $".Kits{idKit}.Status");
                        CuiHelper.DestroyUi(player, Layer + "Status");

                        var container = new CuiElementContainer();

                        container.Add(new CuiLabel
                        {
                            Text =
                        {
                            Align = TextAnchor.LowerCenter,
                            FontSize = 13,
                            Font = "RobotoCondensed-Regular.ttf",
                            Text = TimeHelper.FormatTime(TimeSpan.FromSeconds(playerData.cooldown - TimeHelper.GetTimeStamp()))
                        },
                            RectTransform = { AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin = "0 2", OffsetMax = $"0 24" }
                        }, Layer + $".Kits{idKit}", Layer + $".Kits{idKit}.Status.Text");
                        container.Add(new CuiPanel
                        {
                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0", OffsetMin = "0 0", OffsetMax = "0 4.6" },
                            Image = { Color = "0.87 0.33 0.33 0.5" }
                        }, Layer + $".Kits{idKit}", Layer + $".Kits{idKit}.Status");

                        container.Add(new CuiLabel
                        {
                            Text = { Text = "Кит успешно выдан и отправлен к вам в инвентарь", Align = TextAnchor.LowerCenter, FontSize = 18, Font = "robotocondensed-bold.ttf" },
                            RectTransform = { AnchorMin = "0.5 0", AnchorMax = "0.5 0", OffsetMin = "-250 104", OffsetMax = "250 130" }
                        }, Layer, Layer + "Status");
                        CuiHelper.AddUi(player, container);

                        CuiHelper.AddUi(player, container);

                        if (kitData.maxUse != -1) playerData.amount -= 1;
                    }

                    break;
                }
            }
        }

        [ChatCommand("kit")] 
        void KitOpen(BasePlayer player, string command, string[] args)
        { 
            var ret = Interface.Call("CanRedeemKit", player) as string;
             
            if (ret != null)
            {
                SendReply(player, ret);
                return;
            }
            
            player.SendConsoleCommand("UI_KITS showavailablekits");
        }
        
        [ChatCommand("kits")] 
        void KitsOpen(BasePlayer player, string command, string[] args)
        {
            var ret = Interface.Call("CanRedeemKit", player) as string;
            
            if (ret != null)
            {
                SendReply(player, ret);
                return;
            }
            
            player.SendConsoleCommand("UI_KITS showavailablekits");
        }

        #endregion
        
        #region Methods
        
        private List<KitInfo> GetKitsForPlayer(BasePlayer player)
        {
            var kitsInfo = GetKitsInfo(player);
            return _config.kits.Where(kit => (string.IsNullOrEmpty(kit.privilege) || permission.UserHasPermission(player.UserIDString, kit.privilege)) && GetKitData(kitsInfo, kit).amount != 0).ToList(); 
        }
         
        private void GiveItems(BasePlayer player, KitInfo kit)
        {
            foreach(var kitItem in kit.items)
            {             
                GiveItem(player,BuildItem(kitItem.shortname,kitItem.amount,kitItem.skinID,kitItem.Condition,kitItem.Weapon,kitItem.Content), kitItem.place == "Панель" ? player.inventory.containerBelt : kitItem.place == "Одежда" ? player.inventory.containerWear : player.inventory.containerMain);
            }
        }
        
        private void GiveItem(BasePlayer player, Item item, ItemContainer cont = null)
        {
            if (item == null) return;
            
            player.GiveItem(item);
        }
        
        private Item BuildItem(string ShortName, int Amount, ulong SkinID, float Condition, Weapon weapon, List<ItemContent> Content)
        {
            Item item = ItemManager.CreateByName(ShortName, Amount > 1 ? Amount : 1, SkinID);
            item.condition = Condition;
            if(weapon != null)
            {
                ((BaseProjectile) item.GetHeldEntity()).primaryMagazine.contents = weapon.ammoAmount;
                ((BaseProjectile) item.GetHeldEntity()).primaryMagazine.ammoType = ItemManager.FindItemDefinition(weapon.ammoType);
            }
            if(Content != null)
            {
                foreach(var cont in Content)
                {
                    Item newCont = ItemManager.CreateByName(cont.ShortName, cont.Amount);
                    newCont.condition = cont.Condition;
                    newCont.MoveToContainer(item.contents);
                }
            }
            return item;
        }
        
        private List<ItemInfo> GetPlayerItems(BasePlayer player)
        {
            List<ItemInfo> kititems = new List<ItemInfo>();
            foreach (Item item in player.inventory.containerWear.itemList)
            {
                if (item != null)
                {
                    var iteminfo = ItemToKit(item, "Одежда");
                    kititems.Add(iteminfo);
                }
            }
            foreach (Item item in player.inventory.containerMain.itemList)
            {
                if (item != null)
                {
                    var iteminfo = ItemToKit(item, "Рюкзак");
                    kititems.Add(iteminfo);
                }
            }
            foreach (Item item in player.inventory.containerBelt.itemList)
            {
                if (item != null)
                {
                    var iteminfo = ItemToKit(item, "Панель");
                    kititems.Add(iteminfo);
                }
            }
            return kititems;
        }
        
        private ItemInfo ItemToKit(Item item, string container)
        {
            ItemInfo itemInfo = new ItemInfo();

            itemInfo.amount = item.amount;
            itemInfo.place = container;
            itemInfo.shortname = item.info.shortname;
            itemInfo.Condition = item.condition;
            itemInfo.skinID = item.skin;
            itemInfo.Weapon = null;
            itemInfo.Content = null;
            
            if(item.info.category == ItemCategory.Weapon)
            {
                BaseProjectile weapon = item.GetHeldEntity() as BaseProjectile;
                if(weapon != null)
                {
                    itemInfo.Weapon = new Weapon();
                    itemInfo.Weapon.ammoType = weapon.primaryMagazine.ammoType.shortname;
                    itemInfo.Weapon.ammoAmount = weapon.primaryMagazine.contents;
                }
            }
            
            if(item.contents != null)
            {
                itemInfo.Content = new List<ItemContent>();
                foreach (var cont in item.contents.itemList)
                {
                    itemInfo.Content.Add(new ItemContent()
                    {
                        Amount = cont.amount,
                        Condition = cont.condition,
                        ShortName = cont.info.shortname
                    });
                }
            }

            return itemInfo;
        }
        
        private static string HexToRGB(string hex)
        {
            if (string.IsNullOrEmpty(hex))
            {
                hex = "#FFFFFFFF";
            }
 
            var str = hex.Trim('#');
 
            if (str.Length == 6)
                str += "FF";
 
            if (str.Length != 8)
            {
                throw new Exception(hex);
                throw new InvalidOperationException("Cannot convert a wrong format.");
            }
 
            var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
            var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
            var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
            var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);
 
            Color color = new Color32(r, g, b, a);
            return $"{color.r:F2} {color.g:F2} {color.b:F2} {color.a:F2}";
        }

        #endregion 

        #region Config

        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }
        
        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<Configuration>();
        }

        protected override void LoadDefaultConfig()
        {
            _config = new Configuration()
            {
                spawnKit = new List<ItemInfo>()
                {
                    new ItemInfo()
                    {
                        amount = 1,
                        shortname = "rock",
                        Content = null,
                        place = "Панель",
                    }
                }
            };
        }
        
        public Configuration _config;

        public class Configuration
        {
            [JsonProperty("Набор на респавне")] public List<ItemInfo> spawnKit = new List<ItemInfo>();
            [JsonProperty("Наборы")] public List<KitInfo> kits = new List<KitInfo>();
        }
        
        #endregion

        #region Class

        public class KitInfo
        {
            [JsonProperty("Название")] public string kitName = "";
            [JsonProperty("Максимум использований")] public int maxUse = 0;
            [JsonProperty("Кулдаун")] public double cooldownKit = 0;
            [JsonProperty("Привилегия")] public string privilege = "";
            [JsonProperty("Предметы")] public List<ItemInfo> items = new List<ItemInfo>();
        }
        
        public class ItemInfo
        {
            [JsonProperty("Позиция")] public int position = 0;
            [JsonProperty("Shortname")] public string shortname = "";
            [JsonProperty("Количество")] public int amount = 0;
            [JsonProperty("Место")] public string place = "Рюкзак";
            [JsonProperty("Скин")] public ulong skinID = 0U;
            [JsonProperty("Контейнер")] public List<ItemContent> Content { get; set; }
            [JsonProperty("Прочность")] public float Condition { get; set; }
            [JsonProperty("Оружие")] public Weapon Weapon { get; set; }
        }
        
        public class Weapon
        {
            public string ammoType { get; set; }
            public int ammoAmount { get; set; }
        }
        public class ItemContent
        {
            public string ShortName { get; set; }
            public float Condition { get; set; }
            public int Amount { get; set; }
        }

        #endregion
        
        #region Data

        class StoredData
        {
            public Dictionary<ulong, KitsInfo> players = new Dictionary<ulong, KitsInfo>();
        }

        class KitsInfo
        {
            public Dictionary<string, KitData> kits = new Dictionary<string, KitData>();
        }

        class KitData
        {
            [JsonProperty("a")]
            public int amount = 0;
            
            [JsonProperty("cd")]
            public double cooldown = 0;
        }
        
        void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject("Temporary/Kits/kits", storedData);
        }

        void LoadData()
        {
            try
            {
                storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>("Temporary/Kits/kits");
            }
            catch (Exception ex)
            {
                PrintError($"Failed to load data: {ex}");
            }
            
            if (storedData == null)
                storedData = new StoredData();
        }

        StoredData storedData;
        
        #endregion

        #region Helper

        private static class TimeHelper
        {
            public static string FormatTime(TimeSpan time, int maxSubstr = 5, string language = "ru")
            {
                string result = string.Empty;
                switch (language)
                {
                    case "ru":
                        int i = 0;
                        if (time.Days != 0 && i < maxSubstr)
                        {
                            if (!string.IsNullOrEmpty(result))
                                result += " ";

                            result += $"{Format(time.Days, "д", "д", "д")}";
                            i++;
                        }

                        if (time.Hours != 0 && i < maxSubstr)
                        {
                            if (!string.IsNullOrEmpty(result))
                                result += " ";

                            result += $"{Format(time.Hours, "ч", "ч", "ч")}";
                            i++;
                        }

                        if (time.Minutes != 0 && i < maxSubstr)
                        {
                            if (!string.IsNullOrEmpty(result))
                                result += " ";

                            result += $"{Format(time.Minutes, "м", "м", "м")}";
                            i++;
                        }

                        
                        
                        if (time.Days == 0)
                        {
                            if (time.Seconds != 0 && i < maxSubstr)
                            {
                                if (!string.IsNullOrEmpty(result))
                                    result += " ";

                                result += $"{Format(time.Seconds, "с", "с", "с")}";
                                i++;
                            }
                        }

                        break;
                    case "en":
                        result = string.Format("{0}{1}{2}{3}",
                            time.Duration().Days > 0
                                ? $"{time.Days:0} day{(time.Days == 1 ? String.Empty : "s")}, "
                                : string.Empty,
                            time.Duration().Hours > 0
                                ? $"{time.Hours:0} hour{(time.Hours == 1 ? String.Empty : "s")}, "
                                : string.Empty,
                            time.Duration().Minutes > 0
                                ? $"{time.Minutes:0} minute{(time.Minutes == 1 ? String.Empty : "s")}, "
                                : string.Empty,
                            time.Duration().Seconds > 0
                                ? $"{time.Seconds:0} second{(time.Seconds == 1 ? String.Empty : "s")}"
                                : string.Empty);

                        if (result.EndsWith(", ")) result = result.Substring(0, result.Length - 2);

                        if (string.IsNullOrEmpty(result)) result = "0 seconds";
                        break;
                }

                return result;
            }

            private static string Format(int units, string form1, string form2, string form3)
            {
                var tmp = units % 10;

                if (units >= 5 && units <= 20 || tmp >= 5 && tmp <= 9)
                    return $"{units}{form1}";

                if (tmp >= 2 && tmp <= 4)
                    return $"{units}{form2}";

                return $"{units}{form3}";
            }

            private static DateTime Epoch = new DateTime(1970, 1, 1);

            public static double GetTimeStamp()
            {
                return DateTime.Now.Subtract(Epoch).TotalSeconds;
            }
        }

        #endregion
		
		
		public CuiRawImageComponent GetAvatarImageComponent(ulong user_id, string color = "1.0 1.0 1.0 1.0"){
			
			if (plugins.Find("ImageLoader")) return plugins.Find("ImageLoader").Call("BuildAvatarImageComponent",user_id) as CuiRawImageComponent;
			if (plugins.Find("ImageLibrary")) {
				return new CuiRawImageComponent { Png = (string)plugins.Find("ImageLibrary").Call("GetImage", user_id.ToString()), Color = color, Sprite = "assets/content/textures/generic/fulltransparent.tga" };
			}
			return new CuiRawImageComponent {Url = "https://image.flaticon.com/icons/png/512/37/37943.png", Color = color, Sprite = "assets/content/textures/generic/fulltransparent.tga"};
		}
		public CuiRawImageComponent GetImageComponent(string url, string shortName="", string color = "1.0 1.0 1.0 1.0"){
			
			if (plugins.Find("ImageLoader")) return plugins.Find("ImageLoader").Call("BuildImageComponent",url) as CuiRawImageComponent;
			if (plugins.Find("ImageLibrary")) {
				if (!string.IsNullOrEmpty(shortName)) url = shortName;
				//Puts($"{url}: "+ (string)plugins.Find("ImageLibrary").Call("GetImage", url));
				return new CuiRawImageComponent { Png = (string)plugins.Find("ImageLibrary").Call("GetImage", url), Color = color, Sprite = "assets/content/textures/generic/fulltransparent.tga"};
			}
			return new CuiRawImageComponent {Url = url, Color = color, Sprite = "assets/content/textures/generic/fulltransparent.tga"};
		}
		public CuiRawImageComponent GetItemImageComponent(string shortName){
			string itemUrl = shortName;
			if (plugins.Find("ImageLoader")) {itemUrl = $"https://static.moscow.ovh/images/games/rust/icons/{shortName}.png";}
            return GetImageComponent(itemUrl, shortName);
		}
		public bool AddImage(string url,string shortName=""){
			if (plugins.Find("ImageLoader")){				
				plugins.Find("ImageLoader").Call("CheckCachedOrCache", url);
				return true;
			}else
			if (plugins.Find("ImageLibrary")){
				if (string.IsNullOrEmpty(shortName)) shortName=url;
				plugins.Find("ImageLibrary").Call("AddImage", url, shortName);
				//Puts($"Add Image {shortName}");
				return true;
			}	
			return false;		
		}
		
    }
}

// --- End of file: Kits.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/CupboardLogs.cs ---
// --- Original Local Path: CupboardLogs.cs ---

using Oxide.Core;
using System;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Cupboard Logging", "DylanSMR", "1.0.3", ResourceId = 1904)]
    [Description("Creates a log when a player places a cupboard.")]
    class CupboardLogs : RustPlugin
    {  
        void Loaded()
        {
            logData = Interface.GetMod().DataFileSystem.ReadObject<LogData>("Cupboard-Logs");   
            lang.RegisterMessages(messages, this);    
        }
        
        public Dictionary<string, string> messages = new Dictionary<string, string>()
        {
            {"Format", "[{0}] placed down a tool cupboard at variables: [Location:{1}] - [Time:{2}] - [OnGround:{3}] - [OnBuildingBlock:{4}]" },        
        };
        
        void WriteLogs()
        {
            Interface.Oxide.DataFileSystem.WriteObject("Cupboard-Logs", logData);    
        }
        
        class LogData
        {
            public List<string> logs = new List<string>();
        }
        
         LogData logData;
        
        void OnEntitySpawned(BaseEntity entity, UnityEngine.GameObject gameObject)
        {
            try 
            {
                if(entity.ToString().Contains("cupboard.tool"))
                {
                    if(entity.OwnerID == null) return; 
                    var player = BasePlayer.FindByID(entity.OwnerID);
                    var onground = false;
                    var onbuildingblock = false;
                        List<BaseEntity> nearby = new List<BaseEntity>();
                        Vis.Entities(entity.transform.position, 1, nearby);
                        foreach (var ent in nearby)  
                        {
                            if(ent.ShortPrefabName.Contains("cupboard"))
                            {
                                foreach(var ent1 in nearby)
                                {
                                    if(ent1 is BuildingBlock)
                                    {
                                        break;
                                    }
                                    else
                                    {
                                        onground = true;
                                        onbuildingblock = false;   
                                    }
                                }
                            }      
                            if (ent is BuildingBlock)
                            {
                                onground = false;
                                onbuildingblock = true;
                            }
                        }
                            
                    logData.logs.Add(string.Format(lang.GetMessage("Format", this), player.displayName, entity.transform.position, DateTime.Now.ToString("h:mm tt"), onground, onbuildingblock));
                    WriteLogs();
                }
                else
                {
                    return;
                }
            }
            catch(System.Exception)
            {
                return;       
            }
        }
    }
}

// --- End of file: CupboardLogs.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/SecurityCameras.cs ---
// --- Original Local Path: SecurityCameras.cs ---

﻿//Requires: RustNET
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using System.Linq;
using Rust;
using Facepunch;
using Network;

namespace Oxide.Plugins
{
    [Info("SecurityCameras", "k1lly0u", "0.2.28")]
    [Description("Deploy security cameras around your base and view them by accessing a RustNET terminal")]
    class SecurityCameras : RustPlugin
    {
        #region Fields
        private StoredData storedData;
        private DynamicConfigFile data;

        private static SecurityCameras ins;
        private static LinkManager linkManager;
        private static int layerPlcmnt;

        private List<CameraManager> cameraManagers = new List<CameraManager>();
       
        private bool wipeDetected;
        private bool isInitialized;

        const string permUse = "securitycameras.use";
        const string permIgnore = "securitycameras.ignorelimit";
        const string permPublic = "securitycameras.public";

        const string SCUI_Overlay = "SCUI_Overlay";

        const string CHAIR_PREFAB = "assets/prefabs/deployable/chair/chair.deployed.prefab";
        const int CAMERA_ID = 634478325;
        #endregion

        #region Oxide Hooks
        private void Loaded()
        {
            permission.RegisterPermission(permUse, this);
            permission.RegisterPermission(permIgnore, this);
            permission.RegisterPermission(permPublic, this);

            foreach (string key in configData.Camera.Max.Keys)
            {
                if (permission.PermissionExists(key, this))
                    continue;
                permission.RegisterPermission(key, this);
            }

            lang.RegisterMessages(Messages, this);
            data = Interface.Oxide.DataFileSystem.GetFile("RustNET/cameras");

            linkManager = new LinkManager();
        }

        private void OnServerInitialized()
        {
            ins = this; 
            LoadData(); 
            LoadDefaultImages(); 
            layerPlcmnt = LayerMask.GetMask("Construction", "Default", "Deployed", "World", "Terrain");

            if (wipeDetected)
            {
                storedData = new StoredData();
                SaveData();
            }

            InvokeHandler.Invoke(ServerMgr.Instance, InitializeAllLinks, 10f);
            RustNET.RegisterModule(Title, this);
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            Controller controller = player.GetComponent<Controller>();
            if (controller != null)
            {
                LinkManager.CameraLink link = linkManager.GetLinkOf(controller);
                if (link != null)
                    link.CloseLink(controller);
            }
        }

        private object OnPlayerCommand(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();

            if (player != null && player.GetComponent<Controller>())
                return false;
            return null;
        }

        private object OnPlayerTick(BasePlayer player, PlayerTick msg, bool wasPlayerStalled)
        {
            Controller controller = player.GetComponent<Controller>();
            if (controller != null)
                return false;
            return null;
        }

        private void OnEntityKill(BaseNetworkable networkable)
        {
            if (networkable != null && (networkable is BuildingBlock || networkable is DroppedItem))
                linkManager.OnEntityDeath(networkable);
        }

        private void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (entity == null || info == null)
                return;

            if (entity is BasePlayer)
            {
                if (entity.GetComponent<Controller>())
                {
                    info.damageTypes = new DamageTypeList();
                    info.HitEntity = null;
                    info.HitMaterial = 0;
                    info.PointStart = Vector3.zero;
                }
            }
            else if (entity is BaseMountable)                            
                linkManager.OnEntityTakeDamage(entity, info);            
        }

        private void OnNewSave(string filename) => wipeDetected = true;

        private void OnServerSave()
        {
            if (isInitialized)
                SaveData();
        }
                       
        private object CanDismountEntity(BasePlayer player, BaseMountable mountable)
        {
            Controller controller = player.GetComponent<Controller>();
            if (controller != null)
                return false;
            return null;
        }

        private void Unload()
        {
            if (InvokeHandler.IsInvoking(ServerMgr.Instance, InitializeAllLinks))            
                InvokeHandler.CancelInvoke(ServerMgr.Instance, InitializeAllLinks);

            if (!ServerMgr.Instance.Restarting)
                SaveData();

            foreach (BasePlayer player in BasePlayer.activePlayerList)            
                CuiHelper.DestroyUi(player, SCUI_Overlay);
            
            linkManager.DestroyAllLinks(true);

            for (int i = cameraManagers.Count - 1; i >= 0; i--)
                cameraManagers[i].Destroy();

            ins = null;
            linkManager = null;
        }
        #endregion

        #region Functions
        private bool CanPlaceItem(BasePlayer player, bool ignoreRestriction)
        {
            int cameraCount = 0;

            BuildingManager.Building building = player.GetBuildingPrivilege()?.GetBuilding();
            if (building != null)
            {
                RustNET.LinkManager.Link buildingLink = RustNET.linkManager.GetLinkOf(building);
                if (buildingLink == null && !ignoreRestriction)
                {
                    SendReply(player, msg("Error.NoTerminal", player.userID));
                    return false;
                }
               
                cameraCount = linkManager.GetLinkOf(building)?.managers.Count ?? 0;
            }
            else
            {
                if (!ignoreRestriction)
                {
                    SendReply(player, msg("Error.NoBuildingPrivilege", player.userID));
                    return false;
                }
            }

            int cameraLimit = GetMaxCameras(player.userID);
            if (!permission.UserHasPermission(player.UserIDString, permIgnore) && cameraCount >= cameraLimit)
            {
                SendReply(player, msg("Error.Limit", player.userID));
                return false;
            }

            return true;
        }

        private void InitializeAllLinks()
        {
            for (int i = 0; i < storedData.cameraData.Length; i++)
            {
                CameraManager.CameraData cameraData = storedData.cameraData.ElementAt(i);

                int terminalId = cameraData.terminalId;
                BuildingManager.Building building = null;

                RustNET.LinkManager.Link link = RustNET.linkManager.GetLinkOf(cameraData.terminalId);
                if (link == null || !link.IsPublicLink)
                {
                    building = RustNET.GetBuilding(new Vector3(cameraData.position[0], cameraData.position[1], cameraData.position[2]), 0.5f);
                    if (building == null) 
                        continue;
                    else terminalId = RustNET.linkManager.GetLinkOf(building)?.terminal?.terminalId ?? 0;                    
                }

                LinkManager.CameraLink cameraLink = linkManager.GetLinkOf(terminalId);
                if (cameraLink == null)
                    cameraLink = new LinkManager.CameraLink(terminalId, building, cameraData);
                else cameraLink.AddCameraToLink(cameraData);
            }
            isInitialized = true;
        }
       
        private CameraManager InitializeCamera(CameraManager.CameraData cameraData, int terminalId)
        {
            CameraManager camera = RustNET.SpawnDroppedItem(CAMERA_ID, new Vector3(cameraData.position[0], cameraData.position[1], cameraData.position[2]), new Vector3(cameraData.baseRotation[0], cameraData.baseRotation[1], cameraData.baseRotation[2])).gameObject.AddComponent<CameraManager>();
            camera.SetRotation(new float[] { cameraData.baseRotation[0], cameraData.baseRotation[1], cameraData.baseRotation[2] });
            camera.terminalId = terminalId;
            camera.cameraName = cameraData.cameraName;
            return camera;
        }

        private void InitializeCamera(BasePlayer player, DroppedItem droppedItem)
        {
            BuildingManager.Building building = RustNET.GetBuilding(droppedItem.transform.position, 0.5f);
            if (building == null)
            {
                droppedItem.DestroyItem();
                droppedItem.Kill();
                player.GiveItem(ItemManager.CreateByItemID(CAMERA_ID), BaseEntity.GiveItemReason.PickedUp);
                SendReply(player, msg("Error.InvalidPlacement", player.userID));
                return;
            }

            int terminalId = RustNET.linkManager.GetLinkOf(building)?.terminal?.terminalId ?? 0;

            CameraManager camera = RustNET.SpawnDroppedItem(CAMERA_ID, droppedItem.transform.position, droppedItem.transform.eulerAngles).gameObject.AddComponent<CameraManager>();

            camera.SetRotation(new float[] { droppedItem.transform.eulerAngles.x, droppedItem.transform.eulerAngles.y, droppedItem.transform.eulerAngles.z });
            camera.terminalId = terminalId;

            LinkManager.CameraLink cameraLink = linkManager.GetLinkOf(terminalId);
            if (cameraLink == null)
                cameraLink = new LinkManager.CameraLink(terminalId, building, camera);
            else cameraLink.AddCameraToLink(camera);
        }

        private void InitializeCamera(BasePlayer player, DroppedItem droppedItem, int terminalId)
        {            
            CameraManager camera = RustNET.SpawnDroppedItem(CAMERA_ID, droppedItem.transform.position, droppedItem.transform.eulerAngles).gameObject.AddComponent<CameraManager>();

            camera.SetRotation(new float[] { droppedItem.transform.eulerAngles.x, droppedItem.transform.eulerAngles.y, droppedItem.transform.eulerAngles.z });
            camera.terminalId = terminalId;

            LinkManager.CameraLink cameraLink = linkManager.GetLinkOf(terminalId);
            if (cameraLink == null)
                cameraLink = new LinkManager.CameraLink(terminalId, null, camera);
            else cameraLink.AddCameraToLink(camera);
        }

        private int GetMaxCameras(ulong playerId)
        {
            int max = 0;
            foreach(var entry in configData.Camera.Max)
            {
                if (permission.UserHasPermission(playerId.ToString(), entry.Key))
                {
                    if (max < entry.Value)
                        max = entry.Value;
                }                    
            }
            return max;
        }
        #endregion

        #region RustNET Integration
        private void DestroyAllLinks() => linkManager.DestroyAllLinks(true);

        private void OnTerminalCreated(RustNET.TerminalManager terminal)
        {
            BuildingManager.Building building = terminal.parentEntity?.GetBuilding();

            if (building == null)
                return;

            for (int i = cameraManagers.Count - 1; i >= 0; i--)
            {
                CameraManager camera = cameraManagers[i];
                if (camera.parent?.GetBuilding() == building)
                {
                    LinkManager.CameraLink link = linkManager.GetLinkOf(terminal.terminalId);
                    if (link == null)                    
                        link = new LinkManager.CameraLink(terminal.terminalId, building, camera);                    
                    else link.AddCameraToLink(camera);                    
                }
            }            
        }

        private void OnTerminalRemoved(int terminalId)
        {
            LinkManager.CameraLink link = linkManager.GetLinkOf(terminalId);
            if (link != null)
            {
                for (int i = cameraManagers.Count - 1; i >= 0; i--)
                {
                    CameraManager camera = cameraManagers[i];
                    if (camera.terminalId == terminalId)                    
                        camera.terminalId = 0;  
                }

                linkManager.links.Remove(link);
            }           
        }

        private void OnLinkShutdown(int terminalId)
        {
            LinkManager.CameraLink link = linkManager.GetLinkOf(terminalId);
            if (link != null)
                link.OnLinkTerminated(false);
        }

        private void OnLinkDestroyed(int terminalId)
        {
            LinkManager.CameraLink link = linkManager.GetLinkOf(terminalId);
            if (link != null)
                link.OnLinkTerminated(true);
        }

        private CameraManager[] GetAvailableCameras(int terminalId)
        {
            LinkManager.CameraLink link = linkManager.GetLinkOf(terminalId);
            if (link != null)           
                return link.managers.Where(x => x != null && x.camera != null).ToArray();            
            return new CameraManager[0];
        }
        
        private void InitializeController(BasePlayer player, uint managerId, int terminalId)
        {
            LinkManager.CameraLink link = linkManager.GetLinkOf(terminalId);
            if (link != null)
                link.InitiateLink(player, managerId);
        }

        private string GetHelpString(ulong playerId, bool title)
        {
            if (title)
                return msg("UI.Help.Title", playerId);
            else
            {
                string message = msg("UI.Help", playerId);
                if (permission.UserHasPermission(playerId.ToString(), permPublic))
                    message += msg("UI.Help.Public", playerId);
                return message;
            }
        }

        private bool AllowPublicAccess() => true;
        #endregion

        #region Components
        private class LinkManager
        {
            public List<CameraLink> links = new List<CameraLink>();

            public CameraLink GetLinkOf(BuildingManager.Building building) => links.Find(x => x.building == building) ?? null;

            public CameraLink GetLinkOf(CameraManager camera) => links.Find(x => x.managers.Contains(camera)) ?? null;

            public CameraLink GetLinkOf(Controller controller) => links.Find(x => x.controllers.Contains(controller)) ?? null;

            public CameraLink GetLinkOf(int terminalId) => links.Find(x => x.terminalId == terminalId) ?? null;

            public CameraLink GetLinkOf(DroppedItem camera)
            {
                CameraManager component = camera.GetComponent<CameraManager>();
                if (component == null)
                    return null;
                return GetLinkOf(component);
            }
           
            public void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
            {
                for (int i = links.Count - 1; i >= 0; i--)
                    links.ElementAt(i).OnEntityTakeDamage(entity, info);
            }

            public void OnEntityDeath(BaseNetworkable networkable)
            {
                for (int i = links.Count - 1; i >= 0; i--)
                    links.ElementAt(i).OnEntityDeath(networkable);
            }

            public void DestroyAllLinks(bool shutdown)
            {
                foreach (CameraLink link in links)
                {
                    link.OnLinkTerminated(false);
                    if (shutdown)
                        link.DestroyCameraManagers();
                }
            }

            public class CameraLink
            {
                public int terminalId { get; set; }
                public BuildingManager.Building building { get; private set; }
                public List<Controller> controllers { get; private set; }
                public List<CameraManager> managers { get; private set; }

                public CameraLink() { }
                public CameraLink(int terminalId, BuildingManager.Building building, CameraManager camera)
                {
                    this.terminalId = terminalId;
                    this.building = building;
                    this.controllers = new List<Controller>();
                    this.managers = new List<CameraManager>();

                    AddCameraToLink(camera);
                    linkManager.links.Add(this);
                }

                public CameraLink(int terminalId, BuildingManager.Building building, CameraManager.CameraData cameraData)
                {
                    this.terminalId = terminalId;
                    this.building = building;
                    this.controllers = new List<Controller>();
                    this.managers = new List<CameraManager>();

                    AddCameraToLink(cameraData);

                    linkManager.links.Add(this);
                }

                public void AddCameraToLink(CameraManager camera)
                {                    
                    managers.Add(camera);
                    if (!ins.cameraManagers.Contains(camera))
                        ins.cameraManagers.Add(camera);
                }

                public void AddCameraToLink(CameraManager.CameraData cameraData)
                {
                    CameraManager camera = ins.InitializeCamera(cameraData, terminalId);
                    managers.Add(camera);
                    if (!ins.cameraManagers.Contains(camera))
                        ins.cameraManagers.Add(camera);
                }

                public void InitiateLink(BasePlayer player, uint managerId)
                {                   
                    CameraManager manager = managers.FirstOrDefault(x => x.camera.net.ID == managerId);
                    if (manager != null)
                    {
                        player.inventory.crafting.CancelAll(true);
                        Controller controller = player.gameObject.AddComponent<Controller>();
                        controllers.Add(controller);
                        controller.InitiateLink(terminalId);
                        controller.SetCameraLink(this);
                        controller.SetSpectateTarget(managers.IndexOf(manager));
                    }
                }

                public void CloseLink(Controller controller, bool isDead = false)
                {
                    if (controller != null)
                    {                        
                        controllers.Remove(controller);                        
                        controller.FinishSpectating(isDead);
                    }
                }

                public void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
                {
                    foreach (Controller controller in controllers)
                    {
                        if (controller != null && entity == controller.mountPoint)
                        {
                            info.damageTypes = new DamageTypeList();
                            info.HitEntity = null;
                            info.HitMaterial = 0;
                            info.PointStart = Vector3.zero;
                        }
                    }
                }

                public void OnEntityDeath(BaseNetworkable networkable)
                {
                    CameraManager manager = networkable.GetComponent<CameraManager>();
                    if (manager != null && managers.Contains(manager))
                    {
                        if (manager.controller != null)
                        {
                            manager.controller.player.ChatMessage(ins.msg("Warning.CameraDestroyed", manager.controller.player.userID));
                            CloseLink(manager.controller);
                        }
                        OnCameraDestroyed(manager);
                        return;
                    }

                    BuildingBlock buildingBlock = networkable.GetComponent<BuildingBlock>();
                    if (buildingBlock != null)
                    {
                        for (int i = managers.Count - 1; i >= 0; i--)
                        {
                            CameraManager camera = managers.ElementAt(i);
                            if (camera.parent == buildingBlock)
                            {
                                if (camera.controller != null)
                                {
                                    camera.controller.player.ChatMessage(ins.msg("Warning.CameraDestroyed", camera.controller.player.userID));
                                    CloseLink(camera.controller);
                                }

                                OnCameraDestroyed(camera);
                            }
                        }
                    }
                }

                public void OnLinkTerminated(bool isDestroyed)
                {
                    for (int i = controllers.Count - 1; i >= 0; i--)
                    {
                        Controller controller = controllers.ElementAt(i);
                        controller.player.ChatMessage(isDestroyed ? ins.msg("Warning.TerminalDestroyed", controller.player.userID) : ins.msg("Warning.TerminalShutdown", controller.player.userID));
                        CloseLink(controller);
                    }
                }

                public void OnCameraDestroyed(CameraManager manager)
                {
                    ins.cameraManagers.Remove(manager);
                    managers.Remove(manager);
                    UnityEngine.Object.Destroy(manager);

                    if (managers.Count == 0)
                    {
                        linkManager.links.Remove(this);
                        return;
                    }

                    for (int i = managers.Count - 1; i >= 0; i--)
                    {
                        CameraManager m = managers.ElementAt(i);
                        if (m == null || m.camera == null)
                            managers.RemoveAt(i);
                    }
                }

                public void DestroyCameraManagers()
                {
                    foreach (CameraManager manager in managers)                    
                        UnityEngine.Object.Destroy(manager);
                    
                    managers.Clear();
                }
            }
        }
        
        class CameraManager : MonoBehaviour
        {            
            public DroppedItem camera { get; private set; }
            public Controller controller { get; private set; }

            public BuildingBlock parent { get; private set; }
            public Vector3 baseRotation { get; set; }
            public int terminalId { get; set; }
            public string cameraName { get; set; }

            private void Awake()
            {
                camera = GetComponent<DroppedItem>();
                enabled = false;
                baseRotation = camera.transform.eulerAngles;

                OBB obb = camera.WorldSpaceBounds();
                List<BuildingBlock> list = Pool.GetList<BuildingBlock>();
                Vis.Entities<BuildingBlock>(obb.position, 0.5f + obb.extents.magnitude, list, 2097152, QueryTriggerInteraction.Collide);

                if (list.Count > 0)
                {
                    parent = list[0];
                    ins.cameraManagers.Add(this);
                    terminalId = RustNET.linkManager.GetLinkOf(parent.GetBuilding())?.terminal?.terminalId ?? 0;
                }              
                Pool.FreeList<BuildingBlock>(ref list);               
            }  
            
            private void OnDestroy()
            {
                if (camera != null)
                {
                    camera.DestroyItem();
                    if (!camera.IsDestroyed)
                        camera.Kill();
                }
            }

            public void Destroy() => Destroy(this);

            public void SetRotation(float[] rotation)
            {
                baseRotation = new Vector3(rotation[0], rotation[1], rotation[2]);
                camera.transform.rotation = Quaternion.Euler(baseRotation);
            }

            public void SetController(Controller controller) => this.controller = controller;
            
            public CameraData GetCameraData() => new CameraData(this);
                       
            public class CameraData
            {
                public float[] position;
                public float[] baseRotation;
                public string cameraName;
                public int terminalId;

                public CameraData() { }

                public CameraData(CameraManager camera)
                {
                    position = new float[] { camera.camera.transform.position.x, camera.camera.transform.position.y, camera.camera.transform.position.z };
                    baseRotation = new float[] { camera.baseRotation.x, camera.baseRotation.y, camera.baseRotation.z };
                    cameraName = camera.cameraName;
                    terminalId = camera.terminalId;
                }
            }
        }

        class Controller : RustNET.Controller
        {
            public CameraManager manager { get; private set; }
            public BaseMountable mountPoint { get; private set; }
            private LinkManager.CameraLink link;
            
            private int spectateIndex;
            private bool switchingTargets;
            private bool canCyle;

            public override void Awake()
            {
                base.Awake();
                enabled = false;

                canCyle = ins.configData.Camera.CanCycle;

                mountPoint = GameManager.server.CreateEntity(CHAIR_PREFAB, player.transform.position) as BaseMountable;
                mountPoint.enableSaving = false;
                mountPoint.skinID = (ulong)1169930802; // 1311472987
                mountPoint.isMobile = true;
                mountPoint.Spawn();

                Destroy(mountPoint.GetComponent<DestroyOnGroundMissing>());
                Destroy(mountPoint.GetComponent<GroundWatch>());
                Destroy(mountPoint.GetComponent<MeshCollider>());                
            }

            public override void OnDestroy()
            {
                player.SetPlayerFlag(BasePlayer.PlayerFlags.Spectating, false);
                player.DismountObject();
                player.EnsureDismounted();

                if (mountPoint != null && !mountPoint.IsDestroyed)
                    mountPoint.Kill();

                base.OnDestroy();
            }

            private void Update()
            {
                if (player == null || player.serverInput == null || switchingTargets)
                    return;

                InputState input = player.serverInput;
               
                if (manager.controller == this)
                {                   
                    Vector3 aimAngle = player.serverInput.current.aimAngles;
                    manager.camera.transform.rotation = Quaternion.Euler(aimAngle.x, aimAngle.y, 0) * Quaternion.Euler(0, 90, 0);                    
                }

                if (input.WasJustPressed(BUTTON.USE))
                {
                    enabled = false;
                    link.CloseLink(this);
                }
                else
                {
                    if (canCyle)
                    {
                        if (input.WasJustPressed(BUTTON.JUMP))
                            UpdateSpectateTarget(1);
                        else if (input.WasJustPressed(BUTTON.DUCK))
                            UpdateSpectateTarget(-1);
                    }
                }
            }

            public void SetCameraLink(LinkManager.CameraLink link)
            {
                this.link = link;
                BeginSpectating();
            }

            public void BeginSpectating()
            {
                RustNET.StripInventory(player);
                player.SetPlayerFlag(BasePlayer.PlayerFlags.Spectating, true);
                player.MountObject(mountPoint);

                if (Net.sv.write.Start())
                {
                    Net.sv.write.PacketID(Message.Type.EntityDestroy);
                    Net.sv.write.EntityID(player.net.ID);
                    Net.sv.write.UInt8((byte)BaseNetworkable.DestroyMode.None);
                    Net.sv.write.Send(new SendInfo(player.net.group.subscribers.Where(x => x.userid != player.userID).ToList()));
                }

                player.limitNetworking = true;
                player.syncPosition = false;

                if (canCyle)
                    player.ChatMessage(ins.msg("Help.ControlInfo", player.userID));
                else player.ChatMessage(ins.msg("Help.ControlInfo.NoCycle", player.userID));
            }

            public void FinishSpectating(bool isDead)
            {
                enabled = false;
                player.SetPlayerFlag(BasePlayer.PlayerFlags.Spectating, false);
                player.limitNetworking = false;
                player.syncPosition = true;

                InvokeHandler.CancelInvoke(player, UpdateNetworkGroup);

                player.DismountObject();
                player.EnsureDismounted();
                CuiHelper.DestroyUi(player, SCUI_Overlay);

                if (!isDead)
                    Destroy(this);
            }

            public void SetSpectateTarget(int spectateIndex)
            {
                this.spectateIndex = spectateIndex;
                manager = link.managers[spectateIndex];

                enabled = true;
                
                mountPoint.transform.position = manager.camera.transform.position + (Vector3.down * 1.5f) + (-manager.camera.transform.right * 0.2f);
                mountPoint.transform.rotation = Quaternion.Euler(manager.baseRotation.x, manager.baseRotation.y, 0) * Quaternion.Euler(0, 270, 0);
                mountPoint.SendNetworkUpdate();

                UpdateNetworkGroup();

                if (manager.controller == null)                
                    manager.SetController(this);                
                else player.ChatMessage(ins.msg("Warning.InUse", player.userID));                

                CreateCameraOverlay();                
            }

            private void UpdateNetworkGroup()
            {
                Network.Visibility.Group group = Net.sv.visibility.GetGroup(manager.camera.transform.position);
                if (mountPoint.net.group != group)                
                    mountPoint.net.SwitchGroup(group);                    
                
                if (player.net.group != group)
                    player.net.SwitchGroup(group);
            }

            public void UpdateSpectateTarget(int index = 0)
            {
                switchingTargets = true;
                player.Invoke(() => switchingTargets = false, 0.25f);

                int newIndex = spectateIndex + index;

                if (newIndex > link.managers.Count - 1)
                    newIndex = 0;
                else if (newIndex < 0)
                    newIndex = link.managers.Count - 1;

                if (spectateIndex == newIndex)
                    return;

                if (manager.controller == this)
                    manager.SetController(null);
                manager = null;
                SetSpectateTarget(newIndex);
            }

            public override void OnPlayerDeath(HitInfo info)
            {
                enabled = false;
                link.CloseLink(this, true);

                base.OnPlayerDeath(info);
            }

            private void CreateCameraOverlay()
            {
                if (!ins.configData.Camera.Overlay)
                    return;

                CuiElementContainer container = RustNET.UI.Container("0 0 0 0", "0 0", "1 1", false, "Under", SCUI_Overlay);
                RustNET.UI.Image(ref container, ins.GetImage("camoverlay"), "0 0", "1 1", SCUI_Overlay);
                RustNET.UI.Panel(ref container, "0 0 0 0.4", "0.04 0.9", "0.18 0.94", SCUI_Overlay);
                RustNET.UI.Label(ref container, "<color=red>REC</color>", 18, "0.04 0.9", "0.18 0.94", TextAnchor.MiddleCenter, SCUI_Overlay);

                RustNET.UI.Panel(ref container, "0 0 0 0.4", "0.82 0.9", "0.96 0.94", SCUI_Overlay);
                RustNET.UI.Label(ref container, string.IsNullOrEmpty(manager.cameraName) ? string.Format(ins.msg("UI.CameraName", player.userID), spectateIndex + 1) : manager.cameraName, 18, "0.82 0.9", "0.96 0.94", TextAnchor.MiddleCenter, SCUI_Overlay);

                CuiHelper.DestroyUi(player, SCUI_Overlay);
                CuiHelper.AddUi(player, container);
            }           
        }
        #endregion

        #region UI
        private void CreateConsoleWindow(BasePlayer player, int terminalId, int page)
        {
            CuiElementContainer container = RustNET.ins.GetBaseContainer(player, terminalId, Title);

            CameraManager[] entityIds = GetAvailableCameras(terminalId);

            RustNET.UI.Panel(ref container, RustNET.uiColors[RustNET.Colors.Panel], "0.04 0.765", "0.96 0.8");
            RustNET.UI.Label(ref container, msg("UI.Select.Camera", player.userID), 12, "0.05 0.765", "0.5 0.8", TextAnchor.MiddleLeft);
            RustNET.UI.Button(ref container, RustNET.uiColors[RustNET.Colors.Button], RustNET.msg("UI.MainMenu", player.userID), 11, "0.82 0.765", "0.96 0.8", $"rustnet.changepage {terminalId}");

            if (entityIds == null || entityIds.Length == 0)            
                RustNET.UI.Label(ref container, msg("UI.NoCameras", player.userID), 12, "0.05 0.5", "0.95 0.7");            
            else
            {
                int count = 0;
                int startAt = page * 18;
                for (int i = startAt; i < (startAt + 18 > entityIds.Length ? entityIds.Length : startAt + 18); i++)
                {
                    CameraManager manager = entityIds.ElementAt(i);
                    RustNET.UI.Panel(ref container, RustNET.uiColors[RustNET.Colors.Panel], $"0.04 {(0.725f - (count * 0.04f))}", $"0.96 {(0.755f - (count * 0.04f))}");
                    RustNET.UI.Label(ref container, string.IsNullOrEmpty(manager.cameraName) ? string.Format(msg("UI.Camera", player.userID), i + 1) : $"> {manager.cameraName}", 11, $"0.05 {0.725f - (count * 0.04f)}", $"0.31 {0.755f - (count * 0.04f)}", TextAnchor.MiddleLeft);                   
                    RustNET.UI.Button(ref container, RustNET.uiColors[RustNET.Colors.Button], RustNET.msg("UI.Control", player.userID), 11, $"0.76 {0.725f - (count * 0.04f)}", $"0.96 {0.755f - (count * 0.04f)}", $"securitycameras.control {manager.camera.net.ID} {terminalId}");

                    count++;
                }

                int totalPages = entityIds.Length / 18;

                RustNET.UI.Button(ref container, RustNET.uiColors[RustNET.Colors.Button], RustNET.msg("UI.Back", player.userID), 11, "0.3 0.01", "0.44 0.04", page > 0 ? $"rustnet.changepage {terminalId} {Title} {page - 1}" : "");
                RustNET.UI.Label(ref container, string.Format(RustNET.msg("UI.Page", player.userID), page + 1, totalPages + 1), 11, "0.44 0.01", "0.56 0.04");
                RustNET.UI.Button(ref container, RustNET.uiColors[RustNET.Colors.Button], RustNET.msg("UI.Next", player.userID), 11, "0.56 0.01", "0.7 0.04", page + 1 <= totalPages ? $"rustnet.changepage {terminalId} {Title} {page + 1}" : "");
            }

            CuiHelper.DestroyUi(player, RustNET.RustNET_Panel);
            CuiHelper.AddUi(player, container);
        }

        [ConsoleCommand("securitycameras.control")]
        private void ccmdControl(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            if (!RustNET.linkManager.IsValidTerminal(arg.GetInt(1)))
            {
                CuiHelper.DestroyUi(player, RustNET.RustNET_Panel);
                SendReply(player, RustNET.msg("Warning.TerminalDestroyed", player.userID));
                return;
            }

            CuiHelper.DestroyUi(player, RustNET.RustNET_Panel);
            InitializeController(player, arg.GetUInt(0), arg.GetInt(1));            
        }
        #endregion

        #region Commands
        [ChatCommand("sc")]
        private void cmdSC(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, permUse)) return;
            if (args.Length == 0)
            {
                SendReply(player, $"<color=#ce422b>{Title}</color><color=#939393>  v{Version}  -</color> <color=#ce422b>{Author} @ www.chaoscode.io</color>");
                SendReply(player, msg("Help.Main", player.userID));
                SendReply(player, msg("Help.Add", player.userID));

                if (permission.UserHasPermission(player.UserIDString, permPublic))
                    SendReply(player, msg("Help.AddPublic", player.userID));

                SendReply(player, msg("Help.Remove", player.userID));
                SendReply(player, msg("Help.Name", player.userID));
                return;
            }

            if (configData.Camera.RequirePrivilege && !player.IsBuildingAuthed() &&!player.IsAdmin)
            {
                SendReply(player, msg("Error.NoPrivilege", player.userID));
                return;
            }
                   
            switch (args[0].ToLower())
            {
                case "add":
                    {
                        bool isPublic = permission.UserHasPermission(player.UserIDString, permPublic) && args.Length > 2 && args[1].ToLower() == "public";

                        Item activeItem = player.GetActiveItem();
                        if (activeItem == null || activeItem.info.itemid != CAMERA_ID)
                        {
                            SendReply(player, msg("Error.NoCamera", player.userID));
                            return;
                        }

                        int cameraCount = 0;

                        BuildingManager.Building building = player.GetBuildingPrivilege()?.GetBuilding();
                        if (building != null)
                        {
                            RustNET.LinkManager.Link buildingLink = RustNET.linkManager.GetLinkOf(building);
                            if (buildingLink == null && !isPublic)
                            {
                                SendReply(player, msg("Error.NoTerminal", player.userID));
                                return;
                            }
                          
                            cameraCount = linkManager.GetLinkOf(building)?.managers.Count ?? 0;
                        }
                        else
                        {
                            if (!isPublic)
                            {
                                SendReply(player, msg("Error.NoBuildingPrivilege", player.userID));
                                return;
                            }
                        }

                        int cameraLimit = GetMaxCameras(player.userID); 
                        if (!permission.UserHasPermission(player.UserIDString, permIgnore) && cameraCount >= cameraLimit)
                        {
                            SendReply(player, msg("Error.Limit", player.userID));
                            return;
                        }                        

                        if (isPublic)
                        {
                            int terminalId;
                            if (!int.TryParse(args[2], out terminalId))
                            {
                                SendReply(player, msg("Error.TerminalID", player.userID));
                                return;
                            }

                            if (!RustNET.linkManager.IsValidTerminal(terminalId))
                            {
                                SendReply(player, msg("Error.RustNETID", player.userID));
                                return;
                            }

                            RustNET.ItemPlacement placement = player.gameObject.AddComponent<RustNET.ItemPlacement>();
                            placement.terminalId = terminalId;
                            placement.SetRequiredItem(CAMERA_ID, new Vector3(0, 90, 0), new Vector3(0, 0, -0.1f), true, true, null, InitializeCamera, this);
                        }
                        else
                        {
                            RustNET.ItemPlacement placement = player.gameObject.AddComponent<RustNET.ItemPlacement>();
                            placement.SetRequiredItem(CAMERA_ID, new Vector3(0, 90, 0), new Vector3(0, 0, -0.1f), true, false, InitializeCamera, null, this);
                        }

                        SendReply(player, msg("Placement.Enabled", player.userID));
                    }
                    return;
                case "remove":
                    {
                        CameraManager manager = RustNET.FindEntityFromRay(player)?.GetComponent<CameraManager>();
                        if (manager == null)
                        {
                            SendReply(player, msg("Error.NoEntity", player.userID));
                            return;
                        }

                        if (manager.terminalId != 0)
                        {
                            RustNET.LinkManager.Link rustNetLink = RustNET.linkManager.GetLinkOf(manager.terminalId);
                            if (rustNetLink != null && rustNetLink.IsPublicLink)
                            {
                                if (!permission.UserHasPermission(player.UserIDString, permPublic))
                                {
                                    SendReply(player, msg("Error.PublicLink", player.userID));
                                    return;
                                }
                            }
                        }

                        LinkManager.CameraLink link = linkManager.GetLinkOf(manager);
                        if (link != null)
                            link.OnCameraDestroyed(manager);
                        else UnityEngine.Object.Destroy(manager);
                       
                        player.GiveItem(ItemManager.CreateByItemID(CAMERA_ID), BaseEntity.GiveItemReason.PickedUp);
                        SendReply(player, msg("Placement.Removed", player.userID));
                    }
                    return;
                case "name":
                    {
                        if (args.Length < 2)
                        {
                            SendReply(player, msg("Error.NoNameSpecified", player.userID));
                            return;
                        }

                        CameraManager manager = RustNET.FindEntityFromRay(player)?.GetComponent<CameraManager>();
                        if (manager == null)
                        {
                            SendReply(player, msg("Error.NoEntity", player.userID));
                            return;
                        }

                        manager.cameraName = args[1];
                        
                        SendReply(player, string.Format(msg("Success.NameSet", player.userID), args[1]));
                    }
                    return;
                default:
                    SendReply(player, msg("Error.InvalidCommand", player.userID));
                    return;
            }
        }
        #endregion
       
        #region Image Management
        private void LoadDefaultImages(int attempts = 0)
        {
            if (attempts > 3)
            {
                PrintError("ImageLibrary not found. Unable to load camera overlay UI");
                configData.Camera.Overlay = false;
                return;
            }

            if (configData.Camera.Overlay && !string.IsNullOrEmpty(configData.Camera.OverlayImage))    
                AddImage("camoverlay", configData.Camera.OverlayImage);

            if (!string.IsNullOrEmpty(configData.Camera.RustNETIcon))
                AddImage(Title, configData.Camera.RustNETIcon);            
        }

        private void AddImage(string imageName, string fileName) => RustNET.ins.AddImage(imageName, fileName);

        private string GetImage(string name) => RustNET.ins.GetImage(name);
        #endregion

        #region Config        
        private ConfigData configData;
        class ConfigData
        {            
            [JsonProperty(PropertyName = "Camera Options")]
            public CameraOptions Camera { get; set; }

            public class CameraOptions
            {
                [JsonProperty(PropertyName = "Allow players to cycle through all linked cameras")]
                public bool CanCycle { get; set; }
                [JsonProperty(PropertyName = "Allow friends and clan members to place/remove cameras")]
                public bool Friends { get; set; }
                [JsonProperty(PropertyName = "Require building privilege to place/remove cameras")]
                public bool RequirePrivilege { get; set; }
                [JsonProperty(PropertyName = "Maximum allowed cameras per base (Permission | Amount)")]
                public Dictionary<string, int> Max { get; set; }
                [JsonProperty(PropertyName = "Camera placement and removal distance")]
                public int Distance { get; set; }
                [JsonProperty(PropertyName = "Display camera overlay UI")]
                public bool Overlay { get; set; }
                [JsonProperty(PropertyName = "Camera overlay image URL")]
                public string OverlayImage { get; set; }
                [JsonProperty(PropertyName = "Camera icon URL for RustNET menu")]
                public string RustNETIcon { get; set; }
            }           
            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();

            if (configData.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                Camera = new ConfigData.CameraOptions
                {
                    CanCycle = true,
                    Distance = 4,
                    Friends = true,
                    Max = new Dictionary<string, int>
                    {
                        ["securitycameras.use"] = 4,
                        ["securitycameras.pro"] = 10
                    },
                    Overlay = true,
                    OverlayImage = "http://www.rustedit.io/images/RustNET/camera.png",
                    RustNETIcon = "http://www.rustedit.io/images/RustNET/cameraicon.png"
                },                
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();

            if (configData.Version < new VersionNumber(0, 1, 05))
                configData.Camera.Max = baseConfig.Camera.Max;

            if (configData.Version < new VersionNumber(0, 2, 0))
                configData = baseConfig;

            if (configData.Version < new VersionNumber(0, 2, 10))
            {
                configData.Camera.Overlay = baseConfig.Camera.Overlay;
                configData.Camera.OverlayImage = baseConfig.Camera.OverlayImage;
                configData.Camera.RustNETIcon = baseConfig.Camera.RustNETIcon;
            }

            if (configData.Version < new VersionNumber(0, 2, 14))
                configData.Camera.CanCycle = baseConfig.Camera.CanCycle;

            configData.Version = Version;
            PrintWarning("Config update completed!");
        }

        #endregion

        #region Data Management
        private void SaveData()
        {
            storedData.cameraData = cameraManagers.Where(x => x != null).Select(x => x.GetCameraData()).ToArray();
            data.WriteObject(storedData);
        }

        private void LoadData()
        {
            try
            {
                storedData = data.ReadObject<StoredData>();
            }
            catch
            {
                storedData = new StoredData();
            }
        }

        private class StoredData
        {
            public CameraManager.CameraData[] cameraData = new CameraManager.CameraData[0];
        }        
        #endregion

        #region Localization
        string msg(string key, ulong playerId = 0U) => lang.GetMessage(key, this, playerId == 0U ? null : playerId.ToString());
        Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            ["Help.Main"] = "<color=#ce422b>/rustnet</color><color=#939393> - Display the help menu for using RustNET</color>",
            ["Help.Add"] = "<color=#ce422b>/sc add</color><color=#939393> - Activates the camera placement tool. Requires a camera in your hands!</color>",
            ["Help.AddPublic"] = "<color=#ce422b>/sc add public <terminal ID></color><color=#939393> - Activates the public camera placement tool. These cameras can be placed anywhere and need to be registered to a specific terminal</color>",
            ["Help.Remove"] = "<color=#ce422b>/sc remove</color><color=#939393> - Remove the camera you are looking at</color>",
            ["Help.Name"] = "<color=#ce422b>/sc name <name></color><color=#939393> - Set a name for the camera you are looking at</color>",
            ["Help.ControlInfo"] = "<color=#939393>Press <color=#ce422b>'JUMP'</color> and <color=#ce422b>'DUCK'</color> to cycle through available cameras.\nPress <color=#ce422b>'USE'</color> to exit the controller!</color>",
            ["Help.ControlInfo.NoCycle"] = "Press <color=#ce422b>'USE'</color> to exit the controller!</color>",
            ["Warning.TerminalDestroyed"] = "<color=#ce422b>The terminal has been destroyed!</color>",
            ["Warning.TerminalShutdown"] = "<color=#ce422b>The terminal has been shutdown</color>",
            ["Warning.InUse"] = "<color=#ce422b>This camera is currently in use</color>",
            ["Warning.CameraDestroyed"] = "<color=#ce422b>This camera has been destroyed!</color>",
            ["Placement.Enabled"] = "<color=#939393>You have <color=#ce422b>enabled</color> the camera placement tool!</color>",
            ["Placement.Removed"] = "<color=#939393>You have <color=#ce422b>removed</color> this security camera!</color>",
            ["Error.NoPrivilege"] = "<color=#ce422b>You require tool cupboard access to use these commands!</color>",
            ["Error.Limit"] = "<color=#939393>This building already has the maximum number of security cameras!</color>",
            ["Error.NoBuilding"] = "<color=#939393>The camera controller needs to be attached to the building the cameras are on</color>",
            ["Error.InvalidCommand"] = "<color=#939393>Invalid command! Type <color=#ce422b>/sc</color> for available commands</color>",
            ["Error.NoEntity"] = "<color=#939393>You are not looking at a security camera</color>",            
            ["Error.InvalidPlacement"] = "<color=#ce422b>Invalid camera placement!</color> <color=#939393>Unable to find a neighbouring building block</color>",            
            ["Error.NoCamera"] = "<color=#939393>You must have a camera in your hands to activate the placement tool!</color>",
            ["Error.NoTerminal"] = "<color=#939393>The building requires a terminal to place a camera!</color>",
            ["Error.NoBuildingPrivilege"] = "<color=#939393>You must be inside building privilege to place a camera!</color>",
            ["Error.NoNameSpecified"] = "<color=#939393>You must enter a name for the camera!</color>",
            ["Error.TerminalID"] = "<color=#939393>You need to enter a valid terminal ID</color>",
            ["Error.RustNETID"] = "<color=#939393>Invalid terminal ID selected! You can find the terminal ID by opening the terminal</color>",
            ["Error.PublicLink"] = "<color=#939393>You do not have permission to remove public cameras</color>",
            ["Success.NameSet"] = "<color=#939393>You have set the name of this camera to <color=#ce422b>{0}</color></color>",
            ["UI.Select.Camera"] = "> <color=#28ffa6>Cameras</color> <",
            ["UI.NoCameras"] = "No cameras registered to this terminal",
            ["UI.Camera"] = "> Camera {0}",
            ["UI.CameraName"] = "Camera {0}",
            ["UI.Help.Title"] = "> <color=#28ffa6>Camera Help Menu</color> <",
            ["UI.Help"] = "> Creating a security camera\nStep 1. Place a camera item in your hands.\nStep 2. Type <color=#28ffa6>/sc add</color>. The camera placement tool will now be activated. You can place the camera by pressing the <color=#28ffa6>FIRE</color> key, or cancel placement by pressing the <color=#28ffa6>AIM</color> key.\n\n> Cameras can only be placed on building blocks.\n> If the building block the camera is placed on is destroyed, the camera will also be destroyed.\n> Once you place a camera it will be registered to the terminal of the base that you placed it on\n> You can access any camera attached to your base by interacting with the RustNET terminal.\n\n> Removing a camera\nTo remove a camera look at it and type <color=#28ffa6>/sc remove</color>. This will remove the camera and give you a camera item back to be placed elsewhere.",
            ["UI.Help.Public"] = "\n\n> Creating a public security camera\nPublic cameras can be placed anywhere and accessed by anyone, although they should NOT be placed on building blocks or player bases.\nYou will require a public terminal already placed somewhere in the world and its terminal ID to create a public camera.\n\nStep 1. Place a camera item in your hands.\nStep 2. Type <color=#28ffa6>/sc add public <terminal ID></color>. The ID is the 4 digit number displayed when you open the terminal.\nYou can place the camera by pressing the <color=#28ffa6>FIRE</color> key, or cancel placement by pressing the <color=#28ffa6>AIM</color> key.",
        };
        #endregion       
    }
}


// --- End of file: SecurityCameras.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BetterResearching.cs ---
// --- Original Local Path: BetterResearching.cs ---

namespace Oxide.Plugins
{
    [Info("Better Researching", "Waizujin", 1.3)]
    [Description("Allows instant researching and adjustable research chance.")]
    public class BetterResearching : RustPlugin
    {
        public float ResearchChance { get { return Config.Get<float>("ResearchChance"); } }
        public float ResearchCostFraction { get { return Config.Get<float>("ResearchCostFraction"); } }
        public int PaperRequired { get { return Config.Get<int>("PaperRequired"); } }

        protected override void LoadConfig()
        {
            bool dirty = false;
            base.LoadConfig();

            if (Config["InstantResearch"] == null)
            {
                Config["InstantResearch"] = false;
                dirty = true;
            }

            if (Config["ResearchChance"] == null)
            {
                Config["ResearchChance"] = 0.3f;
                dirty = true;
            }

            if (Config["PaperRequired"] == null)
            {
                Config["PaperRequired"] = 10;
                dirty = true;
            }

            if (Config["ResearchCostFraction"] == null)
            {
                Config["ResearchCostFraction"] = 1f;
                dirty = true;
            }

            if (dirty)
            {
                PrintWarning("Updating configuration file with new values.");
                SaveConfig();
            }
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file.");
            Config.Clear();

            Config["InstantResearch"] = false;
            Config["ResearchChance"] = 0.3f;
            Config["PaperRequired"] = 10;
            Config["ResearchCostFraction"] = 1f;

            SaveConfig();
        }

        void OnServerInitialized()
        {
            updateResearchTables();
        }

        void OnItemDeployed(Deployer deployer, BaseEntity deployedEntity)
        {
            Item item = deployer.GetItem();

            if (item.info.shortname == "research_table")
            {
                updateResearchTables();
            }
        }

        void OnItemResearchStart(ResearchTable table)
        {
            table.researchCostFraction = ResearchCostFraction;

            if((bool) Config["InstantResearch"]) {
                table.researchDuration = 0f;
            }
        }

        private float OnItemResearchEnd(ResearchTable table, float chance)
        {
            Item item = table.GetResearchItem();
            float num1 = ResearchChance;

            if (!item.hasCondition)
            {
                if (chance <= num1)
                {
                    chance = 0f;
                }
                else
                {
                    chance = 1f;
                }

                return chance;
            }

            float num2 = item.maxCondition / item.info.condition.max;
            float successChance = num1 * num2 * item.conditionNormalized;

            if (chance <= successChance)
            {
                chance = 0f;
            }
            else
            {
                chance = 1f;
            }

            return chance;
        }

        public void updateResearchTables()
        {
            var researchTables = UnityEngine.Object.FindObjectsOfType<ResearchTable>();

            foreach (ResearchTable researchTable in researchTables)
            {
                researchTable.requiredPaper = PaperRequired;
            }
        }
    }
}


// --- End of file: BetterResearching.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/RepRewards.cs ---
// --- Original Local Path: RepRewards.cs ---

﻿using Oxide.Core.Configuration;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;

namespace Oxide.Plugins {
    [Info("Rep Rewards", "TopPlugin.ru", 1.0)]
    [Description("Reward players for representing your server!")]
    public class RepRewards : RustPlugin {
        [PluginReference]
        private Plugin economics = null;
        [PluginReference]
        private Plugin serverRewards = null;

        private Hash<string, Timer> users;

        private void Loaded() {
            if (economics == null || serverRewards == null) {
                foreach (Plugin pl in plugins.GetAll()) {
                    if (economics != null && serverRewards != null) break;

                    if (!pl.IsLoaded) continue;
                    if (economics == null && pl.Name.Equals("Economics")) {
                        economics = pl;
                        Puts("Found previously loaded Economics plugin.");
                        continue;
                    }
                    if (serverRewards == null && pl.Name.Equals("ServerRewards")) {
                        serverRewards = pl;
                        Puts("Found previously loaded ServerRewards plugin.");
                        continue;
                    }
                }
            }
            
            LoadConfig();
            users = new Hash<string, Timer>();

            foreach (BasePlayer player in BasePlayer.activePlayerList) {
                if (player.displayName.Contains(Config.Get<string>("RepKey"))) {
                    if (!users.ContainsKey(player.UserIDString)) {
                        Timer userTimer = timer.Every(Config.Get<float>("RewardIntervalMins") * 60f, () => {
                            RewardPlayer(player);
                        });
                        users.Add(player.UserIDString, userTimer);
                    }
                }
            }
        }

        private void OnPluginLoaded(Plugin plugin) {
            if (plugin.Name.Equals("Economics")) {
                economics = plugin;
                Puts("Found Economics plugin from subscribed event.");
            } else if (plugin.Name.Equals("ServerRewards")) {
                serverRewards = plugin;
                Puts("Found ServerRewards plugin from subscribed event.");
            }
        }

        private void OnPlayerConnected(BasePlayer player) {
            if (player.displayName.Contains(Config.Get<string>("RepKey"))) {
                if (!users.ContainsKey(player.UserIDString)) {
                    Timer userTimer = timer.Every(Config.Get<float>("RewardIntervalMins") * 60f, () => {
                        RewardPlayer(player);
                    });
                    users.Add(player.UserIDString, userTimer);
                }
            }
        }

        private void OnPlayerDisconnected(BasePlayer player, string reason) {
            if (users.ContainsKey(player.UserIDString)) {
                users[player.UserIDString].Destroy();
                if (!users.Remove(player.UserIDString)) {
                    Puts("Couldn't remove player!");
                }
            }
        }

        private void RewardPlayer(BasePlayer player) {
            Dictionary<string, double> itemRewards = Config.Get<Dictionary<string, double>>("ItemRewards");
            foreach (KeyValuePair<string, double> item in itemRewards) {
                if (item.Key.Equals("money")) {
                    if (economics != null) {
                        economics.Call("Deposit", player.userID, item.Value);
                    } else {
                        Puts("Couldn't find Economy plugin. " + item.Key);
                    }
                } else if (item.Key.Equals("points")) {
                    if (serverRewards != null) {
                        serverRewards.Call("AddPoints", player.userID, (int)item.Value);
                        Puts("Gave user points");
                    } else {
                        Puts("Couldn't find ServerRewards plugin. " + item.Key);
                    }
                } else {
                    int itemID = ItemManager.FindItemDefinition(item.Key).itemid;
                    Item objectToGive = ItemManager.CreateByItemID(itemID, (int)item.Value);
                    if (objectToGive == null) {
                        Puts("Invalid item! " + item.Key);
                    }
                    player.GiveItem(objectToGive);
                }
            }
        }

        // Default Config
        protected override void LoadDefaultConfig() {
            Config.Clear();
            Config["RepKey"] = "[RR]";
            Config["RewardIntervalMins"] = 10f;
            Dictionary<string, double> itemRewards = new Dictionary<string, double>();
            itemRewards.Add("money", 100.0);
            itemRewards.Add("points", 100.0);
            itemRewards.Add("metal.fragments", 1000.0);
            Config["ItemRewards"] = itemRewards;
        }
    }
}


// --- End of file: RepRewards.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BuildingProtection (1).cs ---
// --- Original Local Path: BuildingProtection (1).cs ---

using System; using System.Linq; using System.Collections; using System.Collections.Generic; using Oxide.Core; using Oxide.Game.Rust.Cui; using Oxide.Core.Plugins; using UnityEngine; using Rust; using Newtonsoft.Json; namespace Oxide.Plugins { [Info("BuildingProtection", "Nimant", "1.0.3")] class BuildingProtection : RustPlugin { [PluginReference] private Plugin NoEscape; private const string OWOVpgnVlfVxxsMuOrNrJ = "buildingprotection.use"; private const string PGMMtZJJBYEHHcAHhhRG = "☐"; private const string ZeNttCwYMfQavz = "☑"; private static Dictionary<ulong, DHyiUPhOmQlUYi> ZpRpfYtdstxkqnrDctmFjHG = new Dictionary<ulong, DHyiUPhOmQlUYi>(); private class DHyiUPhOmQlUYi { public float xTmepcJMRSBCYpotIWvVjxncHGpirm; public int CKfukblzRm; public long UYhfLDMgybnUfsfAr; public BuildingPrivlidge daGIJHDKUbwTcWLDqcyvEKyoUgP; public List<uint> fUSUsDdJKJxLwFEoG = new List<uint>(); public Dictionary<string, int> InzmNYamAcRouAhooBXjK = null; public Dictionary<string, int> LOiPIabNmehxGwNGwcfrSFOAkxg = null; } private static bool DSZRmXskeNPbtuIULZ = false; private static Dictionary<ulong, rcxnpARIqA> jVrZEpCTSbLq = new Dictionary<ulong, rcxnpARIqA>(); private class rcxnpARIqA { public int GbtXbbXGQhryAd; public Dictionary<uint, THKYObKFdbXpSTzeXvejA> VPOgwjDRXYfHDUisEgLjZUynG = new Dictionary<uint, THKYObKFdbXpSTzeXvejA>(); } private static List<BuildingPrivlidge> hqVwQYSwveXkjeRwploLosAbB = new List<BuildingPrivlidge>(); private static string PfwNpbGXroE = null; private void Init() { FbUwtQnmPCLjJgk(); wZjNGtqHGNwmqtfUizKyMOX(); lang.RegisterMessages(HhSsvHSFdMIRcQjDGsqeEQRnBGpjRP, this, "en"); permission.RegisterPermission(OWOVpgnVlfVxxsMuOrNrJ, this); foreach (var OhZbSGgexQmVYo in HIRsvYQPzWyuvfESFxHaUFIZurtTC.RmrosELnidzVJnFLKUlKeIxGLnRX) permission.RegisterPermission(OhZbSGgexQmVYo.Key, this); DSZRmXskeNPbtuIULZ = false; if (!string.IsNullOrEmpty(HIRsvYQPzWyuvfESFxHaUFIZurtTC.CommandChatBP)) cmd.AddChatCommand(HIRsvYQPzWyuvfESFxHaUFIZurtTC.CommandChatBP, this, "cmdBP"); RaUuSZVKIAvrtfTR(HIRsvYQPzWyuvfESFxHaUFIZurtTC); } private void OnServerInitialized() { ZpRpfYtdstxkqnrDctmFjHG.Clear(); jVrZEpCTSbLq.Clear(); hqVwQYSwveXkjeRwploLosAbB.Clear(); var zRCdTSyvMjZjbzqFTfEllInYVbVa = BaseNetworkable.serverEntities.OfType<BaseEntity>().Where(x=> x!=null && !x.IsDestroyed && htjoTujQiNY.iCsBlkTpLGdFOvVb.ContainsKey(x.net.ID) && !htjoTujQiNY.iCsBlkTpLGdFOvVb[x.net.ID].jUEuKEKgYDmZEzqLbOAwZjRc).Select(x=> x.net.ID).ToHashSet(); htjoTujQiNY.iCsBlkTpLGdFOvVb = htjoTujQiNY.iCsBlkTpLGdFOvVb.Where(x=> zRCdTSyvMjZjbzqFTfEllInYVbVa.Contains(x.Key)).ToDictionary(x=> x.Key, x=> x.Value); mQzhRoJNMQhRYNGRRGouBHwpzchVGn(); YdyGyUGPjDyQuoEwgBawGtqbaB(); timer.Once(3f, ()=> { foreach (var eztFfWeeIhyNfEiSrzLS in BasePlayer.activePlayerList) OnPlayerInit(eztFfWeeIhyNfEiSrzLS); xQWAhngVweKRUulszOTiHptfrUS(); FvqvCLgzoHekniMb(); }); } private void OnPlayerInit(BasePlayer eztFfWeeIhyNfEiSrzLS) { if (eztFfWeeIhyNfEiSrzLS == null) return; if (eztFfWeeIhyNfEiSrzLS.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot)) { timer.Once(0.5f, () => OnPlayerInit(eztFfWeeIhyNfEiSrzLS)); return; } if (htjoTujQiNY.HVMhRoaoCievfPDLpLtyzLrnHS.ContainsKey(eztFfWeeIhyNfEiSrzLS.userID) && htjoTujQiNY.HVMhRoaoCievfPDLpLtyzLrnHS[eztFfWeeIhyNfEiSrzLS.userID].Count() > 0) bkCLUKXnmbelgdhAIeIMoc(eztFfWeeIhyNfEiSrzLS); } private void Unload() { mQzhRoJNMQhRYNGRRGouBHwpzchVGn(); foreach (var eztFfWeeIhyNfEiSrzLS in BasePlayer.activePlayerList) { CuiHelper.DestroyUi(eztFfWeeIhyNfEiSrzLS, ayYSMEgmsLvDAgljdcPIml); CuiHelper.DestroyUi(eztFfWeeIhyNfEiSrzLS, "IconPanel"); } } private void OnNewSave() { htjoTujQiNY.iCsBlkTpLGdFOvVb.Clear(); htjoTujQiNY.HVMhRoaoCievfPDLpLtyzLrnHS.Clear(); mQzhRoJNMQhRYNGRRGouBHwpzchVGn(); } private void OnHammerHit(BasePlayer eztFfWeeIhyNfEiSrzLS, HitInfo info) { if (eztFfWeeIhyNfEiSrzLS == null || info?.HitEntity == null || !permission.UserHasPermission(eztFfWeeIhyNfEiSrzLS.UserIDString, OWOVpgnVlfVxxsMuOrNrJ)) return; if (info.HitEntity is BuildingPrivlidge && (info.HitEntity as BuildingPrivlidge).IsAuthed(eztFfWeeIhyNfEiSrzLS)) PjoEKarzAEFhBoEh(eztFfWeeIhyNfEiSrzLS, info.HitEntity as BuildingPrivlidge); } private void OnStructureUpgrade(BaseCombatEntity CyGbREYipufEhLlJYkZFPkw) { if (CyGbREYipufEhLlJYkZFPkw == null || !htjoTujQiNY.iCsBlkTpLGdFOvVb.ContainsKey(CyGbREYipufEhLlJYkZFPkw.net.ID)) return; htjoTujQiNY.iCsBlkTpLGdFOvVb[CyGbREYipufEhLlJYkZFPkw.net.ID].jUEuKEKgYDmZEzqLbOAwZjRc = true; } private void OnEntityTakeDamage(BaseCombatEntity CyGbREYipufEhLlJYkZFPkw, HitInfo dZmGnyMWbrVRuaEc) { if (CyGbREYipufEhLlJYkZFPkw == null || dZmGnyMWbrVRuaEc == null) return; if (!dZmGnyMWbrVRuaEc.hasDamage || dZmGnyMWbrVRuaEc.damageTypes == null) return; if (!HIRsvYQPzWyuvfESFxHaUFIZurtTC.WAwJTluQpKj.Contains(CyGbREYipufEhLlJYkZFPkw.ShortPrefabName) && !(CyGbREYipufEhLlJYkZFPkw is BuildingBlock)) return; CuFTmOvASzbETPIsC(CyGbREYipufEhLlJYkZFPkw, dZmGnyMWbrVRuaEc); } private void cmdBP(BasePlayer eztFfWeeIhyNfEiSrzLS, string hXITxPqoZrEvoXys, string[] args) { if (eztFfWeeIhyNfEiSrzLS == null || !permission.UserHasPermission(eztFfWeeIhyNfEiSrzLS.UserIDString, OWOVpgnVlfVxxsMuOrNrJ)) return; var buildingPrivilege = eztFfWeeIhyNfEiSrzLS.GetBuildingPrivilege(); if (buildingPrivilege != null && buildingPrivilege.IsAuthed(eztFfWeeIhyNfEiSrzLS)) PjoEKarzAEFhBoEh(eztFfWeeIhyNfEiSrzLS, buildingPrivilege); else SendReply(eztFfWeeIhyNfEiSrzLS, string.Format(zlBwsfqIZhISnFHdBH("INFO.NO_CUP_AUTH", eztFfWeeIhyNfEiSrzLS.userID))); } private void xQWAhngVweKRUulszOTiHptfrUS() { if (!DSZRmXskeNPbtuIULZ) { var RflRUMhWNwjir = hpGNPeGnzYRReiWGgloEPvAeufDr(DateTime.Now); var uecOOAHGxgMcVxKXAW = new Dictionary<uint, THKYObKFdbXpSTzeXvejA>(); foreach(var OhZbSGgexQmVYo in htjoTujQiNY.iCsBlkTpLGdFOvVb) if ((OhZbSGgexQmVYo.Value.dTyvbttwmBMF - RflRUMhWNwjir) >= 0) uecOOAHGxgMcVxKXAW.Add(OhZbSGgexQmVYo.Key, OhZbSGgexQmVYo.Value); if (htjoTujQiNY.iCsBlkTpLGdFOvVb.Count() != uecOOAHGxgMcVxKXAW.Count()) { try { htjoTujQiNY.iCsBlkTpLGdFOvVb = uecOOAHGxgMcVxKXAW; mQzhRoJNMQhRYNGRRGouBHwpzchVGn(); } catch{} } } timer.Once(60f, xQWAhngVweKRUulszOTiHptfrUS); } private void FvqvCLgzoHekniMb(ulong pDktUvdrNoKvwbLOHcCvkdviel = 0) { var bMYheABVuLmynoQ = false; var juoZyUyjPJpzSMoNTq = hpGNPeGnzYRReiWGgloEPvAeufDr(DateTime.Now); foreach (var OhZbSGgexQmVYo in htjoTujQiNY.HVMhRoaoCievfPDLpLtyzLrnHS.ToDictionary(x=> x.Key, x=> x.Value)) { if (pDktUvdrNoKvwbLOHcCvkdviel != 0 && pDktUvdrNoKvwbLOHcCvkdviel != OhZbSGgexQmVYo.Key) continue; var eztFfWeeIhyNfEiSrzLS = BasePlayer.FindByID(OhZbSGgexQmVYo.Key); if (eztFfWeeIhyNfEiSrzLS == null) continue; if (OhZbSGgexQmVYo.Value.Count() == 0) { CuiHelper.DestroyUi(eztFfWeeIhyNfEiSrzLS, "IconPanel"); htjoTujQiNY.HVMhRoaoCievfPDLpLtyzLrnHS.Remove(OhZbSGgexQmVYo.Key); bMYheABVuLmynoQ = true; continue; } else { if (!jVrZEpCTSbLq.ContainsKey(OhZbSGgexQmVYo.Key)) jVrZEpCTSbLq.Add(OhZbSGgexQmVYo.Key, new rcxnpARIqA()); else { jVrZEpCTSbLq[OhZbSGgexQmVYo.Key].GbtXbbXGQhryAd++; if (jVrZEpCTSbLq[OhZbSGgexQmVYo.Key].GbtXbbXGQhryAd+1 > OhZbSGgexQmVYo.Value.Count()) jVrZEpCTSbLq[OhZbSGgexQmVYo.Key].GbtXbbXGQhryAd = 0; } var UElTEUsksLPPEdfWq = RyWHwlZMXKbHFnNseXpZCjffJRkv(OhZbSGgexQmVYo.Value[jVrZEpCTSbLq[OhZbSGgexQmVYo.Key].GbtXbbXGQhryAd]); if (UElTEUsksLPPEdfWq == null || !UElTEUsksLPPEdfWq.IsAuthed(eztFfWeeIhyNfEiSrzLS)) { htjoTujQiNY.HVMhRoaoCievfPDLpLtyzLrnHS[OhZbSGgexQmVYo.Key].Remove(OhZbSGgexQmVYo.Value[jVrZEpCTSbLq[OhZbSGgexQmVYo.Key].GbtXbbXGQhryAd]); bMYheABVuLmynoQ = true; continue; } if (!jVrZEpCTSbLq[OhZbSGgexQmVYo.Key].VPOgwjDRXYfHDUisEgLjZUynG.ContainsKey(UElTEUsksLPPEdfWq.net.ID)) { var info = GDfNGTzuGYfMtZESO(UElTEUsksLPPEdfWq); if (info != null) jVrZEpCTSbLq[OhZbSGgexQmVYo.Key].VPOgwjDRXYfHDUisEgLjZUynG.Add(UElTEUsksLPPEdfWq.net.ID, info); else { htjoTujQiNY.HVMhRoaoCievfPDLpLtyzLrnHS[OhZbSGgexQmVYo.Key].Remove(OhZbSGgexQmVYo.Value[jVrZEpCTSbLq[OhZbSGgexQmVYo.Key].GbtXbbXGQhryAd]); bMYheABVuLmynoQ = true; continue; } } var CfYJiWHBvlwWIRlpuDZQl = jVrZEpCTSbLq[OhZbSGgexQmVYo.Key].VPOgwjDRXYfHDUisEgLjZUynG[UElTEUsksLPPEdfWq.net.ID].dTyvbttwmBMF - juoZyUyjPJpzSMoNTq; if (CfYJiWHBvlwWIRlpuDZQl <= 0) { htjoTujQiNY.HVMhRoaoCievfPDLpLtyzLrnHS[OhZbSGgexQmVYo.Key].Remove(OhZbSGgexQmVYo.Value[jVrZEpCTSbLq[OhZbSGgexQmVYo.Key].GbtXbbXGQhryAd]); bMYheABVuLmynoQ = true; continue; } nDSdiAzYcDUrZTOEZsa(eztFfWeeIhyNfEiSrzLS, CfYJiWHBvlwWIRlpuDZQl, jVrZEpCTSbLq[OhZbSGgexQmVYo.Key].VPOgwjDRXYfHDUisEgLjZUynG[UElTEUsksLPPEdfWq.net.ID].cdspsASrrXBdzATOFNpbJmxD, OhZbSGgexQmVYo.Value.Count()==1 ? 0 : jVrZEpCTSbLq[OhZbSGgexQmVYo.Key].GbtXbbXGQhryAd+1); } } if (bMYheABVuLmynoQ) mQzhRoJNMQhRYNGRRGouBHwpzchVGn(); if (pDktUvdrNoKvwbLOHcCvkdviel == 0) timer.Once(10f, ()=> FvqvCLgzoHekniMb()); } private static void CuFTmOvASzbETPIsC(BaseCombatEntity CyGbREYipufEhLlJYkZFPkw, HitInfo dZmGnyMWbrVRuaEc) { if (!htjoTujQiNY.iCsBlkTpLGdFOvVb.ContainsKey(CyGbREYipufEhLlJYkZFPkw.net.ID) || htjoTujQiNY.iCsBlkTpLGdFOvVb[CyGbREYipufEhLlJYkZFPkw.net.ID].jUEuKEKgYDmZEzqLbOAwZjRc) return; for (int i = 0; i < (int)dZmGnyMWbrVRuaEc.damageTypes.types.Length; i++) { float nkKtBXpGbIgSpIdrsCzEGRP = dZmGnyMWbrVRuaEc.damageTypes.types[i]; if (!float.IsNaN(nkKtBXpGbIgSpIdrsCzEGRP) && !float.IsInfinity(nkKtBXpGbIgSpIdrsCzEGRP) && nkKtBXpGbIgSpIdrsCzEGRP > 0) dZmGnyMWbrVRuaEc.damageTypes.Scale((DamageType)i, 1f - htjoTujQiNY.iCsBlkTpLGdFOvVb[CyGbREYipufEhLlJYkZFPkw.net.ID].cdspsASrrXBdzATOFNpbJmxD/100f); } } private DHyiUPhOmQlUYi ciaTOTCuDwKfpyfWbXJYIpZMnp(BasePlayer eztFfWeeIhyNfEiSrzLS, BuildingPrivlidge UElTEUsksLPPEdfWq) { var RjQizHusPlbYmv = new DHyiUPhOmQlUYi(); float LjHZPpcPPRcNDLf = 1f; foreach (var OhZbSGgexQmVYo in HIRsvYQPzWyuvfESFxHaUFIZurtTC.RmrosELnidzVJnFLKUlKeIxGLnRX.OrderBy(x=> x.Value)) { if (permission.UserHasPermission(eztFfWeeIhyNfEiSrzLS.UserIDString, OhZbSGgexQmVYo.Key)) { LjHZPpcPPRcNDLf = OhZbSGgexQmVYo.Value; break; } } RjQizHusPlbYmv.xTmepcJMRSBCYpotIWvVjxncHGpirm = HIRsvYQPzWyuvfESFxHaUFIZurtTC.WUkZrDfquy; RjQizHusPlbYmv.CKfukblzRm = HIRsvYQPzWyuvfESFxHaUFIZurtTC.qQiYjYCTFYGvVlYwaVgSv; RjQizHusPlbYmv.InzmNYamAcRouAhooBXjK = tmiyvxVvON(UElTEUsksLPPEdfWq, LjHZPpcPPRcNDLf); RjQizHusPlbYmv.LOiPIabNmehxGwNGwcfrSFOAkxg = WsxxcFKfjohNq(eztFfWeeIhyNfEiSrzLS, RjQizHusPlbYmv.InzmNYamAcRouAhooBXjK.Keys.ToList()); RjQizHusPlbYmv.fUSUsDdJKJxLwFEoG = aThTzBZfWtzCTSmtbpfvpFEJMnb(UElTEUsksLPPEdfWq); RjQizHusPlbYmv.daGIJHDKUbwTcWLDqcyvEKyoUgP = UElTEUsksLPPEdfWq; return RjQizHusPlbYmv; } private static bool dYDXPtOHhfykMrMThXyGbs(BasePlayer eztFfWeeIhyNfEiSrzLS) { ZpRpfYtdstxkqnrDctmFjHG[eztFfWeeIhyNfEiSrzLS.userID].LOiPIabNmehxGwNGwcfrSFOAkxg = WsxxcFKfjohNq(eztFfWeeIhyNfEiSrzLS, ZpRpfYtdstxkqnrDctmFjHG[eztFfWeeIhyNfEiSrzLS.userID].InzmNYamAcRouAhooBXjK.Keys.ToList()); foreach(var OhZbSGgexQmVYo in ZpRpfYtdstxkqnrDctmFjHG[eztFfWeeIhyNfEiSrzLS.userID].InzmNYamAcRouAhooBXjK) { int wOqUTemtIiG = ZpRpfYtdstxkqnrDctmFjHG[eztFfWeeIhyNfEiSrzLS.userID].LOiPIabNmehxGwNGwcfrSFOAkxg.ContainsKey(OhZbSGgexQmVYo.Key) ? ZpRpfYtdstxkqnrDctmFjHG[eztFfWeeIhyNfEiSrzLS.userID].LOiPIabNmehxGwNGwcfrSFOAkxg[OhZbSGgexQmVYo.Key] : 0; int EXHfmprVnUG = (int)Math.Round(OhZbSGgexQmVYo.Value * ZpRpfYtdstxkqnrDctmFjHG[eztFfWeeIhyNfEiSrzLS.userID].xTmepcJMRSBCYpotIWvVjxncHGpirm * ZpRpfYtdstxkqnrDctmFjHG[eztFfWeeIhyNfEiSrzLS.userID].CKfukblzRm * neygPZBqOxPeyyCfNHjNlYY(ZpRpfYtdstxkqnrDctmFjHG[eztFfWeeIhyNfEiSrzLS.userID].xTmepcJMRSBCYpotIWvVjxncHGpirm) * CDSVHYsJCghKZTqkdWzNszkvBv(ZpRpfYtdstxkqnrDctmFjHG[eztFfWeeIhyNfEiSrzLS.userID].CKfukblzRm)); if (wOqUTemtIiG < EXHfmprVnUG) return false; } return true; } private static void ThablvjYgzPPFtapXSKl(BasePlayer eztFfWeeIhyNfEiSrzLS) { foreach(var OhZbSGgexQmVYo in ZpRpfYtdstxkqnrDctmFjHG[eztFfWeeIhyNfEiSrzLS.userID].InzmNYamAcRouAhooBXjK) { int EXHfmprVnUG = (int)Math.Round(OhZbSGgexQmVYo.Value * ZpRpfYtdstxkqnrDctmFjHG[eztFfWeeIhyNfEiSrzLS.userID].xTmepcJMRSBCYpotIWvVjxncHGpirm * ZpRpfYtdstxkqnrDctmFjHG[eztFfWeeIhyNfEiSrzLS.userID].CKfukblzRm * neygPZBqOxPeyyCfNHjNlYY(ZpRpfYtdstxkqnrDctmFjHG[eztFfWeeIhyNfEiSrzLS.userID].xTmepcJMRSBCYpotIWvVjxncHGpirm) * CDSVHYsJCghKZTqkdWzNszkvBv(ZpRpfYtdstxkqnrDctmFjHG[eztFfWeeIhyNfEiSrzLS.userID].CKfukblzRm)); var pEEmEHpWrWCYzgP = ItemManager.FindItemDefinition(OhZbSGgexQmVYo.Key); if (pEEmEHpWrWCYzgP == null) continue; eztFfWeeIhyNfEiSrzLS.inventory.Take(eztFfWeeIhyNfEiSrzLS.inventory.AllItems().ToList(), pEEmEHpWrWCYzgP.itemid, EXHfmprVnUG); } } private static string USsAdFTaOOwkGrEVPu(string hSamcTjjkLhpSCRRSZx) { if (HIRsvYQPzWyuvfESFxHaUFIZurtTC.gKOyVvBdMhstfyHffixIQDfEbhpLvj.ContainsKey(hSamcTjjkLhpSCRRSZx)) return HIRsvYQPzWyuvfESFxHaUFIZurtTC.gKOyVvBdMhstfyHffixIQDfEbhpLvj[hSamcTjjkLhpSCRRSZx]; return hSamcTjjkLhpSCRRSZx; } private static BuildingPrivlidge RyWHwlZMXKbHFnNseXpZCjffJRkv(uint JmSlRHEiXsEwgvVxzC) { var UElTEUsksLPPEdfWq = hqVwQYSwveXkjeRwploLosAbB.FirstOrDefault(x=> x != null && x.net.ID == JmSlRHEiXsEwgvVxzC); if (UElTEUsksLPPEdfWq == null) { var CyGbREYipufEhLlJYkZFPkw = BaseNetworkable.serverEntities.OfType<BuildingPrivlidge>().FirstOrDefault(x=> x != null && x.net.ID == JmSlRHEiXsEwgvVxzC); if (CyGbREYipufEhLlJYkZFPkw != null) { hqVwQYSwveXkjeRwploLosAbB.Add(CyGbREYipufEhLlJYkZFPkw); return CyGbREYipufEhLlJYkZFPkw; } } return UElTEUsksLPPEdfWq; } private static List<uint> aThTzBZfWtzCTSmtbpfvpFEJMnb(BuildingPrivlidge UElTEUsksLPPEdfWq) { var PQgaztpdvJdKRFZKkicyWHBftesRm = UElTEUsksLPPEdfWq.GetBuilding(); if (PQgaztpdvJdKRFZKkicyWHBftesRm == null || !PQgaztpdvJdKRFZKkicyWHBftesRm.HasDecayEntities()) return null; var LhdrKSnVepi = PQgaztpdvJdKRFZKkicyWHBftesRm.decayEntities.Where(x=> x!=null && !x.IsDestroyed && (HIRsvYQPzWyuvfESFxHaUFIZurtTC.WAwJTluQpKj.Contains(x.ShortPrefabName) || x is BuildingBlock)).Select(x=> x.net.ID).ToList(); if (HIRsvYQPzWyuvfESFxHaUFIZurtTC.WAwJTluQpKj.Contains(UElTEUsksLPPEdfWq.ShortPrefabName) && !LhdrKSnVepi.Contains(UElTEUsksLPPEdfWq.net.ID)) LhdrKSnVepi.Add(UElTEUsksLPPEdfWq.net.ID); return LhdrKSnVepi; } private static int KcBlKeRmnM(BuildingPrivlidge UElTEUsksLPPEdfWq) { var PQgaztpdvJdKRFZKkicyWHBftesRm = UElTEUsksLPPEdfWq.GetBuilding(); if (PQgaztpdvJdKRFZKkicyWHBftesRm == null || !PQgaztpdvJdKRFZKkicyWHBftesRm.HasDecayEntities()) return 0; return PQgaztpdvJdKRFZKkicyWHBftesRm.decayEntities.Where(x=> x != null && !x.IsDestroyed && x is BuildingBlock).Count(); } private static Dictionary<string, float> hwRhYZSATICNXfBRs(BuildingPrivlidge UElTEUsksLPPEdfWq) { var PQgaztpdvJdKRFZKkicyWHBftesRm = UElTEUsksLPPEdfWq.GetBuilding(); if (PQgaztpdvJdKRFZKkicyWHBftesRm == null || !PQgaztpdvJdKRFZKkicyWHBftesRm.HasDecayEntities()) return null; var ZRjMzshOskQzIEVPxiMIy = PQgaztpdvJdKRFZKkicyWHBftesRm.decayEntities.Where(x=> x!=null && !x.IsDestroyed && (HIRsvYQPzWyuvfESFxHaUFIZurtTC.WAwJTluQpKj.Contains(x.ShortPrefabName) || x is BuildingBlock)).ToList(); if (HIRsvYQPzWyuvfESFxHaUFIZurtTC.WAwJTluQpKj.Contains(UElTEUsksLPPEdfWq.ShortPrefabName) && !ZRjMzshOskQzIEVPxiMIy.Contains(UElTEUsksLPPEdfWq as DecayEntity)) ZRjMzshOskQzIEVPxiMIy.Add(UElTEUsksLPPEdfWq as DecayEntity); var RjQizHusPlbYmv = new Dictionary<string, float>(); foreach(var CGWDCTyALZbkWaYeDwCi in ZRjMzshOskQzIEVPxiMIy) { var AkgqvQCRrQMBWqeBbBApJcoBFlRgl = CGWDCTyALZbkWaYeDwCi.BuildCost(); if (AkgqvQCRrQMBWqeBbBApJcoBFlRgl == null) continue; foreach (ItemAmount itemAmount in AkgqvQCRrQMBWqeBbBApJcoBFlRgl) { if (itemAmount.itemDef.category != ItemCategory.Resources) continue; if (!RjQizHusPlbYmv.ContainsKey(itemAmount.itemDef.shortname)) RjQizHusPlbYmv.Add(itemAmount.itemDef.shortname, 0); RjQizHusPlbYmv[itemAmount.itemDef.shortname] += itemAmount.amount; } } return RjQizHusPlbYmv; } private static Dictionary<string, int> tmiyvxVvON(BuildingPrivlidge UElTEUsksLPPEdfWq, float LjHZPpcPPRcNDLf) { var gQyKJTfugWyZSiUzJisDeslf = hwRhYZSATICNXfBRs(UElTEUsksLPPEdfWq); if (gQyKJTfugWyZSiUzJisDeslf == null) return null; var RjQizHusPlbYmv = new Dictionary<string, int>(); int TkXcwWOBjApAMKTmSVRRMUFZbCEX = KcBlKeRmnM(UElTEUsksLPPEdfWq); float rePmhzGjMBkOBfrdBamWhXAVsS = 1f; foreach (var OhZbSGgexQmVYo in HIRsvYQPzWyuvfESFxHaUFIZurtTC.PcLEgwhWxwYXWLBUHMxBSBbSYVv.OrderByDescending(x=> x.Key)) { if (TkXcwWOBjApAMKTmSVRRMUFZbCEX >= OhZbSGgexQmVYo.Key) { rePmhzGjMBkOBfrdBamWhXAVsS = OhZbSGgexQmVYo.Value; break; } } foreach (var OhZbSGgexQmVYo in gQyKJTfugWyZSiUzJisDeslf) { if (OhZbSGgexQmVYo.Value <= 0f) continue; if (HIRsvYQPzWyuvfESFxHaUFIZurtTC.ESiTmtHBTeohwpzBGeUW.ContainsKey(OhZbSGgexQmVYo.Key)) { if (HIRsvYQPzWyuvfESFxHaUFIZurtTC.ESiTmtHBTeohwpzBGeUW[OhZbSGgexQmVYo.Key].YYRShJFRcBfcbPCquuXjgjjMQDHQT > 0f) { var amount = (int)Math.Round(OhZbSGgexQmVYo.Value * HIRsvYQPzWyuvfESFxHaUFIZurtTC.ESiTmtHBTeohwpzBGeUW[OhZbSGgexQmVYo.Key].YYRShJFRcBfcbPCquuXjgjjMQDHQT * (HIRsvYQPzWyuvfESFxHaUFIZurtTC.QcDimTVYjcB/100f) * rePmhzGjMBkOBfrdBamWhXAVsS * LjHZPpcPPRcNDLf); amount = amount < 1 ? 1 : amount; if (!RjQizHusPlbYmv.ContainsKey(HIRsvYQPzWyuvfESFxHaUFIZurtTC.ESiTmtHBTeohwpzBGeUW[OhZbSGgexQmVYo.Key].XPWVFkAIoCXaSFsTVAzqSSiGI)) RjQizHusPlbYmv.Add(HIRsvYQPzWyuvfESFxHaUFIZurtTC.ESiTmtHBTeohwpzBGeUW[OhZbSGgexQmVYo.Key].XPWVFkAIoCXaSFsTVAzqSSiGI, amount); else RjQizHusPlbYmv[HIRsvYQPzWyuvfESFxHaUFIZurtTC.ESiTmtHBTeohwpzBGeUW[OhZbSGgexQmVYo.Key].XPWVFkAIoCXaSFsTVAzqSSiGI] += amount; } } else { var amount = (int)Math.Round(OhZbSGgexQmVYo.Value * (HIRsvYQPzWyuvfESFxHaUFIZurtTC.QcDimTVYjcB/100f) * rePmhzGjMBkOBfrdBamWhXAVsS * LjHZPpcPPRcNDLf); amount = amount < 1 ? 1 : amount; RjQizHusPlbYmv.Add(OhZbSGgexQmVYo.Key, amount); } } return RjQizHusPlbYmv; } private static Dictionary<string, int> WsxxcFKfjohNq(BasePlayer eztFfWeeIhyNfEiSrzLS, List<string> gQyKJTfugWyZSiUzJisDeslf) { var RjQizHusPlbYmv = new Dictionary<string, int>(); foreach(var AGMhUNvwGBSINxypsTSWBx in eztFfWeeIhyNfEiSrzLS.inventory.AllItems().Where(x=> gQyKJTfugWyZSiUzJisDeslf.Contains(x.info.shortname))) { if (!RjQizHusPlbYmv.ContainsKey(AGMhUNvwGBSINxypsTSWBx.info.shortname)) RjQizHusPlbYmv.Add(AGMhUNvwGBSINxypsTSWBx.info.shortname, 0); RjQizHusPlbYmv[AGMhUNvwGBSINxypsTSWBx.info.shortname] += AGMhUNvwGBSINxypsTSWBx.amount; } return RjQizHusPlbYmv; } private static THKYObKFdbXpSTzeXvejA GDfNGTzuGYfMtZESO(BuildingPrivlidge UElTEUsksLPPEdfWq) { var WxKcwnOmaLHEiHfLY = aThTzBZfWtzCTSmtbpfvpFEJMnb(UElTEUsksLPPEdfWq); if (WxKcwnOmaLHEiHfLY?.Count() == 0) return null; var CGWDCTyALZbkWaYeDwCi = htjoTujQiNY.iCsBlkTpLGdFOvVb.Where(x=> WxKcwnOmaLHEiHfLY.Contains(x.Key)).OrderBy(x=> x.Value.cdspsASrrXBdzATOFNpbJmxD).FirstOrDefault(); return CGWDCTyALZbkWaYeDwCi.Value; } private static string SSvJOPDahXrxGAQaDcOCVYDwelq(BasePlayer eztFfWeeIhyNfEiSrzLS, uint JmSlRHEiXsEwgvVxzC) { if (!htjoTujQiNY.HVMhRoaoCievfPDLpLtyzLrnHS.ContainsKey(eztFfWeeIhyNfEiSrzLS.userID)) return PGMMtZJJBYEHHcAHhhRG; if (htjoTujQiNY.HVMhRoaoCievfPDLpLtyzLrnHS[eztFfWeeIhyNfEiSrzLS.userID].Contains(JmSlRHEiXsEwgvVxzC)) return ZeNttCwYMfQavz; return PGMMtZJJBYEHHcAHhhRG; } private static string MeZRnTsgPJchwzIYpqJDE(string RKEbMvykjk) { try { var eNxYsSILImxEutRcR = RKEbMvykjk.Split(' '); var r = (int)Math.Round(Convert.ToSingle(eNxYsSILImxEutRcR[0]) * 255f); var g = (int)Math.Round(Convert.ToSingle(eNxYsSILImxEutRcR[1]) * 255f); var b = (int)Math.Round(Convert.ToSingle(eNxYsSILImxEutRcR[2]) * 255f); return "#" + r.ToString("X2") + g.ToString("X2") + b.ToString("X2"); } catch { } return "white"; } private static string ayqPLbEUYCxOGOq(int mBnsIqPKgEnaOcqESyHZfV, bool twbQkCJGfoUHqHCPQ = false) { string RKEbMvykjk = twbQkCJGfoUHqHCPQ ? MeZRnTsgPJchwzIYpqJDE(HIRsvYQPzWyuvfESFxHaUFIZurtTC.rZGBuvEfDiwFzCUjsXDuPhBCyGEo) : "white"; return $"<color={RKEbMvykjk}>" + mBnsIqPKgEnaOcqESyHZfV.ToString("#,##0").Replace(",","'") + "</color>"; } private string HWaWrTxPyBtfJCWfzUhu(long CfYJiWHBvlwWIRlpuDZQl, bool EUfzGfHpjZYqkHhCHRNLmI, ulong pDktUvdrNoKvwbLOHcCvkdviel) { var XJfmsxqQYoh = (int)Math.Truncate(CfYJiWHBvlwWIRlpuDZQl / 3600f); var tULKyPsQkMVUZNEYgqLAIZBy = (int)Math.Floor(CfYJiWHBvlwWIRlpuDZQl / 60f - XJfmsxqQYoh * 60f); if (!EUfzGfHpjZYqkHhCHRNLmI) { var kmCZXQweHfyXRcGVRtMeROKMUTSJ = new List<string>() { zlBwsfqIZhISnFHdBH("MINUTE1", pDktUvdrNoKvwbLOHcCvkdviel), zlBwsfqIZhISnFHdBH("MINUTES1", pDktUvdrNoKvwbLOHcCvkdviel), zlBwsfqIZhISnFHdBH("MINUTES2", pDktUvdrNoKvwbLOHcCvkdviel) }; var xveCUppuhDfaNJxdZoimmQwfYK = $@"{LXquRVLGGmwxgmKcB(tULKyPsQkMVUZNEYgqLAIZBy, kmCZXQweHfyXRcGVRtMeROKMUTSJ)}"; var ssbEaqthLVaMUHRbFGvgIMZDXmpF = new List<string>() { zlBwsfqIZhISnFHdBH("HOUR", pDktUvdrNoKvwbLOHcCvkdviel), zlBwsfqIZhISnFHdBH("HOURS1", pDktUvdrNoKvwbLOHcCvkdviel), zlBwsfqIZhISnFHdBH("HOURS2", pDktUvdrNoKvwbLOHcCvkdviel) }; return (XJfmsxqQYoh > 0 ? $@"{LXquRVLGGmwxgmKcB(XJfmsxqQYoh, ssbEaqthLVaMUHRbFGvgIMZDXmpF)}" : "") + (tULKyPsQkMVUZNEYgqLAIZBy > 0 ? ((XJfmsxqQYoh > 0 ? " " : "") + xveCUppuhDfaNJxdZoimmQwfYK) : (XJfmsxqQYoh == 0 ? $@"1 {zlBwsfqIZhISnFHdBH("MINUTE2", pDktUvdrNoKvwbLOHcCvkdviel)}" : "")); } return (XJfmsxqQYoh > 0 ? $@"{XJfmsxqQYoh}{zlBwsfqIZhISnFHdBH("HOUR", pDktUvdrNoKvwbLOHcCvkdviel)[0]}" : "") + (tULKyPsQkMVUZNEYgqLAIZBy > 0 ? ((XJfmsxqQYoh > 0 ? " " : "") + $@"{tULKyPsQkMVUZNEYgqLAIZBy}{zlBwsfqIZhISnFHdBH("MINUTE1", pDktUvdrNoKvwbLOHcCvkdviel)[0]}") : (XJfmsxqQYoh == 0 ? $@"1{zlBwsfqIZhISnFHdBH("MINUTE1", pDktUvdrNoKvwbLOHcCvkdviel)[0]}" : "")); } private bool oheHITHFJFYiOHPmCfYfunMROyOedP(BasePlayer eztFfWeeIhyNfEiSrzLS) { if (NoEscape == null) return false; try { var DeJWXcbFHDuY = NoEscape.Call("ApiGetTime", eztFfWeeIhyNfEiSrzLS.userID); if (DeJWXcbFHDuY != null && (DeJWXcbFHDuY is int || DeJWXcbFHDuY is float || DeJWXcbFHDuY is long || DeJWXcbFHDuY is double || DeJWXcbFHDuY is uint || DeJWXcbFHDuY is ulong)) { if (Convert.ToInt64(DeJWXcbFHDuY) > 0) { SendReply(eztFfWeeIhyNfEiSrzLS, string.Format(zlBwsfqIZhISnFHdBH("NOESCAPE.WARNING", eztFfWeeIhyNfEiSrzLS.userID), DeJWXcbFHDuY)); return true; } } } catch { PrintWarning(zlBwsfqIZhISnFHdBH("NOESCAPE.CALL.ERROR")); } return false; } private static float neygPZBqOxPeyyCfNHjNlYY(float xQDkpXxGStqJpwaOjmgUSmikWB) { var RjQizHusPlbYmv = 1f; for (int uBjuIumTfsdohEYmBplW = 0; uBjuIumTfsdohEYmBplW < (int)Math.Round(xQDkpXxGStqJpwaOjmgUSmikWB / HIRsvYQPzWyuvfESFxHaUFIZurtTC.uRkyQkziKUEaKyLdGPminbfEN); uBjuIumTfsdohEYmBplW++ ) RjQizHusPlbYmv *= HIRsvYQPzWyuvfESFxHaUFIZurtTC.hgTDiegoLXbuTVpHav; return RjQizHusPlbYmv; } private static float CDSVHYsJCghKZTqkdWzNszkvBv(int XJfmsxqQYoh) { var RjQizHusPlbYmv = 1f; for (int uBjuIumTfsdohEYmBplW = 0; uBjuIumTfsdohEYmBplW < XJfmsxqQYoh; uBjuIumTfsdohEYmBplW++ ) RjQizHusPlbYmv *= HIRsvYQPzWyuvfESFxHaUFIZurtTC.aIVGeziGeitoyycbJRBtiMEXbHqOBW; return RjQizHusPlbYmv; } private const string ayYSMEgmsLvDAgljdcPIml = "BPPanel"; private void PjoEKarzAEFhBoEh(BasePlayer eztFfWeeIhyNfEiSrzLS, BuildingPrivlidge UElTEUsksLPPEdfWq) { if (eztFfWeeIhyNfEiSrzLS == null || UElTEUsksLPPEdfWq == null) return; var kEzXjiiXPmrzNAIOpqcMm = GDfNGTzuGYfMtZESO(UElTEUsksLPPEdfWq); if (kEzXjiiXPmrzNAIOpqcMm != null) oLFicwVIXrJDOklAOcO(eztFfWeeIhyNfEiSrzLS, kEzXjiiXPmrzNAIOpqcMm, UElTEUsksLPPEdfWq); else { if (!oheHITHFJFYiOHPmCfYfunMROyOedP(eztFfWeeIhyNfEiSrzLS)) { ZpRpfYtdstxkqnrDctmFjHG[eztFfWeeIhyNfEiSrzLS.userID] = ciaTOTCuDwKfpyfWbXJYIpZMnp(eztFfWeeIhyNfEiSrzLS, UElTEUsksLPPEdfWq); GPdvkxiUBmDiI(eztFfWeeIhyNfEiSrzLS); } } } private void oLFicwVIXrJDOklAOcO(BasePlayer eztFfWeeIhyNfEiSrzLS, THKYObKFdbXpSTzeXvejA kEzXjiiXPmrzNAIOpqcMm, BuildingPrivlidge UElTEUsksLPPEdfWq) { if (eztFfWeeIhyNfEiSrzLS == null) return; var CTanCGEFHH = new CuiElementContainer(); apCsaAWiXv(ref CTanCGEFHH, HIRsvYQPzWyuvfESFxHaUFIZurtTC.huotRVpEiisGCL, "0.35 0.2", "0.65 0.8"); SuXbKyvVKZKv(ref CTanCGEFHH, HIRsvYQPzWyuvfESFxHaUFIZurtTC.pHgijKkhafaWaQAWyCNIwZXHzcG, "0 0.92", "1 1"); jzZksiWahxYYl(ref CTanCGEFHH, HIRsvYQPzWyuvfESFxHaUFIZurtTC.chnJkKVjBAkIgjSFJaGUm, "X", 20, "0.90 0.92", "1 1", "bp_12345.close", "permanentmarker.ttf"); yiDkSeDzLRhkbHKquZShOcqGAyeXZL(ref CTanCGEFHH, zlBwsfqIZhISnFHdBH("TITLE.REMIND.MSG", eztFfWeeIhyNfEiSrzLS.userID), 18, "0.03 0.92", "0.89 1", TextAnchor.MiddleLeft); var CfYJiWHBvlwWIRlpuDZQl = HWaWrTxPyBtfJCWfzUhu(kEzXjiiXPmrzNAIOpqcMm.dTyvbttwmBMF - hpGNPeGnzYRReiWGgloEPvAeufDr(DateTime.Now), false, eztFfWeeIhyNfEiSrzLS.userID); var QqbMTvNEKFVg = string.Format(zlBwsfqIZhISnFHdBH("REMIND.HOME_PROTECT.MSG", eztFfWeeIhyNfEiSrzLS.userID), kEzXjiiXPmrzNAIOpqcMm.cdspsASrrXBdzATOFNpbJmxD, CfYJiWHBvlwWIRlpuDZQl); yiDkSeDzLRhkbHKquZShOcqGAyeXZL(ref CTanCGEFHH, QqbMTvNEKFVg, 18, "0.07 0.5", "0.93 0.9", TextAnchor.MiddleLeft); var LxeECrfUitaZwThE = 0.05f; var kFGRTkrauDwUxhCHvUpcCGoESNb = 0.525f; jzZksiWahxYYl(ref CTanCGEFHH, "1 1 1 0", SSvJOPDahXrxGAQaDcOCVYDwelq(eztFfWeeIhyNfEiSrzLS, UElTEUsksLPPEdfWq.net.ID), 18, $"{LxeECrfUitaZwThE-0.02} {0.55-0.08}", $"{0.15} {0.53}", $"bp_12345.toggleicon {UElTEUsksLPPEdfWq.net.ID}", "robotocondensed-regular.ttf", TextAnchor.MiddleCenter, ayYSMEgmsLvDAgljdcPIml, ayYSMEgmsLvDAgljdcPIml + "_toggle_icon"); yiDkSeDzLRhkbHKquZShOcqGAyeXZL(ref CTanCGEFHH, zlBwsfqIZhISnFHdBH("REMIND.CHECK_TOGGLE.MSG", eztFfWeeIhyNfEiSrzLS.userID), 18, $"{0.16} {0.45-0.04}", $"{0.4+kFGRTkrauDwUxhCHvUpcCGoESNb} {0.55}", TextAnchor.MiddleLeft); jzZksiWahxYYl(ref CTanCGEFHH, HIRsvYQPzWyuvfESFxHaUFIZurtTC.YyPzjwnofbDqeDtrAFPpCAqcXGDkM, zlBwsfqIZhISnFHdBH("BUTTON.APPLY", eztFfWeeIhyNfEiSrzLS.userID), 18, $"{0.02+LxeECrfUitaZwThE} {0.15-0.08}", $"{0.4+kFGRTkrauDwUxhCHvUpcCGoESNb} {0.15}", "bp_12345.close"); CuiHelper.DestroyUi(eztFfWeeIhyNfEiSrzLS, ayYSMEgmsLvDAgljdcPIml); CuiHelper.AddUi(eztFfWeeIhyNfEiSrzLS, CTanCGEFHH); } private void GPdvkxiUBmDiI(BasePlayer eztFfWeeIhyNfEiSrzLS) { if (eztFfWeeIhyNfEiSrzLS == null) return; var CTanCGEFHH = new CuiElementContainer(); apCsaAWiXv(ref CTanCGEFHH, HIRsvYQPzWyuvfESFxHaUFIZurtTC.huotRVpEiisGCL, "0.35 0.2", "0.65 0.8"); SuXbKyvVKZKv(ref CTanCGEFHH, HIRsvYQPzWyuvfESFxHaUFIZurtTC.pHgijKkhafaWaQAWyCNIwZXHzcG, "0 0.92", "1 1"); jzZksiWahxYYl(ref CTanCGEFHH, HIRsvYQPzWyuvfESFxHaUFIZurtTC.chnJkKVjBAkIgjSFJaGUm, "X", 20, "0.90 0.92", "1 1", "bp_12345.ok", "permanentmarker.ttf"); yiDkSeDzLRhkbHKquZShOcqGAyeXZL(ref CTanCGEFHH, zlBwsfqIZhISnFHdBH("TITLE.WARNING.MSG", eztFfWeeIhyNfEiSrzLS.userID), 18, "0.03 0.92", "0.89 1", TextAnchor.MiddleLeft); var QqbMTvNEKFVg = zlBwsfqIZhISnFHdBH("WARNING.RECOMENDATION.MSG", eztFfWeeIhyNfEiSrzLS.userID); yiDkSeDzLRhkbHKquZShOcqGAyeXZL(ref CTanCGEFHH, QqbMTvNEKFVg, 18, "0.07 0.2", "0.93 0.9", TextAnchor.MiddleLeft); var LxeECrfUitaZwThE = 0.05f; var kFGRTkrauDwUxhCHvUpcCGoESNb = 0.525f; jzZksiWahxYYl(ref CTanCGEFHH, HIRsvYQPzWyuvfESFxHaUFIZurtTC.YyPzjwnofbDqeDtrAFPpCAqcXGDkM, zlBwsfqIZhISnFHdBH("BUTTON.APPLY", eztFfWeeIhyNfEiSrzLS.userID), 18, $"{0.02+LxeECrfUitaZwThE} {0.15-0.08}", $"{0.4+kFGRTkrauDwUxhCHvUpcCGoESNb} {0.15}", "bp_12345.ok"); CuiHelper.DestroyUi(eztFfWeeIhyNfEiSrzLS, ayYSMEgmsLvDAgljdcPIml); CuiHelper.AddUi(eztFfWeeIhyNfEiSrzLS, CTanCGEFHH); } private void jqHEvKPWUOFScgGR(BasePlayer eztFfWeeIhyNfEiSrzLS) { var CTanCGEFHH = new CuiElementContainer(); apCsaAWiXv(ref CTanCGEFHH, HIRsvYQPzWyuvfESFxHaUFIZurtTC.huotRVpEiisGCL, "0.35 0.2", "0.65 0.8"); SuXbKyvVKZKv(ref CTanCGEFHH, HIRsvYQPzWyuvfESFxHaUFIZurtTC.pHgijKkhafaWaQAWyCNIwZXHzcG, "0 0.92", "1 1"); jzZksiWahxYYl(ref CTanCGEFHH, HIRsvYQPzWyuvfESFxHaUFIZurtTC.chnJkKVjBAkIgjSFJaGUm, "X", 20, "0.90 0.92", "1 1", "bp_12345.close", "permanentmarker.ttf"); yiDkSeDzLRhkbHKquZShOcqGAyeXZL(ref CTanCGEFHH, zlBwsfqIZhISnFHdBH("TITLE.MAIN.MSG", eztFfWeeIhyNfEiSrzLS.userID), 18, "0.03 0.92", "0.89 1", TextAnchor.MiddleLeft); var uUTwDdYqIjboJpkal = -0.02f; var LxeECrfUitaZwThE = 0.05f; yiDkSeDzLRhkbHKquZShOcqGAyeXZL(ref CTanCGEFHH, zlBwsfqIZhISnFHdBH("MAIN.PROTECT_PERCENT.MSG", eztFfWeeIhyNfEiSrzLS.userID), 18, $"{0.02+LxeECrfUitaZwThE} {0.825+uUTwDdYqIjboJpkal}", $"{0.4+LxeECrfUitaZwThE} {0.905+uUTwDdYqIjboJpkal}", TextAnchor.MiddleLeft); SuXbKyvVKZKv(ref CTanCGEFHH, HIRsvYQPzWyuvfESFxHaUFIZurtTC.pHgijKkhafaWaQAWyCNIwZXHzcG, $"{0.02+LxeECrfUitaZwThE} {0.75+uUTwDdYqIjboJpkal}", $"{0.4+LxeECrfUitaZwThE} {0.83+uUTwDdYqIjboJpkal}", ayYSMEgmsLvDAgljdcPIml, ayYSMEgmsLvDAgljdcPIml + "_percent_panel"); jzZksiWahxYYl(ref CTanCGEFHH, HIRsvYQPzWyuvfESFxHaUFIZurtTC.YyPzjwnofbDqeDtrAFPpCAqcXGDkM, "<", 25, "0.03 0.1", "0.25 0.87", $"bp_12345.percent_shift {-1*HIRsvYQPzWyuvfESFxHaUFIZurtTC.uRkyQkziKUEaKyLdGPminbfEN}", "robotocondensed-regular.ttf", TextAnchor.MiddleCenter, ayYSMEgmsLvDAgljdcPIml + "_percent_panel"); jzZksiWahxYYl(ref CTanCGEFHH, HIRsvYQPzWyuvfESFxHaUFIZurtTC.YyPzjwnofbDqeDtrAFPpCAqcXGDkM, ">", 25, "0.745 0.1", "0.965 0.87", $"bp_12345.percent_shift {HIRsvYQPzWyuvfESFxHaUFIZurtTC.uRkyQkziKUEaKyLdGPminbfEN}", "robotocondensed-regular.ttf", TextAnchor.MiddleCenter, ayYSMEgmsLvDAgljdcPIml + "_percent_panel"); yiDkSeDzLRhkbHKquZShOcqGAyeXZL(ref CTanCGEFHH, ZpRpfYtdstxkqnrDctmFjHG[eztFfWeeIhyNfEiSrzLS.userID].xTmepcJMRSBCYpotIWvVjxncHGpirm.ToString()+"%", 18, "0.3 0.1", "0.7 0.87", TextAnchor.MiddleCenter, ayYSMEgmsLvDAgljdcPIml + "_percent_panel", ayYSMEgmsLvDAgljdcPIml + "_percent_panel" + "_value"); var kFGRTkrauDwUxhCHvUpcCGoESNb = 0.525f; yiDkSeDzLRhkbHKquZShOcqGAyeXZL(ref CTanCGEFHH, zlBwsfqIZhISnFHdBH("MAIN.PROTECT_HOURS.MSG", eztFfWeeIhyNfEiSrzLS.userID), 18, $"{0.02+kFGRTkrauDwUxhCHvUpcCGoESNb} {0.825+uUTwDdYqIjboJpkal}", $"{0.4+kFGRTkrauDwUxhCHvUpcCGoESNb} {0.905+uUTwDdYqIjboJpkal}", TextAnchor.MiddleLeft); SuXbKyvVKZKv(ref CTanCGEFHH, HIRsvYQPzWyuvfESFxHaUFIZurtTC.pHgijKkhafaWaQAWyCNIwZXHzcG, $"{0.02+kFGRTkrauDwUxhCHvUpcCGoESNb} {0.75+uUTwDdYqIjboJpkal}", $"{0.4+kFGRTkrauDwUxhCHvUpcCGoESNb} {0.83+uUTwDdYqIjboJpkal}", ayYSMEgmsLvDAgljdcPIml, ayYSMEgmsLvDAgljdcPIml + "_hour_panel"); jzZksiWahxYYl(ref CTanCGEFHH, HIRsvYQPzWyuvfESFxHaUFIZurtTC.YyPzjwnofbDqeDtrAFPpCAqcXGDkM, "<", 25, "0.03 0.1", "0.25 0.87", "bp_12345.hour_shift -1", "robotocondensed-regular.ttf", TextAnchor.MiddleCenter, ayYSMEgmsLvDAgljdcPIml + "_hour_panel"); jzZksiWahxYYl(ref CTanCGEFHH, HIRsvYQPzWyuvfESFxHaUFIZurtTC.YyPzjwnofbDqeDtrAFPpCAqcXGDkM, ">", 25, "0.745 0.1", "0.965 0.87", "bp_12345.hour_shift 1", "robotocondensed-regular.ttf", TextAnchor.MiddleCenter, ayYSMEgmsLvDAgljdcPIml + "_hour_panel"); yiDkSeDzLRhkbHKquZShOcqGAyeXZL(ref CTanCGEFHH, ZpRpfYtdstxkqnrDctmFjHG[eztFfWeeIhyNfEiSrzLS.userID].CKfukblzRm.ToString()+zlBwsfqIZhISnFHdBH("HOUR", eztFfWeeIhyNfEiSrzLS.userID)[0], 18, "0.3 0.1", "0.7 0.87", TextAnchor.MiddleCenter, ayYSMEgmsLvDAgljdcPIml + "_hour_panel", ayYSMEgmsLvDAgljdcPIml + "_hour_panel" + "_value"); float pUlgdwhwvZlxkTa = 0.63f, delta_step = 0.1f; int FKaCEFkbaXo = 0; yiDkSeDzLRhkbHKquZShOcqGAyeXZL(ref CTanCGEFHH, zlBwsfqIZhISnFHdBH("MAIN.RES_FOR_PAY.MSG", eztFfWeeIhyNfEiSrzLS.userID), 18, $"{0.02+LxeECrfUitaZwThE} {0.63+uUTwDdYqIjboJpkal}", $"{0.4+kFGRTkrauDwUxhCHvUpcCGoESNb} {0.71+uUTwDdYqIjboJpkal}", TextAnchor.MiddleCenter); foreach(var OhZbSGgexQmVYo in ZpRpfYtdstxkqnrDctmFjHG[eztFfWeeIhyNfEiSrzLS.userID].InzmNYamAcRouAhooBXjK) { int wOqUTemtIiG = ZpRpfYtdstxkqnrDctmFjHG[eztFfWeeIhyNfEiSrzLS.userID].LOiPIabNmehxGwNGwcfrSFOAkxg.ContainsKey(OhZbSGgexQmVYo.Key) ? ZpRpfYtdstxkqnrDctmFjHG[eztFfWeeIhyNfEiSrzLS.userID].LOiPIabNmehxGwNGwcfrSFOAkxg[OhZbSGgexQmVYo.Key] : 0; int EXHfmprVnUG = (int)Math.Round(OhZbSGgexQmVYo.Value * ZpRpfYtdstxkqnrDctmFjHG[eztFfWeeIhyNfEiSrzLS.userID].xTmepcJMRSBCYpotIWvVjxncHGpirm * ZpRpfYtdstxkqnrDctmFjHG[eztFfWeeIhyNfEiSrzLS.userID].CKfukblzRm * neygPZBqOxPeyyCfNHjNlYY(ZpRpfYtdstxkqnrDctmFjHG[eztFfWeeIhyNfEiSrzLS.userID].xTmepcJMRSBCYpotIWvVjxncHGpirm) * CDSVHYsJCghKZTqkdWzNszkvBv(ZpRpfYtdstxkqnrDctmFjHG[eztFfWeeIhyNfEiSrzLS.userID].CKfukblzRm)); var twbQkCJGfoUHqHCPQ = wOqUTemtIiG < EXHfmprVnUG; var PwyLdoPCRUPwvkPwsVEe = $"{USsAdFTaOOwkGrEVPu(OhZbSGgexQmVYo.Key)}"; var RiWkSmSjJOsAf = $"{ayqPLbEUYCxOGOq(EXHfmprVnUG)} / {ayqPLbEUYCxOGOq(wOqUTemtIiG, twbQkCJGfoUHqHCPQ)}"; SuXbKyvVKZKv(ref CTanCGEFHH, HIRsvYQPzWyuvfESFxHaUFIZurtTC.pHgijKkhafaWaQAWyCNIwZXHzcG, $"{0.02+LxeECrfUitaZwThE} {pUlgdwhwvZlxkTa-0.08-FKaCEFkbaXo*delta_step+uUTwDdYqIjboJpkal}", $"{0.4+kFGRTkrauDwUxhCHvUpcCGoESNb} {pUlgdwhwvZlxkTa-FKaCEFkbaXo*delta_step+uUTwDdYqIjboJpkal}", ayYSMEgmsLvDAgljdcPIml, ayYSMEgmsLvDAgljdcPIml + $"_res_panel_{FKaCEFkbaXo}"); yiDkSeDzLRhkbHKquZShOcqGAyeXZL(ref CTanCGEFHH, PwyLdoPCRUPwvkPwsVEe, 18, "0.03 0.1", "0.96 0.9", TextAnchor.MiddleLeft, ayYSMEgmsLvDAgljdcPIml + $"_res_panel_{FKaCEFkbaXo}"); yiDkSeDzLRhkbHKquZShOcqGAyeXZL(ref CTanCGEFHH, RiWkSmSjJOsAf, 18, "0.03 0.1", "0.96 0.9", TextAnchor.MiddleRight, ayYSMEgmsLvDAgljdcPIml + $"_res_panel_{FKaCEFkbaXo}", ayYSMEgmsLvDAgljdcPIml + "_res_panel" + $"_value_right_{FKaCEFkbaXo}"); FKaCEFkbaXo++; } jzZksiWahxYYl(ref CTanCGEFHH, HIRsvYQPzWyuvfESFxHaUFIZurtTC.YyPzjwnofbDqeDtrAFPpCAqcXGDkM, zlBwsfqIZhISnFHdBH("BUTTON.PROTECT_SET", eztFfWeeIhyNfEiSrzLS.userID), 18, $"{0.02+LxeECrfUitaZwThE} {0.15-0.08}", $"{0.4+kFGRTkrauDwUxhCHvUpcCGoESNb} {0.15}", "bp_12345.apply"); CuiHelper.DestroyUi(eztFfWeeIhyNfEiSrzLS, ayYSMEgmsLvDAgljdcPIml); CuiHelper.AddUi(eztFfWeeIhyNfEiSrzLS, CTanCGEFHH); } private static void KuKMfYLEaKPPPFmiqfbkBAUrbf(BasePlayer eztFfWeeIhyNfEiSrzLS, ref CuiElementContainer CTanCGEFHH) { int FKaCEFkbaXo = 0; foreach(var OhZbSGgexQmVYo in ZpRpfYtdstxkqnrDctmFjHG[eztFfWeeIhyNfEiSrzLS.userID].InzmNYamAcRouAhooBXjK) { CuiHelper.DestroyUi(eztFfWeeIhyNfEiSrzLS, ayYSMEgmsLvDAgljdcPIml + "_res_panel" + $"_value_right_{FKaCEFkbaXo}"); int wOqUTemtIiG = ZpRpfYtdstxkqnrDctmFjHG[eztFfWeeIhyNfEiSrzLS.userID].LOiPIabNmehxGwNGwcfrSFOAkxg.ContainsKey(OhZbSGgexQmVYo.Key) ? ZpRpfYtdstxkqnrDctmFjHG[eztFfWeeIhyNfEiSrzLS.userID].LOiPIabNmehxGwNGwcfrSFOAkxg[OhZbSGgexQmVYo.Key] : 0; int EXHfmprVnUG = (int)Math.Round(OhZbSGgexQmVYo.Value * ZpRpfYtdstxkqnrDctmFjHG[eztFfWeeIhyNfEiSrzLS.userID].xTmepcJMRSBCYpotIWvVjxncHGpirm * ZpRpfYtdstxkqnrDctmFjHG[eztFfWeeIhyNfEiSrzLS.userID].CKfukblzRm * neygPZBqOxPeyyCfNHjNlYY(ZpRpfYtdstxkqnrDctmFjHG[eztFfWeeIhyNfEiSrzLS.userID].xTmepcJMRSBCYpotIWvVjxncHGpirm) * CDSVHYsJCghKZTqkdWzNszkvBv(ZpRpfYtdstxkqnrDctmFjHG[eztFfWeeIhyNfEiSrzLS.userID].CKfukblzRm)); var twbQkCJGfoUHqHCPQ = wOqUTemtIiG < EXHfmprVnUG; var RiWkSmSjJOsAf = $"{ayqPLbEUYCxOGOq(EXHfmprVnUG)} / {ayqPLbEUYCxOGOq(wOqUTemtIiG, twbQkCJGfoUHqHCPQ)}"; yiDkSeDzLRhkbHKquZShOcqGAyeXZL(ref CTanCGEFHH, RiWkSmSjJOsAf, 18, "0.03 0.1", "0.96 0.9", TextAnchor.MiddleRight, ayYSMEgmsLvDAgljdcPIml + $"_res_panel_{FKaCEFkbaXo}", ayYSMEgmsLvDAgljdcPIml + "_res_panel" + $"_value_right_{FKaCEFkbaXo}"); FKaCEFkbaXo++; } } private static void apCsaAWiXv(ref CuiElementContainer CTanCGEFHH, string RKEbMvykjk, string BrOBDQWVVpocLVedYIaYqgtSwEQGJ, string yACafJEmfctMoJBsdaqETMMAeAgKi) { CTanCGEFHH.Add(new CuiPanel { Image = { Color = RKEbMvykjk }, RectTransform = { AnchorMin = BrOBDQWVVpocLVedYIaYqgtSwEQGJ, AnchorMax = yACafJEmfctMoJBsdaqETMMAeAgKi }, CursorEnabled = true }, "Hud", ayYSMEgmsLvDAgljdcPIml); } private static void SuXbKyvVKZKv(ref CuiElementContainer CTanCGEFHH, string RKEbMvykjk, string BrOBDQWVVpocLVedYIaYqgtSwEQGJ, string yACafJEmfctMoJBsdaqETMMAeAgKi, string gaUGSeRmdtVANhGzTxSRFIZJtHP = ayYSMEgmsLvDAgljdcPIml, string kelJPfHxMZvDS = null) { CTanCGEFHH.Add(new CuiPanel { Image = { Color = RKEbMvykjk }, RectTransform = { AnchorMin = BrOBDQWVVpocLVedYIaYqgtSwEQGJ, AnchorMax = yACafJEmfctMoJBsdaqETMMAeAgKi } }, gaUGSeRmdtVANhGzTxSRFIZJtHP, kelJPfHxMZvDS); } private static void yiDkSeDzLRhkbHKquZShOcqGAyeXZL(ref CuiElementContainer CTanCGEFHH, string QqbMTvNEKFVg, int DVjZOEcMKV, string BrOBDQWVVpocLVedYIaYqgtSwEQGJ, string yACafJEmfctMoJBsdaqETMMAeAgKi, TextAnchor wuPPWtuwCJp = TextAnchor.MiddleCenter, string gaUGSeRmdtVANhGzTxSRFIZJtHP = ayYSMEgmsLvDAgljdcPIml, string kelJPfHxMZvDS = null) { CTanCGEFHH.Add(new CuiLabel { Text = { FontSize = DVjZOEcMKV, Align = wuPPWtuwCJp, Text = QqbMTvNEKFVg, Font = "robotocondensed-regular.ttf" }, RectTransform = { AnchorMin = BrOBDQWVVpocLVedYIaYqgtSwEQGJ, AnchorMax = yACafJEmfctMoJBsdaqETMMAeAgKi } }, gaUGSeRmdtVANhGzTxSRFIZJtHP, kelJPfHxMZvDS); } private static void OoYQdZvWCGnJexBWqAOSQWz(ref CuiElementContainer CTanCGEFHH, string QqbMTvNEKFVg, int DVjZOEcMKV, string BrOBDQWVVpocLVedYIaYqgtSwEQGJ, string yACafJEmfctMoJBsdaqETMMAeAgKi, TextAnchor wuPPWtuwCJp = TextAnchor.MiddleCenter, string gaUGSeRmdtVANhGzTxSRFIZJtHP = ayYSMEgmsLvDAgljdcPIml, string kelJPfHxMZvDS = null) { CTanCGEFHH.Add(new CuiElement() { Name = kelJPfHxMZvDS, Parent = gaUGSeRmdtVANhGzTxSRFIZJtHP, Components = { new CuiTextComponent() { Text = QqbMTvNEKFVg, Font = "robotocondensed-regular.ttf", Align = wuPPWtuwCJp, FontSize = DVjZOEcMKV }, new CuiOutlineComponent() { Color = "0 0 0 1" }, new CuiRectTransformComponent() { AnchorMin = BrOBDQWVVpocLVedYIaYqgtSwEQGJ, AnchorMax = yACafJEmfctMoJBsdaqETMMAeAgKi } } }); } private static void jzZksiWahxYYl(ref CuiElementContainer CTanCGEFHH, string RKEbMvykjk, string QqbMTvNEKFVg, int DVjZOEcMKV, string BrOBDQWVVpocLVedYIaYqgtSwEQGJ, string yACafJEmfctMoJBsdaqETMMAeAgKi, string hXITxPqoZrEvoXys, string font = "robotocondensed-regular.ttf", TextAnchor wuPPWtuwCJp = TextAnchor.MiddleCenter, string gaUGSeRmdtVANhGzTxSRFIZJtHP = ayYSMEgmsLvDAgljdcPIml, string kelJPfHxMZvDS = null) { if (string.IsNullOrEmpty(RKEbMvykjk)) RKEbMvykjk = "0 0 0 0"; CTanCGEFHH.Add(new CuiButton { Button = { Color = RKEbMvykjk, Command = hXITxPqoZrEvoXys, FadeIn = 0f }, RectTransform = { AnchorMin = BrOBDQWVVpocLVedYIaYqgtSwEQGJ, AnchorMax = yACafJEmfctMoJBsdaqETMMAeAgKi }, Text = { Text = QqbMTvNEKFVg, FontSize = DVjZOEcMKV, Align = wuPPWtuwCJp, Font = font } }, gaUGSeRmdtVANhGzTxSRFIZJtHP, kelJPfHxMZvDS); } private static void qYftOzWmucUJ(ref CuiElementContainer CTanCGEFHH, string png, string BrOBDQWVVpocLVedYIaYqgtSwEQGJ, string yACafJEmfctMoJBsdaqETMMAeAgKi, string gaUGSeRmdtVANhGzTxSRFIZJtHP = ayYSMEgmsLvDAgljdcPIml) { CTanCGEFHH.Add(new CuiElement { Name = CuiHelper.GetGuid(), Parent = gaUGSeRmdtVANhGzTxSRFIZJtHP, Components = { new CuiRawImageComponent {Png = png }, new CuiRectTransformComponent { AnchorMin = BrOBDQWVVpocLVedYIaYqgtSwEQGJ, AnchorMax = yACafJEmfctMoJBsdaqETMMAeAgKi } } }); } private void bkCLUKXnmbelgdhAIeIMoc(BasePlayer eztFfWeeIhyNfEiSrzLS) { if (eztFfWeeIhyNfEiSrzLS == null) return; CuiHelper.DestroyUi(eztFfWeeIhyNfEiSrzLS, "IconPanel"); var CTanCGEFHH = new CuiElementContainer(); SuXbKyvVKZKv(ref CTanCGEFHH, "1 1 1 0", HIRsvYQPzWyuvfESFxHaUFIZurtTC.AnchorMin, HIRsvYQPzWyuvfESFxHaUFIZurtTC.AnchorMax, "Hud", "IconPanel"); if (!string.IsNullOrEmpty(PfwNpbGXroE)) qYftOzWmucUJ(ref CTanCGEFHH, PfwNpbGXroE, "0 0", "1 1", "IconPanel"); CuiHelper.AddUi(eztFfWeeIhyNfEiSrzLS, CTanCGEFHH); } private void nDSdiAzYcDUrZTOEZsa(BasePlayer eztFfWeeIhyNfEiSrzLS, long LtBSCPxDGghGy, float percent, int ZIZaiMatAyPWPrLlyRFzqVJ) { if (eztFfWeeIhyNfEiSrzLS == null) return; var CfYJiWHBvlwWIRlpuDZQl = HWaWrTxPyBtfJCWfzUhu(LtBSCPxDGghGy, true, eztFfWeeIhyNfEiSrzLS.userID); var home = ZIZaiMatAyPWPrLlyRFzqVJ > 0 ? string.Format(zlBwsfqIZhISnFHdBH("ICON.HOME_NUMBER.MSG", eztFfWeeIhyNfEiSrzLS.userID), ZIZaiMatAyPWPrLlyRFzqVJ) : ""; var IbjotEluWAowFyxKRJ = "184"; var QqbMTvNEKFVg = string.Format(zlBwsfqIZhISnFHdBH("ICON.HOME_PROTECT.MSG", eztFfWeeIhyNfEiSrzLS.userID), home, percent, CfYJiWHBvlwWIRlpuDZQl); CuiHelper.DestroyUi(eztFfWeeIhyNfEiSrzLS, "IconPanel" + "_icon_text"); var CTanCGEFHH = new CuiElementContainer(); OoYQdZvWCGnJexBWqAOSQWz(ref CTanCGEFHH, QqbMTvNEKFVg, 12, "0 0", "1 1", TextAnchor.MiddleCenter, "IconPanel", "IconPanel" + "_icon_text"); CuiHelper.AddUi(eztFfWeeIhyNfEiSrzLS, CTanCGEFHH); } private static Dictionary<ulong, Timer> jriazZYsHvlgHweLXNiFwgzYRjOP = new Dictionary<ulong, Timer>(); private void JHjmeAlSceXEOAqRiuNhMpnsg(BasePlayer eztFfWeeIhyNfEiSrzLS, string ezSHcKJNszZPiCrf) { if (eztFfWeeIhyNfEiSrzLS == null || string.IsNullOrEmpty(ezSHcKJNszZPiCrf)) return; ZDVNslHPlv(eztFfWeeIhyNfEiSrzLS); var CTanCGEFHH = new CuiElementContainer(); SuXbKyvVKZKv(ref CTanCGEFHH, HIRsvYQPzWyuvfESFxHaUFIZurtTC.TGaJzdOECkNQlmE, "0.1 0.56", "0.9 0.7", ayYSMEgmsLvDAgljdcPIml, ayYSMEgmsLvDAgljdcPIml + "_sm_container"); yiDkSeDzLRhkbHKquZShOcqGAyeXZL(ref CTanCGEFHH, ezSHcKJNszZPiCrf, 18, "0 0", "1 1", TextAnchor.MiddleCenter, ayYSMEgmsLvDAgljdcPIml + "_sm_container"); CuiHelper.AddUi(eztFfWeeIhyNfEiSrzLS, CTanCGEFHH); if (!jriazZYsHvlgHweLXNiFwgzYRjOP.ContainsKey(eztFfWeeIhyNfEiSrzLS.userID)) jriazZYsHvlgHweLXNiFwgzYRjOP.Add(eztFfWeeIhyNfEiSrzLS.userID, null); jriazZYsHvlgHweLXNiFwgzYRjOP[eztFfWeeIhyNfEiSrzLS.userID] = timer.Once(2f, ()=> CuiHelper.DestroyUi(eztFfWeeIhyNfEiSrzLS, ayYSMEgmsLvDAgljdcPIml + "_sm_container")); } private static void ZDVNslHPlv(BasePlayer eztFfWeeIhyNfEiSrzLS) { if (eztFfWeeIhyNfEiSrzLS == null) return; if (jriazZYsHvlgHweLXNiFwgzYRjOP.ContainsKey(eztFfWeeIhyNfEiSrzLS.userID) && jriazZYsHvlgHweLXNiFwgzYRjOP[eztFfWeeIhyNfEiSrzLS.userID] != null) { jriazZYsHvlgHweLXNiFwgzYRjOP[eztFfWeeIhyNfEiSrzLS.userID].Destroy(); jriazZYsHvlgHweLXNiFwgzYRjOP[eztFfWeeIhyNfEiSrzLS.userID] = null; } CuiHelper.DestroyUi(eztFfWeeIhyNfEiSrzLS, ayYSMEgmsLvDAgljdcPIml + "_sm_container"); } private void YdyGyUGPjDyQuoEwgBawGtqbaB() => ServerMgr.Instance.StartCoroutine(YdyGyUGPjDyQuoEwgBawGtqbaB(HIRsvYQPzWyuvfESFxHaUFIZurtTC.WJJmQmItrSjbZCphagKfVlPQnMVi)); private IEnumerator YdyGyUGPjDyQuoEwgBawGtqbaB(string itpoWCRnTJMpocYTkAuDkDNQpyVsor) { using (var sdqbdyEqYSUmGBSMu = new WWW(itpoWCRnTJMpocYTkAuDkDNQpyVsor)) { yield return sdqbdyEqYSUmGBSMu; if (sdqbdyEqYSUmGBSMu.error != null) PrintError(zlBwsfqIZhISnFHdBH("IMAGE.LOAD.ERROR") + $"\n{itpoWCRnTJMpocYTkAuDkDNQpyVsor}"); else { var WOSBkVEkJUmJA = sdqbdyEqYSUmGBSMu.texture; byte[] opXnYbaUuzV = WOSBkVEkJUmJA.EncodeToPNG(); PfwNpbGXroE = FileStorage.server.Store(opXnYbaUuzV, FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID).ToString(); UnityEngine.Object.DestroyImmediate(WOSBkVEkJUmJA); yield break; } } } [ConsoleCommand("bp_12345.close")] private void UJBQjrkhDdeSMs(ConsoleSystem.Arg caFpWMeDPIgyNMLe) { BasePlayer eztFfWeeIhyNfEiSrzLS = caFpWMeDPIgyNMLe.Player(); if (eztFfWeeIhyNfEiSrzLS == null) return; CuiHelper.DestroyUi(eztFfWeeIhyNfEiSrzLS, ayYSMEgmsLvDAgljdcPIml); } [ConsoleCommand("bp_12345.ok")] private void xfSgROuDbrNTDAm(ConsoleSystem.Arg caFpWMeDPIgyNMLe) { BasePlayer eztFfWeeIhyNfEiSrzLS = caFpWMeDPIgyNMLe.Player(); if (eztFfWeeIhyNfEiSrzLS == null) return; CuiHelper.DestroyUi(eztFfWeeIhyNfEiSrzLS, ayYSMEgmsLvDAgljdcPIml); jqHEvKPWUOFScgGR(eztFfWeeIhyNfEiSrzLS); } [ConsoleCommand("bp_12345.toggleicon")] private void YvwlYygWwUfmBhF(ConsoleSystem.Arg caFpWMeDPIgyNMLe) { BasePlayer eztFfWeeIhyNfEiSrzLS = caFpWMeDPIgyNMLe.Player(); if (eztFfWeeIhyNfEiSrzLS == null) return; var JmSlRHEiXsEwgvVxzC = Convert.ToUInt32(caFpWMeDPIgyNMLe.Args[0]); CuiHelper.DestroyUi(eztFfWeeIhyNfEiSrzLS, ayYSMEgmsLvDAgljdcPIml + "_toggle_icon"); if (!htjoTujQiNY.HVMhRoaoCievfPDLpLtyzLrnHS.ContainsKey(eztFfWeeIhyNfEiSrzLS.userID)) htjoTujQiNY.HVMhRoaoCievfPDLpLtyzLrnHS.Add(eztFfWeeIhyNfEiSrzLS.userID, new List<uint>()); if (!htjoTujQiNY.HVMhRoaoCievfPDLpLtyzLrnHS[eztFfWeeIhyNfEiSrzLS.userID].Contains(JmSlRHEiXsEwgvVxzC)) { htjoTujQiNY.HVMhRoaoCievfPDLpLtyzLrnHS[eztFfWeeIhyNfEiSrzLS.userID].Add(JmSlRHEiXsEwgvVxzC); bkCLUKXnmbelgdhAIeIMoc(eztFfWeeIhyNfEiSrzLS); FvqvCLgzoHekniMb(eztFfWeeIhyNfEiSrzLS.userID); } else { htjoTujQiNY.HVMhRoaoCievfPDLpLtyzLrnHS[eztFfWeeIhyNfEiSrzLS.userID].Remove(JmSlRHEiXsEwgvVxzC); if (htjoTujQiNY.HVMhRoaoCievfPDLpLtyzLrnHS[eztFfWeeIhyNfEiSrzLS.userID].Count() == 0) CuiHelper.DestroyUi(eztFfWeeIhyNfEiSrzLS, "IconPanel"); } var CTanCGEFHH = new CuiElementContainer(); var LxeECrfUitaZwThE = 0.05f; jzZksiWahxYYl(ref CTanCGEFHH, "1 1 1 0", SSvJOPDahXrxGAQaDcOCVYDwelq(eztFfWeeIhyNfEiSrzLS, JmSlRHEiXsEwgvVxzC), 18, $"{LxeECrfUitaZwThE-0.02} {0.55-0.08}", $"{0.15} {0.53}", $"bp_12345.toggleicon {JmSlRHEiXsEwgvVxzC}", "robotocondensed-regular.ttf", TextAnchor.MiddleCenter, ayYSMEgmsLvDAgljdcPIml, ayYSMEgmsLvDAgljdcPIml + "_toggle_icon"); CuiHelper.AddUi(eztFfWeeIhyNfEiSrzLS, CTanCGEFHH); } [ConsoleCommand("bp_12345.apply")] private void fiVLqOSKIemVwZjynS(ConsoleSystem.Arg caFpWMeDPIgyNMLe) { BasePlayer eztFfWeeIhyNfEiSrzLS = caFpWMeDPIgyNMLe.Player(); if (eztFfWeeIhyNfEiSrzLS == null) return; var UElTEUsksLPPEdfWq = ZpRpfYtdstxkqnrDctmFjHG[eztFfWeeIhyNfEiSrzLS.userID].daGIJHDKUbwTcWLDqcyvEKyoUgP; if (UElTEUsksLPPEdfWq == null) { JHjmeAlSceXEOAqRiuNhMpnsg(eztFfWeeIhyNfEiSrzLS, zlBwsfqIZhISnFHdBH("INFO.CUPBOARD_NOT_FOUND", eztFfWeeIhyNfEiSrzLS.userID)); return; } if (!dYDXPtOHhfykMrMThXyGbs(eztFfWeeIhyNfEiSrzLS)) { var CTanCGEFHH = new CuiElementContainer(); KuKMfYLEaKPPPFmiqfbkBAUrbf(eztFfWeeIhyNfEiSrzLS, ref CTanCGEFHH); CuiHelper.AddUi(eztFfWeeIhyNfEiSrzLS, CTanCGEFHH); JHjmeAlSceXEOAqRiuNhMpnsg(eztFfWeeIhyNfEiSrzLS, zlBwsfqIZhISnFHdBH("INFO.NO_RESOURCE_PAY", eztFfWeeIhyNfEiSrzLS.userID)); return; } ThablvjYgzPPFtapXSKl(eztFfWeeIhyNfEiSrzLS); ZpRpfYtdstxkqnrDctmFjHG[eztFfWeeIhyNfEiSrzLS.userID].UYhfLDMgybnUfsfAr = hpGNPeGnzYRReiWGgloEPvAeufDr(DateTime.Now); DSZRmXskeNPbtuIULZ = true; var pDktUvdrNoKvwbLOHcCvkdviel = eztFfWeeIhyNfEiSrzLS.userID; var JmSlRHEiXsEwgvVxzC = UElTEUsksLPPEdfWq.net.ID; timer.Once(0.1f, ()=> { var endTime = ZpRpfYtdstxkqnrDctmFjHG[pDktUvdrNoKvwbLOHcCvkdviel].UYhfLDMgybnUfsfAr + ZpRpfYtdstxkqnrDctmFjHG[pDktUvdrNoKvwbLOHcCvkdviel].CKfukblzRm * 60 * 60; foreach(var blockID in ZpRpfYtdstxkqnrDctmFjHG[pDktUvdrNoKvwbLOHcCvkdviel].fUSUsDdJKJxLwFEoG) { var kEzXjiiXPmrzNAIOpqcMm = new THKYObKFdbXpSTzeXvejA(); kEzXjiiXPmrzNAIOpqcMm.cdspsASrrXBdzATOFNpbJmxD = ZpRpfYtdstxkqnrDctmFjHG[pDktUvdrNoKvwbLOHcCvkdviel].xTmepcJMRSBCYpotIWvVjxncHGpirm; kEzXjiiXPmrzNAIOpqcMm.dTyvbttwmBMF = endTime; if (htjoTujQiNY.iCsBlkTpLGdFOvVb.ContainsKey(blockID)) htjoTujQiNY.iCsBlkTpLGdFOvVb[blockID] = kEzXjiiXPmrzNAIOpqcMm; else htjoTujQiNY.iCsBlkTpLGdFOvVb.Add(blockID, kEzXjiiXPmrzNAIOpqcMm); } if (!htjoTujQiNY.HVMhRoaoCievfPDLpLtyzLrnHS.ContainsKey(pDktUvdrNoKvwbLOHcCvkdviel)) htjoTujQiNY.HVMhRoaoCievfPDLpLtyzLrnHS.Add(pDktUvdrNoKvwbLOHcCvkdviel, new List<uint>()); if (!htjoTujQiNY.HVMhRoaoCievfPDLpLtyzLrnHS[pDktUvdrNoKvwbLOHcCvkdviel].Contains(JmSlRHEiXsEwgvVxzC)) htjoTujQiNY.HVMhRoaoCievfPDLpLtyzLrnHS[pDktUvdrNoKvwbLOHcCvkdviel].Add(JmSlRHEiXsEwgvVxzC); mQzhRoJNMQhRYNGRRGouBHwpzchVGn(); bkCLUKXnmbelgdhAIeIMoc(eztFfWeeIhyNfEiSrzLS); FvqvCLgzoHekniMb(pDktUvdrNoKvwbLOHcCvkdviel); if (HIRsvYQPzWyuvfESFxHaUFIZurtTC.AutoEnableIcon) { foreach (var authed in UElTEUsksLPPEdfWq.authorizedPlayers) { if (pDktUvdrNoKvwbLOHcCvkdviel == authed.userid) continue; var user = BasePlayer.FindByID(authed.userid); if (!htjoTujQiNY.HVMhRoaoCievfPDLpLtyzLrnHS.ContainsKey(authed.userid)) htjoTujQiNY.HVMhRoaoCievfPDLpLtyzLrnHS.Add(authed.userid, new List<uint>()); if (!htjoTujQiNY.HVMhRoaoCievfPDLpLtyzLrnHS[authed.userid].Contains(JmSlRHEiXsEwgvVxzC)) { htjoTujQiNY.HVMhRoaoCievfPDLpLtyzLrnHS[authed.userid].Add(JmSlRHEiXsEwgvVxzC); if (user != null) { bkCLUKXnmbelgdhAIeIMoc(user); FvqvCLgzoHekniMb(authed.userid); } } } } DSZRmXskeNPbtuIULZ = false; PjoEKarzAEFhBoEh(eztFfWeeIhyNfEiSrzLS, UElTEUsksLPPEdfWq); }); } [ConsoleCommand("bp_12345.percent_shift")] private void YkgvHGZGgN(ConsoleSystem.Arg caFpWMeDPIgyNMLe) { BasePlayer eztFfWeeIhyNfEiSrzLS = caFpWMeDPIgyNMLe.Player(); if (eztFfWeeIhyNfEiSrzLS == null) return; var mBnsIqPKgEnaOcqESyHZfV = Convert.ToInt32(caFpWMeDPIgyNMLe.Args[0]); if (mBnsIqPKgEnaOcqESyHZfV == 0) return; if ((mBnsIqPKgEnaOcqESyHZfV < 0 && ZpRpfYtdstxkqnrDctmFjHG[eztFfWeeIhyNfEiSrzLS.userID].xTmepcJMRSBCYpotIWvVjxncHGpirm <= HIRsvYQPzWyuvfESFxHaUFIZurtTC.WUkZrDfquy) || (mBnsIqPKgEnaOcqESyHZfV > 0 && ZpRpfYtdstxkqnrDctmFjHG[eztFfWeeIhyNfEiSrzLS.userID].xTmepcJMRSBCYpotIWvVjxncHGpirm >= HIRsvYQPzWyuvfESFxHaUFIZurtTC.JdTmRPDwkC)) return; ZpRpfYtdstxkqnrDctmFjHG[eztFfWeeIhyNfEiSrzLS.userID].xTmepcJMRSBCYpotIWvVjxncHGpirm += mBnsIqPKgEnaOcqESyHZfV; if (ZpRpfYtdstxkqnrDctmFjHG[eztFfWeeIhyNfEiSrzLS.userID].xTmepcJMRSBCYpotIWvVjxncHGpirm >= HIRsvYQPzWyuvfESFxHaUFIZurtTC.JdTmRPDwkC) ZpRpfYtdstxkqnrDctmFjHG[eztFfWeeIhyNfEiSrzLS.userID].xTmepcJMRSBCYpotIWvVjxncHGpirm = HIRsvYQPzWyuvfESFxHaUFIZurtTC.JdTmRPDwkC; else if (ZpRpfYtdstxkqnrDctmFjHG[eztFfWeeIhyNfEiSrzLS.userID].xTmepcJMRSBCYpotIWvVjxncHGpirm <= HIRsvYQPzWyuvfESFxHaUFIZurtTC.WUkZrDfquy) ZpRpfYtdstxkqnrDctmFjHG[eztFfWeeIhyNfEiSrzLS.userID].xTmepcJMRSBCYpotIWvVjxncHGpirm = HIRsvYQPzWyuvfESFxHaUFIZurtTC.WUkZrDfquy; CuiHelper.DestroyUi(eztFfWeeIhyNfEiSrzLS, ayYSMEgmsLvDAgljdcPIml + "_percent_panel" + "_value"); var CTanCGEFHH = new CuiElementContainer(); yiDkSeDzLRhkbHKquZShOcqGAyeXZL(ref CTanCGEFHH, ZpRpfYtdstxkqnrDctmFjHG[eztFfWeeIhyNfEiSrzLS.userID].xTmepcJMRSBCYpotIWvVjxncHGpirm.ToString()+"%", 18, "0.3 0.1", "0.7 0.87", TextAnchor.MiddleCenter, ayYSMEgmsLvDAgljdcPIml + "_percent_panel", ayYSMEgmsLvDAgljdcPIml + "_percent_panel" + "_value"); KuKMfYLEaKPPPFmiqfbkBAUrbf(eztFfWeeIhyNfEiSrzLS, ref CTanCGEFHH); CuiHelper.AddUi(eztFfWeeIhyNfEiSrzLS, CTanCGEFHH); } [ConsoleCommand("bp_12345.hour_shift")] private void TZyrfWqhSnUDTeLclFkiEC(ConsoleSystem.Arg caFpWMeDPIgyNMLe) { BasePlayer eztFfWeeIhyNfEiSrzLS = caFpWMeDPIgyNMLe.Player(); if (eztFfWeeIhyNfEiSrzLS == null) return; var mBnsIqPKgEnaOcqESyHZfV = Convert.ToInt32(caFpWMeDPIgyNMLe.Args[0]); if (mBnsIqPKgEnaOcqESyHZfV == 0) return; if ((mBnsIqPKgEnaOcqESyHZfV < 0 && ZpRpfYtdstxkqnrDctmFjHG[eztFfWeeIhyNfEiSrzLS.userID].CKfukblzRm <= HIRsvYQPzWyuvfESFxHaUFIZurtTC.qQiYjYCTFYGvVlYwaVgSv) || (mBnsIqPKgEnaOcqESyHZfV > 0 && ZpRpfYtdstxkqnrDctmFjHG[eztFfWeeIhyNfEiSrzLS.userID].CKfukblzRm >= HIRsvYQPzWyuvfESFxHaUFIZurtTC.dQFQKANrXEiOISjoPReFilZ)) return; ZpRpfYtdstxkqnrDctmFjHG[eztFfWeeIhyNfEiSrzLS.userID].CKfukblzRm += mBnsIqPKgEnaOcqESyHZfV; if (ZpRpfYtdstxkqnrDctmFjHG[eztFfWeeIhyNfEiSrzLS.userID].CKfukblzRm >= HIRsvYQPzWyuvfESFxHaUFIZurtTC.dQFQKANrXEiOISjoPReFilZ) ZpRpfYtdstxkqnrDctmFjHG[eztFfWeeIhyNfEiSrzLS.userID].CKfukblzRm = HIRsvYQPzWyuvfESFxHaUFIZurtTC.dQFQKANrXEiOISjoPReFilZ; else if (ZpRpfYtdstxkqnrDctmFjHG[eztFfWeeIhyNfEiSrzLS.userID].CKfukblzRm <= HIRsvYQPzWyuvfESFxHaUFIZurtTC.qQiYjYCTFYGvVlYwaVgSv) ZpRpfYtdstxkqnrDctmFjHG[eztFfWeeIhyNfEiSrzLS.userID].CKfukblzRm = HIRsvYQPzWyuvfESFxHaUFIZurtTC.qQiYjYCTFYGvVlYwaVgSv; CuiHelper.DestroyUi(eztFfWeeIhyNfEiSrzLS, ayYSMEgmsLvDAgljdcPIml + "_hour_panel" + "_value"); var CTanCGEFHH = new CuiElementContainer(); yiDkSeDzLRhkbHKquZShOcqGAyeXZL(ref CTanCGEFHH, ZpRpfYtdstxkqnrDctmFjHG[eztFfWeeIhyNfEiSrzLS.userID].CKfukblzRm.ToString()+zlBwsfqIZhISnFHdBH("HOUR", eztFfWeeIhyNfEiSrzLS.userID)[0], 18, "0.3 0.1", "0.7 0.87", TextAnchor.MiddleCenter, ayYSMEgmsLvDAgljdcPIml + "_hour_panel", ayYSMEgmsLvDAgljdcPIml + "_hour_panel" + "_value"); KuKMfYLEaKPPPFmiqfbkBAUrbf(eztFfWeeIhyNfEiSrzLS, ref CTanCGEFHH); CuiHelper.AddUi(eztFfWeeIhyNfEiSrzLS, CTanCGEFHH); } private static long hpGNPeGnzYRReiWGgloEPvAeufDr(DateTime dsDlrjGGMgUUfoB) { var LfjajEEGaxPUfNS = dsDlrjGGMgUUfoB.ToLocalTime(); var HhIqGyQIQEPintRJPwwXkqqdW = LfjajEEGaxPUfNS.Ticks - new DateTime(1970, 1, 1, 0, 0, 0, 0).Ticks; var SFdaxvjfkDZ = HhIqGyQIQEPintRJPwwXkqqdW / TimeSpan.TicksPerSecond; return SFdaxvjfkDZ; } private static string LXquRVLGGmwxgmKcB(long CoQhYAEfDGx, List<string> glStxPuEyKPmxaXBmhEOEd) { switch(CoQhYAEfDGx) { case 11:case 12: case 13: case 14: return $"{CoQhYAEfDGx} {glStxPuEyKPmxaXBmhEOEd[2]}"; } var GeLksXKNte = CoQhYAEfDGx.ToString(); switch(GeLksXKNte[GeLksXKNte.Length-1]) { case '1': return $"{CoQhYAEfDGx} {glStxPuEyKPmxaXBmhEOEd[0]}"; case '2': case '3': case '4': return $"{CoQhYAEfDGx} {glStxPuEyKPmxaXBmhEOEd[1]}"; } return $"{CoQhYAEfDGx} {glStxPuEyKPmxaXBmhEOEd[2]}"; } private string zlBwsfqIZhISnFHdBH(string QHGbRfmUAlPNrWuvKpWfjB, ulong KEFZYWxMzGHkc = 0U) => lang.GetMessage(QHGbRfmUAlPNrWuvKpWfjB, this, KEFZYWxMzGHkc == 0U ? null : KEFZYWxMzGHkc.ToString()); private static Dictionary<string, string> HhSsvHSFdMIRcQjDGsqeEQRnBGpjRP = new Dictionary<string, string> { { "TITLE.MAIN.MSG", "Установка защиты дома" }, { "TITLE.REMIND.MSG", "Состояние защиты дома" }, { "TITLE.WARNING.MSG", "<color=orange>Внимание</color>" }, { "NOESCAPE.WARNING", "Вы не можете усиливать защиту дома во время рейда, подождите {0} сек." }, { "NOESCAPE.CALL.ERROR", "Ошибка вызова API метода плагина NoEscape!" }, { "MAIN.RES_FOR_PAY.MSG", "Ресурсы для оплаты защиты (нужно/есть)" }, { "MAIN.PROTECT_PERCENT.MSG", " Процент защиты" }, { "MAIN.PROTECT_HOURS.MSG", " Часы защиты" }, { "REMIND.HOME_PROTECT.MSG", "<color=orange>ВАШ ДОМ ЗАЩИЩЕН!</color>\n\n <color=orange>*</color> Защита дома усилена на <color=orange>{0}%</color>\n <color=orange>*</color> Защита окончится через <color=orange>{1}</color>" }, { "REMIND.CHECK_TOGGLE.MSG", "отображать иконку с информацией о состоянии защиты этого дома" }, { "WARNING.RECOMENDATION.MSG", "РЕКОМЕНДАЦИЯ!\n\nУстанавливайте защиту на уже полностью достроеный дом, т.к. если после установки защиты дом будет достроен новыми блоками или будут улучшены какие то старые блоки, то защита на эти блоки не будет распространяться.\nУстановить защиту на все блоки, включая достроенные новые, можно будет уже после окончания действия старой защиты." }, { "BUTTON.APPLY", "Понятно" }, { "BUTTON.PROTECT_SET", "Установить защиту" }, { "ICON.HOME_NUMBER.MSG", "Дом №{0}\n" }, { "ICON.HOME_PROTECT.MSG", "<color=white>{0}{1} %\n{2}</color>" }, { "IMAGE.LOAD.ERROR", "Ошибка загрузки изображения!" }, { "INFO.CUPBOARD_NOT_FOUND", "Не найден шкаф!" }, { "INFO.NO_RESOURCE_PAY", "Недостаточно ресурсов для оплаты!" }, { "INFO.NO_CUP_AUTH", "Вы не находитесь в билдинг зоне своего шкафа!" }, { "MINUTE1", "минуту" }, { "MINUTE2", "минута" }, { "MINUTES1", "минуты" }, { "MINUTES2", "минут" }, { "HOUR", "час" }, { "HOURS1", "часа" }, { "HOURS2", "часов" } }; private static ConfigData HIRsvYQPzWyuvfESFxHaUFIZurtTC; private class ConfigData { [JsonProperty(PropertyName = "Процент ресурсов от стоимости дома, который будет требоватся на защиту дома в 1% и длительностью 1 час")] public float QcDimTVYjcB; [JsonProperty(PropertyName = "Коррекционный коэффициент для стоимости защиты в зависимости от количества строительных блоков")] public Dictionary<int, float> PcLEgwhWxwYXWLBUHMxBSBbSYVv; [JsonProperty(PropertyName = "Коррекционный коэффициент для стоимости защиты с вип привилегиями")] public Dictionary<string, float> RmrosELnidzVJnFLKUlKeIxGLnRX; [JsonProperty(PropertyName = "Строительные объекты которые требуется защищать (помимо строительных блоков)")] public List<string> WAwJTluQpKj; [JsonProperty(PropertyName = "Минимальный разрешенный процент защиты")] public int WUkZrDfquy; [JsonProperty(PropertyName = "Максимальный разрешенный процент защиты")] public int JdTmRPDwkC; [JsonProperty(PropertyName = "Шаг изменения процентов")] public int uRkyQkziKUEaKyLdGPminbfEN; [JsonProperty(PropertyName = "Коэффициент увеличения стоимости защиты на каждый шаг процента")] public float hgTDiegoLXbuTVpHav; [JsonProperty(PropertyName = "Минимальное количество часов защиты")] public int qQiYjYCTFYGvVlYwaVgSv; [JsonProperty(PropertyName = "Максимальное количество часов защиты")] public int dQFQKANrXEiOISjoPReFilZ; [JsonProperty(PropertyName = "Коэффициент увеличения стоимости защиты на каждый дополнительный час")] public float aIVGeziGeitoyycbJRBtiMEXbHqOBW; [JsonProperty(PropertyName = "Замена стандартных ресурсов на свои ресурсы или предметы")] public Dictionary<string, TxkvFQxiOYonNxThqkY> ESiTmtHBTeohwpzBGeUW = new Dictionary<string, TxkvFQxiOYonNxThqkY>(); [JsonProperty(PropertyName = "Названия ресурсов в меню")] public Dictionary<string, string> gKOyVvBdMhstfyHffixIQDfEbhpLvj = new Dictionary<string, string>(); [JsonProperty(PropertyName = "Цвет панели 1")] public string huotRVpEiisGCL; [JsonProperty(PropertyName = "Цвет панели 2")] public string pHgijKkhafaWaQAWyCNIwZXHzcG; [JsonProperty(PropertyName = "Цвет кнопки закрытия панели")] public string chnJkKVjBAkIgjSFJaGUm; [JsonProperty(PropertyName = "Цвет панели информационного сообщения")] public string TGaJzdOECkNQlmE; [JsonProperty(PropertyName = "Цвет кнопок и акцентированного текста")] public string YyPzjwnofbDqeDtrAFPpCAqcXGDkM; [JsonProperty(PropertyName = "Цвет акцентированного текста для предметов")] public string rZGBuvEfDiwFzCUjsXDuPhBCyGEo; [JsonProperty(PropertyName = "Ссылка на картинку информирующей о защите дома")] public string WJJmQmItrSjbZCphagKfVlPQnMVi; [JsonProperty(PropertyName = "Позиция иконки (MinX MinY)")] public string AnchorMin; [JsonProperty(PropertyName = "Позиция иконки (MaxX MaxY)")] public string AnchorMax; [JsonProperty(PropertyName = "Включать отображение иконки сразу для всех авторизованных в шкафу")] public bool AutoEnableIcon; [JsonProperty(PropertyName = "Чат команда для активации меню шкафа в зоне действия шкафа (если пусто, - не используется)")] public string CommandChatBP; } private class TxkvFQxiOYonNxThqkY { [JsonProperty(PropertyName = "Название нового ресурса или предмета")] public string XPWVFkAIoCXaSFsTVAzqSSiGI; [JsonProperty(PropertyName = "Рейт нового ресурса по отношению к одной еденице старого (0 - не использовать вообще)")] public float YYRShJFRcBfcbPCquuXjgjjMQDHQT; } private void FbUwtQnmPCLjJgk() { HIRsvYQPzWyuvfESFxHaUFIZurtTC = Config.ReadObject<ConfigData>(); if (HIRsvYQPzWyuvfESFxHaUFIZurtTC.PcLEgwhWxwYXWLBUHMxBSBbSYVv == null) { HIRsvYQPzWyuvfESFxHaUFIZurtTC.PcLEgwhWxwYXWLBUHMxBSBbSYVv = new Dictionary<int, float>() { { 1, 1f }, { 15, 0.95f }, { 50, 0.85f }, { 125, 0.6f }, { 200, 0.4f } }; RaUuSZVKIAvrtfTR(HIRsvYQPzWyuvfESFxHaUFIZurtTC); } if (HIRsvYQPzWyuvfESFxHaUFIZurtTC.RmrosELnidzVJnFLKUlKeIxGLnRX == null) { HIRsvYQPzWyuvfESFxHaUFIZurtTC.RmrosELnidzVJnFLKUlKeIxGLnRX = new Dictionary<string, float>() { { "buildingprotection.vip", 0.75f }, { "buildingprotection.premium", 0.5f } }; RaUuSZVKIAvrtfTR(HIRsvYQPzWyuvfESFxHaUFIZurtTC); } } protected override void LoadDefaultConfig() { HIRsvYQPzWyuvfESFxHaUFIZurtTC = new ConfigData { QcDimTVYjcB = 1f, PcLEgwhWxwYXWLBUHMxBSBbSYVv = new Dictionary<int, float>() { { 1, 1f }, { 15, 0.95f }, { 50, 0.85f }, { 125, 0.6f }, { 200, 0.4f } }, RmrosELnidzVJnFLKUlKeIxGLnRX = new Dictionary<string, float>() { { "buildingprotection.vip", 0.75f }, { "buildingprotection.premium", 0.5f } }, WAwJTluQpKj = new List<string>() { "floor.grill", "door.hinged.toptier", "door.double.hinged.toptier", "gates.external.high.stone", "wall.external.high.stone", "gates.external.high.wood", "wall.external.high", "floor.ladder.hatch", "shutter.metal.embrasure.a", "shutter.metal.embrasure.b", "wall.window.bars.metal", "wall.frame.cell.gate", "wall.frame.cell", "wall.window.bars.toptier", "wall.window.glass.reinforced", "door.hinged.metal", "door.double.hinged.metal", "door.hinged.wood", "door.double.hinged.wood", "wall.frame.garagedoor", "wall.frame.shopfront.metal", "cupboard.tool.deployed" }, WUkZrDfquy = 10, JdTmRPDwkC = 80, uRkyQkziKUEaKyLdGPminbfEN = 10, hgTDiegoLXbuTVpHav = 1f, qQiYjYCTFYGvVlYwaVgSv = 1, dQFQKANrXEiOISjoPReFilZ = 24, aIVGeziGeitoyycbJRBtiMEXbHqOBW = 1f, ESiTmtHBTeohwpzBGeUW = new Dictionary<string, TxkvFQxiOYonNxThqkY>() { { "wood1", new TxkvFQxiOYonNxThqkY() { XPWVFkAIoCXaSFsTVAzqSSiGI = "scrap", YYRShJFRcBfcbPCquuXjgjjMQDHQT = 0.1f } }, { "stones1", new TxkvFQxiOYonNxThqkY() { XPWVFkAIoCXaSFsTVAzqSSiGI = "scrap", YYRShJFRcBfcbPCquuXjgjjMQDHQT = 0.05f } }, { "metal.fragments1", new TxkvFQxiOYonNxThqkY() { XPWVFkAIoCXaSFsTVAzqSSiGI = "scrap", YYRShJFRcBfcbPCquuXjgjjMQDHQT = 0.2f } }, { "metal.refined1", new TxkvFQxiOYonNxThqkY() { XPWVFkAIoCXaSFsTVAzqSSiGI = "scrap", YYRShJFRcBfcbPCquuXjgjjMQDHQT = 5f } } }, gKOyVvBdMhstfyHffixIQDfEbhpLvj = new Dictionary<string, string>() { { "wood", "Дерево" }, { "stones", "Камень" }, { "metal.fragments", "Металл-фрагменты" }, { "metal.refined", "МВК" }, { "scrap", "Скрап" } }, huotRVpEiisGCL = "0.3 0.3 0.3 0.9", pHgijKkhafaWaQAWyCNIwZXHzcG = "0.5 0.5 0.5 0.9", chnJkKVjBAkIgjSFJaGUm = "0.9 0.3 0.3 0.9", TGaJzdOECkNQlmE = "0.8 0.3 0.3 1", YyPzjwnofbDqeDtrAFPpCAqcXGDkM = "0.95 0.49 0.28 1", rZGBuvEfDiwFzCUjsXDuPhBCyGEo = "1 0.5 0.48 1", WJJmQmItrSjbZCphagKfVlPQnMVi = "https://i.imgur.com/VLYW2dR.png", AnchorMin = "0.288 0.025", AnchorMax = "0.331 0.095", AutoEnableIcon = true, CommandChatBP = "bp" }; RaUuSZVKIAvrtfTR(HIRsvYQPzWyuvfESFxHaUFIZurtTC); timer.Once(0.1f, ()=> RaUuSZVKIAvrtfTR(HIRsvYQPzWyuvfESFxHaUFIZurtTC)); } private void RaUuSZVKIAvrtfTR(ConfigData DeyFbVbpxSFvNvCWafbkdKUcsSbp) => Config.WriteObject(DeyFbVbpxSFvNvCWafbkdKUcsSbp, true); private static ceuARwUFPXh htjoTujQiNY; private class ceuARwUFPXh { [JsonProperty(PropertyName = "_blocks_")] public Dictionary<uint, THKYObKFdbXpSTzeXvejA> iCsBlkTpLGdFOvVb = new Dictionary<uint, THKYObKFdbXpSTzeXvejA>(); [JsonProperty(PropertyName = "_players_")] public Dictionary<ulong, List<uint>> HVMhRoaoCievfPDLpLtyzLrnHS = new Dictionary<ulong, List<uint>>(); } private class THKYObKFdbXpSTzeXvejA { [JsonProperty(PropertyName = "_perc_")] public float cdspsASrrXBdzATOFNpbJmxD; [JsonProperty(PropertyName = "_time_")] public long dTyvbttwmBMF; [JsonProperty(PropertyName = "_flag_")] public bool jUEuKEKgYDmZEzqLbOAwZjRc; } private void wZjNGtqHGNwmqtfUizKyMOX() => htjoTujQiNY = Interface.GetMod().DataFileSystem.ReadObject<ceuARwUFPXh>("BuildingProtectionData"); private void mQzhRoJNMQhRYNGRRGouBHwpzchVGn() => Interface.GetMod().DataFileSystem.WriteObject("BuildingProtectionData", htjoTujQiNY); } } 


// --- End of file: BuildingProtection (1).cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/ACode-1.0.0.cs ---
// --- Original Local Path: ACode-1.0.0.cs ---

﻿using System.Collections.Generic;
using System.Reflection;
using Oxide.Core;
using Oxide.Core.Configuration;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("ACode", "A0001", "1.0.0")]
	[Description("Установка последнего введенного кода")]
    class ACode : RustPlugin
    {
		#region FIELDS/DATA

        private readonly FieldInfo hasCodeField = typeof(CodeLock).GetField("hasCode", BindingFlags.Instance | BindingFlags.NonPublic);
		DynamicConfigFile saveFile = Interface.Oxide.DataFileSystem.GetFile("ACode/UserCode");
        Dictionary<ulong, string> userCode;

        void LoadData()
        {
            userCode = saveFile.ReadObject<Dictionary<ulong, string>>() ?? new Dictionary<ulong, string>();
        }

        void OnServerSave() => SaveData();

        void SaveData()
        {
            saveFile.WriteObject(userCode);
        }

		#endregion

		#region HOOKS

        void OnServerInitialized()
        {
            lang.RegisterMessages(Messages, this, "ru");
            Messages = lang.GetMessages("ru", this);
            LoadData();
        }

		void Unload() => SaveData();

		object CanChangeCode(BasePlayer player, CodeLock codeLock, string newCode, bool isGuestCode)
        {
			if (!isGuestCode)
			{
                userCode[player.userID] = newCode;
				SendReply(player, Messages["CodelockCodeSave"]);
                SaveData();
			}
			return null;
        }

		void OnItemDeployed(Deployer deployer, BaseEntity entity)
        {
            var player = deployer.GetOwnerPlayer();
            if (player == null) return;
			if (entity.HasSlot(BaseEntity.Slot.Lock))	
            {
                BaseEntity slotEntity = entity.GetSlot(BaseEntity.Slot.Lock);
                if (slotEntity == null) return;
                if (slotEntity is CodeLock)
                {
                    CodeLock codeLock = slotEntity as CodeLock;
                    if (codeLock == null) return;
                    if (userCode.ContainsKey(player.userID))
                    {
						codeLock.code = userCode[player.userID];
                        codeLock.whitelistPlayers.Add(player.userID);
                        Effect.server.Run(codeLock.effectLocked.resourcePath, codeLock, 0, Vector3.zero, Vector3.forward, null, false);
                        codeLock.SetFlag(BaseEntity.Flags.Locked, true);
						codeLock.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);
						SendReply(player, Messages["CodelockLastCode"]);
                    }
                    else
                    {
                        SendReply(player, Messages["CodelockNoCode"]);
                    }
                }
            }
        }

		#endregion

        #region LOCALIZATION

        Dictionary<string, string> Messages = new Dictionary<string, string>()
        {
            { "CodelockLastCode", "<size=16>Для замка установлен <color=#FAC73A>последний введеный код</color>!</size>"},
            { "CodelockNoCode", "<size=16>Код не установлен. Введите код в замок!</size>"},
            { "CodelockCodeSave", "<size=16>Ваш код сохранен. Он будет использоваться для всех следующих замков!</size>"}
        };

        #endregion
    }
}


// --- End of file: ACode-1.0.0.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/ProximityAlert.cs ---
// --- Original Local Path: ProximityAlert.cs ---

using System.Collections.Generic;
using Oxide.Core;
using System.Linq;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("ProximityAlert", "k1lly0u", "0.1.22", ResourceId = 1801)]
    class ProximityAlert : RustPlugin
    {
        #region Fields
        [PluginReference]
        Plugin Clans;
        [PluginReference]
        Plugin Friends;
        [PluginReference]
        Plugin EventManager;

        private static int playerLayer = UnityEngine.LayerMask.GetMask("Player (Server)");
        List<ProximityPlayer> playerList = new List<ProximityPlayer>();
        private Vector2 guiPos;
        private Vector2 guiDim;
        #endregion

        #region Functions
        void OnServerInitialized() => InitializePlugin();
        void Unload()
        {
            var objects = UnityEngine.Object.FindObjectsOfType(typeof(ProximityPlayer));
            if (objects != null)
                foreach (var gameObj in objects)
                    UnityEngine.Object.Destroy(gameObj);
            playerList.Clear();
        }
        void OnPlayerInit(BasePlayer player) => InitializePlayer(player);
        void OnPlayerDisconnected(BasePlayer player)
        {
            if (player.GetComponent<ProximityPlayer>())
                DestroyPlayer(player);
        }
        private void DestroyPlayer(BasePlayer player)
        {
            playerList.Remove(player.GetComponent<ProximityPlayer>());
            UnityEngine.Object.Destroy(player.GetComponent<ProximityPlayer>());
        }
        private void InitializePlugin()
        {
            RegisterMessages();
            permission.RegisterPermission("proximityalert.use", this);
            LoadVariables();
            guiPos = new Vector2(configData.GUI_X_Pos, configData.GUI_Y_Pos);
            guiDim = new Vector2(configData.GUI_X_Dim, configData.GUI_Y_Dim);
            foreach (var player in BasePlayer.activePlayerList)
                OnPlayerInit(player);
        }
        private void InitializePlayer(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, "proximityalert.use")) return;
            if (player.GetComponent<ProximityPlayer>())
                DestroyPlayer(player);            
            GetPlayer(player);
        }
        private void CheckDependencies()
        {
            if (Friends == null) PrintWarning($"FriendsAPI could not be found! Disabling friends feature");
            if (Clans == null) PrintWarning($"Clans could not be found! Disabling clans feature");
        }
        private void ProxCollisionEnter(BasePlayer player) => SendUI(player, lang.GetMessage("warning", this, player.UserIDString));
        private void ProxCollisionLeave(BasePlayer player) => SendUI(player, lang.GetMessage("clear", this, player.UserIDString));
        private bool PA_IsClanmate(ulong playerId, ulong friendId)
        {
            if (!Clans) return false;
            object playerTag = Clans?.Call("GetClanOf", playerId);
            object friendTag = Clans?.Call("GetClanOf", friendId);
            if (playerTag is string && friendTag is string)
                if (playerTag == friendTag) return true;
            return false;
        }
        private bool PA_IsFriend(ulong playerID, ulong friendID)
        {
            if (!Friends) return false;
            bool isFriend = (bool)Friends?.Call("IsFriend", playerID, friendID);
            return isFriend;
        }
        private bool PA_IsPlaying(BasePlayer player)
        {
            if (EventManager)
            {
                object isPlaying = EventManager?.Call("isPlaying", new object[] { player });
                if (isPlaying is bool)
                {
                    if ((bool)isPlaying) return true;
                }
            }
            return false;
        }
        private void SendUI(BasePlayer player, string msg)
        {
            if (!GetPlayer(player).GUIDestroyed)
                timer.Once(3, () => SendUI(player, msg));
            else GetPlayer(player).UseUI(msg, guiPos, guiDim);
        }
        private ProximityPlayer GetPlayer(BasePlayer player)
        {
            if (!player.GetComponent<ProximityPlayer>())
            {
                playerList.Add(player.gameObject.AddComponent<ProximityPlayer>());
                player.GetComponent<ProximityPlayer>().SetRadius(configData.TriggerRadius);
                player.GetComponent<ProximityPlayer>().Instance = this;
            }
            return player.GetComponent<ProximityPlayer>();
        }
        #endregion

        #region Chat Command
        [ChatCommand("prox")]
        private void cmdProx(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, "proximityalert.use")) return;
            if (GetPlayer(player).Activated)
            {
                GetPlayer(player).Activated = false;
                SendReply(player, lang.GetMessage("deactive", this, player.UserIDString));
                return;
            }
            else
            {
                GetPlayer(player).Activated = true;
                SendReply(player, lang.GetMessage("active", this, player.UserIDString));                
            }
        }
        #endregion

        #region Player Class
        class ProximityPlayer : MonoBehaviour
        {
            private BasePlayer player;
            private List<ulong> inProximity = new List<ulong>();
            private float collisionRadius;
            public ProximityAlert Instance;
            public bool GUIDestroyed = true;
            public bool Activated = true;

            private void Awake()
            {
                player = GetComponent<BasePlayer>();
                InvokeRepeating("UpdateTrigger", 2f, 2f);
            }
            public void SetRadius(float radius) => collisionRadius = radius;
            private void OnDestroy() => CancelInvoke("UpdateTrigger");
            private void UpdateTrigger()
            {
                if (!Activated) return;
                if (IsPlaying(player)) return;
                var colliderArray = Physics.OverlapSphere(player.transform.position, collisionRadius, playerLayer);
                var collidePlayers = new List<ulong>();
                var outProximity = new List<ulong>();

                var existingCount = inProximity.Count();

                foreach (Collider collider in colliderArray)
                {
                    var col = collider.GetComponentInParent<BasePlayer>();
                    if (col != null && col != player && !IsClanmate(col) && !IsFriend(col) && !col.IsSleeping() && !col.IsAdmin() && col.IsAlive())
                        collidePlayers.Add(col.userID);

                    if (!inProximity.Contains(col.userID))
                        inProximity.Add(col.userID);
                }

                if (inProximity.Count > existingCount)
                    EnterTrigger();

                foreach (var entry in inProximity)
                    if (!collidePlayers.Contains(entry))
                        outProximity.Add(entry);

                foreach (var entry in outProximity)
                {
                    inProximity.Remove(entry);
                    if (inProximity.Count == 0)
                        LeaveTrigger();
                }
            }
            private bool IsClanmate(BasePlayer target)
            {
                if (Instance.PA_IsClanmate(player.userID, target.userID))               
                        return true;
                return false;
            }
            private bool IsFriend(BasePlayer target)
            {
                if (Instance.PA_IsFriend(player.userID, target.userID))                
                        return true;
                return false;
            }
            private bool IsPlaying(BasePlayer player)
            {
                if (Instance.PA_IsPlaying(player))               
                        return true;
                return false;
            }
            void EnterTrigger() => Instance.ProxCollisionEnter(player);
            void LeaveTrigger() => Instance.ProxCollisionLeave(player);            
            public void UseUI(string msg, Vector2 pos, Vector2 dim, int size = 20)
            {                
                GUIDestroyed = false;        
                Vector2 posMin = pos;
                Vector2 posMax = posMin + dim;

                var elements = new CuiElementContainer();
                CuiElement textElement = new CuiElement
                {
                    Name = "ProxWarn",
                    Parent = "Overlay",
                    FadeOut = 0.3f,
                    Components =
                    {
                        new CuiTextComponent
                        {
                            Text = msg,
                            FontSize = size,
                            Align = TextAnchor.MiddleCenter,
                            FadeIn = 0.3f
                        },
                        new CuiOutlineComponent
                        {
                            Distance = "1.0 1.0",
                            Color = "0.0 0.0 0.0 1.0"
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = posMin.x + " " + posMin.y,
                            AnchorMax = posMax.x + " " + posMax.y
                        }
                    }
                };
                elements.Add(textElement);
                CuiHelper.AddUi(player, elements);
                Invoke("DestroyNotification", 4f);
            }
            private void DestroyNotification()
            {
                CuiHelper.DestroyUi(player, "ProxWarn");
                GUIDestroyed = true;
            }
        }
        #endregion
        
        #region Config
        private ConfigData configData;
        class ConfigData
        {
            public float GUI_X_Pos { get; set; }
            public float GUI_X_Dim { get; set; }
            public float GUI_Y_Pos { get; set; }
            public float GUI_Y_Dim { get; set; }
            public float TriggerRadius { get; set; }          
        }
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                GUI_X_Pos = 0.2f,
                GUI_X_Dim = 0.6f,
                GUI_Y_Pos = 0.1f,
                GUI_Y_Dim = 0.2f,
                TriggerRadius = 50f
            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        private void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        private void RegisterMessages() => lang.RegisterMessages(messages, this);
        #endregion

        #region Localization
        Dictionary<string, string> messages = new Dictionary<string, string>
        {
            {"warning", "<color=#cc0000>Caution!</color> There are players nearby!" },
            {"clear", "<color=#ffdb19>Clear!</color>" },
            {"active", "You have activated ProximityAlert" },
            {"deactive", "You have deactivated ProximityAlert" }
        };
        #endregion
    }
}


// --- End of file: ProximityAlert.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/PortableVehicles.cs ---
// --- Original Local Path: PortableVehicles.cs ---

/*
 ########### README ####################################################
                                                                             
  !!! DON'T EDIT THIS FILE !!!
  Orange is the original developer of this plugin
                                                                     
 ########### CHANGES ###################################################

 1.1.2
    - Rewrited config
    - Added chat command
    - Added chat icon option
    - Added more localization messages
    - Added option blacklist pickupable vehicles
    - Added item name vehicle
    - Fixed Pickupable Hot Air Balloon
    - Added submarinesolo
    - Added submarineduo
    - Added snowmobile
    - Added option what item you will be placing

 #######################################################################
*/

using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using UnityEngine;
using VLB;

namespace Oxide.Plugins
{
    [Info("Portable Vehicles", "Paulsimik", "1.1.2")]
    [Description("Give vehicles as item to your players")]
    public class PortableVehicles : RustPlugin
    {
        #region [Fields]

        private static Configuration config;
        private const string permUse = "portablevehicles.use";
        private const string permAdmin = "portablevehicles.admin";
        private const string permPickup = "portablevehicles.pickup";
        private string[] chatCommands = { "pv", "portablevehicles", "portablevehicle" };

        #endregion

        #region [Oxide Hooks]

        private void Init()
        {
            permission.RegisterPermission(permUse, this);
            permission.RegisterPermission(permAdmin, this);
            permission.RegisterPermission(permPickup, this);

            foreach (var command in chatCommands)
                cmd.AddChatCommand(command, this, nameof(cmdPortableVehicles));
        }

        private void OnEntityBuilt(Planner plan, GameObject go) => CheckPlacement(plan, go);

        private object OnHammerHit(BasePlayer player, HitInfo info)
        {
            if (info.HitEntity is BaseVehicle)
            {
                if (CheckPickup(player, info.HitEntity as BaseVehicle))
                    return true;
            }

            if (info.HitEntity is HotAirBalloon)
            {
                if (CheckPickupBalloon(player, info.HitEntity as HotAirBalloon))
                    return true;
            }

            return null;
        }

        #endregion

        #region [Hooks]   

        private void CheckPlacement(Planner plan, GameObject go)
        {
            var entity = go.ToBaseEntity();
            if (entity == null)
                return;

            var player = plan.GetOwnerPlayer();
            var info = AllVehicles.FirstOrDefault(x => x.skinId == entity.skinID);
            if (info == null)
                return;

            var transform = entity.transform;
            var position = transform.position;
            var rotation = transform.rotation;
            var owner = entity.OwnerID;
            var skin = entity.skinID;

            transform.position = new Vector3();
            entity.TransformChanged();
            timer.Once(1f, () =>
            {
                if (entity.IsValid() && !entity.IsDestroyed)
                {
                    entity.Kill();
                }
            });

            var time = 0.5f;
            if (info.bigModel)
            {
                time = 5f;
                Message(player, "BigModel");
            }

            timer.Once(time, () =>
            {
                var vehicle = GameManager.server.CreateEntity(info.prefab, position, rotation);
                if (vehicle != null)
                {
                    vehicle.skinID = skin;
                    vehicle.OwnerID = owner;
                    vehicle.Spawn();

                    if (config.autoMount)
                    {
                        var mountable = vehicle as BaseVehicle;
                        if (mountable != null && mountable.mountPoints != null && mountable.mountPoints.Count > 0)
                        {
                            var driverSeat = mountable.mountPoints.FirstOrDefault()?.mountable;
                            if (driverSeat != null)
                            {
                                driverSeat.MountPlayer(player);
                                player.SendNetworkUpdate();
                            }
                        }
                    }
                }
                else
                {
                    SendMessage(player, "Failed to spawn vehicle!");
                }
            });
        }

        private bool CheckPickup(BasePlayer player, BaseVehicle entity)
        {
            if (entity == null)
                return false;

            if (entity.skinID == 0)
                return false;

            if (!permission.UserHasPermission(player.UserIDString, permPickup))
                return false;

            var time = entity.SecondsSinceAttacked;
            if (time < 30)
            {
                Message(player, "Recently Attacked", (30 - time).ToString("0.0"));
                return true;
            }

            var diff = (Mathf.Abs(entity.MaxHealth() - entity.Health()));
            if (diff > 5f)
            {
                Message(player, "Durability");
                return false;
            }

            if (config.pickupableBlacklist.Contains(entity.ShortPrefabName))
            {
                Message(player, "Pickupable");
                return true;
            }

            if (entity.OwnerID != player.userID)
            {
                Message(player, "Pickup Ownership");
                return true;
            }

            if (!player.CanBuild())
            {
                Message(player, "Cupboard");
                return true;
            }

            var containers = entity.GetComponentsInChildren<StorageContainer>();
            if (containers.Any(x => x.inventory.itemList.Count > 0))
            {
                Message(player, "Not Empty");
                return true;
            }

            var fs = entity.GetFuelSystem();
            if (fs != null && !fs.fuelStorageInstance.Get(true).IsLocked() && fs.HasFuel())
            {
                Message(player, "Fuel");
                return true;
            }

            var script = entity.GetOrAddComponent<PickupScript>();
            script.AddHit();
            var left = script.GetHitsLeft();
            if (left > 0)
            {
                Message(player, "Hits", script.GetHitsLeft());
                return true;
            }

            foreach (var value in AllVehicles)
            {
                if (value.prefab == entity.PrefabName)
                {
                    entity.Kill();
                    GiveItem(player, value.skinId, value.displayName, value.isWaterVehicle);
                    return true;
                }
            }

            return false;
        }

        private bool CheckPickupBalloon(BasePlayer player, HotAirBalloon balloon)
        {
            if (balloon == null)
                return false;

            if (balloon.skinID == 0)
                return false;

            if (!permission.UserHasPermission(player.UserIDString, permPickup))
                return false;

            var time = balloon.SecondsSinceAttacked;
            if (time < 30)
            {
                Message(player, "Recently Attacked", (30 - time).ToString("0.0"));
                return true;
            }

            var diff = (Mathf.Abs(balloon.MaxHealth() - balloon.Health()));
            if (diff > 5f)
            {
                Message(player, "Durability");
                return false;
            }

            if (config.pickupableBlacklist.Contains(balloon.ShortPrefabName))
            {
                Message(player, "Pickupable");
                return true;
            }

            if (balloon.OwnerID != player.userID)
            {
                Message(player, "Pickup Ownership");
                return true;
            }

            if (!player.CanBuild())
            {
                Message(player, "Cupboard");
                return true;
            }

            var containers = balloon.GetComponentsInChildren<StorageContainer>();
            if (containers.Any(x => x.inventory.itemList.Count > 0))
            {
                Message(player, "Not Empty");
                return true;
            }

            var fs = balloon.fuelSystem;
            if (fs != null && !fs.fuelStorageInstance.Get(true).IsLocked() && fs.HasFuel())
            {
                Message(player, "Fuel");
                return true;
            }

            var script = balloon.GetOrAddComponent<PickupScript>();
            script.AddHit();
            var left = script.GetHitsLeft();
            if (left > 0)
            {
                Message(player, "Hits", script.GetHitsLeft());
                return true;
            }

            foreach (var value in AllVehicles)
            {
                if (value.prefab == balloon.PrefabName)
                {
                    balloon.Kill();
                    GiveItem(player, value.skinId, value.displayName, value.isWaterVehicle);
                    return true;
                }
            }

            return false;
        }

        private void GiveItem(BasePlayer player, ulong skin)
        {
            var vehicle = AllVehicles.FirstOrDefault(x => x.skinId == skin);
            if (vehicle == null)
                return;

            GiveItem(player, skin, vehicle.displayName, vehicle.isWaterVehicle);
        }

        private void GiveItem(BasePlayer player, ulong skinID, string name, bool isWaterVehicle)
        {
            if (string.IsNullOrEmpty(name))
                name = "Portable Vehicle";

            var shortname = isWaterVehicle ? config.waterEntityShortName : config.groundEntityShortName;
            if (string.IsNullOrEmpty(shortname))
                shortname = "box.wooden.large";

            Item item = ItemManager.CreateByName(shortname, 1, skinID);
            if (item != null)
            {
                item.name = name;
                player.GiveItem(item);
                Message(player, "Received", name);
            }
        }

        private ulong GetSkin(string name)
        {
            switch (name.ToLower())
            {
                case "rhib":
                case "militaryboat":
                case "military":
                    return 1742627792;

                case "boat":
                case "rowboat":
                case "motorboat":
                    return 1742651766;

                case "copter":
                case "mini":
                case "minicopter":
                    return 1742653197;

                case "balloon":
                case "hotairballoon":
                    return 1771792987;

                case "ch":
                case "ch47":
                case "chinook":
                    return 1771792500;

                case "horse":
                case "testridablehorse":
                    return 1773898864;

                case "scrap":
                case "scrapheli":
                case "scraphelicopter":
                case "helicopter":
                    return 1856165291;

                case "car":
                case "car1":
                case "sedan":
                    return 1742652663;

                case "car2":
                    return 2160249787;

                case "car3":
                    return 2160250208;

                case "car4":
                    return 2160251723;

                case "submarinesolo":
                    return 2566928797;

                case "submarineduo":
                    return 2566928707;

                case "snowmobile":
                    return 2741703605;

                default:
                    return 0;
            }
        }

        #endregion

        #region [Chat Commands]

        private void cmdPortableVehicles(BasePlayer player, string command, string[] args)
        {
            var value = args.Length > 0 ? args[0] : null;
            var value2 = args.Length > 1 ? args[1] : null;
            if (value == null)
            {
                Message(player, "Invalid Syntax");
                return;
            }

            if (value2 == null)
            {
                if (!permission.UserHasPermission(player.UserIDString, permUse))
                {
                    Message(player, "Permission");
                    return;
                }

                var skin = GetSkin(value);
                if (skin == 0)
                {
                    Message(player, "Invalid Vehicle");
                    return;
                }

                GiveItem(player, skin);
            }
            else
            {
                if (!IsAdmin(player))
                {
                    Message(player, "Permission");
                    return;
                }

                var target = FindPlayer(player, value);
                if (target == null)
                    return;

                var skin = GetSkin(value2);
                if (skin == 0)
                {
                    Message(player, "Invalid Vehicle");
                    return;
                }

                GiveItem(target, skin);
            }
        }

        #endregion

        #region [Console Commands]

        [ConsoleCommand("portablevehicles.give")]
        private void cmdGiveConsole(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player != null && !IsAdmin(player))
            {
                Message(player, "Permission");
                return;
            }

            var args = arg.Args;
            if (args == null || args.Length < 2)
            {
                Message(arg, "Usage");
                return;
            }

            var target = FindPlayer(arg, args[0]);
            if (target == null)
                return;

            var skin = GetSkin(args[1]);
            if (skin == 0)
            {
                Message(arg, "Invalid Vehicle");
                return;
            }

            GiveItem(target, skin);
        }

        #endregion

        #region [Classes]

        private class Configuration
        {
            [JsonProperty(PropertyName = "Chat Icon")]
            public uint chatIcon;

            [JsonProperty("Hits count to pickup vehicle")]
            public int hitsToPickup;

            [JsonProperty("Automatically mount players")]
            public bool autoMount;

            [JsonProperty(PropertyName = "Item shortname for water entity")]
            public string waterEntityShortName;

            [JsonProperty(PropertyName = "Item shortname for ground entity")]
            public string groundEntityShortName;

            [JsonProperty(PropertyName = "Blacklist pickupable vehicles shortname")]
            public List<string> pickupableBlacklist = new List<string>();

            public VersionNumber version;
        }

        private class VehicleEntry
        {
            public ulong skinId;
            public string displayName;
            public string prefab;
            public bool bigModel;
            public bool isWaterVehicle;
        }

        private VehicleEntry[] AllVehicles = new[]
        {
            new VehicleEntry
            {
                skinId = 1742627792,
                displayName = "Rhib",
                prefab = "assets/content/vehicles/boats/rhib/rhib.prefab",
                isWaterVehicle = true
            },
            new VehicleEntry
            {
                skinId = 1742651766,
                displayName = "Boat",
                prefab = "assets/content/vehicles/boats/rowboat/rowboat.prefab",
                isWaterVehicle = true
            },
            new VehicleEntry
            {
                skinId = 1742653197,
                displayName = "MiniCopter",
                prefab = "assets/content/vehicles/minicopter/minicopter.entity.prefab",
            },
            new VehicleEntry
            {
                skinId = 1742652663,
                displayName = "Sedan",
                prefab = "assets/content/vehicles/sedan_a/sedantest.entity.prefab",
            },
            new VehicleEntry
            {
                skinId = 1771792500,
                displayName = "Chinook",
                prefab = "assets/prefabs/npc/ch47/ch47.entity.prefab",
                bigModel = true,
            },
            new VehicleEntry
            {
                skinId = 1771792987,
                displayName = "Hot Air Balloon",
                prefab = "assets/prefabs/deployable/hot air balloon/hotairballoon.prefab",
                bigModel = true,
            },
            new VehicleEntry
            {
                skinId = 1773898864,
                displayName = "Horse",
                prefab = "assets/rust.ai/nextai/testridablehorse.prefab",
            },
            new VehicleEntry
            {
                skinId = 1856165291,
                displayName = "Scrap Transport Helicopter",
                prefab = "assets/content/vehicles/scrap heli carrier/scraptransporthelicopter.prefab",
                bigModel = true,
            },
            new VehicleEntry
            {
                skinId = 2160249787,
                displayName = "2 Module Car",
                prefab = "assets/content/vehicles/modularcar/2module_car_spawned.entity.prefab",
            },
            new VehicleEntry
            {
                skinId = 2160250208,
                displayName = "3 Module Car",
                prefab = "assets/content/vehicles/modularcar/3module_car_spawned.entity.prefab",
            },
            new VehicleEntry
            {
                skinId = 2160251723,
                displayName = "4 Module Car",
                prefab = "assets/content/vehicles/modularcar/4module_car_spawned.entity.prefab",
            },
            new VehicleEntry
            {
                skinId = 2566928797,
                displayName = "Submarine Solo",
                prefab = "assets/content/vehicles/submarine/submarinesolo.entity.prefab",
                isWaterVehicle = true
            },
            new VehicleEntry
            {
                skinId = 2566928707,
                displayName = "Submarine Duo",
                prefab = "assets/content/vehicles/submarine/submarineduo.entity.prefab",
                isWaterVehicle = true
            },
            new VehicleEntry
            {
                skinId = 2741703605,
                displayName = "Snowmobile",
                prefab = "assets/content/vehicles/snowmobiles/snowmobile.prefab",
            }
        };

        private class PickupScript : MonoBehaviour
        {
            private BaseEntity entity;
            private int hits;

            private void Awake()
            {
                entity = GetComponent<BaseEntity>();
            }

            public void AddHit()
            {
                if (entity.Health() < entity.MaxHealth())
                    return;

                hits++;
                CancelInvoke(nameof(ResetHits));
                Invoke(nameof(ResetHits), 60);
            }

            private void ResetHits()
            {
                hits = 0;
            }

            public int GetHitsLeft()
            {
                return config.hitsToPickup - hits;
            }
        }

        #endregion

        #region [Config]

        private Configuration GetDefaultConfig()
        {
            return new Configuration
            {
                chatIcon = 0,
                hitsToPickup = 5,
                autoMount = false,
                waterEntityShortName = "innertube",
                groundEntityShortName = "box.wooden.large",
                pickupableBlacklist = new List<string>
                {
                    "rhib",
                    "rowboat",
                    "minicopter.entity",
                    "sedantest.entity",
                    "ch47.entity",
                    "hotairballoon",
                    "testridablehorse",
                    "scraptransporthelicopter",
                    "2module_car_spawned.entity",
                    "3module_car_spawned.entity",
                    "4module_car_spawned.entity",
                    "submarinesolo.entity",
                    "submarineduo.entity",
                    "snowmobile"
                },
                version = Version
            };
        }

        protected override void LoadDefaultConfig()
        {
            config = GetDefaultConfig();
            Puts("Generating new configuration file........");
        }

        protected override void SaveConfig() => Config.WriteObject(config);

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<Configuration>();

                if (config == null)
                    LoadDefaultConfig();
            }
            catch
            {
                for (var i = 0; i < 3; i++)
                {
                    PrintError("######### Configuration file is not valid! #########");
                }
                return;
            }

            SaveConfig();
        }

        #endregion

        #region [Localization]

        private string GetLang(string key, string playerID, params object[] args) => string.Format(lang.GetMessage(key, this, playerID), args);

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"Usage", "Usage: portablevehicles.give 'steamID/player name' 'vehicle name'\n"},
                {"Invalid Syntax", "Invalid Syntax!\n/pv 'vehicle name'\n/pv 'steamID/player name' 'vehicle name'"},
                {"Permission", "You don't have permission to use that!"},
                {"Received", "You received '{0}'!"},
                {"No Player", "There are no players with that Name or steamID!"},
                {"Multiple Players", "There are many players with that Name:\n{0}"},
                {"Pickup Ownership", "Only owner can pickup vehicles!"},
                {"Fuel", "You need to remove fuel from vehicle first!"},
                {"Recently Attacked", "Vehicle was recently attacked! {0}s left"},
                {"Durability", "You need to repair vehicles fully!"},
                {"Not Empty", "Vehicle is not empty! Check fuel or storages!"},
                {"Hits", "You need to do more {0} hits!"},
                {"Cupboard", "You need to have building privilege to do that!"},
                {"BigModel", "That vehicle have big model and can kill you. Run away! It will be spawned in 5 seconds"},
                {"Pickupable", "This vehicle cannot be picked up"},
                {"Invalid Vehicle", "Vehicle name is invalid!"},
            }, this);
        }

        #endregion

        #region [Helpers]

        private bool IsAdmin(BasePlayer player)
        {
            if (player.IsAdmin || permission.UserHasPermission(player.UserIDString, permAdmin))
                return true;

            return false;
        }

        private BasePlayer FindPlayer(ConsoleSystem.Arg arg, string nameOrID)
        {
            var targets = BasePlayer.activePlayerList.Where(x => x.UserIDString == nameOrID || x.displayName.ToLower().Contains(nameOrID.ToLower())).ToList();
            if (targets.Count == 0)
            {
                Message(arg, "No Player");
                return null;
            }

            if (targets.Count > 1)
            {
                Message(arg, "Multiple Players");
                return null;
            }

            return targets[0];
        }

        private BasePlayer FindPlayer(BasePlayer player, string nameOrID)
        {
            var targets = BasePlayer.activePlayerList.Where(x => x.UserIDString == nameOrID || x.displayName.ToLower().Contains(nameOrID.ToLower())).ToList();
            if (targets.Count == 0)
            {
                Message(player, "No Player");
                return null;
            }

            if (targets.Count > 1)
            {
                Message(player, "Multiple Players");
                return null;
            }

            return targets[0];
        }

        private void Message(ConsoleSystem.Arg arg, string messageKey, params object[] args)
        {
            var message = GetLang(messageKey, null, args);
            var player = arg.Player();
            if (player != null)
            {
                SendMessage(player, message);
            }
            else
            {
                SendReply(arg, message);
            }
        }

        private void Message(BasePlayer player, string messageKey, params object[] args)
        {
            if (player == null)
                return;

            var message = GetLang(messageKey, player.UserIDString, args);
            SendMessage(player, message);
        }

        private void SendMessage(BasePlayer player, string msg) => Player.Message(player, msg, config.chatIcon);

        #endregion
    }
}

// --- End of file: PortableVehicles.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/NoSteamHelper.cs ---
// --- Original Local Path: NoSteamHelper.cs ---

﻿// Author:  Kaidoz
// Filename: NoSteamHelper.cs
// Last update: 2019.10.07 19:20

using System.Collections.Generic;
using Network;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("NoSteamHelper", "Kaidoz", "1.0.2")]
    [Description("")]
    internal class NoSteamHelper : RustPlugin
    {
        private static List<DataPlayer> _players = new List<DataPlayer>();

        private bool _loaded = false;

        #region API

        private object IsPlayerNoSteam(ulong steamid)
        {
            DataPlayer dataPlayer;
            var result = DataPlayer.FindPlayer(steamid, out dataPlayer);

            if (result == false)
            {
                Puts("Player no found");
                return false;
            }

            if (dataPlayer.IsSteam())
                return null;

            return false;
        }

        #endregion

        private void InitData()
        {
            _players =
                Interface.Oxide.DataFileSystem.ReadObject<List<DataPlayer>>("NoSteamHelper/Players");
        }

        private static void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject("NoSteamHelper/Players", _players);
        }

        public class DataPlayer
        {
            public bool Steam;
            public ulong SteamId;

            public DataPlayer(ulong id, bool steam)
            {
                SteamId = id;
                Steam = steam;
            }

            public static void AddPlayer(ulong id, bool steam)
            {
                _players.Add(new DataPlayer(id, steam));
                SaveData();
            }

            public static bool FindPlayer(ulong steamid, out DataPlayer dataPlayer)
            {
                dataPlayer = null;
                foreach (var player in _players)
                    if (player.SteamId == steamid)
                    {
                        dataPlayer = player;
                        return true;
                    }

                return false;
            }

            public bool IsSteam()
            {
                return Steam;
            }
        }

        #region Hooks

        private void OnServerInitialized(bool loaded)
        {
            if (!loaded)
                _loaded = loaded;
            InitData();
        }

        private object OnSteamAuthFailed(Connection connection)
        {
            if (_loaded)
            {
                Puts("Need a restart server");
                return null;
            }

            DataPlayer dataPlayer;

            var result = DataPlayer.FindPlayer(connection.userid, out dataPlayer);
            if (result)
            {
                if (dataPlayer.IsSteam())
                    return false;

                return null;
            }

            DataPlayer.AddPlayer(connection.userid, false);
            return null;
        }

        private void OnPlayerInit(BasePlayer player)
        {
            if (_loaded)
            {
                Puts("Need a restart server");
                return;
            }

            DataPlayer dataPlayer;

            var result = DataPlayer.FindPlayer(player.userID, out dataPlayer);
            if (result)
                return;

            DataPlayer.AddPlayer(player.userID, true);
        }

        #endregion
    }
}

// --- End of file: NoSteamHelper.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/BuildingSkins.cs ---
// --- Original Local Path: BuildingSkins.cs ---

using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Cui;
using Oxide.Core.Plugins;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Building Skins", "Marat", "2.0.3")]
    [Description("Automatic application of DLC skins for building blocks")]
    class BuildingSkins : RustPlugin
    {
        [PluginReference] private Plugin ImageLibrary;
        
        #region Field
        
        private const string InitialLayer = "UI_BuildingLayer";
        
        private const string permissionUse = "buildingskins.use";
        private const string permissionAll = "buildingskins.all";
        private const string permissionBuild = "buildingskins.build";
        private const string permissionAdmin = "buildingskins.admin";
        
        private readonly Dictionary<ulong, Coroutine> runningCoroutines = new();
        private readonly Dictionary<BuildingGrade.Enum, List<ulong>> gradesSkin = new();
        
        private readonly Dictionary<uint, string> colors = new()
        {
            [1] = "0.38 0.56 0.74 1.0",  [2] = "0.45 0.71 0.34 1.0",
            [3] = "0.57 0.29 0.83 1.0",  [4] = "0.42 0.17 0.11 1.0",
            [5] = "0.82 0.46 0.13 1.0",  [6] = "0.87 0.87 0.87 1.0",
            [7] = "0.20 0.20 0.18 1.0",  [8] = "0.40 0.33 0.27 1.0",
            [9] = "0.20 0.22 0.34 1.0",  [10] = "0.24 0.35 0.20 1.0",
            [11] = "0.73 0.30 0.18 1.0", [12] = "0.78 0.53 0.39 1.0",
            [13] = "0.84 0.66 0.22 1.0", [14] = "0.34 0.33 0.31 1.0",
            [15] = "0.21 0.34 0.37 1.0", [16] = "0.66 0.61 0.56 1.0"
        };
        
        #endregion
        
        #region Oxide Hooks
        
        private void OnServerInitialized()
        {
            if (ImageLibrary == null)
            {
                PrintError("[ImageLibrary] not found! Plugin is disabled!");
                Interface.Oxide.UnloadPlugin(Title);
                return;
            }
            
            LoadData();
            AddCovalenceCommand(config.Commands, nameof(CmdChangeSkin));
            permission.RegisterPermission(permissionUse, this);
            permission.RegisterPermission(permissionAll, this);
            permission.RegisterPermission(permissionBuild, this);
            permission.RegisterPermission(permissionAdmin, this);
            
            foreach (var list in config.BuildingImages)
            {
                var skinId = list.Value.Select(x => x.SkinId).ToList();
                gradesSkin.Add((BuildingGrade.Enum)(list.Key + 1), skinId);
                
                foreach (var info in list.Value.Where(x => !string.IsNullOrEmpty(x.Url)))
                {
                    ImageLibrary.Call("AddImage", info.Url, info.Title);
                    if (config.SeparatePermissions && info.SkinId != 0 && !string.IsNullOrEmpty(info.Title))
                    {
                        if (!permission.PermissionExists(info.Title))
                        {
                            permission.RegisterPermission($"buildingskins.{info.Title}".ToLower(), this);
                        }
                    }
                }
            }
            
            for (int i = 0; i < BasePlayer.activePlayerList.Count; i++)
            {
                OnPlayerConnected(BasePlayer.activePlayerList[i]);
            }
        }
        
        private void Unload()
        {
            for (int i = 0; i < BasePlayer.activePlayerList.Count; i++)
            {
                var player = BasePlayer.activePlayerList[i];
                CuiHelper.DestroyUi(player, InitialLayer);
                StopCoroutine(player);
            }
            SaveData();
            runningCoroutines.Clear();
            config = null;
        }
        
        private void OnServerSave() => SaveData();
        
        private void OnPlayerConnected(BasePlayer player)
        {
            if (player == null || !player.IsConnected) return;
            if (player.IsReceivingSnapshot)
            {
                timer.Once(1f, () => OnPlayerConnected(player));
                return;
            }
            StartCoroutine(player, PreloadImages(player));
            if (!storedData.PlayerData.TryGetValue(player.userID, out var data))
            {
                data = new Data
                {
                    ChangeHammer = true, NeedsRepair = true, EnableAnimation = true, RandomColor = false, Color = 9
                };
                storedData.PlayerData[player.userID] = data;
            }
            player.LastBlockColourChangeId = data.RandomColor ? player.LastBlockColourChangeId : data.Color;
        }
        
        private void OnPlayerDisconnected(BasePlayer player) => StopCoroutine(player);
        
        private void OnPlayerRespawned(BasePlayer player)
        {
            if (player == null || !player.IsConnected) return;
            var data = storedData.PlayerData.TryGetValue(player.userID, out var playerData) ? playerData : null;
            player.LastBlockColourChangeId = data?.RandomColor == false ? data.Color : player.LastBlockColourChangeId;
        }
        
        private void OnHammerHit(BasePlayer player, HitInfo info)
        {
            if (player == null || info == null || info.HitEntity == null) return;
            if (!permission.UserHasPermission(player.UserIDString, permissionUse)) return;
            var block = info.HitEntity as BuildingBlock;
            if (block == null || !gradesSkin.TryGetValue(block.grade, out var skinId) || skinId == null) return;
            var skinID = GetPlayerSkinID(player, block.grade);
            var playerData = storedData.PlayerData[player.userID];
            //if (skinID == 10226 && block.grade.ToString() == "Wood" && block.prefabID == 870964632) return;
            if (block.skinID != 0 && block.grade.ToString() == "Metal" && !playerData.RandomColor) block.SetCustomColour(player.LastBlockColourChangeId);
            if (block.skinID == skinID) return;
            if ((config.BuildingBlocked && !player.CanBuild() || block.OwnerID != player.userID) && !permission.UserHasPermission(player.UserIDString, permissionAdmin)) return;
            if (!playerData.ChangeHammer || block.health != block.MaxHealth() && !playerData.NeedsRepair) return;
            block.skinID = skinID;
            block.ChangeGradeAndSkin(block.grade, skinID, true, true);
            if (playerData.EnableAnimation) block.ClientRPC(null, "DoUpgradeEffect", (int)block.grade, skinID);
        }
        
        private object OnStructureUpgrade(BuildingBlock block, BasePlayer player, BuildingGrade.Enum grade, ulong skin)
        {
            if (player == null || block == null) return null;
            if (!permission.UserHasPermission(player.UserIDString, permissionUse)) return null;
            if (skin != 0 && player.blueprints.steamInventory.HasItem((int)skin)) return null;
            if (!gradesSkin.TryGetValue(grade, out var skinId) || skinId == null) return null;
            var skinID = GetPlayerSkinID(player, grade);
            var playerData = storedData.PlayerData[player.userID];
            //if (skinID == 10226 && grade.ToString() == "Wood" && block.prefabID == 870964632) return null;
            if (block.skinID != 0 && grade.ToString() == "Metal" && !playerData.RandomColor) block.SetCustomColour(player.LastBlockColourChangeId);
            if (block.skinID == skinID && block.grade == grade) return false;
            NextTick(() =>
            {
                if (block == null || block.IsDestroyed) return;
                block.skinID = skinID;
                block.ChangeGradeAndSkin(block.grade, skinID, true, true);
                if (playerData.EnableAnimation) block.ClientRPC(null, "DoUpgradeEffect", (int)block.grade, skinID);
                ///for plugin BuildingGrades
                if (block.skinID != 0 && grade.ToString() == "Metal" && !playerData.RandomColor) block.SetCustomColour(player.LastBlockColourChangeId);
            });
            return null;
        }
        
        ///for plugin BuildingGrades
        private void OnStructureGradeUpdated(BuildingBlock block, BasePlayer player, BuildingGrade.Enum oldGrade, BuildingGrade.Enum newGrade)
        {
            OnStructureUpgrade(block, player, newGrade, block.skinID);
        }
        
        #endregion
        
        #region Configuration
        
        private static PluginConfig config;
        
        private class PluginConfig
        {
            [JsonProperty("Building skin change commands")] public string[] Commands;
            [JsonProperty("Block building skin in building blocked")] public bool BuildingBlocked;
            [JsonProperty("Number of blocks updated per tick")] public int UpdatesPerTick;
            [JsonProperty("Use separate permissions for skins")] public bool SeparatePermissions;
            [JsonProperty("Image and description settings")] public Dictionary<int, List<BlockInfo>> BuildingImages;
            public Oxide.Core.VersionNumber Version;
        }
        
        protected override void LoadDefaultConfig()
        {
            config = new PluginConfig
            {
                Commands = new string[] {"bskin", "building.skin"},
                BuildingBlocked = true,
                UpdatesPerTick = 5,
                SeparatePermissions = false,
                BuildingImages = new Dictionary<int, List<BlockInfo>>
                {
                    [0] = new List<BlockInfo>
                    {
                        new("Wood", "https://i.ibb.co/yqsWpbp/wood.png", 0),
                        new("Frontier", "https://i.ibb.co/b2bZFXj/frontier.png", 10232),
                        new("Gingerbread", "https://i.ibb.co/Tw67yBM/gingerbread.png", 2)
                    },
                    [1] = new List<BlockInfo>
                    {
                        new("Stone", "https://i.ibb.co/jw9FJFP/stone.png", 0),
                        new("Adobe", "https://i.ibb.co/Ky1MBJ7/adobe.png", 10220),
                        new("Brick", "https://i.ibb.co/vjqh3Hj/brick.png", 10223),
                        new("Brutalist", "https://i.ibb.co/86bpvS2/brutalist.png", 10225)
                    },
                    [2] = new List<BlockInfo>
                    {
                        new("Metal", "https://i.ibb.co/M9RPSZ2/metal.png", 0),
                        new("Container", "https://i.ibb.co/YWzfwS4/container.png", 10221)
                    },
                    [3] = new List<BlockInfo>
                    {
                        new("TopTier", "https://i.ibb.co/T0Nwfvp/toptire.png", 0)
                    }
                },
                Version = Version
            };
        }
        
        private class BlockInfo
        {
            public string Title;
            public string Url;
            public ulong SkinId;
            
            public BlockInfo(string title, string url, ulong skinId)
            {
                Title = title;
                Url = url;
                SkinId = skinId;
            }
        }
        
        protected override void SaveConfig() => Config.WriteObject(config);
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<PluginConfig>();
                if (config == null) LoadDefaultConfig();
                if (config.Version < Version)
                {
                    PrintWarning("Config update detected! Updating config values...");
                    if (config.Version < new Core.VersionNumber(2, 0, 0))
                    {
                        LoadDefaultConfig();
                    }
                    if (config.Version < new Core.VersionNumber(2, 0, 3))
                    {
                        if (config.BuildingImages[0][3].SkinId == 10225)
                        {
                            config.BuildingImages[0][3].SkinId = 3;
                        }
                    }
                    config.Version = Version;
                    PrintWarning("Config update completed!");
                }
            }
            catch
            {
                PrintWarning("The config file contains an error and has been replaced with the default config.");
                LoadDefaultConfig();
            }
            SaveConfig();
        }
        
        #endregion
        
        #region Commands
        
        [ConsoleCommand("UI_BuildingController")]
        private void CmdConsoleHandler(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null || !arg.HasArgs(1)) return;
            var playerData = storedData.PlayerData[player.userID];
            SoundEffect(player, "assets/bundled/prefabs/fx/notice/loot.drag.grab.fx.prefab");
            
            int index, skinIndex;
            switch (arg.Args[0].ToLower())
            {
                case "change":
                {
                    if (!int.TryParse(arg.Args[1], out index) || !int.TryParse(arg.Args[2], out skinIndex)) return;
                    ImageLayers(player, index, skinIndex);
                    break;
                }
                case "choose":
                {
                    if (!int.TryParse(arg.Args[1], out index) || !int.TryParse(arg.Args[2], out skinIndex)) return;
                    var grades = gradesSkin.ElementAt(index);
                    playerData.GetType().GetField(grades.Key.ToString())?.SetValue(playerData, grades.Value[skinIndex]);
                    ImageLayers(player, index, skinIndex);
                    SoundEffect(player, "assets/prefabs/missions/effects/mission_objective_complete.prefab");
                    break;
                }
                case "settings":
                {
                    SettingsLayer(player);
                    break;
                }
                case "colors":
                {
                    if (!int.TryParse(arg.Args[1], out index)) return;
                    ColorLayer(player, index);
                    break;
                }
                case "setcolor":
                {
                    if (!int.TryParse(arg.Args[1], out index) || !uint.TryParse(arg.Args[2], out uint colorId)) return;
                    player.LastBlockColourChangeId = colorId;
                    playerData.Color = colorId;
                    ColorLayer(player, index);
                    SoundEffect(player, "assets/prefabs/deployable/repair bench/effects/skinchange_spraypaint.prefab");
                    break;
                }
                case "randomcolor":
                {
                    if (!int.TryParse(arg.Args[1], out index)) return;
                    var randomColor = !playerData.RandomColor;
                    playerData.RandomColor = randomColor;
                    player.LastBlockColourChangeId = randomColor ? 0U : playerData.Color;
                    ColorLayer(player, index);
                    break;
                }
                case "hammer":
                {
                    var changeHammer = !playerData.ChangeHammer;
                    playerData.ChangeHammer = changeHammer;
                    SettingsLayer(player);
                    break;
                }
                case "repair":
                {
                    var needsRepair = !playerData.NeedsRepair;
                    playerData.NeedsRepair = needsRepair;
                    SettingsLayer(player);
                    break;
                }
                case "animation":
                {
                    var enableAnimation = !playerData.EnableAnimation;
                    playerData.EnableAnimation = enableAnimation;
                    SettingsLayer(player);
                    break;
                }
            }
        }
        
        private void CmdChangeSkin(IPlayer ipPlayer, string command, string[] arg)
        {
            var player = ipPlayer?.Object as BasePlayer;
            if (player == null) return;
            if (!permission.UserHasPermission(player.UserIDString, permissionUse))
            {
                PrintToChat(player, GetMessage("Lang_NoPermissions", player));
                return;
            }
            if (arg.Length == 0)
            {
                InitializeLayers(player, true);
                return;
            }
            if (runningCoroutines.ContainsKey(player.userID))
            {
                PrintToChat(player, GetMessage("Lang_UpdateProgress", player));
                return;
            }
            if (arg.Length > 0 && config.BuildingBlocked && !player.CanBuild() && !permission.UserHasPermission(player.UserIDString, permissionAdmin))
            {
                PrintToChat(player, GetMessage("Lang_BuildingBlocked", player));
                return;
            }
            switch (arg[0].ToLower())
            {
                case "build":
                {
                    if (!permission.UserHasPermission(player.UserIDString, permissionBuild))
                    {
                        PrintToChat(player, GetMessage("Lang_NoPermissions", player));
                        return;
                    }
                    var entity = GetLookEntity(player);
                    if (entity == null)
                    {
                        PrintToChat(player, GetMessage("Lang_NotFoundBuilding", player));
                        return;
                    }
                    if (entity.OwnerID != player.userID && !permission.UserHasPermission(player.UserIDString, permissionAdmin))
                    {
                        PrintToChat(player, GetMessage("Lang_NotOwnerBuilding", player));
                        return;
                    }
                    var blocks = entity.GetBuilding()?.buildingBlocks.ToArray();
                    if (blocks == null) return;
                    PrintToChat(player, GetMessage("Lang_UpdateBuilding", player));
                    StartCoroutine(player, UpgradeSkin(player, blocks));
                    break;
                }
                case "all":
                {
                    if (!permission.UserHasPermission(player.UserIDString, permissionAll))
                    {
                        PrintToChat(player, GetMessage("Lang_NoPermissions", player));
                        return;
                    }
                    if (arg.Length > 1 && !ulong.TryParse(arg[1], out var owner))
                    {
                        PrintToChat(player, GetMessage("Lang_NotFoundPlayer", player));
                        return;
                    }
                    var targetOwner = arg.Length > 1 ? ulong.Parse(arg[1]) : player.userID;
                    if (!permission.UserHasPermission(player.UserIDString, permissionAdmin) && targetOwner != player.userID)
                    {
                        PrintToChat(player, GetMessage("Lang_NoPermissions", player));
                        return;
                    }
                    var blockOwner = BaseNetworkable.serverEntities.OfType<BuildingBlock>().Where(x => x.OwnerID == targetOwner).ToArray();
                    if (blockOwner.Length == 0)
                    {
                        PrintToChat(player, GetMessage("Lang_NotFoundBlocks", player));
                        return;
                    }
                    PrintToChat(player, GetMessage(targetOwner != player.userID ? "Lang_UpdateAllTarget" : "Lang_UpdateAll", player));
                    StartCoroutine(player, UpgradeSkin(player, blockOwner));
                    break;
                }
            }
        }
        
        #endregion
        
        #region Methods
        
        private void StartCoroutine(BasePlayer player, IEnumerator routine)
        {
            if (runningCoroutines.ContainsKey(player.userID)) return;
            var coroutine = ServerMgr.Instance?.StartCoroutine(routine);
            if (coroutine != null) runningCoroutines[player.userID] = coroutine;
        }
        
        private void StopCoroutine(BasePlayer player)
        {
            if (!runningCoroutines.ContainsKey(player.userID)) return;
            var coroutine = runningCoroutines[player.userID];
            if (coroutine != null) ServerMgr.Instance?.StopCoroutine(coroutine);
            runningCoroutines.Remove(player.userID);
        }
        
        private IEnumerator UpgradeSkin(BasePlayer player, BuildingBlock[] blocks)
        {
            var count = 0;
            for (int i = 0; i < blocks.Length; i++)
            {
                var block = blocks[i];
                if (block == null || block.IsDestroyed) continue;
                if (!gradesSkin.TryGetValue(block.grade, out var skinId) || skinId == null) continue;
                var skinID = GetPlayerSkinID(player, block.grade);
                var playerData = storedData.PlayerData[player.userID];
                if (skinID != 0 && player.blueprints.steamInventory.HasItem((int)skinID)) continue;
                //if (skinID == 10226 && block.grade.ToString() == "Wood" && block.prefabID == 870964632) continue;
                if (block.skinID != 0 && block.grade.ToString() == "Metal" && !playerData.RandomColor) block.SetCustomColour(player.LastBlockColourChangeId);
                if (block.skinID == skinID) continue;
                block.skinID = skinID;
                block.ChangeGradeAndSkin(block.grade, skinID, true, true);
                count++;
                if (i % config.UpdatesPerTick == 0)
                    yield return CoroutineEx.waitForFixedUpdate;
            }
            if (count == 0) PrintToChat(player, GetMessage("Lang_UpdateNotRequired", player));
            else PrintToChat(player, GetMessage("Lang_UpdateCompleted", player), count, blocks.Length);
            StopCoroutine(player);
        }
        
        private bool HasPermission(BasePlayer player, string name)
        {
            foreach (var blockInfoList in config.BuildingImages.Values)
            {
                foreach (var blockInfo in blockInfoList)
                {
                    if (blockInfo.Title == name && permission.UserHasPermission(player.UserIDString, $"buildingskins.{blockInfo.Title}".ToLower()))
                    {
                        return true;
                    }
                }
            }
            return false;
        }
        
        private ulong GetPlayerSkinID(BasePlayer player, BuildingGrade.Enum grade)
        {
            var playerData = storedData.PlayerData.TryGetValue(player.userID, out var data) ? data : null;
            return (ulong)(playerData?.GetType().GetField(grade.ToString()).GetValue(playerData) ?? 0);
        }
        
        private BuildingBlock GetLookEntity(BasePlayer player)
        {
            return Physics.Raycast(player.eyes.HeadRay(), out RaycastHit raycastHit, 4f, Rust.Layers.Mask.Construction) ? raycastHit.GetEntity() as BuildingBlock : null;
        }
        
        private static void SoundEffect(BasePlayer player, string effect = null)
        {
            EffectNetwork.Send(new Effect(effect, player, 0, new Vector3(), new Vector3()), player.Connection);
        }
        
        private string GetMessage(string key, BasePlayer player)
        {
            return lang.GetMessage(key, this, player.UserIDString);
        }
        
        #endregion
        
        #region Interfaces
        
        private void InitializeLayers(BasePlayer player, bool update)
        {
            float fade = !update ? 0f : 0.25f;
            CuiElementContainer container = new CuiElementContainer();
            
            container.Add(new CuiElement()
            {
                Parent = "Overlay",
                Name = InitialLayer,
                DestroyUi = InitialLayer,
                Components =
                {
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "0 0" },
                    new CuiImageComponent { Color = "0.235 0.227 0.2 0.9" },
                    new CuiNeedsCursorComponent()
                }
            });
            
            container.Add(new CuiButton()
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "0 0" },
                Button = { Close = InitialLayer, Color = "0.141 0.137 0.096 0.98", Sprite = "assets/content/ui/ui.background.transparent.radial.psd" }
            }, InitialLayer);
            
            container.Add(new CuiPanel()
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"-250 -320", OffsetMax = $"250 300" },
                Image = { Color = "0.117 0.121 0.109 0.8", Material = "assets/content/ui/uibackgroundblur.mat", FadeIn = fade }
            }, InitialLayer, InitialLayer + ".Main");
            
            container.Add(new CuiLabel()
            {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin = "30 -60", OffsetMax = "-30 -2" },
                Text = { Text = GetMessage("Lang_InterfaceTitle", player).ToUpper(), Color = "0.78 0.74 0.70 1.0", FontSize = 20, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter, FadeIn = fade }
            }, InitialLayer + ".Main");
            
            container.Add(new CuiLabel()
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0", OffsetMin = "0 5", OffsetMax = "0 25" },
                Text = { Text = $"• {GetMessage("Lang_InterfaceDescr", player)}".ToUpper(), Color = "0.78 0.74 0.70 0.6", FontSize = 12, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter, FadeIn = fade }
            }, InitialLayer + ".Main");
            
            container.Add(new CuiButton()
            {
                RectTransform = { AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = "-25 -25", OffsetMax = "-5 -5" },
                Button = { Close = InitialLayer, Color = "0.71 0.22 0.15 1.0", Sprite = "assets/icons/close.png" }
            }, InitialLayer + ".Main");
            
            container.Add(new CuiButton()
            {
                RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "5 -25", OffsetMax = "25 -5" },
                Button = { Command = $"UI_BuildingController settings", Color = "0.31 0.64 0.89 0.5", Sprite = "assets/icons/gear.png" }
            }, InitialLayer + ".Main", InitialLayer + ".Settings");
            
            CuiHelper.AddUi(player, container);
            
            for (var i = 0; i < config.BuildingImages.Count; i++)
            {
                var grades = gradesSkin.ElementAt(i);
                var skinID = GetPlayerSkinID(player, grades.Key);
                var skinIndex = grades.Value.IndexOf(skinID);
                ImageLayers(player, i, skinIndex);
            }
        }
        
        private void ImageLayers(BasePlayer player, int index, int skinIndex)
        {
            var playerData = storedData.PlayerData[player.userID];
            var listIndex = config.BuildingImages[index];
            var nextIndex = (skinIndex + 1) % listIndex.Count;
            var grades = gradesSkin.ElementAt(index);
            var skinID = GetPlayerSkinID(player, grades.Key);
            var selected = listIndex[skinIndex].SkinId == skinID;
            var hasSkin = listIndex.Any(x => !string.IsNullOrEmpty(x.Url) && x.SkinId != 0);
            var hasPermission = HasPermission(player, listIndex[skinIndex].Title);
            var isBlocked = config.SeparatePermissions && !hasPermission && skinIndex != 0;
            
            if (isBlocked && selected)
            {
                playerData.GetType().GetField(grades.Key.ToString())?.SetValue(playerData, grades.Value[0]);
                ImageLayers(player, index, 0);
                return;
            }
            
            const int marginTop = 10, margin = 6, width = 200, height = 250;
            var offsetX = (index % 2 == 0 ? -1 : 1) * ((width + margin) / 2 + margin);
            var offsetY = (index < 2 ? 1 : -1) * ((height + margin) / 2 + margin) - marginTop;
            
            CuiElementContainer container = new CuiElementContainer();
            
            container.Add(new CuiButton()
            {
                RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"{offsetX - width / 2} {offsetY - height / 2}", OffsetMax = $"{offsetX + width / 2} {offsetY + height / 2}" },
                Button = { Command = hasSkin ? $"UI_BuildingController change {index} {nextIndex}" : "", Color = "0.22 0.25 0.16 0.9", Material = "assets/content/ui/uibackgroundblur.mat" },
            }, InitialLayer + ".Main", InitialLayer + $".Button.{index}");
            
            container.Add(new CuiElement()
            {
                Parent = InitialLayer + $".Button.{index}",
                Name = InitialLayer + $".Image.{index}",
                DestroyUi = InitialLayer + $".Image.{index}",
                Components =
                {
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-85 -72", OffsetMax = "85 98" },
                    new CuiRawImageComponent { Png = (string) ImageLibrary.Call("GetImage", listIndex[skinIndex].Title), Color = hasSkin && !isBlocked ? "1 1 1 1" : "0.8 0.8 0.8 0.5" }
                }
            });
            
            if (hasSkin)
            {
                container.Add(new CuiPanel()
                {
                    RectTransform = { AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = "-28 -28", OffsetMax = "-5 -5" },
                    Image = { Color = "0.81 0.77 0.74 0.8", Sprite = "assets/icons/refresh.png" }
                }, InitialLayer + $".Button.{index}");
            }
            if (!hasSkin || isBlocked)
            {
                container.Add(new CuiPanel()
                {
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-22 -30", OffsetMax = "22 30" },
                    Image = { Color = "0.81 0.77 0.74 0.8", Sprite = "assets/content/ui/lock@4x.png" }
                }, InitialLayer + $".Image.{index}");
            }
            
            if (grades.Key.ToString() == "Metal" && !isBlocked)
            {
                if (skinIndex != 0)
                {
                    var colorIcon = colors.TryGetValue(player.LastBlockColourChangeId, out var value) ? value : "0.20 0.30 0.40 1.0";
                    
                    container.Add(new CuiButton()
                    {
                        RectTransform = { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "5 -28", OffsetMax = "28 -5" },
                        Button = { Command = $"UI_BuildingController colors {index}", Color = colorIcon, Sprite = "assets/icons/circle_closed.png" }
                    }, InitialLayer + $".Button.{index}", InitialLayer + ".Color");
                    
                    container.Add(new CuiPanel()
                    {
                        RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "-2 -2", OffsetMax = "2 2" },
                        Image = { Color = "0.81 0.77 0.74 1.0", Sprite = "assets/icons/workshop.png" }
                    }, InitialLayer + ".Color");
                }
                else CuiHelper.DestroyUi(player, InitialLayer + ".Color");
            }
            
            container.Add(new CuiPanel()
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0", OffsetMin = "0 0", OffsetMax = "0 26" },
                Image = { Color = "0 0 0 0.5" }
            }, InitialLayer + $".Button.{index}", InitialLayer + $".Title.{index}");
            
            container.Add(new CuiLabel()
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0 0", OffsetMin = "10 0", OffsetMax = "125 26" },
                Text = { Text = GetMessage(listIndex[skinIndex].Title, player).ToUpper(), Color = "0.81 0.77 0.74 1.0", FontSize = 11, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, InitialLayer + $".Title.{index}");
            
            var textTitle = GetMessage(selected ? "Lang_SkinInstalled" : (isBlocked ? "Lang_Unavailable" : "Lang_InterfaceApply"), player);
            var colorTitle = selected ? "0.59 0.84 0.18 1.0" : isBlocked ? "0.81 0.77 0.74 1.0" : "0.30 0.65 0.90 1.0";
            var colorButton = selected ? "0.30 0.36 0.16 1.0" : isBlocked ? "0.34 0.33 0.31 1.0" : "0.20 0.30 0.40 1.0";
            
            container.Add(new CuiButton()
            {
                RectTransform = { AnchorMin = "1 0", AnchorMax = "1 0", OffsetMin = "-75 0", OffsetMax = "0 26" },
                Button = { Command = hasSkin && !isBlocked && !selected ? $"UI_BuildingController choose {index} {skinIndex}" : "", Color = colorButton, Material = "assets/content/ui/uibackgroundblur.mat" },
                Text = { Text = textTitle.ToUpper(), Color = colorTitle, FontSize = 11, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            }, InitialLayer + $".Title.{index}");
            
            CuiHelper.AddUi(player, container);
        }
        
        private void SettingsLayer(BasePlayer player)
        {
            CuiElementContainer container = new CuiElementContainer();
            
            container.Add(new CuiElement()
            {
                Parent = InitialLayer + ".Settings",
                Name = InitialLayer + ".SettingsMenu",
                DestroyUi = InitialLayer + ".SettingsMenu",
                Components =
                {
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "-350 -5", OffsetMax = "5 5" },
                    new CuiImageComponent { Color = "0.20 0.30 0.40 1.0", Material = "assets/content/ui/uibackgroundblur.mat" }
                }
            });
            
            container.Add(new CuiLabel()
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "10 0", OffsetMax = "0 0" },
                Text = { Text = GetMessage("Lang_MenuSettings", player).ToUpper(), Color = "0.78 0.74 0.70 1.0", FontSize = 20, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, InitialLayer + ".SettingsMenu");
            
            container.Add(new CuiButton()
            {
                RectTransform = { AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = "-25 -25", OffsetMax = "-5 -5" },
                Button = { Close = InitialLayer + ".SettingsMenu", Color = "0.71 0.22 0.15 1.0", Sprite = "assets/icons/close.png" }
            }, InitialLayer + ".SettingsMenu");
            
            container.Add(new CuiPanel()
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0", OffsetMin = "2 -150", OffsetMax = "-35 0" },
                Image = { Color = "0.117 0.121 0.109 0.8", Material = "assets/content/ui/uibackgroundblur.mat" }
            }, InitialLayer + ".SettingsMenu", InitialLayer + ".SettingsButton");
            
            string[] langKeys = {"Lang_ChangeHammer", "Lang_NeedsRepair", "Lang_EnableAnimation"};
            string[] commands = {"UI_BuildingController hammer", "UI_BuildingController repair", "UI_BuildingController animation"};
            var playerData = storedData.PlayerData[player.userID];
            var margin = 0;
            
            for (var i = 0; i < 3; i++)
            {
                var active = new[]{playerData.ChangeHammer, playerData.ChangeHammer && playerData.NeedsRepair, playerData.EnableAnimation}[i];
                var text = GetMessage($"Lang_Setting{(active ? "Enable" : "Disable")}", player);
                var textlang = GetMessage(langKeys[i], player);
                
                container.Add(new CuiButton()
                {
                    RectTransform = { AnchorMin = "0 1", AnchorMax = "1 1", OffsetMin = $"10 {-50 - margin}", OffsetMax = $"-10 {-15 - margin}" },
                    Button = { Command = commands[i], Color = "0.34 0.33 0.31 1.0", Material = "assets/content/ui/uibackgroundblur.mat" },
                }, InitialLayer + ".SettingsButton", InitialLayer + $".SettingsButton.{i}");
                
                container.Add(new CuiPanel()
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "0 1", OffsetMin = "0 0", OffsetMax = "50 0" },
                    Image = { Color = active ? "0.36 0.44 0.22 1.0" : "0.71 0.22 0.15 1.0", Material = "assets/content/ui/uibackgroundblur.mat" },
                }, InitialLayer + $".SettingsButton.{i}", InitialLayer + $".TextButton");
                
                container.Add(new CuiLabel()
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "0 0", OffsetMax = "0 0" },
                    Text = { Text = text.ToUpper(), Color = active ? "0.78 0.74 0.70 1.0" : "0.78 0.74 0.70 0.6", FontSize = 16, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
                }, InitialLayer + $".TextButton");
                
                container.Add(new CuiLabel()
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "60 0", OffsetMax = "-5 0" },
                    Text = { Text = textlang.ToUpper(), Color = "0.78 0.74 0.70 1.0", FontSize = 12, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
                }, InitialLayer + $".SettingsButton.{i}");
                
                margin += 45;
            }
            
            CuiHelper.AddUi(player, container);
        }
        
        private void ColorLayer(BasePlayer player, int index)
        {
            var playerData = storedData.PlayerData[player.userID];
            var playerColor = player.LastBlockColourChangeId;
            CuiElementContainer container = new CuiElementContainer();
            
            container.Add(new CuiElement()
            {
                Parent = InitialLayer + ".Color",
                Name = InitialLayer + ".SetColor",
                DestroyUi = InitialLayer + ".SetColor",
                Components =
                {
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "-250 -5", OffsetMax = "5 5" },
                    new CuiImageComponent { Color = colors.TryGetValue(playerColor, out var value) ? value : "0.20 0.30 0.40 1.0", Material = "assets/content/ui/uibackgroundblur.mat" }
                }
            });
            
            container.Add(new CuiLabel()
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "10 0", OffsetMax = "0 0" },
                Text = { Text = GetMessage("Lang_ColorSettings", player).ToUpper(), Color = "0.78 0.74 0.70 1.0", FontSize = 20, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleLeft }
            }, InitialLayer + ".SetColor");
            
            container.Add(new CuiButton()
            {
                RectTransform = { AnchorMin = "1 1", AnchorMax = "1 1", OffsetMin = "-25 -25", OffsetMax = "-5 -5" },
                Button = { Close = InitialLayer + ".SetColor", Color = "0.71 0.22 0.15 1.0", Sprite = "assets/icons/close.png" }
            }, InitialLayer + ".SetColor");
            
            container.Add(new CuiPanel()
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0", OffsetMin = $"2 {(playerData.RandomColor ? -42 : -228)}", OffsetMax = "-80 0" },
                Image = { Color = "0.117 0.121 0.109 0.8", Material = "assets/content/ui/uibackgroundblur.mat" }
            }, InitialLayer + ".SetColor", InitialLayer + ".ColorButton");
            
            container.Add(new CuiButton()
            {
                RectTransform = { AnchorMin = "0.5 1", AnchorMax = "0.5 1", OffsetMin = "-89 -35", OffsetMax = "89 -6" },
                Button = { Command = $"UI_BuildingController randomcolor {index}", Color = "0.34 0.33 0.31 1.0", Material = "assets/content/ui/uibackgroundblur.mat" }
            }, InitialLayer + ".ColorButton", InitialLayer + ".RandomButton");
            
            container.Add(new CuiLabel()
            {
                RectTransform = { AnchorMin = "0.25 0", AnchorMax = "0.9 1", OffsetMin = "0 0", OffsetMax = "0 0" },
                Text = { Text = GetMessage("Lang_Randomcolor", player).ToUpper(), Color = "0.78 0.74 0.70 1.0", FontSize = 12, Font = "robotocondensed-bold.ttf", Align = TextAnchor.MiddleCenter }
            }, InitialLayer + ".RandomButton");
            
            var sprite = playerData.RandomColor ? "assets/icons/circle_closed.png" : "assets/icons/circle_open.png";
            
            container.Add(new CuiPanel()
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "0 1", OffsetMin = "23 5", OffsetMax = "42 -5" },
                Image = { Color = "0.85 0.85 0.85 0.8", Sprite = sprite }
            }, InitialLayer + ".RandomButton", InitialLayer + ".Panel");
            
            if (playerData.RandomColor)
            {
                container.Add(new CuiPanel()
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "3 3", OffsetMax = "-3 -3" },
                    Image = { Color = "0 0 0 1", Sprite = "assets/icons/check.png" }
                }, InitialLayer + ".Panel");
            }
            else
            {
                const int marginTop = 2, margin = 6, width = 40, height = 40;
                
                for (var i = 0; i < colors.Count; i++)
                {
                    var colorIndex = colors.ElementAt(i).Key;
                    var colorValue = colors.ElementAt(i).Value;
                    var offsetX = i % 4 * (width + margin) - (2 * width + 1.5 * margin);
                    var offsetY = -i / 4 * (height + margin) + 35 - marginTop;
                    
                    container.Add(new CuiButton
                    {
                        RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = $"{offsetX} {offsetY}", OffsetMax = $"{offsetX + width} {offsetY + height}" },
                        Button = { Command = colorIndex != playerColor ? $"UI_BuildingController setcolor {index} {colorIndex}" : "", Color = colorValue, Material = "assets/content/ui/uibackgroundblur.mat" }
                    }, InitialLayer + ".ColorButton", InitialLayer + ".PanelButton");
                    
                    if (colorIndex == playerColor)
                    {
                        container.Add(new CuiPanel()
                        {
                            RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "2 2", OffsetMax = "-2 -2" },
                            Image = { Color = "0.59 0.84 0.18 1.0", Sprite = "assets/icons/vote_up.png" }
                        }, InitialLayer + ".PanelButton");
                    }
                }
            }
            
            CuiHelper.AddUi(player, container);
        }
        
        private IEnumerator PreloadImages(BasePlayer player)
        {
            if (player == null || !player.IsConnected) yield break;
            for (var i = 0; i < config.BuildingImages.Count; i++)
            {
                CuiElementContainer temp = new CuiElementContainer();
                
                foreach (var blockInfo in config.BuildingImages[i])
                {
                    if (string.IsNullOrEmpty(blockInfo.Url)) continue;
                    temp.Add(new CuiElement()
                    {
                        Parent = "Hud",
                        Name = $".{i}",
                        DestroyUi = $".{i}",
                        Components =
                        {
                            new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "0 0" },
                            new CuiRawImageComponent { Png = (string) ImageLibrary?.Call("GetImage", blockInfo.Title) }
                        }
                    });
                    CuiHelper.AddUi(player, temp);
                    yield return new WaitForSeconds(1.0f);
                    CuiHelper.DestroyUi(player, $".{i}");
                }
            }
            StopCoroutine(player);
        }
        
        #endregion
        
        #region Language
        
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Lang_UpdateAll"] = "Skin update for all your buildings has started...",
                ["Lang_UpdateBuilding"] = "Skin update for selected building has started...",
                ["Lang_UpdateAllTarget"] = "Skin update for all players buildings has started...",
                ["Lang_UpdateProgress"] = "Please wait for the building skin update to finish.",
                ["Lang_UpdateCompleted"] = "Building skin update completed.\nUpdated {0} of {1} building blocks.",
                ["Lang_UpdateNotRequired"] = "All building blocks already have your chosen skin.",
                ["Lang_NotFoundBlocks"] = "No available buildings found for the selected player.",
                ["Lang_NotFoundPlayer"] = "Player not found. Use only the Steam Id of the player.",
                ["Lang_NotFoundBuilding"] = "Building not found. Get closer to the building and repeat again.",
                ["Lang_NotOwnerBuilding"] = "You are not the owner of this building.",
                ["Lang_BuildingBlocked"] = "You can't use this command if the building is blocked.",
                ["Lang_NoPermissions"] = "You don't have permission to use this command.",
                ["Lang_InterfaceTitle"] = "Choose a default skin for the building block",
                ["Lang_InterfaceDescr"] = "The skin will be automatically applied to building blocks.",
                ["Lang_ChangeHammer"] = "Change the skin of a building block with a hammer",
                ["Lang_NeedsRepair"] = "Allow skin changing with a hammer if a building needs repair",
                ["Lang_EnableAnimation"] = "Allow building block skin update animation",
                ["Lang_InterfaceApply"] = "Apply",
                ["Lang_SkinInstalled"] = "Installed",
                ["Lang_Unavailable"] = "Unavailable",
                ["Lang_MenuSettings"] = "Settings",
                ["Lang_ColorSettings"] = "Set color",
                ["Lang_Randomcolor"] = "Use random color",
                ["Lang_SettingEnable"] = "On",
                ["Lang_SettingDisable"] = "Off",
                ["Wood"] = "Wood skin",
                ["Stone"] = "Stone skin",
                ["Metal"] = "Metal skin",
                ["TopTier"] = "TopTier skin",
                ["Adobe"] = "Adobe skin",
                ["Brick"] = "Brick skin",
                ["Brutalist"] = "Brutalist skin",
                ["Container"] = "Container skin",
                ["Frontier"] = "Frontier skin",
                ["Gingerbread"] = "Gingerbread skin"
            }, this);
            
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Lang_UpdateAll"] = "Обновление скина для всех ваших построек началось...",
                ["Lang_UpdateBuilding"] = "Обновление скина для выбранной постройки началось...",
                ["Lang_UpdateAllTarget"] = "Обновление скина для всех построек игрока началось...",
                ["Lang_UpdateProgress"] = "Пожалуйста, дождитесь завершения обновления скина построек.",
                ["Lang_UpdateCompleted"] = "Обновление скина построек завершено.\nОбновлено {0} из {1} строительных блоков.",
                ["Lang_UpdateNotRequired"] = "Все строительные блоки уже имеют выбранный вами скин.",
                ["Lang_NotFoundBlocks"] = "Не найдено доступных построек для выбранного игрока.",
                ["Lang_NotFoundPlayer"] = "Игрок не найден. Используйте только Steam Id игрока.",
                ["Lang_NotFoundBuilding"] = "Постройка не найдена. Подойдите ближе к постройке и повторите снова.",
                ["Lang_NotOwnerBuilding"] = "Вы не являетесь владельцем этой постройки.",
                ["Lang_BuildingBlocked"] = "Вы не можете использовать эту команду в зоне блокировки строительства.",
                ["Lang_NoPermissions"] = "У вас нет разрешения на использование этой команды.",
                ["Lang_InterfaceTitle"] = "Выберите скин по умолчанию для строительного блока",
                ["Lang_InterfaceDescr"] = "Скин будет автоматически применяться к постройке.",
                ["Lang_ChangeHammer"] = "Изменять скин постройки при помощи киянки",
                ["Lang_NeedsRepair"] = "Разрешить смену скина киянкой, если требуется ремонт постройки",
                ["Lang_EnableAnimation"] = "Разрешить анимацию обновления скина постройки",
                ["Lang_InterfaceApply"] = "Применить",
                ["Lang_SkinInstalled"] = "Установлен",
                ["Lang_Unavailable"] = "Недоступен",
                ["Lang_MenuSettings"] = "Настройки",
                ["Lang_ColorSettings"] = "Выбор цвета",
                ["Lang_Randomcolor"] = "Случайный цвет",
                ["Lang_SettingEnable"] = "Вкл",
                ["Lang_SettingDisable"] = "Выкл",
                ["Wood"] = "Деревянный скин",
                ["Stone"] = "Каменный скин",
                ["Metal"] = "Металлический скин",
                ["TopTier"] = "МВК скин",
                ["Adobe"] = "Саманный скин",
                ["Brick"] = "Кирпичный скин",
                ["Brutalist"] = "Брутализм скин",
                ["Container"] = "Контейнерный скин",
                ["Frontier"] = "Фронтир скин",
                ["Gingerbread"] = "Пряничный скин"
            }, this, "ru");
        }
        
        #endregion
        
        #region Data
        
        private StoredData storedData;
        
        private class StoredData
        {
            public Dictionary<ulong, Data> PlayerData = new Dictionary<ulong, Data>();
        }
        
        private class Data
        {
            [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore)] public bool ChangeHammer;
            [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore)] public bool NeedsRepair;
            [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore)] public bool EnableAnimation;
            [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore)] public bool RandomColor;
            [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore)] public uint Color;
            [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore)] public ulong Wood;
            [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore)] public ulong Stone;
            [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore)] public ulong Metal;
            [JsonProperty(DefaultValueHandling = DefaultValueHandling.Ignore)] public ulong TopTier;
        }
        
        private void SaveData()
        {
            if (storedData != null)
            {
                Interface.Oxide.DataFileSystem.WriteObject($"{Name}_Data", storedData, true);
            }
        }
        
        private void LoadData()
        {
            storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>($"{Name}_Data");
            if (storedData == null)
            {
                storedData = new StoredData();
                SaveData();
            }
        }
        
        #endregion
    }
}

// --- End of file: BuildingSkins.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/RadtownAnimals.cs ---
// --- Original Local Path: RadtownAnimals.cs ---

// Reference: RustBuild
using System;
using System.Collections.Generic;
using UnityEngine;
using System.Linq;
using System.Reflection;

namespace Oxide.Plugins
{
    [Info("RadtownAnimals", "k1lly0u", "0.2.11", ResourceId = 1561)]
    class RadtownAnimals : RustPlugin
    {
        #region Fields
        private Dictionary<BaseEntity, Vector3> animalList = new Dictionary<BaseEntity, Vector3>();
        private List<Timer> refreshTimers = new List<Timer>();
        #endregion

        #region Oxide Hooks
        void Loaded()
        {
            lang.RegisterMessages(messages, this);
        }
        void OnServerInitialized()
        {
            LoadVariables();
            InitializeAnimalSpawns();
        }
        void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            try
            {
                if (entity.GetComponent<BaseNPC>() != null)
                {
                    if (animalList.ContainsKey(entity as BaseEntity))
                    {
                        UnityEngine.Object.Destroy(entity.GetComponent<RAController>());
                        InitiateRefresh(entity as BaseEntity);
                    }
                }
            }
            catch { }
        }
        void Unload()
        {
            foreach (var time in refreshTimers)
                time.Destroy();

            foreach (var animal in animalList)
            {
                if (animal.Key != null)
                {
                    UnityEngine.Object.Destroy(animal.Key.GetComponent<RAController>());
                    animal.Key.KillMessage();
                }
            }
            var objects = UnityEngine.Object.FindObjectsOfType<RAController>();
            if (objects != null)
                foreach (var gameObj in objects)
                    UnityEngine.Object.Destroy(gameObj);
            animalList.Clear();
        }
        #endregion

        #region Initial Spawning
        private void InitializeAnimalSpawns()
        {
            var allobjects = UnityEngine.Object.FindObjectsOfType<GameObject>();
            foreach (var gobject in allobjects)
            {
                if (gobject.name.Contains("autospawn/monument"))
                {
                    var position = gobject.transform.position;
                    if (gobject.name.ToLower().Contains("lighthouse"))
                    {
                        if (configData.Lighthouses.Enabled)
                        {
                            SpawnAnimals(position, GetSpawnList(configData.Lighthouses.AnimalCounts));
                            continue;
                        }
                    }
                    if (gobject.name.Contains("powerplant_1"))
                    {
                        if (configData.Powerplant.Enabled)
                        {
                            SpawnAnimals(position, GetSpawnList(configData.Powerplant.AnimalCounts));
                            continue;
                        }
                    }

                    if (gobject.name.Contains("military_tunnel_1"))
                    {
                        if (configData.MilitaryTunnels.Enabled)
                        {
                            SpawnAnimals(position, GetSpawnList(configData.MilitaryTunnels.AnimalCounts));
                            continue;
                        }
                    }

                    if (gobject.name.Contains("airfield_1"))
                    {
                        if (configData.Airfield.Enabled)
                        {
                            SpawnAnimals(position, GetSpawnList(configData.Airfield.AnimalCounts));
                            continue;
                        }
                    }

                    if (gobject.name.Contains("trainyard_1"))
                    {
                        if (configData.Trainyard.Enabled)
                        {
                            SpawnAnimals(position, GetSpawnList(configData.Trainyard.AnimalCounts));
                            continue;
                        }
                    }

                    if (gobject.name.Contains("water_treatment_plant_1"))
                    {
                        if (configData.WaterTreatmentPlant.Enabled)
                        {
                            SpawnAnimals(position, GetSpawnList(configData.WaterTreatmentPlant.AnimalCounts));
                            continue;
                        }
                    }

                    if (gobject.name.Contains("warehouse"))
                    {
                        if (configData.Warehouses.Enabled)
                        {
                            SpawnAnimals(position, GetSpawnList(configData.Warehouses.AnimalCounts));
                            continue;
                        }
                    }

                    if (gobject.name.Contains("satellite_dish"))
                    {
                        if (configData.Satellite.Enabled)
                        {
                            SpawnAnimals(position, GetSpawnList(configData.Satellite.AnimalCounts));
                            continue;
                        }
                    }

                    if (gobject.name.Contains("sphere_tank"))
                    {
                        if (configData.SphereTank.Enabled)
                        {
                            SpawnAnimals(position, GetSpawnList(configData.SphereTank.AnimalCounts));
                            continue;
                        }
                    }

                    if (gobject.name.Contains("radtown_small_3"))
                    {
                        if (configData.Radtowns.Enabled)
                        {
                            SpawnAnimals(position, GetSpawnList(configData.Radtowns.AnimalCounts));
                            continue;
                        }
                    }
                }
            }            
        }
        private Dictionary<string, int> GetSpawnList(AnimalCounts counts)
        {
            var spawnList = new Dictionary<string, int>
            {
                {"bear", counts.Bears},
                {"boar", counts.Boars },
                {"chicken", counts.Chickens },
                {"horse", counts.Horses },
                {"stag", counts.Stags },
                {"wolf", counts.Wolfs }
            };
            return spawnList;
        }
        private void SpawnAnimals(Vector3 position, Dictionary<string,int> spawnList)
        {
            if (animalList.Count >= configData.a_Options.TotalMaximumAmount)
            {
                PrintError(lang.GetMessage("spawnLimit", this));
                return;
            }
            foreach (var type in spawnList)
            {
                
                for (int i = 0; i < type.Value; i++)
                {
                    var entity = SpawnAnimalEntity(type.Key, position);
                    animalList.Add(entity, position);
                }
            }
        }
        #endregion

        #region Spawn Control
        private void InitiateRefresh(BaseEntity animal)
        {
            var position = animal.transform.position;
            var type = animal.ShortPrefabName.Replace(".prefab", "");
            refreshTimers.Add(timer.Once(configData.a_Options.RespawnTimer * 60, () =>
            {
                InitializeNewSpawn(type, position);
            }));
            animalList.Remove(animal);
        }
        private void InitializeNewSpawn(string type, Vector3 position)
        {
            var newAnimal = SpawnAnimalEntity(type, position);
            animalList.Add(newAnimal, position);
        }
        private BaseEntity SpawnAnimalEntity(string type, Vector3 pos)
        {
            var newPos = AdjustPosition(pos);
            BaseEntity entity = GameManager.server.CreateEntity($"assets/bundled/prefabs/autospawn/animals/{type}.prefab", newPos, new Quaternion(), true);
            entity.Spawn();
            var npc = entity.gameObject.AddComponent<RAController>();
            npc.SetHome(pos);
            return entity;
        }
        private Vector3 AdjustPosition(Vector3 pos)
        {
            Vector3 randomPos = Quaternion.Euler(UnityEngine.Random.Range((float)(-configData.a_Options.SpawnSpread * 0.2), configData.a_Options.SpawnSpread * 0.2f), UnityEngine.Random.Range((float)(-configData.a_Options.SpawnSpread * 0.2), configData.a_Options.SpawnSpread * 0.2f), UnityEngine.Random.Range((float)(-configData.a_Options.SpawnSpread * 0.2), configData.a_Options.SpawnSpread * 0.2f)) * pos;
            Vector3 correctPos = GetGroundPosition(randomPos);
            return correctPos;
        }
        #endregion

        #region Helper Methods
        static Vector3 GetGroundPosition(Vector3 sourcePos) // credit Wulf & Nogrod
        {
            RaycastHit hitInfo;

            if (Physics.Raycast(sourcePos, Vector3.down, out hitInfo, LayerMask.GetMask("Terrain", "World", "Construction")))            
                sourcePos.y = hitInfo.point.y;            
            sourcePos.y = Mathf.Max(sourcePos.y, TerrainMeta.HeightMap.GetHeight(sourcePos));
            return sourcePos;
        }
        #endregion

        #region NPCController
        class RAController : MonoBehaviour
        {
            private readonly MethodInfo SetDeltaTimeMethod = typeof(NPCAI).GetProperty("deltaTime", (BindingFlags.Public | BindingFlags.Instance)).GetSetMethod(true);

            internal static double targetAttackRange = 70;

            internal Vector3 Home;
            internal Vector3 NextPos;
            internal BaseCombatEntity Target;

            internal bool isAttacking;

            public BaseNPC NPC;
            public NPCAI AI;
            public NPCMetabolism Metabolism;

            void Awake()
            {
                AI = GetComponent<NPCAI>();
                NPC = GetComponent<BaseNPC>();
                Metabolism = GetComponent<NPCMetabolism>();
                isAttacking = false;
                Target = null;
                NPC.state = BaseNPC.State.Normal;
                NPC.enableSaving = false;
                BaseEntity.saveList.Remove(NPC);
            }
            void FixedUpdate()
            {
                if (AI.deltaTime < ConVar.Server.TickDelta()) return;
                if (NPC.IsStunned()) return;
                NPC.Tick();
                if (NPC.attack.IsActive())
                {
                    NPC.attack.gameObject.SetActive(false);
                    Move(NextPos);
                    return;
                }
                if (Vector3.Distance(transform.position, Home) > 140)
                {
                    Move(Home);
                    return;
                }
                if (isAttacking && Target != null)
                {
                    var distance = Vector3.Distance(transform.position, Target.transform.position);
                    if (distance >= 70)
                    {
                        isAttacking = false;
                        Target = null;
                        return;
                    }
                    else if (distance < targetAttackRange)
                    {
                        var normalized = (Target.transform.position - transform.position).XZ3D().normalized;
                        if (NPC.diet.Eat(Target))
                        {
                            NPC.Heal(NPC.MaxHealth() / 10);
                            Metabolism.calories.Add(Metabolism.calories.max / 10);
                            Metabolism.hydration.Add(Metabolism.hydration.max / 10);
                        }
                        else if (NPC.attack.Hit(Target, 1, false))
                            transform.rotation = Quaternion.LookRotation(normalized);
                        NPC.steering.Face(normalized);
                    }
                    else Move(Target.transform.position);
                }
                else if (Vector3.Distance(transform.position, NextPos) < 20)
                {
                    CalculateNextPos();

                    if (Metabolism.calories.value < 20f)
                        NPC.diet.Forage();
                    else if (Metabolism.sleep.value < 20f)
                        Sleep();
                }
                else Move(NextPos);
            }
            public void SetHome(Vector3 pos)
            {
                Home = pos;
                NextPos = pos;
            }
            void CalculateNextPos()
            {
                RaycastHit hitInfo;

                NextPos = Home;
                NextPos.x += UnityEngine.Random.Range(-100, 100);

                if (Physics.Raycast(NextPos, Vector3.down, out hitInfo, LayerMask.GetMask("Terrain", "World", "Construction")))
                    NextPos.y = hitInfo.point.y;
                NextPos.y = Mathf.Max(NextPos.y, TerrainMeta.HeightMap.GetHeight(NextPos));

                NextPos.z += UnityEngine.Random.Range(-100, 100);
            }
            void Move(Vector3 pos)
            {
                NPC.state = BaseNPC.State.Normal;
                AI.sense.Think();
                NPC.steering.Move((pos - transform.position).XZ3D().normalized, pos, (int)NPCSpeed.Trot);
            }
            void Sleep()
            {
                NPC.state = BaseNPC.State.Sleeping;
                NPC.sleep.Recover(20f);
                Metabolism.stamina.Run(20f);
                NPC.StartCooldown(20f, true);
            }
            internal void OnAttacked(HitInfo info)
            {
                if (info.Initiator)
                    Attack(info.Initiator.GetComponent<BaseCombatEntity>());
            }
            internal void Attack(BaseCombatEntity ent)
            {
                Target = ent;
                isAttacking = true;
                targetAttackRange = Math.Pow(NPC._collider.bounds.XZ3D().extents.Max() + NPC.attack.range + ent._collider.bounds.XZ3D().extents.Max(), 2);
            }
        }
        #endregion

        #region Commands
        [ChatCommand("ra_killall")]
        private void chatKillAnimals(BasePlayer player, string command, string[] args)
        {
            if (player.IsAdmin()) return;
            foreach(var animal in animalList)
            {
                UnityEngine.Object.Destroy(animal.Key.GetComponent<RAController>());
                animal.Key.KillMessage();
            }
            animalList.Clear();
            SendReply(player, lang.GetMessage("title", this, player.UserIDString) + lang.GetMessage("killedAll", this, player.UserIDString));
        }

        [ConsoleCommand("ra_killall")]
        private void ccmdKillAnimals(ConsoleSystem.Arg arg)
        {
            if (arg.connection == null)
            {
                foreach (var animal in animalList)
                {
                    UnityEngine.Object.Destroy(animal.Key.GetComponent<RAController>());
                    animal.Key.KillMessage();
                }
                animalList.Clear();
                SendReply(arg, lang.GetMessage("killedAll", this));
            }
        }
        #endregion

        #region Config 
        #region Options       
        class AnimalCounts
        {
            public int Bears;
            public int Boars;
            public int Chickens;
            public int Horses;
            public int Stags;
            public int Wolfs;
        }
        class LightHouses
        {
            public AnimalCounts AnimalCounts { get; set; }  
            public bool Enabled { get; set; }          
        }
        class Airfield
        {
            public AnimalCounts AnimalCounts { get; set; }
            public bool Enabled { get; set; }
        }

        class Powerplant
        {
            public AnimalCounts AnimalCounts { get; set; }
            public bool Enabled { get; set; }
        }

        class Trainyard
        {
            public AnimalCounts AnimalCounts { get; set; }
            public bool Enabled { get; set; }
        }

        class WaterTreatmentPlant
        {
            public AnimalCounts AnimalCounts { get; set; }
            public bool Enabled { get; set; }
        }

        class Warehouses
        {
            public AnimalCounts AnimalCounts { get; set; }
            public bool Enabled { get; set; }
        }

        class Satellite
        {
            public AnimalCounts AnimalCounts { get; set; }
            public bool Enabled { get; set; }
        }

        class SphereTank
        {
            public AnimalCounts AnimalCounts { get; set; }
            public bool Enabled { get; set; }
        }

        class Radtowns
        {
            public AnimalCounts AnimalCounts { get; set; }
            public bool Enabled { get; set; }
        }
        class MilitaryTunnels
        {
            public AnimalCounts AnimalCounts { get; set; }
            public bool Enabled { get; set; }
        }
        class Options
        {
            public int RespawnTimer;
            public float SpawnSpread;
            public int TotalMaximumAmount;           
        }
        #endregion

        private ConfigData configData;
        class ConfigData
        {
            public LightHouses Lighthouses { get; set; }
            public Airfield Airfield { get; set; }
            public Powerplant Powerplant { get; set; }
            public Trainyard Trainyard { get; set; }
            public WaterTreatmentPlant WaterTreatmentPlant { get; set; }
            public Warehouses Warehouses { get; set; }
            public Satellite Satellite { get; set; }
            public SphereTank SphereTank { get; set; }
            public Radtowns Radtowns { get; set; }
            public MilitaryTunnels MilitaryTunnels { get; set; }
            public Options a_Options { get; set; }
        }
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                Airfield = new Airfield
                {
                    AnimalCounts = new AnimalCounts
                    {
                        Bears = 0,
                        Boars = 0,
                        Chickens = 0,
                        Horses = 0,
                        Stags = 0,
                        Wolfs = 0,
                    },
                    Enabled = false
                },
                Lighthouses = new LightHouses
                {
                    AnimalCounts = new AnimalCounts
                    {
                        Bears = 0,
                        Boars = 0,
                        Chickens = 0,
                        Horses = 0,
                        Stags = 0,
                        Wolfs = 0,
                    },
                    Enabled = false
                },
                MilitaryTunnels = new MilitaryTunnels
                {
                    AnimalCounts = new AnimalCounts
                    {
                        Bears = 0,
                        Boars = 0,
                        Chickens = 0,
                        Horses = 0,
                        Stags = 0,
                        Wolfs = 0,
                    },
                    Enabled = false
                },
                Powerplant = new Powerplant
                {
                    AnimalCounts = new AnimalCounts
                    {
                        Bears = 0,
                        Boars = 0,
                        Chickens = 0,
                        Horses = 0,
                        Stags = 0,
                        Wolfs = 0,
                    },
                    Enabled = false
                },
                Radtowns = new Radtowns
                {
                    AnimalCounts = new AnimalCounts
                    {
                        Bears = 0,
                        Boars = 0,
                        Chickens = 0,
                        Horses = 0,
                        Stags = 0,
                        Wolfs = 0,
                    },
                    Enabled = false
                },
                Satellite = new Satellite
                {
                    AnimalCounts = new AnimalCounts
                    {
                        Bears = 0,
                        Boars = 0,
                        Chickens = 0,
                        Horses = 0,
                        Stags = 0,
                        Wolfs = 0,
                    },
                    Enabled = false
                },
                SphereTank = new SphereTank
                {
                    AnimalCounts = new AnimalCounts
                    {
                        Bears = 0,
                        Boars = 0,
                        Chickens = 0,
                        Horses = 0,
                        Stags = 0,
                        Wolfs = 0,
                    },
                    Enabled = false
                },
                Trainyard = new Trainyard
                {
                    AnimalCounts = new AnimalCounts
                    {
                        Bears = 0,
                        Boars = 0,
                        Chickens = 0,
                        Horses = 0,
                        Stags = 0,
                        Wolfs = 0,
                    },
                    Enabled = false
                },
                Warehouses = new Warehouses
                {
                    AnimalCounts = new AnimalCounts
                    {
                        Bears = 0,
                        Boars = 0,
                        Chickens = 0,
                        Horses = 0,
                        Stags = 0,
                        Wolfs = 0,
                    },
                    Enabled = false
                },
                WaterTreatmentPlant = new WaterTreatmentPlant
                {
                    AnimalCounts = new AnimalCounts
                    {
                        Bears = 0,
                        Boars = 0,
                        Chickens = 0,
                        Horses = 0,
                        Stags = 0,
                        Wolfs = 0,
                    },
                    Enabled = false
                },
                a_Options = new Options
                {
                    TotalMaximumAmount = 40,
                    RespawnTimer = 15,
                    SpawnSpread = 100
                }
            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion      

        #region Messaging
        Dictionary<string, string> messages = new Dictionary<string, string>()
        {
            {"nullList", "<color=#939393>Error getting a list of monuments</color>" },
            {"title", "<color=orange>Radtown Animals:</color> " },
            {"killedAll", "<color=#939393>Killed all animals</color>" },
            {"spawnLimit", "<color=#939393>The animal spawn limit has been hit.</color>" }
        };
        #endregion
    }
}


// --- End of file: RadtownAnimals.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/ShowCrosshair.cs ---
// --- Original Local Path: ShowCrosshair.cs ---

using System.Collections.Generic;
using UnityEngine;
using Oxide.Core;
using Oxide.Game.Rust.Cui;
using System;

namespace Oxide.Plugins
{
    [Info("ShowCrosshair", "Marat", "1.0.7", ResourceId = 2057)]
	[Description("Shows a crosshair on the screen.")]

    class ShowCrosshair : RustPlugin
    { 
	    List<ulong> Cross = new List<ulong>();
		List<ulong> Menu = new List<ulong>();
		bool EnableCross(BasePlayer player) => Cross.Contains(player.userID);
		bool EnableMenu(BasePlayer player) => Menu.Contains(player.userID);

		#region Initialization
		
		private bool configChanged;
	    private const string permShowCrosshair = "showcrosshair.allowed";
		private string background = "http://i.imgur.com/mD8K49U.png";
		private string background2 = "http://i.imgur.com/mYV1bFs.png";

        private void Loaded()
        {
			LoadConfiguration();
            LoadDefaultMessages();
            permission.RegisterPermission(permShowCrosshair, this);
            cmd.AddChatCommand(command, this, "cmdChatCrosshair");
			cmd.AddChatCommand(commandmenu, this, "cmdChatShowMenu");
        }
		
		#endregion
		
		#region Configuration
		
		protected override void LoadDefaultConfig()
        {
            PrintWarning("New configuration file created.");
            Config.Clear();
		}
		
		private bool usePermissions = false;
		private bool ShowOnLogin = false;
		private bool EnableSound = true;
		private bool ShowMessage = true;
		private bool KeyBindSet = true;
		private string SoundOpen = "assets/bundled/prefabs/fx/build/promote_metal.prefab";
		private string SoundDisable = "assets/prefabs/locks/keypad/effects/lock.code.lock.prefab";
		private string SoundSelect = "assets/prefabs/locks/keypad/effects/lock.code.unlock.prefab";
		private string SoundToggle = "assets/prefabs/misc/xmas/presents/effects/unwrap.prefab";
		private string commandmenu = "showmenu";
		private string command = "crosshair";
		private string keybind = "f5";
		private string colorClose = "0 0 0 0.7";
		private string colorBackground = "0 0 0 0.7";
		private string colorToggle = "0 0 0 0.7";
		private string colorDisable = "0 0 0 0.7";
		private string image1 = "http://i.imgur.com/n1y3P5t.png";
	    private string image2 = "http://i.imgur.com/v6dqmPI.png";
	    private string image3 = "http://i.imgur.com/oTcb8fz.png";
		private string image4 = "http://i.imgur.com/FRpk2mJ.png";
		private string image5 = "http://i.imgur.com/8Jrca6t.png";
	    private string image6 = "http://i.imgur.com/K7yirTy.png";
	    private string image7 = "http://i.imgur.com/beHkRnR.png";
		private string image8 = "http://i.imgur.com/tB088dk.png";
		
		private void LoadConfiguration()
        {
			command = GetConfigValue("Options", "Command", command);
			commandmenu = GetConfigValue("Options", "CommandMenu", commandmenu);
			keybind = GetConfigValue("Options", "KeyBindMenu", keybind);
            ShowMessage = GetConfigValue("Options", "ShowMessage", ShowMessage);
			KeyBindSet = GetConfigValue("Options", "KeyBindSet", KeyBindSet);
			ShowOnLogin = GetConfigValue("Options", "ShowOnLogin", ShowOnLogin);
			EnableSound = GetConfigValue("Options", "EnableSound", EnableSound);
			usePermissions = GetConfigValue("Options", "UsePermissions", usePermissions);
			
			SoundOpen = GetConfigValue("Sound", "SoundOpen", SoundOpen);
			SoundDisable = GetConfigValue("Sound", "SoundDisable", SoundDisable);
			SoundSelect = GetConfigValue("Sound", "SoundSelect", SoundSelect);
			SoundToggle = GetConfigValue("Sound", "SoundToggle", SoundToggle);
			
			colorClose = GetConfigValue("Color", "ColorButtonClose", colorClose);
			colorToggle = GetConfigValue("Color", "ColorButtonToggle", colorToggle);
			colorDisable = GetConfigValue("Color", "ColorButtonDisable", colorDisable);
			colorBackground = GetConfigValue("Color", "ColorBackground", colorBackground);
			
			image1 = GetConfigValue("Image", "Crosshair1", image1);
			image2 = GetConfigValue("Image", "Crosshair2", image2);
			image3 = GetConfigValue("Image", "Crosshair3", image3);
			image4 = GetConfigValue("Image", "Crosshair4", image4);
			image5 = GetConfigValue("Image", "Crosshair5", image5);
			image6 = GetConfigValue("Image", "Crosshair6", image6);
			image7 = GetConfigValue("Image", "Crosshair7", image7);
			image8 = GetConfigValue("Image", "Crosshair8", image8);
			
			if (!configChanged) return;
            PrintWarning("Configuration file updated.");
            SaveConfig();
        }
		
		private T GetConfigValue<T>(string category, string setting, T defaultValue)
        {
            var data = Config[category] as Dictionary<string, object>;
            object value;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[category] = data;
                configChanged = true;
            }
            if (data.TryGetValue(setting, out value)) return (T)Convert.ChangeType(value, typeof(T));
            value = defaultValue;
            data[setting] = value;
            configChanged = true;
            return (T)Convert.ChangeType(value, typeof(T));
        }
		
		#endregion
		
		#region Localization
		
		private void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
				["NoPermission"] = "You don't have permission to use this command.",
				["Enabled"] = "You have enabled the crosshair.",
                ["Disabled"] = "You have disabled the crosshair.",
				["crosshair1"] = "You set the crosshair â1.",
				["crosshair2"] = "You set the crosshair â2.",
				["crosshair3"] = "You set the crosshair â3.",
				["crosshair4"] = "You set the crosshair â4.",
				["crosshair5"] = "You set the crosshair â5.",
				["crosshair6"] = "You set the crosshair â6.",
				["crosshair7"] = "You set the crosshair â7.",
				["crosshair8"] = "You set the crosshair â8."
            }, this, "en");
			lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoPermission"] = "Ð£ Ð²Ð°Ñ Ð½ÐµÑ ÑÐ°Ð·ÑÐµÑÐµÐ½Ð¸Ñ Ð½Ð° Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°Ð½Ð¸Ðµ ÑÑÐ¾Ð¹ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ.",
				["Enabled"] = "ÐÑ Ð²ÐºÐ»ÑÑÐ¸Ð»Ð¸ Ð¿ÐµÑÐµÐºÑÐµÑÑÐ¸Ðµ.",
                ["Disabled"] = "ÐÑ Ð¾ÑÐºÐ»ÑÑÐ¸Ð»Ð¸ Ð¿ÐµÑÐµÐºÑÐµÑÑÐ¸Ðµ.",
				["crosshair1"] = "ÐÑ ÑÑÑÐ°Ð½Ð¾Ð²Ð¸Ð»Ð¸ Ð¿ÐµÑÐµÐºÑÐµÑÑÐ¸Ðµ â1.",
				["crosshair2"] = "ÐÑ ÑÑÑÐ°Ð½Ð¾Ð²Ð¸Ð»Ð¸ Ð¿ÐµÑÐµÐºÑÐµÑÑÐ¸Ðµ â2.",
				["crosshair3"] = "ÐÑ ÑÑÑÐ°Ð½Ð¾Ð²Ð¸Ð»Ð¸ Ð¿ÐµÑÐµÐºÑÐµÑÑÐ¸Ðµ â3.",
				["crosshair4"] = "ÐÑ ÑÑÑÐ°Ð½Ð¾Ð²Ð¸Ð»Ð¸ Ð¿ÐµÑÐµÐºÑÐµÑÑÐ¸Ðµ â4.",
				["crosshair5"] = "ÐÑ ÑÑÑÐ°Ð½Ð¾Ð²Ð¸Ð»Ð¸ Ð¿ÐµÑÐµÐºÑÐµÑÑÐ¸Ðµ â5.",
				["crosshair6"] = "ÐÑ ÑÑÑÐ°Ð½Ð¾Ð²Ð¸Ð»Ð¸ Ð¿ÐµÑÐµÐºÑÐµÑÑÐ¸Ðµ â6.",
				["crosshair7"] = "ÐÑ ÑÑÑÐ°Ð½Ð¾Ð²Ð¸Ð»Ð¸ Ð¿ÐµÑÐµÐºÑÐµÑÑÐ¸Ðµ â7.",
				["crosshair8"] = "ÐÑ ÑÑÑÐ°Ð½Ð¾Ð²Ð¸Ð»Ð¸ Ð¿ÐµÑÐµÐºÑÐµÑÑÐ¸Ðµ â8."
            }, this, "ru");
        }

        #endregion
		
		#region Commands
		
		/////Crosshair/////
		private void cmdChatCrosshair(BasePlayer player)
		{
			if (usePermissions && !IsAllowed(player.UserIDString, permShowCrosshair))
            {
                Reply(player, Lang("NoPermission", player.UserIDString));
                return;
            }
			if (EnableCross(player))
			{
                DisabledCrosshair(player);
			}
            else
			{
                EnabledCrosshair(player);
			}
        }
		////ShowMenu////
		private void cmdChatShowMenu(BasePlayer player)
		{
			if (usePermissions && !IsAllowed(player.UserIDString, permShowCrosshair))
            {
                Reply(player, Lang("NoPermission", player.UserIDString));
                return;
            }
			if (EnableMenu(player))
			{
                DisabledMenu(player);
			}
            else
			{
                EnabledMenu(player);
				if(EnableSound)Effect.server.Run(SoundOpen, player.transform.position, Vector3.zero, null, false);
			}
        }
		[ConsoleCommand("ShowMenu")]
        private void cmdConsoleShowMenu(ConsoleSystem.Arg arg)
	    {
			var player = arg.Player();
			cmdChatShowMenu(player);
	    }
		////CloseMenu////
		[ConsoleCommand("CloseMenu")]
        void cmdConsoleCloseMenu(ConsoleSystem.Arg arg)
	    {
		    var player = arg.Player();
		    DisabledMenu(player);
	    }
		////Commands////
		[ConsoleCommand("command1")]
        void cmdConsoleCommand1(ConsoleSystem.Arg arg)
        {
			var player = arg.Player();
			DestroyCrosshair(player);
		    Crosshair1(player);
			if(EnableSound)Effect.server.Run(SoundSelect, player.transform.position, Vector3.zero, null, false);
			if(ShowMessage)Reply(player, Lang("crosshair1", player.UserIDString));
        }
        [ConsoleCommand("command2")]
        void cmdConsoleCommand2(ConsoleSystem.Arg arg)
        {
			var player = arg.Player();
			DestroyCrosshair(player);
		    Crosshair2(player);
			if(EnableSound)Effect.server.Run(SoundSelect, player.transform.position, Vector3.zero, null, false);
			if(ShowMessage)Reply(player, Lang("crosshair2", player.UserIDString));
        }
        [ConsoleCommand("command3")]
        void cmdConsoleCommand3(ConsoleSystem.Arg arg)
        {
		    var player = arg.Player();
			DestroyCrosshair(player);
		    Crosshair3(player);
			if(EnableSound)Effect.server.Run(SoundSelect, player.transform.position, Vector3.zero, null, false);
			if(ShowMessage)Reply(player, Lang("crosshair3", player.UserIDString));
        }
        [ConsoleCommand("command4")]
        void cmdConsoleCommand4(ConsoleSystem.Arg arg)
		{
		    var player = arg.Player();
			DestroyCrosshair(player);
		    Crosshair4(player);
			if(EnableSound)Effect.server.Run(SoundSelect, player.transform.position, Vector3.zero, null, false);
			if(ShowMessage)Reply(player, Lang("crosshair4", player.UserIDString));
	    }
		[ConsoleCommand("command5")]
        void cmdConsoleCommand5(ConsoleSystem.Arg arg)
        {
			var player = arg.Player();
			DestroyCrosshair(player);
		    Crosshair5(player);
			if(EnableSound)Effect.server.Run(SoundSelect, player.transform.position, Vector3.zero, null, false);
			if(ShowMessage)Reply(player, Lang("crosshair5", player.UserIDString));
        }
        [ConsoleCommand("command6")]
        void cmdConsoleCommand6(ConsoleSystem.Arg arg)
        {
			var player = arg.Player();
			DestroyCrosshair(player);
		    Crosshair6(player);
			if(EnableSound)Effect.server.Run(SoundSelect, player.transform.position, Vector3.zero, null, false);
			if(ShowMessage)Reply(player, Lang("crosshair6", player.UserIDString));
        }
        [ConsoleCommand("command7")]
        void cmdConsoleCommand7(ConsoleSystem.Arg arg)
        {
		    var player = arg.Player();
			DestroyCrosshair(player);
		    Crosshair7(player);
			if(EnableSound)Effect.server.Run(SoundSelect, player.transform.position, Vector3.zero, null, false);
			if(ShowMessage)Reply(player, Lang("crosshair7", player.UserIDString));
        }
        [ConsoleCommand("command8")]
        void cmdConsoleCommand8(ConsoleSystem.Arg arg)
		{
		    var player = arg.Player();
			DestroyCrosshair(player);
		    Crosshair8(player);
			if(EnableSound)Effect.server.Run(SoundSelect, player.transform.position, Vector3.zero, null, false);
			if(ShowMessage)Reply(player, Lang("crosshair8", player.UserIDString));
	    }
		[ConsoleCommand("commandNext")]
        void cmdConsoleCommandNext(ConsoleSystem.Arg arg)
		{
		    var player = arg.Player();
			DestroyGUImenu(player);
			NextMenu(player, null);
			if(EnableSound)Effect.server.Run(SoundToggle, player.transform.position, Vector3.zero, null, false);
	    }
		[ConsoleCommand("commandBack")]
        void cmdConsoleCommandBack(ConsoleSystem.Arg arg)
		{
		    var player = arg.Player();
			DestroyGUImenu(player);
			ShowMenu(player, null);
			if(EnableSound)Effect.server.Run(SoundToggle, player.transform.position, Vector3.zero, null, false);
	    }
		[ConsoleCommand("commandDisable")]
        void cmdConsoleCommandDisable(ConsoleSystem.Arg arg)
		{
		    var player = arg.Player();
			DestroyCrosshair(player);
			if(EnableSound)Effect.server.Run(SoundDisable, player.transform.position, Vector3.zero, null, false);
			if(ShowMessage)Reply(player, Lang("Disabled", player.UserIDString));
	    }
		
		#endregion
		
		#region Hooks
		
		private void OnPlayerInit(BasePlayer player)
        {
			if (player.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot))
			{
				timer.Once(2, () => OnPlayerInit(player));
				return;
			}
            if (usePermissions && !IsAllowed(player.UserIDString, permShowCrosshair))
            {
                return;
            }
			if (ShowOnLogin)
		    {
				EnabledCrosshair(player);
		    }
			if (KeyBindSet)
            {
                player.Command("bind " + keybind + " \"ShowMenu\"");
            }
	    }
		private void OnPlayerDisconnected(BasePlayer player)
	    {
			if (Menu.Contains(player.userID))
            {
			    if (KeyBindSet)
                {
			        player.SendConsoleCommand("bind " + keybind + " \"\"");
			    }
                Menu.Remove(player.userID);
			    DestroyAll(player);
			    return;
			}
	    }
		private void Unload()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                Menu.Remove(player.userID);
				DestroyAll(player);
				return;
            }
        }
		private void DestroyAll(BasePlayer player)
	    {
			DestroyGUImenu(player);
		    DestroyCrosshair(player);
	    }
		private void DestroyCrosshair(BasePlayer player)
	    {
		    CuiHelper.DestroyUi(player, "image1");
			CuiHelper.DestroyUi(player, "image2");
			CuiHelper.DestroyUi(player, "image3");
			CuiHelper.DestroyUi(player, "image4");
			CuiHelper.DestroyUi(player, "image5");
			CuiHelper.DestroyUi(player, "image6");
			CuiHelper.DestroyUi(player, "image7");
			CuiHelper.DestroyUi(player, "image8");
	    }
		private void DestroyGUImenu(BasePlayer player)
		{
			CuiHelper.DestroyUi(player, "GUImenu");
			CuiHelper.DestroyUi(player, "GUImenu2");
		}
		private void EnabledCrosshair(BasePlayer player)
        {
            if (!Cross.Contains(player.userID))
            {
                Cross.Add(player.userID);
				DestroyCrosshair(player);
				player.SendConsoleCommand("command1");
            }
        }
        private void DisabledCrosshair(BasePlayer player)
        {
            if (Cross.Contains(player.userID))
            {
                Cross.Remove(player.userID);
			    player.SendConsoleCommand("commandDisable");
            }
        }
		private void EnabledMenu(BasePlayer player)
        {
            if (!Menu.Contains(player.userID))
            {
                Menu.Add(player.userID);
				DestroyGUImenu(player);
		        ShowMenu(player, null);
            }
        }
        private void DisabledMenu(BasePlayer player)
        {
            if (Menu.Contains(player.userID))
            {
                Menu.Remove(player.userID);
			    DestroyGUImenu(player);
            }
        }
		
		#endregion
		
		#region Crosshair
		
	    private void Crosshair1(BasePlayer player)
        {
		    var elements = new CuiElementContainer();
            elements.Add(new CuiElement
            {
                Name = "image1",
				Parent = "Hud.Under",
                Components =
                {
                    new CuiRawImageComponent 
					{ 
						Color = "1 1 1 1", 
						Url = image1,
						Sprite = "assets/content/textures/generic/fulltransparent.tga" 
					},
                    new CuiRectTransformComponent 
					{ 
						AnchorMin = "0.490 0.4812",
                        AnchorMax = "0.509 0.517"
					}
                }
            });
			CuiHelper.AddUi(player, elements);
		}
		private void Crosshair2(BasePlayer player)
        {
		    var elements = new CuiElementContainer();
			elements.Add(new CuiElement
            {
                Name = "image2",
				Parent = "Hud.Under",
                Components =
                {
                    new CuiRawImageComponent 
					{ 
						Color = "1 1 1 1", 
						Url = image2,
						Sprite = "assets/content/textures/generic/fulltransparent.tga" 
					},
                    new CuiRectTransformComponent 
					{ 
						AnchorMin = "0.490 0.4812",
                        AnchorMax = "0.509 0.517"
					}
                }
            });
			CuiHelper.AddUi(player, elements);
		}
		private void Crosshair3(BasePlayer player)
        {
		    var elements = new CuiElementContainer();
			elements.Add(new CuiElement
            {
                Name = "image3",
				Parent = "Hud.Under",
                Components =
                {
                    new CuiRawImageComponent 
					{ 
						Color = "1 1 1 1", 
						Url = image3,
						Sprite = "assets/content/textures/generic/fulltransparent.tga" 
					},
                    new CuiRectTransformComponent 
					{ 
						AnchorMin = "0.490 0.4812",
                        AnchorMax = "0.509 0.517"
					}
                }
            });
			CuiHelper.AddUi(player, elements);
		}
		private void Crosshair4(BasePlayer player)
        {
		    var elements = new CuiElementContainer();
			elements.Add(new CuiElement
            {
                Name = "image4",
				Parent = "Hud.Under",
                Components =
                {
                    new CuiRawImageComponent 
					{ 
						Color = "1 1 1 1", 
						Url = image4,
						Sprite = "assets/content/textures/generic/fulltransparent.tga" 
					},
                    new CuiRectTransformComponent 
					{ 
						AnchorMin = "0.490 0.4812",
                        AnchorMax = "0.509 0.517"
					}
                }
            });
			CuiHelper.AddUi(player, elements);
		}
		private void Crosshair5(BasePlayer player)
        {
		    var elements = new CuiElementContainer();
            elements.Add(new CuiElement
            {
                Name = "image5",
				Parent = "Hud.Under",
                Components =
                {
                    new CuiRawImageComponent 
					{ 
						Color = "1 1 1 1", 
						Url = image5,
						Sprite = "assets/content/textures/generic/fulltransparent.tga" 
					},
                    new CuiRectTransformComponent 
					{ 
						AnchorMin = "0.490 0.4812",
                        AnchorMax = "0.509 0.517"
					}
                }
            });
			CuiHelper.AddUi(player, elements);
		}
		private void Crosshair6(BasePlayer player)
        {
		    var elements = new CuiElementContainer();
			elements.Add(new CuiElement
            {
                Name = "image6",
				Parent = "Hud.Under",
                Components =
                {
                    new CuiRawImageComponent 
					{ 
						Color = "1 1 1 1", 
						Url = image6,
						Sprite = "assets/content/textures/generic/fulltransparent.tga" 
					},
                    new CuiRectTransformComponent 
					{ 
						AnchorMin = "0.490 0.4812",
                        AnchorMax = "0.509 0.517"
					}
                }
            });
			CuiHelper.AddUi(player, elements);
		}
		private void Crosshair7(BasePlayer player)
        {
		    var elements = new CuiElementContainer();
			elements.Add(new CuiElement
            {
                Name = "image7",
				Parent = "Hud.Under",
                Components =
                {
                    new CuiRawImageComponent 
					{ 
						Color = "1 1 1 1", 
						Url = image7,
						Sprite = "assets/content/textures/generic/fulltransparent.tga" 
					},
                    new CuiRectTransformComponent 
					{ 
						AnchorMin = "0.490 0.4812",
                        AnchorMax = "0.509 0.517"
					}
                }
            });
			CuiHelper.AddUi(player, elements);
		}
		private void Crosshair8(BasePlayer player)
        {
		    var elements = new CuiElementContainer();
			elements.Add(new CuiElement
            {
                Name = "image8",
				Parent = "Hud.Under",
                Components =
                {
                    new CuiRawImageComponent 
					{ 
						Color = "1 1 1 1", 
						Url = image8,
						Sprite = "assets/content/textures/generic/fulltransparent.tga" 
					},
                    new CuiRectTransformComponent 
					{ 
						AnchorMin = "0.490 0.4812",
                        AnchorMax = "0.509 0.517"
					}
                }
            });
			CuiHelper.AddUi(player, elements);
		}
		
		#endregion
		
		#region GuiMenu
		
		/////////////////Menu1/////////////////////
		
		private void ShowMenu(BasePlayer player, string text)
        {
			var elements = new CuiElementContainer();
            var menu = elements.Add(new CuiPanel
            {
                Image =
                {
					FadeIn = 0.6f,
                    Color = colorBackground
                },
                RectTransform =
                {
                    AnchorMin = "0.2395 0.18",
                    AnchorMax = "0.761 0.4525"
                },
                CursorEnabled = true
            }, "Hud", "GUImenu"); 
			var buttonClose = new CuiButton
            {
                Button =
                {
                    Command = "CloseMenu",
					FadeIn = 0.6f,
                    Color = colorClose
                },
                RectTransform =
                {
                    AnchorMin = "0.402 -0.225",
                    AnchorMax = "0.596 -0.058"
                },
                Text =
                {
                    Text = "<color=#ff0000>C</color><color=#ff1a1a>l</color><color=#ff3333>o</color><color=#ff1a1a>s</color><color=#ff0000>e</color>",
	   /////rus/////Text = "<color=#ff0000>Ð</color><color=#ff1a1a>Ð°</color><color=#ff3333>Ðº</color><color=#ff4d4d>Ñ</color><color=#ff3333>Ñ</color><color=#ff1a1a>Ñ</color><color=#ff0000>Ñ</color>",
                    FontSize = 18,
					FadeIn = 0.6f,
                    Align = TextAnchor.MiddleCenter
                }
            };
			
			/////////////button///////////////////
			
            elements.Add(buttonClose, menu);
            {
				//button1
                elements.Add(new CuiButton
                {
                    Button =
                    {
                        Command = $"command1",
						FadeIn = 0.6f,
                        Color = "0 0 0 0"
                    },
                    RectTransform =
                    {
                        AnchorMin = $"0.0445 0.11",
                        AnchorMax = $"0.236 0.85"
                    },
                    Text =
                    {
                        Text = "<color=#46d100>S</color><color=#52f500>e</color><color=#66ff1a>l</color><color=#52f500>e</color><color=#46d100>c</color><color=#3aad00>t</color>",
		   /////rus/////Text = "<color=#3aad00>Ð</color><color=#46d100>Ñ</color><color=#52f500>Ð±</color><color=#66ff1a>Ñ</color><color=#52f500>Ð°</color><color=#46d100>Ñ</color><color=#3aad00>Ñ</color>",						
                        FontSize = 20,
						FadeIn = 0.6f,
                        Align = TextAnchor.LowerCenter
                    }
                }, menu);
				//button2
				elements.Add(new CuiButton
                {
                    Button =
                    {
                        Command = $"command2",
						FadeIn = 0.6f,
                        Color = "0 0 0 0"
                    },
                    RectTransform =
                    {
                        AnchorMin = $"0.282 0.11",
                        AnchorMax = $"0.476 0.85"
                    },
                    Text =
                    {
                        Text = "<color=#46d100>S</color><color=#52f500>e</color><color=#66ff1a>l</color><color=#52f500>e</color><color=#46d100>c</color><color=#3aad00>t</color>",
		   /////rus/////Text = "<color=#3aad00>Ð</color><color=#46d100>Ñ</color><color=#52f500>Ð±</color><color=#66ff1a>Ñ</color><color=#52f500>Ð°</color><color=#46d100>Ñ</color><color=#3aad00>Ñ</color>",						
                        FontSize = 20,
						FadeIn = 0.6f,
                        Align = TextAnchor.LowerCenter
                    }
                }, menu);
				//button3
				elements.Add(new CuiButton
                {
                    Button =
                    {
                        Command = $"command3",
						FadeIn = 0.6f,
                        Color = "0 0 0 0"
                    },
                    RectTransform =
                    {
                        AnchorMin = $"0.523 0.11",
                        AnchorMax = $"0.715 0.85"
                    },
                    Text =
                    {
                        Text = "<color=#46d100>S</color><color=#52f500>e</color><color=#66ff1a>l</color><color=#52f500>e</color><color=#46d100>c</color><color=#3aad00>t</color>",
		   /////rus/////Text = "<color=#3aad00>Ð</color><color=#46d100>Ñ</color><color=#52f500>Ð±</color><color=#66ff1a>Ñ</color><color=#52f500>Ð°</color><color=#46d100>Ñ</color><color=#3aad00>Ñ</color>",
                        FontSize = 20,
						FadeIn = 0.6f,
                        Align = TextAnchor.LowerCenter
                    }
                }, menu);
				//button4
				elements.Add(new CuiButton
                {
                    Button =
                    {
                        Command = $"command4",
						FadeIn = 0.6f,
                        Color = "0 0 0 0"
                    },
                    RectTransform =
                    {
                        AnchorMin = $"0.762 0.11",
                        AnchorMax = $"0.954 0.85"
                    },
                    Text =
                    {
                        Text = "<color=#46d100>S</color><color=#52f500>e</color><color=#66ff1a>l</color><color=#52f500>e</color><color=#46d100>c</color><color=#3aad00>t</color>",
		   /////rus/////Text = "<color=#3aad00>Ð</color><color=#46d100>Ñ</color><color=#52f500>Ð±</color><color=#66ff1a>Ñ</color><color=#52f500>Ð°</color><color=#46d100>Ñ</color><color=#3aad00>Ñ</color>",
                        FontSize = 20,
						FadeIn = 0.6f,
                        Align = TextAnchor.LowerCenter
                    }
                }, menu);
				//buttonDisable
				elements.Add(new CuiButton
                {
                    Button =
                    {
                        Command = $"commandDisable",
						FadeIn = 0.6f,
                        Color = colorDisable
                    },
                    RectTransform =
                    {
                        AnchorMin = "-0.003 -0.226",
                        AnchorMax = "0.192 -0.060"
                    },
                    Text =
                    {
                        Text = "<color=#fbff00>D</color><color=#fbff1a>i</color><color=#fcff33>s</color><color=#fcff4d>a</color><color=#fcff33>b</color><color=#fbff1a>l</color><color=#fbff00>e</color>",
		   /////rus/////Text = "<color=#e2e600>Ð</color><color=#fbff00>Ñ</color><color=#fbff1a>Ðº</color><color=#fcff33>Ð»</color><color=#fcff4d>Ñ</color><color=#fcff33>Ñ</color><color=#fbff1a>Ð¸</color><color=#fbff00>Ñ</color><color=#e2e600>Ñ</color>",
                        FontSize = 18,
						FadeIn = 0.6f,
                        Align = TextAnchor.MiddleCenter
                    }
                }, menu);
				//buttonNext
				elements.Add(new CuiButton
                {
                    Button =
                    {
                        Command = $"commandNext",
						FadeIn = 0.6f,
                        Color = colorToggle
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.805 -0.226",
                        AnchorMax = "1 -0.060"
                    },
                    Text =
                    {
                        Text = "<color=#0055ff>N</color><color=#1a66ff>e</color><color=#1a66ff>x</color><color=#0055ff>t</color>",
		   /////rus/////Text = "<color=#0055ff>Ð</color><color=#1a66ff>Ð°</color><color=#3377ff>Ð»</color><color=#1a66ff>Ðµ</color><color=#0055ff>Ðµ</color>",
                        FontSize = 18,
						FadeIn = 0.6f,
                        Align = TextAnchor.MiddleCenter
                    }
                }, menu);
				
				////////////////background///////////////
				
				//background1
				elements.Add(new CuiElement
                {
                    Name = menu,
					Parent = "Hud.Under",
			        Components =
                    {
                        new CuiRawImageComponent
				        { 
					        Color = "1 1 1 1",
							FadeIn = 0.3f,
							Url = background,
					        Sprite = "assets/content/textures/generic/fulltransparent.tga" 
				        },
                        new CuiRectTransformComponent 
				        { 
					        AnchorMin = $"0.2555 0.195",
                            AnchorMax = $"0.3705 0.44"
				        }
                    }
                });
				//background2
				elements.Add(new CuiElement
                {
                    Name = menu,
					Parent = "Hud.Under",
			        Components =
                    {
                        new CuiRawImageComponent
				        { 
					        Color = "1 1 1 1",
							FadeIn = 0.3f,
							Url = background,
					        Sprite = "assets/content/textures/generic/fulltransparent.tga" 
				        },
                        new CuiRectTransformComponent 
				        { 
					        AnchorMin = $"0.3805 0.195",
                            AnchorMax = $"0.4955 0.44"
				        }
                    }
                });
				//background3
				elements.Add(new CuiElement
                {
                    Name = menu,
					Parent = "Hud.Under",
			        Components =
                    {
                        new CuiRawImageComponent
				        { 
					        Color = "1 1 1 1",
							FadeIn = 0.3f,
							Url = background,
					        Sprite = "assets/content/textures/generic/fulltransparent.tga" 
				        },
                        new CuiRectTransformComponent 
				        { 
					        AnchorMin = $"0.5055 0.195",
                            AnchorMax = $"0.6205 0.44"
				        }
                    }
                });
				//background4
				elements.Add(new CuiElement
                {
                    Name = menu,
					Parent = "Hud.Under",
			        Components =
                    {
                        new CuiRawImageComponent
				        { 
					        Color = "1 1 1 1",
							FadeIn = 0.3f,
							Url = background,
					        Sprite = "assets/content/textures/generic/fulltransparent.tga" 
				        },
                        new CuiRectTransformComponent 
				        { 
					        AnchorMin = $"0.6305 0.195",
                            AnchorMax = $"0.7455 0.44"
				        }
                    }
                });
				
				////////////////image////////////////
				
				//image1
				elements.Add(new CuiElement
                {
                    Name = menu,
			        Components =
                    {
                        new CuiRawImageComponent
				        { 
					        Color = "1 1 1 1", 
					        Url = image1,
					        Sprite = "assets/content/textures/generic/fulltransparent.tga" 
				        },
                        new CuiRectTransformComponent 
				        { 
					        AnchorMin = $"0.294 0.295",
                            AnchorMax = $"0.335 0.365"
				        }
                    }
                });
				//image2
				elements.Add(new CuiElement
                {
                    Name = menu,
			        Components =
                    {
                        new CuiRawImageComponent
				        { 
					        Color = "1 1 1 1", 
					        Url = image2,
					        Sprite = "assets/content/textures/generic/fulltransparent.tga" 
				        },
                        new CuiRectTransformComponent 
				        { 
					        AnchorMin = $"0.42 0.295",
                            AnchorMax = $"0.46 0.365"
				        }
                    }
                });
				//image3
				elements.Add(new CuiElement
                {
                    Name = menu,
			        Components =
                    {
                        new CuiRawImageComponent
				        { 
					        Color = "1 1 1 1", 
					        Url = image3,
					        Sprite = "assets/content/textures/generic/fulltransparent.tga" 
				        },
                        new CuiRectTransformComponent 
				        { 
					        AnchorMin = $"0.545 0.295",
                            AnchorMax = $"0.585 0.365"
				        }
                    }
                });
				//image4
				elements.Add(new CuiElement
                {
                    Name = menu,
			        Components =
                    {
                        new CuiRawImageComponent
				        { 
					        Color = "1 1 1 1", 
					        Url = image4,
					        Sprite = "assets/content/textures/generic/fulltransparent.tga" 
				        },
                        new CuiRectTransformComponent 
				        { 
					        AnchorMin = $"0.666 0.295",
                            AnchorMax = $"0.710 0.365"
				        }
                    }
                });
				
				////////////MainBackground////////////////
				
				elements.Add(new CuiElement
                {
                    Name = menu,
					FadeOut = 0.3f,
				    Parent = "Hud.Under",
                    Components =
                    {
                        new CuiRawImageComponent 
					    { 
						    Color = "1 1 1 1", 
							FadeIn = 0.3f,
						    Url = background2,
						    Sprite = "assets/content/textures/generic/fulltransparent.tga" 
					    },
                        new CuiRectTransformComponent 
					    { 
						    AnchorMin = "0.2365 0.110",
                            AnchorMax = "0.7635 0.468"
					    }
                    }
                });
            }
            CuiHelper.AddUi(player, elements);
        }
		
		/////////////////Menu2/////////////////////
		
		private void NextMenu(BasePlayer player, string text)
        {
			var elements = new CuiElementContainer();
            var menu = elements.Add(new CuiPanel
            {
                Image =
                {
					FadeIn = 0.6f,
                    Color = colorBackground
                },
                RectTransform =
                {
                    AnchorMin = "0.2395 0.18",
                    AnchorMax = "0.761 0.4525"
                },
                CursorEnabled = true
            }, "Hud", "GUImenu2"); 
			var buttonClose = new CuiButton
            {
                Button =
                {
                    Command = "CloseMenu",
					FadeIn = 0.6f,
                    Color = colorClose
                },
                RectTransform =
                {
                    AnchorMin = "0.402 -0.225",
                    AnchorMax = "0.596 -0.058"
                },
                Text =
                {
                    Text = "<color=#ff0000>C</color><color=#ff1a1a>l</color><color=#ff3333>o</color><color=#ff1a1a>s</color><color=#ff0000>e</color>",
	   /////rus/////Text = "<color=#ff0000>Ð</color><color=#ff1a1a>Ð°</color><color=#ff3333>Ðº</color><color=#ff4d4d>Ñ</color><color=#ff3333>Ñ</color><color=#ff1a1a>Ñ</color><color=#ff0000>Ñ</color>",
                    FontSize = 18,
					FadeIn = 0.6f,
                    Align = TextAnchor.MiddleCenter
                }
            };
			
			/////////////button///////////////////
			
            elements.Add(buttonClose, menu);
            {
				//button5
                elements.Add(new CuiButton
                {
                    Button =
                    {
                        Command = $"command5",
						FadeIn = 0.6f,
                        Color = "0 0 0 0"
                    },
                    RectTransform =
                    {
                        AnchorMin = $"0.0445 0.11",
                        AnchorMax = $"0.236 0.85"
                    },
                    Text =
                    {
                        Text = "<color=#46d100>S</color><color=#52f500>e</color><color=#66ff1a>l</color><color=#52f500>e</color><color=#46d100>c</color><color=#3aad00>t</color>",
		   /////rus/////Text = "<color=#3aad00>Ð</color><color=#46d100>Ñ</color><color=#52f500>Ð±</color><color=#66ff1a>Ñ</color><color=#52f500>Ð°</color><color=#46d100>Ñ</color><color=#3aad00>Ñ</color>",						
                        FontSize = 20,
						FadeIn = 0.6f,
                        Align = TextAnchor.LowerCenter
                    }
                }, menu);
				//button6
				elements.Add(new CuiButton
                {
                    Button =
                    {
                        Command = $"command6",
						FadeIn = 0.6f,
                        Color = "0 0 0 0"
                    },
                    RectTransform =
                    {
                        AnchorMin = $"0.282 0.11",
                        AnchorMax = $"0.476 0.85"
                    },
                    Text =
                    {
                        Text = "<color=#46d100>S</color><color=#52f500>e</color><color=#66ff1a>l</color><color=#52f500>e</color><color=#46d100>c</color><color=#3aad00>t</color>",
		   /////rus/////Text = "<color=#3aad00>Ð</color><color=#46d100>Ñ</color><color=#52f500>Ð±</color><color=#66ff1a>Ñ</color><color=#52f500>Ð°</color><color=#46d100>Ñ</color><color=#3aad00>Ñ</color>",						
                        FontSize = 20,
						FadeIn = 0.6f,
                        Align = TextAnchor.LowerCenter
                    }
                }, menu);
				//button7
				elements.Add(new CuiButton
                {
                    Button =
                    {
                        Command = $"command7",
						FadeIn = 0.6f,
                        Color = "0 0 0 0"
                    },
                    RectTransform =
                    {
                        AnchorMin = $"0.523 0.11",
                        AnchorMax = $"0.715 0.85"
                    },
                    Text =
                    {
                        Text = "<color=#46d100>S</color><color=#52f500>e</color><color=#66ff1a>l</color><color=#52f500>e</color><color=#46d100>c</color><color=#3aad00>t</color>",
		   /////rus/////Text = "<color=#3aad00>Ð</color><color=#46d100>Ñ</color><color=#52f500>Ð±</color><color=#66ff1a>Ñ</color><color=#52f500>Ð°</color><color=#46d100>Ñ</color><color=#3aad00>Ñ</color>",
                        FontSize = 20,
						FadeIn = 0.6f,
                        Align = TextAnchor.LowerCenter
                    }
                }, menu);
				//button8
				elements.Add(new CuiButton
                {
                    Button =
                    {
                        Command = $"command8",
						FadeIn = 0.6f,
                        Color = "0 0 0 0"
                    },
                    RectTransform =
                    {
                        AnchorMin = $"0.762 0.11",
                        AnchorMax = $"0.954 0.85"
                    },
                    Text =
                    {
                        Text = "<color=#46d100>S</color><color=#52f500>e</color><color=#66ff1a>l</color><color=#52f500>e</color><color=#46d100>c</color><color=#3aad00>t</color>",
		   /////rus/////Text = "<color=#3aad00>Ð</color><color=#46d100>Ñ</color><color=#52f500>Ð±</color><color=#66ff1a>Ñ</color><color=#52f500>Ð°</color><color=#46d100>Ñ</color><color=#3aad00>Ñ</color>",
                        FontSize = 20,
						FadeIn = 0.6f,
                        Align = TextAnchor.LowerCenter
                    }
                }, menu);
				//buttonDisable
				elements.Add(new CuiButton
                {
                    Button =
                    {
                        Command = $"commandDisable",
						FadeIn = 0.6f,
                        Color = colorDisable
                    },
                    RectTransform =
                    {
                        AnchorMin = "-0.003 -0.226",
                        AnchorMax = "0.192 -0.060"
                    },
                    Text =
                    {
                        Text = "<color=#fbff00>D</color><color=#fbff1a>i</color><color=#fcff33>s</color><color=#fcff4d>a</color><color=#fcff33>b</color><color=#fbff1a>l</color><color=#fbff00>e</color>",
		   /////rus/////Text = "<color=#e2e600>Ð</color><color=#fbff00>Ñ</color><color=#fbff1a>Ðº</color><color=#fcff33>Ð»</color><color=#fcff4d>Ñ</color><color=#fcff33>Ñ</color><color=#fbff1a>Ð¸</color><color=#fbff00>Ñ</color><color=#e2e600>Ñ</color>",
                        FontSize = 18,
						FadeIn = 0.6f,
                        Align = TextAnchor.MiddleCenter
                    }
                }, menu);
				//buttonBack
				elements.Add(new CuiButton
                {
                    Button =
                    {
                        Command = $"commandBack",
						FadeIn = 0.6f,
                        Color = colorToggle
                    },
                    RectTransform =
                    {
                        AnchorMin = "0.805 -0.226",
                        AnchorMax = "1 -0.060"
                    },
                    Text =
                    {
                        Text = "<color=#0055ff>B</color><color=#1a66ff>a</color><color=#1a66ff>c</color><color=#0055ff>k</color>",
		   /////rus/////Text = "<color=#0055ff>Ð</color><color=#1a66ff>Ð°</color><color=#3377ff>Ð·</color><color=#1a66ff>Ð°</color><color=#0055ff>Ð´</color>",
                        FontSize = 18,
						FadeIn = 0.6f,
                        Align = TextAnchor.MiddleCenter
                    }
                }, menu);
				
				////////////////background///////////////
				
				//background1
				elements.Add(new CuiElement
                {
                    Name = menu,
					Parent = "Hud.Under",
			        Components =
                    {
                        new CuiRawImageComponent
				        { 
					        Color = "1 1 1 1",
							FadeIn = 0.3f,
							Url = background,
					        Sprite = "assets/content/textures/generic/fulltransparent.tga" 
				        },
                        new CuiRectTransformComponent 
				        { 
					        AnchorMin = $"0.2555 0.195",
                            AnchorMax = $"0.3705 0.44"
				        }
                    }
                });
				//background2
				elements.Add(new CuiElement
                {
                    Name = menu,
					Parent = "Hud.Under",
			        Components =
                    {
                        new CuiRawImageComponent
				        { 
					        Color = "1 1 1 1",
							FadeIn = 0.3f,
							Url = background,
					        Sprite = "assets/content/textures/generic/fulltransparent.tga" 
				        },
                        new CuiRectTransformComponent 
				        { 
					        AnchorMin = $"0.3805 0.195",
                            AnchorMax = $"0.4955 0.44"
				        }
                    }
                });
				//background3
				elements.Add(new CuiElement
                {
                    Name = menu,
					Parent = "Hud.Under",
			        Components =
                    {
                        new CuiRawImageComponent
				        { 
					        Color = "1 1 1 1",
							FadeIn = 0.3f,
							Url = background,
					        Sprite = "assets/content/textures/generic/fulltransparent.tga" 
				        },
                        new CuiRectTransformComponent 
				        { 
					        AnchorMin = $"0.5055 0.195",
                            AnchorMax = $"0.6205 0.44"
				        }
                    }
                });
				//background4
				elements.Add(new CuiElement
                {
                    Name = menu,
					Parent = "Hud.Under",
			        Components =
                    {
                        new CuiRawImageComponent
				        { 
					        Color = "1 1 1 1",
							FadeIn = 0.3f,
							Url = background,
					        Sprite = "assets/content/textures/generic/fulltransparent.tga" 
				        },
                        new CuiRectTransformComponent 
				        { 
					        AnchorMin = $"0.6305 0.195",
                            AnchorMax = $"0.7455 0.44"
				        }
                    }
                });
				
				////////////////image////////////////
				
				//image5
				elements.Add(new CuiElement
                {
                    Name = menu,
			        Components =
                    {
                        new CuiRawImageComponent
				        { 
					        Color = "1 1 1 1", 
					        Url = image5,
					        Sprite = "assets/content/textures/generic/fulltransparent.tga" 
				        },
                        new CuiRectTransformComponent 
				        { 
					        AnchorMin = $"0.294 0.295",
                            AnchorMax = $"0.335 0.365"
				        }
                    }
                });
				//image6
				elements.Add(new CuiElement
                {
                    Name = menu,
			        Components =
                    {
                        new CuiRawImageComponent
				        { 
					        Color = "1 1 1 1", 
					        Url = image6,
					        Sprite = "assets/content/textures/generic/fulltransparent.tga" 
				        },
                        new CuiRectTransformComponent 
				        { 
					        AnchorMin = $"0.42 0.295",
                            AnchorMax = $"0.46 0.365"
				        }
                    }
                });
				//image7
				elements.Add(new CuiElement
                {
                    Name = menu,
			        Components =
                    {
                        new CuiRawImageComponent
				        { 
					        Color = "1 1 1 1", 
					        Url = image7,
					        Sprite = "assets/content/textures/generic/fulltransparent.tga" 
				        },
                        new CuiRectTransformComponent 
				        { 
					        AnchorMin = $"0.545 0.295",
                            AnchorMax = $"0.585 0.365"
				        }
                    }
                });
				//image8
				elements.Add(new CuiElement
                {
                    Name = menu,
			        Components =
                    {
                        new CuiRawImageComponent
				        { 
					        Color = "1 1 1 1", 
					        Url = image8,
					        Sprite = "assets/content/textures/generic/fulltransparent.tga" 
				        },
                        new CuiRectTransformComponent 
				        { 
					        AnchorMin = $"0.666 0.295",
                            AnchorMax = $"0.710 0.365"
				        }
                    }
                });
				
				////////////MainBackground////////////////
				
				elements.Add(new CuiElement
                {
                    Name = menu,
					FadeOut = 0.3f,
				    Parent = "Hud.Under",
                    Components =
                    {
                        new CuiRawImageComponent 
					    { 
						    Color = "1 1 1 1", 
							FadeIn = 0.3f,
						    Url = background2,
						    Sprite = "assets/content/textures/generic/fulltransparent.tga" 
					    },
                        new CuiRectTransformComponent 
					    { 
						    AnchorMin = "0.2365 0.110",
                            AnchorMax = "0.7635 0.468"
					    }
                    }
                });
            }
            CuiHelper.AddUi(player, elements);
        }
		
		#endregion
		 
		#region Helpers
		
        string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        void Reply(BasePlayer player, string message, string args = null) => PrintToChat(player, $"{message}", args);
		
		bool IsAllowed(string id, string perm) => permission.UserHasPermission(id, perm);
		
        #endregion
    }
}

// --- End of file: ShowCrosshair.cs ---
// --- Next file ---

// --- GitHub Source URL: https://github.com/RustyyTown/plugins/blob/main/IQChat-2.65.46.cs ---
// --- Original Local Path: IQChat-2.65.46.cs ---

using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using CompanionServer;
using ConVar;
using Facepunch;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;
using UnityEngine.Networking;
using Object = System.Object;
using Pool = Facepunch.Pool;

namespace Oxide.Plugins
{
    [Info("IQChat", "Mercury", "2.65.46")]
    [Description("The most pleasant chat for your server from the IQ system")]
    class IQChat : RustPlugin
    {
        //TODO: https://docs.rustapp.io/ru/dev/custom-alerts.html (добавить поддержку)
        //TODO: Добавить перевод префиксов
        /// <summary>
        /// Обновление 2.///
        /// - Добавлена возможность блокировать личный чат (pm, r) - если у игрока заблокирован чат, включается отдельно в конфигурации
        /// - Добавлен новый пункт в конфигурацию с возможностью отключить дополнительное логирование сообщений в RCON
        /// - Добавлена поддержка AutoEmoje by YaMang -w-
        /// - Добавлен новый хук : Object OnMessageIQChat(String message) - вызывается каждую отправку сообщения, позволяет получить и редактировать отправленное сообщение (нужно вернуть новый String)
        /// - Добавлен новый хук : void OnPlayerUnMuted(BasePlayer target, BasePlayer moderator) - вызывается после разблокировки чата игрока
        /// </summary>

        #region Reference
        [PluginReference] Plugin ImageLibrary, IQFakeActive, IQRankSystem, XLevels, Clans, XPrison, TranslationAPI, RustApp, SkillTree, PlayerRanks;
        
        #region Clans

        private String GetClanTag(BasePlayer.EncryptedValue<UInt64> playerID) => GetClanTag(playerID.Get());
        private String GetClanTag(UInt64 playerID)
        {
            if (!Clans) return String.Empty;
            if (!config.ReferenceSetting.ClansSettings.UseClanTag) return String.Empty;
            String ClanTag = (String)Clans?.CallHook("GetClanOf", playerID);
            if(String.IsNullOrWhiteSpace(ClanTag)) return String.Empty;
            String tagClan = GetLang("CLANS_SYNTAX_PREFIX", playerID.ToString(), ClanTag);
            
            Object resultColorMessage = IsGradientColorValue(config.ReferenceSetting.ClansSettings.colorTag);
            if (resultColorMessage is List<String> gradientColors)
                tagClan = ApplyGradientToText(tagClan, gradientColors);
            else tagClan = $"<color={config.ReferenceSetting.ClansSettings.colorTag}>{tagClan}</color>";

            return tagClan;
        }

        #endregion

        #region PlayerRanks

        private String PlayerRanks_GetRanks(BasePlayer player)
        {
            if (!PlayerRanks || !config.ReferenceSetting.playerRanksSettings.UsePlayerRanks) return String.Empty;
            String pRank = PlayerRanks.Call<String>("GetPlayerTitle", player.IPlayer);
            
            Object resultColorMessage = IsGradientColorValue(config.ReferenceSetting.playerRanksSettings.colorTag);
            if (resultColorMessage is List<String> gradientColors)
                pRank = ApplyGradientToText(pRank, gradientColors);
            else pRank = $"<color={config.ReferenceSetting.playerRanksSettings.colorTag}>{pRank}</color>";

            return pRank;
        }

        #endregion
        
        #region Skill Tree
        
        private String GetPrestigeLevel(UInt64 player)
        {
            if (!config.ReferenceSetting.skillTreeSettings.UsePrestigeSkillTree || !SkillTree) return String.Empty;
            Object prestige = SkillTree.Call("GetPrestigeLevel", player);
            if(prestige == null) return String.Empty;
            Int32 levelPrestige = (Int32)prestige;
            String prestigeResult = GetLang("SKILLTREE_SYNTAX_PRESTIGE_LEVEL", player.ToString(), levelPrestige);
            
            Object resultColorMessage = IsGradientColorValue(config.ReferenceSetting.skillTreeSettings.colorTag);
            if (resultColorMessage is List<String> gradientColors)
                prestigeResult = ApplyGradientToText(prestigeResult, gradientColors);
            else prestigeResult = $"<color={config.ReferenceSetting.skillTreeSettings.colorTag}>{prestigeResult}</color>";
            
            return prestigeResult;
        }
        private String SkillTree_GetLevel(BasePlayer player)
        {
            String[] infoSkills = GetInfoSkillTree(player);
            if(infoSkills == null) return String.Empty;
            String levelSkillTree = GetLang("SKILLTREE_SYNTAX_LEVEL", player.UserIDString, infoSkills.First());
            
            Object resultColorMessage = IsGradientColorValue(config.ReferenceSetting.skillTreeSettings.colorTag);
            if (resultColorMessage is List<String> gradientColors)
                levelSkillTree = ApplyGradientToText(levelSkillTree, gradientColors);
            else levelSkillTree = $"<color={config.ReferenceSetting.skillTreeSettings.colorTag}>{levelSkillTree}</color>";

            return levelSkillTree;
        }
        private String SkillTree_GetXP(BasePlayer player)
        {
            String[] infoSkills = GetInfoSkillTree(player);
            if(infoSkills == null) return String.Empty;
            String xpSkillTree = GetLang("SKILLTREE_SYNTAX_XP", player.UserIDString, infoSkills.Last());

            Object resultColorMessage = IsGradientColorValue(config.ReferenceSetting.skillTreeSettings.colorTag);
            if (resultColorMessage is List<String> gradientColors)
                xpSkillTree = ApplyGradientToText(xpSkillTree, gradientColors);
            else xpSkillTree = $"<color={config.ReferenceSetting.skillTreeSettings.colorTag}>{xpSkillTree}</color>";
            
            return xpSkillTree;
        }
        private String[] GetInfoSkillTree(BasePlayer player)
        {
            if (!SkillTree || !config.ReferenceSetting.skillTreeSettings.UseSkillTree) return null;
            return (String[])SkillTree.Call("ST_GetPlayerLevel", player);
        }

        #endregion
        
        #region XLevels

        private String XLevel_GetLevel(BasePlayer player)
        {
            if (!XLevels || !config.ReferenceSetting.XLevelsSettings.UseXLevels) return String.Empty;
            String level = GetLang("XLEVELS_SYNTAX_PREFIX", player.UserIDString, (Int32)XLevels?.CallHook("API_GetLevel", player));
            
            Object resultColorMessage = IsGradientColorValue(config.ReferenceSetting.XLevelsSettings.colorTag);
            if (resultColorMessage is List<String> gradientColors)
                level = ApplyGradientToText(level, gradientColors);
            else level = $"<color={config.ReferenceSetting.XLevelsSettings.colorTag}>{level}</color>";

            return level;
        }
        private String XLevel_GetPrefix(BasePlayer player)
        {
            if (!XLevels || !config.ReferenceSetting.XLevelsSettings.UseXLevels) return String.Empty;
            String xLevelPrefix = (String)XLevels?.CallHook("API_GetPlayerPrefix", player);
            
            Object resultColorMessage = IsGradientColorValue(config.ReferenceSetting.XLevelsSettings.colorTag);
            if (resultColorMessage is List<String> gradientColors)
                xLevelPrefix = ApplyGradientToText(xLevelPrefix, gradientColors);
            else xLevelPrefix = $"<color={config.ReferenceSetting.XLevelsSettings.colorTag}>{xLevelPrefix}</color>";

            return xLevelPrefix;
        }

        #endregion

        #region IQFakeActive
        
        public class FakePlayer
        {
            [JsonProperty("userId")] public String userId;
            [JsonProperty("displayName")] public String displayName;

            public Boolean isMuted;
        }

        public Boolean IsReadyIQFakeActive()
        {
            if (IQFakeActive != null && config.ReferenceSetting.IQFakeActiveSettings.UseIQFakeActive)
                return IQFakeActive.Call<Boolean>("IsReady");

            return false;
        }
        
        private List<FakePlayer> GetCombinedPlayerList()
        {
            if (!IsReadyIQFakeActive()) return null;
            JObject jsonData = IQFakeActive.Call<JObject>("GetListPlayers");
            
            if (!jsonData.TryGetValue("players", out JToken playersToken)) return null;
            List<FakePlayer> playerList = playersToken.ToObject<List<FakePlayer>>();
            return playerList;
        }
        
        private Boolean IsFakeUser(String idOrName)
        {
            if (!IsReadyIQFakeActive()) return false;
            return (Boolean)IQFakeActive.Call("IsFakeUser", idOrName);
        }

        private Boolean SetMuteFakeUser(String idOrName, Boolean isMuted)
        {
            if (!IsReadyIQFakeActive()) return false;
            return IQFakeActive.Call<Boolean>("MuteAction", idOrName, isMuted);
        }

        private String GetFakeName(String idOrName)
        {
            if (!IsReadyIQFakeActive()) return String.Empty;
            return (String)IQFakeActive.Call("GetFakeName", idOrName);
        }
        
        #endregion

        #region IQRankSystem

        String IQRankGetRank(BasePlayer.EncryptedValue<UInt64> userID) => IQRankGetRank(userID.Get());
        String IQRankGetRank(ulong userID) => (string)(IQRankSystem?.Call("API_GET_RANK_NAME", userID));
        String IQRankGetTimeGame(BasePlayer.EncryptedValue<UInt64> userID) => IQRankGetTimeGame(userID.Get());
        String IQRankGetTimeGame(ulong userID) => (string)(IQRankSystem?.Call("API_GET_TIME_GAME", userID));
        List<String> IQRankListKey(BasePlayer.EncryptedValue<UInt64> userID) => IQRankListKey(userID.Get());
        List<String> IQRankListKey(ulong userID) => (List<string>)(IQRankSystem?.Call("API_RANK_USER_KEYS", userID));
        String IQRankGetNameRankKey(string Key) => (string)(IQRankSystem?.Call("API_GET_RANK_NAME", Key));

        void IQRankSetRank(BasePlayer.EncryptedValue<UInt64> userID, string RankKey) => IQRankSetRank(userID.Get(), RankKey);
        void IQRankSetRank(ulong userID, string RankKey) => IQRankSystem?.Call("API_SET_ACTIVE_RANK", userID, RankKey);

        #endregion

        #region XPrison

        private String XPrison_GetPrefix(BasePlayer player)
        {
            if (!XPrison || !config.ReferenceSetting.xPrisonSettings.UseXPrison) return String.Empty;
            Boolean isPrisonPlayer = (Boolean)XPrison.CallHook("API_IsOnlinePrisoner", player.userID.Get());
            if (!isPrisonPlayer) return String.Empty;
            String prefixPrison = (String)XPrison.CallHook("API_GetOnlinePrisonerPrefix", player);
            if (String.IsNullOrWhiteSpace(prefixPrison)) return String.Empty;
            String resultPrefix = GetLang("XPRISON_SYNTAX_PREFIX", player.UserIDString, prefixPrison);
            
            Object resultColorMessage = IsGradientColorValue(config.ReferenceSetting.xPrisonSettings.colorTag);
            if (resultColorMessage is List<String> gradientColors)
                resultPrefix = ApplyGradientToText(resultPrefix, gradientColors);
            else resultPrefix = $"<color={config.ReferenceSetting.xPrisonSettings.colorTag}>{resultPrefix}</color>";

            return resultPrefix;
        }

        #endregion

        #endregion

        #region Vars

        private const Boolean LanguageEn = true;

        private static IQChat _;
        private static ImageUI _imageUI;
        public class TranslationState
        {
            public Boolean IsProcessed { get; set; }
            public String Translation { get; set; }
            public String DoTranslation { get; set; }
        }
        private Dictionary<String, TranslationState> saveTranslate = new();
        
        static Double CurrentTime => Facepunch.Math.Epoch.Current;
        public enum MuteType
        {
            Chat,
            Voice
        }
        private enum SelectedAction
        {
            Mute,
            Ignore
        }
        private enum SelectedParametres
        {
            DropList,
            Slider
        }
        private enum TakeElementUser
        {
            Prefix,
            Nick,
            Chat,
            Rank,
            MultiPrefix
        }
        private enum ElementsSettingsType
        {
            PM,
            Broadcast,
            Alert,
            Sound
        }
        public Dictionary<BasePlayer, BasePlayer> PMHistory = new Dictionary<BasePlayer, BasePlayer>();
        public Dictionary<BasePlayer, List<String>> LastMessagesChat = new Dictionary<BasePlayer, List<String>>();

        private const String PermissionUseCmdCnick = "iqchat.cnick";
        private const String PermissionUseCmdMsg = "iqchat.cmsg";
        private const String PermissionTranslationIgnore = "iqchat.translationignore";
        private const String PermissionHideMuteName = "iqchat.hidemutename";
        private const String PermissionHideOnline = "iqchat.onlinehide";
        private const String PermissionMute = "iqchat.muteuse";
        private const String PermissionAlert = "iqchat.alertuse";
        private const String PermissionRename = "iqchat.renameuse";
        private const String PermissionAntiSpam = "iqchat.antispamabuse";
        private const String PermissionHideConnection = "iqchat.hideconnection";
        private const String PermissionHideDisconnection = "iqchat.hidedisconnection";
        private const String PermissionMutedAdmin = "iqchat.adminmuted";
        class Response
        {
            [JsonProperty("country")]
            public string Country { get; set; }
        }
        public static StringBuilder sb = new StringBuilder();
        public string GetLang(string LangKey, string userID = null, params object[] args)
        {
            sb.Clear();
            if (args != null)
            {
                sb.AppendFormat(lang.GetMessage(LangKey, this, userID), args);
                return sb.ToString();
            }
            return lang.GetMessage(LangKey, this, userID);
        }
        #endregion
        
        #region Configuration

        private static Configuration config = new Configuration();
        private class Configuration
        {
            #region Controller Connection
            [JsonProperty(LanguageEn ? "Setting up player information" : "Настройка информации о игроке")]
            public ControllerConnection ControllerConnect = new ControllerConnection();
            internal class ControllerConnection
            {
                [JsonProperty(LanguageEn ? "Function switches" : "Перключатели функций")]
                public Turned Turneds = new Turned();
                [JsonProperty(LanguageEn ? "Setting Standard Values" : "Настройка стандартных значений")]
                public SetupDefault SetupDefaults = new SetupDefault();

                internal class SetupDefault
                {
                    [JsonProperty(LanguageEn ? "This prefix will be set if the player entered the server for the first time or in case of expiration of the rights to the prefix that he had earlier" : "Данный префикс установится если игрок впервые зашел на сервер или в случае окончания прав на префикс, который у него стоял ранее")]
                    public String PrefixDefault = "<color=#CC99FF>[ИГРОК]</color>";
                    [JsonProperty(LanguageEn ? "This nickname color will be set if the player entered the server for the first time or in case of expiration of the rights to the nickname color that he had earlier" : "Данный цвет ника установится если игрок впервые зашел на сервер или в случае окончания прав на цвет ника, который у него стоял ранее")]
                    public String NickDefault = "#33CCCC";
                    [JsonProperty(LanguageEn ? "This chat color will be set if the player entered the server for the first time or in case of expiration of the rights to the chat color that he had earlier" : "Данный цвет чата установится если игрок впервые зашел на сервер или в случае окончания прав на цвет чата, который у него стоял ранее")]
                    public String MessageDefault = "#0099FF";
                }
                internal class Turned
                {
                    [JsonProperty(LanguageEn ? "Set automatically a prefix to a player when he got the rights to it" : "Устанавливать автоматически префикс игроку, когда он получил права на него")]
                    public Boolean TurnAutoSetupPrefix;
                    [JsonProperty(LanguageEn ? "Set automatically the color of the nickname to the player when he got the rights to it" : "Устанавливать автоматически цвет ника игроку, когда он получил права на него")]
                    public Boolean TurnAutoSetupColorNick;
                    [JsonProperty(LanguageEn ? "Set the chat color automatically to the player when he got the rights to it" : "Устанавливать автоматически цвет чата игроку, когда он получил права на него")]
                    public Boolean TurnAutoSetupColorChat;
                    [JsonProperty(LanguageEn ? "Automatically reset the prefix when the player's rights to it expire" : "Сбрасывать автоматически префикс при окончании прав на него у игрока")]
                    public Boolean TurnAutoDropPrefix;
                    [JsonProperty(LanguageEn ? "Automatically reset the color of the nickname when the player's rights to it expire" : "Сбрасывать автоматически цвет ника при окончании прав на него у игрока")]
                    public Boolean TurnAutoDropColorNick;
                    [JsonProperty(LanguageEn ? "Automatically reset the color of the chat when the rights to it from the player expire" : "Сбрасывать автоматически цвет чата при окончании прав на него у игрока")]
                    public Boolean TurnAutoDropColorChat;
                }
            }
            #endregion

            #region Controller Parameters
            [JsonProperty(LanguageEn ? "Setting options for the player" : "Настройка параметров для игрока")]
            public ControllerParameters ControllerParameter = new ControllerParameters();
            internal class ControllerParameters
            {
                [JsonProperty(LanguageEn ? "Setting the display of options for player selection" : "Настройка отображения параметров для выбора игрока")]
                public VisualSettingParametres VisualParametres = new VisualSettingParametres();
                [JsonProperty(LanguageEn ? "List and customization of colors for a nickname" : "Список и настройка цветов для ника")]
                public List<AdvancedFuncion> NickColorList = new List<AdvancedFuncion>();
                [JsonProperty(LanguageEn ? "List and customize colors for chat messages" : "Список и настройка цветов для сообщений в чате")]
                public List<AdvancedFuncion> MessageColorList = new List<AdvancedFuncion>();
                [JsonProperty(LanguageEn ? "List and configuration of prefixes in chat" : "Список и настройка префиксов в чате")]
                public PrefixSetting Prefixes = new PrefixSetting();
                internal class PrefixSetting
                {
                    [JsonProperty(LanguageEn ? "Enable support for multiple prefixes at once (true - multiple prefixes can be set/false - only 1 can be set to choose from)" : "Включить поддержку нескольких префиксов сразу (true - можно установить несколько префиксов/false - установить можно только 1 на выбор)")]
                    public Boolean TurnMultiPrefixes;
                    [JsonProperty(LanguageEn ? "The maximum number of prefixes that can be set at a time (This option only works if setting multiple prefixes is enabled)" : "Максимальное количество префиксов, которое можно установить за раз(Данный параметр работает только если включена установка нескольких префиксов)")]
                    public Int32 MaximumMultiPrefixCount;
                    [JsonProperty(LanguageEn ? "List of prefixes and their settings" : "Список префиксов и их настройка")]
                    public List<AdvancedFuncion> Prefixes = new List<AdvancedFuncion>();
                }

                internal class AdvancedFuncion
                {
                    [JsonProperty(LanguageEn ? "Permission" : "Права")]
                    public String Permissions;
                    [JsonProperty(LanguageEn ? "Argument" : "Значение")]
                    public String Argument;
                    [JsonProperty(LanguageEn ? "Block the player's ability to select this parameter in the plugin menu (true - yes/false - no)" : "Заблокировать возможность выбрать данный параметр игроком в меню плагина (true - да/false - нет)")]
                    public Boolean IsBlockSelected;
                }

                internal class VisualSettingParametres
                {
                    [JsonProperty(LanguageEn ? "Player prefix selection display type - (0 - dropdown list, 1 - slider (Please note that if you have multi-prefix enabled, the dropdown list will be set))" : "Тип отображения выбора префикса для игрока - (0 - выпадающий список, 1 - слайдер (Учтите, что если у вас включен мульти-префикс, будет установлен выпадающий список))")]
                    public SelectedParametres PrefixType;
                    [JsonProperty(LanguageEn ? "Display type of player's nickname color selection - (0 - drop-down list, 1 - slider)" : "Тип отображения выбора цвета ника для игрока - (0 - выпадающий список, 1 - слайдер)")]
                    public SelectedParametres NickColorType;
                    [JsonProperty(LanguageEn ? "Display type of message color choice for the player - (0 - drop-down list, 1 - slider)" : "Тип отображения выбора цвета сообщения для игрока - (0 - выпадающий список, 1 - слайдер)")]
                    public SelectedParametres ChatColorType;
                    [JsonProperty(LanguageEn ? "IQRankSystem : Player rank selection display type - (0 - drop-down list, 1 - slider)" : "IQRankSystem : Тип отображения выбора ранга для игрока - (0 - выпадающий список, 1 - слайдер)")]
                    public SelectedParametres IQRankSystemType;
                }
            }
            #endregion

            #region Controller Mute
            [JsonProperty(LanguageEn ? "Plugin mute settings" : "Настройка мута в плагине")]
            public ControllerMute ControllerMutes = new ControllerMute();
            internal class ControllerMute
            {
                [JsonProperty(LanguageEn ? "Prohibit sending messages in /pm and /r if the player's chat is blocked" : "Запрещать отправлять сообщения в /pm, /r - если у игрока заблокирован чат")]
                public Boolean mutedPM;
                [JsonProperty(LanguageEn ? "Setting up automatic muting" : "Настройка автоматического мута")]
                public AutoMute AutoMuteSettings = new AutoMute();
                internal class AutoMute
                {
                    [JsonProperty(LanguageEn ? "Enable automatic muting for forbidden words (true - yes/false - no)" : "Включить автоматический мут по запрещенным словам(true - да/false - нет)")]
                    public Boolean UseAutoMute;
                    [JsonProperty(LanguageEn ? "Reason for automatic muting" : "Причина автоматического мута")]
                    public Muted AutoMuted;
                }
                [JsonProperty(LanguageEn ? "Additional setting for logging about mutes in discord" : "Дополнительная настройка для логирования о мутах в дискорд")]
                public LoggedFuncion LoggedMute = new LoggedFuncion();
                internal class LoggedFuncion
                {
                    [JsonProperty(LanguageEn ? "Support for logging the last N messages (Discord logging about mutes must be enabled)" : "Поддержка логирования последних N сообщений (Должно быть включено логирование в дискорд о мутах)")]
                    public Boolean UseHistoryMessage;
                    [JsonProperty(LanguageEn ? "How many latest player messages to send in logging" : "Сколько последних сообщений игрока отправлять в логировании")]
                    public Int32 CountHistoryMessage;
                }

                [JsonProperty(LanguageEn ? "Reasons to block chat" : "Причины для блокировки чата")]
                public List<Muted> MuteChatReasons = new List<Muted>();
                [JsonProperty(LanguageEn ? "Reasons to block your voice" : "Причины для блокировки голоса")]
                public List<Muted> MuteVoiceReasons = new List<Muted>();
                internal class Muted
                {
                    [JsonProperty(LanguageEn ? "Reason for blocking" : "Причина для блокировки")]
                    public String Reason;
                    [JsonProperty(LanguageEn ? "Block time (in seconds)" : "Время блокировки(в секундах)")]
                    public Int32 SecondMute;
                }
            }
            #endregion

            #region Controller Message
            [JsonProperty(LanguageEn ? "Configuring Message Processing" : "Настройка обработки сообщений")]
            public ControllerMessage ControllerMessages = new ControllerMessage();
            internal class ControllerMessage
            {
                [JsonProperty(LanguageEn ? "Basic settings for chat messages from the plugin" : "Основная настройка сообщений в чат от плагина")]
                public GeneralSettings GeneralSetting = new GeneralSettings();
                [JsonProperty(LanguageEn ? "Configuring functionality switching in chat" : "Настройка переключения функционала в чате")]
                public TurnedFuncional TurnedFunc = new TurnedFuncional();
                [JsonProperty(LanguageEn ? "Player message formatting settings" : "Настройка форматирования сообщений игроков")]
                public FormattingMessage Formatting = new FormattingMessage();
  
                
                internal class GeneralSettings
                {
                    [JsonProperty(LanguageEn ? "Notify the player in chat about receiving a prefix/nickname color/chat color (true - yes/false - no)" : "Уведомлять игрока в чате о получении префикса/цвета ника/цвета чата (true - да/false - нет)")]
                    public Boolean alertArgumentsInfoSetup;
                    [JsonProperty(LanguageEn ? "Notify the player in chat about the end of a prefix/nickname color/chat color (true - yes/false - no)" : "Уведомлять игрока в чате о окончании префикса/цвета ника/цвета чата (true - да/false - нет)")]
                    public Boolean alertArgumentsInfoRemove;
                    [JsonProperty(LanguageEn ? "Customizing the chat alert format" : "Настройка формата оповещения в чате")]
                    public BroadcastSettings BroadcastFormat = new BroadcastSettings();
                    [JsonProperty(LanguageEn ? "Setting the mention format in the chat, via @" : "Настройка формата упоминания в чате, через @")]
                    public AlertSettings AlertFormat = new AlertSettings();
                    [JsonProperty(LanguageEn ? "Additional setting" : "Дополнительная настройка")]
                    public OtherSettings OtherSetting = new OtherSettings();

                    internal class BroadcastSettings
                    {
                        [JsonProperty(LanguageEn ? "The name of the notification in the chat" : "Наименование оповещения в чат")]
                        public String BroadcastTitle;
                        [JsonProperty(LanguageEn ? "Chat alert message color" : "Цвет сообщения оповещения в чат")]
                        public String BroadcastColor;
                        [JsonProperty(LanguageEn ? "Steam64ID for chat avatar" : "Steam64ID для аватарки в чате")]
                        public String Steam64IDAvatar;
                    }
                    internal class AlertSettings
                    {
                        [JsonProperty(LanguageEn ? "The color of the player mention message in the chat" : "Цвет сообщения упоминания игрока в чате")]
                        public String AlertPlayerColor;
                        [JsonProperty(LanguageEn ? "Sound when receiving and sending a mention via @" : "Звук при при получении и отправки упоминания через @")]
                        public String SoundAlertPlayer;
                    }
                    internal class OtherSettings
                    {
                        [JsonProperty(LanguageEn ? "Time after which the message will be deleted from the UI from the administrator" : "Время,через которое удалится сообщение с UI от администратора")]
                        public Int32 TimeDeleteAlertUI;

                        [JsonProperty(LanguageEn ? "The size of the message from the player in the chat" : "Размер сообщения от игрока в чате")]
                        public Int32 SizeMessage = 14;
                        [JsonProperty(LanguageEn ? "Player nickname size in chat" : "Размер ника игрока в чате")]
                        public Int32 SizeNick = 14;
                        [JsonProperty(LanguageEn ? "The size of the player's prefix in the chat (will be used if <size=N></size> is not set in the prefix itself)" : "Размер префикса игрока в чате (будет использовано, если в самом префиксе не установвлен <size=N></size>)")]
                        public Int32 SizePrefix = 14;

                        [JsonProperty(LanguageEn ? "Nickname size according to privilege [permission] = size" : "Размер ника по привилегии [permission] = размер")]
                        public Dictionary<String, Int32> sizeNickPrivilages = new Dictionary<String, Int32>();
                        [JsonProperty(LanguageEn ? "Chat message size according to privilege [permission] = size" : "Размер сообщения в чате по привилегии [permission] = размер")]
                        public Dictionary<String, Int32> sizeMessagePrivilages = new Dictionary<String, Int32>();

                        public Int32 GetSizeNickOrMessage(BasePlayer player, Boolean nickOrMessage)
                        {
                            Dictionary<String, Int32> sizePrivilage =
                                nickOrMessage ? sizeNickPrivilages : sizeMessagePrivilages;

                            if(sizePrivilage != null && sizePrivilage.Count != 0)
                                foreach (KeyValuePair<String, Int32> privilage in sizePrivilage)
                                {
                                    if (_.permission.UserHasPermission(player.UserIDString, privilage.Key))
                                        return privilage.Value;
                                }

                            return nickOrMessage ? SizeNick : SizeMessage;
                        }
                    }
                }
                internal class TurnedFuncional
                {
                    [JsonProperty(LanguageEn ? "Configuring spam protection" : "Настройка защиты от спама")]
                    public AntiSpam AntiSpamSetting = new AntiSpam();
                    [JsonProperty(LanguageEn ? "Setting up a temporary chat block for newbies (who have just logged into the server)" : "Настройка временной блокировки чата новичкам (которые только зашли на сервер)")]
                    public AntiNoob AntiNoobSetting = new AntiNoob();
                    [JsonProperty(LanguageEn ? "Setting up private messages" : "Настройка личных сообщений")]
                    public PM PMSetting = new PM();

                    internal class AntiNoob
                    {
                        [JsonProperty(LanguageEn ? "Newbie protection in PM/R" : "Защита от новичка в PM/R")]
                        public Settings AntiNoobPM = new Settings();
                        [JsonProperty(LanguageEn ? "Newbie protection in global and team chat" : "Защита от новичка в глобальном и коммандном чате")]
                        public Settings AntiNoobChat = new Settings();
                        internal class Settings
                        {
                            [JsonProperty(LanguageEn ? "Enable protection?" : "Включить защиту?")]
                            public Boolean AntiNoobActivate = false;
                            [JsonProperty(LanguageEn ? "Newbie Chat Lock Time" : "Время блокировки чата для новичка")]
                            public Int32 TimeBlocked = 1200;
                        }
                    }
                    internal class AntiSpam
                    {
                        [JsonProperty(LanguageEn ? "Enable spam protection (Anti-spam)" : "Включить защиту от спама (Анти-спам)")]
                        public Boolean AntiSpamActivate;
                        [JsonProperty(LanguageEn ? "Time after which a player can send a message (AntiSpam)" : "Время через которое игрок может отправлять сообщение (АнтиСпам)")]
                        public Int32 FloodTime;
                        [JsonProperty(LanguageEn ? "Additional Anti-Spam settings" : "Дополнительная настройка Анти-Спама")]
                        public AntiSpamDuples AntiSpamDuplesSetting = new AntiSpamDuples();
                        internal class AntiSpamDuples
                        {
                            [JsonProperty(LanguageEn ? "Enable additional spam protection (Anti-duplicates, duplicate messages)" : "Включить дополнительную защиту от спама (Анти-дубликаты, повторяющие сообщения)")]
                            public Boolean AntiSpamDuplesActivate = true;
                            [JsonProperty(LanguageEn ? "How many duplicate messages does a player need to make to be confused by the system" : "Сколько дублирующих сообщений нужно сделать игроку чтобы его замутила система")]
                            public Int32 TryDuples = 3;
                            [JsonProperty(LanguageEn ? "Setting up automatic muting for duplicates" : "Настройка автоматического мута за дубликаты")]
                            public ControllerMute.Muted MuteSetting = new ControllerMute.Muted
                            {
                                Reason = LanguageEn ? "Blocking for duplicate messages (SPAM)" : "Блокировка за дублирующие сообщения (СПАМ)",
                                SecondMute = 300,
                            };
                        }
                    }
                    internal class PM
                    {
                        [JsonProperty(LanguageEn ? "Enable Private Messages" : "Включить личные сообщения")]
                        public Boolean PMActivate;
                        [JsonProperty(LanguageEn ? "Sound when receiving a private message" : "Звук при при получении личного сообщения")]
                        public String SoundPM;
                    }
                    [JsonProperty(LanguageEn ? "Enable PM ignore for players (/ignore nick or via interface)" : "Включить игнор ЛС игрокам(/ignore nick или через интерфейс)")]
                    public Boolean IgnoreUsePM;
                    [JsonProperty(LanguageEn ? "Hide the issue of items to the Admin from the chat" : "Скрыть из чата выдачу предметов Админу")]
                    public Boolean HideAdminGave;
                    [JsonProperty(LanguageEn ? "Move mute to team chat (In case of a mute, the player will not be able to write even to the team chat)" : "Переносить мут в командный чат(В случае мута, игрок не сможет писать даже в командный чат)")]
                    public Boolean MuteTeamChat;
                }
                internal class FormattingMessage
                {
                    [JsonProperty(LanguageEn ? "Enable message formatting [Will control caps, message format] (true - yes/false - no)" : "Включить форматирование сообщений [Будет контроллировать капс, формат сообщения] (true - да/false - нет)")]
                    public Boolean FormatMessage;
                    [JsonProperty(LanguageEn ? "Use a list of banned words (true - yes/false - no)" : "Использовать список запрещенных слов (true - да/false - нет)")]
                    public Boolean UseBadWords;
                    [JsonProperty(LanguageEn ? "The word that will replace the forbidden word" : "Слово которое будет заменять запрещенное слово")]
                    public String ReplaceBadWord;
                    [JsonProperty(LanguageEn ? "The list of forbidden words [Forbidden Word] = Whether to replace it in part of the word (for example, Vasya Fucking => Vasya ***) (true - yes/false - no)" : "Список запрещенных слов [ЗапрещенноеСлово] = Заменять ли его в части слова (например ВасяБля => Вася***) (true - да/false - нет)")]
                    public Dictionary<String, Boolean> BadWords = new Dictionary<String, Boolean>();

                    [JsonProperty(LanguageEn ? "Nickname controller setup" : "Настройка контроллера ников")]
                    public NickController ControllerNickname = new NickController();
                    internal class NickController
                    {
                        [JsonProperty(LanguageEn ? "Enable player nickname formatting (message formatting must be enabled)" : "Включить форматирование ников игроков (должно быть включено форматирование сообщений)")]
                        public Boolean UseNickController = true;
                        [JsonProperty(LanguageEn ? "The word that will replace the forbidden word (You can leave it blank and it will just delete)" : "Слово которое будет заменять запрещенное слово (Вы можете оставить пустым и будет просто удалять)")]
                        public String ReplaceBadNick = "****";
                        [JsonProperty(LanguageEn ? "The list of forbidden nicknames [Forbidden Word] = Whether to replace it in part of the word (for example, Vasya Fucking => Vasya ***) (true - yes/false - no)" : "Список запрещенных ников [ЗапрещенноеСлово] = Заменять ли его в части слова (например ВасяБля => Вася***) (true - да/false - нет)")]
                        public Dictionary<String, Boolean> BadNicks = new Dictionary<String, Boolean>();
                        [JsonProperty(LanguageEn ? "List of allowed links in nicknames" : "Список разрешенных ссылок в никах")]
                        public List<String> AllowedLinkNick = new List<String>();
                    }
                }
            }

            #endregion

            #region Controller Alert

            [JsonProperty(LanguageEn ? "Setting up chat alerts" : "Настройка оповещений в чате")]
            public ControllerAlert ControllerAlertSetting;

            internal class ControllerAlert
            {
                [JsonProperty(LanguageEn ? "Setting up chat alerts" : "Настройка оповещений в чате")]
                public Alert AlertSetting;
                [JsonProperty(LanguageEn ? "Setting notifications about the status of the player's session" : "Настройка оповещений о статусе сессии игрока")]
                public PlayerSession PlayerSessionSetting;
                [JsonProperty(LanguageEn ? "Configuring administrator session status alerts" : "Настройка оповещений о статусе сессии администратора")]
                public AdminSession AdminSessionSetting;
                [JsonProperty(LanguageEn ? "Setting up personal notifications to the player when connecting" : "Настройка персональных оповоещений игроку при коннекте")]
                public PersonalAlert PersonalAlertSetting;
                internal class Alert
                {
                    [JsonProperty(LanguageEn ? "Enable automatic messages in chat (true - yes/false - no)" : "Включить автоматические сообщения в чат (true - да/false - нет)")]
                    public Boolean AlertMessage;
                    [JsonProperty(LanguageEn ? "Type of automatic messages : true - sequential / false - random" : "Тип автоматических сообщений : true - поочередные/false - случайные")]
                    public Boolean AlertMessageType;

                    [JsonProperty(LanguageEn ? "List of automatic messages in chat" : "Список автоматических сообщений в чат")]
                    public LanguageController MessageList = new LanguageController();
                    [JsonProperty(LanguageEn ? "Interval for sending messages to chat (Broadcaster) (in seconds)" : "Интервал отправки сообщений в чат (Броадкастер) (в секундах)")]
                    public Int32 MessageListTimer;
                }
                internal class PlayerSession
                {
                    [JsonProperty(LanguageEn ? "When a player is notified about the entry / exit of the player, display his avatar opposite the nickname (true - yes / false - no)" : "При уведомлении о входе/выходе игрока отображать его аватар напротив ника (true - да/false - нет)")]
                    public Boolean ConnectedAvatarUse;

                    [JsonProperty(LanguageEn ? "Notify in chat when a player enters (true - yes/false - no)" : "Уведомлять в чате о входе игрока (true - да/false - нет)")]
                    public Boolean ConnectedAlert;
                    [JsonProperty(LanguageEn ? "Enable random notifications when a player from the list enters (true - yes / false - no)" : "Включить случайные уведомления о входе игрока из списка (true - да/false - нет)")]
                    public Boolean ConnectionAlertRandom;
                    [JsonProperty(LanguageEn ? "Show the country of the entered player (true - yes/false - no)" : "Отображать страну зашедшего игрока (true - да/false - нет")]
                    public Boolean ConnectedWorld;

                    [JsonProperty(LanguageEn ? "Notify when a player enters the chat (selected from the list) (true - yes/false - no)" : "Уведомлять о выходе игрока в чат(выбираются из списка) (true - да/false - нет)")]
                    public Boolean DisconnectedAlert;
                    [JsonProperty(LanguageEn ? "Enable random player exit notifications (true - yes/false - no)" : "Включить случайные уведомления о выходе игрока (true - да/false - нет)")]
                    public Boolean DisconnectedAlertRandom;
                    [JsonProperty(LanguageEn ? "Display reason for player exit (true - yes/false - no)" : "Отображать причину выхода игрока (true - да/false - нет)")]
                    public Boolean DisconnectedReason;

                    [JsonProperty(LanguageEn ? "Random player entry notifications({0} - player's nickname, {1} - country (if country display is enabled)" : "Случайные уведомления о входе игрока({0} - ник игрока, {1} - страна(если включено отображение страны)")]
                    public LanguageController RandomConnectionAlert = new LanguageController();
                    [JsonProperty(LanguageEn ? "Random notifications about the exit of the player ({0} - player's nickname, {1} - the reason for the exit (if the reason is enabled)" : "Случайные уведомления о выходе игрока({0} - ник игрока, {1} - причина выхода(если включена причина)")]
                    public LanguageController RandomDisconnectedAlert = new LanguageController();
                }
                internal class AdminSession
                {
                    [JsonProperty(LanguageEn ? "Notify admin on the server in the chat (true - yes/false - no)" : "Уведомлять о входе админа на сервер в чат (true - да/false - нет)")]
                    public Boolean ConnectedAlertAdmin;
                    [JsonProperty(LanguageEn ? "Notify about admin leaving the server in chat (true - yes/false - no)" : "Уведомлять о выходе админа на сервер в чат (true - да/false - нет)")]
                    public Boolean DisconnectedAlertAdmin;
                }
                internal class PersonalAlert
                {
                    [JsonProperty(LanguageEn ? "Enable random message to the player who has logged in (true - yes/false - no)" : "Включить случайное сообщение зашедшему игроку (true - да/false - нет)")]
                    public Boolean UseWelcomeMessage;
                    [JsonProperty(LanguageEn ? "List of messages to the player when entering" : "Список сообщений игроку при входе")]
                    public LanguageController WelcomeMessage = new LanguageController();
                }
            }

            public class LanguageController
            {
                [JsonProperty(LanguageEn ? "Setting up Multilingual Messages [Language Code] = Translation Variations" : "Настройка мультиязычных сообщений [КодЯзыка] = ВариацииПеревода")]
                public Dictionary<String, List<String>> LanguageMessages = new Dictionary<String, List<String>>();
            }

            #endregion

            #region Rust Plus
            [JsonProperty(LanguageEn ? "Settings Rust+" : "Настройка Rust+")]
            public RustPlus RustPlusSettings;
            internal class RustPlus
            {
                [JsonProperty(LanguageEn ? "Use Rust+" : "Использовать Rust+")]
                public Boolean UseRustPlus;
                [JsonProperty(LanguageEn ? "Title for notification Rust+" : "Название для уведомления Rust+")]
                public String DisplayNameAlert;
            }
            #endregion

            #region Reference Setting
            [JsonProperty(LanguageEn ? "Configuring support plugins" : "Настройка плагинов поддержки")]
            public ReferenceSettings ReferenceSetting = new ReferenceSettings();
            internal class ReferenceSettings
            {
                [JsonProperty(LanguageEn ? "Settings XLevels" : "Настройка XLevels")]
                public XLevels XLevelsSettings = new XLevels();
                [JsonProperty(LanguageEn ? "Settings IQFakeActive" : "Настройка IQFakeActive")]
                public IQFakeActive IQFakeActiveSettings = new IQFakeActive();
                [JsonProperty(LanguageEn ? "Settings IQRankSystem" : "Настройка IQRankSystem")]
                public IQRankSystem IQRankSystems = new IQRankSystem();
                [JsonProperty(LanguageEn ? "Settings Clans" : "Настройка Clans")]
                public Clans ClansSettings = new Clans();
                [JsonProperty(LanguageEn ? "Settings TranslationAPI" : "Настройка TranslationAPI")]
                public TranslataionApi translationApiSettings = new TranslataionApi();    
                [JsonProperty(LanguageEn ? "Settings SkillTree" : "Настройка SkillTree")]
                public SkillTree skillTreeSettings = new SkillTree();
                [JsonProperty(LanguageEn ? "Settings PlayerRanks" : "Настройка PlayerRanks")]
                public PlayerRanks playerRanksSettings = new PlayerRanks();
                [JsonProperty(LanguageEn ? "Settings XPrison" : "Настройка XPrison")]
                public XPrison xPrisonSettings = new XPrison();
                internal class TranslataionApi
                {
                    [JsonProperty(LanguageEn ? "To use automatic message translation using the TranslationAPI" : "Использовать автоматический перевод сообщений с помощью TranslataionAPI")]
                    public Boolean useTranslationApi;
                    [JsonProperty(LanguageEn ? "Translate team chat" : "Переводить командный чат")]
                    public Boolean translateTeamChat;
                    [JsonProperty(LanguageEn ? "Translate chat in private messages." : "Переводить чат в личных сообщениях")] 
                    public Boolean translatePmChat;
                    [JsonProperty(LanguageEn ? "The code for the preferred language (leave it empty, and then the translation will be done in each player's language)" : "Код приоритетного языка (оставьте пустым и тогда для каждого игрока будет переводиться на его языке клиента)")]
                    public String codeLanguagePrimary;
                }
                internal class Clans
                {
                    [JsonProperty(LanguageEn ? "Display a clan tag in the chat (if Clans are installed)" : "Отображать в чате клановый тэг (если установлены Clans)")]
                    public Boolean UseClanTag;
                    [JsonProperty(LanguageEn ? "The color of the additional tag" : "Цвет дополнительного тэга")]
                    public String colorTag;
                }
                internal class IQRankSystem
                {
                    [JsonProperty(LanguageEn ? "Rank display format in chat ( {0} is the user's rank, do not delete this value)" : "Формат отображения ранга в чате ( {0} - это ранг юзера, не удаляйте это значение)")]
                    public String FormatRank = "[{0}]";
                    [JsonProperty(LanguageEn ? "Time display format with IQRank System in chat ( {0} is the user's time, do not delete this value)" : "Формат отображения времени с IQRankSystem в чате ( {0} - это время юзера, не удаляйте это значение)")]
                    public String FormatRankTime = "[{0}]";
                    [JsonProperty(LanguageEn ? "Use support IQRankSystem" : "Использовать поддержку рангов")]
                    public Boolean UseRankSystem;
                    [JsonProperty(LanguageEn ? "Show players their played time next to their rank" : "Отображать игрокам их отыгранное время рядом с рангом")]
                    public Boolean UseTimeStandart;
                }
                internal class IQFakeActive
                {
                    [JsonProperty(LanguageEn ? "Use support IQFakeActive" : "Использовать поддержку IQFakeActive")]
                    public Boolean UseIQFakeActive;
                }
                internal class XLevels
                {
                    [JsonProperty(LanguageEn ? "Use support XLevels" : "Использовать поддержку XLevels")]
                    public Boolean UseXLevels;
                    [JsonProperty(LanguageEn ? "Use full prefix with level from XLevel (true) otherwise only level (false)" : "Использовать полный префикс с уровнем из XLevel (true) иначе только уровень (false)")]
                    public Boolean UseFullXLevels;
                    [JsonProperty(LanguageEn ? "The color of the additional tag" : "Цвет дополнительного тэга")]
                    public String colorTag;
                }
                
                internal class XPrison
                {
                    [JsonProperty(LanguageEn ? "Use support XPrison" : "Использовать поддержку XPrison")]
                    public Boolean UseXPrison;
                    [JsonProperty(LanguageEn ? "The color of the additional tag" : "Цвет дополнительного тэга")]
                    public String colorTag;
                }
                
                internal class SkillTree
                {
                    [JsonProperty(LanguageEn ? "Use support SkillTree" : "Использовать поддержку SkillTree")]
                    public Boolean UseSkillTree;
                    [JsonProperty(LanguageEn ? "Use full XP + Level information output (true), use only Level (false)" : "Использовать полный вывод информации XP + Level (true), использовать только Level (false)")]
                    public Boolean UseFullSkillTree;
                    [JsonProperty(LanguageEn ? "Use prestige" : "Использовать престиж")]
                    public Boolean UsePrestigeSkillTree;
                    [JsonProperty(LanguageEn ? "The color of the additional tag" : "Цвет дополнительного тэга")]
                    public String colorTag;
                }
                
                internal class PlayerRanks
                {
                    [JsonProperty(LanguageEn ? "Use support PlayerRanks" : "Использовать поддержку PlayerRanks")]
                    public Boolean UsePlayerRanks;
                    [JsonProperty(LanguageEn ? "The color of the additional tag" : "Цвет дополнительного тэга")]
                    public String colorTag;
                }
            }
            #endregion

            #region Anwser Setting

            [JsonProperty(LanguageEn ? "Setting up an answering machine" : "Настройка автоответчика")]
            public AnswerMessage AnswerMessages = new AnswerMessage();

            internal class AnswerMessage
            {
                [JsonProperty(LanguageEn ? "Enable auto-reply? (true - yes/false - no)" : "Включить автоответчик?(true - да/false - нет)")]
                public bool UseAnswer;
                [JsonProperty(LanguageEn ? "Customize Messages [Keyword] = Reply" : "Настройка сообщений [Ключевое слово] = Ответ")]
                public Dictionary<String, LanguageController> AnswerMessageList = new Dictionary<String, LanguageController>();
            }

            #endregion

            #region Other Setting

            [JsonProperty(LanguageEn ? "Disable additional chat duplication in RCON" : "Отключить дополнительное дублированиеи чата в RCON")]
            public Boolean disableRconBroadcast;
            [JsonProperty(LanguageEn ? "Additional setting" : "Дополнительная настройка")]
            public OtherSettings OtherSetting;

            internal class OtherSettings
            {
                [JsonProperty("SteamApiKey (https://steamcommunity.com/dev/apikey)")]
                public String renameSteamApiKey;
                [JsonProperty(LanguageEn ? "Enable the /online command (true - yes / false - no)" : "Включить команду /online (true - да/ false - нет)")]
                public Boolean UseCommandOnline;
                [JsonProperty(LanguageEn ? "Use shortened format /online (will only display quantity)" : "Использовать сокращенный формат /online (будет отображать только количество)")]
                public Boolean UseCommandShortOnline;
                [JsonProperty(LanguageEn ? "Compact logging of messages" : "Компактное логирование сообщений")]
                public CompactLoggetChat CompactLogsChat = new CompactLoggetChat();
                [JsonProperty(LanguageEn ? "Setting up message logging" : "Настройка логирования сообщений")]
                public LoggedChat LogsChat = new LoggedChat();
                [JsonProperty(LanguageEn ? "Setting up logging of personal messages of players" : "Настройка логирования личных сообщений игроков")]
                public General LogsPMChat = new General();
                [JsonProperty(LanguageEn ? "Setting up chat/voice lock/unlock logging" : "Настройка логирования блокировок/разблокировок чата/голоса")]
                public General LogsMuted = new General();
                [JsonProperty(LanguageEn ? "Setting up logging of chat commands from players" : "Настройка логирования чат-команд от игроков")]
                public General LogsChatCommands = new General();

                internal class CompactLoggetChat
                {
                    [JsonProperty(LanguageEn ? "Display Steam64ID in the log (true - yes/false - no)" : "Отображать в логе Steam64ID (true - да/false - нет)")]
                    public Boolean ShowSteamID;
                    [JsonProperty(LanguageEn ? "Setting up compact message logging" : "Настройка компактного логирования сообщений")]
                    public LoggedChat LogsCompactChat = new LoggedChat();
                }
                internal class LoggedChat
                {
                    [JsonProperty(LanguageEn ? "Setting up general chat logging" : "Настройка логирования общего чата")]
                    public General GlobalChatSettings = new General();
                    [JsonProperty(LanguageEn ? "Setting up team chat logging" : "Настройка логирования тим чата")]
                    public General TeamChatSettings = new General();
                }
                internal class General
                {
                    [JsonProperty(LanguageEn ? "Enable logging (true - yes/false - no)" : "Включить логирование (true - да/false - нет)")]
                    public Boolean UseLogged = false;
                    [JsonProperty(LanguageEn ? "Webhooks channel for logging" : "Webhooks канала для логирования")]
                    public String Webhooks = "";
                }
            }
            #endregion

            public static Configuration GetNewConfiguration()
            {
                return new Configuration
                {
                    #region Controller Parameter
                    ControllerParameter = new ControllerParameters
                    {
                        VisualParametres = new ControllerParameters.VisualSettingParametres
                        {
                            PrefixType = SelectedParametres.DropList,
                            ChatColorType = SelectedParametres.DropList,
                            NickColorType = SelectedParametres.Slider,
                            IQRankSystemType = SelectedParametres.Slider,
                        },
                        Prefixes = new ControllerParameters.PrefixSetting
                        {
                            TurnMultiPrefixes = false,
                            MaximumMultiPrefixCount = 5,
                            Prefixes = new List<ControllerParameters.AdvancedFuncion>
                              {
                                  new ControllerParameters.AdvancedFuncion
                                  {
                                      Argument = LanguageEn ? "<color=#CC99FF>[PLAYER]</color>" : "<color=#CC99FF>[ИГРОК]</color>",
                                      Permissions = "iqchat.default",
                                      IsBlockSelected = false,
                                  },
                                  new ControllerParameters.AdvancedFuncion
                                  {
                                      Argument = "<color=#ffff99>[VIP]</color>",
                                      Permissions = "iqchat.admin",
                                      IsBlockSelected = false,
                                  },
                                  new ControllerParameters.AdvancedFuncion
                                  {
                                      Argument = LanguageEn ? "<color=#ff9999>[ADMIN]</color>" : "<color=#ff9999>[АДМИН]</color>",
                                      Permissions = "iqchat.admin",
                                      IsBlockSelected = false,
                                  },
                            },
                        },
                        MessageColorList = new List<ControllerParameters.AdvancedFuncion>
                        {
                               new ControllerParameters.AdvancedFuncion
                               {
                                    Argument = "#CC99FF",
                                    Permissions = "iqchat.default",
                                    IsBlockSelected = false,
                               },
                               new ControllerParameters.AdvancedFuncion
                               {
                                    Argument = "#ffff99",
                                    Permissions = "iqchat.admin",
                                    IsBlockSelected = false,
                               },
                               new ControllerParameters.AdvancedFuncion
                               {
                                    Argument = "#ff9999",
                                    Permissions = "iqchat.admin",
                                    IsBlockSelected = false,
                               },
                        },
                        NickColorList = new List<ControllerParameters.AdvancedFuncion>
                        {
                               new ControllerParameters.AdvancedFuncion
                               {
                                    Argument = "#CC99FF",
                                    Permissions = "iqchat.default",
                                    IsBlockSelected = false,
                               },
                               new ControllerParameters.AdvancedFuncion
                               {
                                    Argument = "#ffff99",
                                    Permissions = "iqchat.admin",
                                    IsBlockSelected = false,
                               },
                               new ControllerParameters.AdvancedFuncion
                               {
                                    Argument = "#ff9999",
                                    Permissions = "iqchat.admin",
                                    IsBlockSelected = false,
                               },
                        },
                    },
                    #endregion

                    #region Controller Connect

                    ControllerConnect = new ControllerConnection
                    {
                        SetupDefaults = new ControllerConnection.SetupDefault
                        {
                            PrefixDefault = LanguageEn ? "<color=#CC99FF>[PLAYER]</color>" : "<color=#CC99FF>[ИГРОК]</color>",
                            MessageDefault = "#eee",
                            NickDefault = "#0099FF",
                        },
                        Turneds = new ControllerConnection.Turned
                        {
                            TurnAutoDropColorChat = true,
                            TurnAutoDropColorNick = true,
                            TurnAutoDropPrefix = true,
                            TurnAutoSetupColorChat = true,
                            TurnAutoSetupColorNick = true,
                            TurnAutoSetupPrefix = true,
                        }
                    },

                    #endregion

                    #region Controller Mute

                    ControllerMutes = new ControllerMute
                    {
                        mutedPM = false,
                        LoggedMute = new ControllerMute.LoggedFuncion
                        {
                            UseHistoryMessage = false,
                            CountHistoryMessage = 10,
                        },
                        AutoMuteSettings = new ControllerMute.AutoMute
                        {
                            UseAutoMute = true,
                            AutoMuted = new ControllerMute.Muted
                            {
                                Reason = LanguageEn ? "Automatic chat blocking" : "Автоматическая блокировка чата",
                                SecondMute = 300,
                            }
                        },
                        MuteChatReasons = new List<ControllerMute.Muted>
                        {
                            new ControllerMute.Muted
                            {
                                Reason = LanguageEn ? "Aggressive behavior" : "Агрессивное поведение",
                                SecondMute = 100,
                            },
                            new ControllerMute.Muted
                            {
                                Reason = LanguageEn ? "Insults" : "Оскорбления",
                                SecondMute = 300,
                            },
                            new ControllerMute.Muted
                            {
                                Reason = LanguageEn ? "Insult (repeated violation)" : "Оскорбление (повторное нарушение)",
                                SecondMute = 1000,
                            },
                            new ControllerMute.Muted
                            {
                                Reason = LanguageEn ? "Advertising" : "Реклама",
                                SecondMute = 5000,
                            },
                            new ControllerMute.Muted
                            {
                                Reason = LanguageEn ? "Humiliation" : "Унижение",
                                SecondMute = 300,
                            },
                            new ControllerMute.Muted
                            {
                                Reason = LanguageEn ? "Spam" : "Спам",
                                SecondMute = 60,
                            },
                        },
                        MuteVoiceReasons = new List<ControllerMute.Muted>
                        {
                            new ControllerMute.Muted
                            {
                                Reason = LanguageEn ? "Aggressive behavior" : "Агрессивное поведение",
                                SecondMute = 100,
                            },
                            new ControllerMute.Muted
                            {
                                Reason = LanguageEn ? "Insults" : "Оскорбления",
                                SecondMute = 300,
                            },
                            new ControllerMute.Muted
                            {
                                Reason = LanguageEn ? "Disruption of the event by shouting" : "Срыв мероприятия криками",
                                SecondMute = 300,
                            },
                        }
                    },

                    #endregion

                    #region Controller Message

                    ControllerMessages = new ControllerMessage
                    {
                        Formatting = new ControllerMessage.FormattingMessage
                        {
                            UseBadWords = true,
                            BadWords = LanguageEn ? new Dictionary<String, Boolean>() { ["fucking"] = false, ["sucking"] = false, ["fuckyou"] = false, ["fuck"] = true } : new Dictionary<String, Boolean>() { ["бля"] = false, ["сука"] = false, ["говно"] = false, ["нахуй"] = true },
                            FormatMessage = true, 
                            ReplaceBadWord = "***",
                            ControllerNickname = new ControllerMessage.FormattingMessage.NickController
                            {
                                BadNicks = LanguageEn ? new Dictionary<String, Boolean>() { ["Admin"] = true, ["Owner"] = true, ["Moderator"] = true, ["Helper"] = true } : new Dictionary<String, Boolean>() { ["Админ"] = true, ["Модератор"] = true, ["Модер"] = true, ["Хелпер"] = true },
                                AllowedLinkNick = new List<String> { "mysite.com" },
                                ReplaceBadNick = "",
                                UseNickController = true,
                            },
                        },
                        TurnedFunc = new ControllerMessage.TurnedFuncional
                        {
                            HideAdminGave = true,
                            IgnoreUsePM = true,
                            MuteTeamChat = true,
                            AntiNoobSetting = new ControllerMessage.TurnedFuncional.AntiNoob
                            {
                                AntiNoobChat = new ControllerMessage.TurnedFuncional.AntiNoob.Settings
                                {
                                    AntiNoobActivate = false,
                                    TimeBlocked = 1200,
                                },
                                AntiNoobPM = new ControllerMessage.TurnedFuncional.AntiNoob.Settings
                                {
                                    AntiNoobActivate = false,
                                    TimeBlocked = 1200,
                                },
                            },
                            AntiSpamSetting = new ControllerMessage.TurnedFuncional.AntiSpam
                            {
                                AntiSpamActivate = true,
                                FloodTime = 10,
                                AntiSpamDuplesSetting = new ControllerMessage.TurnedFuncional.AntiSpam.AntiSpamDuples
                                {
                                    AntiSpamDuplesActivate = true,
                                    MuteSetting = new ControllerMute.Muted
                                    {
                                        Reason = LanguageEn ? "Duplicate messages (SPAM)" : "Повторяющиеся сообщения (СПАМ)",
                                        SecondMute = 300,
                                    },
                                    TryDuples = 3,
                                }
                            },
                            PMSetting = new ControllerMessage.TurnedFuncional.PM
                            {
                                PMActivate = true,
                                SoundPM = "assets/bundled/prefabs/fx/notice/stack.world.fx.prefab",
                            },
                        },
                        GeneralSetting = new ControllerMessage.GeneralSettings
                        {
                            alertArgumentsInfoRemove = true,
                            alertArgumentsInfoSetup = true,
                            BroadcastFormat = new ControllerMessage.GeneralSettings.BroadcastSettings
                            {
                                BroadcastColor = "#efedee",
                                BroadcastTitle = LanguageEn ? "<color=#68cacd><b>[Alert]</b></color>" : "<color=#68cacd><b>[ОПОВЕЩЕНИЕ]</b></color>",
                                Steam64IDAvatar = "0",
                            },
                            AlertFormat = new ControllerMessage.GeneralSettings.AlertSettings
                            {
                                AlertPlayerColor = "#efedee",
                                SoundAlertPlayer = "assets/bundled/prefabs/fx/notice/item.select.fx.prefab",
                            },
                            OtherSetting = new ControllerMessage.GeneralSettings.OtherSettings
                            {
                                TimeDeleteAlertUI = 5,
                                SizePrefix = 14,
                                SizeMessage = 14,
                                SizeNick = 14,
                                sizeMessagePrivilages = new Dictionary<String, Int32>()
                                {
                                    ["iqchat.bigBoy"] = 16,
                                },
                                sizeNickPrivilages = new Dictionary<String, Int32>()
                                {
                                    ["iqchat.bigBoy"] = 16,
                                }
                            }
                        },
                    },

                    #endregion

                    #region Controller Alert

                    ControllerAlertSetting = new ControllerAlert
                    {
                        AlertSetting = new ControllerAlert.Alert
                        {
                            AlertMessage = true,
                            AlertMessageType = false,
                            MessageList = new LanguageController()
                            {
                                LanguageMessages = new Dictionary<String, List<String>>()
                                {
                                    ["en"] = new List<String>()
                                    {
                                        "Automatic message #1 (Edit in configuration)",
                                        "Automatic message #2 (Edit in configuration)",
                                        "Automatic message #3 (Edit in configuration)",
                                        "Automatic message #4 (Edit in configuration)",
                                        "Automatic message #5 (Edit in configuration)",
                                        "Automatic message #6 (Edit in configuration)",
                                    },
                                    ["ru"] = new List<String>()
                                    {
                                        "Автоматическое сообщение #1 (Редактировать в конфигурации)",
                                        "Автоматическое сообщение #2 (Редактировать в конфигурации)",
                                        "Автоматическое сообщение #3 (Редактировать в конфигурации)",
                                        "Автоматическое сообщение #4 (Редактировать в конфигурации)",
                                        "Автоматическое сообщение #5 (Редактировать в конфигурации)",
                                        "Автоматическое сообщение #6 (Редактировать в конфигурации)",
                                    }
                                },
                            },
                            MessageListTimer = 60,
                        },
                        AdminSessionSetting = new ControllerAlert.AdminSession
                        {
                            ConnectedAlertAdmin = false,
                            DisconnectedAlertAdmin = false,
                        },
                        PlayerSessionSetting = new ControllerAlert.PlayerSession
                        {
                            ConnectedAlert = true,
                            ConnectedAvatarUse = true,
                            ConnectedWorld = true,
                            ConnectionAlertRandom = false,

                            DisconnectedAlert = true,
                            DisconnectedAlertRandom = false,
                            DisconnectedReason = true,

                            RandomConnectionAlert = new LanguageController
                            {
                                LanguageMessages = new Dictionary<String, List<String>>()
                                {
                                    ["en"] = new List<String>()
                                    {
                                        "{0} flew in from {1}",
                                        "{0} flew into the server from{1}",
                                        "{0} jumped on a server"
                                    },
                                    ["ru"] = new List<String>()
                                    {
                                        "{0} влетел как дурачок из {1}",
                                        "{0} залетел на сервер из {1}, соболезнуем",
                                        "{0} прыгнул на сервачок"
                                    }
                                }
                            },
                            RandomDisconnectedAlert = new LanguageController()
                            {
                                LanguageMessages = new Dictionary<String, List<String>>()
                                {
                                    ["en"] = new List<String>()
                                    {
                                        "{0} gone to another world",
                                        "{0} left the server with a reason {1}",
                                        "{0} went to another server"
                                    },
                                    ["ru"] = new List<String>()
                                    {
                                        "{0} ушел в мир иной",
                                        "{0} вылетел с сервера с причиной {1}",
                                        "{0} пошел на другой сервачок"
                                    }
                                }
                            },
                        },
                        PersonalAlertSetting = new ControllerAlert.PersonalAlert
                        {
                            UseWelcomeMessage = true,
                            WelcomeMessage = new LanguageController
                            {
                                LanguageMessages = new Dictionary<String, List<String>>()
                                {
                                    ["en"] = new List<String>()
                                    {
                                        "Welcome to the server SUPERSERVER\nWe are glad that you chose us!",
                                        "Welcome back to the server!\nWe wish you good luck",
                                        "Welcome to the server\nWe have the best plugins",
                                    },
                                    ["ru"] = new List<String>()
                                    {
                                        "Добро пожаловать на сервер SUPERSERVER\nРады,что выбрал именно нас!",
                                        "С возвращением на сервер!\nЖелаем тебе удачи",
                                        "Добро пожаловать на сервер\nУ нас самые лучшие плагины",
                                    }
                                }
                            },
                        }
                    },

                    #endregion

                    #region Reference Setting

                    ReferenceSetting = new ReferenceSettings
                    {
                        playerRanksSettings = new ReferenceSettings.PlayerRanks()
                        {
                            UsePlayerRanks = false,
                            colorTag = "#FF0000, #FF3300, #FF6600, #FF9900, #FFCC00, #FFFF00, #CCFF00, #99FF00, #66FF00, #33FF00",
                        },
                        skillTreeSettings = new ReferenceSettings.SkillTree
                        {
                            UseSkillTree = false,
                            UseFullSkillTree = false,
                            UsePrestigeSkillTree = false,
                            colorTag = "#FF0000, #FF3300, #FF6600, #FF9900, #FFCC00, #FFFF00, #CCFF00, #99FF00, #66FF00, #33FF00",
                        },
                        translationApiSettings = new ReferenceSettings.TranslataionApi()
                        {
                            useTranslationApi = false,
                            translateTeamChat = false,
                            translatePmChat = true,
                            codeLanguagePrimary = "",
                        },
                        IQFakeActiveSettings = new ReferenceSettings.IQFakeActive
                        {
                            UseIQFakeActive = true,
                        },
                        IQRankSystems = new ReferenceSettings.IQRankSystem
                        {
                            FormatRank = "[{0}]",
                            FormatRankTime = "[{0}]",
                            UseRankSystem = false,
                            UseTimeStandart = true
                        },
                        xPrisonSettings = new ReferenceSettings.XPrison()
                        {
                            UseXPrison = false,
                            colorTag = "#FF0000, #FF3300, #FF6600, #FF9900, #FFCC00, #FFFF00, #CCFF00, #99FF00, #66FF00, #33FF00",
                        },
                        XLevelsSettings = new ReferenceSettings.XLevels()
                        {
                            UseXLevels = false,
                            UseFullXLevels = false,
                            colorTag = "#FF0000, #FF3300, #FF6600, #FF9900, #FFCC00, #FFFF00, #CCFF00, #99FF00, #66FF00, #33FF00",
                        },
                        ClansSettings = new ReferenceSettings.Clans()
                        {
                            UseClanTag = false,
                            colorTag = "#FF0000, #FF3300, #FF6600, #FF9900, #FFCC00, #FFFF00, #CCFF00, #99FF00, #66FF00, #33FF00",
                        }
                    },

                    #endregion

                    #region Rust Plus

                    RustPlusSettings = new RustPlus
                    {
                        UseRustPlus = true,
                        DisplayNameAlert = LanguageEn ? "SUPER SERVER" : "СУПЕР СЕРВЕР",
                    },

                    #endregion

                    #region Anwser Setting

                    AnswerMessages = new AnswerMessage
                    {
                        UseAnswer = true,
                        AnswerMessageList = new Dictionary<String, LanguageController>()
                        {
                            ["wipe"] = new LanguageController()
                            {
                                LanguageMessages = new Dictionary<String, List<String>>()
                                {
                                    ["en"] = new List<String>()
                                    {
                                        "Wipe will be 27.06"
                                    },
                                    ["ru"] = new List<String>()
                                    {
                                        "Вайп будет 27.06"
                                    }
                                }
                            },
                            ["читер"] = new LanguageController()
                            {
                                LanguageMessages = new Dictionary<String, List<String>>()
                                {
                                    ["en"] = new List<String>()
                                    {
                                        "Found a cheater? Write /report and send a complaint"
                                    },
                                    ["ru"] = new List<String>()
                                    {
                                        "Нашли читера?Напиши /report и отправь жалобу"
                                    }
                                }
                            }
                        },
                    },

                    #endregion

                    #region Other Setting
                    disableRconBroadcast = true,
                    OtherSetting = new OtherSettings
                    {
                        renameSteamApiKey = "",
                        UseCommandOnline = false,
                        UseCommandShortOnline = true,
                        CompactLogsChat = new OtherSettings.CompactLoggetChat
                        {
                            ShowSteamID = false,
                            LogsCompactChat = new OtherSettings.LoggedChat
                            {
                                GlobalChatSettings = new OtherSettings.General
                                {
                                    UseLogged = false,
                                    Webhooks = "",
                                },
                                TeamChatSettings = new OtherSettings.General
                                {
                                    UseLogged = false,
                                    Webhooks = "",
                                }
                            }
                        },
                        LogsChat = new OtherSettings.LoggedChat
                        {
                            GlobalChatSettings = new OtherSettings.General
                            {
                                UseLogged = false,
                                Webhooks = "",
                            },
                            TeamChatSettings = new OtherSettings.General
                            {
                                UseLogged = false,
                                Webhooks = "",
                            }
                        },
                        LogsChatCommands = new OtherSettings.General
                        {
                            UseLogged = false,
                            Webhooks = "",
                        },
                        LogsPMChat = new OtherSettings.General
                        {
                            UseLogged = false,
                            Webhooks = "",
                        },
                        LogsMuted = new OtherSettings.General
                        {
                            UseLogged = false,
                            Webhooks = "",
                        },
                    },

                    #endregion
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();

                if (config.OtherSetting.renameSteamApiKey == null)
                    config.OtherSetting.renameSteamApiKey = "";
                
                if (config.ControllerMessages.Formatting.BadWords == null ||
                    config.ControllerMessages.Formatting.BadWords.Count == 0)
                {
                    config.ControllerMessages.Formatting.BadWords = LanguageEn
                        ? new Dictionary<String, Boolean>()
                            { ["fucking"] = false, ["sucking"] = false, ["fuckyou"] = false, ["fuck"] = true }
                        : new Dictionary<String, Boolean>()
                            { ["бля"] = false, ["сука"] = false, ["говно"] = false, ["нахуй"] = true };
                }

                if (config.ControllerMessages.Formatting.ControllerNickname.BadNicks == null ||
                    config.ControllerMessages.Formatting.ControllerNickname.BadNicks.Count == 0)
                {
                    config.ControllerMessages.Formatting.ControllerNickname.BadNicks = LanguageEn
                        ? new Dictionary<String, Boolean>()
                            { ["Admin"] = true, ["Owner"] = true, ["Moderator"] = true, ["Helper"] = true }
                        : new Dictionary<String, Boolean>()
                            { ["Админ"] = true, ["Модератор"] = true, ["Модер"] = true, ["Хелпер"] = true };
                }

                if (config.ReferenceSetting.playerRanksSettings.colorTag == null)
                    config.ReferenceSetting.playerRanksSettings.colorTag =
                        "#FF0000, #FF3300, #FF6600, #FF9900, #FFCC00, #FFFF00, #CCFF00, #99FF00, #66FF00, #33FF00";
                
                if (config.ReferenceSetting.ClansSettings.colorTag == null)
                    config.ReferenceSetting.ClansSettings.colorTag =
                        "#FF0000, #FF3300, #FF6600, #FF9900, #FFCC00, #FFFF00, #CCFF00, #99FF00, #66FF00, #33FF00";
                
                if (config.ReferenceSetting.XLevelsSettings.colorTag == null)
                    config.ReferenceSetting.XLevelsSettings.colorTag =
                        "#FF0000, #FF3300, #FF6600, #FF9900, #FFCC00, #FFFF00, #CCFF00, #99FF00, #66FF00, #33FF00";
                
                if (config.ReferenceSetting.skillTreeSettings.colorTag == null)
                    config.ReferenceSetting.skillTreeSettings.colorTag =
                        "#FF0000, #FF3300, #FF6600, #FF9900, #FFCC00, #FFFF00, #CCFF00, #99FF00, #66FF00, #33FF00";

                if (config.ReferenceSetting.xPrisonSettings == null)
                {
                    config.ReferenceSetting.xPrisonSettings = new Configuration.ReferenceSettings.XPrison()
                    {
                        UseXPrison = false,
                        colorTag = "#FF0000, #FF3300, #FF6600, #FF9900, #FFCC00, #FFFF00, #CCFF00, #99FF00, #66FF00, #33FF00",
                    };
                }
                
                if (config.ReferenceSetting.xPrisonSettings.colorTag == null)
                    config.ReferenceSetting.xPrisonSettings.colorTag =
                        "#FF0000, #FF3300, #FF6600, #FF9900, #FFCC00, #FFFF00, #CCFF00, #99FF00, #66FF00, #33FF00";
            }
            catch
            {
                PrintWarning(LanguageEn
                    ? $"Error #132 read configuration 'oxide/config/{Name}', create a new configuration!!"
                    : $"Ошибка #132 чтения конфигурации 'oxide/config/{Name}', создаём новую конфигурацию!!");

                LoadDefaultConfig();
            }

            NextTick(SaveConfig);
        }

        private void RegisteredPermissions()
        {
            Configuration.ControllerParameters Controller = config.ControllerParameter;
            IEnumerable<Configuration.ControllerParameters.AdvancedFuncion> Parametres = Controller.Prefixes.Prefixes
                .Concat(Controller.NickColorList).Concat(Controller.MessageColorList);

            foreach (Configuration.ControllerParameters.AdvancedFuncion Permission in Parametres.Where(perm =>
                         !permission.PermissionExists(perm.Permissions, this)))
                permission.RegisterPermission(Permission.Permissions, this);
            
            foreach (KeyValuePair<String, Int32> sizeMessages in config.ControllerMessages.GeneralSetting.OtherSetting.sizeMessagePrivilages.Where(perm =>
                         !permission.PermissionExists(perm.Key, this)))
                permission.RegisterPermission(sizeMessages.Key, this);
            
            foreach (KeyValuePair<String, Int32> sizeNick in config.ControllerMessages.GeneralSetting.OtherSetting.sizeNickPrivilages.Where(perm =>
                         !permission.PermissionExists(perm.Key, this)))
                permission.RegisterPermission(sizeNick.Key, this);

            if (!permission.PermissionExists(PermissionUseCmdCnick, this))
                permission.RegisterPermission(PermissionUseCmdCnick, this);      
            if (!permission.PermissionExists(PermissionUseCmdMsg, this))
                permission.RegisterPermission(PermissionUseCmdMsg, this);  
            if (!permission.PermissionExists(PermissionTranslationIgnore, this))
                permission.RegisterPermission(PermissionTranslationIgnore, this);  
            if (!permission.PermissionExists(PermissionHideMuteName, this))
                permission.RegisterPermission(PermissionHideMuteName, this); 
            if (!permission.PermissionExists(PermissionHideOnline, this))
                permission.RegisterPermission(PermissionHideOnline, this);
            if (!permission.PermissionExists(PermissionRename, this))
                permission.RegisterPermission(PermissionRename, this);
            if (!permission.PermissionExists(PermissionMute, this))
                permission.RegisterPermission(PermissionMute, this);
            if (!permission.PermissionExists(PermissionAlert, this))
                permission.RegisterPermission(PermissionAlert, this);
            if (!permission.PermissionExists(PermissionAntiSpam, this))
                permission.RegisterPermission(PermissionAntiSpam, this);
            if (!permission.PermissionExists(PermissionHideConnection, this))
                permission.RegisterPermission(PermissionHideConnection, this);
            if (!permission.PermissionExists(PermissionHideDisconnection, this))
                permission.RegisterPermission(PermissionHideDisconnection, this);
            if (!permission.PermissionExists(PermissionMutedAdmin, this))
                permission.RegisterPermission(PermissionMutedAdmin, this);

            PrintWarning("Permissions - completed");
        }

        protected override void LoadDefaultConfig() => config = Configuration.GetNewConfiguration();
        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion

        #region Data
        public GeneralInformation GeneralInfo = new GeneralInformation();
        public Dictionary<UInt64, User> UserInformation = new Dictionary<UInt64, User>();
        public Dictionary<UInt64, AntiNoob> UserInformationConnection = new Dictionary<UInt64, AntiNoob>();
        internal class AntiNoob
        {
            public DateTime DateConnection = DateTime.UtcNow;

            public Boolean IsNoob(Int32 TimeBlocked)
            {
                System.TimeSpan Time = DateTime.UtcNow.Subtract(DateConnection);
                return Time.TotalSeconds < TimeBlocked;
            }

            public Double LeftTime(Int32 TimeBlocked)
            {
                System.TimeSpan Time = DateTime.UtcNow.Subtract(DateConnection);

                return (TimeBlocked - Time.TotalSeconds);
            }
        }
        public class User
        {
            public Information Info = new Information();
            public Setting Settings = new Setting();
            public Mute MuteInfo = new Mute();
            internal class Information
            {
                public String Prefix;
                public String ColorNick;
                public String ColorMessage;
                public String Rank;
                public String CustomColorNick;
                public String CustomColorMessage;

                public List<String> PrefixList = new List<String>();
            }

            internal class Setting
            {
                public Boolean TurnPM = true;
                public Boolean TurnAlert = true;
                public Boolean TurnBroadcast = true;
                public Boolean TurnSound = true;

                public List<UInt64> IgnoreUsers = new List<UInt64>();

                public Boolean IsIgnored(UInt64 TargetID) => IgnoreUsers.Contains(TargetID);
                public void IgnoredAddOrRemove(UInt64 TargetID)
                {
                    if (IsIgnored(TargetID))
                        IgnoreUsers.Remove(TargetID);
                    else IgnoreUsers.Add(TargetID);
                }
            }

            internal class Mute
            {
                public Double TimeMuteChat;
                public Double TimeMuteVoice;

                public Double GetTime(MuteType Type)
                {
                    Double TimeMuted = 0;
                    switch (Type)
                    {
                        case MuteType.Chat:
                            TimeMuted = TimeMuteChat - CurrentTime;
                            break;
                        case MuteType.Voice:
                            TimeMuted = TimeMuteVoice - CurrentTime;
                            break;
                        default:
                            break;
                    }
                    return TimeMuted;
                }
                public void SetMute(MuteType Type, Int32 Time)
                {
                    switch (Type)
                    {
                        case MuteType.Chat:
                            TimeMuteChat = Time + CurrentTime;
                            break;
                        case MuteType.Voice:
                            TimeMuteVoice = Time + CurrentTime;
                            break;
                        default:
                            break;
                    }
                }
                public void UnMute(MuteType Type)
                {
                    switch (Type)
                    {
                        case MuteType.Chat:
                            TimeMuteChat = 0;
                            break;
                        case MuteType.Voice:
                            TimeMuteVoice = 0;
                            break;
                        default:
                            break;
                    }
                }
                public Boolean IsMute(MuteType Type) => GetTime(Type) > 0;
            }
        }

        public class GeneralInformation
        {
            public Boolean TurnMuteAllChat;
            public Boolean TurnMuteAllVoice;

            public Dictionary<UInt64, RenameInfo> RenameList = new Dictionary<UInt64, RenameInfo>();
            internal class RenameInfo
            {
                public String RenameNick;
                public UInt64 RenameID;
            }
            
            public RenameInfo GetInfoRename(UInt64 UserID)
            {
                if (!RenameList.ContainsKey(UserID)) return null;
                return RenameList[UserID];
            }
        }
        private void MigrateDataToNoob()
        {
            if (config.ControllerMessages.TurnedFunc.AntiNoobSetting.AntiNoobPM.AntiNoobActivate || config.ControllerMessages.TurnedFunc.AntiNoobSetting.AntiNoobChat.AntiNoobActivate)
            {
                if (UserInformationConnection.Count == 0 || UserInformationConnection == null)
                {
                    PrintWarning(LanguageEn ? "Migration of old players to Anti-Nub.." : "Миграция старых игроков в Анти-Нуб..");
                    foreach (KeyValuePair<UInt64, User> InfoUser in UserInformation.Where(x => !UserInformationConnection.ContainsKey(x.Key)))
                        UserInformationConnection.Add(InfoUser.Key, new AntiNoob { DateConnection = new DateTime(2022, 1, 1) });
                    PrintWarning(LanguageEn ? "Migration of old players completed" : "Миграция старых игроков завершена");
                }
            }
        }
        private void UserConnecteionData(BasePlayer player)
        {
            if (config.ControllerMessages.TurnedFunc.AntiNoobSetting.AntiNoobPM.AntiNoobActivate || config.ControllerMessages.TurnedFunc.AntiNoobSetting.AntiNoobChat.AntiNoobActivate)
            {
                if (!UserInformationConnection.ContainsKey(player.userID))
                    UserInformationConnection.Add(player.userID, new AntiNoob());
            }

            if (GeneralInfo.RenameList.TryGetValue(player.userID, out GeneralInformation.RenameInfo value))
            {
                String nickname = value.RenameNick;
                RenameUpdate(player, nickname);
            }
            
            Configuration.ControllerConnection ControllerConntect = config.ControllerConnect;
            Configuration.ControllerParameters ControllerParameter = config.ControllerParameter;
            if (ControllerConntect == null || ControllerParameter == null) return;

            if (!UserInformation.ContainsKey(player.userID))
            {
                User Info = new User();
                if (ControllerConntect.Turneds.TurnAutoSetupPrefix)
                {
                    if (ControllerParameter.Prefixes.TurnMultiPrefixes)
                        Info.Info.PrefixList.Add(ControllerConntect.SetupDefaults.PrefixDefault ?? String.Empty);
                    else Info.Info.Prefix = ControllerConntect.SetupDefaults.PrefixDefault ?? String.Empty;
                }
                
                Info.Info.ColorNick = ControllerConntect.SetupDefaults.NickDefault ?? String.Empty;
                Info.Info.ColorMessage = ControllerConntect.SetupDefaults.MessageDefault ?? String.Empty;
                
                // if (ControllerConntect.Turneds.TurnAutoSetupColorNick)
                //     Info.Info.ColorNick = ControllerConntect.SetupDefaults.NickDefault ?? "#ffffff";
                // else Info.Info.ColorNick = "#ff3232";
                //
                // if (ControllerConntect.Turneds.TurnAutoSetupColorChat)
                //     Info.Info.ColorMessage = ControllerConntect.SetupDefaults.MessageDefault ?? "#ffffff";
                // else Info.Info.ColorMessage = "#ffffff";

                Info.Info.Rank = String.Empty;

                UserInformation.Add(player.userID, Info);
            }
            else
            {
                User User = UserInformation[player.userID];
                User.Info.ColorNick ??= ControllerConntect.SetupDefaults.NickDefault ?? String.Empty;
                User.Info.ColorMessage ??= ControllerConntect.SetupDefaults.MessageDefault ?? String.Empty;
            }
        }

        void ReadData()
        {
            if (!Oxide.Core.Interface.Oxide.DataFileSystem.ExistsDatafile("IQSystem/IQChat/Users") && Oxide.Core.Interface.Oxide.DataFileSystem.ExistsDatafile("IQChat/Users"))
            {
                GeneralInfo = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<GeneralInformation>("IQChat/Information");
                UserInformation = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<Dictionary<UInt64, User>>("IQChat/Users");

                Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQSystem/IQChat/Information", GeneralInfo);
                Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQSystem/IQChat/Users", UserInformation);

                PrintWarning(LanguageEn ? "Your player data has been moved to a new directory - IQSystem/IQChat , you can delete old data files!" : "Ваши данные игроков были перенесены в новую директорию - IQSystem/IQChat , вы можете удалить старые дата-файлы!");
            }

            GeneralInfo = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<GeneralInformation>("IQSystem/IQChat/Information");
            UserInformation = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<Dictionary<UInt64, User>>("IQSystem/IQChat/Users");
            UserInformationConnection = Oxide.Core.Interface.Oxide.DataFileSystem.ReadObject<Dictionary<UInt64, AntiNoob>>("IQSystem/IQChat/AntiNoob");
        }
        void WriteData()
        {
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQSystem/IQChat/Information", GeneralInfo);
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQSystem/IQChat/Users", UserInformation);
            Oxide.Core.Interface.Oxide.DataFileSystem.WriteObject("IQSystem/IQChat/AntiNoob", UserInformationConnection);
        }

        #endregion

        #region Hooks     

        private bool OnPlayerChat(BasePlayer player, string message, Chat.ChatChannel channel)
        {
            if (Interface.Oxide.CallHook("CanChatMessage", player, message) != null) return false;
            
            SeparatorChat(channel, player, message);
            return false;
        }

        private object OnServerMessage(String message, String name)
        {
            if (config.ControllerMessages.TurnedFunc.HideAdminGave)
                if (message.Contains("gave") && name == "SERVER")
                    return true;
            return null;
        }
        void OnPlayerCommand(BasePlayer player, string command, string[] args)
        {
            DiscordLoggCommand(player, command, args);
        }

        #region Auto Setup/Remove Permission

        #region User
        void OnUserPermissionGranted(string id, string permName) => SetupParametres(id, permName);
        void OnUserPermissionRevoked(string id, string permName) => RemoveParametres(id, permName);

        void OnUserGroupAdded(string id, string groupName)
        {
            String[] PermissionsGroup = permission.GetGroupPermissions(groupName);
            if (PermissionsGroup == null) return;
            foreach (String permName in PermissionsGroup)
                SetupParametres(id, permName);
        }

        void OnUserGroupRemoved(string id, string groupName)
        {
            String[] PermissionsGroup = permission.GetGroupPermissions(groupName);
            if (PermissionsGroup == null) return;

            foreach (String permName in PermissionsGroup)
                RemoveParametres(id, permName);
        }

        #endregion

        #region Group 
        void OnGroupPermissionGranted(string name, string perm)
        {
            String[] PlayerGroups = permission.GetUsersInGroup(name);
            if (PlayerGroups == null) return;

            foreach (String playerInfo in PlayerGroups)
            {
                BasePlayer player = BasePlayer.FindByID(UInt64.Parse(playerInfo.Substring(0, 17)));
                if (player == null) return;

                SetupParametres(player.UserIDString, perm);
            }
        }

        void OnGroupPermissionRevoked(string name, string perm)
        {
            String[] PlayerGroups = permission.GetUsersInGroup(name);
            if (PlayerGroups == null) return;

            foreach (String playerInfo in PlayerGroups)
            {
                BasePlayer player = BasePlayer.FindByID(UInt64.Parse(playerInfo.Substring(0, 17)));
                if (player == null) return;

                RemoveParametres(player.UserIDString, perm);
            }
        }
        #endregion

        #endregion

        object OnPlayerVoice(BasePlayer player, Byte[] data)
        {
            if (UserInformation[player.userID].MuteInfo.IsMute(MuteType.Voice))
                return false;
            return null;
        }
        void Init()
        {
            ReadData();
        }
        private void OnServerInitialized()
        {
            _ = this;
            
            if(IQFakeActive && config.ReferenceSetting.IQFakeActiveSettings.UseIQFakeActive)
                if (IQFakeActive.Version < new Oxide.Core.VersionNumber(2, 0, 0))
                {
                    PrintWarning(LanguageEn
                        ? "You have an outdated version of the IQFakeActive plugin, the plugin cannot access the API, update the IQIQFakeActiveChat plugin to version 2.0.0 or higher"
                        : "У вас устаревшая версия плагина IQFakeActive, плагин не может получить доступ к API, обновите плагин IQFakeActive до версии 2.0.0 или выше");
                    NextTick(() => { Interface.Oxide.UnloadPlugin(Name); });
                    return;
                }

            timer.Once(3f, () => 
            {
                if (!TranslationAPI && config.ReferenceSetting.translationApiSettings.useTranslationApi)
                {
                    PrintWarning(LanguageEn
                        ? "You have TranslationAPI support enabled, but the plugin is not installed. Download and install the plugin - https://umod.org/plugins/translation-api"
                        : "У вас включена поддержка TranslationAPI, но не установлен плагин. Скачайте и установите плагин - https://umod.org/plugins/translation-api");
                    NextTick(() => { Interface.Oxide.UnloadPlugin(Name); });
                    return;
                }
            });

            _imageUI = new ImageUI();
            _imageUI.DownloadImage();

            MigrateDataToNoob();

            foreach (BasePlayer player in BasePlayer.activePlayerList)
                UserConnecteionData(player);

            RegisteredPermissions();
            BroadcastAuto();

            CheckValidateUsers();

            if (!config.ControllerMessages.Formatting.ControllerNickname.UseNickController)
                Unsubscribe("OnUserConnected");

        }
        private void CheckValidateUsers()
        {
            Configuration.ControllerParameters Controller = config.ControllerParameter;
            Configuration.ControllerConnection ControllerConnection = config.ControllerConnect;

            List<Configuration.ControllerParameters.AdvancedFuncion> Prefixes = Controller.Prefixes.Prefixes;
            List<Configuration.ControllerParameters.AdvancedFuncion> NickColor = Controller.NickColorList;
            List<Configuration.ControllerParameters.AdvancedFuncion> ChatColor = Controller.MessageColorList;

            foreach (KeyValuePair<UInt64, User> Info in UserInformation)
            {
                if (Controller.Prefixes.TurnMultiPrefixes)
                {
                    foreach (String Prefix in Info.Value.Info.PrefixList.Where(prefixList => !Prefixes.Exists(i => i.Argument == prefixList)))
                        NextTick(() => Info.Value.Info.PrefixList.Remove(Prefix));
                }
                else
                {
                    if (!Prefixes.Exists(i => i.Argument == Info.Value.Info.Prefix))
                        Info.Value.Info.Prefix = ControllerConnection.SetupDefaults.PrefixDefault;
                }
                if (!NickColor.Exists(i => i.Argument == Info.Value.Info.ColorNick))
                    Info.Value.Info.ColorNick = ControllerConnection.SetupDefaults.NickDefault;

                if (!ChatColor.Exists(i => i.Argument == Info.Value.Info.ColorMessage))
                    Info.Value.Info.ColorMessage = ControllerConnection.SetupDefaults.MessageDefault;
            }
        }
        void OnPlayerConnected(BasePlayer player)
        {
            UserConnecteionData(player);
            AlertController(player);
        }
        private void OnUserConnected(IPlayer player) => ControlledBadNick(player);
        void Unload()
        {
            InterfaceBuilder.DestroyAll();
            
            if (_imageUI != null)
            {
                _imageUI.UnloadImages();
                _imageUI = null;
            }
            
            WriteData();
            _ = null;
        }

        void OnPlayerDisconnected(BasePlayer player, string reason) => AlertDisconnected(player, reason);
        #endregion

        #region DiscordFunc

        #region Logged Chat

        private void DiscordLoggCommand(BasePlayer player, String Command, String[] Args)
        {
            Configuration.OtherSettings.General Commands = config.OtherSetting.LogsChatCommands;
            if (!Commands.UseLogged || String.IsNullOrWhiteSpace(Commands.Webhooks)) return;

            List<Fields> fields = new List<Fields>
                        {
                            new Fields(LanguageEn ? "Nick" : "Ник", player.displayName, true),
                            new Fields("Steam64ID", player.UserIDString, true),
                            new Fields(LanguageEn ? "Command" : "Команда", $"/{Command} ", true),
                        };

            String Arguments = String.Join(" ", Args);
            if (Args != null && Arguments != null && Arguments.Length != 0 && !String.IsNullOrWhiteSpace(Arguments))
                fields.Insert(fields.Count, new Fields(LanguageEn ? "Arguments" : "Аргументы", Arguments, false));

            FancyMessage newMessage = new FancyMessage(null, false, new FancyMessage.Embeds[1] { new FancyMessage.Embeds(null, 10710525, fields, new Authors("IQChat Command-History", null, "https://i.postimg.cc/SshGgy52/xiwsg5m.png", null), null) });

            Request($"{Commands.Webhooks}", newMessage.toJSON());
        }
        private void DiscordLoggChat(BasePlayer player, Chat.ChatChannel Channel, String MessageLogged)
        {
            List<Fields> fields = new List<Fields>
                        {
                            new Fields(LanguageEn ? "Nick" : "Ник", player.displayName, true),
                            new Fields("Steam64ID", player.UserIDString, true),
                            new Fields(LanguageEn ? "Channel" : "Канал", Channel == Chat.ChatChannel.Global ? (LanguageEn ? "Global" : "Глобальный чат") : Channel == Chat.ChatChannel.Local ? (LanguageEn ? "Local" : "Локальный чат") : Channel == Chat.ChatChannel.Cards ? (LanguageEn ? "Poker" : "Покерный чат") : (LanguageEn ? "Team" : "Командный чат"), true),
                            new Fields(LanguageEn ? "Message" : "Сообщение", MessageLogged, false),
                        };

            FancyMessage newMessage = new FancyMessage(null, false, new FancyMessage.Embeds[1] { new FancyMessage.Embeds(null, 10710525, fields, new Authors("IQChat Chat-History", null, "https://i.postimg.cc/SshGgy52/xiwsg5m.png", null), null) });

            switch (Channel)
            {
                case Chat.ChatChannel.Cards:
                case Chat.ChatChannel.Global:
                case Chat.ChatChannel.Local:
                    {
                        Configuration.OtherSettings.General GlobalChat = config.OtherSetting.LogsChat.GlobalChatSettings;
                        if (!GlobalChat.UseLogged || String.IsNullOrWhiteSpace(GlobalChat.Webhooks)) return;
                        Request($"{GlobalChat.Webhooks}", newMessage.toJSON());
                        break;
                    }
                case Chat.ChatChannel.Team:
                    {
                        Configuration.OtherSettings.General TeamChat = config.OtherSetting.LogsChat.TeamChatSettings;
                        if (!TeamChat.UseLogged || String.IsNullOrWhiteSpace(TeamChat.Webhooks)) return;
                        Request($"{TeamChat.Webhooks}", newMessage.toJSON());
                    }
                    break;
                default:
                    break;
            }
        }
        
        private void DiscordCompactLoggChat(BasePlayer player, Chat.ChatChannel Channel, String MessageLogged)
        {
            String ChannelTitle = (LanguageEn ? (Channel == Chat.ChatChannel.Global ? "Global" : Channel == Chat.ChatChannel.Local ? "Local" : "Team") : (Channel == Chat.ChatChannel.Global ? "Глобальный чат" : Channel == Chat.ChatChannel.Local ? "Локальный чат" : "Командный чат"));
            String Format = config.OtherSetting.CompactLogsChat.ShowSteamID
                ? $"[{DateTime.Now.ToShortTimeString()}] [{ChannelTitle}] {player.displayName} ({player.userID}): {MessageLogged}"
                : $"[{DateTime.Now.ToShortTimeString()}] [{ChannelTitle}] {player.displayName}: {MessageLogged}";
            
            FancyMessage newMessage = new FancyMessage(Format, false, null);

            switch (Channel)
            {
                case Chat.ChatChannel.Local:
                case Chat.ChatChannel.Global:
                {
                    Configuration.OtherSettings.General GlobalChat = config.OtherSetting.CompactLogsChat.LogsCompactChat.GlobalChatSettings;
                    if (!GlobalChat.UseLogged || String.IsNullOrWhiteSpace(GlobalChat.Webhooks)) return;
                    Request($"{GlobalChat.Webhooks}", newMessage.toJSON());
                    break;
                }
                case Chat.ChatChannel.Team:
                {
                    Configuration.OtherSettings.General TeamChat = config.OtherSetting.CompactLogsChat.LogsCompactChat.TeamChatSettings;
                    if (!TeamChat.UseLogged || String.IsNullOrWhiteSpace(TeamChat.Webhooks)) return;
                    Request($"{TeamChat.Webhooks}", newMessage.toJSON());
                }
                    break;
                default:
                    break;
            }
        }
        
        private void DiscordLoggPM(BasePlayer Sender, BasePlayer Reciepter, String MessageLogged)
        {
            Configuration.OtherSettings.General PMChat = config.OtherSetting.LogsPMChat;
            if (PMChat == null || !PMChat.UseLogged || String.IsNullOrWhiteSpace(PMChat.Webhooks)) return;
            if (Sender == null || Reciepter == null) return;
            
            GeneralInformation.RenameInfo SenderRename = GeneralInfo.GetInfoRename(Sender.userID);
            GeneralInformation.RenameInfo ReciepterRename = GeneralInfo.GetInfoRename(Reciepter.userID);

            UInt64 UserIDSender = SenderRename != null ? SenderRename.RenameID == 0 ? Sender.userID : SenderRename.RenameID : Sender.userID;
            UInt64 UserIDReciepter = ReciepterRename != null ? ReciepterRename.RenameID == 0 ? Reciepter.userID : ReciepterRename.RenameID : Reciepter.userID;
            String SenderName = SenderRename != null ? ReciepterRename.RenameNick ?? Sender.displayName : Sender.displayName;
            String ReciepterName = ReciepterRename != null ? ReciepterRename.RenameNick ?? Reciepter.displayName : Reciepter.displayName;

            List<Fields> fields = new List<Fields>
                        {
                            new Fields(LanguageEn ? "Sender" : "Отправитель", $"{SenderName}({UserIDSender})", true),
                            new Fields(LanguageEn ? "Recipient" : "Получатель", $"{ReciepterName}({UserIDReciepter})", true),
                            new Fields(LanguageEn ? "Message" : "Сообщение", MessageLogged, false),
                        };

            FancyMessage newMessage = new FancyMessage(null, false, new FancyMessage.Embeds[1] { new FancyMessage.Embeds(null, 16608621, fields, new Authors("IQChat PM-History", null, "https://i.postimg.cc/SshGgy52/xiwsg5m.png", null), null) });

            Request($"{PMChat.Webhooks}", newMessage.toJSON());
        }

        private void DiscordLoggMuted(BasePlayer Target, MuteType Type, String Reason = null, String TimeBlocked = null, BasePlayer Moderator = null)
        {
            Configuration.OtherSettings.General MuteChat = config.OtherSetting.LogsMuted;
            if (!MuteChat.UseLogged || String.IsNullOrWhiteSpace(MuteChat.Webhooks)) return;

            Configuration.ControllerMute.LoggedFuncion ControllerMuted = config.ControllerMutes.LoggedMute;

            String ActionReason = String.Empty;

            GeneralInformation.RenameInfo RenameSender = GeneralInfo.GetInfoRename(Target.userID);

            UInt64 UserIDModeration = 0;
            String NickModeration = GetLang("IQCHAT_FUNCED_ALERT_TITLE_SERVER", Target.UserIDString);
            if (Moderator != null)
            {
                GeneralInformation.RenameInfo RenameModerator = GeneralInfo.GetInfoRename(Moderator.userID);

                UserIDModeration = RenameModerator != null
                    ? RenameModerator.RenameID == 0 ? Moderator.userID : RenameModerator.RenameID
                    : Moderator.userID;
                NickModeration = RenameModerator != null
                    ? $"{RenameModerator.RenameNick ?? Moderator.displayName}"
                    : Moderator.displayName;
            }

            String NickTarget = RenameSender != null ? $"{RenameSender.RenameNick ?? Target.displayName}" : Target.displayName;
            UInt64 UserIDTarget = RenameSender != null ? RenameSender.RenameID == 0 ? Target.userID : RenameSender.RenameID : Target.userID;

            List<Fields> fields;

            switch (Type)
            {
                case MuteType.Chat:
                    {
                        if (Reason != null)
                            ActionReason = LanguageEn ? "Mute chat" : "Блокировка чата";
                        else ActionReason = LanguageEn ? "Unmute chat" : "Разблокировка чата";
                        break;
                    }
                case MuteType.Voice:
                    {
                        if (Reason != null)
                            ActionReason = LanguageEn ? "Mute voice" : "Блокировка голоса";
                        else ActionReason = LanguageEn ? "Unmute voice" : "Разблокировка голоса";
                        break;
                    }
                default:
                    break;
            }
            Int32 Color = 0;
            if (Reason != null)
            {
                fields = new List<Fields>
                        {
                            new Fields(LanguageEn ? "Nickname of the moderator" : "Ник модератора", NickModeration, true),
                            new Fields(LanguageEn ? "Steam64ID Moderator" : "Steam64ID модератора", $"{UserIDModeration}", true),
                            new Fields(LanguageEn ? "Action" : "Действие", ActionReason, false),
                            new Fields(LanguageEn ? "Reason" : "Причина", Reason, false),
                            new Fields(LanguageEn ? "Time" : "Время", TimeBlocked, false),
                            new Fields(LanguageEn ? "Nick blocked" : "Ник заблокированного", NickTarget, true),
                            new Fields(LanguageEn ? "Steam64ID blocked" : "Steam64ID заблокированного", $"{UserIDTarget}", true),
                        };



                if (ControllerMuted.UseHistoryMessage)
                {
                    String Messages = GetLastMessage(Target, ControllerMuted.CountHistoryMessage);
                    if (Messages != null && !String.IsNullOrWhiteSpace(Messages))
                        fields.Insert(fields.Count, new Fields(LanguageEn ? $"The latter {ControllerMuted.CountHistoryMessage} messages" : $"Последние {ControllerMuted.CountHistoryMessage} сообщений", Messages, false));
                }

                Color = 14357781;
            }
            else
            {
                fields = new List<Fields>
                        {
                            new Fields(LanguageEn ? "Nickname of the moderator" : "Ник модератора", NickModeration, true),
                            new Fields(LanguageEn ? "Steam64ID moderator" : "Steam64ID модератора", $"{UserIDModeration}", true),
                            new Fields(LanguageEn ? "Action" : "Действие", ActionReason, false),
                            new Fields(LanguageEn ? "Nick blocked" : "Ник заблокированного", NickTarget, true),
                            new Fields(LanguageEn ? "Steam64ID blocked" : "Steam64ID заблокированного", $"{UserIDTarget}", true),
                        };
                Color = 1432346;
            }


            FancyMessage newMessage = new FancyMessage(null, false, new FancyMessage.Embeds[1] { new FancyMessage.Embeds(null, Color, fields, new Authors("IQChat Mute-History", null, "https://i.postimg.cc/SshGgy52/xiwsg5m.png", null), null) });

            Request($"{MuteChat.Webhooks}", newMessage.toJSON());
        }


        #endregion

        #region FancyDiscord
        public class FancyMessage
        {
            public string content { get; set; }
            public bool tts { get; set; }
            public Embeds[] embeds { get; set; }

            public class Embeds
            {
                public string title { get; set; }
                public int color { get; set; }
                public List<Fields> fields { get; set; }
                public Footer footer { get; set; }
                public Authors author { get; set; }

                public Embeds(string title, int color, List<Fields> fields, Authors author, Footer footer)
                {
                    this.title = title;
                    this.color = color;
                    this.fields = fields;
                    this.author = author;
                    this.footer = footer;

                }
            }

            public FancyMessage(string content, bool tts, Embeds[] embeds)
            {
                this.content = content;
                this.tts = tts;
                this.embeds = embeds;
            }
            
            public string toJSON() => JsonConvert.SerializeObject(this);
        }

        public class Footer
        {
            public string text { get; set; }
            public string icon_url { get; set; }
            public string proxy_icon_url { get; set; }
            public Footer(string text, string icon_url, string proxy_icon_url)
            {
                this.text = text;
                this.icon_url = icon_url;
                this.proxy_icon_url = proxy_icon_url;
            }
        }

        public class Authors
        {
            public string name { get; set; }
            public string url { get; set; }
            public string icon_url { get; set; }
            public string proxy_icon_url { get; set; }
            public Authors(string name, string url, string icon_url, string proxy_icon_url)
            {
                this.name = name;
                this.url = url;
                this.icon_url = icon_url;
                this.proxy_icon_url = proxy_icon_url;
            }
        }

        public class Fields
        {
            public string name { get; set; }
            public string value { get; set; }
            public bool inline { get; set; }
            public Fields(string name, string value, bool inline)
            {
                this.name = name;
                this.value = value;
                this.inline = inline;
            }
        }

        private void Request(string url, string payload, Action<int> callback = null)
        {
            Dictionary<string, string> header = new Dictionary<string, string>();
            header.Add("Content-Type", "application/json");
            webrequest.Enqueue(url, payload, (code, response) =>
            {
                if (code != 200 && code != 204)
                {
                    if (response != null)
                    {
                        try
                        {
                            JObject json = JObject.Parse(response);
                            if (code == 429)
                            {
                                float seconds = float.Parse(Math.Ceiling((double)(int)json["retry_after"] / 1000).ToString());
                            }
                            else
                            {
                                PrintWarning($" Discord rejected that payload! Responded with \"{json["message"].ToString()}\" Code: {code}");
                            }
                        }
                        catch
                        {
                            PrintWarning($"Failed to get a valid response from discord! Error: \"{response}\" Code: {code}");
                        }
                    }
                    else
                    {
                        PrintWarning($"Discord didn't respond (down?) Code: {code}");
                    }
                }
                try
                {
                    callback?.Invoke(code);
                }
                catch (Exception ex) { }

            }, this, RequestMethod.POST, header, 10f);
        }
        #endregion

        #endregion

        #region Funcion

        #region GetLanguageMessage

        public List<String> GetMesagesList(BasePlayer player, Dictionary<String, List<String>> LanguageMessages)
        {
            String LangPlayer = _.lang.GetLanguage(player.UserIDString);

            if (LanguageMessages.ContainsKey(LangPlayer))
                return LanguageMessages[LangPlayer];
            else if (LanguageMessages.ContainsKey("en"))
                return LanguageMessages["en"];
            else return LanguageMessages.FirstOrDefault().Value;
        }
        public String GetMessages(BasePlayer player, Dictionary<String, List<String>> LanguageMessages)
        {
            String LangPlayer = _.lang.GetLanguage(player.UserIDString);

            if (LanguageMessages.ContainsKey(LangPlayer))
                return LanguageMessages[LangPlayer].GetRandom();
            else if (LanguageMessages.ContainsKey("en"))
                return LanguageMessages["en"].GetRandom();
            else return LanguageMessages.FirstOrDefault().Value.GetRandom();
        }

        #endregion

        #region AddOrRemove Auto Parametres

        private void SetupParametres(String ID, String Permissions)
        {
            UInt64 UserID = UInt64.Parse(ID);
            BasePlayer player = BasePlayer.FindByID(UserID);
            Configuration.ControllerConnection.Turned Controller = config.ControllerConnect.Turneds;
            Configuration.ControllerParameters Parameters = config.ControllerParameter;

            if (!UserInformation.ContainsKey(UserID)) return;
            User Info = UserInformation[UserID];

            if (Controller.TurnAutoSetupPrefix)
            {
                Configuration.ControllerParameters.AdvancedFuncion Prefixes = Parameters.Prefixes.Prefixes.FirstOrDefault(prefix => prefix.Permissions == Permissions);
                if (Prefixes != null)
                {
                    if (Parameters.Prefixes.TurnMultiPrefixes && !Info.Info.PrefixList.Contains(Prefixes.Argument))
                        Info.Info.PrefixList.Add(Prefixes.Argument);
                    else Info.Info.Prefix = Prefixes.Argument;

                    if (player != null && config.ControllerMessages.GeneralSetting.alertArgumentsInfoSetup)
                        ReplySystem(player, GetLang("PREFIX_SETUP", player.UserIDString, Prefixes.Argument));

                    Log(LanguageEn ? $"Player ({UserID}) successfully retrieved the prefix {Prefixes.Argument}" : $"Игрок ({UserID}) успешно забрал префикс {Prefixes.Argument}");
                }
            }
            if (Controller.TurnAutoSetupColorNick)
            {
                Configuration.ControllerParameters.AdvancedFuncion ColorNick = Parameters.NickColorList.FirstOrDefault(nick => nick.Permissions == Permissions);
                if (ColorNick != null)
                {
                    Info.Info.ColorNick = ColorNick.Argument;
                    
                    if (player != null && config.ControllerMessages.GeneralSetting.alertArgumentsInfoSetup)
                    {
                        String nickColorTitle = GetLang("COLOR_NICK_SETUP_TITLE", player.UserIDString); 
                        Object resultColorMessage = IsGradientColorValue(Info.Info.ColorNick);
                        if (resultColorMessage is List<String> gradientColors)
                            nickColorTitle = ApplyGradientToText(nickColorTitle, gradientColors);
                        else nickColorTitle = $"<color={Info.Info.ColorNick}>{nickColorTitle}</color>";
                        
                        ReplySystem(player, GetLang("COLOR_NICK_SETUP", player.UserIDString, nickColorTitle));
                    }

                    Log(LanguageEn
                        ? $"Player ({UserID}) successfully took the color of the nickname {ColorNick.Argument}"
                        : $"Игрок ({UserID}) успешно забрал цвет ника {ColorNick.Argument}");
                }
            }
            if (Controller.TurnAutoSetupColorChat)
            {
                Configuration.ControllerParameters.AdvancedFuncion ColorChat = Parameters.MessageColorList.FirstOrDefault(message => message.Permissions == Permissions);
                if (ColorChat != null)
                {
                    Info.Info.ColorMessage = ColorChat.Argument;
                    
                    if (player != null && config.ControllerMessages.GeneralSetting.alertArgumentsInfoSetup)
                    {
                        String chatColorTitle = GetLang("COLOR_CHAT_SETUP_TITLE", player.UserIDString);
                        Object resultColorMessage = IsGradientColorValue(Info.Info.ColorMessage);
                        if (resultColorMessage is List<String> gradientColors)
                            chatColorTitle = ApplyGradientToText(chatColorTitle, gradientColors);
                        else chatColorTitle = $"<color={Info.Info.ColorMessage}>{chatColorTitle}</color>";
                        
                        ReplySystem(player, GetLang("COLOR_CHAT_SETUP", player.UserIDString, chatColorTitle));
                    }

                    Log(LanguageEn ? $"Player ({UserID}) successfully retrieved the color of the chat {ColorChat.Argument}" : $"Игрок ({UserID}) успешно забрал цвет чата {ColorChat.Argument}");
                }
            }
        }

        private void RemoveParametres(String ID, String Permissions)
        {
            UInt64 UserID = UInt64.Parse(ID);
            BasePlayer player = BasePlayer.FindByID(UserID);

            Configuration.ControllerConnection Controller = config.ControllerConnect;
            Configuration.ControllerParameters Parameters = config.ControllerParameter;

            if (!UserInformation.ContainsKey(UserID)) return;
            User Info = UserInformation[UserID];

            if (Controller.Turneds.TurnAutoDropPrefix)
            {
                if (Parameters.Prefixes.TurnMultiPrefixes)
                {
                    foreach (Configuration.ControllerParameters.AdvancedFuncion Prefixes in
                             Parameters.Prefixes.Prefixes.Where(prefix =>
                                 Info.Info.PrefixList.Contains(prefix.Argument) && prefix.Permissions == Permissions))
                    {
                        Info.Info.PrefixList.Remove(Prefixes.Argument);

                        if (player != null && config.ControllerMessages.GeneralSetting.alertArgumentsInfoRemove)
                            ReplySystem(player, GetLang("PREFIX_RETURNRED", player.UserIDString, Prefixes.Argument));

                        Log(LanguageEn
                            ? $"Player ({UserID}) expired prefix {Prefixes.Argument}"
                            : $"У игрока ({UserID}) истек префикс {Prefixes.Argument}");
                    }
                }
                else
                {
                    Configuration.ControllerParameters.AdvancedFuncion Prefixes = Parameters.Prefixes.Prefixes.FirstOrDefault(prefix => prefix.Argument == Info.Info.Prefix && prefix.Permissions == Permissions);
                    if (Prefixes != null)
                    {
                        Info.Info.Prefix = Controller.SetupDefaults.PrefixDefault;

                        if (player != null && config.ControllerMessages.GeneralSetting.alertArgumentsInfoRemove)
                            ReplySystem(player, GetLang("PREFIX_RETURNRED", player.UserIDString, Prefixes.Argument));

                        Log(LanguageEn
                            ? $"Player ({UserID}) expired prefix {Prefixes.Argument}"
                            : $"У игрока ({UserID}) истек префикс {Prefixes.Argument}");
                    }
                }
            }
            if (Controller.Turneds.TurnAutoDropColorNick)
            {
                Configuration.ControllerParameters.AdvancedFuncion ColorNick = Parameters.NickColorList.FirstOrDefault(nick => Info.Info.ColorNick == nick.Argument && nick.Permissions == Permissions);
                if (ColorNick != null)
                {
                    Info.Info.ColorNick = Controller.SetupDefaults.NickDefault;
                    
                    if (player != null && config.ControllerMessages.GeneralSetting.alertArgumentsInfoRemove)
                    {
                        String nickColorTitle = GetLang("COLOR_NICK_RETURNRED_TITLE", player.UserIDString);
                        Object resultColorMessage = IsGradientColorValue(Info.Info.ColorNick);
                        if (resultColorMessage is List<String> gradientColors)
                            nickColorTitle = ApplyGradientToText(nickColorTitle, gradientColors);
                        else nickColorTitle = $"<color={Info.Info.ColorNick}>{nickColorTitle}</color>";
                        
                        ReplySystem(player, GetLang("COLOR_NICK_RETURNRED", player.UserIDString, nickColorTitle));
                    }

                    Log(LanguageEn
                        ? $"Player ({UserID}) expired nick color {ColorNick.Argument}"
                        : $"У игрока ({UserID}) истек цвет ника {ColorNick.Argument}");
                }
            }
            if (Controller.Turneds.TurnAutoDropColorChat)
            {
                Configuration.ControllerParameters.AdvancedFuncion ColorChat = Parameters.MessageColorList.FirstOrDefault(message => Info.Info.ColorMessage == message.Argument && message.Permissions == Permissions);
                if (ColorChat == null) return;
                
                Info.Info.ColorMessage = Controller.SetupDefaults.MessageDefault;
                
                if (player != null && config.ControllerMessages.GeneralSetting.alertArgumentsInfoRemove)
                {
                    String chatColorTitle = GetLang("COLOR_CHAT_RETURNRED_TITLE", player.UserIDString);
                    Object resultColorMessage = IsGradientColorValue(Info.Info.ColorMessage);
                    if (resultColorMessage is List<String> gradientColors)
                        chatColorTitle = ApplyGradientToText(chatColorTitle, gradientColors);
                    else chatColorTitle = $"<color={Info.Info.ColorMessage}>{chatColorTitle}</color>";
                    
                    ReplySystem(player, GetLang("COLOR_CHAT_RETURNRED", player.UserIDString, chatColorTitle));
                }

                Log(LanguageEn ? $"Player ({UserID}) chat color expired {ColorChat.Argument}" : $"У игрока ({UserID}) истек цвет чата {ColorChat.Argument}");
            }
        }

        #endregion

        #region Main Chat Funcion

        private void ReplyPlayerChat(Chat.ChatChannel channel, BasePlayer player, BasePlayer playerSender, String OutMessage, String FormatMessage, String FormatPlayer, UInt64 RenameID)
        {
            Configuration.ControllerMessage ControllerMessages = config.ControllerMessages;
            
            User Info = UserInformation[playerSender.userID];
            String colorMessage = !String.IsNullOrWhiteSpace(Info.Info.CustomColorMessage)
                ? Info.Info.CustomColorMessage
                : Info.Info.ColorMessage;
            
            Object resultColorMessage = IsGradientColorValue(colorMessage);
            if (resultColorMessage is List<String> gradientColors)
                OutMessage = ApplyGradientToText(OutMessage, gradientColors);
            else OutMessage = !String.IsNullOrWhiteSpace(colorMessage) ? $"<color={colorMessage}>{OutMessage}</color>" : OutMessage;
            
            String messageSend = String.Format(FormatMessage, OutMessage);

            if (messageSend.Contains("@"))
            {
                String SplittedName = messageSend.Substring(messageSend.IndexOf('@')).Replace("@", "").Split(' ')[0];

                BasePlayer playerTags = GetPlayerNickOrID(SplittedName);

                if (playerTags != null)
                {
                    User InfoP = UserInformation[playerTags.userID];

                    if (InfoP.Settings.TurnAlert && player == playerTags)
                    {
                        ReplySystem(player, $"<size=16>{messageSend.Trim()}</size>", GetLang("IQCHAT_FUNCED_ALERT_TITLE", player.UserIDString, playerTags.displayName), player.UserIDString, ControllerMessages.GeneralSetting.AlertFormat.AlertPlayerColor);
                        if (InfoP.Settings.TurnSound)
                            Effect.server.Run(ControllerMessages.GeneralSetting.AlertFormat.SoundAlertPlayer, playerTags.GetNetworkPosition());
                    }
                    else player.SendConsoleCommand("chat.add", (int)channel, RenameID, $"{FormatPlayer}: {messageSend}");
                }
                else player.SendConsoleCommand("chat.add", (int)channel, RenameID, $"{FormatPlayer}: {messageSend}");
            }
            else player.SendConsoleCommand("chat.add", (int)channel, RenameID, $"{FormatPlayer}: {messageSend}");
            
            player.ConsoleMessage($"{FormatPlayer} {messageSend}");
        }
        private ListHashSet<BasePlayer> GetPlayerList(BasePlayer player, Chat.ChatChannel channel)
        {
            ListHashSet<BasePlayer> playerList = new();

            if (channel is Chat.ChatChannel.Global or Chat.ChatChannel.Local)
                playerList = BasePlayer.activePlayerList;
            else if (channel == Chat.ChatChannel.Team)
            {
                RelationshipManager.PlayerTeam Team = RelationshipManager.ServerInstance.FindTeam(player.currentTeam);
                if (Team == null) return null;
                foreach (UInt64 FindPlayers in Team.members)
                {
                    BasePlayer TeamPlayer = BasePlayer.FindByID(FindPlayers);
                    if (TeamPlayer == null) continue;

                    playerList.Add(TeamPlayer);
                }
            }
            else if (channel == Chat.ChatChannel.Cards)
            {
                if (!player.isMounted)
                    return null;

                CardTable cardTable = player.GetMountedVehicle() as CardTable;
                if (cardTable == null || !cardTable.GameController.PlayerIsInGame(player))
                    return null;

                List<Network.Connection> PlayersCards = new List<Network.Connection>();
                cardTable.GameController.GetConnectionsInGame(PlayersCards);
                if (PlayersCards == null || PlayersCards.Count == 0)
                    return null;

                foreach (Network.Connection PCard in PlayersCards)
                {
                    BasePlayer PlayerInRound = BasePlayer.FindByID(PCard.userid);
                    if (PlayerInRound == null) return null;
                    playerList.Add(PlayerInRound);
                }
            }

            return playerList;
        }
        private void ReplyTranslationMessage(Chat.ChatChannel channel, BasePlayer player, BasePlayer playerSender, String OutMessage, String FormatMessage, String FormatPlayer, UInt64 RenameID)
        {
            ListHashSet<BasePlayer> playerList = GetPlayerList(player, channel);
            if (playerList == null) return;

            if (!String.IsNullOrWhiteSpace(config.ReferenceSetting.translationApiSettings.codeLanguagePrimary))
            {
                Action<String> callback = translation =>
                {
                    foreach (BasePlayer p in playerList)
                        ReplyPlayerChat(channel, p, playerSender, !permission.UserHasPermission(p.UserIDString, PermissionTranslationIgnore) ? translation : OutMessage, FormatMessage, FormatPlayer, RenameID);
                };

                TranslationAPI.Call("Translate", OutMessage, config.ReferenceSetting.translationApiSettings.codeLanguagePrimary, "auto", callback);
            }
            else
            {
                foreach (BasePlayer p in playerList)
                {
                    String codeResult = lang.GetLanguage(p.UserIDString);
                    saveTranslate.TryAdd(codeResult, new TranslationState());

                    Action<String> callback = translation =>
                    {
                        saveTranslate[codeResult].IsProcessed = true;
                        saveTranslate[codeResult].Translation = translation;
                        saveTranslate[codeResult].DoTranslation = OutMessage;
                        
                        ReplyPlayerChat(channel, p, playerSender,!permission.UserHasPermission(p.UserIDString, PermissionTranslationIgnore) ? translation : OutMessage, FormatMessage, FormatPlayer, RenameID);
                    };

                    if (lang.GetLanguage(player.UserIDString) == codeResult)
                        ReplyPlayerChat(channel, p, playerSender, OutMessage, FormatMessage, FormatPlayer, RenameID);
                    else if (saveTranslate[codeResult].IsProcessed && !string.IsNullOrWhiteSpace(saveTranslate[codeResult].Translation) && OutMessage == saveTranslate[codeResult].DoTranslation)
                        ReplyPlayerChat(channel, p, playerSender, saveTranslate[codeResult].Translation, FormatMessage, FormatPlayer, RenameID);
                    else TranslationAPI.Call("Translate", OutMessage, codeResult, "auto", callback);
                }
            }
        }

        void ReplyChat(Chat.ChatChannel channel, BasePlayer player, String OutMessage, String FormatMessage, String FormatPlayer)
        {
            GeneralInformation.RenameInfo RenameInfo = GeneralInfo.GetInfoRename(player.userID);
            UInt64 RenameID = RenameInfo != null ? RenameInfo.RenameID != 0 ? RenameInfo.RenameID : player.userID : player.userID;
            
            if (channel == Chat.ChatChannel.Team)
            {
                if (TranslationAPI && config.ReferenceSetting.translationApiSettings.useTranslationApi && config.ReferenceSetting.translationApiSettings.translateTeamChat)
                    ReplyTranslationMessage(channel, player, player, OutMessage, FormatMessage, FormatPlayer, RenameID);
                else
                {
                    ListHashSet<BasePlayer> playerList = GetPlayerList(player, channel);
                    if (playerList == null) return;
                    foreach (BasePlayer p in playerList)
                        ReplyPlayerChat(channel, p, player, OutMessage, FormatMessage, FormatPlayer, RenameID);
                }
            }
            else
            {
                if (TranslationAPI && config.ReferenceSetting.translationApiSettings.useTranslationApi)
                    ReplyTranslationMessage(channel, player, player, OutMessage, FormatMessage, FormatPlayer, RenameID);
                else
                {
                    foreach (BasePlayer p in BasePlayer.activePlayerList)
                        ReplyPlayerChat(channel, p, player, OutMessage, FormatMessage, FormatPlayer, RenameID);
                }
            }
        }
        void ReplySystem(BasePlayer player, String Message, String CustomPrefix = null, String CustomAvatar = null, String CustomHex = null)
        {
            Configuration.ControllerMessage ControllerMessages = config.ControllerMessages;

            String Prefix = (CustomPrefix == null || String.IsNullOrWhiteSpace(CustomPrefix)) ? (ControllerMessages.GeneralSetting.BroadcastFormat.BroadcastTitle == null || String.IsNullOrWhiteSpace(ControllerMessages.GeneralSetting.BroadcastFormat.BroadcastTitle)) ? "" : ControllerMessages.GeneralSetting.BroadcastFormat.BroadcastTitle : CustomPrefix;
            String AvatarID = (CustomAvatar == null || String.IsNullOrWhiteSpace(CustomAvatar)) ? (ControllerMessages.GeneralSetting.BroadcastFormat.Steam64IDAvatar == null || String.IsNullOrWhiteSpace(ControllerMessages.GeneralSetting.BroadcastFormat.Steam64IDAvatar)) ? "0" : ControllerMessages.GeneralSetting.BroadcastFormat.Steam64IDAvatar : CustomAvatar;
            String Hex = (CustomHex == null || String.IsNullOrWhiteSpace(CustomHex)) ? (ControllerMessages.GeneralSetting.BroadcastFormat.BroadcastColor == null || String.IsNullOrWhiteSpace(ControllerMessages.GeneralSetting.BroadcastFormat.BroadcastColor)) ? "#ffff" : ControllerMessages.GeneralSetting.BroadcastFormat.BroadcastColor : CustomHex;
           
            player.SendConsoleCommand("chat.add", Chat.ChatChannel.Global, AvatarID, $"{Prefix}<color={Hex}>{Message}</color>");
        }

        void ReplyBroadcast(String Message, String CustomPrefix = null, String CustomAvatar = null, Boolean AdminAlert = false)
        {
            foreach (BasePlayer p in !AdminAlert ? BasePlayer.activePlayerList.Where(p => UserInformation[p.userID].Settings.TurnBroadcast) : BasePlayer.activePlayerList)
                ReplySystem(p, Message, CustomPrefix, CustomAvatar);
        }
        
        void ReplyBroadcast(String CustomPrefix = null, String CustomAvatar = null, Boolean AdminAlert = false, String LangKey = "", params object[] args)
        {
            foreach (BasePlayer p in !AdminAlert ? BasePlayer.activePlayerList.Where(p => UserInformation[p.userID].Settings.TurnBroadcast) : BasePlayer.activePlayerList)
                ReplySystem(p,GetLang(LangKey, p.UserIDString, args), CustomPrefix, CustomAvatar);
        }
        
        void ReplyBroadcast(String CustomPrefix = null, String CustomAvatar = null, Boolean AdminAlert = false, Dictionary<String, List<String>> Messages = null, params object[] args)
        {
            foreach (BasePlayer p in !AdminAlert ? BasePlayer.activePlayerList.Where(p => UserInformation[p.userID].Settings.TurnBroadcast) : BasePlayer.activePlayerList)
            {
                sb.Clear();
                String templateText = GetMessages(p, Messages);
                if(String.IsNullOrWhiteSpace(templateText)) continue;
                ReplySystem(p, sb.AppendFormat(templateText, args).ToString(), CustomPrefix, CustomAvatar);
            }
        }

        #endregion

        #region Chat Controller
        public Boolean IsNoob(UInt64 userID, Int32 TimeBlocked)
        {
            if (UserInformationConnection.ContainsKey(userID))
                return UserInformationConnection[userID].IsNoob(TimeBlocked);
            return false;
        }
        public void AnwserMessage(BasePlayer player, String Message)
        {
            Configuration.AnswerMessage Anwser = config.AnswerMessages;
            if (!Anwser.UseAnswer) return;
            foreach (KeyValuePair<String, Configuration.LanguageController> Anwsers in Anwser.AnswerMessageList)
                if (Message.Contains(Anwsers.Key.ToLower()))
                {
                    String templateText = GetMessages(player, Anwsers.Value.LanguageMessages);
                    if(String.IsNullOrWhiteSpace(templateText)) continue;
                    ReplySystem(player, templateText);
                }
        }
        private void AddHistoryMessage(BasePlayer player, String Message)
        {
            if (!LastMessagesChat.ContainsKey(player))
                LastMessagesChat.Add(player, new List<String> { Message });
            else LastMessagesChat[player].Add(Message);
        }

        private String GetLastMessage(BasePlayer player, Int32 Count)
        {
            String Messages = String.Empty;

            if (LastMessagesChat.ContainsKey(player))
            {
                foreach (String Message in LastMessagesChat[player].Skip(LastMessagesChat[player].Count - Count))
                    Messages += $"\n{Message}";
            }

            return Messages;
        }

        public Dictionary<UInt64, FlooderInfo> Flooders = new Dictionary<UInt64, FlooderInfo>();
        internal class FlooderInfo
        {
            public Double Time;
            public String LastMessage;
            public Int32 TryFlood;
        }
        
        private Tuple<String, Boolean> BadWordsCleaner(String formattingMessage, String replaceBadWord, Dictionary<String, Boolean> badWords)
        {
            String resultMessage = formattingMessage;
            Boolean isBadWords = false;

            foreach (KeyValuePair<String, Boolean> word in badWords.Where(x => !x.Key.Contains("*")))
            {
                if (word.Value)
                {
                    String pattern = Regex.Escape(word.Key);
                    resultMessage = Regex.Replace(resultMessage, pattern, replaceBadWord, RegexOptions.IgnoreCase);
                    if (Regex.IsMatch(formattingMessage, pattern, RegexOptions.IgnoreCase))
                        isBadWords = true;
                }
                else
                {
                    String pattern = $@"\b{Regex.Escape(word.Key)}\b";
                    resultMessage = Regex.Replace(resultMessage, pattern, replaceBadWord);
                    if (Regex.IsMatch(formattingMessage, pattern))
                        isBadWords = true;
                }
            }

            return Tuple.Create(resultMessage, isBadWords);
        }

        
        private String RemoveLinkText(String text)
        {
            String hrefPattern = "([A-Za-z0-9-А-Яа-я]|https?://)[^ ]+\\.(com|lt|net|org|gg|ru|рф|int|info|ru.com|ru.net|com.ru|net.ru|рус|org.ru|moscow|biz|орг|su)";
            Regex rgx = new Regex(hrefPattern, RegexOptions.IgnoreCase);

            return config.ControllerMessages.Formatting.ControllerNickname.AllowedLinkNick.Contains(rgx.Match(text).Value) ? text : rgx.Replace(text, "").Trim();
        }

        private String GetReferenceTags(BasePlayer player)
        {
            String Result = String.Empty;
            String Rank = String.Empty;
            String RankTime = String.Empty;
            if (IQRankSystem)
            {
                Configuration.ReferenceSettings.IQRankSystem IQRank = config.ReferenceSetting.IQRankSystems;

                if (IQRank.UseRankSystem)
                {
                    if (IQRank.UseTimeStandart)
                        RankTime = String.IsNullOrWhiteSpace(IQRankGetTimeGame(player.userID)) ? String.Empty : String.Format(IQRank.FormatRankTime, IQRankGetTimeGame(player.userID));
                    Rank = String.IsNullOrWhiteSpace(IQRankGetRank(player.userID)) ? String.Empty : String.Format(IQRank.FormatRank, IQRankGetRank(player.userID));

                    if (!String.IsNullOrWhiteSpace(RankTime))
                        Result += $"{RankTime} ";
                    if (!String.IsNullOrWhiteSpace(Rank))
                        Result += $"{Rank} ";
                }
            }

            String XPrison = XPrison_GetPrefix(player);
            if (!String.IsNullOrWhiteSpace(XPrison))
                Result += $"{XPrison} ";
            
            String XLevel = config.ReferenceSetting.XLevelsSettings.UseFullXLevels ? XLevel_GetPrefix(player) : XLevel_GetLevel(player);
            if (!String.IsNullOrWhiteSpace(XLevel))
                Result += $"{XLevel} ";

            String ClanTag = GetClanTag(player.userID);
            if (!String.IsNullOrWhiteSpace(ClanTag))
                Result += $"{ClanTag} ";

            String SkillTree = config.ReferenceSetting.skillTreeSettings.UseFullSkillTree ? $"{SkillTree_GetLevel(player)} {SkillTree_GetXP(player)}" : $"{SkillTree_GetLevel(player)}";
            if (!String.IsNullOrWhiteSpace(SkillTree))
                Result += $"{SkillTree} ";

            String PrestigeSkillTree = GetPrestigeLevel(player.userID.Get());
            if (!String.IsNullOrWhiteSpace(PrestigeSkillTree))
                Result += $"{PrestigeSkillTree} ";
            
            String PlayerRanks = PlayerRanks_GetRanks(player);
            if (!String.IsNullOrWhiteSpace(PlayerRanks))
                Result += $"{PlayerRanks} ";
            
            String hookResult = Interface.Call<String>("OnChatReferenceTags", player);
            if (!String.IsNullOrWhiteSpace(hookResult))
                Result += $"{hookResult} ";
            
            return Result;
        }
        public Object IsGradientColorValue(String value)
        {
            if (String.IsNullOrEmpty(value)) return value?.Trim();
            if (!value.Contains(",")) return value.Trim();
            List<String> colors = new(value.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries));
            for (Int32 i = 0; i < colors.Count; i++)
                colors[i] = colors[i].Trim();
    
            return colors;
        }
        
        public static Regex regex = new Regex(@"(:\w+:|<[^>]+>)");
        public static String ApplyGradientToText(String text, List<String> colors)
        {
            String result = string.Empty;
            Int32 colorCount = colors.Count;
            Int32 textLength = text.Length;
            
            MatchCollection matches = regex.Matches(text);
            
            for (Int32 i = 0; i < textLength; i++)
            {
                Boolean isMatch = false;
                foreach (Match match in matches)
                {
                    if (match.Index == i)
                    {
                        result += match.Value;
                        i += match.Length - 1; 
                        isMatch = true;
                        break;
                    }
                }

                if (!isMatch)
                {
                    int gradientColorIndex = (int)((float)i / textLength * colorCount);
                    result += $"<color={colors[gradientColorIndex]}>{text[i]}</color>";
                }
            }

            return result;
        }
        
        private void SeparatorChat(Chat.ChatChannel channel, BasePlayer player, String Message)
        {
            Configuration.ControllerMessage.TurnedFuncional.AntiNoob.Settings antiNoob = config.ControllerMessages.TurnedFunc.AntiNoobSetting.AntiNoobChat;
            if (antiNoob.AntiNoobActivate)
                if (IsNoob(player.userID, antiNoob.TimeBlocked))
                {
                    ReplySystem(player, GetLang("IQCHAT_INFO_ANTI_NOOB", player.UserIDString, FormatTime(UserInformationConnection[player.userID].LeftTime(antiNoob.TimeBlocked), player.UserIDString)));
                    return;
                }

            Configuration.ControllerMessage ControllerMessage = config.ControllerMessages;
            User Info = UserInformation[player.userID];

            if (ControllerMessage.TurnedFunc.AntiSpamSetting.AntiSpamActivate)
                if (!permission.UserHasPermission(player.UserIDString, PermissionAntiSpam))
                {
                    if (!Info.MuteInfo.IsMute(MuteType.Chat))
                    {
                        if (!Flooders.ContainsKey(player.userID))
                            Flooders.Add(player.userID, new FlooderInfo { Time = CurrentTime + ControllerMessage.TurnedFunc.AntiSpamSetting.FloodTime, LastMessage = Message });
                        else
                        {
                            if (Flooders[player.userID].Time > CurrentTime)
                            {
                                ReplySystem(player, GetLang("FLOODERS_MESSAGE", player.UserIDString, Convert.ToInt32(Flooders[player.userID].Time - CurrentTime)));
                                return;
                            }

                            if (ControllerMessage.TurnedFunc.AntiSpamSetting.AntiSpamDuplesSetting.AntiSpamDuplesActivate)
                            {
                                if (Flooders[player.userID].LastMessage == Message)
                                {
                                    if (Flooders[player.userID].TryFlood >= ControllerMessage.TurnedFunc.AntiSpamSetting.AntiSpamDuplesSetting.TryDuples)
                                    {
                                        MutePlayer(player, MuteType.Chat, 0, null, ControllerMessage.TurnedFunc.AntiSpamSetting.AntiSpamDuplesSetting.MuteSetting.Reason, ControllerMessage.TurnedFunc.AntiSpamSetting.AntiSpamDuplesSetting.MuteSetting.SecondMute);
                                        Flooders[player.userID].TryFlood = 0;
                                        return;
                                    }
                                    Flooders[player.userID].TryFlood++;
                                }
                            }
                        }
                        Flooders[player.userID].Time = ControllerMessage.TurnedFunc.AntiSpamSetting.FloodTime + CurrentTime;
                        Flooders[player.userID].LastMessage = Message;
                    }
                }

            GeneralInformation General = GeneralInfo;
            GeneralInformation.RenameInfo RenameInformation = General.GetInfoRename(player.userID);

            Configuration.ControllerParameters ControllerParameter = config.ControllerParameter;
            Configuration.ControllerMute ControllerMutes = config.ControllerMutes;
            Configuration.ControllerMessage.GeneralSettings.OtherSettings OtherController = config.ControllerMessages.GeneralSetting.OtherSetting;

            if (General.TurnMuteAllChat)
            {
                ReplySystem(player, GetLang("IQCHAT_FUNCED_NO_SEND_CHAT_MUTED_ALL_CHAT", player.UserIDString));
                return;
            }

            if (channel == Chat.ChatChannel.Team && !ControllerMessage.TurnedFunc.MuteTeamChat) { }
            else if (Info.MuteInfo.IsMute(MuteType.Chat))
            {
                ReplySystem(player, GetLang("IQCHAT_FUNCED_NO_SEND_CHAT_MUTED", player.UserIDString, FormatTime(Info.MuteInfo.GetTime(MuteType.Chat), player.UserIDString)));
                return;
            }

            String Prefixes = String.Empty;
            String FormattingMessage = Message;
            String DisplayName = player.displayName;

            UInt64 UserID = player.userID;
            if (RenameInformation != null)
            {
                DisplayName = RenameInformation.RenameNick;
                UserID = RenameInformation.RenameID;
            }

            String ColorNickPlayer = !String.IsNullOrWhiteSpace(Info.Info.CustomColorNick) ? Info.Info.CustomColorNick : String.IsNullOrWhiteSpace(Info.Info.ColorNick) ? player.IsAdmin ? "#a8fc55" : "#54aafe" : Info.Info.ColorNick;
            
            Object resultColorNick = IsGradientColorValue(ColorNickPlayer);
            if (resultColorNick is List<String> gradientColors)
                DisplayName = ApplyGradientToText(DisplayName, gradientColors);
            else DisplayName = $"<color={ColorNickPlayer}>{DisplayName}</color>";
            
            String ChannelMessage = channel == Chat.ChatChannel.Cards ? "<color=#AA8234>[Cards]</color>" :  channel == Chat.ChatChannel.Clan ? "<color=#a5e664>[Clan]</color>" : "";

            if (ControllerMessage.Formatting.UseBadWords)
            {
                Tuple<String, Boolean> GetTuple = BadWordsCleaner(Message, ControllerMessage.Formatting.ReplaceBadWord, ControllerMessage.Formatting.BadWords);
                FormattingMessage = GetTuple.Item1;

                if (GetTuple.Item2 && channel == Chat.ChatChannel.Global)
                {
                    if (permission.UserHasPermission(player.UserIDString, PermissionMute))
                        Interface.Oxide.CallHook("OnModeratorSendBadWords", player, GetTuple.Item1);

                    Interface.Oxide.CallHook("OnPlayerSendBadWords", player, GetTuple.Item1);

                    if (ControllerMutes.AutoMuteSettings.UseAutoMute)
                        MutePlayer(player, MuteType.Chat, 0, null, ControllerMutes.AutoMuteSettings.AutoMuted.Reason, ControllerMutes.AutoMuteSettings.AutoMuted.SecondMute);
                }
            }

            Object OnMessageIQChat = Interface.CallHook("OnMessageIQChat", FormattingMessage);
            if (OnMessageIQChat is String)
                FormattingMessage = (String)OnMessageIQChat;
            
            if (ControllerMessage.Formatting.FormatMessage)
                FormattingMessage = $"{FormattingMessage.Substring(0, 1).ToUpper()}{FormattingMessage.Remove(0, 1).ToLower()}";
            
            if (ControllerParameter.Prefixes.TurnMultiPrefixes)
            {
                if (Info.Info.PrefixList != null)
                    Prefixes = String.Join("", Info.Info.PrefixList.Take(ControllerParameter.Prefixes.MaximumMultiPrefixCount));

            }
            else Prefixes = Info.Info.Prefix;

            Int32 SizeNick = OtherController.GetSizeNickOrMessage(player, true);
            Int32 SizeMessage = OtherController.GetSizeNickOrMessage(player, false);

            String FormatMessage = $"<size={SizeMessage}>" + "{0}</size>";
            
            // String FormatMessage = String.IsNullOrWhiteSpace(Info.Info.ColorMessage) ? $"<size={SizeMessage}>" + "{0}</size>" :
            //     $"<color={Info.Info.ColorMessage}><size={SizeMessage}>" + "{0}</size></color>";

            String ResultReference = GetReferenceTags(player); 
            String SendFormat = !String.IsNullOrWhiteSpace(Prefixes) ? 
                $"{ChannelMessage} {ResultReference}<size={OtherController.SizePrefix}>{Prefixes}</size> <size={SizeNick}>{DisplayName}</size>" :
                $"{ChannelMessage} {ResultReference} <size={SizeNick}>{DisplayName}</size>";
            
            if (config.RustPlusSettings.UseRustPlus)
                if (channel == Chat.ChatChannel.Team)
                {
                    RelationshipManager.PlayerTeam Team = RelationshipManager.ServerInstance.FindTeam(player.currentTeam);
                    if (Team == null) return;
                    Util.BroadcastTeamChat(player.Team, player.userID, player.displayName, FormattingMessage, Info.Info.ColorMessage);
                }

            if (ControllerMutes.LoggedMute.UseHistoryMessage && config.OtherSetting.LogsMuted.UseLogged)
                AddHistoryMessage(player, FormattingMessage);
            
            ReplyChat(channel, player, FormattingMessage, FormatMessage, SendFormat);
            AnwserMessage(player, FormattingMessage.ToLower());
            Puts($"{player.displayName}({player.UserIDString}): {FormattingMessage}");
            Log(LanguageEn ? $"CHAT MESSAGE : {player}: {ChannelMessage} {FormattingMessage}" : $"СООБЩЕНИЕ В ЧАТ : {player}: {ChannelMessage} {FormattingMessage}");
            DiscordLoggChat(player, channel, Message);
            DiscordCompactLoggChat(player, channel, Message);

            if (!config.disableRconBroadcast)
            {
                RCon.Broadcast(RCon.LogType.Chat, new Chat.ChatEntry
                {
                    Message = $"{player.displayName} : {FormattingMessage}",
                    UserId = player.UserIDString,
                    Username = player.displayName,
                    Channel = channel,
                    Time = (DateTime.UtcNow.Hour * 3600) + (DateTime.UtcNow.Minute * 60),
                });
            }
        }

        #endregion

        #region Alert Controller
        public void BroadcastAuto()
        {
            Configuration.ControllerAlert.Alert Broadcast = config.ControllerAlertSetting.AlertSetting;

            if (Broadcast.AlertMessage)
            {
                Int32 IndexBroadkastNow = 0;
                String RandomMsg = String.Empty;

                timer.Every(Broadcast.MessageListTimer, () =>
                {
                    if (Broadcast.AlertMessageType)
                    {
                        foreach (BasePlayer p in BasePlayer.activePlayerList)
                        {
                            List<String> MessageList = GetMesagesList(p, Broadcast.MessageList.LanguageMessages);
                            if (MessageList.Count == 0) continue;
                            
                            if (IndexBroadkastNow >= MessageList.Count)
                                IndexBroadkastNow = 0;
                            RandomMsg = MessageList[IndexBroadkastNow];

                            ReplySystem(p, RandomMsg);
                        }

                        IndexBroadkastNow++;
                    }
                    else
                    {
                        foreach (BasePlayer p in BasePlayer.activePlayerList)
                        {
                            String templateText = GetMessages(p, Broadcast.MessageList.LanguageMessages);
                            if(String.IsNullOrWhiteSpace(templateText)) continue;
                            ReplySystem(p, templateText);
                        }
                    }
                });

            }
        }

        private void AlertDisconnected(BasePlayer player, String reason)
        {
            Object status = Interface.CallHook("OnChatAlertDisconnected", player, reason);
            if (status != null)
                return;
            
            Configuration.ControllerAlert.AdminSession AlertSessionAdmin = config.ControllerAlertSetting.AdminSessionSetting;
            Configuration.ControllerAlert.PlayerSession AlertSessionPlayer = config.ControllerAlertSetting.PlayerSessionSetting;
            GeneralInformation.RenameInfo RenameInformation = GeneralInfo.GetInfoRename(player.userID);

            if (AlertSessionPlayer.DisconnectedAlert)
            {
                if (!AlertSessionAdmin.DisconnectedAlertAdmin)
                    if (player.IsAdmin) return;

                String DisplayName = player.displayName;

                UInt64 UserID = player.userID;
                if (RenameInformation != null)
                {
                    DisplayName = RenameInformation.RenameNick;
                    UserID = RenameInformation.RenameID;
                }

                String Avatar = AlertSessionPlayer.ConnectedAvatarUse ? UserID.ToString() : String.Empty;

                if (!permission.UserHasPermission(player.UserIDString, PermissionHideDisconnection))
                {
                    if (AlertSessionPlayer.DisconnectedAlertRandom)
                        ReplyBroadcast(null, Avatar, false, AlertSessionPlayer.RandomDisconnectedAlert.LanguageMessages,DisplayName, reason);
                    else
                    {
                        System.Object[] args = AlertSessionPlayer.DisconnectedReason ? new System.Object[] { DisplayName, reason } : new System.Object[] { DisplayName };
                        String Lang = AlertSessionPlayer.DisconnectedReason ? "LEAVE_PLAYER_REASON" : "LEAVE_PLAYER";
                        ReplyBroadcast(null, Avatar, false, Lang, args);
                    }
                }

                Log($"[{player.userID}] {(AlertSessionPlayer.DisconnectedReason ? GetLang("LEAVE_PLAYER_REASON", player.UserIDString, DisplayName, reason) : GetLang("LEAVE_PLAYER", player.UserIDString, DisplayName))}");
            }
        }
        
        private void AlertController(BasePlayer player)
        {
            Object status = Interface.CallHook("OnChatAlertConnected", player);
            if (status != null)
                return;
            
            Configuration.ControllerAlert.AdminSession AlertSessionAdmin = config.ControllerAlertSetting.AdminSessionSetting;
            Configuration.ControllerAlert.PlayerSession AlertSessionPlayer = config.ControllerAlertSetting.PlayerSessionSetting;
            Configuration.ControllerAlert.PersonalAlert AlertPersonal = config.ControllerAlertSetting.PersonalAlertSetting;
            GeneralInformation.RenameInfo RenameInformation = GeneralInfo.GetInfoRename(player.userID);

            String DisplayName = player.displayName;

            UInt64 UserID = player.userID;
            if (RenameInformation != null)
            {
                DisplayName = RenameInformation.RenameNick;
                UserID = RenameInformation.RenameID;
            }

            if (AlertSessionPlayer.ConnectedAlert)
            {
                if (!AlertSessionAdmin.ConnectedAlertAdmin)
                    if (player.IsAdmin) return;

                String Avatar = AlertSessionPlayer.ConnectedAvatarUse ? UserID.ToString() : String.Empty;

                if (AlertSessionPlayer.ConnectedWorld)
                {
                    String ipPlayer = player.IPlayer.Address;

                    if (player.net?.connection != null)
                    {
                        String[] ipPortPlayer = player.net.connection.ipaddress.Split(':');
                        if (ipPortPlayer.Length >= 1)
                            ipPlayer = ipPortPlayer[0]; 
                    }
                    
                    webrequest.Enqueue("http://ip-api.com/json/" + ipPlayer, null, (code, response) =>
                    {
                        if (code != 200 || response == null)
                            return;

                        String country = JsonConvert.DeserializeObject<Response>(response).Country;

                        if (!permission.UserHasPermission(player.UserIDString, PermissionHideConnection))
                        {
                            if (AlertSessionPlayer.ConnectionAlertRandom)
                                ReplyBroadcast(null, Avatar, false, AlertSessionPlayer.RandomConnectionAlert.LanguageMessages,DisplayName, country ?? "none");
                            else ReplyBroadcast(null, Avatar, false, "WELCOME_PLAYER_WORLD", DisplayName, country ?? "none");
                        }

                        Log($"[{player.userID}] {GetLang("WELCOME_PLAYER_WORLD", "", DisplayName, country ?? "none")}");
                    }, this);
                }
                else
                {
                    if (!permission.UserHasPermission(player.UserIDString, PermissionHideConnection))
                    {
                        if (AlertSessionPlayer.ConnectionAlertRandom)
                            ReplyBroadcast(null, Avatar, false,AlertSessionPlayer.RandomConnectionAlert.LanguageMessages, DisplayName);
                        else ReplyBroadcast(null, Avatar, false, "WELCOME_PLAYER", DisplayName);
                    }

                    Log($"[{player.userID}] {GetLang("WELCOME_PLAYER", "", DisplayName)}");
                }
            }
            if (AlertPersonal.UseWelcomeMessage)
            {
                String WelcomeMessage = GetMessages(player, AlertPersonal.WelcomeMessage.LanguageMessages);
                if (String.IsNullOrWhiteSpace(WelcomeMessage)) return;
                ReplySystem(player, WelcomeMessage);
            }
        }
        #endregion

        #region Mute Controller
        private void MutePlayer(BasePlayer Target, MuteType Type, Int32 ReasonIndex, BasePlayer Moderator = null, String ReasonCustom = null, Int32 TimeCustom = 0, Boolean HideMute = false, Boolean Command = false, String fakeUserId = "")
        {
            Configuration.ControllerMute ControllerMutes = config.ControllerMutes;

            if (IsReadyIQFakeActive() && Target == null && !String.IsNullOrWhiteSpace(fakeUserId))
            {
                ReplySystem(Moderator, GetLang(Type == MuteType.Chat ? "FUNC_MESSAGE_MUTE_CHAT" : "FUNC_MESSAGE_MUTE_VOICE", Moderator != null ? Moderator.displayName : Moderator.UserIDString, GetLang("IQCHAT_FUNCED_ALERT_TITLE_SERVER"), GetFakeName(fakeUserId), FormatTime(TimeCustom == 0 ? config.ControllerMutes.MuteChatReasons[ReasonIndex].SecondMute : TimeCustom), ReasonCustom ?? config.ControllerMutes.MuteChatReasons[ReasonIndex].Reason));
                SetMuteFakeUser(fakeUserId, true);
                return;
            }

            if (!UserInformation.ContainsKey(Target.userID)) return;
            User Info = UserInformation[Target.userID];

            String LangMessage = String.Empty;
            String Reason = String.Empty;
            Int32 MuteTime = 0;
            
            String NameModerator = GetLang("IQCHAT_FUNCED_ALERT_TITLE_SERVER", Target.UserIDString);

            if (Moderator != null)
            {
                if (!permission.UserHasPermission(Moderator.UserIDString, PermissionHideMuteName))
                {
                    GeneralInformation.RenameInfo ModeratorRename = GeneralInfo.GetInfoRename(Moderator.userID);
                    NameModerator = ModeratorRename != null ? $"{ModeratorRename.RenameNick ?? Moderator.displayName}" : Moderator.displayName;
                }
            }

            GeneralInformation.RenameInfo TagetRename = GeneralInfo.GetInfoRename(Target.userID);
            String TargetName = TagetRename != null ? $"{TagetRename.RenameNick ?? Target.displayName}" : Target.displayName;

            if (Target == null || !Target.IsConnected)
            {
                if (Moderator != null && !Command)
                    ReplySystem(Moderator, GetLang("UI_CHAT_PANEL_MODERATOR_MUTE_PANEL_TAKE_TYPE_CHAT_ACTION_NOT_CONNNECTED", Moderator.UserIDString));
                return;
            }

            if (Moderator != null && !Command)
                if (Info.MuteInfo.IsMute(Type))
                {
                    ReplySystem(Moderator, GetLang("IQCHAT_FUNCED_ALERT_TITLE_ISMUTED", Moderator.UserIDString));
                    return;
                }

            switch (Type)
            {
                case MuteType.Chat:
                    {
                        Reason = ReasonCustom ?? ControllerMutes.MuteChatReasons[ReasonIndex].Reason;
                        MuteTime = TimeCustom == 0 ? ControllerMutes.MuteChatReasons[ReasonIndex].SecondMute : TimeCustom;
                        LangMessage = "FUNC_MESSAGE_MUTE_CHAT";
                        break;
                    }
                case MuteType.Voice:
                    {
                        Reason = ReasonCustom ?? ControllerMutes.MuteVoiceReasons[ReasonIndex].Reason;
                        MuteTime = TimeCustom == 0 ? ControllerMutes.MuteVoiceReasons[ReasonIndex].SecondMute : TimeCustom;
                        LangMessage = "FUNC_MESSAGE_MUTE_VOICE";
                        break;
                    }
            }

            Info.MuteInfo.SetMute(Type, MuteTime);

            if (Moderator != null && Moderator != Target)
                Interface.Oxide.CallHook("OnPlayerMuted", Target, Moderator, MuteTime, Reason);

            if (!HideMute)
                ReplyBroadcast(null, null, false, LangMessage, NameModerator, TargetName, FormatTime(MuteTime, Target.UserIDString), Reason);
               // ReplyBroadcast(GetLang(LangMessage, Target.UserIDString, NameModerator, TargetName, FormatTime(MuteTime, Target.UserIDString), Reason));
            else
            {
                if (Target != null)
                    ReplySystem(Target, GetLang(LangMessage, Target.UserIDString, NameModerator, TargetName, FormatTime(MuteTime, Target.UserIDString), Reason));

                if (Moderator != null)
                    ReplySystem(Moderator, GetLang(LangMessage, Target.UserIDString, NameModerator, TargetName, FormatTime(MuteTime, Target.UserIDString), Reason));
            }

            DiscordLoggMuted(Target, Type, Reason, FormatTime(MuteTime, Target.UserIDString), Moderator);
        }

        private void UnmutePlayer(BasePlayer Target, MuteType Type, BasePlayer Moderator = null, Boolean HideUnmute = false, Boolean Command = false, String fakeUserId = "")
        {
            if (IsReadyIQFakeActive() && !String.IsNullOrWhiteSpace(fakeUserId))
            {
                if (Moderator != null)
                {
                    String fakeName = GetFakeName(fakeUserId);
                    ReplyBroadcast(null, null, false, Type == MuteType.Chat ? "FUNC_MESSAGE_UNMUTE_CHAT" : "FUNC_MESSAGE_UNMUTE_VOICE", Moderator.displayName, fakeName);
                }

                SetMuteFakeUser(fakeUserId, false);
                return;
            }
            
            if (!UserInformation.ContainsKey(Target.userID)) return;
            User Info = UserInformation[Target.userID];

            GeneralInformation.RenameInfo TargetRename = GeneralInfo.GetInfoRename(Target.userID);
            GeneralInformation.RenameInfo ModeratorRename = Moderator != null ? GeneralInfo.GetInfoRename(Moderator.userID) : null;
            if (!Info.MuteInfo.IsMute(Type))
            {
                if (Moderator != null)
                    ReplySystem(Moderator, LanguageEn ? "The player is not banned" : "У игрока нет блокировки");
                else Puts(LanguageEn ? "The player is not banned!" : "У игрока нет блокировки!");
                return;
            }

            String TargetName = TargetRename != null ? $"{TargetRename.RenameNick ?? Target.displayName}" : Target.displayName;
            String NameModerator = Moderator == null ? GetLang("IQCHAT_FUNCED_ALERT_TITLE_SERVER", Target.UserIDString) : permission.UserHasPermission(Moderator.UserIDString, PermissionHideMuteName) ? GetLang("IQCHAT_FUNCED_ALERT_TITLE_SERVER", Target.UserIDString) : ModeratorRename != null ? $"{ModeratorRename.RenameNick ?? Moderator.displayName}" : Moderator.displayName;
            String LangMessage = Type == MuteType.Chat ? "FUNC_MESSAGE_UNMUTE_CHAT" : "FUNC_MESSAGE_UNMUTE_VOICE";

            if (!HideUnmute)
            {
                if (Moderator != null)
                    if (!Moderator.IsAdmin && Moderator.userID == Target.userID)
                    {
                        ReplySystem(Moderator, GetLang("FUNC_MESSAGE_UNMUTE_YOURSELF", Moderator.UserIDString));
                        return;
                    }

                ReplyBroadcast(null, null, false, LangMessage, NameModerator, TargetName);
            }
            else
            {
                if (Target != null)
                    ReplySystem(Target, GetLang(LangMessage, Target.UserIDString, NameModerator, TargetName));
                if (Moderator != null)
                {
                    if (!Moderator.IsAdmin && Moderator.userID == Target.userID)
                    {
                        ReplySystem(Moderator, GetLang("FUNC_MESSAGE_UNMUTE_YOURSELF", Moderator.UserIDString));
                        return;
                    }

                    ReplySystem(Moderator, GetLang(LangMessage, Moderator.UserIDString, NameModerator, TargetName));
                }
            }

            Info.MuteInfo.UnMute(Type);
            
            if (Moderator != null && Moderator != Target)
                Interface.Oxide.CallHook("OnPlayerUnMuted", Target, Moderator);

            DiscordLoggMuted(Target, Type, Moderator: Moderator);
        }

        #endregion

        #region Alert Metods
        void AlertUI(BasePlayer Sender, string[] arg)
        {
            if (_interface == null)
            {
                PrintWarning(LanguageEn ? "We generate the interface, wait for a message about successful generation" : "Генерируем интерфейс, ожидайте сообщения об успешной генерации");
                return;
            }
            String Message = GetMessageInArgs(Sender, arg);
            if (Message == null) return;

            foreach (BasePlayer PlayerInList in BasePlayer.activePlayerList)
                DrawUI_IQChat_Alert(PlayerInList, Message);
        }
        void AlertUI(BasePlayer Sender, BasePlayer Recipient, string[] arg)
        {
            if (_interface == null)
            {
                PrintWarning(LanguageEn ? "We generate the interface, wait for a message about successful generation" : "Генерируем интерфейс, ожидайте сообщения об успешной генерации");
                return;
            }
            String Message = GetMessageInArgs(Sender, arg);
            if (Message == null) return;

            DrawUI_IQChat_Alert(Recipient, Message);
        }
        void Alert(BasePlayer Sender, string[] arg, Boolean IsAdmin)
        {
            String Message = GetMessageInArgs(Sender, arg);
            if (Message == null) return;

            ReplyBroadcast(Message, AdminAlert: IsAdmin);

            if (config.RustPlusSettings.UseRustPlus)
                foreach (BasePlayer playerList in BasePlayer.activePlayerList)
                    NotificationList.SendNotificationTo(playerList.userID, NotificationChannel.SmartAlarm, config.RustPlusSettings.DisplayNameAlert, Message, Util.GetServerPairingData());
        }
        void Alert(BasePlayer Sender, BasePlayer Recipient, string[] arg)
        {
            String Message = GetMessageInArgs(Sender, arg);
            if (Message == null) return;

            ReplySystem(Recipient, Message);
        }

        #endregion

        #region ShowPlayersOnline

        private Int32 GetPlayersOnlineShort()
        {
            if (IsReadyIQFakeActive())
            {
                List<FakePlayer> combinedPlayers = GetCombinedPlayerList();
                if (combinedPlayers != null)
                    return GetCombinedPlayerList().Count(fp => !permission.UserHasPermission(fp.userId, PermissionHideOnline));
            }
            return BasePlayer.activePlayerList.Count(p => !permission.UserHasPermission(p.UserIDString, PermissionHideOnline));
        }
        private List<String> GetPlayersOnline()
        {
            List<String> PlayerNames = new List<String>();
            Int32 Count = 1;

            if (IsReadyIQFakeActive())
            {
                List<FakePlayer> fakePlayerList = GetCombinedPlayerList();
                if (fakePlayerList != null)
                {
                    String prefix = API_GET_DEFAULT_PREFIX();
                    String colorNick = API_GET_DEFAULT_NICK_COLOR();

                    foreach (FakePlayer combinedPlayer in fakePlayerList)
                    {
                        String resultName = IsFakeUser(combinedPlayer.userId)
                            ? $"{Count} - {prefix}<color={colorNick}>{combinedPlayer.displayName}</color>"
                            : $"{Count} - {GetPlayerFormat(combinedPlayer.displayName, combinedPlayer.userId)}";
                        PlayerNames.Add(resultName);

                        Count++;
                    }

                    return PlayerNames;
                }
            }
            
            foreach (BasePlayer playerInList in BasePlayer.activePlayerList.Where(p => !permission.UserHasPermission(p.UserIDString, PermissionHideOnline)))
            {
                PlayerNames.Add($"{Count} - {GetPlayerFormat(playerInList.displayName, playerInList.UserIDString)}");
                Count++;
            }
            
            return PlayerNames;
        }

        private String GetPlayerFormat(String displayName, String userId)
        {
            if (!UInt64.TryParse(userId, out UInt64 userID)) return $"<color=54aafe>{displayName}</color>";
            
            GeneralInformation.RenameInfo Renamer = GeneralInfo.GetInfoRename(userID);
            String NickNamed = Renamer != null ? $"{Renamer.RenameNick ?? displayName}" : displayName;

            User Info = UserInformation[userID];
            Configuration.ControllerParameters ControllerParameter = config.ControllerParameter;

            String Prefixes = String.Empty;
            String ColorNickPlayer = String.IsNullOrWhiteSpace(Info.Info.ColorNick) ? "#54aafe" : Info.Info.ColorNick;

            String DisplayName = NickNamed;
            
            Object resultColorNick = IsGradientColorValue(ColorNickPlayer);
            if (resultColorNick is List<String> gradientColors)
                DisplayName = ApplyGradientToText(DisplayName, gradientColors);
            else DisplayName = $"<color={ColorNickPlayer}>{DisplayName}</color>";
            
            if (ControllerParameter.Prefixes.TurnMultiPrefixes)
            {
                if (Info.Info.PrefixList != null)
                    Prefixes = String.Join("", Info.Info.PrefixList.Take(ControllerParameter.Prefixes.MaximumMultiPrefixCount));
            }
            else Prefixes = Info.Info.Prefix;

            String ResultName = $"{Prefixes}{DisplayName}";

            return ResultName;
        }
        #endregion

        #region Nick Controller

        private void ControlledBadNick(IPlayer player)
        {
            if (player == null) return;
            Configuration.ControllerMessage ControllerMessage = config.ControllerMessages;

            String DisplayName = player.Name;

            Tuple<String, Boolean> GetTupleNick = BadWordsCleaner(DisplayName,
                ControllerMessage.Formatting.ControllerNickname.ReplaceBadNick,
                ControllerMessage.Formatting.ControllerNickname.BadNicks);
            DisplayName = GetTupleNick.Item1;

            DisplayName = RemoveLinkText(DisplayName);
            player.Rename(DisplayName);
        }


        #endregion

        #endregion

        #region IQChat_Menu 
        
        #region ImageLoader

        private class ImageUI
        {
            private const String _path = "IQSystem/IQChat/Images/";
            private const String _printPath = "data/" + _path;
            private readonly Dictionary<String, ImageData> _images = new()
            {
                { "UI_IQCHAT_CONTEXT_NO_RANK", new ImageData() },
                { "UI_IQCHAT_CONTEXT_RANK", new ImageData() },
                { "IQCHAT_INFORMATION_ICON", new ImageData() },
                { "IQCHAT_SETTING_ICON", new ImageData() },
                { "IQCHAT_IGNORE_INFO_ICON", new ImageData() },
                { "IQCHAT_MODERATION_ICON", new ImageData() },
                { "IQCHAT_ELEMENT_PANEL_ICON", new ImageData() },
                { "IQCHAT_ELEMENT_PREFIX_MULTI_TAKE_ICON", new ImageData() },
                { "IQCHAT_ELEMENT_SLIDER_ICON", new ImageData() },
                { "IQCHAT_ELEMENT_SLIDER_LEFT_ICON", new ImageData() },
                { "IQCHAT_ELEMENT_SLIDER_RIGHT_ICON", new ImageData() },
                { "IQCHAT_ELEMENT_DROP_LIST_OPEN_ICON", new ImageData() },
                { "IQCHAT_ELEMENT_DROP_LIST_OPEN_ARGUMENT_ICON", new ImageData() },
                { "IQCHAT_ELEMENT_DROP_LIST_OPEN_TAKED", new ImageData() },
                { "IQCHAT_ELEMENT_SETTING_CHECK_BOX", new ImageData() },
                { "IQCHAT_ALERT_PANEL", new ImageData() },
                { "IQCHAT_MUTE_AND_IGNORE_PANEL", new ImageData() },
                { "IQCHAT_MUTE_AND_IGNORE_ICON", new ImageData() },
                { "IQCHAT_MUTE_AND_IGNORE_SEARCH", new ImageData() },
                { "IQCHAT_MUTE_AND_IGNORE_PAGE_PANEL", new ImageData() },
                { "IQCHAT_MUTE_AND_IGNORE_PLAYER", new ImageData() },
                { "IQCHAT_MUTE_AND_IGNORE_PLAYER_STATUS", new ImageData() },
                { "IQCHAT_IGNORE_ALERT_PANEL", new ImageData() },
                { "IQCHAT_IGNORE_ALERT_ICON", new ImageData() },
                { "IQCHAT_IGNORE_ALERT_BUTTON_YES", new ImageData() },
                { "IQCHAT_IGNORE_ALERT_BUTTON_NO", new ImageData() },
                { "IQCHAT_MUTE_ALERT_PANEL", new ImageData() },
                { "IQCHAT_MUTE_ALERT_ICON", new ImageData() },
                { "IQCHAT_MUTE_ALERT_PANEL_REASON", new ImageData() },
              
            };

            private enum ImageStatus
            {
                NotLoaded,
                Loaded,
                Failed
            }

            private class ImageData
            {
                public ImageStatus Status = ImageStatus.NotLoaded;
                public string Id { get; set; }
            }

            public string GetImage(string name)
            {
                ImageData image;
                if (_images.TryGetValue(name, out image) && image.Status == ImageStatus.Loaded)
                    return image.Id;
                return null;
            }

            public void DownloadImage()
            {
                KeyValuePair<string, ImageData>? image = null;
                foreach (KeyValuePair<string, ImageData> img in _images)
                {
                    if (img.Value.Status == ImageStatus.NotLoaded)
                    {
                        image = img;
                        break;
                    }
                }

                if (image != null)
                {
                    ServerMgr.Instance.StartCoroutine(ProcessDownloadImage(image.Value));
                }
                else
                {
                    List<String> failedImages = new List<string>();

                    foreach (KeyValuePair<String, ImageData> img in _images)
                    {
                        if (img.Value.Status == ImageStatus.Failed)
                        {
                            failedImages.Add(img.Key);
                        }
                    }

                    if (failedImages.Count > 0)
                    {
                        String images = String.Join(", ", failedImages);
                        _.PrintError(LanguageEn
                            ? $"Failed to load the following images: {images}. Perhaps you did not upload them to the '{_printPath}' folder.\nDownloaded image - https://drive.google.com/drive/folders/1duFZ6jOjGGwY4Rni-GFD0doviOQiOKMi?usp=sharing"
                            : $"Не удалось загрузить следующие изображения: {images}. Возможно, вы не загрузили их в папку '{_printPath}'.\nСкачать можно тут - https://drive.google.com/drive/folders/1duFZ6jOjGGwY4Rni-GFD0doviOQiOKMi?usp=sharing");
                        Interface.Oxide.UnloadPlugin(_.Name);
                    }
                    else
                    {
                        _.Puts(LanguageEn
                            ? $"{_images.Count} images downloaded successfully!"
                            : $"{_images.Count} изображений успешно загружено!");
                        
                        _interface = new InterfaceBuilder();
                    }
                }
            }
            
            public void UnloadImages()
            {
                foreach (KeyValuePair<string, ImageData> item in _images)
                    if(item.Value.Status == ImageStatus.Loaded)
                        if (item.Value?.Id != null)
                            FileStorage.server.Remove(uint.Parse(item.Value.Id), FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID);

                _images?.Clear();
            }

            private IEnumerator ProcessDownloadImage(KeyValuePair<string, ImageData> image)
            {
                string url = "file://" + Interface.Oxide.DataDirectory + Path.DirectorySeparatorChar + _path + image.Key + ".png";

                using (UnityWebRequest www = UnityWebRequestTexture.GetTexture(url))
                {
                    yield return www.SendWebRequest();

                    if (www.isNetworkError || www.isHttpError)
                    {
                        image.Value.Status = ImageStatus.Failed;
                    }
                    else
                    {
                        Texture2D tex = DownloadHandlerTexture.GetContent(www);
                        image.Value.Id = FileStorage.server.Store(tex.EncodeToPNG(), FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID).ToString();
                        image.Value.Status = ImageStatus.Loaded;
                        UnityEngine.Object.DestroyImmediate(tex);
                    }

                    DownloadImage();
                }
            }
        }

        #endregion

        private static InterfaceBuilder _interface;
        private Dictionary<BasePlayer, InformationOpenedUI> LocalBase = new Dictionary<BasePlayer, InformationOpenedUI>();
        private class InformationOpenedUI
        {
            public List<Configuration.ControllerParameters.AdvancedFuncion> ElementsPrefix;
            public List<Configuration.ControllerParameters.AdvancedFuncion> ElementsNick;
            public List<Configuration.ControllerParameters.AdvancedFuncion> ElementsChat;
            public List<Configuration.ControllerParameters.AdvancedFuncion> ElementsRanks;
            public Int32 SlideIndexPrefix = 0;
            public Int32 SlideIndexNick = 0;
            public Int32 SlideIndexChat = 0;
            public Int32 SlideIndexRank = 0;
        }

        #region UpdateDisplayName Draw UI
        private void DrawUI_IQChat_Update_DisplayName(BasePlayer player)
        {
            String InterfaceVisualNick = InterfaceBuilder.GetInterface("UI_Chat_Context_Visual_Nick");
            User Info = UserInformation[player.userID];
            Configuration.ControllerParameters Controller = config.ControllerParameter;
            if (Info == null || InterfaceVisualNick == null || Controller == null) return;

            String DisplayNick = String.Empty;

            String Pattern = @"</?size.*?>";
            // if (Controller.Prefixes.TurnMultiPrefixes) 
            // {
            //     if (Info.Info.PrefixList != null && Info.Info.PrefixList.Count != 0)
            //         DisplayNick += Info.Info.PrefixList.Count > 1 ? $"{(Regex.IsMatch(Info.Info.PrefixList[0], Pattern) ? Regex.Replace(Info.Info.PrefixList[0], Pattern, "") : Info.Info.PrefixList[0])}+{Info.Info.PrefixList.Count - 1}" :
            //             (Regex.IsMatch(Info.Info.PrefixList[0], Pattern) ? Regex.Replace(Info.Info.PrefixList[0], Pattern, "") : Info.Info.PrefixList[0]);
            // }
            // else DisplayNick += Regex.IsMatch(Info.Info.Prefix, Pattern) ? Regex.Replace(Info.Info.Prefix, Pattern, "") : Info.Info.Prefix;
            //
            if (Controller.Prefixes.TurnMultiPrefixes)
            {
                if (Info.Info.PrefixList != null && Info.Info.PrefixList.Count != 0)
                {
                    if (Info.Info.PrefixList[0] != null && Regex.IsMatch(Info.Info.PrefixList[0], Pattern))
                        DisplayNick += Regex.Replace(Info.Info.PrefixList[0], Pattern, "");
                    else
                        DisplayNick += Info.Info.PrefixList[0];

                    DisplayNick += Info.Info.PrefixList.Count > 1 ? $"+{Info.Info.PrefixList.Count - 1}" : string.Empty;
                }
            }
            else
            {
                if (Info.Info.Prefix != null && Regex.IsMatch(Info.Info.Prefix, Pattern))
                    DisplayNick += Regex.Replace(Info.Info.Prefix, Pattern, "");
                else DisplayNick += Info.Info.Prefix;
            }

            String DisplayName = player.displayName;
            String ColorNickPlayer = !String.IsNullOrWhiteSpace(Info.Info.CustomColorNick)
                ? Info.Info.CustomColorNick
                : (Info.Info.ColorNick ?? "#ffffff");
            
            Object resultColorNick = IsGradientColorValue(ColorNickPlayer);
            if (resultColorNick is List<String> gradientColors)
                DisplayName = ApplyGradientToText(DisplayName, gradientColors);
            else DisplayName = $"<color={ColorNickPlayer}>{DisplayName}</color>";
            
            String ChatMessage = GetLang("IQCHAT_CONTEXT_NICK_DISPLAY_MESSAGE", player.UserIDString);
            String ColorChat = !String.IsNullOrWhiteSpace(Info.Info.CustomColorMessage) ? Info.Info.CustomColorMessage : Info.Info.ColorMessage;
            Object resultColorChat = IsGradientColorValue(ColorChat);
            if (resultColorChat is List<String> gradientChatColors)
                ChatMessage = ApplyGradientToText(ChatMessage, gradientChatColors);
            else ChatMessage = $"<color={ColorChat}>{ChatMessage}</color>";
            
            DisplayNick += $"{DisplayName}: <color={ColorChat ?? "#ffffff"}>{ChatMessage}</color>";

            InterfaceVisualNick = InterfaceVisualNick.Replace("%NICK_DISPLAY%", DisplayNick);

            CuiHelper.DestroyUi(player, InterfaceBuilder.UI_Chat_Context_Visual_Nick);
            CuiHelper.AddUi(player, InterfaceVisualNick);
        }
        #endregion

        #region Context Draw UI
        private void DrawUI_IQChat_Context(BasePlayer player)
        {
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_Context");
            User Info = UserInformation[player.userID];
            Configuration.ControllerParameters ControllerParameter = config.ControllerParameter;
            if (Info == null || ControllerParameter == null || Interface == null) return;

            String BackgroundStatic = IQRankSystem && config.ReferenceSetting.IQRankSystems.UseRankSystem ? "UI_IQCHAT_CONTEXT_RANK" : "UI_IQCHAT_CONTEXT_NO_RANK";
            
            Interface = Interface.Replace("%IMG_BACKGROUND%", _imageUI.GetImage(BackgroundStatic));
            Interface = Interface.Replace("%TITLE%", GetLang("IQCHAT_CONTEXT_TITLE", player.UserIDString));
            Interface = Interface.Replace("%SETTING_ELEMENT%", GetLang("IQCHAT_CONTEXT_SETTING_ELEMENT_TITLE", player.UserIDString));
            Interface = Interface.Replace("%INFORMATION%", GetLang("IQCHAT_CONTEXT_INFORMATION_TITLE", player.UserIDString));
            Interface = Interface.Replace("%SETTINGS%", GetLang("IQCHAT_CONTEXT_SETTINGS_TITLE", player.UserIDString));
            Interface = Interface.Replace("%SETTINGS_PM%", GetLang("IQCHAT_CONTEXT_SETTINGS_PM_TITLE", player.UserIDString));
            Interface = Interface.Replace("%SETTINGS_ALERT%", GetLang("IQCHAT_CONTEXT_SETTINGS_ALERT_TITLE", player.UserIDString));
            Interface = Interface.Replace("%SETTINGS_ALERT_PM%", GetLang("IQCHAT_CONTEXT_SETTINGS_ALERT_PM_TITLE", player.UserIDString));
            Interface = Interface.Replace("%SETTINGS_SOUNDS%", GetLang("IQCHAT_CONTEXT_SETTINGS_SOUNDS_TITLE", player.UserIDString));
            Interface = Interface.Replace("%MUTE_STATUS_TITLE%", GetLang("IQCHAT_CONTEXT_MUTE_STATUS_TITLE", player.UserIDString));
            Interface = Interface.Replace("%IGNORED_STATUS_COUNT%", GetLang("IQCHAT_CONTEXT_IGNORED_STATUS_COUNT", player.UserIDString, Info.Settings.IgnoreUsers.Count));
            Interface = Interface.Replace("%IGNORED_STATUS_TITLE%", GetLang("IQCHAT_CONTEXT_IGNORED_STATUS_TITLE", player.UserIDString));
            Interface = Interface.Replace("%NICK_DISPLAY_TITLE%", GetLang("IQCHAT_CONTEXT_NICK_DISPLAY_TITLE", player.UserIDString));
            Interface = Interface.Replace("%MUTE_STATUS_PLAYER%", Info.MuteInfo.IsMute(MuteType.Chat) ? FormatTime(Info.MuteInfo.GetTime(MuteType.Chat), player.UserIDString) : GetLang("IQCHAT_CONTEXT_MUTE_STATUS_NOT", player.UserIDString));
            Interface = Interface.Replace("%SLIDER_PREFIX_TITLE%", GetLang("IQCHAT_CONTEXT_SLIDER_PREFIX_TITLE", player.UserIDString));
            Interface = Interface.Replace("%SLIDER_NICK_COLOR_TITLE%", GetLang("IQCHAT_CONTEXT_SLIDER_NICK_COLOR_TITLE", player.UserIDString));

            Interface = Interface.Replace("%SLIDER_MESSAGE_COLOR_TITLE%",GetLang("IQCHAT_CONTEXT_SLIDER_MESSAGE_COLOR_TITLE", player.UserIDString));
            
            Interface = Interface.Replace("%SLIDER_IQRANK_TITLE%", IQRankSystem && config.ReferenceSetting.IQRankSystems.UseRankSystem ? GetLang("IQCHAT_CONTEXT_SLIDER_IQRANK_TITLE", player.UserIDString) : String.Empty);

            CuiHelper.DestroyUi(player, InterfaceBuilder.UI_Chat_Context);
            CuiHelper.AddUi(player, Interface);

            DrawUI_IQChat_Update_DisplayName(player);

            if (ControllerParameter.VisualParametres.PrefixType == SelectedParametres.DropList || ControllerParameter.Prefixes.TurnMultiPrefixes)
                DrawUI_IQChat_DropList(player, "-46.788 67.4", "-14.788 91.4", GetLang("IQCHAT_CONTEXT_SLIDER_PREFIX_TITLE_DESCRIPTION", player.UserIDString), ControllerParameter.Prefixes.TurnMultiPrefixes ? TakeElementUser.MultiPrefix : TakeElementUser.Prefix);
            else DrawUI_IQChat_Sliders(player, "SLIDER_PREFIX", "-140 54", "-16 78", TakeElementUser.Prefix);

            if (ControllerParameter.VisualParametres.NickColorType == SelectedParametres.DropList)
                DrawUI_IQChat_DropList(player, "112.34 67.4", "144.34 91.4", GetLang("IQCHAT_CONTEXT_SLIDER_CHAT_NICK_TITLE_DESCRIPTION", player.UserIDString), TakeElementUser.Nick);
            else DrawUI_IQChat_Sliders(player, "SLIDER_NICK_COLOR", "20 54", "144 78", TakeElementUser.Nick);
            
            if (ControllerParameter.VisualParametres.ChatColorType == SelectedParametres.DropList)
                DrawUI_IQChat_DropList(player, "-46.787 -0.591", "-14.787 23.409",GetLang("IQCHAT_CONTEXT_SLIDER_CHAT_MESSAGE_TITLE_DESCRIPTION", player.UserIDString),TakeElementUser.Chat);
            else DrawUI_IQChat_Sliders(player, "SLIDER_MESSAGE_COLOR", "-140 -12", "-16 12", TakeElementUser.Chat);

            if (IQRankSystem && config.ReferenceSetting.IQRankSystems.UseRankSystem)
            {
                if (ControllerParameter.VisualParametres.IQRankSystemType == SelectedParametres.DropList)
                    DrawUI_IQChat_DropList(player, "112.34 -0.591", "144.34 23.409", GetLang("IQCHAT_CONTEXT_SLIDER_IQRANK_TITLE_DESCRIPTION", player.UserIDString), TakeElementUser.Rank);
                else DrawUI_IQChat_Sliders(player, "SLIDER_IQRANK", "20 -12", "144 12", TakeElementUser.Rank);
            }

            DrawUI_IQChat_Update_Check_Box(player, ElementsSettingsType.PM, "143.38 -67.9", "151.38 -59.9", Info.Settings.TurnPM);
            DrawUI_IQChat_Update_Check_Box(player, ElementsSettingsType.Broadcast, "143.38 -79.6", "151.38 -71.6", Info.Settings.TurnBroadcast);
            DrawUI_IQChat_Update_Check_Box(player, ElementsSettingsType.Alert, "143.38 -91.6", "151.38 -83.6", Info.Settings.TurnAlert);
            DrawUI_IQChat_Update_Check_Box(player, ElementsSettingsType.Sound, "143.38 -103.6", "151.38 -95.6", Info.Settings.TurnSound);
            DrawUI_IQChat_Context_AdminAndModeration(player);
        }
        private void DrawUI_IQChat_Context_AdminAndModeration(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, PermissionMute)) return;

            String InterfaceModeration = InterfaceBuilder.GetInterface("UI_Chat_Moderation");
            if (InterfaceModeration == null) return;

            InterfaceModeration = InterfaceModeration.Replace("%TITLE%", GetLang("IQCHAT_TITLE_MODERATION_PANEL", player.UserIDString));
            InterfaceModeration = InterfaceModeration.Replace("%COMMAND_MUTE_MENU%", $"newui.cmd action.mute.ignore open {SelectedAction.Mute}");
            InterfaceModeration = InterfaceModeration.Replace("%TEXT_MUTE_MENU%", GetLang("IQCHAT_BUTTON_MODERATION_MUTE_MENU", player.UserIDString));

            CuiHelper.AddUi(player, InterfaceModeration);

            DrawUI_IQChat_Update_MuteChat_All(player);
            DrawUI_IQChat_Update_MuteVoice_All(player);
        }
        private void DrawUI_IQChat_Update_MuteChat_All(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, PermissionMutedAdmin)) return;

            String InterfaceAdministratorChat = InterfaceBuilder.GetInterface("UI_Chat_Administation_AllChat");
            if (InterfaceAdministratorChat == null) return;

            InterfaceAdministratorChat = InterfaceAdministratorChat.Replace("%TEXT_MUTE_ALLCHAT%", GetLang(!GeneralInfo.TurnMuteAllChat ? "IQCHAT_BUTTON_MODERATION_MUTE_ALL_CHAT" : "IQCHAT_BUTTON_MODERATION_UNMUTE_ALL_CHAT", player.UserIDString));
            InterfaceAdministratorChat = InterfaceAdministratorChat.Replace("%COMMAND_MUTE_ALLCHAT%", $"newui.cmd action.mute.ignore mute.controller {SelectedAction.Mute} mute.all.chat");

            CuiHelper.DestroyUi(player, "ModeratorMuteAllChat");
            CuiHelper.AddUi(player, InterfaceAdministratorChat);
        }
        private void DrawUI_IQChat_Update_MuteVoice_All(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, PermissionMutedAdmin)) return;

            String InterfaceAdministratorVoice = InterfaceBuilder.GetInterface("UI_Chat_Administation_AllVoce");
            if (InterfaceAdministratorVoice == null) return;

            InterfaceAdministratorVoice = InterfaceAdministratorVoice.Replace("%TEXT_MUTE_ALLVOICE%", GetLang(!GeneralInfo.TurnMuteAllVoice ? "IQCHAT_BUTTON_MODERATION_MUTE_ALL_VOICE" : "IQCHAT_BUTTON_MODERATION_UNMUTE_ALL_VOICE", player.UserIDString));
            InterfaceAdministratorVoice = InterfaceAdministratorVoice.Replace("%COMMAND_MUTE_ALLVOICE%", $"newui.cmd action.mute.ignore mute.controller {SelectedAction.Mute} mute.all.voice");

            CuiHelper.DestroyUi(player, "ModeratorMuteAllVoice");
            CuiHelper.AddUi(player, InterfaceAdministratorVoice);
        }
        #endregion

        #region MuteAndIgnore Draw UI

        #region Ignore Alert
        private void DrawUI_IQChat_Ignore_Alert(BasePlayer player, BasePlayer Target, UInt64 fakeUserId = 0)
        {
            String InterfacePanel = InterfaceBuilder.GetInterface("UI_Chat_Mute_And_Ignore_Alert_Panel");
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_Ignore_Alert");
            if (Interface == null || InterfacePanel == null) return;

            Boolean isFake = (IsReadyIQFakeActive() && Target == null && fakeUserId != 0);
            
            GeneralInformation.RenameInfo Renamer = isFake ? null : GeneralInfo.GetInfoRename(Target.userID);
            String NickNamed = isFake ? GetFakeName(fakeUserId.ToString()) : Renamer != null ? $"{Renamer.RenameNick ?? Target.displayName}" : Target.displayName;

            Interface = Interface.Replace("%TITLE%", GetLang(UserInformation[player.userID].Settings.IsIgnored(isFake ? fakeUserId : Target.userID) ? "IQCHAT_TITLE_IGNORE_TITLES_UNLOCK" : "IQCHAT_TITLE_IGNORE_TITLES", player.UserIDString, NickNamed));
            Interface = Interface.Replace("%BUTTON_YES%", GetLang("IQCHAT_TITLE_IGNORE_BUTTON_YES", player.UserIDString));
            Interface = Interface.Replace("%BUTTON_NO%", GetLang("IQCHAT_TITLE_IGNORE_BUTTON_NO", player.UserIDString));
            Interface = Interface.Replace("%COMMAND%", $"newui.cmd action.mute.ignore ignore.and.mute.controller {SelectedAction.Ignore} confirm.yes {(isFake ? fakeUserId : Target.userID)}");

            CuiHelper.DestroyUi(player, "MUTE_AND_IGNORE_PANEL_ALERT");
            CuiHelper.AddUi(player, InterfacePanel);
            CuiHelper.AddUi(player, Interface);
        }
        #endregion

        #region Mute Alert
        private void DrawUI_IQChat_Mute_Alert(BasePlayer player, BasePlayer Target, UInt64 IDFake = 0)
        {
            String InterfacePanel = InterfaceBuilder.GetInterface("UI_Chat_Mute_And_Ignore_Alert_Panel");
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_Mute_Alert");
            if (Interface == null || InterfacePanel == null) return;

            Boolean isFake = (IsReadyIQFakeActive() && Target == null && IDFake != 0);
            User InfoTarget = isFake ? null : UserInformation[Target.userID];
            FakePlayer fakePlayer = GetCombinedPlayerList() == null ? null : GetCombinedPlayerList().FirstOrDefault(x => x.userId == IDFake.ToString());
            if (isFake && fakePlayer == null)
                return;
            
            Interface = Interface.Replace("%TITLE%", GetLang("IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT", player.UserIDString));
            Interface = Interface.Replace("%BUTTON_TAKE_CHAT_ACTION%", (isFake && fakePlayer is { isMuted: false }) ? GetLang("IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_CHAT", player.UserIDString) : (isFake && fakePlayer is { isMuted: true }) ? GetLang("IQCHAT_BUTTON_MODERATION_UNMUTE_MENU_TITLE_ALERT_CHAT", player.UserIDString) : InfoTarget == null ? GetLang("IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_CHAT", player.UserIDString) : InfoTarget.MuteInfo.IsMute(MuteType.Chat) ? GetLang("IQCHAT_BUTTON_MODERATION_UNMUTE_MENU_TITLE_ALERT_CHAT", player.UserIDString) : GetLang("IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_CHAT", player.UserIDString));
            Interface = Interface.Replace("%BUTTON_TAKE_VOICE_ACTION%", (isFake && fakePlayer is { isMuted: false }) ? GetLang("IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_VOICE", player.UserIDString) : (isFake && fakePlayer is { isMuted: true }) ? GetLang("IQCHAT_BUTTON_MODERATION_UNMUTE_MENU_TITLE_ALERT_VOICE", player.UserIDString) : InfoTarget == null ? GetLang("IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_VOICE", player.UserIDString) : InfoTarget.MuteInfo.IsMute(MuteType.Voice) ? GetLang("IQCHAT_BUTTON_MODERATION_UNMUTE_MENU_TITLE_ALERT_VOICE", player.UserIDString) : GetLang("IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_VOICE", player.UserIDString));
            Interface = Interface.Replace("%COMMAND_TAKE_ACTION_MUTE_CHAT%", (isFake && fakePlayer is { isMuted: false }) ? $"newui.cmd action.mute.ignore ignore.and.mute.controller {SelectedAction.Mute} open.reason.mute {IDFake} {MuteType.Chat}" : (isFake && fakePlayer is { isMuted: true }) ? $"newui.cmd action.mute.ignore ignore.and.mute.controller {SelectedAction.Mute} unmute.yes {fakePlayer.userId} {MuteType.Chat}" : InfoTarget == null ? $"newui.cmd action.mute.ignore ignore.and.mute.controller {SelectedAction.Mute} open.reason.mute {IDFake} {MuteType.Chat}" : InfoTarget.MuteInfo.IsMute(MuteType.Chat) ? $"newui.cmd action.mute.ignore ignore.and.mute.controller {SelectedAction.Mute} unmute.yes {Target.UserIDString} {MuteType.Chat}" : $"newui.cmd action.mute.ignore ignore.and.mute.controller {SelectedAction.Mute} open.reason.mute {Target.UserIDString} {MuteType.Chat}");
            Interface = Interface.Replace("%COMMAND_TAKE_ACTION_MUTE_VOICE%", (isFake && fakePlayer is { isMuted: false }) ? $"newui.cmd action.mute.ignore ignore.and.mute.controller {SelectedAction.Mute} open.reason.mute {IDFake} {MuteType.Voice}" : (isFake && fakePlayer is { isMuted: true }) ? $"newui.cmd action.mute.ignore ignore.and.mute.controller {SelectedAction.Mute} unmute.yes {fakePlayer.userId} {MuteType.Voice}" : InfoTarget == null ? $"newui.cmd action.mute.ignore ignore.and.mute.controller {SelectedAction.Mute} open.reason.mute {IDFake} {MuteType.Voice}" : InfoTarget.MuteInfo.IsMute(MuteType.Voice) ? $"newui.cmd action.mute.ignore ignore.and.mute.controller {SelectedAction.Mute} unmute.yes {Target.UserIDString} {MuteType.Voice}" : $"newui.cmd action.mute.ignore ignore.and.mute.controller {SelectedAction.Mute} open.reason.mute {Target.UserIDString} {MuteType.Voice}");

            CuiHelper.DestroyUi(player, "MUTE_AND_IGNORE_PANEL_ALERT");
            CuiHelper.AddUi(player, InterfacePanel);
            CuiHelper.AddUi(player, Interface);
        }
        private void DrawUI_IQChat_Mute_Alert_Reasons(BasePlayer player, BasePlayer Target, MuteType Type, UInt64 IDFake = 0)
        {
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_Mute_Alert_DropList_Title");
            if (Interface == null) return;

            Interface = Interface.Replace("%TITLE%", GetLang("IQCHAT_BUTTON_MODERATION_MUTE_MENU_TITLE_ALERT_REASON", player.UserIDString));

            CuiHelper.DestroyUi(player, "AlertMuteTitleReason");
            CuiHelper.DestroyUi(player, "PanelMuteReason");
            CuiHelper.AddUi(player, Interface);

            List<Configuration.ControllerMute.Muted> Reasons = Type == MuteType.Chat ? config.ControllerMutes.MuteChatReasons : config.ControllerMutes.MuteVoiceReasons;

            Int32 Y = 0;
            foreach (Configuration.ControllerMute.Muted Reason in Reasons.Take(6))
                DrawUI_IQChat_Mute_Alert_Reasons(player, Target, Reason.Reason, Y++, Type, IDFake);
        }

        private void DrawUI_IQChat_Mute_Alert_Reasons(BasePlayer player, BasePlayer Target, String Reason, Int32 Y, MuteType Type, UInt64 IDFake = 0)
        {
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_Mute_Alert_DropList_Reason");
            if (Interface == null) return;

            Interface = Interface.Replace("%OFFSET_MIN%", $"-147.5 {85.42 - (Y * 40)}");
            Interface = Interface.Replace("%OFFSET_MAX%", $"147.5 {120.42 - (Y * 40)}");
            Interface = Interface.Replace("%REASON%", Reason);
            Interface = Interface.Replace("%COMMAND_REASON%", $"newui.cmd action.mute.ignore ignore.and.mute.controller {SelectedAction.Mute} confirm.yes {((IsReadyIQFakeActive() && Target == null && IDFake != 0) ? IDFake : Target.userID)} {Type} {Y}");
            CuiHelper.AddUi(player, Interface);
        }
        #endregion

        private void DrawUI_IQChat_Mute_And_Ignore(BasePlayer player, SelectedAction Action)
        {
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_Mute_And_Ignore");
            if (Interface == null) return;

            Interface = Interface.Replace("%TITLE%", Action == SelectedAction.Mute ? GetLang("IQCHAT_TITLE_IGNORE_AND_MUTE_MUTED", player.UserIDString) : GetLang("IQCHAT_TITLE_IGNORE_AND_MUTE_IGNORED", player.UserIDString));
            Interface = Interface.Replace("%ACTION_TYPE%", $"{Action}");

            CuiHelper.DestroyUi(player, "MuteAndIgnoredPanel");
            CuiHelper.AddUi(player, Interface);

            DrawUI_IQChat_Mute_And_Ignore_Player_Panel(player, Action);
        }

        private void DrawUI_IQChat_Mute_And_Ignore_Player_Panel(BasePlayer player, SelectedAction Action, Int32 Page = 0, String SearchName = null)
        {
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_Mute_And_Ignore_Panel_Content");
            if (Interface == null) return;

            CuiHelper.DestroyUi(player, "MuteIgnorePanelContent");
            CuiHelper.AddUi(player, Interface);
            
            if (IsReadyIQFakeActive())
            {
                List<FakePlayer> filteredPlayers = GetFilteredPlayers(SearchName);

                DrawUI_IQChat_Mute_And_Ignore_Pages(player, HasMorePages(filteredPlayers, Page), Action, Page);
                DrawUI_IQChat_Mute_And_Ignore_Player(player, Action, null, GetPageOfPlayers(filteredPlayers, Page));
            }
            else
            {
                IOrderedEnumerable<BasePlayer> playerList = GetPlayerList(SearchName, Action);

                DrawUI_IQChat_Mute_And_Ignore_Pages(player, HasMorePages(playerList, Page), Action, Page);
                DrawUI_IQChat_Mute_And_Ignore_Player(player, Action, playerList.Skip(18 * Page).Take(18));
            }
        }
        
        private List<FakePlayer> GetFilteredPlayers(string searchName)
        {
            var combinedPlayerList = GetCombinedPlayerList();
            var filteredPlayers = combinedPlayerList;

            if (searchName != null)
                filteredPlayers = filteredPlayers.Where(p => p.displayName.ToLower().Contains(searchName.ToLower())).ToList();

            filteredPlayers = filteredPlayers.OrderByDescending(p => !IsFakeUser(p.userId) &&
                                                                     TryGetUserIdAsUlong(p.userId, out UInt64 userIdAsUlong) &&
                                                                     UserInformation.ContainsKey(userIdAsUlong) &&
                                                                     (UserInformation[userIdAsUlong].MuteInfo.IsMute(MuteType.Chat) || UserInformation[userIdAsUlong].MuteInfo.IsMute(MuteType.Voice))).ToList();

            return filteredPlayers;
        }
        private Boolean TryGetUserIdAsUlong(String userId, out UInt64 userIdAsUlong) => UInt64.TryParse(userId, out userIdAsUlong);
        private Boolean HasMorePages<T>(IEnumerable<T> items, Int32 page) => items != null && items.Skip(18 * (page + 1)).Any();
        private IEnumerable<T> GetPageOfPlayers<T>(IEnumerable<T> items, Int32 page) => items != null ? items.Skip(18 * page).Take(18) : Enumerable.Empty<T>();
        private IOrderedEnumerable<BasePlayer> GetPlayerList(String searchName, SelectedAction action)
        {
            List<BasePlayer> basePlayerList = BasePlayer.activePlayerList.ToList();

            if (searchName != null)
                basePlayerList = basePlayerList.Where(p => UserInformation.ContainsKey(p.userID) && p.displayName.ToLower().Contains(searchName.ToLower())).ToList();

            return action == SelectedAction.Mute ?
                basePlayerList.OrderBy(p => UserInformation[p.userID].MuteInfo.IsMute(MuteType.Chat) || UserInformation[p.userID].MuteInfo.IsMute(MuteType.Voice)) :
                basePlayerList.OrderBy(p => UserInformation[p.userID].Settings.IgnoreUsers.Contains(p.userID));
        }
        
        private void DrawUI_IQChat_Mute_And_Ignore_Pages(BasePlayer player, Boolean IsNextPage, SelectedAction Action, Int32 Page = 0)
        {
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_Mute_And_Ignore_Pages");
            if (Interface == null) return;

            String CommandRight = IsNextPage ? $"newui.cmd action.mute.ignore page.controller {Action} {Page + 1}" : String.Empty;
            String ColorRight = String.IsNullOrEmpty(CommandRight) ? "1 1 1 0.1" : "1 1 1 1";

            String CommandLeft = Page > 0 ? $"newui.cmd action.mute.ignore page.controller {Action} {Page - 1}" : String.Empty;
            String ColorLeft = String.IsNullOrEmpty(CommandLeft) ? "1 1 1 0.1" : "1 1 1 1";

            Interface = Interface.Replace("%COMMAND_LEFT%", CommandLeft);
            Interface = Interface.Replace("%COMMAND_RIGHT%", CommandRight);
            Interface = Interface.Replace("%PAGE%", $"{Page}");
            Interface = Interface.Replace("%COLOR_LEFT%", ColorLeft);
            Interface = Interface.Replace("%COLOR_RIGHT%", ColorRight);

            CuiHelper.DestroyUi(player, "PageCount");
            CuiHelper.DestroyUi(player, "LeftPage");
            CuiHelper.DestroyUi(player, "RightPage");
            CuiHelper.AddUi(player, Interface);
        }
        private void DrawUI_IQChat_Mute_And_Ignore_Player(BasePlayer player, SelectedAction Action, IEnumerable<BasePlayer> PlayerList, IEnumerable<FakePlayer> FakePlayerList = null)
        {
            User MyInfo = UserInformation[player.userID];
            if (MyInfo == null) return;
            Int32 X = 0, Y = 0;
            String ColorGreen = "0.5803922 1 0.5372549 1";
            String ColorRed = "0.8962264 0.2578764 0.3087685 1";
            String Color = String.Empty;

            if (IsReadyIQFakeActive() && FakePlayerList != null)
            {
                foreach (FakePlayer playerInList in FakePlayerList)
                {
                    String Interface = InterfaceBuilder.GetInterface("UI_Chat_Mute_And_Ignore_Player");
                    if (Interface == null) return;

                    String DisplayName = playerInList.displayName;
                    if (!UInt64.TryParse(playerInList.userId, out UInt64 userIdAsUlong)) return;
                    
                    if (GeneralInfo.RenameList.ContainsKey(userIdAsUlong))
                        if (!String.IsNullOrWhiteSpace(GeneralInfo.RenameList[userIdAsUlong].RenameNick))
                            DisplayName = GeneralInfo.RenameList[userIdAsUlong].RenameNick;

                    Interface = Interface.Replace("%OFFSET_MIN%", $"{-385.795 - (-281.17 * X)} {97.54 - (46.185 * Y)}");
                    Interface = Interface.Replace("%OFFSET_MAX%", $"{-186.345 - (-281.17 * X)} {132.03 - (46.185 * Y)}");
                    Interface = Interface.Replace("%DISPLAY_NAME%", $"{DisplayName}");
                    Interface = Interface.Replace("%COMMAND_ACTION%", $"newui.cmd action.mute.ignore ignore.and.mute.controller {Action} confirm.alert {userIdAsUlong}");

                    switch (Action)
                    {
                        case SelectedAction.Mute:
                            if (playerInList.isMuted || (UserInformation.ContainsKey(userIdAsUlong) && UserInformation[userIdAsUlong] != null && (UserInformation[userIdAsUlong].MuteInfo.IsMute(MuteType.Chat) || UserInformation[userIdAsUlong].MuteInfo.IsMute(MuteType.Voice))))
                                Color = ColorRed;
                            else Color = ColorGreen;
                            break;
                        case SelectedAction.Ignore:
                            if (MyInfo.Settings.IsIgnored(userIdAsUlong))
                                Color = ColorRed;
                            else Color = ColorGreen;
                            break;
                        default:
                            break;
                    }

                    Interface = Interface.Replace("%COLOR%", Color);


                    X++;
                    if (X == 3)
                    {
                        X = 0;
                        Y++;
                    }

                    CuiHelper.AddUi(player, Interface);
                }
            }
            else
            {
                foreach (var playerInList in PlayerList)
                {
                    String Interface = InterfaceBuilder.GetInterface("UI_Chat_Mute_And_Ignore_Player");
                    if (Interface == null) return;
                    User Info = UserInformation[playerInList.userID];
                    if (Info == null) continue;

                    String DisplayName = playerInList.displayName;
                    if (GeneralInfo.RenameList.ContainsKey(playerInList.userID))
                        if (!String.IsNullOrWhiteSpace(GeneralInfo.RenameList[playerInList.userID].RenameNick))
                            DisplayName = GeneralInfo.RenameList[playerInList.userID].RenameNick;

                    Interface = Interface.Replace("%OFFSET_MIN%", $"{-385.795 - (-281.17 * X)} {97.54 - (46.185 * Y)}");
                    Interface = Interface.Replace("%OFFSET_MAX%", $"{-186.345 - (-281.17 * X)} {132.03 - (46.185 * Y)}");
                    Interface = Interface.Replace("%DISPLAY_NAME%", $"{DisplayName}");
                    Interface = Interface.Replace("%COMMAND_ACTION%", $"newui.cmd action.mute.ignore ignore.and.mute.controller {Action} confirm.alert {playerInList.userID}");

                    switch (Action)
                    {
                        case SelectedAction.Mute:
                            if (Info.MuteInfo.IsMute(MuteType.Chat) || Info.MuteInfo.IsMute(MuteType.Voice))
                                Color = ColorRed;
                            else Color = ColorGreen;
                            break;
                        case SelectedAction.Ignore:
                            if (MyInfo.Settings.IsIgnored(playerInList.userID))
                                Color = ColorRed;
                            else Color = ColorGreen;
                            break;
                        default:
                            break;
                    }

                    Interface = Interface.Replace("%COLOR%", Color);


                    X++;
                    if (X == 3)
                    {
                        X = 0;
                        Y++;
                    }

                    CuiHelper.AddUi(player, Interface);
                }
            }
        }
        #endregion

        #region CheckBox Draw UI 
        private void DrawUI_IQChat_Update_Check_Box(BasePlayer player, ElementsSettingsType Type, String OffsetMin, String OffsetMax, Boolean StatusCheckBox)
        {
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_Context_CheckBox");
            User Info = UserInformation[player.userID];
            if (Info == null || Interface == null) return;

            String Name = $"{Type}";
            Interface = Interface.Replace("%NAME_CHECK_BOX%", Name);
            Interface = Interface.Replace("%COLOR%", !StatusCheckBox ? "0.4716981 0.4716981 0.4716981 1" : "0.6040971 0.4198113 1 1");
            Interface = Interface.Replace("%OFFSET_MIN%", OffsetMin);
            Interface = Interface.Replace("%OFFSET_MAX%", OffsetMax);
            Interface = Interface.Replace("%COMMAND_TURNED%", $"newui.cmd checkbox.controller {Type}");

            CuiHelper.DestroyUi(player, Name);
            CuiHelper.AddUi(player, Interface);
        }

        #endregion

        #region Sliders Draw UI
        private void DrawUI_IQChat_Sliders(BasePlayer player, String Name, String OffsetMin, String OffsetMax, TakeElementUser ElementType)
        {
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_Slider");
            if (Interface == null) return;

            Interface = Interface.Replace("%OFFSET_MIN%", OffsetMin);
            Interface = Interface.Replace("%OFFSET_MAX%", OffsetMax);
            Interface = Interface.Replace("%NAME%", Name);
            Interface = Interface.Replace("%COMMAND_LEFT_SLIDE%", $"newui.cmd slider.controller {ElementType} -");
            Interface = Interface.Replace("%COMMAND_RIGHT_SLIDE%", $"newui.cmd slider.controller {ElementType} +");

            CuiHelper.DestroyUi(player, Name);
            CuiHelper.AddUi(player, Interface);

            DrawUI_IQChat_Slider_Update_Argument(player, ElementType);
        }
        private void DrawUI_IQChat_Slider_Update_Argument(BasePlayer player, TakeElementUser ElementType)
        {
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_Slider_Update_Argument");
            User Info = UserInformation[player.userID];
            if (Info == null || Interface == null) return;

            String Argument = String.Empty;
            String Name = String.Empty;
            String Parent = String.Empty;
            
            switch (ElementType)
            {
                case TakeElementUser.Prefix:
                    Argument = Info.Info.Prefix;
                    Parent = "SLIDER_PREFIX";
                    Name = "ARGUMENT_PREFIX";
                    break;
                case TakeElementUser.Nick:

                    String DisplayName = player.displayName;
                    String ColorNickPlayer = Info.Info.ColorNick;
                    Object resultColorNick = IsGradientColorValue(ColorNickPlayer);
                    if (resultColorNick is List<String> gradientColors)
                        DisplayName = ApplyGradientToText(DisplayName, gradientColors);
                    else DisplayName = $"<color={ColorNickPlayer}>{DisplayName}</color>";
                    
                    Argument = DisplayName;
                    Parent = "SLIDER_NICK_COLOR";
                    Name = "ARGUMENT_NICK_COLOR";
                    break;
                case TakeElementUser.Chat:
                    String ChatMessage = GetLang("IQCHAT_CONTEXT_NICK_DISPLAY_MESSAGE", player.UserIDString);
                    String ColorChat = Info.Info.ColorMessage;
                    Object resultColorChat = IsGradientColorValue(ColorChat);
                    if (resultColorChat is List<String> gradientChatColors)
                        ChatMessage = ApplyGradientToText(ChatMessage, gradientChatColors);
                    else ChatMessage = $"<color={ColorChat}>{ChatMessage}</color>";
                    
                    Argument = ChatMessage;
                    Parent = "SLIDER_MESSAGE_COLOR";
                    Name = "ARGUMENT_MESSAGE_COLOR";
                    break;
                case TakeElementUser.Rank:
                    Argument = IQRankGetNameRankKey(Info.Info.Rank) ?? GetLang("IQCHAT_CONTEXT_SLIDER_IQRANK_TITLE_NULLER", player.UserIDString);
                    Parent = "SLIDER_IQRANK";
                    Name = "ARGUMENT_RANK";
                    break;
                default:
                    break;
            }

            String Pattern = @"</?size.*?>";
            String ArgumentRegex = Regex.IsMatch(Argument, Pattern) ? Regex.Replace(Argument, Pattern, "") : Argument;
            Interface = Interface.Replace("%ARGUMENT%", ArgumentRegex);
            Interface = Interface.Replace("%PARENT%", Parent);
            Interface = Interface.Replace("%NAME%", Name);

            CuiHelper.DestroyUi(player, Name);
            CuiHelper.AddUi(player, Interface);

        }

        #endregion

        #region DropList Draw UI
        private void DrawUI_IQChat_DropList(BasePlayer player, String OffsetMin, String OffsetMax, String Title, TakeElementUser ElementType)
        {
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_DropList");
            if (Interface == null) return;

            Interface = Interface.Replace("%TITLE%", Title);
            Interface = Interface.Replace("%OFFSET_MIN%", OffsetMin);
            Interface = Interface.Replace("%OFFSET_MAX%", OffsetMax);
            Interface = Interface.Replace("%BUTTON_DROP_LIST_CMD%", $"newui.cmd droplist.controller open {ElementType}");

            CuiHelper.AddUi(player, Interface);
        }
        private void DrawUI_IQChat_OpenDropList(BasePlayer player, TakeElementUser ElementType, Int32 Page = 0)
        {
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_OpenDropList");
            if (Interface == null) return;

            if (!LocalBase.ContainsKey(player)) return;

            String Title = String.Empty;
            String Description = String.Empty;
            List<Configuration.ControllerParameters.AdvancedFuncion> InfoUI = new List<Configuration.ControllerParameters.AdvancedFuncion>();

            switch (ElementType)
            {
                case TakeElementUser.MultiPrefix:
                case TakeElementUser.Prefix:
                    {
                        InfoUI = LocalBase[player].ElementsPrefix;
                        Title = GetLang("IQCHAT_CONTEXT_SLIDER_PREFIX_TITLE", player.UserIDString);
                        Description = GetLang("IQCHAT_CONTEXT_DESCRIPTION_PREFIX", player.UserIDString);
                        break;
                    }
                case TakeElementUser.Nick:
                    {
                        InfoUI = LocalBase[player].ElementsNick;
                        Title = GetLang("IQCHAT_CONTEXT_SLIDER_NICK_COLOR_TITLE", player.UserIDString);
                        Description = GetLang("IQCHAT_CONTEXT_DESCRIPTION_NICK", player.UserIDString);
                        break;
                    }
                case TakeElementUser.Chat:
                    {
                        InfoUI = LocalBase[player].ElementsChat;
                        Title = GetLang("IQCHAT_CONTEXT_SLIDER_MESSAGE_COLOR_TITLE", player.UserIDString);
                        Description = GetLang("IQCHAT_CONTEXT_DESCRIPTION_CHAT", player.UserIDString);
                        break;
                    }
                case TakeElementUser.Rank:
                    {
                        InfoUI = LocalBase[player].ElementsRanks;
                        Title = GetLang("IQCHAT_CONTEXT_SLIDER_IQRANK_TITLE", player.UserIDString);
                        Description = GetLang("IQCHAT_CONTEXT_DESCRIPTION_RANK", player.UserIDString);
                        break;
                    }
                default:
                    break;
            }

            //  if (InfoUI == null || InfoUI.Count == 0) return;

            Interface = Interface.Replace("%TITLE%", Title);
            Interface = Interface.Replace("%DESCRIPTION%", Description);

            String CommandRight = InfoUI.Skip(9 * (Page + 1)).Count() > 0 ? $"newui.cmd droplist.controller page.controller {ElementType} + {Page}" : String.Empty;
            String CommandLeft = Page != 0 ? $"newui.cmd droplist.controller page.controller {ElementType} - {Page}" : String.Empty;

            Interface = Interface.Replace("%NEXT_BTN%", CommandRight);
            Interface = Interface.Replace("%BACK_BTN%", CommandLeft);

            Interface = Interface.Replace("%COLOR_RIGHT%", String.IsNullOrWhiteSpace(CommandRight) ? "1 1 1 0.1" : "1 1 1 1");
            Interface = Interface.Replace("%COLOR_LEFT%", String.IsNullOrWhiteSpace(CommandLeft) ? "1 1 1 0.1" : "1 1 1 1");

            CuiHelper.DestroyUi(player, "OpenDropList");
            CuiHelper.AddUi(player, Interface);

            Int32 Count = 0;
            Int32 X = 0, Y = 0;
            foreach (Configuration.ControllerParameters.AdvancedFuncion Info in InfoUI.Skip(9 * Page).Take(9))
            {
                DrawUI_IQChat_OpenDropListArgument(player, ElementType, Info, X, Y, Count);

                if (ElementType == TakeElementUser.MultiPrefix && UserInformation[player.userID].Info.PrefixList.Contains(Info.Argument))
                    DrawUI_IQChat_OpenDropListArgument(player, Count);

                Count++;
                X++;
                if (X == 3)
                {
                    X = 0;
                    Y++;
                }
            }
        }

        private void DrawUI_IQChat_OpenDropListArgument(BasePlayer player, TakeElementUser ElementType, Configuration.ControllerParameters.AdvancedFuncion Info, Int32 X, Int32 Y, Int32 Count)
        {
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_OpenDropListArgument");
            if (Interface == null) return;

            String DisplayName = player.displayName;
            if (ElementType == TakeElementUser.Nick)
            {
                String ColorNickPlayer = Info.Argument;
                Object resultColorNick = IsGradientColorValue(ColorNickPlayer);
                if (resultColorNick is List<String> gradientColors)
                    DisplayName = ApplyGradientToText(DisplayName, gradientColors);
                else DisplayName = $"<color={ColorNickPlayer}>{DisplayName}</color>";
            }

            String ChatMessage = GetLang("IQCHAT_CONTEXT_NICK_DISPLAY_MESSAGE", player.UserIDString);
            if (ElementType == TakeElementUser.Chat)
            {
                String ColorChat = Info.Argument;
                Object resultColorChat = IsGradientColorValue(ColorChat);
                if (resultColorChat is List<String> gradientChatColors)
                    ChatMessage = ApplyGradientToText(ChatMessage, gradientChatColors);
                else ChatMessage = $"<color={ColorChat}>{ChatMessage}</color>";
            }

            String Argument = ElementType == TakeElementUser.MultiPrefix || ElementType == TakeElementUser.Prefix ? Info.Argument :
                    ElementType == TakeElementUser.Nick ? DisplayName :
                    ElementType == TakeElementUser.Chat ? ChatMessage :
                    ElementType == TakeElementUser.Rank ? IQRankGetNameRankKey(Info.Argument) : String.Empty;

            Interface = Interface.Replace("%OFFSET_MIN%", $"{-140.329 - (-103 * X)} {-2.243 + (Y * -28)}");
            Interface = Interface.Replace("%OFFSET_MAX%", $"{-65.271 - (-103 * X)} {22.568 + (Y * -28)}");
            Interface = Interface.Replace("%COUNT%", Count.ToString());
            Interface = Interface.Replace("%ARGUMENT%", Argument);
            Interface = Interface.Replace("%TAKE_COMMAND_ARGUMENT%", $"newui.cmd droplist.controller element.take {ElementType} {Count} {Info.Permissions} {Info.Argument}");

            CuiHelper.DestroyUi(player, $"ArgumentDropList_{Count}");
            CuiHelper.AddUi(player, Interface);
        }
        private void DrawUI_IQChat_OpenDropListArgument(BasePlayer player, Int32 Count)
        {
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_OpenDropListArgument_Taked");
            if (Interface == null) return;

            Interface = Interface.Replace("%COUNT%", Count.ToString());

            CuiHelper.DestroyUi(player, $"TAKED_INFO_{Count}");
            CuiHelper.AddUi(player, Interface);
        }

        private void DrawUI_IQChat_Alert(BasePlayer player, String Description, String Title = null)
        {
            if (_interface == null)
            {
                PrintWarning("Генерируем интерфейс, ожидайте сообщения об успешной генерации");
                return;
            }
            String Interface = InterfaceBuilder.GetInterface("UI_Chat_Alert");
            if (Interface == null) return;

            Interface = Interface.Replace("%TITLE%", Title ?? GetLang("IQCHAT_ALERT_TITLE", player.UserIDString));
            Interface = Interface.Replace("%DESCRIPTION%", Description);

            CuiHelper.DestroyUi(player, InterfaceBuilder.UI_Chat_Alert);
            CuiHelper.AddUi(player, Interface);

            player.Invoke(() =>
            {
                CuiHelper.DestroyUi(player, InterfaceBuilder.UI_Chat_Alert);
            }, config.ControllerMessages.GeneralSetting.OtherSetting.TimeDeleteAlertUI);
        }
        #endregion

        private class InterfaceBuilder
        {
            #region Vars

            public static InterfaceBuilder Instance;
            public const String UI_Chat_Context = "UI_IQCHAT_CONTEXT";
            public const String UI_Chat_Context_Visual_Nick = "UI_IQCHAT_CONTEXT_VISUAL_NICK";
            public const String UI_Chat_Alert = "UI_IQCHAT_ALERT";
            public Dictionary<String, String> Interfaces;

            #endregion

            #region Main

            public InterfaceBuilder()
            {
                Instance = this;
                Interfaces = new Dictionary<String, String>();
                BuildingStaticContext();
                BuildingVisualNick();
                BuildingCheckBox();

                BuildingModerationStatic();
                BuildingMuteAllChat();
                BuildingMuteAllVoice();

                BuildingSlider();
                BuildingSliderUpdateArgument();

                BuildingDropList();
                BuildingOpenDropList();
                BuildingElementDropList();
                BuildingElementDropListTakeLine();

                BuildingAlertUI();

                BuildingMuteAndIgnore();
                BuildingMuteAndIgnorePlayerPanel();
                BuildingMuteAndIgnorePlayer();
                BuildingMuteAndIgnorePages();

                BuildingMuteAndIgnorePanelAlert();
                BuildingIgnoreAlert();
                BuildingMuteAlert();
                BuildingMuteAlert_DropList_Title();
                BuildingMuteAlert_DropList_Reason();
            }

            public static void AddInterface(String name, String json)
            {
                if (Instance.Interfaces.ContainsKey(name))
                {
                    _.PrintError($"Error! Tried to add existing cui elements! -> {name}");
                    return;
                }

                Instance.Interfaces.Add(name, json);
            }

            public static string GetInterface(String name)
            {
                string json = string.Empty;
                if (Instance.Interfaces.TryGetValue(name, out json) == false)
                {
                    _.PrintWarning($"Warning! UI elements not found by name! -> {name}");
                }

                return json;
            }

            public static void DestroyAll()
            {
                for (var i = 0; i < BasePlayer.activePlayerList.Count; i++)
                {
                    var player = BasePlayer.activePlayerList[i];
                    CuiHelper.DestroyUi(player, UI_Chat_Context);
                    CuiHelper.DestroyUi(player, UI_Chat_Context_Visual_Nick);
                    CuiHelper.DestroyUi(player, UI_Chat_Alert);
                    CuiHelper.DestroyUi(player, "MUTE_AND_IGNORE_PANEL_ALERT");
                }
            }

            #endregion

            #region StaticChatContext

            #region VisualNick Building
            private void BuildingVisualNick()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = UI_Chat_Context_Visual_Nick,
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%NICK_DISPLAY%", Font = "robotocondensed-regular.ttf", FontSize = 7, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-135.769 -89.558", OffsetMax = "-12.644 -77.176" }
                }
                });

                AddInterface("UI_Chat_Context_Visual_Nick", container.ToJson());
            }
            #endregion

            #region Context
            private void BuildingStaticContext()
            {
                Configuration.ControllerParameters Controller = config.ControllerParameter;
                if (Controller == null)
                {
                    _.PrintWarning("Ошибка генерации интерфейса, null значение в конфигурации, свяжитесь с разработчиком");
                    return;
                }
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiPanel
                {
                    CursorEnabled = true,
                    RectTransform = { AnchorMin = "1 0.5", AnchorMax = "1 0.5", OffsetMin = "-379 -217", OffsetMax = "-31 217" },
                    Image = { Color = "0 0 0 0" }
                }, "Overlay", UI_Chat_Context);

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "1000 1000", OffsetMax = "-1000 -1000" },
                    Button = { Close = UI_Chat_Context, Color = "0 0 0 0.5" },
                    Text = { Text = "" }
                }, UI_Chat_Context, "CLOSE_UI_Chat_Context_FullScreen");

                container.Add(new CuiElement
                {
                    Name = "ImageContext",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = "%IMG_BACKGROUND%" },
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "TitleLabel",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 17, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-149.429 166.408", OffsetMax = "-14.788 189.564" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "DescriptionLabel",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%SETTING_ELEMENT%", Font = "robotocondensed-regular.ttf", FontSize = 8, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-149.429 112.0213232", OffsetMax = "152.881 131.787" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "InformationLabel",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%INFORMATION%", Font = "robotocondensed-regular.ttf", FontSize = 8, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-149.429 -53.432", OffsetMax = "-32.905 -39.808" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "InformationIcon",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = _imageUI.GetImage("IQCHAT_INFORMATION_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-14.788 -52.12", OffsetMax = "-3.788 -41.12" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "SettingLabel",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%SETTINGS%", Font = "robotocondensed-regular.ttf", FontSize = 8, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "11.075 -53.432", OffsetMax = "126.125 -39.808" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "SettingIcon",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = _imageUI.GetImage("IQCHAT_SETTING_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "141.88 -52.12", OffsetMax = "152.88 -41.12" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "SettingPM",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%SETTINGS_PM%", Font = "robotocondensed-regular.ttf", FontSize = 8, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "11.075 -70.712", OffsetMax = "126.125 -57.088" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "SettingAlertChat",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%SETTINGS_ALERT%", Font = "robotocondensed-regular.ttf", FontSize = 8, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "11.075 -82.412", OffsetMax = "126.125 -68.788" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "SettingNoticyChat",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%SETTINGS_ALERT_PM%", Font = "robotocondensed-regular.ttf", FontSize = 8, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "11.075 -94.412", OffsetMax = "126.125 -80.788" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "SettingSoundAlert",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%SETTINGS_SOUNDS%", Font = "robotocondensed-regular.ttf", FontSize = 8, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "11.075 -106.412", OffsetMax = "126.125 -92.788" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "MuteStatus",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%MUTE_STATUS_PLAYER%", Font = "robotocondensed-regular.ttf", FontSize = 11, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-143.174 -131.59", OffsetMax = "-120.611 -114.967" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "MuteStatusTitle",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%MUTE_STATUS_TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 7, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-143.174 -141.429", OffsetMax = "-89.127 -132.508" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "CountIgnored",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%IGNORED_STATUS_COUNT%", Font = "robotocondensed-regular.ttf", FontSize = 7, Align = TextAnchor.UpperLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-66.98 -131.715", OffsetMax = "-11.09 -116.831" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "IgonoredTitle",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%IGNORED_STATUS_TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 7, Align = TextAnchor.UpperLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-66.98 -142.04", OffsetMax = "-19.967 -132.537" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "IgnoredIcon",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = _imageUI.GetImage("IQCHAT_IGNORE_INFO_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-19.483 -115.225", OffsetMax = "-11.762 -107.814" }
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = $"newui.cmd action.mute.ignore open {SelectedAction.Ignore}", Color = "0 0 0 0" },
                    Text = { Text = "" }
                }, "IgnoredIcon", "CLOSE_IGNORED");

                container.Add(new CuiElement
                {
                    Name = "TitleNickPanel",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%NICK_DISPLAY_TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-135.769 -78.878", OffsetMax = "-85.632 -64.613" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "NickTitle",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%SLIDER_NICK_COLOR_TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "22.591 76.362", OffsetMax = "80.629 92.278" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "ChatMessageTitle",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%SLIDER_MESSAGE_COLOR_TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-136.591 9.362", OffsetMax = "-78.045 24.278" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "PrefixTitle",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%SLIDER_PREFIX_TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-136.591 77.362", OffsetMax = "-89.949 93.278" }
                }
                });


                container.Add(new CuiElement
                {
                    Name = "RankTitle",
                    Parent = UI_Chat_Context,
                    Components = {
                        new CuiTextComponent { Text = "%SLIDER_IQRANK_TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 10, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "22.825 9.242", OffsetMax = "81.375 25.158" }
                    }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "123.62 166", OffsetMax = "153.62 196" },
                    Button = { Close = UI_Chat_Context, Color = "0 0 0 0" },
                    Text = { Text = "" }
                }, UI_Chat_Context, "CLOSE_UI_Chat_Context");

                AddInterface("UI_Chat_Context", container.ToJson());
            }

            #endregion

            #region CheckBox Building
            private void BuildingCheckBox()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "%NAME_CHECK_BOX%",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiRawImageComponent { Color = "%COLOR%", Png = _imageUI.GetImage("IQCHAT_ELEMENT_SETTING_CHECK_BOX") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "%OFFSET_MIN%", OffsetMax = "%OFFSET_MAX%" }
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = "%COMMAND_TURNED%", Color = "0 0 0 0" },
                    Text = { Text = "" }
                }, "%NAME_CHECK_BOX%", "CHECK_BOX_TURNED");

                AddInterface("UI_Chat_Context_CheckBox", container.ToJson());
            }
            #endregion

            #region Slider Building
            private void BuildingSlider()
            {
                CuiElementContainer container = new CuiElementContainer();
                String NameSlider = "%NAME%";

                container.Add(new CuiElement
                {
                    Name = NameSlider,
                    Parent = UI_Chat_Context,
                    Components = {
                            new CuiRawImageComponent { Color = "1 1 1 1", Png = _imageUI.GetImage("IQCHAT_ELEMENT_SLIDER_ICON") },
                            new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "%OFFSET_MIN%" , OffsetMax = "%OFFSET_MAX%"  }
                        }
                });

                container.Add(new CuiElement
                {
                    Name = "Left",
                    Parent = NameSlider,
                    Components = {
                        new CuiRawImageComponent { Color = "1 1 1 1", Png = _imageUI.GetImage("IQCHAT_ELEMENT_SLIDER_LEFT_ICON") },
                        new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-53.9 -4.5", OffsetMax = "-48.9 4.5" }
                    }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = "%COMMAND_LEFT_SLIDE%", Color = "0 0 0 0" },
                    Text = { Text = "" }
                }, "Left", "LEFT_SLIDER_BTN");

                container.Add(new CuiElement
                {
                    Name = "Right",
                    Parent = NameSlider,
                    Components = {
                        new CuiRawImageComponent { Color = "1 1 1 1", Png = _imageUI.GetImage("IQCHAT_ELEMENT_SLIDER_RIGHT_ICON") },
                        new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "48.92 -4.5", OffsetMax = "53.92 4.5" }
                    }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = "%COMMAND_RIGHT_SLIDE%", Color = "0 0 0 0" },
                    Text = { Text = "" }
                }, "Right", "RIGHT_SLIDER_BTN");

                AddInterface("UI_Chat_Slider", container.ToJson());
            }
            private void BuildingSliderUpdateArgument()
            {
                CuiElementContainer container = new CuiElementContainer();
                String ParentSlider = "%PARENT%";
                String NameArgument = "%NAME%";

                container.Add(new CuiElement
                {
                    Name = NameArgument,
                    Parent = ParentSlider,
                    Components = {
                    new CuiTextComponent { Text = "%ARGUMENT%", Font = "robotocondensed-regular.ttf", FontSize = 9, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-41.929 -6.801", OffsetMax = "41.929 6.801" }
                }
                });

                AddInterface("UI_Chat_Slider_Update_Argument", container.ToJson());
            }
            #endregion

            #region MuteAndIgnore Bulding

            #region Menu
            private void BuildingMuteAndIgnore()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "MuteAndIgnoredPanel",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = _imageUI.GetImage("IQCHAT_MUTE_AND_IGNORE_PANEL")},
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-1007.864 -220.114", OffsetMax = "-167.374 219.063" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "TitlesPanel",
                    Parent = "MuteAndIgnoredPanel",
                    Components = {
                    new CuiTextComponent { Text = "%TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 20, Align = TextAnchor.MiddleRight, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "60.217 164.031", OffsetMax = "356.114 190.962" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "IconPanel",
                    Parent = "MuteAndIgnoredPanel",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = _imageUI.GetImage("IQCHAT_MUTE_AND_IGNORE_ICON")},
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "357.5 170", OffsetMax = "373.5 185"  }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "SearchPanel",
                    Parent = "MuteAndIgnoredPanel",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = _imageUI.GetImage("IQCHAT_MUTE_AND_IGNORE_SEARCH")},
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-385.8 161.244", OffsetMax = "-186.349 192.58" }
                }
                });

                string SearchName = "";

                container.Add(new CuiElement
                {
                    Parent = "SearchPanel",
                    Name = "SearchPanel" + ".Input.Current",
                    Components =
                {
                    new CuiInputFieldComponent { Text = SearchName, FontSize = 14,Command = $"newui.cmd action.mute.ignore search.controller %ACTION_TYPE% {SearchName}", Align = TextAnchor.MiddleCenter, Color = "1 1 1 0.5", CharsLimit = 15},
                    new CuiRectTransformComponent { AnchorMin = "0 0", AnchorMax = "1 1" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "PanelPages",
                    Parent = "MuteAndIgnoredPanel",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = _imageUI.GetImage("IQCHAT_MUTE_AND_IGNORE_PAGE_PANEL")},
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-179.196 161.242", OffsetMax = "-121.119 192.578" }
                }
                });

                AddInterface("UI_Chat_Mute_And_Ignore", container.ToJson());
            }

            private void BuildingMuteAndIgnorePlayerPanel()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiPanel
                {
                    CursorEnabled = true,
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.85" },
                    Image = { Color = "0 0 0 0" }
                }, "MuteAndIgnoredPanel", "MuteIgnorePanelContent");

                AddInterface("UI_Chat_Mute_And_Ignore_Panel_Content", container.ToJson());
            }
            private void BuildingMuteAndIgnorePlayer()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "PANEL_PLAYER",
                    Parent = "MuteIgnorePanelContent",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = _imageUI.GetImage("IQCHAT_MUTE_AND_IGNORE_PLAYER") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "%OFFSET_MIN%", OffsetMax = "%OFFSET_MAX%" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "NickName",
                    Parent = "PANEL_PLAYER",
                    Components = {
                    new CuiTextComponent { Text = "%DISPLAY_NAME%", Font = "robotocondensed-regular.ttf", FontSize = 12, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-77.391 -17.245", OffsetMax = "91.582 17.244" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "StatusPanel",
                    Parent = "PANEL_PLAYER",
                    Components = {
                    new CuiRawImageComponent { Color = "%COLOR%", Png = _imageUI.GetImage("IQCHAT_MUTE_AND_IGNORE_PLAYER_STATUS") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-92.231 -11.655", OffsetMax = "-87.503 10.44" }
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = "%COMMAND_ACTION%", Color = "0 0 0 0" },
                    Text = { Text = "" }
                }, "PANEL_PLAYER");

                AddInterface("UI_Chat_Mute_And_Ignore_Player", container.ToJson());
            }
            private void BuildingMuteAndIgnorePages()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "PageCount",
                    Parent = "PanelPages",
                    Components = {
                    new CuiTextComponent { Text = "%PAGE%", Font = "robotocondensed-regular.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-11.03 -15.668", OffsetMax = "11.03 15.668" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "LeftPage",
                    Parent = "PanelPages",
                    Components = {
                    new CuiRawImageComponent { Color = "%COLOR_LEFT%", Png = _imageUI.GetImage("IQCHAT_ELEMENT_SLIDER_LEFT_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-18 -7", OffsetMax = "-13 6" }
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = "%COMMAND_LEFT%", Color = "0 0 0 0" },
                    Text = { Text = "" }
                }, "LeftPage");

                container.Add(new CuiElement
                {
                    Name = "RightPage",
                    Parent = "PanelPages",
                    Components = {
                    new CuiRawImageComponent { Color = "%COLOR_RIGHT%", Png = _imageUI.GetImage("IQCHAT_ELEMENT_SLIDER_RIGHT_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "14 -7", OffsetMax = "19 6" }
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = "%COMMAND_RIGHT%", Color = "0 0 0 0" },
                    Text = { Text = "" }
                }, "RightPage");

                AddInterface("UI_Chat_Mute_And_Ignore_Pages", container.ToJson());
            }

            #endregion

            #region Alert Ignore And Mute
            private void BuildingMuteAndIgnorePanelAlert()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiPanel
                {
                    CursorEnabled = true,
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Image = { Color = "0 0 0 0.25", Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" }
                }, "Overlay", "MUTE_AND_IGNORE_PANEL_ALERT");

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Close = "MUTE_AND_IGNORE_PANEL_ALERT", Color = "0 0 0 0" },
                    Text = { Text = "" }
                }, "MUTE_AND_IGNORE_PANEL_ALERT");

                AddInterface("UI_Chat_Mute_And_Ignore_Alert_Panel", container.ToJson());
            }

            #region Mute

            private void BuildingMuteAlert()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "AlertMute",
                    Parent = "MUTE_AND_IGNORE_PANEL_ALERT",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = _imageUI.GetImage("IQCHAT_MUTE_ALERT_PANEL") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-199.832 -274.669", OffsetMax = "199.832 274.669" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "AlertMuteIcon",
                    Parent = "AlertMute",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = _imageUI.GetImage("IQCHAT_MUTE_ALERT_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-67 204.8", OffsetMax = "67 339.8" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "AlertMuteTitles",
                    Parent = "AlertMute",
                    Components = {
                    new CuiTextComponent { Text = "%TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 25, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-199.828 142.57", OffsetMax = "199.832 179.43" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "AlertMuteTakeChat",
                    Parent = "AlertMute",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1",Png = _imageUI.GetImage("IQCHAT_IGNORE_ALERT_BUTTON_YES") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-99.998 87.944", OffsetMax = "100.002 117.944" }
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = "%COMMAND_TAKE_ACTION_MUTE_CHAT%", Color = "0 0 0 0" },
                    Text = { Text = "%BUTTON_TAKE_CHAT_ACTION%", Align = TextAnchor.MiddleCenter, FontSize = 18, Color = "0.1294118 0.145098 0.1647059 1" }
                }, "AlertMuteTakeChat", "BUTTON_TAKE_CHAT");

                container.Add(new CuiElement
                {
                    Name = "AlertMuteTakeVoice",
                    Parent = "AlertMute",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1",Png = _imageUI.GetImage("IQCHAT_IGNORE_ALERT_BUTTON_YES") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-100 49.70", OffsetMax = "100 79.70" } //
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = "%COMMAND_TAKE_ACTION_MUTE_VOICE%", Color = "0 0 0 0" },
                    Text = { Text = "%BUTTON_TAKE_VOICE_ACTION%", Align = TextAnchor.MiddleCenter, FontSize = 18, Color = "0.1294118 0.145098 0.1647059 1" }
                }, "AlertMuteTakeVoice", "BUTTON_TAKE_VOICE");

                AddInterface("UI_Chat_Mute_Alert", container.ToJson());
            }
            private void BuildingMuteAlert_DropList_Title()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "AlertMuteTitleReason",
                    Parent = "AlertMute",
                    Components = {
                    new CuiTextComponent { Text = "%TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 22, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-199.828 -9.430", OffsetMax = "199.832 27.430" }
                }
                });

                container.Add(new CuiPanel
                {
                    CursorEnabled = false,
                    Image = { Color = "1 1 1 0" },
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-147.497 -265.5440", OffsetMax = "147.503 -24.70" }
                }, "AlertMute", "PanelMuteReason");

                AddInterface("UI_Chat_Mute_Alert_DropList_Title", container.ToJson());
            }

            private void BuildingMuteAlert_DropList_Reason()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "Reason",
                    Parent = "PanelMuteReason",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = _imageUI.GetImage("IQCHAT_MUTE_ALERT_PANEL_REASON")},
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "%OFFSET_MIN%", OffsetMax = "%OFFSET_MAX%" }
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = "%COMMAND_REASON%", Color = "0 0 0 0" },
                    Text = { Text = "%REASON%", Align = TextAnchor.MiddleCenter, FontSize = 13, Color = "1 1 1 1" }
                }, "Reason");

                AddInterface("UI_Chat_Mute_Alert_DropList_Reason", container.ToJson());
            }
            #endregion

            #region Ignore
            private void BuildingIgnoreAlert()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "AlertIgnore",
                    Parent = "MUTE_AND_IGNORE_PANEL_ALERT",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = _imageUI.GetImage("IQCHAT_IGNORE_ALERT_PANEL") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-236.5 -134", OffsetMax = "236.5 134" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "AlertIgnoreIcon",
                    Parent = "AlertIgnore",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = _imageUI.GetImage("IQCHAT_IGNORE_ALERT_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-66.5 64.8", OffsetMax = "66.5 198.8" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "AlertIgnoreTitle",
                    Parent = "AlertIgnore",
                    Components = {
                    new CuiTextComponent { Text = "%TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 22, Align = TextAnchor.UpperCenter, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-231 -55.00", OffsetMax = "229.421 33.983232" } 
                }
                });

                container.Add(new CuiElement
                {
                    Name = "AlertIgnoreYes",
                    Parent = "AlertIgnore",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = _imageUI.GetImage("IQCHAT_IGNORE_ALERT_BUTTON_YES") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-178 -115", OffsetMax = "-22 -77" }
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Close = "MUTE_AND_IGNORE_PANEL_ALERT", Command = "%COMMAND%", Color = "0 0 0 0" },
                    Text = { Text = "%BUTTON_YES%", Align = TextAnchor.MiddleCenter, FontSize = 18, Color = "0.1294118 0.145098 0.1647059 1" }
                }, "AlertIgnoreYes", "BUTTON_YES");

                container.Add(new CuiElement
                {
                    Name = "AlertIgnoreNo",
                    Parent = "AlertIgnore",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = _imageUI.GetImage("IQCHAT_IGNORE_ALERT_BUTTON_NO") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "22 -115", OffsetMax = "178 -77" }
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Close = "MUTE_AND_IGNORE_PANEL_ALERT", Color = "0 0 0 0" },
                    Text = { Text = "%BUTTON_NO%", Align = TextAnchor.MiddleCenter, FontSize = 18 }
                }, "AlertIgnoreNo", "BUTTON_NO");

                AddInterface("UI_Chat_Ignore_Alert", container.ToJson());
            }
            #endregion

            #endregion

            #endregion

            #region DropList Building

            private void BuildingDropList()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "DropListIcon",
                    Parent = UI_Chat_Context,
                    Components = {
                            new CuiRawImageComponent { Color = "1 1 1 1", Png = _imageUI.GetImage("IQCHAT_ELEMENT_PREFIX_MULTI_TAKE_ICON")},
                      new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "%OFFSET_MIN%", OffsetMax = "%OFFSET_MAX%" }
                        }
                });

                container.Add(new CuiElement
                {
                    Name = "DropListDescription",
                    Parent = "DropListIcon",
                    Components = {
                            new CuiTextComponent { Text = "%TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 8, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                            new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-105.5 -13.948", OffsetMax = "-42.615 1.725" }
                        }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = "%BUTTON_DROP_LIST_CMD%", Color = "0 0 0 0" },
                    Text = { Text = "" }
                }, "DropListIcon", "DropListIcon_Button");

                AddInterface("UI_Chat_DropList", container.ToJson());
            }

            private void BuildingOpenDropList()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "OpenDropList",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = _imageUI.GetImage("IQCHAT_ELEMENT_DROP_LIST_OPEN_ICON")},
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-149.429 -17.38", OffsetMax = "155.093 109.1" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "DropListName",
                    Parent = "OpenDropList",
                    Components = {
                    new CuiTextComponent { Text = "%TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 11, Align = TextAnchor.UpperLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-140.329 44.5", OffsetMax = "-40.329 58.312" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "DropListDescription",
                    Parent = "OpenDropList",
                    Components = {
                    new CuiTextComponent { Text = "%DESCRIPTION%", Font = "robotocondensed-regular.ttf", FontSize = 8, Align = TextAnchor.UpperLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-140.329 32.993", OffsetMax = "-40.329 42.77" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "DropListClose",
                    Parent = "OpenDropList",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = _imageUI.GetImage("IQCHAT_ELEMENT_PREFIX_MULTI_TAKE_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "113 32.2", OffsetMax = "145 56.2" }
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Close = "OpenDropList", Color = "0 0 0 0" },
                    Text = { Text = "" }
                }, "DropListClose", "DropListClose_Button");

                container.Add(new CuiElement
                {
                    Name = "DropListPageRight",
                    Parent = "OpenDropList",
                    Components = {
                    new CuiRawImageComponent { Color = "%COLOR_RIGHT%", Png = _imageUI.GetImage("IQCHAT_ELEMENT_SLIDER_RIGHT_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "100 38", OffsetMax = "105.2 48" }
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = "%NEXT_BTN%", Color = "0 0 0 0" },
                    Text = { Text = "" }
                }, "DropListPageRight", "DropListPageRight_Button");

                container.Add(new CuiElement
                {
                    Name = "DropListPageLeft",
                    Parent = "OpenDropList",
                    Components = {
                    new CuiRawImageComponent { Color ="%COLOR_LEFT%", Png = _imageUI.GetImage("IQCHAT_ELEMENT_SLIDER_LEFT_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "86 38", OffsetMax = "91.2 48" }
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" },
                    Button = { Command = "%BACK_BTN%", Color = "0 0 0 0" },
                    Text = { Text = "" }
                }, "DropListPageLeft", "DropListPageLeft_Button");

                AddInterface("UI_Chat_OpenDropList", container.ToJson());
            }

            private void BuildingElementDropList()
            {
                CuiElementContainer container = new CuiElementContainer();
                String Name = "ArgumentDropList_%COUNT%";

                container.Add(new CuiElement
                {
                    Name = Name,
                    Parent = "OpenDropList",
                    Components = {
                    new CuiRawImageComponent { FadeIn = 0.3f, Color = "1 1 1 1", Png = _imageUI.GetImage("IQCHAT_ELEMENT_DROP_LIST_OPEN_ARGUMENT_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "%OFFSET_MIN%", OffsetMax = "%OFFSET_MAX%" }
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-37.529 -12.843", OffsetMax = "37.528 12.842" },
                    Button = { FadeIn = 0.3f, Command = "%TAKE_COMMAND_ARGUMENT%", Color = "0 0 0 0" },
                    Text = { FadeIn = 0.3f, Text = "%ARGUMENT%", Font = "robotocondensed-regular.ttf", FontSize = 9, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1" }
                }, Name, "ArgumentButton");

                AddInterface("UI_Chat_OpenDropListArgument", container.ToJson());
            }

            private void BuildingElementDropListTakeLine()
            {
                CuiElementContainer container = new CuiElementContainer();
                String Parent = "ArgumentDropList_%COUNT%";

                container.Add(new CuiElement
                {
                    Name = "TAKED_INFO_%COUNT%",
                    Parent = Parent,
                    Components = {
                    new CuiRawImageComponent { Color = "0.3098039 0.2745098 0.572549 1", Png = _imageUI.GetImage("IQCHAT_ELEMENT_DROP_LIST_OPEN_TAKED") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-25.404 -17.357", OffsetMax = "25.403 -1.584" }
                }
                });

                AddInterface("UI_Chat_OpenDropListArgument_Taked", container.ToJson());
            }

            #endregion

            #region ModerationStatic
            private void BuildingModerationStatic()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "ModerationLabel",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiTextComponent { Text = "%TITLE%", Font = "robotocondensed-regular.ttf", FontSize = 8, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "11.075 -126.612", OffsetMax = "126.125 -112.988" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "ModerationIcon",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = _imageUI.GetImage("IQCHAT_MODERATION_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "141.88 -125.3", OffsetMax = "152.88 -114.3" }
                }
                });


                container.Add(new CuiElement
                {
                    Name = "ModeratorMuteMenu",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = _imageUI.GetImage("IQCHAT_ELEMENT_PANEL_ICON")},
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "11.071 -144.188", OffsetMax = "152.881 -129.752" }
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.95" },
                    Button = { Command = "%COMMAND_MUTE_MENU%", Color = "0 0 0 0" },
                    Text = { Text = "%TEXT_MUTE_MENU%", FontSize = 9, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf" }
                }, "ModeratorMuteMenu", "ModeratorMuteMenu_Btn");


                AddInterface("UI_Chat_Moderation", container.ToJson());
            }
            private void BuildingMuteAllChat()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "ModeratorMuteAllChat",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = _imageUI.GetImage("IQCHAT_ELEMENT_PANEL_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "11.07 -161.818", OffsetMax = "152.88 -147.382" }
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.95" },
                    Button = { Command = "%COMMAND_MUTE_ALLCHAT%", Color = "0 0 0 0" },
                    Text = { Text = "%TEXT_MUTE_ALLCHAT%", FontSize = 9, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf" }
                }, "ModeratorMuteAllChat", "ModeratorMuteAllChat_Btn");

                AddInterface("UI_Chat_Administation_AllChat", container.ToJson());
            }
            private void BuildingMuteAllVoice()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = "ModeratorMuteAllVoice",
                    Parent = UI_Chat_Context,
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = _imageUI.GetImage("IQCHAT_ELEMENT_PANEL_ICON") },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "11.075 -179.448", OffsetMax = "152.885 -165.012" }
                }
                });

                container.Add(new CuiButton
                {
                    RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.95" },
                    Button = { Command = "%COMMAND_MUTE_ALLVOICE%", Color = "0 0 0 0" },
                    Text = { Text = "%TEXT_MUTE_ALLVOICE%", FontSize = 9, Align = TextAnchor.MiddleCenter, Font = "robotocondensed-regular.ttf" }
                }, "ModeratorMuteAllVoice", "ModeratorMuteAllVoice_Btn");

                AddInterface("UI_Chat_Administation_AllVoce", container.ToJson());
            }

            #endregion

            #endregion

            #region DynamicAlert
            private void BuildingAlertUI()
            {
                CuiElementContainer container = new CuiElementContainer();

                container.Add(new CuiElement
                {
                    Name = UI_Chat_Alert,
                    Parent = "Overlay",
                    Components = {
                    new CuiRawImageComponent { Color = "1 1 1 1", Png = _imageUI.GetImage("IQCHAT_ALERT_PANEL") },
                    new CuiRectTransformComponent { AnchorMin = "0 1", AnchorMax = "0 1", OffsetMin = "0 -136.5", OffsetMax = "434 -51.5" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "AlertTitle",
                    Parent = UI_Chat_Alert,
                    Components = {
                    new CuiTextComponent { Text = "<b>%TITLE%</b>", Font = "robotocondensed-bold.ttf", FontSize = 16, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-184.193 9.119", OffsetMax = "189.223 30.925" }
                }
                });

                container.Add(new CuiElement
                {
                    Name = "AlertText",
                    Parent = UI_Chat_Alert,
                    Components = {
                    new CuiTextComponent { Text = "%DESCRIPTION%", Font = "robotocondensed-regular.ttf", FontSize = 12, Align = TextAnchor.MiddleLeft, Color = "1 1 1 1" },
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-184.193 -27.133", OffsetMax = "189.223 9.119" }
                }
                });

                AddInterface("UI_Chat_Alert", container.ToJson());
            }
            #endregion
        }
        #endregion

        #region Command

        #region Funcion Command
        [ConsoleCommand("newui.cmd")]
        private void ConsoleCommandFuncional(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            if (player == null) return;
            String Action = arg.Args[0];
            if (Action == null || String.IsNullOrWhiteSpace(Action)) return;

            if (!LocalBase.ContainsKey(player))
            {
                PrintError(LanguageEn ? "UI was unable to process the local base (Local Base) contact the developer" : "UI не смог обработать локальную базу (LocalBase) свяжитесь с разработчиком");
                return;
            }
            Configuration.ControllerParameters ControllerParameters = config.ControllerParameter;
            if (ControllerParameters == null)
            {
                PrintError(LanguageEn ? "An error has been made in the configuration! Controller Parameters is null, contact developer" : "В конфигурации допущена ошибка! ControllerParameters является null, свяжитесь с разработчиком");
                return;
            }

            switch (Action)
            {
                case "action.mute.ignore":
                    {
                        String ActionMenu = arg.Args[1];
                        SelectedAction ActionType = (SelectedAction)Enum.Parse(typeof(SelectedAction), arg.Args[2]);
                        if (ActionMenu == "search.controller" && arg.Args.Length < 4)
                            return;

                        switch (ActionMenu)
                        {
                            case "mute.controller":
                                {
                                    if (!player.IsAdmin)
                                        if (!permission.UserHasPermission(player.UserIDString, PermissionMute)) return;

                                    String ActionMute = arg.Args[3];
                                    switch (ActionMute)
                                    {
                                        case "mute.all.chat":
                                        {
                                            if (!player.IsAdmin) return;

                                            if (GeneralInfo.TurnMuteAllChat)
                                            {
                                                GeneralInfo.TurnMuteAllChat = false;
                                                //  ReplyBroadcast(GetLang("IQCHAT_FUNCED_NO_SEND_CHAT_UNMUTED_ALL_CHAT", player.UserIDString), AdminAlert: true);
                                                ReplyBroadcast(null, null, true,
                                                    "IQCHAT_FUNCED_NO_SEND_CHAT_UNMUTED_ALL_CHAT");
                                            }
                                            else
                                            {
                                                GeneralInfo.TurnMuteAllChat = true;
                                                // ReplyBroadcast(GetLang("IQCHAT_FUNCED_NO_SEND_CHAT_MUTED_ALL_CHAT", player.UserIDString), AdminAlert: true);
                                                ReplyBroadcast(null, null, true,
                                                    "IQCHAT_FUNCED_NO_SEND_CHAT_MUTED_ALL_CHAT");
                                            }

                                            DrawUI_IQChat_Update_MuteChat_All(player);
                                            break;
                                        }
                                        case "mute.all.voice":
                                        {
                                            if (!player.IsAdmin) return;
                                            if (GeneralInfo.TurnMuteAllVoice)
                                            {
                                                GeneralInfo.TurnMuteAllVoice = false;
                                                //   ReplyBroadcast(GetLang("IQCHAT_FUNCED_NO_SEND_CHAT_UMMUTED_ALL_VOICE", player.UserIDString), AdminAlert: true);
                                                ReplyBroadcast(null, null, true,
                                                    "IQCHAT_FUNCED_NO_SEND_CHAT_UMMUTED_ALL_VOICE");
                                            }
                                            else
                                            {
                                                GeneralInfo.TurnMuteAllVoice = true;
                                                // ReplyBroadcast(GetLang("IQCHAT_FUNCED_NO_SEND_CHAT_MUTED_ALL_VOICE", player.UserIDString), AdminAlert: true);
                                                ReplyBroadcast(null, null, true,
                                                    "IQCHAT_FUNCED_NO_SEND_CHAT_MUTED_ALL_VOICE");

                                            }

                                            DrawUI_IQChat_Update_MuteVoice_All(player);
                                            break;
                                        }
                                        default:
                                            break;
                                    }
                                    break;
                                }
                            case "ignore.and.mute.controller":
                                {
                                    String ActionController = arg.Args[3];
                                    BasePlayer TargetPlayer = BasePlayer.Find(arg.Args[4]);
                                    UInt64.TryParse(arg.Args[4], out UInt64 ID);
                                    Boolean isFakeUser = IsFakeUser(arg.Args[4]);
                                    String userIdString = !isFakeUser ? String.Empty : arg.Args[4];

                                    if (TargetPlayer == null && !isFakeUser) 
                                    {
                                        CuiHelper.DestroyUi(player, "MUTE_AND_IGNORE_PANEL_ALERT");
                                        return;
                                    }

                                    switch (ActionController)
                                    {
                                        case "confirm.alert":
                                            {
                                                if (ActionType == SelectedAction.Ignore)
                                                    DrawUI_IQChat_Ignore_Alert(player, TargetPlayer, ID);
                                                else DrawUI_IQChat_Mute_Alert(player, TargetPlayer, ID);
                                                break;
                                            }
                                        case "open.reason.mute":
                                            {
                                                MuteType Type = (MuteType)Enum.Parse(typeof(MuteType), arg.Args[5]);
                                                DrawUI_IQChat_Mute_Alert_Reasons(player, TargetPlayer, Type, IDFake: ID);
                                                break;
                                            }
                                        case "confirm.yes":
                                            {
                                                if (ActionType == SelectedAction.Ignore)
                                                {
                                                    User Info = UserInformation[player.userID];
                                                    Info.Settings.IgnoredAddOrRemove(isFakeUser ? ID : TargetPlayer.userID);

                                                    CuiHelper.DestroyUi(player, "MUTE_AND_IGNORE_PANEL_ALERT");
                                                    DrawUI_IQChat_Mute_And_Ignore_Player_Panel(player, ActionType);
                                                }
                                                else
                                                {
                                                    MuteType Type = (MuteType)Enum.Parse(typeof(MuteType), arg.Args[5]);
                                                    Int32 IndexReason = Int32.Parse(arg.Args[6]);

                                                    MutePlayer(TargetPlayer, Type, IndexReason, player, fakeUserId: userIdString);

                                                    CuiHelper.DestroyUi(player, "MUTE_AND_IGNORE_PANEL_ALERT");
                                                    DrawUI_IQChat_Mute_And_Ignore_Player_Panel(player, ActionType);
                                                }
                                                break;
                                            }
                                        case "unmute.yes":
                                            {
                                                MuteType Type = (MuteType)Enum.Parse(typeof(MuteType), arg.Args[5]);

                                                UnmutePlayer(TargetPlayer, Type, player, fakeUserId: userIdString);

                                                CuiHelper.DestroyUi(player, "MUTE_AND_IGNORE_PANEL_ALERT");
                                                DrawUI_IQChat_Mute_And_Ignore_Player_Panel(player, ActionType);
                                                break;
                                            }
                                    }
                                    break;
                                }
                            case "open":
                                {
                                    DrawUI_IQChat_Mute_And_Ignore(player, ActionType);
                                    break;
                                }
                            case "page.controller":
                                {
                                    Int32 Page = Int32.Parse(arg.Args[3]);

                                    DrawUI_IQChat_Mute_And_Ignore_Player_Panel(player, ActionType, Page);
                                    break;
                                }
                            case "search.controller":
                                {
                                    String SearchName = arg.Args[3];
                                    DrawUI_IQChat_Mute_And_Ignore_Player_Panel(player, ActionType, SearchName: SearchName);
                                    break;
                                }
                            default:
                                break;
                        }

                        break;
                    }
                case "checkbox.controller":
                    {
                        ElementsSettingsType Type = (ElementsSettingsType)Enum.Parse(typeof(ElementsSettingsType), arg.Args[1]);
                        if (!UserInformation.ContainsKey(player.userID)) return;
                        User Info = UserInformation[player.userID];
                        if (Info == null) return;

                        switch (Type)
                        {
                            case ElementsSettingsType.PM:
                                {
                                    if (Info.Settings.TurnPM)
                                        Info.Settings.TurnPM = false;
                                    else Info.Settings.TurnPM = true;

                                    DrawUI_IQChat_Update_Check_Box(player, Type, "143.38 -67.9", "151.38 -59.9", Info.Settings.TurnPM);
                                    break;
                                }
                            case ElementsSettingsType.Broadcast:
                                {
                                    if (Info.Settings.TurnBroadcast)
                                        Info.Settings.TurnBroadcast = false;
                                    else Info.Settings.TurnBroadcast = true;

                                    DrawUI_IQChat_Update_Check_Box(player, Type, "143.38 -79.6", "151.38 -71.6", Info.Settings.TurnBroadcast);
                                    break;
                                }
                            case ElementsSettingsType.Alert:
                                {
                                    if (Info.Settings.TurnAlert)
                                        Info.Settings.TurnAlert = false;
                                    else Info.Settings.TurnAlert = true;

                                    DrawUI_IQChat_Update_Check_Box(player, Type, "143.38 -91.6", "151.38 -83.6", Info.Settings.TurnAlert);
                                    break;
                                }
                            case ElementsSettingsType.Sound:
                                {
                                    if (Info.Settings.TurnSound)
                                        Info.Settings.TurnSound = false;
                                    else Info.Settings.TurnSound = true;

                                    DrawUI_IQChat_Update_Check_Box(player, Type, "143.38 -103.6", "151.38 -95.6", Info.Settings.TurnSound);
                                    break;
                                }
                            default:
                                break;
                        }
                        break;
                    }
                case "droplist.controller":
                    {
                        String ActionDropList = arg.Args[1];
                        TakeElementUser Element = (TakeElementUser)Enum.Parse(typeof(TakeElementUser), arg.Args[2]);

                        switch (ActionDropList)
                        {
                            case "open":
                                {
                                    DrawUI_IQChat_OpenDropList(player, Element);
                                    break;
                                }
                            case "page.controller":
                                {
                                    String ActionDropListPage = arg.Args[3];
                                    Int32 Page = (Int32)Int32.Parse(arg.Args[4]);
                                    Page = ActionDropListPage == "+" ? Page + 1 : Page - 1;

                                    DrawUI_IQChat_OpenDropList(player, Element, Page);
                                    break;
                                }
                            case "element.take":
                                {
                                    Int32 Count = Int32.Parse(arg.Args[3]);
                                    String Permissions = arg.Args[4];
                                    
                                    String Argument = String.Join(" ", arg.Args.Skip(5));
                                    if (!permission.UserHasPermission(player.UserIDString, Permissions)) return;
                                    if (!UserInformation.ContainsKey(player.userID)) return;
                                    User User = UserInformation[player.userID];
                                    if (User == null) return;

                                    switch (Element)
                                    {
                                        case TakeElementUser.MultiPrefix:
                                            {
                                                if (!User.Info.PrefixList.Contains(Argument))
                                                {
                                                    User.Info.PrefixList.Add(Argument);
                                                    DrawUI_IQChat_OpenDropListArgument(player, Count);
                                                }
                                                else
                                                {
                                                    User.Info.PrefixList.Remove(Argument);
                                                    CuiHelper.DestroyUi(player, $"TAKED_INFO_{Count}");
                                                }
                                                break;
                                            }
                                        case TakeElementUser.Prefix:
                                            User.Info.Prefix = User.Info.Prefix.Equals(Argument) ? String.Empty : Argument;
                                            break;
                                        case TakeElementUser.Nick:
                                            User.Info.ColorNick = Argument;
                                            User.Info.CustomColorNick = String.Empty;
                                            break;
                                        case TakeElementUser.Chat:
                                            User.Info.ColorMessage = Argument;
                                            User.Info.CustomColorMessage = String.Empty;
                                            break;
                                        case TakeElementUser.Rank:
                                            {
                                                User.Info.Rank = Argument;
                                                IQRankSetRank(player.userID, Argument);
                                            }
                                            break;
                                        default:
                                            break;
                                    }
                                    DrawUI_IQChat_Update_DisplayName(player);
                                    break;
                                }
                        }
                        break;
                    }
                case "slider.controller": // newui.cmd slider.controller 0 +
                    {
                        TakeElementUser Element = (TakeElementUser)Enum.Parse(typeof(TakeElementUser), arg.Args[1]);
                        List<Configuration.ControllerParameters.AdvancedFuncion> SliderElements = new List<Configuration.ControllerParameters.AdvancedFuncion>();
                        User Info = UserInformation[player.userID];
                        if (Info == null) return;

                        InformationOpenedUI InfoUI = LocalBase[player];
                        if (InfoUI == null) return;


                        String ActionSlide = arg.Args[2];

                        switch (Element)
                        {
                            case TakeElementUser.Prefix:
                                {
                                    SliderElements = LocalBase[player].ElementsPrefix;

                                    if (SliderElements == null || SliderElements.Count == 0) return;

                                    if (ActionSlide == "+")
                                    {
                                        InfoUI.SlideIndexPrefix++;

                                        if (InfoUI.SlideIndexPrefix >= SliderElements.Count)
                                            InfoUI.SlideIndexPrefix = 0;
                                    }
                                    else
                                    {
                                        InfoUI.SlideIndexPrefix--;

                                        if (InfoUI.SlideIndexPrefix < 0)
                                            InfoUI.SlideIndexPrefix = SliderElements.Count - 1;
                                    }

                                    Info.Info.Prefix = SliderElements[InfoUI.SlideIndexPrefix].Argument;
                                }
                                break;
                            case TakeElementUser.Nick:
                                {
                                    SliderElements = LocalBase[player].ElementsNick;

                                    if (SliderElements == null || SliderElements.Count == 0) return;

                                    if (ActionSlide == "+")
                                    {
                                        InfoUI.SlideIndexNick++;

                                        if (InfoUI.SlideIndexNick >= SliderElements.Count)
                                            InfoUI.SlideIndexNick = 0;
                                    }
                                    else
                                    {
                                        InfoUI.SlideIndexNick--;

                                        if (InfoUI.SlideIndexNick < 0)
                                            InfoUI.SlideIndexNick = SliderElements.Count - 1;
                                    }
                                    Info.Info.ColorNick = SliderElements[InfoUI.SlideIndexNick].Argument;
                                    Info.Info.CustomColorNick = String.Empty;
                                }
                                break;
                            case TakeElementUser.Chat:
                                {
                                    SliderElements = LocalBase[player].ElementsChat;
                                    if (SliderElements == null || SliderElements.Count == 0) return;

                                    if (ActionSlide == "+")
                                    {
                                        InfoUI.SlideIndexChat++;

                                        if (InfoUI.SlideIndexChat >= SliderElements.Count)
                                            InfoUI.SlideIndexChat = 0;
                                    }
                                    else
                                    {
                                        InfoUI.SlideIndexChat--;

                                        if (InfoUI.SlideIndexChat < 0)
                                            InfoUI.SlideIndexChat = SliderElements.Count - 1;
                                    }
                                    Info.Info.ColorMessage = SliderElements[InfoUI.SlideIndexChat].Argument;
                                    Info.Info.CustomColorMessage = String.Empty;
                                }
                                break;
                            case TakeElementUser.Rank:
                                {
                                    SliderElements = LocalBase[player].ElementsRanks;
                                    if (SliderElements == null || SliderElements.Count == 0) return;

                                    if (ActionSlide == "+")
                                    {
                                        InfoUI.SlideIndexRank++;

                                        if (InfoUI.SlideIndexRank >= SliderElements.Count)
                                            InfoUI.SlideIndexRank = 0;
                                    }
                                    else
                                    {
                                        InfoUI.SlideIndexRank--;

                                        if (InfoUI.SlideIndexRank < 0)
                                            InfoUI.SlideIndexRank = SliderElements.Count - 1;
                                    }
                                    Info.Info.Rank = SliderElements[InfoUI.SlideIndexRank].Argument;
                                    IQRankSetRank(player.userID, SliderElements[InfoUI.SlideIndexRank].Argument);
                                }
                                break;
                            default:
                                break;
                        }
                        DrawUI_IQChat_Slider_Update_Argument(player, Element);
                        DrawUI_IQChat_Update_DisplayName(player);
                        break;
                    }
                default:
                    break;
            }
        }
        #endregion

        #region Using Command

        [ChatCommand("chat")]
        private void ChatCommandOpenedUI(BasePlayer player)
        {
            if (_interface == null)
            {
                PrintWarning(LanguageEn ? "We generate the interface, wait for a message about successful generation" : "Генерируем интерфейс, ожидайте сообщения об успешной генерации");
                return;
            }
            if (player == null) return;

            Configuration.ControllerParameters ControllerParameters = config.ControllerParameter;

            if (!LocalBase.ContainsKey(player))
                LocalBase.Add(player, new InformationOpenedUI { });

            LocalBase[player].ElementsPrefix = ControllerParameters.Prefixes.Prefixes.OrderByDescending(arg => arg.Argument.Length).Where(p => permission.UserHasPermission(player.UserIDString, p.Permissions) && !p.IsBlockSelected).ToList();
            LocalBase[player].ElementsNick = ControllerParameters.NickColorList.Where(n => permission.UserHasPermission(player.UserIDString, n.Permissions) && !n.IsBlockSelected).ToList();
            LocalBase[player].ElementsChat = ControllerParameters.MessageColorList.Where(m => permission.UserHasPermission(player.UserIDString, m.Permissions) && !m.IsBlockSelected).ToList();

            if (IQRankSystem && config.ReferenceSetting.IQRankSystems.UseRankSystem)
            {
                List<Configuration.ControllerParameters.AdvancedFuncion> RankList = new List<Configuration.ControllerParameters.AdvancedFuncion>();
                foreach (String Rank in IQRankListKey(player.userID))
                    RankList.Add(new Configuration.ControllerParameters.AdvancedFuncion { Argument = Rank, Permissions = String.Empty });

                LocalBase[player].ElementsRanks = RankList;
            }

            DrawUI_IQChat_Context(player);
        }

        #region Colored Setup

        [ChatCommand("cnick")]
        private void ColoredNickSetup(BasePlayer player, String cmd, String[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, PermissionUseCmdCnick)) return;
            if (player == null)
                return;

            if (args.Length == 0)
            {
                ReplySystem(player, GetLang("COMMAND_COLOR_CUSTOM_NOT_ARG", player.UserIDString));
                return;
            }

            String color = String.Join("", args);
            List<String> correctedColors = Pool.GetList<String>();

            correctedColors = ConvertStringToList(color);
            if (HasInvalidHexColor(correctedColors, out String invalidHex))
            {
                ReplySystem(player, GetLang("COMMAND_COLOR_CUSTOM_NOT_HEX", player.UserIDString, invalidHex));
                return;
            }

            if (correctedColors.Count > 10)
                ReplySystem(player, GetLang("COMMAND_COLOR_CUSTOM_MAX_ARGUMENTS", player.UserIDString));
            

            User User = UserInformation[player.userID];
            String resultColor = JoinStringList(correctedColors);
            
            User.Info.CustomColorNick = resultColor;
            
            Pool.FreeList(ref correctedColors);
            
            ReplySystem(player, GetLang("COMMAND_COLOR_CUSTOM_ACCESS", player.UserIDString));
        }
        
        [ChatCommand("cmsg")]
        private void ColoredMsgSetup(BasePlayer player, String cmd, String[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, PermissionUseCmdMsg)) return;
            if (player == null)
                return;

            if (args.Length == 0)
            {
                ReplySystem(player, GetLang("COMMAND_COLOR_CUSTOM_NOT_ARG", player.UserIDString));
                return;
            }

            String color = String.Join("", args);
            List<String> corrected