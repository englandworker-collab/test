// --- Source Plugin URL: https://umod.org/plugins/console-chat ---
// --- Original File Path: C/ConsoleChat/ConsoleChat.cs ---

using ConVar;
using System;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("ConsoleChat", "Death", "1.0.5")]
    [Description("Prints all player chat to console.")]
    class ConsoleChat : RustPlugin
    {
        #region Declarations
        const string perm = "consolechat.exclude";
        BasePlayer cachedTeamPlayer;
        #endregion

        #region Hooks
        void Init()
        {
            LoadConfigVariables();
            permission.RegisterPermission(perm, this);
        }

        void OnPlayerChat(BasePlayer player, string message, Chat.ChatChannel channel)
        {
            if (channel == Chat.ChatChannel.Team)
            {
                foreach (var teamMate in player.Team.members)
                {
                    if (!RelationshipManager.ServerInstance.cachedPlayers.TryGetValue(teamMate, out cachedTeamPlayer) || permission.UserHasPermission(cachedTeamPlayer.UserIDString, perm))
                    {
                        continue;
                    }

                    cachedTeamPlayer.SendConsoleCommand($"echo [Team] <color={configData.Options.Output_Color}>[{DateTime.UtcNow.ToString(configData.Options.Time_Format)} UTC] {player.displayName}: {message}</color>");
                }
            }
            else
            {
                foreach (var aPlayer in BasePlayer.activePlayerList)
                {
                    if (aPlayer == null || permission.UserHasPermission(aPlayer.UserIDString, perm))
                    {
                        continue;
                    }

                    aPlayer.SendConsoleCommand($"echo [Global] <color={configData.Options.Output_Color}>[{DateTime.UtcNow.ToString(configData.Options.Time_Format)} UTC] {player.displayName}: {message}</color>");
                }
            }
        }
        #endregion

        #region Functions

        #region Commands
        [ConsoleCommand("consolechat.toggle")]
        void ConsoleCommand(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection?.player as BasePlayer;

            if (player == null)
            {
                return;
            }

            if (!configData.Options.Enable_Toggle)
            {
                player.SendConsoleCommand($"echo {lang.GetMessage("disabled", this, player.UserIDString)}");
                return;
            }

            var m = string.Empty;

            if (permission.UserHasPermission(player.UserIDString, perm))
            {
                m = "enabled";
                permission.RevokeUserPermission(player.UserIDString, perm);
            }
            else
            {
                m = "disabled";
                permission.GrantUserPermission(player.UserIDString, perm, null);
            }

            player.SendConsoleCommand($"echo <color={configData.Options.Output_Color}>{lang.GetMessage("toggle", this, player.UserIDString).Replace("{0}", m)}</color>");
        }
        #endregion

        #region Config
        private ConfigData configData;

        class ConfigData
        {
            public Options Options = new Options();
        }

        class Options
        {
            public bool Enable_Toggle = true;
            public string Output_Color = "#fff";
            public string Time_Format = "hh:mm tt";
        }

        private void LoadConfigVariables()
        {
            configData = Config.ReadObject<ConfigData>();
            SaveConfig(configData);
        }

        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData();
            SaveConfig(config);
        }

        void SaveConfig(ConfigData config)
        {
            Config.WriteObject(config, true);
        }
        #endregion

        #region Localization
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>()
            {
                {"toggle", "ConsoleChat is now {0}" },
                {"disabled", "ConsoleChat toggle is disabled." }
            }, this, "en");
        }
        #endregion

        #endregion
    }
}

// --- End of file: ConsoleChat.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/commands-only ---
// --- Original File Path: C/CommandsOnly/CommandsOnly.cs ---

ï»¿using System.Collections.Generic;
using ConVar;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Commands Only", "varygoode", "1.0.2")]
    [Description("Only allow chat messages that are commands")]
    class CommandsOnly : CovalencePlugin
    {
        #region Fields

        private const string PermBypass = "commandsonly.bypass";

        #endregion Fields

        #region Init

        private void Init()
        {
            permission.RegisterPermission(PermBypass, this);
        }

        #endregion Init

        #region Hooks

        private object OnPlayerChat(BasePlayer player, string message, Chat.ChatChannel channel)
        {
            if (!player.IPlayer.HasPermission(PermBypass))
            {
                player.ChatMessage(lang.GetMessage("CommandsOnly", this, player.IPlayer.Id));
                return false;
            }

            return null;
        }

        private Dictionary<string, object> OnBetterChat(Dictionary<string, object> data)
        {
            string message = (string)data?["Message"];
            if (!string.IsNullOrEmpty(message) && message[0] != '/')
            {
                data["CancelOption"] = 1;
            }
            return data;
        }

        #endregion Hooks

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CommandsOnly"] = "You may only use commands in the chat."
            }, this);
        }

        #endregion Localization
    }
}


// --- End of file: CommandsOnly.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/chill-fuel ---
// --- Original File Path: C/ChillFuel/ChillFuel.cs ---

using System;
using System.Collections.Generic;

using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Game.Rust.Cui;
using System.Globalization;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Chill Fuel", "Thisha", "0.3.2")]
    [Description("Simple visualisation of vehicle fuel amount")]
    public class ChillFuel : RustPlugin
    {
        #region variables
        private const string minicopterShortName = "minicopter.entity";
        private const string rowboatShortName = "rowboat";
        private const string RHIBShortName = "rhib";
        private const string fuelpermissionName = "chillfuel.use";
        private const string fuelmodpermissionName = "chillfuel.modify";

        #endregion variables

        #region localization
        private const string inviteNoticeMsg = "assets/bundled/prefabs/fx/invite_notice.prefab";
        private const string dplnMinicopter = "Minicopter";
        private const string dplnScrapTransport = "Scrap heli";
        private const string dplnMotorboat = "Motorboat";
        private const string dplnRHIB = "RHIB";
        private const string dplnCar = "Car";
        private const string dplnShowValue = "Show fuel";
        private const string lblClose = "Close";
        private const string noModPerm = "You are not allowed to modify fuel settings";

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [dplnMinicopter] = dplnMinicopter,
                [dplnScrapTransport] = dplnScrapTransport,
                [dplnMotorboat] = dplnMotorboat,
                [dplnRHIB] = dplnRHIB,
                [dplnCar] = dplnCar,
                [dplnShowValue] = dplnShowValue,
                [lblClose] = lblClose,
                [noModPerm] = noModPerm
            }, this);
        }
        #endregion localization

        #region config
        private ConfigData config;

        class ConfigData
        {
            [JsonProperty(PropertyName = "Postition")]
            public AnchorPosition Position = new AnchorPosition
            {
                XAxis = 0.285f,
                YAxis = 0.010f
            };

            [JsonProperty(PropertyName = "Width")]
            public float Width = 0.045f;

            [JsonProperty(PropertyName = "Minicopter alert")]
            public int MiniAlert = 50;

            [JsonProperty(PropertyName = "Scrap heli alert")]
            public int ScrapAlert = 0;

            [JsonProperty(PropertyName = "Motorboat alert")]
            public int BoatAlert = 0;

            [JsonProperty(PropertyName = "RHIB alert")]
            public int RHIBAlert = 0;

            [JsonProperty(PropertyName = "Car alert")]
            public int CarAlert = 0;
        }

        private class AnchorPosition
        {
            [JsonProperty(PropertyName = "X-axis")]
            public float XAxis = 0;

            [JsonProperty(PropertyName = "Y-axis")]
            public float YAxis = 0;
        }

        protected override void LoadDefaultConfig()
        {
            config = new ConfigData();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigData>();
                if (config == null)
                    throw new Exception();

                SaveConfig();
            }
            catch
            {
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig() => Config.WriteObject(config);
        #endregion config

        #region data
        private Dictionary<ulong, PlayerData> playerData = new Dictionary<ulong, PlayerData>();

        class PlayerData
        {
            public bool Enabled;
            public int MiniAlert = 50;
            public int ScrapAlert = 0;
            public int BoatAlert = 0;
            public int RHIBAlert = 0;
            public int CarAlert = 0;
        }

        void InitPlayer(ulong userID, bool reset)
        {
            if (reset)
                playerData.Remove(userID);

            PlayerData data = new PlayerData();
            data.Enabled = true;
            data.MiniAlert = config.MiniAlert;
            data.ScrapAlert = config.ScrapAlert;
            data.BoatAlert = config.BoatAlert;
            data.RHIBAlert = config.RHIBAlert;
            data.CarAlert = config.CarAlert;
            
            playerData[userID] = data;
            SaveData();
        }

        void LoadData()
        {
            try
            {
                playerData = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, PlayerData>>(Name);
            }
            catch
            {
                playerData = new Dictionary<ulong, PlayerData>();
            }
        }

        void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, playerData);
        #endregion data

        #region commands
        [ChatCommand("Fuel")]
        void HandleChatcommand(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, fuelmodpermissionName))
            {
                player.ChatMessage(Lang(noModPerm, player.UserIDString));
                return;
            }

            ShowPlayerPanel(player);
        }

        [ConsoleCommand("fuel.add")]
        private void DeltaAlarm(ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null || arg.Connection.player == null)
                return;

            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            switch (arg.Args[0])
            {
                case "mini":
                    {
                        int newValue = playerData[player.userID].MiniAlert + Convert.ToInt32(arg.Args[1]);
                        if ((newValue < 0) || (newValue > 200))
                            return;

                        playerData[player.userID].MiniAlert = newValue;
                        SaveData();
                        break;
                    }

                case "scrap":
                    {
                        int newValue = playerData[player.userID].ScrapAlert + Convert.ToInt32(arg.Args[1]);
                        if ((newValue < 0) || (newValue > 200))
                            return;

                        playerData[player.userID].ScrapAlert = newValue;
                        SaveData();
                        break;
                    }
                    
                case "boat":
                    {
                        int newValue = playerData[player.userID].BoatAlert + Convert.ToInt32(arg.Args[1]);
                        if ((newValue < 0) || (newValue > 200))
                            return;

                        playerData[player.userID].BoatAlert = newValue;
                        SaveData();
                        break;
                    }
                    
                case "rhib":
                    {
                        int newValue = playerData[player.userID].RHIBAlert + Convert.ToInt32(arg.Args[1]);
                        if ((newValue < 0) || (newValue > 200))
                            return;

                        playerData[player.userID].RHIBAlert = newValue;
                        SaveData();
                        break;
                    }
                    
                case "car":
                    {
                        int newValue = playerData[player.userID].CarAlert + Convert.ToInt32(arg.Args[1]);
                        if ((newValue < 0) || (newValue > 200))
                            return;

                        playerData[player.userID].CarAlert = newValue;
                        SaveData();
                        break;
                    }
            }

            CuiHelper.DestroyUi(player, playerDataPanel);
            ShowValuePanel(player);
        }

        [ConsoleCommand("playerdatafuelclose")]
        private void CloseInfo(ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null || arg.Connection.player == null)
                return;

            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            CuiHelper.DestroyUi(player, playerLabelPanel);
            CuiHelper.DestroyUi(player, playerDataPanel);
            CuiHelper.DestroyUi(player, playerButtonPanel);
        }

        [ConsoleCommand("playerdatatoggleshowfuel")]
        private void ToggleShowFuel(ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null || arg.Connection.player == null)
                return;

            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;

            playerData[player.userID].Enabled = !playerData[player.userID].Enabled;
            SaveData();

            CuiHelper.DestroyUi(player, playerDataPanel);
            ShowValuePanel(player);

            DestroyUI(player, true);
            if (playerData[player.userID].Enabled)
                CheckAction(player, true);
        }
        #endregion commands

        #region Hooks
        private void Init()
        {
            permission.RegisterPermission(fuelpermissionName, this);
            permission.RegisterPermission(fuelmodpermissionName, this);

            LoadData();
        }

        private void Unload()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                if (!player.IsAlive())
                    continue;

                if (!permission.UserHasPermission(player.UserIDString, fuelpermissionName))
                    continue;

                CuiHelper.DestroyUi(player, playerLabelPanel);
                CuiHelper.DestroyUi(player, playerDataPanel);
                CuiHelper.DestroyUi(player, playerButtonPanel);

                if (!PlayerSignedUp(player))
                    continue;

                DestroyUI(player, true);
            }
        }

        void OnPlayerDeath(BasePlayer player, ref HitInfo info)
        {
            if (!permission.UserHasPermission(player.UserIDString, fuelpermissionName))
                return;

            if (!PlayerSignedUp(player))
                return;

            DestroyUI(player, true);
        }

        void OnEntityMounted(BaseMountable entity, BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, fuelpermissionName))
                return;
            
            if (!PlayerSignedUp(player))
                return;

            BaseEntity be = entity.GetParentEntity();
            if (be == null)
                return;

            EntityFuelSystem fuelSystem;

            ScrapTransportHelicopter scrap = be.GetComponentInParent<ScrapTransportHelicopter>();
            if (scrap != null)
            {
                fuelSystem = scrap.GetFuelSystem();
                if (fuelSystem != null)
                {
                    if (fuelSystem.fuelStorageInstance.IsValid(true))
                    {
                        UpdatePanels(player, fuelSystem.GetFuelAmount(), true);
                        DoPlayerTime(player, false);
                    }
                }
            }
            else
            {
                if (be.ShortPrefabName.Equals(minicopterShortName))
                {
                    Minicopter copter = be.GetComponentInParent<Minicopter>();
                    if (copter != null)
                    {
                        fuelSystem = copter.GetFuelSystem();
                        if (fuelSystem != null)
                        {
                            if (fuelSystem.fuelStorageInstance.IsValid(true))
                            {
                                UpdatePanels(player, fuelSystem.GetFuelAmount(), true);
                                DoPlayerTime(player, false);
                            }
                        }
                    }
                }
                else
                {
                    if (be.ShortPrefabName.Equals(rowboatShortName))
                    {
                        MotorRowboat boat = be.GetComponentInChildren<MotorRowboat>();
                        if (boat != null)
                        {
                            fuelSystem = boat.GetFuelSystem();
                            if (fuelSystem != null)
                            {
                                if (fuelSystem.fuelStorageInstance.IsValid(true))
                                {
                                    UpdatePanels(player, fuelSystem.GetFuelAmount(), true);
                                    DoPlayerTime(player, false);
                                }
                            }
                        }
                    }
                    else
                    {
                        if (be.ShortPrefabName.Equals(RHIBShortName))
                        {
                            RHIB rhib = be.GetComponentInChildren<RHIB>();
                            if (rhib != null)
                            {
                                fuelSystem = rhib.GetFuelSystem();
                                if (fuelSystem != null)
                                {
                                    if (fuelSystem.fuelStorageInstance.IsValid(true))
                                    {
                                        UpdatePanels(player, fuelSystem.GetFuelAmount(), true);
                                        DoPlayerTime(player, false);
                                    }
                                }
                            }
                        }
                        else
                        {
                            ModularCar car = be.GetComponentInChildren<ModularCar>();
                            if (car != null)
                            {
                                car.GetFuelSystem().HasFuel(false);
                                UpdatePanels(player, car.GetFuelSystem().GetFuelAmount(), true);
                                DoPlayerTime(player, false);
                            }
                        }
                    }
                }
            }
        }

        void OnEntityDismounted(BaseMountable entity, BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, fuelpermissionName))
                return;

            if (!PlayerSignedUp(player))
                return;

            DestroyUI(player, true);
        }
        #endregion Hooks

        #region Functions
        void DoPlayerTime(BasePlayer player, bool updatePicture)
        {
            if (player == null)
                return;
            
            if (player.isMounted)
            {
                timer.Once(5f, () =>
                {
                    CheckAction(player, updatePicture);
                });
            } 
            else
            {
                DestroyUI(player,true);
            }
        }

        void CheckAction(BasePlayer player, bool updatePicture)
        {
            if (player == null)
                return;

            if (!PlayerSignedUp(player))
            {
                DestroyUI(player, true);
                return;
            }

            EntityFuelSystem fuelSystem;

            BaseVehicle veh = player.GetMountedVehicle();
            if (veh != null)
            {
                ScrapTransportHelicopter scrap = veh.GetComponentInParent<ScrapTransportHelicopter>();
                if (scrap != null)
                {
                    fuelSystem = scrap.GetFuelSystem();
                    if (fuelSystem != null)
                    {
                        if (fuelSystem.fuelStorageInstance.IsValid(true))
                        {
                            if (playerData[player.userID].ScrapAlert > 0)
                            {
                                if ((fuelSystem.GetFuelAmount() >= playerData[player.userID].ScrapAlert - 2) && (fuelSystem.GetFuelAmount() <= playerData[player.userID].ScrapAlert))
                                    Effect.server.Run(inviteNoticeMsg, scrap.transform.position);
                            }

                            UpdatePanels(player, fuelSystem.GetFuelAmount(), updatePicture);
                            DoPlayerTime(player, false);
                        }
                    }
                }
                else
                {
                    Minicopter copter = veh.GetComponentInParent<Minicopter>();
                    if (copter != null)
                    {
                        fuelSystem = copter.GetFuelSystem();
                        if (fuelSystem != null)
                        {
                            if (fuelSystem.fuelStorageInstance.IsValid(true))
                            {
                                if (playerData[player.userID].MiniAlert > 0)
                                { 
                                    if ((fuelSystem.GetFuelAmount() >= playerData[player.userID].MiniAlert - 2) && (fuelSystem.GetFuelAmount() <= playerData[player.userID].MiniAlert))
                                        Effect.server.Run(inviteNoticeMsg, copter.transform.position);
                                }

                                UpdatePanels(player, fuelSystem.GetFuelAmount(), updatePicture);
                                DoPlayerTime(player, false);
                            }
                        }
                    }
                    else
                    {
                        RHIB rhib = veh.GetComponentInParent<RHIB>();
                        if (rhib != null)
                        {
                            fuelSystem = rhib.GetFuelSystem();
                            if (fuelSystem != null)
                            {
                                if (fuelSystem.fuelStorageInstance.IsValid(true))
                                {
                                    if (playerData[player.userID].RHIBAlert > 0)
                                    {
                                        if ((fuelSystem.GetFuelAmount() >= playerData[player.userID].RHIBAlert - 2) && (fuelSystem.GetFuelAmount() <= playerData[player.userID].RHIBAlert))
                                            Effect.server.Run(inviteNoticeMsg, rhib.transform.position);
                                    }

                                    UpdatePanels(player, fuelSystem.GetFuelAmount(), updatePicture);
                                    DoPlayerTime(player, false);
                                }
                            }
                        }
                        else
                        {
                            MotorRowboat motorBoat = veh.GetComponentInParent<MotorRowboat>();
                            if (motorBoat != null)
                            {
                                fuelSystem = motorBoat.GetFuelSystem();
                                if (fuelSystem != null)
                                {
                                    if (fuelSystem.fuelStorageInstance.IsValid(true))
                                    {
                                        if (playerData[player.userID].BoatAlert > 0)
                                        {
                                            if ((fuelSystem.GetFuelAmount() >= playerData[player.userID].BoatAlert - 2) && (fuelSystem.GetFuelAmount() <= playerData[player.userID].BoatAlert))
                                                Effect.server.Run(inviteNoticeMsg, motorBoat.transform.position);
                                        }

                                        UpdatePanels(player, fuelSystem.GetFuelAmount(), updatePicture);
                                        DoPlayerTime(player, false);
                                    }
                                }
                            }
                            else
                            {
                                ModularCar car = veh.GetComponentInParent<ModularCar>();
                                if (car != null)
                                {
                                    car.GetFuelSystem().HasFuel(true);

                                    if (playerData[player.userID].CarAlert > 0)
                                    {
                                        if ((car.GetFuelSystem().GetFuelAmount() >= playerData[player.userID].CarAlert - 2) && (car.GetFuelSystem().GetFuelAmount() <= playerData[player.userID].CarAlert))
                                            Effect.server.Run(inviteNoticeMsg, car.transform.position);
                                    }

                                    UpdatePanels(player, car.GetFuelSystem().GetFuelAmount(), updatePicture);
                                    DoPlayerTime(player, false);
                                }
                                else
                                    DestroyUI(player, true);
                            }
                        }
                    }
                }
            }
            else
            {
                DestroyUI(player, true);
            }
        }
        
        void UpdateState(BasePlayer player, bool newState)
        {
            bool doSave = false;

            if (!playerData.ContainsKey(player.userID))
            {
                InitPlayer(player.userID,false);
                playerData[player.userID].Enabled = newState;
                doSave = true;
            }
            else
            {
                if (playerData[player.userID].Enabled != newState)
                {
                    playerData[player.userID].Enabled = newState;
                    doSave = true;
                }
            }

            if (doSave)
            {
                SaveData();
                DestroyUI(player,true);
                if (newState == true)
                    CheckAction(player, true);
            }
        }
        #endregion Functions    

        #region ui
        void UpdatePanels(BasePlayer player, float condition, bool doPicture)
        {
            if (player == null)
                return;

            string color = "1 1 1 255";
            string valueText;

            if (condition < 0)
                condition = 0;

            valueText = ((int)Math.Round(condition, 0)).ToString();

            DestroyUI(player, doPicture);
            DrawUI(player, color, valueText, doPicture);
        }

        void DestroyUI(BasePlayer player, bool updatePicture)
        {
            CuiHelper.DestroyUi(player, "fuelmeterpanel");
            if (updatePicture)
                CuiHelper.DestroyUi(player, "fuelmeterpicture");
        }

        void DrawUI(BasePlayer player, string color, string valueText, bool updatePicture)
        {
            if (player == null)
                return;

            CuiElementContainer menu = Generate_Menu(player, color, valueText, updatePicture);
            CuiHelper.AddUi(player, menu);
        }

        CuiElementContainer Generate_Menu(BasePlayer player, string color, string valueText, bool updatePicture)
        {
            var elements = new CuiElementContainer();
            var info01 = elements.Add(new CuiLabel
            {
                Text =
                {
                    Text = valueText,
                    Color = "1 1 1 255",
                    FontSize = 13,
                    Align = TextAnchor.MiddleLeft
                },

                RectTransform = {
                    AnchorMin = (config.Position.XAxis + 0.015f).ToString() + " " + config.Position.YAxis.ToString(),      
                    AnchorMax = (config.Position.XAxis + 0.040f).ToString() + " " + (config.Position.YAxis + 0.020f).ToString() 
                },
            }, "Hud", "fuelmeterpanel"); ;

            if (updatePicture)
            {
                var elements2 = new CuiElementContainer();
                elements2.Add(new CuiElement
                {
                    Name = "fuelmeterpicture",
                    Components =
                    {
                        new CuiRawImageComponent
                        {
                            Color = "1 1 1 1",
                            Url = "https://i.imgur.com/t0d3aza.png"
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = config.Position.XAxis.ToString() + " " + config.Position.YAxis.ToString(),
                            AnchorMax = (config.Position.XAxis + 0.010f).ToString() + " " + (config.Position.YAxis + 0.020f).ToString()
                        }
                    }
                }); 

                CuiHelper.AddUi(player, elements2);
            }

            return elements;
        }
        #endregion ui

        #region playerpanel
        private const string playerLabelPanel = "playerfuellabels";
        private const string playerDataPanel = "playerfueldata";
        private const string playerButtonPanel = "playerfuelbuttons";

        private void ShowPlayerPanel(BasePlayer player)
        {
            var elements = new CuiElementContainer();

            var panel = elements.Add(new CuiPanel
            {
                Image = {
                    Color = ColorExtensions.ColorFromHex("#859c5aE4",255)  
                },

                RectTransform = {
                    AnchorMin = "0.40 0.35",
                    AnchorMax = "0.50 0.7"
                },

                CursorEnabled = false
            }, "Hud", playerLabelPanel);

            elements.Add(AddLabel(Lang(dplnMinicopter, player.UserIDString), "0.08 0.80", "0.9 0.90"), playerLabelPanel);
            elements.Add(AddLabel(Lang(dplnScrapTransport, player.UserIDString), "0.08 0.65", "0.9 0.75"), playerLabelPanel);
            elements.Add(AddLabel(Lang(dplnMotorboat, player.UserIDString), "0.08 0.50", "0.9 0.60"), playerLabelPanel);
            elements.Add(AddLabel(Lang(dplnRHIB, player.UserIDString), "0.08 0.35", "0.9 0.45"), playerLabelPanel); 
            elements.Add(AddLabel(Lang(dplnCar, player.UserIDString), "0.08 0.20", "0.9 0.30"), playerLabelPanel);

            elements.Add(AddLabel(Lang(dplnShowValue, player.UserIDString), "0.08 0.05", "0.9 0.15"), playerLabelPanel);


            CuiHelper.AddUi(player, elements);

            ShowValuePanel(player);
            ShowButtonPanel(player);
        }

        private void ShowValuePanel(BasePlayer player)
        {
            var elements = new CuiElementContainer();

            var panel = elements.Add(new CuiPanel
            {
                Image = {
                    Color = ColorExtensions.ColorFromHex("#859c5aE4",255)
                },

                RectTransform = {
                    AnchorMin = "0.50 0.35",
                    AnchorMax = "0.55 0.7"
                },

                CursorEnabled = true
            }, "Hud", playerDataPanel);

            elements.Add(AddValueBackground("0.35 0.80", "0.65 0.90"), playerDataPanel);
            elements.Add(AddValueBackground("0.35 0.65", "0.65 0.75"), playerDataPanel);
            elements.Add(AddValueBackground("0.35 0.50", "0.65 0.60"), playerDataPanel);
            elements.Add(AddValueBackground("0.35 0.35", "0.65 0.45"), playerDataPanel);
            elements.Add(AddValueBackground("0.35 0.20", "0.65 0.30"), playerDataPanel);
            elements.Add(AddValueBackground("0.35 0.05", "0.65 0.15"), playerDataPanel);

            elements.Add(AddValueLabel(GetStringValue(playerData[player.userID].MiniAlert), "0.35 0.80", "0.65 0.90"), playerDataPanel);
            elements.Add(AddValueLabel(GetStringValue(playerData[player.userID].ScrapAlert), "0.35 0.65", "0.65 0.75"), playerDataPanel);
            elements.Add(AddValueLabel(GetStringValue(playerData[player.userID].BoatAlert), "0.35 0.50", "0.65 0.60"), playerDataPanel);
            elements.Add(AddValueLabel(GetStringValue(playerData[player.userID].RHIBAlert), "0.35 0.35", "0.65 0.45"), playerDataPanel);
            elements.Add(AddValueLabel(GetStringValue(playerData[player.userID].CarAlert), "0.35 0.20", "0.65 0.30"), playerDataPanel);

            if (playerData[player.userID].Enabled)
                elements.Add(AddValueLabel("V", "0.35 0.05", "0.65 0.15"), playerDataPanel);
            else
                elements.Add(AddValueLabel("X", "0.35 0.05", "0.65 0.15"), playerDataPanel);

            CuiHelper.AddUi(player, elements);
        }

        private void ShowButtonPanel(BasePlayer player)
        {
            var elements = new CuiElementContainer();

            var panel = elements.Add(new CuiPanel
            {
                Image = {
                    Color = ColorExtensions.ColorFromHex("#859c5aE4",255)
                },

                RectTransform = {
                    AnchorMin = "0.55 0.35",
                    AnchorMax = "0.72 0.7"
                },

                CursorEnabled = true
            }, "Hud", playerButtonPanel);

            elements.Add(CreateUpDownButton(playerButtonPanel, "mini", false, "0.25 0.80", "0.40 0.90"), playerButtonPanel);
            elements.Add(CreateUpDownButton(playerButtonPanel, "scrap", false, "0.25 0.65", "0.40 0.75"), playerButtonPanel);
            elements.Add(CreateUpDownButton(playerButtonPanel, "boat", false, "0.25 0.50", "0.40 0.60"), playerButtonPanel);
            elements.Add(CreateUpDownButton(playerButtonPanel, "rhib", false, "0.25 0.35", "0.40 0.45"), playerButtonPanel);
            elements.Add(CreateUpDownButton(playerButtonPanel, "car", false, "0.25 0.20", "0.40 0.30"), playerButtonPanel);
            
            elements.Add(CreateUpDownButton(playerButtonPanel, "mini", true, "0.45 0.80", "0.60 0.90"), playerButtonPanel);
            elements.Add(CreateUpDownButton(playerButtonPanel, "scrap", true, "0.45 0.65", "0.60 0.75"), playerButtonPanel);
            elements.Add(CreateUpDownButton(playerButtonPanel, "boat", true, "0.45 0.50", "0.60 0.60"), playerButtonPanel);
            elements.Add(CreateUpDownButton(playerButtonPanel, "rhib", true, "0.45 0.35", "0.60 0.45"), playerButtonPanel);
            elements.Add(CreateUpDownButton(playerButtonPanel, "car", true, "0.45 0.20", "0.60 0.30"), playerButtonPanel);

            elements.Add(CreateToggleButton(playerButtonPanel, !playerData[player.userID].Enabled, "0.35 0.05", "0.50 0.15"), playerButtonPanel);

            elements.Add(CreateCloseButton(playerButtonPanel, Lang(lblClose, player.UserIDString)), playerButtonPanel);
            
            CuiHelper.AddUi(player, elements);
        }

        private static CuiButton CreateToggleButton(string mainPanelName, bool toggleOn, string anchorMin, string anchorMax)
        {
            return new CuiButton
            {
                Button =
                {
                    Command = "playerdatatoggleshowfuel",
                    Color = ColorExtensions.ColorFromHex("#060804E4",255),
                },
                RectTransform =
                {
                    AnchorMin = anchorMin,
                    AnchorMax = anchorMax
                },
                Text =
                {
                    Text = "<>",
                    FontSize = 14,
                    Align = TextAnchor.MiddleCenter
                },
                
            };
        }

        private static CuiButton CreateUpDownButton(string mainPanelName, string vehicle, bool up, string anchorMin, string anchorMax)
        {
            int value;
            string lblText = string.Empty;

            if (up)
            {
                value = 10;
                lblText = "+";
            }
            else
            {
                value = -10;
                lblText = "-";
            }

            string command = "fuel.add " + vehicle + " " + value.ToString();

            return new CuiButton
            {
                Button =
                {
                    Command = command,
                    Color = ColorExtensions.ColorFromHex("#060804E4",255)
                },
                RectTransform =
                {
                    AnchorMin = anchorMin,
                    AnchorMax = anchorMax
                },
                Text =
                {
                    Text = lblText,
                    FontSize = 14,
                    Align = TextAnchor.MiddleCenter
                }
            };
        }

        private static CuiButton CreateCloseButton(string mainPanelName, string lblText)
        {
            return new CuiButton
            {
                Button =
                {
                    Command = string.Format("playerdatafuelclose", mainPanelName),
                    Color = ColorExtensions.ColorFromHex("#060804E4",255)
                },
                RectTransform =
                {
                    AnchorMin = "0.68 0.04",
                    AnchorMax = "0.94 0.16"
                },
                Text =
                {
                    Text = lblText,
                    FontSize = 14,
                    Align = TextAnchor.MiddleCenter
                }
            };
        }

        private static CuiLabel AddLabel(string labelText, string anchorMin, string anchorMax)
        {
            return new CuiLabel
            {
                Text =
                {
                Text = labelText,
                Color = ColorExtensions.ColorFromHex("#FFFFFFFF", 255),
                FontSize = 14,
                Align = TextAnchor.MiddleLeft,
                },

                RectTransform = {
                AnchorMin = anchorMin,
                AnchorMax = anchorMax
                },
            };
        }

        private static CuiLabel AddValueLabel(string labelText, string anchorMin, string anchorMax)
        {
            return new CuiLabel
            {
                Text =
                {
                Text = labelText,
                Color = ColorExtensions.ColorFromHex("#FFFFFFFF", 255),
                FontSize = 14,
                Align = TextAnchor.MiddleCenter,
                },

                RectTransform = {
                AnchorMin = anchorMin,
                AnchorMax = anchorMax
                },
            };
        }

        private static CuiPanel AddValueBackground(string anchorMin, string anchorMax)
        {
            return new CuiPanel
            {
                Image = {
                    Color = ColorExtensions.ColorFromHex("##060804E4",255)
                },

                RectTransform = {
                    AnchorMin = anchorMin,
                    AnchorMax = anchorMax
                },

                CursorEnabled = true
            };

        }
        #endregion playerpanel

        #region helpers
        private bool PlayerSignedUp(BasePlayer player)
        {
            if (playerData.ContainsKey(player.userID))
            {
                return playerData[player.userID].Enabled;
            }
            else
            {
                InitPlayer(player.userID, false);
                return true;
            }
        }

        private string GetStringValue(int value)
        {
            if (value != 0)
                return value.ToString();
            else
                return "0";
        }

        private string Lang(string key, string userId = null, params object[] args) => string.Format(lang.GetMessage(key, this, userId), args);

        public static class ColorExtensions
        {
            public static string ToRustFormatString(Color color)
            {
                return string.Format("{0:F2} {1:F2} {2:F2} {3:F2}", color.r, color.g, color.b, color.a);
            }

            //
            // UnityEngine 5.1 Color extensions which were removed in 5.2
            //

            public static string ToHexStringRGB(Color col)
            {
                Color32 color = col;
                return string.Format("{0}{1}{2}", color.r, color.g, color.b);
            }

            public static string ToHexStringRGBA(Color col)
            {
                Color32 color = col;
                return string.Format("{0}{1}{2}{3}", color.r, color.g, color.b, color.a);
            }

            public static bool TryParseHexString(string hexString, out Color color)
            {
                try
                {
                    color = FromHexString(hexString);
                    return true;
                }
                catch
                {
                    color = Color.white;
                    return false;
                }
            }

            private static Color FromHexString(string hexString)
            {
                if (string.IsNullOrEmpty(hexString))
                {
                    throw new InvalidOperationException("Cannot convert an empty/null string.");
                }
                var trimChars = new[] { '#' };
                var str = hexString.Trim(trimChars);
                switch (str.Length)
                {
                    case 3:
                        {
                            var chArray2 = new[] { str[0], str[0], str[1], str[1], str[2], str[2], 'F', 'F' };
                            str = new string(chArray2);
                            break;
                        }
                    case 4:
                        {
                            var chArray3 = new[] { str[0], str[0], str[1], str[1], str[2], str[2], str[3], str[3] };
                            str = new string(chArray3);
                            break;
                        }
                    default:
                        if (str.Length < 6)
                        {
                            str = str.PadRight(6, '0');
                        }
                        if (str.Length < 8)
                        {
                            str = str.PadRight(8, 'F');
                        }
                        break;
                }
                var r = byte.Parse(str.Substring(0, 2), NumberStyles.HexNumber);
                var g = byte.Parse(str.Substring(2, 2), NumberStyles.HexNumber);
                var b = byte.Parse(str.Substring(4, 2), NumberStyles.HexNumber);
                var a = byte.Parse(str.Substring(6, 2), NumberStyles.HexNumber);

                return new Color32(r, g, b, a);
            }

            public static string ColorFromHex(string hexColor, int alpha)
            {
                hexColor = hexColor.TrimStart('#');
                if (hexColor.Length != 6 && hexColor.Length != 8)
                {
                    hexColor = "000000";
                }
                int red = int.Parse(hexColor.Substring(0, 2), NumberStyles.AllowHexSpecifier);
                int green = int.Parse(hexColor.Substring(2, 2), NumberStyles.AllowHexSpecifier);
                int blue = int.Parse(hexColor.Substring(4, 2), NumberStyles.AllowHexSpecifier);

                if (hexColor.Length == 8)
                {
                    alpha = int.Parse(hexColor.Substring(6, 2), NumberStyles.AllowHexSpecifier);
                }

                return $"{red / 255.0} {green / 255.0} {blue / 255.0} {alpha / 255.0}";
            }
        }
        #endregion helpers
    }
}

// --- End of file: ChillFuel.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/craft-spam-blocker ---
// --- Original File Path: C/CraftSpamBlocker/CraftSpamBlocker.cs ---

using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;
using UnityEngine;
using Object = UnityEngine.Object;

namespace Oxide.Plugins
{
    [Info("Craft Spam Blocker", "Iv Misticos", "1.0.2")]
    [Description("Prevents items from being crafted if the player's inventory is full")]
    class CraftSpamBlocker : RustPlugin
    {
        #region Variables
        
        private static List<PlayerController> _data = new List<PlayerController>();

        private static CraftSpamBlocker _ins;
        
        #endregion
        
        #region Configuration

        private static Configuration _config;

        private class Configuration
        {
            [JsonProperty(PropertyName = "Incorrect Crafts To Block")]
            public int IncorrectNeeded = 10;

            [JsonProperty(PropertyName = "Incorrect Craft Lifetime (In Seconds)")]
            public float IncorrectCraftLifetime = 5f;

            [JsonProperty(PropertyName = "Block Time (In Seconds)")]
            public float BlockTime = 300f;

            [JsonProperty(PropertyName = "Debug")]
            public bool Debug = false;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig() => Config.WriteObject(_config);

        protected override void LoadDefaultConfig() => _config = new Configuration();
        
        #endregion
        
        #region Hooks

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                { "Start Limited Crafting", "Your crafting was just limited for {time} seconds." },
                { "Limited Crafting", "Your crafting is limited. Please, stop spamming. Time left: {time}s" },
            }, this);
        }

        private object CanCraft(ItemCrafter crafter, ItemBlueprint blueprint, int amount) => Process(crafter, blueprint, amount);

        private void OnServerInitialized()
        {
            _ins = this;
            
            for (var i = 0; i < BasePlayer.activePlayerList.Count; i++)
            {
                OnPlayerConnected(BasePlayer.activePlayerList[i]);
            }
        }

        private void Unload()
        {
            for (var i = 0; i < BasePlayer.activePlayerList.Count; i++)
            {
                OnPlayerDisconnected(BasePlayer.activePlayerList[i]);
            }
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            _data.Add(player.gameObject.AddComponent<PlayerController>());
            foreach (var task in player.inventory.crafting.queue)
            {
                Process(player.inventory.crafting, task.blueprint, task.amount);
            }
        }

        private void OnPlayerDisconnected(Object player)
        {
            var index = PlayerController.FindIndex(player);
            if (index == -1)
                return;
            
            UnityEngine.Object.Destroy(_data[index]);
            _data.RemoveAt(index);
        }

        #endregion
        
        #region Controller

        private class PlayerController : FacepunchBehaviour
        {
            public BasePlayer player;

            public List<float> craftHistory = new List<float>();
            
            public float blockStartTime;

            private void Awake()
            {
                player = GetComponent<BasePlayer>();
            }

            public object UpdateCraftTime()
            {
                PrintDebug($"Craft History Length: {craftHistory.Count}");
                
                var current = Time.realtimeSinceStartup;
                
                {
                    var diff = current - blockStartTime;
                    if (diff < _config.BlockTime)
                    {
                        player.ChatMessage(GetMsg("Limited Crafting", player.UserIDString)
                            .Replace("{time}", $"{Math.Round(_config.BlockTime - diff, 1)}"));
                        return false;
                    }
                }

                // Cleaning old entries here, cuz why would we need a timer for it? We need to access it only here :)
                for (var i = craftHistory.Count - 1; i >= 0; i--)
                {
                    var craft = craftHistory[i];
                    var diff = current - craft;
                    if (diff > _config.IncorrectCraftLifetime)
                        craftHistory.RemoveAt(i);
                }

                if (craftHistory.Count >= _config.IncorrectNeeded)
                {
                    player.ChatMessage(GetMsg("Start Limited Crafting", player.UserIDString)
                        .Replace("{time}", $"{Math.Round(_config.BlockTime, 1)}"));
                    blockStartTime = current;
                    return false;
                }
                
                craftHistory.Add(current);
                return null;
            }

            public static int FindIndex(Object player)
            {
                for (var i = 0; i < _data.Count; i++)
                {
                    if (_data[i].player == player)
                        return i;
                }

                return -1;
            }

            public static PlayerController Find(Object player)
            {
                var index = FindIndex(player);
                return index == -1 ? null : _data[index];
            }
        }
        
        #endregion
        
        #region Helpers

        private object Process(ItemCrafter crafter, ItemBlueprint blueprint, int amount)
        {
            PrintDebug("PROCESSING");
            var player = crafter.gameObject.GetComponent<BasePlayer>(); // Getting the player
            if (player == null)
            {
                PrintWarning("Crafter player is null");
                return null;
            }

            return Process(player, blueprint, amount);
        }

        private object Process(BasePlayer player, ItemBlueprint blueprint, int amount)
        {
            var inventory = player.inventory;
            if (inventory.containerMain.itemList.Count < inventory.containerMain.capacity ||
                inventory.containerBelt.itemList.Count < inventory.containerBelt.capacity)
                return null; // Return if inventory is NOT full

            var controller = PlayerController.Find(player);

            var toReturn = (object) null;
            for (var i = 0; i < amount; i += blueprint.targetItem.stackable)
            {
                var result = controller.UpdateCraftTime();
                if (result != null)
                    toReturn = result;
            }

            return toReturn;
        }

        private static string GetMsg(string key, string userId = null) => _ins.lang.GetMessage(key, _ins, userId);

        private static void PrintDebug(string message)
        {
            if (_config.Debug)
                Interface.Oxide.LogDebug(message);
        }

        #endregion
    }
}

// --- End of file: CraftSpamBlocker.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/connect-respawn ---
// --- Original File Path: C/ConnectRespawn/ConnectRespawn.cs ---

ï»¿namespace Oxide.Plugins
{

    [Info("Connect Respawn", "Tryhard", "1.0.2")]
    [Description("Automatically respawns players upon connection")]
    public class ConnectRespawn : RustPlugin
    {

        private void Init() => permission.RegisterPermission("ConnectRespawn.allowed", this);


        private void OnPlayerConnected(BasePlayer player)
        {
            if (permission.UserHasPermission(player.UserIDString, "ConnectRespawn.allowed") && player.IsDead())
               player.Respawn();
        }
      
    }
}


// --- End of file: ConnectRespawn.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/console-filter ---
// --- Original File Path: C/ConsoleFilter/ConsoleFilter.cs ---

using Newtonsoft.Json;
using System.Collections.Generic;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("Console Filter", "Wulf", "0.0.2")]
    [Description("Filters debug, test, and other undesired output in the server console")]
    class ConsoleFilter : CovalencePlugin
    {
        #region Configuration

        private Configuration config;

        class Configuration
        {
            // TODO: Add support for regex matching

            [JsonProperty("List of partial strings to filter", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> Filter = new List<string>
            {
                "AngryAnt Behave version",
                "alphamapResolution is clamped to the range of",
                "api.facepunch.com/api/public/manifest/",
                "Checking for new Steam Item Definitions..",
                "Floating point textures aren't supported on this device",
                "HDR Render Texture not supported, disabling HDR on reflection probe",
                "Image Effects are not supported on this platform",
                "Loading Prefab Bundle",
                "Missing shader in",
                "Missing projectileID",
                "Motion vectors not supported on a platform that does not support",
                "SwitchParent Missed",
                "saddletest",
                "The image effect Main Camera",
                "The image effect effect -",
                "The referenced script",
                "Unsupported encoding: 'utf8'",
                "Warning, null renderer for ScaleRenderer!",
                "[AmplifyColor]",
                "[AmplifyOcclusion]",
                "[CoverageQueries] Disabled due to unsupported",
                "[CustomProbe]",
                "[Manifest] URI IS",
                "[SpawnHandler] populationCounts",
                ", disk("
            };

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    throw new JsonException();
                }

                if (!config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch
            {
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            LogWarning($"Configuration changes saved to {Name}.json");
            Config.WriteObject(config, true);
        }

        #endregion Configuration

        #region Filtering

        private void Init()
        {
            UnityEngine.Application.logMessageReceived += HandleLog;
#if HURTWORLD
            UnityEngine.Application.logMessageReceived -= ConsoleManager.Instance.CaptureLog;
#elif RUST
            UnityEngine.Application.logMessageReceived -= Facepunch.Output.LogHandler;
#elif SEVENDAYSTODIE
            UnityEngine.Application.logMessageReceivedThreaded -= Logger.Main.UnityLogCallback;
#endif
        }

        private void Unload()
        {
#if HURTWORLD
            UnityEngine.Application.logMessageReceived += ConsoleManager.Instance.CaptureLog;
#elif RUST
            UnityEngine.Application.logMessageReceived += Facepunch.Output.LogHandler;
#elif SEVENDAYSTODIE
            UnityEngine.Application.logMessageReceivedThreaded += Logger.Main.UnityLogCallback;
#endif
            UnityEngine.Application.logMessageReceived -= HandleLog;
        }

        private void HandleLog(string message, string stackTrace, UnityEngine.LogType type)
        {
            if (!string.IsNullOrEmpty(message) && !config.Filter.Any(message.Contains))
            {
#if HURTWORLD
                ConsoleManager.Instance.CaptureLog(message, stackTrace, type);
#elif RUST
                Facepunch.Output.LogHandler(message, stackTrace, type);
#elif SEVENDAYTODIE
                Logger.Main.SendToLogListeners(message, stackTrace, type);
#endif
            }
        }

        #endregion Filtering
    }
}


// --- End of file: ConsoleFilter.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/convert-status ---
// --- Original File Path: C/ConvertStatus/ConvertStatus.cs ---

using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Convert Status", "Orange", "1.0.8")]
    [Description("Change your admin status by a command")]
    public class ConvertStatus : RustPlugin
    {
        #region Vars

        private const string perm_use = "convertstatus.use";

        #endregion
    
        #region Oxide Hooks

        private void Init()
        {
            permission.RegisterPermission(perm_use, this);
            lang.RegisterMessages(messagesEN, this);
            lang.RegisterMessages(messagesRU, this, "ru");
        }

        #endregion

        #region Commands

        [ChatCommand("convert")]
        private void CmdConvert(BasePlayer p)
        {
            Convert(p);
        }

        #endregion

        #region Helpers

        private void Convert(BasePlayer p)
        {
            if (!HasPerm(p, perm_use))
            {
                message(p, "NOPERM");
                return;
            }

            if (p.IsAdmin)
            {
                if (p.IsFlying)
                {
                    p.SendConsoleCommand("noclip");
                    message(p, "NOCLIP");
                    timer.Once(1f, () => Convert(p));
                    return;
                }
                
                ServerUsers.Set(p.userID, ServerUsers.UserGroup.None, "", "");
                p.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, false);
                p.Connection.authLevel = 0;
                permission.RemoveUserGroup(p.UserIDString, "admin");
            }
            else
            {
                ServerUsers.Set(p.userID, ServerUsers.UserGroup.Owner, "", "");
                p.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, true);
                p.Connection.authLevel = 2;
                permission.AddUserGroup(p.UserIDString, "admin");
            }
            
            var a = p.IsAdmin ? "into" : "out of";
            PrintWarning($"{p.displayName} converted {a} admin status");
            message(p, "CHANGED", p.IsAdmin);
            ServerUsers.Save();
        }

        private bool HasPerm(BasePlayer p, string s)
        {
            return permission.UserHasPermission(p.UserIDString, s);
        }

        #endregion

        #region Language

        private Dictionary<string, string> messagesEN = new Dictionary<string, string>
        {
            {"NOPERM", "You don't have permission to that command!"},
            {"CHANGED", "Admin status now is <color=cyan>{0}</color>"},
            {"NOCLIP", "Fly will be deactivated in 1 sec. Don't use it in next 3 seconds or you will be banned!"},
        };
        
        private Dictionary<string, string> messagesRU = new Dictionary<string, string>
        {
            {"NOPERM", "Ð£ Ð²Ð°Ñ Ð½ÐµÑ Ð´Ð¾ÑÑÑÐ¿Ð° Ðº ÑÑÐ¾Ð¹ ÐºÐ¾Ð¼Ð°Ð½Ð´Ðµ!"},
            {"CHANGED", "ÐÐ°Ñ Ð°Ð´Ð¼Ð¸Ð½ ÑÑÐ°ÑÑÑ ÑÐµÐ¿ÐµÑÑ <color=cyan>{0}</color>"},
            {"NOCLIP", "Ð ÐµÐ¶Ð¸Ð¼ Ð¿Ð¾Ð»ÑÑÐ° Ð±ÑÐ´ÐµÑ Ð²ÑÐºÐ»ÑÑÐµÐ½ ÑÐµÑÐµÐ· 1 ÑÐµÐºÑÐ½Ð´Ñ. ÐÐµ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·ÑÐ¹ÑÐµ ÐµÐ³Ð¾ Ð² Ð±Ð»Ð¸Ð¶Ð°Ð¹ÑÐ¸Ðµ 3 ÑÐµÐºÑÐ½Ñ Ð¸Ð»Ð¸ Ð²Ñ Ð±ÑÐ´ÐµÑÐµ Ð·Ð°Ð±Ð°Ð½ÐµÐ½Ñ!"},
        };

        private void message(BasePlayer player, string key, params object[] args)
        {
            player.ChatMessage(string.Format(lang.GetMessage(key, this, player.UserIDString), args));
        }

        #endregion
    }
}

// --- End of file: ConvertStatus.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/custom-decay ---
// --- Original File Path: C/CustomDecay/CustomDecay.cs ---

ï»¿using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using System.Linq;
using UnityEngine;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
	[Info("CustomDecay", "Wizera", "1.0.2", ResourceId = 2690)]
	[Description("Custom decay for all individual entities")]

	class CustomDecay : CovalencePlugin
	{
		private bool configChanged = false;
		private int saveConfigInterval = 60;
		private ConfigData config;

		protected override void LoadConfig()
		{
			base.LoadConfig();
			config = Config.ReadObject<ConfigData>();
		}

		protected override void LoadDefaultConfig()
		{
			config = new ConfigData
			{
				DefaultMultiplier = 0.0f,

				PreventDecayWithinCupboardRange = false,

				DeveloperDebug = false,

				DecayConfig = new ConfigData.DecayConfigEntry()
				{
					buildingBlocks = new Dictionary<string, float>
					{
						{"Twigs", 1.0f },
						{"Wood", 0.0f },
						{"Stone", 0.0f },
						{"Metal", 0.0f },
						{"TopTier", 0.0f }
					},

					deployables = new Dictionary<string, float>
					{
						{ "barricade.concrete", 0.0f },
						{ "barricade.metal", 0.0f },
						{ "barricade.sandbags", 0.0f },
						{ "barricade.stone", 0.0f },
						{ "barricade.wood", 0.0f },
						{ "barricade.woodwire", 0.0f },
						{ "BBQ.Deployed", 0.0f },
						{ "beartrap", 0.0f },
						{ "box.wooden.large", 0.0f },
						{ "campfire", 0.0f },
						{ "fridge.deployed", 0.0f },
						{ "furnace", 0.0f },
						{ "furnace.large", 0.0f },
						{ "gates.external.high.wood", 0.0f },
						{ "jackolantern.angry", 0.0f },
						{ "jackolantern.happy", 0.0f },
						{ "landmine", 0.0f },
						{ "lantern.deployed", 0.0f },
						{ "locker.deployed", 0.0f },
						{ "reactivetarget_deployed", 0.0f },
						{ "refinery_small_deployed", 0.0f },
						{ "repairbench_deployed", 0.0f },
						{ "researchtable_deployed", 0.0f },
						{ "skull_fire_pit", 0.0f },
						{ "sleepingbag_leather_deployed", 0.0f },
						{ "spikes.floor", 0.0f },
						{ "survivalfishtrap.deployed", 0.0f },
						{ "tunalight.deployed", 0.0f },
						{ "wall.external.high.stone", 0.0f },
						{ "wall.external.high.wood", 0.0f },
						{ "water_catcher_large", 0.0f },
						{ "water_catcher_small", 0.0f },
						{ "WaterBarrel", 0.0f },
						{ "woodbox_deployed", 0.0f },
						{ "wall.window.glass.reinforced", 0.0f }
					}
				}
			};

			Puts("New configuration file created.");
		}

		protected override void SaveConfig() => Config.WriteObject(config);

		private void OnServerInitialized()
		{
			timer.Every(saveConfigInterval, () =>
			{
				try
				{
					if (configChanged)
					{
						configChanged = false;
						Puts("Saving decay confiuration file");
						SaveConfig();
					}
				}
				finally
				{
				}
			});
		}

		[Command("customdecay.toggledebug")]
		private void CustomDecayToggleDebug(IPlayer player, string command, string[] args)
		{
			if (!player.IsAdmin)
			{
				Puts("No permission to execute this command. You need auth level 2");
				return;
			}

			config.DeveloperDebug = !config.DeveloperDebug;
			if (config.DeveloperDebug)
				Puts("Debug switched on");
			else
				Puts("Debug switched off");
			SaveConfig();
		}

		void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
		{
			var started = DateTime.Now;

			try
			{
				if (hitInfo.damageTypes.Has(Rust.DamageType.Decay))
				{
					var block = entity as BuildingBlock;
					if (block == null)
					{
						// Process deployables
						ProcessEntity(entity, hitInfo, config.DecayConfig.deployables, entity.LookupPrefab().name);
					}
					else if (block.grade == BuildingGrade.Enum.Twigs || block.grade == BuildingGrade.Enum.Wood || block.grade == BuildingGrade.Enum.Stone || block.grade == BuildingGrade.Enum.Metal || block.grade == BuildingGrade.Enum.TopTier)
					{
						// Process Twigs + all foundation types of higher tiers
						ProcessEntity(entity, hitInfo, config.DecayConfig.buildingBlocks, block.grade.ToString());
					}
				}
			}
			finally
			{
				if (config.DeveloperDebug)
				{
					var ms = (DateTime.Now - started).TotalMilliseconds;
					if (ms > 10) Puts($"OnEntityTakeDamage took {ms} ms to execute.");
				}
			}
		}

		private bool UserHasCupboardPrivAtEntityPosition(Vector3 position, ulong entityOwnerID)
		{
			List<BaseEntity> list = new List<BaseEntity>();
			Vis.Entities<BaseEntity>(position, 1f, list);

			foreach (var ent in list)
			{
				var buildingPrivlidge = ent.GetComponentInParent<BuildingPrivlidge>();
				if (buildingPrivlidge != null)
				{
					foreach (var auth in buildingPrivlidge.authorizedPlayers.Select(x => x.userid).ToArray())
					{
						if (auth.ToString() == entityOwnerID.ToString())
						{
							return true;
						}
					}
				}
			}

			return false;
		}

		private void ProcessEntity(BaseCombatEntity entity, HitInfo hitInfo, Dictionary<string, float> dictionary, string prefabName)
		{
			float configMultiplier = 0.0f;

			if (config.PreventDecayWithinCupboardRange && prefabName != "Twigs" && UserHasCupboardPrivAtEntityPosition(entity.transform.position, entity.OwnerID != 0 ? entity.OwnerID : hitInfo.HitEntity.OwnerID))
			{
				// Entity is within users cupboard range, disable decay for entity
				configMultiplier = 0.0f;
			}
			else if (!GetMultiplierValueFromConfig(prefabName, dictionary, out configMultiplier))
			{
				AddDefaultToConfig(prefabName, dictionary);
			}

			bool skipped = true;
			float before = hitInfo.damageTypes.Get(Rust.DamageType.Decay);
			if (!configMultiplier.Equals(1.0f))
			{
				skipped = false;
				hitInfo.damageTypes.Scale(Rust.DamageType.Decay, configMultiplier);
			}

			if (config.DeveloperDebug)
			{
				float after = hitInfo.damageTypes.Get(Rust.DamageType.Decay);
				bool more = after > before;
				bool less = after < before;
				string damage = more ? "more" : (less ? (after.Equals(0f) ? "none" : "less") : (after.Equals(before) ? "default" : "not changed"));

				Puts($"Entity: {prefabName} before={before}, after={after}, multiplier={configMultiplier}, skipped={skipped}, damage={damage}");
			}
		}

		private bool GetMultiplierValueFromConfig(string prefabName, Dictionary<string, float> dictionary, out float configMultiplier)
		{
			float localConfigMultiplier = 0.0f;
			bool exists = dictionary.TryGetValue(prefabName, out localConfigMultiplier);
			if (localConfigMultiplier < 0f || localConfigMultiplier > 10000f)
			{
				localConfigMultiplier = 0f;
			}

			configMultiplier = localConfigMultiplier;
			return exists;
		}

		private void AddDefaultToConfig(string prefabName, Dictionary<string, float> dictionary)
		{
			if (config.DeveloperDebug)
			{
				Puts($"Adding missing config item for {prefabName} set to default multiplier {config.DefaultMultiplier}");
			}

			dictionary.Add(prefabName, config.DefaultMultiplier);

			configChanged = true;
		}

		private class ConfigData
		{
			[JsonProperty(PropertyName = "Default Decay Multiplier")]
			public float DefaultMultiplier { get; set; } = 0f;

			[JsonProperty(PropertyName = "Prevent Decay Within Cupboard Range")]
			public bool PreventDecayWithinCupboardRange { get; set; } = false;

			[JsonProperty(PropertyName = "Developer Debug")]
			public bool DeveloperDebug { get; set; } = false;

			[JsonProperty(PropertyName = "Decay Config")]
			public DecayConfigEntry DecayConfig { get; set; } = new DecayConfigEntry();

			public class DecayConfigEntry
			{
				[JsonProperty(PropertyName = "Building Blocks")]
				public Dictionary<string, float> buildingBlocks;

				[JsonProperty(PropertyName = "Deployables")]
				public Dictionary<string, float> deployables;
			}
		}
	}
}

// --- End of file: CustomDecay.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/crazy-copter ---
// --- Original File Path: C/CrazyCopter/CrazyCopter.cs ---

using Rust;
using UnityEngine;
using Newtonsoft.Json;
using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Crazy Copter", "Colon Blow", "1.0.2")]
    [Description("Monuments cause helicopter throttles to glitch at 100%")]

    public class CrazyCopter : CovalencePlugin
    {
        #region Configuration

        private static PluginConfig config;

        private class PluginConfig
        {
            public CrazyCopterSettings copterSettings { get; set; }

            public class CrazyCopterSettings
            {
                [JsonProperty(PropertyName = "Percent : Throttle will max out to this when around Monuments Triggers : ")] public int throttleEffect { get; set; }
                [JsonProperty(PropertyName = "Radius : Helicopter will detect Monument Triggers within this radius : ")] public float detectionRadius { get; set; }
                [JsonProperty(PropertyName = "Force : Add force against Helicopters when they are effected")] public bool forceEnabled { get; set; }
                [JsonProperty(PropertyName = "Force : Max force possible when enabled (randomizes direction and amount from zero to max)")] public float maxForceAmount { get; set; }
                [JsonProperty(PropertyName = "Minicopters are effected by glitch ? ")] public bool miniCopterEnabled { get; set; }
                [JsonProperty(PropertyName = "Scrap Helicopters are effected by glitch ? ")] public bool scrapHeliEnabled { get; set; }
            }

            public static PluginConfig DefaultConfig() => new PluginConfig()
            {
                copterSettings = new PluginConfig.CrazyCopterSettings
                {
                    throttleEffect = 100,
                    detectionRadius = 1f,
                    forceEnabled = true,
                    maxForceAmount = 2f,
                    miniCopterEnabled = true,
                    scrapHeliEnabled = true,
                }
            };
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("New configuration file created!!");
            config = PluginConfig.DefaultConfig();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
            SaveConfig();
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["interference"] = "Interference from Monument in Helicopter Controls !!"
            }, this);
        }

        #endregion

        #region Hooks

        private void OnEntitySpawned(BaseHelicopterVehicle baseHeli)
        {
            if (config.copterSettings.miniCopterEnabled && baseHeli.ToString().Contains("minicopter")) baseHeli.gameObject.AddComponent<ThrottleGlitchControl>();
            if (config.copterSettings.scrapHeliEnabled && baseHeli.ToString().Contains("scraptransporthelicopter")) baseHeli.gameObject.AddComponent<ThrottleGlitchControl>();
        }

        private void SendPlayerWarning(BasePlayer pilotPlayer)
        {
            var iplayer = covalence.Players.FindPlayerById(pilotPlayer.UserIDString);
            if (iplayer != null) iplayer.Message(lang.GetMessage("interference", this, iplayer.Id));
        }

        private void Unload()
        {
            DestroyAll<ThrottleGlitchControl>();
        }

        private static void DestroyAll<T>()
        {
            var objects = GameObject.FindObjectsOfType(typeof(T));
            if (objects != null)
                foreach (var gameObj in objects)
                    GameObject.Destroy(gameObj);
        }


        #endregion

        #region Throttle Glitch Control

        private class ThrottleGlitchControl : MonoBehaviour
        {
            private CrazyCopter instance;
            private BaseHelicopterVehicle baseHeli;
            private SphereCollider sphereCollider;
            private bool isEffected;
            private float throttleSpeed;
            private float counter;
            private BasePlayer pilotPlayer;

            private void Awake()
            {
                instance = new CrazyCopter();
                baseHeli = GetComponent<BaseHelicopterVehicle>();
                if (baseHeli == null) { OnDestroy(); return; }
                throttleSpeed = config.copterSettings.throttleEffect;
                sphereCollider = baseHeli.gameObject.AddComponent<SphereCollider>();
                sphereCollider.gameObject.layer = (int)Layer.Reserved1;
                sphereCollider.isTrigger = true;
                sphereCollider.radius = config.copterSettings.detectionRadius;
                isEffected = false;
                counter = 0f;
            }

            private void OnTriggerEnter(Collider col)
            {
                if (col.name.ToLower().Contains("prevent_building"))
                {
                    isEffected = true;
                    SendWarning();
                }
            }

            private void OnTriggerExit(Collider col)
            {
                if (col.name.ToLower().Contains("prevent_building"))
                {
                    counter = 0;
                    isEffected = false;
                }
            }

            private void SendWarning()
            {
                for (int i = 0; i < baseHeli.children.Count; i++)
                {
                    if (baseHeli.children[i] is BaseMountable)
                    {
                        var isMount = (BaseMountable)baseHeli.children[i];
                        if (isMount)
                        {
                            BasePlayer pilotPlayer = isMount.GetMounted();
                            if (pilotPlayer != null) instance.SendPlayerWarning(pilotPlayer);
                        }
                    }
                }
            }

            private void FixedUpdate()
            {
                if (isEffected)
                {
                    baseHeli.currentThrottle = throttleSpeed;
                    if (config.copterSettings.forceEnabled && baseHeli.IsMounted())
                    {
                        if (counter >= 75f) { baseHeli.rigidBody.AddRelativeTorque(Random.insideUnitSphere * config.copterSettings.maxForceAmount, ForceMode.VelocityChange); SendWarning(); counter = 0f; }
                        counter++;
                    }
                }
            }

            private void OnDestroy()
            {
                if (sphereCollider != null) GameObject.Destroy(sphereCollider);
                GameObject.Destroy(this);
            }

        }

        #endregion
    }
}

// --- End of file: CrazyCopter.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/cupboard-auto-lock ---
// --- Original File Path: C/CupboardAutoLock/CupboardAutoLock.cs ---

using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Cupboard Auto Lock", "BuzZ/Arainrr", "0.0.6")]
    [Description("Automatically add a codelock on cupboards.")]
    public class CupboardAutoLock : RustPlugin
    {
        private const string PERMISSION_USE = "cupboardautolock.code";
        private const string PREFAB_CODE_LOCK = "assets/prefabs/locks/keypad/lock.code.prefab";

        private void Init() => permission.RegisterPermission(PERMISSION_USE, this);

        private void OnEntityBuilt(Planner planner, GameObject obj)
        {
            var buildingPrivlidge = obj.ToBaseEntity() as BuildingPrivlidge;
            if (buildingPrivlidge == null || !buildingPrivlidge.OwnerID.IsSteamId()) return;
            var player = planner.GetOwnerPlayer();
            NextTick(() =>
            {
                if (buildingPrivlidge == null || buildingPrivlidge.IsDestroyed) return;
                if (buildingPrivlidge.GetSlot(BaseEntity.Slot.Lock) != null) return;
                if (!permission.UserHasPermission(buildingPrivlidge.OwnerID.ToString(), PERMISSION_USE)) return;
                var codeLock = GameManager.server.CreateEntity(PREFAB_CODE_LOCK) as CodeLock;
                if (codeLock == null) return;
                codeLock.SetParent(buildingPrivlidge, buildingPrivlidge.GetSlotAnchorName(BaseEntity.Slot.Lock));
                codeLock.OwnerID = buildingPrivlidge.OwnerID;
                codeLock.OnDeployed(buildingPrivlidge, player, null);
                codeLock.Spawn();
                if (configData.cupboardNoRefill) codeLock.SetFlag(BaseEntity.Flags.Locked, true, false);
                else
                {
                    codeLock.code = Random.Range(1000, 10000).ToString();
                    codeLock.whitelistPlayers.Add(buildingPrivlidge.OwnerID);
                    codeLock.SetFlag(BaseEntity.Flags.Locked, true);
                }
                buildingPrivlidge.SetSlot(BaseEntity.Slot.Lock, codeLock);
                Effect.server.Run(codeLock.effectLocked.resourcePath, codeLock.transform.position);
                if (player != null) player.ChatMessage(Lang("AutoLockMsg", player.UserIDString, codeLock.code));
            });
        }

        #region ConfigurationFile

        private ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Prevent inventory from being accessed")]
            public bool cupboardNoRefill;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                configData = Config.ReadObject<ConfigData>();
                if (configData == null)
                    LoadDefaultConfig();
            }
            catch
            {
                PrintError("The configuration file is corrupted");
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            configData = new ConfigData();
        }

        protected override void SaveConfig() => Config.WriteObject(configData);

        #endregion ConfigurationFile

        #region LanguageFile

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["AutoLockMsg"] = "Your cupboard is automatically locked. Password is {0}",
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["AutoLockMsg"] = "æ¨çé¢å°æå·²èªå¨ä¸éï¼å¯ç ä¸º {0}",
            }, this, "zh-CN");
        }

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        #endregion LanguageFile
    }
}

// --- End of file: CupboardAutoLock.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/crate-fix ---
// --- Original File Path: C/CrateFix/CrateFix.cs ---

using System;
using System.Collections.Generic;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Crate Fix", "birthdates", "1.0.2")]
    [Description("A fix for players being able to swap items in crates thus not letting them despawn.")]
    public class CrateFix : RustPlugin
    {
        #region Hooks
        private void Init()
        {
            LoadConfig();
        }

        object CanAcceptItem(ItemContainer container, Item item, int targetPos)
        {
            var Entity = container.entityOwner;
            if (Entity == null) return null;
            if (!Entity.PrefabName.Contains("crate") && !Entity.PrefabName.Contains("radtown")) return null;
            if (_config.DisabledCrates.Contains(Entity.PrefabName)) return null;
            var Player = item.GetRootContainer()?.GetOwnerPlayer();
            if (Player == null) return null;
            Player.ChatMessage(lang.GetMessage("CannotSwap", this, Player.UserIDString));
            return ItemContainer.CanAcceptResult.CannotAcceptRightNow;
        }
        #endregion

        #region Configuration & Language
        public ConfigFile _config;

        public class ConfigFile
        {
            [JsonProperty("Disabled Crates (Prefab)")]
            public List<string> DisabledCrates;
            public static ConfigFile DefaultConfig()
            {
                return new ConfigFile()
                {
                    DisabledCrates = new List<string>
                    {
                        "assets/prefabs/deployable/chinooklockedcrate/codelockedhackablecrate.prefab"
                    }
                };
            }
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"CannotSwap", "You cannot swap that item."},
            }, this);
        }


        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<ConfigFile>();
            if (_config == null)
            {
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig()
        {
            _config = ConfigFile.DefaultConfig();
            PrintWarning("Default configuration has been loaded.");
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }
        #endregion
    }
}
//Generated with birthdates' Plugin Maker

// --- End of file: CrateFix.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/custom-ammo ---
// --- Original File Path: C/CustomAmmo/CustomAmmo.cs ---

using System.Collections.Generic;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("Custom Ammo", "Ryz0r", "1.0.1")]
    [Description("Allows players to use a custom ammunition in their gun they are holding. Enabling custom ammo will give infinite ammo.")]
    internal class CustomAmmo : RustPlugin
    { 
        private const string NoReloadPerm = "customammo.noreload";
        private const string NoDamagePerm = "customammo.nodamage";
        private const string CommandPerm = "customammo.command";

        private static List<string> _toggledList = new List<string>();
        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, _toggledList);
        
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["BadFormat"] = "Incorrect Format - Try: /switch ammo.rifle",
                ["ArgOver"] = "You provided {0} arguments, but 1 was expected.",
                ["InvalidItem"] = "The item you are wielding is not a valid weapon.",
                ["BadAmmo"] = "Oh god no! This item is prohibited from being used. It will do bad things.",
                ["InvalidAmmo"] = "That is not a valid ammo type - Try: ammo.rifle, ammo.pistol, etc..",
                ["NoPerm"] = "You do not have the permissions required to use this command.",
                ["Disabled"] = "You have disabled the switch command.",
                ["NotOn"] = "You have not yet initialized the /switch command."
                
            }, this);
        }
        
        private void OnNewSave(string filename)
        {
            if(Interface.Oxide.DataFileSystem.ExistsDatafile(Name))
            {
                Interface.Oxide.DataFileSystem.GetFile(Name).Clear();
                Interface.Oxide.DataFileSystem.GetFile(Name).Save();

                Puts($"Wiped '{Name}.json'");
            }
        }
        
        private void Init()
        {
            permission.RegisterPermission(NoReloadPerm, this);
            permission.RegisterPermission(NoDamagePerm, this);
            permission.RegisterPermission(CommandPerm, this);
        }

        [ChatCommand("switch")]
        private void SwitchAmmoCommand(BasePlayer player, string command, string[] args)
        {
            if (permission.UserHasPermission(player.UserIDString, CommandPerm))
            {
                if (args.Length == 0)
                {
                    if (_toggledList.Contains(player.UserIDString))
                    {
                        _toggledList.Remove(player.UserIDString);
                        SaveData();
                        
                        SendReply(player, lang.GetMessage("Disabled", this, player.UserIDString));
                    }
                    else
                    {
                        SendReply(player, lang.GetMessage("NotOn", this, player.UserIDString));
                    }
                }
                else
                {
                    if (args.Length > 1)
                    {
                        SendReply(player,
                            string.Format(lang.GetMessage("ArgOver", this, player.UserIDString), args.Length));
                        return;
                    }

                    if (args[0].Contains("rocket") || args[0].Contains("grenade") || !args[0].StartsWith("ammo."))
                    {
                        SendReply(player, lang.GetMessage("BadAmmo", this, player.UserIDString));
                        return;
                    }

                    var weapon = player.GetHeldEntity() as BaseProjectile;

                    if (!weapon.IsValid())
                    {
                        SendReply(player, lang.GetMessage("InvalidItem", this, player.UserIDString));
                        return;
                    }

                    if (!ItemManager.FindItemDefinition(args[0]))
                    {
                        SendReply(player, lang.GetMessage("InvalidAmmo", this, player.UserIDString));
                        return;
                    }

                    if (weapon == null) return;
                    _toggledList.Add(player.UserIDString);
                    SaveData();
                    
                    weapon.primaryMagazine.contents = weapon.primaryMagazine.capacity;
                    weapon.primaryMagazine.ammoType = ItemManager.FindItemDefinition(args[0]);
                    weapon.SendNetworkUpdateImmediate();
                }
            }
            else
            {
                SendReply(player, lang.GetMessage("NoPerm", this, player.UserIDString));
            }
        }

        private void OnWeaponFired(BaseProjectile weapon, BasePlayer player)
        {
            if (_toggledList.Contains(player.UserIDString))
            {
                if (permission.UserHasPermission(player.UserIDString, NoDamagePerm))
                {
                    weapon.GetItem().condition = weapon.GetItem().info.condition.max;
                    weapon.SendNetworkUpdateImmediate();
                }
            
                if (permission.UserHasPermission(player.UserIDString, NoReloadPerm))
                {
                    if (weapon.primaryMagazine.contents > 0) return;
                    weapon.primaryMagazine.contents = weapon.primaryMagazine.capacity;
                    weapon.SendNetworkUpdateImmediate();
                }
            }
        }

        private object OnReloadWeapon(BasePlayer player, BaseProjectile projectile)
        {
            if (_toggledList.Contains(player.UserIDString))
            {
                projectile.primaryMagazine.contents = projectile.primaryMagazine.capacity;
                projectile.SendNetworkUpdateImmediate();
                return true;
            }
            
            return null;
        }

    }
}

// --- End of file: CustomAmmo.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/cupboard-limiter ---
// --- Original File Path: C/CupboardLimiter/CupboardLimiter.cs ---

using System;
using System.Linq;
using System.Reflection;
using System.Collections.Generic;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using UnityEngine;

#region Changelogs and ToDo
/**********************************************************************
 * 
 * v1.1.0   :   Started to Maintain (Krungh Crow)
 *          :   Fixed RPC error
 *          :   Added permissions
 *          :   Language File Updated
 *          :   Debug warning added (read .cs file)
 *          :   Rewrite of config handling
 *          :   Coding Optimisations
 * v1.2.0   :   Added discord notification for exceeding limit
 *          :   Added Remaining tc chat notification after 1st placement
 * V1.2.1   :   Fix for remaining tc limit chatmessage
 * v1.2.2   :   Performance Update
 * v1.2.3   :   Possible fix for NRE at startup
 * v1.3.0   :   Maintain (Spiikesan): Rework done. Performance increased and bugs fixed.
 * v1.3.1   :   Lang messages are now version dependant (CANCELLED)
 * v1.4.0   :   Add command 'clinspect' to retrieve users TCs informations
 * v1.5.0   :   "Limit reached" message is now working.
 *          :   Chat prefix and icon is customizable.
 *          :   Dynamic limits and permissions.
 * v1.6.0   :   Add team-based limits.
 * v1.6.1   :   Refactoring team-based limits
 * V1.6.2   :   Command "tc" now use the player instead of the argument if there is no argument.
 **********************************************************************/
#endregion

namespace Oxide.Plugins
{
    [Info("Cupboard Limiter", "Spiikesan", "1.7.6")]
    [Description("Simplified version for cupboard limits")]

    public class CupboardLimiter : RustPlugin
    {
        #region Variables

        bool debug = false;

        const string Vip_Perm = "cupboardlimiter.vip";
        const string Bypass_Perm = "cupboardlimiter.bypass";
        const string Admin_Perm = "cupboardlimiter.admin";
        const string Other_Perm = "cupboardlimiter.limit_";
        const string CommandList_Perm = "cupboardlimiter.commandList";

        const string Message_MaxLimitDefault = "MaxLimitDefault";
        const string Message_MaxLimitVip = "MaxLimitVip";
        const string Message_MaxLimit = "MaxLimit";
        const string Message_Remaining = "Remaining";
        const string Message_NoPermission = "NoPermission";
        const string Message_Inspect = "cInspect";
        const string Message_InspectOwn = "cInspectOwn";
        const string Message_InspectNotFound = "cInspectNotFound";
        const string Message_InspectUsage = "cInspectUsage";
        const string Message_TeamOvercount = "TeamOvercount";
        const string Message_TeamOvercountTarget = "TeamOvercountTarget";
        const string Message_Error = "Error";


        Dictionary<ulong, List<BuildingPrivlidge>> TCIDs = new Dictionary<ulong, List<BuildingPrivlidge>>();
        private int TCCount(BasePlayer player)
        {
            //bypass command : ignore TC from player with bypass ?
            List<BuildingPrivlidge> tcs;
            int count = 0;

            if (configData.Limits.GlobalTeamLimit && player.Team != null && player.Team.members.Count > 1)
            {
                foreach (var pl in player.Team.members)
                {
                    if (TCIDs.TryGetValue(pl, out tcs))
                    {
                        count += tcs.Count;
                    }
                }
                // Counting pending invites to avoid bypass
                foreach (var pl in player.Team.invites.Except(player.Team.members))
                {
                    if (TCIDs.TryGetValue(pl, out tcs))
                    {
                        count += tcs.Count;
                    }
                }
            }
            else
            {
                if (TCIDs.TryGetValue(player.userID, out tcs))
                {
                    count = tcs.Count;
                }
            }
            return count;
        }

        private void TCAdd(ulong playerId, BuildingPrivlidge tcId)
        {
            List<BuildingPrivlidge> tcs;
            if (TCIDs.TryGetValue(playerId, out tcs))
            {
                if (!tcs.Contains(tcId))
                    tcs.Add(tcId);
            }
            else
            {
                tcs = new List<BuildingPrivlidge>();
                tcs.Add(tcId);
                TCIDs.Add(playerId, tcs);
            }
        }

        private void TCDel(ulong playerId, BuildingPrivlidge tcId)
        {
            List<BuildingPrivlidge> tcs;
            if (TCIDs.TryGetValue(playerId, out tcs))
            {
                tcs.Remove(tcId);
            }
        }

        #endregion

        #region Configuration

        void Init()
        {
            if (!LoadConfigVariables())
            {
                Puts("Config file issue detected. Please delete file, or check syntax and fix.");
                return;
            }
            permission.RegisterPermission(Vip_Perm, this);
            permission.RegisterPermission(Bypass_Perm, this);
            permission.RegisterPermission(Admin_Perm, this);
            permission.RegisterPermission(CommandList_Perm, this);

            for (int i = 0; i < configData.Limits.OtherLimits.Count; i++)
            {
                permission.RegisterPermission(Other_Perm + (i + 1), this);
            }

            if (debug) Puts($"Debug is activated check CupboardLimiter.cs file if not intended");
        }

        private ConfigData configData;

        class ConfigData
        {
            [JsonProperty(PropertyName = "Max amount of TC(s) to place")]
            public Settings Limits = new Settings();
            [JsonProperty(PropertyName = "Discord Notification")]
            public SettingsDiscord Discord = new SettingsDiscord();
            [JsonProperty(PropertyName = "Chat Settings")]
            public SettingsChat Chat = new SettingsChat();
        }

        class Settings
        {
            [JsonProperty(PropertyName = "Limit Default")]
            public int DefaultLimit = 1;
            [JsonProperty(PropertyName = "Limit Vip")]
            public int VipLimit = 3;
            [JsonProperty(PropertyName = "Limit Others")]
            public List<int> OtherLimits = new List<int>();
            [JsonProperty(PropertyName = "Limit Others Can Downgrade Default")]
            public bool OtherLimitsOverDefault = false;
            [JsonProperty(PropertyName = "Global Team Limit")]
            public bool GlobalTeamLimit = true;
            [JsonProperty(PropertyName = "Limits In Team")]
            public Dictionary<int, int> TeamLimits = new Dictionary<int, int>();
        }

        class SettingsDiscord
        {
            [JsonProperty(PropertyName = "Discord Webhook URL")]
            public string DiscordWebhookAddress = string.Empty;
        }

        class SettingsChat
        {
            [JsonProperty(PropertyName = "Prefix")]
            public string Prefix = "[Cupboard Limiter] :";
            [JsonProperty(PropertyName = "Icon's SteamId")]
            public ulong SteamIdIcon = 76561198049668039;

        }

        private bool LoadConfigVariables()
        {
            try
            {
                configData = Config.ReadObject<ConfigData>();
                foreach (var data in configData.Limits.TeamLimits)
                {
                    if (data.Key <= 1)
                    {
                        Puts($"Config Warning : Team count {data.Key} is below the limit of 2 players.");
                    }
                    else if (data.Key > RelationshipManager.maxTeamSize)
                    {
                        Puts($"Config Warning : Team count {data.Key} is over the max team limit of {RelationshipManager.maxTeamSize} players.");
                    }
                }
            }
            catch (Exception ex)
            {
                PrintError("An error occured dugin ConfigData load: " + ex.ToString());
                return false;
            }
            SaveConf();
            return true;
        }

        protected override void LoadDefaultConfig()
        {
            Puts("Fresh install detected Creating a new config file.");
            configData = new ConfigData();
            SaveConf();
        }

        void SaveConf() => Config.WriteObject(configData, true);
        #endregion

        #region LanguageAPI
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [Message_MaxLimitDefault] = "You have reached the Default maximum cupboard limit of {0}",
                [Message_MaxLimitVip] = "You have reached the Vip maximum cupboard limit of {0}",
                [Message_MaxLimit] = "You have reached the maximum cupboard limit of {0}",
                [Message_Remaining] = "Amount of TC's remaining = {0}",
                [Message_NoPermission] = "You don't have the permission.",
                [Message_Inspect] = "The user {0} have {1} TCs.",
                [Message_InspectOwn] = "You have {0} TC and {1} remaining.",
                [Message_InspectNotFound] = "Error: User not found",
                [Message_TeamOvercount] = "You cannot invite this player right now, he have {0} TC too many.",
                [Message_TeamOvercountTarget] = "You cannot be invited by this player right now, you have {0} TC too many.",
                [Message_InspectUsage] = "Usage: tc <partialNameOrId> ...",
                [Message_Error] = "An unexpected error occured.",
            }, this, "en");

            lang.RegisterMessages(new Dictionary<string, string>
            {
                [Message_MaxLimitDefault] = "Vous avez atteint la limite par defaut de {0} pour les armoires a outils.",
                [Message_MaxLimitVip] = "Vous avez atteint la limite VIP de {0} pour les armoires a outils.",
                [Message_MaxLimit] = "Vous avez atteint la limite de {0} pour les armoires a outils.",
                [Message_Remaining] = "Il vous reste {0} armoires a outils a placer.",
                [Message_NoPermission] = "Vous n'avez pas la permission",
                [Message_Inspect] = "Le joueur {0} a {1} TCs.",
                [Message_InspectOwn] = "Vous avez {0} TC(s) et {1} restant a poser.",
                [Message_InspectNotFound] = "Erreur: Le joueur n'a pas ete trouve.",
                [Message_TeamOvercount] = "Vous ne pouvez pas inviter ce joueur actuellement, il a {0} armoires a outils en trop.",
                [Message_TeamOvercountTarget] = "Vous ne pouvez pas etre invite par ce joueur actuellement, vous avez {0} armoires a outils en trop.",
                [Message_InspectUsage] = "Usage: tc <pseudoPartielOuId> ...",
                [Message_Error] = "Une erreur inattendue s'est produite.",
            }, this, "fr");
        }

        #endregion

        #region Hooks

        void OnServerInitialized()
        {
            if (!configData.Discord.DiscordWebhookAddress.Contains("discord.com/api/webhooks"))
            {
                Puts("Warning !!\n----------------------------------\nNo Webhook has been assigned yet !\n----------------------------------");
            }
            else if (configData.Discord.DiscordWebhookAddress.Contains("discord.com/api/webhooks"))
            {
                Puts($"Verified !!\n----------------------------------\nWebhook has been found :\n{configData.Discord.DiscordWebhookAddress}\n----------------------------------");
            }

            foreach (var entity in BaseNetworkable.serverEntities)
            {
                BuildingPrivlidge TC = entity as BuildingPrivlidge;
                if (TC != null && !TC.IsDestroyed && TC.OwnerID.IsSteamId())
                {
                    TCAdd(TC.OwnerID, TC);
                }
            }

            if (debug)
            {
                foreach (var userTc in TCIDs)
                {
                    try
                    {
                        Puts("User " + BasePlayer.allPlayerList.Single(pl => pl.userID == userTc.Key) + " has " + userTc.Value.Count + " TC : ");
                    }
                    catch
                    {
                        Puts("User " + userTc.Key + " has " + userTc.Value.Count + " TC : ");
                    }
                    foreach (var tc in userTc.Value)
                    {
                        Puts("   - " + tc);
                    }
                }
            }
        }

        void OnEntitySpawned(BaseEntity entity, UnityEngine.GameObject gameObject)
        {
            BuildingPrivlidge TC = entity as BuildingPrivlidge;

            if (TC != null && TC.OwnerID.IsSteamId())
            {
                TCAdd(TC.OwnerID, TC);

                if (debug) Puts($"a cupboard is spawning in world. It's ID is {TC.GetInstanceID()} and owner {TC.OwnerID}");

                BasePlayer player = BasePlayer.FindByID(TC.OwnerID);
                if (player == null) return;
                if (player.IsSleeping() || !player.IsConnected)
                {
                    if (debug) Puts($"sleep|offline check");
                    return;
                }

                // HOW MANY CHECK

                if (!permission.UserHasPermission(player.UserIDString, Bypass_Perm))
                {
                    int limit = GetTCLimit(player);
                    int count = TCCount(player);

                    if (debug) Puts($"{player}: cupboard count {count}");
                    // EXTRA CHECK IF PLAYER HAS ABNORMAL CUPBOARD COUNT
                    if (count - limit > 1) PrintWarning($"PLAYER {player.displayName} has {count - limit - 1} more cupboards over his limit of {limit} !");
                    // CANCEL IF LIMIT REACHED

                    if (count > limit)
                    {
                        NextTick(() =>
                        {
                            if (configData.Discord.DiscordWebhookAddress.Contains("discord.com/api/webhooks"))
                            {
                                try
                                {
                                    webrequest.Enqueue(configData.Discord.DiscordWebhookAddress, $"{{\"content\":\" {DateTime.Now.ToShortTimeString()} : **{player}** : Tried to place more TC's than the max of **{limit}**\"}}",
                                    Callback, this, RequestMethod.POST, new Dictionary<string, string> { ["Content-Type"] = "application/json" });
                                }
                                catch { }
                            }
                            RefundTC(TC, player);
                        });
                    }
                    else
                        ChatMessage(player, FormatMessage(Message_Remaining, player.UserIDString, limit - count));
                }
            }
            return;
        }

        void OnEntityKill(BaseEntity entity)
        {
            BuildingPrivlidge TC = entity as BuildingPrivlidge;

            if (TC is BuildingPrivlidge && TC.OwnerID.IsSteamId())
            {
                TCDel(TC.OwnerID, TC);
            }
        }

        object OnTeamInvite(BasePlayer inviter, BasePlayer target)
        {
            if (configData.Limits.GlobalTeamLimit)
            {
                int limit = GetTCLimit(inviter, true);
                int teamTC = TCCount(inviter);
                int targetTC = TCCount(target);

                if (teamTC + targetTC > limit)
                {
                    ChatMessage(inviter, FormatMessage(Message_TeamOvercount, inviter.UserIDString, (teamTC + targetTC) - limit));
                    ChatMessage(target, FormatMessage(Message_TeamOvercountTarget, target.UserIDString, (teamTC + targetTC) - limit));
                    inviter.Team.RejectInvite(target);
                    return false;
                }
            }
            return null;
        }

        #endregion

        #region Commands

        [ChatCommand("tc")]
        private void ChatCommand_Inspect(BasePlayer player, string command, string[] args)
        {

            ulong userID = player.userID;
            bool isOwn = true;
            string receiverId = player.UserIDString;
            if (args.Length >= 1)
            {
                isOwn = false;
                userID = 0;
                if (permission.UserHasPermission(player.UserIDString, CommandList_Perm))
                {
                    var user = covalence.Players.FindPlayer(args[0]);

                    if (user is IPlayer)
                    {
                        if (ulong.TryParse(user.Id, out userID))
                        {
                            player = user.Object as BasePlayer;
                        }
                    }
                    else
                    {
                        ChatMessage(player, FormatMessage(Message_InspectNotFound, player.UserIDString));
                    }
                }
                else
                {
                    ChatMessage(player, FormatMessage(Message_NoPermission, player.UserIDString));
                }
            }

            if (player != null && userID.IsSteamId())
            {
                ChatMessage(player, PlayerTcsString(player, receiverId, isOwn));
            }
            else
            {
                ChatMessage(player, FormatMessage(Message_Error, player.UserIDString));
            }
        }
        [ConsoleCommand("tc")]
        private void ServerCommand_Inspect(ConsoleSystem.Arg arg)
        {
            PrintToConsole("ServerCommand");
            if (!arg.IsServerside)
            {
                arg.ReplyWith("Unkown command.");
            }
            else if (arg.Args == null || arg.Args.Count() == 0)
            {
                arg.ReplyWith(FormatMessage(Message_InspectUsage, null));
            }
            else
            {
                string reply = "Query result:\n";
                foreach (string playerId in arg.Args)
                {
                    var user = covalence.Players.FindPlayer(playerId);
                    if (user != null)
                    {
                        BasePlayer player = user.Object as BasePlayer;
                        if (player != null)
                        {
                            reply += $"{PlayerTcsString(player, null, false)}\n";
                        }
                        else
                        {
                            reply += $"Player \"{playerId}\" cannot be got as BasePlayer\n";
                        }
                    }
                    else
                    {
                        reply += $"Player \"{playerId}\" not found\n";
                    }
                }
                arg.ReplyWith(reply);
            }
        }


        #endregion

        #region Helpers

        void RefundTC(BaseEntity tC, BasePlayer player)
        {
            if (debug) Puts($"cancelling cupboard ID {tC.GetInstanceID()} of player {player.UserIDString}");

            if (permission.UserHasPermission(player.UserIDString, Vip_Perm))
            {
                ChatMessage(player, FormatMessage(Message_MaxLimitVip, player.UserIDString, configData.Limits.VipLimit));
            }
            else
            {
                bool otherLimitPerm = false;
                for (int i = 0; i < configData.Limits.OtherLimits.Count; i++)
                {
                    if (permission.UserHasPermission(player.UserIDString, Other_Perm + (i + 1)))
                    {
                        otherLimitPerm = true;
                        break;
                    }
                }
                if (otherLimitPerm)
                {
                    ChatMessage(player, FormatMessage(Message_MaxLimit, player.UserIDString, configData.Limits.DefaultLimit));
                }
                else
                {
                    ChatMessage(player, FormatMessage(Message_MaxLimitDefault, player.UserIDString, configData.Limits.DefaultLimit));
                }
            }

            tC.KillMessage();
            var itemToGive = ItemManager.CreateByItemID(-97956382, 1);
            if (itemToGive != null) player.inventory.GiveItem(itemToGive);
        }

        public int GetTCLimit(BasePlayer player, bool isInvite = false)
        {
            int limit = configData.Limits.DefaultLimit;

            if (debug) Puts($"{player}: Default limit {limit}");

            if (configData.Limits.TeamLimits.Count > 0 && player.Team != null)
            {
                int tcount = player.Team.members.Count + (isInvite ? 1 : 0);

                if (tcount > 1)
                {
                    foreach (var tlim in configData.Limits.TeamLimits)
                    {
                        if (tlim.Key <= tcount)
                            limit = tlim.Value;
                        else
                            break;
                    }
                    if (debug) Puts($"{player}: Team limit {limit} for {tcount} players in the team");
                }
            }

            if (configData.Limits.OtherLimits.Count > 0)
            {
                int olimit = -1;
                for (int i = 0; i < configData.Limits.OtherLimits.Count; i++)
                {
                    if (permission.UserHasPermission(player.UserIDString, Other_Perm + (i + 1)))
                    {
                        if (configData.Limits.OtherLimits[i] > olimit)
                        {
                            olimit = configData.Limits.OtherLimits[i];
                        }
                    }
                }
                if (olimit > 0 && (olimit > limit || configData.Limits.OtherLimitsOverDefault))
                {
                    limit = olimit;
                }
                if (debug) Puts($"{player}: Other limit {olimit}");
            }

            if (permission.UserHasPermission(player.UserIDString, Vip_Perm))
            {
                limit = configData.Limits.VipLimit;
                if (debug) Puts($"{player}: VIP limit {limit}");
            }

            return limit;
        }

        public void Callback(int code, string response)
        {
        }

        public string FormatMessage(string messageId, string userId, params object[] parameters)
        {
            return string.Format(lang.GetMessage(messageId, this, userId), parameters);
        }

        private void ChatMessage(BasePlayer player, string message)
        {
            Player.Message(player, message, configData.Chat.Prefix, configData.Chat.SteamIdIcon);
        }

        private string PlayerTcsString(BasePlayer player, string receiverId, bool isOwn)
        {
            List<BuildingPrivlidge> tcs;
            if (!TCIDs.TryGetValue(player.userID, out tcs))
                tcs = new List<BuildingPrivlidge>();
            tcs = tcs.FindAll(tc => !tc.IsDestroyed);
            string msg = isOwn ? FormatMessage(Message_InspectOwn, receiverId, tcs.Count, GetTCLimit(player) - TCCount(player))
                               : FormatMessage(Message_Inspect, receiverId, player.displayName, tcs.Count);
            foreach (var TC in tcs)
            {
                msg += "\n - Pos: " + GetCoordinates(TC.ServerPosition);
            }
            return msg;
        }

        private string GetCoordinates(Vector3 position)
        {
            const float CELL_SIZE = 150f;
            Vector3 realPos = position - TerrainMeta.Transform.position; //Getting the real position in the "player map"
            realPos.z = TerrainMeta.Size.z - realPos.z; //Top is 0, we need to invert Z axis

            Vector3 error = new Vector3(-90f, 0f, -90f);
            Vector3 correction = new Vector3(
                error.x * (realPos.x / (TerrainMeta.Size.x + error.x)),
                0,
                error.z * (realPos.z / TerrainMeta.Size.z) - error.z
                );

            Vector3 cellPos = (realPos - correction) / CELL_SIZE;


            int letter = (int)cellPos.x;
            string c = string.Empty;
            if (letter >= 26)
            {
                c += (char)((letter / 26 - 1) + 'A');
                letter %= 26;
            }
            c += (char)(letter + 'A');

            c += ((int)cellPos.z).ToString();
            return c;
        }

        #endregion
    }
}

// --- End of file: CupboardLimiter.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/custom-cards ---
// --- Original File Path: C/CustomCards/CustomCards.cs ---

ï»¿using System;
using Newtonsoft.Json;


namespace Oxide.Plugins
{
    [Info("Custom Cards", "Camoec", 1.1)]
    [Description("Allows to change the max uses of the keycards")]

    public class CustomCards : RustPlugin
    {
        private PluginConfig _config;
        private class PluginConfig
        {
            [JsonProperty(PropertyName = "Green KeyCard Max Uses")]
            public int GreenMaxUses = 4;
            [JsonProperty(PropertyName = "Blue KeyCard Max Uses")]
            public int BlueMaxUses = 4;
            [JsonProperty(PropertyName = "Red KeyCard Max Uses")]
            public int RedMaxUses = 4;
        }

        protected override void SaveConfig() => Config.WriteObject(_config, true);
        protected override void LoadDefaultConfig()
        {
            _config = new PluginConfig();
            SaveConfig();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<PluginConfig>();

                if (_config == null)
                    throw new Exception();

                SaveConfig(); // override posible obsolet / outdated config
            }
            catch (Exception)
            {
                PrintError("Loaded default config.");

                LoadDefaultConfig();
            }
        }

        private object OnCardSwipe(CardReader cardReader, Keycard card, BasePlayer player)
        {
            if (cardReader == null || card == null || player == null)
            {
                return null;
            }

            if (cardReader.accessLevel != card.accessLevel)
                return null;

            int maxUses = card.accessLevel == 1 ? _config.GreenMaxUses : card.accessLevel == 2 ? _config.BlueMaxUses : _config.RedMaxUses;

            
           
            Item cardItem = card.GetItem();
            float mHealth = cardItem.maxCondition / maxUses;

            cardReader.Invoke(cardReader.GrantCard, 0.5f);
            cardItem.LoseCondition(cardItem.condition - mHealth > 0.01 ? mHealth : cardItem.condition);
            return true;
        }
    }
}

// --- End of file: CustomCards.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/chat-clear ---
// --- Original File Path: C/ChatClear/ChatClear.cs ---

ï»¿using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;

namespace Oxide.Plugins
{
    [Info("Chat Clear", "Wulf", "2.0.0")]
    [Description("Clears the chat for player(s) when joining the server or on command")]
    class ChatClear : CovalencePlugin
    {
        #region Configuration

        private Configuration config;

        public class Configuration
        {
            [JsonProperty("Clear chat on connect")]
            public bool ClearOnConnect = true;

            [JsonProperty("Exclude admin from clearing")]
            public bool ExcludeAdmin = false;

            [JsonProperty("Number of lines to clear (ex. 300)")]
            public int NumberOfLines = 300;

            [JsonProperty("Show chat cleared message")]
            public bool ShowMessage = false;

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    throw new JsonException();
                }

                if (!config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch
            {
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(config, true);
        }

        #endregion Configuration

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CommandClearAll"] = "clearall",
                ["CommandClearSelf"] = "clear",
                ["ChatCleared"] = "Chat has been cleared, mmm fresh!",
                ["NotAllowed"] = "You are not allowed to use the '{0}' command"
            }, this);
        }

        #endregion Localization

        #region Initialization

        private const string permAll = "chatclear.all";
        private const string permSelf = "chatclear.self";

        private void Init()
        {
            AddLocalizedCommand(nameof(CommandClearAll));
            AddLocalizedCommand(nameof(CommandClearSelf));

            permission.RegisterPermission(permAll, this);
            permission.RegisterPermission(permSelf, this);
            MigratePermission("chatcleaner.all", permAll);
            MigratePermission("chatcleaner.self", permSelf);

            if (!config.ClearOnConnect)
            {
                Unsubscribe(nameof(OnUserConnected));
            }
        }

        #endregion Initialization

        #region Chat Clearing

        private void ClearChat(IPlayer player)
        {
            if (config.ExcludeAdmin && player.IsAdmin)
            {
                return;
            }

            player.Message(new string('\n', config.NumberOfLines));

            if (config.ShowMessage)
            {
                Message(player, "ChatCleared");
            }
        }

        private void CommandClearAll(IPlayer player, string command)
        {
            if (!player.HasPermission(permAll))
            {
                Message(player, "NotAllowed", command);
                return;
            }

            foreach (IPlayer target in players.Connected)
            {
                ClearChat(target);
            }
        }

        private void CommandClearSelf(IPlayer player, string command)
        {
            if (!player.HasPermission(permSelf) || player.IsServer)
            {
                Message(player, "NotAllowed", command);
                return;
            }

            ClearChat(player);
        }

        private void OnUserConnected(IPlayer player) => ClearChat(player);

        #endregion Chat Clearing

        #region Helpers

        private void AddLocalizedCommand(string command)
        {
            foreach (string language in lang.GetLanguages(this))
            {
                Dictionary<string, string> messages = lang.GetMessages(language, this);
                foreach (KeyValuePair<string, string> message in messages)
                {
                    if (message.Key.Equals(command))
                    {
                        if (!string.IsNullOrEmpty(message.Value))
                        {
                            AddCovalenceCommand(message.Value, command);
                        }
                    }
                }
            }
        }

        private string GetLang(string langKey, string playerId = null, params object[] args)
        {
            return string.Format(lang.GetMessage(langKey, this, playerId), args);
        }

        private void Message(IPlayer player, string langKey, params object[] args)
        {
            player.Reply(GetLang(langKey, player.Id, args));
        }

        private void MigratePermission(string oldPerm, string newPerm)
        {
            foreach (string groupName in permission.GetPermissionGroups(oldPerm))
            {
                permission.GrantGroupPermission(groupName, newPerm, null);
                permission.RevokeGroupPermission(groupName, oldPerm);
            }

            foreach (string playerId in permission.GetPermissionUsers(oldPerm))
            {
                permission.GrantUserPermission(Regex.Replace(playerId, "[^0-9]", ""), newPerm, null);
                permission.RevokeUserPermission(Regex.Replace(playerId, "[^0-9]", ""), oldPerm);
            }
        }

        #endregion Helpers
    }
}


// --- End of file: ChatClear.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/custom-ui ---
// --- Original File Path: C/CustomUI/CustomUI.cs ---

using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Custom UI", "birthdates", "1.1.3")]
    [Description("Create your custom user interface without code!")]
    public class CustomUI : RustPlugin
    {
        #region Variables

        private readonly Dictionary<string, string> StoredMedia = new Dictionary<string, string>();
        [PluginReference] private Plugin ImageLibrary;
        private const string PermissionOpenUI = "customui.openui";
        private const string PermissionCloseUI = "customui.closeui";

        #endregion

        #region Hooks

        private void Init()
        {
            LoadConfig();
            RegisterUICommands();

            permission.RegisterPermission(PermissionOpenUI, this);
            permission.RegisterPermission(PermissionCloseUI, this);
        }

        private void OnServerInitialized()
        {
            if (!LoadImages())
            {
                CacheUIs();
                return;
            }

            timer.In(Config.TimeToLoadUI, () =>
            {
                PrintWarning("Caching UIs...");
                CacheUIs();
            });
        }

        #endregion

        #region Commands

        [ConsoleCommand("CustomUI.OpenUI")]
        private void OpenUICommand(ConsoleSystem.Arg Arg)
        {
            var Player = Arg.Player();
            if (Player == null || !Player.IPlayer.HasPermission(PermissionOpenUI) ||
                (Arg.Args?.Length ?? 0) == 0) return;
            OpenUI(Player, Arg.Args[0]);
        }

        [ConsoleCommand("CustomUI.CloseUI")]
        private void CloseUICommand(ConsoleSystem.Arg Arg)
        {
            var Player = Arg.Player();
            if (Player|| !Player.IPlayer.HasPermission(PermissionCloseUI) ||
                Arg.Args?.Length == 0) return;
            CuiHelper.DestroyUi(Player, Arg.Args[0]);
        }

        #endregion

        #region Helpers

        #region Image Library

        /// <summary>
        ///     Load all of the UI images via ImageLibrary
        /// </summary>
        /// <returns>If ImageLibrary is installed</returns>
        private bool LoadImages()
        {
            if (ImageLibrary == null)
            {
                PrintWarning("Image Library isn't installed, if you're using images you might get an error!");
                return false;
            }

            PrintWarning("Loading Images...");
            foreach (var UI in Config.UIs.Values)
            {
                if (!IsHexColor(UI.Media)) AddImage(UI.Media);
                foreach (var Element in AllElements(UI).Where(Ui => !IsHexColor(Ui.Media))) AddImage(Element.Media);
            }

            return true;
        }

        /// <summary>
        ///     Store an image's PNG data
        /// </summary>
        /// <param name="Media">The image and key</param>
        private void AddImage(string Media)
        {
            if (ImageLibrary == null)
            {
                PrintError("Attemtping to load an image and Image Library is not installed!");
                return;
            }

            if (string.IsNullOrEmpty(Media)) return;
            ImageLibrary.Call("AddImage", Media, Media, 0);
        }

        /// <summary>
        ///     Get PNG data from Media using ImageLibrary
        /// </summary>
        /// <param name="Media">The URL (the key)</param>
        /// <returns></returns>
        private string GetImage(string Media)
        {
            if (ImageLibrary == null)
            {
                PrintError("Attemtping to get an image and Image Library is not installed!");
                return string.Empty;
            }

            string PNG;
            if (StoredMedia.TryGetValue(Media, out PNG)) return PNG;
            PNG = ImageLibrary.Call<string>("GetImage", Media);
            StoredMedia.Add(Media, PNG);
            return PNG;
        }

        #endregion

        #region UI

        /// <summary>
        ///     Cache all custom UIs instead of creating a new container each call
        /// </summary>
        private void CacheUIs()
        {
            foreach (var UIPair in Config.UIs.Where(UIPair => UIPair.Value.CachedElements == null))
                CacheUI(UIPair.Key, UIPair.Value);
            PrintWarning("UIs have been cached.");
        }

        /// <summary>
        ///     Cache an individual UI
        /// </summary>
        /// <param name="Name">UI Name</param>
        /// <param name="UI">UI Object</param>
        private void CacheUI(string Name, UI UI)
        {
            var H = GetImageFromMedia(UI.Media);
            UI.CachedElements = new CuiElementContainer
            {
                new CuiElement
                {
                    Name = Name,
                    Parent = UI.Parent,
                    Components =
                    {
                        H,
                        new CuiRectTransformComponent
                        {
                            AnchorMin = UI.Position.X + " " + UI.Position.Y,
                            AnchorMax = UI.Position.X + UI.Position.Width + " " + (UI.Position.Y +
                                                                                   UI.Position.Height)
                        }
                    }
                }
            };

            if (UI.Cursor)
                UI.CachedElements.Add(new CuiElement
                {
                    Parent = Name,
                    Components = {new CuiNeedsCursorComponent()}
                });

            foreach (var Element in AllElements(UI))
            {
                var ElementName = Element.Name;
                var AnchorMin = Element.Position.X + " " + Element.Position.Y;
                var AnchorMax = Element.Position.X + Element.Position.Width + " " + (Element.Position.Y +
                                                                                     Element.Position.Height);
                var Image = GetImageFromMedia(Element.Media);
                var Button = Element as Button;
                if (Button != null)
                {
                    UI.CachedElements.Add(new CuiElement
                    {
                        Parent = Element.Parent,
                        Name = ElementName + "Background",
                        Components =
                        {
                            Image,
                            new CuiRectTransformComponent
                            {
                                AnchorMax = AnchorMax,
                                AnchorMin = AnchorMin
                            }
                        }
                    });
                    UI.CachedElements.Add(new CuiButton
                        {
                            RectTransform =
                            {
                                AnchorMax = "1 1",
                                AnchorMin = "0 0"
                            },
                            Button =
                            {
                                Command = Button.Command
                            },
                            Text =
                            {
                                Text = Button.Text.Value,
                                FontSize = Button.Text.Size,
                                Align = Button.Text.Anchor,
                                Color = "1 1 1 1"
                            }
                        }, ElementName + "Background", ElementName);
                    continue;
                }

                var Text = Element as Text;
                if (Text == null)
                {
                    UI.CachedElements.Add(new CuiElement
                    {
                        Name = ElementName,
                        Parent = Element.Parent,
                        Components =
                        {
                            Image,
                            new CuiRectTransformComponent
                            {
                                AnchorMax = AnchorMax,
                                AnchorMin = AnchorMin
                            }
                        }
                    });
                    continue;
                }

                UI.CachedElements.Add(new CuiLabel
                {
                    RectTransform =
                    {
                        AnchorMax = AnchorMax,
                        AnchorMin = AnchorMin
                    },
                    Text =
                    {
                        Text = Text.Value,
                        FontSize = Text.Size,
                        Align = Text.Anchor,
                        Color = HexToRGB(Text.Color)
                    }
                }, Element.Parent, ElementName);
            }
        }

        /// <summary>
        ///     Get all UI elements (button, text, panel) in one list
        /// </summary>
        /// <param name="UI">Target UI</param>
        /// <returns></returns>
        private static IEnumerable<UIElement> AllElements(UI UI)
        {
            return UI.UIElements.Buttons
                .Union(UI.UIElements.Panels)
                .Union(UI.UIElements.Text);
        }

        /// <summary>
        ///     Convert Image (media) to CuiRawImageComponent (needed because Image can be color or image url)
        /// </summary>
        /// <param name="Image">Media (Image/Color)</param>
        /// <returns>CuiRawImageComponent that has either a color or png</returns>
        private ICuiComponent GetImageFromMedia(string Media)
        {
            if (IsHexColor(Media)) return new CuiImageComponent {Color = HexToRGB(Media)};
            return new CuiRawImageComponent {Png = GetImage(Media)};
        }

        /// <summary>
        ///     Convert HEX to RGB (0-1)
        /// </summary>
        /// <param name="hexColor">Hex Color</param>
        /// <returns>RGB Color (0-1)</returns>
        private static string HexToRGB(string hexColor)
        {
            if (hexColor.StartsWith("#")) hexColor = hexColor.TrimStart('#');

            var red = int.Parse(hexColor.Substring(0, 2), NumberStyles.AllowHexSpecifier);
            var green = int.Parse(hexColor.Substring(2, 2), NumberStyles.AllowHexSpecifier);
            var blue = int.Parse(hexColor.Substring(4, 2), NumberStyles.AllowHexSpecifier);
            return $"{(double) red / 255} {(double) green / 255} {(double) blue / 255} 1";
        }

        private static bool IsHexColor(string Media)
        {
            return !Media.Contains("//") && !Media.Contains(".");
        }

        /// <summary>
        ///     Open a custom UI for given player
        /// </summary>
        /// <param name="Target">Target Player</param>
        /// <param name="UIName">UI Name</param>
        /// <param name="UI">Used if you've already found UI (saves performance)</param>
        private void OpenUI(BasePlayer Target, string UIName, UI UI = null)
        {
            if (UI == null && !Config.UIs.TryGetValue(UIName, out UI)) return;
            if (UI.CachedElements == null)
            {
                Target.ChatMessage(lang.GetMessage("UINotReady", this, Target.UserIDString));
                return;
            }

            CuiHelper.DestroyUi(Target, UIName); //Ensures you will not open the UI twice (forcing you to re-log)
            CuiHelper.AddUi(Target, UI.CachedElements);
            //Hook for developers
            Interface.Oxide.CallHook("OnUIOpened", Target, UIName);
        }

        #endregion

        #region Other

        /// <summary>
        ///     Register Custom UI chat commands and their respected permissions
        /// </summary>
        private void RegisterUICommands()
        {
            foreach (var Pair in Config.UIs)
            {
                var UI = Pair.Value;
                if (string.IsNullOrEmpty(UI.ChatCommand)) return;

                var UIPermission = $"customui.{UI.Permission}";
                permission.RegisterPermission(UIPermission, this);

                cmd.AddChatCommand(UI.ChatCommand, this, (Player, Label, Args) =>
                {
                    if (!Player.IPlayer.HasPermission(UIPermission))
                    {
                        Player.ChatMessage(lang.GetMessage("NoPermission", this, Player.UserIDString));
                        return;
                    }

                    Player.ChatMessage(string.Format(lang.GetMessage("OpeningUI", this, Player.UserIDString),
                        Pair.Key));
                    OpenUI(Player, Pair.Key, UI);
                });
            }
        }

        #endregion

        #endregion

        #region Configuration & Language

        private new ConfigFile Config;

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"OpeningUI", "Opening the <color=#32a852>{0}</color> UI..."},
                {"NoPermission", "You don't have permission to open this UI!"},
                {"UINotReady", "The UI you're trying to use hasn't been constructed yet, try again later."}
            }, this);
        }

        public class ConfigFile
        {
            [JsonProperty("Max Time to Load UI (Turn up/down depending on how fast images download)")]
            public float TimeToLoadUI;

            public Dictionary<string, UI> UIs;

            public static ConfigFile DefaultConfig()
            {
                return new ConfigFile
                {
                    TimeToLoadUI = 15f,
                    UIs = new Dictionary<string, UI>
                    {
                        {
                            "TestUI", new UI
                            {
                                Permission = "testui",
                                Parent = "Hud",
                                ChatCommand = "test",
                                Cursor = false,
                                Media = "#000000",
                                Position = new Position
                                {
                                    X = 0.25f,
                                    Y = 0.25f,
                                    Width = 0.5f,
                                    Height = 0.5f
                                },
                                UIElements = new UIElements
                                {
                                    Buttons = new List<Button>
                                    {
                                        new Button
                                        {
                                            Name = "TestButton",
                                            Command = "CloseUI TestUI",
                                            Text = new Text
                                            {
                                                Color = "#ffffff",
                                                Value = "EXIT",
                                                Size = 15,
                                                Anchor = TextAnchor.MiddleCenter,
                                                Media = "#000000",
                                                Parent = "TestButton",
                                                Name = "TestButtonText"
                                            },
                                            Media = "#ffffff",
                                            Position = new Position
                                            {
                                                X = 0f,
                                                Y = 0f,
                                                Width = 0.125f,
                                                Height = 0.125f
                                            },
                                            Parent = "TestUI"
                                        }
                                    },
                                    Panels = new List<UIElement>
                                    {
                                        new UIElement
                                        {
                                            Name = "TestPanel",
                                            Position = new Position
                                            {
                                                X = 0.5f,
                                                Y = 0f,
                                                Width = 0.125f,
                                                Height = 0.125f
                                            },
                                            Media = "#787878",
                                            Parent = "TestUI"
                                        }
                                    },
                                    Text = new List<Text>
                                    {
                                        new Text
                                        {
                                            Name = "TestText",
                                            Position = new Position
                                            {
                                                X = 0f,
                                                Y = 0f,
                                                Width = 1f,
                                                Height = 1f
                                            },
                                            Value = "TEST",
                                            Parent = "TestPanel",
                                            Media = "#ffffff",
                                            Color = "#ffffff",
                                            Size = 15,
                                            Anchor = TextAnchor.MiddleCenter
                                        }
                                    }
                                }
                            }
                        }
                    }
                };
            }
        }

        #region UI Classes

        public class UI
        {
            [JsonIgnore] public CuiElementContainer CachedElements;

            [JsonProperty("Chat Command")] public string ChatCommand;

            [JsonProperty("Cursor Enabled?")] public bool Cursor;

            [JsonProperty("Background Media")] public string Media;

            public string Parent;
            public string Permission;

            public Position Position;

            [JsonProperty("UI Elements")] public UIElements UIElements;
        }

        public class UIElements
        {
            public List<Button> Buttons;
            public List<UIElement> Panels;
            public List<Text> Text;
        }

        /// <summary>
        ///     Base UI class
        /// </summary>
        public class UIElement
        {
            [JsonProperty("Media (URL/Hex Color)")]
            public string Media;

            public string Name;
            public string Parent;
            public Position Position;
        }

        public class Button : UIElement
        {
            public string Command;
            public Text Text;
        }

        public class Text : UIElement
        {
            [JsonProperty("Text Alignment")] public TextAnchor Anchor;

            [JsonProperty("Hex Color")] public string Color;

            [JsonProperty("Font Size")] public int Size;

            public string Value;
        }

        public class Position
        {
            [JsonProperty("Height (0-1)")] public float Height; //MaxY

            [JsonProperty("Width (0-1)")] public float Width; //MaxX

            [JsonProperty("X (0-1)")] public float X; //MinX

            [JsonProperty("Y (0-1)")] public float Y; //MinY
        }

        #endregion

        protected override void LoadConfig()
        {
            base.LoadConfig();
            Config = ((Plugin) this).Config.ReadObject<ConfigFile>();
            if (Config != null) return;
            LoadDefaultConfig();
        }

        protected override void LoadDefaultConfig()
        {
            Config = ConfigFile.DefaultConfig();
            PrintWarning("Default configuration has been loaded.");
        }

        protected override void SaveConfig()
        {
            ((Plugin) this).Config.WriteObject(Config);
        }

        #endregion
    }
}
//Generated with birthdates' Plugin Maker

// --- End of file: CustomUI.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/clan-info ---
// --- Original File Path: C/ClanInfo/ClanInfo.cs ---

// Requires: Clans

using Newtonsoft.Json.Linq;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Core;
using System.Linq;
using System.Collections.Generic;
 
namespace Oxide.Plugins
{
    [Info("Clan Info", "Bazz3l", "1.0.5")]
    [Description("List all clan members in a given clan")]
    class ClanInfo : CovalencePlugin
    {
        #region Plugins
        [PluginReference] Plugin Clans;
        #endregion

        #region Props
        private const string Perm = "claninfo.use";
        #endregion

        #region Oxide
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Message"] = "Clan: [#999999]{0}[/#] Members:\n{1}",
                ["NotFound"] = "No clan found",
                ["NoTag"] = "No clan tag specified"
            }, this);
        }

        private void Init() => permission.RegisterPermission(Perm, this);
        #endregion

        #region Clan
        public JObject GetClan(string tag) => Clans?.Call<JObject>("GetClan", new object[] { tag });
        public JArray GetClanMembers(string tag) => (JArray)GetClan(tag)?.SelectToken("members");
        #endregion

        #region Chat Commands
        [Command("cinfo")]
        private void cmdCinfo(IPlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.Id, Perm)) return;
            if (args.Length < 1)
            {
                player.Reply(Lang("NoTag", player.Id));
                return;
            }

            JArray clanMembers = GetClanMembers(args[0]);
            if (clanMembers == null)
            {
                player.Reply(Lang("NotFound", player.Id));
                return;
            }

            List<string> members = new List<string>();
            foreach(JToken member in clanMembers)
            {
                var mPlayer = covalence.Players?.FindPlayerById((string) member)?.Name;
                if (mPlayer != null)
                    members.Add(mPlayer);
            }

            player.Reply(Lang("Message", player.Id, args[0], string.Join("\n", members.ToArray())));
        }
        #endregion

        #region Helpers
        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);
        #endregion
    }
}

// --- End of file: ClanInfo.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/chinook-spawner ---
// --- Original File Path: C/ChinookSpawner/ChinookSpawner.cs ---

ï»¿using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Chinook Spawner", "ziptie", 1.1)]
    [Description("Spawn and despawn chinooks on command.")]
    public class ChinookSpawner : CovalencePlugin
    {
        // Definitions
        public Dictionary<ulong, bool> hasChinook = new Dictionary<ulong, bool>();
        private PluginConfig config;

        // Localization
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["AlreadyHasChinook"] = "You aleady have a chinook spawned!",
                ["SuccessfullySpawned"] = "You spawned a chinook",
                ["NoChinook"] = "You do not have a chinook",
                ["ChinookDestroyed"] = "Your chinook was destroyed!",
                ["CannotSpawn"] = "You cannot spawn a chinook here",
                ["CannotSpawnInBuildingBlock"] = "You cannot spawn a chinook in a building blocked zone",
                ["TooFar"] = "You cannot spawn a chinook that far away"
            }, this);
        }

        //Config
        private void Init()
        {
            config = Config.ReadObject<PluginConfig>();
        }

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(GetDefaultConfig(), true);
        }

        private PluginConfig GetDefaultConfig()
        {
            return new PluginConfig
            {
                SpawnFireOnCrash = true,
                SpawnGibsOnCrash = true,
                BlockSpawningInBuildingBlock = true,
                SpawnDistance = 10,
            };
        }

        // Commands
        [Command("chinook"), Permission("chinookspawner.spawn")]
        private void SpawnChinook(IPlayer player, string command, string[] args)
        {
            var playerBP = (player.Object as BasePlayer);
            if (playerBP != null)
            {
                if (hasChinook.ContainsKey(playerBP.userID))
                {
                    if (hasChinook[playerBP.userID] == false)
                    {
                        if (CreateChinook(playerBP) == true)
                        {
                            hasChinook[playerBP.userID] = true;
                            player.Reply(lang.GetMessage("SuccessfullySpawned", this, player.Id));
                        }
                    }
                    else
                    {
                        player.Reply(lang.GetMessage("AlreadyHasChinook", this, player.Id));
                    }
                }
                else
                {
                    hasChinook.Add(playerBP.userID, false);
                    SpawnChinook(player, command, args);
                }
            }
        }
        [Command("nochinook"), Permission("chinookspawner.despawn")]
        private void NoChinook(IPlayer player, string command, string[] args)
        {
            var playerBP = (player.Object as BasePlayer);
            if (playerBP != null)
            {
                if (hasChinook.ContainsKey(playerBP.userID))
                {
                    if (hasChinook[playerBP.userID] == true)
                    {
                        if (DespawnChinook(playerBP) == true)
                        {
                            hasChinook[playerBP.userID] = false;
                        }
                    }
                    else
                    {
                        player.Reply(lang.GetMessage("NoChinook", this, player.Id));
                    }
                }
                else
                {
                    hasChinook.Add(playerBP.userID, false);
                    NoChinook(player, command, args);
                }
            }
        }

        // Hooks
        void OnEntityKill(CH47Helicopter entity)
        {
                var ch47 = entity.GetComponent<ChinookIdentifier>();
                if (ch47 != null)
                {
                    players.FindPlayer(ch47.ownerID.ToString()).Reply(lang.GetMessage("ChinookDestroyed", this, ch47.ownerID.ToString()));
                    hasChinook[ch47.ownerID] = false;
                }
        }

        // Methods
        private bool CreateChinook(BasePlayer player)
        {
            Vector3 position;
            if (player != null)
            {
                RaycastHit hit;
                if (!Physics.Raycast(player.eyes.HeadRay(), out hit, Mathf.Infinity,
                    LayerMask.GetMask("Construction", "Default", "Deployed", "Resource", "Terrain", "Water", "World")))
                {
                    player.ChatMessage(lang.GetMessage("CannotSpawn", this, player.UserIDString));
                    return false;
                }

                if (hit.distance > config.SpawnDistance)
                {
                    player.ChatMessage(lang.GetMessage("TooFar", this, player.UserIDString));
                    return false;
                }
                if (config.BlockSpawningInBuildingBlock == true)
                {
                    if (player.IsBuildingBlocked() == true)
                    {
                        player.ChatMessage(lang.GetMessage("CannotSpawnInBuildingBlock", this, player.UserIDString));
                        return false;
                    }
                }
                position = hit.point + Vector3.up * 2f;
                CH47Helicopter ch = GameManager.server.CreateEntity("assets/prefabs/npc/ch47/ch47.entity.prefab", position, player.eyes.transform.localRotation, true) as CH47Helicopter;
                if (ch != null)
                {
                    if (!config.SpawnGibsOnCrash == true)
                    {
                        ch.serverGibs.guid = null;
                    }

                    if (!config.SpawnFireOnCrash == true)
                    {
                        ch.fireBall.guid = null;
                    }
                    ch.Spawn();
                    ch.gameObject.AddComponent<ChinookIdentifier>().ownerID = player.userID;
                }
                return true;
            }
            else
            {
                Debug.LogError("CreateChinook Failed: BasePlayer is null");
                return false;
            }
        }
        private bool? DespawnChinook(BasePlayer playerBP)
        {
            if (playerBP != null)
            {
                foreach (var entity in UnityEngine.Object.FindObjectsOfType<CH47Helicopter>())
                {
                    if (entity == null) { return false; }
                    ChinookIdentifier chinookIdentifier = entity.GetComponent<ChinookIdentifier>();
                    if (chinookIdentifier != null)
                    {
                        if (chinookIdentifier.ownerID == playerBP.userID)
                        {
                            entity.AdminKill();
                            return true;
                        }
                    }
                }
            }
            return null;
        }
    }

    // ID Class
    public class ChinookIdentifier : MonoBehaviour
    {
        public ulong ownerID = 0;
    }

    // Config
    public class PluginConfig
    {
        public bool SpawnFireOnCrash = true;
        public bool SpawnGibsOnCrash = true;
        public float SpawnDistance = 10;
        public bool BlockSpawningInBuildingBlock = true;
    }
}

// --- End of file: ChinookSpawner.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/car-turrets ---
// --- Original File Path: C/CarTurrets/CarTurrets.cs ---

ï»¿using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Rust.Modular;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Car Turrets", "WhiteThunder", "1.6.3")]
    [Description("Allows players to deploy auto turrets onto modular cars.")]
    internal class CarTurrets : CovalencePlugin
    {
        #region Fields

        [PluginReference]
        private readonly Plugin VehicleDeployedLocks;

        private Configuration _config;

        private const string PermissionDeployCommand = "carturrets.deploy.command";
        private const string PermissionDeployInventory = "carturrets.deploy.inventory";
        private const string PermissionFree = "carturrets.free";
        private const string PermissionControl = "carturrets.control";
        private const string PermissionRemoveAll = "carturrets.removeall";

        private const string PermissionLimit2 = "carturrets.limit.2";
        private const string PermissionLimit3 = "carturrets.limit.3";
        private const string PermissionLimit4 = "carturrets.limit.4";

        private const string PermissionSpawnWithCar = "carturrets.spawnwithcar";

        private const string PermissionAllModules = "carturrets.allmodules";
        private const string PermissionModuleFormat = "carturrets.{0}";

        private const string PrefabEntityAutoTurret = "assets/prefabs/npc/autoturret/autoturret_deployed.prefab";
        private const string PrefabEntityElectricSwitch = "assets/prefabs/deployable/playerioents/simpleswitch/switch.prefab";
        private const string PrefabEffectDeployAutoTurret = "assets/prefabs/npc/autoturret/effects/autoturret-deploy.prefab";
        private const string PrefabEffectCodeLockDenied = "assets/prefabs/locks/keypad/effects/lock.code.denied.prefab";

        private const int ItemIdAutoTurret = -2139580305;

        private static readonly Vector3 TurretSwitchPosition = new Vector3(0, 0.36f, -0.32f);
        private static readonly Quaternion TurretBackwardRotation = Quaternion.Euler(0, 180, 0);
        private static readonly Quaternion TurretSwitchRotation = Quaternion.Euler(0, 180, 0);

        private readonly object False = false;

        private DynamicHookSubscriber<NetworkableId> _carTurretTracker;
        private ProtectionProperties ImmortalProtection;

        #endregion

        #region Hooks

        private void Init()
        {
            permission.RegisterPermission(PermissionDeployCommand, this);
            permission.RegisterPermission(PermissionDeployInventory, this);
            permission.RegisterPermission(PermissionFree, this);
            permission.RegisterPermission(PermissionControl, this);
            permission.RegisterPermission(PermissionRemoveAll, this);

            permission.RegisterPermission(PermissionLimit2, this);
            permission.RegisterPermission(PermissionLimit3, this);
            permission.RegisterPermission(PermissionLimit4, this);

            permission.RegisterPermission(PermissionSpawnWithCar, this);

            permission.RegisterPermission(PermissionAllModules, this);
            foreach (var moduleItemShortName in _config.ModulePositions.Keys)
            {
                permission.RegisterPermission(GetAutoTurretPermission(moduleItemShortName), this);
            }

            Unsubscribe(nameof(OnEntitySpawned));

            var dynamicHookNames = new List<string>()
            {
                nameof(OnItemDropped),
                nameof(OnEntityKill),
                nameof(OnSwitchToggle),
                nameof(OnSwitchToggled),
                nameof(OnTurretTarget),
            };

            if (_config.EnableTurretPickup)
            {
                Unsubscribe(nameof(CanPickupEntity));
                Unsubscribe(nameof(canRemove));
            }
            else
            {
                dynamicHookNames.Add(nameof(CanPickupEntity));
                dynamicHookNames.Add(nameof(canRemove));
            }

            if (!_config.OnlyPowerTurretsWhileEngineIsOn)
            {
                Unsubscribe(nameof(OnEngineStartFinished));
                Unsubscribe(nameof(OnEngineStopped));
                Unsubscribe(nameof(OnTurretStartup));
            }
            else
            {
                dynamicHookNames.Add(nameof(OnEngineStartFinished));
                dynamicHookNames.Add(nameof(OnEngineStopped));
                dynamicHookNames.Add(nameof(OnTurretStartup));
            }

            if (!_config.RequirePermissionToControl)
            {
                Unsubscribe(nameof(OnBookmarkControlStarted));
            }
            else
            {
                dynamicHookNames.Add(nameof(OnBookmarkControlStarted));
            }

            _carTurretTracker = new DynamicHookSubscriber<NetworkableId>(this, dynamicHookNames.ToArray());
            _carTurretTracker.UnsubscribeAll();
        }

        private void Unload()
        {
            UnityEngine.Object.Destroy(ImmortalProtection);
        }

        private void OnServerInitialized()
        {
            ImmortalProtection = ScriptableObject.CreateInstance<ProtectionProperties>();
            ImmortalProtection.name = "CarTurretsSwitchProtection";
            ImmortalProtection.Add(1);

            foreach (var entity in BaseNetworkable.serverEntities)
            {
                var car = entity as ModularCar;
                if (car == null)
                    continue;

                foreach (var module in car.AttachedModuleEntities)
                {
                    var turret = GetModuleAutoTurret(module);
                    if (turret == null)
                        continue;

                    RefreshCarTurret(turret);
                }

                if (_config.OnlyPowerTurretsWhileEngineIsOn)
                {
                    if (car.IsOn())
                    {
                        OnEngineStartFinished(car);
                    }
                    else
                    {
                        OnEngineStopped(car);
                    }
                }
            }

            if (_config.SpawnWithCarConfig.Enabled)
            {
                Subscribe(nameof(OnEntitySpawned));
            }
        }

        private void OnEntitySpawned(ModularCar car)
        {
            if (!ShouldSpawnTurretsWithCar(car))
                return;

            // Intentionally using both NextTick and Invoke.
            // Using NextTick to delay until the items have been added to the module inventory.
            // Using Invoke since that's what the game uses to delay spawning module entities.
            NextTick(() =>
            {
                if (car == null)
                    return;

                car.Invoke(() =>
                {
                    var ownerIdString = car.OwnerID != 0 ? car.OwnerID.ToString() : string.Empty;
                    var ownerPlayer = FindEntityOwner(car);

                    var allowedTurretsRemaining = GetCarAutoTurretLimit(car);
                    for (var i = 0; i < car.AttachedModuleEntities.Count && allowedTurretsRemaining > 0; i++)
                    {
                        var vehicleModule = car.AttachedModuleEntities[i];

                        Vector3 position;
                        if (!TryGetAutoTurretPositionForModule(vehicleModule, out position) ||
                            GetModuleAutoTurret(vehicleModule) != null ||
                            ownerIdString != string.Empty && !HasPermissionToVehicleModule(ownerIdString, vehicleModule) ||
                            UnityEngine.Random.Range(0, 100) >= GetAutoTurretChanceForModule(vehicleModule) ||
                            DeployWasBlocked(vehicleModule, ownerPlayer, automatedDeployment: true))
                            continue;

                        if (ownerPlayer == null)
                            DeployAutoTurret(car, vehicleModule, position);
                        else
                            DeployAutoTurretForPlayer(car, vehicleModule, position, ownerPlayer);

                        allowedTurretsRemaining--;
                    }
                }, 0);
            });
        }

        private object CanMoveItem(Item item, PlayerInventory playerInventory, ItemContainerId targetContainerId, int targetSlot, int amount)
        {
            if (item == null || playerInventory == null)
                return null;

            var basePlayer = playerInventory.baseEntity;
            if (basePlayer == null)
                return null;

            if (item.parent == null || item.parent.uid == targetContainerId)
                return null;

            if (playerInventory.loot.containers.Contains(item.parent))
            {
                // Player is moving an item from the loot panel.
                var fromCar = item.parent.entityOwner as ModularCar;
                if (fromCar == null)
                    return null;

                return HandleRemoveTurret(basePlayer, item, fromCar);
            }

            // Player is moving an item to the loot panel (module inventory is at position 1).
            var targetContainer = targetContainerId.Value != 0
                ? playerInventory.loot.FindContainer(targetContainerId)
                : playerInventory.loot.containers.ElementAtOrDefault(1);

            var toCar = targetContainer?.entityOwner as ModularCar;
            if ((object)toCar == null)
                return null;

            return HandleAddTurret(basePlayer, item, toCar, targetContainer, targetSlot);
        }

        private object HandleAddTurret(BasePlayer basePlayer, Item item, ModularCar car, ItemContainer targetContainer, int targetSlot)
        {
            var player = basePlayer.IPlayer;

            var itemid = item.info.itemid;
            if (itemid != ItemIdAutoTurret)
                return null;

            // In case a future update or a plugin adds another storage container to the car.
            if (car.Inventory.ModuleContainer != targetContainer)
                return null;

            if (!player.HasPermission(PermissionDeployInventory))
            {
                ChatMessage(basePlayer, Lang.GenericErrorNoPermission);
                return null;
            }

            if (!VerifyCarHasAutoTurretCapacity(player, car, replyInChat: true))
                return null;

            if (targetSlot == -1)
            {
                targetSlot = FindFirstSuitableSocketIndex(car, basePlayer);
            }

            if (targetSlot == -1)
            {
                ChatMessage(basePlayer, Lang.DeployErrorNoSuitableModule);
                return null;
            }

            var moduleItem = targetContainer.GetSlot(targetSlot);
            if (moduleItem == null)
                return null;

            var vehicleModule = car.GetModuleForItem(moduleItem);
            if (vehicleModule == null)
                return null;

            if (!HasPermissionToVehicleModule(player.Id, vehicleModule))
            {
                ChatMessage(basePlayer, Lang.DeployErrorNoPermissionToModule);
                return null;
            }

            if (GetModuleAutoTurret(vehicleModule) != null)
            {
                ChatMessage(basePlayer, Lang.DeployErrorModuleAlreadyHasTurret);
                return null;
            }

            Vector3 position;
            if (!TryGetAutoTurretPositionForModule(vehicleModule, out position)
                || DeployWasBlocked(vehicleModule, basePlayer))
                return null;

            if (DeployAutoTurretForPlayer(car, vehicleModule, position, basePlayer, GetItemConditionFraction(item)) == null)
                return null;

            if (!player.HasPermission(PermissionFree))
            {
                UseItem(basePlayer, item);
            }

            return False;
        }

        private object HandleRemoveTurret(BasePlayer basePlayer, Item moduleItem, ModularCar car, ItemContainer targetContainer = null)
        {
            if (car.Inventory.ModuleContainer != moduleItem.parent)
                return null;

            var vehicleModule = car.GetModuleForItem(moduleItem);
            if (vehicleModule == null)
                return null;

            var autoTurret = GetModuleAutoTurret(vehicleModule);
            if (autoTurret == null)
                return null;

            if (_config.EnableTurretPickup && autoTurret.pickup.enabled)
            {
                if (autoTurret.pickup.requireEmptyInv && !autoTurret.inventory.IsEmpty() && !autoTurret.inventory.IsLocked())
                {
                    ChatMessage(basePlayer, Lang.RemoveErrorTurretHasItems);
                    return False;
                }

                var turretItem = ItemManager.CreateByItemID(ItemIdAutoTurret);
                if (turretItem == null)
                    return null;

                if (turretItem.info.condition.enabled)
                {
                    turretItem.condition = autoTurret.healthFraction * 100;
                }

                if (targetContainer == null)
                {
                    if (!basePlayer.inventory.GiveItem(turretItem))
                    {
                        turretItem.Remove();
                        return False;
                    }
                }
                else if (!turretItem.MoveToContainer(targetContainer))
                {
                    turretItem.Remove();
                    return False;
                }

                basePlayer.Command("note.inv", ItemIdAutoTurret, 1);
            }

            autoTurret.Kill();
            return null;
        }

        private void OnItemDropped(Item item, BaseEntity itemEntity)
        {
            if (item?.parent == null)
                return;

            var car = item.parent.entityOwner as ModularCar;
            if (car == null)
                return;

            if (item.info.GetComponent<ItemModVehicleModule>() == null)
                return;

            var vehicleModule = car.GetModuleForItem(item);
            if (vehicleModule == null)
                return;

            var autoTurret = GetModuleAutoTurret(vehicleModule);
            if (autoTurret == null)
                return;

            if (_config.EnableTurretPickup && autoTurret.pickup.enabled)
            {
                var turretItem = CreateItemFromAutoTurret(autoTurret);
                if (turretItem == null)
                    return;

                var rigidBody = itemEntity.GetComponent<Rigidbody>();
                turretItem.Drop(itemEntity.transform.position, rigidBody?.velocity ?? Vector3.zero, itemEntity.transform.rotation);
            }
        }

        // Automatically move a deployed turret when a module moves.
        // This is not done in the CanMoveItem hook since we don't know if it's being moved yet.
        private void OnEntityKill(BaseVehicleModule vehicleModule)
        {
            var moduleItem = vehicleModule.AssociatedItemInstance;
            if (moduleItem == null)
                return;

            var car = vehicleModule.Vehicle as ModularCar;
            if (car == null)
                return;

            var autoTurret = GetModuleAutoTurret(vehicleModule);
            if (autoTurret == null)
                return;

            autoTurret.SetParent(null);

            var moduleItem2 = moduleItem;
            var car2 = car;
            var autoTurret2 = autoTurret;

            NextTick(() =>
            {
                if (car2 == null)
                {
                    autoTurret2.Kill();
                }
                else
                {
                    var newModule = car2.GetModuleForItem(moduleItem2);
                    if (newModule == null)
                    {
                        autoTurret2.Kill();
                    }
                    else
                    {
                        autoTurret2.SetParent(newModule);
                    }
                }
            });
        }

        private void OnEntityKill(AutoTurret turret)
        {
            _carTurretTracker.Remove(turret.net.ID);
        }

        private object OnSwitchToggle(ElectricSwitch electricSwitch, BasePlayer player)
        {
            var turret = GetParentTurret(electricSwitch);
            if (turret == null)
                return null;

            var vehicleModule = GetParentVehicleModule(turret);
            if (vehicleModule == null)
                return null;

            var car = vehicleModule.Vehicle as ModularCar;
            if (car == null)
                return null;

            if (!player.CanBuild())
            {
                // Disallow switching the turret on and off while building blocked.
                Effect.server.Run(PrefabEffectCodeLockDenied, electricSwitch, 0, Vector3.zero, Vector3.forward);
                return False;
            }

            return null;
        }

        private void OnSwitchToggled(ElectricSwitch electricSwitch, BasePlayer player)
        {
            var turret = GetParentTurret(electricSwitch);
            if (turret == null)
                return;

            var vehicleModule = GetParentVehicleModule(turret);
            if (vehicleModule == null)
                return;

            var car = vehicleModule.Vehicle as ModularCar;
            if (car == null)
                return;

            if (electricSwitch.IsOn())
            {
                if (_config.OnlyPowerTurretsWhileEngineIsOn && !car.IsOn())
                {
                    ChatMessage(player, Lang.InfoPowerRequiresEngine);
                }
                else
                {
                    turret.InitiateStartup();
                }
            }
            else
            {
                turret.InitiateShutdown();
            }
        }

        private object OnTurretTarget(AutoTurret turret, BaseCombatEntity target)
        {
            if (turret == null || target == null || GetParentVehicleModule(turret) == null)
                return null;

            if (!_config.TargetAnimals && target is BaseAnimalNPC)
                return False;

            var basePlayer = target as BasePlayer;
            if (basePlayer != null)
            {
                if (!_config.TargetNPCs && basePlayer.IsNpc)
                    return False;

                if (!_config.TargetPlayers && basePlayer.userID.IsSteamId())
                    return False;

                // Don't target human or NPC players in safe zones, unless they are hostile.
                if (basePlayer.InSafeZone() && (basePlayer.IsNpc || !basePlayer.IsHostile()))
                    return False;

                return null;
            }

            return null;
        }

        private void OnBookmarkControlStarted(ComputerStation station, BasePlayer player, string bookmarkName, AutoTurret turret)
        {
            var vehicleModule = GetParentVehicleModule(turret);
            if (vehicleModule == null)
                return;

            if (!RCUtils.HasController(turret, player))
                return;

            if (!HasPermissionToControl(player))
            {
                RCUtils.RemoveController(turret);
                RCUtils.AddFakeViewer(turret);
                RCUtils.AddViewer(turret, player);
                RCUtils.RemoveController(turret);
                station.SetFlag(ComputerStation.Flag_HasFullControl, false);
            }
        }

        // This is only subscribed while config option EnableTurretPickup is false.
        private object CanPickupEntity(BasePlayer player, AutoTurret turret)
        {
            if (GetParentVehicleModule(turret) != null)
                return False;

            return null;
        }

        // This hook is exposed by plugin: Remover Tool (RemoverTool).
        // Only subscribed while config option EnableTurretPickup is false.
        private object canRemove(BasePlayer player, AutoTurret turret)
        {
            if (GetParentVehicleModule(turret) != null)
                return False;

            return null;
        }

        // This is only subscribed while OnlyPowerTurretsWhileEngineIsOn is true.
        private void OnEngineStartFinished(ModularCar car)
        {
            foreach (var module in car.AttachedModuleEntities)
            {
                var turret = GetModuleAutoTurret(module);
                if (turret == null || turret.booting || turret.IsOn())
                    continue;

                var electricSwitch = GetTurretSwitch(turret);
                if (electricSwitch == null || !electricSwitch.IsOn())
                    continue;

                turret.InitiateStartup();
            }
        }

        // This is only subscribed while OnlyPowerTurretsWhileEngineIsOn is true.
        private void OnEngineStopped(ModularCar car)
        {
            foreach (var module in car.AttachedModuleEntities)
            {
                var turret = GetModuleAutoTurret(module);
                if (turret == null || !turret.booting && !turret.IsOn())
                    continue;

                var electricSwitch = GetTurretSwitch(turret);
                if (electricSwitch == null)
                    continue;

                turret.InitiateShutdown();
            }
        }

        // This is only subscribed while OnlyPowerTurretsWhileEngineIsOn is true.
        private object OnTurretStartup(AutoTurret turret)
        {
            var module = GetParentVehicleModule(turret);
            if (module == null)
                return null;

            var car = module.Vehicle as ModularCar;
            if (car == null)
                return null;

            if (!car.IsOn())
                return False;

            return null;
        }

        #endregion

        #region API

        [HookMethod(nameof(API_DeployAutoTurret))]
        public AutoTurret API_DeployAutoTurret(BaseVehicleModule vehicleModule, BasePlayer basePlayer)
        {
            var car = vehicleModule.Vehicle as ModularCar;
            if (car == null)
                return null;

            Vector3 position;
            if (!TryGetAutoTurretPositionForModule(vehicleModule, out position) ||
                GetModuleAutoTurret(vehicleModule) != null ||
                DeployWasBlocked(vehicleModule, basePlayer))
                return null;

            return basePlayer == null
                ? DeployAutoTurret(car, vehicleModule, position)
                : DeployAutoTurretForPlayer(car, vehicleModule, position, basePlayer);
        }

        #endregion

        #region Commands

        [Command("carturret")]
        private void CommandDeploy(IPlayer player, string cmd, string[] args)
        {
            if (player.IsServer || !VerifyPermissionAny(player, PermissionDeployCommand))
                return;

            var basePlayer = player.Object as BasePlayer;
            ModularCar car;
            BaseVehicleModule vehicleModule;

            if (!VerifyCanBuild(player) ||
                !VerifyVehicleModuleFound(player, out car, out vehicleModule) ||
                !CanAccessVehicle(car, basePlayer) ||
                !VerifyCarHasAutoTurretCapacity(player, car) ||
                !VerifyPermissionToModule(player, vehicleModule))
                return;

            if (GetModuleAutoTurret(vehicleModule) != null)
            {
                ReplyToPlayer(player, Lang.DeployErrorModuleAlreadyHasTurret);
                return;
            }

            Vector3 position;
            if (!TryGetAutoTurretPositionForModule(vehicleModule, out position))
            {
                ReplyToPlayer(player, Lang.DeployErrorUnsupportedModule);
                return;
            }

            Item autoTurretItem = null;
            var conditionFraction = 1.0f;

            var isFree = player.HasPermission(PermissionFree);
            if (!isFree)
            {
                autoTurretItem = FindPlayerAutoTurretItem(basePlayer);
                if (autoTurretItem == null)
                {
                    ReplyToPlayer(player, Lang.DeployErrorNoTurret);
                    return;
                }

                conditionFraction = GetItemConditionFraction(autoTurretItem);
            }

            if (DeployWasBlocked(vehicleModule, basePlayer))
                return;

            if (DeployAutoTurretForPlayer(car, vehicleModule, position, basePlayer, conditionFraction) != null && !isFree && autoTurretItem != null)
            {
                UseItem(basePlayer, autoTurretItem);
            }
        }

        [Command("carturrets.removeall")]
        private void CommandRemoveAllCarTurrets(IPlayer player, string cmd, string[] args)
        {
            if (!player.IsServer && !VerifyPermissionAny(player, PermissionRemoveAll))
                return;

            var turretsRemoved = 0;
            foreach (var turret in BaseNetworkable.serverEntities.OfType<AutoTurret>().ToArray())
            {
                if (turret.GetParentEntity() is BaseVehicleModule)
                {
                    turret.Kill();
                    turretsRemoved++;
                }
            }

            ReplyToPlayer(player, Lang.RemoveAllSuccess, turretsRemoved);
        }

        #endregion

        #region Helper Methods - Command Checks

        private bool VerifyPermissionAny(IPlayer player, params string[] permissionNames)
        {
            foreach (var perm in permissionNames)
            {
                if (player.HasPermission(perm))
                    return true;
            }

            ReplyToPlayer(player, Lang.GenericErrorNoPermission);
            return false;
        }

        private bool VerifyCanBuild(IPlayer player)
        {
            if ((player.Object as BasePlayer).CanBuild())
                return true;

            ReplyToPlayer(player, Lang.GenericErrorBuildingBlocked);
            return false;
        }

        private bool VerifyVehicleModuleFound(IPlayer player, out ModularCar car, out BaseVehicleModule vehicleModule)
        {
            var basePlayer = player.Object as BasePlayer;
            var entity = GetLookEntity(basePlayer);

            vehicleModule = entity as BaseVehicleModule;
            if (vehicleModule != null)
            {
                car = vehicleModule.Vehicle as ModularCar;
                if (car != null)
                    return true;

                ReplyToPlayer(player, Lang.DeployErrorNoCarFound);
                return false;
            }

            car = entity as ModularCar;
            if (car == null)
            {
                var lift = entity as ModularCarGarage;
                car = lift?.carOccupant;
                if (car == null)
                {
                    ReplyToPlayer(player, Lang.DeployErrorNoCarFound);
                    return false;
                }
            }

            var closestModule = FindClosestModuleToAim(car, basePlayer);
            if (closestModule != null)
            {
                vehicleModule = closestModule;
                return true;
            }

            ReplyToPlayer(player, Lang.DeployErrorNoModules);
            return false;
        }

        private bool VerifyCarHasAutoTurretCapacity(IPlayer player, ModularCar car, bool replyInChat = false)
        {
            var limit = GetCarAutoTurretLimit(car);
            if (GetCarTurretCount(car) < limit)
                return true;

            if (replyInChat)
            {
                ChatMessage(player.Object as BasePlayer, Lang.DeployErrorTurretLimit, limit);
            }
            else
            {
                ReplyToPlayer(player, Lang.DeployErrorTurretLimit, limit);
            }

            return false;
        }

        private bool VerifyPermissionToModule(IPlayer player, BaseVehicleModule vehicleModule)
        {
            if (HasPermissionToVehicleModule(player.Id, vehicleModule))
                return true;

            ReplyToPlayer(player, Lang.DeployErrorNoPermissionToModule);
            return false;
        }

        #endregion

        #region Helpers

        private static class RCUtils
        {
            public static bool HasController(IRemoteControllable controllable, BasePlayer player)
            {
                return controllable.ControllingViewerId?.SteamId == player.userID;
            }

            public static void RemoveController(IRemoteControllable controllable)
            {
                var controllerId = controllable.ControllingViewerId;
                if (controllerId.HasValue)
                {
                    controllable.StopControl(controllerId.Value);
                }
            }

            public static bool AddViewer(IRemoteControllable controllable, BasePlayer player)
            {
                return controllable.InitializeControl(new CameraViewerId(player.userID, 0));
            }

            public static bool AddFakeViewer(IRemoteControllable controllable)
            {
                return controllable.InitializeControl(new CameraViewerId());
            }
        }

        private static bool DeployWasBlocked(BaseVehicleModule vehicleModule, BasePlayer basePlayer, bool automatedDeployment = false)
        {
            var hookResult = Interface.CallHook("OnCarAutoTurretDeploy", vehicleModule, basePlayer, automatedDeployment);
            return hookResult is bool && (bool)hookResult == false;
        }

        private static BaseVehicleModule FindClosestModuleToAim(ModularCar car, BasePlayer basePlayer)
        {
            var headRay = basePlayer.eyes.HeadRay();

            BaseVehicleModule closestModule = null;
            float closestDistance = 0;

            for (var socketIndex = 0; socketIndex < car.TotalSockets; socketIndex++)
            {
                BaseVehicleModule currentModule;
                if (car.TryGetModuleAt(socketIndex, out currentModule) && currentModule.FirstSocketIndex == socketIndex)
                {
                    var currentDistance = Vector3.Cross(headRay.direction, currentModule.CenterPoint() - headRay.origin).magnitude;
                    if (ReferenceEquals(closestModule, null))
                    {
                        closestModule = currentModule;
                        closestDistance = currentDistance;
                    }
                    else if (currentDistance < closestDistance)
                    {
                        closestModule = currentModule;
                        closestDistance = currentDistance;
                    }
                }
            }

            return closestModule;
        }

        private static void UseItem(BasePlayer basePlayer, Item item, int amountToConsume = 1)
        {
            item.amount -= amountToConsume;
            if (item.amount <= 0)
            {
                item.RemoveFromContainer();
                item.Remove();
            }
            else
            {
                item.MarkDirty();
            }

            basePlayer.Command("note.inv", item.info.itemid, -amountToConsume);
        }

        private static float GetItemConditionFraction(Item item)
        {
            return item.hasCondition ? item.condition / item.info.condition.max : 1.0f;
        }

        private static Item FindPlayerAutoTurretItem(BasePlayer basePlayer)
        {
            return basePlayer.inventory.FindItemByItemID(ItemIdAutoTurret);
        }

        private static Item CreateItemFromAutoTurret(AutoTurret autoTurret)
        {
            var turretItem = ItemManager.CreateByItemID(ItemIdAutoTurret);
            if (turretItem == null)
                return null;

            if (turretItem.info.condition.enabled)
            {
                turretItem.condition = autoTurret.healthFraction * 100;
            }

            return turretItem;
        }

        private static string GetAutoTurretPermissionForModule(BaseVehicleModule vehicleModule)
        {
            return GetAutoTurretPermission(vehicleModule.AssociatedItemDef.shortname);
        }

        private static string GetAutoTurretPermission(string moduleItemShortName)
        {
            return string.Format(PermissionModuleFormat, moduleItemShortName);
        }

        private static int GetCarTurretCount(ModularCar car)
        {
            var numTurrets = 0;
            foreach (var module in car.AttachedModuleEntities)
            {
                var turret = GetModuleAutoTurret(module);
                if (turret != null)
                {
                    numTurrets++;
                }
            }

            return numTurrets;
        }

        private static T GetChildOfType<T>(BaseEntity entity) where T : BaseEntity
        {
            foreach (var child in entity.children)
            {
                var childOfType = child as T;
                if (childOfType != null)
                    return childOfType;
            }

            return null;
        }

        private static AutoTurret GetModuleAutoTurret(BaseVehicleModule vehicleModule)
        {
            return GetChildOfType<AutoTurret>(vehicleModule);
        }

        private static ElectricSwitch GetTurretSwitch(AutoTurret turret)
        {
            return GetChildOfType<ElectricSwitch>(turret);
        }

        private static bool IsNaturalCarSpawn(ModularCar car)
        {
            var spawnable = car.GetComponent<Spawnable>();
            return spawnable != null && spawnable.Population != null;
        }

        private static BaseVehicleModule GetParentVehicleModule(BaseEntity entity)
        {
            return entity.GetParentEntity() as BaseVehicleModule;
        }

        private static AutoTurret GetParentTurret(BaseEntity entity)
        {
            return entity.GetParentEntity() as AutoTurret;
        }

        private static void RunOnEntityBuilt(Item turretItem, AutoTurret autoTurret)
        {
            Interface.CallHook("OnEntityBuilt", turretItem.GetHeldEntity(), autoTurret.gameObject);
        }

        private static void HideInputsAndOutputs(IOEntity ioEntity)
        {
            // Hide the inputs and outputs on the client.
            foreach (var input in ioEntity.inputs)
            {
                input.type = IOEntity.IOType.Generic;
            }

            foreach (var output in ioEntity.outputs)
            {
                output.type = IOEntity.IOType.Generic;
            }
        }

        private static Quaternion GetIdealTurretRotation(ModularCar car, BaseVehicleModule vehicleModule)
        {
            var lastSocketIndex = vehicleModule.FirstSocketIndex + vehicleModule.GetNumSocketsTaken() - 1;

            var faceForward = car.TotalSockets == 2
                ? vehicleModule.FirstSocketIndex == 0
                : car.TotalSockets == 3
                ? lastSocketIndex <= 1
                : vehicleModule.FirstSocketIndex <= 1;

            return faceForward ? Quaternion.identity : TurretBackwardRotation;
        }

        private static void RemoveColliders<T>(BaseEntity entity) where T : Collider
        {
            foreach (var collider in entity.GetComponentsInChildren<T>())
            {
                UnityEngine.Object.DestroyImmediate(collider);
            }
        }

        private static void RemoveGroundWatch(BaseEntity entity)
        {
            UnityEngine.Object.DestroyImmediate(entity.GetComponent<DestroyOnGroundMissing>());
            UnityEngine.Object.DestroyImmediate(entity.GetComponent<GroundWatch>());
        }

        private static BaseEntity GetLookEntity(BasePlayer basePlayer, float maxDistance = 3)
        {
            RaycastHit hit;
            return Physics.Raycast(basePlayer.eyes.HeadRay(), out hit, maxDistance, Physics.DefaultRaycastLayers, QueryTriggerInteraction.Ignore)
                ? hit.GetEntity()
                : null;
        }

        private static BasePlayer FindEntityOwner(BaseEntity entity)
        {
            return entity.OwnerID != 0 ? BasePlayer.FindByID(entity.OwnerID) : null;
        }

        private bool HasPermissionToControl(BasePlayer player)
        {
            if (!_config.RequirePermissionToControl)
                return true;

            return permission.UserHasPermission(player.UserIDString, PermissionControl);
        }

        private void SetupCarTurret(AutoTurret turret)
        {
            turret.gameObject.layer = (int)Rust.Layer.Vehicle_Detailed;
            RemoveColliders<MeshCollider>(turret);
            RemoveGroundWatch(turret);
            _carTurretTracker.Add(turret.net.ID);
        }

        private AutoTurret DeployAutoTurret(ModularCar car, BaseVehicleModule vehicleModule, Vector3 position, float conditionFraction = 1, ulong ownerId = 0)
        {
            var autoTurret = GameManager.server.CreateEntity(PrefabEntityAutoTurret, position, GetIdealTurretRotation(car, vehicleModule)) as AutoTurret;
            if (autoTurret == null)
                return null;

            autoTurret.SetFlag(IOEntity.Flag_HasPower, true);
            autoTurret.SetParent(vehicleModule);
            autoTurret.OwnerID = ownerId;
            autoTurret.Spawn();
            autoTurret.SetHealth(autoTurret.MaxHealth() * conditionFraction);

            SetupCarTurret(autoTurret);
            AttachTurretSwitch(autoTurret);

            Effect.server.Run(PrefabEffectDeployAutoTurret, autoTurret.transform.position);

            return autoTurret;
        }

        private void RefreshCarTurret(AutoTurret turret)
        {
            SetupCarTurret(turret);

            var turretSwitch = GetTurretSwitch(turret);
            if (turretSwitch != null)
            {
                SetupTurretSwitch(turretSwitch);
            }
        }

        private ElectricSwitch AttachTurretSwitch(AutoTurret autoTurret)
        {
            var turretSwitch = GameManager.server.CreateEntity(PrefabEntityElectricSwitch, autoTurret.transform.TransformPoint(TurretSwitchPosition), autoTurret.transform.rotation * TurretSwitchRotation) as ElectricSwitch;
            if (turretSwitch == null)
                return null;

            SetupTurretSwitch(turretSwitch);
            turretSwitch.Spawn();
            turretSwitch.SetParent(autoTurret, true);

            return turretSwitch;
        }

        private void SetupTurretSwitch(ElectricSwitch electricSwitch)
        {
            electricSwitch.pickup.enabled = false;
            electricSwitch.SetFlag(IOEntity.Flag_HasPower, true);
            electricSwitch.baseProtection = ImmortalProtection;
            RemoveColliders<Collider>(electricSwitch);
            RemoveGroundWatch(electricSwitch);
            HideInputsAndOutputs(electricSwitch);

            if (electricSwitch.HasParent())
            {
                var transform = electricSwitch.transform;
                if (transform.localPosition != TurretSwitchPosition)
                {
                    transform.localPosition = TurretSwitchPosition;
                    electricSwitch.InvalidateNetworkCache();
                    electricSwitch.SendNetworkUpdate_Position();
                }
            }
        }

        private bool CanAccessVehicle(BaseVehicle vehicle, BasePlayer basePlayer, bool provideFeedback = true)
        {
            if (VehicleDeployedLocks == null)
                return true;

            var canAccess = VehicleDeployedLocks.Call("API_CanAccessVehicle", basePlayer, vehicle, provideFeedback);
            return !(canAccess is bool) || (bool)canAccess;
        }

        private int FindFirstSuitableSocketIndex(ModularCar car, BasePlayer basePlayer)
        {
            for (var socketIndex = 0; socketIndex < car.TotalSockets; socketIndex++)
            {
                BaseVehicleModule currentModule;
                if (car.TryGetModuleAt(socketIndex, out currentModule)
                    && currentModule.FirstSocketIndex == socketIndex
                    && HasPermissionToVehicleModule(basePlayer.UserIDString, currentModule)
                    && GetModuleAutoTurret(currentModule) == null)
                {
                    return socketIndex;
                }
            }

            return -1;
        }

        private int GetCarAutoTurretLimit(ModularCar car)
        {
            var defaultLimit = _config.DefaultLimitPerCar;

            if (car.OwnerID == 0)
                return defaultLimit;

            var ownerIdString = car.OwnerID.ToString();
            if (defaultLimit < 4 && permission.UserHasPermission(ownerIdString, PermissionLimit4))
                return 4;
            if (defaultLimit < 3 && permission.UserHasPermission(ownerIdString, PermissionLimit3))
                return 3;
            if (defaultLimit < 2 && permission.UserHasPermission(ownerIdString, PermissionLimit2))
                return 2;

            return defaultLimit;
        }

        private bool HasPermissionToVehicleModule(string userId, BaseVehicleModule vehicleModule)
        {
            return permission.UserHasPermission(userId, PermissionAllModules)
                || permission.UserHasPermission(userId, GetAutoTurretPermissionForModule(vehicleModule));
        }

        private bool ShouldSpawnTurretsWithCar(ModularCar car)
        {
            var spawnWithCarConfig = _config.SpawnWithCarConfig;
            if (!spawnWithCarConfig.Enabled)
                return false;

            if (IsNaturalCarSpawn(car))
                return spawnWithCarConfig.NaturalCarSpawns.Enabled;

            if (!spawnWithCarConfig.OtherCarSpawns.Enabled)
                return false;

            if (!spawnWithCarConfig.OtherCarSpawns.RequirePermission)
                return true;

            return car.OwnerID != 0 && permission.UserHasPermission(car.OwnerID.ToString(), PermissionSpawnWithCar);
        }

        private bool TryGetAutoTurretPositionForModule(BaseVehicleModule vehicleModule, out Vector3 position)
        {
            return _config.ModulePositions.TryGetValue(vehicleModule.AssociatedItemDef.shortname, out position);
        }

        private int GetAutoTurretChanceForModule(BaseVehicleModule vehicleModule)
        {
            int chance;
            return _config.SpawnWithCarConfig.SpawnChanceByModule.TryGetValue(vehicleModule.AssociatedItemDef.shortname, out chance)
                ? chance
                : 0;
        }

        private AutoTurret DeployAutoTurretForPlayer(ModularCar car, BaseVehicleModule vehicleModule, Vector3 position, BasePlayer basePlayer, float conditionFraction = 1)
        {
            var autoTurret = DeployAutoTurret(car, vehicleModule, position, conditionFraction, basePlayer.userID);
            if (autoTurret == null)
                return null;

            // Other plugins may have already automatically authorized the player.
            if (!autoTurret.IsAuthed(basePlayer))
            {
                autoTurret.authorizedPlayers.Add(new ProtoBuf.PlayerNameID
                {
                    userid = basePlayer.userID,
                    username = basePlayer.displayName
                });
                autoTurret.SendNetworkUpdate();
            }

            // Allow other plugins to detect the auto turret being deployed (e.g., to add a weapon automatically).
            var turretItem = FindPlayerAutoTurretItem(basePlayer);
            if (turretItem != null)
            {
                RunOnEntityBuilt(turretItem, autoTurret);
            }
            else
            {
                // Temporarily increase the player inventory capacity to ensure there is enough space.
                basePlayer.inventory.containerMain.capacity++;
                var temporaryTurretItem = ItemManager.CreateByItemID(ItemIdAutoTurret);
                if (basePlayer.inventory.GiveItem(temporaryTurretItem))
                {
                    RunOnEntityBuilt(temporaryTurretItem, autoTurret);
                    temporaryTurretItem.RemoveFromContainer();
                }

                temporaryTurretItem.Remove();
                basePlayer.inventory.containerMain.capacity--;
            }

            return autoTurret;
        }

        #endregion

        #region Dynamic Hook Subscriptions

        private class DynamicHookSubscriber<T>
        {
            private CarTurrets _plugin;
            private HashSet<T> _list = new HashSet<T>();
            private string[] _hookNames;

            public DynamicHookSubscriber(CarTurrets plugin, params string[] hookNames)
            {
                _plugin = plugin;
                _hookNames = hookNames;
            }

            public void Add(T item)
            {
                if (_list.Add(item) && _list.Count == 1)
                {
                    SubscribeAll();
                }
            }

            public void Remove(T item)
            {
                if (_list.Remove(item) && _list.Count == 0)
                {
                    UnsubscribeAll();
                }
            }

            public void SubscribeAll()
            {
                foreach (var hookName in _hookNames)
                {
                    _plugin.Subscribe(hookName);
                }
            }

            public void UnsubscribeAll()
            {
                foreach (var hookName in _hookNames)
                {
                    _plugin.Unsubscribe(hookName);
                }
            }
        }

        #endregion

        #region Configuration

        [JsonObject(MemberSerialization.OptIn)]
        private class SpawnWithCarConfig
        {
            [JsonProperty("NaturalCarSpawns")]
            public NaturalCarSpawnsConfig NaturalCarSpawns = new NaturalCarSpawnsConfig();

            [JsonProperty("OtherCarSpawns")]
            public OtherCarSpawnsConfig OtherCarSpawns = new OtherCarSpawnsConfig();

            [JsonProperty("SpawnChanceByModule")]
            public Dictionary<string, int> SpawnChanceByModule = new Dictionary<string, int>()
            {
                ["vehicle.1mod.cockpit"] = 0,
                ["vehicle.1mod.cockpit.armored"] = 0,
                ["vehicle.1mod.cockpit.with.engine"] = 0,
                ["vehicle.1mod.engine"] = 0,
                ["vehicle.1mod.flatbed"] = 0,
                ["vehicle.1mod.passengers.armored"] = 0,
                ["vehicle.1mod.rear.seats"] = 0,
                ["vehicle.1mod.storage"] = 0,
                ["vehicle.1mod.taxi"] = 0,
                ["vehicle.2mod.flatbed"] = 0,
                ["vehicle.2mod.fuel.tank"] = 0,
                ["vehicle.2mod.passengers"] = 0,
                ["vehicle.2mod.camper"] = 0,
            };

            public bool Enabled => NaturalCarSpawns.Enabled || OtherCarSpawns.Enabled;
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class NaturalCarSpawnsConfig
        {
            [JsonProperty("Enabled")]
            public bool Enabled = false;
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class OtherCarSpawnsConfig
        {
            [JsonProperty("Enabled")]
            public bool Enabled = false;

            [JsonProperty("RequirePermission")]
            public bool RequirePermission = false;
        }

        [JsonObject(MemberSerialization.OptIn)]
        private class Configuration : BaseConfiguration
        {
            [JsonProperty("RequirePermissionToControlCarTurrets")]
            public bool RequirePermissionToControl;

            [JsonProperty("DefaultLimitPerCar")]
            public int DefaultLimitPerCar = 4;

            [JsonProperty("EnableTurretPickup")]
            public bool EnableTurretPickup = true;

            [JsonProperty("OnlyPowerTurretsWhileEngineIsOn")]
            public bool OnlyPowerTurretsWhileEngineIsOn = false;

            [JsonProperty("TargetPlayers")]
            public bool TargetPlayers = true;

            [JsonProperty("TargetNPCs")]
            public bool TargetNPCs = true;

            [JsonProperty("TargetAnimals")]
            public bool TargetAnimals = true;

            [JsonProperty("SpawnWithCar")]
            public SpawnWithCarConfig SpawnWithCarConfig = new SpawnWithCarConfig();

            [JsonProperty("AutoTurretPositionByModule")]
            public Dictionary<string, Vector3> ModulePositions = new Dictionary<string, Vector3>()
            {
                ["vehicle.1mod.cockpit"] = new Vector3(0, 1.39f, -0.3f),
                ["vehicle.1mod.cockpit.armored"] = new Vector3(0, 1.39f, -0.3f),
                ["vehicle.1mod.cockpit.with.engine"] = new Vector3(0, 1.39f, -0.85f),
                ["vehicle.1mod.engine"] = new Vector3(0, 0.4f, 0),
                ["vehicle.1mod.flatbed"] = new Vector3(0, 0.06f, 0),
                ["vehicle.1mod.passengers.armored"] = new Vector3(0, 1.38f, -0.31f),
                ["vehicle.1mod.rear.seats"] = new Vector3(0, 1.4f, -0.12f),
                ["vehicle.1mod.storage"] = new Vector3(0, 0.61f, 0),
                ["vehicle.1mod.taxi"] = new Vector3(0, 1.38f, -0.13f),
                ["vehicle.2mod.flatbed"] = new Vector3(0, 0.06f, -0.7f),
                ["vehicle.2mod.fuel.tank"] = new Vector3(0, 1.28f, -0.85f),
                ["vehicle.2mod.passengers"] = new Vector3(0, 1.4f, -0.9f),
                ["vehicle.2mod.camper"] = new Vector3(0, 1.4f, -1.6f),
            };
        }

        private Configuration GetDefaultConfig() => new Configuration();

        #region Configuration Helpers

        private class BaseConfiguration
        {
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(BaseConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            var changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                object currentRawValue;
                if (currentRaw.TryGetValue(key, out currentRawValue))
                {
                    var defaultDictValue = currentWithDefaults[key] as Dictionary<string, object>;
                    var currentDictValue = currentRawValue as Dictionary<string, object>;

                    if (defaultDictValue != null)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                            changed = true;
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => _config = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(_config))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                LogError(e.Message);
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_config, true);
        }

        #endregion

        #endregion

        #region Localization

        private string GetMessage(string userId, string messageName, params object[] args)
        {
            var message = lang.GetMessage(messageName, this, userId);
            return args.Length > 0 ? string.Format(message, args) : message;
        }

        private string GetMessage(IPlayer player, string messageName, params object[] args) =>
            GetMessage(player.Id, messageName, args);

        private void ReplyToPlayer(IPlayer player, string messageName, params object[] args) =>
            player.Reply(string.Format(GetMessage(player, messageName), args));

        private void ChatMessage(BasePlayer basePlayer, string messageName, params object[] args) =>
            basePlayer.ChatMessage(string.Format(GetMessage(basePlayer.UserIDString, messageName), args));

        private class Lang
        {
            public const string GenericErrorNoPermission = "Generic.Error.NoPermission";
            public const string GenericErrorBuildingBlocked = "Generic.Error.BuildingBlocked";
            public const string DeployErrorNoCarFound = "Deploy.Error.NoCarFound";
            public const string DeployErrorNoModules = "Deploy.Error.NoModules";
            public const string DeployErrorNoPermissionToModule = "Deploy.Error.NoPermissionToModule";
            public const string DeployErrorModuleAlreadyHasTurret = "Deploy.Error.ModuleAlreadyHasTurret";
            public const string DeployErrorUnsupportedModule = "Deploy.Error.UnsupportedModule";
            public const string DeployErrorTurretLimit = "Deploy.Error.TurretLimit";
            public const string DeployErrorNoSuitableModule = "Deploy.Error.NoSuitableModule";
            public const string DeployErrorNoTurret = "Deploy.Error.NoTurret";
            public const string RemoveErrorTurretHasItems = "Remove.Error.TurretHasItems";
            public const string RemoveAllSuccess = "RemoveAll.Success";
            public const string InfoPowerRequiresEngine = "Info.PowerRequiresEngine";
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [Lang.GenericErrorNoPermission] = "You don't have permission to do that.",
                [Lang.GenericErrorBuildingBlocked] = "Error: Cannot do that while building blocked.",
                [Lang.DeployErrorNoCarFound] = "Error: No car found.",
                [Lang.DeployErrorNoModules] = "Error: That car has no modules.",
                [Lang.DeployErrorNoPermissionToModule] = "You don't have permission to do that to that module type.",
                [Lang.DeployErrorModuleAlreadyHasTurret] = "Error: That module already has a turret.",
                [Lang.DeployErrorUnsupportedModule] = "Error: That module is not supported.",
                [Lang.DeployErrorTurretLimit] = "Error: That car may only have {0} turret(s).",
                [Lang.DeployErrorNoSuitableModule] = "Error: No suitable module found.",
                [Lang.DeployErrorNoTurret] = "Error: You need an auto turret to do that.",
                [Lang.RemoveErrorTurretHasItems] = "Error: That module's turret must be empty.",
                [Lang.RemoveAllSuccess] = "Removed all {0} car turrets.",
                [Lang.InfoPowerRequiresEngine] = "The turret will power on when the car engine starts."
            }, this, "en");

            //Adding translation in portuguese brazil
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [Lang.GenericErrorNoPermission] = "VocÃª nÃ£o tem permissÃ£o para fazer isso.",
                [Lang.GenericErrorBuildingBlocked] = "Erro: NÃ£o Ã© possÃ­vel fazer isso enquanto o prÃ©dio estÃ¡ bloqueado.",
                [Lang.DeployErrorNoCarFound] = "Erro: nenhum carro encontrado.",
                [Lang.DeployErrorNoModules] = "Erro: esse carro nÃ£o tem mÃ³dulos.",
                [Lang.DeployErrorNoPermissionToModule] = "VocÃª nÃ£o tem permissÃ£o para fazer isso com esse tipo de mÃ³dulo.",
                [Lang.DeployErrorModuleAlreadyHasTurret] = "Erro: esse mÃ³dulo jÃ¡ tem uma turret.",
                [Lang.DeployErrorUnsupportedModule] = "Erro: esse mÃ³dulo nÃ£o Ã© compatÃ­vel.",
                [Lang.DeployErrorTurretLimit] = "Erro: esse carro sÃ³ pode ter {0} torreta(s).",
                [Lang.DeployErrorNoSuitableModule] = "Erro: Nenhum mÃ³dulo adequado encontrado.",
                [Lang.DeployErrorNoTurret] = "Erro: vocÃª precisa de uma turret automÃ¡tica para fazer isso.",
                [Lang.RemoveErrorTurretHasItems] = "Erro: a torre desse mÃ³dulo deve estar vazia.",
                [Lang.RemoveAllSuccess] = "Removidas todas as {0} turrets do carro.",
                [Lang.InfoPowerRequiresEngine] = "A torre serÃ¡ ligada quando o motor do carro ligar."
            }, this, "pt-BR");
        }

        #endregion
    }
}


// --- End of file: CarTurrets.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/clear-night ---
// --- Original File Path: C/ClearNight/ClearNight.cs ---

ï»¿using Facepunch;
using Network;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using ProtoBuf;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Clear Night", "Clearshot", "2.3.6")]
    [Description("Always bright nights")]
    class ClearNight : CovalencePlugin
    {
        private PluginConfig _config;
        private EnvSync _envSync;
        private List<DateTime> _fullMoonDates = new List<DateTime> {
            new DateTime(2024, 1, 25),
            new DateTime(2024, 2, 24),
            new DateTime(2024, 3, 25),
            new DateTime(2024, 4, 23),
            new DateTime(2024, 5, 23),
            new DateTime(2024, 6, 21),
            new DateTime(2024, 7, 21),
            new DateTime(2024, 8, 19),
            new DateTime(2024, 9, 17),
            new DateTime(2024, 10, 17),
            new DateTime(2024, 11, 15),
            new DateTime(2024, 12, 15)
        };
        private Dictionary<string, string> _weatherSync = new Dictionary<string, string>();
        private DateTime _date;
        private Climate _climate;
        private int _current = 0;
        private bool _playSound = false;

        private bool IsDay = false;
        private bool IsNight = false;

        [PluginReference("NightVision")]
        Plugin NightVisionRef;
        VersionNumber NightVisionMinVersion = new VersionNumber(1, 4, 0);

        void OnServerInitialized()
        {
            _envSync = BaseNetworkable.serverEntities.OfType<EnvSync>().FirstOrDefault();
            _climate = SingletonComponent<Climate>.Instance;
            _date = _fullMoonDates[_current];

            TOD_Sky.Instance.Components.Time.OnDay += OnDay;
            TOD_Sky.Instance.Components.Time.OnSunset += OnSunset;

            if (_envSync == null)
            {
                NextTick(() => {
                    LogError("Unable to find EnvSync! Are you using a custom map?");
                    Interface.Oxide.UnloadPlugin(Name);
                });
                return;
            }

            if (NightVisionRef != null && NightVisionRef.Version < NightVisionMinVersion)
            {
                NextTick(() => {
                    LogError($"NightVision version: v{NightVisionRef.Version}");
                    LogError($"Please update NightVision to v{NightVisionMinVersion} or higher!");
                    Interface.Oxide.UnloadPlugin(Name);
                });
                return;
            }

            timer.Every(_config.syncInterval, () => {
                if (!_envSync.limitNetworking)
                {
                    _envSync.limitNetworking = true;
                }

                if (NightVisionRef != null)
                {
                    NightVisionRef?.CallHook("BlockEnvUpdates", true);
                }

                UpdateCelestials();
                SyncWeather();

                List<Connection> subscribers = _envSync.net.group.subscribers;
                if (subscribers != null && subscribers.Count > 0)
                {
                    for (int i = 0; i < subscribers.Count; i++)
                    {
                        Connection connection = subscribers[i];
                        BasePlayer basePlayer = connection.player as BasePlayer;

                        if (!(basePlayer == null))
                        {
                            if (NightVisionRef != null && (bool)NightVisionRef?.CallHook("IsPlayerTimeLocked", basePlayer)) continue;

                            UpdatePlayerDateTime(ref connection, _config.freezeMoon && IsNight ? _date : _date.AddHours(TOD_Sky.Instance.Cycle.Hour));

                            if (_playSound)
                            {
                                var effect = new Effect(_config.sound, basePlayer, 0, Vector3.zero, Vector3.forward);
                                EffectNetwork.Send(effect, connection);
                            }
                        }
                    }
                }

                _playSound = false;
            });
        }

        void Unload()
        {
            TOD_Sky.Instance.Components.Time.OnDay -= OnDay;
            TOD_Sky.Instance.Components.Time.OnSunset -= OnSunset;

            if (_envSync != null)
            {
                _envSync.limitNetworking = false;
            }

            if (NightVisionRef != null)
            {
                NightVisionRef?.CallHook("BlockEnvUpdates", false);
            }

            ServerMgr.SendReplicatedVars("weather.");
        }

        void OnDay()
        {
            if (_config.randomizeDates)
            {
                _current = UnityEngine.Random.Range(0, _fullMoonDates.Count - 1);
                _date = _fullMoonDates[_current];
            }
            else
            {
                _current = _current >= _fullMoonDates.Count ? 0 : _current;
                _date = _fullMoonDates[_current];
                _current++;
            }
        }

        void OnSunset()
        {
            _playSound = _config.playSoundAtSunset;
        }

        private void UpdatePlayerDateTime(ref Connection connection, DateTime date)
        {
            NetWrite netWrite = Net.sv.StartWrite();
            connection.validate.entityUpdates = connection.validate.entityUpdates + 1;
            BaseNetworkable.SaveInfo saveInfo = new BaseNetworkable.SaveInfo
            {
                forConnection = connection,
                forDisk = false
            };
            netWrite.PacketID(Message.Type.Entities);
            netWrite.UInt32(connection.validate.entityUpdates);
            using (saveInfo.msg = Pool.Get<Entity>())
            {
                _envSync.Save(saveInfo);
                saveInfo.msg.environment.dateTime = date.ToBinary();
                saveInfo.msg.environment.fog = 0;
                saveInfo.msg.environment.rain = 0;
                saveInfo.msg.environment.clouds = 0;
                saveInfo.msg.environment.wind = 0;
                if (saveInfo.msg.baseEntity == null)
                {
                    LogError(this + ": ToStream - no BaseEntity!?");
                }
                if (saveInfo.msg.baseNetworkable == null)
                {
                    LogError(this + ": ToStream - no baseNetworkable!?");
                }
                saveInfo.msg.ToProto(netWrite);
                _envSync.PostSave(saveInfo);
                netWrite.Send(new SendInfo(connection));
            }
        }

        private void UpdatePlayerWeather(ref Dictionary<string, string> weatherVars)
        {
            NetWrite netWrite = Net.sv.StartWrite();
            List<Connection> list = Pool.GetList<Connection>();
            foreach (Connection connection in Net.sv.connections)
            {
                if (connection.connected)
                {
                    list.Add(connection);
                }
            }
            List<KeyValuePair<string, string>> list2 = Pool.GetList<KeyValuePair<string, string>>();
            list2.AddRange(weatherVars.ToList());
            netWrite.PacketID(Message.Type.ConsoleReplicatedVars);
            netWrite.Int32(list2.Count);
            foreach (var item in list2)
            {
                netWrite.String(item.Key);
                netWrite.String(item.Value);
            }
            netWrite.Send(new SendInfo(list));
            Pool.FreeList<KeyValuePair<string, string>>(ref list2);
            Pool.FreeList<Connection>(ref list);
        }

        private void UpdateCelestials()
        {
            float f = 0.0174532924f * TOD_Sky.Instance.World.Latitude;
            float num = Mathf.Sin(f);
            float num2 = Mathf.Cos(f);
            float longitude = TOD_Sky.Instance.World.Longitude;
            float num3 = 1.57079637f;
            int year = _date.Year;
            int month = _date.Month;
            int day = _date.Day;
            float num4 = TOD_Sky.Instance.Cycle.Hour - TOD_Sky.Instance.World.UTC;
            float num5 = (float)(367 * year - 7 * (year + (month + 9) / 12) / 4 + 275 * month / 9 + day - 730530) + num4 / 24f;
            float num7 = 23.4393f - 3.563E-07f * num5;
            float f2 = 0.0174532924f * num7;
            float num8 = Mathf.Sin(f2);
            float num9 = Mathf.Cos(f2);
            float num37 = 282.9404f + 4.70935E-05f * num5;
            float num38 = 0.016709f - 1.151E-09f * num5;
            float num39 = 356.047f + 0.985600233f * num5;
            float num40 = 0.0174532924f * num39;
            float num41 = Mathf.Sin(num40);
            float num42 = Mathf.Cos(num40);
            float f6 = num40 + num38 * num41 * (1f + num38 * num42);
            float num43 = Mathf.Sin(f6);
            float num44 = Mathf.Cos(f6) - num38;
            float num45 = Mathf.Sqrt(1f - num38 * num38) * num43;
            float num46 = 57.29578f * Mathf.Atan2(num45, num44);
            float num47 = Mathf.Sqrt(num44 * num44 + num45 * num45);
            float num48 = num46 + num37;
            float f7 = 0.0174532924f * num48;
            float num49 = Mathf.Sin(f7);
            float num50 = Mathf.Cos(f7);
            float num51 = num47 * num50;
            float num52 = num47 * num49;
            float num53 = num51;
            float num54 = num52 * num9;
            float y2 = num52 * num8;
            float num55 = Mathf.Atan2(num54, num53);
            float f8 = Mathf.Atan2(y2, Mathf.Sqrt(num53 * num53 + num54 * num54));
            float num56 = Mathf.Sin(f8);
            float num57 = Mathf.Cos(f8);
            float num58 = num46 + num37 + 180f + 15f * num4;
            float num59 = 0.0174532924f * (num58 + longitude);
            float f9 = num59 - num55;
            float num60 = Mathf.Sin(f9);
            float num61 = Mathf.Cos(f9) * num57;
            float num62 = num60 * num57;
            float num63 = num56;
            float num64 = num61 * num - num63 * num2;
            float num65 = num62;
            float y3 = num61 * num2 + num63 * num;
            float num67 = Mathf.Atan2(y3, Mathf.Sqrt(num64 * num64 + num65 * num65));
            float num68 = num3 - num67;
            float SunZenith = 57.29578f * num68;
            float LerpValue = Mathf.InverseLerp(105f, 90f, SunZenith);
            if (LerpValue > 0.1f)
            {
                IsDay = true;
                IsNight = false;
            }
            else
            {
                IsDay = false;
                IsNight = true;
            }
        }

        private void SyncWeather()
        {
            if (_config.syncWeather)
            {
                _weatherSync["weather.atmosphere_brightness"] = _climate.WeatherOverrides.Atmosphere.Brightness != -1f ? _climate.WeatherOverrides.Atmosphere.Brightness.ToString() : _climate.WeatherState.Atmosphere.Brightness.ToString();
                _weatherSync["weather.atmosphere_contrast"] = _climate.WeatherOverrides.Atmosphere.Contrast != -1f ? _climate.WeatherOverrides.Atmosphere.Contrast.ToString() : _climate.WeatherState.Atmosphere.Contrast.ToString();
                _weatherSync["weather.atmosphere_directionality"] = _climate.WeatherOverrides.Atmosphere.Directionality != -1f ? _climate.WeatherOverrides.Atmosphere.Directionality.ToString() : _climate.WeatherState.Atmosphere.Directionality.ToString();
                _weatherSync["weather.atmosphere_mie"] = _climate.WeatherOverrides.Atmosphere.MieMultiplier != -1f ? _climate.WeatherOverrides.Atmosphere.MieMultiplier.ToString() : _climate.WeatherState.Atmosphere.MieMultiplier.ToString();
                _weatherSync["weather.atmosphere_rayleigh"] = _climate.WeatherOverrides.Atmosphere.RayleighMultiplier != -1f ? _climate.WeatherOverrides.Atmosphere.RayleighMultiplier.ToString() : _climate.WeatherState.Atmosphere.RayleighMultiplier.ToString();
                _weatherSync["weather.clear_chance"] = _climate.Weather.ClearChance.ToString();
                _weatherSync["weather.cloud_attenuation"] = _climate.WeatherOverrides.Clouds.Attenuation != -1f ? _climate.WeatherOverrides.Clouds.Attenuation.ToString() : _climate.WeatherState.Clouds.Attenuation.ToString();
                _weatherSync["weather.cloud_brightness"] = _climate.WeatherOverrides.Clouds.Brightness != -1f ? _climate.WeatherOverrides.Clouds.Brightness.ToString() : _climate.WeatherState.Clouds.Brightness.ToString();
                _weatherSync["weather.cloud_coloring"] = _climate.WeatherOverrides.Clouds.Coloring != -1f ? _climate.WeatherOverrides.Clouds.Coloring.ToString() : _climate.WeatherState.Clouds.Coloring.ToString();
                _weatherSync["weather.cloud_coverage"] = _climate.WeatherOverrides.Clouds.Coverage != -1f ? _climate.WeatherOverrides.Clouds.Coverage.ToString() : _climate.WeatherState.Clouds.Coverage.ToString();
                _weatherSync["weather.cloud_opacity"] = _climate.WeatherOverrides.Clouds.Opacity != -1f ? _climate.WeatherOverrides.Clouds.Opacity.ToString() : _climate.WeatherState.Clouds.Opacity.ToString();
                _weatherSync["weather.cloud_saturation"] = _climate.WeatherOverrides.Clouds.Saturation != -1f ? _climate.WeatherOverrides.Clouds.Saturation.ToString() : _climate.WeatherState.Clouds.Saturation.ToString();
                _weatherSync["weather.cloud_scattering"] = _climate.WeatherOverrides.Clouds.Scattering != -1f ? _climate.WeatherOverrides.Clouds.Scattering.ToString() : _climate.WeatherState.Clouds.Scattering.ToString();
                _weatherSync["weather.cloud_sharpness"] = _climate.WeatherOverrides.Clouds.Sharpness != -1f ? _climate.WeatherOverrides.Clouds.Sharpness.ToString() : _climate.WeatherState.Clouds.Sharpness.ToString();
                _weatherSync["weather.cloud_size"] = _climate.WeatherOverrides.Clouds.Size != -1f ? _climate.WeatherOverrides.Clouds.Size.ToString() : _climate.WeatherState.Clouds.Size.ToString();
                _weatherSync["weather.dust_chance"] = _climate.Weather.DustChance.ToString();
                _weatherSync["weather.fog"] = _climate.WeatherOverrides.Atmosphere.Fogginess != -1f ? _climate.WeatherOverrides.Atmosphere.Fogginess.ToString() : _climate.WeatherState.Atmosphere.Fogginess.ToString();
                _weatherSync["weather.fog_chance"] = _climate.Weather.FogChance.ToString();
                _weatherSync["weather.overcast_chance"] = _climate.Weather.OvercastChance.ToString();
                _weatherSync["weather.rain"] = _climate.WeatherOverrides.Rain != -1f ? _climate.WeatherOverrides.Rain.ToString() : _climate.WeatherState.Rain.ToString();
                _weatherSync["weather.rain_chance"] = _climate.Weather.RainChance.ToString();
                _weatherSync["weather.rainbow"] = _climate.WeatherOverrides.Rainbow != -1f ? _climate.WeatherOverrides.Rainbow.ToString() : _climate.WeatherState.Rainbow.ToString();
                _weatherSync["weather.storm_chance"] = _climate.Weather.StormChance.ToString();
                _weatherSync["weather.thunder"] = _climate.WeatherOverrides.Thunder != -1f ? _climate.WeatherOverrides.Thunder.ToString() : _climate.WeatherState.Thunder.ToString();
                _weatherSync["weather.wind"] = _climate.WeatherOverrides.Wind != -1f ? _climate.WeatherOverrides.Wind.ToString() : _climate.WeatherState.Wind.ToString();

                if (IsNight)
                {
                    foreach (var pair in _config.weatherAtNight)
                    {
                        _weatherSync[pair.Key] = pair.Value;
                    }
                }

                UpdatePlayerWeather(ref _weatherSync);
            } 
            else if (IsNight && _config.weatherAtNight.Count > 0)
            {
                UpdatePlayerWeather(ref _config.weatherAtNight);
            }
        }

        [Command("clearnight.debug")]
        private void DebugCommand(Core.Libraries.Covalence.IPlayer player, string command, string[] args)
        {
            player.Message("clearnight.debug");
            if (!player.IsAdmin && !player.IsServer) return;

            StringBuilder _sb = new StringBuilder();
            _sb.AppendLine("\n*** DEBUG START ***\n");
            _sb.AppendLine($"ClearNight version: {Version}");
            _sb.AppendLine($"ClearNight date: {(_config.freezeMoon && IsNight ? _date : _date.AddHours(TOD_Sky.Instance.Cycle.Hour))}");
            _sb.AppendLine($"ClearNight IsNight: {IsNight}");
            _sb.AppendLine($"ClearNight IsDay: {IsDay}");

            _sb.AppendLine($"\n[Server date and time]");
            _sb.AppendLine($"Year: {TOD_Sky.Instance.Cycle.Year}");
            _sb.AppendLine($"Month: {TOD_Sky.Instance.Cycle.Month}");
            _sb.AppendLine($"Day: {TOD_Sky.Instance.Cycle.Day}");
            _sb.AppendLine($"Hour: {TOD_Sky.Instance.Cycle.Hour}");
            _sb.AppendLine($"IsNight: {TOD_Sky.Instance.IsNight}");
            _sb.AppendLine($"IsDay: {TOD_Sky.Instance.IsDay}");

            _sb.AppendLine($"\n[Config]");
            _sb.AppendLine(JsonConvert.SerializeObject(_config, Formatting.Indented, Config.Settings));

            _sb.AppendLine($"\nNightVision installed: {NightVisionRef != null}");
            if (NightVisionRef != null)
            {
                _sb.AppendLine($"NightVision version: {NightVisionRef.Version}");
            }

            _sb.AppendLine("\n*** DEBUG END ***");
            Puts(_sb.ToString());
            LogToFile("debug", _sb.ToString(), this);
        }

        #region Config

        protected override void LoadDefaultConfig()
        {
            Puts("Generating new default config file...");
            Config.WriteObject(GetDefaultConfig(), true);
        }

        private PluginConfig GetDefaultConfig()
        {
            PluginConfig defaultConfig = new PluginConfig();

            defaultConfig.fullMoonDates = _fullMoonDates.Select(d => d.ToString("MM/dd/yyyy")).ToArray();
            defaultConfig.weatherAtNight = new Dictionary<string, string> {
                { "weather.atmosphere_brightness", "1" },
                { "weather.atmosphere_contrast", "1.5" },
                { "weather.cloud_coverage", "0" },
                { "weather.cloud_size", "0" },
                { "weather.fog", "0" },
                { "weather.fog_chance", "0" }
            };

            return defaultConfig;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<PluginConfig>();

            bool invalidDates = true;
            if (_config.fullMoonDates.Length > 0)
            {
                List<DateTime> tempDates = new List<DateTime>();
                foreach (string date in _config.fullMoonDates)
                {
                    DateTime dt;
                    if (DateTime.TryParse(date, out dt))
                    {
                        tempDates.Add(dt);
                    }
                    else
                    {
                        Puts($"invalid date: {date}");
                    }
                }

                if (tempDates.Count > 0)
                {
                    invalidDates = false;
                    _fullMoonDates = tempDates;
                    Puts($"registered {_fullMoonDates.Count} {(_fullMoonDates.Count == 1 ? "date" : "dates")} from config");
                }
            }

            if (invalidDates)
            {
                Puts("no valid dates registered, using default dates");
            }

            Config.WriteObject(_config, true);
        }

        private class PluginConfig
        {
            public string[] fullMoonDates;
            public Dictionary<string, string> weatherAtNight;
            public bool syncWeather = true;
            public bool randomizeDates = false;
            public bool freezeMoon = false;
            public bool playSoundAtSunset = false;
            public string sound = "assets/bundled/prefabs/fx/player/howl.prefab";
            public float syncInterval = 5f;
        }

        #endregion
    }
}


// --- End of file: ClearNight.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/collider-count ---
// --- Original File Path: C/ColliderCount/ColliderCount.cs ---

using System;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Collider Count", "Cheeze", "0.0.4", ResourceId = 1306)]
    class ColliderCount : RustPlugin
    {

        private const string ChatPrefix = "Server Status";
        private const string ChatPrefixColor = "#ffa500ff";

        private readonly DateTime epoch = new DateTime(1970, 1, 1, 0, 0, 0);
        private DateTime wipeDate;

        IFormatProvider culture = new System.Globalization.CultureInfo("en-GB", true);

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file.");
            Config.Clear();
            Config["Settings", "LastWipe"] = "17.8.2015";
            Config["Settings", "MaxColliders"] = 270000;
            Config["Settings", "Color1"] = "<color=#ff0000ff>";
            Config["Settings", "Color2"] = "<color=#008000ff>";
            SaveConfig();
        }
        void Loaded()
        {
            var date = Config["Settings", "LastWipe"].ToString();
            wipeDate = DateTime.Parse(date, culture, System.Globalization.DateTimeStyles.AssumeLocal);
        }

        [ChatCommand("wipeinfo")]
        private void WipeInfoChat(BasePlayer player, string command, string[] args)
        {
            SendMessage(player, $"{GetColor1()}There are currently</color>{GetColor2()} {GetColliderCount()}</color> {GetColor1()}colliders on the server out of a max of</color>{GetColor2()} {GetMaxColliders()}</color>");
            SendMessage(player, GetTimeToWipe());
        }

        [ConsoleCommand("wipeinfo")]
        private void WipeInfoConsole(ConsoleSystem.Arg arg)
        {
            if (arg.Player() != null && !arg.Player().IsAdmin)
            {
                string NotAllowed = null;
                arg.ReplyWith(NotAllowed);
                return;
            }
            PrintToChat($"{GetColor1()}There are currently</color>{GetColor2()} {GetColliderCount()}</color> {GetColor1()}colliders on the server out of a max of</color>{GetColor2()} {GetMaxColliders()}</color>");
            PrintToChat(GetTimeToWipe());
        }

        private int GetColliderCount()
        {
            var colliders = UnityEngine.Object.FindObjectsOfType<Collider>().Count(x => x.enabled);
            return colliders;
        }


        private int GetMaxColliders()
        {
            var maxColliders = int.Parse(Config["Settings", "MaxColliders"].ToString());
            return maxColliders;
        }

        private string GetColor1()
        {
           string color1 = (Config["Settings", "Color1"].ToString());
           return color1;
        }

        private string GetColor2()
        {
            string color2 = (Config["Settings", "Color2"].ToString());
            return color2;
        }

        private string GetTimeToWipe()
        {
            var days = (int)Math.Floor((DateTime.UtcNow - wipeDate).TotalDays);
            if (days > 0)
            {
                var mapSize = TerrainMeta.Size.x;
                var initialColliders = (int)(((mapSize * mapSize) / 1000000) * 1500);
                var colliders = UnityEngine.Object.FindObjectsOfType<Collider>().Count(x => x.enabled);
                var postEnts = (colliders - initialColliders);
                var entsDaily = (postEnts / days);
                var maxColliders = int.Parse(Config["Settings", "MaxColliders"].ToString());
                var timetowipe = (maxColliders - colliders) / entsDaily;
                var wipeDays = $"{GetColor1()}We estimate needing to wipe in </color>{GetColor2()}" + timetowipe + $"</color> {GetColor1()}days!</color>";
                return wipeDays;
            }

            var nodays = $"{GetColor1()}We only just recently wiped and cannot estimate next wipe yet!</color>";
            return nodays;
        }

        private static void SendMessage(BasePlayer player, string message, params object[] args) => player?.SendConsoleCommand("chat.add", -1, string.Format($"<color={ChatPrefixColor}>{ChatPrefix}</color>: {message}", args), 1.0);

        private long GetTimestamp(DateTime date) => Convert.ToInt64(date.Subtract(epoch).TotalSeconds);
    }
}

// --- End of file: ColliderCount.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/crafting-controller ---
// --- Original File Path: C/CraftingController/CraftingController.cs ---

using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using Facepunch;

namespace Oxide.Plugins
{
    [Info("Crafting Controller", "Whispers88", "3.3.4")]
    [Description("Allows you to modify the time spend crafting and which items can be crafted")]

    //Credits to previous authors Nivex & Mughisi
    public class CraftingController : RustPlugin
    {
        #region Config
        private Configuration config;
        private static Dictionary<string, CraftingData> defaultsetup = new Dictionary<string, CraftingData>();
        public struct CraftingData
        {
            public bool canCraft;
            public bool canResearch;
            public bool useCrafteRateMultiplier;
            public float craftTime;
            public int workbenchLevel;
            public ulong defaultskinid;
        }

        public class Configuration
        {

            [JsonProperty("Default crafting rate percentage")]
            public float CraftingRate = 50;

            [JsonProperty("Save commands to config (save config changes via command to the configuration)")]
            public bool SaveCommands = true;

            [JsonProperty("Simple Mode (disables: instant bulk craft, skin options and full inventory checks for better performance)")]
            public bool SimpleMode = false;

            [JsonProperty("Allow crafting when inventory is full")]
            public bool FullInventory = false;

            [JsonProperty("Complete crafting on server shut down")]
            public bool CompleteCrafting = false;

            [JsonProperty("Craft items with random skins if not already skinned")]
            public bool RandomSkins = false;

            [JsonProperty("Show Crafting Notes")]
            public bool ShowCraftNotes = false;

            [JsonProperty("Crafting rate bonus mulitplier (apply oxide perms for additional mulitpliers", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, float> BonusMultiplier = new Dictionary<string, float>() { { "vip1", 90 }, { "vip2", 80 } };

            [JsonProperty("Advanced Crafting Options", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, CraftingData> CraftingOptions = new Dictionary<string, CraftingData>();

            [JsonProperty("Version")]
            public float Version = 331;

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    throw new JsonException();
                }
            }
            catch
            {
                Puts($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Puts($"Configuration changes saved to {Name}.json");
            Config.WriteObject(config, true);
        }

        #endregion Config

        #region Init
        private const string perminstantbulkcraft = "craftingcontroller.instantbulkcraft";
        private const string permblockitems = "craftingcontroller.blockitems";
        private const string permitemrate = "craftingcontroller.itemrate";
        private const string permcraftingrate = "craftingcontroller.craftingrate";
        private const string permsetbenchlvl = "craftingcontroller.setbenchlvl";
        private const string permsetskins = "craftingcontroller.setskins";

        private List<string> permissions = new List<string> { perminstantbulkcraft, permblockitems, permitemrate, permcraftingrate, permsetbenchlvl, permsetskins };
        private List<string> permissionsBonusMultiplier = new List<string>();
        private List<string> commands = new List<string> { nameof(CommandCraftingRate), nameof(CommandCraftTime), nameof(CommandBlockItem), nameof(CommandUnblockItem), nameof(CommandSetDefaultSkin), nameof(CommandWorkbenchLVL) };
        private void OnServerInitialized()
        {
            //Set default stats for unload
            ItemManager.bpList.ForEach(bp => defaultsetup[bp.name] = new CraftingData() { canCraft = bp.userCraftable, canResearch = bp.isResearchable, craftTime = bp.time, workbenchLevel = bp.workbenchLevelRequired });

            foreach (var key in config.BonusMultiplier.Keys)
            {
                permissionsBonusMultiplier.Add("craftingcontroller." + key);
            }
            //register permissions
            permissions.ForEach(perm => permission.RegisterPermission(perm, this));
            permissionsBonusMultiplier.ForEach(perm => permission.RegisterPermission(perm, this));
            //register commands
            commands.ForEach(command => AddLocalizedCommand(command));

            if (config.SimpleMode)
            {
                Unsubscribe("OnItemCraft");
                Unsubscribe("OnItemCraftFinished");
                Unsubscribe("OnItemCraftCancelled");
            }
            ItemManager.bpList.ForEach(item => {
                if (!config.CraftingOptions.ContainsKey(item.targetItem.shortname))
                    config.CraftingOptions.Add(item.targetItem.shortname, new CraftingData() { craftTime = item.time, workbenchLevel = item.workbenchLevelRequired, canCraft = item.userCraftable, canResearch = item.isResearchable });
            });

            if (config.Version < 332)
            {
                config.CraftingOptions["revolver.hc"] = new CraftingData() { craftTime = 30, workbenchLevel = 2, canCraft = true, canResearch = true };
                config.Version = 332;
            }

            SaveConfig();
            UpdateCraftingRate();
        }

        private void Unload()
        {
            //Reset to defaults
            foreach (var bp in ItemManager.bpList)
            {
                CraftingData craftingData;
                if (!defaultsetup.TryGetValue(bp.name, out craftingData))
                    continue;

                bp.time = craftingData.craftTime;
                bp.workbenchLevelRequired = craftingData.workbenchLevel;
                bp.userCraftable = craftingData.canCraft;
                bp.isResearchable = craftingData.canResearch;
            }
        }

        #endregion Init

        #region Localization
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoInvSpace"] = "You don't have enough room to craft this item!",
                ["NoPerms"] = "You don't have permission to use this command.",
                ["CannotFindItem"] = "Cannot find item {0}.",
                ["ItemBlocked"] = "{0} has been blocked from crafting.",
                ["ItemUnblocked"] = "{0} has been unblocked from crafting.",
                ["NeedsAdvancedOptions"] = "You need to enable advanced crafting options in your config to use this.",
                ["WrongNumberInput"] = "Your input needs to be a number.",
                ["ItemCraftTimeSet"] = "{0} craft time set to {1} seconds",
                ["WorkbenchLevelSet"] = "{0} workbench level set to {1}",
                ["CurrentCraftinRate"] = "The current crafting rate is {0 }%",
                ["CraftingRateUpdated"] = "The crafting rate was updated to {0} %",
                ["CraftTime2Args"] = "This command needs two arguments in the format /crafttime item.shortname timetocraft",
                ["BlockItem1Args"] = "This command needs one argument in the format /blockitem item.shortname",
                ["UnblockItem1Args"] = "This command needs one argument in the format /unblockitem item.shortname",
                ["WorckBenchLvl2Args"] = "This command needs two arguments in the format /benchlvl item.shortname workbenchlvl",
                ["BenchLevelInput"] = "The work bench level must be between 0 and 3",
                ["SetSkin2Args"] = "This command needs one argument in the format /setcraftskin item.shortname skinworkshopid",
                ["SkinSet"] = "The default skin for {0} was set to {1}",
                ["CraftTimeCheck"] = "The craft time of this item is {0}",
                //Commands
                ["CommandCraftingRate"] = "craftrate",
                ["CommandCraftTime"] = "crafttime",
                ["CommandBlockItem"] = "blockitem",
                ["CommandUnblockItem"] = "unblockitem",
                ["CommandWorkbenchLVL"] = "benchlvl",
                ["CommandSetDefaultSkin"] = "setcraftskin"

            }, this);
        }

        #endregion Localization

        #region Commands
        private void CommandCraftingRate(IPlayer iplayer, string command, string[] args)
        {
            if (!HasPerm(iplayer.Id, permitemrate))
            {
                Message(iplayer, "NoPerms");
                return;
            }
            int craftingrate;
            if (args.Length == 0)
            {
                Message(iplayer, "CurrentCraftinRate", config.CraftingRate);
                return;
            }
            if (!int.TryParse(args[0], out craftingrate))
            {
                Message(iplayer, "WrongNumberInput");
                return;
            }
            if (craftingrate < 0) craftingrate = 0;
            config.CraftingRate = craftingrate;
            UpdateCraftingRate();
            Message(iplayer, "CraftingRateUpdated", config.CraftingRate);
            if (config.SaveCommands) SaveConfig();

        }

        private void CommandCraftTime(IPlayer iplayer, string command, string[] args)
        {
            if (!HasPerm(iplayer.Id, permitemrate))
            {
                Message(iplayer, "NoPerms");
                return;
            }
            if (args.Length == 1)
            {
                var itemcheck = FindItem(args[0]);
                if (itemcheck)
                {
                    Message(iplayer, "CraftTimeCheck", itemcheck.Blueprint.time);
                    return;
                }
            }
            if (args.Length < 2)
            {
                Message(iplayer, "CraftTime2Args");
                return;
            }
            var setitem = FindItem(args[0]);
            if (!setitem)
            {
                Message(iplayer, "CannotFindItem", args[0]);
                return;
            }
            if (args[1].ToLower() == "default")
            {
                if (!config.CraftingOptions.TryGetValue(setitem.shortname, out CraftingData craftingdata))
                    return;

                craftingdata.useCrafteRateMultiplier = true; ;
                craftingdata.craftTime = defaultsetup[setitem.Blueprint.name].craftTime * (config.CraftingRate / 100);

                Message(iplayer, "ItemCraftTimeSet", setitem.shortname, (setitem.Blueprint.time).ToString());
                if (config.SaveCommands) SaveConfig();
                return;
            }
            int crafttime;
            if (!int.TryParse(args[1], out crafttime))
            {
                Message(iplayer, "WrongNumberInput");
                return;
            }
            if (!config.CraftingOptions.TryGetValue(setitem.shortname, out CraftingData craftingdata1))
                return;

            craftingdata1.craftTime = crafttime;
            craftingdata1.useCrafteRateMultiplier = false;

            ItemBlueprint bp = ItemManager.itemDictionaryByName[setitem.shortname].Blueprint;
            bp.time = crafttime;
            Message(iplayer, "ItemCraftTimeSet", setitem.shortname, crafttime.ToString());
            if (config.SaveCommands) SaveConfig();
        }

        private void CommandBlockItem(IPlayer iplayer, string command, string[] args)
        {
            if (!HasPerm(iplayer.Id, permblockitems))
            {
                Message(iplayer, "NoPerms");
                return;
            }
            if (args.Length < 1)
            {
                Message(iplayer, "BlockItem1Args");
                return;
            }
            var blockitem = FindItem(args[0]);
            if (!blockitem)
            {
                Message(iplayer, "CannotFindItem", args[0]);
                return;
            }
            if (config.CraftingOptions.TryGetValue(blockitem.shortname, out CraftingData craftingdata))
            {
                craftingdata.canCraft = false;
                craftingdata.canResearch = false;
            }
            ItemBlueprint bp = ItemManager.itemDictionaryByName[blockitem.shortname].Blueprint;
            bp.userCraftable = false;
            bp.isResearchable = false;
            Message(iplayer, "ItemBlocked", blockitem.shortname);
            if (config.SaveCommands) SaveConfig();
        }

        private void CommandUnblockItem(IPlayer iplayer, string command, string[] args)
        {
            if (!HasPerm(iplayer.Id, permblockitems))
            {
                Message(iplayer, "NoPerms");
                return;
            }
            if (args.Length < 1)
            {
                Message(iplayer, "UnbockItem1Args");
                return;
            }
            var blockitem = FindItem(args[0]);
            if (!blockitem)
            {
                Message(iplayer, "CannotFindItem", args[0]);
                return;
            }
            if (!config.CraftingOptions.TryGetValue(blockitem.shortname, out CraftingData craftingdata))
                return;
            craftingdata.canCraft = true;
            craftingdata.canResearch = true;
            ItemBlueprint bp = ItemManager.itemDictionaryByName[blockitem.shortname].Blueprint;
            bp.userCraftable = true;
            bp.isResearchable = true;
            Message(iplayer, "ItemUnblocked", blockitem.shortname);
            if (config.SaveCommands) SaveConfig();
        }
        private void CommandWorkbenchLVL(IPlayer iplayer, string command, string[] args)
        {
            if (!HasPerm(iplayer.Id, permsetbenchlvl))
            {
                Message(iplayer, "NoPerms");
                return;
            }
            if (args.Length < 2)
            {
                Message(iplayer, "WorckBenchLvl2Args");
                return;
            }
            var item = FindItem(args[0]);
            if (!item)
            {
                Message(iplayer, "CannotFindItem", args[0]);
                return;
            }
            int benchlvl;
            if (!int.TryParse(args[1], out benchlvl))
            {
                Message(iplayer, "WrongNumberInput");
                return;
            }
            if (benchlvl < 0 || benchlvl > 3)
            {
                Message(iplayer, "BenchLevelInput");
                return;
            }
            if (!config.CraftingOptions.TryGetValue(item.shortname, out CraftingData craftingdata))
                return;
            craftingdata.workbenchLevel = benchlvl;
            ItemBlueprint bp = ItemManager.itemDictionaryByName[item.shortname].Blueprint;
            bp.workbenchLevelRequired = benchlvl;
            Message(iplayer, "WorkbenchLevelSet", item.shortname, benchlvl.ToString());
            if (config.SaveCommands) SaveConfig();
        }
        private void CommandSetDefaultSkin(IPlayer iplayer, string command, string[] args)
        {
            if (!HasPerm(iplayer.Id, permsetskins))
            {
                Message(iplayer, "NoPerms");
                return;
            }
            if (args.Length < 2)
            {
                Message(iplayer, "SetSkin2Args");
                return;
            }
            var setitem = FindItem(args[0]);
            if (!setitem)
            {
                Message(iplayer, "CannotFindItem", args[0]);
                return;
            }
            ulong skinid;
            if (!ulong.TryParse(args[1], out skinid))
            {
                Message(iplayer, "WrongNumberInput", args);
                return;
            }
            if (!config.CraftingOptions.TryGetValue(setitem.shortname, out CraftingData craftingdata))
                return;
            craftingdata.defaultskinid = skinid;
            Message(iplayer, "SkinSet", setitem.shortname, skinid.ToString());
            if (config.SaveCommands) SaveConfig();
        }
        #endregion Commands

        #region Methods
        private void UpdateCraftingRate()
        {
            foreach (var bp in ItemManager.bpList)
            {
                CraftingData data;
                if (!config.CraftingOptions.TryGetValue(bp.targetItem.shortname, out data)) continue;
                bp.userCraftable = data.canCraft;
                bp.isResearchable = data.canResearch;
                if (config.CraftingRate == 0f)
                    bp.time = 0f;
                else if (!data.useCrafteRateMultiplier)
                    bp.time = data.craftTime;
                else
                    bp.time *= (float)(config.CraftingRate / 100);

                if (data.workbenchLevel > 4) data.workbenchLevel = 3;
                if (data.workbenchLevel >= 0)
                    bp.workbenchLevelRequired = data.workbenchLevel;
            }
        }

        private void InstantBulkCraft(BasePlayer player, ItemCraftTask task, ItemDefinition item, List<int> stacks, int craftSkin, ulong skin)
        {
            if (skin == 0uL && craftSkin != 0)
            {
                skin = ItemDefinition.FindSkin(item.itemid, craftSkin);
            }
            foreach (var stack in stacks)
            {
                var itemtogive = ItemManager.Create(item, stack, craftSkin != 0 && skin == 0uL ? (ulong)craftSkin : skin);
                itemtogive.OnVirginSpawn(player);
                itemtogive.SetItemOwnership(player, ItemOwnershipPhrases.CraftedPhrase);
                var held = itemtogive.GetHeldEntity();
                if (held != null)
                {
                    held.skinID = skin == 0uL ? (ulong)craftSkin : skin;
                    held.SendNetworkUpdate();
                }
                player.GiveItem(itemtogive);
                //if (config.ShowCraftNotes) player.Command(string.Concat(new object[] { "note.inv ", item.itemid, " ", stack }), new object[0]);
                Interface.CallHook("OnItemCraftFinished", task, itemtogive, player.inventory.crafting);
            }
        }

        private static void CompleteCrafting(BasePlayer player)
        {
            if (player.inventory.crafting.queue.Count == 0) return;
            player.inventory.crafting.FinishCrafting(player.inventory.crafting.queue.First.Value);
            player.inventory.crafting.queue.RemoveFirst();
        }
        private static void CancelAllCrafting(BasePlayer player)
        {
            ItemCrafter crafter = player.inventory.crafting;
            crafter.CancelAll();
        }

        #endregion Methods

        #region Hooks
        private Dictionary<ItemCraftTask, ulong> skinupdate = new Dictionary<ItemCraftTask, ulong>();
        private object OnItemCraft(ItemCraftTask task, BasePlayer player, Item fromTempBlueprint)
        {
            var target = task.blueprint.targetItem;
            if (task == null || target == null || task?.instanceData?.dataInt != null || task?.amount == 0) return null;
            var stacks = GetStacks(target, task.amount * task.blueprint.amountToCreate);
            ulong defaultskin = 0uL;
            int freeslots = FreeSlots(player);
            bool f = false;
            if (!config.FullInventory && stacks.Count >= freeslots)
            {
                f = true;
                int space = FreeSpace(player, target);
                if (space < 1)
                {
                    ReturnCraft(task, player);
                    return true;
                }
                int taskamt = task.amount * task.blueprint.amountToCreate;
                for (int i = 0; i < 20 && taskamt > space; i++)
                {
                    var oldtaskamt = taskamt;
                    taskamt = space;
                    foreach (var item in task.takenItems)
                    {
                        var itemtogive = item;
                        double fraction = (double)taskamt / (double)oldtaskamt;
                        int amttogive = (int)(item.amount * (1 - fraction));
                        if (amttogive <= 1)
                        {
                            ReturnCraft(task, player);
                            return true;
                        }
                        itemtogive = ItemManager.Create(item.info, amttogive, 0uL);
                        item.amount -= amttogive;

                        player.GiveItem(itemtogive);
                    }
                    space -= (freeslots - FreeSlots(player)) * target.stackable;
                    if (space < 1 || taskamt < 1)
                    {
                        ReturnCraft(task, player);
                        return true;
                    }
                    if (taskamt <= space) break;

                }
                task.amount = (int)(taskamt / task.blueprint.amountToCreate);
            }


            if (task.skinID == 0)
            {
                CraftingData data;
                if (config.CraftingOptions.TryGetValue(target.shortname, out data))
                {
                    defaultskin = data.defaultskinid;
                }

                if (config.RandomSkins && defaultskin == 0)
                {
                    List<ulong> skins = GetSkins(ItemManager.FindItemDefinition(target.itemid));
                    defaultskin = skins.GetRandom();
                }

                if (defaultskin > 999999)
                    skinupdate[task] = defaultskin;
                else
                    task.skinID = (int)defaultskin;
            }

            float bonusperm_time = float.MaxValue;
            foreach (var bonusperm in permissionsBonusMultiplier)
            {
                if (!HasPerm(player.UserIDString, $"{bonusperm}")) continue;
                if (bonusperm_time < (float)config.BonusMultiplier[bonusperm.Split('.')[1]]) continue;
                bonusperm_time = (float)config.BonusMultiplier[bonusperm.Split('.')[1]];
            }
            if (bonusperm_time != float.MaxValue)
            {
                task.blueprint = UnityEngine.Object.Instantiate(task.blueprint);
                task.blueprint.time *= bonusperm_time / 100;
            }

            if (task.blueprint.time == 0f || HasPerm(player.UserIDString, perminstantbulkcraft))
            {
                skinupdate.Remove(task);
                if (f)
                    stacks = GetStacks(target, task.amount * task.blueprint.amountToCreate);
                InstantBulkCraft(player, task, target, stacks, task.skinID, defaultskin);
                task.cancelled = true;
                return true;
            }
            return null;
        }

        private void OnItemCraftFinished(ItemCraftTask task, Item item)
        {
            ulong skinid;
            if (!skinupdate.TryGetValue(task, out skinid)) return;

            item.skin = skinid;
            var held = item.GetHeldEntity();

            if (held != null)
            {
                held.skinID = skinid;
                held.SendNetworkUpdate();
            }
            if (task.amount == 0)
                skinupdate.Remove(task);
        }

        void OnItemCraftCancelled(ItemCraftTask task)
        {
            ulong skinid;
            if (!skinupdate.TryGetValue(task, out skinid)) return;
            skinupdate.Remove(task);
        }

        private void OnServerQuit()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (player.inventory.crafting.queue.Count == 0) continue;
                if (config.CompleteCrafting)
                    CompleteCrafting(player);
                CancelAllCrafting(player);
            }
        }

        #endregion Hooks

        #region Helpers
        private void ReturnCraft(ItemCraftTask task, BasePlayer crafter)
        {
            task.cancelled = true;
            Message(crafter.IPlayer, "NoInvSpace");
            foreach (var item in task.takenItems)
            {
                if (item.amount > 0)
                    crafter.GiveItem(item);
            }
        }

        private ItemDefinition FindItem(string itemNameOrId)
        {
            ItemDefinition itemDef;
            if (int.TryParse(itemNameOrId, out int itemId))
            {
                itemDef = ItemManager.FindItemDefinition(itemId);
                return itemDef;
            }
            itemDef = ItemManager.FindItemDefinition(itemNameOrId.ToLower());
            return itemDef;
        }

        private int FreeSpace(BasePlayer player, ItemDefinition item)
        {
            var slots = player.inventory.containerMain.capacity + player.inventory.containerBelt.capacity;
            List<Item> containeritems = Pool.Get<List<Item>>();
            Dictionary<ItemDefinition, int> queueamts = new Dictionary<ItemDefinition, int>();
            containeritems.AddRange(player.inventory.containerMain.itemList);
            containeritems.AddRange(player.inventory.containerBelt.itemList);

            int value = 0;
            //Sum all items in crafting queue not including the item to be crafted
            foreach (var queueitem in player.inventory.crafting.queue)
            {
                if (queueitem.blueprint.targetItem == item) continue;
                if (queueamts.TryGetValue(queueitem.blueprint.targetItem, out value))
                {
                    queueamts[queueitem.blueprint.targetItem] += queueitem.amount * queueitem.blueprint.amountToCreate;
                    continue;
                }
                queueamts[queueitem.blueprint.targetItem] = queueitem.amount * queueitem.blueprint.amountToCreate;
            }
            //Take into account room of other stacks
            int queuestacks = 0;
            foreach (var i in queueamts)
            {
                queuestacks += GetStacks(i.Key, i.Value - Stackroom(containeritems, i.Key.shortname)).Count;
            }

            //calculate total room in inventory for the item required
            int invstackroom = (slots - containeritems.Count - queuestacks) * item.stackable;
            containeritems.ForEach(x => { if (x.info == item && x.amount < x.MaxStackable()) invstackroom += x.MaxStackable() - x.amount; });
            foreach (var x in player.inventory.crafting.queue)
            {
                if (x.blueprint.targetItem.shortname == item.shortname)
                {
                    invstackroom -= x.amount * x.blueprint.amountToCreate;
                }
            }
            Pool.FreeUnmanaged(ref containeritems);
            return invstackroom;
        }
        private int FreeSlots(BasePlayer player)
        {
            var slots = player.inventory.containerMain.capacity + player.inventory.containerBelt.capacity;
            var taken = player.inventory.containerMain.itemList.Count + player.inventory.containerBelt.itemList.Count;
            return slots - taken;
        }

        private int Stackroom(List<Item> items, string item)
        {
            int stackroom = 0;
            items.ForEach(x => { if (x.info.shortname == item && x.amount < x.MaxStackable()) stackroom += x.MaxStackable() - x.amount; });
            return stackroom;
        }

        private List<int> GetStacks(ItemDefinition item, int amount)
        {
            List<int> list = new List<int>();
            int maxStack = item.stackable;
            int maxstacks = amount / maxStack;
            if (maxStack == 0) return list;
            for (int i = 0; i <= maxstacks; i++)
            {
                if (maxStack > amount)
                {
                    if (amount >= 1)
                        list.Add(amount);
                    return list;
                }
                list.Add(maxStack);
                amount -= maxStack;
            }
            return list;
        }
        private readonly Dictionary<string, List<ulong>> skinsCache = new Dictionary<string, List<ulong>>();
        private List<ulong> GetSkins(ItemDefinition def)
        {
            List<ulong> skins;
            if (skinsCache.TryGetValue(def.shortname, out skins)) return skins;
            skins = new List<ulong>();
            foreach (var skin in ItemSkinDirectory.ForItem(def))
            {
                skins.Add((ulong)skin.id);
            }
            foreach (var skin in Rust.Workshop.Approved.All.Values)
            {
                if (skin.Skinnable.ItemName == def.shortname)
                    skins.Add(skin.WorkshopdId);
            }
            skinsCache.Add(def.shortname, skins);
            return skins;
        }

        private string GetLang(string langKey, string playerId = null, params object[] args)
        {
            return string.Format(lang.GetMessage(langKey, this, playerId), args);
        }
        private void Message(IPlayer player, string langKey, params object[] args)
        {
            if (player.IsConnected) player.Message(GetLang(langKey, player.Id, args));
        }

        private bool HasPerm(string id, string perm) => permission.UserHasPermission(id, perm);

        private void AddLocalizedCommand(string command)
        {
            foreach (string language in lang.GetLanguages(this))
            {
                Dictionary<string, string> messages = lang.GetMessages(language, this);
                foreach (KeyValuePair<string, string> message in messages)
                {
                    if (!message.Key.Equals(command)) continue;

                    if (string.IsNullOrEmpty(message.Value)) continue;

                    AddCovalenceCommand(message.Value, command);
                }
            }
        }
        #endregion Helpers
    }
}

// --- End of file: CraftingController.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/custom-sets ---
// --- Original File Path: C/CustomSets/CustomSets.cs ---

ï»¿using System.Collections.Generic;
using System;
using System.Linq;
using UnityEngine;
using Oxide.Core.Plugins;
using Oxide.Core.Configuration;
using Oxide.Game.Rust.Cui;
using Oxide.Core;
using Newtonsoft.Json.Linq;

namespace Oxide.Plugins
{
    [Info("CustomSets", "Absolut", "1.0.3", ResourceId = 2425)]
    [Description("An equipment set creation and management system. All Sets are managed through the UI and can be given or sold to players with Economics or ServerRewards")]
    class CustomSets : RustPlugin
    {
        [PluginReference]
        Plugin EventManager, ServerRewards, Economics, ImageLibrary;

        SavedData csData;
        private DynamicConfigFile CSDATA;

        bool ready;
        string TitleColor = "<color=#0045ff>";
        string MsgColor = "<color=#A9A9A9>";
        private List<ulong> SavingCollection = new List<ulong>();
        private Dictionary<string, Timer> timers = new Dictionary<string, Timer>();
        Dictionary<string, List<ulong>> ItemSkins = new Dictionary<string, List<ulong>>();
        private Dictionary<ulong, SetCreation> NewSet = new Dictionary<ulong, SetCreation>();
        class SetCreation
        {
            public string setname;
            public bool Editing;
            public bool UsePermission;
            public Set set = new Set();
        }

        private Dictionary<ulong, screen> CSUIInfo = new Dictionary<ulong, screen>();
        class screen
        {
            public bool open;
            public bool admin;
            public string SelectedCategory = string.Empty;
            public string SelectedSet;
            public int CategoryIndex;
            public int SetIndex;
            public int page;
            public int InspectedGear = -1;
            public string InspectedAttachment = string.Empty;
            public string location = string.Empty;
        }

        void Loaded()
        {
            ready = false;
            CSDATA = Interface.Oxide.DataFileSystem.GetFile("CustomSets_Data");
        }

        void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
                DestroyPlayer(player);
            foreach (var timer in timers)
                timer.Value.Destroy();
            timers.Clear();
            SaveData();
        }

        void OnServerInitialized()
        {
            timer.Once(10, () =>
            {
                if (!ImageLibrary)
                {
                    PrintWarning("Image Library not detected.. This plugin will unload as it will not work", Name);
                    Interface.Oxide.UnloadPlugin(Name);
                    return;
                }
                LoadVariables();
                LoadData();
                InitializeStuff();
                permission.RegisterPermission(this.Title + ".admin", this);
                permission.RegisterPermission(this.Title + ".allow", this);
                foreach (var entry in csData.SavedSets.Where(k => !string.IsNullOrEmpty(k.Value.permission)))
                    permission.RegisterPermission(this.Title + "." + entry.Value.permission.Replace(" ", string.Empty), this);
                timers.Add("info", timer.Once(900, () => InfoLoop()));
                timers.Add("save", timer.Once(600, () => SaveLoop()));
                foreach (BasePlayer p in BasePlayer.activePlayerList)
                    OnPlayerInit(p);
            });
        }


        private void InitializeStuff()
        {
            if (timers.ContainsKey("imageloading"))
            {
                timers["imageloading"].Destroy();
                timers.Remove("imageloading");
            }
            CreateLoadOrder();
            if (!isReady())
            {
                Puts(GetMSG("WaitingImageLibrary"));
                timers.Add("imageloading", timer.Once(60, () => InitializeStuff()));
                return;
            };

            foreach (var itemDef in ItemManager.GetItemDefinitions())
            {
                List<ulong> skins;
                skins = new List<ulong> { 0 };
                skins.AddRange(ItemSkinDirectory.ForItem(itemDef).Select(skin => Convert.ToUInt64(skin.id)));
                List<ulong> templist = GetImageList(itemDef.shortname);
                if (templist != null && templist.Count >= 1)
                    foreach (var entry in templist.Where(k => !skins.Contains(k)))
                        skins.Add(entry);
                ItemSkins.Add(itemDef.shortname, skins);
            }
        }

        private void CreateLoadOrder()
        {
            Dictionary<string, string> newLoadOrder = new Dictionary<string, string>
            {
                { "cs_selectedbutton", "http://i.imgur.com/tfpKLAQ.png"},
                { "cs_unselectedbutton", "http://i.imgur.com/i3XLvJb.png"},
                { "cs_attachmentoverlay", "http://i.imgur.com/Icl5BaB.png"},
                { "cs_next", "http://i.imgur.com/F4FnvVT.png"},
                { "cs_prior", "http://i.imgur.com/SP93UQj.png"},
                { "cs_smallbackground", "http://i.imgur.com/fIetbic.png"},
                { "cs_remove", "http://i.imgur.com/7D6cGeu.png"},
                { "cs_back", "http://i.imgur.com/Ymexrbe.jpg"},
                { "cs_background", "http://i.imgur.com/1sJtIBF.png"}
            };
            ImageLibrary.Call("ImportImageList", Title, newLoadOrder, (ulong)ResourceId, true);
        }

        private void OnPlayerInit(BasePlayer player)
        {
            if (player != null)
            {
                string key = String.Empty;
                //if (!string.IsNullOrEmpty(configData.MenuKeyBinding))
                //{
                //    player.Command($"bind {configData.MenuKeyBinding} \"ToggleCSUI\"");
                //    key = GetMSG("CSAltInfo", player, configData.MenuKeyBinding.ToUpper());
                //}
                if (configData.InfoInterval != 0)
                    GetSendMSG(player, "CSInfo", key);
            }
        }

        private void OnPlayerRespawned(BasePlayer player)
        {
            DestroyUI(player);
            if (EventManager)
            {
                object isPlaying = EventManager?.Call("isPlaying", new object[] { player });
                if (isPlaying is bool)
                    if ((bool)isPlaying)
                        return;
            }
            foreach (var entry in configData.SpawnSets.OrderBy(k => k.Key))
                if (csData.SavedSets.ContainsKey(entry.Value) && (string.IsNullOrEmpty(csData.SavedSets[entry.Value].permission) || permission.UserHasPermission(player.UserIDString, this.Title + "." + csData.SavedSets[entry.Value].permission.Replace(" ", string.Empty))))
                {
                    var setData = csData.SavedSets[entry.Value];
                    if (setData.cooldown != 0 || setData.dailyUses != 0 && csData.PlayerData.ContainsKey(player.userID))
                    {
                        var data = csData.PlayerData[player.userID];
                        CoolandUse info = null;
                        data.cooldownANDuses.TryGetValue(entry.Value, out info);
                        if (info != null)
                        {
                            if (info.CooldownExpiration < CurrentTotalMinutes()) info.CooldownExpiration = 0;
                            if (CurrentTotalMinutes() > info.FirstUse + (configData.UsesResetInterval_InHours * 60 * 60))
                            {
                                info.timesUsed = 0;
                                info.FirstUse = 0;
                            }
                            if (info.CooldownExpiration != 0 || setData.dailyUses - info.timesUsed == 0) continue;
                        }
                    }
                    player.inventory.Strip();
                    ProcessSelection(player, entry.Value);
                    return;
                }
        }

        private void SRAction(ulong ID, int amount, string action)
        {
            if (action == "ADD")
                ServerRewards?.Call("AddPoints", new object[] { ID, amount });
            if (action == "REMOVE")
                ServerRewards?.Call("TakePoints", new object[] { ID, amount });
        }

        private void ECOAction(ulong ID, int amount, string action)
        {
            if (action == "ADD")
                Economics.Call("DepositS", ID.ToString(), amount);
            if (action == "REMOVE")
                Economics.Call("WithdrawS", ID.ToString(), amount);
        }

        object OnServerCommand(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection?.player as BasePlayer;
            if (player != null && SavingCollection.Contains(player.userID) && arg.cmd?.FullName == "chat.say" && !string.IsNullOrEmpty(string.Join(" ", arg.Args)) && !arg.GetString(0).StartsWith("/"))
            {
                CollectionCreationChat(player, string.Join(" ", arg.Args));
                return false;
            }
            return null;
        }

        private void CollectionCreationChat(BasePlayer player, string Args)
        {
            if (Args.Contains("quit"))
            {
                ExitSetCreation(player);
                return;
            }
            if (csData.SavedSets.ContainsKey(Args))
            {
                GetSendMSG(player, "NameTaken", Args);
                return;
            }
            NewSet[player.userID].setname = Args;
            SaveCollection(player);
        }

        private string TryForImage(string shortname, ulong skin = 99)
        {
            if (shortname.Contains("http")) return shortname;
            if (skin == 99) skin = (ulong)ResourceId;
            return GetImage(shortname, skin, true);
        }

        public string GetImage(string shortname, ulong skin = 0, bool returnUrl = false) => (string)ImageLibrary.Call("GetImage", shortname.ToLower(), skin, returnUrl);
        public bool HasImage(string shortname, ulong skin = 0) => (bool)ImageLibrary.Call("HasImage", shortname.ToLower(), skin);
        public bool AddImage(string url, string shortname, ulong skin = 0) => (bool)ImageLibrary?.Call("AddImage", url, shortname.ToLower(), skin);
        public List<ulong> GetImageList(string shortname) => (List<ulong>)ImageLibrary.Call("GetImageList", shortname.ToLower());
        public bool isReady() => (bool)ImageLibrary?.Call("IsReady");
        private object CheckPoints(ulong ID) => ServerRewards?.Call("CheckPoints", ID);

        void DestroyPlayer(BasePlayer player)
        {
            if (player == null) return;
            {
                DestroyUI(player);
                //if (!string.IsNullOrEmpty(configData.MenuKeyBinding))
                //    player.Command($"bind {configData.MenuKeyBinding} \"\"");
                CSUIInfo.Remove(player.userID);
            }
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            DestroyPlayer(player);
            SaveData();
        }

        private void GetSendMSG(BasePlayer player, string message, string arg1 = "", string arg2 = "", string arg3 = "")
        {
            string msg = string.Format(lang.GetMessage(message, this, player.UserIDString), arg1, arg2, arg3);
            SendReply(player, TitleColor + lang.GetMessage("title", this, player.UserIDString) + "</color>" + MsgColor + msg + "</color>");
        }

        private string GetMSG(string message, BasePlayer player = null, string arg1 = "", string arg2 = "", string arg3 = "")
        {
            string p = null;
            if (player != null)
                p = player.UserIDString;
            if (messages.ContainsKey(message))
                return string.Format(lang.GetMessage(message, this, p), arg1, arg2, arg3);
            else return message;
        }

        [ChatCommand("sets")]
        private void chatauction(BasePlayer player, string cmd, string[] args)
        {
            if (player == null) return;
            if (!isAuth(player) && !permission.UserHasPermission(player.UserIDString, this.Title + ".allow"))
            {
                GetSendMSG(player, "NoPerm");
                return;
            }
            ToggleCSUI(player);
        }


        [ConsoleCommand("ToggleCSUI")]
        private void cmdToggleCSUI(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (!isAuth(player) && !permission.UserHasPermission(player.UserIDString, this.Title + ".allow"))
            {
                GetSendMSG(player, "NoPerm");
                return;
            }
            if (arg.Args != null && arg.Args.Length > 0 && arg.Args[0] == "close")
            {
                CuiHelper.DestroyUi(player, BackgroundPanel);
                DestroySetPanels(player);
                return;
            }
            if (!ImageLibrary || !isReady())
            {
                GetSendMSG(player, "ImagesLoading");
                return;
            }
            else if (CSUIInfo.ContainsKey(player.userID))
                if (!CSUIInfo[player.userID].open)
                {
                    CSUIInfo[player.userID].open = true;
                    ToggleCSUI(player);
                }
                else
                {
                    CuiHelper.DestroyUi(player, BackgroundPanel);
                    DestroySetPanels(player);
                }
            else
                ToggleCSUI(player);
        }

        private void ToggleCSUI(BasePlayer player)
        {
            if (!CSUIInfo.ContainsKey(player.userID))
                CSUIInfo.Add(player.userID, new screen());
            CSUIInfo[player.userID].open = true;
            UIPanel(player);
        }


        public void DestroyUI(BasePlayer player)
        {
            DestroySetPanels(player);
            CuiHelper.DestroyUi(player, BackgroundPanel);
            CuiHelper.DestroyUi(player, PanelOnScreen);
            CuiHelper.DestroyUi(player, PanelMisc);
        }

        public void DestroySetPanels(BasePlayer player)
        {
            if (CSUIInfo.ContainsKey(player.userID))
                CSUIInfo[player.userID].open = false;
            CuiHelper.DestroyUi(player, SetContentsPanel);
            CuiHelper.DestroyUi(player, PanelInspector);
            CuiHelper.DestroyUi(player, SetIndexPanel);
            CuiHelper.DestroyUi(player, PanelMisc);
        }

        public void Broadcast(string message, string userid = "0") => PrintToChat(message);

        private void SaveCollection(BasePlayer player)
        {
            var name = NewSet[player.userID].setname;
            if (NewSet[player.userID].UsePermission)
            {
                NewSet[player.userID].set.permission = name.Replace(" ", string.Empty);
                permission.RegisterPermission(this.Title + "." + name, this);
            }
            if (csData.SavedSets.ContainsKey(name))
                csData.SavedSets.Remove(name);
            csData.SavedSets.Add(name, NewSet[player.userID].set);
            NewSet.Remove(player.userID);
            SavingCollection.Remove(player.userID);
            GetSendMSG(player, "NewSetCreated", name);
            CuiHelper.DestroyUi(player, PanelMisc);
            SaveData();
            CSUIInfo[player.userID].SelectedSet = string.Empty;
            ToggleCSUI(player);
        }


        private void ExitSetCreation(BasePlayer player)
        {
            if (SavingCollection.Contains(player.userID))
                SavingCollection.Remove(player.userID);
            SetPanel(player);
        }

        bool isAuth(BasePlayer player)
        {
            if (player.net.connection != null)
                if (player.net.connection.authLevel < 2 && !permission.UserHasPermission(player.UserIDString, this.Title + ".admin"))
                    return false;
            return true;
        }

        private string BackgroundPanel = "BackgroundPanel";
        private string SetIndexPanel = "SetIndexPanel";
        private string SetContentsPanel = "SetContentsPanel";
        private string PanelInspector = "PanelInspector";
        private string PanelOnScreen = "OnScreen";
        private string PanelMisc = "PanelMisc";

        public class UI
        {
            static public CuiElementContainer CreateElementContainer(string panelName, string color, string aMin, string aMax, bool cursor = false)
            {
                var NewElement = new CuiElementContainer()
            {
                {
                    new CuiPanel
                    {
                        Image = {Color = color},
                        RectTransform = {AnchorMin = aMin, AnchorMax = aMax},
                        CursorEnabled = cursor
                    },
                    new CuiElement().Parent,
                    panelName
                }
            };
                return NewElement;
            }
            static public CuiElementContainer CreateOverlayContainer(string panelName, string color, string aMin, string aMax, bool cursor = false)
            {
                var NewElement = new CuiElementContainer()
            {
                {
                    new CuiPanel
                    {
                        Image = {Color = color},
                        RectTransform = {AnchorMin = aMin, AnchorMax = aMax},
                        CursorEnabled = cursor
                    },
                    new CuiElement().Parent = "Overlay",
                    panelName
                }
            };
                return NewElement;
            }

            static public void CreatePanel(ref CuiElementContainer container, string panel, string color, string aMin, string aMax, bool cursor = false)
            {
                container.Add(new CuiPanel
                {
                    Image = { Color = color },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    CursorEnabled = cursor
                },
                panel);
            }
            static public void CreateLabel(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiLabel
                {
                    Text = { Color = color, FontSize = size, Align = align, FadeIn = 1.0f, Text = text },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax }
                },
                panel);
            }

            static public void CreateButton(ref CuiElementContainer container, string panel, string color, string text, int size, string aMin, string aMax, string command, TextAnchor align = TextAnchor.MiddleCenter)
            {
                container.Add(new CuiButton
                {
                    Button = { Color = color, Command = command, FadeIn = 1.0f },
                    RectTransform = { AnchorMin = aMin, AnchorMax = aMax },
                    Text = { Text = text, FontSize = size, Align = align }
                },
                panel);
            }

            static public void LoadImage(ref CuiElementContainer container, string panel, string img, string aMin, string aMax)
            {
                if (img.StartsWith("http") || img.StartsWith("www"))
                {
                    container.Add(new CuiElement
                    {
                        Parent = panel,
                        Components =
                    {
                        new CuiRawImageComponent {Url = img, Sprite = "assets/content/textures/generic/fulltransparent.tga" },
                        new CuiRectTransformComponent {AnchorMin = aMin, AnchorMax = aMax }
                    }
                    });
                }
                else
                    container.Add(new CuiElement
                    {
                        Parent = panel,
                        Components =
                    {
                        new CuiRawImageComponent {Png = img, Sprite = "assets/content/textures/generic/fulltransparent.tga" },
                        new CuiRectTransformComponent {AnchorMin = aMin, AnchorMax = aMax }
                    }
                    });
            }

            static public void CreateTextOutline(ref CuiElementContainer element, string panel, string colorText, string colorOutline, string text, int size, string aMin, string aMax, TextAnchor align = TextAnchor.MiddleCenter)
            {
                element.Add(new CuiElement
                {
                    Parent = panel,
                    Components =
                    {
                        new CuiTextComponent{Color = colorText, FontSize = size, Align = align, Text = text },
                        new CuiOutlineComponent {Distance = "1 1", Color = colorOutline},
                        new CuiRectTransformComponent {AnchorMax = aMax, AnchorMin = aMin }
                    }
                });
            }
        }

        private Dictionary<string, string> UIColors = new Dictionary<string, string>
        {
            {"black", "0 0 0 1.0" },
            {"dark", "0.1 0.1 0.1 0.98" },
            {"header", "0.7 0.7 0.7 0.15" },
            {"background", "0 0 0 1.0" },
            {"white", "1 1 1 1" },
            {"grey", "0.7 0.7 0.7 1.0" },
            {"buttonblue", "0.05 0.08 0.176 1.0" },
            {"buttonbg", "0.4 0.4 0.4 0.5" },
            {"buttongreen", "0.133 0.965 0.133 0.9" },
            {"buttonred", "0.964 0.133 0.133 0.9" },
            {"buttongrey", "0.8 0.8 0.8 0.9" },
            {"SpecialOrange", "0.956 0.388 0.03 1.0" }
        };


        void UIPanel(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, BackgroundPanel);
            var element = UI.CreateOverlayContainer(BackgroundPanel, "0 0 0 0", "0.1 0.05", "0.9 0.97", true);
            //UI.CreatePanel(ref element, BackgroundPanel, UIColors["header"], "0.005 0.01", "0.995 0.99");
            UI.LoadImage(ref element, BackgroundPanel, TryForImage("CS_Background"), "0 0", "1 1");
            if (CSUIInfo.ContainsKey(player.userID))
                CSUIInfo[player.userID].open = true;
            if (configData.UsePayment)
            {
                string money = ServerRewards && CheckPoints(player.userID) is int ? CheckPoints(player.userID).ToString() : Economics ? Economics.CallHook("GetPlayerMoney", player.userID).ToString() : "0";
                UI.CreateTextOutline(ref element, BackgroundPanel, UIColors["white"], UIColors["black"], money, 26, "0.8 0.92", "0.98 0.97", TextAnchor.LowerLeft);
            }
            UI.CreateButton(ref element, BackgroundPanel, "0 0 0 0", "", 16, "0.95 0.92", ".99 .98", "ToggleCSUI close");
            CuiHelper.AddUi(player, element);
            SetListPanel(player);
            SetPanel(player);
        }

        private static readonly DateTime Epoch = new DateTime(1970, 1, 1, 0, 0, 0);
        static double CurrentTotalMinutes() => DateTime.UtcNow.Subtract(Epoch).TotalMinutes;
        private string GetMinutesFormat(double minutes)
        {
            TimeSpan dateDifference = TimeSpan.FromMinutes(minutes);
            var hours = dateDifference.Hours;
            hours += (dateDifference.Days * 24);
            return string.Format("{0:00}:{1:00}:{2:00}", hours, dateDifference.Minutes, dateDifference.Seconds);
        }

        void SetListPanel(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, SetIndexPanel);
            var element = UI.CreateOverlayContainer(SetIndexPanel, "0 0 0 0", "0.11 0.1", "0.32 0.95");
            UI.CreateTextOutline(ref element, SetIndexPanel, UIColors["white"], UIColors["black"], GetMSG("ListOFSets", player), 22, "0.1 0.91", "0.9 0.985", TextAnchor.UpperCenter);
            var uiInfo = CSUIInfo[player.userID];
            if (string.IsNullOrEmpty(uiInfo.SelectedCategory))
            {
                //UI.CreateTextOutline(ref element, SetIndexPanel, UIColors["white"], UIColors["black"], GetMSG("SetCategories", player), 16, "0.1 0.85", "0.9 0.9", TextAnchor.MiddleCenter);
                if (configData.Categories.Count() >= 1)
                {
                    if (CSUIInfo[player.userID].CategoryIndex + 10 < configData.Categories.Count())
                    {
                        UI.LoadImage(ref element, SetIndexPanel, TryForImage("CS_down"), "0.3 0.02", "0.45 0.07");
                        UI.CreateButton(ref element, SetIndexPanel, "0 0 0 0", "", 12, "0.3 0.02", "0.45 0.07", $"UI_CategoryIndexShownChange {CSUIInfo[player.userID].CategoryIndex + 1}");
                    }
                    if (CSUIInfo[player.userID].CategoryIndex != 0)
                    {
                        UI.LoadImage(ref element, SetIndexPanel, TryForImage("CS_up"), "0.55 0.02", "0.7 0.07");
                        UI.CreateButton(ref element, SetIndexPanel, "0 0 0 0", "", 12, "0.55 0.02", "0.7 0.07", $"UI_CategoryIndexShownChange {CSUIInfo[player.userID].CategoryIndex - 1}");
                    }
                    var i = -1;
                    foreach (var entry in configData.Categories)
                    {
                        i++;
                        if (i < CSUIInfo[player.userID].CategoryIndex) continue;
                        if (i > CSUIInfo[player.userID].CategoryIndex + 10) continue;
                        var pos = CalcSetButtons(i - CSUIInfo[player.userID].CategoryIndex);
                        UI.LoadImage(ref element, SetIndexPanel, TryForImage("CS_UnselectedButton"), $"{ pos[0]} {pos[1]}", $"{pos[2] - .04f} {pos[3]}");
                        UI.CreateLabel(ref element, SetIndexPanel, UIColors["white"], entry, 24, $"{pos[0] + .15f} {pos[1]}", $"{pos[2]} {pos[3]}", TextAnchor.MiddleLeft);
                        UI.CreateButton(ref element, SetIndexPanel, "0 0 0 0", "", 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_ChangeCategory {entry}", TextAnchor.MiddleLeft);
                    }
                }
            }
            else
            {
                UI.CreateLabel(ref element, SetIndexPanel, UIColors["SpecialOrange"], GetMSG("Category", player, uiInfo.SelectedCategory), 16, "0.14 0.9", "0.75 0.97", TextAnchor.LowerLeft);
                UI.LoadImage(ref element, SetIndexPanel, TryForImage("CS_Back"), "0.75 0.9", "0.95 0.93");
                UI.CreateLabel(ref element, SetIndexPanel, UIColors["white"], GetMSG("Back"), 10, "0.84 0.9", "0.95 0.93", TextAnchor.MiddleLeft);
                UI.CreateButton(ref element, SetIndexPanel, "0 0 0 0", "", 12, "0.75 0.9", "0.95 0.93", $"UI_ChangeCategory BACK");
                List<string> sets = new List<string>();
                if (CSUIInfo[player.userID].admin)
                    sets = csData.SavedSets.Where(k => k.Value.Category == uiInfo.SelectedCategory).Select(k => k.Key).ToList();
                else if (!configData.ShowLockedSets)
                    sets = csData.SavedSets.Where(k => k.Value.Category == uiInfo.SelectedCategory && !k.Value.hidden && (string.IsNullOrEmpty(k.Value.permission) || permission.UserHasPermission(player.UserIDString, this.Title + "." + k.Value.permission.Replace(" ", string.Empty)))).Select(k => k.Key).ToList();
                else sets = csData.SavedSets.Where(k => k.Value.Category == uiInfo.SelectedCategory && !k.Value.hidden).Select(k => k.Key).ToList();
                if (sets.Count() >= 1)
                {
                    if (CSUIInfo[player.userID].SetIndex + 10 < sets.Count())
                    {
                        UI.LoadImage(ref element, SetIndexPanel, TryForImage("CS_Prior"), "0.135 -0.01", "0.58 0.035");
                        UI.CreateButton(ref element, SetIndexPanel, "0 0 0 0", "", 12, "0.135 -0.01", "0.58 0.035", $"UI_GearIndexShownChange {CSUIInfo[player.userID].SetIndex + 1}");
                    }
                    if (CSUIInfo[player.userID].SetIndex != 0)
                    {
                        UI.LoadImage(ref element, SetIndexPanel, TryForImage("CS_Next"), "0.58 -0.01", "1.01 0.035");
                        UI.CreateButton(ref element, SetIndexPanel, "0 0 0 0", "", 12, "0.58 -0.01", "1.01 0.035", $"UI_GearIndexShownChange {CSUIInfo[player.userID].SetIndex - 1}");
                    }
                    var i = -1;
                    foreach (var entry in sets)
                    {
                        i++;
                        if (i < CSUIInfo[player.userID].SetIndex) continue;
                        if (i > CSUIInfo[player.userID].SetIndex + 10) continue;
                        var pos = CalcSetButtons(i - CSUIInfo[player.userID].SetIndex);
                        if (CSUIInfo[player.userID].SelectedSet == entry) UI.LoadImage(ref element, SetIndexPanel, TryForImage("CS_SelectedButton"), $"{ pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                        else UI.LoadImage(ref element, SetIndexPanel, TryForImage("CS_UnselectedButton"), $"{ pos[0]} {pos[1]}", $"{pos[2] - .04f} {pos[3]}");
                        UI.CreateLabel(ref element, SetIndexPanel, UIColors["white"], entry, 24, $"{pos[0] + .15f} {pos[1]}", $"{pos[2]} {pos[3]}", TextAnchor.MiddleLeft);
                        //if (!string.IsNullOrEmpty(csData.SavedSets[entry].permission) && !permission.UserHasPermission(player.UserIDString, this.Title + "." + csData.SavedSets[entry].permission.Replace(" ", string.Empty)))
                        //    UI.LoadImage(ref element, SetIndexPanel, TryForImage("CS_lock"), $"{pos[0] + .02f} {pos[1]}", $"{pos[0] + 0.18f} {pos[3]}");
                        UI.CreateButton(ref element, SetIndexPanel, "0 0 0 0", "", 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_ChangeSet {entry}", TextAnchor.MiddleLeft);
                    }
                }
            }
            CuiHelper.AddUi(player, element);
        }

        private float[] CalcSetButtons(int number)
        {
            Vector2 position = new Vector2(0.13f, 0.83f);
            Vector2 dimensions = new Vector2(0.88f, 0.05f);
            float offsetY = 0;
            float offsetX = 0;
            if (number >= 0 && number < 15)
            {
                offsetY = (-0.005f - dimensions.y) * number;
            }
            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }

        void SetPanel(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, PanelMisc);
            CuiHelper.DestroyUi(player, SetContentsPanel);
            CuiHelper.DestroyUi(player, PanelInspector);
            var element = UI.CreateOverlayContainer(SetContentsPanel, "0 0 0 0", "0.33 0.06", "0.7 0.86");
            UI.CreateTextOutline(ref element, SetContentsPanel, UIColors["white"], UIColors["black"], GetMSG("INFO", player), 22, "1.01 0.94", "1.42 1");
            UI.CreateTextOutline(ref element, SetContentsPanel, UIColors["white"], UIColors["black"], GetMSG("Container", player, "HOTBAR"), 20, "0.15 0.71", "0.79 0.84", TextAnchor.MiddleLeft);
            UI.CreateTextOutline(ref element, SetContentsPanel, UIColors["white"], UIColors["black"], GetMSG("Container", player, "INVENTORY"), 20, "0.15 0.55", "0.9 0.6", TextAnchor.MiddleLeft);
            UI.CreateTextOutline(ref element, SetContentsPanel, UIColors["white"], UIColors["black"], GetMSG("Container", player, "WEAR"), 20, "0.15 0.95", "0.9 0.99", TextAnchor.MiddleLeft);
            if (isAuth(player))
                if (CSUIInfo[player.userID].admin) UI.CreateButton(ref element, SetContentsPanel, UIColors["SpecialOrange"], $"<color=black>{GetMSG("ToggleAdminView", player)}</color>", 12, "1.55 1.05", "1.7 1.1", "UI_SwitchAdminView");
                else UI.CreateButton(ref element, SetContentsPanel, UIColors["black"], $"<color=#F56201>{GetMSG("ToggleAdminView", player)}</color>", 12, "1.55 1.05", "1.7 1.1", "UI_SwitchAdminView");
            if (!string.IsNullOrEmpty(CSUIInfo[player.userID].SelectedCategory))
            {
                if (NewSet.ContainsKey(player.userID) && CSUIInfo[player.userID].admin && (!NewSet[player.userID].Editing || (NewSet[player.userID].Editing && NewSet[player.userID].setname == CSUIInfo[player.userID].SelectedSet)))
                {
                    foreach (var entry in new Dictionary<string, List<Gear>> { { "belt", NewSet[player.userID].set.belt }, { "wear", NewSet[player.userID].set.wear }, { "main", NewSet[player.userID].set.main } })
                        GearEntries(player, element, entry.Value, entry.Key);
                    if (NewSet[player.userID].Editing)
                    {
                        if (NewSet[player.userID].setname == CSUIInfo[player.userID].SelectedSet)
                        {
                            var info = NewSet[player.userID].set;

                            UI.CreateButton(ref element, SetContentsPanel, UIColors["black"], $"<color=#F56201>{GetMSG("Cost", player, info.cost.ToString())}</color>", 10, "1.55 .93", "1.7 .98", $"UI_EditSetCost");

                            UI.CreateLabel(ref element, SetContentsPanel, UIColors["white"], GetMSG("DailyUses", player, info.dailyUses <= 0 ? GetMSG("Unlimited") : $"<color=green>{info.dailyUses}</color>/{info.dailyUses}"), 22, "1.03 0.86", "1.42 0.94", TextAnchor.MiddleLeft);
                            UI.CreateButton(ref element, SetContentsPanel, UIColors["black"], $"<color=#F56201>{GetMSG("Uses", player)}</color>", 10, "1.55 0.87", "1.7 0.92", $"UI_EditSetUses");

                            UI.CreateLabel(ref element, SetContentsPanel, UIColors["white"], GetMSG("Cooldown", player, info.cooldown <= 0 ? GetMSG("None", player) : GetMinutesFormat(info.cooldown).ToString()), 22, "1.03 0.78", "1.42 0.86", TextAnchor.MiddleLeft);
                            UI.CreateButton(ref element, SetContentsPanel, UIColors["black"], $"<color=#F56201>{GetMSG("CooldownTitle", player)}</color>", 10, "1.55 0.81", "1.7 0.86", $"UI_EditSetCooldown");



                            UI.CreateButton(ref element, SetContentsPanel, UIColors["black"], $"<color=#F56201>{GetMSG("Hidden", player, info.hidden.ToString())}</color>", 10, "1.55 .75", "1.7 .8", $"UI_HiddenSet");

                            UI.CreateButton(ref element, SetContentsPanel, UIColors["black"], $"<color=#F56201>{GetMSG("Permission", player, string.IsNullOrEmpty(info.permission).ToString())}</color>", 10, "1.55 .69", "1.7 .74", $"UI_Permission");

                            UI.CreateButton(ref element, SetContentsPanel, UIColors["black"], $"<color=#F56201>{GetMSG("ExitSetEditing", player)}</color>", 10, "1.55 .99", "1.7 1.04", $"UI_CancelSetCreation");
                        }
                    }
                    else
                    {
                            UI.CreateButton(ref element, SetContentsPanel, UIColors["black"], $"<color=#F56201>{GetMSG("CancelSet", player)}</color>", 10, "1.55 .99", "1.7 1.04", $"UI_CancelSetCreation");
                            UI.CreateButton(ref element, SetContentsPanel, "0 0 0 0", GetMSG("SaveSet"), 18, "1.01 0.04", "1.42 0.14", $"UI_SaveCollect");
                    }
                }
                else if (string.IsNullOrEmpty(CSUIInfo[player.userID].SelectedSet) && CSUIInfo[player.userID].admin)
                    UI.CreateButton(ref element, SetContentsPanel, UIColors["black"], $"<color=#F56201>{GetMSG("CreateSet", player)}</color>", 10, "1.55 .99", "1.7 1.04", $"UI_CreateGearSet");

                else if (!string.IsNullOrEmpty(CSUIInfo[player.userID].SelectedSet))
                {
                    var setname = CSUIInfo[player.userID].SelectedSet;
                    var money = 0;
                    if (ServerRewards && CheckPoints(player.userID) is int)
                        money = (int)CheckPoints(player.userID);
                    else if (Economics)
                        money = Convert.ToInt32(Economics.CallHook("GetPlayerMoney", player.userID));
                    if (string.IsNullOrEmpty(setname) || !csData.SavedSets.ContainsKey(setname)) return;
                    bool ready = true;
                    bool printed = false;
                    var set = csData.SavedSets[setname];
                    foreach (var entry in new Dictionary<string, List<Gear>> { { "belt", set.belt }, { "wear", set.wear }, { "main", set.main } })
                    {
                        GearEntries(player, element, entry.Value, entry.Key);
                    }
                    if ((set.cooldown != 0 || set.dailyUses != 0) && csData.PlayerData.ContainsKey(player.userID))
                    {
                        var data = csData.PlayerData[player.userID];
                        CoolandUse info = null;
                        data.cooldownANDuses.TryGetValue(setname, out info);
                        if (info != null)
                        {
                            printed = true;
                            if (info.CooldownExpiration < CurrentTotalMinutes()) info.CooldownExpiration = 0;
                            if (CurrentTotalMinutes() > info.FirstUse + (configData.UsesResetInterval_InHours * 60 * 60))
                            {
                                info.timesUsed = 0;
                                info.FirstUse = 0;
                            }
                            UI.CreateLabel(ref element, SetContentsPanel, UIColors["white"], GetMSG("DailyUses", player, set.dailyUses <= 0 ? GetMSG("Unlimited") : $"<color=red>{set.dailyUses - info.timesUsed}</color>/{set.dailyUses}"), 22, "1.03 0.86", "1.42 0.94", TextAnchor.MiddleLeft);
                            UI.CreateLabel(ref element, SetContentsPanel, UIColors["white"], GetMSG("Cooldown", player, set.cooldown <= 0 ? GetMSG("None", player) : info.CooldownExpiration != 0 ? "<color=red> -" + GetMinutesFormat(info.CooldownExpiration - CurrentTotalMinutes()) + "</color>" : GetMinutesFormat(set.cooldown).ToString()), 22, "1.03 0.78", "1.42 0.86", TextAnchor.MiddleLeft);

                            if (info.CooldownExpiration != 0 || set.dailyUses - info.timesUsed == 0) ready = false;
                        }
                    }
                    if (!printed)
                    {
                        UI.CreateLabel(ref element, SetContentsPanel, UIColors["white"], GetMSG("DailyUses", player, set.dailyUses <= 0 ? GetMSG("Unlimited") : $"<color=green>{set.dailyUses}</color>/{set.dailyUses}"), 22, "1.03 0.86", "1.42 0.94", TextAnchor.MiddleLeft);
                        UI.CreateLabel(ref element, SetContentsPanel, UIColors["white"], GetMSG("Cooldown", player, set.cooldown <= 0 ? GetMSG("None", player) : GetMinutesFormat(set.cooldown).ToString()), 22, "1.03 0.78", "1.42 0.86", TextAnchor.MiddleLeft);
                    }
                    if (string.IsNullOrEmpty(set.permission) || permission.UserHasPermission(player.UserIDString, this.Title + "." + set.permission.Replace(" ", string.Empty)))
                    {
                        if (ready)
                            UI.CreateButton(ref element, SetContentsPanel, "0 0 0 0", GetMSG("Redeem", player, setname.ToUpper()), 26, "1.01 0.04", "1.42 0.14", $"UI_ProcessSelection {setname}");
                    }
                    else if (configData.UsePayment)
                    {
                        if (money >= set.cost)
                        {
                            UI.CreateButton(ref element, SetContentsPanel, "0 0 0 0", GetMSG("UnlockSet", player, set.cost.ToString()), 22, "1.01 0.04", "1.42 0.14", $"UI_SetPurchase {setname}");
                        }
                        else
                            UI.CreateTextOutline(ref element, SetContentsPanel, UIColors["white"], UIColors["black"], GetMSG("CostOFSet", player, set.cost.ToString()), 24, "1.01 0.04", "1.42 0.14");
                    }
                    if (CSUIInfo[player.userID].admin)
                    {
                        if (!NewSet.ContainsKey(player.userID) || (NewSet[player.userID].Editing && NewSet[player.userID].setname != CSUIInfo[player.userID].SelectedSet))
                        {
                            UI.CreateButton(ref element, SetContentsPanel, UIColors["black"], $"<color=#F56201>{GetMSG("CreateSet", player)}</color>", 10, "1.55 .99", "1.7 1.04", $"UI_CreateGearSet");
                            UI.CreateButton(ref element, SetContentsPanel, UIColors["black"], $"<color=#F56201>{GetMSG("Edit", player)}</color>", 14, "1.55 0.93", "1.7 0.98", $"UI_EditGearSet");
                            UI.CreateButton(ref element, SetContentsPanel, UIColors["black"], $"<color=#F56201>{GetMSG("Delete", player)}</color>", 14, "1.55 0.87", "1.7 0.92", $"UI_DeleteGearSet");
                        }
                    }
                }
            }
            CuiHelper.AddUi(player, element);
            InspectorPanel(player);
        }

        private void GearEntries(BasePlayer player, CuiElementContainer element, List<Gear> list, string location)
        {
            float[] pos;
            var i = 0;
            foreach (var item in list)
            {
                pos = MainLocation(i);
                if (location == "belt") pos = BeltLocation(i);
                if (location == "wear") pos = WearLocation(i);
                UI.LoadImage(ref element, SetContentsPanel, TryForImage(item.shortname, item.skin), $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                if (item.attachments != null && item.attachments.Count > 0)
                    UI.LoadImage(ref element, SetContentsPanel, TryForImage("CS_AttachmentOverlay"), $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                UI.CreateButton(ref element, SetContentsPanel, "0 0 0 0", "", 16, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_ChangeSelection {i} {location}", TextAnchor.MiddleCenter);
                i++;
            }
        }
        private void InspectorPanel(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, PanelInspector);
            if (!CSUIInfo.ContainsKey(player.userID)) return;
            CuiElementContainer element = null;
            var i = 0;
            var money = 0;
            if (ServerRewards && CheckPoints(player.userID) is int)
                money = (int)CheckPoints(player.userID);
            else if (Economics)
                money = Convert.ToInt32(Economics.CallHook("GetPlayerMoney", player.userID));
            string set;
            element = UI.CreateOverlayContainer(PanelInspector, "0 0 0 0", "0.705 0.2", "0.86 0.68");
            UI.CreateTextOutline(ref element, PanelInspector, UIColors["white"], UIColors["black"], GetMSG("ITEM", player), 22, "0 0.91", "1 .99");
            if (CSUIInfo[player.userID].InspectedGear != -1 && !string.IsNullOrEmpty(CSUIInfo[player.userID].location))
                if (NewSet.ContainsKey(player.userID) && CSUIInfo[player.userID].admin)
                {
                    var cont = NewSet[player.userID].set.main;
                    if (CSUIInfo[player.userID].location == "belt")
                        cont = NewSet[player.userID].set.belt;
                    else if (CSUIInfo[player.userID].location == "wear")
                        cont = NewSet[player.userID].set.wear;
                    if (cont[CSUIInfo[player.userID].InspectedGear] == null) return;
                    var item = cont[CSUIInfo[player.userID].InspectedGear];
                    UI.LoadImage(ref element, PanelInspector, TryForImage(item.shortname, item.skin), $".05 .24", $".95 .76");
                    if (item.attachments.Count == 0 || string.IsNullOrEmpty(CSUIInfo[player.userID].InspectedAttachment))
                    {
                        UI.CreateTextOutline(ref element, PanelInspector, UIColors["white"], UIColors["black"], item.displayName, 18, "0 0.81", "1 .89");
                        if (ItemSkins.ContainsKey(item.shortname) && ItemSkins[item.shortname].Count() > 1)
                            UI.CreateButton(ref element, PanelInspector, UIColors["black"], $"<color=#F56201>{GetMSG("SetSkin", player)}</color>", 12, $".27 .77", $".73 .81", $"UI_AddItemAttributes");
                    }
                    if (item.attachments.Count > 0)
                    {
                        UI.CreateTextOutline(ref element, PanelInspector, UIColors["white"], UIColors["black"], GetMSG("ATTACHMENTS"), 16, "0 0.15", "1 .21", TextAnchor.UpperCenter);
                        foreach (var entry in item.attachments)
                        {
                            var pos = AttachmentInspectorPos(i);
                            UI.LoadImage(ref element, PanelInspector, TryForImage(entry, 0), $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                            if (CSUIInfo[player.userID].InspectedAttachment == entry)
                            {
                                UI.CreateTextOutline(ref element, PanelInspector, UIColors["white"], UIColors["black"], GetDisplayNameFromSN(entry), 18, "0 0.81", "1 .89");
                                UI.CreateButton(ref element, PanelInspector, "0 0 0 0", "", 12, $".08 .3", $".92 .8", $"UI_ChangeSelection clear");
                            }
                            else
                                UI.CreateButton(ref element, PanelInspector, "0 0 0 0", "", 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_ChangeSelection {entry}");
                            i++;
                        }
                    }
                    UI.LoadImage(ref element, PanelInspector, TryForImage("CS_Remove"), "0.85 0.83", ".97 .91");
                    UI.CreateButton(ref element, PanelInspector, "0 0 0 0", "", 12, "0.85 0.83", ".97 .91", $"UI_RemoveItem");
                }
                else
                {
                    set = CSUIInfo[player.userID].SelectedSet;
                    var cont = csData.SavedSets[set].main;
                    if (CSUIInfo[player.userID].location == "belt")
                        cont = csData.SavedSets[set].belt;
                    else if (CSUIInfo[player.userID].location == "wear")
                        cont = csData.SavedSets[set].wear;

                    if (cont[CSUIInfo[player.userID].InspectedGear] == null) return;
                    var item = cont[CSUIInfo[player.userID].InspectedGear];
                    if (item == null) { CuiHelper.AddUi(player, element); return; }
                    UI.LoadImage(ref element, PanelInspector, TryForImage(item.shortname, item.skin), $".05 .24", $".95 .76");
                    if (item.attachments.Count == 0 || string.IsNullOrEmpty(CSUIInfo[player.userID].InspectedAttachment))
                        UI.CreateTextOutline(ref element, PanelInspector, UIColors["white"], UIColors["black"], item.displayName, 18, "0 0.81", "1 .89");
                    if (item.attachments.Count > 0)
                    {
                        UI.CreateTextOutline(ref element, PanelInspector, UIColors["white"], UIColors["black"], GetMSG("ATTACHMENTS"), 16, "0 0.15", "1 .21", TextAnchor.UpperCenter);
                        foreach (var entry in item.attachments)
                        {
                            var pos = AttachmentInspectorPos(i);
                            UI.LoadImage(ref element, PanelInspector, TryForImage(entry, 0), $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}");
                            if (CSUIInfo[player.userID].InspectedAttachment == entry)
                            {
                                UI.CreateTextOutline(ref element, PanelInspector, UIColors["white"], UIColors["black"], GetDisplayNameFromSN(entry), 18, "0 0.81", "1 .89");
                                UI.CreateButton(ref element, PanelInspector, "0 0 0 0", "", 12, $".08 .3", $".92 .8", $"UI_ChangeSelection clear");
                            }
                            else
                                UI.CreateButton(ref element, PanelInspector, "0 0 0 0", "", 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_ChangeSelection {entry}");
                            i++;
                        }
                    }
                }
            CuiHelper.AddUi(player, element);
        }


        string GetDisplayNameFromSN(string shortname)
        {
            ItemDefinition def = ItemManager.FindItemDefinition(shortname);
            if (def != null)
                return def.displayName.english;
            else return shortname;
        }


        void OnScreen(BasePlayer player, string msg)
        {
            if (timers.ContainsKey(player.userID.ToString()))
            {
                timers[player.userID.ToString()].Destroy();
                timers.Remove(player.userID.ToString());
            }
            CuiHelper.DestroyUi(player, PanelOnScreen);
            var element = UI.CreateOverlayContainer(PanelOnScreen, "0.0 0.0 0.0 0.0", "0.3 0.35", "0.7 0.65", false);
            UI.LoadImage(ref element, PanelOnScreen, TryForImage("CS_SmallBackground"), "0 0", "1 1");
            UI.CreateTextOutline(ref element, PanelOnScreen, UIColors["white"], UIColors["black"], msg, 32, "0.0 0.0", "1.0 1.0");
            CuiHelper.AddUi(player, element);
            timers.Add(player.userID.ToString(), timer.Once(3, () => CuiHelper.DestroyUi(player, PanelOnScreen)));
        }

        private void SelectIfFree(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, PanelMisc);
            var element = UI.CreateOverlayContainer(PanelMisc, "0 0 0 0", "0.4 0.3", "0.6 0.6");
            UI.LoadImage(ref element, PanelMisc, TryForImage("CS_SmallBackground"), "0 0", "1 1");
            UI.CreateLabel(ref element, PanelMisc, UIColors["white"], GetMSG("UnlockSetFree"), 16, "0.1 0.5", "0.9 .98");
            UI.CreateButton(ref element, PanelMisc, UIColors["buttongreen"], "Yes", 18, "0.2 0.08", "0.475 0.28", $"UI_Free true");
            UI.CreateButton(ref element, PanelMisc, UIColors["buttonred"], "No", 18, "0.525 0.08", "0.8 0.28", $"UI_Free false");
            CuiHelper.AddUi(player, element);
        }

        private void SelectIfPermission(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, PanelMisc);
            var element = UI.CreateOverlayContainer(PanelMisc, "0 0 0 0", "0.4 0.3", "0.6 0.6");
            UI.LoadImage(ref element, PanelMisc, TryForImage("CS_SmallBackground"), "0 0", "1 1");
            UI.CreateLabel(ref element, PanelMisc, UIColors["white"], GetMSG("UseAPermission"), 16, "0.1 0.5", "0.9 .98");
            UI.CreateButton(ref element, PanelMisc, UIColors["black"], $"<color=#F56201>{GetMSG("Yes", player)}</color>", 18, "0.2 0.08", "0.475 0.28", $"UI_Permission true");
            UI.CreateButton(ref element, PanelMisc, UIColors["black"], $"<color=#F56201>{GetMSG("No", player)}</color>", 18, "0.525 0.08", "0.8 0.28", $"UI_Permission false");
            CuiHelper.AddUi(player, element);
        }

        private void SelectIfHidden(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, PanelMisc);
            var element = UI.CreateOverlayContainer(PanelMisc, "0 0 0 0", "0.4 0.3", "0.6 0.6");
            UI.LoadImage(ref element, PanelMisc, TryForImage("CS_SmallBackground"), "0 0", "1 1");
            UI.CreateLabel(ref element, PanelMisc, UIColors["white"], GetMSG("HiddenSet"), 16, "0.1 0.5", "0.9 .98");
            UI.CreateButton(ref element, PanelMisc, UIColors["black"], $"<color=#F56201>{GetMSG("Yes", player)}</color>", 18, "0.2 0.08", "0.475 0.28", $"UI_HiddenSet true");
            UI.CreateButton(ref element, PanelMisc, UIColors["black"], $"<color=#F56201>{GetMSG("No", player)}</color>", 18, "0.525 0.08", "0.8 0.28", $"UI_HiddenSet false");
            CuiHelper.AddUi(player, element);
        }

        private void NumberPad(BasePlayer player, string cmd, string title, bool small = false)
        {
            CuiHelper.DestroyUi(player, PanelMisc);
            var element = UI.CreateOverlayContainer(PanelMisc, "0 0 0 0", "0.35 0.3", "0.65 0.7");
            UI.LoadImage(ref element, PanelMisc, TryForImage("CS_SmallBackground"), "0 0", "1 1");
            UI.CreateLabel(ref element, PanelMisc, UIColors["white"], GetMSG(title, player), 16, "0.1 0.86", "0.9 .99", TextAnchor.UpperCenter);
            var n = 1;
            var i = 0;
            if (small)
            {
                n = 0;
                while (n < 15)
                {
                    CreateNumberPadButton(ref element, PanelMisc, i, n, cmd); i++; n++;
                }
                while (n >= 15 && n < 90)
                {
                    CreateNumberPadButton(ref element, PanelMisc, i, n, cmd); i++; n += 15;
                }
                while (n >= 90 && n < 720)
                {
                    CreateNumberPadButton(ref element, PanelMisc, i, n, cmd); i++; n += 30;
                }
                while (n >= 720 && n <= 1440)
                {
                    CreateNumberPadButton(ref element, PanelMisc, i, n, cmd); i++; n += 60;
                }
            }
            else
            {
                UI.CreateButton(ref element, PanelMisc, UIColors["black"], $"<color=#F56201>{GetMSG("Free", player)}</color>", 12, "0.3 0.04", "0.7 .12", $"{cmd} {0}");
                while (n < 10)
                {
                    CreateNumberPadButton(ref element, PanelMisc, i, n, cmd); i++; n++;
                }
                while (n >= 10 && n < 25)
                {
                    CreateNumberPadButton(ref element, PanelMisc, i, n, cmd); i++; n += 5;
                }
                while (n >= 25 && n < 200)
                {
                    CreateNumberPadButton(ref element, PanelMisc, i, n, cmd); i++; n += 25;
                }
                while (n >= 200 && n <= 950)
                {
                    CreateNumberPadButton(ref element, PanelMisc, i, n, cmd); i++; n += 50;
                }
                while (n >= 1000 && n <= 10000)
                {
                    CreateNumberPadButton(ref element, PanelMisc, i, n, cmd); i++; n += 500;
                }
            }
            CuiHelper.AddUi(player, element);
        }

        private void CreateNumberPadButton(ref CuiElementContainer container, string panelName, int i, int number, string command)
        {
            var pos = CalcNumButtonPos(i);
            UI.CreateButton(ref container, panelName, UIColors["black"], $"<color=#F56201>{number.ToString()}</color>", 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"{command} {number}");
        }

        private float[] WearLocation(int number)
        {
            Vector2 position = new Vector2(0.015f, 0.825f);
            Vector2 dimensions = new Vector2(0.15f, 0.12f);
            float offsetY = 0;
            float offsetX = 0;
            offsetX = (0.01f + dimensions.x) * number;
            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }

        private float[] BeltLocation(int number)
        {
            Vector2 position = new Vector2(0.015f, 0.625f);
            Vector2 dimensions = new Vector2(0.15f, 0.12f);
            float offsetY = 0;
            float offsetX = 0;
            offsetX = (0.01f + dimensions.x) * number;
            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }

        private float[] MainLocation(int number)
        {
            Vector2 position = new Vector2(0.015f, 0.425f);
            Vector2 dimensions = new Vector2(0.15f, 0.12f);
            float offsetY = 0;
            float offsetX = 0;
            if (number >= 0 && number < 6)
            {
                offsetX = (0.01f + dimensions.x) * number;
            }
            if (number > 5 && number < 12)
            {
                offsetX = (0.01f + dimensions.x) * (number - 6);
                offsetY = (-0.011f - dimensions.y) * 1;
            }
            if (number > 11 && number < 18)
            {
                offsetX = (0.01f + dimensions.x) * (number - 12);
                offsetY = (-0.012f - dimensions.y) * 2;
            }
            if (number > 17 && number < 24)
            {
                offsetX = (0.01f + dimensions.x) * (number - 18);
                offsetY = (-0.013f - dimensions.y) * 3;
            }
            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }

        private float[] AttachmentInspectorPos(int number)
        {
            Vector2 position = new Vector2(0.07f, 0.02f);
            Vector2 dimensions = new Vector2(0.25f, 0.13f);
            float offsetY = 0;
            float offsetX = 0;
            offsetX = (0.05f + dimensions.x) * number;
            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }

        private float[] AttachmentMainScreenPos(Vector2 min, int number)
        {
            Vector2 position = min;
            Vector2 dimensions = new Vector2(0.0325f, 0.04f);
            float offsetY = 0;
            float offsetX = 0;
            offsetX = (0.005f + dimensions.x) * number;
            if (number == 2)
            {
                offsetX = (0.02f);
                offsetY = (-0.005f - dimensions.y);
            }
            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }

        private float[] CalcButtonPos(int number)
        {
            Vector2 position = new Vector2(0.03f, 0.75f);
            Vector2 dimensions = new Vector2(0.15f, 0.15f);
            float offsetY = 0;
            float offsetX = 0;
            if (number >= 0 && number < 6)
            {
                offsetX = (0.01f + dimensions.x) * number;
            }
            if (number > 5 && number < 12)
            {
                offsetX = (0.01f + dimensions.x) * (number - 6);
                offsetY = (-0.002f - dimensions.y) * 1;
            }
            if (number > 11 && number < 18)
            {
                offsetX = (0.01f + dimensions.x) * (number - 12);
                offsetY = (-0.002f - dimensions.y) * 2;
            }
            if (number > 17 && number < 24)
            {
                offsetX = (0.01f + dimensions.x) * (number - 18);
                offsetY = (-0.002f - dimensions.y) * 3;
            }
            if (number > 23 && number < 30)
            {
                offsetX = (0.01f + dimensions.x) * (number - 24);
                offsetY = (-0.002f - dimensions.y) * 4;
            }
            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }

        private float[] CalcNumButtonPos(int number)
        {
            Vector2 position = new Vector2(0.05f, 0.75f);
            Vector2 dimensions = new Vector2(0.09f, 0.10f);
            float offsetY = 0;
            float offsetX = 0;
            if (number >= 0 && number < 9)
            {
                offsetX = (0.01f + dimensions.x) * number;
            }
            if (number > 8 && number < 18)
            {
                offsetX = (0.01f + dimensions.x) * (number - 9);
                offsetY = (-0.02f - dimensions.y) * 1;
            }
            if (number > 17 && number < 27)
            {
                offsetX = (0.01f + dimensions.x) * (number - 18);
                offsetY = (-0.02f - dimensions.y) * 2;
            }
            if (number > 26 && number < 36)
            {
                offsetX = (0.01f + dimensions.x) * (number - 27);
                offsetY = (-0.02f - dimensions.y) * 3;
            }
            if (number > 35 && number < 45)
            {
                offsetX = (0.01f + dimensions.x) * (number - 36);
                offsetY = (-0.02f - dimensions.y) * 4;
            }
            if (number > 44 && number < 54)
            {
                offsetX = (0.01f + dimensions.x) * (number - 45);
                offsetY = (-0.02f - dimensions.y) * 5;
            }
            Vector2 offset = new Vector2(offsetX, offsetY);
            Vector2 posMin = position + offset;
            Vector2 posMax = posMin + dimensions;
            return new float[] { posMin.x, posMin.y, posMax.x, posMax.y };
        }






        [ConsoleCommand("UI_AddItemAttributes")]
        private void cmdUI_AddGearAttributes(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (!NewSet.ContainsKey(player.userID)) return;
            SelectSkin(player);
        }

        [ConsoleCommand("UI_RemoveItem")]
        private void cmdUI_RemoveItem(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            var item = CSUIInfo[player.userID].InspectedGear;
            var cont = NewSet[player.userID].set.main;
            if (CSUIInfo[player.userID].location == "belt")
                cont = NewSet[player.userID].set.belt;
            else if (CSUIInfo[player.userID].location == "wear")
                cont = NewSet[player.userID].set.wear;

            if (string.IsNullOrEmpty(CSUIInfo[player.userID].InspectedAttachment))
            {
                cont.Remove(cont[item]);
                CSUIInfo[player.userID].InspectedGear = -1;
                CSUIInfo[player.userID].InspectedAttachment = string.Empty;
            }
            else
            {
                cont[item].attachments.Remove(CSUIInfo[player.userID].InspectedAttachment);
                CSUIInfo[player.userID].InspectedAttachment = string.Empty;
            }
            SetPanel(player);
        }

        [ConsoleCommand("UI_ChangeSkinPage")]
        private void cmdUI_ChangeSkinPage(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (!NewSet.ContainsKey(player.userID)) return;
            CSUIInfo[player.userID].page = Convert.ToInt32(arg.Args[0]);
            SelectSkin(player);
        }

        private void SelectSkin(BasePlayer player)
        {
            Gear item = null;
            if (CSUIInfo[player.userID].location == "main")
                item = NewSet[player.userID].set.main[CSUIInfo[player.userID].InspectedGear];
            if (CSUIInfo[player.userID].location == "belt")
                item = NewSet[player.userID].set.belt[CSUIInfo[player.userID].InspectedGear];
            else if (CSUIInfo[player.userID].location == "wear")
                item = NewSet[player.userID].set.wear[CSUIInfo[player.userID].InspectedGear];
            if (ItemSkins.ContainsKey(item.shortname) && ItemSkins[item.shortname].Count() > 1)
            {
                CuiHelper.DestroyUi(player, PanelMisc);
                var element = UI.CreateOverlayContainer(PanelMisc, "0 0 0 0", "0.3 0.2", "0.7 0.8");
                UI.LoadImage(ref element, PanelMisc, TryForImage("CS_SmallBackground"), "0 0", "1 1");
                UI.CreateLabel(ref element, PanelMisc, UIColors["white"], GetMSG("SkinTitle", player, item.displayName), 20, "0 .92", "1 1");
                var page = CSUIInfo[player.userID].page;
                var skinlist = ItemSkins[item.shortname];
                int entriesallowed = 30;
                int remainingentries = skinlist.Count - (page * entriesallowed);
                {
                    if (remainingentries > entriesallowed)
                    {
                        UI.CreateButton(ref element, PanelMisc, UIColors["black"], $"<color=#F56201>{GetMSG("Next", player)}</color>", 18, "0.83 0.08", "0.93 0.13", $"UI_ChangeSkinPage {page + 1}");
                    }
                    if (page > 0)
                    {
                        UI.CreateButton(ref element, PanelMisc, UIColors["black"], $"<color=#F56201>{GetMSG("Back", player)}</color>", 18, "0.72 0.08", "0.82 0.13", $"UI_ChangeSkinPage {page - 1}");
                    }
                }
                int shownentries = page * entriesallowed;
                int i = 0;
                int n = 0;
                foreach (var entry in skinlist.Where(k => k != item.skin))
                {
                    i++;
                    if (i < shownentries + 1) continue;
                    else if (i <= shownentries + entriesallowed)
                    {
                        {
                            var pos = CalcButtonPos(n);
                            UI.LoadImage(ref element, PanelMisc, TryForImage(item.shortname, entry), $"{pos[0] + 0.005f} {pos[1] + 0.005f}", $"{pos[2] - 0.005f} {pos[3] - 0.005f}");
                            UI.CreateButton(ref element, PanelMisc, "0 0 0 0", "", 12, $"{pos[0]} {pos[1]}", $"{pos[2]} {pos[3]}", $"UI_SelectSkin {entry}");
                            n++;
                        }
                    }
                    if (n >= entriesallowed)
                        break;
                }
                CuiHelper.AddUi(player, element);
            }
            else
            {
                item.skin = 0;
                SetPanel(player);
            }
        }

        [ConsoleCommand("UI_SetCost")]
        private void cmdUI_SetCollectionCost(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            int cost = Convert.ToInt32(arg.Args[0]);
            NewSet[player.userID].set.cost = cost;
            if (NewSet[player.userID].Editing)
                SetPanel(player);
            else
            {
                NumberPad(player, "UI_SetCooldown", "SetCooldown", true);
            }
        }

        [ConsoleCommand("UI_SetCooldown")]
        private void cmdUI_SetCooldown(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            int amount = Convert.ToInt32(arg.Args[0]);
            NewSet[player.userID].set.cooldown = amount;
            if (NewSet[player.userID].Editing)
                SetPanel(player);
            else
                NumberPad(player, "UI_SetDailyUses", "SetMaxDailyUses", true);
        }

        [ConsoleCommand("UI_SetDailyUses")]
        private void cmdUI_SetDailyUses(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            int amount = Convert.ToInt32(arg.Args[0]);
            NewSet[player.userID].set.dailyUses = amount;
            if (NewSet[player.userID].Editing)
                SetPanel(player);
            else
                SetCollectionName(player);
        }

        void SetCollectionName(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, BackgroundPanel);
            CuiHelper.DestroyUi(player, PanelMisc);
            DestroySetPanels(player);
            var element = UI.CreateOverlayContainer(PanelMisc, "0 0 0 0", "0.4 0.3", "0.6 0.6");
            UI.LoadImage(ref element, PanelMisc, TryForImage("CS_SmallBackground"), "0 0", "1 1");
            UI.CreateLabel(ref element, PanelMisc, UIColors["white"], GetMSG("SetName"), 16, "0.1 0.5", "0.9 .98");
            CuiHelper.AddUi(player, element);
        }

        [ConsoleCommand("UI_EditSetCost")]
        private void cmdUI_EditSetCost(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (NewSet[player.userID].Editing)
                NumberPad(player, "UI_SetCost", "SetCost");
        }

        [ConsoleCommand("UI_EditSetUses")]
        private void cmdUI_EditSetUses(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (NewSet[player.userID].Editing)
                NumberPad(player, "UI_SetDailyUses", "SetMaxDailyUses", true);
        }

        [ConsoleCommand("UI_EditSetCooldown")]
        private void cmdUI_EditSetCooldown(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (NewSet[player.userID].Editing)
                NumberPad(player, "UI_SetCooldown", "SetCooldown", true);
        }



        [ConsoleCommand("UI_Permission")]
        private void cmdUI_Permission(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (NewSet[player.userID].Editing)
            {
                if (string.IsNullOrEmpty(NewSet[player.userID].set.permission))
                    NewSet[player.userID].set.permission = NewSet[player.userID].setname.Replace(" ", string.Empty);
                else
                    NewSet[player.userID].set.permission = string.Empty;
                SetPanel(player);
                OnScreen(player, GetMSG("SettingChangedTo", player, (string.IsNullOrEmpty(NewSet[player.userID].set.permission).ToString().ToUpper())));
            }
            else
            {
                if (arg.Args[0] == "true")
                {
                    NewSet[player.userID].UsePermission = true;
                }
                else
                    NewSet[player.userID].UsePermission = false;
                SelectIfHidden(player);
            }
        }


        [ConsoleCommand("UI_HiddenSet")]
        private void cmdUI_HiddenSet(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (NewSet[player.userID].Editing)
            {
                if (NewSet[player.userID].set.hidden)
                    NewSet[player.userID].set.hidden = false;
                else
                    NewSet[player.userID].set.hidden = true;
                SetPanel(player);
                OnScreen(player, GetMSG("SettingChangedTo", player, NewSet[player.userID].set.hidden.ToString().ToUpper()));
            }
            else
            {
                if (arg.Args[0] == "true")
                    NewSet[player.userID].set.hidden = true;
                else
                {
                    NewSet[player.userID].set.hidden = false;
                    if (configData.UsePayment && NewSet[player.userID].UsePermission)
                    {
                        NumberPad(player, "UI_SetCost", "SetCost");
                        return;
                    }
                }
                NumberPad(player, "UI_SetCooldown", "SetCooldown", true);
            }
        }



        [ConsoleCommand("UI_ChangeCategory")]
        private void cmdUI_ChangeCategory(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            var cat = string.Join(" ", arg.Args);
            if (cat == "BACK")
            {
                CSUIInfo[player.userID].SelectedCategory = string.Empty;
                CSUIInfo[player.userID].SelectedSet = string.Empty;
            }
            else
            {
                CSUIInfo[player.userID].SelectedCategory = cat;
                CSUIInfo[player.userID].SetIndex = 0;
            }
            SetListPanel(player);
            if (CSUIInfo[player.userID].admin)
                SetPanel(player);
        }


        [ConsoleCommand("UI_ChangeSet")]
        private void cmdUI_ChangeGearSet(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            var set = string.Join(" ", arg.Args);
            CSUIInfo[player.userID].SelectedSet = set;
            CSUIInfo[player.userID].InspectedGear = -1;
            CSUIInfo[player.userID].InspectedAttachment = string.Empty;
            CuiHelper.DestroyUi(player, PanelMisc);
            CuiHelper.DestroyUi(player, PanelInspector);
            SetListPanel(player);
            SetPanel(player);
        }

        [ConsoleCommand("UI_ChangeSelection")]
        private void cmdUI_ChangeSelection(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            int item;
            if (!int.TryParse(arg.Args[0], out item))
            {
                if (arg.Args[0] == "clear")
                {
                    CSUIInfo[player.userID].InspectedAttachment = string.Empty;
                    InspectorPanel(player);
                    return;
                }
                CSUIInfo[player.userID].InspectedAttachment = arg.Args[0];
                InspectorPanel(player);
                return;
            }
            else
            {
                CSUIInfo[player.userID].location = arg.Args[1];
                CSUIInfo[player.userID].InspectedGear = item;
                CSUIInfo[player.userID].InspectedAttachment = string.Empty;
            }
            InspectorPanel(player);
        }

        [ConsoleCommand("UI_SwitchAdminView")]
        private void cmdUI_SwitchAdminView(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (!isAuth(player))
            {
                GetSendMSG(player, "NotAuthorized");
                return;
            }
            if (CSUIInfo[player.userID].admin)
            {
                CSUIInfo[player.userID].admin = false;
                CSUIInfo[player.userID].SetIndex = 0;
            }
            else
            {
                CSUIInfo[player.userID].admin = true;
                CSUIInfo[player.userID].SetIndex = 0;
            }
            UIPanel(player);
            if (!CSUIInfo[player.userID].admin)
                OnScreen(player, GetMSG("ExitAdminView", player));
            else
                OnScreen(player, GetMSG("EnterAdminView", player));
        }

        [ConsoleCommand("UI_CategoryIndexShownChange")]
        private void cmdUI_CategoryIndexShownChange(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            var index = Convert.ToInt32(arg.Args[0]);
            CSUIInfo[player.userID].CategoryIndex = index;
            SetListPanel(player);
        }

        [ConsoleCommand("UI_GearIndexShownChange")]
        private void cmdUI_GearIndexShownChange(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            var index = Convert.ToInt32(arg.Args[0]);
            CSUIInfo[player.userID].SetIndex = index;
            SetListPanel(player);
        }

        [ConsoleCommand("UI_DestroyPurchaseConfirmation")]
        private void cmdUI_DestroyPurchaseConfirmation(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            CuiHelper.DestroyUi(player, PanelMisc);
        }

        [ConsoleCommand("UI_ProcessSelection")]
        private void cmdUI_ProcessSelection(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            var set = string.Join(" ", arg.Args);
            if (!csData.SavedSets.ContainsKey(set)) return;
            ProcessSelection(player, set);
        }

        [ConsoleCommand("UI_SetPurchase")]
        private void cmdUI_SetPurchase(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            var setname = string.Join(" ", arg.Args);
            var set = csData.SavedSets[setname];
            CuiHelper.DestroyUi(player, PanelMisc);
            var element = UI.CreateOverlayContainer(PanelMisc, "0 0 0 0", "0.4 0.3", "0.6 0.6");
            UI.LoadImage(ref element, PanelMisc, TryForImage("CS_SmallBackground"), "0 0", "1 1");
            UI.CreateTextOutline(ref element, PanelMisc, UIColors["white"], UIColors["black"], GetMSG("PurchaseSetInfo", player, setname, set.cost.ToString()), 18, "0.1 0.3", "0.9 0.89");
            UI.CreateButton(ref element, PanelMisc, UIColors["black"], $"<color=#F56201>{GetMSG("Yes", player)}</color>", 18, "0.2 0.08", "0.475 0.28", $"UI_ExecutePurchase {setname}");
            UI.CreateButton(ref element, PanelMisc, UIColors["black"], $"<color=#F56201>{GetMSG("No", player)}</color>", 18, "0.525 0.08", "0.8 0.28", $"UI_DestroyPurchaseConfirmation");
            CuiHelper.AddUi(player, element);
        }

        [ConsoleCommand("UI_ExecutePurchase")]
        private void cmdUI_ExecutePurchase(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            var set = string.Join(" ", arg.Args);
            if (ServerRewards)
                SRAction(player.userID, csData.SavedSets[set].cost, "REMOVE");
            else if (Economics)
                ECOAction(player.userID, csData.SavedSets[set].cost, "REMOVE");
            else
            {
                GetSendMSG(player, "UnableToPurchase_Payment");
                CuiHelper.DestroyUi(player, PanelMisc);
                return;
            }
            permission.GrantUserPermission(player.UserIDString, this.Title + "." + csData.SavedSets[set].permission.Replace(" ", string.Empty), null);
            DestroySetPanels(player);
            CuiHelper.DestroyUi(player, PanelMisc);
            SetPanel(player);
            OnScreen(player, GetMSG("purchaseset", player, set));
        }

        [ConsoleCommand("UI_SaveCollect")]
        private void cmdUI_SaveCollect(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            if (NewSet[player.userID].Editing)
            {
                SaveCollection(player);
                return;
            }
            if (!SavingCollection.Contains(player.userID))
                SavingCollection.Add(player.userID);
            SelectIfPermission(player);
        }

        [ConsoleCommand("UI_CreateGearSet")]
        private void cmdUI_CreateGearSet(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null || !isAuth(player)) return;
            CreateGearSet(player);
        }

        [ConsoleCommand("UI_EditGearSet")]
        private void cmdUI_EditGearSet(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null || !isAuth(player) || !CSUIInfo.ContainsKey(player.userID)) return;
            var existingSet = csData.SavedSets[CSUIInfo[player.userID].SelectedSet];
            if (NewSet.ContainsKey(player.userID))
                NewSet.Remove(player.userID);
            NewSet.Add(player.userID, new SetCreation { setname = CSUIInfo[player.userID].SelectedSet, set = existingSet, Editing = true });
            SetPanel(player);
        }

        [ConsoleCommand("UI_CancelSetCreation")]
        private void cmdUI_CancelGearSet(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null) return;
            if (NewSet.ContainsKey(player.userID))
                NewSet.Remove(player.userID);
            SetPanel(player);
        }

        [ConsoleCommand("UI_DeleteGearSet")]
        private void cmdUI_DeleteGearSet(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            var set = CSUIInfo[player.userID].SelectedSet;
            if (csData.SavedSets.ContainsKey(set))
            {
                csData.SavedSets.Remove(set);
                foreach (var entry in CSUIInfo)
                {
                    if (entry.Value.SelectedSet == set)
                        entry.Value.SelectedSet = "";
                }
                foreach (BasePlayer p in BasePlayer.activePlayerList.Where(p => p != player))
                {
                    if (CSUIInfo[player.userID].open)
                        ToggleCSUI(p);
                }
                SaveData();
            }
            ToggleCSUI(player);
        }

        [ConsoleCommand("UI_SelectSkin")]
        private void cmdUI_SelectSkin(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            if (player == null)
                return;
            ulong skin;
            if (!ulong.TryParse(arg.Args[0], out skin)) skin = 0;
            if (CSUIInfo[player.userID].location == "main")
                NewSet[player.userID].set.main[CSUIInfo[player.userID].InspectedGear].skin = skin;
            else if (CSUIInfo[player.userID].location == "belt")
                NewSet[player.userID].set.belt[CSUIInfo[player.userID].InspectedGear].skin = skin;
            else if (CSUIInfo[player.userID].location == "wear")
                NewSet[player.userID].set.wear[CSUIInfo[player.userID].InspectedGear].skin = skin;
            CSUIInfo[player.userID].page = 0;
            SetPanel(player);
        }


        private void ProcessSelection(BasePlayer player, string name)
        {
            var SetData = csData.SavedSets[name];
            int totalcount = SetData.belt.Count() + SetData.wear.Count() + SetData.main.Count();
            if ((player.inventory.containerBelt.capacity - player.inventory.containerBelt.itemList.Count) < SetData.belt.Count() || (player.inventory.containerWear.capacity - player.inventory.containerWear.itemList.Count) < SetData.wear.Count() || (player.inventory.containerMain.capacity - player.inventory.containerMain.itemList.Count) < SetData.main.Count())
                if (totalcount > (player.inventory.containerMain.capacity - player.inventory.containerMain.itemList.Count))
                {
                    OnScreen(player, "NoInventorySpace");
                    return;
                }
            CuiHelper.DestroyUi(player, BackgroundPanel);
            DestroySetPanels(player);
            if (!csData.PlayerData.ContainsKey(player.userID))
                csData.PlayerData.Add(player.userID, new PlayerSetData());
            if (csData.SavedSets[name].cooldown > 0)
            {
                if (!csData.PlayerData[player.userID].cooldownANDuses.ContainsKey(name))
                    csData.PlayerData[player.userID].cooldownANDuses.Add(name, new CoolandUse());
                csData.PlayerData[player.userID].cooldownANDuses[name].CooldownExpiration = CurrentTotalMinutes() + csData.SavedSets[name].cooldown;
            }
            if (csData.SavedSets[name].dailyUses > 0)
            {
                if (!csData.PlayerData[player.userID].cooldownANDuses.ContainsKey(name))
                    csData.PlayerData[player.userID].cooldownANDuses.Add(name, new CoolandUse());
                csData.PlayerData[player.userID].cooldownANDuses[name].timesUsed++;
                if (csData.PlayerData[player.userID].cooldownANDuses[name].FirstUse == 0)
                    csData.PlayerData[player.userID].cooldownANDuses[name].FirstUse = CurrentTotalMinutes();
            }
            OnScreen(player, GetMSG("GivenSet", player, name));
            GiveGearSet(player, name);
        }

        private void GiveGearSet(BasePlayer player, string setname)
        {
            var set = csData.SavedSets[setname];
            foreach (var item in set.main)
            {
                var gear = BuildSet(item);
                gear.MoveToContainer(player.inventory.containerMain);
            }
            foreach (var item in set.wear)
            {
                var gear = BuildSet(item);
                gear.MoveToContainer(player.inventory.containerWear);
            }
            foreach (var item in set.belt)
            {
                var gear = BuildSet(item);
                int index = -1;
                index = player.inventory.containerBelt.itemList.FindIndex(k => k.position == item.position);
                if (index != -1)
                    player.inventory.containerBelt.itemList[index].MoveToContainer(player.inventory.containerMain);
                gear.MoveToContainer(player.inventory.containerBelt, item.position, false);
            }
        }

        private Item BuildSet(Gear gear)
        {
            var definition = ItemManager.FindItemDefinition(gear.shortname);
            if (definition != null)
            {
                var item = ItemManager.Create(definition, gear.amount, gear.skin);
                if (item != null)
                {
                    var held = item.GetHeldEntity() as BaseProjectile;
                    if (held != null)
                    {
                        if (!string.IsNullOrEmpty(gear.ammoType))
                        {
                            var ammoType = ItemManager.FindItemDefinition(gear.ammoType);
                            if (ammoType != null)
                                held.primaryMagazine.ammoType = ammoType;
                        }
                        held.primaryMagazine.contents = held.primaryMagazine.capacity;
                    }
                    if (gear.attachments != null)
                        foreach (var attachment in gear.attachments)
                        {
                            var att = BuildItem(attachment);
                            att.MoveToContainer(item.contents);
                        }
                    return item;
                }
            }
            Puts("Error making item: " + gear.shortname);
            return null;
        }

        private Item BuildItem(string shortname, int amount = 1, ulong skin = 0)
        {
            var definition = ItemManager.FindItemDefinition(shortname);
            if (definition != null)
            {
                var item = ItemManager.Create(definition, amount, skin);
                if (item != null)
                    return item;
            }
            Puts("Error making attachment: " + shortname);
            return null;
        }



        public void CreateGearSet(BasePlayer player)
        {
            if (NewSet.ContainsKey(player.userID))
                NewSet.Remove(player.userID);
            NewSet.Add(player.userID, new SetCreation());
            foreach (var cont in new List<ItemContainer> { player.inventory.containerBelt, player.inventory.containerMain, player.inventory.containerWear })
            {
                foreach (var entry in cont.itemList)
                {
                    List<string> attachments = new List<string>();
                    int ammo = 0;
                    string ammoType = string.Empty;
                    var held = entry.GetHeldEntity() as BaseProjectile;
                    if (held != null)
                    {
                        if (held.primaryMagazine != null)
                        {
                            ammo = held.primaryMagazine.contents;
                            ammoType = held.primaryMagazine.ammoType.shortname;
                        }
                        if (entry.contents != null && entry.contents.itemList != null)
                            foreach (var mod in entry.contents.itemList)
                                attachments.Add(mod.info.shortname);
                    }
                    if (cont == player.inventory.containerBelt)
                        NewSet[player.userID].set.belt.Add(new Gear
                        {
                            skin = entry.skin,
                            displayName = entry.info.displayName.english,
                            amount = entry.amount,
                            attachments = attachments,
                            ammo = ammo,
                            position = entry.position,
                            ammoType = ammoType,
                            shortname = entry.info.shortname,
                        });
                    else if (cont == player.inventory.containerWear)
                        NewSet[player.userID].set.wear.Add(new Gear
                        {
                            skin = entry.skin,
                            displayName = entry.info.displayName.english,
                            amount = entry.amount,
                            attachments = attachments,
                            ammo = ammo,
                            ammoType = ammoType,
                            shortname = entry.info.shortname,
                        });
                    else if (cont == player.inventory.containerMain)
                        NewSet[player.userID].set.main.Add(new Gear
                        {
                            skin = entry.skin,
                            displayName = entry.info.displayName.english,
                            amount = entry.amount,
                            attachments = attachments,
                            ammo = ammo,
                            ammoType = ammoType,
                            shortname = entry.info.shortname,
                        });
                }
            }
            NewSet[player.userID].set.Category = CSUIInfo[player.userID].SelectedCategory;
            SetPanel(player);
        }

        class SavedData
        {
            public Dictionary<string, Set> SavedSets = new Dictionary<string, Set>();
            public Dictionary<ulong, PlayerSetData> PlayerData = new Dictionary<ulong, PlayerSetData>();
        }

        class PlayerSetData
        {
            public Dictionary<string, CoolandUse> cooldownANDuses = new Dictionary<string, CoolandUse>();
        }

        class CoolandUse
        {
            public double CooldownExpiration;
            public int timesUsed;
            public double FirstUse;
        }

        class Set
        {
            public int cost = 0;
            public string Category;
            public string permission;
            public bool hidden;
            public int cooldown;
            public int dailyUses;
            public List<Gear> belt = new List<Gear>();
            public List<Gear> wear = new List<Gear>();
            public List<Gear> main = new List<Gear>();
        }

        class Gear
        {
            public string shortname;
            public string displayName;
            public ulong skin;
            public int amount;
            public int ammo;
            public string ammoType;
            public List<string> attachments = new List<string>();
            public int position;
        }



        private void SaveLoop()
        {
            if (timers.ContainsKey("save"))
            {
                timers["save"].Destroy();
                timers.Remove("save");
            }
            SaveData();
            timers.Add("save", timer.Once(600, () => SaveLoop()));
        }

        private void InfoLoop()
        {
            if (timers.ContainsKey("info"))
            {
                timers["info"].Destroy();
                timers.Remove("info");
            }
            if (configData.InfoInterval == 0) return;
            foreach (BasePlayer p in BasePlayer.activePlayerList)
            {
                string key = String.Empty;
                //if (!string.IsNullOrEmpty(configData.MenuKeyBinding))
                //    key = GetMSG("CSAltInfo", p, configData.MenuKeyBinding.ToUpper());
                GetSendMSG(p, "CSInfo", key);
            }
            timers.Add("info", timer.Once(configData.InfoInterval * 60, () => InfoLoop()));
        }



        #region  External Calls
        private bool isSet(string set)
        {
            if (!csData.SavedSets.ContainsKey(set)) return false;
            return true;
        }

        private bool GiveSet(BasePlayer player, string set)
        {
            if (!csData.SavedSets.ContainsKey(set)) return false;
            GiveGearSet(player, set);
            return true;
        }

        private bool TryGiveSet(BasePlayer player, string set)
        {
            if (!csData.SavedSets.ContainsKey(set)) return false;
            if (!permission.UserHasPermission(player.UserIDString, this.Title + "." + csData.SavedSets[set].permission)) return false;
            GiveGearSet(player, set);
            return true;
        }

        [HookMethod("GetSetInfo")]
        public object GetSetInfo(string set)
        {
            if (!csData.SavedSets.ContainsKey(set)) return false;
            var s = csData.SavedSets[set];
            JObject obj = new JObject();
            obj["category"] = s.Category;
            obj["cooldown"] = s.cooldown;
            obj["cost"] = s.cost;
            obj["uses"] = s.dailyUses;
            obj["hidden"] = s.hidden;
            obj["permission"] = s.permission;
            JArray belt = new JArray();
            foreach (var itemEntry in s.belt)
            {
                JObject item = new JObject();
                item["amount"] = itemEntry.amount;
                item["ammoamount"] = itemEntry.ammo;
                item["ammotype"] = itemEntry.ammoType;
                item["name"] = itemEntry.displayName;
                item["position"] = itemEntry.position;
                item["shortname"] = itemEntry.shortname;
                item["skin"] = itemEntry.skin;
                JArray mods = new JArray();
                foreach (var mod in itemEntry.attachments)
                    mods.Add(mod);
                item["attachments"] = mods;
                belt.Add(item);
            }
            obj["belt"] = belt;
            JArray main = new JArray();
            foreach (var itemEntry in s.main)
            {
                JObject item = new JObject();
                item["amount"] = itemEntry.amount;
                item["ammoamount"] = itemEntry.ammo;
                item["ammotype"] = itemEntry.ammoType;
                item["name"] = itemEntry.displayName;
                item["position"] = itemEntry.position;
                item["shortname"] = itemEntry.shortname;
                item["skin"] = itemEntry.skin;
                JArray mods = new JArray();
                foreach (var mod in itemEntry.attachments)
                    mods.Add(mod);
                item["attachments"] = mods;
                main.Add(item);
            }
            obj["main"] = main;
            JArray wear = new JArray();
            foreach (var itemEntry in s.wear)
            {
                JObject item = new JObject();
                item["amount"] = itemEntry.amount;
                item["ammoamount"] = itemEntry.ammo;
                item["ammotype"] = itemEntry.ammoType;
                item["name"] = itemEntry.displayName;
                item["position"] = itemEntry.position;
                item["shortname"] = itemEntry.shortname;
                item["skin"] = itemEntry.skin;
                JArray mods = new JArray();
                foreach (var mod in itemEntry.attachments)
                    mods.Add(mod);
                item["attachments"] = mods;
                wear.Add(item);
            }
            obj["wear"] = wear;
            return obj;
        }

        private object GetSetContents(string set)
        {
            if (!csData.SavedSets.ContainsKey(set)) return false;
            List<string> contents = new List<string>();
            foreach (var entry in csData.SavedSets[set].belt)
                contents.Add(entry.shortname + "_" + entry.skin + "belt");
            foreach (var entry in csData.SavedSets[set].wear)
                contents.Add(entry.shortname + "_" + entry.skin + "wear");
            foreach (var entry in csData.SavedSets[set].main)
                contents.Add(entry.shortname + "_" + entry.skin + "main");
            return contents;
        }

        private bool isKit(string set)
        {
            if (!csData.SavedSets.ContainsKey(set)) return false;
            return true;
        }

        private object GiveKit(BasePlayer player, string set)
        {
            if (!csData.SavedSets.ContainsKey(set)) return "No Set Found";
            GiveGearSet(player, set);
            return true;
        }

        private string[] GetAllKits() => csData.SavedSets.Keys.ToArray();

        private string[] GetKitContents(string kitname)
        {
            if (csData.SavedSets.ContainsKey(kitname))
            {
                List<string> items = new List<string>();
                foreach (var item in csData.SavedSets[kitname].belt)
                {
                    var itemstring = $"{item.shortname}_{item.amount}";
                    if (item.attachments.Count > 0)
                        foreach (var mod in item.attachments)
                            itemstring = itemstring + $"_{mod}";
                    items.Add(itemstring);
                }
                foreach (var item in csData.SavedSets[kitname].wear)
                {
                    var itemstring = $"{item.shortname}_{item.amount}";
                    if (item.attachments.Count > 0)
                        foreach (var mod in item.attachments)
                            itemstring = itemstring + $"_{mod}";
                    items.Add(itemstring);
                }
                foreach (var item in csData.SavedSets[kitname].main)
                {
                    var itemstring = $"{item.shortname}_{item.amount}";
                    if (item.attachments.Count > 0)
                        foreach (var mod in item.attachments)
                            itemstring = itemstring + $"_{mod}";
                    items.Add(itemstring);
                }
                if (items.Count > 0)
                    return items.ToArray();
            }
            return null;
        }

        CoolandUse GetSetData(ulong userID, string setname)
        {
            CoolandUse info = new CoolandUse();
            if (csData.PlayerData.ContainsKey(userID))
            {
                var Data = csData.PlayerData[userID];
                Data.cooldownANDuses.TryGetValue(setname, out info);
            }
            return info;
        }

        private double KitCooldown(string kitname) => csData.SavedSets[kitname].cooldown;

        private double PlayerKitCooldown(ulong ID, string kitname) => csData.SavedSets[kitname].cooldown <= 0 ? 0 : CurrentTotalMinutes() > GetSetData(ID, kitname).CooldownExpiration ? 0 : GetSetData(ID, kitname).CooldownExpiration - CurrentTotalMinutes();

        private string KitDescription(string kitname) => string.Empty;

        private int KitMax(string kitname) => csData.SavedSets[kitname].dailyUses;

        private double PlayerKitMax(ulong ID, string kitname) => csData.SavedSets[kitname].dailyUses <= 0 ? 0 : csData.SavedSets[kitname].dailyUses - GetSetData(ID, kitname).timesUsed < csData.SavedSets[kitname].dailyUses ? csData.SavedSets[kitname].dailyUses - GetSetData(ID, kitname).timesUsed : csData.SavedSets[kitname].dailyUses;
        #endregion

        void SaveData()
        {
            if (ready)
                CSDATA.WriteObject(csData);
        }

        void LoadData()
        {
            try
            {
                csData = CSDATA.ReadObject<SavedData>();
                if (csData == null)
                {
                    Puts("Corrupt Data file....creating new datafile");
                    csData = new SavedData();
                }
            }
            catch
            {
                Puts("Couldn't load Custom Sets Data, creating a new datafile");
                csData = new SavedData();
            }
            if (csData.SavedSets == null)
                csData.SavedSets = new Dictionary<string, Set>();
            if (csData.PlayerData == null)
                csData.PlayerData = new Dictionary<ulong, PlayerSetData>();
            ready = true;
            SaveData();
        }


        private ConfigData configData;
        class ConfigData
        {
            public int InfoInterval { get; set; }
            //public string MenuKeyBinding { get; set; }
            public List<string> Categories { get; set; }
            public Dictionary<int, string> SpawnSets { get; set; }
            public bool UsePayment { get; set; }
            public bool ShowLockedSets { get; set; }
            public int UsesResetInterval_InHours { get; set; }
        }
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                InfoInterval = 15,
                //MenuKeyBinding = "",
                UsePayment = false,
                ShowLockedSets = true,
                UsesResetInterval_InHours = 24,
                Categories = new List<string> { "Basic", "Special", "Unlimited", "NoCooldowns", "VIP", "ADMIN ONLY" },
                SpawnSets = new Dictionary<int, string>
                {
                    {1, "setName1"},
                    {2, "setName2"},
                    {3, "setName3"},
                }
            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);

        void LoadDefaultMessages()
        {
            lang.RegisterMessages(messages, this, "en");
        }

        Dictionary<string, string> messages = new Dictionary<string, string>()
        {
            {"title", "CustomSets: " },
            {"CSInfo", "This server is running CustomSet. Type '/sets'{0} to open the menu."},
            {"CSAltInfo", " or press '{0}'" },
            {"NoPerm", "You do not have permission to use this command" },
            {"ImagesLoading", "Unable to open menu. Images are still loading..." },
            {"purchaseset", "You have successfully unlocked the {0} Set" },
            {"SetTitle", "Set: {0}" },
            {"Sets", "Sets in {0}" },
            {"SetCategories", "Set Categories" },
            {"PurchaseSetInfo", "Are you sure you want to purchase the Set: {0} for ${1}?" },
            {"SkinTitle", "Please select a Skin for {0}" },
            {"UnlockSetFree", "Do you want this Set to be FREE?" },
            {"Next", "Next" },
            {"Back", "Back" },
            {"Cancel", "Cancel" },
            {"Delete", "Delete" },
            {"ToggleAdminView", "Admin View" },
            {"NotAuthorized", "You are not authorized to use this function" },
            {"EnterAdminView", "You have entered Admin View." },
            {"ExitAdminView", "You have exited Admin View." },
            {"CostOFSet", "Cost $ {0} to Unlock" },
            {"UnlockSet", "Unlock for $ {0}?" },
            {"Redeem", "REDEEM !" },
            {"SetName", "Please provide a name for the new set. You can also type 'quit' to exit." },
            {"SetCost", "Please Select the Price to Unlock this Set" },
            {"CreateSet", "Create New Set?" },
            {"CancelSet", "Cancel Set Creation?" },
            {"SaveSet", "SAVE SET !" },
            {"GivenSet", "You have been given Set: {0}" },
            {"NewSetCreated", "You have successfully created a new set: {0}" },
            {"ClickToDetail", "Set Item Cost" },
            {"Remove", "Remove Item" },
            {"SetSkin", "Select Skin" },
            {"Container", "ITEMS FOR {0}" },
            {"Cooldown", "Cooldown: {0}" },
            {"RemainingCooldown", "Remaining Cooldown: {0}" },
            {"RemainingUses", "Remaining Uses: {0}" },
            {"DailyUses", "Uses: {0}" },
            {"SetCooldown", "Select a Set Cooldown (in Minutes)" },
            {"SetMaxDailyUses", "Select a Set Max Uses Amount" },
            {"UseAPermission", "Make this Set require Permission?" },
            {"NoInventorySpace", "You do not have enough inventory space for this set!" },
            {"ListOFSets", "LIST OF SETS" },
            {"Category", "Category: {0}" },
            {"HiddenSet", "Hide this Set from the menu?" },
            {"NameTaken", "That Set Name already exists. Try a different one." },
            {"Hidden", "Hidden: {0}" },
            {"Permission", "Permission: {0}" },
            {"Free", "Free" },
            {"Yes", "Yes" },
            {"No", "No" },
            {"CooldownTitle", "Edit Cooldown" },
            {"Cost", "Cost: {0}" },
            {"CostTitle", "Cost" },
            {"Uses", "Edit Uses" },
            {"CurrentStatus", "Current: {0}"},
            {"ExitSetEditing", "Stop Editing Set" },
            {"ITEM", "ITEM" },
            {"INFO", "INFO" },
            {"SettingChangedTo", "Change to {0}" },
            {"WaitingImageLibrary", "Waiting on Image Library to initialize. Trying again in 20 Seconds" }
        };
    }
}

// --- End of file: CustomSets.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/car-radio ---
// --- Original File Path: C/CarRadio/CarRadio.cs ---

using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Rust.Instruments;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using static InstrumentKeyController;

namespace Oxide.Plugins
{
    [Info("Car Radio", "TCM420G", "1.0.70")]
    [Description("Allows players to attach radios to vehicles")]
    class CarRadio : CovalencePlugin
    {
        #region variables
        private const string PERMISSION_ATTACHRADIO = "carradio.attachcarradio";
        private const string PERMISSION_DETACHRADIO = "carradio.detachcarradio";
        private const string PERMISSION_ATTACHRADIO_GLOBAL = "carradio.attachallcarradio";
        private const string PERMISSION_DETACHRADIO_GLOBAL = "carradio.detachallcarradio";

        private const string I18N_MISSING_SIREN = "NoRadioForName";
        private const string I18N_COULD_NOT_ATTACH = "CouldNotAttach";
        private const string I18N_NOT_SUPPORTED = "NotSupported";
        private const string I18N_ATTACHED = "Attached";
        private const string I18N_ATTACHED_GLOBAL = "AttachedGlobal";
        private const string I18N_DETACHED = "Detached";
        private const string I18N_DETACHED_GLOBAL = "DetachedGlobal";
        private const string I18N_NOT_A_VEHICLE = "NotAVehicle";
        private const string I18N_RADIO = "Radios";
        private const string I18N_PLAYERS_ONLY = "PlayersOnly";

        // Initial prefabs
        private const string PREFAB_COCKPIT = "assets/content/vehicles/modularcar/module_entities/1module_cockpit.prefab";
        private const string PREFAB_COCKPIT_ARMORED = "assets/content/vehicles/modularcar/module_entities/1module_cockpit_armored.prefab";
        private const string PREFAB_COCKPIT_WITH_ENGINE = "assets/content/vehicles/modularcar/module_entities/1module_cockpit_with_engine.prefab";
       // private const string PREFAB_BUTTON = "assets/prefabs/deployable/playerioents/button/button.prefab";
        private const string PREFAB_FLASHERLIGHT = null;
        private const string PREFAB_SIRENLIGHT = null;
        private const string PREFAB_SPOTLIGHT = null;
        private const string PREFAB_RADIO = "assets/prefabs/voiceaudio/boombox/boombox.static.prefab";

        // Vehicles
        private const string PREFAB_KAYAK = "assets/content/vehicles/boats/kayak/kayak.prefab";
        private const string PREFAB_TUGBOAT = "assets/content/vehicles/boats/tugboat/tugboat.prefab";
        private const string PREFAB_ROWBOAT = "assets/content/vehicles/boats/rowboat/rowboat.prefab";
        private const string PREFAB_RHIB = "assets/content/vehicles/boats/rhib/rhib.prefab";
        private const string PREFAB_SEDAN = "assets/content/vehicles/sedan_a/sedantest.entity.prefab";
        private const string PREFAB_SEDANRAIL = "assets/content/vehicles/sedan_a/sedanrail.entity.prefab";
        private const string PREFAB_MINICOPTER = "assets/content/vehicles/minicopter/minicopter.entity.prefab";
        private const string PREFAB_ATTACKHELI = "assets/content/vehicles/attackhelicopter/attackhelicopter.entity.prefab";
        private const string PREFAB_TRANSPORTHELI = "assets/content/vehicles/scrap heli carrier/scraptransporthelicopter.prefab";
        private const string PREFAB_CHINOOK = "assets/prefabs/npc/ch47/ch47.entity.prefab";
        private const string PREFAB_MAGNETCRANE = "assets/content/vehicles/crane_magnet/magnetcrane.entity.prefab";
        private const string PREFAB_SUBMARINESOLO = "assets/content/vehicles/submarine/submarinesolo.entity.prefab";
        private const string PREFAB_SUBMARINEDUO = "assets/content/vehicles/submarine/submarineduo.entity.prefab";
        private const string PREFAB_SNOWMOBILE = "assets/content/vehicles/snowmobiles/snowmobile.prefab";
        private const string PREFAB_SNOWMOBILETOMAHA = "assets/content/vehicles/snowmobiles/tomahasnowmobile.prefab";

        // Train Engine
        private const string PREFAB_WORKCART = "assets/content/vehicles/trains/workcart/workcart.entity.prefab";
        private const string PREFAB_TRAINENGINE = "assets/content/vehicles/trains/workcart/workcart_aboveground.entity.prefab";
        private const string PREFAB_TRAINENGINE_COVERED = "assets/content/vehicles/trains/workcart/workcart_aboveground2.entity.prefab";
        private const string PREFAB_TRAINENGINE_LOCOMOTIVE = "assets/content/vehicles/trains/locomotive/locomotive.entity.prefab";

        // Other Vehicles
        private const string PREFAB_HORSE = "assets/rust.ai/nextai/testridablehorse.prefab";
        private const string PREFAB_HOTAIRBALLOON = "assets/prefabs/deployable/hot air balloon/hotairballoon.prefab";

        private const string KEY_MODULAR_CAR = "MODULAR_CAR";

        private const string DATAPATH_RADIO = "carradio/";

        // Preconfigured carradio
        private static readonly Radio SIREN_DEFAULT = new Radio("Car-Radio",
            new Dictionary<string, Attachment[]>
            {
                [PREFAB_COCKPIT] = new Attachment[] {
                 //   new Attachment(PREFAB_BUTTON, new Vector3(0.05f, 1.85f, 0.62f), new Vector3(200f, 0f, 0f)),
                    new Attachment(PREFAB_RADIO, new Vector3(-0.00f, 0.58f, 0.2f), new Vector3(330f, 180f, 0f))
                },
                [PREFAB_COCKPIT_ARMORED] = new Attachment[] {
                //    new Attachment(PREFAB_BUTTON, new Vector3(0.05f, 1.85f, 0.62f), new Vector3(200f, 0f, 0f)),
                    new Attachment(PREFAB_RADIO, new Vector3(-0.00f, 0.58f, 0.2f), new Vector3(330f, 180f, 0f))
                },
                [PREFAB_COCKPIT_WITH_ENGINE] = new Attachment[] {
                 //   new Attachment(PREFAB_BUTTON, new Vector3(0.05f, 1.85f, 0.62f), new Vector3(200f, 0f, 0f)),
                    new Attachment(PREFAB_RADIO, new Vector3(-0.00f, 0.58f, 0.2f), new Vector3(330f, 180f, 0f))
                }
            },
           new Dictionary<string, Attachment[]>
            {
                [PREFAB_KAYAK] = new Attachment[] {
                //    new Attachment(PREFAB_BUTTON, new Vector3(-1.0f, 0.2f, 1.5f), new Vector3(270f, 270f, 0f)),
                    new Attachment(PREFAB_RADIO, new Vector3(-0.1f, 0.25f, -0.7f), new Vector3(0f, 0f, 0f))
                },
                [PREFAB_ROWBOAT] = new Attachment[] {
                 //   new Attachment(PREFAB_BUTTON, new Vector3(-1.7f, 0.5f, -1.8f), new Vector3(270f, 270f, 0f)),
                    new Attachment(PREFAB_RADIO, new Vector3(0.0f, 0.8f, 2.18f), new Vector3(0f, 180f, 0f))
                },
                [PREFAB_TUGBOAT] = new Attachment[] {
                  //  new Attachment(PREFAB_BUTTON, new Vector3(-2.05f, 6.8f, 3.1f), new Vector3(230f, 320f, 270f)),
                    new Attachment(PREFAB_RADIO, new Vector3(0.0f, 8.0f, 0.7f), new Vector3(0f, 0f, 0f)), // Cockpit Radio
                    new Attachment(PREFAB_RADIO, new Vector3(0.0f, 2.0f, 5.3f), new Vector3(0f, 180f, 0f)), // Lower Deck Radio
                    new Attachment(PREFAB_RADIO, new Vector3(0.0f, 2.75f, -10.5f), new Vector3(0f, 0f, 0f)) // Outer Deck Radio
                },
                [PREFAB_RHIB] = new Attachment[] {
                  //  new Attachment(PREFAB_BUTTON, new Vector3(0.5f, 2.275f, 1.55f), new Vector3(251f, 0f, 0f)),
                    new Attachment(PREFAB_RADIO, new Vector3(0.0f, 2.83f, 0.62f), new Vector3(0f, 180f, 0f))
                },
                [PREFAB_SEDAN] = new Attachment[] {
                  //  new Attachment(PREFAB_BUTTON, new Vector3(0.0f, 2.07f, 1.98f), new Vector3(210f, 0f, 0f)),
                    new Attachment(PREFAB_RADIO, new Vector3(0.0f, 0.53f, 1.25f), new Vector3(315f, 180f, 0f))
                },
                [PREFAB_SEDANRAIL] = new Attachment[] {
                  //  new Attachment(PREFAB_BUTTON, new Vector3(0.0f, 2.3f, 1.22f), new Vector3(210f, 0f, 0f)),
                    new Attachment(PREFAB_RADIO, new Vector3(0.0f, 0.76f, 0.48f), new Vector3(315f, 180f, 0f))
                },
                [PREFAB_MINICOPTER] = new Attachment[] {
                  //  new Attachment(PREFAB_BUTTON, new Vector3(0.0f, 2.01f, 1.03f), new Vector3(180f, 0f, 0f)),
                    new Attachment(PREFAB_RADIO, new Vector3(0.0f, 1.4f, 0.0f), new Vector3(0f, 0f, 0f))
                },
                [PREFAB_ATTACKHELI] = new Attachment[] {
                  //  new Attachment(PREFAB_BUTTON, new Vector3(0.0f, 0.35f, 0.55f), new Vector3(0f, 180f, 0f)),
                    new Attachment(PREFAB_RADIO, new Vector3(0.0f, 2.15f, -0.45f), new Vector3(0f, 0f, 0f))
                },
                [PREFAB_TRANSPORTHELI] = new Attachment[] {
                   // new Attachment(PREFAB_BUTTON, new Vector3(-0.1f, 2.68f, 3.865f), new Vector3(205f, 0f, 0f)),
                    new Attachment(PREFAB_RADIO, new Vector3(0.0f, 2.51f, 1.53f), new Vector3(90f, 0f, 0f))
                },
                [PREFAB_CHINOOK] = new Attachment[] {
                  //  new Attachment(PREFAB_BUTTON, new Vector3(0.0f, 1.9f, 8.0f), new Vector3(270f, 0f, 0f)),
                    new Attachment(PREFAB_RADIO, new Vector3(0.0f, 3.5f, -1.6f), new Vector3(100f, 180f, 0f)), // Back Radio
                    new Attachment(PREFAB_RADIO, new Vector3(0.0f, 3.4f, 6.35f), new Vector3(90f, 0f, 0f)) // Cockpit Radio
                },
                [PREFAB_MAGNETCRANE] = new Attachment[] {
                  //  new Attachment(PREFAB_BUTTON, new Vector3(1.08f, 3.98f, -2.15f), new Vector3(233f, 170f, 0f), "Top"),
                    new Attachment(PREFAB_RADIO, new Vector3(0.95f, 3.5f, 0.0f), new Vector3(0f, 180f, 0f), "Top")
                },
                [PREFAB_SUBMARINESOLO] = new Attachment[] {
                  //  new Attachment(PREFAB_BUTTON, new Vector3(-0.27f, 2.55f, -0.27f), new Vector3(180f, 225f, 0f)),
                    new Attachment(PREFAB_RADIO, new Vector3(0.0f, 0.85f, 0.45f), new Vector3(0f, 180f, 0f))
                },
                [PREFAB_SUBMARINEDUO] = new Attachment[] {
                  //  new Attachment(PREFAB_BUTTON, new Vector3(0.275f, 2.5f, 0.76f), new Vector3(172f, 90f, 0f)),
                    new Attachment(PREFAB_RADIO, new Vector3(0.0f, 1.25f, -1.48f), new Vector3(0f, 0f, 0f))
                },
                [PREFAB_SNOWMOBILE] = new Attachment[] {
                  //  new Attachment(PREFAB_BUTTON, new Vector3(0.0f, 1.8f, 0.9f), new Vector3(210f, 0f, 0f)),
                    new Attachment(PREFAB_RADIO, new Vector3(0.0f, 0.9f, -1.1f), new Vector3(0f, 0f, 0f))
                },
                [PREFAB_SNOWMOBILETOMAHA] = new Attachment[] {
                   // new Attachment(PREFAB_BUTTON, new Vector3(0.0f, 1.21f, 0.88f), new Vector3(240f, 0f, 0f)),
                    new Attachment(PREFAB_RADIO, new Vector3(0.0f, 0.5f, -1.25f), new Vector3(0f, 0f, 0f))
                },
                [PREFAB_WORKCART] = new Attachment[] {
                  //  new Attachment(PREFAB_BUTTON, new Vector3(0.19f, 3.13f, 4.95f), new Vector3(235f, 0f, 0f)),
                    new Attachment(PREFAB_RADIO, new Vector3(0.7f, 2.6f, 0.0f), new Vector3(0f, 180f, 0f))
                },
                [PREFAB_TRAINENGINE] = new Attachment[] {
                  //  new Attachment(PREFAB_BUTTON, new Vector3(0.19f, 3.13f, 4.95f), new Vector3(235f, 0f, 0f)),
                    new Attachment(PREFAB_RADIO, new Vector3(0.7f, 2.6f, 0.0f), new Vector3(0f, 180f, 0f))
                },
                [PREFAB_TRAINENGINE_COVERED] = new Attachment[] {
                  //  new Attachment(PREFAB_BUTTON, new Vector3(0.19f, 3.13f, 4.95f), new Vector3(235f, 0f, 0f)),
                    new Attachment(PREFAB_RADIO, new Vector3(0.7f, 2.6f, 0.0f), new Vector3(0f, 180f, 0f))
                },
                [PREFAB_TRAINENGINE_LOCOMOTIVE] = new Attachment[] {
                 //   new Attachment(PREFAB_BUTTON, new Vector3(-0.1f, 4.3f, 5.35f), new Vector3(200f, 270f, 0f)),
                    new Attachment(PREFAB_RADIO, new Vector3(1.1f, 3.5f, 3.34f), new Vector3(0f, 0f, 0f)), // Cockpit Radio
                    new Attachment(PREFAB_RADIO, new Vector3(0.0f, 1.55f, -9.4f), new Vector3(0f, 180f, 0f)) // Back Radio
                },
                [PREFAB_HORSE] = new Attachment[] {
                    new Attachment(PREFAB_RADIO, new Vector3(0.0f, 1.55f, -0.8f), new Vector3(260f, 0f, 180f))
                },
                [PREFAB_HOTAIRBALLOON] = new Attachment[] {
                 //   new Attachment(PREFAB_BUTTON, new Vector3(0.0f, 2.01f, 1.03f), new Vector3(180f, 0f, 0f)),
                    new Attachment(PREFAB_RADIO, new Vector3(0.0f, 1.4f, 0.0f), new Vector3(0f, 0f, 0f))
                }
            }, new Tone(Notes.A, NoteType.Regular, 4, 1f), new Tone(Notes.D, NoteType.Regular, 5, 1f));
			
        private static readonly Radio SIREN_SILENT = new Radio("test-radio",
            new Dictionary<string, Attachment[]>
            {
				//Erased Dictionary to remove bulk since it was a duplicate of the above
			},
            new Dictionary<string, Attachment[]>
          {
			  //Erased Dictionary to remove bulk since it was a duplicate of the above
		  });
        #endregion variables

        #region data
        private class DataContainer
        {
            // Map BaseVehicle.net.ID -> RadioInfos
            public Dictionary<ulong, VehicleContainer> VehicleRadioMap = new Dictionary<ulong, VehicleContainer>();
        }

        private class VehicleContainer
        {
            public string RadioName = SIREN_DEFAULT.Name;
            public RadioController.States State = RadioController.States.OFF;
            public HashSet<ulong> NetIDs = new HashSet<ulong>();

            public VehicleContainer()
            {
            }

            public VehicleContainer(string aRadioName, RadioController.States aState, IEnumerable<ulong> someNetIDs)
            {
                RadioName = aRadioName;
                State = aState;
                NetIDs.UnionWith(someNetIDs);
            }
        }
        #endregion data

        #region configuration

        private Configuration config;
        private IDictionary<string, Radio> RadioDictionary { get; } = new Dictionary<string, Radio>();

        private class Configuration
        {
            [JsonProperty("MountNeeded")]
            public bool MountNeeded = true;

            [JsonProperty("SoundEnabled")]
            public bool SoundEnabled = true;

            [JsonProperty("RadioSpawnProbability")]
            public Dictionary<string, float> RadioSpawnProbability = new Dictionary<string, float>
            {
                [KEY_MODULAR_CAR] = 0f,
                [PREFAB_HORSE] = 0f,
                [PREFAB_MINICOPTER] = 0f,
                [PREFAB_SEDAN] = 0f,
                [PREFAB_TRANSPORTHELI] = 0f
            };

            [JsonConverter(typeof(StringEnumConverter))]
            [JsonProperty("DefaultState")]
            public RadioController.States DefaultState = RadioController.States.OFF;

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        private class Tone
        {
            public Tone(Notes aNote = Notes.A, NoteType aNoteType = NoteType.Regular, int anOctave = 4, float aDuration = 1f)
            {
                Note = aNote;
                NoteType = aNoteType;
                Octave = anOctave;
                Duration = aDuration;
            }

            [JsonConverter(typeof(StringEnumConverter))]
            [JsonProperty("Note")]
            public Notes Note;

            [JsonConverter(typeof(StringEnumConverter))]
            [JsonProperty("NoteType")]
            public NoteType NoteType;

            [JsonProperty("Octave")]
            public int Octave;

            [JsonProperty("Duration")]
            public float Duration;

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        private class Radio
        {
            public Radio(string aName, Dictionary<string, Attachment[]> someModules, Dictionary<string, Attachment[]> someVehicles, params Tone[] someTones)
            {
                Name = aName;
                Modules = someModules;
                Vehicles = someVehicles;
                Tones = someTones;
            }

            [JsonProperty("Name")]
            public string Name;

            [JsonProperty("Tones")]
            public Tone[] Tones;

            [JsonProperty("Modules")]
            public Dictionary<string, Attachment[]> Modules;

            [JsonProperty("Vehicles")]
            public Dictionary<string, Attachment[]> Vehicles;

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        private class Attachment
        {
            public Attachment(string aPrefab, Vector3 aPosition, Vector3 anAngle = new Vector3(), string aBone = null)
            {
                Prefab = aPrefab;
                Position = aPosition;
                Angle = anAngle;
                Bone = aBone;
            }

            [JsonProperty("Prefab")]
            public string Prefab;

            [JsonProperty("Position")]
            public Vector3 Position;

            [JsonProperty("Angle")]
            public Vector3 Angle;

            [JsonProperty("Bone")]
            public string Bone;

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        protected override void LoadDefaultConfig()
        {
            config = new Configuration();
            RadioDictionary.Clear();
            RadioDictionary.Add(SIREN_DEFAULT.Name, SIREN_DEFAULT);
            RadioDictionary.Add(SIREN_SILENT.Name, SIREN_SILENT);
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    throw new JsonException();
                }

                try
                {
                    foreach (string eachRadioFile in Interface.Oxide.DataFileSystem.GetFiles(DATAPATH_RADIO, "*.json"))
                    {
                        string theFilename = eachRadioFile.Basename(".json");
                        try
                        {
                            Radio theRadio = Interface.Oxide.DataFileSystem.ReadObject<Radio>(DATAPATH_RADIO + theFilename);
                            RadioDictionary.Add(theRadio.Name, theRadio);
                        }
                        catch
                        {
                            PrintWarning($"Radio file {theFilename}.json is invalid; ignoring");
                        }
                    }
                }
                catch
                {

                }
                Puts("Loaded carradio: " + string.Join(", ", RadioDictionary.Keys));

                if (RadioDictionary.IsEmpty())
                {
                    PrintWarning("Configuration appears to be missing carradio; using defaults");
                    RadioDictionary.Add(SIREN_DEFAULT.Name, SIREN_DEFAULT);
                    RadioDictionary.Add(SIREN_SILENT.Name, SIREN_SILENT);
                    SaveConfig();
                }

                if (!config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    PrintWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }

            }
            catch
            {
                PrintWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            PrintWarning($"Configuration changes saved to {Name}.json");
            Config.WriteObject(config, true);

            foreach (Radio eachRadio in RadioDictionary.Values)
            {
                Interface.Oxide.DataFileSystem.WriteObject(DATAPATH_RADIO + eachRadio.Name, eachRadio);
            }
        }
        #endregion configuration

        #region localization
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [I18N_MISSING_SIREN] = "No radio was found for the given name (using {0} instead)",
                [I18N_COULD_NOT_ATTACH] = "Could not attach '{0}'",
                [I18N_ATTACHED] = "Attached radio '{0}'",
                [I18N_ATTACHED_GLOBAL] = "Attached radio '{0}' to all existing cars",
                [I18N_DETACHED] = "Detached radio",
                [I18N_DETACHED_GLOBAL] = "Detached all existing carradio",
                [I18N_NOT_A_VEHICLE] = "This entity is not a (supported) vehicle",
                [I18N_RADIO] = "Available carradio: {0}",
                [I18N_PLAYERS_ONLY] = "Command '{0}' can only be used by a player",
                [I18N_NOT_SUPPORTED] = "The radio '{0}' has no configuration for '{1}'"
            }, this);
        }
        #endregion localization

        #region commands
        [Command("attachradio"), Permission(PERMISSION_ATTACHRADIO)]
        private void AttachCarRadios(IPlayer aPlayer, string aCommand, string[] someArgs)
        {
            if (aPlayer.IsServer)
            {
                Message(aPlayer, I18N_PLAYERS_ONLY, aCommand);
                return;
            }

            BaseVehicle theVehicle = RaycastVehicle(aPlayer);
            if (theVehicle)
            {
                Radio theRadio = someArgs.Length > 0 ? FindRadioForName(someArgs[0], aPlayer) : RadioDictionary.Values.First();
                AttachRadios(theVehicle, theRadio, config.DefaultState, aPlayer);
                Message(aPlayer, I18N_ATTACHED, theRadio.Name);
            }
        }

        [Command("removeradio"), Permission(PERMISSION_DETACHRADIO)]
        private void DetachCarRadios(IPlayer aPlayer, string aCommand, string[] someArgs)
        {
            if (aPlayer.IsServer)
            {
                Message(aPlayer, I18N_PLAYERS_ONLY, aCommand);
                return;
            }

            BaseVehicle theVehicle = RaycastVehicle(aPlayer);
            if (theVehicle && DetachRadios(theVehicle))
            {
                Message(aPlayer, I18N_DETACHED);
            }
        }

        [Command("attachallcarradio"), Permission(PERMISSION_ATTACHRADIO_GLOBAL)]
        private void AttachAllCarRadios(IPlayer aPlayer, string aCommand, string[] someArgs)
        {
            Radio theRadio = someArgs.Length > 0 ? FindRadioForName(someArgs[0], aPlayer) : RadioDictionary.Values.First();
            foreach (BaseVehicle eachVehicle in BaseNetworkable.serverEntities.OfType<BaseVehicle>())
            {
                AttachRadios(eachVehicle, theRadio, config.DefaultState, aPlayer);
            }
            Message(aPlayer, I18N_ATTACHED_GLOBAL, theRadio.Name);
        }

        [Command("detachallcarradio"), Permission(PERMISSION_DETACHRADIO_GLOBAL)]
        private void DetachAllCarRadios(IPlayer aPlayer, string aCommand, string[] someArgs)
        {
            foreach (BaseVehicle eachVehicle in BaseNetworkable.serverEntities.OfType<BaseVehicle>())
            {
                DetachRadios(eachVehicle);
            }
            Message(aPlayer, I18N_DETACHED_GLOBAL);
        }

        

        [Command("togglecarradio")]
        private void ToggleRadios(IPlayer aPlayer, string aCommand, string[] someArgs)
        {
            if (aPlayer.IsServer)
            {
                Message(aPlayer, I18N_PLAYERS_ONLY, aCommand);
                return;
            }

            BasePlayer thePlayer = aPlayer.Object as BasePlayer;
            BaseVehicle theVehicle = thePlayer?.GetMountedVehicle();
            if (theVehicle)
            {
                theVehicle.GetComponent<RadioController>()?.ChangeState();
            }
            else if (!config.MountNeeded)
            {
                RaycastVehicle(aPlayer)?.GetComponent<RadioController>()?.ChangeState(); ;
            }
        }
        #endregion commands

        #region hooks
        private void Unload()
        {
            OnServerSave();

            foreach (BaseVehicle eachVehicle in BaseNetworkable.serverEntities.OfType<BaseVehicle>())
            {
                DetachRadios(eachVehicle);
            }
        }

        private void OnServerSave()
        {
            DataContainer thePersistentData = new DataContainer();
            foreach (BaseVehicle eachCar in BaseNetworkable.serverEntities.OfType<BaseVehicle>())
            {
                RadioController theController = eachCar.GetComponent<RadioController>();
                thePersistentData.VehicleRadioMap.Add(eachCar.net.ID.Value, theController ? new VehicleContainer(theController.Radio.Name, theController.State, theController.NetIDs) : null);
            }
            Interface.Oxide.DataFileSystem.WriteObject(Name, thePersistentData);
        }

        private void OnServerInitialized(bool anInitialFlag)
        {
            bool theSpawnRandomlyFlag = config.RadioSpawnProbability.Any(entry => entry.Value > 0f);
            if (!theSpawnRandomlyFlag)
            {
                Unsubscribe("OnEntitySpawned");
            }

            // Reattach on server restart
            DataContainer thePersistentData = Interface.Oxide.DataFileSystem.ReadObject<DataContainer>(Name);
            foreach (BaseVehicle eachVehicle in BaseNetworkable.serverEntities.OfType<BaseVehicle>())
            {
                VehicleContainer theContainer;
                if (thePersistentData.VehicleRadioMap.TryGetValue(eachVehicle.net.ID.Value, out theContainer))
                {
                    if (theContainer != null)
                    {
                        Radio theRadio;
                        if (RadioDictionary.TryGetValue(theContainer.RadioName, out theRadio))
                        {
                            CreateRadioController(eachVehicle, theRadio, theContainer.NetIDs);
                            AttachRadios(eachVehicle, theRadio, theContainer.State);
                        }
                        else
                        {
                            CreateRadioController(eachVehicle, null, theContainer.NetIDs);
                            DetachRadios(eachVehicle);
                            PrintWarning($"Missing radio for name \"{theContainer.RadioName}\". Ignoring...");
                        }
                    }
                }
                else if (theSpawnRandomlyFlag)
                {
                    RadioController theController = eachVehicle.GetComponent<RadioController>();
                    if (!theController)
                    {
                        float theProbability;
                        if (config.RadioSpawnProbability.TryGetValue(eachVehicle is ModularCar ? KEY_MODULAR_CAR : eachVehicle.PrefabName, out theProbability) && Core.Random.Range(0f, 1f) < theProbability)
                        {
                            AttachRadios(eachVehicle, RadioDictionary.Values.First(), config.DefaultState);
                        }
                    }
                }
            }
        }

    /*    private object OnButtonPress(PressButton aButton, BasePlayer aPlayer)
        {
            BaseVehicle theVehicle = aButton.GetComponentInParent<BaseVehicle>()?.VehicleParent();
            theVehicle = theVehicle ? theVehicle : aButton.GetComponentInParent<BaseVehicle>();
			theVehicle = aPlayer?.GetMountedVehicle();
            if (theVehicle)
            {
                RadioController theController = theVehicle.GetComponent<RadioController>();
                if (theController)
                {
                    if ((config.MountNeeded && aPlayer.GetMountedVehicle() != theVehicle) || !theController.NetIDs.Contains(aButton.net.ID.Value))
                    {
                        return false;
                    }
                    theController.ChangeState();
                }
            }
            return null;
        }
*/
        private void OnEntitySpawned(BaseVehicle aVehicle)
        {
            RadioController theController = aVehicle.GetComponent<RadioController>();
            if (!theController)
            {
                float theProbability;
                if (config.RadioSpawnProbability.TryGetValue(aVehicle is ModularCar ? KEY_MODULAR_CAR : aVehicle.PrefabName, out theProbability) && Core.Random.Range(0f, 1f) < theProbability)
                {
                    AttachRadios(aVehicle, RadioDictionary.Values.First(), config.DefaultState);
                }
            }
        }
        #endregion hooks

        #region methods
        /// <summary>
        /// Tries to attach the given radio to the vehicle, replacing any existing radio.
        /// </summary>
        /// <param name="aVehicle">The vehicle.</param>
        /// <param name="aRadio">The radio.</param>
        /// <param name="anInitialState">The initial radio state.</param>
        /// <param name="aPlayer">The calling player.</param>
        private void AttachRadios(BaseVehicle aVehicle, Radio aRadio, RadioController.States anInitialState, IPlayer aPlayer = null)
        {
            DetachRadios(aVehicle);
            RadioController theController = CreateRadioController(aVehicle, aRadio);
            if (aVehicle as ModularCar)
            {
                if (aRadio.Modules == null)
                {
                    Message(aPlayer, I18N_NOT_SUPPORTED, aRadio.Name, KEY_MODULAR_CAR);
                    DetachRadios(aVehicle);
                    return;
                }
                foreach (BaseVehicleModule eachModule in aVehicle.GetComponentsInChildren<BaseVehicleModule>())
                {
                    SpawnAttachments(aRadio.Modules, aPlayer, theController, eachModule);
                }
            }
            else if (!SpawnAttachments(aRadio.Vehicles, aPlayer, theController, aVehicle))
            {
                Message(aPlayer, I18N_NOT_SUPPORTED, aRadio.Name, aVehicle.PrefabName);
                DetachRadios(aVehicle);
                return;
            }
            theController.SetState(anInitialState);
        }

        /// <summary>
        /// Spawns the attachments for the given dictionary for the given parent entity.
        /// </summary>
        /// <param name="someAttachments">The dictionary.</param>
        /// <param name="aPlayer">The calling player.</param>
        /// <param name="theController">The RadioController of the Parent.</param>
        /// <param name="aParent">The Parent.</param>
        /// <returns>True, if the parent has an entry in the dictionary with at least one Attachment.</returns>
        private bool SpawnAttachments(IDictionary<string, Attachment[]> someAttachments, IPlayer aPlayer, RadioController theController, BaseEntity aParent)
        {
            if (someAttachments == null)
            {
                return false;
            }

            Attachment[] theAttachments;
            if (someAttachments.TryGetValue(aParent.PrefabName, out theAttachments))
            {
                foreach (Attachment eachAttachment in theAttachments)
                {
                    BaseEntity theNewEntity = AttachEntity(aParent, eachAttachment.Prefab, eachAttachment.Position, eachAttachment.Angle, eachAttachment.Bone);
                    if (theNewEntity)
                    {
                        theController.NetIDs.Add(theNewEntity.net.ID.Value);
                    }
                    else if (aPlayer != null)
                    {
                        Message(aPlayer, I18N_COULD_NOT_ATTACH, eachAttachment.Prefab);
                    }
                }
                return !theAttachments.IsEmpty();
            }
            return false;
        }

        /// <summary>
        /// Creates or replaces the RadioController of the given vehicle.
        /// </summary>
        /// <param name="aVehicle">The vehicle.</param>
        /// <param name="aRadio">The Radio.</param>
        /// <param name="someNetIDs">Already existing radio entities.</param>
        /// <returns>The newly created RadioController.</returns>
        private RadioController CreateRadioController(BaseVehicle aVehicle, Radio aRadio, IEnumerable<ulong> someNetIDs = null)
        {
            RadioController theController = aVehicle.GetComponent<RadioController>();
            if (theController)
            {
                UnityEngine.Object.DestroyImmediate(theController);
            }
            theController = aVehicle.gameObject.AddComponent<RadioController>();
            theController.Config = config;
            theController.Radio = aRadio;
            if (someNetIDs != null)
            {
                theController.NetIDs.UnionWith(someNetIDs);
            }
            return theController;
        }

        /// <summary>
        /// Detaches the radio from a vehicle and removes all corresponding entities.
        /// </summary>
        /// <param name="aVehicle"> The vehicle.</param>
        /// <returns>True, if a radio was removed.</returns>
        private bool DetachRadios(BaseVehicle aVehicle)
        {
            RadioController theController = aVehicle.GetComponent<RadioController>();
            if (theController)
            {
                foreach (BaseEntity eachEntity in aVehicle.GetComponentsInChildren<BaseEntity>())
                {
                    if (theController.NetIDs.Contains(eachEntity.net.ID.Value))
                    {
                        Destroy(eachEntity);
                    }
                }
                UnityEngine.Object.DestroyImmediate(theController);
                return true;
            }
            return false;
        }

        /// <summary>
        /// Destroys the entity.
        /// </summary>
        /// <param name="anEntity">The entity.</param>
        private static void Destroy(BaseEntity anEntity)
        {
            if (!anEntity.IsDestroyed)
            {
                anEntity.Kill();
            }
        }

        /// <summary>
        /// Attaches the prefab entity at the given local position and angles to the parent.
        /// </summary>
        /// <param name="aParent">The parent.</param>
        /// <param name="aPrefab">The prefab for the new entity.</param>
        /// <param name="aPosition">The local position.</param>
        /// <param name="anAngle">The local angles.</param>
        /// <returns></returns>
        private BaseEntity AttachEntity(BaseEntity aParent, string aPrefab, Vector3 aPosition, Vector3 anAngle = new Vector3(), string aBone = null)
        {
            BaseEntity theNewEntity = GameManager.server.CreateEntity(aPrefab, aParent.transform.position);
            if (!theNewEntity)
            {
                return null;
            }

            theNewEntity.Spawn();
            Transform theBone = aParent.FindBone(aBone);
            if (theBone == null && aBone != null)
            {
                PrintWarning($"No bone found for name '{aBone}'");
                PrintWarning("Valid bone names: " + string.Join(", ", aParent.GetBones().Select(eachBone => eachBone.name)));
            }

            if (theBone != null && theBone != aParent.transform)
            {
                theNewEntity.SetParent(aParent, theBone.name);
                theNewEntity.transform.localPosition = theBone.InverseTransformPoint(aParent.transform.TransformPoint(aPosition));
                theNewEntity.transform.localRotation = Quaternion.Inverse(theBone.rotation) * (aParent.transform.rotation * Quaternion.Euler(anAngle));
            }
            else
            {
                theNewEntity.transform.localPosition = aPosition;
                theNewEntity.transform.localEulerAngles = anAngle;
                theNewEntity.SetParent(aParent);
            }
            //Puts(theNewEntity.ShortPrefabName + ": (" + theNewEntity.GetComponents<Component>().Length + ") " + string.Join(", ", theNewEntity.GetComponents<Component>().Select(eachComp => eachComp.GetType().Name)));
            UnityEngine.Object.DestroyImmediate(theNewEntity.GetComponent<DestroyOnGroundMissing>());
            UnityEngine.Object.DestroyImmediate(theNewEntity.GetComponent<GroundWatch>());
            UnityEngine.Object.DestroyImmediate(theNewEntity.GetComponent<BoxCollider>());
            UnityEngine.Object.DestroyImmediate(theNewEntity.GetComponent<InstrumentKeyController>());
            theNewEntity.OwnerID = 0;
            BaseCombatEntity theCombatEntity = theNewEntity as BaseCombatEntity;
            if (theCombatEntity)
            {
                theCombatEntity.pickup.enabled = false;
            }
            PressButton theButton = theNewEntity as PressButton;
            if (theButton)
            {
                theButton.pressDuration = 0.2f;
            }

            theNewEntity.EnableSaving(true);
            theNewEntity.SendNetworkUpdateImmediate();
            return theNewEntity;
        }

        /// <summary>
        /// Toggles the IOEntity.
        /// </summary>
        /// <param name="anIOEntity">The IOEntity.</param>
        /// <param name="theEnabledFlag">The new state.</param>
        private static void ToogleRadios(IOEntity anIOEntity, bool theEnabledFlag)
        {
            anIOEntity.UpdateHasPower(theEnabledFlag ? anIOEntity.ConsumptionAmount() : 0, 0);
            anIOEntity.SetFlag(BaseEntity.Flags.On, theEnabledFlag);
        }
        #endregion methods

        #region helpers
        private BaseVehicle RaycastVehicle(IPlayer aPlayer)
        {
            RaycastHit theHit;
            if (!Physics.Raycast((aPlayer.Object as BasePlayer).eyes.HeadRay(), out theHit, 5f))
            {
                return null;
            }

            BaseVehicle theVehicle = theHit.GetEntity()?.GetComponentInParent<BaseVehicle>();
            if (!theVehicle)
            {
                Message(aPlayer, I18N_NOT_A_VEHICLE);
            }
            return theVehicle;
        }

        private Radio FindRadioForName(string aName, IPlayer aPlayer)
        {
            Radio theRadio;
            if (!RadioDictionary.TryGetValue(aName, out theRadio))
            {
                theRadio = RadioDictionary.Values.First();
                Message(aPlayer, I18N_MISSING_SIREN, theRadio.Name);
            }
            return theRadio;
        }

        private string GetText(string aKey, string aPlayerId = null, params object[] someArgs) => string.Format(lang.GetMessage(aKey, this, aPlayerId), someArgs);

        private void Message(IPlayer aPlayer, string anI18nKey, params object[] someArgs)
        {
            if (aPlayer.IsConnected)
            {
                string theText = GetText(anI18nKey, aPlayer.Id, someArgs);
                aPlayer.Reply(theText != anI18nKey ? theText : anI18nKey);
            }
        }

        private void Message(BasePlayer aPlayer, string anI18nKey, params object[] someArgs)
        {
            if (aPlayer.IsConnected)
            {
                string theText = GetText(anI18nKey, aPlayer.UserIDString, someArgs);
                aPlayer.ChatMessage(theText != anI18nKey ? theText : anI18nKey);
            }
        }
        #endregion helpers

        #region controllers
        private class RadioController : FacepunchBehaviour
        {
            public enum States
            {
                OFF,
                ON,
                LIGHTS_ONLY
            }

            private BaseVehicle vehicle;
            private InstrumentTool trumpet;
            public Configuration Config { get; set; }
            public States State { get; private set; }
            public Radio Radio { get; set; }
            public ISet<ulong> NetIDs { get; } = new HashSet<ulong>();

            public States ChangeState()
            {
                SetState(State >= States.LIGHTS_ONLY ? States.OFF : State + 1);
                return State;
            }

            public void SetState(States aState)
            {
                State = aState;
                if ((!Config.SoundEnabled || Radio?.Tones?.Length < 1 || !GetTrumpet()) && State == States.ON)
                {
                    State++;
                }
                RefreshRadioState();
            }

            public void RefreshRadioState()
            {
                if (State == States.ON)
                {
                    PlayTone(0);
                }
                bool theLightsOnFlag = State > States.OFF;
                foreach (IOEntity eachEntity in GetVehicle().GetComponentsInChildren<IOEntity>())
                {
					//if (NetIDs.Contains(eachEntity.net.ID.Value) && !(eachEntity is PressButton)) -- Original Code for button functionality
                    if (eachEntity is PressButton)
                    {
                        ToogleRadios(eachEntity, theLightsOnFlag);
                    }
                }
            }

            private InstrumentTool GetTrumpet()
            {
                if (trumpet == null || trumpet.IsDestroyed)
                {
                    trumpet = GetVehicle().GetComponentInChildren<InstrumentTool>();
                }
                return trumpet;
            }

            private BaseVehicle GetVehicle()
            {
                if (vehicle == null)
                {
                    vehicle = GetComponentInParent<BaseVehicle>();
                }
                return vehicle;
            }

            private void PlayTone(int anIndex)
            {
                if (State != States.ON || !GetTrumpet())
                {
                    return;
                }
                if (anIndex >= Radio.Tones.Length)
                {
                    anIndex = 0;
                }
                Tone theTone = Radio.Tones[anIndex];
                GetTrumpet().ClientRPC(null, "Client_PlayNote", (int)theTone.Note, (int)theTone.NoteType, theTone.Octave, 1f);
                Invoke(() => GetTrumpet().ClientRPC(null, "Client_StopNote", (int)theTone.Note, (int)theTone.NoteType, theTone.Octave), theTone.Duration);
                Invoke(() => PlayTone(++anIndex), theTone.Duration);
            }
        }
        #endregion controllers
    }
}

// --- End of file: CarRadio.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/countries ---
// --- Original File Path: C/Countries/Countries.cs ---

//#define DEBUG

using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text.RegularExpressions;
using Random = System.Random;

// TODO: Implement local database support
// - https://lite.ip2location.com/database/ip-country
// - https://dev.maxmind.com/geoip/geoip2/geolite2/

namespace Oxide.Plugins
{
    [Info("Countries", "Wulf", "2.0.1")]
    [Description("Limits players connecting from certain countries")]
    class Countries : CovalencePlugin
    {
        #region Configuration

        private Configuration config;

        public class Configuration
        {
            /*[JsonProperty("Use free IP lookup service providers (true/false)")] // TODO: Implement this
            public bool UseFreeServices = true;*/

            /*[JsonProperty("Use local IP database (true/false)")] // TODO: Implement this
            public bool UseLocalDatabase = false;*/

            /*[JsonProperty("Use paid IP lookup service provider (true/false)")] // TODO: Implement this
            public bool UsePaidService = true;*/

            /*[JsonProperty("Paid IP lookup service provider (domain name)")] // TODO: Implement this
            public string PaidProvider = "YOUR_PAID_PROVIDER";*/

            // TODO: Add option for custom provider URL and JSON response field

            [JsonProperty("API key for paid IP lookup service (if applicable)")]
            public string ApiKey = "YOUR_API_KEY";

            [JsonProperty("Ban player if country is blacklisted (true/false)")]
            public bool BanPlayer = false;

            [JsonProperty("Only allow players from server's country (true/false)")]
            public bool NativesOnly = false;

            [JsonProperty("Cache responses from IP lookup service provider (true/false)")]
            public bool CacheResponses = true;

            [JsonProperty("Number of retries on IP lookup fail (0 to disable)")]
            public int RetriesOnFail = 3;

            [JsonProperty("Log connections from players (true/false)")]
            public bool LogConnections = false;

            [JsonProperty("Use country code list as a whitelist (true/false)")]
            public bool IsWhitelist = false;

            [JsonProperty("List of two-digit countries codes to check", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> CountryList = new List<string> { "CN", "JP", "HK", "KR", "RU", "VN" };

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    throw new JsonException();
                }

                if (!config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch
            {
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            LogWarning($"Configuration changes saved to {Name}.json");
            Config.WriteObject(config, true);
        }

        #endregion Configuration

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CommandAdmin"] = "countries",
                ["CountryAdded"] = "Country '{0}' was added to the country list",
                ["CountryListed"] = "Country '{0}' is already in the country list",
                ["CountryNotListed"] = "Country '{0}' is not in the country list",
                ["CountryRemoved"] = "Country '{0}' was removed from the country list",
                ["InvalidCountry"] = "{0} is not a valid two-digit country code",
                ["NoPlayersFound"] = "No online players found with name or ID '{0}'",
                ["PlayerCheckFailed"] = "Getting country for {0} ({1}) at {2} failed! ({3})",
                ["PlayerConnected"] = "{0} ({1}) connected from {2}",
                ["PlayerExcluded"] = "{0} ({1}) is excluded from country checking",
                ["PlayersFound"] = "Multiple players were found, please specify: {0}",
                ["PlayerRejected"] = "This server does not allow players from {0}",
                ["NotAllowed"] = "You are not allowed to use the '{0}' command",
                ["Unknown"] = "unknown",
                ["UsageAddRemove"] = "Usage: {0} add/remove <word or phrase> - add to or remove from country list",
                ["UsageCheck"] = "Usage: {0} <player name or ID> - check if player is from a listed country",
                ["UsageList"] = "Usage: {0} list - list all countries currently on the country list"
            }, this);
        }

        #endregion Localization

        #region Initialization

        private Dictionary<string, string> apiLimits = new Dictionary<string, string>();
        private Dictionary<string, string> ipCache = new Dictionary<string, string>();
        private readonly List<Provider> providersFree = new List<Provider>();
        private readonly List<Provider> providersPaid = new List<Provider>();
        private static readonly Random random = new Random();

        private const string permAdmin = "countries.admin";
        private const string permExclude = "countries.exclude";

        private string serverCountry;

        public class Provider
        {
            public string Name { get; set; }
            public string Url { get; set; }
            public string Field { get; set; }
            public string ApiKey { get; set; }
            public int ApiLimit { get; set; }
            public string LimitPeriod { get; set; }

            public Provider(string name, string url, string field, string apiKey = "", int apiLimit = 0, string limitPeriod = "month")
            {
                Name = name;
                Url = url;
                Field = field;
                ApiKey = apiKey;
                ApiLimit = apiLimit;
                LimitPeriod = limitPeriod;
            }
        }

        private void RegisterProviders()
        {
            // TODO: Test each provider individually to confirm working

            #region Free Providers

            providersFree.Add(new Provider("dp-ip.com", "http://api.db-ip.com/v2/free/{ip}", "countryCode"));
            /*
             *   Free option, but unaware of request limit // TODO: Figure out free request limit
             */

            providersFree.Add(new Provider("freegeoip.app", "https://freegeoip.app/json/{ip}", "country_code", string.Empty, 15000, "hour"));
            /*
             *   Limit of 15,000 free requests per hour
             */

            providersFree.Add(new Provider("geolocation-db.com", "http://geolocation-db.com/json/{ip}", "country_code"));
            /*
             *   Free, but unaware of request limit // TODO: Figure out request limit
             */

            providersFree.Add(new Provider("ipgeolocationapi.com", "https://api.ipgeolocationapi.com/geolocate/{ip}", "alpha2"));
            /*
             *   Free, but unsure of request limit; caching recommended (can self-host)
             */

            //providersFree.Add(new Provider("ipinfodb.com", "http://api.ipinfodb.com/v3/ip-country/?format=json&ip={ip}&key={key}", "countryCode", config.ApiKey, 2, "second"));
            /*
             *   Limit of 2 free requests per second
             *   Get free API key: https://ipinfodb.com/register (required)
             */

            providersFree.Add(new Provider("ipwhois.io", "http://free.ipwhois.io/json/{ip}", "country_code", string.Empty, 10000, "month"));
            /*
             *   Limit of 10,000 free requests per month
             */

            #endregion Free Providers

            #region Free/Paid Providers

            //providers.Add(new Provider("extreme-ip-lookup.com", "http://extreme-ip-lookup.com/json/{ip}", "countryCode", config.ApiKey, 20, "minute")); // TODO: Figure out how API key is used
            /*
             *   Limit of 20 free requests per minute (strict); $20-25/mo for Pro package
             */

            //providers.Add(new Provider("ip-api.com", "http://ip-api.com/line/{ip}?fields=countryCode", "countryCode", config.ApiKey, 45, "minute")); // TODO: Figure out how API key is used
            /*
             *   Limit of 45 free requests per minute; unlimited paid option available for ~$15/mo: https://members.ip-api.com/
             *   Get paid API key: ??
             */

            //providers.Add(new Provider("ipapi.co", "https://ipapi.co/{ip}/json/", "country", config.ApiKey, 1000, "day")); // TODO: Figure out how API key is used
            /*
             *   Limit of 30,000 free request per month, 1k requests per day; paid options available: https://ipapi.co/#pricing
             *   Get paid API key: ??
             */

            //providers.Add(new Provider("ipdata.co", "https://api.ipdata.co/{ip}?api-key={key}", "country_code", config.ApiKey, 1500, "day"));
            /*
             *   Limit of 1,500 free requests per day; paid options available: https://ipdata.co/pricing.html
             *   Get free API key: https://ipdata.co/sign-up.html (required)
             */

            //providers.Add(new Provider("ipfinder.io", "https://api.ipfinder.io/v1/{ip}?token={key}", "country_code", config.ApiKey, 4000, "day"));
            /*
             *   Limit of 4,000 free requests per day; paid options available: https://ipfinder.io/pricing
             *   Get free API key: https://ipfinder.io/auth/signup (required)
             */

            //providers.Add(new Provider("ipgeolocation.io", "https://api.ipgeolocation.io/ipgeo?ip={ip}&apiKey={key}", "country_code2", config.ApiKey, 1000, "day"));
            /*
             *   Limit of 30,000 free requests per month, 1,000 requests per day; paid options available: https://ipgeolocation.io/pricing.html
             *   Get free API key: https://ipgeolocation.io/signup.html (required)
             */

            //providers.Add(new Provider("dp-ip.com", "http://api.db-ip.com/v2/{key}/{ip}", "countryCode", config.ApiKey));
            /*
             *   Paid option; plans start at ~$18/mo for 10k-50k per day: https://db-ip.com/api/pricing/
             *   Get paid API key: https://db-ip.com/api/pricing/basic (required)
             */

            //providers.Add(new Provider("ipstack.com", "https://api.ipstack.com/{ip}?fields=country_code&access_key={key}", "country_code", config.ApiKey, 10000, "month"));
            /*
             *   Limit of 10,000 free requests per month; paid options available: https://ipstack.com/product
             *   Get free API key: https://ipstack.com/signup/free (required)
             */

            //providers.Add(new Provider("ipapi.com", "http://api.ipapi.com/{ip}?fields=country_code&access_key={key}", "country_code", config.ApiKey, 10000, "month"));
            /*
             *   Limit of 10,000 free requests per month; paid options available: https://ipapi.com/product
             *   Get free API key: https://ipapi.com/signup/free (required)
             */

            #endregion Free/Paid Providers

            #region WIP Providers

            //providers.Add(new Provider("iphub.info", "http://v2.api.iphub.info/ip/{ip}")); // TODO: Figure out missing information
            /*
             *   Limit of ??; API key required
             *   'X-Key' header
             *   ["??"]
             */

            //providers.Add(new Provider("smartip.io", "https://api.smartip.io/{ip}?api_key={key}", "country,country-iso-code", config.ApiKey, 250000, "day")); // TODO: Handle nested fields
            /*
             *   Limit of 250,000 free requests per day; paid options available: https://smartip.io/#pricing-section
             *   Get free API key: https://smartip.io/account/register/?returnUrl=/dashboard (required)
             */

            //providers.Add(new Provider("snoopi.io", "http://api.snoopi.io/v1/?api_key={key}&user_ip_address={ip}")); // TODO: Figure out missing information
            /*
             *   Limit of ??; API key optional: ??
             *   Get API key: ??
             *   ["??"]
             */

            /*
             *   ip-geolocation.whoisxmlapi.com
             *   Limit of 1,000 free requests per month; paid options available: https://ip-geolocation.whoisxmlapi.com/api/pricing
             *   https://ip-geolocation.whoisxmlapi.com/api/v1?ipAddress={ip}&apiKey={apiKey}
             *   Get free API key: https://ip-geolocation.whoisxmlapi.com/api/signup
             *   ["location"]["country"] // TODO: Handle nested fields
             */

            /*
             *   ipinfo.io
             *   Limit of 50,000 free requests per month; paid options available: https://ipinfo.io/pricing
             *   https://ipinfo.io/{ip}?token={apiKey}
             *   Get free API key: https://ipinfo.io/signup
             *   ["country"]
             */

            /*
             *   hostip.info
             *   http://api.hostip.info/get_json.php?ip={ip}
             *   Limit of ??
             *   ["country_code"]
             */

            /*
             *   webcargo.io
             *   Limit of 500 free requests per month; paid options available: https://webcargo.io/pricing
             *   https://api.webcargo.io/ip?ip_address={ip}&key={apiKey}
             *   Get free API key: https://webcargo.io/register
             *   ["country_code"]
             */

            /*
             *   ipwhois.io
             *   Limit of ?? requests per month: https://ipwhois.io/pricing
             *   https://pro.ipwhois.io/json/{ip}?key={apiKey}
             *   ["country_code"]
             */

            /*
             *   ip-api.io // TODO: Figure out free requests limit
             *   Limit of 200 free requests per ?? without key, or 12,000 free requests per month with key; paid options available: https://ip-api.io/#pricing
             *   https://ip-api.io/json/{ip} / https://ip-api.io/json/{ip}?api_key={apiKey}
             *   ["country_code"]
             */

            /*
             *   keycdn.com // TODO: Handle nested fields
             *   Limit of 3 free requests per second
             *   https://tools.keycdn.com/geo.json?host={ip}
             *   ["data"]["geo"]["country_code"]
             */

            /*
             *   iplocate.io
             *   Limit of 1,000 free requests per day; paid options available: https://www.iplocate.io/pricing
             *   https://www.iplocate.io/api/lookup/{ip} / https://www.iplocate.io/api/lookup/{ip}?apikey={apiKey}
             *   ["country_code"]
             */

            /*
             *   ip2location.com
             *   Limt of 50 free requests per day with "demo" key, 200 free requests per day with key; paid options available: https://www.ip2location.com/buy-online#web-service
             *   https://api.ip2location.com/v2/?ip={ip}&key=demo / https://api.ip2location.com/v2/?ip={ip}&key={apiKey}
             *   ["country_code"]
             */

            /*
             *   maxmind.com
             *   https://dev.maxmind.com/geoip/geoip2/web-services/#Client_APIs
             *   https://geoip.maxmind.com/geoip/v2.1/country/{ip_address}
             *   ["country"]["iso_code"]
             */

            /*
             *   ip.city
             *   Limit of 100 free requests per day with key; paid options available: https://ip.city/users.php
             *   https://ip.city/api.php?ip=[IP]&key=[YOUR_API_KEY]
             *   ["countryCode"]
             */

            /*
             *   iptoasn.com
             *   Free, but unaware of request limit // TODO: Figure out request limit
             *   https://api.iptoasn.com/v1/as/ip/{ip}
             *   Header: 'Accept: application/json'
             *   ["as_country_code"]
             */

            #endregion WIP Providers
        }

        private void Init()
        {
            AddLocalizedCommand(nameof(CommandAdmin));

            // Register new and migrate old permission(s)
            permission.RegisterPermission(permAdmin, this);
            permission.RegisterPermission(permExclude, this);
            MigratePermission("countryblock.bypass", permExclude);

            // Check for and remove duplicate country codes from list
            List<string> origCountryList = config.CountryList;
            config.CountryList = config.CountryList.Distinct().ToList();

            // Check for and remove any invalid country codes from list
            foreach (string country in origCountryList)
            {
                if (!IsCountryCode(country))
                {
                    config.CountryList.Remove(country);
                }
            }

            // Save updated country list, if changed
            if (!config.CountryList.SequenceEqual(origCountryList))
            {
                LogWarning("Updated country list to remove invalid/duplicate entries");
                SaveConfig();
            }

            // Load stored data
            //apiLimits = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<string, string>>($"{Name}_Limits"); // TODO: Implement
            ipCache = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<string, string>>($"{Name}_Cache");

            RegisterProviders();
        }

        private void OnServerInitialized()
        {
            // Look up country for server
            serverCountry = GetCachedCountry(server.Address.ToString());
            if (string.IsNullOrEmpty(serverCountry))
            {
                Action<string, int> callback = (string response, int code) =>
                {
                    // TODO: Get and output error code

                    if (!string.IsNullOrEmpty(response))
                    {
                        serverCountry = response ?? GetLang("Unknown");
                    }
                };
                IpLookup(server.Address.ToString(), callback);
            }
        }

        #endregion Initialization

        #region Commands

        private void CommandAdmin(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission(permAdmin))
            {
                Message(player, "NotAllowed", command);
                return;
            }

            // TODO: Show command usage if subcommands do not match

            // TODO: Show command usage if arg lenth is invalid

            string countryInput = string.Empty;
            switch (args[0].ToLower())
            {
                case "+":
                case "add":
                    {
                        if (args.Length != 2)
                        {
                            Message(player, "UsageAdmin", command);
                            return;
                        }

                        countryInput = args[1].ToUpper();
                        if (!IsCountryCode(countryInput))
                        {
                            Message(player, "InvalidCountry", countryInput);
                            return;
                        }

                        if (config.CountryList.Contains(countryInput))
                        {
                            Message(player, "CountryListed", countryInput);
                            break;
                        }

                        config.CountryList.Add(countryInput);
                        SaveConfig();

                        Message(player, "CountryAdded", countryInput);
                        break;
                    }

                case "-":
                case "remove":
                    {
                        if (args.Length != 2)
                        {
                            Message(player, "UsageAdmin", command);
                            return;
                        }

                        countryInput = args[1].ToUpper();
                        if (!IsCountryCode(countryInput))
                        {
                            Message(player, "InvalidCountry", countryInput);
                            return;
                        }

                        if (!config.CountryList.Contains(countryInput))
                        {
                            Message(player, "CountryNotListed", countryInput);
                            break;
                        }

                        config.CountryList.Remove(countryInput);
                        SaveConfig();

                        Message(player, "CountryRemoved", countryInput);
                        break;
                    }

                case "?":
                case "check":
                    {
                        if (args.Length < 1)
                        {
                            Message(player, "UsageCheck", command);
                            return;
                        }

                        IPlayer target = FindPlayer(args[1], player);
                        if (target == null)
                        {
                            return;
                        }

                        Action<string, int> callback = (string response, int code) =>
                        {
                            if (string.IsNullOrEmpty(response))
                            {
                                Message(player, "PlayerCheckFailed", target.Name, target.Id, target.Address, code);
                            }
                            else
                            {
                                if (!IsCountryAllowed(response))
                                {
                                    RejectPlayer(player, response);
                                }
                            }
                        };
                        IpLookup(player.Address, callback);
                        break;
                    }

                case "list":
                    Message(player, string.Join(", ", config.CountryList.Cast<string>().ToArray()));
                    break;

                default:
                    break;
            }
        }

        #endregion Commands

        #region IP Lookup

        private void IpLookup(string ip, Action<string, int> callback = null)
        {
            // TODO: Add support for local database using Geo IP plugin API

            // TODO: Check to make sure config.ApiKey is not set to "YOUR_API_KEY", is empty, or is null

            // TODO: Implement config.UseFreeServices option for only using free providers (no API key ones)

            Provider provider = providersFree[random.Next(providersFree.Count)]; // TODO: Select another provider if at limit
            string url = provider.Url.ToLower().Replace("{ip}", ip).Replace("{key}", config.ApiKey); // TODO: Handle this better

            webrequest.Enqueue(url, null, (code, response) =>
            {
#if DEBUG
                LogWarning($"DEBUG: {url}");
                LogWarning($"DEBUG: {response}");
#endif
                int retries = 0;
                string country = string.Empty;

                if (code != 200 || string.IsNullOrEmpty(response))
                {
                    if (retries == config.RetriesOnFail)
                    {
                        callback?.Invoke(country, code); // TODO: Exclude provider that errored from next check
                        return;
                    }

                    retries++;
                    IpLookup(ip, callback);
                    return;
                }

                try
                {
                    JObject json = JObject.Parse(response);
                    // TODO: Split provider.Field into multiple fields if it contains a comma
                    if (json[provider.Field] != null && ((string)json[provider.Field]).Length == 2)
                    {
                        country = ((string)json[provider.Field]).Trim();
                    }
                }
                catch
                {
                    // Ignored
                }
                callback?.Invoke(country, code);

                // Store country and IP address in cache
                if (config.CacheResponses && !string.IsNullOrEmpty(country))
                {
                    string wildcardIp = ToWildcardIp(ip);
                    if (!IsLocalIp(ip) && !ipCache.ContainsKey(wildcardIp))
                    {
                        ipCache.Add(wildcardIp, country);
                        LogWarning($"Wildcard IP {wildcardIp} added to cache for {country}");
                        Interface.Oxide.DataFileSystem.WriteObject($"{Name}_Cache", ipCache);
                    }
                }

                // TODO: Increment and store usage toward API request limit for provider
                //Interface.Oxide.DataFileSystem.WriteObject($"{Name}_Limits", apiLimits);
#if DEBUG
                LogWarning($"DEBUG: Country response for {ip}: {(!string.IsNullOrEmpty(country) ? country : GetLang("Unknown"))}");
#endif
            }, this, RequestMethod.GET, null, 10f); // TODO: Add support for headers, and low timeout with retry
        }

        private void IsPlayerBlocked(IPlayer player)
        {
            string ip = IpAddress(player.Address);
#if DEBUG
            LogWarning($"DEBUG: Local: {IsLocalIp(ip)}, Perm: {player.HasPermission(permExclude)}");
#endif
            if (IsLocalIp(ip) || player.HasPermission(permExclude))
            {
                return;
            }

            if (config.CacheResponses)
            {
                string country = GetCachedCountry(ip);
                if (!string.IsNullOrEmpty(country) && !IsCountryAllowed(country))
                {
                    RejectPlayer(player, country);
                    return;
                }
            }

            Action<string, int> callback = (string response, int code) =>
            {
                if (string.IsNullOrEmpty(response))
                {
                    LogWarning(GetLang("PlayerCheckFailed", null, player.Name, player.Id, ip, code));
                }
                else
                {
                    if (config.LogConnections)
                    {
                        Log(GetLang("PlayerConnected", null, player.Name, player.Id, response));
                    }

                    if (!IsCountryAllowed(response))
                    {
                        RejectPlayer(player, response);
                    }
                }
            };
            IpLookup(ip, callback);
        }

        #endregion IP Lookup

        #region Player Rejection

        private object CanUserLogin(string name, string id, string ip)
        {
            if (IsLocalIp(ip) || permission.UserHasPermission(id, permExclude))
            {
                LogWarning(GetLang("PlayerExcluded", null, name, id));
                return null;
            }

            if (config.CacheResponses)
            {
                string country = GetCachedCountry(ip);
                if (!string.IsNullOrEmpty(country))
                {
                    if (config.LogConnections)
                    {
                        Log(GetLang("PlayerConnected", null, name, id, country));
                    }

                    if (!IsCountryAllowed(country))
                    {
                        return GetLang("PlayerRejected", id, country);
                    }
                }
            }

            return null;
        }

        private void OnUserConnected(IPlayer player) => IsPlayerBlocked(player);

        private void RejectPlayer(IPlayer player, string country)
        {
            if (config.BanPlayer)
            {
                player.Ban(GetLang("PlayerRejected", player.Id, country), TimeSpan.Zero); // TODO: Implement ban time and option when available
            }
            else
            {
                player.Kick(GetLang("PlayerRejected", player.Id, country));
            }
        }

        #endregion Player Rejection

        #region Helpers

        private IPlayer FindPlayer(string nameOrId, IPlayer player)
        {
            IPlayer[] foundPlayers = players.Connected.Where(p => p.Name == nameOrId).ToArray();
            if (foundPlayers.Length > 1)
            {
                Message(player, "PlayersFound", string.Join(", ", foundPlayers.Select(p => p.Name).ToArray()));
                return null;
            }

            IPlayer target = foundPlayers.Length == 1 ? foundPlayers[0] : null;
            if (target == null)
            {
                Message(player, "NoPlayersFound", nameOrId);
                return null;
            }

            return target;
        }

        private string GetCachedCountry(string ip)
        {
            string wildcardIp = ToWildcardIp(ip);
            if (ipCache.ContainsKey(wildcardIp))
            {
                return ipCache[wildcardIp];
            }

            return string.Empty;
        }

        private static string IpAddress(string ip)
        {
#if DEBUG
            return "8.8.8.8"; // US
#else
            return Regex.Replace(ip, @":{1}[0-9]{1}\d*", "");
#endif
        }

        private bool IsCountryAllowed(string country)
        {
            bool countryListed = config.CountryList.Contains(country);
            if (!config.IsWhitelist && countryListed || config.IsWhitelist && !countryListed || config.NativesOnly && !serverCountry.Equals(country))
            {
                return false;
            }
        
            return true;
        }

        private bool IsCountryCode(string countryCode)
        {
            return CultureInfo.GetCultures(CultureTypes.SpecificCultures).Select(culture => new RegionInfo(culture.LCID))
                        .Any(region => region.TwoLetterISORegionName == countryCode);
        }

        private static bool IsLocalIp(string ipAddress)
        {
            string[] split = ipAddress.Split(new[] { "." }, StringSplitOptions.RemoveEmptyEntries);
            int[] ip = new[] { int.Parse(split[0]), int.Parse(split[1]), int.Parse(split[2]), int.Parse(split[3]) };
            return ip[0] == 10 || ip[0] == 127 || (ip[0] == 192 && ip[1] == 168) || (ip[0] == 172 && (ip[1] >= 16 && ip[1] <= 31));
        }

        public static string ToWildcardIp(string ip)
        {
            return ip.Substring(0, ip.LastIndexOf(".")) + ".*";
        }

        private void AddLocalizedCommand(string command)
        {
            foreach (string language in lang.GetLanguages(this))
            {
                Dictionary<string, string> messages = lang.GetMessages(language, this);
                foreach (KeyValuePair<string, string> message in messages)
                {
                    if (message.Key.Equals(command))
                    {
                        if (!string.IsNullOrEmpty(message.Value))
                        {
                            AddCovalenceCommand(message.Value, command);
                        }
                    }
                }
            }
        }

        private string GetLang(string langKey, string playerId = null, params object[] args)
        {
            return string.Format(lang.GetMessage(langKey, this, playerId), args);
        }

        private void Message(IPlayer player, string langKey, params object[] args)
        {
            player.Reply(GetLang(langKey, player.Id, args));
        }

        private void MigratePermission(string oldPerm, string newPerm)
        {
            foreach (IPlayer player in players.All)
            {
                if (player.HasPermission(oldPerm))
                {
                    permission.GrantUserPermission(player.Id, newPerm, null);
                    permission.RevokeUserPermission(player.Id, oldPerm);
                }
            }

            foreach (string group in permission.GetGroups())
            {
                if (permission.GroupHasPermission(group, oldPerm))
                {
                    permission.GrantGroupPermission(group, newPerm, null);
                    permission.RevokeGroupPermission(group, oldPerm);
                }
            }
        }

        #endregion Helpers
    }
}

// --- End of file: Countries.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/closest-mini ---
// --- Original File Path: C/ClosestMinicopter/ClosestMinicopter.cs ---

using System;
using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("ClosestMinicopter", "GigaBit", "1.3.2")]
    [Description("Tells a player where the closest minicopter is and on what bearing")]

    class ClosestMinicopter : RustPlugin
    {
        private Dictionary<string, RaycastHit> playerData = new Dictionary<string, RaycastHit>();
        private Dictionary<string, DateTime> cooldowns = new Dictionary<string, DateTime>();
        private float searchDistance;
        private int defaultCooldown;

        protected override void LoadDefaultConfig()
        {
            Config["SearchDistance"] = 500f;
            Config["DefaultCooldown"] = 60;
            SaveConfig();
        }

        private void Init()
        {
            permission.RegisterPermission("closestminicopter.use", this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoPermission"] = "You don't have permission to use this command.",
                ["NoMinicopters"] = "You are out of luck, there are no minicopters nearby - you best run",
                ["HelicopterFound"] = "The closest Helicopter is {0} meters away on a bearing of {1}Â°",
                ["Cooldown"] = "Please wait {0} seconds before using this command again."
            }, this);
            searchDistance = Convert.ToSingle(GetConfigValue("SearchDistance", 500f));
            defaultCooldown = Convert.ToInt32(GetConfigValue("DefaultCooldown", 60));
        }

        private void SetCooldown(BasePlayer player)
        {
            if (cooldowns.ContainsKey(player.UserIDString))
                cooldowns[player.UserIDString] = DateTime.UtcNow;
            else
                cooldowns.Add(player.UserIDString, DateTime.UtcNow);
        }

        private bool HasCooldown(BasePlayer player)
        {
            if (cooldowns.ContainsKey(player.UserIDString))
            {
                DateTime lastUsage = cooldowns[player.UserIDString];
                TimeSpan cooldownTime = TimeSpan.FromSeconds(defaultCooldown);
                DateTime cooldownEnd = lastUsage + cooldownTime;
                if (DateTime.UtcNow < cooldownEnd)
                    return true;
            }
            return false;
        }

        private TimeSpan GetRemainingCooldown(BasePlayer player)
        {
            if (cooldowns.ContainsKey(player.UserIDString))
            {
                DateTime lastUsage = cooldowns[player.UserIDString];
                TimeSpan cooldownTime = TimeSpan.FromSeconds(defaultCooldown);
                DateTime cooldownEnd = lastUsage + cooldownTime;
                TimeSpan remainingTime = cooldownEnd - DateTime.UtcNow;
                return remainingTime;
            }
            return TimeSpan.Zero;
        }

        private T GetConfigValue<T>(string key, T defaultValue)
        {
            if (Config[key] == null)
            {
                Config[key] = defaultValue;
                SaveConfig();
                return defaultValue;
            }
            return (T)Convert.ChangeType(Config[key], typeof(T));
        }

        [ChatCommand("cmini")]
		private void FindClosestMinicopter(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, "closestminicopter.use"))
            {
                SendReply(player, lang.GetMessage("NoPermission", this, player.UserIDString));
                return;
            }

            if (HasCooldown(player))
            {
                TimeSpan remainingTime = GetRemainingCooldown(player);
                SendReply(player, string.Format(lang.GetMessage("Cooldown", this, player.UserIDString), remainingTime.Seconds));
                return;
            }

            RaycastHit closestMinicopter;
            if (FindClosestMinicopter(player, out closestMinicopter))
            {
                float distance = Vector3.Distance(player.transform.position, closestMinicopter.transform.position);
                float bearing = GetBearing(player.transform.position, closestMinicopter.transform.position);

                SendReply(player, string.Format(lang.GetMessage("HelicopterFound", this, player.UserIDString), Mathf.RoundToInt(distance), Mathf.RoundToInt(bearing)));
                playerData[player.UserIDString] = closestMinicopter;

                SetCooldown(player);
            }
            else
            {
                SendReply(player, lang.GetMessage("NoMinicopters", this, player.UserIDString));
                playerData.Remove(player.UserIDString);
            }
        }
      

       private bool FindClosestMinicopter(BasePlayer player, out RaycastHit closestMinicopter)
		{
			closestMinicopter = new RaycastHit();

			Vector3 origin = player.eyes.position;
			Vector3 direction = player.eyes.HeadForward();
			float closestDistance = searchDistance;

			RaycastHit[] hits = Physics.SphereCastAll(origin, searchDistance, direction);

			foreach (RaycastHit hit in hits)
			{
				BaseEntity entity = hit.GetEntity();
				if (entity != null && entity.ShortPrefabName.Contains("copter")) //Giga modified this to just copter to capture both mini and scrappy
				{
					float distance = Vector3.Distance(player.transform.position, hit.transform.position);
					if (distance < closestDistance)
					{
						closestMinicopter = hit;
						closestDistance = distance;
					}
				}
			}

			return closestMinicopter.collider != null;
		}

        private float GetBearing(Vector3 origin, Vector3 target)
        {
            Vector3 direction = (target - origin).normalized;
            float angle = Quaternion.LookRotation(direction).eulerAngles.y;
            return (angle + 360) % 360;
        }
    }
}


// --- End of file: ClosestMinicopter.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/car-collision-damage-scaler ---
// --- Original File Path: C/CarCollisionDamageScaler/CarCollisionDamageScaler.cs ---

using Oxide.Core.Plugins;

namespace Oxide.Plugins
{

    [Info("Car Collision Damage Scaler", "Zugzwang", "1.0.2")]
    [Description("Scales collision damage on the new modular vehicles.")]	
	
    public class CarCollisionDamageScaler : CovalencePlugin
    {
		#region Permissions and Config

		private const string permissionGod = "carcollisiondamagescaler.god";
		private const string permissionScale = "carcollisiondamagescaler.scale";

		private void Init()
		{
			permission.RegisterPermission(permissionGod, this);
			permission.RegisterPermission(permissionScale, this);
			config = Config.ReadObject<PluginConfig>();
		}	
		
		private PluginConfig config;
		
		private class PluginConfig
		{
			public bool requireDriver;
			public bool requirePermission;
			public float scale;
			
			public PluginConfig()
			{
				requireDriver = false; 
				requirePermission = false; 
				scale = 0.5f;
			}
		}	
		
		protected override void LoadDefaultConfig() 
		{
			Config.WriteObject(new PluginConfig(), true);
		}

		#endregion Permissions and Config

		
		void OnEntityTakeDamage(BaseVehicleModule entity, HitInfo info)
		{
			if (info?.damageTypes.Has(Rust.DamageType.Collision) != true)
				return;

			BasePlayer driver = entity.Vehicle?.GetDriver();

			if (driver != null && permission.UserHasPermission(driver.UserIDString, permissionGod))
			{
				info?.damageTypes.Scale(Rust.DamageType.Collision, 0f);	
				return;
			}

			if (config.requireDriver)
			{
				if (driver == null || (config.requirePermission && !permission.UserHasPermission(driver.UserIDString, permissionScale))) 
					return;
			}
			
			info?.damageTypes.Scale(Rust.DamageType.Collision, config.scale);
		}
		
		
	}
}

// --- End of file: CarCollisionDamageScaler.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/custom-auto-kits ---
// --- Original File Path: C/CustomAutoKits/CustomAutoKits.cs ---

ï»¿//Requires: Kits

using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Custom Auto Kits", "Absolut/Arainrr", "1.2.5", ResourceId = 41234154)]
    [Description("Automatic kits by permission")]
    public class CustomAutoKits : RustPlugin
    {
        [PluginReference] private readonly Plugin EventManager, Kits;

        private readonly Dictionary<ulong, Hash<string, float>> kitCooldown =
            new Dictionary<ulong, Hash<string, float>>();

        private void Init()
        {
            LoadData();
            cmd.AddChatCommand(configData.chatS.command, this, nameof(CmdChooseKit));
        }

        private void OnServerInitialized()
        {
            foreach (var autoKit in configData.autoKits)
            {
                if (!permission.PermissionExists(autoKit.permission, this))
                    permission.RegisterPermission(autoKit.permission, this);
                foreach (var kitS in autoKit.kits)
                    if (!IsKit(kitS.kitName))
                        PrintError($"'{kitS.kitName}' kit does not exist");
            }

            foreach (var player in BasePlayer.allPlayerList)
                storedData.players.Add(player.userID);
        }

        private void OnServerSave()
        {
            timer.Once(UnityEngine.Random.Range(0f, 60f), SaveData);
        }

        private void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
                DestroyUI(player);
            SaveData();
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player == null || !player.userID.IsSteamId()) return;
            if (!storedData.players.Add(player.userID)) return;
            OnPlayerRespawned(player);
        }

        private void OnPlayerRespawned(BasePlayer player)
        {
            var isPlaying = EventManager?.CallHook("isPlaying", player);
            if (isPlaying is bool && (bool)isPlaying) return;
            var playerData = GetPlayerData(player.userID, true);
            if (!playerData.enabled) return;
            var kitName = GetSelectedKit(player, playerData);
            if (string.IsNullOrEmpty(kitName)) return;
            if (configData.emptyInventory) player.inventory.Strip();
            GiveKit(player, kitName);

            Hash<string, float> cooldowns;
            if (kitCooldown.TryGetValue(player.userID, out cooldowns)) cooldowns[kitName] = Time.realtimeSinceStartup;
            else kitCooldown.Add(player.userID, new Hash<string, float> { { kitName, Time.realtimeSinceStartup } });
        }

        #region Methods

        private string GetSelectedKit(BasePlayer player, StoredData.PlayerData playerData)
        {
            string kitName;
            ConfigData.KitS kitS;
            var availableKits = GetAvailableKits(player);
            if (!availableKits.Any()) return null;
            if (!string.IsNullOrEmpty(playerData.selectedKit))
            {
                var found = availableKits.FirstOrDefault(x => x.kitName == playerData.selectedKit);
                if (found != null)
                {
                    kitS = found;
                }
                else
                {
                    playerData.selectedKit = null;
                    kitS = GetDefaultKit(availableKits);
                }
            }
            else
            {
                kitS = GetDefaultKit(availableKits);
            }

            if (kitS == null) return null;
            kitName = kitS.kitName;
            Hash<string, float> cooldowns;
            if (kitS.cooldown > 0 && kitCooldown.TryGetValue(player.userID, out cooldowns))
            {
                float lastUse;
                if (cooldowns.TryGetValue(kitName, out lastUse) && Time.realtimeSinceStartup - lastUse < kitS.cooldown)
                    return kitS.cooldownKit;
            }

            return kitName;
        }

        private static ConfigData.KitS GetDefaultKit(IEnumerable<ConfigData.KitS> availableKits)
        {
            return availableKits.OrderByDescending(x => x.priority).First();
        }

        private IEnumerable<ConfigData.KitS> GetAvailableKits(BasePlayer player)
        {
            return from entry in configData.autoKits
                   where permission.UserHasPermission(player.UserIDString, entry.permission)
                   from kitS in entry.kits
                   where IsKit(kitS.kitName)
                   select kitS;
        }

        private bool IsKit(string kitName)
        {
            return (bool)(Kits.Call("isKit", kitName) ?? true);
        }

        private void GiveKit(BasePlayer player, string kitName)
        {
            Kits.Call("GiveKit", player, kitName);
        }

        private StoredData.PlayerData GetPlayerData(ulong playerID, bool readOnly = false)
        {
            StoredData.PlayerData playerData;
            if (!storedData.playerPrefs.TryGetValue(playerID, out playerData))
            {
                playerData = new StoredData.PlayerData { enabled = true };
                if (readOnly) return playerData;
                storedData.playerPrefs.Add(playerID, playerData);
            }

            return playerData;
        }

        #endregion Methods

        #region Commands

        private void CmdChooseKit(BasePlayer player, string command, string[] args)
        {
            var availableKits = GetAvailableKits(player);
            if (!availableKits.Any())
            {
                Print(player, Lang("NoAvailableKits", player.UserIDString));
                return;
            }

            CreateMainUI(player);
        }

        [ConsoleCommand("CustomAutoKitsUI")]
        private void CCmdCustomAutoKitsUI(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;
            var playerData = GetPlayerData(player.userID);
            switch (arg.Args[0].ToLower())
            {
                case "toggle":
                    playerData.enabled = !playerData.enabled;
                    UpdateMenuUI(player, playerData);
                    return;

                case "choose":
                    var kitName = arg.Args[1];
                    playerData.selectedKit = playerData.selectedKit == kitName ? null : kitName;
                    UpdateMenuUI(player, playerData);
                    return;
            }
        }

        #endregion Commands

        #region UI

        private const string UINAME_MAIN = "CustomAutoKitsUI_Main";
        private const string UINAME_MENU = "CustomAutoKitsUI_Menu";

        private void CreateMainUI(BasePlayer player)
        {
            var container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                Image = { Color = "0 0 0 0" },
                RectTransform =
                    {AnchorMin = "0.5 0.5", AnchorMax = "0.5 0.5", OffsetMin = "-210 -180", OffsetMax = "210 220"},
                CursorEnabled = true
            }, "Hud", UINAME_MAIN);
            container.Add(new CuiPanel
            {
                Image = { Color = "0 0 0 0.6" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1" }
            }, UINAME_MAIN);
            var titlePanel = container.Add(new CuiPanel
            {
                Image = { Color = "0.42 0.88 0.88 1" },
                RectTransform = { AnchorMin = "0 0.902", AnchorMax = "0.995 1" }
            }, UINAME_MAIN);
            container.Add(new CuiElement
            {
                Parent = titlePanel,
                Components =
                {
                    new CuiTextComponent
                    {
                        Text = Lang("Title", player.UserIDString), FontSize = 20, Align = TextAnchor.MiddleCenter,
                        Color = "1 0 0 1"
                    },
                    new CuiOutlineComponent {Distance = "0.5 0.5", Color = "1 1 1 1"},
                    new CuiRectTransformComponent {AnchorMin = "0.2 0", AnchorMax = "0.8 1"}
                }
            });
            container.Add(new CuiButton
            {
                Button = { Color = "0.95 0.1 0.1 0.95", Close = UINAME_MAIN },
                Text = { Text = "X", Align = TextAnchor.MiddleCenter, Color = "0 0 0 1", FontSize = 22 },
                RectTransform = { AnchorMin = "0.885 0.05", AnchorMax = "0.995 0.95" }
            }, titlePanel);
            CuiHelper.DestroyUi(player, UINAME_MAIN);
            CuiHelper.AddUi(player, container);
            var playerData = GetPlayerData(player.userID, true);
            UpdateMenuUI(player, playerData);
        }

        private void UpdateMenuUI(BasePlayer player, StoredData.PlayerData playerData)
        {
            if (player == null) return;
            var container = new CuiElementContainer();
            container.Add(new CuiPanel
            {
                Image = { Color = "0.1 0.1 0.1 0.4" },
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 0.898" }
            }, UINAME_MAIN, UINAME_MENU);
            var selectedKitName = GetSelectedKit(player, playerData);
            var availableKits = GetAvailableKits(player);
            var i = 0;
            var spacing = 1f / 10;
            var anchors = GetEntryAnchors(i++, spacing);
            CreateEntry(ref container, $"CustomAutoKitsUI Toggle", Lang("Status", player.UserIDString),
                playerData.enabled ? Lang("Enabled", player.UserIDString) : Lang("Disabled", player.UserIDString),
                $"0 {anchors[0]}", $"1 {anchors[1]}");
            foreach (var kitS in availableKits)
            {
                var kitName = kitS.kitName;
                anchors = GetEntryAnchors(i++, spacing);
                CreateEntry(ref container, $"CustomAutoKitsUI Choose {kitName}", kitName,
                    selectedKitName == kitName
                        ? Lang("Selected", player.UserIDString)
                        : Lang("Unselected", player.UserIDString), $"0 {anchors[0]}", $"1 {anchors[1]}");
            }

            CuiHelper.DestroyUi(player, UINAME_MENU);
            CuiHelper.AddUi(player, container);
        }

        private static void CreateEntry(ref CuiElementContainer container, string command, string leftText,
            string rightText, string anchorMin, string anchorMax)
        {
            var panelName = container.Add(new CuiPanel
            {
                Image = { Color = "0.1 0.1 0.1 0.6" },
                RectTransform = { AnchorMin = anchorMin, AnchorMax = anchorMax }
            }, UINAME_MENU);
            container.Add(new CuiLabel
            {
                Text = { Color = "0 1 1 1", FontSize = 14, Align = TextAnchor.MiddleLeft, Text = leftText },
                RectTransform = { AnchorMin = "0.1 0", AnchorMax = "0.795 1" }
            }, panelName);
            container.Add(new CuiButton
            {
                Button = { Color = "0 0 0 0.7", Command = command },
                Text = { Text = rightText, Align = TextAnchor.MiddleCenter, Color = "1 1 1 1", FontSize = 14 },
                RectTransform = { AnchorMin = "0.8 0.01", AnchorMax = "0.995 0.99" }
            }, panelName);
        }

        private static float[] GetEntryAnchors(int i, float spacing)
        {
            return new[] { 1f - (i + 1) * spacing, 1f - i * spacing };
        }

        private static void DestroyUI(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, UINAME_MAIN);
        }

        #endregion UI

        #region ConfigurationFile

        private ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Empty default items before give kits")]
            public bool emptyInventory = true;

            [JsonProperty(PropertyName = "Auto Kits", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<AutoKit> autoKits = new List<AutoKit>
            {
                new AutoKit
                {
                    permission = "customautokits.vip1",
                    kits = new List<KitS>
                    {
                        new KitS
                        {
                            priority = 0,
                            cooldown = 0,
                            kitName = "KitName1",
                            cooldownKit = "Cooldown Kit"
                        }
                    }
                },
                new AutoKit
                {
                    permission = "customautokits.vip2",
                    kits = new List<KitS>
                    {
                        new KitS
                        {
                            priority = 1,
                            cooldown = 0,
                            kitName = "KitName2",
                            cooldownKit = "Cooldown Kit"
                        },
                        new KitS
                        {
                            priority = 2,
                            cooldown = 0,
                            kitName = "KitName21",
                            cooldownKit = "Cooldown Kit"
                        }
                    }
                }
            };

            public class AutoKit
            {
                public string permission = string.Empty;
                public List<KitS> kits = new List<KitS>();
            }

            public class KitS
            {
                public int priority;
                public float cooldown;
                public string kitName = string.Empty;
                public string cooldownKit = string.Empty;
            }

            [JsonProperty(PropertyName = "Chat Settings")]
            public ChatSettings chatS = new ChatSettings();

            public class ChatSettings
            {
                [JsonProperty(PropertyName = "Chat Command")]
                public string command = "autokit";

                [JsonProperty(PropertyName = "Chat Prefix")]
                public string prefix = "<color=#00FFFF>[CustomAutoKits]</color>: ";

                [JsonProperty(PropertyName = "Chat SteamID Icon")]
                public ulong steamIDIcon = 0;
            }

            [JsonProperty(PropertyName = "Version")]
            public VersionNumber version = new VersionNumber(1, 2, 4);
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                configData = Config.ReadObject<ConfigData>();
                if (configData == null)
                    LoadDefaultConfig();
                else
                    UpdateConfigValues();
            }
            catch
            {
                PrintError("The configuration file is corrupted");
                LoadDefaultConfig();
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            configData = new ConfigData();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(configData);
        }

        private void UpdateConfigValues()
        {
            if (configData.version < Version)
            {
                if (configData.version <= new VersionNumber(1, 2, 4))
                {
                    if (configData.chatS.prefix == "[CustomAutoKits]: ")
                    {
                        configData.chatS.prefix = "<color=#00FFFF>[CustomAutoKits]</color>: ";
                    }
                }
                configData.version = Version;
            }
        }

        #endregion ConfigurationFile

        #region DataFile

        private StoredData storedData;

        private class StoredData
        {
            public readonly Dictionary<ulong, PlayerData> playerPrefs = new Dictionary<ulong, PlayerData>();
            public readonly HashSet<ulong> players = new HashSet<ulong>();

            public class PlayerData
            {
                public bool enabled;
                public string selectedKit;
            }
        }

        private void LoadData()
        {
            try
            {
                storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
            }
            catch
            {
                storedData = null;
            }
            finally
            {
                if (storedData == null)
                {
                    ClearData();
                }
            }
        }

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(Name, storedData);
        }

        private void ClearData()
        {
            storedData = new StoredData();
            SaveData();
        }

        private void OnNewSave(string filename)
        {
            storedData.players.Clear();
            SaveData();
        }

        #endregion DataFile

        #region LanguageFile

        private void Print(BasePlayer player, string message)
        {
            Player.Message(player, message, configData.chatS.prefix, configData.chatS.steamIDIcon);
        }

        private string Lang(string key, string id = null, params object[] args)
        {
            return string.Format(lang.GetMessage(key, this, id), args);
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoAvailableKits"] = "You don't have any available kits",
                ["Title"] = "Custom Auto Kits UI",
                ["Status"] = "Respawn kit status",
                ["Selected"] = "<color=#8ee700>Selected</color>",
                ["Unselected"] = "<color=#ce422b>X</color>",
                ["Enabled"] = "<color=#8ee700>Enabled</color>",
                ["Disabled"] = "<color=#ce422b>Disabled</color>"
            }, this);

            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoAvailableKits"] = "æ¨æ²¡æå¯ç¨çå¤æ´»ç¤¼å",
                ["Title"] = "èªå®ä¹å¤æ´»ç¤¼å",
                ["Status"] = "å¤æ´»ç¤¼åç¶æ",
                ["Selected"] = "<color=#8ee700>å·²éæ©</color>",
                ["Unselected"] = "<color=#ce422b>æªéæ©</color>",
                ["Enabled"] = "<color=#8ee700>å·²å¯ç¨</color>",
                ["Disabled"] = "<color=#ce422b>å·²ç¦ç¨</color>"
            }, this, "zh-CN");
        }

        #endregion LanguageFile
    }
}

// --- End of file: CustomAutoKits.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/car-horn ---
// --- Original File Path: C/CarHorn/CarHorn.cs ---

ï»¿using System.Collections.Generic;
using UnityEngine;
using System;

namespace Oxide.Plugins
{
    [Info("Car Horn", "dFxPhoeniX", "1.1.6")]
    [Description("Adds an FX similar to that of a car horn to the driver in the sedan.")]
    class CarHorn : RustPlugin
    {
        #region variables
        private bool Changed = false;
        private string hornPrefab = "assets/prefabs/instruments/bass/effects/guitardeploy.prefab";
        private const string permissionUse = "carhorn.use";
        #endregion
            
        #region Main plugin
        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            LoadVariables();
        }

        private void OnPlayerInput(BasePlayer player, InputState input, BaseEntity entity)
        {
            if (!permission.UserHasPermission(player.UserIDString, permissionUse))
            {
                return;
            }

            if (player.GetMounted() == null)
                return;

            if (!input.IsDown(BUTTON.FIRE_SECONDARY))
                return;

            if (player.isMounted && player.GetMounted().name.Contains("driverseat"))
            {
                Effect.server.Run(hornPrefab, player.transform.position);
            }

        }



        void Init()
        {
            LoadVariables();
            permission.RegisterPermission(permissionUse, this);
        }

        #endregion 

        #region Config
        void LoadVariables()
        {
            hornPrefab = Convert.ToString(GetConfig("Horn Prefab", "FX used", "assets/prefabs/instruments/bass/effects/guitardeploy.prefab"));
            if (!Changed) return;
            SaveConfig();
            Changed = false;
        }


        object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }
        #endregion
    }
}

// --- End of file: CarHorn.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/crater-note ---
// --- Original File Path: C/CraterNote/CraterNote.cs ---

namespace Oxide.Plugins 
{
	[Info("Crater Note", "rostov114", "1.0.0")]
	[Description("Returns the analysis of the wells in a note. Like before.")]
	class CraterNote : RustPlugin 
	{
		private void OnAnalysisComplete(SurveyCrater crater, BasePlayer player)
		{
			ResourceDepositManager.ResourceDeposit orCreate = ResourceDepositManager.GetOrCreate(crater.transform.position);
			if (orCreate == null)
				return;

			Item item = ItemManager.CreateByName("note", 1, 0UL);
			item.text = "-Mineral Analysis-\n\n";
			float num = 10f;
			float num2 = 7.5f;
			foreach (ResourceDepositManager.ResourceDeposit.ResourceDepositEntry resourceDepositEntry in orCreate._resources)
			{
				float num3 = 60f / num * (num2 / resourceDepositEntry.workNeeded);
				Item item2 = item;
				item2.text = string.Concat(new string[]
				{
					item2.text,
					resourceDepositEntry.type.displayName.english,
					" : ",
					num3.ToString("0.0"),
					" pM\n"
				});
			}
			item.MarkDirty();
			player.GiveItem(item, BaseEntity.GiveItemReason.PickedUp);
		}
	}
}

// --- End of file: CraterNote.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/cctv-utilities ---
// --- Original File Path: C/CCTVUtilities/CCTVUtilities.cs ---

ï»¿using Oxide.Core.Libraries;
using System;
using System.IO;
using UnityEngine;
using UnityEngine.Networking;
using System.Collections;
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using Oxide.Core.Configuration;
using Oxide.Core;

namespace Oxide.Plugins
{
    /*  Copyright 2020, GrumpyGordon
     * 
     *  This software is licensed & protected under the MIT Copyright License (1988)
     * 
     *  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the
     *  Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,
     *  and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
     * 
     *  The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
     * 
     *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
     *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
     *  ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH
     *  THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
     * 
     */

    [Info("CCTV Utilities", "GrumpyGordon","1.5.1")]
    [Description("Allows players to quickly add all their cameras to a computer station in Rust. With additional permissions they can add all the servers cameras to their CCTV setup.")]
    public class CCTVUtilities : RustPlugin
    {
        void Init()
        {
            permission.RegisterPermission("cctvutilities.help", this);
            permission.RegisterPermission("cctvutilities.rename", this);
            permission.RegisterPermission("cctvutilities.add.me", this);
            permission.RegisterPermission("cctvutilities.add.server", this);
            permission.RegisterPermission("cctvutilities.add.custom", this);
            permission.RegisterPermission("cctvutilities.add.all", this);
            permission.RegisterPermission("cctvutilities.clear", this);
            permission.RegisterPermission("cctvutilities.status.me", this);
            permission.RegisterPermission("cctvutilities.status.server", this);
            permission.RegisterPermission("cctvutilities.status.custom", this);
            permission.RegisterPermission("cctvutilities.status.all", this);
            permission.RegisterPermission("cctvutilities.autoname", this);
            permission.RegisterPermission("cctvutilities.autoadd", this);
            permission.RegisterPermission("cctvutilities.autoadd.on", this);
            permission.RegisterPermission("cctvutilities.autoadd.off", this);
            permission.RegisterPermission("cctvutilities.autoadd.toggle", this);
            permission.RegisterPermission("cctvutilities.autoadd.me", this);
            permission.RegisterPermission("cctvutilities.autoadd.server", this);
            permission.RegisterPermission("cctvutilities.autoadd.custom", this);
            permission.RegisterPermission("cctvutilities.autoadd.all", this);
            permission.RegisterPermission("cctvutilities.autopowered", this);
            EnsureCustomConfigExists();
            LoadDefaultMessages();
        }
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NoPerm"] = "You don't have permission to perform this action",
                ["Error"] = "An error has occured! {0}",
                ["Incomplete"] = "This command is not yet complete!",
                ["ArgNotRecognised"] = "Argument is not recognised! Please try again with: {0} instead.",
                ["CheckConsole"] = "Hi {0}! Please check the console (F1) for command output!",
                //
                ["HelpAPI"] = "<color=#ff9a00ff>CCTV Utilities</color> /cctv help - Get help with CCTV Utilities",
                //
                ["Help1"] = "Help for <color=#ff9a00ff>CCTV Utilities</color> commands",
                ["Help2"] = "<color=#96ff94ff>/cctv help</color> - Sends help information.",
                ["Help3"] = "<color=#96ff94ff>/cctv status</color> <color=#ffd799ff><me | server | custom | all></color> - Prints a list of all cameras (in selected category)  to console.",
                ["Help4"] = "<color=#96ff94ff>/cctv add</color> <color=#ffd799ff><me | server | custom | all></color> - Adds cameras in selected category to a the computer station you're currently looking at.",
                ["Help5"] = "<color=#96ff94ff>/cctv clear</color> - Clears cameras from the computer station you're currently looking at.",
                ["Help6"] = "<color=#96ff94ff>/cctv rename</color> <color=#ffd799ff><Camera ID> <New Name></color> - Rename a camera identifier remotely.",
                ["Help7"] = "<color=#96ff94ff>/cctv about</color> - Provides plugin information.",
                ["Help8"] = "<color=#96ff94ff>/cctv autoname</color> <color=#ffd799ff><on | off | toggle></color> - Automatically names cameras as they are placed.",
                ["Help9"] = "<color=#96ff94ff>/cctv autoadd</color> <color=#ffd799ff><on | off | me | server | custom | all | toggle></color> - Automatically adds cameras to the computer station when placed.",
                ["Help10"] = "<color=#96ff94ff>/cctv autopowered</color> <color=#ffd799ff><on | off | toggle></color> - Automatically powers cameras when placed / server restarts.",
                //
                ["AddMe"] = "Successfully added all your cameras to this computer station!",
                ["AddServer"] = "Successfully added all Server cameras to this computer station!",
                ["AddCustom"] = "Successfully added all Custom cameras to this computer station!",
                ["AddAll"] = "Successfully added all cameras to this computer station!",
                ["WarnInactive"] = "Please bare in mind some may be inactive.",
                //
                ["Clear"] = "All cameras have been cleared from this computer station.",
                //
                ["IdentifierUpdated"] = "Camera name successfully changed from {0} to {1}",
                //
                ["DetailAll"] = "All Cameras",
                ["DetailAllHeader"] = "Camera ID: | <color=#00d619ff>Online</color> / <color=#ff0000ff>Offline</color> | Owner(OwnerSteamID)",
                ["DetailAllServer"] = "{0} | <color=#00d619ff>Online</color> | Server",
                ["DetailAllPlayerOnline"] = "{0} | <color=#00d619ff>Online</color> | {1}({2})",
                ["DetailAllPlayerOffline"] = "{0} | <color=#ff0000ff>Offline</color> | {1}({2})",
                //
                ["DetailServer"] = "All Server Owned Cameras",
                ["DetailCustom"] = "All Custom Server Owned Cameras",
                ["DetailPlayer"] = "All Player Owned Cameras",
                ["DetailUniversalHeader"] = "Camera ID: | <color=#00d619ff>Online</color> / <color=#ff0000ff>Offline</color>",
                ["DetailUniversalOnline"] = "{0} | <color=#00d619ff>Online</color>",
                ["DetailUniversalOffline"] = "{0} | <color=#00d619ff>Online</color>",
                //
                ["AboutHeader"] = "About <color=#ff9a00ff>CCTV Utilities</color>",
                ["AboutDescription"] = "Description: {0}",
                ["AboutAuthor"] = "Author: GrumpyGordon (Discord: GrumpyGordon#9728) (Web: grumpygordon.modded.org)",
                ["AboutVersion"] = "Version: {0}",
                ["AboutLicense"] = "License: This plugin is protected under the MIT License (1988)",
                //
                ["NoEntity"] = "This is not a valid entity! (Are you too far away?)",
                ["WrongEntity"] = "Please make sure you are looking at a {0}! (Are you too far away?)",
                //
                ["CamDown"] = "Camera powered down.",
                ["CamUp"] = "Camera powered up.",
                //
                ["CamNotOwner"] = "You do not own this camera!",
                ["CamNotOwnerConsole"] = "{0} tried to interact with other players CCTV: {1} owned by {2}({3})",
                ["CamNotFound"] = "We failed to find the camera you were looking for. Please ensure you have typed it correctly and try again.",
                //
                ["AutoNameOn"] = "Cameras will now be automatically named.",
                ["AutoNameOff"] = "Cameras will no longer be automatically named.",
                ["AutoNameToggleOn"] = "Camera auto naming toggled on.",
                ["AutoNameToggleOff"] = "Camera auto naming toggled off.",
                //
                ["AutoNameCamPlaced"] = "Camera placed and automatically named: {0}",
                ["AutoPoweredCamPlaced"] = "Camera placed and automatically powered",
                ["AutoNamePoweredCamPlaced"] = "Camera placed and automatically powered and named: {0}",
                //
                ["AutoAddOn"] = "Your cameras will be automatically added to computer stations when placed!",
                ["AutoAddOff"] = "Your cameras will no longer be automatically added to computer stations when placed!",
                ["AutoAddMe"] = "Your cameras will be automatically added to computer stations when placed!",
                ["AutoAddServer"] = "Server cameras will be automatically added to computer stations when placed!",
                ["AutoAddCustom"] = "Custom server cameras will be automatically added to computer stations when placed!",
                ["AutoAddAll"] = "All cameras will be automatically added to computer stations when placed!",
                ["AutoAddToggleOn"] = "Computer station auto adding toggled on.",
                ["AutoAddToggleOff"] = "Computer station auto adding toggled on.",
                //
                ["AutoPoweredOn"] = "Cameras will now be automatically powered on",
                ["AutoPoweredOff"] = "Cameras will no longer be automatically powered on",
                ["AutoPoweredToggleOn"] = "Camera auto powering toggled on.",
                ["AutoPoweredToggleOff"] = "Camera auto powering toggled off.",
                //
                ["DefaultMsg"] = "This message is here because commas."
            }, this);
        }

        void EnsureCustomConfigExists()
        {
            try
            {
                Interface.Oxide.DataFileSystem.ReadObject<string[]>("CCTVUtilities\\CustomCameras");
            }
            catch
            {
                CCTV_RC[] cams = GetServerCCTVs();
                string[] names = new string[cams.Length];
                for (int i = 0; i < cams.Length; i++)
                {
                    names[i] = cams[i].rcIdentifier;
                }
                Interface.Oxide.DataFileSystem.WriteObject("CCTVUtilities\\CustomCameras", names);
                Puts("Created Custom Cameras List using default server cameras.");
            }
        }

        //API to work with Help-Text Plugin (https://umod.org/plugins/help-text)
        private void SendHelpText(BasePlayer ply)
        {
            if (ply == null || ply.userID == 0)
            {
                return;
            }

            if (ply.IPlayer.HasPermission("cctvutilities.help"))
            {
                SendLangMsg(ply, "HelpAPI");
            }
        }

        void SendLangMsg(BasePlayer ply, string key)
        {
            ply.IPlayer.Reply(lang.GetMessage(key, this, ply.IPlayer.Id));
        }
        void SendLangMsg(BasePlayer ply, string key, string arg0)
        {
            ply.IPlayer.Reply(string.Format(lang.GetMessage(key, this, ply.IPlayer.Id), arg0));
        }
        void SendLangMsg(BasePlayer ply, string key, string arg0, string arg1)
        {
            ply.IPlayer.Reply(string.Format(lang.GetMessage(key, this, ply.IPlayer.Id), arg0, arg1));
        }
        void SendLangMsgConsole(BasePlayer ply, string key)
        {
            ply.IPlayer.Command("echo", lang.GetMessage(key, this, ply.IPlayer.Id));
        }
        void SendLangMsgConsole(BasePlayer ply, string key, string arg0)
        {
            ply.IPlayer.Command("echo", string.Format(lang.GetMessage(key, this, ply.IPlayer.Id), arg0));
        }
        void SendLangMsgConsole(BasePlayer ply, string key, string arg0, string arg1, string arg2)
        {
            ply.IPlayer.Command("echo", string.Format(lang.GetMessage(key, this, ply.IPlayer.Id), arg0, arg1, arg2));
        }

        public void SendHelpChat(BasePlayer ply)
        {
            if (ply.IPlayer.HasPermission("cctvutilities.help"))
            {
                SendLangMsg(ply, "Help1");
                SendLangMsg(ply, "Help2");
                if (ply.IPlayer.HasPermission("cctvutilities.status.me") || ply.IPlayer.HasPermission("cctvutilities.status.server") || ply.IPlayer.HasPermission("cctvutilities.status.custom") || ply.IPlayer.HasPermission("cctvutilities.status.all"))
                {
                    SendLangMsg(ply, "Help3");
                }
                if (ply.IPlayer.HasPermission("cctvutilities.add.me") || ply.IPlayer.HasPermission("cctvutilities.add.server") || ply.IPlayer.HasPermission("cctvutilities.add.custom") || ply.IPlayer.HasPermission("cctvutilities.add.all"))
                {
                    SendLangMsg(ply, "Help4");
                }
                if (ply.IPlayer.HasPermission("cctvutilities.clear"))
                {
                    SendLangMsg(ply, "Help5");
                }
                if (ply.IPlayer.HasPermission("cctvutilities.rename"))
                {
                    SendLangMsg(ply, "Help6");
                }
                SendLangMsg(ply, "Help7");
                if (ply.IPlayer.HasPermission("cctvutilities.autoname"))
                {
                    SendLangMsg(ply, "Help8");
                }
                if (ply.IPlayer.HasPermission("cctvutilities.autoadd.off") || ply.IPlayer.HasPermission("cctvutilities.autoadd.on") || ply.IPlayer.HasPermission("cctvutilities.autoadd.toggle") || ply.IPlayer.HasPermission("cctvutilities.autoadd.me") || ply.IPlayer.HasPermission("cctvutilities.autoadd.server") || ply.IPlayer.HasPermission("cctvutilities.autoadd.custom") || ply.IPlayer.HasPermission("cctvutilities.autoadd.all"))
                {
                    SendLangMsg(ply, "Help9");
                }
                if (ply.IPlayer.HasPermission("cctvutilities.autopowered"))
                {
                    SendLangMsg(ply, "Help10");
                }
            }
        }


        [ChatCommand("cctv")]
        void CCTVCommand(BasePlayer ply, string cctv, string[] args)
        {
            if (0 < args.Length)
            {
                args[0] = args[0].ToLower();
                switch (args[0])
                {
                    case "help":
                        if (ply.IPlayer.HasPermission("cctvutilities.help"))
                        {
                            SendHelpChat(ply);
                        }
                        else
                        {
                            SendLangMsg(ply, "NoPerm");
                        }
                        break;
                    case "rename":
                        if (ply.IPlayer.HasPermission("cctvutilities.rename"))
                        {
                            if(2 < args.Length)
                            {
                                if(GetCCTVAuth(args[1], ply) != null)
                                {
                                    CCTV_RC cam = GetCCTVAuth(args[1], ply);
                                    cam.UpdateIdentifier(args[2]);
                                    SendLangMsg(ply, "IdentifierUpdated", args[1], args[2]);
                                }                                
                            }
                            else
                            {
                                SendLangMsg(ply, "ArgNotRecognised", "<Camera ID> <New ID>");
                            }
                        }
                        else
                        {
                            SendLangMsg(ply, "NoPerm");
                        }
                        break;
                    case "add":
                        args[1] = args[1].ToLower();
                        if (1 < args.Length)
                        {
                            switch (args[1])
                            {
                                case "me":
                                    if (ply.IPlayer.HasPermission("cctvutilities.add.me"))
                                    {
                                        var cs = FindCCTVStationByRay(ply);
                                        if (cs != null)
                                        {
                                            foreach (var item in GetPlayerCCTVs(ply))
                                            {
                                                if (!cs.controlBookmarks.ContainsKey(item.rcIdentifier))
                                                {
                                                    cs.controlBookmarks.Add(item.rcIdentifier, item.net.ID);
                                                }
                                            }
                                        }
                                        SendLangMsg(ply, "AddMe");
                                        SendLangMsg(ply, "WarnInactive");
                                    }
                                    else
                                    {
                                        SendLangMsg(ply, "NoPerm");
                                    }
                                    break;
                                case "server":
                                    if (ply.IPlayer.HasPermission("cctvutilities.add.server"))
                                    {
                                        var cs = FindCCTVStationByRay(ply);
                                        if (cs != null)
                                        {
                                            foreach (var item in GetServerCCTVs())
                                            {
                                                if (!cs.controlBookmarks.ContainsKey(item.rcIdentifier))
                                                {
                                                    cs.controlBookmarks.Add(item.rcIdentifier, item.net.ID);
                                                }
                                            }
                                            SendLangMsg(ply, "AddServer");
                                        }
                                    }
                                    else
                                    {
                                        SendLangMsg(ply, "NoPerm");
                                    }
                                    break;
                                case "custom":
                                    if (ply.IPlayer.HasPermission("cctvutilities.add.custom"))
                                    {
                                        var cs = FindCCTVStationByRay(ply);
                                        if (cs != null)
                                        {
                                            foreach (var item in GetCustomCCTVs())
                                            {
                                                if (!cs.controlBookmarks.ContainsKey(item.rcIdentifier))
                                                {
                                                    cs.controlBookmarks.Add(item.rcIdentifier, item.net.ID);
                                                }
                                            }
                                            SendLangMsg(ply, "AddCustom");
                                        }
                                    }
                                    else
                                    {
                                        SendLangMsg(ply, "NoPerm");
                                    }
                                    break;
                                case "all":
                                    if (ply.IPlayer.HasPermission("cctvutilities.add.all"))
                                    {
                                        var cs = FindCCTVStationByRay(ply);
                                        if (cs != null)
                                        {
                                            foreach (var item in GetCCTVs())
                                            {
                                                if (!cs.controlBookmarks.ContainsKey(item.rcIdentifier))
                                                {
                                                    cs.controlBookmarks.Add(item.rcIdentifier, item.net.ID);
                                                }
                                            }
                                            SendLangMsg(ply, "AddAll");
                                            SendLangMsg(ply, "WarnInactive");
                                        }
                                    }
                                    else
                                    {
                                        SendLangMsg(ply, "NoPerm");
                                    }
                                    break;
                                default:
                                    SendLangMsg(ply, "ArgNotRecognised", "me | server | custom | all");
                                    break;
                            }
                        }
                        else
                        {
                            if (ply.IPlayer.HasPermission("cctvutilities.add.me"))
                            {
                                var cs = FindCCTVStationByRay(ply);
                                if (cs != null)
                                {
                                    foreach (var item in GetPlayerCCTVs(ply))
                                    {
                                        if (!cs.controlBookmarks.ContainsKey(item.rcIdentifier))
                                        {
                                            cs.controlBookmarks.Add(item.rcIdentifier, item.net.ID);
                                        }
                                    }
                                }
                                SendLangMsg(ply, "AddMe");
                                SendLangMsg(ply, "WarnInactive");
                            }
                            else
                            {
                                SendLangMsg(ply, "NoPerm");
                            }
                        }
                        break;
                    case "clear":
                        if (ply.IPlayer.HasPermission("cctvutilities.clear"))
                        {
                            var cs = FindCCTVStationByRay(ply);
                            if (cs != null)
                            {
                                cs.controlBookmarks.Clear();
                                SendLangMsg(ply, "Clear");
                            }
                        }
                        else
                        {
                            SendLangMsg(ply, "NoPerm");
                        }
                        break;
                    case "status":
                        args[1] = args[1].ToLower();
                        if (1 < args.Length)
                        {
                            switch (args[1])
                            {
                                case "me":
                                    if (ply.IPlayer.HasPermission("cctvutilities.status.me"))
                                    {
                                        SendLangMsgConsole(ply, "DetailPlayer");
                                        SendLangMsgConsole(ply, "DetailUniversalHeader");
                                        foreach (var cam in GetPlayerCCTVs(ply))
                                        {
                                            if (cam.IsPowered())
                                            {
                                                SendLangMsgConsole(ply, "DetailUniversalOnline", cam.rcIdentifier);
                                            }
                                            else
                                            {
                                                SendLangMsgConsole(ply, "DetailUniversalOffline", cam.rcIdentifier);
                                            }
                                        }
                                        SendLangMsg(ply, "CheckConsole", ply.displayName);
                                    }
                                    else
                                    {
                                        SendLangMsg(ply, "NoPerm");
                                    }
                                    break;
                                case "server":
                                    if (ply.IPlayer.HasPermission("cctvutilities.status.server"))
                                    {
                                        SendLangMsgConsole(ply, "DetailServer");
                                        SendLangMsgConsole(ply, "DetailUniversalHeader");
                                        foreach (var cam in GetServerCCTVs())
                                        {
                                            SendLangMsgConsole(ply, "DetailAllServer", cam.rcIdentifier);
                                        }
                                        SendLangMsg(ply, "CheckConsole", ply.displayName);
                                    }
                                    else
                                    {
                                        SendLangMsg(ply, "NoPerm");
                                    }
                                    break;
                                case "custom":
                                    if (ply.IPlayer.HasPermission("cctvutilities.status.custom"))
                                    {
                                        SendLangMsgConsole(ply, "DetailCustom");
                                        SendLangMsgConsole(ply, "DetailAllHeader");
                                        foreach (var cam in GetCustomCCTVs())
                                        {
                                            if (cam.OwnerID == 0)
                                            {
                                                SendLangMsgConsole(ply, "DetailAllServer", cam.rcIdentifier);
                                            }
                                            else
                                            {
                                                if (cam.IsPowered())
                                                {
                                                    SendLangMsgConsole(ply, "DetailAllPlayerOnline", cam.rcIdentifier, GetPlyName(cam.OwnerID), cam.OwnerID.ToString());
                                                }
                                                else
                                                {
                                                    SendLangMsgConsole(ply, "DetailAllPlayerOffline", cam.rcIdentifier, GetPlyName(cam.OwnerID), cam.OwnerID.ToString());
                                                }
                                            }
                                        }
                                        SendLangMsg(ply, "CheckConsole", ply.displayName);
                                    }
                                    else
                                    {
                                        SendLangMsg(ply, "NoPerm");
                                    }
                                    break;
                                case "all":
                                    if (ply.IPlayer.HasPermission("cctvutilities.status.all"))
                                    {
                                        SendLangMsgConsole(ply, "DetailAll");
                                        SendLangMsgConsole(ply, "DetailAllHeader");
                                        foreach (var cam in GetCCTVs())
                                        {
                                            if (cam.OwnerID == 0)
                                            {
                                                SendLangMsgConsole(ply, "DetailAllServer", cam.rcIdentifier);
                                            }
                                            else
                                            {
                                                if (cam.IsPowered())
                                                {
                                                    SendLangMsgConsole(ply, "DetailAllPlayerOnline", cam.rcIdentifier, GetPlyName(cam.OwnerID), cam.OwnerID.ToString());
                                                }
                                                else
                                                {
                                                    SendLangMsgConsole(ply, "DetailAllPlayerOffline", cam.rcIdentifier, GetPlyName(cam.OwnerID), cam.OwnerID.ToString());
                                                }
                                            }
                                        }
                                        SendLangMsg(ply, "CheckConsole", ply.displayName);
                                    }
                                    else
                                    {
                                        SendLangMsg(ply, "NoPerm");
                                    }
                                    break;
                                default:
                                    SendLangMsg(ply, "ArgNotRecognised", "me | server | all");
                                    break;
                            }
                        }
                        else
                        {
                            if (ply.IPlayer.HasPermission("cctvutilities.status.me"))
                            {
                                SendLangMsgConsole(ply, "DetailPlayer");
                                SendLangMsgConsole(ply, "DetailUniversalHeader");
                                foreach (var cam in GetPlayerCCTVs(ply))
                                {
                                    if (cam.IsPowered())
                                    {
                                        SendLangMsgConsole(ply, "DetailUniversalOnline", cam.rcIdentifier);
                                    }
                                    else
                                    {
                                        SendLangMsgConsole(ply, "DetailUniversalOffline", cam.rcIdentifier);
                                    }
                                }
                                SendLangMsg(ply, "CheckConsole", ply.displayName);
                            }
                            else
                            {
                                SendLangMsg(ply, "NoPerm");
                            }
                        }
                        break;
                    case "about":
                        SendLangMsg(ply, "CheckConsole", ply.displayName);
                        SendLangMsgConsole(ply, "AboutHeader");
                        SendLangMsgConsole(ply, "AboutDescription", this.Description);
                        SendLangMsgConsole(ply, "AboutAuthor");
                        SendLangMsgConsole(ply, "AboutVersion", this.Version.ToString());
                        SendLangMsgConsole(ply, "AboutLicense");
                        break;
                    case "autoname":
                        args[1] = args[1].ToLower();
                        if (ply.IPlayer.HasPermission("cctvutilities.autoname"))
                        {
                            if (1 < args.Length)
                            {
                                SetCCTVAutoname(ply, args[1]);
                            }
                            else
                            {
                                SetCCTVAutoname(ply, "toggle");
                            }
                        }
                        else
                        {
                            SendLangMsg(ply, "NoPerm");
                        }
                        break;
                    case "autoadd":
                        args[1] = args[1].ToLower();
                        if (ply.IPlayer.HasPermission("cctvutilities.autoadd"))
                        {
                            if (1 < args.Length)
                            {
                                SetCCTVAutoadd(ply, args[1]);
                            }
                            else
                            {
                                SetCCTVAutoadd(ply, "toggle");
                            }
                        }
                        else
                        {
                            SendLangMsg(ply, "NoPerm");
                        }
                        break;
                    case "autopowered":
                        args[1] = args[1].ToLower();
                        if (ply.IPlayer.HasPermission("cctvutilities.autopowered"))
                        {
                            if (1 < args.Length)
                            {
                                SetCCTVAutopowered(ply, args[1]);
                            }
                            else
                            {
                                SetCCTVAutopowered(ply, "toggle");
                            }
                        }
                        else
                        {
                            SendLangMsg(ply, "NoPerm");
                        }
                        break;
                    default:
                        SendLangMsg(ply, "ArgNotRecognised", "help | status | add | clear | rename | about | autoname | autoadd | autopowered");
                        break;
                        //Made By Grumpy Gordon :)
                }
            }
            else
            {
                if (ply.IPlayer.HasPermission("cctvutilities.help"))
                {
                    SendHelpChat(ply);
                }
                else
                {
                    SendLangMsg(ply, "NoPerm");
                }
            }
        }
        CCTV_RC FindCCTVByRay(BasePlayer ply)
        {
            RaycastHit ray;
            if (!Physics.Raycast(ply.eyes.HeadRay(), out ray, 5f))
            {
                SendLangMsg(ply, "NoEntity");
                return null;
            }
            CCTV_RC cctv = ray.GetEntity() as CCTV_RC;

            if(cctv == null)
            {
                SendLangMsg(ply, "WrongEntity", "Camera");
                return null;
            }
            else
            {
                return cctv;
            }
        }
        ComputerStation FindCCTVStationByRay(BasePlayer ply)
        {
            RaycastHit ray;

            if (!Physics.Raycast(ply.eyes.HeadRay(), out ray, 5f))
            {
                SendLangMsg(ply, "NoEntity");
                return null;
            }
            ComputerStation cctv = ray.GetEntity() as ComputerStation;

            if (cctv == null)
            {
                SendLangMsg(ply, "WrongEntity", "Computer Station");
                return null;
            }
            else
            {
                return cctv;
            }
        }
        CCTV_RC[] GetCCTVs()
        {
            return GameObject.FindObjectsOfType<CCTV_RC>();
        }
        CCTV_RC[] GetPlayerCCTVs(BasePlayer ply)
        {
            List<CCTV_RC> list = new List<CCTV_RC>(); 
            foreach (var item in GetCCTVs())
            {
                if(item.OwnerID == ply.userID)
                {
                    list.Add(item);
                }
            }
            return list.ToArray();
        }
        CCTV_RC[] GetServerCCTVs()
        {
            List<CCTV_RC> list = new List<CCTV_RC>();
            foreach (var item in GetCCTVs())
            {
                if (item.OwnerID == 0)
                {
                    list.Add(item);
                }
            }
            return list.ToArray();
        }
        CCTV_RC[] GetCustomCCTVs()
        {
            List<CCTV_RC> list = new List<CCTV_RC>();

            foreach (var cam in GetCCTVs())
            {
                if (GetCustomCCTVNames().Contains(cam.rcIdentifier))
                {
                    list.Add(cam);
                }
            }
            return list.ToArray();
        }
        string[] GetCustomCCTVNames()
        {
            return Interface.Oxide.DataFileSystem.ReadObject<string[]>("CCTVUtilities\\CustomCameras");
        }
        CCTV_RC FindCCTV(string id)
        {
            foreach (var item in GetCCTVs())
            {
                if(item.rcIdentifier == id)
                {
                    return item;
                }
            }
            return null;
        }
        CCTV_RC GetCCTVAuth(string id, BasePlayer ply)
        {
            var cam = FindCCTV(id);
            if (cam != null)
            {
                if (IsCCTVOwner(cam, ply))
                {
                    return cam;
                }
                else
                {
                    SendLangMsg(ply, "CamNotOwner");
                    Puts(string.Format(lang.GetMessage("CamNotOwnerConsole", this, ply.IPlayer.Id), ply.displayName, cam.rcIdentifier, GetPlyName(cam.OwnerID), cam.OwnerID));
                    return null;
                }
            }
            else
            {
                SendLangMsg(ply, "CamNotFound");
                return null;
            }
        }
        CCTV_RC GetCCTVAuth(CCTV_RC cam, BasePlayer ply)
        {
            if (cam != null)
            {
                if (IsCCTVOwner(cam, ply))
                {
                    return cam;
                }
                else
                {
                    SendLangMsg(ply, "CamNotOwner");
                    Puts(string.Format(lang.GetMessage("CamNotOwnerConsole", this, ply.IPlayer.Id), ply.displayName, cam.rcIdentifier, GetPlyName(cam.OwnerID), cam.OwnerID));
                    return null;
                }
            }
            else
            {
                return null;
            }
        }
        bool IsCCTVOwner(CCTV_RC cctv, BasePlayer ply)
        {
            if(cctv.OwnerID == ply.userID)
            {
                return true;
            }
            else
            {
                return false;
            }
        }
        string GetPlyName(ulong id)
        {
            if (BasePlayer.FindByID(id) != null)
            {
                return BasePlayer.FindByID(id).displayName;
            }
            else
            {
                return "Server";
            }
        }

        void SetCCTVAutoname(BasePlayer ply, string arg)
        {
            DynamicConfigFile dataFile = Interface.Oxide.DataFileSystem.GetDatafile("CCTVUtilities\\PlayerOptions");
            switch (arg)
            {
                case "on":
                    dataFile[ply.userID + "_autoname"] = true;
                    dataFile.Save();
                    SendLangMsg(ply, "AutoNameOn");
                    break;
                case "off":
                    dataFile[ply.userID + "_autoname"] = false;
                    dataFile.Save();
                    SendLangMsg(ply, "AutoNameOff");
                    break;
                case "toggle":
                    if (dataFile[ply.userID + "_autoname"] == null)
                    {
                        dataFile[ply.userID + "_autoname"] = true;
                        SendLangMsg(ply, "AutoNameToggleOn");
                    }
                    else if (dataFile[ply.userID + "_autoname"].ToString().ToLower() == "true")
                    {
                        dataFile[ply.userID + "_autoname"] = false;
                        SendLangMsg(ply, "AutoNameToggleOff");
                    }
                    else if (dataFile[ply.userID + "_autoname"].ToString().ToLower() == "false")
                    {
                        dataFile[ply.userID + "_autoname"] = true;
                        SendLangMsg(ply, "AutoNameToggleOn");
                    }
                    else
                    {
                        dataFile[ply.userID + "_autoname"] = true;
                        SendLangMsg(ply, "AutoNameToggleOn");
                    }
                    dataFile.Save();
                    break;
                default:
                    SendLangMsg(ply, "ArgNotRecognised", "on | off | toggle");
                    break;
            }
        }
        void SetCCTVAutopowered(BasePlayer ply, string arg)
        {
            DynamicConfigFile dataFile = Interface.Oxide.DataFileSystem.GetDatafile("CCTVUtilities\\PlayerOptions");
            switch (arg)
            {
                case "on":
                    dataFile[ply.userID + "_autopowered"] = true;
                    dataFile.Save();
                    SendLangMsg(ply, "AutoPoweredOn");
                    break;
                case "off":
                    dataFile[ply.userID + "_autopowered"] = false;
                    dataFile.Save();
                    SendLangMsg(ply, "AutoPoweredOff");
                    break;
                case "toggle":
                    if (dataFile[ply.userID + "_autopowered"] == null)
                    {
                        dataFile[ply.userID + "_autopowered"] = true;
                        SendLangMsg(ply, "AutoPoweredToggleOn");
                    }
                    else if (dataFile[ply.userID + "_autopowered"].ToString().ToLower() == "true")
                    {
                        dataFile[ply.userID + "_autopowered"] = false;
                        SendLangMsg(ply, "AutoPoweredToggleOff");
                    }
                    else if (dataFile[ply.userID + "_autopowered"].ToString().ToLower() == "false")
                    {
                        dataFile[ply.userID + "_autopowered"] = true;
                        SendLangMsg(ply, "AutoPoweredToggleOn");
                    }
                    else
                    {
                        dataFile[ply.userID + "_autopowered"] = true;
                        SendLangMsg(ply, "AutoPoweredToggleOn");
                    }
                    dataFile.Save();
                    break;
                default:
                    SendLangMsg(ply, "ArgNotRecognised", "on | off | toggle");
                    break;
            }
        }
        void SetCCTVAutoadd(BasePlayer ply, string arg)
        {
            DynamicConfigFile dataFile = Interface.Oxide.DataFileSystem.GetDatafile("CCTVUtilities\\PlayerOptions");
            switch (arg)
            {
                case "on":
                    if (ply.IPlayer.HasPermission("cctvutilities.autoadd.on"))
                    {
                        dataFile[ply.userID + "_autoadd"] = "me";
                        dataFile.Save();
                        SendLangMsg(ply, "AutoAddOn");
                    }
                    else
                    {
                        SendLangMsg(ply, "NoPerm");
                    }
                    break;
                case "off":
                    if (ply.IPlayer.HasPermission("cctvutilities.autoadd.off"))
                    {
                        dataFile[ply.userID + "_autoadd"] = false;
                        dataFile.Save();
                        SendLangMsg(ply, "AutoAddOff");
                    }
                    else
                    {
                        SendLangMsg(ply, "NoPerm");
                    }
                    break;
                case "me":
                    if (ply.IPlayer.HasPermission("cctvutilities.autoadd.me"))
                    {
                        dataFile[ply.userID + "_autoadd"] = "me";
                        dataFile.Save();
                        SendLangMsg(ply, "AutoAddMe");
                    }
                    else
                    {
                        SendLangMsg(ply, "NoPerm");
                    }
                    break;
                case "server":
                    if (ply.IPlayer.HasPermission("cctvutilities.autoadd.server"))
                    {
                        dataFile[ply.userID + "_autoadd"] = "server";
                        dataFile.Save();
                        SendLangMsg(ply, "AutoAddServer");
                    }
                    else
                    {
                        SendLangMsg(ply, "NoPerm");
                    }
                    break;
                case "custom":
                    if (ply.IPlayer.HasPermission("cctvutilities.autoadd.custom"))
                    {
                        dataFile[ply.userID + "_autoadd"] = "custom";
                        dataFile.Save();
                        SendLangMsg(ply, "AutoAddCustom");
                    }
                    else
                    {
                        SendLangMsg(ply, "NoPerm");
                    }
                    break;
                case "all":
                    if (ply.IPlayer.HasPermission("cctvutilities.autoadd.all"))
                    {
                        dataFile[ply.userID + "_autoadd"] = "all";
                        dataFile.Save();
                        SendLangMsg(ply, "AutoAddAll");
                    }
                    else
                    {
                        SendLangMsg(ply, "NoPerm");
                    }
                    break;
                case "toggle":
                    if (ply.IPlayer.HasPermission("cctvutilities.autoadd.toggle"))
                    {
                        if (dataFile[ply.userID + "_autoadd"] == null)
                        {
                            dataFile[ply.userID + "_autoadd"] = "me";
                            SendLangMsg(ply, "AutoAddToggleOn");
                        }
                        else if (dataFile[ply.userID + "_autoadd"].ToString().ToLower() == "me")
                        {
                            dataFile[ply.userID + "_autoadd"] = false;
                            SendLangMsg(ply, "AutoAddToggleOff");
                        }
                        else if (dataFile[ply.userID + "_autoadd"].ToString().ToLower() == "false")
                        {
                            dataFile[ply.userID + "_autoadd"] = "me";
                            SendLangMsg(ply, "AutoAddToggleOn");
                        }
                        else
                        {
                            dataFile[ply.userID + "_autoadd"] = "me";
                            SendLangMsg(ply, "AutoAddToggleOn");
                        }
                    }
                    else
                    {
                        SendLangMsg(ply, "NoPerm");
                    }
                    dataFile.Save();
                    break;
                default:
                    SendLangMsg(ply, "ArgNotRecognised", "on | off | me | server | custom | all | toggle");
                    break;
            }
        }

        void OnEntityBuilt(Planner plan, GameObject go)
        {
            BaseEntity be = go.ToBaseEntity();
            BasePlayer ply = BasePlayer.FindByID(be.OwnerID);
            if (be.name == "assets/prefabs/deployable/cctvcamera/cctv_deployed.prefab")
            {
                CCTV_RC cam = be as CCTV_RC;

                DynamicConfigFile dataFile = Interface.Oxide.DataFileSystem.GetDatafile("CCTVUtilities\\PlayerOptions");
                if (dataFile[ply.userID + "_autoname"] != null && dataFile[ply.userID + "_autopowered"] != null)
                {
                    if (dataFile[ply.userID + "_autoname"].ToString().ToLower() == "true" && dataFile[ply.userID + "_autopowered"].ToString().ToLower() == "true")
                    {
                        cam.UpdateIdentifier(RandomString(12));
                        cam.UpdateHasPower(25, 1);
                        SendLangMsg(ply, "AutoNamePoweredCamPlaced", cam.rcIdentifier);
                    }
                }
                else if (dataFile[ply.userID + "_autoname"] != null)
                {
                    if (dataFile[ply.userID + "_autoname"].ToString().ToLower() == "true")
                    {
                        cam.UpdateIdentifier(RandomString(12));
                        SendLangMsg(ply, "AutoNameCamPlaced", cam.rcIdentifier);
                    }
                }
                else if (dataFile[ply.userID + "_autopowered"] != null)
                {
                    if (dataFile[ply.userID + "_autopowered"].ToString().ToLower() == "true")
                    {
                        cam.UpdateHasPower(25, 1);
                        SendLangMsg(ply, "AutoPoweredCamPlaced");
                    }
                }
            }
            else if (be.name == "assets/prefabs/deployable/computerstation/computerstation.deployed.prefab")
            {
                ComputerStation cs = be as ComputerStation;
                
                DynamicConfigFile dataFile = Interface.Oxide.DataFileSystem.GetDatafile("CCTVUtilities\\PlayerOptions");
                if (dataFile[ply.userID + "_autoadd"] != null)
                {
                    string option = dataFile[ply.userID + "_autoadd"].ToString().ToLower();
                    switch (option)
                    {
                        case "me":
                            if (ply.IPlayer.HasPermission("cctvutilities.autoadd.me"))
                            {
                                if (cs != null)
                                {
                                    foreach (var item in GetPlayerCCTVs(ply))
                                    {
                                        if (!cs.controlBookmarks.ContainsKey(item.rcIdentifier))
                                        {
                                            cs.controlBookmarks.Add(item.rcIdentifier, item.net.ID);
                                        }
                                    }
                                }
                                SendLangMsg(ply, "AddMe");
                            }
                            else
                            {
                                SendLangMsg(ply, "NoPerm");
                            }
                            break;
                        case "server":
                            if (ply.IPlayer.HasPermission("cctvutilities.autoadd.server"))
                            {
                                if (cs != null)
                                {
                                    foreach (var item in GetServerCCTVs())
                                    {
                                        if (!cs.controlBookmarks.ContainsKey(item.rcIdentifier))
                                        {
                                            cs.controlBookmarks.Add(item.rcIdentifier, item.net.ID);
                                        }
                                    }
                                }
                                SendLangMsg(ply, "AddServer");
                            }
                            else
                            {
                                SendLangMsg(ply, "NoPerm");
                            }
                            break;
                        case "custom":
                            if (ply.IPlayer.HasPermission("cctvutilities.autoadd.custom"))
                            {
                                if (cs != null)
                                {
                                    foreach (var item in GetCustomCCTVs())
                                    {
                                        if (!cs.controlBookmarks.ContainsKey(item.rcIdentifier))
                                        {
                                            cs.controlBookmarks.Add(item.rcIdentifier, item.net.ID);
                                        }
                                    }
                                }
                                SendLangMsg(ply, "AddCustom");
                            }
                            else
                            {
                                SendLangMsg(ply, "NoPerm");
                            }
                            break;
                        case "all":
                            if (ply.IPlayer.HasPermission("cctvutilities.autoadd.all"))
                            {
                                if (cs != null)
                                {
                                    foreach (var item in GetCCTVs())
                                    {
                                        if (!cs.controlBookmarks.ContainsKey(item.rcIdentifier))
                                        {
                                            cs.controlBookmarks.Add(item.rcIdentifier, item.net.ID);
                                        }
                                    }
                                }
                                SendLangMsg(ply, "AddAll");
                            }
                            else
                            {
                                SendLangMsg(ply, "NoPerm");
                            }
                            break;
                        case "false":
                            break;
                        default:
                            if (ply.IPlayer.HasPermission("cctvutilities.autoadd.me"))
                            {
                                if (cs != null)
                                {
                                    foreach (var item in GetPlayerCCTVs(ply))
                                    {
                                        if (!cs.controlBookmarks.ContainsKey(item.rcIdentifier))
                                        {
                                            cs.controlBookmarks.Add(item.rcIdentifier, item.net.ID);
                                        }
                                    }
                                }
                                SendLangMsg(ply, "AddMe");
                            }
                            else
                            {
                                SendLangMsg(ply, "NoPerm");
                            }
                            break;
                    }
                }
            }
        }
        string RandomString(int length)
        {
            var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
            var stringChars = new char[length];
            var random = new System.Random();

            for (int i = 0; i < stringChars.Length; i++)
            {
                stringChars[i] = chars[random.Next(chars.Length)];
            }
            return new String(stringChars);
        }
        void OnEntitySpawned(CCTV_RC cam)
        {
            if(cam.OwnerID != 0)
            {
                DynamicConfigFile dataFile = Interface.Oxide.DataFileSystem.GetDatafile("CCTVUtilities\\PlayerOptions");
                BasePlayer ply = BasePlayer.FindByID(cam.OwnerID);
                if (dataFile[ply.userID + "_autopowered"] != null)
                {
                    if (dataFile[ply.userID + "_autopowered"].ToString().ToLower() == "true")
                    {
                        cam.UpdateHasPower(25, 1);
                    }
                }
                cam.UpdateHasPower(25, 1);
            }
        }
    }
}


// --- End of file: CCTVUtilities.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/custom-loot-spawns ---
// --- Original File Path: C/CustomLootSpawns/CustomLootSpawns.cs ---

ï»¿using Facepunch;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;
using System;
using System.Collections.Generic;
using Network;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace Oxide.Plugins
{
    [Info("Custom Loot Spawns", "k1lly0u", "0.2.17")]
    [Description("Creates additional custom spawn points for loot boxes of your choosing")]
    class CustomLootSpawns : RustPlugin
    {
        #region Fields

        private CLSData clsData;
        private DynamicConfigFile clsdata;

        private Dictionary<BaseEntity, int> boxCache = new Dictionary<BaseEntity, int>();
        private Dictionary<int, CustomBoxData> boxTypes = new Dictionary<int, CustomBoxData>();
        private List<Timer> refreshTimers = new List<Timer>();
        private List<BaseEntity> wipeList = new List<BaseEntity>();

        private Dictionary<ulong, BoxCreator> boxCreators = new Dictionary<ulong, BoxCreator>();

        private const int blueprintId = -996920608;

        #endregion Fields

        #region Oxide Hooks

        private void Loaded()
        {
            permission.RegisterPermission("customlootspawns.admin", this);
            lang.RegisterMessages(messages, this);
            clsdata = Interface.Oxide.DataFileSystem.GetFile("CustomSpawns/cls_data");
            clsdata.Settings.Converters = new JsonConverter[] { new StringEnumConverter(), new UnityVector3Converter() };
        }

        private void OnServerInitialized()
        {
            LoadVariables();
            LoadData();
            FindBoxTypes();
            InitializeBoxSpawns();
        }

        private void OnEntityKill(BaseNetworkable entity)
        {
            BaseEntity baseEnt = entity as BaseEntity;
            if (baseEnt == null) return;
            if (wipeList.Contains(baseEnt)) return;
            if (entity.GetComponent<LootContainer>())
            {
                if (boxCache.ContainsKey(baseEnt))
                {
                    InitiateRefresh(baseEnt, boxCache[baseEnt]);
                }
            }
            else if (entity.GetComponent<StorageContainer>())
            {
                if (boxCache.ContainsKey(baseEnt))
                {
                    InitiateRefresh(baseEnt, boxCache[baseEnt]);
                }
            }
        }

        private void OnPlayerLootEnd(PlayerLoot inventory)
        {
            BasePlayer player = inventory.GetComponent<BasePlayer>();
            if (boxCreators.ContainsKey(player.userID))
            {
                StoreBoxData(player);
                boxCreators.Remove(player.userID);
            }

            if (inventory.entitySource != null)
            {
                BaseEntity box = inventory.entitySource;
                if (boxCache.ContainsKey(box))
                {
                    if (box is LootContainer) return;
                    if (box is StorageContainer)
                    {
                        if ((box as StorageContainer).inventory.itemList.Count == 0)
                            box.KillMessage();
                    }
                }
            }
        }

        private void OnLootSpawn(LootContainer container)
        {
            if (boxCache.ContainsKey(container))
                SpawnLoot(container, boxCache[container]);
        }

        private void Unload()
        {
            foreach (Timer time in refreshTimers)
                time.Destroy();

            foreach (KeyValuePair<BaseEntity, int> box in boxCache)
            {
                if (box.Key == null) continue;

                ClearContainer(box.Key);
                box.Key.KillMessage();
            }
            boxCache.Clear();
        }

        #endregion Oxide Hooks

        #region Box Control

        private void InitializeBoxSpawns()
        {
            foreach (KeyValuePair<int, CLBox> box in clsData.lootBoxes)
            {
                InitializeNewBox(box.Key);
            }
        }

        private void InitiateRefresh(BaseEntity box, int ID)
        {
            if (!clsData.lootBoxes.TryGetValue(ID, out CLBox boxData))
                return;
           
            int time = configData.RespawnTimer * 60;
            if (boxData.time > 0)
                time = boxData.time;

            refreshTimers.Add(timer.Once(time, () =>
            {
                InitializeNewBox(ID);
            }));

            boxCache.Remove(box);
        }

        private void InitializeNewBox(int ID)
        {
            if (!clsData.lootBoxes.TryGetValue(ID, out CLBox boxData))
                return;

            BaseEntity newBox = SpawnBoxEntity(boxData.boxType.Type, boxData.Position, boxData.yRotation, boxData.boxType.SkinID);

            SpawnLoot(newBox, ID);
            boxCache.Add(newBox, ID);
        }

        private void SpawnLoot(BaseEntity entity, int ID)
        {
            if (!clsData.lootBoxes.TryGetValue(ID, out CLBox boxData))
                return;

            if (!string.IsNullOrEmpty(boxData.customLoot) && clsData.customBoxes.ContainsKey(boxData.customLoot))
            {
                CustomBoxData customLoot = clsData.customBoxes[boxData.customLoot];
                if (customLoot.itemList.Count > 0)
                {
                    timer.In(3, () =>
                    {
                        ClearContainer(entity);
                        for (int i = 0; i < customLoot.itemList.Count; i++)
                        {
                            ItemStorage itemInfo = customLoot.itemList[i];
                            Item item;

                            if (itemInfo.IsBlueprint)
                            {
                                item = CreateItem(blueprintId, itemInfo.Amount, itemInfo.SkinID);
                                item.blueprintTarget = itemInfo.ID;
                            }
                            else item = CreateItem(itemInfo.ID, itemInfo.Amount, itemInfo.SkinID);

                            if (entity is LootContainer)
                                item.MoveToContainer((entity as LootContainer).inventory);
                            else item.MoveToContainer((entity as StorageContainer).inventory);
                        }
                    });
                }
            }
        }

        private BaseEntity SpawnBoxEntity(string type, Vector3 pos, float rot, ulong skin = 0)
        {
            BaseEntity entity = InstantiateEntity(type, pos, Quaternion.Euler(0, rot, 0));
            entity.skinID = skin;
            entity.enableSaving = false;
            entity.Spawn();
            return entity;
        }

        private BaseEntity InstantiateEntity(string type, Vector3 position, Quaternion rotation)
        {
            GameObject gameObject = Instantiate.GameObject(GameManager.server.FindPrefab(type), position, rotation);
            gameObject.name = type;

            SceneManager.MoveGameObjectToScene(gameObject, Rust.Server.EntityScene);

            UnityEngine.Object.Destroy(gameObject.GetComponent<Spawnable>());

            if (!gameObject.activeSelf)
                gameObject.SetActive(true);

            BaseEntity component = gameObject.GetComponent<BaseEntity>();
            return component;
        }

        private void ClearContainer(BaseEntity container)
        {
            if (container is LootContainer)
            {
                (container as LootContainer).minSecondsBetweenRefresh = -1;
                (container as LootContainer).maxSecondsBetweenRefresh = 0;
                (container as LootContainer).CancelInvoke("SpawnLoot");

                while ((container as LootContainer).inventory.itemList.Count > 0)
                {
                    Item item = (container as LootContainer).inventory.itemList[0];
                    item.RemoveFromContainer();
                    item.Remove(0f);
                }
            }
            else
            {
                while ((container as StorageContainer).inventory.itemList.Count > 0)
                {
                    Item item = (container as StorageContainer).inventory.itemList[0];
                    item.RemoveFromContainer();
                    item.Remove(0f);
                }
            }
        }

        #endregion Box Control

        #region Custom Loot Creation

        private void AddSpawn(BasePlayer player, int type, int time)
        {
            CustomBoxData boxData = boxTypes[type];
            Vector3 pos = GetSpawnPos(player);
            int ID = GenerateRandomID();
            clsData.lootBoxes.Add(ID, new CLBox { Position = pos, yRotation = player.GetNetworkRotation().y, boxType = boxData.boxType, customLoot = boxData.Name, time = time });
            SaveData();
            InitializeNewBox(ID);
        }

        private void CreateNewCLB(BasePlayer player, string name, int type, ulong skin = 0)
        {
            if (boxCreators.ContainsKey(player.userID))
            {
                if (boxCreators[player.userID].entity != null)
                {
                    ClearContainer(boxCreators[player.userID].entity);
                    boxCreators[player.userID].entity.KillMessage();
                }
                boxCreators.Remove(player.userID);
            }
            CustomBoxData boxData = boxTypes[type];
            Vector3 pos = GetGroundPosition(player.transform.position + (player.eyes.BodyForward() * 2));

            BaseEntity box = GameManager.server.CreateEntity(boxData.boxType.Type, pos);
            if (boxData.boxType.SkinID != 0)
                box.skinID = boxData.boxType.SkinID;

            box.enableSaving = false;
            box.SendMessage("SetDeployedBy", player, UnityEngine.SendMessageOptions.DontRequireReceiver);
            box.Spawn();

            ClearContainer(box);

            boxCreators.Add(player.userID, new BoxCreator { entity = box, boxData = new CustomBoxData { Name = name, boxType = boxData.boxType } });
        }

        private void StoreBoxData(BasePlayer player)
        {
            ulong ID = player.userID;
            BoxCreator boxData = boxCreators[ID];

            List<Item> itemList = Pool.Get<List<Item>>();

            if (boxData.entity is LootContainer)
                itemList = (boxData.entity as LootContainer).inventory.itemList;
            else itemList = (boxData.entity as StorageContainer).inventory.itemList;

            List<ItemStorage> storedList = new List<ItemStorage>();
            for (int i = 0; i < itemList.Count; i++)
            {
                Item item = itemList[i];

                bool isBlueprint = false;
                int itemId = item.info.itemid;
                if (itemId == blueprintId)
                {
                    isBlueprint = true;
                    itemId = item.blueprintTarget;
                }

                storedList.Add(new ItemStorage { ID = itemId, Amount = item.amount, Shortname = item.info.shortname, SkinID = item.skin, IsBlueprint = isBlueprint });
            }
            Pool.FreeUnmanaged(ref itemList);

            if (storedList.Count == 0)
            {
                SendMSG(player, MSG("noItems", player.UserIDString));
                boxData.entity.KillMessage();
                boxCreators.Remove(player.userID);
                return;
            }
            CustomBoxData data = new CustomBoxData { boxType = boxData.boxData.boxType, Name = boxData.boxData.Name, itemList = storedList };
            clsData.customBoxes.Add(boxData.boxData.Name, data);
            boxTypes.Add(boxTypes.Count + 1, data);
            SaveData();
            SendMSG(player, string.Format(MSG("boxCreated", player.UserIDString), boxTypes.Count, boxData.boxData.Name));
            ClearContainer(boxData.entity);
            boxData.entity.KillMessage();
            boxCreators.Remove(player.userID);
            
        }

        #endregion Custom Loot Creation

        #region Helper Methods

        private Item CreateItem(int itemID, int itemAmount, ulong itemSkin) => ItemManager.CreateByItemID(itemID, itemAmount, itemSkin);

        private int GenerateRandomID() => UnityEngine.Random.Range(0, 999999999);

        private Vector3 GetGroundPosition(Vector3 sourcePos) 
        {
            if (Physics.Raycast(sourcePos, Vector3.down, out RaycastHit hitInfo, LayerMask.GetMask("Terrain", "World", "Construction")))
            {
                sourcePos.y = hitInfo.point.y;
            }
            sourcePos.y = Mathf.Max(sourcePos.y, TerrainMeta.HeightMap.GetHeight(sourcePos));
            return sourcePos;
        }

        private void FindBoxTypes()
        {
            Dictionary<string, UnityEngine.Object> files = FileSystem.Backend.cache;
            int i = 1;
            foreach (string str in files.Keys)
            {
                if ((str.StartsWith("assets/content/") || str.StartsWith("assets/bundled/") || str.StartsWith("assets/prefabs/")) && str.EndsWith(".prefab"))
                {
                    if (str.Contains("resource/loot") || str.Contains("radtown/crate") || str.Contains("radtown/loot") || str.Contains("loot") || str.Contains("radtown/oil"))
                    {
                        if (!str.Contains("ot/dm tier1 lootb"))
                        {
                            GameObject gmobj = GameManager.server.FindPrefab(str);

                            if (gmobj?.GetComponent<BaseEntity>() != null)
                            {
                                boxTypes.Add(i, new CustomBoxData { boxType = new BoxType { Type = str, SkinID = 0 } });
                                i++;
                            }
                        }
                    }
                }
            }
            boxTypes.Add(i, new CustomBoxData { boxType = new BoxType { Type = "assets/prefabs/deployable/large wood storage/box.wooden.large.prefab", SkinID = 0 } });
            i++;
            boxTypes.Add(i, new CustomBoxData { boxType = new BoxType { Type = "assets/prefabs/deployable/large wood storage/box.wooden.large.prefab", SkinID = 10124, SkinName = "Ammo" } });
            i++;
            boxTypes.Add(i, new CustomBoxData { boxType = new BoxType { Type = "assets/prefabs/deployable/large wood storage/box.wooden.large.prefab", SkinID = 10123, SkinName = "FirstAid" } });
            i++;
            boxTypes.Add(i, new CustomBoxData { boxType = new BoxType { Type = "assets/prefabs/deployable/large wood storage/box.wooden.large.prefab", SkinID = 10141, SkinName = "Guns" } });
            i++;
            foreach (KeyValuePair<string, CustomBoxData> box in clsData.customBoxes)
            {
                boxTypes.Add(i, box.Value);
                i++;
            }
        }

        private Vector3 GetSpawnPos(BasePlayer player)
        {
            Vector3 closestHitpoint;
            Vector3 sourceEye = player.transform.position + new Vector3(0f, 1.5f, 0f);
            Quaternion currentRot = Quaternion.Euler(player.serverInput.current.aimAngles);
            Ray ray = new Ray(sourceEye, currentRot * Vector3.forward);

            RaycastHit[] hits = Physics.RaycastAll(ray);
            float closestdist = 999999f;
            closestHitpoint = player.transform.position;

            foreach (RaycastHit hit in hits)
            {
                if (hit.collider.GetComponentInParent<TriggerBase>() == null)
                {
                    if (hit.distance < closestdist)
                    {
                        closestdist = hit.distance;
                        closestHitpoint = hit.point;
                    }
                }
            }
            return closestHitpoint;
        }

        private BaseEntity FindContainer(BasePlayer player)
        {
            Vector3 currentRot = Quaternion.Euler(player.serverInput.current.aimAngles) * Vector3.forward;
            Vector3 eyesAdjust = new Vector3(0f, 1.5f, 0f);

            object rayResult = CastRay(player.transform.position + eyesAdjust, currentRot);
            if (rayResult is BaseEntity)
            {
                BaseEntity box = rayResult as BaseEntity;
                return box;
            }
            return null;
        }

        private object CastRay(Vector3 Pos, Vector3 Aim)
        {
            RaycastHit[] hits = Physics.RaycastAll(Pos, Aim);
            object target = null;

            foreach (RaycastHit hit in hits)
            {
                if (hit.distance < 100)
                {
                    if (hit.collider.GetComponentInParent<StorageContainer>() != null)
                        target = hit.collider.GetComponentInParent<StorageContainer>();
                    else if (hit.collider.GetComponentInParent<LootContainer>() != null)
                        target = hit.collider.GetComponentInParent<LootContainer>();
                }
            }
            return target;
        }

        private List<BaseEntity> FindInRadius(Vector3 pos, float rad)
        {
            List<BaseEntity> foundBoxes = new List<BaseEntity>();
            foreach (KeyValuePair<BaseEntity, int> item in boxCache)
            {
                Vector3 itemPos = item.Key.transform.position;
                if (GetDistance(pos, itemPos.x, itemPos.y, itemPos.z) < rad)
                {
                    foundBoxes.Add(item.Key);
                }
            }
            return foundBoxes;
        }

        private float GetDistance(Vector3 v3, float x, float y, float z)
        {
            float distance = 1000f;

            distance = (float)Math.Pow(Math.Pow(v3.x - x, 2) + Math.Pow(v3.y - y, 2), 0.5);
            distance = (float)Math.Pow(Math.Pow(distance, 2) + Math.Pow(v3.z - z, 2), 0.5);

            return distance;
        }

        private bool IsUncreateable(string name)
        {
            foreach (string entry in unCreateable)
            {
                if (name.Contains(entry))
                    return true;
            }
            return false;
        }

        private void ShowBoxList(BasePlayer player)
        {
            foreach (KeyValuePair<int, CustomBoxData> entry in boxTypes)
            {               
                SendEchoConsole(player.net.connection, string.Format("{0} - {1} {2}", entry.Key, entry.Value.boxType.Type, entry.Value.boxType.SkinName));
            }
        }

        private void ShowCurrentBoxes(BasePlayer player)
        {
            foreach (KeyValuePair<int, CLBox> box in clsData.lootBoxes)
            {
                string str = string.Empty;
                if (box.Value.time > 0)
                    str = string.Format("Position: {0} - Type: {1} - Respawn Time: {2} seconds", box.Value.Position, box.Value.boxType.Type, box.Value.time);
                else str = string.Format("Position: {0} - Type: {1}", box.Value.Position, box.Value.boxType.Type);

                SendEchoConsole(player.net.connection, str);
            }
        }

        private void SendEchoConsole(Network.Connection cn, string msg)
        {
            if (Net.sv.IsConnected())
            {
                NetWrite netWrite = Net.sv.StartWrite();
                netWrite.PacketID(Network.Message.Type.ConsoleMessage);
                netWrite.String(msg);
                netWrite.Send(new SendInfo(cn));
            }
        }

        private bool IsLootBox(BaseEntity entity) => boxCache.ContainsKey(entity);

        #endregion Helper Methods

        #region Chat Commands

        [ChatCommand("cls")]
        private void chatLootspawn(BasePlayer player, string command, string[] args)
        {
            if (!CanSpawnLoot(player))
                return;

            if (args.Length == 0)
            {
                SendReply(player, MSG("synAdd1", player.UserIDString));
                SendReply(player, MSG("synRem", player.UserIDString));
                SendReply(player, MSG("createSyn", player.UserIDString));
                SendReply(player, MSG("synList", player.UserIDString));
                SendReply(player, MSG("synBoxes", player.UserIDString));
                SendReply(player, MSG("synWipe", player.UserIDString));
                return;
            }

            if (args.Length >= 1)
            {
                switch (args[0].ToLower())
                {
                    case "add":
                        {
                            if (!int.TryParse(args[1], out int type))
                            {
                                SendMSG(player, MSG("notNum", player.UserIDString));
                                return;
                            }
                            int time;
                            if (args.Length > 2)
                            {
                                if (!int.TryParse(args[2], out time))
                                {
                                    SendMSG(player, MSG("notTime", player.UserIDString));
                                    return;
                                }
                            }
                            else time = -1;

                            if (boxTypes.ContainsKey(type))
                            {
                                AddSpawn(player, type, time);
                                return;
                            }
                            SendMSG(player, MSG("notType", player.UserIDString));
                        }
                        return;

                    case "create":
                        {
                            if (!(args.Length == 3))
                            {
                                SendMSG(player, MSG("createSyn", player.UserIDString));
                                return;
                            }
                            if (!(args[1] == "") || (args[1] == null))
                            {
                                if (clsData.customBoxes.ContainsKey(args[1]))
                                {
                                    SendMSG(player, MSG("nameExists", player.UserIDString));
                                    return;
                                }

                                if (!int.TryParse(args[2], out int type))
                                {
                                    SendMSG(player, MSG("notNum", player.UserIDString));
                                    return;
                                }
                                if (boxTypes.ContainsKey(type))
                                {
                                    if (IsUncreateable(boxTypes[type].boxType.Type))
                                    {
                                        SendMSG(player, MSG("unCreateable", player.UserIDString));
                                        return;
                                    }
                                    CreateNewCLB(player, args[1], type, boxTypes[type].boxType.SkinID);
                                    return;
                                }
                                SendMSG(player, MSG("notType", player.UserIDString));
                                return;
                            }
                            SendReply(player, MSG("createSyn", player.UserIDString));
                        }
                        return;

                    case "remove":
                        {
                            BaseEntity box = FindContainer(player);
                            if (box != null)
                            {
                                if (boxCache.ContainsKey(box))
                                {
                                    if (clsData.lootBoxes.ContainsKey(boxCache[box]))
                                    {
                                        clsData.lootBoxes.Remove(boxCache[box]);
                                        SaveData();
                                    }
                                    ClearContainer(box);
                                    box.KillMessage();
                                    SendMSG(player, MSG("removedBox", player.UserIDString));
                                    return;
                                }
                                else
                                    SendMSG(player, MSG("notReg", player.UserIDString));
                                return;
                            }
                            SendMSG(player, MSG("notBox", player.UserIDString));
                        }
                        return;

                    case "list":
                        ShowCurrentBoxes(player);
                        SendMSG(player, MSG("checkConsole", player.UserIDString));
                        return;

                    case "boxes":
                        ShowBoxList(player);
                        SendMSG(player, MSG("checkConsole", player.UserIDString));
                        return;

                    case "near":
                        {
                            float rad = 3f;
                            if (args.Length == 2) float.TryParse(args[1], out rad);

                            List<BaseEntity> boxes = FindInRadius(player.transform.position, rad);
                            if (boxes != null)
                            {
                                SendMSG(player, string.Format(MSG("foundBoxes", player.UserIDString), boxes.Count));
                                foreach (BaseEntity box in boxes)
                                {
                                    player.SendConsoleCommand("ddraw.box", 30f, Color.magenta, box.transform.position, 1f);
                                }
                            }
                            else
                                SendMSG(player, string.Format(MSG("noFind", player.UserIDString), rad));
                        }
                        return;

                    case "wipe":
                        {
                            foreach (KeyValuePair<BaseEntity, int> box in boxCache)
                            {
                                wipeList.Add(box.Key);
                                ClearContainer(box.Key);
                                box.Key.KillMessage();
                            }
                            clsData.lootBoxes.Clear();
                            wipeList.Clear();
                            SaveData();
                            SendMSG(player, string.Format(MSG("wipedAll1", player.UserIDString), clsData.lootBoxes.Count));
                        }
                        return;

                    case "wipeall":
                        {                           
                            foreach (KeyValuePair<BaseEntity, int> box in boxCache)
                            {
                                wipeList.Add(box.Key);
                                ClearContainer(box.Key);
                                box.Key.KillMessage();
                            }
                            clsData.lootBoxes.Clear();
                            clsData.customBoxes.Clear();
                            wipeList.Clear();
                            SaveData();
                            SendMSG(player, string.Format(MSG("wipedData1", player.UserIDString), clsData.lootBoxes.Count, clsData.customBoxes.Count));
                        }
                        return;

                    default:
                        break;
                }
            }
        }
        private bool CanSpawnLoot(BasePlayer player)
        {
            if (permission.UserHasPermission(player.UserIDString, "customlootspawns.admin")) return true;
            SendMSG(player, MSG("noPerms", player.UserIDString));
            return false;
        }

        #endregion Chat Commands

        #region Config

        private ConfigData configData;

        private class ConfigData
        {
            public int RespawnTimer { get; set; }
        }

        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            ConfigData config = new ConfigData
            {
                RespawnTimer = 20
            };
            SaveConfig(config);
        }

        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();

        private void SaveConfig(ConfigData config) => Config.WriteObject(config, true);

        #endregion Config

        #region Data Management

        private void SaveData() => clsdata.WriteObject(clsData);

        private void LoadData()
        {
            try
            {
                clsData = clsdata.ReadObject<CLSData>();
            }
            catch
            {
                clsData = new CLSData();
            }
        }

        private class CLSData
        {
            public Dictionary<int, CLBox> lootBoxes = new Dictionary<int, CLBox>();
            public Dictionary<string, CustomBoxData> customBoxes = new Dictionary<string, CustomBoxData>();
        }

        #endregion Data Management

        #region Classes

        private class CLBox
        {
            public float yRotation;
            public Vector3 Position;
            public BoxType boxType;
            public string customLoot;
            public int time;
        }

        private class BoxCreator
        {
            public BaseEntity entity;
            public CustomBoxData boxData;
        }

        private class CustomBoxData
        {
            public string Name = null;
            public BoxType boxType = new BoxType();
            public List<ItemStorage> itemList = new List<ItemStorage>();
        }

        private class BoxType
        {
            public string SkinName = null;
            public ulong SkinID;
            public string Type;
        }

        private class ItemStorage
        {
            public string Shortname;
            public int ID;
            public ulong SkinID;
            public int Amount;
            public bool IsBlueprint = false;
        }

        private class UnityVector3Converter : JsonConverter
        {
            public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
            {
                Vector3 vector = (Vector3)value;
                writer.WriteValue($"{vector.x} {vector.y} {vector.z}");
            }

            public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
            {
                if (reader.TokenType == JsonToken.String)
                {
                    string[] values = reader.Value.ToString().Trim().Split(' ');
                    return new Vector3(Convert.ToSingle(values[0]), Convert.ToSingle(values[1]), Convert.ToSingle(values[2]));
                }
                JObject o = JObject.Load(reader);
                return new Vector3(Convert.ToSingle(o["x"]), Convert.ToSingle(o["y"]), Convert.ToSingle(o["z"]));
            }

            public override bool CanConvert(Type objectType)
            {
                return objectType == typeof(Vector3);
            }
        } 
        #endregion Classes

        #region Messaging

        private void SendMSG(BasePlayer player, string message) => SendReply(player, $"<color=orange>{Title}:</color> <color=#939393>{message}</color>");

        private string MSG(string key, string playerid = null) => lang.GetMessage(key, this, playerid);

        private Dictionary<string, string> messages = new Dictionary<string, string>()
        {
            {"checkConsole", "Check your console for a list of boxes" },
            {"noPerms", "You do not have permission to use this command" },
            {"notType", "The number you have entered is not on the list" },
            {"notNum", "You must enter a box number" },
            {"notTime", "You must enter a valid time in seconds" },
            {"notBox", "You are not looking at a box" },
            {"notReg", "This is not a custom placed box" },
            {"removedBox", "Box deleted" },
            {"synAdd1", "<color=orange>/cls add id <opt:time></color><color=#939393>- Adds a new box, optional argument of time between respawn in seconds</color>" },
            {"createSyn", "<color=orange>/cls create yourboxname ## </color><color=#939393>- Builds a custom loot box with boxID: ## and Name: yourboxname</color>" },
            {"nameExists", "You already have a box with that name" },
            {"synRem", "<color=orange>/cls remove </color><color=#939393>- Remove the box you are looking at</color>" },
            {"synBoxes", "<color=orange>/cls boxes </color><color=#939393>- List available box types and their ID</color>" },
            {"synWipe", "<color=orange>/cls wipe </color><color=#939393>- Wipes all custom placed boxes</color>" },
            {"synList", "<color=orange>/cls list </color><color=#939393>- Puts all custom box details to console</color>" },
            {"synNear", "<color=orange>/cls near XX </color><color=#939393>- Shows custom loot boxes in radius XX</color>" },
            {"wipedAll1", "Wiped {0} custom loot spawns" },
            {"wipedData1", "Wiped {0} custom loot spawns and {1} custom loot kits" },
            {"foundBoxes", "Found {0} loot spawns near you"},
            {"noFind", "Couldn't find any boxes in radius: {0}M" },
            {"noItems", "You didnt place any items in the box" },
            {"boxCreated", "You have created a new loot box. ID: {0}, Name: {1}" },
            {"unCreateable", "You can not create custom loot for this type of box" }
        };

        #endregion Messaging

        private List<string> unCreateable = new List<string> { "barrel", "trash", "giftbox" };
    }
}

// --- End of file: CustomLootSpawns.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/code-reset ---
// --- Original File Path: C/CodeReset/CodeReset.cs ---

ï»¿using System;
using System.Collections.Generic;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Configuration;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Code Reset", "Default", "1.0.3")]
    [Description("Resets codelock code on the targeted door")]
    class CodeReset : RustPlugin
    {
        #region variables

        public bool Changed = false;
        private readonly string usePerm = "codereset.use";
        private string codecommand = "resetcode";
        private string setcodecommand = "setcode";
        private float autodisable = 30f;
        private bool clearusers = false;
        private System.Random _random = new System.Random();
        private HashSet<ulong> _coding = new HashSet<ulong>();
        static CodeReset _pluginInstance;
        SavedData _pluginData;

        #endregion

        #region Commands


        private void CmdResetCode(BasePlayer player, string command, string[] args)
        {
            if (player == null || !permission.UserHasPermission(player.UserIDString, usePerm))
            {
                PrintToChat(player, string.Format(lang.GetMessage("NoPermission", this, player.UserIDString)));
                return;
            }

            if (_coding.Contains(player.userID))
            {
                _coding.Remove(player.userID);
                PrintToChat(player, string.Format(lang.GetMessage("TurnedOff", this, player.UserIDString)));
                return;
            }
            _coding.Add(player.userID);
            PrintToChat(player, string.Format(lang.GetMessage("TurnedOn", this, player.UserIDString), autodisable));
            timer.Once(autodisable, () =>
            {
                if (_coding.Contains(player.userID))
                {
                    _coding.Remove(player.userID);
                    PrintToChat(player, string.Format(lang.GetMessage("AutoOff", this, player.UserIDString)));
                    return;
                }
                else return;
            });
        }


        void CmdSetCode(BasePlayer player, string command, string[] args)
        {
            if (player == null || !permission.UserHasPermission(player.UserIDString, usePerm))
            {
                PrintToChat(player, string.Format(lang.GetMessage("NoPermission", this, player.UserIDString)));
                return;
            }

            //string randomcode = GenerateRandomNo();

            //TODO Add function to allow for a randomly generated code for the admin to use
            if (args.Length == 0 || args[0].Length != 4)
            {
                PrintToChat(player, string.Format(lang.GetMessage("NoArgs", this, player.UserIDString)));
                return;
            }

            /*else if (args[0].Length != 4) 
            {
                if (!_pluginData.PlayerNumbers.ContainsKey(player.userID))
                {
                    _pluginData.addCode(player.userID, randomcode);
                    _pluginData.Save();
                    PrintToChat(player, string.Format(lang.GetMessage("SetCode", this, player.UserIDString), randomcode));
                    return;
                }
                else
                {
                    _pluginData.PlayerNumbers[player.userID] = randomcode;
                    _pluginData.Save();
                    PrintToChat(player, string.Format(lang.GetMessage("SetCode", this, player.UserIDString), randomcode));
                    return;
                }
            }*/

            if (!_pluginData.PlayerNumbers.ContainsKey(player.userID))
            {
                _pluginData.addCode(player.userID, args[0]);
                _pluginData.Save();
                PrintToChat(player, string.Format(lang.GetMessage("SetCode", this, player.UserIDString), args[0]));
                return;
            }
            else 
            {
                _pluginData.PlayerNumbers[player.userID] = args[0];
                _pluginData.Save();
                PrintToChat(player, string.Format(lang.GetMessage("SetCode", this, player.UserIDString), args[0]));
                return;
            }
        }

        #endregion

        #region Hooks

        void Init()
        {
            LoadVariables();
            lang.RegisterMessages(Messages, this);
            permission.RegisterPermission(usePerm, this);
            cmd.AddChatCommand(codecommand, this, nameof(CmdResetCode));
            cmd.AddChatCommand(setcodecommand, this, nameof(CmdSetCode));
            _pluginInstance = this;
            _pluginData = SavedData.Load();
            _coding.Clear();
        }


        /*void OnServerInitialized(bool initial)
        {
            if (initial && clearusers) 
            {
                int i = 0;
                foreach (var admin in _pluginData.PlayerNumbers.Keys) 
                {
                    BasePlayer user = FindPlayer(admin);
                    if (!user.IsAdmin) 
                    {
                        permission.RevokeUserPermission(admin.ToString(), usePerm);
                        _pluginData.PlayerNumbers.Remove(admin);
                        i++;
                    }
                }
                Log("CodeReset", $"Removed {i} users no longer under admin status");
            }

            
        }*/

        void Unload() 
        {
            _pluginInstance = null;
            _coding.Clear();
        }

        private void OnPlayerInput(BasePlayer player, InputState input)
        {
            if (!input.WasJustPressed(BUTTON.FIRE_PRIMARY) || player == null || !permission.UserHasPermission(player.UserIDString, usePerm)) { return; }
            handleCodeLock(player);
            return;
        }

        void handleCodeLock(BasePlayer player) 
        {
            if (!_coding.Contains(player.userID)) return;
            RaycastHit RayHit;
            var flag1 = Physics.Raycast(player.eyes.HeadRay(), out RayHit, 20f);
            BaseEntity baseEntity = flag1 ? RayHit.GetEntity() : null;
            if (baseEntity == null) return;
            CodeLock codelock = (CodeLock)baseEntity.GetSlot(BaseEntity.Slot.Lock);
            if (!_pluginData.PlayerNumbers.ContainsKey(player.userID))
            {
                PrintToChat(player, string.Format(lang.GetMessage("NoCode", this, player.UserIDString), setcodecommand));
                return;
            }
            if (codelock.code == _pluginData.PlayerNumbers[player.userID])
            {
                PrintToChat(player, string.Format(lang.GetMessage("AlreadyUsed", this, player.UserIDString), codelock.code));
                return;
            }
            codelock.code = _pluginData.PlayerNumbers[player.userID];
            BasePlayer ownerplayer = FindPlayer(codelock.OwnerID);
            Log("CodeReset", $"Player: {player.displayName} has reset a codelock to {_pluginData.PlayerNumbers[player.userID]} for {ownerplayer.displayName} | {ownerplayer.userID}");
            codelock.whitelistPlayers = new List<ulong>();
            codelock.guestPlayers = new List<ulong>();
            PrintToChat(player, string.Format(lang.GetMessage("ChangedCode", this, player.UserIDString), _pluginData.PlayerNumbers[player.userID]));
        }


        #endregion

        #region Helpers

        public string GenerateRandomNo()
        {

            return _random.Next(0, 9999).ToString("0000");
        }


        private void Log(string filename, string text)
        {
            LogToFile(filename, $"[{DateTime.Now}] {text.Replace("{", "").Replace("}", "")}", this);
        }

        private static BasePlayer FindPlayer(ulong userId)
        {
            foreach (var activePlayer in BasePlayer.activePlayerList)
            {
                if (activePlayer.userID == userId)
                    return activePlayer;
            }
            foreach (var sleepingPlayer in BasePlayer.sleepingPlayerList)
            {
                if (sleepingPlayer.userID == userId)
                    return sleepingPlayer;
            }
            return null;
        }

        #endregion

        #region Config
        object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }

        void LoadVariables()
        {

            codecommand = Convert.ToString(GetConfig("Code Reset", "Enable tool command", "resetcode"));
            setcodecommand = Convert.ToString(GetConfig("Code Reset", "Set code command", "setcode"));
            autodisable = Convert.ToSingle(GetConfig("Code Reset", "Auto disable time", 30f));
            //clearusers = Convert.ToBoolean(GetConfig("Code Reset", "Automatically purge users no longer an admin? (On server startup)", false));

            if (!Changed) return;
            SaveConfig();
            Changed = false;
        }

        protected override void LoadDefaultConfig()
        {
            Config.Clear();
            LoadVariables();
        }
        #endregion

        #region Data/Messages

        Dictionary<string, string> Messages = new Dictionary<string, string>()
        {
            {"NoPermission", "You lack <color=#FF0000>permission</color> to use this command."},
            {"TurnedOn", "You have <color=#00FBFF>enabled</color> the code reset tool.\nThe code reset tool will <color=#FF0000>disable</color> after {0} seconds."},
            {"TurnedOff", "You have <color=#FF0000>disabled</color> the code reset tool."},
            {"AutoOff", "The code reset tool has been <color=#FF0000>disabled</color> automatically."},
            {"NoArgs", "You require a <color=#FF0000>4</color> digit code." },
            {"SetCode", "You have set your code to <color=#00FBFF>{0}</color>."},
            {"ChangedCode", "You have changed the code to this lock to <color=#00FBFF>{0}</color>." },
            {"NoCode", "You do not have a code set. Use the command <color=#FF0000>/{0}</color> to set your code." },
            {"AlreadyUsed", "Please use <color=#FF0000>another</color> code as <color=#00FBFF>{0}</color> is already used on this door." }

        };
        class SavedData
        {
            [JsonProperty("PlayerNumbers")]
            public Dictionary<ulong, string> PlayerNumbers = new Dictionary<ulong, string>();
            //[JsonProperty("CR Users")]
            //public HashSet<ulong> CRUsers = new HashSet<ulong>();

            public static SavedData Load() =>
                Interface.Oxide.DataFileSystem.ReadObject<SavedData>(_pluginInstance.Name) ?? new SavedData();

            public void Save() =>
                Interface.Oxide.DataFileSystem.WriteObject<SavedData>(_pluginInstance.Name, this);

            public void addCode(ulong a, string b) 
            {
                PlayerNumbers.Add(a, b);
                Save();
            }

            public void removeCode(ulong a) 
            {
                PlayerNumbers.Remove(a);
                Save();
            }

        }


        #endregion
    }
}


// --- End of file: CodeReset.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/custom-rock ---
// --- Original File Path: C/CustomRock/CustomRock.cs ---

ï»¿using System.Collections.Generic;
using Oxide.Core;
using System;
using System.Text;


namespace Oxide.Plugins
{
    [Info("Custom Rock", "birthdates", "0.5", ResourceId = 0)]
    [Description("Custom rock when you spawn.")]
    public class CustomRock : RustPlugin
    {
        private class StoredData
        {
            public readonly Dictionary<string, ulong> delayedRocks = new Dictionary<string, ulong>();
            public readonly Dictionary<string, ulong> rocks = new Dictionary<string, ulong>();
        }
        private StoredData sd;

        private ulong DefaultRockSkin;

        protected override void LoadDefaultConfig() {
            Config["DefaultRockSkin"] = 1;
        }        

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"NoPermission", "You don't have any permission."},
                {
                    "RespawnMessage",
                    "Thank you for supporting the server! For this, we have granted you a custom rock skin"
                },
                {"ValidArgs", "Please specify a valid skin id"},
                {
                    "ResettingSkinAtSave",
                    "Considering you already have a skin, to keep the server lag free(and spam free): We are going to reset your rock skin when the server saves"
                },
                {"SuccessMessage", "Success! We have set your rock skin to {0}!"},
                {"SaveSuccessMessage", "Success! The server has saved and your rock skin has been updated."}
            }, this);
        }

        private void Init()
        {
            permission.RegisterPermission("customrock.use", this);
            permission.RegisterPermission("customrock.spawnwith", this);
            sd = Interface.Oxide.DataFileSystem.ReadObject<StoredData>("CustomRock");
            DefaultRockSkin = ulong.Parse(Config["DefaultRockSkin"].ToString());
        }

        private void OnPlayerRespawned(BasePlayer player)
        {
            if (permission.UserHasPermission(player.UserIDString, "customrock.spawnwith")) GiveKit(player);
            
        }

        private void OnServerSave()
        {
            if (sd.delayedRocks.Count > 0) {
                foreach (var p in sd.delayedRocks.Keys)
                {
                    ulong skin;
                    if (sd.delayedRocks.TryGetValue(p, out skin)) {
                        sd.rocks[p] = skin;
                        SendReply(Player.Find(p), lang.GetMessage("SaveSuccessMessage",this,p));
                    }                      
                }
            }
            Interface.Oxide.DataFileSystem.WriteObject("CustomRock", sd);
            sd.delayedRocks.Clear();
            
        }


        private void GiveKit(BasePlayer player)
        {
            

            ulong skin = DefaultRockSkin;
            
            sd.rocks.TryGetValue(player.UserIDString, out skin);
            foreach (var i in player.inventory.AllItems())
                if (i.info.shortname == "rock" && skin != null)
                {
                    var b = ItemManager.CreateByName("rock", 1, Convert.ToUInt32(Config["DefaultRockSkin"].ToString()));

                    if (i != null) i.Remove();

                    if (b != null) player.GiveItem(b);
                }
            if(skin != 0) {
                SendReply(player, lang.GetMessage("RespawnMessage", this, player.UserIDString));
            }
        }

        [ChatCommand("rskin")]
        private void rSkinCommand(BasePlayer player, string command, string[] args)
        {
            if (args.Length == 1)
            {
                if (!permission.UserHasPermission(player.UserIDString, "customrock.use")) SendReply(player, lang.GetMessage("NoPermission", this, player.UserIDString));
                    
                else
                {
                    ulong s;
                    if (!ulong.TryParse(args[0], out s)) SendReply(player, lang.GetMessage("ValidArgs", this, player.UserIDString));
                    
                    else if(args[0].Length < 8 || args[0].Length > 10) SendReply(player, lang.GetMessage("ValidArgs", this, player.UserIDString));
                    
                    else
                    {
                        if (sd.rocks.ContainsKey(player.UserIDString))
                        {
                            sd.delayedRocks[player.UserIDString] = s;
                            SendReply(player, lang.GetMessage("ResettingSkinAtSave", this, player.UserIDString));
                        }
                        else
                        {
                            sd.rocks[player.UserIDString] = s;
                            Interface.Oxide.DataFileSystem.WriteObject("CustomRock", sd);
                            SendReply(player, lang.GetMessage("SuccessMessage", this, player.UserIDString),s);
                        }
                    }
                }
            }
            else SendReply(player, lang.GetMessage("ValidArgs", this, player.UserIDString));
                
        }


    }
    
}

// --- End of file: CustomRock.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/clan-team ---
// --- Original File Path: C/ClanTeam/ClanTeam.cs ---

ï»¿// Requires: Clans

using Newtonsoft.Json.Linq;
using Oxide.Core.Plugins;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("Clan Team", "deivismac", "1.0.6")]
    [Description("Adds clan members to the same team")]
    class ClanTeam : CovalencePlugin
    {
        #region Definitions

        [PluginReference]
        private Plugin Clans;

        private readonly Dictionary<string, List<ulong>> clans = new Dictionary<string, List<ulong>>();

        #endregion Definitions

        #region Functions

        private bool CompareTeams(List<ulong> currentIds, List<ulong> clanIds)
        {
            foreach (ulong clanId in clanIds)
            {
                if (!currentIds.Contains(clanId))
                {
                    return false;
                }
            }

            return true;
        }

        private void GenerateClanTeam(List<ulong> memberIds)
        {
            if (clans.ContainsKey(ClanTag(memberIds[0])))
            {
                clans.Remove(ClanTag(memberIds[0]));
            }

            clans[ClanTag(memberIds[0])] = new List<ulong>();
            RelationshipManager.PlayerTeam team = RelationshipManager.ServerInstance.CreateTeam();

            foreach (ulong memberId in memberIds)
            {
                BasePlayer player = BasePlayer.FindByID(memberId);
                if (player != null)
                {
                    if (player.currentTeam != 0UL)
                    {
                        RelationshipManager.PlayerTeam current = RelationshipManager.ServerInstance.FindTeam(player.currentTeam);
                        current.RemovePlayer(player.userID);
                    }
                    team.AddPlayer(player);

                    clans[ClanTag(memberId)].Add(player.userID);

                    if (IsAnOwner(player))
                    {
                        team.SetTeamLeader(player.userID);
                    }
                }
            }
        }

        private bool IsAnOwner(BasePlayer player)
        {
            JObject clanInfo = Clans.Call<JObject>("GetClan", Clans.Call<string>("GetClanOf", player.userID));
            return (string)clanInfo["owner"] == player.UserIDString;
        }

        private string ClanTag(ulong memberId)
        {
            return Clans.Call<string>("GetClanOf", memberId);
        }

        private List<ulong> ClanPlayers(BasePlayer player)
        {
            JObject clanInfo = Clans.Call<JObject>("GetClan", Clans.Call<string>("GetClanOf", player.userID));
            return clanInfo["members"].ToObject<List<ulong>>();
        }

        private List<ulong> ClanPlayersTag(string tag)
        {
            JObject clanInfo = Clans.Call<JObject>("GetClan", tag);
            return clanInfo["members"].ToObject<List<ulong>>();
        }

        #endregion Functions

        #region Hooks

        private void OnClanCreate(string tag)
        {
            timer.Once(1f, () =>
            {
                List<ulong> clanPlayers = new List<ulong>();
                JObject clanInfo = Clans.Call<JObject>("GetClan", tag);
                JArray players = clanInfo["members"] as JArray;
                foreach (string memberId in players)
                {
                    ulong clanId;
                    ulong.TryParse(memberId, out clanId);
                    if (clanId != 0UL)
                    {
                        clanPlayers.Add(clanId);
                    }
                }
                GenerateClanTeam(clanPlayers);
            });
        }

        private void OnClanUpdate(string tag)
        {
            GenerateClanTeam(ClanPlayersTag(tag));
        }

        private void OnClanDestroy(string tag)
        {
            BasePlayer player = BasePlayer.FindByID(clans[tag][0]);
            if (player != null)
            {
                RelationshipManager.PlayerTeam team = RelationshipManager.ServerInstance.FindTeam(player.currentTeam);

                foreach (ulong memberId in clans[tag])
                {
                    team.RemovePlayer(memberId);
                }

                RelationshipManager.ServerInstance.DisbandTeam(team);
                clans.Remove(tag);
            }
        }

        private void OnPlayerSleepEnded(BasePlayer player)
        {
            if (!string.IsNullOrEmpty(ClanTag(player.userID)))
            {
                List<ulong> clanPlayers = ClanPlayers(player);
                if (player.currentTeam != 0UL)
                {
                    RelationshipManager.PlayerTeam team = RelationshipManager.ServerInstance.FindTeam(player.currentTeam);
                    if (team != null && CompareTeams(team.members, clanPlayers))
                    {
                        return;
                    }
                }

                GenerateClanTeam(clanPlayers);
            }
        }
    }

    #endregion Hooks
}


// --- End of file: ClanTeam.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/corpse-location ---
// --- Original File Path: C/CorpseLocation/CorpseLocation.cs ---

ï»¿using Network;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Corpse Location", "shinnova", "2.3.8")]
    [Description("Allows users to locate their latest corpse")]
    internal class CorpseLocation : RustPlugin
    {
        [PluginReference] Plugin ZoneManager, AbandonedBases, RaidableBases;

        public enum AmountType { Double, Float, Int }
        public enum PlayerType { BasePlayer, String, ULong }
        private const string UsePerm = "corpselocation.use";
        private const string TPPerm = "corpselocation.tp";
        private const string VIPPerm = "corpselocation.vip";
        private const string AdminPerm = "corpselocation.admin";
        private const string NoCostPerm = "corpselocation.nocost";
        private Dictionary<string, Timer> ActiveTimers = new();
        private Dictionary<string, Vector3> ReturnLocations = new();

        #region Data
        public class StoredData
        {
            public Dictionary<string, string> deaths = new();
            public Dictionary<string, int> teleportsRemaining = new();

            public StoredData() { }
        }

        private StoredData storedData = new();

        private void NewData()
        {
            storedData = new();
            SaveData();
        }

        private void LoadData()
        {
            try
            {
                storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
            }
            catch { }

            if (storedData == null || storedData.deaths == null)
            {
                Puts("Corrupted data -- generating new data file");
                NewData();
            }
        }

        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject(Name, storedData);
        }
        #endregion Data

        #region Hooks
        private void OnNewSave(string filename)
        {
            NewData();
        }

        private void OnServerSave()
        {
            timer.Once(15f, SaveData);
        }

        private void Unload()
        {
            SaveData();
        }

        private void OnServerInitialized()
        {
            permission.RegisterPermission(UsePerm, this);
            permission.RegisterPermission(TPPerm, this);
            permission.RegisterPermission(VIPPerm, this);
            permission.RegisterPermission(AdminPerm, this);
            LoadData();
            StartResetTimer();
        }

        private void OnPlayerRespawned(BasePlayer player)
        {
            if (player == null || !permission.UserHasPermission(player.UserIDString, UsePerm))
            {
                return;
            }
            if (storedData.deaths.TryGetValue(player.UserIDString, out var location))
            {
                SendCorpseLocation(player, location.ToVector3());
            }
        }

        private void OnEntityDeath(BasePlayer player, HitInfo info)
        {
            if (player == null || player.IsDestroyed || !player.userID.IsSteamId())
            {
                return;
            }
            storedData.deaths[player.UserIDString] = player.transform.position.ToString();
            Puts($"{player.displayName} ({player.UserIDString}) died at {player.transform.position}");
        }

        private void OnEntitySpawned(PlayerCorpse corpse)
        {
            if (corpse == null)
            {
                return;
            }

            string userid = corpse.playerSteamID.ToString();

            if (!userid.IsSteamId())
            {
                return;
            }

            if (ActiveTimers.Remove(userid, out Timer t))
            {
                t.Destroy();
            }

            ActiveTimers[userid] = timer.Repeat(1, config.trackTime, () =>
            {
                if (corpse != null && !corpse.IsDestroyed)
                {
                    storedData.deaths[userid] = corpse.transform.position.ToString();
                }
            });
        }

        private void OnUserPermissionGranted(string id, string permName)
        {
            if (permName != VIPPerm)
            {
                return;
            }

            storedData.teleportsRemaining[id] = storedData.teleportsRemaining.TryGetValue(id, out var n) ? n + config.viptpAmount - config.tpAmount : config.viptpAmount;
        }

        private void OnUserGroupAdded(string id, string groupName)
        {
            foreach (var permName in permission.GetGroupPermissions(groupName))
            {
                if (permName == VIPPerm)
                {
                    OnUserPermissionGranted(id, permName);
                }
            }
        }

        #endregion Hooks

        #region Helpers

        private void StartResetTimer()
        {
            if (!TimeSpan.TryParse(config.resetTime, out var resetTime))
            {
                Puts("Invalid resetTime format. Using midnight as default.");
                resetTime = TimeSpan.Zero;
            }

            DateTime now = DateTime.Now;
            DateTime nextReset = now.Date + resetTime;

            if (nextReset <= now)
                nextReset = nextReset.AddDays(1);

            float time = (float)(nextReset - now).TotalSeconds;

            timer.Once(time, () =>
            {
                foreach (var playerId in storedData.teleportsRemaining.Keys.ToList())
                {
                    bool isVIP = permission.UserHasPermission(playerId, VIPPerm);
                    storedData.teleportsRemaining[playerId] = isVIP ? config.viptpAmount : config.tpAmount;
                }

                SaveData();
                Puts("Daily teleports were reset.");

                foreach (var player in BasePlayer.activePlayerList)
                {
                    Message(player, "DailyReset");
                }

                StartResetTimer();
            });
        }

        public bool CanPlayerTeleport(BasePlayer player, Vector3 to)
        {
            if (config.blockToZM && ZoneManager != null && Convert.ToBoolean(ZoneManager?.Call("HasPlayerFlag", player, "notp")))
            {
                Message(player, "TeleportBlockedCorpse");
                return false;
            }

            if (config.blockFromBuildBlocked && player.IsBuildingBlocked())
            {
                Message(player, "TeleportBlockedFrom");
                return false;
            }

            if (config.blockToBuildBlocked && player.IsBuildingBlocked(to, player.transform.rotation, player.bounds))
            {
                Message(player, "TeleportBlockedTo");
                return false;
            }

            if (config.ignoreRB && RaidableBases != null && Convert.ToBoolean(RaidableBases?.Call("EventTerritory", to)))
            {
                return true;
            }

            if (config.ignoreAB && AbandonedBases != null && Convert.ToBoolean(AbandonedBases?.Call("EventTerritory", to)))
            {
                return true;
            }

            var ret = Interface.CallHook("CanTeleport", player, to);

            if (ret is string str)
            {
                Player.Message(player, str);
                return false;
            }

            return true;
        }

        private object OnBlockRaidableBasesTeleport(BasePlayer player, Vector3 to) => config.ignoreRB ? true : (object)null;

        private object OnBlockAbandonedBasesTeleport(BasePlayer player, Vector3 to) => config.ignoreAB ? true : (object)null;

        private static string PositionToGrid(Vector3 position) => MapHelper.PositionToString(position);

        private void SendCorpseLocation(BasePlayer player, Vector3 location)
        {
            int DistanceToCorpse = Mathf.FloorToInt(Vector3.Distance(player.transform.position, location));
            if (config.showGrid)
            {
                Message(player, "YouDiedGrid", DistanceToCorpse, PositionToGrid(location));
            }
            else Message(player, "YouDied", DistanceToCorpse);
        }

        private List<BasePlayer> GetPlayers(string NameOrID)
        {
            return BasePlayer.allPlayerList.Where(target =>
            {
                if (target == null)
                {
                    return false;
                }
                return target.UserIDString == NameOrID || target.displayName.Contains(NameOrID, StringComparison.OrdinalIgnoreCase);
            }).ToList();
        }

        #endregion Helpers

        #region Commands
        [ChatCommand("where")]
        private void whereCommand(BasePlayer player, string command, string[] args)
        {
            string PlayerID = player.UserIDString;
            if (args.Contains("tp") && permission.UserHasPermission(PlayerID, TPPerm))
            {
                int TPAllowed = config.tpAmount;
                if (permission.UserHasPermission(PlayerID, VIPPerm))
                {
                    TPAllowed = config.viptpAmount;
                }
                if (!storedData.teleportsRemaining.TryGetValue(PlayerID, out int remainingTeleports) || remainingTeleports > TPAllowed)
                {
                    remainingTeleports = TPAllowed;
                    storedData.teleportsRemaining[PlayerID] = remainingTeleports;
                    SaveData();
                }
                if (!storedData.deaths.TryGetValue(PlayerID, out string location))
                {
                    Message(player, "UnknownLocation");
                    return;
                }
                if (config.blockFromZM && Convert.ToBoolean(ZoneManager?.CallHook("HasPlayerFlag", player, "notp")))
                {
                    Message(player, "TeleportBlockedPlayer");
                    return;
                }
                Vector3 destination = location.ToVector3();
                if (!CanPlayerTeleport(player, destination))
                {
                    return;
                }
                if (TPAllowed > 0 && remainingTeleports <= 0)
                {
                    Message(player, "OutOfTeleports");
                }
                else
                {
                    float tpCd = config.tpCountdown;
                    if (tpCd > 0)
                    {
                        Message(player, "TeleportingIn", tpCd);
                    }
                    timer.Once(tpCd, () =>
                    {
                        if (!CanPlayerTeleport(player, destination))
                        {
                            return;
                        }
                        if (!Teleport(player, destination, IsFree(player, args))) return;
                        Vector3 originalpos = player.transform.position;
                        player.Invoke(() =>
                        {
                            if (config.blockToZM && Convert.ToBoolean(ZoneManager?.Call("HasPlayerFlag", player, "notp")))
                            {
                                player.Teleport(originalpos);
                                Message(player, "TeleportBlockedCorpse");
                                return;
                            }
                            Message(player, "ArrivedAtYourCorpse");
                            if (config.allowReturn)
                            {
                                ReturnLocations[PlayerID] = originalpos;
                                Message(player, "ReturnAvailable");
                            }
                            if (TPAllowed > 0)
                            {
                                storedData.teleportsRemaining[PlayerID] = --remainingTeleports;
                                SaveData();
                                Message(player, "TeleportsRemaining", remainingTeleports);
                            }
                        }, 0.1f);
                    });
                }
                return;
            }
            if (permission.UserHasPermission(PlayerID, UsePerm))
            {
                if (storedData.deaths.TryGetValue(player.UserIDString, out var location))
                {
                    SendCorpseLocation(player, location.ToVector3());
                }
                else Message(player, "UnknownLocation");
                if (storedData.teleportsRemaining.ContainsKey(player.UserIDString))
                {
                    Message(player, "TeleportsRemaining", storedData.teleportsRemaining[PlayerID]);
                }
                else
                {
                    int TPAllowed = config.tpAmount;
                    if (permission.UserHasPermission(PlayerID, VIPPerm))
                    {
                        TPAllowed = config.viptpAmount;
                    }
                    Message(player, "TeleportsRemaining", TPAllowed);
                }
            }
            else Message(player, "NotAllowed");
        }

        private bool TryPay(BasePlayer player, PaymentMethod m) => m switch
        {
            { IsEnabled: false } => true,

            _ when player == null => false,

            _ => TryPay(player, m.PlayerType, m.AmountType, m.Amount, m.PluginName, m.BalanceHook, m.WithdrawHook, m.CostFormat)
        };

        private bool TryPay(BasePlayer player, PlayerType playerType, AmountType amountType, double amount, string pluginName, string balanceHook, string withdrawHook, string formattedCost)
        {
            Plugin plugin = plugins.Find(pluginName);

            if (plugin == null || !plugin.IsLoaded)
            {
                return true;
            }

            object amountObj = amountType switch
            {
                AmountType.Double => (object)(double)amount,
                AmountType.Float => (object)(float)amount,
                AmountType.Int or _ => (object)(int)amount
            };

            object userObj = playerType switch
            {
                PlayerType.BasePlayer => player,
                PlayerType.String => player.UserIDString,
                PlayerType.ULong or _ => (ulong)player.userID,
            };

            double balance = Convert.ToDouble(plugin.Call(balanceHook, userObj));

            if (string.IsNullOrEmpty(formattedCost))
            {
                formattedCost = amountObj.ToString();
            }
            else
            {
                formattedCost = formattedCost.Replace("{cost}", amountObj.ToString());
            }

            switch (balance >= amount)
            {
                case true:
                    plugin.Call(withdrawHook, userObj, amountObj);
                    Message(player, "Withdrawn", formattedCost);
                    return true;

                case false:
                    Message(player, "NotWithdrawn", formattedCost);
                    return false;
            }
        }

        [HookMethod("Teleport")]
        public bool Teleport(BasePlayer player, Vector3 to, bool free = false)
        {
            if (!free && !config.Payments.All(m => TryPay(player, m)))
            {
                return false;
            }

            Vector3 from = player.transform.position;

            try
            {
                player.UpdateActiveItem(default);
                player.EnsureDismounted();
                player.Server_CancelGesture();

                if (player.HasParent())
                {
                    player.SetParent(null, true, true);
                }

                if (player.IsConnected)
                {
                    player.EndLooting();
                    StartSleeping(player);
                }

                player.RemoveFromTriggers();
                player.Teleport(to);

                if (player.IsConnected && !Net.sv.visibility.IsInside(player.net.group, to))
                {
                    player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, true);
                    player.ClientRPC(RpcTarget.Player("StartLoading", player));
                    player.SendEntityUpdate();

                    if (!player.limitNetworking)
                    {
                        player.UpdateNetworkGroup();
                        player.SendNetworkUpdateImmediate(false);
                    }
                }
            }
            finally
            {
                if (!player.limitNetworking)
                {
                    player.ForceUpdateTriggers();
                }
            }

            Interface.CallHook("OnPlayerTeleported", player, from, to);

            return true;
        }

        public void StartSleeping(BasePlayer player)
        {
            if (!player.IsSleeping())
            {
                Interface.CallHook("OnPlayerSleep", player);
                player.SetPlayerFlag(BasePlayer.PlayerFlags.Sleeping, true);
                player.sleepStartTime = Time.time;
                BasePlayer.sleepingPlayerList.Add(player);
                player.CancelInvoke("InventoryUpdate");
                player.CancelInvoke("TeamUpdate");
            }
        }

        [ChatCommand("return")]
        private void returnCommand(BasePlayer player, string command, string[] args)
        {
            if (permission.UserHasPermission(player.UserIDString, TPPerm))
            {
                if (!ReturnLocations.TryGetValue(player.UserIDString, out var destination))
                {
                    Message(player, "ReturnUnavailable");
                    return;
                }
                if (!CanPlayerTeleport(player, destination))
                {
                    return;
                }
                if (!Teleport(player, destination, IsFree(player, args))) return;
                Message(player, "ReturnUsed");
                ReturnLocations.Remove(player.UserIDString);
            }
            else Message(player, "NotAllowed");
        }

        [ChatCommand("tpcorpse")]
        private void tpCommand(BasePlayer player, string command, string[] args)
        {
            if (permission.UserHasPermission(player.UserIDString, AdminPerm))
            {
                if (args.Length == 0)
                {
                    Message(player, "NeedTarget");
                    return;
                }
                var NameOrID = args[0] == "nocost" && args.Length > 1 ? args[1] : args[0];
                var FoundPlayers = GetPlayers(NameOrID);
                if (FoundPlayers.Count == 0)
                {
                    Message(player, "InvalidPlayer", NameOrID);
                    return;
                }
                var target = FoundPlayers[0];
                if (storedData.deaths.TryGetValue(target.UserIDString, out string value))
                {
                    Vector3 destination = value.ToVector3();
                    if (!Teleport(player, destination, IsFree(player, args))) return;
                    Message(player, "ArrivedAtTheCorpse", target.displayName);
                }
                else Message(player, "UnknownLocationTarget", target.displayName);
            }
            else Message(player, "NotAllowed");
        }

        private bool IsFree(BasePlayer player, string[] args) => permission.UserHasPermission(player.UserIDString, NoCostPerm) || player.IsAdmin && config.nocost && args.Contains("nocost");

        #endregion Commands

        #region Config

        protected override void LoadDefaultMessages()
        {
            var messages = new Dictionary<string, string>
            {
                ["YouDied"] = "Your corpse was last seen {0} meters from here.",
                ["YouDiedGrid"] = "Your corpse was last seen {0} meters from here, in {1}.",
                ["TeleportingIn"] = "Teleporting to your corpse in {0} second(s).",
                ["TeleportBlockedCorpse"] = "Your corpse is in a restricted area, preventing teleportation.",
                ["TeleportBlockedPlayer"] = "You are not allowed to teleport from here.",
                ["TeleportBlockedTo"] = "You cannot teleport into a building blocked area.",
                ["TeleportBlockedFrom"] = "You cannot teleport from a building blocked area.",
                ["ArrivedAtYourCorpse"] = "You have arrived at your corpse.",
                ["ArrivedAtTheCorpse"] = "You have arrived at the corpse of {0}.",
                ["ReturnAvailable"] = "You can use <color=#ffa500ff>/return</color> to return to your initial location.",
                ["ReturnUnavailable"] = "You don't have a location set to return to.",
                ["ReturnUsed"] = "You have successfully returned to your initial location.",
                ["OutOfTeleports"] = "You have no more teleports left today.",
                ["TeleportsRemaining"] = "You have {0} teleports remaining today.",
                ["UnknownLocation"] = "Your last death location is unknown.",
                ["UnknownLocationTarget"] = "{0}'s last death location is unknown.",
                ["NeedTarget"] = "You need to specify a player to teleport to the corpse of, using either their name or steam id.",
                ["InvalidPlayer"] = "{0} is not part of a known player's name/id.",
                ["NotAllowed"] = "You do not have permission to use that command.",
                ["NotWithdrawn"] = "You do not have <color=#FFFF00>{0}</color> to pay for this corpse teleport!",
                ["Withdrawn"] = "You have paid <color=#FFFF00>{0}</color> for this corpse teleport!",
                ["DailyReset"] = "Daily teleports were reset."
            };

            lang.RegisterMessages(messages, this);
        }

        private void Message(BasePlayer player, string key, params object[] args)
        {
            if (!player.IsValid())
            {
                return;
            }

            string message = lang.GetMessage(key, this, player.UserIDString);

            if (string.IsNullOrEmpty(message))
            {
                return;
            }

            Player.Message(player, args.Length == 0 ? message : string.Format(message, args), config.steamId);
        }

        private Configuration config;

        public class Configuration
        {
            [JsonProperty(PropertyName = "Teleport payment methods", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<PaymentMethod> Payments;

            [JsonProperty(PropertyName = "Show grid location")]
            public bool showGrid = true;

            [JsonProperty(PropertyName = "Track a corpse's location for x seconds")]
            public int trackTime = 30;

            [JsonProperty(PropertyName = "Allow teleporting to own corpse x times per day (0 for unlimited)")]
            public int tpAmount = 5;

            [JsonProperty(PropertyName = "Allow teleporting to own corpse x times per day (0 for unlimited), for VIPs")]
            public int viptpAmount = 10;

            [JsonProperty(PropertyName = "Allow returning to original location after teleporting")]
            public bool allowReturn = false;

            [JsonProperty(PropertyName = "Countdown until teleporting to own corpse (0 for instant tp)")]
            public float tpCountdown = 5f;

            [JsonProperty(PropertyName = "Block teleports into Zone Manager's tp blocked zones")]
            public bool blockToZM = true;

            [JsonProperty(PropertyName = "Block teleports from Zone Manager's tp blocked zones")]
            public bool blockFromZM = true;

            [JsonProperty(PropertyName = "Block teleports into building blocked areas")]
            public bool blockToBuildBlocked = false;

            [JsonProperty(PropertyName = "Block teleports from building blocked areas")]
            public bool blockFromBuildBlocked = false;

            [JsonProperty(PropertyName = "Ignore Abandoned Bases")]
            public bool ignoreAB;

            [JsonProperty(PropertyName = "Ignore Raidable Bases")]
            public bool ignoreRB;

            [JsonProperty(PropertyName = "Reset players' remaining teleports at this time (HH:mm:ss format)")]
            public string resetTime = "00:00:00";

            [JsonProperty(PropertyName = "Chat steam id")]
            public ulong steamId;

            [JsonProperty(PropertyName = "Allow admins to specify 'nocost' in commands")]
            public bool nocost;

            [JsonProperty(PropertyName = "ServerRewards Cost", NullValueHandling = NullValueHandling.Ignore)]
            public int? SRC { get; set; } = null;

            [JsonProperty(PropertyName = "Economics Cost", NullValueHandling = NullValueHandling.Ignore)]
            public double? EC { get; set; } = null;
        }

        public class PaymentMethod
        {
            [JsonProperty(PropertyName = "Player Type (0 = BasePlayer, 1 = String, 2 = ULong)")]
            public PlayerType PlayerType;
            [JsonProperty(PropertyName = "Amount Type (0 = Double, 1 = Float, 2 = Int)")]
            public AmountType AmountType;
            public bool Enabled;
            [JsonProperty(PropertyName = "Cost")]
            public double Amount;
            public string PluginName;
            public string BalanceHook;
            public string WithdrawHook;
            public string CostFormat;
            public PaymentMethod(bool enabled, PlayerType playerType, AmountType amountType, double amount, string pluginName, string balanceHook, string withdrawHook, string costFormat)
            {
                Enabled = enabled;
                PlayerType = playerType;
                AmountType = amountType;
                Amount = amount;
                PluginName = pluginName;
                BalanceHook = balanceHook;
                WithdrawHook = withdrawHook;
                CostFormat = costFormat;
            }
            internal bool IsEnabled => Enabled && Amount > 0 && !string.IsNullOrEmpty(PluginName) && !string.IsNullOrEmpty(BalanceHook) && !string.IsNullOrEmpty(WithdrawHook);
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            canSaveConfig = false;
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
                canSaveConfig = true;
            }
            catch (Exception ex)
            {
                Puts(ex.ToString());
                LoadDefaultConfig();
            }
            if (config.Payments == null)
            {
                double economics = config.EC.HasValue ? config.EC.Value : 0;
                int rewards = config.SRC.HasValue ? config.SRC.Value : 0;
                config.Payments = new()
                {
                    new(economics != 0, PlayerType.ULong, AmountType.Double, economics, "Economics", "Balance", "Withdraw", "${cost}"),
                    new(economics != 0, PlayerType.ULong, AmountType.Int, economics, "BankSystem", "Balance", "Withdraw", "${cost}"),
                    new(economics != 0, PlayerType.ULong, AmountType.Int, economics, "IQEconomic", "API_GET_BALANCE", "API_REMOVE_BALANCE", "${cost}"),
                    new(rewards != 0, PlayerType.ULong, AmountType.Int, rewards, "ServerRewards", "CheckPoints", "TakePoints", "{cost} RP"),
                };
                config.EC = null;
                config.SRC = null;
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            config = new();
        }

        private bool canSaveConfig = true;

        protected override void SaveConfig()
        {
            if (canSaveConfig)
            {
                Config.WriteObject(config);
            }
        }
        #endregion
    }
}

// --- End of file: CorpseLocation.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/craft-car-chassis ---
// --- Original File Path: C/CraftChassis/CraftChassis.cs ---

ï»¿using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Craft Car Chassis", "WhiteThunder", "1.2.5")]
    [Description("Allows players to craft a modular car chassis at a car lift using a UI.")]
    internal class CraftChassis : CovalencePlugin
    {
        #region Fields

        [PluginReference]
        private Plugin Economics, ServerRewards;

        private Configuration _config;

        private const string PermissionCraft2 = "craftchassis.2";
        private const string PermissionCraft3 = "craftchassis.3";
        private const string PermissionCraft4 = "craftchassis.4";
        private const string PermissionFree = "craftchassis.free";
        private const string PermissionFuel = "craftchassis.fuel";

        private const string ChassisPrefab2 = "assets/content/vehicles/modularcar/car_chassis_2module.entity.prefab";
        private const string ChassisPrefab3 = "assets/content/vehicles/modularcar/car_chassis_3module.entity.prefab";
        private const string ChassisPrefab4 = "assets/content/vehicles/modularcar/car_chassis_4module.entity.prefab";
        private const string SpawnEffect = "assets/bundled/prefabs/fx/build/promote_toptier.prefab";

        private readonly Dictionary<BasePlayer, ModularCarGarage> playerLifts = new();
        private readonly ChassisUIManager uiManager = new();

        private enum CurrencyType { Items, Economics, ServerRewards }

        #endregion

        #region Hooks

        private void Init()
        {
            permission.RegisterPermission(PermissionCraft2, this);
            permission.RegisterPermission(PermissionCraft3, this);
            permission.RegisterPermission(PermissionCraft4, this);
            permission.RegisterPermission(PermissionFree, this);
            permission.RegisterPermission(PermissionFuel, this);
        }

        private void Unload()
        {
            uiManager.DestroyAllUIs();
        }

        private void OnLootEntity(BasePlayer player, ModularCarGarage carLift)
        {
            if (carLift == null)
                return;

            if (carLift.carOccupant == null)
            {
                playerLifts.Add(player, carLift);
                uiManager.MaybeSendPlayerUI(this, player);
            }
            else
            {
                uiManager.DestroyPlayerUI(player);
            }
        }

        private void OnPlayerLootEnd(PlayerLoot inventory)
        {
            var player = inventory.baseEntity;
            if (player == null)
                return;

            playerLifts.Remove(player);
            uiManager.DestroyPlayerUI(player);
        }

        #endregion

        #region Commands

        [Command("craftchassis.ui")]
        private void CraftChassisUICommand(IPlayer player, string cmd, string[] args)
        {
            if (player.IsServer || args.Length < 1)
                return;

            if (!int.TryParse(args[0], out var numSockets))
                return;

            var maxAllowedSockets = GetMaxAllowedSockets(player);
            if (numSockets < 2 || numSockets > maxAllowedSockets)
                return;

            if (!CanPlayerCreateChassis(player, numSockets, out var chassisCost))
                return;

            var basePlayer = player.Object as BasePlayer;
            if (!playerLifts.TryGetValue(basePlayer, out var carLift) || carLift.carOccupant != null)
                return;

            var car = SpawnChassis(carLift, numSockets, basePlayer);
            if (car == null)
                return;

            if (_config.EnableEffects)
            {
                Effect.server.Run(SpawnEffect, car.transform.position);
            }

            if (chassisCost != null)
            {
                ChargePlayer(basePlayer, chassisCost);
            }
        }

        #endregion

        #region Helper Methods

        private ModularCar SpawnChassis(ModularCarGarage carLift, int numSockets, BasePlayer player)
        {
            var prefab = GetChassisPrefab(numSockets);

            var position = carLift.transform.position + Vector3.up * 0.7f;
            var rotation = Quaternion.Euler(0, carLift.transform.eulerAngles.y - 90, 0);

            var car = GameManager.server.CreateEntity(prefab, position, rotation) as ModularCar;
            if (car == null)
                return null;

            if (_config.SetOwner)
            {
                car.OwnerID = player.userID;
            }

            car.Spawn();
            AddOrRestoreFuel(car, player);

            return car;
        }

        private void AddOrRestoreFuel(ModularCar car, BasePlayer player)
        {
            var desiredFuelAmount = _config.FuelAmount;
            if (desiredFuelAmount == 0 || !permission.UserHasPermission(player.UserIDString, PermissionFuel))
                return;

            if (car.GetFuelSystem() is not EntityFuelSystem fuelSystem)
                return;

            var fuelContainer = fuelSystem.GetFuelContainer();
            if (desiredFuelAmount < 0)
            {
                desiredFuelAmount = fuelContainer.allowedItem.stackable;
            }

            var fuelItem = fuelContainer.inventory.FindItemByItemID(fuelContainer.allowedItem.itemid);
            if (fuelItem == null)
            {
                fuelContainer.inventory.AddItem(fuelContainer.allowedItem, desiredFuelAmount);
            }
            else if (fuelItem.amount < desiredFuelAmount)
            {
                fuelItem.amount = desiredFuelAmount;
                fuelItem.MarkDirty();
            }
        }

        private string GetChassisPrefab(int numSockets)
        {
            if (numSockets == 4)
                return ChassisPrefab4;

            if (numSockets == 3)
                return ChassisPrefab3;

            return ChassisPrefab2;
        }

        private int GetMaxAllowedSockets(IPlayer player)
        {
            if (player.HasPermission(PermissionCraft4))
                return 4;

            if (player.HasPermission(PermissionCraft3))
                return 3;

            if (player.HasPermission(PermissionCraft2))
                return 2;

            return 0;
        }

        private bool CanPlayerCreateChassis(IPlayer player, int numSockets, out ChassisCost chassisCost)
        {
            chassisCost = null;
            if (player.HasPermission(PermissionFree))
                return true;

            chassisCost = GetCostForSockets(numSockets);
            return CanPlayerAffordCost(player.Object as BasePlayer, chassisCost);
        }

        private bool CanPlayerAffordSockets(BasePlayer basePlayer, int sockets)
        {
            return CanPlayerAffordCost(basePlayer, GetCostForSockets(sockets));
        }

        private bool CanPlayerAffordCost(BasePlayer basePlayer, ChassisCost chassisCost)
        {
            return chassisCost.Amount == 0 || GetPlayerCurrencyAmount(basePlayer, chassisCost, out _) >= chassisCost.Amount;
        }

        private void ChargePlayer(BasePlayer basePlayer, ChassisCost chassisCost)
        {
            if (chassisCost.Amount == 0)
                return;

            if (chassisCost.UseEconomics && Economics != null)
            {
                Economics.Call("Withdraw", (ulong)basePlayer.userID, Convert.ToDouble(chassisCost.Amount));
                return;
            }

            if (chassisCost.UseServerRewards && ServerRewards != null)
            {
                ServerRewards.Call("TakePoints", (ulong)basePlayer.userID, chassisCost.Amount);
                return;
            }

            var itemid = ItemManager.itemDictionaryByName[chassisCost.ItemShortName].itemid;
            basePlayer.inventory.Take(null, itemid, chassisCost.Amount);
            basePlayer.Command("note.inv", itemid, -chassisCost.Amount);
        }

        private double GetPlayerCurrencyAmount(BasePlayer basePlayer, ChassisCost chassisCost, out CurrencyType currencyType)
        {
            if (chassisCost.UseEconomics && Economics != null)
            {
                var balance = Economics.Call("Balance", (ulong)basePlayer.userID);
                currencyType = CurrencyType.Economics;
                return balance as double? ?? 0;
            }

            if (chassisCost.UseServerRewards && ServerRewards != null)
            {
                var points = ServerRewards.Call("CheckPoints", (ulong)basePlayer.userID);
                currencyType = CurrencyType.ServerRewards;
                return points is int i ? i : 0;
            }

            currencyType = CurrencyType.Items;
            return basePlayer.inventory.GetAmount(ItemManager.itemDictionaryByName[chassisCost.ItemShortName].itemid);
        }

        private ChassisCost GetCostForSockets(int numSockets)
        {
            if (numSockets == 4)
                return _config.ChassisCostMap.ChassisCost4;

            if (numSockets == 3)
                return _config.ChassisCostMap.ChassisCost3;

            return _config.ChassisCostMap.ChassisCost2;
        }

        #endregion

        #region UI

        internal class ChassisUIManager
        {
            private const string PanelBackgroundColor = "1 0.96 0.88 0.15";
            private const string TextColor = "0.97 0.92 0.88 1";
            private const string DisabledLabelTextColor = "0.75 0.42 0.14 1";
            private const string ButtonColor = "0.44 0.54 0.26 1";
            private const string DisabledButtonColor = "0.25 0.32 0.19 0.7";

            private const string CraftChassisUIName = "CraftChassis";
            private const string CraftChassisUIHeaderName = "CraftChassis.Header";

            private readonly List<BasePlayer> PlayersWithUIs = new();

            public void DestroyAllUIs()
            {
                var playerList = new BasePlayer[PlayersWithUIs.Count];
                PlayersWithUIs.CopyTo(playerList, 0);

                foreach (var player in playerList)
                {
                    DestroyPlayerUI(player);
                }
            }

            public void DestroyPlayerUI(BasePlayer player)
            {
                if (PlayersWithUIs.Contains(player))
                {
                    CuiHelper.DestroyUi(player, CraftChassisUIName);
                    PlayersWithUIs.Remove(player);
                }
            }

            private CuiLabel CreateCostLabel(CraftChassis plugin, BasePlayer player, bool freeCrafting, int maxAllowedSockets, int numSockets)
            {
                var freeLabel = plugin.GetMessage(player.IPlayer, "UI.CostLabel.Free");

                var text = freeLabel;
                var color = TextColor;

                if (numSockets > maxAllowedSockets)
                {
                    text = plugin.GetMessage(player.IPlayer, "UI.CostLabel.NoPermission");
                    color = DisabledLabelTextColor;
                }
                else if (!freeCrafting)
                {
                    var chassisCost = plugin.GetCostForSockets(numSockets);
                    if (chassisCost.Amount > 0)
                    {
                        var playerCurrencyAmount = plugin.GetPlayerCurrencyAmount(player, chassisCost, out var currencyType);

                        switch (currencyType)
                        {
                            case CurrencyType.Economics:
                                text = plugin.GetMessage(player.IPlayer, "UI.CostLabel.Economics", chassisCost.Amount);
                                break;
                            case CurrencyType.ServerRewards:
                                text = plugin.GetMessage(player.IPlayer, "UI.CostLabel.ServerRewards", chassisCost.Amount);
                                break;
                            default:
                                var itemDefinition = ItemManager.itemDictionaryByName[chassisCost.ItemShortName];
                                text = $"{chassisCost.Amount} {itemDefinition.displayName.translated}";
                                break;
                        }

                        if (playerCurrencyAmount < chassisCost.Amount)
                            color = DisabledLabelTextColor;
                    }
                }

                var offsetMinX = 8 + (numSockets - 2) * 124;
                var offsetMaxX = 124 + (numSockets - 2) * 124;
                var offsetMinY = 43;
                var offsetMaxY = 58;

                return new CuiLabel
                {
                    Text =
                    {
                        Text = text,
                        Color = color,
                        Align = TextAnchor.MiddleCenter,
                        FontSize = 11,
                    },
                    RectTransform =
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "0 0",
                        OffsetMin = $"{offsetMinX} {offsetMinY}",
                        OffsetMax = $"{offsetMaxX} {offsetMaxY}",
                    },
                };
            }

            private CuiButton CreateCraftButton(CraftChassis plugin, BasePlayer player, bool freeCrafting, int maxAllowedSockets, int numSockets)
            {
                var color = ButtonColor;

                if (numSockets > maxAllowedSockets || !freeCrafting && !plugin.CanPlayerAffordSockets(player, numSockets))
                    color = DisabledButtonColor;

                var offsetMinX = 8 + (numSockets - 2) * 124;
                var offsetMaxX = 124 + (numSockets - 2) * 124;
                var offsetMinY = 8;
                var offsetMaxY = 40;

                return new CuiButton
                {
                    Text = {
                        Text = plugin.GetMessage(player.IPlayer, $"UI.ButtonText.Sockets.{numSockets}"),
                        Color = TextColor,
                        Align = TextAnchor.MiddleCenter,
                    },
                    Button =
                    {
                        Color = color,
                        Command = $"craftchassis.ui {numSockets}",
                    },
                    RectTransform =
                    {
                        AnchorMin = "0 0",
                        AnchorMax = "0 0",
                        OffsetMin = $"{offsetMinX} {offsetMinY}",
                        OffsetMax = $"{offsetMaxX} {offsetMaxY}",
                    },
                };
            }

            public void MaybeSendPlayerUI(CraftChassis plugin, BasePlayer player)
            {
                if (PlayersWithUIs.Contains(player))
                    return;

                var maxAllowedSockets = plugin.GetMaxAllowedSockets(player.IPlayer);
                if (maxAllowedSockets == 0)
                    return;

                var freeCrafting = player.IPlayer.HasPermission(PermissionFree);

                var cuiElements = new CuiElementContainer
                {
                    {
                        new CuiPanel
                        {
                            Image = new CuiImageComponent { Color = PanelBackgroundColor },
                            RectTransform =
                            {
                                AnchorMin = "0.5 0",
                                AnchorMax = "0.5 0",
                                OffsetMin = "192.5 431",
                                OffsetMax = "572.5 495",
                            },
                        },
                        "Hud.Menu",
                        CraftChassisUIName
                    },
                    {
                        new CuiPanel
                        {
                            Image = new CuiImageComponent { Color = PanelBackgroundColor },
                            RectTransform =
                            {
                                AnchorMin = "0 1",
                                AnchorMax = "0 1",
                                OffsetMin = "0 3",
                                OffsetMax = "380 24",
                            },
                        },
                        CraftChassisUIName,
                        CraftChassisUIHeaderName
                    },
                    {
                        new CuiLabel
                        {
                            RectTransform =
                            {
                                AnchorMin = "0 0",
                                AnchorMax = "1 1",
                                OffsetMin = "10 0",
                                OffsetMax = "0 0",
                            },
                            Text =
                            {
                                Text = plugin.GetMessage(player.IPlayer, "UI.Header").ToUpperInvariant(),
                                Align = TextAnchor.MiddleLeft,
                                FontSize = 13,
                            },
                        },
                        CraftChassisUIHeaderName
                    },
                    { CreateCostLabel(plugin, player, freeCrafting, maxAllowedSockets, 2), CraftChassisUIName },
                    { CreateCraftButton(plugin, player, freeCrafting, maxAllowedSockets, 2), CraftChassisUIName },
                    { CreateCostLabel(plugin, player, freeCrafting, maxAllowedSockets, 3), CraftChassisUIName },
                    { CreateCraftButton(plugin, player, freeCrafting, maxAllowedSockets, 3), CraftChassisUIName },
                    { CreateCostLabel(plugin, player, freeCrafting, maxAllowedSockets, 4), CraftChassisUIName },
                    { CreateCraftButton(plugin, player, freeCrafting, maxAllowedSockets, 4), CraftChassisUIName },
                };

                CuiHelper.AddUi(player, cuiElements);
                PlayersWithUIs.Add(player);
            }
        }

        #endregion

        #region Configuration

        private class ChassisCost
        {
            [JsonProperty("Amount")]
            public int Amount;

            [JsonProperty("ItemShortName")]
            public string ItemShortName;

            [JsonProperty("UseEconomics")]
            public bool UseEconomics;

            [JsonProperty("UseServerRewards")]
            public bool UseServerRewards;
        }

        private class ChassisCostMap
        {
            [JsonProperty("2sockets")]
            public ChassisCost ChassisCost2 = new()
            {
                ItemShortName = "metal.fragments",
                Amount = 200,
            };

            [JsonProperty("3sockets")]
            public ChassisCost ChassisCost3 = new()
            {
                ItemShortName = "metal.fragments",
                Amount = 300,
            };

            [JsonProperty("4sockets")]
            public ChassisCost ChassisCost4 = new()
            {
                ItemShortName = "metal.fragments",
                Amount = 400,
            };
        }

        private class Configuration : BaseConfiguration
        {
            [JsonProperty("ChassisCost")]
            public ChassisCostMap ChassisCostMap = new();

            [JsonProperty("FuelAmount")]
            public int FuelAmount = 0;

            [JsonProperty("EnableEffects")]
            public bool EnableEffects = true;

            [JsonProperty("SetOwner")]
            public bool SetOwner = false;
        }

        private Configuration GetDefaultConfig() => new();

        #region Configuration Helpers

        private class BaseConfiguration
        {
            public string ToJson()
            {
                return JsonConvert.SerializeObject(this);
            }

            public Dictionary<string, object> ToDictionary()
            {
                return JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
            }
        }

        private static class JsonHelper
        {
            public static object Deserialize(string json)
            {
                return ToObject(JToken.Parse(json));
            }

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(BaseConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            var changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                if (currentRaw.TryGetValue(key, out var currentRawValue))
                {
                    var currentDictValue = currentRawValue as Dictionary<string, object>;
                    if (currentWithDefaults[key] is Dictionary<string, object> defaultDictValue)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                            changed = true;
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig()
        {
            _config = GetDefaultConfig();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(_config))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch (Exception e)
            {
                LogError(e.Message);
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_config, true);
        }

        #endregion

        #endregion

        #region Localization

        private string GetMessage(IPlayer player, string messageName, params object[] args)
        {
            var message = lang.GetMessage(messageName, this, player.Id);
            return args.Length > 0 ? string.Format(message, args) : message;
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["UI.Header"] = "Craft a chassis",
                ["UI.CostLabel.Free"] = "Free",
                ["UI.CostLabel.NoPermission"] = "No Permission",
                ["UI.CostLabel.Economics"] = "{0:C}",
                ["UI.CostLabel.ServerRewards"] = "{0} reward points",
                ["UI.ButtonText.Sockets.2"] = "2 sockets",
                ["UI.ButtonText.Sockets.3"] = "3 sockets",
                ["UI.ButtonText.Sockets.4"] = "4 sockets",
            }, this, "en");
        }

        #endregion
    }
}


// --- End of file: CraftChassis.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/chest-warp ---
// --- Original File Path: C/ChestWarp/ChestWarp.cs ---

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Xml;
using Newtonsoft.Json;
using UnityEngine;
using Facepunch;
using UnityEngine;
using Oxide.Core;
using Oxide.Core.Libraries;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries.Covalence;
using Oxide.Game.Rust.Cui;


namespace Oxide.Plugins
{
    [Info("Chest Warp", "CEbbinghaus", "1.2.1")]
    [Description("Create warp between two chests")]
    class ChestWarp : RustPlugin
    {
        #region Variables
        public class Warp
        {
			[JsonProperty("User")]
			public ulong User = 0;
			[JsonProperty("First chest")]
             public uint FirstPoint = 0;
            [JsonProperty("Second chest")]
             public uint SecondPoint = 0;
			 public Warp(){}
			 public Warp(ulong uid){
				 User = uid;
			 }
        }

		 public class setup{
			 public bool isActive = false;
			 public string id = "";
			 public Warp warp = new Warp();
			 public setup(ulong id){
				 warp = new Warp(id);
			 }
		}

		[JsonProperty("Settings")]
		Dictionary<string, Dictionary<string, bool>> settings = new Dictionary<string, Dictionary<string, bool>>();

         public Dictionary<string, Warp> chestWarps = new Dictionary<string, Warp>();
		 Dictionary<ulong, setup> activeBinds = new Dictionary<ulong, setup>();
        #endregion

		#region OxideHooks
        void Unload() => Interface.Oxide.DataFileSystem.WriteObject("ChestWarp/Chests", chestWarps);

		void LoadDefaultMessages(){            
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["PERMISSION"] = "You do not have the permissions to use this Command!",
                ["NOEXIST"] = "The Command you are looking for doesn't Exist!",
				["ENTITY"] = "You arent Looking At a valid Entity",
                ["GENERATED"] = "Generated new Warp with the id of: {0}",
                ["SUCCSESS"] = "Finished linking the chest to the warp id: {0}",
                ["SINGLEWARP"] = "You can only link a single warp to a box",
                ["SAMEBOX"] = "You cannot Link a Box to Itself",
				["OWNERSHIP"] = "This Warp Doesnt Belong to you",
				["REMOVED"] = "Removed Warp with the id of: {0}",
                ["NOWARP"] = "There is no Warp associated with this Box",
				["UNMATCHED"] = "Removed Unmatched Warp with the id of: {0}",
                ["CANCELERR"] = "There is Nothing to Cancel",
                ["CANCEL"] = "Cancelled Warp Linking with the id of: {0}",
				["HELP"] = "Commands Are:" +
                             "\n /cw add (or just /cw) - Adds a Chest to the current Wap Pairing" +
                             "\n /cw cancel - Cancels the current Warp Pairing" +
                             "\n /cw clear - Clears a Chest from a warp" +
                             "\n /cw help - Displays This",  
                ["RAY.NULL"] = "You are not looking at a Valid Entity!"
            }, this);
		}

		void Init(){
			if (Interface.Oxide.DataFileSystem.ExistsDatafile("ChestWarp/Chests"))
                chestWarps = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<string, Warp>>("ChestWarp/Chests");

			permission.RegisterPermission("chestwarp.use", this);
			permission.RegisterPermission("chestwarp.admin", this);
		}
		
		void OnServerSave() {
			Clean();
			Interface.Oxide.DataFileSystem.WriteObject("ChestWarp/Chests", chestWarps);
		}

        void OnLootEntity(BasePlayer player, BaseEntity entity)
        {
			if (player.IsDucked()) {
				return;
			}

            Warp warp = null;
            if (chestWarps.Any(p => p.Value.FirstPoint == entity.net.ID || p.Value.SecondPoint == entity.net.ID))
                warp = chestWarps.First(p => p.Value.FirstPoint == entity.net.ID || p.Value.SecondPoint == entity.net.ID).Value;
            else
                return;


			BaseEntity teleportBox = null;
			if(warp.FirstPoint == entity.net.ID)
            	teleportBox = BaseNetworkable.serverEntities.Find(warp.SecondPoint) as BaseEntity;
			else
            	teleportBox = BaseNetworkable.serverEntities.Find(warp.FirstPoint) as BaseEntity;



            if (teleportBox == null){
				var id = chestWarps.Where(v => v.Value.FirstPoint == entity.net.ID || v.Value.SecondPoint == entity.net.ID).First().Key;
				chestWarps.Remove(id);
				SendReply(player, Lang("UNMATCHED", player.UserIDString, id));//lang.GetMessage("UNMATCHED", this, player.UserIDString) + id);
				return;
			}
            
            timer.Once(0.01f, player.EndLooting);

            
			Teleport(player, teleportBox.transform.position + new Vector3(0f, 2f, 0f));
        }

		void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
		{
			if (chestWarps.Any(v => v.Value.FirstPoint == entity.net.ID || v.Value.SecondPoint == entity.net.ID)) {
				var id = chestWarps.Where(v => v.Value.FirstPoint == entity.net.ID || v.Value.SecondPoint == entity.net.ID).First().Key;
				chestWarps.Remove(id);
				//Puts("Removed Warp with the id of: " + id);
			}
		}

		#endregion

		#region Commands

		[ChatCommand("cw")]
        void cmdWarp(BasePlayer player, string command, string[] args)
        {
			if (!permission.UserHasPermission(player.UserIDString, "chestwarp.use") && !permission.UserHasPermission(player.UserIDString, "chestwarp.admin")) {
				SendReply(player, Lang("PERMISSION",  player.UserIDString ));
				return;
			}

			if (!activeBinds.ContainsKey(player.userID)){
				activeBinds.Add(player.userID, new setup(player.userID));
			}
			
			RaycastHit hitInfo;

			if (args.Length > 0){
				switch (args[0]) {
					case "cancel":
						if (activeBinds[player.userID].isActive == false){
							SendReply(player, Lang("CANCELERR",  player.UserIDString ));
							return;
						}

						var currentBind = activeBinds[player.userID];
						SendReply(player, Lang("CANCEL",  player.UserIDString, currentBind.id));
						currentBind.isActive = false;
						return;
					break;
					case "help":
						SendReply(player, Lang("HELP",  player.UserIDString ));
						return;
					break;
				}
			}
			
			bool isLookingAtObject = Physics.Raycast(player.eyes.position, Quaternion.Euler(player.GetNetworkRotation().eulerAngles) * Vector3.forward, out hitInfo, 5f, LayerMask.GetMask(new string[] { "Deployed" }));
			
			if(!isLookingAtObject){
				SendReply(player, Lang("RAY.NULL",  player.UserIDString ));
				return;
			}

			if (!(hitInfo.GetEntity() is BoxStorage)){
				SendReply(player, Lang("RAY.NULL",  player.UserIDString ));
				return;
			}

			var boxid = hitInfo.GetEntity().net.ID;

			if (args.Length > 0 && args[0] == "clear"){
					
				if (!chestWarps.Any(v => v.Value.FirstPoint == boxid || v.Value.SecondPoint == boxid)){
					SendReply(player, Lang("NOWARP",  player.UserIDString ));
					return;
				}

				var id = chestWarps.First(v => v.Value.FirstPoint == boxid || v.Value.SecondPoint == boxid);
				if(id.Value.User != player.userID && !permission.UserHasPermission(player.UserIDString, "chestwarp.admin")){
					SendReply(player, Lang("OWNERSHIP",  player.UserIDString ));
					return;
				}

				chestWarps.Remove(id.Key);
				SendReply(player, Lang("REMOVED",  player.UserIDString, id.Key));

				return;
			}

			setup playerBind = activeBinds[player.userID];
			if (chestWarps.Any(i => i.Value.FirstPoint == boxid || i.Value.SecondPoint == boxid)) {
				SendReply(player, Lang("SINGLEWARP",  player.UserIDString ));
				return;
			}

			if (playerBind.isActive){
				if (boxid == playerBind.warp.FirstPoint){
					SendReply(player, Lang("SAMEBOX",  player.UserIDString ));
					return;
				}

				playerBind.warp.SecondPoint = hitInfo.GetEntity().net.ID;
				chestWarps.Add(playerBind.id, playerBind.warp);
				playerBind.isActive = false;
				activeBinds[player.userID].warp = new Warp();
				SendReply(player, Lang("SUCCSESS",  player.UserIDString, playerBind.id));
			}
			else{
				string id = Guid.NewGuid().ToString("N");
				playerBind.id = id;
				playerBind.warp.FirstPoint = hitInfo.GetEntity().net.ID;
				playerBind.isActive = true;
				SendReply(player, Lang("GENERATED",  player.UserIDString, id));
			}
			return;
        }

		#endregion

		#region function
		void Clean(){
			foreach(var i in chestWarps) {
				Warp warp = i.Value;
				BaseEntity firstBox = BaseNetworkable.serverEntities.Find(warp.FirstPoint) as BaseEntity;
				BaseEntity secondBox = BaseNetworkable.serverEntities.Find(warp.SecondPoint) as BaseEntity;
				if (firstBox == null || secondBox == null)
				{
					chestWarps.Remove(i.Key);
					//Puts("Removed: " + i.Key);
				}
			}
		}
		void Teleport(BasePlayer player, Vector3 pos) {
			if (player.net?.connection != null)
				player.ClientRPCPlayer(null, player, "StartLoading");
			player.StartSleeping();
			player.MovePosition(pos);
			if (player.net?.connection != null)
				player.ClientRPCPlayer(null, player, "ForcePositionTo", pos);
			if (player.net?.connection != null)
				player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, true);
			player.UpdateNetworkGroup();
			player.SendFullSnapshot();
		}

		//Written by Wulf @https://umod.org/plugins/bed-rename-blocker
		private string Lang(string key, string id, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);
		#endregion
	}
}

// --- End of file: ChestWarp.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/community-vigilance ---
// --- Original File Path: C/CommunityVigilance/CommunityVigilance.cs ---

/*
CommunityVigilance Copyright (c) 2021 by PinguinNordpol

This plugin is loosely based on "Skip Night Vote" plugin which is

Copyright (c) 2019 k1lly0u

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Oxide.Core.Libraries;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Community Vigilance", "PinguinNordpol", "0.2.2")]
    [Description("Adds the possibility to start votes to kick players from the server")]
    class CommunityVigilance : CovalencePlugin
    {
        #region Fields
        private List<string> ReceivedVotes = new List<string>();

        private bool IsVoteOpen = false;
        private IPlayer TargetPlayer = null;
        private bool DisplayCountEveryVote = false;
        private int TimeRemaining = 0;
        private int CooldownTime = 0;
        private int RequiredVotes = 0;
        private string TimeRemMSG = "";
        private Timer VotingTimer = null;
        private Timer CountTimer = null;
        private Timer CooldownTimer = null;

        private enum VoteEndReason : int
        {
            VoteEnded = 0,
            PlayerDisconnected = 1,
            AdminAbort = 2
        }
        #endregion

        #region Oxide Hooks
        void Init()
        {
            // Register our permissions
            permission.RegisterPermission("communityvigilance.use", this);
            permission.RegisterPermission("communityvigilance.startvote", this);
            permission.RegisterPermission("communityvigilance.admin", this);
        }

        void Loaded() => lang.RegisterMessages(Messages, this);

        void OnServerInitialized()
        {
            LoadVariables();
            this.TimeRemMSG = GetMSG("timeRem").Replace("{cmd}", this.configData.Commands.CommandVoteKick);
            if (this.configData.Messaging.DisplayCountEvery == -1) this.DisplayCountEveryVote = true;

            // Register our commands
            AddCovalenceCommand(this.configData.Commands.CommandVoteKick, "cmdVoteKick");
            AddCovalenceCommand(this.configData.Commands.CommandVoteKickCancel, "cmdVoteKickCancel");
        }

        void Unload()
        {
            if (this.VotingTimer != null) this.VotingTimer.Destroy();
            if (this.CountTimer != null) this.CountTimer.Destroy();
            if (this.CooldownTimer != null) this.CooldownTimer.Destroy();
        }

        void OnUserDisconnected(IPlayer player)
        {
            if (this.IsVoteOpen && this.TargetPlayer.Id == player.Id)
            {
                VoteEnd(false, VoteEndReason.PlayerDisconnected);
            }
        }
        #endregion

        #region Functions
        /*
         * OpenVote
         *
         * Starts a new vote
         */
        private void OpenVote(IPlayer player, string playerNameOrId)
        {
            // Make sure cooldown is over
            if (!player.HasPermission("communityvigilance.admin") && this.CooldownTimer != null)
            {
                player.Reply(GetMSG("CooldownActive", player.Id).Replace("{secs}", this.CooldownTime.ToString()));
                return;
            }

            // Find target player
            this.TargetPlayer = FindPlayer(player, playerNameOrId);
            if (this.TargetPlayer == null) return;

            // Make sure target player is of lower or same authlevel
            if (GetPlayerAuthlevel(this.TargetPlayer) > GetPlayerAuthlevel(player))
            {
                player.Reply(GetMSG("CantKickHigherAuthlevel", player.Id));
                return;
            }

            // Make sure server population is above configured minimum
            if (!player.HasPermission("communityvigilance.admin") && server.Players < this.configData.Options.RequiredMinPlayers)
            {
                player.Reply(GetMSG("NotEnoughPlayers", player.Id).Replace("{minPlayers}", this.configData.Options.RequiredMinPlayers.ToString()));
                return;
            }

            // Calculate required votes to pass
            var rVotes = (server.Players - 1) * this.configData.Options.RequiredVotePercentage;
            if (rVotes < 1) rVotes = 1;
            this.RequiredVotes = Convert.ToInt32(rVotes);

            // Log votekick attempt
            Puts($"Player '{player.Name.Sanitize()}' ({player.Id}) initiated a votekick against '{this.TargetPlayer.Name.Sanitize()}' ({this.TargetPlayer.Id})");

            // Opening a vote is considered as casting a vote too
            this.ReceivedVotes.Add(player.Id);
            if (this.RequiredVotes == 1)
            {
                // If only one vote is required, we're already done
                VoteEnd(true);
                return;
            }

            // Start vote
            this.IsVoteOpen = true;
            var msg = GetMSG("voteMSG").Replace("{reqVote}", this.RequiredVotes.ToString()).Replace("{cmd}", this.configData.Commands.CommandVoteKick).Replace("{player}", this.TargetPlayer.Name.Sanitize());
            server.Broadcast(msg);
            VoteTimer();
            if (!this.DisplayCountEveryVote) this.CountTimer = timer.In(this.configData.Messaging.DisplayCountEvery, ShowCountTimer);
        }

        /*
         * VoteTimer
         *
         * Starts a voting timer
         */
        private void VoteTimer()
        {
            this.TimeRemaining = this.configData.Timers.VoteOpenSecs;
            this.VotingTimer = timer.Repeat(1, this.TimeRemaining, () =>
            {
                this.TimeRemaining--;

                // Show message every full minute, then every 10 seconds
                if (this.TimeRemaining/60 > 0 && this.TimeRemaining%60 == 0)
                {
                    server.Broadcast(TimeRemMSG.Replace("{time}", (this.TimeRemaining/60).ToString()).Replace("{type}", GetMSG("Minutes")));
                }
                else if (this.TimeRemaining/60 == 0 && this.TimeRemaining/10 > 0 && this.TimeRemaining%10 == 0)
                {
                    server.Broadcast(TimeRemMSG.Replace("{time}", this.TimeRemaining.ToString()).Replace("{type}", GetMSG("Seconds")));
                }
                else if (this.TimeRemaining == 0)
                {
                    VoteEnd((this.ReceivedVotes.Count >= this.RequiredVotes));
                }
            });
        }

        /*
         * ShowCountTimer
         *
         * Broadcasts the current voting stats
         */
        private void ShowCountTimer()
        {
            server.Broadcast(GetMSG("HaveVotedToKick").Replace("{recVotes}", this.ReceivedVotes.Count.ToString()).Replace("{reqVotes}", this.RequiredVotes.ToString()).Replace("{player}", this.TargetPlayer.Name.Sanitize()));
            this.CountTimer = timer.In(this.configData.Messaging.DisplayCountEvery, ShowCountTimer);
        }

        /*
         * VoteEnd
         *
         * Ends a vote
         */
        private void VoteEnd(bool success, VoteEndReason reason = VoteEndReason.VoteEnded)
        {
            // Stop timers
            if (this.VotingTimer != null)
            {
                this.VotingTimer.Destroy();
                this.VotingTimer = null;
            }
            if (this.CountTimer != null)
            {
              this.CountTimer.Destroy();
              this.CountTimer = null;
            }

            switch(reason)
            {
                default:
                case VoteEndReason.VoteEnded:
                {
                    if (success)
                    {
                        server.Broadcast(GetMSG("VoteSuccess").Replace("{player}", this.TargetPlayer.Name.Sanitize()));
                        Puts($"Votekick against '{this.TargetPlayer.Name.Sanitize()}' ({this.TargetPlayer.Id}) was successful ({this.ReceivedVotes.Count} player(s) voted in favor)");
                        this.TargetPlayer.Kick(GetMSG("KickReason", TargetPlayer.Id));
                    }
                    else
                    {
                        server.Broadcast(GetMSG("VoteFailed").Replace("{player}", this.TargetPlayer.Name.Sanitize()));
                        Puts($"Votekick against '{this.TargetPlayer.Name.Sanitize()}' ({this.TargetPlayer.Id}) failed ({this.ReceivedVotes.Count} player(s) voted in favor, {this.RequiredVotes} votes were needed)");
                    }
                    break;
                }
                case VoteEndReason.PlayerDisconnected:
                {
                    server.Broadcast(GetMSG("VoteEndedDisconnected"));
                    Puts($"Votekick against '{this.TargetPlayer.Name.Sanitize()}' ({this.TargetPlayer.Id}) was cancelled. Player disconnected");
                    break;
                }
                case VoteEndReason.AdminAbort:
                {
                    server.Broadcast(GetMSG("VoteWasAborted"));
                    break;
                }
            }

            // Reset values
            this.IsVoteOpen = false;
            this.RequiredVotes = 0;
            this.ReceivedVotes.Clear();
            this.TimeRemaining = 0;
            this.TargetPlayer = null;

            // Start cooldown timer
            if (this.configData.Timers.VoteCooldownSecs > 0)
            {
                if (this.CooldownTimer != null) this.CooldownTimer.Destroy();
                this.CooldownTime = this.configData.Timers.VoteCooldownSecs;
                this.CooldownTimer = timer.Repeat(1, this.CooldownTime, () =>
                {
                    this.CooldownTime--;
                    if (this.CooldownTime == 0)
                    {
                        this.CooldownTimer.Destroy();
                        this.CooldownTimer = null;
                    }
                });
            }
        }
        #endregion

        #region Helpers
        /*
         * AlreadyVoted
         *
         * Check if a player has already voted
         */
        private bool AlreadyVoted(string player) => this.ReceivedVotes.Contains(player);

        /*
         * FindPlayer
         *
         * Find a player base on steam id or name
         */
        private IPlayer FindPlayer(IPlayer player, string playerNameOrId)
        {
            IPlayer[] foundPlayers = players.FindPlayers(playerNameOrId).ToArray();
            if (foundPlayers.Length > 1)
            {
                player.Reply(GetMSG("MultiplePlayersFound", player.Id));
                return null;
            }

            if (foundPlayers.Length != 1)
            {
                player.Reply(GetMSG("NoPlayerFound", player.Id));
                return null;
            }

            return foundPlayers[0];
        }

        /*
         * GetPlayerAuthlevel
         *
         * Get a player's authlevel
         */
        private uint GetPlayerAuthlevel(IPlayer player) {
          BasePlayer base_player = player.Object as BasePlayer;
          return base_player.net.connection.authLevel;
        }

        /*
         * ColorizeText
         *
         * Replace color placeholders in messages
         */
        private string ColorizeText(string msg)
        {
            return msg.Replace("{MsgCol}", this.configData.Messaging.MsgColor).Replace("{HilCol}", this.configData.Messaging.MainColor).Replace("{ErrCol}", this.configData.Messaging.ErrColor).Replace("{ColEnd}","</color>");
        }
        #endregion

        #region ChatCommands
        /*
         * cmdVoteKick
         *
         * Chat command to start / cast a vote
         */
        private void cmdVoteKick(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission("communityvigilance.use")) return;
            else if ((player.HasPermission("communityvigilance.startvote") || player.HasPermission("communityvigilance.admin")) && args != null && args.Length > 0)
            {
                // Start new vote
                if (args.Length != 1)
                {
                    player.Reply(GetMSG("OpenVote", player.Id).Replace("{cmd}", this.configData.Commands.CommandVoteKick));
                    return;
                }
                if (this.IsVoteOpen)
                {
                    player.Reply(GetMSG("AlreadyVoteOpen", player.Id));
                    return;
                }
                OpenVote(player, args[0]);
            }
            else if (this.IsVoteOpen)
            {
                // Cast vote
                if (this.TargetPlayer.Id == player.Id)
                {
                    player.Reply(GetMSG("TargetedPlayerCantVote", player.Id));
                    return;
                }
                else if (!this.AlreadyVoted(player.Id))
                {
                    this.ReceivedVotes.Add(player.Id);
                    player.Reply(GetMSG("YouHaveVoted", player.Id).Replace("{player}", this.TargetPlayer.Name.Sanitize()));
                    if (this.DisplayCountEveryVote)
                        server.Broadcast(GetMSG("HaveVotedToKick", player.Id).Replace("{recVotes}", this.ReceivedVotes.Count.ToString()).Replace("{reqVotes}", this.RequiredVotes.ToString()).Replace("{player}", this.TargetPlayer.Name.Sanitize()));
                    if (this.ReceivedVotes.Count >= this.RequiredVotes)
                        VoteEnd(true);
                    return;
                }
                else player.Reply(GetMSG("AlreadyVoted", player.Id));
            }
            else if (player.HasPermission("communityvigilance.startvote") || player.HasPermission("communityvigilance.admin"))
            {
                player.Reply(GetMSG("NoOpenVoteButPermission", player.Id).Replace("{cmd}", this.configData.Commands.CommandVoteKick));
            }
            else player.Reply(GetMSG("NoOpenVoteAndNoPermission", player.Id));
        }

        /*
         * cmdVoteKickCancel
         *
         * Chat command to cancel a vote
         */
        private void cmdVoteKickCancel(IPlayer player, string command, string[] args)
        {
            if (!player.HasPermission("communityvigilance.admin")) return;
            else if (!this.IsVoteOpen)
            {
                player.Reply(GetMSG("NoOpenVote", player.Id));
                return;
            }
            Puts($"Votekick against {this.TargetPlayer.Name.Sanitize()} ({this.TargetPlayer.Id}) was cancelled by '{player.Name.Sanitize()}' ({player.Id})");
            VoteEnd(false, VoteEndReason.AdminAbort);
        }
        #endregion

        #region Config
        private ConfigData configData;
        class Messaging
        {
            public int DisplayCountEvery { get; set; }
            public string MainColor { get; set; }
            public string MsgColor { get; set; }
            public string ErrColor { get; set; }
        }        
        class Timers
        {
            public int VoteOpenSecs { get; set; }
            public int VoteCooldownSecs { get; set; }
        }
        class Options
        {
            public float RequiredVotePercentage { get; set; }
            public int RequiredMinPlayers { get; set; }
        }
        class Commands
        {
            public string CommandVoteKick { get; set; }
            public string CommandVoteKickCancel { get; set; }
        }
        class ConfigData
        {
            public Messaging Messaging { get; set; }
            public Timers Timers { get; set; }
            public Options Options { get; set; }
            public Commands Commands { get; set; }

        }
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                Messaging = new Messaging
                {
                    DisplayCountEvery = 30,
                    MsgColor = "<color=#939393>",
                    MainColor = "<color=orange>",
                    ErrColor = "<color=red>"
                },
                Options = new Options
                {
                    RequiredVotePercentage = 0.8f,
                    RequiredMinPlayers = 4
                },
                Timers = new Timers
                {
                    VoteOpenSecs = 240,
                    VoteCooldownSecs = 300
                },
                Commands = new Commands
                {
                    CommandVoteKick = "votekick",
                    CommandVoteKickCancel = "votekickcancel"
                }
            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => this.configData = Config.ReadObject<ConfigData>();
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion

        #region Messaging
        private string GetMSG(string key, string userid = null) => ColorizeText(lang.GetMessage(key, this, userid));
        Dictionary<string, string> Messages = new Dictionary<string, string>
        {
            {"OpenVote", "Use {HilCol}/{cmd} PlayerName|SteamID{ColEnd} {MsgCol}to open a new vote{ColEnd}" },
            {"NoOpenVote", "{ErrCol}There is currently no ongoing vote!{ColEnd}" },
            {"NoOpenVoteAndNoPermission", "{ErrCol}There is currently no ongoing vote and you don't have permission to initiate a new one!{ColEnd}" },
            {"NoOpenVoteButPermission", "{ErrCol}There is currently no ongoing vote!{ColEnd}\n{MsgCol}To start a new vote use {ColEnd}{HilCol}/{cmd} PlayerName|SteamID{ColEnd}" },
            {"YouHaveVoted", "{MsgCol}You have voted to kick '{player}'{ColEnd}" },
            {"HaveVotedToKick", "{HilCol}{recVotes} / {reqVotes}{ColEnd} {MsgCol}players have voted to kick '{player}'{ColEnd}" },
            {"VoteSuccess", "{HilCol}Voting was successful, bye bye '{player}'.{ColEnd}" },
            {"VoteFailed", "{HilCol}Voting was unsuccessful, '{player}' remains in the game.{ColEnd}" },
            {"Minutes", "Minute(s)" },
            {"Seconds", "Seconds" },
            {"voteMSG", "{MsgCol}Type</color> {HilCol}/{cmd}</color> {MsgCol}now if you want to kick '{player}'. A total of {ColEnd}{HilCol}{reqVote}{ColEnd} {MsgCol}votes are needed.{ColEnd}" },
            {"timeRem", "{MsgCol}Voting ends in{ColEnd} {HilCol}{time} {type}{ColEnd}{MsgCol}, use {ColEnd}{HilCol}/{cmd}{ColEnd}{MsgCol} now to cast your vote{ColEnd}" },
            {"NoPlayerFound", "{ErrCol}No players found by that name / id!{ColEnd}" },
            {"MultiplePlayersFound", "{ErrCol}Given player identification string matches multiple players!{ColEnd}" },
            {"KickReason", "We're sorry but a majority of players wanted you to leave" },
            {"AlreadyVoteOpen", "{ErrCol}A vote is already ongoing!{ColEnd}" },
            {"AlreadyVoted", "{ErrCol}You have already voted!{ColEnd}" },
            {"TargetedPlayerCantVote", "{ErrCol}You are excluded from the current vote!{ColEnd}" },
            {"CantKickHigherAuthlevel", "{ErrCol}You are not allowed to kick higher-level players!{ColEnd}" },
            {"VoteEndedDisconnected", "{MsgCol}Previous vote was cancelled, player disconnected.{ColEnd}" },
            {"VoteWasAborted", "{MsgCol}Previous vote was cancelled by and admin.{ColEnd}" },
            {"NotEnoughPlayers", "{ErrCol}A minimum of {minPlayers} players are needed to be able to initiate a vote!{ColEnd}" },
            {"CooldownActive", "{ErrCol}You have to wait another {secs} second(s) before a new vote can be started!{ColEnd}" }
        };
        #endregion
    }
}


// --- End of file: CommunityVigilance.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/chill-night-vision ---
// --- Original File Path: C/ChillNightVision/ChillNightVision.cs ---

ï»¿using Oxide.Game.Rust.Cui;
using UnityEngine;
using System;
using Rust;
using System.Collections.Generic;
using Oxide.Core;
using Newtonsoft.Json;
using System.Globalization;
using System.Linq;
using System.Text.RegularExpressions;

namespace Oxide.Plugins
{
    [Info("Chill Night Vision", "Thisha", "0.0.1")]
    [Description("Visual support for night goggles")]

    public class ChillNightVision : RustPlugin
    {
        private const string usePermission = "chillnightvision.use";
        private const string modifyPermission = "chillnightvision.modify";
        
        private const string inviteNoticeMsg = "assets/bundled/prefabs/fx/invite_notice.prefab";
        private const string gogglesShortName = "nightvisiongoggles";

        private const string defaultPictureURL = "https://cdn.discordapp.com/attachments/504359168312868874/808277427498254356/RustachillNightVision.png";
        private float pictureOffset = 0.012f; //0.022f;
        
        public DateTime lastCleanUp;

        public enum ShowValues { All, Bar, Value };

        public enum AllColors
        {
            AliceBlue = 28,
            AntiqueWhite = 29,
            Aqua = 30,
            Aquamarine = 31,
            Azure = 32,
            Beige = 33,
            Bisque = 34,
            Black = 35,
            BlanchedAlmond = 36,
            Blue = 37,
            BlueViolet = 38,
            Brown = 39,
            BurlyWood = 40,
            CadetBlue = 41,
            Chartreuse = 42,
            Chocolate = 43,
            Coral = 44,
            CornflowerBlue = 45,
            Cornsilk = 46,
            Crimson = 47,
            Cyan = 48,
            DarkBlue = 49,
            DarkCyan = 50,
            DarkGoldenrod = 51,
            DarkGray = 52,
            DarkGreen = 53,
            DarkKhaki = 54,
            DarkMagenta = 55,
            DarkOliveGreen = 56,
            DarkOrange = 57,
            DarkOrchid = 58,
            DarkRed = 59,
            DarkSalmon = 60,
            DarkSeaGreen = 61,
            DarkSlateBlue = 62,
            DarkSlateGray = 63,
            DarkTurquoise = 64,
            DarkViolet = 65,
            DeepPink = 66,
            DeepSkyBlue = 67,
            DimGray = 68,
            DodgerBlue = 69,
            Firebrick = 70,
            FloralWhite = 71,
            ForestGreen = 72,
            Fuchsia = 73,
            Gainsboro = 74,
            GhostWhite = 75,
            Gold = 76,
            Goldenrod = 77,
            Gray = 78,
            Green = 79,
            GreenYellow = 80,
            Honeydew = 81,
            HotPink = 82,
            IndianRed = 83,
            Indigo = 84,
            Ivory = 85,
            Khaki = 86,
            Lavender = 87,
            LavenderBlush = 88,
            LawnGreen = 89,
            LemonChiffon = 90,
            LightBlue = 91,
            LightCoral = 92,
            LightCyan = 93,
            LightGoldenrodYellow = 94,
            LightGray = 95,
            LightGreen = 96,
            LightPink = 97,
            LightSalmon = 98,
            LightSeaGreen = 99,
            LightSkyBlue = 100,
            LightSlateGray = 101,
            LightSteelBlue = 102,
            LightYellow = 103,
            Lime = 104,
            LimeGreen = 105,
            Linen = 106,
            Magenta = 107,
            Maroon = 108,
            MediumAquamarine = 109,
            MediumBlue = 110,
            MediumOrchid = 111,
            MediumPurple = 112,
            MediumSeaGreen = 113,
            MediumSlateBlue = 114,
            MediumSpringGreen = 115,
            MediumTurquoise = 116,
            MediumVioletRed = 117,
            MidnightBlue = 118,
            MintCream = 119,
            MistyRose = 120,
            Moccasin = 121,
            NavajoWhite = 122,
            Navy = 123,
            OldLace = 124,
            Olive = 125,
            OliveDrab = 126,
            Orange = 127,
            OrangeRed = 128,
            Orchid = 129,
            PaleGoldenrod = 130,
            PaleGreen = 131,
            PaleTurquoise = 132,
            PaleVioletRed = 133,
            PapayaWhip = 134,
            PeachPuff = 135,
            Peru = 136,
            Pink = 137,
            Plum = 138,
            PowderBlue = 139,
            Purple = 140,
            Red = 141,
            RosyBrown = 142,
            RoyalBlue = 143,
            SaddleBrown = 144,
            Salmon = 145,
            SandyBrown = 146,
            SeaGreen = 147,
            SeaShell = 148,
            Sienna = 149,
            Silver = 150,
            SkyBlue = 151,
            SlateBlue = 152,
            SlateGray = 153,
            Snow = 154,
            SpringGreen = 155,
            SteelBlue = 156,
            Tan = 157,
            Teal = 158,
            Thistle = 159,
            Tomato = 160,
            Turquoise = 161,
            Violet = 162,
            Wheat = 163,
            White = 164,
            WhiteSmoke = 165,
            Yellow = 166,
            YellowGreen = 167,
        }

        #region localization
        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["HelpInfo"] = "Use \"/cnv <on|off>\" to show hide the night vision panel.",
                ["HelpShow"] = "Use \"/cnv show <alerts|ranges>\" to see your active alerts/colors.",
                ["HelpView"] = "Use \"/cnv view <bar|value|all>\" to switch view.",
                ["HelpColor"] = "Use \"/cnv colors help\" to show more info about color usage.",
                ["HelpColorList"] = "Use \"/cnv colors list\" to see a list of the available color names.",
                ["HelpAlertAdd"] = "Use \"/cnv add alert <number>\" to add or update an alert",
                ["HelpRangeAdd"] = "Use \"/cnv add range <number> <barcolor> <fontcolor>\" to add or update a color range.",
                ["HelpDelete"] = "Use \"/cnv remove <alert|range> <number>\" to delete a certain alert or range",
                ["HelpReset"] = "Use \"/cnv reset\" to reset your settings to defaults.",
                ["NoUsePermission"] = "You do not have permission to use the night vision information.",
                ["NoModifyPermission"] = "You do not have permission to modify night vision settings.",
                ["InvalidAlert"] = "Invalid alert value.",
                ["InvalidColor"] = "Invalid color value.",
                ["InvalidRGB"] = "Invalid RGB value.",
                ["InvalidNumberValue"] = "Invalid number value",
                ["NoAlerts"] = "You don't have any active alerts.",
                ["AlertAdded"] = "The alert has been added.",
                ["AlertUpdated"] = "The alert has been updated.",
                ["AlertRemoved"] = "The alert has been removed.",
                ["AlertDoesNotExists"] = "The alert does not exist.",
                ["NoRanges"] = "You don't have any color ranges.",
                ["RangeAdded"] = "The color range has been added.",
                ["RangeUpdated"] = "The color range has been updated.",
                ["RangeRemoved"] = "The color range has been removed.",
                ["RangeDoesNotExists"] = "The color range does not exist.",
                ["MaxAlerts"] = "You have reached the maximum number of alerts.",
                ["DataReset"] = "Your data has been reset to defaults.",
                ["ColorUsage"] = "Colors can be defined by a hexadecimal value, for example #FC03F0.\nTransparancy from FF (none) to 00 (full) can be added, for example FC03F0FF.\nColors can be defined by name too (case-sensitive), use \"/cnv colors list\" to view them.\nWhen using color names, the transparancy will be default.",
                ["ServerDefaults"] = "Server defaults",
                ["NoServerAlerts"] = "No alerts",
            }, this);
        }
        #endregion localization

        #region data
        private Dictionary<ulong, PlayerData> playerData = new Dictionary<ulong, PlayerData>();

        private class PlayerData
        {
            public bool Enabled;
            public string ShowInfo = string.Empty;
            public DateTime LastChange = DateTime.Today;
            public DateTime LastOnline = DateTime.Today;

            public Dictionary<uint, SimpleRangeData> ColorRanges = new Dictionary<uint, SimpleRangeData>();
            public List<uint> Alerts = new List<uint>();

            public PlayerData()
            {

            }
        }
        #endregion data

        #region config
        private ConfigData config;

        class ConfigData
        {
            [JsonProperty(PropertyName = "Lower Range Color Value")]
            public SimpleRangeData LowerRange = new SimpleRangeData
            {
                BarColorValue = "#bce8df",
                FontColorValue = "#FFFFFFFF"
            };

            [JsonProperty(PropertyName = "Middle Range")]
            public FullRangeData MiddleRange = new FullRangeData
            {
                BarColorValue = "#80e8d3",
                StartValue = 300,
                FontColorValue = "#FFFFFFFF"
            };

            [JsonProperty(PropertyName = "Higher Range")]
            public FullRangeData HigherRange = new FullRangeData
            {
                BarColorValue = "#34ebc6",
                StartValue = 600,
                FontColorValue = "#FFFFFFFF"
            };

            [JsonProperty(PropertyName = "Alert 1")]
            public uint Alert1 = 0;

            [JsonProperty(PropertyName = "Show picture")]
            public bool ShowPicture = true;

            [JsonProperty(PropertyName = "Picture URL")]
            public string PictureURL = "https://i.imgur.com/eZdRSQU.png";

            [JsonProperty(PropertyName = "Show info (All, Bar, Value)")]
            public string ShowInfo = ShowValues.All.ToString();

            [JsonProperty(PropertyName = "Postition")]
            public AnchorPosition Position = new AnchorPosition
            {
                XAxis = 0.035f,
                YAxis = 0.007f
            };

            [JsonProperty(PropertyName = "Maximum Player Alerts")]
            public uint MaxAlerts = 6;

            [JsonProperty(PropertyName = "Remove after offline days")]
            public uint OffDays = 0;
        }

        private class FullRangeData
        {
            [JsonProperty(PropertyName = "Starting Value")]
            public uint StartValue = 0;

            [JsonProperty(PropertyName = "Bar Color")]
            public string BarColorValue = "#00000000";

            [JsonProperty(PropertyName = "Font Color")]
            public string FontColorValue = "#00000000";
        }

        private class AnchorPosition
        {
            [JsonProperty(PropertyName = "X-axis")]
            public float XAxis = 0;

            [JsonProperty(PropertyName = "Y-axis")]
            public float YAxis = 0;
        }

        private class SimpleRangeData
        {
            [JsonProperty(PropertyName = "Bar Color")]
            public string BarColorValue = "#00000000";

            [JsonProperty(PropertyName = "Font Color")]
            public string FontColorValue = "#00000000";

            public SimpleRangeData()
            {

            }

            public SimpleRangeData(string barcolor, string fontcolor)
            {
                BarColorValue = barcolor;
                FontColorValue = fontcolor;
            }
        }

        protected override void LoadDefaultConfig()
        {
            config = new ConfigData();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                config = Config.ReadObject<ConfigData>();
                if (config == null)
                    throw new Exception();

                SaveConfig();
            }
            catch
            {
                LoadDefaultConfig();
            }

        }
        #endregion config

        #region commands
        [ChatCommand("cnv")]
        void HandleChatcommand(BasePlayer player, string command, string[] args)
        {
            bool doUpdate = false;

            if (!permission.UserHasPermission(player.UserIDString, usePermission))
            {
                PrintToChat(player, Lang("NoUsePermission", player.UserIDString));
                return;
            }

            switch (args.Length)
            {
                case 1:
                    {
                        switch (args[0].ToLower())
                        {
                            case "on":
                                {
                                    ShowOxygen(player);
                                    break;
                                }

                            case "off":
                                {
                                    HideOxygen(player);
                                    break;
                                }

                            case "reset":
                                {
                                    if (!permission.UserHasPermission(player.UserIDString, modifyPermission))
                                    {
                                        PrintToChat(player, Lang("NoModifyPermission", player.UserIDString));
                                        return;
                                    }
                                    InitPlayer(player.userID, true);
                                    player.ChatMessage(Lang("DataReset", player.UserIDString));

                                    Item item;
                                    if (IsWearingGoggles(player, out item))
                                        UpdatePanels(player, item.condition, item.maxCondition, true);

                                    break;
                                }

                            default:
                                {
                                    ShowCommandHelp(player);
                                    break;
                                }
                        }
                        break;
                    }

                case 2:
                    {
                        switch (args[0].ToLower())
                        {
                            case "show":
                                {
                                    switch (args[1].ToLower())
                                    {
                                        case "alerts":
                                            { }
                                            player.ChatMessage(GetAlerts(player.userID));
                                            break;

                                        case "ranges":
                                            {
                                                player.ChatMessage(GetRanges(player.userID));
                                                break;
                                            }

                                        default:
                                            {
                                                PrintToChat(player, Lang("HelpShow", player.UserIDString));
                                                break;
                                            }
                                    }
                                    break;
                                }

                            case "view":
                                {
                                    if (!permission.UserHasPermission(player.UserIDString, modifyPermission))
                                    {
                                        PrintToChat(player, Lang("NoModifyPermission", player.UserIDString));
                                        return;
                                    }

                                    switch (args[1].ToLower())
                                    {
                                        case "bar":
                                            {
                                                ChangeView(player.userID, args[1], out doUpdate);
                                                break;
                                            }

                                        case "value":
                                            {
                                                ChangeView(player.userID, args[1], out doUpdate);
                                                break;
                                            }

                                        case "all":
                                            {
                                                ChangeView(player.userID, args[1], out doUpdate);
                                                break;
                                            }

                                        default:
                                            {
                                                PrintToChat(player, Lang("HelpView", player.UserIDString));
                                                break;
                                            }
                                    }
                                    break;
                                }

                            case "colors":
                                {
                                    switch (args[1].ToLower())
                                    {
                                        case "help":
                                            {
                                                PrintToChat(player, Lang("ColorUsage", player.UserIDString));
                                                break;
                                            }

                                        case "list":
                                            {
                                                PrintToChat(player, ColorList());
                                                break;
                                            }

                                        default:
                                            {
                                                PrintToChat(player, Lang("HelpColor", player.UserIDString));
                                                break;
                                            }
                                    }
                                    break;
                                }


                            default:
                                ShowCommandHelp(player);
                                break;
                        }
                        break;
                    }

                case 3:
                    {
                        if (!permission.UserHasPermission(player.UserIDString, modifyPermission))
                        {
                            PrintToChat(player, Lang("NoModifyPermission", player.UserIDString));
                            return;
                        }

                        switch (args[0].ToLower())
                        {
                            case "add":
                                {
                                    switch (args[1].ToLower())
                                    {
                                        case "alert":
                                            {
                                                player.ChatMessage(Lang(AddAlert(player.userID, args[2])));
                                                break;
                                            }

                                        default:
                                            {
                                                ShowCommandHelp(player);
                                                break;
                                            }
                                    }
                                    break;
                                }

                            case "remove":
                                {
                                    switch (args[1].ToLower())
                                    {
                                        case "alert":
                                            {
                                                player.ChatMessage(Lang(RemoveAlert(player.userID, args[2])));
                                                break;
                                            }

                                        case "range":
                                            {
                                                player.ChatMessage(Lang(RemoveRange(player.userID, args[2], out doUpdate)));
                                                break;
                                            }

                                        default:
                                            {
                                                ShowCommandHelp(player);
                                                break;
                                            }
                                    }
                                    break;
                                }

                            default:
                                ShowCommandHelp(player);
                                break;
                        }
                        break;
                    }

                case 5:
                    {
                        if (!permission.UserHasPermission(player.UserIDString, modifyPermission))
                        {
                            PrintToChat(player, Lang("NoModifyPermission", player.UserIDString));
                            return;
                        }

                        switch (args[0].ToLower())
                        {
                            case "add":
                                {
                                    switch (args[1].ToLower())
                                    {
                                        case "range":
                                            {
                                                string[] pars = new string[3] { args[2], args[3], args[4] };
                                                player.ChatMessage(Lang(AddRange(player.userID, pars, out doUpdate)));
                                                break;
                                            }

                                        default:
                                            {
                                                ShowCommandHelp(player);
                                                break;
                                            }
                                    }
                                    break;
                                }

                            default:
                                {
                                    ShowCommandHelp(player);
                                    break;
                                }

                        }
                        break;
                    }

                default:
                    {
                        ShowCommandHelp(player);
                        break;
                    }
            };

            if (doUpdate)
            {
                Item item;
                if (PlayerSignedUp(player))
                    if (IsWearingGoggles(player, out item))
                        UpdatePanels(player, item.condition, item.maxCondition, true);
            }

        }
        #endregion commands

        #region hooks
        private void Init()
        {
            permission.RegisterPermission(usePermission, this);
            permission.RegisterPermission(modifyPermission, this);
            LoadData();
        }

        void OnServerInitialized()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                if (!PlayerSignedUp(player))
                    continue;

                if (!player.IsAlive())
                    continue;

                Item item;
                if (IsWearingGoggles(player, out item))
                {
                    UpdatePanels(player, item.condition, item.maxCondition, true);
                }
            }
        }

        void OnServerSave()
        {
            RemoveOldData();
        }

        private void Unload()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                if (PlayerSignedUp(player))
                    DestroyUI(player, true);
            }
        }

        void OnPlayerConnected(BasePlayer player)
        {
            if (playerData.ContainsKey(player.userID))
            {
                playerData[player.userID].LastOnline = DateTime.Today;
                SaveData();
            }
        }

        private void OnPlayerSleepEnded(BasePlayer player)
        {
            if (!PlayerSignedUp(player))
                return;

            Item item;
            if (IsWearingGoggles(player, out item))
                UpdatePanels(player, item.condition, item.maxCondition, true);
        }

        void OnPlayerDeath(BasePlayer player, ref HitInfo info)
        {
            if (!PlayerSignedUp(player))
                return;

            Item item2;
            if (IsWearingGoggles(player, out item2))
                DestroyUI(player, true);
        }

        void OnItemAddedToContainer(ItemContainer cont, Item item)
        {
            if (ShouldHandleUI(cont, item))
                UpdatePanels(cont.playerOwner, item.condition, item.maxCondition, true);
        }

        void OnItemRemovedFromContainer(ItemContainer cont, Item item)
        {
            if (ShouldHandleUI(cont, item))
                DestroyUI(cont.GetOwnerPlayer(), true);
        }

        void OnEntityTakeDamage(BasePlayer player, ref HitInfo info)
        {
            if (info.damageTypes.Get(DamageType.Drowned) <= 0f)
                return;

            if (!PlayerSignedUp(player))
                return;

            if (!player.IsAlive())
                return;

            Item item;
            if (IsWearingGoggles(player, out item))
            {
                UpdatePanels(player, item.condition, item.maxCondition, true);
            }
        }

        void OnLoseCondition(Item item, ref float amount)
        {
            if (!item.info.shortname.Equals(gogglesShortName))
                return;

            BasePlayer player = item.GetOwnerPlayer();

            if (!PlayerSignedUp(player))
                return;

            UpdatePanels(player, item.condition - 3f, item.maxCondition, false);
        }

        void OnItemAction(Item item, string action, BasePlayer player)
        {
            if (!action.ToUpper().Contains("REFILL"))
                return;

            Item item2;
            if ((item.info.shortname.Equals(gogglesShortName)) && (IsWearingGoggles(player, out item2)))
            {
                float maxLossFraction = 0.05f;
                float tempMax = 0;
                float single = 1f - item.condition / item.maxCondition;
                maxLossFraction = Mathf.Clamp(maxLossFraction, 0f, item.maxCondition);
                tempMax = (float)Math.Floor(item.maxCondition * (1f - maxLossFraction * single));

                UpdatePanels(player, tempMax, tempMax, false);
            }
        }

        #endregion hooks

        #region functions
        #region general
        void RemoveOldData()
        {
            if (lastCleanUp >= DateTime.Today)
                return;

            if (config.OffDays <= 0)
                return;

            List<ulong> ToDelete = new List<ulong>();

            for (int i = 0; i < playerData.Count; i++)
            {
                if ((DateTime.Today - playerData.ElementAt(i).Value.LastOnline).TotalDays > config.OffDays)
                {
                    ToDelete.Add(playerData.ElementAt(i).Key);
                }
            }

            if (ToDelete.Count > 0)
            {
                for (int i = 0; i < ToDelete.Count; i++)
                    playerData.Remove(ToDelete[i]);

            }

            SaveData(); //catch save of new player data lastonline

            lastCleanUp = DateTime.Today;
        }

        void InitPlayer(ulong userID, bool reset)
        {
            if (reset)
            {
                playerData.Remove(userID);
                SaveData();
                return;
            }

            PlayerData data = new PlayerData();
            data.Enabled = true;
            data.ShowInfo = config.ShowInfo;

            data.ColorRanges.Add(0, config.LowerRange);
            data.ColorRanges.Add(config.MiddleRange.StartValue, new SimpleRangeData(config.MiddleRange.BarColorValue, config.MiddleRange.FontColorValue));
            data.ColorRanges.Add(config.HigherRange.StartValue, new SimpleRangeData(config.HigherRange.BarColorValue, config.HigherRange.FontColorValue));

            if (config.Alert1 > 0)
                data.Alerts.Add(config.Alert1);

            playerData[userID] = data;
            SaveData();
        }

        void HideOxygen(BasePlayer player)
        {
            if (!playerData.ContainsKey(player.userID))
                InitPlayer(player.userID, false);

            playerData[player.userID].Enabled = false;
            playerData[player.userID].LastChange = DateTime.Today;
            SaveData();

            DestroyUI(player, true);
        }

        void ShowOxygen(BasePlayer player)
        {
            PlayerData info;
            if (!playerData.TryGetValue(player.userID, out info))
            {
                InitPlayer(player.userID, false);
            }
            else
            {
                info.Enabled = true;
                playerData[player.userID].LastChange = DateTime.Today;
                SaveData();

                Item item;
                if (IsWearingGoggles(player, out item))
                    UpdatePanels(player, item.condition, item.maxCondition, true);
            }
        }
        #endregion general

        #region alerts
        string GetAlerts(ulong userID)
        {
            string alerts = string.Empty;

            if (playerData.ContainsKey(userID))
            {
                if (playerData[userID].Alerts.Count > 0)
                {
                    playerData[userID].Alerts.Sort();
                    foreach (var alert in playerData[userID].Alerts)
                    {
                        if (alerts.Length > 0)
                            alerts = alerts + ", " + alert.ToString();
                        else
                            alerts = alert.ToString();
                    }
                }

                if (alerts.Length == 0)
                {
                    alerts = Lang("NoAlerts", userID.ToString());
                }
            }
            else
            {
                alerts = Lang("NoAlerts", userID.ToString()) + '\n' + GetDefaultAlerts();
            }

            return alerts;
        }

        string GetDefaultAlerts()
        {
            string alerts = string.Empty;

            if (config.Alert1 > 0)
                alerts = (alerts + ", " + config.Alert1.ToString()).TrimStart(' ', ',');

            if (alerts.Length > 0)
                return (Lang("ServerDefaults") + ": " + alerts);
            else
                return (Lang("ServerDefaults") + ": " + Lang("NoServerAlerts"));
        }

        string AddAlert(ulong userID, string args)
        {
            string result = String.Empty;

            bool continuous = args.Substring(args.Length - 1) == "*";

            if (continuous)
            {
                args = args.Remove(args.Length - 1);
            }

            uint condition;
            if (uint.TryParse(args, out condition))
            {
                if (!playerData.ContainsKey(userID))
                    InitPlayer(userID, false);

                if (!playerData[userID].Alerts.Contains(condition))
                {
                    if ((playerData[userID].Alerts.Count < config.MaxAlerts) || (config.MaxAlerts == 0))
                    {
                        playerData[userID].LastChange = DateTime.Today;
                        SaveData();
                        result = "AlertAdded";
                    }
                    else
                    {
                        result = "MaxAlerts";
                    }
                }
                else
                {
                    playerData[userID].LastChange = DateTime.Today;
                    SaveData();
                    result = "AlertUpdated";
                }
            }
            else
            {
                result = "InvalidAlert";
            }

            return (result);
        }

        string RemoveAlert(ulong userID, string args)
        {
            string result = string.Empty;
            uint condition;

            if (uint.TryParse(args, out condition))
            {
                if (playerData[userID].Alerts.Remove(condition))
                {
                    playerData[userID].LastChange = DateTime.Today;
                    SaveData();
                    result = "AlertRemoved";
                }
                else
                {
                    result = "AlertDoesNotExists";
                }
            }
            else
            {
                result = "InvalidAlert";
            };

            return result;
        }

        bool MustDoEffect(float condition, ulong userID)
        {
            uint alert = 0;

            if (playerData.ContainsKey(userID))
            {
                alert = playerData[userID].Alerts.Where(x => x >= condition).OrderBy(x => x).FirstOrDefault();

                if (alert > 0)
                {
                    return (condition == alert);
                }
                else
                {
                    return false;
                }
            }
            else
            {
                return (config.Alert1 > 0) && (condition == config.Alert1);
            }

        }
        #endregion alerts

        #region ranges
        string GetRanges(ulong userID)
        {
            string ranges = string.Empty;

            if (playerData.ContainsKey(userID))
            {
                if (playerData[userID].ColorRanges.Count > 0)
                {
                    foreach (var range in playerData[userID].ColorRanges.OrderBy(x => x.Key))
                    {
                        if (ranges.Length > 0)
                            ranges = ranges + "\n" + range.Key.ToString() + " B: " + range.Value.BarColorValue + " F: " + range.Value.FontColorValue;
                        else
                            ranges = range.Key.ToString() + " B: " + range.Value.BarColorValue + " F: " + range.Value.FontColorValue;
                    }
                }
            }

            if (ranges.Length == 0)
            {
                ranges = Lang("NoRanges", userID.ToString()) + '\n' + Lang("ServerDefaults") + ": " + '\n' + GetDefaultRanges();
            }


            return ranges;
        }

        string GetDefaultRanges()
        {
            return ("0 " + "B: " + config.LowerRange.BarColorValue + " F: " + config.LowerRange.FontColorValue +
                '\n' + config.MiddleRange.StartValue.ToString() + " B: " + config.MiddleRange.BarColorValue + " F: " + config.LowerRange.FontColorValue +
                '\n' + config.HigherRange.StartValue.ToString() + " B: " + config.HigherRange.BarColorValue + " F: " + config.HigherRange.FontColorValue);
        }

        string AddRange(ulong userID, string[] args, out bool doUpdate)
        {
            string result = string.Empty;
            string barRGB = string.Empty;
            string fontRGB = string.Empty;
            uint startCond = 0;
            doUpdate = false;

            if (IsValidColor(args[1], out barRGB))
            {
                if (IsValidColor(args[2], out fontRGB))
                {
                    if (uint.TryParse(args[0], out startCond))
                    {
                        if (!playerData.ContainsKey(userID))
                            InitPlayer(userID, false);

                        SimpleRangeData range;
                        if (!playerData[userID].ColorRanges.TryGetValue(startCond, out range))
                        {
                            playerData[userID].ColorRanges.Add(startCond, new SimpleRangeData(args[1], args[2]));
                            playerData[userID].LastChange = DateTime.Today;
                            SaveData();
                            result = "RangeAdded";
                        }
                        else
                        {
                            playerData[userID].ColorRanges[startCond].BarColorValue = args[1];
                            playerData[userID].ColorRanges[startCond].FontColorValue = args[2];
                            playerData[userID].LastChange = DateTime.Today;
                            SaveData();
                            result = "RangeUpdated";
                        }
                        doUpdate = true;
                    }
                    else
                        result = "InvalidNumberValue";
                }
                else
                    result = "InvalidColor";
            }
            else
                result = "InvalidColor";

            return result;
        }

        string RemoveRange(ulong userID, string args, out bool doUpdate)
        {
            string result = string.Empty;
            uint condition;
            doUpdate = false;

            if (uint.TryParse(args, out condition))
            {
                if (playerData[userID].ColorRanges.Remove(condition))
                {
                    playerData[userID].LastChange = DateTime.Today;
                    SaveData();
                    result = "RangeRemoved";
                    doUpdate = true;
                }
                else
                {
                    result = "RangeDoesNotExists";
                }
            }
            else
            {
                result = "InvalidNumberValue";
            };

            return result;
        }

        void GetRGBValues(ulong userID, uint condition, out string barRGB, out string fontRGB)
        {
            barRGB = string.Empty;
            fontRGB = string.Empty;

            bool getFromconfig = true;
            uint startCond = 0;
            SimpleRangeData range;

            if (playerData.ContainsKey(userID))
            {
                startCond = playerData[userID].ColorRanges.Where(x => x.Key <= condition).OrderBy(x => x.Key).LastOrDefault().Key;

                if (playerData[userID].ColorRanges.TryGetValue(startCond, out range))
                {
                    barRGB = range.BarColorValue;
                    fontRGB = range.FontColorValue;
                    getFromconfig = false;
                }
            }

            if (getFromconfig)
            {
                if (condition < config.MiddleRange.StartValue)
                {
                    barRGB = config.LowerRange.BarColorValue;
                    fontRGB = config.LowerRange.FontColorValue;
                }
                else if ((condition >= config.MiddleRange.StartValue) && (condition < config.HigherRange.StartValue))
                {
                    barRGB = config.MiddleRange.BarColorValue;
                    fontRGB = config.MiddleRange.FontColorValue;
                }
                else
                {
                    barRGB = config.HigherRange.BarColorValue;
                    fontRGB = config.HigherRange.FontColorValue;
                }
            }

            if (barRGB[0] != '#')
                barRGB = ColorToRGB(barRGB);
            if (fontRGB[0] != '#')
                fontRGB = ColorToRGB(fontRGB);
        }
        #endregion ranges

        #region UI
        void ChangeView(ulong userID, string show, out bool doUpdate)
        {
            doUpdate = false;

            if (!playerData.ContainsKey(userID))
                InitPlayer(userID, false);

            if (playerData[userID].ShowInfo != show)
            {
                playerData[userID].ShowInfo = show;
                playerData[userID].LastChange = DateTime.Today;
                SaveData();
                doUpdate = true;
            }
        }

        bool ShouldHandleUI(ItemContainer cont, Item item)
        {
            if (!item.info.shortname.Equals(gogglesShortName))
                return false;

            if (cont.playerOwner == null)
                return false;

            if (!cont.playerOwner.IsAlive())
                return false;

            if (!PlayerSignedUp(cont.playerOwner))
                return false;

            if (IsWearablesContainer(cont))
                return true;

            return false;
        }

        void UpdatePanels(BasePlayer player, float condition, float maxCondition, bool doPicture)
        {
            if (!permission.UserHasPermission(player.UserIDString, usePermission))
                return;

            string barColor;
            string fontColor;
            string valueText;
            string barText;

            if (condition < 0)
                condition = 0;

            GetRGBValues(player.userID, (uint)Math.Floor(condition), out barColor, out fontColor);

            double lifepct = condition / maxCondition * 1000;

            if (MustDoEffect(condition, player.userID))
                Effect.server.Run(inviteNoticeMsg, player.transform.position, Vector3.zero, null, false);

            int counter = 0;
            int numberofchars = (int)Math.Round(lifepct);

            counter = Convert.ToInt32(config.Position.XAxis * 10000);

            if (condition != 0)
                counter = counter + numberofchars;

            if (MustShowValue(player.userID))
                counter = counter + 150;

            if (config.ShowPicture)
                counter = counter + 120;

            barText = "0." + counter.ToString("".PadLeft(4, '0')) + " " + (config.Position.YAxis + 0.023f).ToString();
            valueText = ((int)Math.Round(condition, 0)).ToString();

            DestroyUI(player, doPicture);
            DrawUI(player, ColorFromHex(barColor, 228), valueText, barText, ColorFromHex(fontColor, 255), doPicture);
        }

        void DestroyUI(BasePlayer player, bool updatePicture)
        {
            if (player == null)
                return;

            CuiHelper.DestroyUi(player, "cnvPanel");
            CuiHelper.DestroyUi(player, "cnvBar");

            if (updatePicture)
                CuiHelper.DestroyUi(player, "cnvPicture");
        }

        void DrawUI(BasePlayer player, string color, string valueText, string barText, string fontColor, bool updatePicture)
        {
            CuiHelper.AddUi(player, Generate_Menu(player, color, valueText, barText, fontColor, updatePicture));
        }

        private bool MustShowBar(ulong userID)
        {
            if (playerData.ContainsKey(userID))
                return (playerData[userID].ShowInfo.ToLower() == ShowValues.All.ToString().ToLower()) || (playerData[userID].ShowInfo.ToLower() == ShowValues.Bar.ToString().ToLower());
            else
                return (config.ShowInfo.ToLower() == ShowValues.All.ToString().ToLower()) || (config.ShowInfo.ToLower() == ShowValues.Bar.ToString().ToLower());
        }

        private bool MustShowValue(ulong userID)
        {
            if (playerData.ContainsKey(userID))
                return (playerData[userID].ShowInfo.ToLower() == ShowValues.All.ToString().ToLower()) || (playerData[userID].ShowInfo.ToLower() == ShowValues.Value.ToString().ToLower());
            else
                return (config.ShowInfo.ToLower() == ShowValues.All.ToString().ToLower()) || (config.ShowInfo.ToLower() == ShowValues.Value.ToString().ToLower());
        }

        private string GetAnchorMax(ulong userID)
        {
            float X = config.Position.XAxis;
            if (config.ShowPicture)
                X = X + pictureOffset;

            float Y = config.Position.YAxis;

            if (MustShowBar(userID))
                X = X + 0.116f;
            else
                X = X + 0.013f;

            if (!MustShowValue(userID))
                X = X - 0.015f;

            Y = Y + 0.025f;

            return X.ToString() + " " + Y.ToString();
        }

        CuiElementContainer Generate_Menu(BasePlayer player, string barColor, string valueText, string barText, string fontColor, bool updatePicture)
        {
            var elements = new CuiElementContainer();

            string contMin = config.Position.XAxis.ToString() + " " + config.Position.YAxis.ToString();
            if (config.ShowPicture)
                contMin = (config.Position.XAxis + pictureOffset).ToString() + " " + config.Position.YAxis.ToString();

            var panel = elements.Add(new CuiPanel
            {
                Image = {
                    Color = "0.60 0.60 0.60 0.27"
                },

                RectTransform = {
                    AnchorMin = contMin,
                    AnchorMax = GetAnchorMax(player.userID)
                },

                CursorEnabled = false
            }, "Hud", "cnvPanel");

            if (updatePicture)
            {
                if (config.ShowPicture)
                {
                    var logo = new CuiElementContainer();
                    logo.Add(new CuiElement
                    {
                        Name = "cnvPicture",
                        Components =
                    {
                        new CuiRawImageComponent
                        {
                            Color = "1 1 1 1",
                            Url = (config.PictureURL != "") ? config.PictureURL : "https://cdn.discordapp.com/attachments/504359168312868874/808374016821166151/toinvert.png"
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = config.Position.XAxis.ToString() + " " + (config.Position.YAxis + 0.002f).ToString(),
                            AnchorMax = (config.Position.XAxis + 0.010f).ToString() + " " + (config.Position.YAxis + 0.025f).ToString()
                        }
                    }
                    });

                    CuiHelper.AddUi(player, logo);
                }
            }

            if (MustShowValue(player.userID))
            {
                var message01 = elements.Add(new CuiLabel
                {
                    Text =
                    {
                    Text = valueText,
                    Color = fontColor,
                    FontSize = 12,
                    Align = TextAnchor.MiddleLeft
                    },

                    RectTransform = {
                    AnchorMin = "0.02 0",
                    AnchorMax = "0.8 1"
                    },
                }, panel);
            }

            if ((MustShowBar(player.userID)) && (valueText != "0"))
            {
                float anchorMin = config.Position.XAxis;
                if (config.ShowPicture)
                    anchorMin = anchorMin + pictureOffset;

                if (MustShowValue(player.userID))
                    anchorMin = anchorMin + 0.015f;

                var panel2 = elements.Add(new CuiPanel
                {
                    Image = {
                    Color = barColor
                },

                    RectTransform = {
                    AnchorMin = anchorMin.ToString() + " " + (config.Position.YAxis + 0.002f).ToString(),
                    AnchorMax = barText
                },

                    CursorEnabled = false
                }, "Hud", "cnvBar");
            }

            return elements;
        }
        #endregion UI

        void LoadData()
        {
            try
            {
                playerData = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, PlayerData>>(Name);
            }
            catch
            {
                playerData = new Dictionary<ulong, PlayerData>();
            }
        }

        void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, playerData);

        protected override void SaveConfig() => Config.WriteObject(config);
        #endregion functions    

        #region helpers
        private static string ColorFromHex(string hexColor, int alpha)
        {
            hexColor = hexColor.TrimStart('#');
            if (hexColor.Length != 6 && hexColor.Length != 8)
            {
                hexColor = "000000";
            }
            int red = int.Parse(hexColor.Substring(0, 2), NumberStyles.AllowHexSpecifier);
            int green = int.Parse(hexColor.Substring(2, 2), NumberStyles.AllowHexSpecifier);
            int blue = int.Parse(hexColor.Substring(4, 2), NumberStyles.AllowHexSpecifier);

            if (hexColor.Length == 8)
            {
                alpha = int.Parse(hexColor.Substring(6, 2), NumberStyles.AllowHexSpecifier);
            }

            return $"{red / 255.0} {green / 255.0} {blue / 255.0} {alpha / 255.0}";
        }

        private string Lang(string key, string userId = null, params object[] args) => string.Format(lang.GetMessage(key, this, userId), args);

        private bool IsWearablesContainer(ItemContainer cont)
        {
            return (cont.HasFlag(ItemContainer.Flag.Clothing) && (cont.HasFlag(ItemContainer.Flag.IsPlayer)));
        }

        private bool IsWearingGoggles(BasePlayer player, out Item item)
        {
            foreach (Item contItem in player.inventory.containerWear.itemList)
            {
                if (contItem.info.shortname.Equals(gogglesShortName))
                {
                    item = contItem;
                    return true;
                }
            }

            item = null;
            return false;
        }

        private bool PlayerSignedUp(BasePlayer player)
        {
            PlayerData info;
            if (playerData.TryGetValue(player.userID, out info))
                return info.Enabled;
            else
                return true;
        }

        private bool IsValidColor(string value, out string RGB)
        {
            RGB = string.Empty;

            if (value[0] == '#')
            {
                if (IsValidRGBValue(value))
                {
                    RGB = value;
                    return true;
                }
                else
                    return false;
            }
            else
            {
                if (Enum.IsDefined(typeof(AllColors), value))
                {
                    RGB = ColorToRGB(value);
                    return true;
                }
                else
                    return false;

            }
        }

        private bool IsValidRGBValue(string value)
        {
            if (value.Length <= 7)
                return Regex.IsMatch(value, "^#([A-Fa-f0-9]{6})$");
            else
                return Regex.IsMatch(value, "^#([A-Fa-f0-9]{8})$");
        }

        void ShowCommandHelp(BasePlayer player)
        {
            player.ChatMessage(Lang("HelpInfo", player.UserIDString) + "\n\n" + Lang("HelpView", player.userID.ToString()) + "\n" + Lang("HelpShow", player.userID.ToString()) +
                "\n\n" + Lang("HelpAlertAdd", player.userID.ToString()) + "\n" + Lang("HelpRangeAdd", player.userID.ToString()) + "\n" + Lang("HelpDelete", player.userID.ToString()) +
                "\n\n" + Lang("HelpView", player.userID.ToString()) + "\n\n" + Lang("HelpColor", player.userID.ToString()));
        }

        string ColorList()
        {
            string colors = string.Empty;
            foreach (string value in Enum.GetNames(typeof(AllColors)))
            {
                colors = colors + ", " + value;
            }

            colors = colors.TrimStart(',', ' ');
            return (colors);
        }

        string ColorToRGB(string namedColor)
        {
            System.Drawing.Color color = System.Drawing.Color.FromName(namedColor);
            return ("#" + color.R.ToString("X2") + color.G.ToString("X2") + color.B.ToString("X2"));
        }

        #endregion helpers
    }
}

// --- End of file: ChillNightVision.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/coin-flip ---
// --- Original File Path: C/CoinFlip/CoinFlip.cs ---

ï»¿// Requires: Economics
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("Coin Flip", "Gachl", "1.0.7")]
    [Description("Try your luck by challenging players to a coin flip and betting on it using Economics")]
    class CoinFlip : CovalencePlugin
    {
        #region Internal structures
        /// <summary>
        /// Store information about a coin flip
        /// </summary>
        private struct CoinFlipParams
        {
            /// <summary>
            /// Amount of the bet
            /// </summary>
            internal int Amount;

            /// <summary>
            /// If set, the coin flip is private, and the target is the opponent that was asked to join. Otherwise null.
            /// </summary>
            internal IPlayer Target;

            /// <summary>
            /// The timer that will cancel the coin flip after the configured timeout
            /// </summary>
            internal Timer Timer;
        }

        /// <summary>
        /// Message enumeration for localisation
        /// </summary>
        private enum Messages
        {
            FLIP_USAGE,
            DUPLICATE_PLAYERS,
            AMBIGUOUS_PLAYERS,
            NO_PLAYERS,
            ALREADY_FLIPPING,
            COINFLIP_INITIATED,
            PRIVATE_COINFLIP_INITIATED,
            AMOUNT_TOO_LOW,
            BALANCE_TOO_LOW,
            COINFLIP_READY,
            PRIVATE_COINFLIP_READY,
            COINFLIP_CANCELED,
            PRIVATE_COINFLIP_CANCELED,
            NO_FLIPS,
            JOIN_USAGE,
            NOT_FLIPPING,
            FLIP_JOINED,
            FLIP_JOIN,
            COUNT_THREE,
            COUNT_TWO,
            COUNT_ONE,
            FLIP,
            COIN_LAND,
            WIN,
            LOSS,
            LEFT,
            YOURSELF,
            PRIVATE,
            WIN_ALL,
            JOIN_ALL,
            CANT_PARTICIPATE
        }
        #endregion

        #region Static and global data
        // Random Number Generator
        private static Random RNG = new Random();

        // Configuration keys
        private const string CONFIG_MINIMUM_AMOUNT = "MinimumAmount";
        private const string CONFIG_TIMEOUT = "Timeout";
        private const string CONFIG_ANNOUNCE_EVERYBODY = "AnnounceEverybody";
        private const string CONFIG_PREFIX = "Prefix";

        // Permissions
        private const string PERMISSION_CREATE = "coinflip.create";
        private const string PERMISSION_JOIN = "coinflip.join";
        #endregion

        #region Data
        // Configuration values
        private int MinimumAmount => (int)Config[CoinFlip.CONFIG_MINIMUM_AMOUNT];
        private int Timeout => (int)Config[CoinFlip.CONFIG_TIMEOUT];
        private bool AnnounceEverybody => (bool)Config[CoinFlip.CONFIG_ANNOUNCE_EVERYBODY];
        private string Prefix => (string)Config[CoinFlip.CONFIG_PREFIX];

        // Economics reference
        [PluginReference]
        private Plugin Economics;

        // All active and unjoined coin flips
        private Dictionary<string, CoinFlipParams> coinFlips = new Dictionary<string, CoinFlipParams>();
        #endregion

        #region Plugin control
        protected override void LoadDefaultMessages()
        {
            // Register all default messages

            // English
            this.lang.RegisterMessages(new Dictionary<string, string> {
                { Enum.GetName(typeof(Messages), Messages.FLIP_USAGE), $"Usage:{Environment.NewLine}/coinflip Amount{Environment.NewLine}/coinflip Amount PlayerNameOrId" },
                { Enum.GetName(typeof(Messages), Messages.DUPLICATE_PLAYERS), "The name {0} exactly matches {1} players, please use a steamid to identify the player." },
                { Enum.GetName(typeof(Messages), Messages.AMBIGUOUS_PLAYERS), $"The name {{0}} matches {{1}} players, please be more specific:{Environment.NewLine}{{2}}" },
                { Enum.GetName(typeof(Messages), Messages.NO_PLAYERS), "The name {0} matches no players." },
                { Enum.GetName(typeof(Messages), Messages.COINFLIP_INITIATED), "Player {0} has started a coin flip for {1}, type /joinflip {0} to join." },
                { Enum.GetName(typeof(Messages), Messages.PRIVATE_COINFLIP_INITIATED), "Player {0} requested a coin flip with you for {1}, type /joinflip {0} to join." },
                { Enum.GetName(typeof(Messages), Messages.AMOUNT_TOO_LOW), "The minimum amount for a coin flip is {0}." },
                { Enum.GetName(typeof(Messages), Messages.BALANCE_TOO_LOW), "Your balance of {0} is not sufficient for a coin flip for {1}" },
                { Enum.GetName(typeof(Messages), Messages.COINFLIP_READY), "You paid {0} for a coin flip. If nobody joins within {1} minute(s) it will automatically be canceled." },
                { Enum.GetName(typeof(Messages), Messages.PRIVATE_COINFLIP_READY), "You paid {0} for a coin flip with {2}. It will automatically be canceled in {1} minute(s)." },
                { Enum.GetName(typeof(Messages), Messages.COINFLIP_CANCELED), "Your coin flip was canceled and {0} has been refunded." },
                { Enum.GetName(typeof(Messages), Messages.PRIVATE_COINFLIP_CANCELED), "Your coin flip with {1} was canceled and {0} has been refunded." },
                { Enum.GetName(typeof(Messages), Messages.NO_FLIPS), "You have no active coin flips." },
                { Enum.GetName(typeof(Messages), Messages.ALREADY_FLIPPING), "You already have an active coin flip. Use /cancelflip to cancel it." },
                { Enum.GetName(typeof(Messages), Messages.JOIN_USAGE), $"Usage:{Environment.NewLine}/joinflip PlayerNameOrId" },
                { Enum.GetName(typeof(Messages), Messages.NOT_FLIPPING), "There is no coin flip from player {0}." },
                { Enum.GetName(typeof(Messages), Messages.FLIP_JOINED), "Player {0} has joined your coin flip. Prepare to flip!" },
                { Enum.GetName(typeof(Messages), Messages.FLIP_JOIN), "You paid {1} to join the coin flip of player {0}. Prepare to flip!" },
                { Enum.GetName(typeof(Messages), Messages.COUNT_THREE), "3..." },
                { Enum.GetName(typeof(Messages), Messages.COUNT_TWO), "2..." },
                { Enum.GetName(typeof(Messages), Messages.COUNT_ONE), "1..." },
                { Enum.GetName(typeof(Messages), Messages.FLIP), "The coin is in the air!" },
                { Enum.GetName(typeof(Messages), Messages.COIN_LAND), "The coin has landed on the side of {0}." },
                { Enum.GetName(typeof(Messages), Messages.WIN), "Congratulations! You have won {0}!" },
                { Enum.GetName(typeof(Messages), Messages.LOSS), "Too bad! You have lost {0}." },
                { Enum.GetName(typeof(Messages), Messages.LEFT), "Your opponent has forfeited, {0} has been refunded." },
                { Enum.GetName(typeof(Messages), Messages.YOURSELF), "You can not have a coin flip against yourself." },
                { Enum.GetName(typeof(Messages), Messages.PRIVATE), "You can not join this coin flip because it's private." },
                { Enum.GetName(typeof(Messages), Messages.WIN_ALL), "Player {0} has just won {2} in a coin flip against player {1}." },
                { Enum.GetName(typeof(Messages), Messages.JOIN_ALL), "Players {0} and {1} will flip a coin for {2}." },
                { Enum.GetName(typeof(Messages), Messages.CANT_PARTICIPATE), "Player {0} can not participate in coin flips." }
            }, this, "en");

            // German
            this.lang.RegisterMessages(new Dictionary<string, string> {
                { Enum.GetName(typeof(Messages), Messages.FLIP_USAGE), $"Verwendung:{Environment.NewLine}/coinflip Betrag{Environment.NewLine}/coinflip Betrag SpielerNameOderId" },
                { Enum.GetName(typeof(Messages), Messages.DUPLICATE_PLAYERS), "Der Name {0} trifft auf {1} Spieler exakt zu, bitte verwende die steamid um den Spieler zu identifizieren." },
                { Enum.GetName(typeof(Messages), Messages.AMBIGUOUS_PLAYERS), $"Der Name {{0}} trifft auf {{1}} Spieler zu, bitte gebe den Namen prÃ¤ziser an:{Environment.NewLine}{{2}}" },
                { Enum.GetName(typeof(Messages), Messages.NO_PLAYERS), "Der Name {0} trifft auf keinen Spieler zu." },
                { Enum.GetName(typeof(Messages), Messages.COINFLIP_INITIATED), "Spieler {0} hat einen MÃ¼nzwurf fÃ¼r {1} begonnen, gebe /joinflip {0} ein um beizutreten." },
                { Enum.GetName(typeof(Messages), Messages.PRIVATE_COINFLIP_INITIATED), "Spieler {0} mÃ¶chte mit dir einen MÃ¼nzwurf fÃ¼r {1} machen, gebe /joinflip {0} ein um beizutreten." },
                { Enum.GetName(typeof(Messages), Messages.AMOUNT_TOO_LOW), "Der minimale Einsatz fÃ¼r einen MÃ¼nzwurf betrÃ¤gt {0}." },
                { Enum.GetName(typeof(Messages), Messages.BALANCE_TOO_LOW), "Dein Kontostand von {0} ist nicht ausreichend fÃ¼r einen MÃ¼nzwurf fÃ¼r {1}" },
                { Enum.GetName(typeof(Messages), Messages.COINFLIP_READY), "Du hast {0} fÃ¼r einen MÃ¼nzwurf bezahlt. Wenn niemand innerhalb von {1} Minute(n) beitritt wird er automatisch storniert." },
                { Enum.GetName(typeof(Messages), Messages.PRIVATE_COINFLIP_READY), "Du hast {0} fÃ¼r einen MÃ¼nzwurf gegen {2} gezahlt. Er wird automatisch in {1} Minute(n) storniert." },
                { Enum.GetName(typeof(Messages), Messages.COINFLIP_CANCELED), "Dein MÃ¼nzwurf wurde storniert und {0} zurÃ¼ckgezahlt." },
                { Enum.GetName(typeof(Messages), Messages.PRIVATE_COINFLIP_CANCELED), "Dein MÃ¼nzwurf gegen {1} wurde storniert und {0} zurÃ¼ckgezahlt." },
                { Enum.GetName(typeof(Messages), Messages.NO_FLIPS), "Du hast keinen aktiven MÃ¼nzwurf." },
                { Enum.GetName(typeof(Messages), Messages.ALREADY_FLIPPING), "Du hast bereits einen aktiven MÃ¼nzwurf. Verwende /cancelflip um ihn zu stornieren." },
                { Enum.GetName(typeof(Messages), Messages.JOIN_USAGE), $"Verwendung:{Environment.NewLine}/joinflip SpielerNameOderId" },
                { Enum.GetName(typeof(Messages), Messages.NOT_FLIPPING), "Der Spieler {0} hat keinen MÃ¼nzwurf." },
                { Enum.GetName(typeof(Messages), Messages.FLIP_JOINED), "Spieler {0} ist einem MÃ¼nzwurf beigetreten. Bereit machen zum Wurf!" },
                { Enum.GetName(typeof(Messages), Messages.FLIP_JOIN), "Du hast {1} bezahlt um dem MÃ¼nzwurf gegen Spieler {0} beizutreten. Bereit machen zum Wurf!" },
                { Enum.GetName(typeof(Messages), Messages.COUNT_THREE), "3..." },
                { Enum.GetName(typeof(Messages), Messages.COUNT_TWO), "2..." },
                { Enum.GetName(typeof(Messages), Messages.COUNT_ONE), "1..." },
                { Enum.GetName(typeof(Messages), Messages.FLIP), "Die MÃ¼nze ist in der Luft!" },
                { Enum.GetName(typeof(Messages), Messages.COIN_LAND), "Die MÃ¼nze ist auf der Seite von {0} gelandet." },
                { Enum.GetName(typeof(Messages), Messages.WIN), "GlÃ¼ckwunsch! Du hast {0} gewonnen!" },
                { Enum.GetName(typeof(Messages), Messages.LOSS), "Schade! Du hast {0} verloren." },
                { Enum.GetName(typeof(Messages), Messages.LEFT), "Dein Gegner hat aufgegeben, {0} wurde zurÃ¼ckgezahlt." },
                { Enum.GetName(typeof(Messages), Messages.YOURSELF), "Du kannst keinen MÃ¼nzwurf gegen dich selbst spielen." },
                { Enum.GetName(typeof(Messages), Messages.PRIVATE), "Du kannst diesem MÃ¼nzwurf nicht beitreten da er Privat ist." },
                { Enum.GetName(typeof(Messages), Messages.WIN_ALL), "Spieler {0} hat gerade {2} in einem MÃ¼nzwurf gegen Spieler {1} gewonnen." },
                { Enum.GetName(typeof(Messages), Messages.JOIN_ALL), "Die Spieler {0} und {1} werfen eine MÃ¼nze fÃ¼r {2}." },
                { Enum.GetName(typeof(Messages), Messages.CANT_PARTICIPATE), "Spieler {0} kann nicht an MÃ¼nzwÃ¼rfen teilnehmen." }
            }, this, "de");
        }

        protected override void LoadDefaultConfig()
        {
            // Setup default values for configuration
            Config[CoinFlip.CONFIG_MINIMUM_AMOUNT] = 0;
            Config[CoinFlip.CONFIG_TIMEOUT] = 5;
            Config[CoinFlip.CONFIG_ANNOUNCE_EVERYBODY] = true;
            Config[CoinFlip.CONFIG_PREFIX] = "[Coin Flip]";
        }

        private void Unload()
        {
            // Refund all active coin flips to prevent loss of balance when un- or reloading the plugin
            this.coinFlips.Keys.ToList().ForEach(k => this.cancelCoinFlip(k));
        }
        #endregion

        #region Tool methods
        /// <summary>
        /// Send a localised chat message to a player
        /// </summary>
        /// <param name="player">Target player to receive the message</param>
        /// <param name="message">The localised message to be sent</param>
        /// <param name="args">Additional information of this message</param>
        private void sendLocalisedMessage(IPlayer player, Messages message, params object[] args)
        {
            // Argument validation
            if (player == null)
                throw new ArgumentNullException("player");

            // Get the string representation of the messsage key
            string messageKey = Enum.GetName(typeof(Messages), message);
            
            // Send the localised message to the player
            player.Reply(this.lang.GetMessage(messageKey, this, player.Id), this.Prefix, args);
        }

        /// <summary>
        /// Send a localised chat message to a player if a condition is true
        /// </summary>
        /// <param name="player">Target player to receive the message</param>
        /// <param name="condition">The condition that has to be true if the message should be sent</param>
        /// <param name="message">The localised message to be sent</param>
        /// <param name="args">Additional information of this message</param>
        /// <returns>The value of the condition</returns>
        private bool sendConditionalLocalisedMessage(IPlayer player, bool condition, Messages message, params object[] args)
        {
            // Argument validation
            if (player == null)
                throw new ArgumentNullException("player");

            if (condition)
                this.sendLocalisedMessage(player, message, args);
            
            return condition;
        }

        /// <summary>
        /// Find a player by name or id. Use id match, then exact match, then case insensitive match, then partial match to find a player.
        /// </summary>
        /// <param name="requester">Player who receives messages if matching was unsuccessful</param>
        /// <param name="targetPlayerNameOrId">Search string to use for finding the player</param>
        /// <returns>The player if found, otherwise null</returns>
        private IPlayer findPlayer(IPlayer requester, string targetPlayerNameOrId)
        {
            // Argument validation
            if (requester == null)
                throw new ArgumentNullException("requester");

            // Refuse empty search strings
            if (string.IsNullOrEmpty(targetPlayerNameOrId))
                throw new ArgumentNullException("targetPlayerNameOrId");

            // Get active player list and store as array to dereference the unterlying IEnumerable
            // and prevent changes to occur while this method is running.
            IPlayer[] connectedPlayers = this.covalence.Players.Connected.ToArray();

            // Try an id match
            IPlayer[] matches = connectedPlayers.Where(p => p.Id == targetPlayerNameOrId).ToArray();
            if (matches.Length == 1)
                return matches[0];

            // Try an exact match
            matches = connectedPlayers.Where(p => p.Name == targetPlayerNameOrId).ToArray();
            if (matches.Length == 1)
                return matches[0];
            // This probably happens very rarely but if there are two players with *exactly* the same name force use of steam ID instead of name
            else if (this.sendConditionalLocalisedMessage(requester, matches.Length > 1, Messages.DUPLICATE_PLAYERS, targetPlayerNameOrId, matches.Length))
                return null;

            // Try a case insensitive match
            matches = connectedPlayers.Where(p => p.Name.ToLower() == targetPlayerNameOrId.ToLower()).ToArray();
            if (matches.Length == 1)
                return matches[0];
            else if (this.sendConditionalLocalisedMessage(requester, matches.Length > 1, Messages.AMBIGUOUS_PLAYERS, targetPlayerNameOrId, matches.Length, string.Join(Environment.NewLine, matches.Select(p => p.Name).ToArray())))
                return null;

            // Try a partial match
            matches = connectedPlayers.Where(p => p.Name.ToLower().Contains(targetPlayerNameOrId.ToLower())).ToArray();
            if (matches.Length == 1)
                return matches[0];
            else if (this.sendConditionalLocalisedMessage(requester, matches.Length > 1, Messages.AMBIGUOUS_PLAYERS, targetPlayerNameOrId, matches.Length, string.Join(Environment.NewLine, matches.Select(p => p.Name).ToArray())))
                return null;

            // No matches have returned results
            this.sendLocalisedMessage(requester, Messages.NO_PLAYERS, targetPlayerNameOrId);
            return null;
        }
        #endregion

        #region Commands
        [Command("coinflip"), Permission(CoinFlip.PERMISSION_CREATE)]
        private void coinFlipChatCommand(IPlayer player, string command, string[] args)
        {
            // Validate caller is a player that can interact with Economy
            if (player.IsServer)
            {
                player.Reply("This command can not be used from RCON.");
                return;
            }

            // Validate argument count
            if (this.sendConditionalLocalisedMessage(player, args.Length == 0, Messages.FLIP_USAGE))
                return;

            // Parse bet amount from argument
            int amount = 0;
            if (this.sendConditionalLocalisedMessage(player, !int.TryParse(args[0], out amount), Messages.FLIP_USAGE))
                return;

            // Limit bet amount to configured minimum value
            if (this.sendConditionalLocalisedMessage(player, amount < this.MinimumAmount || amount < 0, Messages.AMOUNT_TOO_LOW, this.MinimumAmount))
                return;

            // If a target player was supplied, try to find it
            string targetPlayerName = String.Join(" ", args.Skip(1).ToArray());
            IPlayer targetPlayer = null;
            if (!string.IsNullOrEmpty(targetPlayerName))
            {
                targetPlayer = this.findPlayer(player, targetPlayerName);

                if (targetPlayer == null)
                    return;
            }

            // Prevent targeting yourself as private coin flip opponent
            if (this.sendConditionalLocalisedMessage(player, targetPlayer != null && player.Id == targetPlayer.Id, Messages.YOURSELF))
                return;

            // Prevent targeting players who can not participate in coin flips
            if (this.sendConditionalLocalisedMessage(player, targetPlayer != null && !targetPlayer.HasPermission(CoinFlip.PERMISSION_JOIN), Messages.CANT_PARTICIPATE, targetPlayer?.Name))
                return;

            // Prevent player from starting multiple coin flips at once
            if (this.coinFlips.ContainsKey(player.Id))
            {
                this.sendLocalisedMessage(player, Messages.ALREADY_FLIPPING, this.coinFlips[player.Id].Amount);
                return;
            }

            // Check and withdraw balance for coin flip
            double availableBalance = this.Economics.Call<double>("Balance", player.Id);
            if (this.sendConditionalLocalisedMessage(player, !this.Economics.Call<bool>("Withdraw", player.Id, (double)amount), Messages.BALANCE_TOO_LOW, availableBalance, amount))
                return;

            // Create active coin flip
            this.coinFlips.Add(player.Id, new CoinFlipParams()
            {
                Amount = amount,
                Target = targetPlayer,

                // Start a timer that cancels the coin flip after the configured timeout
                Timer = timer.Once(60 * this.Timeout, () => this.cancelCoinFlip(player.Id))
            });

            // Send messages depending on whether a target player was supplied or not
            if (targetPlayer == null)
            {
                // Send messages to all players
                this.covalence.Players.Connected.ToArray().Where(p => p.Id != player.Id && p.HasPermission(CoinFlip.PERMISSION_JOIN)).ToList().ForEach(p => this.sendLocalisedMessage(p, Messages.COINFLIP_INITIATED, player.Name, amount));
                // Inform initiating player about the coin flip and withdrawal
                this.sendLocalisedMessage(player, Messages.COINFLIP_READY, amount, this.Timeout);
            }
            else
            {
                // Inform targeted opponent about coin flip 
                this.sendLocalisedMessage(targetPlayer, Messages.PRIVATE_COINFLIP_INITIATED, player.Name, amount);
                // Inform initiator about coin flip and withdrawal
                this.sendLocalisedMessage(player, Messages.PRIVATE_COINFLIP_READY, amount, this.Timeout, targetPlayer.Name);
            }
        }

        [Command("joinflip"), Permission(CoinFlip.PERMISSION_JOIN)]
        private void joinFlipChatCommand(IPlayer player, string command, string[] args)
        {
            // Validate caller is a player that can interact with Economy
            if (player.IsServer)
            {
                player.Reply("This command can not be used from RCON.");
                return;
            }

            // Validate argument count
            if (this.sendConditionalLocalisedMessage(player, args.Length == 0, Messages.JOIN_USAGE))
                return;

            // Try and find the target player
            IPlayer targetPlayer = this.findPlayer(player, String.Join(" ", args));
            if (targetPlayer == null)
                return;

            // Prevent joining your own coin flip
            if (this.sendConditionalLocalisedMessage(player, player.Id == targetPlayer.Id, Messages.YOURSELF))
                return;

            // Check if target player has an active coin flip
            if (this.sendConditionalLocalisedMessage(player, !this.coinFlips.ContainsKey(targetPlayer.Id), Messages.NOT_FLIPPING, targetPlayer.Name))
                return;

            // Retrieve active coin flip of target player
            CoinFlipParams coinFlipParams = this.coinFlips[targetPlayer.Id];
            if (this.sendConditionalLocalisedMessage(player, coinFlipParams.Target != null && coinFlipParams.Target.Id != player.Id, Messages.PRIVATE))
                return;

            // Check and withdraw balance for coin flip
            double availableBalance = this.Economics.Call<double>("Balance", player.Id);
            if (this.sendConditionalLocalisedMessage(player, !this.Economics.Call<bool>("Withdraw", player.Id, (double)coinFlipParams.Amount), Messages.BALANCE_TOO_LOW, availableBalance, coinFlipParams.Amount))
                return;

            // Remove coin flip from active coin flips to prevent any other players from joining
            this.coinFlips.Remove(targetPlayer.Id);
            coinFlipParams.Timer.Destroy();

            // Inform both players about the commencing coin flip
            this.sendLocalisedMessage(targetPlayer, Messages.FLIP_JOINED, player.Name);
            this.sendLocalisedMessage(player, Messages.FLIP_JOIN, targetPlayer.Name, coinFlipParams.Amount);

            // Announce the coin flip to everybody else
            if (this.AnnounceEverybody)
                this.covalence.Players.Connected.ToArray().Where(p => p.Id != player.Id && p.Id != targetPlayer.Id).ToList().ForEach(p => this.sendLocalisedMessage(p, Messages.JOIN_ALL, targetPlayer.Name, player.Name, coinFlipParams.Amount));

            // Start 3 second countdown (it's actually 5 seconds, but sssssh)
            timer.Once(1, () =>
            {
                this.sendLocalisedMessage(player, Messages.COUNT_THREE);
                this.sendLocalisedMessage(targetPlayer, Messages.COUNT_THREE);
                timer.Once(1, () =>
                {
                    this.sendLocalisedMessage(player, Messages.COUNT_TWO);
                    this.sendLocalisedMessage(targetPlayer, Messages.COUNT_TWO);

                    timer.Once(1, () =>
                    {
                        this.sendLocalisedMessage(player, Messages.COUNT_ONE);
                        this.sendLocalisedMessage(targetPlayer, Messages.COUNT_ONE);

                        timer.Once(1, () =>
                        {
                            this.sendLocalisedMessage(player, Messages.FLIP);
                            this.sendLocalisedMessage(targetPlayer, Messages.FLIP);

                            // Start actually flipping
                            timer.Once(1, () => this.flip(targetPlayer, player, coinFlipParams));
                        });
                    });
                });
            });
        }

        [Command("cancelflip"), Permission(CoinFlip.PERMISSION_CREATE)]
        private void cancelFlipChatCommand(IPlayer player, string command, string[] args)
        {
            // Validate caller is a player that can interact with Economy
            if (player.IsServer)
            {
                player.Reply("This command can not be used from RCON.");
                return;
            }

            // Check if player has an active coin flip
            if (this.sendConditionalLocalisedMessage(player, !this.coinFlips.ContainsKey(player.Id), Messages.NO_FLIPS))
                return;

            // Cancel the coin flip
            this.cancelCoinFlip(player.Id);
        }
        #endregion

        #region Coin flip control
        /// <summary>
        /// Flips a coin
        /// </summary>
        /// <param name="initiator">Player who initiated this coin flip</param>
        /// <param name="player">Player who has joined this coin flip</param>
        /// <param name="coinFlipParams">Parameters of this coin flip</param>
        private void flip(IPlayer initiator, IPlayer player, CoinFlipParams coinFlipParams)
        {
            // Argument validation
            if (initiator == null)
                throw new ArgumentNullException("initiator");

            if (player == null)
                throw new ArgumentNullException("player");

            // Check if both opponents are still connected
            if (!initiator.IsConnected || !player.IsConnected)
            {
                // Send abort message
                if (initiator.IsConnected)
                    this.sendLocalisedMessage(initiator, Messages.LEFT, coinFlipParams.Amount);
                if (player.IsConnected)
                    this.sendLocalisedMessage(player, Messages.LEFT, coinFlipParams.Amount);

                // Refund balance
                this.Economics.Call("Deposit", initiator.Id, (double)coinFlipParams.Amount);
                this.Economics.Call("Deposit", player.Id, (double)coinFlipParams.Amount);

                return;
            }

            // Pick a winner and loser by throwing a coin
            IPlayer winner, loser = null;
            if (CoinFlip.RNG.Next(0, 2) == 1)
            {
                winner = initiator;
                loser = player;
            }
            else
            {
                winner = player;
                loser = initiator;
            }

            // Inform both opponents about the result
            this.sendLocalisedMessage(initiator, Messages.COIN_LAND, winner.Name);
            this.sendLocalisedMessage(player, Messages.COIN_LAND, winner.Name);

            // Congratulate the winner, condole the loser
            this.sendLocalisedMessage(winner, Messages.WIN, coinFlipParams.Amount * 2);
            this.sendLocalisedMessage(loser, Messages.LOSS, coinFlipParams.Amount);

            // Deposit the pot to the winner
            this.Economics.Call("Deposit", winner.Id, (double)coinFlipParams.Amount * 2.0);

            // Announce result to everybody excluding the two opponents
            if (this.AnnounceEverybody)
                this.covalence.Players.Connected.ToArray().Where(p => p.Id != player.Id && p.Id != initiator.Id).ToList().ForEach(p => this.sendLocalisedMessage(p, Messages.WIN_ALL, winner.Name, loser.Name, coinFlipParams.Amount * 2));
        }

        /// <summary>
        /// Cancel an active coin flip
        /// </summary>
        /// <param name="userID">User ID of the coin flip that is to be canceled</param>
        private void cancelCoinFlip(string userID)
        {
            // Argument validation
            if (String.IsNullOrEmpty(userID))
                throw new ArgumentNullException("userID");

            // Check if player has an active coin flip
            if (!this.coinFlips.ContainsKey(userID))
                return;

            // Get the coin flip parameters
            CoinFlipParams coinFlipParams = this.coinFlips[userID];

            // Destroy the timer that cancels the coin flip after the timeout
            coinFlipParams.Timer.Destroy();

            // Remove the coin flip from the active coin flip list
            this.coinFlips.Remove(userID);
            
            // Refund the balance to the player
            this.Economics.Call("Deposit", userID, (double)coinFlipParams.Amount);

            // Get the player if he is still online
            IPlayer player = this.covalence.Players.FindPlayerById(userID);
            if (player == null || !player.IsConnected)
                return;

            // Inform the player about the cancellation
            if (coinFlipParams.Target == null)
                this.sendLocalisedMessage(player, Messages.COINFLIP_CANCELED, coinFlipParams.Amount);
            else
                this.sendLocalisedMessage(player, Messages.PRIVATE_COINFLIP_CANCELED, coinFlipParams.Amount, coinFlipParams.Target.Name);
        }
        #endregion
    }
}


// --- End of file: CoinFlip.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/custom-resource-spawns ---
// --- Original File Path: C/CustomResourceSpawns/CustomResourceSpawns.cs ---

ï»¿using Facepunch;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;
using System;
using System.Collections.Generic;
using System.Linq;
using Network;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace Oxide.Plugins
{
    [Info("Custom Resource Spawns", "k1lly0u", "0.2.33", ResourceId = 1783)]
    [Description("Creates additional spawn points for resources of your choosing, that re-spawn on a timer")]
    class CustomResourceSpawns : RustPlugin
    {
        #region Fields
        private RaycastHit raycastHit;

        private static readonly RaycastHit[] raycastBuffer = new RaycastHit[256];

        private readonly List<BaseEntity> currentResourceEntities = new List<BaseEntity>();
        private readonly List<Timer> refreshTimers = new List<Timer>();

        private readonly Dictionary<ulong, int> resourceCreators = new Dictionary<ulong, int>();

        private const string ADMIN_PERMISSION = "customresourcespawns.admin";

        private struct Resource
        {
            public static readonly List<Resource> List = new List<Resource>();

            public static readonly HashSet<string> Categories = new HashSet<string>();

            private const string RESOURCES = "assets/bundled/prefabs/autospawn/resource/";
            private const string COLLECTABLES = "assets/bundled/prefabs/autospawn/collectable/";
            private const string LOOT = "loot";

            public int ID { get; private set; }

            public string Category { get; private set; }

            public string Shortname { get; private set; }

            public string ResourcePath { get; private set; }

            public Resource(int id, BaseEntity baseEntity)
            {
                ID = id;
                Category = baseEntity.PrefabName.Replace(RESOURCES, "").Replace(COLLECTABLES, "").Replace(baseEntity.ShortPrefabName, "").Replace(".prefab", "").TrimEnd('/');              
                Shortname = baseEntity.ShortPrefabName;
                ResourcePath = baseEntity.PrefabName;

                Categories.Add(Category);
            }
                       
            public static void Populate()
            {
                Clear();

                int id = 1;
                foreach (string str in FileSystem.Backend.cache.Keys)
                {
                    if ((str.StartsWith(RESOURCES) || str.StartsWith(COLLECTABLES)) && !str.Contains(LOOT))
                    {
                        BaseEntity baseEntity = GameManager.server.FindPrefab(str).GetComponent<BaseEntity>();
                        if (baseEntity != null)
                        {
                            AddResource(id, baseEntity);
                            id++;
                        }
                    }
                }
            }

            public static bool FindByID(int id, out Resource resource)
            {
                for (int i = 0; i < List.Count; i++)
                {
                    resource = List[i];

                    if (resource.ID == id)
                        return true;                    
                }

                resource = default(Resource);
                return false;
            }

            public static bool Exists(int id)
            {
                for (int i = 0; i < List.Count; i++)
                {
                    if (List[i].ID == id)
                        return true;
                }

                return false;
            }

            private static void AddResource(int id, BaseEntity baseEntity) => List.Add(new Resource(id, baseEntity));

            public static void Clear() => List.Clear();
        }
        #endregion Fields

        #region Oxide Hooks        
        private void OnServerInitialized()
        {
            permission.RegisterPermission(ADMIN_PERMISSION, this);
            Resource.Populate();

            LoadData();
            InitializeResourceSpawns();
        }

        protected override void LoadDefaultMessages() => lang.RegisterMessages(Messages, this);

        private void OnEntityKill(BaseEntity entity)
        {            
            if (entity == null) 
                return;

            if (currentResourceEntities.Contains(entity))
            {
                InitiateRefresh(entity);
                currentResourceEntities.Remove(entity);
            }
        }
        private void OnCollectiblePickup(Item item, BasePlayer player, CollectibleEntity entity)
        {
            BaseEntity ent = entity.GetEntity();
            if (ent != null)
            {
                if (currentResourceEntities.Contains(ent))
                {
                    InitiateRefresh(ent);
                    currentResourceEntities.Remove(ent);
                }
            }
        }
        private void OnPlayerInput(BasePlayer player, InputState input)
        {
            if (resourceCreators.ContainsKey(player.userID))
                if (input.WasJustPressed(BUTTON.FIRE_PRIMARY))
                {
                    int type = resourceCreators[player.userID];
                    AddSpawn(player, type);
                }
        }
        private void Unload()
        {
            for (int i = currentResourceEntities.Count - 1; i >= 0; i--)
                currentResourceEntities[i].Kill();

            currentResourceEntities.Clear();

            for (int i = 0; i < refreshTimers.Count; i++)            
                refreshTimers[i].Destroy();

            refreshTimers.Clear();
        }

        #endregion Oxide Hooks

        #region Resource Control

        private void InitializeResourceSpawns()
        {
            foreach (StoredData.StoredResource resource in storedData.resources)
            {
                InitializeNewSpawn(resource.Type, resource.Position);
            }
        }
        private void InitiateRefresh(BaseEntity resource)
        {
            Vector3 position = resource.transform.position;
            string type = resource.PrefabName;
            refreshTimers.Add(timer.Once(configData.RespawnTimer * 60, () =>
            {
                InitializeNewSpawn(type, position);
            }));
            currentResourceEntities.Remove(resource);
        }
        private void InitializeNewSpawn(string type, Vector3 position)
        {
            BaseEntity entity = InstantiateEntity(type, position);
            entity.enableSaving = false;
            entity.Spawn();
            currentResourceEntities.Add(entity);
        }

        private BaseEntity InstantiateEntity(string type, Vector3 position)
        {
            GameObject gameObject = Instantiate.GameObject(GameManager.server.FindPrefab(type), position, new Quaternion());
            gameObject.name = type;

            SceneManager.MoveGameObjectToScene(gameObject, Rust.Server.EntityScene);

            UnityEngine.Object.Destroy(gameObject.GetComponent<Spawnable>());

            if (!gameObject.activeSelf)
                gameObject.SetActive(true);

            BaseEntity component = gameObject.GetComponent<BaseEntity>();
            return component;
        }

        #endregion Resource Control

        #region Resource Spawning

        private void AddSpawn(BasePlayer player, int id)
        {
            if (Resource.FindByID(id, out Resource resource))
            {
                BaseEntity entity = InstantiateEntity(resource.ResourcePath, GetSpawnPosition(player));
                entity.enableSaving = false;
                entity.Spawn();

                storedData.resources.Add(new StoredData.StoredResource { Position = entity.transform.position, Type = resource.ResourcePath });
                currentResourceEntities.Add(entity);

                SaveData();
            }
        }

        #endregion

        #region Helper Methods        
        private Vector3 GetSpawnPosition(BasePlayer player)
        {
            int hits = Physics.RaycastNonAlloc(player.eyes.HeadRay(), raycastBuffer, 20f, -1, QueryTriggerInteraction.Ignore);

            float closestdist = float.MaxValue;
            Vector3 closestHitpoint = player.transform.position;

            for (int i = 0; i < hits; i++)
            {
                RaycastHit raycastHit = raycastBuffer[i];

                if (raycastHit.distance < closestdist)
                {
                    closestdist = raycastHit.distance;
                    closestHitpoint = raycastHit.point;
                }
            }
            
            return closestHitpoint;
        }

        private BaseEntity FindResourceEntity(BasePlayer player) => Physics.Raycast(player.eyes.HeadRay(), out raycastHit, 10f) ? raycastHit.GetEntity() : null;
       
        private BaseEntity FindResourcePosition(Vector3 position)
        {
            foreach (BaseEntity entry in currentResourceEntities)
            {
                if (entry.transform.position == position)
                    return entry;
            }
            return null;
        }

        private void FindInRadius(Vector3 position, float radius, List<Vector3> foundResources)
        {
            foreach (StoredData.StoredResource item in storedData.resources)
            {
                if (Vector3.Distance(position, item.Position) < radius)                
                    foundResources.Add(item.Position);                
            }
        }

        private bool RemoveResource(BaseEntity entity)
        {
            if (currentResourceEntities.Contains(entity))
            {
                RemoveFromData(entity);
                currentResourceEntities.Remove(entity);

                entity.Kill();
                return true;
            }
            return false;
        }

        private bool RemoveFromData(BaseEntity baseEntity)
        {
            foreach (StoredData.StoredResource resource in storedData.resources)
            {
                if (resource.Type.Equals(baseEntity.PrefabName, StringComparison.OrdinalIgnoreCase) && Vector3.Distance(baseEntity.transform.position, resource.Position) < 0.25f)
                {
                    storedData.resources.Remove(resource);
                    return true;
                }
            }
            return false;
        }

        private void ShowResourceCategories(BasePlayer player)
        {
            SendEchoConsole(player.net.connection, "Available resource categories");
            foreach (string category in Resource.Categories)
                SendEchoConsole(player.net.connection, category);
        }

        private void ShowResourcesByCategory(BasePlayer player, string category)
        {
            SendEchoConsole(player.net.connection, string.Format("Showing resources with category : {0}", category));
            foreach (Resource resource in Resource.List)
            {
                if (resource.Category.Equals(category, StringComparison.OrdinalIgnoreCase))
                {
                    SendEchoConsole(player.net.connection, string.Format("{0} - {1}", resource.ID, resource.Shortname));
                }
            }
        }

        private void ShowCurrentResources(BasePlayer player)
        {
            foreach (StoredData.StoredResource resource in storedData.resources)
                SendEchoConsole(player.net.connection, string.Format("{0} - {1}", resource.Position, resource.Type));
        }

        private void SendEchoConsole(Network.Connection cn, string msg)
        {
            if (Net.sv.IsConnected())
            {
                NetWrite netWrite = Net.sv.StartWrite();
                netWrite.PacketID(Network.Message.Type.ConsoleMessage);
                netWrite.String(msg);
                netWrite.Send(new SendInfo(cn));
            }
        }
        #endregion

        #region Commands
        [ChatCommand("crs")]
        private void chatResourceSpawn(BasePlayer player, string command, string[] args)
        {
            if (!CanSpawnResources(player)) return;
            if (resourceCreators.ContainsKey(player.userID))
            {
                resourceCreators.Remove(player.userID);
                ChatMessage(player, lang.GetMessage("endAdd", this, player.UserIDString));
                return;
            }
            if (args.Length == 0)
            {
                SendReply(player, lang.GetMessage("synAdd1", this, player.UserIDString));
                SendReply(player, lang.GetMessage("synRem", this, player.UserIDString));
                SendReply(player, lang.GetMessage("synRemNear", this, player.UserIDString));
                SendReply(player, lang.GetMessage("synList", this, player.UserIDString));
                SendReply(player, lang.GetMessage("synResourceCats", this, player.UserIDString));
                SendReply(player, lang.GetMessage("synResource1", this, player.UserIDString));
                SendReply(player, lang.GetMessage("synWipe", this, player.UserIDString));
                return;
            }
            if (args.Length >= 1)
            {
                switch (args[0].ToLower())
                {
                    case "add":
                        {
                            if (!int.TryParse(args[1], out int id))
                            {
                                ChatMessage(player, Message("notNum", player.UserIDString));
                                return;
                            }

                            if (Resource.Exists(id))
                            {
                                resourceCreators.Add(player.userID, id);
                                ChatMessage(player, Message("adding", player.UserIDString));
                                return;
                            }

                            ChatMessage(player, Message("notType", player.UserIDString));
                        }
                        return;

                    case "remove":
                        {
                            if (args.Length >= 2 && args[1].ToLower() == "near")
                            {
                                float radius = 10f;

                                if (args.Length == 3) 
                                    float.TryParse(args[2], out radius);

                                List<Vector3> list = Pool.Get<List<Vector3>>();
                                FindInRadius(player.transform.position, radius, list);
                                if (list.Count > 0)
                                {
                                    int totalDestroyed = 0;
                                    foreach (Vector3 position in list)
                                    {
                                        BaseEntity entity = FindResourcePosition(position);
                                        if (entity != null && RemoveResource(entity))
                                            totalDestroyed++;
                                    }

                                    ChatMessage(player, string.Format(Message("removedNear", player.UserIDString), totalDestroyed, radius));
                                    goto FREE_LIST;
                                }
                                else ChatMessage(player, string.Format(Message("noFind", player.UserIDString), radius.ToString()));

                                FREE_LIST:
                                Pool.FreeUnmanaged(ref list);
                                return;
                            }

                            BaseEntity resource = FindResourceEntity(player);
                            if (resource != null)
                            {
                                if (currentResourceEntities.Contains(resource))
                                {
                                    if (RemoveResource(resource))
                                    {
                                        SaveData();
                                        ChatMessage(player, Message("RemovedResource", player.UserIDString));
                                        return;
                                    }
                                }
                                else ChatMessage(player, Message("notReg", player.UserIDString));
                                return;
                            }
                            ChatMessage(player, Message("notBox", player.UserIDString));
                        }
                        return;

                    case "list":
                        ShowCurrentResources(player);
                        ChatMessage(player, Message("checkConsole", player.UserIDString));
                        return;

                    case "categories":
                        ShowResourceCategories(player);
                        ChatMessage(player, Message("checkConsole", player.UserIDString));
                        return;

                    case "resources":
                        if (args.Length >= 2)
                        {
                            ShowResourcesByCategory(player, args[1]);
                            ChatMessage(player, Message("checkConsole", player.UserIDString));
                        }
                        else SendReply(player, lang.GetMessage("synResource1", this, player.UserIDString));
                        return;

                    case "near":
                        {
                            float radius = 10f;
                            if (args.Length == 2) 
                                float.TryParse(args[1], out radius);

                            List<Vector3> list = Pool.Get<List<Vector3>>();
                            FindInRadius(player.transform.position, radius, list);
                            if (list.Count > 0)
                            {
                                ChatMessage(player, string.Format(Message("foundResources", player.UserIDString), list.Count));
                                foreach (Vector3 position in list)
                                    player.SendConsoleCommand("ddraw.box", 30f, Color.magenta, position, 1f);
                            }
                            else ChatMessage(player, string.Format(Message("noFind", player.UserIDString), radius.ToString()));

                            Pool.FreeUnmanaged(ref list);
                        }
                        return;

                    case "wipe":
                        {
                            int count = storedData.resources.Count;

                            for (int i = currentResourceEntities.Count - 1; i >= 0; i--)
                            {
                                currentResourceEntities[i].Kill();
                                currentResourceEntities.RemoveAt(i);
                            }
                            
                            storedData.resources.Clear();

                            SaveData();
                            ChatMessage(player, string.Format(Message("wipedAll1", player.UserIDString), count));
                        }
                        return;

                    default:
                        break;
                }
            }
        }
        private bool CanSpawnResources(BasePlayer player)
        {
            if (permission.UserHasPermission(player.UserIDString, ADMIN_PERMISSION)) 
                return true;

            ChatMessage(player, Message("noPerms", player.UserIDString));

            return false;
        }

        #endregion Chat Commands

        #region Config
        private ConfigData configData;
        private class ConfigData
        {
            public int RespawnTimer { get; set; }

            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();

            if (configData.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                RespawnTimer = 20,
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            configData.Version = Version;
            PrintWarning("Config update completed!");
        }        
        #endregion

        #region Data Management
        private StoredData storedData;

        private DynamicConfigFile dynamicConfigFile;

        private void SaveData() => dynamicConfigFile.WriteObject(storedData);

        private void LoadData()
        {
            dynamicConfigFile = Interface.Oxide.DataFileSystem.GetFile("CustomSpawns/crs_data");
            dynamicConfigFile.Settings.Converters = new JsonConverter[] { new UnityVector3Converter() };

            storedData = dynamicConfigFile.ReadObject<StoredData>();
            if (storedData == null)
                storedData = new StoredData();            
        }

        private class StoredData
        {
            public List<StoredResource> resources = new List<StoredResource>();

            public class StoredResource
            {
                public string Type;
                public Vector3 Position;
            }
        }

        private class UnityVector3Converter : JsonConverter
        {
            public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
            {
                Vector3 vector = (Vector3)value;
                writer.WriteValue($"{vector.x} {vector.y} {vector.z}");
            }

            public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
            {
                if (reader.TokenType == JsonToken.String)
                {
                    string[] values = reader.Value.ToString().Trim().Split(' ');
                    return new Vector3(Convert.ToSingle(values[0]), Convert.ToSingle(values[1]), Convert.ToSingle(values[2]));
                }
                JObject o = JObject.Load(reader);
                return new Vector3(Convert.ToSingle(o["x"]), Convert.ToSingle(o["y"]), Convert.ToSingle(o["z"]));
            }

            public override bool CanConvert(Type objectType)
            {
                return objectType == typeof(Vector3);
            }
        }
        #endregion Data Management

        #region Messages
        private void ChatMessage(BasePlayer player, string message) => SendReply(player, $"<color=orange>{Title}:</color> <color=#939393>{message}</color>");

        private string Message(string key, string playerid = null) => lang.GetMessage(key, this, playerid);


        private readonly Dictionary<string, string> Messages = new Dictionary<string, string>()
        {
            ["checkConsole"] = "Check your console for a list of resources",
            ["noPerms"] = "You do not have permission to use this command",
            ["notType"] = "The number you have entered is not on the list",
            ["notNum"] = "You must enter a resource number",
            ["notBox"] = "You are not looking at a resource",
            ["notReg"] = "This is not a custom placed resource",
            ["RemovedResource"] = "Resource deleted",
            ["synAdd1"] = "<color=orange>/crs add <id> </color><color=#939393>- Adds a new resource</color>",
            ["synRem"] = "<color=orange>/crs remove </color><color=#939393>- Remove the resource you are looking at</color>",
            ["synRemNear"] = "<color=orange>/crs remove near <radius> </color><color=#939393>- Removes the resources within <radius> (default 10M)</color>",
            ["synResourceCats"]= "<color=orange>/crs categories </color><color=#939393>- List available resource categories</color>",
            ["synResource1"] = "<color=orange>/crs resources <category> </color><color=#939393>- List available resources in the specified category</color>",
            ["synWipe"] = "<color=orange>/crs wipe </color><color=#939393>- Wipes all custom placed resources</color>",
            ["synList"] = "<color=orange>/crs list </color><color=#939393>- Puts all custom resource details to console</color>",
            ["synNear"] = "<color=orange>/crs near XX </color><color=#939393>- Shows custom resources in radius XX</color>",
            ["wipedAll1"] = "Wiped {0} custom resource spawns",
            ["foundResources"] = "Found {0} resource spawns near you",
            ["noFind"] = "Couldn't find any resources in radius: {0}M",
            ["adding"] = "You have activated the resouce tool. Look where you want to place and press shoot. Type /crs to end",
            ["endAdd"] = "You have de-activated the resouce tool",
            ["removedNear"] = "Removed {0} resources within a {1}M radius of your position"
        };

        #endregion Messaging
    }
}

// --- End of file: CustomResourceSpawns.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/chinook-crate-to-bag ---
// --- Original File Path: C/ChinookCrateToBag/ChinookCrateToBag.cs ---

ï»¿using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info( "Chinook Crate To Bag", "Waggy", "1.0.1" )]
    [Description( "Chinook crates drop loot in a bag a configurable amount of time after hacking finishes" )]

    class ChinookCrateToBag : CovalencePlugin
    {
        #region Hooks

        void OnCrateHackEnd( HackableLockedCrate crate )
        {
            timer.In( config.timeToWait * 60, () => 
            {
                if ( crate != null )
                {
                    crate.inventory.Drop( "assets/prefabs/misc/item drop/item_drop.prefab", crate.GetDropPosition(), crate.transform.rotation );
                    crate.Kill();
                }
            } );
        }

        #endregion

        #region Config and Lang

        private ConfigData config;

        protected override void LoadDefaultConfig()
        {
            Config.WriteObject( new ConfigData(), true );
        }

        private void Init()
        {
            config = Config.ReadObject<ConfigData>();
        }

        private new void SaveConfig()
        {
            Config.WriteObject( config, true );
        }

        public class ConfigData
        {
            [JsonProperty( "Time to Wait Before Dropping Bag (in minutes)" )]
            public float timeToWait = 15f;
        }

        #endregion
    }
}

// --- End of file: ChinookCrateToBag.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/cupboard-on-foundation ---
// --- Original File Path: C/CupboardOnFoundation/CupboardOnFoundation.cs ---

using System.Collections.Generic;
using UnityEngine;
using System.Linq;

#region Changelogs and ToDo
/**********************************************************************
 * 
 * v1.1.0   :   Started to Maintain (Krungh Crow)
 *          :   Preventive Fix for RPC error
 * 
 **********************************************************************/
#endregion

namespace Oxide.Plugins
{
    [Info("Cupboard On Foundation", "BuzZ/Krungh Crow", "1.1.1")]
    [Description("Authorize cupboard to be placed only on foundation")]

    #region Changelogs and ToDo
    /**********************************************************************
     * 
     * v1.1.1   :   Fixed duping
     * 
     **********************************************************************/
    #endregion


    public class CupboardOnFoundation : RustPlugin
    {

        bool debug = false;
        const string FoundationOnly = "cupboardonfoundation.only"; 

        void Init()
        {
            permission.RegisterPermission(FoundationOnly, this);

        }

        #region LanguageAPI

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"MayNotPlaceMsg", "You may not place a tool cupboard on anything but a foundation !"},

            }, this, "en");

            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"MayNotPlaceMsg", "Vous ne pouvez placer cet objet ailleurs que sur une fondation !"},

            }, this, "fr");
        }

        #endregion


        void OnEntitySpawned(BaseEntity entity, UnityEngine.GameObject gameObject)
        {
            if(entity.ShortPrefabName.Contains("cupboard.tool"))
            {
                if (debug)Puts($"a cupboard is spawning in world");
                if(entity.OwnerID == null) return;
                BasePlayer player = BasePlayer.FindByID(entity.OwnerID);
                if (player == null) return;
                if(player.IsSleeping() == true || player.IsConnected == false) return;
                if (debug)Puts($"sleep check");
                bool isauth = permission.UserHasPermission(player.UserIDString, FoundationOnly);
                if (!isauth) return;
                if (debug)Puts($"wotsaround");
                List<BaseEntity> wotsaround = new List<BaseEntity>();
                Vis.Entities(entity.transform.position, 1, wotsaround);
                foreach (BaseEntity foundentity in wotsaround)
                {
                    if(foundentity.ShortPrefabName.Contains("cupboard") && wotsaround.Count == 1)
                    {
                        if (debug)Puts($"alone cup");
                        CancelThisCupboard(entity, player);
                        break;
                    }

                    if(foundentity.ShortPrefabName.Contains("foundation"))
                    {
                        if (debug)Puts($"foundation");
                        CheckWherePlaced(entity, foundentity, player, null);
                        break;
                    }

                    if(foundentity.ShortPrefabName.Contains("floor"))
                    {
                        if (debug)Puts($"floor");
                        CheckWherePlaced(entity, foundentity, player, "floor");
                    }
                }
            }
        }

        void CheckWherePlaced (BaseEntity cupboard, BaseEntity entity, BasePlayer player, string found)
        {
            if (debug)Puts($"CheckWherePlaced");
            List<BaseEntity> wotsaround = new List<BaseEntity>();
            Vis.Entities(new Vector3(entity.transform.position.x, entity.transform.position.y + 0.5f, entity.transform.position.z), 1, wotsaround);
            if (debug)Puts($"processing one foundation entity");
            foreach (BaseEntity foundentity in wotsaround)
            {
                if (foundentity.ShortPrefabName.Contains("cupboard"))
                {
                    if (found == "floor")
                    {
                        NextTick(() =>
                        {
                            CancelThisCupboard(cupboard, player);
                            return;
                        });
                    }
                    if (debug)Puts($"placing a cupboard");
                    return;
                }
            }
        }

        void CancelThisCupboard (BaseEntity entity, BasePlayer player)
        {
            if (debug)Puts($"cancelling a cupboard");
            SendReply(player, lang.GetMessage("MayNotPlaceMsg", this));  
            entity.KillMessage();
            NextTick(() =>
            {
                var itemtogive = ItemManager.CreateByItemID(-97956382, 1);
                if (itemtogive != null) player.inventory.GiveItem(itemtogive);
                return;
            });
        }
    }
}

// --- End of file: CupboardOnFoundation.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/caps-no-caps ---
// --- Original File Path: C/CapsNoCaps/CapsNoCaps.cs ---

ï»¿using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;
using System.Text;

namespace Oxide.Plugins
{
    [Info("CapsNoCaps", "LaserHydra", "2.0.0")]
    class CapsNoCaps : CovalencePlugin
    {
        private Configuration _config;

        private const string IgnorePermission = "capsnocaps.ignore";

        private void Init()
        {
            permission.RegisterPermission(IgnorePermission, this);
        }

        private void OnBetterChat(Dictionary<string, object> data)
        {
            var player = data["Player"] as IPlayer;
            var message = data["Message"] as string;

            if (CanWriteCaps(player))
                return;

            data["Message"] = ReplaceCapitalWords(message, _config.CapitalLetterPercentageThreshold, _config.WordLengthThreshold);
        }

        private static string ReplaceCapitalWords(string text, float captialLetterPercentageThreshold = 0.4f, int lengthThreshold = 1)
        {
            StringBuilder stringBuilder = new StringBuilder();

            int wordBeginning = 0,
                upperCaseLetters = 0,
                lowerCaseLetters = 0;

            for (int i = 0; i < text.Length; i++)
            {
                bool isLastChar = i == text.Length - 1;

                char c = text[i];

                if (char.IsUpper(c))
                    upperCaseLetters++;
                else if (char.IsLower(c))
                    lowerCaseLetters++;

                if (char.IsWhiteSpace(c) || isLastChar)
                {
                    int length = i - wordBeginning + 1; // +1 to include current character

                    int lengthWithoutWhitespace = isLastChar // In case this is NOT the last character, the current character is a whitespace which we subtract.
                        ? length
                        : length - 1;

                    if (lengthWithoutWhitespace > lengthThreshold && (float) upperCaseLetters / (lowerCaseLetters + upperCaseLetters) > captialLetterPercentageThreshold)
                        stringBuilder.Append(text.Substring(wordBeginning, length).ToLower());
                    else
                        stringBuilder.Append(text.Substring(wordBeginning, length));

                    wordBeginning = i + 1;
                    upperCaseLetters = 0;
                    lowerCaseLetters = 0;
                }
            }

            return stringBuilder.ToString();
        }

        private bool CanWriteCaps(IPlayer player) => player.HasPermission(IgnorePermission);

        #region Configuration

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<Configuration>();
            SaveConfig();
        }

        protected override void LoadDefaultConfig() => _config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(_config);

        private class Configuration
        {
            [JsonProperty("Word Length Threshold")]
            public int WordLengthThreshold { get; private set; } = 1;

            [JsonProperty("Capital Letter Percentage Threshold (between 0 and 1)")]
            public float CapitalLetterPercentageThreshold { get; private set; } = 0.4f;
        }

        #endregion
    }
}


// --- End of file: CapsNoCaps.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/combat-logger ---
// --- Original File Path: C/CombatLogger/CombatLogger.cs ---

using Rust;
using System;
using System.Collections.Generic;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Combat Logger", "Tori1157/RocketMyrr", "2.0.3")]
    [Description("Logs everything related to combat.")]
    class CombatLogger : RustPlugin
    {
        #region Constants
        private readonly List<string> DamageTypes = new List<string> // DamgeTypes Check and Blocking for Damage but shown for Wounded and Killed By
        {
            "Hunger", "Thirst", "Cold", "Drowned", "Heat", "Bleeding", "Poison", "Suicide", "Fall",
            "Radiation", "Explosion", "RadiationExposure", "ColdExposure", "Decay", "ElectricShock", "Arrow", "AntiVehicle", "Collision", "Fun_Water"
        };
        #endregion Constants

        #region Hooks
        private void OnServerInitialized()
        {
            if (configData.LogMain.Damage.Log || configData.LogMain.Damage.Put)
                Subscribe(nameof(OnEntityTakeDamage));

            if (configData.LogMain.Death.Log || configData.LogMain.Death.Put)
                Subscribe(nameof(OnEntityDeath));

            if (configData.LogMain.Respawns.Log || configData.LogMain.Respawns.Put)
                Subscribe(nameof(OnPlayerRespawned));

            if (configData.LogMain.Wound.Log || configData.LogMain.Wound.Put)
                Subscribe(nameof(OnPlayerWound));

            if (configData.LogMain.Healing.Put || configData.LogMain.Healing.Log)
            {
                Subscribe(nameof(OnHealingItemUse));
                Subscribe(nameof(OnItemUse));
            }
        }

        private void Init()
        {
            Unsubscribe(nameof(OnHealingItemUse));
            Unsubscribe(nameof(OnItemUse));
            Unsubscribe(nameof(OnEntityTakeDamage));
            Unsubscribe(nameof(OnEntityDeath));
            Unsubscribe(nameof(OnPlayerRespawned));
            Unsubscribe(nameof(OnPlayerWound));
        }

        #region Healing
        private void OnHealingItemUse(MedicalTool item, BasePlayer target)
        {
            if (item == null || target == null) return;
            if (configData.LogMain.Healing.Log) Log(Lang("Log Player Healing1", target.displayName, target.userID, item.GetItem().info.displayName?.english, target.transform.position, target.health));
            if (configData.LogMain.Healing.Put) Puts(Lang("Log Player Healing1", target.displayName, target.userID, item.GetItem().info.displayName?.english, target.transform.position, target.health));
        }

        private void OnItemUse(Item item, int amountToUse)
        {
            if (item == null) return;
            var player = item?.parent?.GetOwnerPlayer();
            if (player == null) return;

            if (item.info.shortname == "largemedkit")
            {
                if (configData.LogMain.Healing.Log) Log(Lang("Log Player Healing1", player.displayName, player.userID, item.info.displayName?.english, $"{Lang("Log At")} {player.transform.position}", player.health));
                if (configData.LogMain.Healing.Put) Puts(Lang("Log Player Healing1", player.displayName, player.userID, item.info.displayName?.english, $"{Lang("Log At")} {player.transform.position}", player.health));
            }
        }
        #endregion Healing

        #region Combat
        private void OnEntityTakeDamage(BaseEntity entity, HitInfo info)
        {
            if (entity == null || info == null) return;

            if (info.InitiatorPlayer != null)
            {
                if (info.InitiatorPlayer.userID.IsSteamId() && info.InitiatorPlayer != null)
                {
                    var dmg = Math.Round(info.damageTypes.Total(), 2).ToString(); // Round out Damage
                    if (entity is BasePlayer && entity.ToPlayer().UserIDString.IsSteamId() && !entity.IsNpc)
                    {
                        var victim = entity as BasePlayer;
                        if (victim == null) return;
                        if (victim.lastDamage == DamageType.Bleeding) return; // Don't track bleeding
                        if (victim == info.InitiatorPlayer)
                        {
                            if (CheckDamageBL(victim)) return;
                            if (victim.lastDamage.ToString() == "Suicide" || info.damageTypes.Total() == 1000) return; //Because Apparently Suicide doesnt always get caught
                            if (configData.HurtLog.PvP.Log && configData.LogMain.Damage.Log) Log(Lang("Log Player Hurt Himself1", CleanName(info.InitiatorPlayer), $"{Lang("Log Weapon")} '{info.Weapon?.GetItem()?.info?.displayName?.english ?? info.WeaponPrefab?.GetItem()?.info?.displayName?.english ?? info.WeaponPrefab?.ToString() ?? FireCheck(info) ?? info.InitiatorPlayer?.GetHeldEntity()?.GetItem()?.info?.displayName?.english ?? victim.lastDamage.ToString() ?? "Unknown"}' ", dmg, entity.transform.position));
                            if (configData.HurtLog.PvP.Put && configData.LogMain.Damage.Put) Puts(Lang("Log Player Hurt Himself1", CleanName(info.InitiatorPlayer), $"{Lang("Log Weapon")} '{info.Weapon?.GetItem()?.info?.displayName?.english ?? info.WeaponPrefab?.GetItem()?.info?.displayName?.english ?? info.WeaponPrefab?.ToString() ?? FireCheck(info) ?? info.InitiatorPlayer?.GetHeldEntity()?.GetItem()?.info?.displayName?.english ?? victim.lastDamage.ToString() ?? "Unknown"}' ", dmg, entity.transform.position));
                            if (configData.Debug) Log($"|SELF-HURT| Weapon: {info.Weapon?.GetItem()?.info?.displayName?.english ?? info.WeaponPrefab?.ToString() ?? FireCheck(info) ?? victim.lastDamage.ToString() ?? "Unknown"}  |  Weapon2: {info.WeaponPrefab}  |  Damage: {victim.lastDamage.ToString()}  |  Attacker: {info.InitiatorPlayer}  |  Victim: {victim}");
                            return;
                        }
                        var pvpmessage = Lang("Log Entity Attack1", CleanName(victim), CleanName(info.InitiatorPlayer), $"{Lang("Log Weapon")} '{info.Weapon?.GetItem()?.info?.displayName?.english ?? info.WeaponPrefab?.GetItem()?.info?.displayName?.english ?? info.WeaponPrefab?.ToString() ?? FireCheck(info) ?? info.InitiatorPlayer?.GetHeldEntity()?.GetItem()?.info?.displayName?.english ?? victim.lastDamage.ToString() ?? "Unknown"}' ", dmg, GetDistance(entity, info), entity.transform.position, info.InitiatorPlayer.transform.position, GetBodypartName(info));
                        if (configData.HurtLog.PvP.Log && configData.LogMain.Damage.Log) Log(pvpmessage);
                        if (configData.HurtLog.PvP.Put && configData.LogMain.Damage.Put) Puts(pvpmessage);
                        if (configData.Debug) Log($"|Player-Player| Damage: {victim.lastDamage.ToString() ?? "No Damage"}  |  Attacker: {info.InitiatorPlayer}  |  Victim: {victim} | Weapon: {info.Weapon?.GetItem()?.info?.displayName?.english ?? info.WeaponPrefab?.GetItem()?.info?.displayName?.english ?? info.WeaponPrefab?.ToString() ?? FireCheck(info) ?? info.InitiatorPlayer.GetHeldEntity()?.GetItem()?.info?.displayName?.english ?? victim.lastDamage.ToString() ?? "Unknown"}");
                        return;
                    }

                    if (entity.IsNpc || (entity is BasePlayer && !entity.ToPlayer().UserIDString.IsSteamId())) //Some Plugins use Weird Classes that arent detected by IsNPC, I know IsSteamId is redundant but just covering basis
                    {
                        if (entity is BaseAnimalNPC)
                        {
                            if (!configData.HurtLog.PvA.Put && !configData.HurtLog.PvA.Log) return;
                            var animalmessage = Lang("Log Entity Attack1", entity.ShortPrefabName + "[NPC]", CleanName(info.InitiatorPlayer), $"{Lang("Log Weapon")} '{info.Weapon?.GetItem()?.info?.displayName?.english ?? info.WeaponPrefab?.GetItem()?.info?.displayName?.english ?? info.WeaponPrefab?.ToString() ?? FireCheck(info) ?? info.InitiatorPlayer?.GetHeldEntity()?.GetItem()?.info?.displayName?.english ?? info.Initiator?.ShortPrefabName ?? info.damageTypes.GetMajorityDamageType().ToString() ?? "Unknown"}' ", dmg, GetDistance(entity, info), entity.transform.position, info.InitiatorPlayer.transform.position, "");
                            if (configData.HurtLog.PvA.Log && configData.LogMain.Damage.Log) Log(animalmessage);
                            if (configData.HurtLog.PvA.Put && configData.LogMain.Damage.Put) Puts(animalmessage);
                            if (configData.Debug) Log($"|PLAYER-ANIMAL| Weapon: {info.Weapon?.GetItem()?.info?.displayName?.english ?? info.WeaponPrefab?.ToString() ?? info.Initiator?.ShortPrefabName}  |  Weapon2: {info.WeaponPrefab?.ToString() ?? "unable"}  |  Damage: {dmg} |  Attacker: {info.InitiatorPlayer} {info.Initiator.transform.position}  |  Victim: {entity.ShortPrefabName ?? "No Victim"} {entity.transform.position} | Distance: {GetDistance(entity, info)}");
                            return;
                        }

                        var npc = entity as BasePlayer;
                        if (npc != null)
                        {
                            if (!configData.HurtLog.PvN.Put && !configData.HurtLog.PvN.Log) return;
                            if (npc.lastDamage == DamageType.Bleeding) return; // Don't track bleeding
                            var pvpmessage = Lang("Log Entity Attack1", npc.displayName + "[NPC]", CleanName(info.InitiatorPlayer), $"{Lang("Log Weapon")} '{info.Weapon?.GetItem()?.info?.displayName?.english ?? info.WeaponPrefab?.GetItem()?.info?.displayName?.english ?? info.WeaponPrefab?.ToString() ?? FireCheck(info) ?? info.InitiatorPlayer?.GetHeldEntity()?.GetItem()?.info?.displayName?.english ?? info.damageTypes.GetMajorityDamageType().ToString() ?? info.Initiator?.ShortPrefabName ?? "Unknown"}' ", dmg, GetDistance(entity, info), entity.transform.position, info.InitiatorPlayer.transform.position, GetBodypartName(info));
                            if (configData.HurtLog.PvN.Log && configData.LogMain.Damage.Log) Log(pvpmessage);
                            if (configData.HurtLog.PvN.Put && configData.LogMain.Damage.Put) Puts(pvpmessage);
                            if (configData.Debug) Log($"|PLAYER-NPC| Weapon: {info.Weapon?.GetItem()?.info?.displayName?.english ?? info.WeaponPrefab?.ToString() ?? info.Initiator?.ShortPrefabName}  |  Weapon2: {info.WeaponPrefab?.ToString() ?? "unable"}  |  Damage: {dmg} |  Attacker: {info.InitiatorPlayer} {info.Initiator.transform.position}  |  Victim: {entity.ShortPrefabName ?? "No Victim"} {entity.transform.position} | Distance: {GetDistance(entity, info)}");
                            return;
                        }
                        var npcp = entity as NPCPlayer;
                        if (npcp != null)
                        {
                            if (!configData.HurtLog.PvN.Put && !configData.HurtLog.PvN.Log) return;
                            if (npcp.lastDamage == DamageType.Bleeding) return; // Don't track bleeding
                            var pvpmessage = Lang("Log Entity Attack1", npcp.displayName + "[NPC]", CleanName(info.InitiatorPlayer), $"{Lang("Log Weapon")} '{info.Weapon?.GetItem()?.info?.displayName?.english ?? info.WeaponPrefab?.GetItem()?.info?.displayName?.english ?? info.WeaponPrefab?.ToString() ?? FireCheck(info) ?? info.InitiatorPlayer?.GetHeldEntity()?.GetItem()?.info?.displayName?.english ?? info.damageTypes.GetMajorityDamageType().ToString() ?? info.Initiator?.ShortPrefabName ?? "Unknown"}' ", dmg, GetDistance(entity, info), entity.transform.position, info.InitiatorPlayer.transform.position, GetBodypartName(info));
                            if (configData.HurtLog.PvN.Log && configData.LogMain.Damage.Log) Log(pvpmessage);
                            if (configData.HurtLog.PvN.Put && configData.LogMain.Damage.Put) Puts(pvpmessage);
                            if (configData.Debug) Log($"|PLAYER-NPC| Weapon: {info.Weapon?.GetItem()?.info?.displayName?.english ?? info.WeaponPrefab?.ToString() ?? info.Initiator?.ShortPrefabName}  |  Weapon2: {info.WeaponPrefab?.ToString() ?? "unable"}  |  Damage: {dmg} |  Attacker: {info.InitiatorPlayer} {info.Initiator.transform.position}  |  Victim: {entity.ShortPrefabName ?? "No Victim"} {entity.transform.position} | Distance: {GetDistance(entity, info)}");
                            return;
                        }
                        return;
                    }
                }
            }

            var victimPlayer = entity as BasePlayer;
            if (victimPlayer == null) return;
            if (!victimPlayer.UserIDString.IsSteamId()) return;

            if (CheckDamageBL(victimPlayer)) return;

            if (victimPlayer.IsSleeping() && configData.LogMain.LogSleeping) return;

            var dmgPlayer = Math.Round(info.damageTypes.Total(), 2).ToString();

            if (info.Initiator is BaseAnimalNPC)
            {
                var animalmessage = Lang("Log Entity Attack1", CleanName(victimPlayer), $"{info.Initiator?.ShortPrefabName ?? victimPlayer.lastAttacker?.ShortPrefabName ?? "Unknown"}[NPC]", "", dmgPlayer, GetDistance(victimPlayer, info), victimPlayer.transform.position, info.Initiator.IsValid() ? info.Initiator.transform.position.ToString() : "", "");
                if (configData.HurtLog.AvP.Log && configData.LogMain.Damage.Log) Log(animalmessage);
                if (configData.HurtLog.AvP.Put && configData.LogMain.Damage.Put) Puts(animalmessage);
                return;
            }
            if (info.Initiator is ScientistNPC || info.Initiator is Zombie || info.Initiator is ScarecrowNPC || info.Initiator is NPCPlayer)
            {
                var scientistmessage = Lang("Log Entity Attack1", CleanName(victimPlayer), $"{info.InitiatorPlayer?.displayName ?? info.Initiator?.name ?? victimPlayer.lastAttacker?.name ?? victimPlayer.lastAttacker?.ShortPrefabName ?? "Unknown"}[NPC]", $"{Lang("Log Weapon")} '{info.Weapon?.GetItem()?.info.displayName?.english ?? info.WeaponPrefab?.GetItem()?.info?.displayName?.english ?? info.WeaponPrefab?.ToString() ?? info.WeaponPrefab?.ShortPrefabName ?? info.InitiatorPlayer?.GetHeldEntity()?.GetItem()?.info?.displayName?.english ?? victimPlayer.lastDamage.ToString()}' ", dmgPlayer, GetDistance(victimPlayer, info), victimPlayer.transform.position, info.Initiator.IsValid() ? info.Initiator.transform.position.ToString() : "", GetBodypartName(info));
                if (configData.HurtLog.NvP.Log && configData.LogMain.Damage.Log) Log(scientistmessage);
                if (configData.HurtLog.NvP.Put && configData.LogMain.Damage.Put) Puts(scientistmessage);
                return;
            }
            if (info.Initiator is NPCAutoTurret)
            {
                var npcturretmessage = Lang("Log Entity Attack1", CleanName(victimPlayer), "Outpost Sentry", "", dmgPlayer, info.Initiator.IsValid() ? GetDistance(victimPlayer, info) : "", victimPlayer.transform.position, info.Initiator.IsValid() ? info.Initiator.transform.position.ToString() : "", GetBodypartName(info));
                if (configData.HurtLog.EvP.Log && configData.LogMain.Damage.Log) Log(npcturretmessage);
                if (configData.HurtLog.EvP.Put && configData.LogMain.Damage.Put) Puts(npcturretmessage);
                return;
            }
            if (info.Initiator is AutoTurret)
            {
                var Turret = info.Initiator as AutoTurret;
                var turretMessage = Lang("Log Entity Attack1", CleanName(victimPlayer), "Auto Turret", $"{Lang("Log Weapon")} '{info.WeaponPrefab?.GetItem()?.info?.displayName?.english ?? info.WeaponPrefab?.GetItem()?.info?.displayName?.english ?? Turret.AttachedWeapon?.GetItem()?.info?.displayName?.english ?? info.WeaponPrefab?.name}' ", dmgPlayer, info.Initiator.IsValid() ? GetDistance(victimPlayer, info) : "", victimPlayer.transform.position, info.Initiator.IsValid() ? info.Initiator.transform.position.ToString() : "", GetBodypartName(info));
                if (configData.HurtLog.EvP.Put && configData.LogMain.Damage.Put) Puts(turretMessage);
                if (configData.HurtLog.EvP.Log && configData.LogMain.Damage.Log) Log(turretMessage);
                return;
            }

            if (info.Initiator is BradleyAPC || info?.WeaponPrefab?.ShortPrefabName == "maincannonshell")
            {
                var apcMessage = Lang("Log Entity Attack1", CleanName(victimPlayer), "Bradley APC", "", dmgPlayer, info.Initiator.IsValid() ? GetDistance(victimPlayer, info) : "", victimPlayer.transform.position, info.Initiator.IsValid() ? info.Initiator.transform.position.ToString() : "", GetBodypartName(info));
                if (configData.HurtLog.EvP.Put && configData.LogMain.Damage.Put) Puts(apcMessage);
                if (configData.HurtLog.EvP.Log && configData.LogMain.Damage.Log) Log(apcMessage);
                return;
            }
            if (info.Initiator is PatrolHelicopter || info?.WeaponPrefab?.ShortPrefabName == "rocket_heli")
            {
                var heliMessage = Lang("Log Entity Attack1", CleanName(victimPlayer), "Patrol Helicopter", "", dmgPlayer, info.Initiator.IsValid() ? GetDistance(victimPlayer, info) : "", victimPlayer.transform.position, info.Initiator.IsValid() ? info.Initiator.transform.position.ToString() : "", GetBodypartName(info));
                if (configData.HurtLog.EvP.Put && configData.LogMain.Damage.Put) Puts(heliMessage);
                if (configData.HurtLog.EvP.Log && configData.LogMain.Damage.Log) Log(heliMessage);
                return;
            }
            if (info.Initiator is ModularCar)
            {
                ModularCar vehicle = info.Initiator as ModularCar;
                BasePlayer driver = vehicle.GetDriver();
                if (driver != null)
                {
                    var carmessage = Lang("Log Entity Attack1", CleanName(victimPlayer), CleanName(driver), "Modular Car", dmgPlayer, "", victimPlayer.transform.position, driver.transform.position, GetBodypartName(info));
                    if (configData.HurtLog.PvP.Log && configData.LogMain.Damage.Log) Log(carmessage);
                    if (configData.HurtLog.PvP.Put && configData.LogMain.Damage.Put) Puts(carmessage);
                    return;
                }
            }

            if (victimPlayer.lastAttacker != null) // For Somereason the above checks do not catch everything when the damage is less then 1. This will catch alot of it, but there still a very few that slip through
            {
                if (victimPlayer.lastAttacker is BaseAnimalNPC)
                {
                    var animalmessage = Lang("Log Entity Attack1", CleanName(victimPlayer), $"{victimPlayer.lastAttacker?.ShortPrefabName ?? victimPlayer.lastAttacker?.ShortPrefabName ?? "Unknown"}[NPC]", "", dmgPlayer, GetDistanceAttacker(victimPlayer, victimPlayer.lastAttacker), victimPlayer.transform.position, victimPlayer.lastAttacker.IsValid() ? victimPlayer.lastAttacker.transform.position.ToString() : "", "");
                    if (configData.HurtLog.AvP.Log && configData.LogMain.Damage.Log) Log(animalmessage);
                    if (configData.HurtLog.AvP.Put && configData.LogMain.Damage.Put) Puts(animalmessage);
                    return;
                }
                if (victimPlayer.lastAttacker is ScientistNPC || victimPlayer.lastAttacker is Zombie || victimPlayer.lastAttacker is ScarecrowNPC || victimPlayer.lastAttacker is NPCPlayer)
                {
                    var scientistmessage = Lang("Log Entity Attack1", CleanName(victimPlayer), $"{victimPlayer.lastAttacker.ToPlayer()?.displayName ?? victimPlayer.lastAttacker?.name ?? victimPlayer.lastAttacker?.name ?? victimPlayer.lastAttacker?.ShortPrefabName ?? "Unknown"}[NPC]", $"{Lang("Log Weapon")} '{info.Weapon?.GetItem()?.info.displayName?.english ?? info.WeaponPrefab?.GetItem()?.info?.displayName?.english ?? info.WeaponPrefab?.ToString() ?? info.WeaponPrefab?.ShortPrefabName ?? victimPlayer.lastAttacker.ToPlayer()?.GetHeldEntity()?.GetItem()?.info?.displayName?.english ?? victimPlayer.lastDamage.ToString()}' ", dmgPlayer, GetDistanceAttacker(victimPlayer, victimPlayer.lastAttacker), victimPlayer.transform.position, victimPlayer.lastAttacker.IsValid() ? victimPlayer.lastAttacker.transform.position.ToString() : "", GetBodypartName(info));
                    if (configData.HurtLog.NvP.Log && configData.LogMain.Damage.Log) Log(scientistmessage);
                    if (configData.HurtLog.NvP.Put && configData.LogMain.Damage.Put) Puts(scientistmessage);
                    return;
                }
                if (victimPlayer.lastAttacker is NPCAutoTurret)
                {
                    var npcturretmessage = Lang("Log Entity Attack1", CleanName(victimPlayer), "Outpost Sentry", "", dmgPlayer, victimPlayer.lastAttacker.IsValid() ? GetDistanceAttacker(victimPlayer, victimPlayer.lastAttacker) : "", victimPlayer.transform.position, victimPlayer.lastAttacker.IsValid() ? victimPlayer.lastAttacker.transform.position.ToString() : "", GetBodypartName(info));
                    if (configData.HurtLog.EvP.Log && configData.LogMain.Damage.Log) Log(npcturretmessage);
                    if (configData.HurtLog.EvP.Put && configData.LogMain.Damage.Put) Puts(npcturretmessage);
                    return;
                }
                if (victimPlayer.lastAttacker is AutoTurret)
                {
                    var Turret = victimPlayer.lastAttacker as AutoTurret;
                    var turretMessage = Lang("Log Entity Attack1", CleanName(victimPlayer), "Auto Turret", $"{Lang("Log Weapon")} '{info.WeaponPrefab?.GetItem()?.info?.displayName?.english ?? info.WeaponPrefab?.GetItem()?.info?.displayName?.english ?? Turret.AttachedWeapon?.GetItem()?.info?.displayName?.english ?? info.WeaponPrefab?.name}' ", dmgPlayer, victimPlayer.lastAttacker.IsValid() ? GetDistanceAttacker(victimPlayer, victimPlayer.lastAttacker) : "", victimPlayer.transform.position, victimPlayer.lastAttacker.IsValid() ? victimPlayer.lastAttacker.transform.position.ToString() : "", GetBodypartName(info));
                    if (configData.HurtLog.EvP.Put && configData.LogMain.Damage.Put) Puts(turretMessage);
                    if (configData.HurtLog.EvP.Log && configData.LogMain.Damage.Log) Log(turretMessage);
                    return;
                }

                if (victimPlayer.lastAttacker is BradleyAPC || victimPlayer.lastAttacker?.ShortPrefabName == "maincannonshell")
                {
                    var apcMessage = Lang("Log Entity Attack1", CleanName(victimPlayer), "Bradley APC", "", dmgPlayer, victimPlayer.lastAttacker.IsValid() ? GetDistanceAttacker(victimPlayer, victimPlayer.lastAttacker) : "", victimPlayer.transform.position, victimPlayer.lastAttacker.IsValid() ? victimPlayer.lastAttacker.transform.position.ToString() : "", GetBodypartName(info));
                    if (configData.HurtLog.EvP.Put && configData.LogMain.Damage.Put) Puts(apcMessage);
                    if (configData.HurtLog.EvP.Log && configData.LogMain.Damage.Log) Log(apcMessage);
                    return;
                }
                if (victimPlayer.lastAttacker is PatrolHelicopter || victimPlayer.lastAttacker?.ShortPrefabName == "rocket_heli")
                {
                    var heliMessage = Lang("Log Entity Attack1", CleanName(victimPlayer), "Patrol Helicopter", "", dmgPlayer, victimPlayer.lastAttacker.IsValid() ? GetDistanceAttacker(victimPlayer, victimPlayer.lastAttacker) : "", victimPlayer.transform.position, victimPlayer.lastAttacker.IsValid() ? victimPlayer.lastAttacker.transform.position.ToString() : "", GetBodypartName(info));
                    if (configData.HurtLog.EvP.Put && configData.LogMain.Damage.Put) Puts(heliMessage);
                    if (configData.HurtLog.EvP.Log && configData.LogMain.Damage.Log) Log(heliMessage);
                    return;
                }
                if (victimPlayer.lastAttacker is ModularCar)
                {
                    ModularCar vehicle = victimPlayer.lastAttacker as ModularCar;
                    BasePlayer driver = vehicle.GetDriver();
                    if (driver != null)
                    {
                        var carmessage = Lang("Log Entity Attack1", CleanName(victimPlayer), CleanName(driver), "Modular Car", dmgPlayer, "", victimPlayer.transform.position, driver.transform.position, GetBodypartName(info));
                        if (configData.HurtLog.PvP.Log && configData.LogMain.Damage.Log) Log(carmessage);
                        if (configData.HurtLog.PvP.Put && configData.LogMain.Damage.Put) Puts(carmessage);
                        return;
                    }
                }
            }

            if (victimPlayer.lastAttacker == null && info.Initiator == null) return;

            string damage = info?.Initiator?.GetItem()?.info?.displayName?.english ?? info?.WeaponPrefab?.GetItem()?.info?.displayName?.english ?? FireCheck(info) ?? info.Initiator?.ShortPrefabName ?? info?.WeaponPrefab?.ShortPrefabName ?? info?.InitiatorPlayer?.ToString() ?? victimPlayer.lastAttacker?.ShortPrefabName?.ToString() ?? info.Weapon?.GetParentEntity()?.ShortPrefabName ?? victimPlayer.lastAttacker?.ToString() ?? victimPlayer.lastDamage.ToString() ?? "Unknown";
            var othermessage = Lang("Log Entity Attack1", CleanName(victimPlayer), info?.Initiator?.GetItem()?.info?.displayName?.english ?? info?.WeaponPrefab?.GetItem()?.info?.displayName?.english ?? FireCheck(info) ?? info.Initiator?.ShortPrefabName ?? info?.WeaponPrefab?.ShortPrefabName ?? info?.InitiatorPlayer?.ToString() ?? victimPlayer.lastAttacker?.ShortPrefabName?.ToString() ?? info.Weapon?.GetParentEntity()?.ShortPrefabName ?? victimPlayer.lastAttacker?.ToString() ?? victimPlayer.lastDamage.ToString() ?? "Unknown", "", dmgPlayer, info.Initiator.IsValid() ? GetDistance(victimPlayer, info) : "", victimPlayer.transform.position, info.Initiator.IsValid() ? info.Initiator.transform.position.ToString() : victimPlayer.lastAttacker.IsValid() ? victimPlayer.lastAttacker.transform.position.ToString() : "", GetBodypartName(info));
            if (damage == "Generic" || damage == "player") return; // Catching Some random Damage that doest get caught above
            if (configData.HurtLog.EvP.Log && configData.LogMain.Damage.Log) Log(othermessage);
            if (configData.HurtLog.EvP.Put && configData.LogMain.Damage.Put) Puts(othermessage);
            if (configData.Debug) Log($"|Other-Player| Damage: {victimPlayer.lastDamage.ToString() ?? "No Damage"}  |  Attacker: {info.Initiator?.ShortPrefabName}  |  Victim: {victimPlayer}");
        }

        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (entity == null || info == null) return;

            if (info.InitiatorPlayer != null)
            {
                if (info.InitiatorPlayer.userID.IsSteamId() && info.InitiatorPlayer != null)
                {
                    var dmg = Math.Round(info.damageTypes.Total(), 2).ToString();
                    if (entity is BasePlayer && entity.ToPlayer().UserIDString.IsSteamId() && !entity.IsNpc)
                    {
                        var victim = entity as BasePlayer;
                        if (victim == null) return;
                        if (victim == info.InitiatorPlayer)
                        {
                            if (configData.Debug) Log($"|SELF-Death| Weapon: {info.Weapon?.GetItem()?.info?.displayName?.english ?? info.WeaponPrefab?.GetItem()?.info?.displayName?.english ?? info.WeaponPrefab?.ToString() ?? FireCheck(info) ?? victim.lastDamage.ToString() ?? "Unknown"}  |  Weapon2: {info.WeaponPrefab}  |  Damage: {victim.lastDamage.ToString()}  |  Attacker: {info.InitiatorPlayer}  |  Victim: {victim}");
                            if (configData.DeathLog.PvPD.Log && configData.LogMain.Death.Log) Log(Lang("Log Player Kill Himself1", CleanName(info.InitiatorPlayer), entity.lastDamage.ToString() == "Suicide" ? "" : $"{Lang("Log Weapon")} '{info.Weapon?.GetItem()?.info?.displayName?.english ?? info.WeaponPrefab?.GetItem()?.info?.displayName?.english ?? info.WeaponPrefab?.ToString() ?? FireCheck(info) ?? info.InitiatorPlayer?.GetHeldEntity()?.GetItem()?.info?.displayName?.english ?? "Unknown"}' ", $"{(dmg == "1000" ? null : $"{Lang("Log Damage")} {dmg} {Lang("Log Suicide")} ")}", $"{Lang("Log At")} {victim.transform.position}"));
                            if (configData.DeathLog.PvPD.Put && configData.LogMain.Death.Put) Puts(Lang("Log Player Kill Himself1", CleanName(info.InitiatorPlayer), entity.lastDamage.ToString() == "Suicide" ? "" : $"{Lang("Log Weapon")} '{info.Weapon?.GetItem()?.info?.displayName?.english ?? info.WeaponPrefab?.GetItem()?.info?.displayName?.english ?? info.WeaponPrefab?.ToString() ?? FireCheck(info) ?? info.InitiatorPlayer?.GetHeldEntity()?.GetItem()?.info?.displayName?.english ?? "Unknown"}' ", $"{(dmg == "1000" ? null : $"{Lang("Log Damage")} {dmg} {Lang("Log Suicide")} ")}", $"{Lang("Log At")} {victim.transform.position}"));
                            return;
                        }
                        var pvpmessage = Lang("Log Entity Death1", CleanName(victim), CleanName(info.InitiatorPlayer ?? victim.lastAttacker.ToPlayer()), $"{Lang("Log Weapon")} '{info.Weapon?.GetItem()?.info?.displayName?.english ?? info.WeaponPrefab?.GetItem()?.info?.displayName?.english ?? info.WeaponPrefab?.ToString() ?? FireCheck(info) ?? info.InitiatorPlayer?.GetHeldEntity()?.GetItem()?.info?.displayName?.english ?? victim.lastDamage.ToString() ?? "Unknown"}' ", GetDistance(entity, info), entity.transform.position, info.InitiatorPlayer.transform.position);
                        if (configData.DeathLog.PvPD.Log && configData.LogMain.Death.Log) Log(pvpmessage);
                        if (configData.DeathLog.PvPD.Put && configData.LogMain.Death.Put) Puts(pvpmessage);
                        if (configData.Debug) Log($"|Player-Player Death| Damage: {victim.lastDamage.ToString() ?? "No Damage"}  |  Attacker: {info.InitiatorPlayer}  |  Victim: {victim} | Weapon: {info.Weapon?.GetItem()?.info?.displayName?.english ?? info.WeaponPrefab?.GetItem()?.info?.displayName?.english ?? info.WeaponPrefab?.ToString() ?? FireCheck(info) ?? victim.lastDamage.ToString() ?? "Unknown"}");
                        return;
                    }

                    if (entity.IsNpc || (entity is BasePlayer && !entity.ToPlayer().UserIDString.IsSteamId())) //Some Plugins use Weird Classes that arent detected by IsNPC, I know IsSteamId is redundant but just covering basis
                    {
                        if (entity is BaseAnimalNPC)
                        {
                            if (!configData.DeathLog.PvAD.Put && !configData.DeathLog.PvAD.Log) return;
                            var animalmessage = Lang("Log Entity Death1", entity.ShortPrefabName + "[NPC]", CleanName(info.InitiatorPlayer ?? entity.lastAttacker.ToPlayer()), $"{Lang("Log Weapon")} '{info.Weapon?.GetItem()?.info?.displayName?.english ?? info.WeaponPrefab?.GetItem()?.info?.displayName?.english ?? info.WeaponPrefab?.ToString() ?? FireCheck(info) ?? info.Initiator?.ShortPrefabName ?? info.InitiatorPlayer?.GetHeldEntity()?.GetItem()?.info?.displayName?.english ?? info.damageTypes.GetMajorityDamageType().ToString() ?? "Unknown"}' ", GetDistance(entity, info), entity.transform.position, info.InitiatorPlayer.transform.position);
                            if (configData.DeathLog.PvAD.Log && configData.LogMain.Death.Log) Log(animalmessage);
                            if (configData.DeathLog.PvAD.Put && configData.LogMain.Death.Put) Puts(animalmessage);
                            return;
                        }

                        var npc = entity as BasePlayer;
                        if (npc != null)
                        {
                            if (!configData.DeathLog.PvND.Put && !configData.DeathLog.PvND.Log) return;
                            var pvpmessage = Lang("Log Entity Death1", npc.displayName + "[NPC]", CleanName(info.InitiatorPlayer ?? entity.lastAttacker?.ToPlayer()), $"{Lang("Log Weapon")} '{info.Weapon?.GetItem()?.info?.displayName?.english ?? info.WeaponPrefab?.GetItem()?.info?.displayName?.english ?? info.WeaponPrefab?.ToString() ?? FireCheck(info) ?? info.Initiator?.ShortPrefabName ?? info.InitiatorPlayer?.GetHeldEntity()?.GetItem()?.info?.displayName?.english ?? info.damageTypes.GetMajorityDamageType().ToString() ?? "Unknown"}' ", GetDistance(entity, info), entity.transform.position, info.InitiatorPlayer.transform.position);
                            if (configData.DeathLog.PvND.Log && configData.LogMain.Death.Log) Log(pvpmessage);
                            if (configData.DeathLog.PvND.Put && configData.LogMain.Death.Put) Puts(pvpmessage);
                            if (configData.Debug) Log($"|PLAYER-NPC Death| Weapon: {info.Weapon?.GetItem()?.info?.displayName?.english ?? info.WeaponPrefab?.ToString() ?? info.Initiator?.ShortPrefabName}  |  Weapon2: {info.WeaponPrefab?.ToString() ?? "unable"}  |  Damage:  |  Attacker: {info.InitiatorPlayer} {info.Initiator.transform.position}  |  Victim: {entity.ShortPrefabName ?? "No Victim"} {entity.transform.position} | Distance: {GetDistance(entity, info)}");
                            return;
                        }

                        var npcp = entity as NPCPlayer;
                        if (npcp != null)
                        {
                            if (!configData.DeathLog.PvND.Put && !configData.DeathLog.PvND.Log) return;
                            var pvpmessage = Lang("Log Entity Death1", npcp.displayName + "[NPC]", CleanName(info.InitiatorPlayer ?? entity.lastAttacker?.ToPlayer()), $"{Lang("Log Weapon")} '{info.Weapon?.GetItem()?.info?.displayName?.english ?? info.WeaponPrefab?.GetItem()?.info?.displayName?.english ?? info.WeaponPrefab?.ToString() ?? FireCheck(info) ?? info.Initiator?.ShortPrefabName ?? info.InitiatorPlayer?.GetHeldEntity()?.GetItem()?.info?.displayName?.english ?? info.damageTypes.GetMajorityDamageType().ToString() ?? "Unknown"}' ", GetDistance(entity, info), entity.transform.position, info.InitiatorPlayer.transform.position);
                            if (configData.DeathLog.PvND.Log && configData.LogMain.Death.Log) Log(pvpmessage);
                            if (configData.DeathLog.PvND.Put && configData.LogMain.Death.Put) Puts(pvpmessage);
                            if (configData.Debug) Log($"|PLAYER-NPC Death| Weapon: {info.Weapon?.GetItem()?.info?.displayName?.english ?? info.WeaponPrefab?.ToString() ?? info.Initiator?.ShortPrefabName}  |  Weapon2: {info.WeaponPrefab?.ToString() ?? "unable"}  |  Damage:  |  Attacker: {info.InitiatorPlayer} {info.Initiator.transform.position}  |  Victim: {entity.ShortPrefabName ?? "No Victim"} {entity.transform.position} | Distance: {GetDistance(entity, info)}");
                            return;
                        }
                        return;
                    }
                }
            }

            var victimPlayer = entity as BasePlayer;
            if (victimPlayer == null) return;
            if (!victimPlayer.UserIDString.IsSteamId()) return;

            if (info.Initiator is BaseAnimalNPC)
            {
                var animalmessage = Lang("Log Entity Death1", CleanName(victimPlayer), $"{info.Initiator?.ShortPrefabName ?? victimPlayer.lastAttacker?.ShortPrefabName ?? "Unknown"}[NPC]", "", GetDistance(victimPlayer, info), victimPlayer.transform.position, info.Initiator.IsValid() ? info.Initiator.transform.position.ToString() : "");
                if (configData.DeathLog.AvPD.Log && configData.LogMain.Death.Log) Log(animalmessage);
                if (configData.DeathLog.AvPD.Put && configData.LogMain.Death.Put) Puts(animalmessage);
                return;
            }
            if (info.Initiator is ScientistNPC || info.Initiator is Zombie || info.Initiator is ScarecrowNPC || info.Initiator is NPCPlayer)
            {
                var scientistmessage = Lang("Log Entity Death1", CleanName(victimPlayer), $"{info.InitiatorPlayer?.displayName ?? info.Initiator?.name ?? victimPlayer.lastAttacker?.name ?? victimPlayer.lastAttacker?.ShortPrefabName ?? "Unknown"}[NPC]", $"{Lang("Log Weapon")} '{info.Weapon?.GetItem()?.info?.displayName?.english ?? info.WeaponPrefab?.GetItem()?.info?.displayName?.english ?? info.WeaponPrefab?.ToString() ?? info.InitiatorPlayer?.GetHeldEntity()?.GetItem()?.info?.displayName?.english ?? victimPlayer.lastDamage.ToString()}' ", GetDistance(victimPlayer, info), victimPlayer.transform.position, info.Initiator.IsValid() ? info.Initiator.transform.position.ToString() : "");
                if (configData.DeathLog.NvPD.Log && configData.LogMain.Death.Log) Log(scientistmessage);
                if (configData.DeathLog.NvPD.Put && configData.LogMain.Death.Put) Puts(scientistmessage);
                return;
            }
            if (info.Initiator is NPCAutoTurret)
            {
                var npcturretmessage = Lang("Log Entity Death1", CleanName(victimPlayer), "Outpost Sentry", "", info.Initiator.IsValid() ? GetDistance(victimPlayer, info) : "", victimPlayer.transform.position, info.Initiator.IsValid() ? info.Initiator.transform.position.ToString() : "");
                if (configData.DeathLog.EvPD.Log && configData.LogMain.Death.Log) Log(npcturretmessage);
                if (configData.DeathLog.EvPD.Put && configData.LogMain.Death.Put) Puts(npcturretmessage);
                return;
            }
            if (info.Initiator is AutoTurret)
            {
                var turret = info.Initiator as AutoTurret;
                var turretMessage = Lang("Log Entity Death1", CleanName(victimPlayer), "Auto Turret", $"{Lang("Log Weapon")} '{info.WeaponPrefab?.GetItem()?.info?.displayName?.english ?? info.WeaponPrefab?.GetItem()?.info?.displayName?.english ?? info.WeaponPrefab?.ToString()}' ", info.Initiator.IsValid() ? GetDistance(victimPlayer, info) : "", victimPlayer.transform.position, info.Initiator.IsValid() ? info.Initiator.transform.position.ToString() : "");
                if (configData.DeathLog.EvPD.Put && configData.LogMain.Death.Put) Puts(turretMessage);
                if (configData.DeathLog.EvPD.Log && configData.LogMain.Death.Log) Log(turretMessage);
                return;
            }

            if (info.Initiator is BradleyAPC || info?.WeaponPrefab?.ShortPrefabName == "maincannonshell")
            {
                var apcMessage = Lang("Log Entity Death1", CleanName(victimPlayer), "Bradley APC", "", info.Initiator.IsValid() ? GetDistance(victimPlayer, info) : "", victimPlayer.transform.position, info.Initiator.IsValid() ? info.Initiator.transform.position.ToString() : "");
                if (configData.DeathLog.EvPD.Put && configData.LogMain.Death.Put) Puts(apcMessage);
                if (configData.DeathLog.EvPD.Log && configData.LogMain.Death.Log) Log(apcMessage);
                return;
            }
            if (info.Initiator is PatrolHelicopter || info?.WeaponPrefab?.ShortPrefabName == "rocket_heli")
            {
                var heliMessage = Lang("Log Entity Death1", CleanName(victimPlayer), "Patrol Helicopter", "", info.Initiator.IsValid() ? GetDistance(victimPlayer, info) : "", victimPlayer.transform.position, info.Initiator.IsValid() ? info.Initiator.transform.position.ToString() : "");
                if (configData.DeathLog.EvPD.Put && configData.LogMain.Death.Put) Puts(heliMessage);
                if (configData.DeathLog.EvPD.Log && configData.LogMain.Death.Log) Log(heliMessage);
                return;
            }
            if (info.Initiator is ModularCar)
            {
                ModularCar vehicle = info.Initiator as ModularCar;
                BasePlayer driver = vehicle.GetDriver();
                if (driver != null)
                {
                    var carmessage = Lang("Log Entity Death1", CleanName(victimPlayer), CleanName(driver), "Modular Car", "", victimPlayer.transform.position, driver.transform.position);
                    if (configData.DeathLog.PvPD.Log && configData.LogMain.Death.Log) Log(carmessage);
                    if (configData.DeathLog.PvPD.Put && configData.LogMain.Death.Put) Puts(carmessage);
                    return;
                }
            }

            var othermessage = Lang("Log Entity Death1", CleanName(victimPlayer), info.Initiator?.ShortPrefabName ?? info?.WeaponPrefab?.ShortPrefabName ?? victimPlayer.lastAttacker?.ShortPrefabName?.ToString() ?? info.Weapon?.GetParentEntity()?.ShortPrefabName ?? victimPlayer.lastDamage.ToString() ?? "Unknown", "", info.Initiator.IsValid() ? GetDistance(victimPlayer, info) : "", victimPlayer.transform.position, info.Initiator.IsValid() ? info.Initiator.transform.position.ToString() : victimPlayer.lastAttacker.IsValid() ? victimPlayer.lastAttacker.transform.position.ToString() : "");
            if (configData.DeathLog.EvPD.Log && configData.LogMain.Death.Log) Log(othermessage);
            if (configData.DeathLog.EvPD.Put && configData.LogMain.Death.Put) Puts(othermessage);
            if (configData.Debug) Log($"|Other-PlayerDeath| Damage: {victimPlayer.lastDamage.ToString() ?? "No Damage"}  |  Attacker: {info.Initiator?.ShortPrefabName}  |  Victim: {victimPlayer}");
        }

        private void OnPlayerWound(BasePlayer victimPlayer, HitInfo info)
        {
            if (victimPlayer == null || info == null) return;
            if (info.InitiatorPlayer != null)
            {
                if (info.InitiatorPlayer.userID.IsSteamId() && info.InitiatorPlayer != null)
                {
                    var othermessage = Lang("Log Entity Wounded1", CleanName(victimPlayer), CleanName(info.InitiatorPlayer), $"{Lang("Log Weapon")} '{info.Weapon?.GetItem()?.info?.displayName?.english ?? info.WeaponPrefab?.ToString() ?? FireCheck(info) ?? info.Initiator?.ShortPrefabName ?? info.damageTypes?.GetMajorityDamageType().ToString() ?? info.InitiatorPlayer?.GetHeldEntity()?.GetItem()?.info?.displayName?.english ?? "Unknown"}' ", GetDistance(victimPlayer, info), victimPlayer.transform.position, info.InitiatorPlayer.transform.position);
                    if (configData.LogMain.Wound.Log) Log(othermessage);
                    if (configData.LogMain.Wound.Put) Puts(othermessage);
                    if (configData.Debug) Log($"|Player-Player Wound| Damage: {victimPlayer.lastDamage.ToString() ?? "No Damage"}  |  Attacker: {info.InitiatorPlayer}  |  Victim: {victimPlayer}");
                    return;
                }
            }
            if (CheckDamage(victimPlayer) != null && victimPlayer.UserIDString.IsSteamId())
            {
                if (configData.LogMain.Wound.Log) Log(Lang("Log Entity Wounded1", victimPlayer, CheckDamage(victimPlayer), "", "", victimPlayer.transform.position, ""));
                if (configData.LogMain.Wound.Put) Puts(Lang("Log Entity Wounded1", victimPlayer, CheckDamage(victimPlayer), "", "", victimPlayer.transform.position, ""));
                return;
            }

            if (info.Initiator is BaseAnimalNPC)
            {
                var animalmessage = Lang("Log Entity Wounded1", CleanName(victimPlayer), $"{info.Initiator?.ShortPrefabName ?? victimPlayer.lastAttacker?.ShortPrefabName ?? "Unknown"}[NPC]", "", GetDistance(victimPlayer, info), victimPlayer.transform.position, info.Initiator.IsValid() ? info.Initiator.transform.position.ToString() : "");
                if (configData.HurtLog.AvP.Log && configData.LogMain.Damage.Log) Log(animalmessage);
                if (configData.HurtLog.AvP.Put && configData.LogMain.Damage.Put) Puts(animalmessage);
                return;
            }
            if (info.Initiator is ScientistNPC || info.Initiator is Zombie || info.Initiator is ScarecrowNPC || info.Initiator is NPCPlayer)
            {
                var scientistmessage = Lang("Log Entity Wounded1", CleanName(victimPlayer), $"{info.InitiatorPlayer?.displayName ?? info.Initiator?.name ?? victimPlayer.lastAttacker?.name ?? victimPlayer.lastAttacker?.ShortPrefabName ?? "Unknown"}[NPC]", $"{Lang("Log Weapon")} '{info.Weapon?.GetItem()?.info.displayName?.english ?? info.WeaponPrefab?.GetItem()?.info?.displayName?.english ?? info.WeaponPrefab?.ToString() ?? info.WeaponPrefab?.ShortPrefabName ?? info.InitiatorPlayer?.GetHeldEntity()?.GetItem()?.info?.displayName?.english ?? victimPlayer.lastDamage.ToString()}' ", GetDistance(victimPlayer, info), victimPlayer.transform.position, info.Initiator.IsValid() ? info.Initiator.transform.position.ToString() : "");
                if (configData.HurtLog.NvP.Log && configData.LogMain.Damage.Log) Log(scientistmessage);
                if (configData.HurtLog.NvP.Put && configData.LogMain.Damage.Put) Puts(scientistmessage);
                return;
            }

            if (info.Initiator is AutoTurret)
            {
                var Turret = info.Initiator as AutoTurret;
                var turretMessage = Lang("Log Entity Wounded1", CleanName(victimPlayer), "Auto Turret", $"{Lang("Log Weapon")} '{info.WeaponPrefab?.GetItem()?.info?.displayName?.english ?? info.WeaponPrefab?.GetItem()?.info?.displayName?.english ?? Turret.AttachedWeapon?.GetItem()?.info?.displayName?.english ?? info.WeaponPrefab?.name}' ", info.Initiator.IsValid() ? GetDistance(victimPlayer, info) : "", victimPlayer.transform.position, info.Initiator.IsValid() ? info.Initiator.transform.position.ToString() : "");
                if (configData.HurtLog.EvP.Put && configData.LogMain.Damage.Put) Puts(turretMessage);
                if (configData.HurtLog.EvP.Log && configData.LogMain.Damage.Log) Log(turretMessage);
                return;
            }

            var othermessageent = Lang("Log Entity Wounded1", CleanName(victimPlayer), info?.Initiator?.GetItem()?.info?.displayName?.english ?? info?.WeaponPrefab?.GetItem()?.info?.displayName?.english ?? info.Initiator?.ShortPrefabName ?? info?.WeaponPrefab?.ShortPrefabName ?? info?.InitiatorPlayer?.ToString() ?? victimPlayer.lastAttacker?.ShortPrefabName?.ToString() ?? info.Weapon?.GetParentEntity()?.ShortPrefabName ?? FireCheck(info) ?? victimPlayer.lastAttacker?.ToString() ?? victimPlayer.lastDamage.ToString() ?? "Unknown", "", info.Initiator.IsValid() ? GetDistance(victimPlayer, info) : "", victimPlayer.transform.position, info.Initiator.IsValid() ? info.Initiator.transform.position.ToString() : "");
            if (configData.LogMain.Wound.Log) Log(othermessageent);
            if (configData.LogMain.Wound.Put) Puts(othermessageent);
            if (configData.Debug) Log($"|Other-Player Wound| Damage: {victimPlayer.lastDamage.ToString() ?? "No Damage"}   |  Attacker:  {info.Initiator?.ShortPrefabName}  |  Victim: {victimPlayer}");
        }
        #endregion Combat

        #region Respawn
        private void OnPlayerRespawned(BasePlayer player)
        {
            if (player == null) return;
            if (configData.LogMain.Respawns.Log) Log(Lang("Log Player Respawning1", player.displayName ?? player.name, player.UserIDString, $"{Lang("Log At")} {player.transform?.position.ToString() ?? ""}"));
            if (configData.LogMain.Respawns.Put) Puts(Lang("Log Player Respawning1", player.displayName ?? player.name, player.UserIDString, $"{Lang("Log At")} {player.transform?.position.ToString() ?? ""}"));
        }
        #endregion Respawn
        #endregion Hooks

        #region Helpers
        private string CleanName(BasePlayer entity) => $"{entity.displayName}{CheckSleeping(entity)}({entity.UserIDString})";
        private string CheckDamage(BasePlayer entity)
        {
            var damage = entity.lastDamage.ToString();
            if (damage == null) return null;

            if (DamageTypes.Contains(damage))
                return damage;
            return null;
        }

        private bool CheckDamageBL(BasePlayer entity)
        {
            var damage = entity.lastDamage.ToString();
            if (damage == null) return false;

            return DamageTypes.Contains(damage);
        }

        private string CheckSleeping(BasePlayer player)
        {
            if (player.IsSleeping() && configData.LogMain.Sleeping)
                return "(*Sleeping*)";
            return "";
        }

        private string FireCheck(HitInfo info)
        {
            if (info.damageTypes.Has(DamageType.Heat))
            {
                if (info.Initiator.ShortPrefabName != null)
                {
                    switch (info.Initiator.ShortPrefabName) // Get the Name for some Fire Creators
                    {
                        case "flameturret.deployed":
                            return "Flameturret";
                        case "flameturret_fireball":
                            return "Flameturret Flames";
                        case "campfire":
                            return "Campfire";
                        case "skull_fire_pit":
                            return "Skull Firepit";
                        case "campfire_static":
                            return "Campfire";
                        case "fireplace.deployed":
                            return "Stone Fireplace";
                        case "fireball_small_shotgun":
                            return "12 Gauge Incendiary Flame";
                        case "fireball_small_arrow":
                            return "Fire Arrow Flame";
                        case "fireball_small":
                            return "Incendiary Ammo Flame";
                        case "fireball_small_molotov":
                            return "Molotov Flame";
                    }
                }

                var flame = info.WeaponPrefab as FireBall;
                if (flame != null)
                {
                    return flame.creatorEntity?.ToString() ?? "FireBall";
                }

                var fire = info.Initiator as FireBall;
                if (fire != null)
                {
                    return fire.creatorEntity?.ToString() ?? "FireBall";
                }
                return "FireBall";
            }
            return null;
        }

        private void Log(string text) => LogToFile("Combat", $"[{DateTime.Now}] {text.Replace("{", "").Replace("}", "")}", this);

        private string GetDistance(BaseEntity entity, HitInfo info)
        {
            float distance = info.Initiator.Distance(entity);
            return distance.ToString("0").Equals("0") ? "" : $"{Lang("Log Distance F")} {distance.ToString("0")} {Lang("Log Distance M")}";
        }

        private string GetDistanceAttacker(BaseEntity entity, BaseEntity info)
        {
            float distance = info.Distance(entity);
            return distance.ToString("0").Equals("0") ? "" : $"{Lang("Log Distance F")} {distance.ToString("0")} {Lang("Log Distance M")}";
        }
        private string GetBodypartName(HitInfo hitInfo)
        {
            if (configData.LogMain.BodyPart)
            {
                var hitArea = hitInfo?.boneArea ?? (HitArea)(-1);
                string bodypart = (int)hitArea == -1 ? "Body" : hitArea.ToString();
                return $"{Lang("Log BodyPart")} {bodypart}";
            }
            return "";
        }

        #endregion Helpers

        #region Language
        private string Lang(string key, params object[] args) => string.Format(lang.GetMessage(key, this), args);
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                /// -- Combat -- ///
                ["Log Player Healing1"] = "'{0}({1})' used a '{2}' {3} with a current health of {4}",
                ["Log Player Respawning1"] = "'{0}({1})' has respawned {2}",
                ["Log Entity Attack1"] = "'{0}{5}' was attacked by '{1}{6}' {2}for {3} damage{4}{7}",
                ["Log Player Hurt Himself1"] = "'{0}' hurt himself {1}for {2} damage {3}",
                ["Log Entity Death1"] = "'{0}{4}' was killed by '{1}{5}' {2}{3}",
                ["Log Player Kill Himself1"] = "'{0}' committed suicide {1}{2}{3}",
                ["Log Entity Wounded1"] = "'{0}{4}' was downed by '{1}{5}' {2}{3}",
                ["Log Player Hurt Other"] = "'{0}' was killed by '{1}' {2}",

                /// -- Misc -- ///
                ["Log Weapon"] = "with a",
                ["Log BodyPart"] = " in the",
                ["Log Suicide"] = "damage",
                ["Log Distance F"] = " from",
                ["Log Distance M"] = "meters",
                ["Log Damage"] = "for",
                ["Log At"] = "at",
            }, this);
        }
        #endregion Language

        #region Config
        private ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Combat Logging Main")]
            public LoggingMain LogMain { get; set; }
            public class LoggingMain
            {
                [JsonProperty(PropertyName = "Log Combat Damage (Will Override All)")]
                public Options Damage { get; set; }

                [JsonProperty(PropertyName = "Log Combat Death (Will Override All)")]
                public Options Death { get; set; }

                [JsonProperty(PropertyName = "Log Healing Items")]
                public Options Healing { get; set; }

                [JsonProperty(PropertyName = "Log Player Downed")]
                public Options Wound { get; set; }

                [JsonProperty(PropertyName = "Show if Player is Sleeping in Log (Only for Attacking not Death)")]
                public bool Sleeping { get; set; }

                [JsonProperty(PropertyName = "Log Players Getting Attacked while Sleeping")]
                public bool LogSleeping { get; set; }

                [JsonProperty(PropertyName = "Show Body Part Hit")]
                public bool BodyPart { get; set; }

                [JsonProperty(PropertyName = "Log Respawns")]
                public Options Respawns { get; set; }

                public class Options
                {
                    [JsonProperty(PropertyName = "Log to File")]
                    public bool Log { get; set; }

                    [JsonProperty(PropertyName = "Log to Console")]
                    public bool Put { get; set; }
                }
            }

            [JsonProperty(PropertyName = "Combat Hurt Logging")]
            public HurtLogging HurtLog { get; set; }
            public class HurtLogging
            {
                [JsonProperty(PropertyName = "Log Player Attacking Player")]
                public Options PvP { get; set; }

                [JsonProperty(PropertyName = "Log Animal Attacking Player")]
                public Options AvP { get; set; }

                [JsonProperty(PropertyName = "Log NPC Attacking Player")]
                public Options NvP { get; set; }

                [JsonProperty(PropertyName = "Log Player Attacking NPC")]
                public Options PvN { get; set; }

                [JsonProperty(PropertyName = "Log Player Attacking Animal")]
                public Options PvA { get; set; }

                [JsonProperty(PropertyName = "Log Entity Attacking Player")]
                public Options EvP { get; set; }

                public class Options
                {
                    [JsonProperty(PropertyName = "Log to File")]
                    public bool Log { get; set; }

                    [JsonProperty(PropertyName = "Log to Console")]
                    public bool Put { get; set; }
                }
            }

            [JsonProperty(PropertyName = "Combat Death Logging")]
            public DeathLogging DeathLog { get; set; }
            public class DeathLogging
            {
                [JsonProperty(PropertyName = "Log Player killing Player")]
                public Options PvPD { get; set; }

                [JsonProperty(PropertyName = "Log Animal killing Player")]
                public Options AvPD { get; set; }

                [JsonProperty(PropertyName = "Log NPC killing Player")]
                public Options NvPD { get; set; }

                [JsonProperty(PropertyName = "Log Player killing NPC")]
                public Options PvND { get; set; }

                [JsonProperty(PropertyName = "Log Player killing Animal")]
                public Options PvAD { get; set; }

                [JsonProperty(PropertyName = "Log Entity killing Player")]
                public Options EvPD { get; set; }

                [JsonProperty(PropertyName = "Log Other Player Death")]
                public Options OtherDeath { get; set; }

                public class Options
                {
                    [JsonProperty(PropertyName = "Log to File")]
                    public bool Log { get; set; }

                    [JsonProperty(PropertyName = "Log to Console")]
                    public bool Put { get; set; }
                }
            }

            [JsonProperty(PropertyName = "Print Debug Info To Console (Dev)")]
            public bool Debug { get; set; }

            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();
            if (configData.Version < Version)
                UpdateConfigValues();
            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                LogMain = new ConfigData.LoggingMain
                {
                    Sleeping = true,
                    LogSleeping = true,
                    BodyPart = true,
                    Damage = new ConfigData.LoggingMain.Options
                    {
                        Log = true,
                        Put = true
                    },
                    Wound = new ConfigData.LoggingMain.Options
                    {
                        Log = true,
                        Put = true
                    },
                    Death = new ConfigData.LoggingMain.Options
                    {
                        Log = true,
                        Put = true
                    },
                    Healing = new ConfigData.LoggingMain.Options
                    {
                        Log = false,
                        Put = false
                    },
                    Respawns = new ConfigData.LoggingMain.Options
                    {
                        Log = true,
                        Put = true
                    },
                },
                HurtLog = new ConfigData.HurtLogging
                {
                    PvP = new ConfigData.HurtLogging.Options
                    {
                        Log = true,
                        Put = true
                    },
                    PvA = new ConfigData.HurtLogging.Options
                    {
                        Log = true,
                        Put = true
                    },
                    AvP = new ConfigData.HurtLogging.Options
                    {
                        Log = true,
                        Put = true
                    },
                    NvP = new ConfigData.HurtLogging.Options
                    {
                        Log = true,
                        Put = true
                    },
                    EvP = new ConfigData.HurtLogging.Options
                    {
                        Log = true,
                        Put = true
                    },
                    PvN = new ConfigData.HurtLogging.Options
                    {
                        Log = true,
                        Put = true
                    },
                },
                DeathLog = new ConfigData.DeathLogging
                {
                    PvPD = new ConfigData.DeathLogging.Options
                    {
                        Log = true,
                        Put = true
                    },
                    PvAD = new ConfigData.DeathLogging.Options
                    {
                        Log = true,
                        Put = true
                    },
                    AvPD = new ConfigData.DeathLogging.Options
                    {
                        Log = true,
                        Put = true
                    },
                    NvPD = new ConfigData.DeathLogging.Options
                    {
                        Log = true,
                        Put = true
                    },
                    EvPD = new ConfigData.DeathLogging.Options
                    {
                        Log = true,
                        Put = true
                    },
                    PvND = new ConfigData.DeathLogging.Options
                    {
                        Log = true,
                        Put = true
                    },
                    OtherDeath = new ConfigData.DeathLogging.Options
                    {
                        Log = true,
                        Put = true
                    }
                },
                Debug = false,
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();
            configData.Version = Version;
            PrintWarning("Config update completed!");
        }
        #endregion Config
    }
}

// --- End of file: CombatLogger.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/coloured-chat ---
// --- Original File Path: C/ColouredChat/ColouredChat.cs ---

ï»¿using System;
using System.Linq;
using System.Text.RegularExpressions;
using System.Collections.Generic;
using System.Text;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using ConVar;
using UnityEngine;
using CompanionServer;
using Pool = Facepunch.Pool;
using Random = System.Random;

namespace Oxide.Plugins
{
    [Info("Coloured Chat", "collect_vood", "2.2.87")]
    [Description("Allows players to change their name & message colour in chat")]
    class ColouredChat : CovalencePlugin
    {
        [PluginReference]
        private Plugin BetterChat, BetterChatMute, ZoneManager;

        #region Fields
        
        private readonly StringBuilder _sharedStringBuilder = new StringBuilder();

        private const string ColourRegex = "^#(?:[0-9a-fA-f]{3}){1,2}$";
        private const string ChatFormat = "{0}: {1}";

        #endregion

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>()
            {
                { "NoPermission", "You don't have permission to use this command." },
                { "NoPermissionSetOthers", "You don't have permission to set other players {0} colours." },
                { "NoPermissionGradient", "You don't have permission to use {0} gradients." },
                { "NoPermissionRandom", "You don't have permission to use random {0} colours." },
                { "NoPermissionRainbow", "You don't have permission to use the rainbow colours." },
                { "IncorrectGradientUsage", "Incorrect usage! To use gradients please use /{0} gradient hexCode1 hexCode2 ...</color>" },
                { "IncorrectGradientUsageArgs", "Incorrect usage! A gradient requires at least two different valid colours!"},
                { "GradientChanged", "{0} gradient changed to {1}!"},
                { "GradientChangedFor", "{0}'s gradient {1} colour changed to {2}!"},
                { "IncorrectUsage", "Incorrect usage! /{0} <colour>\nFor detailed help do /{1}" },
                { "IncorrectSetUsage", "Incorrect set usage! /{0} set <playerIdOrName> <colourOrColourArgument>\nFor a list of colours do /colours" },
                { "PlayerNotFound", "Player {0} was not found." },
                { "InvalidCharacters", "The character '{0}' is not allowed in colours. Please remove it." },
                { "ColourRemoved", "{0} colour removed!" },
                { "ColourRemovedFor", "{0}'s {1} colour was removed!" },
                { "ColourChanged", "{0} colour changed to <color={1}>{1}</color>!" },
                { "ColourChangedFor", "{0}'s {1} colour changed to <color={2}>{2}</color>!" },
                { "ColoursInfo", "You can only use hexcodes, eg '<color=#ffff94>#ffff94</color>'\nTo remove your colour, use 'clear', 'reset' or 'remove'\n\nAvailable Commands: {0}\n\n{1}"},
                { "InvalidColour", "That colour is not valid. Do /colours for more information on valid colours." },
                { "RndColour", "{0} colour was randomized to <color={1}>{1}</color>" },
                { "RndColourFor", "{0} colour of {1} randomized to <color={2}>{2}</color>."},
                { "RainbowColour", "{0} colour was set to rainbow." },
                { "RainbowColourFor", "{0} colour of {1} set to rainbow."},
                { "IncorrectGroupUsage", "Incorrect group usage! /{0} group <groupName> <colourOrColourArgument>\nFor a list of colours do /colours" },
            }, this);
        }

        #endregion

        #region Config     

        private Configuration _configuration;
        private class Configuration
        {
            //General
            [JsonProperty(PropertyName = "Player Inactivity Data Removal (days)")]
            public int InactivityRemovalTime = 7;
            [JsonProperty(PropertyName = "Block messages of muted players (requires BetterChatMute)")]
            public bool BlockChatMute = true;
            [JsonProperty(PropertyName = "Rainbow Colours")]
            public string[] RainbowColours = { "#ff0000", "#ffa500", "#ffff94", "#008000", "#0000ff", "#4b0082", "#ee82ee" };
            [JsonProperty(PropertyName = "Blocked Characters")]
            public string[] BlockedValues = { "{", "}", "size" };

            //Name
            [JsonProperty(PropertyName = "Name colour commands", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public string[] NameColourCommands = new string[] { "colour", "color" };
            [JsonProperty(PropertyName = "Name colour commands (Help)", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public string[] NameColoursCommands = new string[] { "colours", "colors" };
            [JsonProperty(PropertyName = "Name show colour permission")]
            public string NamePermShow = "colouredchat.name.show";
            [JsonProperty(PropertyName = "Name use permission")]
            public string NamePermUse = "colouredchat.name.use";
            [JsonProperty(PropertyName = "Name use gradient permission")]
            public string NamePermGradient = "colouredchat.name.gradient";
            [JsonProperty(PropertyName = "Name default rainbow name permission")]
            public string NamePermRainbow = "colouredchat.name.rainbow";
            [JsonProperty(PropertyName = "Name bypass restrictions permission")]
            public string NamePermBypass = "colouredchat.name.bypass";
            [JsonProperty(PropertyName = "Name set others colour permission")]
            public string NamePermSetOthers = "colouredchat.name.setothers";
            [JsonProperty(PropertyName = "Name get random colour permission")]
            public string NamePermRandomColour = "colouredchat.name.random";
            [JsonProperty(PropertyName = "Name use blacklist")]
            public bool NameUseBlacklist = true;
            [JsonProperty(PropertyName = "Name blocked colour hex", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> NameBlockColoursHex = new List<string>
            {
                { "#000000" }
            };
            [JsonProperty(PropertyName = "Name blocked colours range hex", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<ColourRange> NameBlacklistedRangeColoursHex = new List<ColourRange>
            {
                { new ColourRange("#000000", "#000000") }
            };
            [JsonProperty(PropertyName = "Name use whitelist")]
            public bool NameUseWhitelist = false;
            [JsonProperty(PropertyName = "Name whitelisted colours hex", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> NameWhitelistedColoursHex = new List<string>
            {
                { "#000000" }
            };
            [JsonProperty(PropertyName = "Name whitelisted colour range hex", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<ColourRange> NameWhitelistedRangeColoursHex = new List<ColourRange>
            {
                { new ColourRange("#000000", "#FFFFFF") }
            };

            //Message
            [JsonProperty(PropertyName = "Message colour commands", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public string[] MessageColourCommands = new string[] { "mcolour", "mcolor" };
            [JsonProperty(PropertyName = "Message colour commands (Help)", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public string[] MessageColoursCommands = new string[] { "mcolours", "mcolors" };
            [JsonProperty(PropertyName = "Message show colour permission")]
            public string MessagePermShow = "colouredchat.message.show";
            [JsonProperty(PropertyName = "Message use permission")]
            public string MessagePermUse = "colouredchat.message.use";
            [JsonProperty(PropertyName = "Message use gradient permission")]
            public string MessagePermGradient = "colouredchat.message.gradient";
            [JsonProperty(PropertyName = "Message default rainbow name permission")]
            public string MessagePermRainbow = "colouredchat.message.rainbow";
            [JsonProperty(PropertyName = "Message bypass restrictions permission")]
            public string MessagePermBypass = "colouredchat.message.bypass";
            [JsonProperty(PropertyName = "Message set others colour permission")]
            public string MessagePermSetOthers = "colouredchat.message.setothers";
            [JsonProperty(PropertyName = "Message get random colour permission")]
            public string MessagePermRandomColour = "colouredchat.message.random";
            [JsonProperty(PropertyName = "Message use blacklist")]
            public bool MessageUseBlacklist = true;
            [JsonProperty(PropertyName = "Message blocked colours hex", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> MessageBlockColoursHex = new List<string>
            {
                { "#000000" }
            };
            [JsonProperty(PropertyName = "Message blocked colour range hex", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<ColourRange> MessageBlacklistedRangeColoursHex = new List<ColourRange>
            {
                { new ColourRange("#000000", "#000000") }
            };
            [JsonProperty(PropertyName = "Message use whitelist")]
            public bool MessageUseWhitelist = false;
            [JsonProperty(PropertyName = "Message whitelisted colours hex", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<string> MessageWhitelistedColoursHex = new List<string>
            {
                { "#000000" }
            };
            [JsonProperty(PropertyName = "Message whitelisted colour range hex", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public List<ColourRange> MessageWhitelistedRangeColoursHex = new List<ColourRange>
            {
                { new ColourRange("#000000", "#FFFFFF") }
            };
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            _configuration = new Configuration();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _configuration = Config.ReadObject<Configuration>();
            SaveConfig();
        }

        protected override void SaveConfig() => Config.WriteObject(_configuration);

        #region Colour Range Class

        public class ColourRange
        {
            [JsonProperty(PropertyName = "From")]
            public string _from;
            [JsonProperty(PropertyName = "To")]
            public string _to;

            public ColourRange(string from, string to)
            {
                _from = from;
                _to = to;
            }
        }

        #endregion

        #endregion

        #region Data

        private Dictionary<string, CachePlayerData> cachedData = new Dictionary<string, CachePlayerData>();
        private StoredData storedData;
        private Dictionary<string, PlayerData> allColourData => storedData.AllColourData;

        private class StoredData
        {
            public Dictionary<string, PlayerData> AllColourData { get; private set; } = new Dictionary<string, PlayerData>();
        }

        private class PlayerData
        {
            [JsonProperty("Name Colour")]
            public string NameColour = string.Empty;
            [JsonProperty("Name Gradient Args")]
            public string[] NameGradientArgs = null;

            [JsonProperty("Message Colour")]
            public string MessageColour = string.Empty;
            [JsonProperty("Message Gradient Args")]
            public string[] MessageGradientArgs = null;

            [JsonProperty("Last active")]
            public long LastActive = DateTimeOffset.UtcNow.ToUnixTimeSeconds();

            public PlayerData()
            {

            }

            public PlayerData(string nameColour = "", string[] nameGradientArgs = null, string messageColour = "", string[] messageGradientArgs = null)
            {
                NameColour = nameColour;
                NameGradientArgs = nameGradientArgs;

                MessageColour = messageColour;
                MessageGradientArgs = messageGradientArgs;
            }

            public PlayerData(bool isGroup)
            {
                LastActive = 0;
            }
        }

        private class CachePlayerData
        {
            public string NameColourGradient;
            public string PrimaryGroup;

            public CachePlayerData(string nameColourGradient = "", string primaryGroup = "")
            {
                NameColourGradient = nameColourGradient;
                PrimaryGroup = primaryGroup;
            }
        }

        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, storedData);

        private void OnServerSave()
        {
            ClearUpData();
            SaveData();
        } 
        private void Unload() => SaveData();

        private void ChangeNameColour(string key, string colour, string[] colourArgs)
        {
            var playerData = new PlayerData(colour, colourArgs);
            if (!allColourData.ContainsKey(key)) allColourData.Add(key, playerData);

            allColourData[key].NameColour = colour;
            allColourData[key].NameGradientArgs = colourArgs;
        }

        private void ChangeMessageColour(string key, string colour, string[] colourArgs)
        {
            var playerData = new PlayerData(string.Empty, null, colour, colourArgs);           
            if (!allColourData.ContainsKey(key)) allColourData.Add(key, playerData);

            allColourData[key].MessageColour = colour;
            allColourData[key].MessageGradientArgs = colourArgs;
        }

        #endregion

        #region Hooks

        private void Init()
        {
            if (_configuration.MessageUseBlacklist && _configuration.MessageUseWhitelist || _configuration.NameUseBlacklist && _configuration.NameUseWhitelist) PrintWarning("You are using both black/- and whitelist! This might cause issues.");

            permission.RegisterPermission(_configuration.NamePermShow, this);
            permission.RegisterPermission(_configuration.MessagePermShow, this);
            permission.RegisterPermission(_configuration.NamePermRainbow, this);
            permission.RegisterPermission(_configuration.MessagePermRainbow, this);
            permission.RegisterPermission(_configuration.NamePermGradient, this);
            permission.RegisterPermission(_configuration.MessagePermGradient, this);
            permission.RegisterPermission(_configuration.NamePermUse, this);
            permission.RegisterPermission(_configuration.MessagePermUse, this);
            permission.RegisterPermission(_configuration.NamePermBypass, this);
            permission.RegisterPermission(_configuration.MessagePermBypass, this);
            permission.RegisterPermission(_configuration.NamePermSetOthers, this);
            permission.RegisterPermission(_configuration.MessagePermSetOthers, this);
            permission.RegisterPermission(_configuration.NamePermRandomColour, this);
            permission.RegisterPermission(_configuration.MessagePermRandomColour, this);

            AddCovalenceCommand(_configuration.NameColourCommands, nameof(cmdNameColour));
            AddCovalenceCommand(_configuration.NameColoursCommands, nameof(cmdNameColours));
            AddCovalenceCommand(_configuration.MessageColourCommands, nameof(cmdMessageColour));
            AddCovalenceCommand(_configuration.MessageColoursCommands, nameof(cmdMessageColours));

            storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);

            ClearUpData();
        }

        private void OnUserConnected(IPlayer player)
        {
            if (!allColourData.ContainsKey(player.Id)) return;
            allColourData[player.Id].LastActive = DateTimeOffset.UtcNow.ToUnixTimeSeconds();
        }

        private void OnUserDisconnected(IPlayer player)
        {
            if (!allColourData.ContainsKey(player.Id)) return;
            allColourData[player.Id].LastActive = DateTimeOffset.UtcNow.ToUnixTimeSeconds();
        }

        private void OnUserNameUpdated(string id, string oldName, string newName) => ClearCache(id);

        private void OnUserGroupAdded(string id, string groupName) => ClearCache(id);

        private void OnUserGroupRemoved(string id, string groupName) => ClearCache(id);

        private void OnGroupDeleted(string name) => ClearCache();

        private void OnGroupPermissionGranted(string name, string perm) => ClearCache();

        private void OnGroupPermissionRevoked(string name, string perm) => ClearCache();

        private object OnPlayerChat(BasePlayer player, string message, Chat.ChatChannel channel)
        {
            if (BetterChatIns()) 
                return null;
            if (_configuration.BlockChatMute && BetterChatMuteIns()) 
                if (BetterChatMute.Call<bool>("API_IsMuted", player.IPlayer)) 
                    return null;
            if (player == null) 
                return null;
            if (ZoneManagerIns() && ZoneManager.Call<bool>("PlayerHasFlag", player, "nochat")) 
                return false;

            if (Chat.serverlog)
            {
                var objArray = new object[] { ConsoleColor.DarkYellow, null, null, null };
                objArray[1] = string.Concat(new object[] { "[", channel, "] ", player.displayName.EscapeRichText(), ": " });
                objArray[2] = ConsoleColor.DarkGreen;
                objArray[3] = message;
                ServerConsole.PrintColoured(objArray);
            }

            var colouredChatMessage = FromMessage(player.IPlayer, channel, message);
            var colouredChatMessageDict = colouredChatMessage.GetDictionary();

            #region API
            
            foreach (var plugin in plugins.GetAll())
            {
                var obj = plugin.CallHook("OnColouredChat", colouredChatMessageDict);

                if (obj is Dictionary<string, object>)
                {
                    try
                    {
                        colouredChatMessageDict = obj as Dictionary<string, object>;
                    }
                    catch (Exception e)
                    {
                        PrintError($"Failed to load modified OnColouredChat hook data from plugin '{plugin.Title} ({plugin.Version})':{Environment.NewLine}{e}");
                        continue;
                    }
                }
                else if (obj != null) return obj;
            }

            colouredChatMessage = ColouredChatMessage.FromDictionary(colouredChatMessageDict);

            #endregion

            SendMessage(colouredChatMessage);
            return true;
        }

        private Dictionary<string, object> OnBetterChat(Dictionary<string, object> dict)
        {
            if (dict != null)
            {
                var player = dict["Player"] as IPlayer;

                var colouredChatMessage = FromMessage(player, (Chat.ChatChannel)dict["ChatChannel"], 
                    dict["Message"].ToString());

                #region API

                var colouredChatMessageDict = colouredChatMessage.GetDictionary();

                foreach (Plugin plugin in plugins.GetAll())
                {
                    object obj = plugin.CallHook("OnColouredChat", colouredChatMessageDict);

                    if (obj is Dictionary<string, object>)
                    {
                        try
                        {
                            colouredChatMessageDict = obj as Dictionary<string, object>;
                        }
                        catch (Exception e)
                        {
                            PrintError($"Failed to load modified OnColouredChat hook data from plugin '{plugin.Title} ({plugin.Version})':{Environment.NewLine}{e}");
                            continue;
                        }
                    }
                    else if (obj != null)
                    {
                        if (obj is bool)
                        {
                            dict["CancelOption"] = 2;
                        }
                    }
                }

                colouredChatMessage = ColouredChatMessage.FromDictionary(colouredChatMessageDict);

                #endregion

                if (!string.IsNullOrEmpty(colouredChatMessage.Name)) dict["Username"] = colouredChatMessage.Name;
                if (!string.IsNullOrEmpty(colouredChatMessage.Colour)) { ((Dictionary<string, object>)dict["UsernameSettings"])["Color"] = colouredChatMessage.Colour; }
                dict["Message"] = colouredChatMessage.Message;
            }
            return dict;
        }

        #endregion

        #region Commands

        void cmdNameColour(IPlayer player, string cmd, string[] args) => ProcessColourCommand(player, cmd, args);

        void cmdNameColours(IPlayer player, string cmd, string[] args) => ProcessColoursCommand(player, cmd, args);

        void cmdMessageColour(IPlayer player, string cmd, string[] args) => ProcessColourCommand(player, cmd, args, true);

        void cmdMessageColours(IPlayer player, string cmd, string[] args) => ProcessColoursCommand(player, cmd, args, true);
        
        #endregion

        #region Helpers

        private bool BetterChatIns() => (BetterChat != null && BetterChat.IsLoaded);
        private bool BetterChatMuteIns() => (BetterChatMute != null && BetterChatMute.IsLoaded);
        private bool ZoneManagerIns() => (ZoneManager != null && ZoneManager.IsLoaded);
        private bool IsValidColour(string input) => Regex.Match(input, ColourRegex).Success;
        private string GetMessage(string key, IPlayer player, params string[] args) => string.Format(lang.GetMessage(key, this, player.Id), args);

        //Name
        private bool HasNameShowPerm(IPlayer player) => (player.IsAdmin || permission.UserHasPermission(player.Id, _configuration.NamePermShow));
        private bool HasNamePerm(IPlayer player) => (player.IsAdmin || permission.UserHasPermission(player.Id, _configuration.NamePermUse));
        private bool HasNameRainbow(IPlayer player) => (player.IsAdmin || permission.UserHasPermission(player.Id, _configuration.NamePermRainbow));
        private bool CanNameGradient(IPlayer player) => (player.IsAdmin || permission.UserHasPermission(player.Id, _configuration.NamePermGradient));
        private bool CanNameBypass(IPlayer player) => (player.IsAdmin || permission.UserHasPermission(player.Id, _configuration.NamePermBypass));
        private bool CanNameSetOthers(IPlayer player) => (player.IsAdmin || permission.UserHasPermission(player.Id, _configuration.NamePermSetOthers));
        private bool CanNameRandomColour(IPlayer player) => (player.IsAdmin || permission.UserHasPermission(player.Id, _configuration.NamePermRandomColour));

        //Message
        private bool HasMessageShowPerm(IPlayer player) => (player.IsAdmin || permission.UserHasPermission(player.Id, _configuration.MessagePermShow));
        private bool HasMessagePerm(IPlayer player) => (player.IsAdmin || permission.UserHasPermission(player.Id, _configuration.MessagePermUse));
        private bool HasMessageRainbow(IPlayer player) => (player.IsAdmin || permission.UserHasPermission(player.Id, _configuration.MessagePermRainbow));
        private bool CanMessageGradient(IPlayer player) => (player.IsAdmin || permission.UserHasPermission(player.Id, _configuration.MessagePermGradient));
        private bool CanMessageBypass(IPlayer player) => (player.IsAdmin || permission.UserHasPermission(player.Id, _configuration.MessagePermBypass));
        private bool CanMessageSetOthers(IPlayer player) => (player.IsAdmin || permission.UserHasPermission(player.Id, _configuration.MessagePermSetOthers));
        private bool CanMessageRandomColour(IPlayer player) => (player.IsAdmin || permission.UserHasPermission(player.Id, _configuration.MessagePermRandomColour));

        private bool IsValidName(string input, IPlayer iPlayer = null)
        {
            if (iPlayer != null && CanNameBypass(iPlayer)) return true;
            if (_configuration.NameUseBlacklist)
            {
                bool inRange = false;
                foreach (var colourRange in _configuration.NameBlacklistedRangeColoursHex)
                {
                    inRange = IsInHexRange(input, colourRange._from, colourRange._to);
                    if (inRange) break;
                }
                return !_configuration.NameBlockColoursHex.Any(x => (input == x)) && !inRange;
            }
            else if (_configuration.NameUseWhitelist)
            {
                bool inRange = false;
                foreach (var colourRange in _configuration.NameWhitelistedRangeColoursHex)
                {
                    inRange = IsInHexRange(input, colourRange._from, colourRange._to);
                    if (!inRange) break;
                }
                return _configuration.NameWhitelistedColoursHex.Any(x => (input == x)) || inRange;
            }
            return true;
        }

        private bool IsValidMessage(string input, IPlayer iPlayer = null)
        {
            if (iPlayer != null && CanMessageBypass(iPlayer)) return true;
            if (_configuration.MessageUseBlacklist)
            {
                bool inRange = false;
                foreach (var colourRange in _configuration.MessageBlacklistedRangeColoursHex)
                {
                    inRange = IsInHexRange(input, colourRange._from, colourRange._to);
                    if (inRange) 
                        break;
                }
                return !_configuration.MessageBlockColoursHex.Any(x => (input == x)) && !inRange;
            }
            else if (_configuration.MessageUseWhitelist)
            {
                bool inRange = false;
                foreach (var colourRange in _configuration.MessageWhitelistedRangeColoursHex)
                {
                    inRange = IsInHexRange(input, colourRange._from, colourRange._to);
                    if (!inRange)
                        break;
                }
                return _configuration.MessageWhitelistedColoursHex.Any(x => (input == x)) || inRange;
            }
            
            return true;
        }
        
        private void SendMessage(ColouredChatMessage colouredChatMessage)
        {
            var player = colouredChatMessage.Player.Object as BasePlayer;
            if (player == null)
                return; // cannot send if player does not exist

            var formattedLogMessage = _sharedStringBuilder;
            formattedLogMessage.Clear();
            
            switch (colouredChatMessage.ChatChannel)
            {
                case Chat.ChatChannel.Global:
                case Chat.ChatChannel.Server:
                {
                    ConsoleNetwork.BroadcastToAllClients("chat.add2", (int) colouredChatMessage.ChatChannel,
                        player.userID, colouredChatMessage.Message, colouredChatMessage.Name,
                        colouredChatMessage.Colour);
                    
                    formattedLogMessage.Append("[CHAT] ");
                    break;
                }
                case Chat.ChatChannel.Team:
                {
                    if (player.Team == null)
                        return;
                    
                    // Broadcast to rust+ app users
                    player.Team.BroadcastTeamChat(player.userID, player.displayName, colouredChatMessage.Message, colouredChatMessage.Colour);

                    ConsoleNetwork.SendClientCommand(player.Team.GetOnlineMemberConnections(), "chat.add2",
                        (int) colouredChatMessage.ChatChannel, player.userID, colouredChatMessage.Message,
                        colouredChatMessage.Name, colouredChatMessage.Colour);

                    formattedLogMessage.Append("[TEAM CHAT] ");
                    break;
                }
                case Chat.ChatChannel.Cards:
                {
                    if (!player.isMounted)
                        return;
                    
                    var cardTable = player.GetMountedVehicle() as CardTable;
                    if (cardTable == null || !cardTable.GameController.PlayerIsInGame(player))
                        return;
                    
                    var cardTableConnections = Pool.GetList<Network.Connection>();
                    cardTable.GameController.GetConnectionsInGame(cardTableConnections);
                    
                    if (cardTableConnections.Count > 0)
                    {
                        ConsoleNetwork.SendClientCommand(cardTableConnections, "chat.add2",
                            (int) colouredChatMessage.ChatChannel, player.userID, colouredChatMessage.Message,
                            colouredChatMessage.Name, colouredChatMessage.Colour);
                    }
                    Pool.FreeList(ref cardTableConnections);
                    
                    formattedLogMessage.Append("[CARDS CHAT] ");
                    break;
                }
                case Chat.ChatChannel.Local:
                {
                    var num = Chat.localChatRange * Chat.localChatRange;
                    var senderPosition = player.transform.position;
                    
                    var closeByConnections = Pool.GetList<Network.Connection>();
                    foreach (var basePlayer in BasePlayer.activePlayerList)
                    {
                        var sqrMagnitude = (basePlayer.transform.position - senderPosition).sqrMagnitude;
                        if (sqrMagnitude > num)
                            continue;
                        
                        closeByConnections.Add(basePlayer.Connection);
                    }

                    ConsoleNetwork.SendClientCommand(closeByConnections, "chat.add2",
                        (int) colouredChatMessage.ChatChannel, player.userID, colouredChatMessage.Message,
                        colouredChatMessage.Name, colouredChatMessage.Colour);
                    
                    Pool.FreeList(ref closeByConnections);
                    formattedLogMessage.Append("[CHAT] ");
                    break;
                }
            }
            
            // Console logging
            formattedLogMessage.Append(player.displayName.EscapeRichText()).Append('[').Append(player.UserIDString)
                .Append("] : ").Append(colouredChatMessage.Message);
            DebugEx.Log(formattedLogMessage);
            
            // Rcon logging
            var chatEntry = new Chat.ChatEntry
            {
                Channel = colouredChatMessage.ChatChannel,
                Message = colouredChatMessage.Message,
                UserId = player.UserIDString,
                Username = player.displayName,
                Color = colouredChatMessage.Colour,
                Time = Facepunch.Math.Epoch.Current
            };
            Facepunch.RCon.Broadcast(Facepunch.RCon.LogType.Chat, chatEntry);
        }

        private void ProcessColourCommand(IPlayer player, string cmd, string[] args, bool isMessage = false)
        {
            if (args.Length < 1)
            {
                player.Reply(GetMessage("IncorrectUsage", player,
                    isMessage ? _configuration.MessageColourCommands[0] : _configuration.NameColourCommands[0],
                    isMessage ? _configuration.MessageColoursCommands[0] : _configuration.NameColoursCommands[0]));
                return;
            }
            var colLower = string.Empty;
            if (args[0] == "set")
            {
                if ((!isMessage && !CanNameSetOthers(player)) || (isMessage && !CanMessageSetOthers(player)))
                {
                    player.Reply(GetMessage("NoPermissionSetOthers", player, isMessage ? "message" : "name"));
                    return;
                }
                if (args.Length < 3)
                {
                    player.Reply(GetMessage("IncorrectSetUsage", player,
                        isMessage ? _configuration.MessageColourCommands[0] : _configuration.NameColourCommands[0]));
                    return;
                }
                var target = covalence.Players.FindPlayer(args[1]);
                if (target == null)
                {
                    player.Reply(GetMessage("PlayerNotFound", player, args[1]));
                    return;
                }
                colLower = args[2].ToLower();
                ProcessColour(player, target, colLower, args.Skip(2).ToArray(), isMessage);
            }
            else if (args[0] == "group")
            {
                if (!player.IsAdmin)
                {
                    player.Reply(GetMessage("NoPermission", player));
                    return;
                }
                if (args.Length < 3)
                {
                    player.Reply(GetMessage("IncorrectGroupUsage", player,
                        isMessage ? _configuration.MessageColourCommands[0] : _configuration.NameColourCommands[0]));
                    return;
                }
                if (!permission.GroupExists(args[1])) permission.CreateGroup(args[1], string.Empty, 0);
                colLower = args[2].ToLower();
                ProcessColour(player, player, colLower, args.Skip(3).ToArray(), isMessage, args[1]);
            }
            else
            {
                if ((!isMessage && !HasNamePerm(player)) || (isMessage && !HasMessagePerm(player)))
                {
                    player.Reply(GetMessage("NoPermission", player));
                    return;
                }
                if (args.Length < 1)
                {
                    player.Reply(GetMessage("IncorrectUsage", player,
                        isMessage ? _configuration.MessageColourCommands[0] : _configuration.NameColourCommands[0]));
                    return;
                }
                colLower = args[0].ToLower();
                ProcessColour(player, player, colLower, args.Skip(1).ToArray(), isMessage);
            }
        }

        private void ProcessColoursCommand(IPlayer player, string cmd, string[] args, bool isMessage = false)
        {
            if ((!isMessage && !HasNamePerm(player)) || (isMessage && !HasMessagePerm(player)))
            {
                player.Reply(GetMessage("NoPermission", player));
                return;
            }
            var availableCommandsBuilder = _sharedStringBuilder;
            availableCommandsBuilder.Clear();
            
            if (isMessage)
            {
                var commandName = _configuration.MessageColourCommands[0];
                availableCommandsBuilder.AppendLine().Append('/').Append(commandName).Append(" <color=#ff6666>#ff6666</color>");
                if (CanMessageRandomColour(player))
                {
                    availableCommandsBuilder.AppendLine().Append('/').Append(commandName).Append(" random");
                }
                if (CanMessageGradient(player)) 
                {
                    availableCommandsBuilder.AppendLine().Append('/').Append(commandName).Append(" gradient <color=#ff6666>#ff6666</color> <color=#ff6666>#ff6666</color>").AppendLine();
                    availableCommandsBuilder.AppendLine().Append('/').Append(commandName).Append(" gradient <color=#ff6666>#ff6666</color> <color=#ffff94>#ffff94</color> <color=#90ee90>#90ee90</color>");
                }
                if (CanMessageSetOthers(player))
                {
                    availableCommandsBuilder.AppendLine().Append('/').Append(commandName).Append(" set <color=#a8a8a8>playerIdOrName</color> <color=#ff6666>#ff6666</color>");
                    availableCommandsBuilder.AppendLine().Append('/').Append(commandName).Append(" set <color=#a8a8a8>playerIdOrName</color> gradient <color=#ff6666>#ff6666</color> <color=#ffff94>#ffff94</color>");
                }
                if (player.IsAdmin)
                {
                    availableCommandsBuilder.AppendLine().Append('/').Append(commandName).Append(" group <color=#a8a8a8>groupName</color> <color=#ff6666>#ff6666</color>");
                    availableCommandsBuilder.AppendLine().Append('/').Append(commandName).Append(" group <color=#a8a8a8>groupName</color> gradient <color=#ff6666>#ff6666</color> <color=#ffff94>#ffff94</color>");
                }
            }
            else
            {
                var commandName = _configuration.NameColourCommands[0];
                availableCommandsBuilder.AppendLine().Append('/').Append(commandName).Append(" <color=#ff6666>#ff6666</color>");
                if (CanNameRandomColour(player))
                {
                    availableCommandsBuilder.AppendLine().Append('/').Append(commandName).Append(" random");
                }
                if (CanNameGradient(player)) 
                {
                    availableCommandsBuilder.AppendLine().Append('/').Append(commandName).Append(" gradient <color=#ff6666>#ff6666</color> <color=#ff6666>#ff6666</color>").AppendLine();
                    availableCommandsBuilder.AppendLine().Append('/').Append(commandName).Append(" gradient <color=#ff6666>#ff6666</color> <color=#ffff94>#ffff94</color> <color=#90ee90>#90ee90</color>");
                }
                if (CanNameSetOthers(player)) 
                {
                    availableCommandsBuilder.AppendLine().Append('/').Append(commandName).Append(" set <color=#a8a8a8>playerIdOrName</color> <color=#ff6666>#ff6666</color>");
                    availableCommandsBuilder.AppendLine().Append('/').Append(commandName).Append(" set <color=#a8a8a8>playerIdOrName</color> gradient <color=#ff6666>#ff6666</color> <color=#ffff94>#ffff94</color>");
                }
                if (player.IsAdmin)
                {
                    availableCommandsBuilder.AppendLine().Append('/').Append(commandName).Append(" group <color=#a8a8a8>groupName</color> <color=#ff6666>#ff6666</color>");
                    availableCommandsBuilder.AppendLine().Append('/').Append(commandName).Append(" group <color=#a8a8a8>groupName</color> gradient <color=#ff6666>#ff6666</color> <color=#ffff94>#ffff94</color>");
                }
            }

            var availableCommands = availableCommandsBuilder.ToString();
            var additionalInfoBuilder = _sharedStringBuilder;
            additionalInfoBuilder.Clear();
            
            if (isMessage && _configuration.MessageUseWhitelist)
            {
                additionalInfoBuilder.AppendLine("Whitelisted Colours:");
                foreach (var colour in _configuration.MessageWhitelistedColoursHex)
                {
                    additionalInfoBuilder.Append("- <color=").Append(colour).Append(">").Append(colour).AppendLine("</color>");
                }
                foreach (var colourRange in _configuration.MessageWhitelistedRangeColoursHex)
                {
                    additionalInfoBuilder.Append("- From <color=").Append(colourRange._from).Append(">")
                        .Append(colourRange._from).Append("</color> to <color=").Append(colourRange._to).Append(">")
                        .Append(colourRange._to).AppendLine("</color>");
                }
            }
            else if (isMessage && _configuration.MessageUseBlacklist)
            {
                additionalInfoBuilder.AppendLine("Blacklisted Colours:");
                foreach (var colour in _configuration.MessageBlockColoursHex)
                {
                    additionalInfoBuilder.Append("- <color=").Append(colour).Append(">").Append(colour).Append("</color>");
                }
                foreach (var colourRange in _configuration.MessageBlacklistedRangeColoursHex)
                {
                    additionalInfoBuilder.Append("- From <color=").Append(colourRange._from).Append(">")
                        .Append(colourRange._from).Append("</color> to <color=").Append(colourRange._to).Append(">")
                        .Append(colourRange._to).AppendLine("</color>");
                }
            }
            else if (!isMessage && _configuration.NameUseWhitelist)
            {
                additionalInfoBuilder.AppendLine("Whitelisted Colours:");
                foreach (var colour in _configuration.NameWhitelistedColoursHex)
                {
                    additionalInfoBuilder.Append("- <color=").Append(colour).Append(">").Append(colour).AppendLine("</color>");
                }
                foreach (var colourRange in _configuration.NameWhitelistedRangeColoursHex)
                {
                    additionalInfoBuilder.Append("- From <color=").Append(colourRange._from).Append(">")
                        .Append(colourRange._from).Append("</color> to <color=").Append(colourRange._to).Append(">")
                        .Append(colourRange._to).AppendLine("</color>");
                }
            }
            else if (!isMessage && _configuration.NameUseBlacklist)
            {
                additionalInfoBuilder.AppendLine("Blacklisted Colours:");
                foreach (var colour in _configuration.NameBlockColoursHex)
                {
                    additionalInfoBuilder.Append("- <color=").Append(colour).Append(">").Append(colour).AppendLine("</color>");
                }
                foreach (var colourRange in _configuration.NameBlacklistedRangeColoursHex)
                {
                    additionalInfoBuilder.Append("- From <color=").Append(colourRange._from).Append(">")
                        .Append(colourRange._from).Append("</color> to <color=").Append(colourRange._to).Append(">")
                        .Append(colourRange._to).AppendLine("</color>");
                }
            }

            player.Reply(GetMessage("ColoursInfo", player, availableCommands, additionalInfoBuilder.ToString()));
        }

        private string ProcessColourMessage(string message, string colour) => $"<color={colour}>" + message + "</color>";

        private void ProcessColour(IPlayer player, IPlayer target, string colLower, string[] colours, bool isMessage = false, string groupName = "")
        {
            var isGroup = !string.IsNullOrEmpty(groupName);
            var isCalledOnto = player != target && !isGroup;
            var key = isGroup ? groupName : target.Id;
            
            if (!isGroup && !allColourData.ContainsKey(target.Id)) allColourData.Add(target.Id, new PlayerData());
            else if (isGroup && !allColourData.ContainsKey(groupName)) allColourData.Add(groupName, new PlayerData(true));

            if (colLower == "gradient")
            {
                if ((!isMessage && !CanNameGradient(player)) || (isMessage && !CanMessageGradient(player)))
                {
                    player.Reply(GetMessage("NoPermissionGradient", player, isMessage ? "message" : "name"));
                    return;
                }

                colours = colours.Where(col =>
                    isMessage
                        ? IsValidMessage(col, player)
                        : IsValidName(col, player) && IsValidColour(col) &&
                          IsInvalidCharacter(col) == null).ToArray();
                if (colours.Length < 2)
                {
                    player.Reply(GetMessage("IncorrectGradientUsageArgs", player,
                        isMessage ? _configuration.MessageColourCommands[0] : _configuration.NameColourCommands[0]));
                    return;
                }
                string gradientName = ProcessGradient(isMessage ? "Example Message" : target.Name, colours, isMessage, player);
                if (gradientName.Equals(string.Empty))
                {
                    player.Reply(GetMessage("IncorrectGradientUsage", player,
                        isMessage ? _configuration.MessageColourCommands[0] : _configuration.NameColourCommands[0]));
                    return;
                }
                if (isMessage)
                {
                    allColourData[key].MessageColour = string.Empty;
                    allColourData[key].MessageGradientArgs = colours;
                }
                else
                {
                    allColourData[key].NameColour = string.Empty;
                    allColourData[key].NameGradientArgs = colours;
                    if (!isGroup)
                    {
                        if (!cachedData.ContainsKey(key)) cachedData.Add(key, new CachePlayerData(gradientName, GetPrimaryUserGroup(player.Id)));
                        else cachedData[key].NameColourGradient = gradientName;
                    }
                }
                if (isGroup) ClearCache();

                if (target.IsConnected) target.Reply(GetMessage("GradientChanged", target, GetCorrectLang(isGroup, isMessage, key), gradientName));
                if (isCalledOnto) player.Reply(GetMessage("GradientChangedFor", player, target.Name, isMessage ? "message" : "name", gradientName));
                return;
            }
            if (colLower == "reset" || colLower == "clear" || colLower == "remove")
            {
                if (isMessage)
                {
                    allColourData[key].MessageColour = string.Empty;
                    allColourData[key].MessageGradientArgs = null;
                } 
                else
                {
                    allColourData[key].NameColour = string.Empty;
                    allColourData[key].NameGradientArgs = null;
                    if (cachedData.ContainsKey(key)) cachedData.Remove(key);
                }

                if (string.IsNullOrEmpty(allColourData[key].NameColour) &&
                    allColourData[key].NameGradientArgs == null &&
                    string.IsNullOrEmpty(allColourData[key].MessageColour) &&
                    allColourData[key].MessageGradientArgs == null)
                {
                    allColourData.Remove(key);
                }

                if (isGroup)
                {
                    ClearCache();
                }

                if (target.IsConnected) target.Reply(GetMessage("ColourRemoved", target, GetCorrectLang(isGroup, isMessage, key)));
                if (isCalledOnto) player.Reply(GetMessage("ColourRemovedFor", player, target.Name, isMessage ? "message" : "name"));
                return;
            }
            if (colLower == "random")
            {
                if (!isMessage && !CanNameRandomColour(player) || isMessage && !CanMessageRandomColour(player))
                {
                    player.Reply(GetMessage("NoPermissionRandom", player, isMessage ? "message" : "name"));
                    return;
                }
                colLower = GetRndColour();
                if (isMessage) ChangeMessageColour(key, colLower, null);
                else ChangeNameColour(key, colLower, null);
                if (isGroup) ClearCache();

                if (target.IsConnected) target.Reply(GetMessage("RndColour", target, GetCorrectLang(isGroup, isMessage, key), colLower));
                if (isCalledOnto) player.Reply(GetMessage("RndColourFor", player, isMessage ? "Message" : "Name", target.Name, colLower));
                return;
            }
            if (colLower == "rainbow")
            {
                if (isMessage && !HasMessageRainbow(player) || !HasNameRainbow(player))
                {
                    player.Reply(GetMessage("NoPermissionRainbow", player));
                    return;
                }

                if (isMessage) ChangeMessageColour(key, string.Empty, _configuration.RainbowColours);
                else ChangeNameColour(key, string.Empty, _configuration.RainbowColours);
                if (isGroup) ClearCache();

                if (target.IsConnected) target.Reply(GetMessage("RainbowColour", target, GetCorrectLang(isGroup, isMessage, key)));
                if (isCalledOnto) player.Reply(GetMessage("RainbowColourFor", player, isMessage ? "Message" : "Name", target.Name));
                return;
            }
            string invalidChar;
            if ((invalidChar = IsInvalidCharacter(colLower)) != null)
            {
                player.Reply(GetMessage("InvalidCharacters", player, invalidChar));
                return;
            }
            if (!IsValidColour(colLower))
            {
                player.Reply(GetMessage("InvalidColour", player));
                return;
            }
            if (isMessage ? !IsValidMessage(colLower, player) : !IsValidName(colLower, player))
            {
                player.Reply(GetMessage("InvalidColour", player));
                return;
            }

            if (isMessage) ChangeMessageColour(key, colLower, null);
            else ChangeNameColour(key, colLower, null);

            if (isCalledOnto) player.Reply(GetMessage("ColourChangedFor", player, target.Name, isMessage ? "message" : "name", colLower));
            else if (isGroup && target.IsConnected) target.Reply(GetMessage("ColourChangedFor", player, key, isMessage ? "message" : "name", colLower));
            else if (target.IsConnected) target.Reply(GetMessage("ColourChanged", target, isMessage ? "Message" : "Name", colLower));
            if (isGroup) ClearCache();
        }

        private string ProcessGradient(string name, string[] colourArgs, bool isMessage = false, IPlayer iPlayer = null)
        {
            var gradientName = _sharedStringBuilder;
            gradientName.Clear();
            
            var colours = Pool.GetList<Color>();
            Color startColour;
            Color endColour;

            var nameLength = name.Length;
            var gradientsSteps = nameLength / (colourArgs.Length - 1);
            if (gradientsSteps <= 1)
            {
                for (var i = 0; i < nameLength; i++)
                {
                    if (i > colourArgs.Length - 1)
                        ColorUtility.TryParseHtmlString(colourArgs[colourArgs.Length - 1], out startColour);
                    else 
                        ColorUtility.TryParseHtmlString(colourArgs[i], out startColour);
                    
                    colours.Add(startColour);
                }
            }
            else
            {
                var gradientIterations = nameLength / gradientsSteps;
                for (var i = 0; i < gradientIterations; i++)
                {
                    if (colours.Count >= nameLength) 
                        continue;
                    if (i > colourArgs.Length - 1) 
                        ColorUtility.TryParseHtmlString(colourArgs[colourArgs.Length - 1], out startColour);
                    else 
                        ColorUtility.TryParseHtmlString(colourArgs[i], out startColour);
                    if (i >= colourArgs.Length - 1) 
                        endColour = startColour;
                    else 
                        ColorUtility.TryParseHtmlString(colourArgs[i + 1], out endColour);
                    GetAndAddGradients(startColour, endColour, gradientsSteps, colours);
                }
                if (colours.Count < nameLength)
                {
                    ColorUtility.TryParseHtmlString(colourArgs[colourArgs.Length - 1], out endColour);
                    while (colours.Count < name.Length) 
                        colours.Add(endColour);
                }
            }
            
            for (var i = 0; i < colours.Count; i++)
            {
                gradientName.Append("<color=#").Append(ColorUtility.ToHtmlStringRGB(colours[i])).Append(">")
                    .Append(name[i]).Append("</color>");
            }
            Pool.FreeList(ref colours);
            
            return gradientName.ToString();
        }

        /// <summary>
        /// Gets and adds gradient colours to provided results list
        /// </summary>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="steps"></param>
        /// <param name="results"></param>
        private void GetAndAddGradients(Color start, Color end, int steps, List<Color> results)
        {
            var stepR = ((end.r - start.r) / (steps - 1));
            var stepG = ((end.g - start.g) / (steps - 1));
            var stepB = ((end.b - start.b) / (steps - 1));

            for (var i = 0; i < steps; i++)
                results.Add(new Color(start.r + (stepR * i), start.g + (stepG * i), start.b + (stepB * i)));
        }

        private readonly Random _random = new Random();
        private string GetRndColour() => $"#{_random.Next(0x1000000):X6}";

        private string IsInvalidCharacter(string input) => _configuration.BlockedValues.FirstOrDefault(x => input.Contains(x));

        private void ClearUpData()
        {
            if (_configuration.InactivityRemovalTime == 0) 
                return;

            var copy = new Dictionary<string, PlayerData>(allColourData);
            foreach (var colData in copy)
            {
                if (colData.Value.LastActive == 0)
                    continue;
                
                if (colData.Value.LastActive + (_configuration.InactivityRemovalTime * 86400) < DateTimeOffset.UtcNow.ToUnixTimeSeconds()) 
                    allColourData.Remove(colData.Key);
            }
        }

        private void ClearCache()
        {
            var cachedCopy = new Dictionary<string, CachePlayerData>(cachedData);
            foreach (var cache in cachedCopy) cachedData.Remove(cache.Key);
        }

        private void ClearCache(string Id)
        {
            if (cachedData.ContainsKey(Id)) cachedData.Remove(Id);
        }

        private string GetCorrectLang(bool isGroup, bool isMessage, string key) => isGroup
            ?
            isMessage ? $"Group {key} message" : $"Group {key} name"
            : isMessage
                ? "Message"
                : "Name";

        private string GetPrimaryUserGroup(string Id)
        {
            var groups = permission.GetUserGroups(Id);

            var primaryGroup = string.Empty;
            var groupRank = -1;
            foreach (var group in groups)
            {
                if (!allColourData.ContainsKey(group)) continue;
                var currentGroupRank = permission.GetGroupRank(group);
                if (currentGroupRank > groupRank)
                {
                    groupRank = currentGroupRank;
                    primaryGroup = group;
                }
            }
            return primaryGroup;
        }

        private ColouredChatMessage FromMessage(IPlayer player, Chat.ChatChannel channel, string message)
        {
            PlayerData playerData;
            if (!allColourData.TryGetValue(player.Id, out playerData) || playerData == null)
                playerData = new PlayerData();
            
            var colouredNameData = GetColouredName(player, playerData);
            colouredNameData.ChatChannel = channel;
            colouredNameData.Message = GetColouredMessage(player, playerData, message);
            return colouredNameData;
        }

        private ColouredChatMessage GetColouredName(IPlayer player, PlayerData playerData)
        {
            var playerUserName = player.Name;
            var playerColour = player.IsAdmin ? "#af5" : "#5af";
            var playerColourNonModified = playerColour;

            CachePlayerData cachedPlayerData;
            if (!cachedData.TryGetValue(player.Id, out cachedPlayerData) || cachedPlayerData == null)
            {
                var gradientName = string.Empty;
                if (playerData?.NameGradientArgs != null) 
                    gradientName = ProcessGradient(player.Name, playerData.NameGradientArgs, false, player);

                cachedData.Add(player.Id, cachedPlayerData = new CachePlayerData(gradientName, GetPrimaryUserGroup(player.Id)));
            }

            if (HasNameShowPerm(player))
            {
                //Gradient Handling
                if (playerData?.NameGradientArgs != null) 
                    playerUserName = cachedPlayerData.NameColourGradient;
                
                else if (!string.IsNullOrEmpty(playerData?.NameColour)) 
                    playerColour = playerData.NameColour;
                
                else if (playerUserName == player.Name && !string.IsNullOrEmpty(cachedPlayerData.NameColourGradient)) 
                    playerUserName = cachedPlayerData.NameColourGradient;
            }
            
            if (allColourData.ContainsKey(cachedPlayerData.PrimaryGroup))
            {
                var groupData = allColourData[cachedPlayerData.PrimaryGroup];
                if (playerUserName == player.Name && playerColour == playerColourNonModified)
                {
                    if (groupData?.NameGradientArgs != null)
                    {
                        playerUserName = string.IsNullOrEmpty(cachedPlayerData.NameColourGradient)
                            ? cachedPlayerData.NameColourGradient = ProcessGradient(player.Name,
                                groupData.NameGradientArgs, false, player)
                            : cachedPlayerData.NameColourGradient;
                    }
                    else if (!string.IsNullOrEmpty(groupData?.NameColour)) 
                        playerColour = groupData.NameColour;
                }
            }

            return new ColouredChatMessage()
            {
                Player = player, Name = playerUserName,
                Colour = (playerColour == playerColourNonModified && BetterChatIns()) ? string.Empty : playerColour
            };
        }

        private string GetColouredMessage(IPlayer player, PlayerData playerData, string message)
        {
            var playerMessage = message;

            if (HasNameShowPerm(player))
            {
                if (playerData?.MessageGradientArgs != null) 
                    playerMessage = ProcessGradient(message, playerData.MessageGradientArgs, true, player);
                else if (!string.IsNullOrEmpty(playerData?.MessageColour)) 
                    playerMessage = ProcessColourMessage(message, playerData.MessageColour);
            }

            //Group Handling
            var userPrimaryGroup = cachedData[player.Id].PrimaryGroup;
            if (allColourData.ContainsKey(userPrimaryGroup))
            {
                var groupData = allColourData[userPrimaryGroup];
                if (playerMessage == message)
                {
                    if (groupData?.MessageGradientArgs != null) 
                        playerMessage = ProcessGradient(message, groupData.MessageGradientArgs, true, player);
                    else if (!string.IsNullOrEmpty(groupData?.MessageColour)) 
                        playerMessage = ProcessColourMessage(message, groupData.MessageColour);
                }
            }

            return playerMessage;
        }

        private bool IsInHexRange(string hexCode,string rangeHexCode1, string rangeHexCode2)
        {
            Color mainColour;
            ColorUtility.TryParseHtmlString(hexCode, out mainColour);
            Color start;
            ColorUtility.TryParseHtmlString(rangeHexCode1, out start);
            Color end;
            ColorUtility.TryParseHtmlString(rangeHexCode2, out end);

            if ((mainColour.r >= start.r && mainColour.r <= end.r) &&
                (mainColour.g >= start.g && mainColour.g <= end.g) &&
                (mainColour.b >= start.b && mainColour.b <= end.b))
            {
                return true;
            }

            return false;
        }

        #endregion

        #region API

        private string API_GetNameColourHex(IPlayer player)
        {
            var playerData = new PlayerData();
            if (allColourData.ContainsKey(player.Id)) 
                playerData = allColourData[player.Id];

            var colouredData = GetColouredName(player, playerData);
            if (string.IsNullOrEmpty(colouredData.Colour))
            {
                return player.IsAdmin ? "#af5" : "#5af";
            }

            return colouredData.Colour;
        }

        private string API_GetColouredName(IPlayer player)
        {
            var playerData = new PlayerData();
            if (allColourData.ContainsKey(player.Id)) 
                playerData = allColourData[player.Id];

            var colouredData = GetColouredName(player, playerData);
            if (!string.IsNullOrEmpty(colouredData.Colour))
                return $"<color={colouredData.Colour}>{player.Name}</color>";

            return colouredData.Name;
        }

        private string API_GetColouredMessage(IPlayer player, string message)
        {
            var playerData = new PlayerData();
            if (allColourData.ContainsKey(player.Id)) playerData = allColourData[player.Id];

            return GetColouredMessage(player, playerData, message);
        }

        private string API_GetColouredChatMessage(IPlayer iPlayer, Chat.ChatChannel channel,
            string message)
        {
            var colouredChatMessage = FromMessage(iPlayer, channel, message);

            var formattedMessage = colouredChatMessage.GetChatOutput();

            if (BetterChatIns())
            {
                Dictionary<string, object> betterChatMessageData = BetterChat.CallHook("API_GetMessageData", iPlayer, message) as Dictionary<string, object>;

                if (!string.IsNullOrEmpty(colouredChatMessage.Name)) betterChatMessageData["Username"] = colouredChatMessage.Name;
                if (!string.IsNullOrEmpty(colouredChatMessage.Colour)) { ((Dictionary<string, object>)betterChatMessageData["UsernameSettings"])["Color"] = colouredChatMessage.Colour; }

                formattedMessage = BetterChat.CallHook("API_GetFormattedMessageFromDict", betterChatMessageData) as string;
            }

            return formattedMessage;
        }

        public struct ColouredChatMessage
        {
            public IPlayer Player;
            public Chat.ChatChannel ChatChannel;
            public string Name;
            public string Colour;
            public string Message;

            private static readonly Dictionary<string, object> _colouredChatDictionary = new Dictionary<string, object>();
            
            public ColouredChatMessage(IPlayer player, Chat.ChatChannel chatChannel, string name, string colour, string message)
            {
                Player = player;
                ChatChannel = chatChannel;
                Name = name;
                Colour = colour;
                Message = message;
            }

            /// <summary>
            /// Gets coloured chat dictionary
            /// <remarks>Note: this is a shared dictionary instance over all ColouredChatMessage's, do not store random stuff in here!</remarks>
            /// </summary>
            /// <returns></returns>
            public Dictionary<string, object> GetDictionary()
            {
                _colouredChatDictionary[nameof(Player)] = Player;
                _colouredChatDictionary[nameof(ChatChannel)] = ChatChannel;
                _colouredChatDictionary[nameof(Name)] = Name;
                _colouredChatDictionary[nameof(Colour)] = Colour;
                _colouredChatDictionary[nameof(Message)] = Message;
                return _colouredChatDictionary;
            }

            public static ColouredChatMessage FromDictionary(Dictionary<string, object> dict)
            {
                return new ColouredChatMessage()
                {
                    Player = dict[nameof(Player)] as IPlayer,
                    ChatChannel = (Chat.ChatChannel)dict[nameof(ChatChannel)],
                    Name = dict[nameof(Name)] as string,
                    Colour = dict[nameof(Colour)] as string,
                    Message = dict[nameof(Message)] as string,
                };
            }     
            
            public string GetChatOutput()
            {
                return string.Format(ChatFormat, $"<color={Colour}>{Name}</color>", Message);
            }
        }
        
        #endregion

    }
}


// --- End of file: ColouredChat.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/christmas-tree-presents ---
// --- Original File Path: C/ChristmasTreePresents/ChristmasTreePresents.cs ---

using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;
using Random = UnityEngine.Random;

/*
 * Changelog
 *
 * - Partial rewrite - Wrecks
 *
 * Version 2.0.0
 * - Rewrote Config.
 * - Removed usage of findobjectsoftype.
 * - Cache Trees on Load and any new ones after.
 * - Added a Timer to config.
 * - If you used the old version, Delete config and Load this version.
 * - Added Lang with Delivery Message.
 * - Added Ability to Give Custom Gifts to Override Vanilla Gifts.
 */

namespace Oxide.Plugins
{
    [Info("Christmas Tree Presents", "redBDGR / Wrecks", "2.0.0")]
    [Description("Spawns Christmas presents under Christmas trees")]
    public class ChristmasTreePresents : RustPlugin
    {
        #region Variables

        private const string Gift = "assets/prefabs/misc/xmas/giftbox/giftbox_loot.prefab";
        private readonly HashSet<ChristmasTree> _christmasTrees = new();
        private Timer _spawnTimer;

        #endregion

        #region Config

        public class Settings
        {
            [JsonProperty("How Often to Spawn Presents in Minutes")] public int SpawnTimer;
            [JsonProperty("Minimum number of presents per tree")] public int MinNumOfPresents;
            [JsonProperty("Maximum number of presents per tree")] public int MaxNumOfPresents;
            [JsonProperty("Tree needs all ornaments?")] public bool TreeNeedsAllOrnaments;
            [JsonProperty("Tree needs to be on foundation?")] public bool TreeNeedsToBeOnFoundation;
            [JsonProperty("Send Custom Gifts?(Clears Vanilla and Adds Your Own)")] public bool SendCustomGifts;
            [JsonProperty("Minimum number of Custom Gifts per Present")] public int MinNumOfCustomGifts;
            [JsonProperty("Maximum number of Custom Gifts per Present")] public int MaxNumOfCustomGifts;
        }

        public class Items
        {
            [JsonProperty("Shortname")] public string Shortname { get; set; }
            [JsonProperty("SkinID")] public ulong SkinId { get; set; }
            [JsonProperty("Probability (0-1)")] public float Probability { get; set; }
            [JsonProperty("Custom Name")] public string CustomName { get; set; }
            [JsonProperty("Minimum Amount")] public int MinimumAmount { get; set; }
            [JsonProperty("Maximum Amount")] public int MaximumAmount { get; set; }
        }

        private static Configuration _config;

        public class Configuration
        {
            [JsonProperty("Settings")] public Settings Settings;
            [JsonProperty("Items")] public List<Items> ItemsList;

            public static Configuration DefaultConfig()
            {
                return new Configuration
                {
                    Settings = new Settings()
                    {
                        SpawnTimer = 180,
                        MinNumOfPresents = 3,
                        MaxNumOfPresents = 4,
                        TreeNeedsAllOrnaments = true,
                        TreeNeedsToBeOnFoundation = true,
                        SendCustomGifts = false,
                        MinNumOfCustomGifts = 1,
                        MaxNumOfCustomGifts = 2
                    },
                    ItemsList = new List<Items>()
                    {
                        new()
                        {
                            Shortname = "snowball",
                            SkinId = 0,
                            Probability = 0.5f,
                            CustomName = "",
                            MinimumAmount = 1,
                            MaximumAmount = 1
                        },
                        new()
                        {
                            Shortname = "scrap",
                            SkinId = 0,
                            Probability = 0.5f,
                            CustomName = "",
                            MinimumAmount = 1,
                            MaximumAmount = 1
                        },
                        new()
                        {
                            Shortname = "blood",
                            SkinId = 0,
                            Probability = 0.5f,
                            CustomName = "",
                            MinimumAmount = 1,
                            MaximumAmount = 1
                        },
                        new()
                        {
                            Shortname = "bleach",
                            SkinId = 0,
                            Probability = 0.5f,
                            CustomName = "",
                            MinimumAmount = 1,
                            MaximumAmount = 1
                        },
                        new()
                        {
                            Shortname = "sticks",
                            SkinId = 0,
                            Probability = 0.5f,
                            CustomName = "",
                            MinimumAmount = 1,
                            MaximumAmount = 1
                        }
                    }
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) LoadDefaultConfig();
                SaveConfig();
            }
            catch (Exception ex)
            {
                Debug.LogException(ex);
                PrintWarning("Creating new configuration file.");
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig() => _config = Configuration.DefaultConfig();
        protected override void SaveConfig() => Config.WriteObject(_config);

        #endregion

        #region Language

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages
            (new Dictionary<string, string>
            {
                ["Message"] = "Gifts are being Delivered, Be sure to Check under your <color=green>Christmas Tree</color>!"
            }, this);
        }

        #endregion

        #region Oxide Hooks

        private void OnServerInitialized()
        {
            CacheTrees();
            StartTimer();
        }

        private void Unload()
        {
            Clear();
        }

        private void OnEntitySpawned(BaseEntity entity)
        {
            if (entity == null)
            {
                return;
            }
            if (entity is ChristmasTree tree)
            {
                _christmasTrees.Add(tree);
            }
        }

        private void OnEntityKill(BaseEntity entity)
        {
            if (entity == null)
            {
                return;
            }
            if (entity is ChristmasTree tree)
            {
                _christmasTrees.Remove(tree);
            }
        }

        #endregion

        #region Helper Methods

        private void Clear()
        {
            _spawnTimer?.Destroy();
            _christmasTrees.Clear();
        }

        private void StartTimer()
        {
            _spawnTimer = timer.Every(_config.Settings.SpawnTimer * 60, TrySpawn);
        }

        private void CacheTrees()
        {
            foreach (var entity in BaseNetworkable.serverEntities)
            {
                if (entity is ChristmasTree tree)
                {
                    _christmasTrees.Add(tree);
                }
            }
        }

        private void TrySpawn()
        {
            SendMessage();
            foreach (var tree in _christmasTrees)
            {
                if (tree == null || tree.IsDestroyed)
                {
                    continue;
                }
                SpawnPresents(tree);
            }
        }

        private void SendMessage()
        {
            string message = lang.GetMessage("Message", this);
            Server.Broadcast(message);
        }

        private void SpawnPresents(ChristmasTree tree)
        {
            if (_config.Settings.TreeNeedsAllOrnaments)
            {
                if (!CheckOrnaments(tree))
                {
                    return;
                }
            }
            if (_config.Settings.TreeNeedsToBeOnFoundation)
            {
                if (!CheckBuilding(tree))
                {
                    return;
                }
            }
            for (int i = 0; i < Random.Range(_config.Settings.MinNumOfPresents, _config.Settings.MaxNumOfPresents + 1); i++)
            {
                CreatePresent(new Vector3(Random.Range(-1.2f, 1.2f), 0, Random.Range(-1.2f, 1.2f)) + tree.transform.localPosition, Quaternion.Euler(0f, Random.Range(0f, 360f), 0f));
            }
        }

        private void CreatePresent(Vector3 pos, Quaternion rot)
        {
            BaseEntity present = GameManager.server.CreateEntity(Gift, pos, rot);
            if (present == null)
            {
                return;
            }
            present.Spawn();
            if (!_config.Settings.SendCustomGifts) return;
            var inventory = present.GetComponent<StorageContainer>().inventory;
            AddCustomLoot(inventory);
        }

        private void AddCustomLoot(ItemContainer inventory)
        {
            inventory.Clear();
            var list = _config.ItemsList;
            if (list == null) return;
            var lootCount = Random.Range(_config.Settings.MinNumOfCustomGifts, _config.Settings.MaxNumOfCustomGifts + 1);
            var lootTable = list;
            for (var i = 0; i < lootCount;)
            {
                var entry = lootTable[Random.Range(0, lootTable.Count)];
                var chance = Random.Range(0f, 1f);
                if (chance > entry.Probability)
                {
                    continue;
                }
                var amount = Random.Range(entry.MinimumAmount, entry.MaximumAmount + 1);
                var item = ItemManager.CreateByName(entry.Shortname, amount, entry.SkinId);
                if (!string.IsNullOrEmpty(entry.CustomName))
                {
                    item.name = entry.CustomName;
                }
                inventory.GiveItem(item);
                i++;
            }
        }

        private static bool CheckOrnaments(ChristmasTree tree)
        {
            return tree.GetComponent<StorageContainer>().inventory.IsFull();
        }

        private static bool CheckBuilding(ChristmasTree tree)
        {
            DecayEntity decay = tree.GetComponent<DecayEntity>();
            if (decay == null)
            {
                return false;
            }
            return decay.GetBuilding() != null;
        }

        #endregion
    }
}

// --- End of file: ChristmasTreePresents.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/code-lock-auth-api ---
// --- Original File Path: C/CodeLockAuthAPI/CodeLockAuthAPI.cs ---

ï»¿using System.Linq;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
	[Info("CodeLock Auth API", "2CHEVSKII", "0.1.1")]
	[Description("API for checking player authorization to code locks in building")]
	class CodeLockAuthAPI : CovalencePlugin
	{
		#region API

		bool IsCodeLocksAuthorized(ulong userid, BuildingManager.Building building, bool acceptGuest = true, bool noLockBehaviour = true, bool acceptAny = false)
		{
			return Authed(userid, building, acceptGuest, noLockBehaviour, acceptAny);
		}

		bool IsCodeLocksAuthorized(string userIDString, BuildingManager.Building building, bool acceptGuest = true, bool noLockBehaviour = true, bool acceptAny = false)
		{
			ulong userid;
			if(string.IsNullOrEmpty(userIDString) || !ulong.TryParse(userIDString, out userid))
			{
				return false;
			}

			return IsCodeLocksAuthorized(userid, building, acceptGuest, noLockBehaviour,acceptAny);
		}

		bool IsCodeLocksAuthorized(IPlayer player, BuildingManager.Building building, bool acceptGuest = true, bool noLockBehaviour = true, bool acceptAny = false)
		{
			var obj = player?.Object as BasePlayer;

			return IsCodeLocksAuthorized(obj, building, acceptGuest, noLockBehaviour, acceptAny);
		}

		bool IsCodeLocksAuthorized(BasePlayer player, BuildingManager.Building building, bool acceptGuest = true, bool noLockBehaviour = true, bool acceptAny = false)
		{
			if(!player)
			{
				return false;
			}

			return IsCodeLocksAuthorized(player.userID, building, acceptGuest, noLockBehaviour, acceptAny);
		}

		bool IsCodeLocksAuthorized(ulong userid, BaseEntity entity, bool acceptGuest = true, bool noLockBehaviour = true, bool acceptAny = false)
		{
			return Authed(userid, GetEntityBuilding(entity), acceptGuest, noLockBehaviour, acceptAny);
		}

		bool IsCodeLocksAuthorized(string userIDString, BaseEntity entity, bool acceptGuest = true, bool noLockBehaviour = true, bool acceptAny = false)
		{
			return IsCodeLocksAuthorized(userIDString, GetEntityBuilding(entity), acceptGuest, noLockBehaviour, acceptAny);
		}

		bool IsCodeLocksAuthorized(IPlayer player, BaseEntity entity, bool acceptGuest = true, bool noLockBehaviour = true, bool acceptAny = false)
		{
			return IsCodeLocksAuthorized(player, GetEntityBuilding(entity), acceptGuest, noLockBehaviour, acceptAny);
		}

		bool IsCodeLocksAuthorized(BasePlayer player, BaseEntity entity, bool acceptGuest = true, bool noLockBehaviour = true, bool acceptAny = false)
		{
			return IsCodeLocksAuthorized(player, GetEntityBuilding(entity), acceptGuest, noLockBehaviour, acceptAny);
		}

		#endregion

		#region Check

		public BuildingManager.Building GetEntityBuilding(BaseEntity entity)
		{
			return entity?.GetBuildingPrivilege()?.GetBuilding();
		}

		public bool Authed(ulong userid, BuildingManager.Building building, bool guest, bool noLock, bool any)
		{
			if(building == null)
			{
				return false;
			}

			var locks = building.decayEntities.SelectMany(de => de.children?.OfType<CodeLock>()).Where(cl => cl != null).ToArray();

			var count = locks.Length;

			if(count < 1)
			{
				return noLock;
			}

			var count2 = 0;

			for(int i = 0; i < count; i++)
			{
				var cl = locks[i];
				var flag = false;

				if(cl.whitelistPlayers.Contains(userid) || (guest && cl.guestPlayers.Contains(userid)))
				{
					flag = true;
				}

				if(!flag)
				{
					continue;
				}

				if(any)
				{
					return true;
				}

				count2++;
			}

			return count2 == count;
		}

		#endregion
	}
}


// --- End of file: CodeLockAuthAPI.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/claim-rewards ---
// --- Original File Path: C/ClaimRewards/ClaimRewards.cs ---

using Newtonsoft.Json;
using Oxide.Core;
using System;
using System.Collections.Generic;

namespace Oxide.Plugins

{
    [Info("Claim Rewards", "DutchKingCobra", "2.0.9")]
    [Description("Claim rewards after certain amount of kills.")]
    // killing yourself not counted anymore
    //killing clanmates not counting anymore
    class ClaimRewards : RustPlugin
    {

        private PluginConfig config;
        private Dictionary<ulong, Dictionary<string, string>> PlayerData;
        Dictionary<string, string> PData;
        readonly Dictionary<string, string> items = new Dictionary<string, string>();
        #region Hooks
        private void Init()
        {
            Registerpermissions();

            config = Config.ReadObject<PluginConfig>();
            if (config == null)
            {
                LoadDefaultConfig();
            }

            if (Config["ChatCommand", "Rewards"] == null) //for ppl already using this plugin just add this ection to config!!!!
            {
                Config["ChatCommand", "Rewards"] = "rw";
                Config["ChatCommand", "Claim"] = "gimme";
                Config["ChatCommand", "Discard"] = "discard";
                Config["ChatCommand", "Nextreward"] = "nextreward";
                SaveConfig();
            }

            cmd.AddChatCommand(config.chatcommands.chatcmdreward, this, nameof(Cmdrw));
            cmd.AddChatCommand(config.chatcommands.chatcmdclaim, this, nameof(Cmdclaim));
            cmd.AddChatCommand(config.chatcommands.chatcmddiscard, this, nameof(Cmddiscard));
            cmd.AddChatCommand(config.chatcommands.chatcmdnextreward, this, nameof(Cmdnextreward));

            PlayerData = Interface.Oxide.DataFileSystem.ReadObject<Dictionary<ulong, Dictionary<string, string>>>("ClaimRewardsPlayerData");
        }

        void OnServerInitialized()
        {
            foreach (ItemDefinition definition in ItemManager.itemList)
            {
                items.Add(definition.shortname, definition.displayName.english);
                // Interface.Oxide.DataFileSystem.WriteObject("items.dump", items);
            }
        }
        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (info == null || entity == null) return;
            if (info.HitEntity == null || info.HitEntity.tag != "Player") return;

            var player = info.InitiatorPlayer;
            if (player == null) { return; }
          
            if (!permission.UserHasPermission(player.UserIDString, this.Name.ToLower() + ".use")) { return; } //dont count for players without perm.
         
            if (player.UserIDString.Length < 10) { return; } //don't count kills for bots we dont want the server giving them stuff :P

            var killer = info.InitiatorPlayer.ToString();
            var victim = entity.ToString();
            if (killer == victim) return; //killing yourself no longer gets you free kills

            if (killer.IndexOf(' ') != -1 && victim.IndexOf(' ') != -1)
            {
                var clantagkiller = "none";
                var clantagvictim = "none";
                int kint = killer.IndexOf(' ');
                clantagkiller = killer.Substring(0, kint);
                int vint = victim.IndexOf(' ');
                clantagvictim = victim.Substring(0, vint);
                if (clantagkiller == clantagvictim) { return; } //killing clanmembers no longer gets you free kills
            }

            IncKillsAndCheckIfReward(player);
        }
        object OnPlayerDeath(BasePlayer player)
        {
            if (config.conf.oneLife == true)
            {
                if (PlayerData.TryGetValue(player.userID, out PData))
                {
                    PData["mykills"] = "0";
                }
            }
            return null;
        }

        void OnServerSave()
        {
            SaveData();
        }
        private void Unload()
        {
            SaveData();
        }
        #endregion
        #region Permissions
        public void Registerpermissions()
        {
            permission.RegisterPermission(this.Name.ToLower() + ".use", this);
        }
        public bool HasPerm(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, this.Name.ToLower() + ".use"))
            {
                player.ChatMessage(msg("noperm", player.UserIDString));
                return false;
            }
            return true;
        }

        #endregion
        #region Subs
        private void IncKillsAndCheckIfReward(BasePlayer player)
        {
            int kills;
            if (!PlayerData.TryGetValue(player.userID, out PData))
            {
                PlayerData[player.userID] = PData = new Dictionary<string, string>();
                PData.Add("mykills", "0");
            }

            if (PlayerData.TryGetValue(player.userID, out PData))
            {

                if (int.TryParse(PData["mykills"], out kills))
                {
                    if (kills < config.conf.maxKills - 1)
                    {
                        kills += 1;
                        PData["mykills"] = kills.ToString();
                    }
                    else
                    {
                        PData["mykills"] = "1";
                        kills = 1;
                    }

                    //Check if Reward
                    if (Config["Rewards", PData["mykills"]] == null) { return; }

                    var reward = Config["Rewards", PData["mykills"]].ToString();

                    var rw = Getitemdetails(reward);

                    if (rw == null)
                    {
                        return;
                    }

                    if (config.conf.autoGiveRewards == true)
                    {
                        GiveReward(player, reward, kills.ToString());
                        return;
                    }

                    AddReward(player.userID, kills.ToString(), reward);

                    player.ChatMessage(msg("rewardadded", player.UserIDString, kills.ToString(), rw.Item3, rw.Item2));
                    player.ChatMessage(msg("crrewards", player.UserIDString));

                }
            }


        }
        private void AddReward(ulong userID, string atKill, string TheReward)
        {
            if (PlayerData.TryGetValue(userID, out PData))
            {
                if (!PData.ContainsKey(atKill))
                {
                    PData.Add(atKill, TheReward);
                }
            }
        }

        private void RemoveReward(ulong userID, string atKill)
        {
            if (PlayerData.TryGetValue(userID, out PData))
            {
                PData.Remove(atKill);
            }
        }
        private void Listrewards(BasePlayer player)
        {
            if (!PlayerData.TryGetValue(player.userID, out PData))
            {
                PlayerData[player.userID] = PData = new Dictionary<string, string>();
                PData.Add("mykills", "0");
            }

            if (PlayerData.TryGetValue(player.userID, out PData))
            {
                if (PData["mykills"] == "0" || PData.Count == 1)
                {
                    player.ChatMessage(msg("norewards", player.UserIDString));
                    return;
                }
                var count = 1;
                foreach (KeyValuePair<string, string> item in PData)
                {
                    if (item.Key != "mykills" && count < 9)
                    {
                        var rw = Getitemdetails(item.Value);
                        if (rw == null)
                        {
                            return;
                        }

                        player.ChatMessage(msg("rwlistitem", player.UserIDString, item.Key, rw.Item3, rw.Item2));
                        count += 1;
                    }
                }
                player.ChatMessage(msg("rwlistsuccess", player.UserIDString));
            }
        }
        public void GiveReward(BasePlayer player, string reward, string str)
        {
            if (player.inventory.containerMain.IsFull())
            {
                player.ChatMessage(msg("invfull", player.UserIDString));

                AddReward(player.userID, str, reward);

                var rw = Getitemdetails(reward);

                if (rw == null)
                {
                    return;
                }

                player.ChatMessage(msg("rewardadded", player.UserIDString, str, rw.Item3, rw.Item2));
                player.ChatMessage(msg("crrewards", player.UserIDString));
                return;
            }
            else
            {
                GiveClaimedReward(player, reward, str);
            }

        }

        public void GiveClaimedReward(BasePlayer player, string reward, string kills)
        {
            if (player.inventory.containerMain.IsFull())
            {
                player.ChatMessage(msg("invfull", player.UserIDString));
                return;
            }

            try
            {
                if (reward == "recycler.give")
                {
                    Server.Command(reward + " " + player.userID);
                }
                else
                {

                    var rw = Getitemdetails(reward);

                    if (rw == null)
                    {
                        return;
                    }

                    int amountx;
                    int.TryParse(rw.Item2, out amountx);
                    player.inventory.GiveItem(ItemManager.CreateByName(rw.Item1, amountx));
                    player.ChatMessage(msg("rwreceived", player.UserIDString, rw.Item3, amountx));
                }
                RemoveReward(player.userID, kills);
                return;
            }
            catch (Exception ex)
            {
                Puts(ex.Message);
                throw;
            }

        }

        public Tuple<string, string, string> Getitemdetails(string sname)
        {
            string fname;
            string amount;
            if (sname != "recycler.give")
            {
                if (sname.IndexOf(' ') == -1)
                {
                    PrintError("bad format in ClaimRewards.json at string: " + sname + " Use item.shortname and quantity EX: 'metal.facemask 1' ");
                    return null;
                }
                else
                {
                    int stind = sname.IndexOf(' ');
                    amount = sname.Substring(stind, sname.Length - stind);
                    sname = sname.Substring(0, stind);

                    if (!items.ContainsKey(sname))
                    {
                        PrintError("Bad shortname in ClaimRewards.json at string: " + sname);
                        return null;
                    }
                    else
                    {
                        items.TryGetValue(sname, out fname);
                    }
                }
            }
            else
            {
                amount = "1";
                fname = "Recycler";
            }

            return new Tuple<string, string, string>(sname, amount, fname);
        }

        #endregion
        #region Config rewards
        protected override void LoadDefaultConfig()
        {
            Config["Config", "OneLife"] = false;
            Config["Config", "AutoGiveRewardsUnlessFullInventory"] = true;
            Config["Config", "MaxKillsBeforeReset"] = 35;

            Config["ChatCommand", "Rewards"] = "rw";
            Config["ChatCommand", "Claim"] = "gimme";
            Config["ChatCommand", "Discard"] = "discard";
            Config["ChatCommand", "Nextreward"] = "nextreward";

            Config["Rewards", "10"] = "bow.hunting 1";
            Config["Rewards", "20"] = "wood 250";
            Config["Rewards", "30"] = "easter.goldegg 1";
        }
        private class PluginConfig
        {
            [JsonProperty(PropertyName = "Config")]
            public ConfigSettings conf = new ConfigSettings();

            [JsonProperty(PropertyName = "ChatCommand")]
            public chatSettings chatcommands = new chatSettings();

            public class ConfigSettings
            {
                [JsonProperty(PropertyName = "OneLife")]
                public bool oneLife = false;

                [JsonProperty(PropertyName = "AutoGiveRewardsUnlessFullInventory")]
                public bool autoGiveRewards = true;

                [JsonProperty(PropertyName = "MaxKillsBeforeReset")]
                public int maxKills = 35;
            }
            public class chatSettings
            {
                [JsonProperty(PropertyName = "Rewards")]
                public string chatcmdreward = "rw";

                [JsonProperty(PropertyName = "Claim")]
                public string chatcmdclaim = "gimme";

                [JsonProperty(PropertyName = "Discard")]
                public string chatcmddiscard = "discard";

                [JsonProperty(PropertyName = "Nextreward")]
                public string chatcmdnextreward = "nextreward";

            }
        }

        #endregion
        #region Save Data
        private void SaveData()
        {
            Interface.Oxide.DataFileSystem.WriteObject("ClaimRewardsPlayerData", PlayerData);
        }
        #endregion
        #region Language
        private string msg(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["rewardadded"] = "Reward ({0}) {1} x {2} added to claim list.",
                ["crrewar