e = 1;
        private int mediumBagsToUse = 1;
        private int largeBagsToUse = 1;
        private int mediumEggsToUse = 1;
        private int largeEggsToUse = 1;
        private int SantaDropToUse = 1;
        private Dictionary<string, int> amountNeededDic = new Dictionary<string, int>();

        private int smallMinItems = 1;
        private int smallMaxItems = 4;
        private int mediumMinItems = 3;
        private int mediumMaxItems = 3;
        private int largeMinItems = 5;
        private int largeMaxItems = 5;

        private int mediumMinEggsItems = 3;
        private int mediumMaxEggsItems = 3;
        private int largeMinEggsItems = 5;
        private int largeMaxEggsItems = 5;

        private int mediumMinBagsItems = 3;
        private int mediumMaxBagsItems = 3;
        private int largeMinBagsItems = 5;
        private int largeMaxBagsItems = 5;

        private int santaMinItems = 6;
        private int santaMaxItems = 12;

        private bool weaponsSpawnWithAmmo = true;
        private bool sureItemsWillAlwaysSpawn = false;
        #endregion

        #region Oxide Hooks
        private void Init()
        {
            PresentData = Interface.Oxide.DataFileSystem.GetFile("HolidayLoot/SmallPresents");
            PresentData2 = Interface.Oxide.DataFileSystem.GetFile("HolidayLoot/MediumPresents");
            PresentData3 = Interface.Oxide.DataFileSystem.GetFile("HolidayLoot/LargePresents");
            HalloweenData2 = Interface.Oxide.DataFileSystem.GetFile("HolidayLoot/MediumHalloweenBags");
            HalloweenData3 = Interface.Oxide.DataFileSystem.GetFile("HolidayLoot/LargeHalloweenBags");
            EasterData2 = Interface.Oxide.DataFileSystem.GetFile("HolidayLoot/SilverEggs");
            EasterData3 = Interface.Oxide.DataFileSystem.GetFile("HolidayLoot/GoldEggs");
            SantaData = Interface.Oxide.DataFileSystem.GetFile("HolidayLoot/SantaDrop");
            LoadData();
            AddDefaultItems();
            LoadVariables();
            amountNeededDic.Add("xmas.present.large", largePresentsToUse);
            amountNeededDic.Add("xmas.present.medium", mediumPresentsToUse);
            amountNeededDic.Add("xmas.present.small", smallPresentsToUse);
            amountNeededDic.Add("halloween.lootbag.large", largeBagsToUse);
            amountNeededDic.Add("halloween.lootbag.medium", mediumBagsToUse);
            amountNeededDic.Add("easter.goldegg", largeEggsToUse);
            amountNeededDic.Add("easter.silveregg", mediumEggsToUse);
            amountNeededDic.Add("presentdrop", SantaDropToUse);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                //chat
                ["No Permission"] = "You are not allowed to use this command",
                ["Tables Reloaded"] = "The Holiday Loot data tables have been reloaded",
                ["NotEnoughItems"] = "You do not have enough of this item to unwrap it!",
            }, this);
        }
        #endregion

        #region Functions
        private void AddDefaultItems()
        {
            bool updated = false;

            // Christmas Present Loot
            if (smallList.Count == 0)
            {
                smallList.Add(new ItemInfo { attachments = new Dictionary<string, float>(), minItemAmount = 4, chance = 0.20f, itemName = "chocholate", maxItemAmount = 5, skinID = 0 });
                smallList.Add(new ItemInfo { attachments = new Dictionary<string, float>(), minItemAmount = 10, chance = 0.20f, itemName = "metal.fragments", maxItemAmount = 50, skinID = 0 });
                updated = true;
            }
            if (mediumList.Count == 0)
            {
                mediumList.Add(new ItemInfo { attachments = new Dictionary<string, float>(), minItemAmount = 3, chance = 0.20f, itemName = "metalspring", maxItemAmount = 5, skinID = 0 });
                mediumList.Add(new ItemInfo { attachments = new Dictionary<string, float>(), minItemAmount = 1, chance = 0.20f, itemName = "pistol.revolver", maxItemAmount = 1, skinID = 0 });
                mediumList.Add(new ItemInfo { attachments = new Dictionary<string, float>(), minItemAmount = 1, chance = 0.20f, itemName = "stocking.small", maxItemAmount = 1, skinID = 0 });
                updated = true;
            }
            if (largeList.Count == 0)
            {
                largeList.Add(new ItemInfo { attachments = new Dictionary<string, float>(), minItemAmount = 1, chance = 0.20f, itemName = "stocking.large", maxItemAmount = 1, skinID = 0 });
                largeList.Add(new ItemInfo { attachments = new Dictionary<string, float> { { "weapon.mod.holosight", 0.5f }, { "weapon.mod.lasersight", 0.5f } }, minItemAmount = 1, chance = 0.20f, itemName = "shotgun.pump", maxItemAmount = 1, skinID = 0 });
                largeList.Add(new ItemInfo { attachments = new Dictionary<string, float>(), minItemAmount = 5, chance = 0.20f, itemName = "ammo.shotgun", maxItemAmount = 15, skinID = 0 });
                updated = true;
            }

            // Halloween Loot Bags
            if (mediumListHalloween.Count == 0)
            {
                mediumListHalloween.Add(new ItemInfo { attachments = new Dictionary<string, float>(), minItemAmount = 3, chance = 0.20f, itemName = "metalspring", maxItemAmount = 5, skinID = 0 });
                mediumListHalloween.Add(new ItemInfo { attachments = new Dictionary<string, float>(), minItemAmount = 1, chance = 0.20f, itemName = "pistol.revolver", maxItemAmount = 1, skinID = 0 });
                updated = true;
            }
            if (largeListHalloween.Count == 0)
            {
                largeListHalloween.Add(new ItemInfo { attachments = new Dictionary<string, float> { { "weapon.mod.holosight", 0.5f }, { "weapon.mod.lasersight", 0.5f } }, minItemAmount = 1, chance = 0.20f, itemName = "shotgun.pump", maxItemAmount = 1, skinID = 0 });
                largeListHalloween.Add(new ItemInfo { attachments = new Dictionary<string, float>(), minItemAmount = 5, chance = 0.20f, itemName = "ammo.shotgun", maxItemAmount = 15, skinID = 0 });
                updated = true;
            }

            // Easter Egg Loot
            if (mediumListEaster.Count == 0)
            {
                mediumListEaster.Add(new ItemInfo { attachments = new Dictionary<string, float>(), minItemAmount = 3, chance = 0.20f, itemName = "metalspring", maxItemAmount = 5, skinID = 0 });
                mediumListEaster.Add(new ItemInfo { attachments = new Dictionary<string, float>(), minItemAmount = 1, chance = 0.20f, itemName = "pistol.revolver", maxItemAmount = 1, skinID = 0 });
                updated = true;
            }
            if (largeListEaster.Count == 0)
            {
                largeListEaster.Add(new ItemInfo { attachments = new Dictionary<string, float> { { "weapon.mod.holosight", 0.5f }, { "weapon.mod.lasersight", 0.5f } }, minItemAmount = 1, chance = 0.20f, itemName = "shotgun.pump", maxItemAmount = 1, skinID = 0 });
                largeListEaster.Add(new ItemInfo { attachments = new Dictionary<string, float>(), minItemAmount = 5, chance = 0.20f, itemName = "ammo.shotgun", maxItemAmount = 15, skinID = 0 });
                updated = true;
            }

            //Santa Drop
            if (santaList.Count == 0)
            {
                santaList.Add(new ItemInfo { attachments = new Dictionary<string, float>(), minItemAmount = 3, chance = 0.20f, itemName = "metalspring", maxItemAmount = 5, skinID = 0 });
                santaList.Add(new ItemInfo { attachments = new Dictionary<string, float>(), minItemAmount = 1, chance = 0.20f, itemName = "pistol.revolver", maxItemAmount = 1, skinID = 0 });
                santaList.Add(new ItemInfo { attachments = new Dictionary<string, float>(), minItemAmount = 1, chance = 0.20f, itemName = "metal.fragments", maxItemAmount = 150, skinID = 0 });
                santaList.Add(new ItemInfo { attachments = new Dictionary<string, float>(), minItemAmount = 1, chance = 0.20f, itemName = "m249", maxItemAmount = 1, skinID = 0 });
                santaList.Add(new ItemInfo { attachments = new Dictionary<string, float>(), minItemAmount = 1, chance = 0.20f, itemName = "lr300", maxItemAmount = 150, skinID = 0 });
                santaList.Add(new ItemInfo { attachments = new Dictionary<string, float>(), minItemAmount = 1, chance = 0.20f, itemName = "metal.refined", maxItemAmount = 150, skinID = 0 });
                santaList.Add(new ItemInfo { attachments = new Dictionary<string, float> { { "weapon.mod.holosight", 0.5f }, { "weapon.mod.lasersight", 0.5f } }, minItemAmount = 1, chance = 0.20f, itemName = "shotgun.pump", maxItemAmount = 1, skinID = 0 });
                santaList.Add(new ItemInfo { attachments = new Dictionary<string, float>(), minItemAmount = 5, chance = 0.20f, itemName = "ammo.shotgun", maxItemAmount = 15, skinID = 0 });
                updated = true;
            }

            if (!updated) return;
            SaveData();
            LoadData();
        }

        private object OnItemAction(Item item, string action)
        {
            if (item == null || action == null || action == "" || item.skin != 0)
                return null;
            if (item.info.shortname != "xmas.present.large" && item.info.shortname != "xmas.present.medium" && item.info.shortname != "xmas.present.small" && item.info.shortname != "halloween.lootbag.medium" && item.info.shortname != "halloween.lootbag.large" && item.info.shortname != "easter.silveregg" && item.info.shortname != "easter.goldegg" && item.info.shortname != "presentdrop")
                return null;
            if (action != "unwrap")
                return null;
            BasePlayer player = item.GetRootContainer().GetOwnerPlayer();
            if (player == null)
                return null;
            if (!CheckAmountNeeded(item.info.shortname, player))
            {
                player.ChatMessage(msg("NotEnoughItems", player.UserIDString));
                return false;
            }
            GiveThink(player, item.info.shortname);
            ItemRemovalThink(item, player, amountNeededDic[item.info.shortname]);
            Effect.server.Run("assets/prefabs/misc/xmas/presents/effects/unwrap.prefab", player.transform.position);
            return false;
        }

        private bool CheckAmountNeeded(string itemName, BasePlayer player)
        {
            bool sufficent = false;
            foreach (Item item in player.inventory.containerMain.itemList)
            {
                if (item.info.shortname == itemName)
                    if (item.amount >= amountNeededDic[item.info.shortname])
                        sufficent = true;
            }
            foreach (Item item in player.inventory.containerWear.itemList)
            {
                if (item.info.shortname == itemName)
                    if (item.amount >= amountNeededDic[item.info.shortname])
                        sufficent = true;
            }
            foreach (Item item in player.inventory.containerBelt.itemList)
            {
                if (item.info.shortname == itemName)
                    if (item.amount >= amountNeededDic[item.info.shortname])
                        sufficent = true;
            }
            return sufficent;
        }

        private void GiveThink(BasePlayer player, string presentName)
        {
            foreach (Item newItem in CreateItems(presentName))
            {
                if (newItem == null)
                {
                    Puts("Item was null");
                    continue;
                }
                if (player.inventory.containerMain.IsFull())
                    newItem.Drop(player.transform.position, Vector3.down);
                else
                    newItem.MoveToContainer(player.inventory.containerMain);
            }
        }

        private List<Item> CreateItems(string presentname)
        {
            List<Item> x = new List<Item>();
            int itemCount = 0;
            switch (presentname)
            {
                case "xmas.present.small":
                    {
                        if (sureItemsWillAlwaysSpawn)
                            foreach (var entry in CheckFor100Items(smallList))
                            {
                                x.Add(entry);
                                itemCount++;
                            }
                        int maxItemAmount = Mathf.RoundToInt(UnityEngine.Random.Range(Convert.ToSingle(smallMinItems), Convert.ToSingle(smallMaxItems)));
                        while (itemCount < maxItemAmount)
                        {
                            Item item = TryMakeItem(smallList);
                            if (item == null)
                                continue;
                            x.Add(item);
                            itemCount++;
                        }
                        return x;
                    }

                case "xmas.present.medium":
                    {
                        if (sureItemsWillAlwaysSpawn)
                            foreach (var entry in CheckFor100Items(mediumList))
                            {
                                x.Add(entry);
                                itemCount++;
                            }
                        int maxItemAmount = Mathf.RoundToInt(UnityEngine.Random.Range(Convert.ToSingle(mediumMinItems), Convert.ToSingle(mediumMaxItems)));
                        while (itemCount < maxItemAmount)
                        {
                            Item item = TryMakeItem(mediumList);
                            if (item == null)
                                continue;
                            x.Add(item);
                            itemCount++;
                        }
                        return x;
                    }

                case "xmas.present.large":
                    {
                        if (sureItemsWillAlwaysSpawn)
                            foreach (var entry in CheckFor100Items(largeList))
                            {
                                x.Add(entry);
                                itemCount++;
                            }
                        int maxItemAmount = Mathf.RoundToInt(UnityEngine.Random.Range(Convert.ToSingle(largeMinItems), Convert.ToSingle(largeMaxItems)));
                        while (itemCount < maxItemAmount)
                        {
                            Item item = TryMakeItem(largeList);
                            if (item == null)
                                continue;
                            x.Add(item);
                            itemCount++;
                        }
                        return x;
                    }
                case "halloween.lootbag.medium":
                    {
                        if (sureItemsWillAlwaysSpawn)
                            foreach (var entry in CheckFor100Items(mediumListHalloween))
                            {
                                x.Add(entry);
                                itemCount++;
                            }
                        int maxItemAmount = Mathf.RoundToInt(UnityEngine.Random.Range(Convert.ToSingle(largeMinItems), Convert.ToSingle(mediumMaxBagsItems)));
                        while (itemCount < maxItemAmount)
                        {
                            Item item = TryMakeItem(mediumListHalloween);
                            if (item == null)
                                continue;
                            x.Add(item);
                            itemCount++;
                        }
                        return x;
                    }
                case "halloween.lootbag.large":
                    {
                        if (sureItemsWillAlwaysSpawn)
                            foreach (var entry in CheckFor100Items(largeListHalloween))
                            {
                                x.Add(entry);
                                itemCount++;
                            }
                        int maxItemAmount = Mathf.RoundToInt(UnityEngine.Random.Range(Convert.ToSingle(largeMinItems), Convert.ToSingle(largeMaxBagsItems)));
                        while (itemCount < maxItemAmount)
                        {
                            Item item = TryMakeItem(largeListHalloween);
                            if (item == null)
                                continue;
                            x.Add(item);
                            itemCount++;
                        }
                        return x;
                    }
                case "easter.silveregg":
                    {
                        if (sureItemsWillAlwaysSpawn)
                            foreach (var entry in CheckFor100Items(mediumListEaster))
                            {
                                x.Add(entry);
                                itemCount++;
                            }
                        int maxItemAmount = Mathf.RoundToInt(UnityEngine.Random.Range(Convert.ToSingle(largeMinItems), Convert.ToSingle(mediumMaxEggsItems)));
                        while (itemCount < maxItemAmount)
                        {
                            Item item = TryMakeItem(mediumListEaster);
                            if (item == null)
                                continue;
                            x.Add(item);
                            itemCount++;
                        }
                        return x;
                    }
                case "easter.goldegg":
                    {
                        if (sureItemsWillAlwaysSpawn)
                            foreach (var entry in CheckFor100Items(largeListEaster))
                            {
                                x.Add(entry);
                                itemCount++;
                            }
                        int maxItemAmount = Mathf.RoundToInt(UnityEngine.Random.Range(Convert.ToSingle(largeMinItems), Convert.ToSingle(largeMaxEggsItems)));
                        while (itemCount < maxItemAmount)
                        {
                            Item item = TryMakeItem(largeListEaster);
                            if (item == null)
                                continue;
                            x.Add(item);
                            itemCount++;
                        }
                        return x;
                    }
                case "presentdrop":
                    {
                        if (sureItemsWillAlwaysSpawn)
                            foreach (var entry in CheckFor100Items(santaList))
                            {
                                x.Add(entry);
                                itemCount++;
                            }
                        int maxItemAmount = Mathf.RoundToInt(UnityEngine.Random.Range(Convert.ToSingle(santaMinItems), Convert.ToSingle(santaMaxItems)));
                        while (itemCount < maxItemAmount)
                        {
                            Item item = TryMakeItem(santaList);
                            if (item == null)
                                continue;
                            x.Add(item);
                            itemCount++;
                        }
                        return x;
                    }
            }
            return x;
        }

        private Item TryMakeItem(List<ItemInfo> list)
        {
            while (true)
            {
                ItemInfo entry = list[Mathf.RoundToInt(UnityEngine.Random.Range(0f, Convert.ToSingle(list.Count - 1)))];
                if (UnityEngine.Random.Range(0f, 1f) > entry.chance)
                    continue;
                Item newItem = ItemManager.CreateByName(entry.itemName, UnityEngine.Random.Range(entry.minItemAmount, entry.maxItemAmount), (ulong)entry.skinID);
                newItem.MarkDirty();
                if (newItem == null)
                {
                    Puts($"An item could not be created successfully {entry.itemName}");
                    continue;
                }
                foreach (var attachmentName in entry.attachments)
                    if (UnityEngine.Random.Range(0f, 1f) < attachmentName.Value)
                    {
                        Item attachment = ItemManager.CreateByName(attachmentName.Key);
                        if (attachment == null)
                        {
                            Puts($"An item could not be created successfully {entry.itemName}");
                            continue;
                        }
                        attachment.MoveToContainer(newItem.contents);
                    }
                if (newItem.info.category != ItemCategory.Weapon) return newItem;
                BaseProjectile ent = newItem.GetHeldEntity()?.GetComponent<BaseProjectile>();
                if (ent == null)
                    return newItem;
                if (ent.primaryMagazine != null)
                    ent.primaryMagazine.contents = ent.primaryMagazine.capacity;
                return newItem;
            }
        }

        private List<Item> CheckFor100Items(List<ItemInfo> list)
        {
            List<Item> x = new List<Item>();
            foreach (var entry in list)
            {
                if (entry.chance <= 0.99f)
                    continue;
                Item newItem = ItemManager.CreateByName(entry.itemName, UnityEngine.Random.Range(entry.minItemAmount, entry.maxItemAmount), (ulong)entry.skinID);
                newItem.MarkDirty();
                if (newItem == null)
                {
                    Puts($"An item could not be created successfully {entry.itemName}");
                    continue;
                }
                foreach (var attachmentName in entry.attachments)
                    if (UnityEngine.Random.Range(0f, 1f) < attachmentName.Value)
                    {
                        Item attachment = ItemManager.CreateByName(attachmentName.Key);
                        if (attachment == null)
                        {
                            Puts($"An item could not be created successfully {entry.itemName}");
                            continue;
                        }
                        attachment.MoveToContainer(newItem.contents);
                    }
                if (newItem.info.category != ItemCategory.Weapon)
                {
                    x.Add(newItem);
                    continue;
                }
                BaseProjectile ent = newItem.GetHeldEntity()?.GetComponent<BaseProjectile>();
                if (ent == null) continue;
                if (ent.primaryMagazine != null)
                    ent.primaryMagazine.contents = ent.primaryMagazine.capacity;
                x.Add(newItem);
            }
            return x;
        }

        private static void ItemRemovalThink(Item item, BasePlayer player, int itemsToTake)
        {
            if (item.amount == itemsToTake)
            {
                item.RemoveFromContainer();
                item.Remove();
            }
            else
            {
                item.amount = item.amount - itemsToTake;
                player.inventory.SendSnapshot();
            }
        }

        private string msg(string key, string id = null) { return lang.GetMessage(key, this, id); }
        #endregion
    }
}

// --- End of file: HolidayLoot.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/heal ---
// --- Original File Path: H/Heal/Heal.cs ---

/***********************************************************************************************************************/
/*** DO NOT edit this file! Edit the files under `oxide/config` and/or `oxide/lang`, created once plugin has loaded. ***/
/*** Please note, support cannot be provided if the plugin has been modified. Please use a fresh copy if modified.   ***/
/***********************************************************************************************************************/

//#define DEBUG

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Heal", "Wulf", "3.1.1")]
    [Description("Allows players with permission to heal themselves or others")]
    public class Heal : CovalencePlugin
    {
        #region Configuration

        private Configuration config;

        private class Configuration
        {
            [JsonProperty("Command cooldown in seconds (0 to disable)")]
            public int CommandCooldown = 30;

            [JsonProperty("Maximum heal amount")]
            public int MaxHealAmount = 100;

            [JsonProperty("Notify target when healed")]
            public bool NotifyTarget = true;

            [JsonProperty("Use permission system")]
            public bool UsePermissions = true;

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    throw new JsonException();
                }

                if (!config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch
            {
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            LogWarning($"Configuration changes saved to {Name}.json");
            Config.WriteObject(config, true);
        }

        #endregion Configuration

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CommandCooldown"] = "Wait a bit before attempting to use '{0}' again",
                ["CommandHeal"] = "heal",
                ["CommandHealAll"] = "healall",
                ["CommandHealPlayer"] = "healplayer",
                ["NotAllowed"] = "You are not allowed to use the '{0}' command",
                ["NoPlayersFound"] = "No players found with name or ID '{0}'",
                ["NoPlayersOnline"] = "There are no players online to heal",
                ["PlayerAtMaxHealth"] = "{0} is already at max health",
                ["PlayerNotFound"] = "Player '{0}' was not found",
                ["PlayerWasHealed"] = "{0} was healed {1}",
                ["PlayerWasNotHealed"] = "{0} was unable to be healed",
                ["PlayersFound"] = "Multiple players were found, please specify: {0}",
                ["PlayersOnly"] = "Command '{0}' can only be used by players",
                ["PlayersHealed"] = "All players have been healed {0}!",
                ["YouAreAtMaxHealth"] = "You are already at max health",
                ["YouWereHealed"] = "You were healed {0}",
                ["YouWereNotHealed"] = "You were unable to be healed",
                ["UsageHeal"] = "Usage: {0} [amount] -- Heal self by specfied or default amount",
                ["UsageHealAll"] = "Usage: {0} [amount] -- Heal all players by specfied or default amount",
                ["UsageHealPlayer"] = "Usage: {0} <player name or id> [amount] -- Heal player by specfied or default amount"
            }, this);
        }

        #endregion Localization

        #region Initialization

        private readonly Hash<string, float> cooldowns = new Hash<string, float>();

        private const string permSelf = "heal.self";
        private const string permAll = "heal.all";
        private const string permPlayer = "heal.player";
        private const string permNoCooldown = "heal.nocooldown";

        private void Init()
        {
            AddLocalizedCommand(nameof(CommandHeal));
            AddLocalizedCommand(nameof(CommandHealAll));
            AddLocalizedCommand(nameof(CommandHealPlayer));

            permission.RegisterPermission(permSelf, this);
            permission.RegisterPermission(permAll, this);
            permission.RegisterPermission(permPlayer, this);
            permission.RegisterPermission(permNoCooldown, this);
            MigratePermission("healer.self", permSelf);
            MigratePermission("healer.all", permAll);
            MigratePermission("healer.others", permPlayer);
        }

        #endregion Initialization

        private bool HasCooldown(IPlayer player, string command)
        {
            if (config.CommandCooldown > 0 && !player.IsServer && !player.HasPermission(permNoCooldown))
            {
                if (!cooldowns.ContainsKey(player.Id))
                {
                    cooldowns.Add(player.Id, 0f);
                }

                if (cooldowns[player.Id] + config.CommandCooldown > Interface.Oxide.Now)
                {
                    Message(player, "CommandCooldown", command);
                    return true;
                }
            }

            return false;
        }

        private object HealPlayer(IPlayer target, float amount)
        {
            float health = target.Health;
            float healthDiff = target.MaxHealth - health;
            amount = amount < healthDiff ? amount : healthDiff;
            if (target.Health < target.MaxHealth)
            {
                target.Heal(amount);
            }
#if RUST
            BasePlayer basePlayer = target.Object as BasePlayer; // TODO: Remove Rust-specifics if implemented in core
            basePlayer.metabolism.bleeding.value = 0;
            basePlayer.metabolism.calories.value += amount;
            basePlayer.metabolism.dirtyness.value = 0;
            basePlayer.metabolism.hydration.value += amount;
            basePlayer.metabolism.oxygen.value = 1;
            basePlayer.metabolism.poison.value = 0;
            basePlayer.metabolism.radiation_level.value = 0;
            basePlayer.metabolism.radiation_poison.value = 0;
            basePlayer.metabolism.temperature.value = 32;
            basePlayer.metabolism.wetness.value = 0;
            basePlayer.StopWounded();
#endif
#if DEBUG
            Puts($"{target.Name} - Heal amount: {amount}");
            Puts($"{target.Name} - Pre health: {health}");
            Puts($"{target.Name} - Post health: {target.Health}");
            Puts($"{target.Name} - Pre health + amount: {health + amount}");
#endif
            if (health == target.MaxHealth)
            {
                return null;
            }
            else if (target.Health >= Math.Abs(health + amount))
            {
#if DEBUG
                Puts($"{target.Name} - Healed? {target.Health >= Math.Abs(health + amount)}");
#endif
                return amount;
            }

            return false;
        }

        #region Heal Command

        private void CommandHeal(IPlayer player, string command, string[] args)
        {
            if (player.IsServer)
            {
                Message(player, "PlayersOnly", command);
                return;
            }

            if (config.UsePermissions && !player.HasPermission(permSelf))
            {
                Message(player, "NotAllowed", command);
                return;
            }

            if (HasCooldown(player, command))
            {
                return;
            }

            float amount = args.Length >= 1 && float.TryParse(args.Last(), out amount) && amount > 0f ? amount : config.MaxHealAmount;
            object healed = HealPlayer(player, amount);
            if (healed is float && (float)healed > 0f)
            {
                if (config.NotifyTarget)
                {
                    Message(player, "YouWereHealed", Math.Round((float)healed, 2));
                }
                if (config.CommandCooldown > 0)
                {
                    cooldowns[player.Id] = Interface.Oxide.Now;
                }
            }
            else if (healed == null)
            {
                Message(player, "YouAreAtMaxHealth", player.Name.Sanitize());
            }
            else
            {
                Message(player, "YouWereNotHealed", player.Name.Sanitize());
            }
        }

        #endregion Heal Command

        #region Heal Player Command

        private void CommandHealPlayer(IPlayer player, string command, string[] args)
        {
            if (!config.UsePermissions && !player.IsAdmin || !player.HasPermission(permPlayer))
            {
                Message(player, "NotAllowed", command);
                return;
            }

            if (HasCooldown(player, command))
            {
                return;
            }

            if (args.Length < 1)
            {
                Message(player, "UsageHealPlayer", command);
                return;
            }

            IPlayer target = FindPlayer(args[0], player);
            if (target == null)
            {
                return;
            }

            float amount = args.Length > 1 && float.TryParse(args.Last(), out amount) && amount > 0f ? amount : config.MaxHealAmount;
            object healed = HealPlayer(target, amount);
            if (healed is float && (float)healed > 0f)
            {
                if (config.CommandCooldown > 0 && !player.HasPermission(permNoCooldown))
                {
                    cooldowns[player.Id] = Interface.Oxide.Now;
                }
                if (!Equals(target.Id, player.Id))
                {
                    Message(player, "PlayerWasHealed", target.Name.Sanitize(), Math.Round((float)healed, 2));
                }
            }
            else if (healed == null)
            {
                Message(player, "PlayerAtMaxHealth", target.Name.Sanitize());
            }
            else
            {
                Message(player, "PlayerWasNotHealed", target.Name.Sanitize());
            }
        }

        #endregion Heal Player Command

        #region Heal All Command

        private void CommandHealAll(IPlayer player, string command, string[] args)
        {
            if (!config.UsePermissions && !player.IsAdmin || !player.HasPermission(permAll))
            {
                Message(player, "NotAllowed", command);
                return;
            }

            if (HasCooldown(player, command))
            {
                return;
            }

            if (!players.Connected.Any())
            {
                Message(player, "NoPlayersOnline");
                return;
            }

            float amount = args.Length > 1 && float.TryParse(args.Last(), out amount) && amount > 0f ? amount : config.MaxHealAmount;
            foreach (IPlayer target in players.Connected)
            {
                HealPlayer(target, amount);
            }
            if (config.CommandCooldown > 0 && !player.HasPermission(permNoCooldown))
            {
                cooldowns[player.Id] = Interface.Oxide.Now;
            }
            Message(player, "PlayersHealed", amount);
        }

        #endregion Heal All Command

        #region Helpers

        private void AddLocalizedCommand(string command)
        {
            foreach (string language in lang.GetLanguages(this))
            {
                Dictionary<string, string> messages = lang.GetMessages(language, this);
                foreach (KeyValuePair<string, string> message in messages)
                {
                    if (message.Key.Equals(command))
                    {
                        if (!string.IsNullOrEmpty(message.Value))
                        {
                            AddCovalenceCommand(message.Value, command);
                        }
                    }
                }
            }
        }

        private IPlayer FindPlayer(string playerNameOrId, IPlayer player)
        {
            IPlayer[] foundPlayers = players.FindPlayers(playerNameOrId).ToArray();
            if (foundPlayers.Length > 1)
            {
                Message(player, "PlayersFound", string.Join(", ", foundPlayers.Select(p => p.Name).Take(10).ToArray()).Truncate(60));
                return null;
            }

            IPlayer target = foundPlayers.Length == 1 ? foundPlayers[0] : null;
            if (target == null)
            {
                Message(player, "NoPlayersFound", playerNameOrId);
                return null;
            }

            return target;
        }

        private string GetLang(string langKey, string playerId = null, params object[] args)
        {
            return string.Format(lang.GetMessage(langKey, this, playerId), args);
        }

        private void Message(IPlayer player, string textOrLang, params object[] args)
        {
            if (player.IsConnected)
            {
                string message = GetLang(textOrLang, player.Id, args);
                player.Reply(message != textOrLang ? message : textOrLang);
            }
        }

        private void MigratePermission(string oldPerm, string newPerm)
        {
            foreach (string groupName in permission.GetPermissionGroups(oldPerm))
            {
                permission.GrantGroupPermission(groupName, newPerm, null);
                permission.RevokeGroupPermission(groupName, oldPerm);
            }

            foreach (string playerId in permission.GetPermissionUsers(oldPerm))
            {
                permission.GrantUserPermission(Regex.Replace(playerId, "[^0-9]", ""), newPerm, null);
                permission.RevokeUserPermission(Regex.Replace(playerId, "[^0-9]", ""), oldPerm);
            }
        }

        #endregion Helpers
    }
}

// --- End of file: Heal.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/hardcore-workbench ---
// --- Original File Path: H/HardcoreWorkbench/HardcoreWorkbench.cs ---

using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Game.Rust.Cui;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Hardcore Workbench", "Marat", "1.0.4")]
    [Description("Removes tech tree from workbenches")]
    public class HardcoreWorkbench : RustPlugin
    {
        #region Variables
        
        private const string WorkbenchLayer = "UI_WorkbenchLayer";
        private const string permissionName = "hardcoreworkbench.use";
        private readonly Dictionary<BasePlayer, WorkbenchBehavior> benchOpen = new();
        private readonly List<BaseEntity> vendingMachine = new();
        
        #endregion
        
        #region Hooks
        
        private void OnServerInitialized()
        {
            LoadData();
            if (config.usePermission) permission.RegisterPermission(permissionName, this);
            
            foreach (var bp in ItemManager.GetBlueprints())
            {
                if (!storedData.cachedLevel.ContainsKey(bp.name))
                {
                    if (bp.workbenchLevelRequired < 1) continue;
                    storedData.cachedLevel.Add(bp.name, bp.workbenchLevelRequired);
                    SaveData();
                }
                bp.workbenchLevelRequired = config.disableCraftMode ? 0 : storedData.cachedLevel[bp.name];
            }
            
            for (int i = 0; i < BasePlayer.activePlayerList.Count; i++)
            {
                OnPlayerConnected(BasePlayer.activePlayerList[i]);
            }
            
            if (config.addVehiclesParts)
            {
                foreach (var vending in UnityEngine.Object.FindObjectsOfType<NPCVendingMachine>())
                {
                    if (vending != null && vending.skinID == 860916780)
                    {
                        vending.Kill();
                    }
                }
                foreach (var monument in UnityEngine.Object.FindObjectsOfType<MonumentInfo>())
                {
                    if (monument != null && monument.name.Contains("compound"))
                    {
                        var pos = monument.transform.position + monument.transform.rotation * new Vector3(0.7f, 0.25f, 6.85f);
                        var rot = monument.transform.rotation * Quaternion.Euler(0f, 0f, 0f);
                        
                        var vending = GameManager.server.CreateEntity("assets/prefabs/deployable/vendingmachine/npcvendingmachines/npcvendingmachine_vehicleshigh.prefab", pos, rot) as NPCVendingMachine;
                        if (vending != null)
                        {
                            vending.Spawn();
                            vending.skinID = 860916780;
                            vending.SendNetworkUpdateImmediate(true);
                            vendingMachine.Add(vending);
                        }
                    }
                }
            }
        }
        
        private void Unload()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(player, WorkbenchLayer);
                OnCloseBox(player);
            }
            
            if (config.addVehiclesParts)
            {
                foreach (var machine in vendingMachine)
                {
                    if (!machine.IsDestroyed)
                        machine?.Kill();
                }
                vendingMachine.Clear();
            }
            
            foreach (var item in ItemManager.GetBlueprints())
            {
                if (storedData.cachedLevel.ContainsKey(item.name))
                    item.workbenchLevelRequired = storedData.cachedLevel[item.name];
            }
            
            config = null;
        }
        
        private void OnPlayerConnected(BasePlayer player)
        {
            if (player == null || !player.IsConnected) return;
            if (player.IsReceivingSnapshot)
            {
                timer.Once(1f, () => OnPlayerConnected(player));
                return;
            }
            
            player.ClientRPCPlayer(null, player, "craftMode", config.disableCraftMode ? 1 : 0);
        }
        
        private void CanLootEntity(BasePlayer player, Workbench container)
        {
            if (player == null || container == null) return;
            if (config.useMenuWorkbench) OpenWorkbench(player);
            else OnOpenBox(player);
        }
        
        private void OnLootEntityEnd(BasePlayer player, BaseCombatEntity entity)
        {
            if (player == null || entity == null) return;
            if (entity is Workbench && config.useMenuWorkbench)
            {
                CuiHelper.DestroyUi(player, WorkbenchLayer);
                return;
            }
            if (entity is ResearchTable)
            {
                OnCloseBox(player);
                return;
            }
        }
        
        private void OnEntityLeave(TriggerWorkbench trigger, BasePlayer player)
        {
            if (player == null || player.IsNpc) return;
            OnCloseBox(player);
        }
        
        private object CanUnlockTechTreeNode(BasePlayer player)
        {
            //player.Kick("You can't unlock the tech tree");
            //PrintWarning($"Player {player} tried to unlock the tech tree");
            return false;
        }
        
        private object OnEntityVisibilityCheck(ResearchTable table, BasePlayer player)
        {
            if (table == null || table?.net.ID == null || player == null) return null;
            if (table.GetComponent<WorkbenchBehavior>() != null)
            {
                if (table.HasFlag(BaseEntity.Flags.Reserved1) && table.HasFlag(BaseEntity.Flags.Reserved2))
                {
                    table.SetFlag(BaseEntity.Flags.Reserved3, true, false, true);
                    return false;
                }
                return true;
            }
            return null;
        }
        
        private void OnOpenBox(BasePlayer player)
        {
            if (!benchOpen.ContainsKey(player) || benchOpen[player] == null)
            {
                var box = player.gameObject.AddComponent<WorkbenchBehavior>();
                benchOpen[player] = box;
                box?.Open(player);
            }
        }
        
        private void OnCloseBox(BasePlayer player)
        {
            if (benchOpen.ContainsKey(player) && benchOpen[player] != null)
            {
                var box = benchOpen[player];
                box?.Close(player);
                benchOpen.Remove(player);
                player.gameObject.GetComponent<WorkbenchBehavior>().Destroy();
            }
        }
        
        #endregion
        
        #region Configuration
        
        private class PluginConfig
        {
            [JsonProperty("Use workbench menu")] public bool useMenuWorkbench;
            [JsonProperty("Remove need for workbench")] public bool disableCraftMode;
            [JsonProperty("Time to research item")] public float itemResearchTime;
            [JsonProperty("Add vehicles parts vending machine")] public bool addVehiclesParts;
            [JsonProperty("Use permission to open workbench")] public bool usePermission;
        }
        
        protected override void LoadDefaultConfig()
        {
            config = new PluginConfig
            {
                useMenuWorkbench = true,
                disableCraftMode = false,
                itemResearchTime = 10f,
                addVehiclesParts = true,
                usePermission = true
            };
        }
        
        private static PluginConfig config;
        
        protected override void SaveConfig() => Config.WriteObject(config);
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<PluginConfig>();
                if (config == null) LoadDefaultConfig();
            }
            catch
            {
                PrintWarning("The config file contains an error and has been replaced with the default config.");
                LoadDefaultConfig();
            }
            SaveConfig();
        }
        
        #endregion

        #region Commands
        
        [ConsoleCommand("UI_Workbench")]
        private void CmdWorkbenchUI(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player == null) return;
            if (config.usePermission && !permission.UserHasPermission(player.UserIDString, permissionName)) return;
            OnOpenBox(player);
        }
        
        #endregion

        #region Interface
        
        private void OpenWorkbench(BasePlayer player)
        {
            CuiElementContainer container = new CuiElementContainer();
            
            container.Add(new CuiElement()
            {
                Parent = "Overlay",
                Name = WorkbenchLayer,
                DestroyUi = WorkbenchLayer,
                Components =
                {
                    new CuiRectTransformComponent { AnchorMin = "0.5 0.0", AnchorMax = "0.5 0.0", OffsetMin = "192 110", OffsetMax = "573 158" },
                    new CuiImageComponent { Color = "0 0 0 0" }
                }
            });
            
            var hasPermission = config.usePermission && permission.UserHasPermission(player.UserIDString, permissionName);
            var text = GetMessage(hasPermission ? "Lang_OpenWorkbench" : "Lang_NoPermissions", player);
            var color = hasPermission ? "0.45 0.56 0.27 1.0" : "0.74 0.33 0.28 1.0";
            
            container.Add(new CuiButton
            {
                RectTransform = { AnchorMin = "0 0", AnchorMax = "1 1", OffsetMin = "128 8", OffsetMax = "-124 -7" },
                Button = { Command = "UI_Workbench", Color = color, Material = "assets/content/ui/uibackgroundblur-ingamemenu.mat" },
                Text = { Text = text, Font = "robotocondensed-bold.ttf", FontSize = 14, Align = TextAnchor.MiddleCenter, Color = "0.93 0.93 0.93 1.0" }
            }, WorkbenchLayer);
            
            CuiHelper.AddUi(player, container);
        }
        
        #endregion
        
        #region Classes
        
        public class WorkbenchBehavior : FacepunchBehaviour
        {
            private ResearchTable container;
            
            public void Awake()
            {
                container = gameObject.GetComponent<ResearchTable>();
            }
            
            public void Open(BasePlayer player)
            {
                if (player != null)
                {
                    container = CreateTable(player);
                    Invoke(() => StartLoot(player), 0.1f);
                }
            }
            
            public void Close(BasePlayer player)
            {
                if (container != null && !container.IsDestroyed)
                {
                    for (int i = container.inventory.itemList.Count - 1; i >= 0; i--)
                    {
                        player.GiveItem(container.inventory.itemList[i], BaseEntity.GiveItemReason.Generic);
                    }
                    container.inventory.itemList.Clear();
                    container.Kill();
                    UnityEngine.Object.Destroy(container);
                    container = null;
                }
                player.EndLooting();
                UnityEngine.Object.Destroy(this);
            }
            
            public void Destroy() => UnityEngine.Object.Destroy(this);
            
            public static ResearchTable CreateTable(BasePlayer player)
            {
                var table = GameManager.server.CreateEntity("assets/prefabs/deployable/research table/researchtable_deployed.prefab", player.transform.position + new Vector3(0, -1000, 0)) as ResearchTable;
                if (table == null) return null;
                
                UnityEngine.Object.DestroyImmediate(table.GetComponent<DestroyOnGroundMissing>());
                UnityEngine.Object.DestroyImmediate(table.GetComponent<GroundWatch>());
                foreach (var collider in table.GetComponentsInChildren<Collider>())
                {
                    UnityEngine.Object.DestroyImmediate(collider);
                }
                
                table._limitedNetworking = false;
                table.EnableSaving(false);
                table.researchDuration = config.itemResearchTime;
                table.Spawn();
                table.gameObject.AddComponent<WorkbenchBehavior>();
                table.SendNetworkUpdate();
                table.UpdateNetworkGroup();
                
                return table;
            }
            
            public void StartLoot(BasePlayer player)
            {
                player.inventory.loot.StartLootingEntity(container, false);
                player.inventory.loot.AddContainer(container.inventory);
                player.inventory.loot.SendImmediate();
                player.ClientRPCPlayer(null, player, "RPC_OpenLootPanel", container.panelName);
                container.SendNetworkUpdate();
                if (config.useMenuWorkbench) EffectNetwork.Send(new Effect("assets/prefabs/npc/flame turret/effects/flameturret-deploy.prefab", player, 0, new Vector3(), new Vector3()), player.Connection);
            }
        }
        
        #endregion
        
        #region Lang
        
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Lang_OpenWorkbench"] = "OPEN WORKBENCH",
                ["Lang_NoPermissions"] = "NO PERMISSION"
            }, this);
            
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Lang_OpenWorkbench"] = "ОТКРЫТЬ ВЕРСТАК",
                ["Lang_NoPermissions"] = "НЕТ РАЗРЕШЕНИЯ"
            }, this, "ru");
        }
        
        private string GetMessage(string key, BasePlayer player) => lang.GetMessage(key, this, player.UserIDString);
        
        #endregion

        #region Data
        
        private StoredData storedData;
        
        private class StoredData
        {
            public Dictionary<string, int> cachedLevel = new Dictionary<string, int>();
        }
        
        private void SaveData()
        {
            if (storedData != null)
            {
                Interface.Oxide.DataFileSystem.WriteObject($"{Name}_cachedLevel", storedData, true);
            }
        }
        
        private void LoadData()
        {
            storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>($"{Name}_cachedLevel");
            if (storedData == null)
            {
                storedData = new StoredData();
                SaveData();
            }
        }
        
        #endregion
    }
}

// --- End of file: HardcoreWorkbench.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/hit-icon ---
// --- Original File Path: H/HitIcon/HitIcon.cs ---

using UnityEngine;
using System;
using Oxide.Game.Rust.Cui;
using System.Collections;
using System.Collections.Generic;
using Oxide.Core;
using Oxide.Core.Plugins;
using System.IO;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("HitIcon", "FastBurst", "2.0.2")]
    [Description("Configurable precached icon when you hit player|friend|clan member|headshot")]
    class HitIcon : RustPlugin
    {

        [PluginReference] Plugin Friends, Clans;

        #region Variables
        private static HitIcon ins { get; set; }
        private ImageCache _imageAssets;
        private GameObject _hitObject;
        private StoredData _storedData;
        private Dictionary<ulong, UIHandler> _playersUIHandler = new Dictionary<ulong, UIHandler>();
        #endregion

        #region Oxide
        private void OnServerInitialized()
        {
            if (!configData.ConfigSettings.showDeathSkull && !configData.ConfigSettings.showNpc)
                Unsubscribe("OnEntityDeath");
            CacheImage();
            InitializeAPI();
            foreach (var player in BasePlayer.activePlayerList)
                GetUIHandler(player);
        }

        private void Loaded()
        {
            LoadData();
            InitLanguage(); ;
        }

        private void Unload()
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList)
            {
                player.GetComponent<UIHandler>()?.Destroy();
                CuiHelper.DestroyUi(player, "hitpng");
                CuiHelper.DestroyUi(player, "hitdmg");
            }
            SaveData();
            UnityEngine.Object.Destroy(_hitObject);
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            UIHandler value;
            if (!_playersUIHandler.TryGetValue(player.userID, out value)) return;
            _playersUIHandler[player.userID]?.Destroy();
            _playersUIHandler.Remove(player.userID);
        }

        private void OnPlayerAttack(BasePlayer attacker, HitInfo hitinfo) => SendHit(attacker, hitinfo);

        private void OnEntityDeath(BaseCombatEntity entity, HitInfo info) => SendDeath(entity, info);
        #endregion

        #region API
        private void InitializeAPI()
        {
            if (Friends != null)
            {
                if (configData.ConfigSettings.useFriends)
                    PrintWarning("Plugin Friends works with HitIcon");
            }

            if (Clans != null)
            {
                if (configData.ConfigSettings.useClans)
                    PrintWarning("Plugin Clans works with HitIcon");
            }
        }
        private bool AreFriends(string playerId, string friendId)
        {
            try
            {
                bool result = (bool)Friends?.CallHook("AreFriends", playerId, friendId);
                return result;
            }
            catch
            {
                return false;
            }
        }
        private bool AreClanMates(ulong playerID, ulong victimID)
        {
            var playerTag = Clans?.Call<string>("GetClanOf", playerID);
            var victimTag = Clans?.Call<string>("GetClanOf", victimID);
            if (playerTag != null)
                if (victimTag != null)
                    if (playerTag == victimTag)
                        return true;
            return false;
        }
        #endregion

        #region ImageDownloader
        private void CacheImage()
        {
            _hitObject = new GameObject();
            _imageAssets = _hitObject.AddComponent<ImageCache>();
            _imageAssets.imageFiles.Clear();
            string dataDirectory = "file://" + Interface.Oxide.DataDirectory + Path.DirectorySeparatorChar;
            _imageAssets.GetImage("hitimage", dataDirectory + "hit.png");
            _imageAssets.GetImage("deathimage", dataDirectory + "death.png");
            Download();
        }

        class ImageCache : MonoBehaviour
        {
            public Dictionary<string, string> imageFiles = new Dictionary<string, string>();
            private List<Queue> queued = new List<Queue>();
            class Queue
            {
                public string Url { get; set; }
                public string Name { get; set; }
            }

            public void OnDestroy()
            {
                foreach (var value in imageFiles.Values)
                {
                    FileStorage.server.RemoveEntityNum(new NetworkableId(ulong.MaxValue), Convert.ToUInt32(value));
                }
            }

            public void GetImage(string name, string url)
            {
                queued.Add(new Queue
                {
                    Url = url,
                    Name = name
                });
            }

            IEnumerator WaitForRequest(Queue queue)
            {
                using (var www = new WWW(queue.Url))
                {
                    yield return www;

                    if (string.IsNullOrEmpty(www.error))
                        imageFiles.Add(queue.Name, FileStorage.server.Store(www.bytes, FileStorage.Type.png, CommunityEntity.ServerInstance.net.ID).ToString());
                    else
                    {
                        Debug.LogWarning("\n\n!!!!!!!!!!!!!!!!!!!!!\n\nError downloading image files (death.png and hit.png)\nThey must be in your oxide/data/ !\n\n!!!!!!!!!!!!!!!!!!!!!\n\n");
                        ins.PrintWarning("\n\n!!!!!!!!!!!!!!!!!!!!!\n\nError downloading image files (death.png and hit.png)\nThey must be in your oxide/data/ !\n\n!!!!!!!!!!!!!!!!!!!!!\n\n");
                        ConsoleSystem.Run(ConsoleSystem.Option.Unrestricted, "oxide.unload HitIcon");
                    }
                }
            }
            public void Process()
            {
                for (int i = 0; i < 2; i++)
                    StartCoroutine(WaitForRequest(queued[i]));
            }
        }

        private string FetchImage(string name)
        {
            string result;
            if (_imageAssets.imageFiles.TryGetValue(name, out result))
                return result;
            return string.Empty;
        }

        private void Download() => _imageAssets.Process();
        #endregion

        #region CUI
        private void Png(BasePlayer player, string name, string image, string start, string end, string color)
        {
            CuiElementContainer container = new CuiElementContainer();
            container.Add(new CuiElement
            {
                Name = name,
                Components =
                {
                    new CuiRawImageComponent
                    {
                        Png = image,
                        Color = color,
                        Sprite = "assets/content/textures/generic/fulltransparent.tga"
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = start,
                        AnchorMax = end
                    }
                }
            });
            CuiHelper.AddUi(player, container);
        }

        private void Dmg(BasePlayer player, string name, string text, string start, string end, string color, int size)
        {
            CuiElementContainer container = new CuiElementContainer();
            container.Add(new CuiElement
            {
                Name = name,
                Components =
                {
                    new CuiTextComponent
                    {
                        Text = text,
                        FontSize = size,
                        Font = configData.ConfigSettings.dmgFont,
                        Color = color,
                        Align = TextAnchor.MiddleCenter
                    },
                    new CuiRectTransformComponent
                    {
                        AnchorMin = start,
                        AnchorMax = end
                    },
                    new CuiOutlineComponent
                    {
                        Color = configData.ConfigSettings.dmgOutlineColor,
                        Distance = configData.ConfigSettings.dmgOutlineDistance
                    }
                }
            });
            CuiHelper.AddUi(player, container);
        }
        #endregion

        #region GuiHandler
        class UIHandler : MonoBehaviour
        {
            public BasePlayer player;
            public bool isDestroyed = false;
            private void Awake()
            {
                player = GetComponent<BasePlayer>();
            }
            public void DestroyUI()
            {
                if (!isDestroyed)
                {
                    CancelInvoke("DestroyUI");
                    CuiHelper.DestroyUi(player, "hitdmg");
                    CuiHelper.DestroyUi(player, "hitpng");
                    Invoke("DestroyUI", configData.ConfigSettings.timeToDestroy);
                    isDestroyed = true;
                    return;
                }
                CuiHelper.DestroyUi(player, "hitdmg");
                CuiHelper.DestroyUi(player, "hitpng");
            }
            public void Destroy() => UnityEngine.Object.Destroy(this);
        }
        #endregion

        #region Helpers
        private void SendHit(BasePlayer attacker, HitInfo info)
        {
            if (info == null || attacker == null || !attacker.IsConnected)
                return;

            if (_storedData.DisabledUsers.Contains(attacker.userID))
                return;

            if (info.HitEntity is BaseNpc && configData.ConfigSettings.showNpc)
            {
                GuiDisplay(attacker, configData.ColorSettings.colorNpc, info);
                return;
            }

            var victim = info.HitEntity as BasePlayer;
            if (victim == null)
                return;

            if (victim == attacker)
                return;

            if (configData.ConfigSettings.useClans)
            {
                if (AreClanMates(attacker.userID, victim.userID))
                {
                    GuiDisplay(attacker, configData.ColorSettings.colorClan, info, false, "clans");
                    if (configData.ConfigSettings.useSound)
                        EffectNetwork.Send(new Effect(configData.ConfigSettings.mateSound, attacker.transform.position, Vector3.zero), attacker.net.connection);
                    return;
                }
            }

            if (configData.ConfigSettings.useFriends && AreFriends(victim.userID.ToString(), attacker.userID.ToString()))
            {
                GuiDisplay(attacker, configData.ColorSettings.colorFriend, info, false, "friends");
                if (configData.ConfigSettings.useSound)
                    EffectNetwork.Send(new Effect(configData.ConfigSettings.mateSound, attacker.transform.position, Vector3.zero), attacker.net.connection);
                return;
            }

            if (info.isHeadshot)
            {
                GuiDisplay(attacker, configData.ColorSettings.colorHead, info, false, "", true);
                return;
            }

            GuiDisplay(attacker, configData.ColorSettings.colorBody, info);
        }

        private void SendDeath(BaseCombatEntity entity, HitInfo info)
        {
            if (info == null || entity == null)
                return;

            if (!configData.ConfigSettings.showDeathSkull)
                return;

            var initiator = (info?.Initiator as BasePlayer);
            if (initiator == null)
                return;

            if (_storedData.DisabledUsers.Contains(initiator.userID))
                return;

            var npc = (entity as BaseNpc);
            if (npc != null)
            {
                if (configData.ConfigSettings.showNpc)
                {
                    NextTick(() => GuiDisplay(initiator, configData.ColorSettings.colorBody, info, true));
                    return;
                }
            }
            var player = entity as BasePlayer;
            if (player == null)
                return;

            if (player == initiator)
                return;

            NextTick(() => GuiDisplay(initiator, configData.ColorSettings.colorBody, info, true));
        }

        private void GuiDisplay(BasePlayer player, string color, HitInfo hitinfo, bool isKill = false, string whatIsIt = "", bool isHead = false)
        {
            var uiHandler = GetUIHandler(player);
            uiHandler.isDestroyed = false;
            uiHandler.DestroyUI();

            if (isKill)
            {
                CuiHelper.DestroyUi(player, "hitdmg");
                Png(player, "hitpng", FetchImage("deathimage"), "0.487 0.482", "0.513 0.518", configData.ColorSettings.colorDeath);
            }
            if (configData.ConfigSettings.showHit && !isKill)
                Png(player, "hitpng", FetchImage("hitimage"), "0.492 0.4905", "0.506 0.5095", color);

            if (configData.ConfigSettings.showDamage)
            {
                NextTick(() => {
                    if (hitinfo.HitEntity == null)
                        return;

                    if ((hitinfo.HitEntity as BaseCombatEntity).IsDead())
                        return;

                    if (whatIsIt == "clans" && !configData.ConfigSettings.showClanDamage)
                        return;

                    if (whatIsIt == "friends" && !configData.ConfigSettings.showFriendDamage)
                        return;

                    if (!isKill && !configData.ConfigSettings.showDeathSkull || !isKill)
                    {
                        CuiHelper.DestroyUi(player, "hitdmg");
                        Dmg(player, "hitdmg", $"-{(int)hitinfo.damageTypes.Total()}", "0.45 0.45", "0.55 0.50", !isHead ? configData.ColorSettings.colorDamage : configData.ColorSettings.colorHeadDamage, configData.ConfigSettings.dmgTextSize);
                    }
                });
            }
        }

        private UIHandler GetUIHandler(BasePlayer player)
        {
            UIHandler value;
            if (!_playersUIHandler.TryGetValue(player.userID, out value))
            {
                _playersUIHandler[player.userID] = player.gameObject.AddComponent<UIHandler>();
                return _playersUIHandler[player.userID];
            }
            return value;
        }
        #endregion

        #region ChatCommand
        [ChatCommand("hit")]
        private void ToggleHit(BasePlayer player)
        {
            if (!_storedData.DisabledUsers.Contains(player.userID))
            {
                _storedData.DisabledUsers.Add(player.userID);
                PrintToChat(player, lang.GetMessage("Disabled", this, player.UserIDString));
            }
            else
            {
                _storedData.DisabledUsers.Remove(player.userID);
                PrintToChat(player, lang.GetMessage("Enabled", this, player.UserIDString));
            }
        }
        #endregion

        #region Config
        private static ConfigData configData;
        private class ConfigData
        {
            [JsonProperty(PropertyName = "Color")]
            public ColorOptions ColorSettings { get; set; }
            [JsonProperty(PropertyName = "Configuration")]
            public ConfigOptions ConfigSettings { get; set; }

            public class ColorOptions
            {
                [JsonProperty(PropertyName = "Hit clan member color")]
                public string colorClan { get; set; }
                [JsonProperty(PropertyName = "Hit friend color")]
                public string colorFriend { get; set; }
                [JsonProperty(PropertyName = "Hit head color")]
                public string colorHead { get; set; }
                [JsonProperty(PropertyName = "Hit body color")]
                public string colorBody { get; set; }
                [JsonProperty(PropertyName = "Hit NPC body color")]
                public string colorNpc { get; set; }
                [JsonProperty(PropertyName = "Hit Death body color")]
                public string colorDeath { get; set; }
                [JsonProperty(PropertyName = "Text damage color")]
                public string colorDamage { get; set; }
                [JsonProperty(PropertyName = "Text head damage color")]
                public string colorHeadDamage { get; set; }
            }

            public class ConfigOptions
            {
                [JsonProperty(PropertyName = "Damage text size")]
                public int dmgTextSize { get; set; }
                [JsonProperty(PropertyName = "Show clan member damage")]
                public bool showClanDamage { get; set; }
                [JsonProperty(PropertyName = "Show damage")]
                public bool showDamage { get; set; }
                [JsonProperty(PropertyName = "Show death kill")]
                public bool showDeathSkull { get; set; }
                [JsonProperty(PropertyName = "Show friend damage")]
                public bool showFriendDamage { get; set; }
                [JsonProperty(PropertyName = "Show hit icon")]
                public bool showHit { get; set; }
                [JsonProperty(PropertyName = "Show hits/deaths on NPC (Bears, wolfs, etc.)")]
                public bool showNpc { get; set; }
                [JsonProperty(PropertyName = "Text Font")]
                public string dmgFont { get; set; }
                [JsonProperty(PropertyName = "Text Outline Color")]
                public string dmgOutlineColor { get; set; }
                [JsonProperty(PropertyName = "Text Outline Distance")]
                public string dmgOutlineDistance { get; set; }
                [JsonProperty(PropertyName = "Time to destroy")]
                public float timeToDestroy { get; set; }
                [JsonProperty(PropertyName = "Use Clans")]
                public bool useClans { get; set; }
                [JsonProperty(PropertyName = "Use Friends")]
                public bool useFriends { get; set; }
                [JsonProperty(PropertyName = "Use sound when clan/friends get attacked")]
                public bool useSound { get; set; }
                [JsonProperty(PropertyName = "When clan/friends get attacked sound fx")]
                public string mateSound { get; set; }

            }

            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();

            if (configData.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                ColorSettings = new ConfigData.ColorOptions
                {
                    colorClan = "0 1 0 1",
                    colorFriend = "0 1 0 1",
                    colorHead = "1 0 0 1",
                    colorBody = "1 1 1 1",
                    colorNpc = "1 1 1 1 ",
                    colorDeath = "1 0 0 1",
                    colorDamage = "1 1 1 1",
                    colorHeadDamage = "1 0 0 1"
                },
                ConfigSettings = new ConfigData.ConfigOptions
                {
                    dmgTextSize = 15,
                    dmgFont = "robotocondensed-regular.ttf",
                    dmgOutlineColor = "0 0 0 1",
                    dmgOutlineDistance = "-0.4 0.4",
                    useFriends = true,
                    useClans = true,
                    showHit = true,
                    useSound = false,
                    showNpc = true,
                    showDamage = true,
                    showClanDamage = false,
                    showFriendDamage = true,
                    showDeathSkull = true,
                    mateSound = "assets/prefabs/instruments/guitar/effects/guitarpluck.prefab",
                    timeToDestroy = 0.45f
                },
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();

            if (configData.Version < new Core.VersionNumber(2, 0, 0))
                configData = baseConfig;

            configData.Version = Version;
            PrintWarning("Config update completed!");
        }

        T GetConfig<T>(string name, T defaultValue)
        {
            if (Config[name] == null) return defaultValue;
            return (T)Convert.ChangeType(Config[name], typeof(T));
        }
        #endregion

        #region StoreData
        private class StoredData
        {
            public List<ulong> DisabledUsers = new List<ulong>();
        }

        private void SaveData() => Interface.GetMod().DataFileSystem.WriteObject("HitIcon", _storedData);

        private void LoadData()
        {
            try
            {
                _storedData = Interface.GetMod().DataFileSystem.ReadObject<StoredData>("HitIcon");
            }
            catch
            {
                _storedData = new StoredData();
            }
        }
        #endregion

        #region Localization
        private void InitLanguage()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"Enabled", "Hit icon was <color=green>enabled</color>"},
                {"Disabled", "Hit icon was <color=red>disabled</color>"}
            }, this);
        }
        #endregion        
    }
}

// --- End of file: HitIcon.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/helicopter-protection ---
// --- Original File Path: H/HelicopterProtection/HelicopterProtection.cs ---

﻿using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Helicopter Protection", "Nobu", "1.0.2")]
    [Description("Protects you from the helicopter and vice versa")]

    class HelicopterProtection : RustPlugin
    {
        private ConfigData configData;
        class ConfigData
        {
            [JsonProperty(PropertyName = "Time on server before heli targets them")]
            public double contime = 600;
            [JsonProperty(PropertyName = "Protect players from heli")]
            public bool protectplayer = true;
            [JsonProperty(PropertyName = "Protect heli from players")]
            public bool protectheli = true;
        }
        private bool LoadConfigVariables()
        {
            try
            {
                configData = Config.ReadObject<ConfigData>();
            }
            catch
            {
                return false;
            }
            SaveConfig(configData);
            return true;
        }

        void Init()
        {
            if (!LoadConfigVariables())
            {
                Puts("Config Issue Detected, delete file or check syntax");
                return;
            }
        }

        protected override void LoadDefaultConfig()
        {
            Puts("Creating new config file");
            configData = new ConfigData();
            SaveConfig(configData);
        }

        void SaveConfig(ConfigData config)
        {
            Config.WriteObject(config, true);
        }

        bool? CanHelicopterTarget(PatrolHelicopterAI heli, BasePlayer player)
        {
            if(configData.protectplayer == true)
            { 
                if(player.Connection.GetSecondsConnected() <= configData.contime)
                {
                    return false;
                }
                else
                {
                   return null;
                }
            }
            else
            {
                return null;
            }
        }
        object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (configData.protectheli == true)
            {
                if(info.Initiator is BasePlayer)
                { 
                   BasePlayer player = info.Initiator.GetComponent<BasePlayer>();
                   if (player.Connection.GetSecondsConnected() <= configData.contime)
                   {
                        return null;
                   }
                   else if(player == null)
                   {
                        return null;
                   }
                   else
                    {
                        return null;    
                    }
                }
                else
                {
                    return false;
                }
            }
            else
            {
                return null;
            }
        }
    }
}

// --- End of file: HelicopterProtection.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/hemp-daddy ---
// --- Original File Path: H/HempDaddy/HempDaddy.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Hemp Daddy", "TacoSauce", "1.0.1")]
    [Description("Modifies gather rate of hemp plants when planted in planters.")]
    class HempDaddy : RustPlugin
    {
        private void OnGrowableGathered(GrowableEntity growable, Item item, BasePlayer player)
        {
            if(item.info.displayName.english == "Cloth")
            {   item.amount = (int)(item.amount * config.modifier);
            }
        }
        private confData config;
        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(new confData(),true);
        }
        private void Init()
        {
            config = Config.ReadObject<confData>();
        }
        private new void SaveConfig()
        {
            Config.WriteObject(config,true);
        }
        public class confData
        {
            [JsonProperty("Cloth Mulitplier")]
            public int modifier = 1;
        }
    }
}

// --- End of file: HempDaddy.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/heli-vote ---
// --- Original File Path: H/HeliVote/HeliVote.cs ---

﻿using System.Collections.Generic;
using System;
using UnityEngine;


namespace Oxide.Plugins
{
    [Info("HeliVote", "k1lly0u", "0.1.32", ResourceId = 1665)]
    class HeliVote : RustPlugin
    {
        bool Changed;

        private List<ulong> receivedYes;
        private List<ulong> receivedNo;
        private List<BaseEntity> currentHelis;

        private bool voteOpen;
        private bool helisActive;
        private bool timeBetween;
        private BasePlayer initiator;

        #region oxide hooks
        //////////////////////////////////////////////////////////////////////////////////////
        // Oxide Hooks ///////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////
        void Loaded()
        {
            permission.RegisterPermission("helivote.use", this);
            lang.RegisterMessages(messages, this);
            LoadVariables();            
        }
        void OnServerInitialized()
        {
            voteOpen = false;
            helisActive = false;
            timeBetween = false;
            initiator = null;
            receivedYes = new List<ulong>();
            receivedNo = new List<ulong>();
            currentHelis = new List<BaseEntity>();
        }
        void LoadDefaultConfig()
        {
            Puts("Creating a new config file");
            Config.Clear();
            LoadVariables();
        }
        void Unload()
        {
            receivedNo.Clear();
            receivedYes.Clear();
            foreach(var heli in currentHelis)
            {
                heli.KillMessage();
            }
            currentHelis.Clear();
        }
        void OnEntityDeath(BaseEntity entity, HitInfo hitinfo)
        {
            if (entity == null) return;
            if (helisActive)
            {
                if (currentHelis.Contains(entity))
                {
                    currentHelis.Remove(entity);
                    if (currentHelis.Count == 0)
                        helisActive = false;
                }
            }
        }
        #endregion

        #region methods
        //////////////////////////////////////////////////////////////////////////////////////
        // Vote Methods //////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////
                
        private bool alreadyVoted(BasePlayer player)
        {
            if (receivedNo.Contains(player.userID) || receivedYes.Contains(player.userID))
                return true;
            return false;
        }
        private bool TallyVotes()
        {
            var Yes = receivedYes.Count;
            var No = receivedNo.Count;
            float requiredVotes = BasePlayer.activePlayerList.Count * requiredVotesPercentage;
            if (useMajorityRules)
                if (Yes >= No)
                    return true;
            if (Yes > No && Yes >= requiredVotes) return true;
            return false;
        }
        private void voteEnd(int amount)
        {
            bool success = TallyVotes();
            if (success)
            {
                msgAll(string.Format(lang.GetMessage("voteSuccess", this), amount));
                helisActive = true;
                CallHeli(amount);                        
            }
            else
            {                
                msgAll(string.Format(lang.GetMessage("voteFail", this), minBetween));               
            }
            voteOpen = false;
            initiator = null;
            clearData();
            timeBetween = true;
            timer.Once(minBetween * 60, () => timeBetween = false);
        }
        private void clearData()
        {
            receivedYes.Clear();
            receivedNo.Clear();
        }
        private void CallHeli(int amount)
        {
            int i = 0;
            while (i < amount)
            {
                BaseEntity entity = GameManager.server.CreateEntity("assets/prefabs/npc/patrol helicopter/patrolhelicopter.prefab", new Vector3(), new Quaternion(), true);
                if (!entity) return;
                PatrolHelicopterAI heliAI = entity.GetComponent<PatrolHelicopterAI>();
                entity.Spawn();
                currentHelis.Add(entity);

                float mapSize = (TerrainMeta.Size.x / 2) - 50f;
                entity.transform.position = new Vector3(-mapSize, 30, mapSize);
                if (heliToInit)
                {
                    if (initiator != null)
                    entity.GetComponent<PatrolHelicopterAI>().State_Move_Enter(initiator.transform.position + new Vector3(0.0f, 20f, 0.0f));
                }
                i++;
            }
        }
        private void VoteTimer(int amount)
        {
            var time = voteOpenTimer * 60;
            timer.Repeat(1, time, () =>
            {                
                time--;
                if (time == 0)
                {
                    voteEnd(amount);
                    return;
                }
                if (time == 180)
                {
                    msgAll(string.Format(lang.GetMessage("timeLeft", this), 2, "Minutes"));
                }
                if (time == 120)
                {
                    msgAll(string.Format(lang.GetMessage("timeLeft", this), 2, "Minutes"));
                }
                if (time == 60)
                {
                    msgAll(string.Format(lang.GetMessage("timeLeft", this), 1, "Minute"));
                }
                if (time == 30)
                {
                    msgAll(string.Format(lang.GetMessage("timeLeft", this), 30, "Seconds"));
                }
                if (time == 10)
                {
                    msgAll(string.Format(lang.GetMessage("timeLeft", this), 10, "Seconds"));
                }
            });
        }
        private void msgAll(string left)
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                if (usePerms)
                    if (!canVote(player)) return;
                SendReply(player, lang.GetMessage("title", this, player.UserIDString) + left);
            }
        }
        private bool CheckIfStillExist()
        {
            int i = 0;
            var allobjects = UnityEngine.Object.FindObjectsOfType<BaseHelicopter>();
            foreach (var gobject in allobjects)
            {
                if (gobject.prefabID == 3703982321)
                {
                    if (currentHelis.Contains(gobject))
                        i++;
                }
            }
            if (i != 0) return true;

            helisActive = false;
            currentHelis.Clear();
            return false;

        }
        #endregion

        #region chat/console commands

        [ChatCommand("helivote")]
        private void cmdHeiVote(BasePlayer player, string command, string[] args)
        {
            if (usePerms)
                if (!canVote(player)) return;
            if (args.Length == 0)
            {
                SendReply(player, string.Format(lang.GetMessage("title", this, player.UserIDString) + lang.GetMessage("badSyn", this, player.UserIDString), maxAmount));
                return;
            }

            if (args.Length >= 1)
            {
                if (args[0].ToLower() == "open")
                {
                    if (voteOpen)
                    {
                        SendReply(player, lang.GetMessage("title", this, player.UserIDString) + lang.GetMessage("voteOpen", this, player.UserIDString));
                        return;
                    }
                    if (timeBetween)
                    {
                        SendReply(player, lang.GetMessage("title", this, player.UserIDString) + lang.GetMessage("cooldown", this, player.UserIDString));
                        return;
                    }                   
                    if (CheckIfStillExist())
                    {
                        SendReply(player, lang.GetMessage("title", this, player.UserIDString) + lang.GetMessage("heliActive", this, player.UserIDString));
                        return;
                    }

                    int amount = 1;
                    if (args.Length == 2)
                    {
                        if (!int.TryParse(args[1], out amount))
                        {
                            SendReply(player, lang.GetMessage("title", this, player.UserIDString) + lang.GetMessage("invAmount", this, player.UserIDString));
                            return;
                        }
                    }
                    if (amount > maxAmount)
                        amount = maxAmount;

                    msgAll(string.Format(lang.GetMessage("opened", this, player.UserIDString), amount));

                    float required = BasePlayer.activePlayerList.Count * requiredVotesPercentage;
                    if (required < 1) required = 1;

                    msgAll(string.Format(lang.GetMessage("required", this, player.UserIDString), (int)required));
                    voteOpen = true;
                    receivedYes.Add(player.userID);
                    initiator = player;
                    VoteTimer(amount);
                    return;
                }
                else if (args[0].ToLower() == "yes")
                {
                    if (!voteOpen)
                    {
                        SendReply(player, lang.GetMessage("title", this, player.UserIDString) + lang.GetMessage("noOpen", this, player.UserIDString));
                        return;
                    }
                    if (!alreadyVoted(player))
                    {
                        receivedYes.Add(player.userID);
                        SendReply(player, lang.GetMessage("title", this, player.UserIDString) + lang.GetMessage("yesVote", this, player.UserIDString));
                        if (displayProgress)
                            msgAll(string.Format(lang.GetMessage("totalVotes", this, player.UserIDString), receivedYes.Count, receivedNo.Count));
                        return;
                    }
                    SendReply(player, lang.GetMessage("title", this, player.UserIDString) + lang.GetMessage("alreadyVoted", this, player.UserIDString));
                    return;
                }
                else if (args[0].ToLower() == "no")
                {
                    if (!voteOpen)
                    {
                        SendReply(player, lang.GetMessage("title", this, player.UserIDString) + lang.GetMessage("noOpen", this, player.UserIDString));
                        return;
                    }
                    if (!alreadyVoted(player))
                    {
                        receivedNo.Add(player.userID);
                        SendReply(player, lang.GetMessage("title", this, player.UserIDString) + lang.GetMessage("noVote", this, player.UserIDString));
                        if (displayProgress)
                            msgAll(string.Format(lang.GetMessage("totalVotes", this, player.UserIDString), receivedYes.Count, receivedNo.Count));
                        return;
                    }
                    SendReply(player, lang.GetMessage("title", this, player.UserIDString) + lang.GetMessage("alreadyVoted", this, player.UserIDString));
                    return;
                }
            }
        }
        [ConsoleCommand("helivote")]
        private void ccmdVote(ConsoleSystem.Arg arg)
        {
            if (!isAuthCon(arg)) return;
            int amount = 1;
            if (arg.Args != null)
                if (arg.Args.Length == 1)
                    int.TryParse(arg.Args[0], out amount);

            msgAll(string.Format(lang.GetMessage("opened", this), amount));

            float required = BasePlayer.activePlayerList.Count * requiredVotesPercentage;
            if (required < 1) required = 1;

            msgAll(string.Format(lang.GetMessage("required", this), (int)required));
            voteOpen = true;
            VoteTimer(amount);
        }

        private bool canVote(BasePlayer player)
        {
            if (permission.UserHasPermission(player.userID.ToString(), "helivote.use")) return true;
            else if (isAuth(player)) return true;
            SendReply(player, lang.GetMessage("title", this, player.UserIDString) + lang.GetMessage("noPerms", this, player.UserIDString));
            return false;
        }
        bool isAuth(BasePlayer player)
        {
            if (player.net.connection != null)
            {
                if (player.net.connection.authLevel < 1)
                {
                    SendReply(player, lang.GetMessage("noPerms", this));
                    return false;
                }
            }
            return true;
        }
        bool isAuthCon(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null)
            {
                if (arg.Connection.authLevel < 1)
                {
                    SendReply(arg, lang.GetMessage("noPerms", this));
                    return false;
                }
            }
            return true;
        }
       
        #endregion

        #region config
        //////////////////////////////////////////////////////////////////////////////////////
        // Configuration /////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////

        static float requiredVotesPercentage = 0.5f;
        static bool useMajorityRules = true;
        static int voteOpenTimer = 4;
        static bool displayProgress = true;
        static int auth = 1;
        static int minBetween = 5;
        static int maxAmount = 4;
        static bool heliToInit = false;
        static bool usePerms = false;     

        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        private void LoadConfigVariables()
        {
            CheckCfgFloat("Options - Required yes vote percentage", ref requiredVotesPercentage);
            CheckCfg("Options - Timers - Open vote timer (minutes)", ref voteOpenTimer);
            CheckCfg("Options - Timers - Minimum time between votes (minutes)", ref minBetween);
            CheckCfg("Options - Display vote progress", ref displayProgress);
            CheckCfg("Options - Maximum helicopters to call", ref maxAmount);
            CheckCfg("Options - Send helicopters to the initiator", ref heliToInit);
            CheckCfg("Options - Use permission system only", ref usePerms);
            CheckCfg("Options - Use majority rules", ref useMajorityRules);
        }
        private void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T)
                var = (T)Config[Key];
            else
                Config[Key] = var;
        }
        private void CheckCfgFloat(string Key, ref float var)
        {

            if (Config[Key] != null)
                var = Convert.ToSingle(Config[Key]);
            else
                Config[Key] = var;
        }
        object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }
        #endregion

        #region messages
        //////////////////////////////////////////////////////////////////////////////////////
        // Messages //////////////////////////////////////////////////////////////////////////
        //////////////////////////////////////////////////////////////////////////////////////

        Dictionary<string, string> messages = new Dictionary<string, string>()
        {
            {"title", "<color=#cc2900>HeliVote</color> : " },
            {"noPerms", "You do not have permission to use this command" },
            {"badSyn", "<color=#ff704d>/helivote open ##</color> - Open a vote to spawn ## amount of helicopters. Maximum is <color=#ff704d>{0}</color>" },
            {"voteOpen", "There is already a vote open" },
            {"noOpen", "There isn't a vote open right now" },
            {"yesVote", "You have voted yes"},
            {"noVote", "You have voted no" },
            {"alreadyVoted", "You have already voted" },
            {"opened", "A vote to call <color=#ff704d>{0}</color> helicopter(s) is now open! Use <color=#ff704d>/helivote yes</color> or <color=#ff704d>/helivote no</color>" },
            {"required", "Minimum yes votes required is <color=#ff704d>{0}</color>" },
            {"invAmount", "You have entered a invalid number" },
            {"timeLeft", "Voting ends in {0} {1}, use <color=#ff704d>/helivote yes</color> or <color=#ff704d>/helivote no</color>" },
            {"cooldown", "You must wait for the cooldown period to end before opening a vote" },
            {"voteSuccess", "The vote was successful, spawning <color=#ff704d>{0}</color> helicopters!" },
            {"voteFail", "The vote failed to meet the requirements, try again in <color=#ff704d>{0}</color> minutes" },
            {"heliActive", "There are still active helicopters from the last vote. Can not open a new vote until they are destroyed" },
            {"totalVotes", "<color=#ff704d>{0}</color> vote(s) for Yes, <color=#ff704d>{1}</color> vote(s) for No" }
        };
        #endregion

    }
}

// --- End of file: HeliVote.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/hotel ---
// --- Original File Path: H/Hotel/Hotel.cs ---

//Requires: ZoneManager

#region Using Statements

using Facepunch;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using UnityEngine;

#endregion

namespace Oxide.Plugins
{
    [Info("Hotel", "Shady14u", "2.0.26")]
    [Description("Complete Hotel System for Rust.")]
    public class Hotel : RustPlugin
    {
        #region PluginReferences

        [PluginReference]
        Plugin ZoneManager, Economics, ServerRewards, Backpacks;

        #endregion

        #region Fields

        private Timer hotelGuiTimer;
        private Timer hotelRoomCheckoutTimer;
        private readonly Hash<BasePlayer, Timer> playerGuiTimers = new Hash<BasePlayer, Timer>();
        private readonly Hash<BasePlayer, Timer> playerBlackListGuiTimers = new Hash<BasePlayer, Timer>();
        private readonly Hash<ulong, HotelData> hotelGuests = new Hash<ulong, HotelData>();

        private StoredData storedData;

        static readonly int ConstructionColl = LayerMask.GetMask("Construction", "Construction Trigger");
        static readonly int DeployableColl = LayerMask.GetMask("Deployed");
        static readonly DateTime Epoch = new DateTime(1970, 1, 1, 0, 0, 0);

        public static Quaternion DefaultQuaternion = new Quaternion(0f, 0f, 0f, 0f);
        private static Dictionary<string, HotelData> EditHotel = new Dictionary<string, HotelData>();
        private static Dictionary<string, HotelMarker> HotelMarkers = new Dictionary<string, HotelMarker>();
        private static readonly Vector3 Vector3Up = new Vector3(0f, 0.1f, 0f);
        private static readonly Vector3 Vector3Up2 = new Vector3(0f, 1.5f, 0f);


        #endregion

        void Init()
        {
            AddCovalenceCommand("hotelextend", "HotelExtend");
        }

        #region Config

        private Configuration config;

        public class Configuration
        {
            [JsonProperty(PropertyName = "adminGuiJson")]
            public string AdminGuiJson;

            [JsonProperty(PropertyName = "authLevel")]
            public int AuthLevel;

            [JsonProperty(PropertyName = "enterZoneShowPlayerGUI")]
            public bool EnterZoneShowPlayerGui;

            [JsonProperty(PropertyName = "enterZoneShowRoom")]
            public bool EnterZoneShowRoom;

            [JsonProperty(PropertyName = "KickHobos")]
            public bool KickHobos;

            [JsonProperty(PropertyName = "mapMarker")]
            public string MapMarker;

            [JsonProperty(PropertyName = "mapMarkerColor")]
            public string MapMarkerColor;

            [JsonProperty(PropertyName = "mapMarkerColorBorder")]
            public string MapMarkerColorBorder;

            [JsonProperty(PropertyName = "mapMarkerRadius")]
            public float MapMarkerRadius;

            [JsonProperty(PropertyName = "openDoorPlayerGUI")]
            public bool OpenDoorPlayerGui;

            [JsonProperty(PropertyName = "openDoorShowRoom")]
            public bool OpenDoorShowRoom;

            [JsonProperty(PropertyName = "panelTimeOut")]
            public int PanelTimeOut;

            [JsonProperty(PropertyName = "panelXMax")]
            public string PanelXMax;

            [JsonProperty(PropertyName = "panelXMin")]
            public string PanelXMin;

            [JsonProperty(PropertyName = "panelYMax")]
            public string PanelYMax;

            [JsonProperty(PropertyName = "panelYMin")]
            public string PanelYMin;

            [JsonProperty(PropertyName = "playerGuiJson")]
            public string PlayerGuiJson;

            [JsonProperty(PropertyName = "useNPCShowPlayerGUI")]
            public bool UseNpcShowPlayerGui;

            [JsonProperty(PropertyName = "useNPCShowRoom")]
            public bool UseNpcShowRoom;

            [JsonProperty(PropertyName = "xMax")] public string XMax;

            [JsonProperty(PropertyName = "xMin")] public string XMin;

            [JsonProperty(PropertyName = "yMax")] public string YMax;

            [JsonProperty(PropertyName = "yMin")] public string YMin;

            [JsonProperty(PropertyName = "blackListGuiJson")]
            public string BlackListGuiJson;

            [JsonProperty(PropertyName = "blackList")]
            public string[] BlackList;

            [JsonProperty(PropertyName = "defaultZoneFlags")]
            public string[] DefaultZoneFlags;

            [JsonProperty(PropertyName = "showRoomCounterUi")]
            public bool ShowRoomCounterUi { get; set; } = false;

            [JsonProperty(PropertyName = "counterUiAnchorMin")]
            public string CounterUiAnchorMin { get; set; } = "0.11 0.9";

            [JsonProperty(PropertyName = "counterUiAnchorMax")]
            public string CounterUiAnchorMax { get; set; } = "0.28 0.98";

            [JsonProperty(PropertyName = "counterUiTextColor")]
            public string CounterUiTextColor { get; set; } = "0 1 0 1";
            [JsonProperty(PropertyName = "counterUiTextSize")]
            public int CounterUiTextSize { get; set; } = 12;
            [JsonProperty(PropertyName = "hideUiForNonRenters")]
            public bool HideUiForNonRenters { get; set; } = true;

            #region Methods (Public)

            public static Configuration DefaultConfig()
            {
                return new Configuration
                {
                    OpenDoorPlayerGui = true,
                    OpenDoorShowRoom = false,
                    UseNpcShowPlayerGui = true,
                    UseNpcShowRoom = true,
                    EnterZoneShowPlayerGui = false,
                    EnterZoneShowRoom = true,
                    KickHobos = true,
                    ShowRoomCounterUi = true,
                    XMin = "0.65",
                    XMax = "1.0",
                    YMin = "0.6",
                    YMax = "0.9",
                    PanelXMin = "0.3",
                    PanelXMax = "0.6",
                    PanelYMin = "0.6",
                    PanelYMax = "0.95",
                    PanelTimeOut = 10,
                    AuthLevel = 2,
                    AdminGuiJson = @"[{""name"": ""HotelAdmin"",""parent"": ""Overlay"",""components"":[{""type"":""UnityEngine.UI.Image"",""color"":""0.1 0.1 0.1 0.7"",},
                            {""type"":""RectTransform"",""anchormin"": ""{xmin} {ymin}"", ""anchormax"": ""{xmax} {ymax}""}]},{""parent"": ""HotelAdmin"",""components"":
                            [{""type"":""UnityEngine.UI.Text"", ""text"":""{msg}"",""fontSize"":15, ""align"": ""MiddleLeft""},{""type"":""RectTransform"",
                            ""anchormin"": ""0.1 0.1"",""anchormax"": ""1 1"" }]}]",
                    PlayerGuiJson = @"[{""name"": ""HotelPlayer"",""parent"": ""Overlay"",""components"":[{""type"":""UnityEngine.UI.Image"",""color"":""0.1 0.1 0.1 0.7"",},
                            {""type"":""RectTransform"",""anchormin"": ""{pxmin} {pymin}"",""anchormax"": ""{pxmax} {pymax}""}]},{""parent"": ""HotelPlayer"",""components"":
                            [{""type"":""UnityEngine.UI.Text"",""text"":""{msg}"",""fontSize"":15,""align"": ""MiddleLeft"",},{""type"":""RectTransform"",
                            ""anchormin"": ""0.1 0.1"",""anchormax"": ""1 0.8""}]}]",
                    BlackListGuiJson = @"[{""name"": ""HotelBlackList"",""parent"": ""Overlay"",""components"":[{""type"":""UnityEngine.UI.Image"",""color"":""0.1 0.1 0.1 0.7"",},
                            {""type"":""RectTransform"",""anchormin"": ""{pxmin} {pymin}"",""anchormax"": ""{pxmax} {pymax}""}]},{""parent"": ""HotelBlackList"",""components"":
                            [{""type"":""UnityEngine.UI.Text"",""text"":""{msg}"",""fontSize"":15,""align"": ""MiddleLeft"",},{""type"":""RectTransform"",
                            ""anchormin"": ""0.1 0.1"",""anchormax"": ""1 1""}]}]",
                    MapMarker = "\t\t\t{name} Hotel\r\n{fnum} of {rnum} Rooms Available\r\n{rp} {rc} per {durHours} hours",
                    MapMarkerColor = "#710AC1",
                    MapMarkerColorBorder = "#5FCEA8",
                    MapMarkerRadius = 0.25f,
                    BlackList = new[] { "explosive.timed" },
                    DefaultZoneFlags = new[] { "lootself", "nobuild", "nocup", "nodecay", "noentitypickup", "noplayerloot", "nostash", "notrade", "pvpgod", "sleepgod", "undestr" }
                };
            }

            #endregion
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) LoadDefaultConfig();
                SaveConfig();
            }
            catch (Exception)
            {
                PrintWarning("Creating new config file.");
                LoadDefaultConfig();
            }

            if (config != null)
            {
                config.AdminGuiJson = config.AdminGuiJson.Replace("{xmin}", config.XMin)
                    .Replace("{xmax}", config.XMax).Replace("{ymin}", config.YMin).Replace("{ymax}", config.YMax);
                config.PlayerGuiJson = config.PlayerGuiJson.Replace("{pxmin}", config.PanelXMin)
                    .Replace("{pxmax}", config.PanelXMax).Replace("{pymin}", config.PanelYMin)
                    .Replace("{pymax}", config.PanelYMax);
                config.BlackListGuiJson = config.BlackListGuiJson.Replace("{pxmin}", config.PanelXMin)
                    .Replace("{pxmax}", config.PanelXMax).Replace("{pymin}", config.PanelYMin)
                    .Replace("{pymax}", config.PanelYMax);

                var blackListTemp = new List<string>();

                if (config.BlackList == null)
                {
                    config.BlackList = blackListTemp.ToArray();
                }

                foreach (var item in config.BlackList)
                {
                    if (item.Contains("_"))
                    {
                        blackListTemp.Add(item);
                        continue;
                    }
                    int itemId;
                    var itemDefinition = int.TryParse(item, out itemId) ? ItemManager.FindItemDefinition(itemId) : ItemManager.FindItemDefinition(item);

                    if (itemDefinition == null) continue;
                    blackListTemp.Add($"{itemDefinition.itemid}_{itemDefinition.displayName.translated}");
                }

                config.BlackList = blackListTemp.ToArray();
            }

            LoadData();
            LoadPermissions();
        }

        protected override void LoadDefaultConfig() => config = Configuration.DefaultConfig();

        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion

        #region Localization

        private static class PluginMessages
        {
            public const string MessageHotelDisableHelp = "MessageHotelDisableHelp";
            public const string MessagePlayerIsRenter = "MessagePlayerIsRenter";
            public const string MessagePlayerNotRenter = "MessagePlayerNotRenter";
            public const string MessageHotelEnableHelp = "MessageHotelEnableHelp";
            public const string MessageErrorPlayerNotFound = "MessageErrorPlayerNotFound";
            public const string MessageAlreadyEditing = "MessageAlreadyEditing";
            public const string MessageNoHotelHelp = "MessageNoHotelHelp";
            public const string MessageHotelNewHelp = "MessageHotelNewHelp";
            public const string MessageHotelEditHelp = "MessageHotelEditHelp";
            public const string MessageHotelEditEditing = "MessageHotelEditEditing";
            public const string MessageErrorAlreadyExist = "MessageErrorAlreadyExist";
            public const string MessageErrorNotAllowed = "MessageErrorNotAllowed";
            public const string MessageErrorEditDoesNotExist = "MessageErrorEditDoesNotExist";
            public const string MessageMaintenance = "MessageMaintenance";
            public const string MessageErrorUnavailableRoom = "MessageErrorUnavailableRoom";
            public const string MessageHotelNewCreated = "MessageHotelNewCreated";
            public const string MessageErrorNotAllowedToEnter = "MessageErrorNotAllowedToEnter";
            public const string MessageHotelExtendHelp = "MessageHotelExtendHelp";
            public const string MessageErrorAlreadyGotRoom = "MessageErrorAlreadyGotRoom";
            public const string MessageErrorPermissionsNeeded = "MessageErrorPermissionsNeeded";
            public const string MessageCouldNotFindToExtend = "MessageCouldNotFindToExtend";
            public const string MessageRentUnlimited = "MessageRentUnlimited";
            public const string MessageRentTimeLeft = "MessageRentTimeLeft";
            public const string MessagePayedRent = "MessagePayedRent";
            public const string MessageErrorNotEnoughCoins = "MessageErrorNotEnoughCoins";
            public const string MessageErrorNotEnoughRp = "MessageErrorNotEnoughRP";
            public const string MessageErrorNotEnoughItems = "MessageErrorNotEnoughItems";
            public const string GuiBoardAdmin = "GUIBoardAdmin";
            public const string GuiBoardBlackList = "GuiBoardBlackList";
            public const string GuiBoardPlayer = "GUIBoardPlayer";
            public const string GuiBoardPlayerRoom = "GUIBoardPlayerRoom";
            public const string GuiBoardPlayerMaintenance = "GUIBoardPlayerMaintenance";
            public const string MessageMustLookAtDoor = "MessageMustLookAtDoor";
            public const string Menu1 = "Menu1";
            public const string Menu2 = "Menu2";
            public const string Menu3 = "Menu3";
            public const string Menu4 = "Menu4";
            public const string Menu5 = "Menu5";
            public const string Menu6 = "Menu6";
            public const string Menu7 = "Menu7";
            public const string Menu8 = "Menu8";
            public const string Menu9 = "Menu9";
            public const string Menu10 = "Menu10";
            public const string Menu11 = "Menu11";
            public const string Menu12 = "Menu12";
            public const string Menu13 = "Menu13";
            public const string ExtendButtonText = "ExtendButtonText";
        }

        private string GetMsg(string key, object userId = null)
        {
            return lang.GetMessage(key, this, userId?.ToString());
        }


        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [PluginMessages.MessageHotelDisableHelp] =
                    "You must enter the name/id of the person you want to disable renting hotels: <color=green>/hotel_disable \"Player Name/Id\"</color>",
                [PluginMessages.MessagePlayerNotRenter] =
                    "Player <color=green>{playerName}</color> revoked from the <color=green>hotel.renter</color> permission.",
                [PluginMessages.MessagePlayerIsRenter] =
                    "Player <color=green>{playerName}</color> granted the <color=green>hotel.renter</color> permission.",
                [PluginMessages.MessageHotelEnableHelp] =
                   "You must enter the name/id of the person you want to enable renting hotels: <color=green>/hotel_enable \"Player Name/Id\"</color>",
                [PluginMessages.MessageErrorPlayerNotFound] =
                    "Player was not found.",
                [PluginMessages.MessageAlreadyEditing] =
                    "You are already editing a hotel. You must close or save it first.",
                [PluginMessages.MessageNoHotelHelp] =
                    "You are not editing a hotel. Create a new one with <color=green>/hotel_new</color>, or edit an existing one with <color=green>/hotel_edit</color>",
                [PluginMessages.MessageHotelNewHelp] =
                    "You must select a name for the new hotel: <color=green>/hotel_new \"Hotel Name\"</color>",
                [PluginMessages.MessageHotelEditHelp] =
                    "You must select the name of the hotel you want to edit: <color=green>/hotel_edit \"Hotel Name\"</color>",
                [PluginMessages.MessageHotelEditEditing] =
                    "You are editing the hotel named: <color=purple>{0}</color>. Now say <color=green>/hotel</color> to continue configuring your hotel. Note that no one can register/leave the hotel while you are editing it.",
                [PluginMessages.MessageErrorAlreadyExist] = "{0} is already the name of a hotel",
                [PluginMessages.MessageErrorNotAllowed] = "You are not allowed to use this command",
                [PluginMessages.MessageErrorEditDoesNotExist] = "The hotel \"<color=purple>{0}</color>\" doesn't exist",
                [PluginMessages.MessageMaintenance] =
                    "This Hotel is under maintenance by the admin, you may not open this door at the moment",
                [PluginMessages.MessageErrorUnavailableRoom] =
                    "This room is unavailable, seems like it wasn't set correctly",
                [PluginMessages.MessageHotelNewCreated] =
                    "You've created a new Hotel named: <color=purple>{0}</color>. Now say <color=green>/hotel</color> to continue configuring your hotel.",
                [PluginMessages.MessageErrorNotAllowedToEnter] =
                    "You are not allowed to enter this room, it's already being used my someone else",
                [PluginMessages.MessageCouldNotFindToExtend] = "Could not find your room to extend, in the {0} hotel",
                [PluginMessages.MessageHotelExtendHelp] =
                    "You must enter the name of the hotel you want to extend your stay at: <color=green>/hotel_extend \"Hotel Name\"</color>",
                [PluginMessages.MessageErrorAlreadyGotRoom] = "You already have a room in this hotel!",
                [PluginMessages.MessageErrorPermissionsNeeded] =
                    "You must have the <color=purple>{0}</color> permission to rent a room here",
                [PluginMessages.MessageRentUnlimited] = "You now have access to this room for an unlimited time",
                [PluginMessages.MessageRentTimeLeft] =
                    "You now have access to this room. You are allowed to keep this room for <color=purple>{0}</color>",
                [PluginMessages.MessagePayedRent] = "You payed for this room <color=purple>{0}</color> coins",
                [PluginMessages.MessageErrorNotEnoughCoins] =
                    "This room costs <color=purple>{0}</color> coins. You only have <color=purple>{1}</color> coins",
                [PluginMessages.MessageErrorNotEnoughRp] =
                    "This room costs <color=purple>{0}</color> RP. You only have<color=purple>{1}</color> Reward Points",
                [PluginMessages.MessageErrorNotEnoughItems] =
                    "Not enough <color=purple>{0}</color>(s) for this room, you need <color=purple>{1}</color> more.",
                [PluginMessages.MessageMustLookAtDoor] = "You must look at the door of the room or put the roomId",
                [PluginMessages.GuiBoardAdmin] =
                    "\t\t\t\t\t<color=green>HOTEL MANAGER</color>\n\n<color=cyan>Hotel Name:\t\t{name}</color>\n<color=grey>Hotel Location:</color>\t{loc}\n<color=orange>Hotel Radius:\t\t{hrad}</color>\t<color=yellow>Rooms Radius:\t{rrad}</color>\n<color=blue>Rooms:\t{rnum}</color>\t\t<color=red>Occupied:\t{onum}</color>\t\t<color=green>Vacant:\t{fnum}</color>\n<color=cyan>Rent Price:\t{rp}\t</color><color=purple>{rc}</color>\n<color=grey>Duration:\t{rd} Seconds</color>\n<color=orange>Kick Hobos:\t{kh}</color>\t\t<color=yellow>NPC Id:\t{npcId}</color>\n<color=blue>Show Marker:\t{sm}</color>\n<color=red>Permission:\t{p}</color>",
                [PluginMessages.GuiBoardBlackList] = "<color=blue>You cannot enter {name} Hotel with any of the following items:</color>\r\n<size=10>{blacklist}</size>",
                [PluginMessages.GuiBoardPlayer] =
                    "\t\t\t\t\t\t\t\t\t\t<color=yellow><size=16>{name}</size></color>\n\t\t\t\t\t<color=yellow><size=12>Location: ({loc})</size></color>\n\t\t<color=blue>Rooms:\t\t{rnum}</color>\t\t<color=green>Price:\t{price} {currency} per {durHours} hours </color>\n\t\t<color=red>Occupied:\t{onum}</color>\n\t\t<color=green>Vacant:\t\t{fnum}</color>",
                [PluginMessages.GuiBoardPlayerRoom] =
                    "\n\t\t\t\t\t\t\t\t<color=yellow><size=14>Your Room</size></color>\n\t\t\t\t\t<color=blue><size=12>Id:\t\t\t\t{rid}</size></color>\n\t\t\t\t\t<color=orange><size=12>Joined:\t\t\t{jdate}</size></color>\n\t\t\t\t\t<color=cyan><size=12>Time Left:\t\t{timeleft}</size></color>",
                [PluginMessages.GuiBoardPlayerMaintenance] =
                    "\t\t\t\t\t\t\t\t\t\t<color=green>{name}</color>\n\nHotel is under maintenance. Please wait couple seconds/minutes until the admin is finished.",
                [PluginMessages.Menu1] = "<color=purple>==== Available options ====</color>",
                [PluginMessages.Menu2] =
                    "<color=green>/hotel location</color> => sets the center hotel location where you stand",
                [PluginMessages.Menu3] =
                    "<color=green>/hotel npc NpcId </color> => sets the NPC that is hooked to this hotel (for UseNPC items)",
                [PluginMessages.Menu4] =
                    "<color=green>/hotel permission \"Permission Name\"</color> => sets the oxide permissions that the player needs to rent a room here",
                [PluginMessages.Menu5] =
                    "<color=green>/hotel radius XX</color> => sets the radius of the hotel (the entire structure of the hotel needs to be covered by the zone)",
                [PluginMessages.Menu6] =
                    "<color=green>/hotel rentduration XX</color> => Sets the duration of a default rent in this hotel. 0 is infinite.",
                [PluginMessages.Menu7] =
                    "<color=green>/hotel rentcurrency XX</color> => (<color=orange>0</color> - Economics, <color=orange>1</color> - Server Rewards, \"<color=orange>short name</color>\" of item ie. scrap).",
                [PluginMessages.Menu8] = "<color=green>/hotel rentprice XX</color> => Sets the rental price of a room.",
                [PluginMessages.Menu9] =
                    "<color=green>/hotel kickhobos [true/false]</color> => Toggles kicking sleepers without rooms.",
                [PluginMessages.Menu10] =
                    "<color=green>/hotel showmarker [true/false]</color> => Toggles showing of map marker.",
                [PluginMessages.Menu11] =
                    "<color=green>/hotel reset</color> => resets the hotel data (all players and rooms, but keeps the hotel)",
                [PluginMessages.Menu12] = "<color=green>/hotel roomradius XX</color> => sets the radius of the rooms",
                [PluginMessages.Menu13] =
                    "<color=green>/hotel rooms</color> => refreshes the rooms (detects new rooms, deletes rooms if they don't exist anymore, if rooms are in use they won't get taken in count)",
                [PluginMessages.ExtendButtonText] = "Extend Your Stay"
            }, this);
        }

        #endregion

        #region OxideHooks

        object CanPickupLock(BasePlayer player, BaseLock baseLock)
        {
            var codeLock = baseLock as CodeLock;
            var parentEntity = codeLock?.GetParentEntity();
            if (parentEntity == null || !parentEntity.name.Contains("door")) return null;

            if (hotelGuests.Any(x => x.Key == player.userID))
            {
                return false;
            }

            return null;
        }

        object CanUseLockedEntity(BasePlayer player, BaseLock baseLock)
        {
            var codeLock = baseLock as CodeLock;
            var parentEntity = codeLock?.GetParentEntity();
            if (parentEntity == null || !parentEntity.name.Contains("door")) return null;

            var playersZones = ZoneManager.Call<string[]>("GetPlayerZoneIDs", player);

            if (!storedData.Hotels.Any(hotel => playersZones.Contains(hotel.hotelName)))
            {
                return null;
            }

            var targetHotel = storedData.Hotels.FirstOrDefault(hotel => playersZones.Contains(hotel.hotelName));
            if (targetHotel == null) return null;

            if (config.OpenDoorPlayerGui)
                RefreshPlayerHotelGui(player, targetHotel);
            if (config.OpenDoorShowRoom)
                ShowPlayerRoom(player, targetHotel);

            if (!targetHotel.enabled)
            {
                SendReply(player, GetMsg(PluginMessages.MessageMaintenance, player.userID));
                return false;
            }

            var room = FindRoomByDoorAndHotel(targetHotel, parentEntity);
            if (room == null)
            {
                SendReply(player, GetMsg(PluginMessages.MessageErrorUnavailableRoom, player.userID));
                return false;
            }

            if (room.renter == null)
            {
                if (!CanRentRoom(player, targetHotel)) return false;

                NewRoomOwner(codeLock, player, targetHotel, room);

                if (targetHotel.currency == "0" && Economics)
                {
                    EconomicsWithdraw(player, targetHotel.Price());
                }

                if (targetHotel.currency == "1" && ServerRewards)
                {
                    ServerRewardsWithdraw(player, targetHotel.Price());
                }

                if (targetHotel.currency != "0" && targetHotel.currency != "1")
                {
                    var collect = Pool.GetList<Item>();
                    var itemDefinition = ItemManager.FindItemDefinition(targetHotel.currency);
                    if (itemDefinition != null)
                    {
                        player.inventory.Take(collect, itemDefinition.itemid, int.Parse(targetHotel.e));
                        player.Command("note.inv", itemDefinition.itemid, -1 * int.Parse(targetHotel.e));
                    }
                }

                CreateMapMarker(targetHotel);
            }

            LockLock(codeLock);

            if (room.renter != player.UserIDString)
            {
                SendReply(player, GetMsg(PluginMessages.MessageErrorNotAllowedToEnter, player.userID));
                return false;
            }

            SaveData();
            return true;
        }

        private void LoadData()
        {
            try
            {
                storedData = Interface.GetMod().DataFileSystem.ReadObject<StoredData>("Hotel");
            }
            catch (Exception e)
            {
                Puts(e.Message);
                Puts(e.StackTrace);
                storedData = new StoredData();
            }
        }

        void OnServerSave()
        {
            SaveData();
        }

        void OnEnterZone(string zoneId, BasePlayer player)
        {
            foreach (var hotel in storedData.Hotels.Where(hotel => hotel.hotelName != null)
                .Where(hotel => hotel.hotelName == zoneId))
            {
                //Log in our guest
                hotelGuests.Add(player.userID, hotel);
                //TODO: Let each Hotel blacklist items?
                //var blackList = hotel.BlackList;

                if (HasBlackListedItems(player, config.BlackList.ToList()))
                {
                    var zone = ZoneManager.Call<ZoneManager.Zone>("GetZoneByID", hotel.hotelName);
                    ZoneManager.Call("EjectPlayer", player, zone);
                    RefreshBlackListGui(player, hotel, config.BlackList.ToList());
                    return;
                }

                if (config.EnterZoneShowPlayerGui)
                    RefreshPlayerHotelGui(player, hotel);
                if (config.EnterZoneShowRoom)
                    ShowPlayerRoom(player, hotel);
            }
        }

        void OnExitZone(string ZoneID, BasePlayer player) // Called when a player leaves a zone
        {
            hotelGuests.Remove(player.userID);
        }

        object OnItemPickup(Item item, BasePlayer player)
        {
            HotelData hotel;
            if (!hotelGuests.TryGetValue(player.userID, out hotel)) return null;
            if (config.BlackList.Any(x => x.Split('_')[0] == item.info.itemid.ToString() || x.Split('_')[1] == item.info.displayName.translated) || HasBlackListedItems(player, config.BlackList.ToList()))
            {
                var zone = ZoneManager.Call<ZoneManager.Zone>("GetZoneByID", hotel.hotelName);
                ZoneManager.Call("EjectPlayer", player, zone);
                RefreshBlackListGui(player, hotel, config.BlackList.ToList());

            }
            return null;
        }

        void OnPlayerLootEnd(PlayerLoot inventory)
        {
            HotelData hotel;
            if (!hotelGuests.TryGetValue(inventory.baseEntity.userID, out hotel)) return;
            if (HasBlackListedItems(inventory.baseEntity, config.BlackList.ToList()))
            {
                var zone = ZoneManager.Call<ZoneManager.Zone>("GetZoneByID", hotel.hotelName);
                ZoneManager.Call("EjectPlayer", inventory.baseEntity, zone);
                RefreshBlackListGui(inventory.baseEntity, hotel, config.BlackList.ToList());
            }
        }

        void OnPlayerDisconnected(BasePlayer player)
        {
            if (player == null)
                return;

            foreach (var hotel in from hotel in storedData.Hotels
                                  where hotel.kickHobos
                                  let isInZone = ZoneManager.Call<bool>("IsPlayerInZone", hotel.hotelName, player)
                                  where isInZone
                                  select hotel)
            {
                if (hotel.rooms.Any(hotelRoom => hotelRoom.Value.renter == player.userID.ToString()))
                {
                    return;
                }

                //Player is in a hotel and they don't have a room.. Kick them.
                var zone = ZoneManager.Call<ZoneManager.Zone>("GetZoneByID", hotel.hotelName);
                ZoneManager.Call("EjectPlayer", player, zone);
                return;
            }
        }

        void OnServerInitialized(bool initial)
        {
            CheckTimeOutRooms();
            if (config.ShowRoomCounterUi)
            {
                hotelGuiTimer = timer.Repeat(5f, 0, UpdateHotelCounter);
            }

            hotelRoomCheckoutTimer = timer.Repeat(60f, 0, CheckTimeOutRooms);
        }


        void OnUseNPC(BasePlayer npc, BasePlayer player)
        {
            var npcId = npc.UserIDString;
            foreach (var hotel in storedData.Hotels.Where(hotel => hotel.npc != null && hotel.npc == npcId))
            {
                if (config.UseNpcShowPlayerGui)
                    RefreshPlayerHotelGui(player, hotel);
                if (config.UseNpcShowRoom)
                    ShowPlayerRoom(player, hotel);
            }
        }

        #endregion

        #region Helper Methods

        private bool CanRentRoom(BasePlayer player, HotelData hotel, bool isExtending = false)
        {
            var playerHasRoom = false;
            if (hotel.rooms.Values.Any(room => room.renter == player.UserIDString))
            {
                if (!isExtending)
                {
                    SendReply(player, GetMsg(PluginMessages.MessageErrorAlreadyGotRoom, player.UserIDString));
                    return false;
                }

                playerHasRoom = true;
            }

            if (isExtending && !playerHasRoom)
            {
                SendReply(player, PluginMessages.MessageCouldNotFindToExtend.Replace("{0}", hotel.hotelName));
                return false;
            }

            if (hotel.p != null)
            {
                if (!permission.UserHasPermission(player.UserIDString, $"hotel.{hotel.p.ToLower()}"))
                {
                    SendReply(player, GetMsg(PluginMessages.MessageErrorPermissionsNeeded, player.UserIDString)
                        .Replace("{0}", hotel.p));
                    return false;
                }
            }

            if (hotel.currency == "0" && Economics == null) return false;

            if (hotel.currency == "0")
            {
                var money = Convert.ToInt32((double)Economics.Call("Balance", player.UserIDString));
                if (money >= hotel.Price()) return true;
                SendReply(player, GetMsg(PluginMessages.MessageErrorNotEnoughCoins, player.UserIDString)
                    .Replace("{0}", hotel.e)
                    .Replace("{1}", money.ToString()));
                return false;
            }

            if (hotel.currency == "1" && ServerRewards == null) return false;

            if (hotel.currency == "1")
            {
                var money = Convert.ToInt32(ServerRewards?.Call("CheckPoints", player.UserIDString));
                if (money >= hotel.Price()) return true;
                SendReply(player, GetMsg(PluginMessages.MessageErrorNotEnoughRp, player.UserIDString)
                    .Replace("{0}", hotel.e)
                    .Replace("{1}", money.ToString()));
                return false;
            }

            var missingAmount = 0;
            var itemName = hotel.currency;
            var itemDefinition = ItemManager.FindItemDefinition(hotel.currency);
            if (itemDefinition != null)
            {
                missingAmount = int.Parse(hotel.e) - player.inventory.GetAmount(itemDefinition.itemid);
                itemName = itemDefinition.displayName.translated;
            }

            if (missingAmount <= 0) return true;
            SendReply(player, GetMsg(PluginMessages.MessageErrorNotEnoughItems, player.UserIDString)
                .Replace("{0}", itemName)
                .Replace("{1}", missingAmount.ToString()));
            return false;
        }

        void CheckTimeOutRooms()
        {
            var currentTime = LogTime();

            foreach (var hotel in storedData.Hotels.Where(hotel => hotel.enabled))
            {
                foreach (var room in hotel.rooms.Values.Where(x =>
                    (x.CheckOutTime() != 0.0 && x.CheckOutTime() < currentTime)))
                {
                    ResetRoom(room);
                }

                foreach (var room in hotel.rooms.Values.Where(x => string.IsNullOrEmpty(x.renter)))
                {
                    var codeLock = FindCodeLockByPos(room.Pos());
                    if (codeLock != null)
                    {
                        UnlockLock(codeLock);
                    }
                }

                CreateMapMarker(hotel);
            }
        }

        private void CleanUpMarkers()
        {
            foreach (var hotelMarker in HotelMarkers)
            {
                hotelMarker.Value.VendingMachineMapMarker?.Kill();
                hotelMarker.Value.GenericMapMarker?.Kill();
            }

        }

        private static void CloseDoor(Door door)
        {
            door.SetFlag(BaseEntity.Flags.Open, false);
            door.SendNetworkUpdateImmediate(true);
        }

        private void EconomicsWithdraw(BasePlayer player, int amount)
        {
            Economics?.Call("Withdraw", player.UserIDString, (double)amount);
            SendReply(player, $"You payed for this room {amount} coins");
        }

        private static void EmptyDeployablesRoom(BaseEntity door, float radius)
        {
            var foundItems = new List<BaseEntity>();
            var doorPos = door.transform.position;
            foreach (var col in Physics.OverlapSphere(doorPos, radius, DeployableColl))
            {
                var deploy = col.GetComponentInParent<BaseEntity>();
                if (deploy == null) continue;
                if (foundItems.Contains(deploy)) continue;

                var canReach = Physics.RaycastAll(deploy.transform.position + Vector3Up,
                        (doorPos + Vector3Up - deploy.transform.position).normalized,
                        Vector3.Distance(deploy.transform.position, doorPos) - 0.2f, ConstructionColl)
                    .All(rayHit =>
                        rayHit.collider.GetComponentInParent<Door>() != null &&
                        rayHit.collider.GetComponentInParent<Door>() == door);

                if (!canReach) continue;

                foreach (var col2 in Physics.OverlapSphere(doorPos, radius, ConstructionColl))
                {
                    BaseEntity door2 = col2.GetComponentInParent<Door>();
                    if (door2 == null) continue;
                    if (door2.transform.position == doorPos) continue;

                    var canReach2 = !Physics.RaycastAll(deploy.transform.position + Vector3Up,
                            (door2.transform.position + Vector3Up - deploy.transform.position).normalized,
                            Vector3.Distance(deploy.transform.position, door2.transform.position) - 0.2f,
                            ConstructionColl)
                        .Any();

                    if (!canReach2) continue;
                    canReach = false;
                    break;
                }

                if (!canReach) continue;

                foundItems.Add(deploy);
            }

            foreach (var deploy in foundItems.Where(deploy => deploy != null && !deploy.IsDestroyed))
            {
                deploy.KillMessage();
            }
        }

        private static Dictionary<string, Room> FindAllRooms(Vector3 position, float radius, float roomradius)
        {
            var listLocks = FindDoorsFromPosition(position, radius);

            var deployables = new Hash<BaseEntity, string>();
            var tempRooms = new Dictionary<string, Room>();

            foreach (var door in listLocks)
            {
                var pos = door.transform.position;
                var newRoom = new Room(pos)
                {
                    defaultDeployables = new List<DeployableItem>()
                };

                var foundItems = new List<BaseEntity>();

                foreach (var col in Physics.OverlapSphere(pos, roomradius, DeployableColl))
                {
                    var deploy = col.GetComponentInParent<BaseEntity>();
                    if (deploy == null) continue;
                    if (foundItems.Contains(deploy)) continue;
                    foundItems.Add(deploy);

                    var canReach = Physics.RaycastAll(deploy.transform.position + Vector3Up,
                            (pos + Vector3Up - deploy.transform.position).normalized,
                            Vector3.Distance(deploy.transform.position, pos) - 0.2f, ConstructionColl)
                        .All(rayHit =>
                            rayHit.collider.GetComponentInParent<Door>() != null &&
                            rayHit.collider.GetComponentInParent<Door>() == door);

                    if (!canReach) continue;

                    if (deployables[deploy] != null) deployables[deploy] = "0";
                    else deployables[deploy] = newRoom.roomId;
                }

                tempRooms.Add(newRoom.roomId, newRoom);
            }

            foreach (var pair in deployables)
            {
                if (pair.Value == "0") continue;
                var newDeployItem = new DeployableItem(pair.Key);
                tempRooms[pair.Value].defaultDeployables.Add(newDeployItem);
            }

            return tempRooms;
        }

        private static BuildingBlock FindBlockFromRay(Vector3 pos, Vector3 aim)
        {
            var hits = Physics.RaycastAll(pos, aim);
            var distance = 100000f;
            BuildingBlock target = null;
            foreach (var hit in hits)
            {
                if (hit.collider.GetComponentInParent<BuildingBlock>() == null || !(hit.distance < distance)) continue;
                distance = hit.distance;
                target = hit.collider.GetComponentInParent<BuildingBlock>();
            }

            return target;
        }

        private static CodeLock FindCodeLockByPos(Vector3 pos)
        {
            CodeLock findCode = null;
            foreach (var col in Physics.OverlapSphere(pos, 2f, ConstructionColl))
            {
                if (col.GetComponentInParent<Door>() == null) continue;
                if (!col.GetComponentInParent<Door>().HasSlot(BaseEntity.Slot.Lock)) continue;

                var slotEntity = col.GetComponentInParent<Door>().GetSlot(BaseEntity.Slot.Lock);
                if (slotEntity == null) continue;
                if (slotEntity.GetComponent<CodeLock>() == null) continue;

                if (findCode != null)
                    if (Vector3.Distance(pos, findCode.GetParentEntity().transform.position) <
                        Vector3.Distance(pos, col.transform.position))
                        continue;
                findCode = slotEntity.GetComponent<CodeLock>();
            }

            return findCode;
        }

        private static CodeLock FindCodeLockByRoomId(string roomId)
        {
            var roomPos = roomId.Split(':');
            return roomPos.Length != 3
                ? null
                : FindCodeLockByPos(new Vector3(Convert.ToSingle(roomPos[0]), Convert.ToSingle(roomPos[1]),
                    Convert.ToSingle(roomPos[2])));
        }

        private static List<Door> FindDoorsFromPosition(Vector3 position, float radius)
        {
            var listLocks = new List<Door>();
            foreach (var col in Physics.OverlapSphere(position, radius, ConstructionColl))
            {
                var door = col.GetComponentInParent<Door>();
                if (door == null) continue;
                if (!door.HasSlot(BaseEntity.Slot.Lock)) continue;
                if (door.GetSlot(BaseEntity.Slot.Lock) == null) continue;
                if (!(door.GetSlot(BaseEntity.Slot.Lock) is CodeLock)) continue;
                if (listLocks.Contains(door)) continue;
                CloseDoor(door);
                listLocks.Add(door);
            }

            return listLocks;
        }

        private bool FindHotelAndRoomByPos(Vector3 position, out HotelData hotelData, out Room roomData)
        {
            hotelData = null;
            roomData = null;
            position.x = Mathf.Ceil(position.x);
            position.y = Mathf.Ceil(position.y);
            position.z = Mathf.Ceil(position.z);

            foreach (var hotel in storedData.Hotels)
            {
                foreach (var room in hotel.rooms.Values.Where(room => room.Pos() == position))
                {
                    hotelData = hotel;
                    roomData = room;
                    return true;
                }
            }

            return false;
        }

        private IPlayer FindPlayer(string nameOrIdOrIp)
        {
            foreach (var activePlayer in covalence.Players.All)
            {
                if (activePlayer.Id == nameOrIdOrIp)
                    return activePlayer;
                if (activePlayer.Name.Contains(nameOrIdOrIp))
                    return activePlayer;
                if (activePlayer.Name.ToLower().Contains(nameOrIdOrIp.ToLower()))
                    return activePlayer;
                if (activePlayer.Address == nameOrIdOrIp)
                    return activePlayer;
            }

            return null;
        }

        private bool FindRoomById(string roomId, out HotelData targetHotel, out Room targetRoom)
        {
            targetHotel = null;
            targetRoom = null;
            foreach (var hotel in storedData.Hotels.Where(hotel => hotel.rooms.ContainsKey(roomId)))
            {
                targetHotel = hotel;
                targetRoom = (hotel.rooms)[roomId];
                return true;
            }

            return false;
        }

        private static Room FindRoomByDoorAndHotel(HotelData hotel, BaseEntity door)
        {
            var roomId =
                $"{Math.Ceiling(door.transform.position.x)}:{Math.Ceiling(door.transform.position.y)}:{Math.Ceiling(door.transform.position.z)}";
            return !hotel.rooms.ContainsKey(roomId) ? null : hotel.rooms[roomId];
        }

        private RoomTimeMessage GetRoomTimeLeft(HotelData hotel, string userIdString)
        {
            var roomTimeMessage = new RoomTimeMessage
            {
                TimeMessage = "No Room Rented.",
                TimeRemaining = double.MaxValue
            };

            foreach (var secondsLeft in from room in hotel.rooms.Values
                                        where room.renter == userIdString
                                        select room.CheckOutTime() - LogTime())
            {
                roomTimeMessage.TimeRemaining = secondsLeft;
                if (secondsLeft > 0)
                {
                    roomTimeMessage.TimeMessage =
                        ConvertSecondsToBetter(secondsLeft) + " (" + hotel.hotelName + " Expires)";
                }
                else
                {
                    roomTimeMessage.TimeMessage = "Your " + hotel.hotelName + " room expired";
                }
            }

            return roomTimeMessage;
        }

        private bool HasBlackListedItems(BasePlayer player, List<string> blackList)
        {
            ItemContainer backpack = null;
            if (Backpacks && Backpacks.IsLoaded)
            {
                backpack = Backpacks.Call<ItemContainer>("API_GetBackpackContainer", player.userID);
            }
            foreach (var item in blackList)
            {
                if (player.inventory.GetAmount(int.Parse(item.Split('_')[0])) > 0)
                {
                    return true;
                };
                if (backpack != null && backpack.GetAmount(int.Parse(item.Split('_')[0]), false) > 0)
                {
                    return true;
                }
            }

            return false;
        }

        private bool HasAccess(BasePlayer player, string accessRole = "admin")
        {
            if (player == null) return false;
            return player.net.connection.authLevel >= config.AuthLevel ||
                   permission.UserHasPermission(player.UserIDString, $"hotel.{accessRole}");
        }

        private void LoadPermissions()
        {
            permission.RegisterPermission("hotel.admin", this);
            permission.RegisterPermission("hotel.extend", this);
            permission.RegisterPermission("hotel.renter", this);

            foreach (var hotel in storedData.Hotels.Where(hotel => hotel.p != null && hotel.p.ToLower() != "renter"))
            {
                permission.RegisterPermission("hotel." + hotel.p, this);
            }
        }

        private static void LockLock(CodeLock codeLock)
        {
            codeLock.SetFlag(BaseEntity.Flags.Locked, true);
            codeLock.SendNetworkUpdate();
        }

        static double LogTime()
        {
            return DateTime.UtcNow.Subtract(Epoch).TotalSeconds;
        }

        private void NewRoomOwner(CodeLock codeLock, BasePlayer player, HotelData hotel, Room room)
        {
            var door = codeLock.GetParentEntity();

            //Reset only if new renter
            if (string.IsNullOrEmpty(room.lastRenter) || room.lastRenter != player.UserIDString)
            {
                EmptyDeployablesRoom(door, Convert.ToSingle(hotel.rr));
                foreach (var deploy in room.defaultDeployables)
                {
                    SpawnDeployable(deploy.prefabName, deploy.Pos(), deploy.Rot(), player, deploy.skinId);
                }

                if (!string.IsNullOrEmpty(room.lastRenter))
                {
                    var oldTenant = BasePlayer.FindByID(ulong.Parse(room.lastRenter));
                    if (oldTenant != null)
                    {
                        //Kick the old tenant out?
                        var isInZone = ZoneManager.Call<bool>("IsPlayerInZone", hotel.hotelName, oldTenant);

                        if (isInZone)
                        {
                            //Player is in a hotel and they don't have a room.. Kick them.
                            var zone = ZoneManager.Call<ZoneManager.Zone>("GetZoneByID", hotel.hotelName);
                            ZoneManager.Call("EjectPlayer", oldTenant, zone);
                        }
                    }
                }
            }

            var whitelist = new List<ulong> { player.userID };
            codeLock.whitelistPlayers = whitelist;

            room.renter = player.UserIDString;
            room.lastRenter = player.UserIDString;
            room.checkingTime = LogTime().ToString(CultureInfo.InvariantCulture);

            room.checkoutTime = hotel.rd == "0"
                ? "0"
                : (LogTime() + double.Parse(hotel.rd)).ToString(CultureInfo.InvariantCulture);
            room.Reset();

            LockLock(codeLock);
            OpenDoor(door as Door);
            var message = hotel.rd == "0"
                ? GetMsg(PluginMessages.MessageRentUnlimited, player.userID)
                : GetMsg(PluginMessages.MessageRentTimeLeft, player.userID)
                    .Replace("{0}", ConvertSecondsToBetter(hotel.rd));

            SendReply(player, message);
        }

        private static void OpenDoor(Door door)
        {
            door.SetFlag(BaseEntity.Flags.Open, true);
            door.SendNetworkUpdateImmediate(true);
        }

        static object RaycastAll<T>(Ray ray) where T : BaseEntity
        {
            var hits = Physics.RaycastAll(ray);
            GamePhysics.Sort(hits);
            var distance = 100f;
            object target = null;
            foreach (var hit in hits)
            {
                var ent = hit.GetEntity();
                if (!(ent is T) || !(hit.distance < distance)) continue;
                target = ent;
                break;
            }

            return target;
        }

        private Vector3 RayForDoor(BasePlayer player)
        {
            var target = RaycastAll<BaseEntity>(player.eyes.HeadRay());
            if (target == null) return default(Vector3);
            return ((BaseEntity)target).transform.position;
        }

        private void ResetRoom(Room room)
        {
            var codeLock = FindCodeLockByPos(room.Pos());
            if (codeLock == null) return;
            ResetRoom(codeLock, room);
        }

        private static void ResetRoom(CodeLock codeLock, Room room)
        {
            var door = codeLock.GetParentEntity();
            codeLock.whitelistPlayers = new List<ulong>();

            UnlockLock(codeLock);
            CloseDoor(door as Door);

            room.lastRenter = room.renter;
            room.renter = null;
            room.checkingTime = null;
            room.checkoutTime = null;
            room.Reset();
        }

        private void SaveData()
        {
            Interface.GetMod().DataFileSystem.WriteObject("Hotel", storedData);
        }

        private void ServerRewardsWithdraw(BasePlayer player, int amount)
        {
            ServerRewards?.Call("TakePoints", player.UserIDString, amount);
            SendReply(player, $"You payed for this room {amount} Reward Points");
        }

        private static void SpawnDeployable(string prefabName, Vector3 pos, Quaternion rot, BasePlayer player = null,
            ulong skinId = 0)
        {
            var newPrefab = GameManager.server.FindPrefab(prefabName);
            if (newPrefab == null) return;
            var entity = GameManager.server.CreateEntity(prefabName, pos, rot);
            if (entity == null) return;
            if (player != null)
            {
                entity.OwnerID = player.userID;
                if (entity is SleepingBag)
                {
                    ((SleepingBag)entity).deployerUserID = player.userID;
                }

                entity.SendMessage("SetDeployedBy", player, SendMessageOptions.DontRequireReceiver);
            }

            if (skinId != 0)
            {
                entity.skinID = skinId;
            }

            entity.Spawn();
        }

        private bool TryParseHtmlString(string value, out Color color)
        {
            if (!value.StartsWith("#"))
            {
                value = $"#{value}";
            }

            return ColorUtility.TryParseHtmlString(value, out color);
        }

        void Unload()
        {
            CleanUpMarkers();
            CleanUpUi();

            SaveData();
            hotelRoomCheckoutTimer?.Destroy();
            hotelGuiTimer?.Destroy();
        }

        private void CleanUpUi()
        {
            foreach (var basePlayer in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(basePlayer, "HotelTimer");
            }
        }

        private static void UnlockLock(CodeLock codeLock)
        {
            codeLock.SetFlag(BaseEntity.Flags.Locked, false);
            codeLock.SendNetworkUpdate();
        }

        private void UpdateHotelCounter()
        {
            foreach (var basePlayer in BasePlayer.activePlayerList)
            {
                var roomTimeMessage = new RoomTimeMessage
                {
                    TimeMessage = "No Room Rented.",
                    TimeRemaining = double.MaxValue
                };

                foreach (var roomTime in storedData.Hotels.Select(hotel =>
                        GetRoomTimeLeft(hotel, basePlayer.UserIDString))
                    .Where(roomTime => roomTime.TimeRemaining < roomTimeMessage.TimeRemaining))
                {
                    roomTimeMessage = roomTime;
                }

                if (roomTimeMessage.TimeMessage.StartsWith("No Room ") && config.HideUiForNonRenters)
                {
                    CuiHelper.DestroyUi(basePlayer, "HotelTimer");
                }else{
                    ShowHotelCounterUi(basePlayer, roomTimeMessage);
                }

            }
        }


        #endregion

        #region GUI

        private void ShowHotelCounterUi(BasePlayer player, RoomTimeMessage roomTimeMessage)
        {

            var hotelCounterUi = new CuiElementContainer
            {
                {
                    new CuiLabel()
                    {
                        Text = {
                            Text = roomTimeMessage.TimeMessage,
                            Align = TextAnchor.UpperLeft,
                            FontSize = config.CounterUiTextSize,
                            Color = roomTimeMessage.TimeRemaining<600?"0.91 0.27 0.27 1":config.CounterUiTextColor
                        },
                        RectTransform =
                        {
                            AnchorMin = config.CounterUiAnchorMin,
                            AnchorMax = config.CounterUiAnchorMax
                        }
                    },
                    "Hud", "HotelTimer"
                }
            };
            CuiHelper.DestroyUi(player, "HotelTimer");
            CuiHelper.AddUi(player, hotelCounterUi);
        }


        private void RefreshAdminHotelGui(BasePlayer player)
        {
            RemoveAdminHotelGui(player);

            if (!EditHotel.ContainsKey(player.UserIDString)) return;
            var msg = CreateAdminGuiMsg(player);
            if (msg == string.Empty) return;
            var send = config.AdminGuiJson.Replace("{msg}", msg);
            CuiHelper.AddUi(player, send);
        }

        private void RefreshBlackListGui(BasePlayer player, HotelData hotel, List<string> blackList)
        {
            RemoveBlackListGui(player);

            var msg = CreateBlackListGuiMsg(player, hotel, blackList);
            if (msg == string.Empty) return;
            var send = config.BlackListGuiJson.Replace("{msg}", msg);
            CuiHelper.AddUi(player, send);
            playerBlackListGuiTimers[player] = timer.Once(config.PanelTimeOut, () => RemoveBlackListGui(player));
        }

        private string CreateBlackListGuiMsg(BasePlayer player, HotelData hotel, List<string> blackList)
        {
            return GetMsg(PluginMessages.GuiBoardBlackList, player.UserIDString)
                .Replace("{name}", hotel.hotelName)
                .Replace("{blacklist}", string.Join("\r\n", blackList.Select(x => x.Split('_')[1]).OrderBy(x => x)));
        }

        private void RemoveBlackListGui(BasePlayer player)
        {
            if (player == null || player.net == null) return;
            if (playerBlackListGuiTimers[player] != null)
                playerBlackListGuiTimers[player].Destroy();

            CuiHelper.DestroyUi(player, "HotelBlackList");
        }

        private void RefreshPlayerHotelGui(BasePlayer player, HotelData hotel)
        {
            RemovePlayerHotelGui(player);
            string msg;
            string send;

            if (!hotel.enabled)
            {
                msg = CreatePlayerGuiMsg(player, hotel,
                    GetMsg(PluginMessages.GuiBoardPlayerMaintenance, player.userID));
                send = config.PlayerGuiJson.Replace("{msg}", msg);
                CuiHelper.AddUi(player, send);
            }
            else
            {
                msg = CreatePlayerGuiMsg(player, hotel, GetMsg(PluginMessages.GuiBoardPlayer, player.userID));
                if (msg == string.Empty) return;
                send = config.PlayerGuiJson.Replace("{msg}", msg);

                CuiHelper.AddUi(player, send);

                if (HasAccess(player, "extend") && hotel.rooms.Values.FirstOrDefault(x => x.renter == player.UserIDString) != null)
                {
                    //if Player can extend add button here
                    var extendContainer = new CuiElementContainer();
                    extendContainer.Add(new CuiButton
                    {
                        Button = { Color = ".3 .2 .3 1", Command = $"hotelextend '{hotel.hotelName}' ", FadeIn = 0.4f },
                        RectTransform = { AnchorMin = "0.7 0.8", AnchorMax = "1 1" },
                        Text = { Text = GetMsg(PluginMessages.ExtendButtonText, player.userID), FontSize = 12, Align = TextAnchor.MiddleCenter }
                    }, "HotelPlayer");

                    CuiHelper.AddUi(player, extendContainer);
                }
            }

            playerGuiTimers[player] = timer.Once(config.PanelTimeOut, () => RemovePlayerHotelGui(player));
        }

        private static string ConvertSecondsToBetter(string seconds)
        {
            return ConvertSecondsToBetter(double.Parse(seconds));
        }

        private static string ConvertSecondsToBetter(double seconds)
        {
            var t = TimeSpan.FromSeconds(seconds);
            return $"{t.Days:D2}d:{t.Hours:D2}h:{t.Minutes:D2}m:{t.Seconds:D2}s";
        }

        private static string ConvertSecondsToDate(string seconds)
        {
            return ConvertSecondsToDate(double.Parse(seconds));
        }

        private static string ConvertSecondsToDate(double seconds)
        {
            return Epoch.AddSeconds(seconds).ToLocalTime().ToString(CultureInfo.InvariantCulture);
        }

        private string CreatePlayerGuiMsg(BasePlayer player, HotelData hotel, string guiMsg)
        {
            var loc = hotel.x == null ? "None" : $"X : {double.Parse(hotel.x):F0}, Y : {double.Parse(hotel.y):F0}, Z : {double.Parse(hotel.z):F0}";
            var hotelRadius = hotel.r ?? "None";
            var roomRadius = hotel.rr ?? "None";
            var roomCount = hotel.rooms?.Count ?? 0;

            var occupiedCount = 0;
            var freeCount = 0;

            var roomGui = string.Empty;

            if (hotel.rooms != null)
            {
                var playersRoom = hotel.rooms.Values.FirstOrDefault(x => x.renter == player.UserIDString);

                if (playersRoom != null)
                {
                    roomGui = GetMsg(PluginMessages.GuiBoardPlayerRoom, player.userID)
                        .Replace("{jdate}", ConvertSecondsToDate(playersRoom.checkingTime))
                        .Replace("{rid}", playersRoom.roomId)
                        .Replace("{timeleft}",
                            playersRoom.CheckOutTime() == 0.0
                                ? "Unlimited"
                                : ConvertSecondsToBetter(playersRoom.CheckOutTime() - LogTime()));
                }

                occupiedCount = hotel.rooms.Values.Count(x => x.renter != null);
                freeCount = hotel.rooms.Values.Count(x => x.renter == null);
            }

            var newGuiMsg = guiMsg
                                .Replace("{name}", hotel.hotelName)
                                .Replace("{loc}", loc)
                                .Replace("{hrad}", hotelRadius)
                                .Replace("{rrad}", roomRadius)
                                .Replace("{rnum}", roomCount.ToString())
                                .Replace("{onum}", occupiedCount.ToString())
                                .Replace("{price}", hotel.e)
                                .Replace("{currency}", hotel.currency == "0" ? "Economics" : hotel.currency == "1" ? "Server Rewards" : hotel.currency)
                                .Replace("{durSeconds}", hotel.rd)
                                .Replace("{durHours}", (int.Parse(hotel.rd ?? "0") / 3600).ToString("F1"))
                                .Replace("{durDays}", (int.Parse(hotel.rd ?? "0") / 86400).ToString("F1"))
                            .Replace("{fnum}", freeCount.ToString())
                            + roomGui;

            return newGuiMsg;
        }

        private string CreateAdminGuiMsg(BasePlayer player)
        {
            var hotelData = EditHotel[player.UserIDString];

            var loc = hotelData.x == null ? "None" : $"{hotelData.x} {hotelData.y} {hotelData.z}";
            var hotelRadius = hotelData.r ?? "None";
            var roomRadius = hotelData.rr ?? "None";
            var rrp = hotelData.e ?? "None";
            var numberRooms = hotelData.rooms?.Count ?? 0;

            if (numberRooms == 0)
            {
                return GetMsg(PluginMessages.GuiBoardAdmin, player.userID)
                    .Replace("{name}", hotelData.hotelName)
                    .Replace("{loc}", loc)
                    .Replace("{hrad}", hotelRadius)
                    .Replace("{rrad}", roomRadius)
                    .Replace("{rnum}", "0")
                    .Replace("{onum}", "0")
                    .Replace("{fnum}", "0")
                    .Replace("{npcId}", hotelData.npc)
                    .Replace("{kh}", hotelData.kickHobos ? "True" : "False")
                    .Replace("{sm}", hotelData.showMarker ? "True" : "False")
                    .Replace("{rd}", hotelData.rd)
                    .Replace("{p}", hotelData.p)
                    .Replace("{rc}",
                        hotelData.currency == "0" ? "Economics" :
                        hotelData.currency == "1" ? "Server Rewards" : hotelData.currency)
                    .Replace("{rp}", rrp);
            }

            var occupiedCount = hotelData.rooms?.Values.Count(x => x.renter != null);
            var freeCount = hotelData.rooms?.Values.Count(x => x.renter == null);

            return GetMsg(PluginMessages.GuiBoardAdmin, player.userID)
                .Replace("{name}", hotelData.hotelName)
                .Replace("{loc}", loc)
                .Replace("{hrad}", hotelRadius)
                .Replace("{rrad}", roomRadius)
                .Replace("{rnum}", numberRooms.ToString())
                .Replace("{onum}", occupiedCount.ToString())
                .Replace("{fnum}", freeCount.ToString())
                .Replace("{npcId}", hotelData.npc)
                .Replace("{rd}", hotelData.rd)
                .Replace("{p}", hotelData.p)
                .Replace("{kh}", hotelData.kickHobos ? "True" : "False")
                .Replace("{sm}", hotelData.showMarker ? "True" : "False")
                .Replace("{rc}",
                    hotelData.currency == "0" ? "Economics" :
                    hotelData.currency == "1" ? "Server Rewards" : hotelData.currency)
                .Replace("{rp}", rrp);
        }

        private void RemoveAdminHotelGui(BasePlayer player)
        {
            CuiHelper.DestroyUi(player, "HotelAdmin");
        }

        private void RemovePlayerHotelGui(BasePlayer player)
        {
            if (player == null || player.net == null) return;
            if (playerGuiTimers[player] != null)
                playerGuiTimers[player].Destroy();

            CuiHelper.DestroyUi(player, "HotelPlayer");
        }

        private void ShowHotelGrid(BasePlayer player)
        {
            var hotelData = EditHotel[player.UserIDString];
            if (hotelData.x != null && hotelData.r != null)
            {
                var hotelPos = hotelData.Pos();
                var hotelRadius = Convert.ToSingle(hotelData.r);
                player.SendConsoleCommand("ddraw.sphere", 5f, Color.blue, hotelPos, hotelRadius);
            }

            if (hotelData.rooms == null) return;
            foreach (var room in hotelData.rooms.Values)
            {
                var deployables = room.defaultDeployables;
                foreach (var deployable in deployables)
                {
                    player.SendConsoleCommand("ddraw.arrow", 10f, Color.green, room.Pos(), deployable.Pos(), 0.5f);
                }
            }
        }

        private static void ShowPlayerRoom(BasePlayer player, HotelData hotel)
        {
            var foundRoom = (from pair in hotel.rooms where pair.Value.renter == player.UserIDString select pair.Value)
                .FirstOrDefault();
            if (foundRoom == null) return;
            player.SendConsoleCommand("ddraw.arrow", 10f, Color.green, player.transform.position,
                foundRoom.Pos() + Vector3Up2, 0.5f);
        }

        public void CreateMapMarker(HotelData hotel)
        {
            HotelMarker hotelMarker;
            if (!hotel.showMarker)
            {
                if (!HotelMarkers.TryGetValue(hotel.hotelName, out hotelMarker)) return;

                hotelMarker.VendingMachineMapMarker?.Kill();
                hotelMarker.GenericMapMarker?.Kill();
                HotelMarkers.Remove(hotel.hotelName);
                return;
            }

            if (!HotelMarkers.TryGetValue(hotel.hotelName, out hotelMarker))
            {
                const uint marker = 3459945130;
                const uint radiusMarker = 2849728229;
                hotelMarker = new HotelMarker
                {
                    VendingMachineMapMarker =
                        GameManager.server.CreateEntity(StringPool.Get(marker), hotel.Pos()) as VendingMachineMapMarker,
                    GenericMapMarker =
                        GameManager.server.CreateEntity(StringPool.Get(radiusMarker), hotel.Pos()) as
                            MapMarkerGenericRadius
                };

                if (hotelMarker.VendingMachineMapMarker != null)
                {
                    hotelMarker.VendingMachineMapMarker.Spawn();
                }

                if (hotelMarker.GenericMapMarker != null)
                {
                    hotelMarker.GenericMapMarker.Spawn();
                }

                HotelMarkers.Add(hotel.hotelName, hotelMarker);
            }

            if (hotelMarker.VendingMachineMapMarker != null)
            {
                hotelMarker.VendingMachineMapMarker.server_vendingMachine = null;
                var roomCount = hotel.rooms.Count;
                var rentedRooms = hotel.rooms.Values.Count(x => !string.IsNullOrEmpty(x.renter));

                if (roomCount > rentedRooms)
                {
                    //Open Rooms make Icon Green
                    hotelMarker.VendingMachineMapMarker.SetFlag(BaseEntity.Flags.Busy, true);
                }

                hotelMarker.VendingMachineMapMarker.enabled = true;
                var markerMsg = config.MapMarker
                    .Replace("{name}", hotel.hotelName)
                    .Replace("{fnum}", hotel.rooms.Values.Count(x => x.renter == null).ToString())
                    .Replace("{onum}", hotel.rooms.Values.Count(x => x.renter != null).ToString())
                    .Replace("{rnum}", hotel.rooms.Values.Count.ToString())
                    .Replace("{rp}", hotel.e)
                    .Replace("{price}", hotel.e)
                    .Replace("{currency}",
                        hotel.currency == "0" ? "Economics" : hotel.currency == "1" ? "Server Rewards" : hotel.currency)
                    .Replace("{rc}",
                        hotel.currency == "0" ? "Economics" : hotel.currency == "1" ? "Server Rewards" : hotel.currency)
                    .Replace("{rd}", hotel.rd)
                    .Replace("{durHours}", (int.Parse(hotel.rd ?? "0") / 3600).ToString("F1"))
                    .Replace("{durDays}", (int.Parse(hotel.rd ?? "0") / 86400).ToString("F1"))
                    .Replace("{durSeconds}", hotel.rd);

                if (!string.IsNullOrEmpty(hotel.p))
                {
                    markerMsg += $"\r\n\"{hotel.p}\" Only";
                }

                hotelMarker.VendingMachineMapMarker.markerShopName = markerMsg;
                hotelMarker.VendingMachineMapMarker.SendNetworkUpdate();
            }

            if (hotelMarker.GenericMapMarker == null) return;
            hotelMarker.GenericMapMarker.alpha = 0.75f;
            hotelMarker.GenericMapMarker.color1 = GetMarkerColor();
            hotelMarker.GenericMapMarker.color2 = GetMarkerColor("color2");
            hotelMarker.GenericMapMarker.radius = Mathf.Min(2.5f, config.MapMarkerRadius);
            hotelMarker.GenericMapMarker.SendUpdate();
        }

        private Color GetMarkerColor(string id = "color1")
        {
            Color color;

            if (id == "color1")
            {
                return TryParseHtmlString(config.MapMarkerColor, out color) ? color : Color.magenta;
            }

            return TryParseHtmlString(config.MapMarkerColorBorder, out color) ? color : Color.magenta;
        }

        #endregion

        #region Chat Commands

        [ChatCommand("hotel_save")]
        void CmdChatHotelSave(BasePlayer player, string command, string[] args)
        {
            if (!HasAccess(player))
            {
                SendReply(player, GetMsg(PluginMessages.MessageErrorNotAllowed, player.userID));
                return;
            }

            if (!EditHotel.ContainsKey(player.UserIDString))
            {
                SendReply(player, "You are not editing a hotel.");
                return;
            }

            var editedHotel = EditHotel[player.UserIDString];

            var removeHotel = storedData.Hotels.FirstOrDefault(hotel =>
                string.Equals(hotel.hotelName, editedHotel.hotelName, StringComparison.CurrentCultureIgnoreCase));
            if (removeHotel != null)
            {
                storedData.Hotels.Remove(removeHotel);
                removeHotel.Activate();
            }

            editedHotel.Activate();

            storedData.Hotels.Add(editedHotel);

            SaveData();
            LoadPermissions();

            CreateMapMarker(editedHotel);

            EditHotel.Remove(player.UserIDString);

            SendReply(player, "Hotel Saved and Closed.");

            RemoveAdminHotelGui(player);
        }

        [ChatCommand("hotel_close")]
        void CmdChatHotelClose(BasePlayer player, string command, string[] args)
        {
            if (!HasAccess(player))
            {
                SendReply(player, GetMsg(PluginMessages.MessageErrorNotAllowed, player.userID));
                return;
            }

            if (!EditHotel.ContainsKey(player.UserIDString))
            {
                SendReply(player, "You are not editing a hotel.");
                return;
            }

            var editedHotel = EditHotel[player.UserIDString];
            foreach (var hotel in storedData.Hotels.Where(hotel =>
                string.Equals(hotel.hotelName, editedHotel.hotelName, StringComparison.CurrentCultureIgnoreCase)))
            {
                hotel.Activate();
                break;
            }

            EditHotel.Remove(player.UserIDString);

            SendReply(player, "Hotel Closed without saving.");

            RemoveAdminHotelGui(player);
        }

        [ChatCommand("hotel")]
        void CmdChatHotel(BasePlayer player, string command, string[] args)
        {
            if (!HasAccess(player))
            {
                SendReply(player, GetMsg(PluginMessages.MessageErrorNotAllowed, player.userID));
                return;
            }

            if (!EditHotel.ContainsKey(player.UserIDString))
            {
                SendReply(player, GetMsg(PluginMessages.MessageNoHotelHelp, player.UserIDString));
                return;
            }

            var editedHotel = EditHotel[player.UserIDString];

            if (args.Length == 0)
            {
                SendReply(player, GetMsg(PluginMessages.Menu1, player.UserIDString));
                SendReply(player, GetMsg(PluginMessages.Menu2, player.UserIDString));
                SendReply(player, GetMsg(PluginMessages.Menu3, player.UserIDString));
                SendReply(player, GetMsg(PluginMessages.Menu4, player.UserIDString));
                SendReply(player, GetMsg(PluginMessages.Menu5, player.UserIDString));
                SendReply(player, GetMsg(PluginMessages.Menu6, player.UserIDString));
                SendReply(player, GetMsg(PluginMessages.Menu7, player.UserIDString));
                SendReply(player, GetMsg(PluginMessages.Menu8, player.UserIDString));
                SendReply(player, GetMsg(PluginMessages.Menu9, player.UserIDString));
                SendReply(player, GetMsg(PluginMessages.Menu10, player.UserIDString));
                SendReply(player, GetMsg(PluginMessages.Menu11, player.UserIDString));
                SendReply(player, GetMsg(PluginMessages.Menu12, player.UserIDString));
                SendReply(player, GetMsg(PluginMessages.Menu13, player.UserIDString));
            }
            else
            {
                switch (args[0].ToLower())
                {
                    case "location":
                        var rad = editedHotel.r ?? "20";

                        var defaultZoneFlags = config.DefaultZoneFlags;
                        var zoneArgs = new List<string> { "name", editedHotel.hotelName, "radius", rad };
                        foreach (var defaultZoneFlag in defaultZoneFlags)
                        {
                            zoneArgs.Add(defaultZoneFlag);
                            zoneArgs.Add("true");
                        }

                        ZoneManager.Call("CreateOrUpdateZone", editedHotel.hotelName, zoneArgs.ToArray(),
                            player.transform.position);

                        (EditHotel[player.UserIDString]).x =
                            player.transform.position.x.ToString(CultureInfo.InvariantCulture);
                        (EditHotel[player.UserIDString]).y =
                            player.transform.position.y.ToString(CultureInfo.InvariantCulture);
                        (EditHotel[player.UserIDString]).z =
                            player.transform.position.z.ToString(CultureInfo.InvariantCulture);

                        SendReply(player, $"Location set to {player.transform.position}");
                        break;
                    case "rentduration":
                        if (args.Length == 1)
                        {
                            SendReply(player, "/hotel rentduration XX");
                            return;
                        }

                        int rd;
                        int.TryParse(args[1], out rd);

                        (EditHotel[player.UserIDString]).rd = rd.ToString();
                        SendReply(player, $"Rent Duration set to {(rd == 0 ? "Infinite" : rd.ToString())}");
                        break;
                    case "rentprice":
                        if (args.Length == 1)
                        {
                            SendReply(player, "/hotel rentprice XX");
                            return;
                        }

                        int rp;
                        if (!int.TryParse(args[1], out rp))
                        {
                            SendReply(player, "/hotel rentprice XX");
                            return;
                        }

                        (EditHotel[player.UserIDString]).e = rp == 0 ? null : rp.ToString();
                        SendReply(player, $"Rent Price set to {(rp == 0 ? "null" : rp.ToString())}");
                        break;
                    case "kickhobos":
                        if (args.Length == 1)
                        {
                            SendReply(player, "/hotel kickhobos [true/false]");
                            return;
                        }

                        bool kickHobos;
                        if (!bool.TryParse(args[1], out kickHobos))
                        {
                            SendReply(player, "/hotel kickhobos [true/false]");
                            return;
                        }

                        (EditHotel[player.UserIDString]).kickHobos = kickHobos;
                        SendReply(player, "Hotel Kicking Hobos set to {0}", args[1]);
                        break;
                    case "showmarker":
                        if (args.Length == 1)
                        {
                            SendReply(player, "/hotel showmarker [true/false]");
                            return;
                        }

                        bool showMarker;
                        if (!bool.TryParse(args[1], out showMarker))
                        {
                            SendReply(player, "/hotel showmarker [true/false]");
                            return;
                        }

                        (EditHotel[player.UserIDString]).showMarker = showMarker;
                        SendReply(player, "Hotel Show Marker set to {0}", args[1]);
                        break;
                    case "rentcurrency":
                        if (args.Length == 1)
                        {
                            SendReply(player, "/hotel rentcurrency XX");
                            return;
                        }

                        int rc;
                        if (int.TryParse(args[1], out rc))
                        {
                            if (rc == 0 && Economics == null)
                            {
                                SendReply(player,
                                    "You don't have economics, please enter an item short name like scrap.");
                                return;
                            }

                            if (rc == 1 && ServerRewards == null)
                            {
                                SendReply(player,
                                    "You don't have Server Rewards, please enter an item short name like scrap.");
                                return;
                            }

                            SendReply(player, $"Rent Currency set to {(rc == 0 ? "Economics" : "Server Rewards")}");
                        }
                        else
                        {
                            var itemName = args[1];
                            var itemDefinition = ItemManager.FindItemDefinition(itemName);
                            if (itemDefinition == null)
                            {
                                SendReply(player, $"Unable to find the currency item {args[1]}");
                                return;
                            }

                            SendReply(player, $"Rent Currency set to {itemDefinition.displayName.translated}");
                        }

                        (EditHotel[player.UserIDString]).currency = args[1];
                        break;
                    case "roomradius":
                        if (args.Length == 1)
                        {
                            SendReply(player, "/hotel roomradius XX");
                            return;
                        }

                        int rad3;

                        int.TryParse(args[1], out rad3);
                        if (rad3 < 1) rad3 = 5;

                        (EditHotel[player.UserIDString]).rr = rad3.ToString();

                        SendReply(player, $"RoomRadius set to {args[1]}");
                        break;
                    case "permission":
                        if (args.Length == 1)
                        {
                            SendReply(player,
                                "/hotel permission \"Permission Name\" => Sets a permission that the player must have to rent in this hotel. put null or false to cancel the permission");
                            return;
                        }

                        var setNewPermission =
                            (args[1].ToLower() == "null" || args[1].ToLower() == "false" || args[1].ToLower() == "0")
                                ? null
                                : args[1];
                        (EditHotel[player.UserIDString]).p = setNewPermission;

                        SendReply(player, $"Permissions set to {setNewPermission ?? "null"}");
                        break;
                    case "npc":
                        if (args.Length == 1)
                        {
                            SendReply(player, "/hotel npc npcId");
                            return;
                        }

                        long npcId;
                        long.TryParse(args[1], out npcId);
                        if (npcId < 1) return;

                        (EditHotel[player.UserIDString]).npc = npcId.ToString();
                        SendReply(player, $"NPC Id hooked to this hotel: {npcId}");
                        break;
                    case "rooms":
                        SendReply(player, "Rooms Refreshing ...");
                        (EditHotel[player.UserIDString]).RefreshRooms();

                        SendReply(player, "Rooms Refreshed");
                        break;
                    case "reset":
                        foreach (var pair in (EditHotel[player.UserIDString]).rooms)
                        {
                            var codeLock = FindCodeLockByRoomId(pair.Key);
                            if (codeLock == null) continue;
                            SendReply(player, "Room Last Renter: {0}, Room Renter: {1}", pair.Value.lastRenter,
                                pair.Value.renter);
                            ResetRoom(codeLock, pair.Value);
                        }

                        break;
                    case "radius":
                        if (args.Length == 1)
                        {
                            SendReply(player, "/hotel radius XX");
                            return;
                        }

                        int rad2;

                        int.TryParse(args[1], out rad2);
                        if (rad2 < 1) rad2 = 20;

                        var zoneArgs2 = new[] { "name", editedHotel.hotelName, "radius", rad2.ToString() };
                        ZoneManager.Call("CreateOrUpdateZone", editedHotel.hotelName, zoneArgs2);

                        (EditHotel[player.UserIDString]).r = rad2.ToString();

                        SendReply(player, $"Radius set to {args[1]}");
                        break;

                    default:
                        SendReply(player, $"Wrong argument {args[0]}");
                        break;
                }
            }

            ShowHotelGrid(player);
            RefreshAdminHotelGui(player);
        }

        [ChatCommand("hotel_list")]
        void CmdChatHotelList(BasePlayer player, string command, string[] args)
        {
            if (!HasAccess(player))
            {
                SendReply(player, GetMsg(PluginMessages.MessageErrorNotAllowed, player.userID));
                return;
            }

            SendReply(player, "======= Hotel List ======");
            foreach (HotelData hotel in storedData.Hotels)
            {
                SendReply(player, $"{hotel.hotelName} - {hotel.rooms.Count}");
            }
        }

        [ChatCommand("hotel_disable")]
        void CmdChatHotelDisable(BasePlayer player, string command, string[] args)
        {
            if (!HasAccess(player))
            {
                SendReply(player, GetMsg(PluginMessages.MessageErrorNotAllowed, player.userID));
                return;
            }

            if (args.Length == 0)
            {
                SendReply(player, GetMsg(PluginMessages.MessageHotelDisableHelp, player.userID));
                return;
            }

            var renter = FindPlayer(args[0]);
            if (renter == null)
            {
                SendReply(player, GetMsg(PluginMessages.MessageErrorPlayerNotFound, player.userID));
                return;
            }
            SetPlayerAsRenter(args[0], false);
            SendReply(player, GetMsg(PluginMessages.MessagePlayerNotRenter, player.userID).Replace("{playerName}", renter.Name));

        }

        [ChatCommand("hotel_edit")]
        void CmdChatHotelEdit(BasePlayer player, string command, string[] args)
        {
            if (!HasAccess(player))
            {
                SendReply(player, GetMsg(PluginMessages.MessageErrorNotAllowed, player.userID));
                return;
            }

            if (EditHotel.ContainsKey(player.UserIDString))
            {
                SendReply(player, GetMsg(PluginMessages.MessageAlreadyEditing, player.userID));
                return;
            }

            if (args.Length == 0)
            {
                SendReply(player, GetMsg(PluginMessages.MessageHotelEditHelp, player.userID));
                return;
            }

            var hotelName = args[0];
            foreach (var hotel in storedData.Hotels.Where(hotel =>
                string.Equals(hotel.hotelName, hotelName, StringComparison.CurrentCultureIgnoreCase)))
            {
                hotel.Deactivate();
                if (hotel.x != null && hotel.r != null)
                {
                    foreach (var col in Physics.OverlapSphere(hotel.Pos(), Convert.ToSingle(hotel.r), ConstructionColl))
                    {
                        var door = col.GetComponentInParent<Door>();
                        if (door == null || !door.HasSlot(BaseEntity.Slot.Lock)) continue;

                        door.SetFlag(BaseEntity.Flags.Open, false);
                        door.SendNetworkUpdateImmediate(true);
                    }
                }

                EditHotel.Add(player.UserIDString, hotel);
                break;
            }

            if (!EditHotel.ContainsKey(player.UserIDString))
            {
                SendReply(player,
                    string.Format(GetMsg(PluginMessages.MessageErrorEditDoesNotExist, player.userID), args[0]));
                return;
            }

            SendReply(player,
                string.Format(GetMsg(PluginMessages.MessageHotelEditEditing, player.userID),
                    EditHotel[player.UserIDString].hotelName));

            RefreshAdminHotelGui(player);
        }

        [ChatCommand("hotel_enable")]
        void CmdChatHotelEnable(BasePlayer player, string command, string[] args)
        {
            if (!HasAccess(player))
            {
                SendReply(player, GetMsg(PluginMessages.MessageErrorNotAllowed, player.userID));
                return;
            }

            if (args.Length == 0)
            {
                SendReply(player, GetMsg(PluginMessages.MessageHotelEnableHelp, player.userID));
                return;
            }

            var renter = FindPlayer(args[0]);
            if (renter == null)
            {
                SendReply(player, GetMsg(PluginMessages.MessageErrorPlayerNotFound, player.userID));
                return;
            }
            SetPlayerAsRenter(args[0], true);
            SendReply(player, GetMsg(PluginMessages.MessagePlayerIsRenter, player.userID).Replace("{playerName}", renter.Name));

        }

        private void SetPlayerAsRenter(string playerName, bool isRenter)
        {

            if (isRenter)
            {
                //TODO: Find player and add hotel.renter permission
                Server.Command($"oxide.grant user {playerName} hotel.renter");

            }
            else
            {
                //TODO: Find player and remove hotel.renter permission
                Server.Command($"oxide.revoke user {playerName} hotel.renter");
            }
        }

        [Command("hotelextend")]
        void HotelExtend(IPlayer iplayer, string command, string[] args)
        {
            var player = iplayer.Object as BasePlayer;
            args[0] = args[0].Replace("'", "");
            CmdChatHotelExtend(player, null, args);
        }

        [ChatCommand("hotel_extend")]
        void CmdChatHotelExtend(BasePlayer player, string command, string[] args)
        {
            if (!HasAccess(player, "extend"))
            {
                SendReply(player, GetMsg(PluginMessages.MessageErrorNotAllowed, player.userID));
                return;
            }

            if (args.Length == 0)
            {
                SendReply(player, GetMsg(PluginMessages.MessageHotelExtendHelp, player.userID));
                return;
            }

            var hotelName = args[0];
            var hotelFound = false;

            foreach (var hotel in storedData.Hotels.Where(hotel =>
                string.Equals(hotel.hotelName, hotelName, StringComparison.CurrentCultureIgnoreCase)))
            {
                hotelFound = true;
                //We found the Hotel now lets see if player has a room
                //Check to see if player has a room in the hotel and can extend it
                if (CanRentRoom(player, hotel, true))
                {
                    foreach (var room in hotel.rooms.Values)
                    {
                        if (room.renter != player.UserIDString) continue;

                        var duration = double.Parse(hotel.rd);
                        if (duration > 0)
                        {
                            //Charge the player
                            if (hotel.currency == "0" && Economics)
                            {
                                EconomicsWithdraw(player, hotel.Price());
                            }

                            if (hotel.currency == "1" && ServerRewards)
                            {
                                ServerRewardsWithdraw(player, hotel.Price());
                            }

                            if (hotel.currency != "0" && hotel.currency != "1")
                            {
                                var collect = Pool.GetList<Item>();
                                var itemDefinition = ItemManager.FindItemDefinition(hotel.currency);
                                if (itemDefinition != null)
                                {
                                    player.inventory.Take(collect, itemDefinition.itemid, int.Parse(hotel.e));
                                    player.Command("note.inv", itemDefinition.itemid, -1 * int.Parse(hotel.e));
                                }
                            }

                            //extend the Duration
                            room.ExtendDuration(duration);

                            SendReply(player, "Your Room has been extended. Checkout is now in {0}",
                                ConvertSecondsToBetter(room.CheckOutTime() - LogTime()));
                        }
                        else
                        {
                            SendReply(player, "Your Room does not expire, you can not extend this room");
                        }

                        break;
                    }
                }
                else
                {
                    SendReply(player, "Unable to Extend your Room");
                }

                break;
            }

            if (!hotelFound)
            {
                SendReply(player, $"Unable to Find the {hotelName} Hotel");
            }

            SaveData();
        }

        [ChatCommand("hotel_reset")]
        void CmdChatHotelReset(BasePlayer player, string command, string[] args)
        {
            if (!HasAccess(player))
            {
                SendReply(player, GetMsg(PluginMessages.MessageErrorNotAllowed, player.userID));
                return;
            }

            if (EditHotel.ContainsKey(player.UserIDString))
            {
                SendReply(player, GetMsg(PluginMessages.MessageAlreadyEditing, player.userID));
                return;
            }

            storedData.Hotels = new HashSet<HotelData>();
            SaveData();
            SendReply(player, "Hotels were all deleted");
        }

        [ChatCommand("hotel_remove")]
        void CmdChatHotelRemove(BasePlayer player, string command, string[] args)
        {
            if (!HasAccess(player))
            {
                SendReply(player, GetMsg(PluginMessages.MessageErrorNotAllowed, player.userID));
                return;
            }

            if (EditHotel.ContainsKey(player.UserIDString))
            {
                SendReply(player, GetMsg(PluginMessages.MessageAlreadyEditing, player.userID));
                return;
            }

            if (args.Length == 0)
            {
                SendReply(player, GetMsg(PluginMessages.MessageHotelEditHelp, player.userID));
                return;
            }

            var hotelName = args[0];
            HotelData targetHotel = null;
            foreach (var hotel in storedData.Hotels.Where(hotel =>
                string.Equals(hotel.hotelName, hotelName, StringComparison.CurrentCultureIgnoreCase)))
            {
                hotel.Deactivate();
                targetHotel = hotel;
                break;
            }

            if (targetHotel == null)
            {
                SendReply(player,
                    string.Format(GetMsg(PluginMessages.MessageErrorEditDoesNotExist, player.userID), args[0]));
                return;
            }

            storedData.Hotels.Remove(targetHotel);
            SaveData();
            SendReply(player, $"Hotel Named: {hotelName} was successfully removed");
        }

        [ChatCommand("rooms")]
        void CmdChatRooms(BasePlayer player, string command, string[] args)
        {
            var hotelFound = false;
            foreach (var hotel in storedData.Hotels)
            {
                foreach (var pair in hotel.rooms.Where(pair => pair.Value.renter == player.UserIDString))
                {
                    hotelFound = true;
                    SendReply(player, "{0} : {1}", hotel.hotelName,
                        ConvertSecondsToBetter(pair.Value.CheckOutTime() - LogTime()));
                    break;
                }
            }

            if (!hotelFound)
            {
                SendReply(player, "You do not have any rooms rented");
            }
        }

        [ChatCommand("room")]
        void CmdChatRoom(BasePlayer player, string command, string[] args)
        {
            if (!HasAccess(player))
            {
                SendReply(player, GetMsg(PluginMessages.MessageErrorNotAllowed, player.userID));
                return;
            }

            var roomId = string.Empty;
            var argsNum = 0;

            if (args.Length > 0)
            {
                var roomLocation = (args[0]).Split(':');
                if (roomLocation.Length == 3)
                    roomId = args[0];
            }

            if (roomId == string.Empty)
            {
                var doorPosition = RayForDoor(player);
                if (doorPosition == default(Vector3))
                {
                    SendReply(player, GetMsg(PluginMessages.MessageMustLookAtDoor, player.userID));
                    return;
                }

                roomId = $"{Mathf.Ceil(doorPosition.x)}:{Mathf.Ceil(doorPosition.y)}:{Mathf.Ceil(doorPosition.z)}";
            }
            else
            {
                argsNum++;
            }

            if (roomId == string.Empty)
            {
                SendReply(player, "Invalid roomId.");
                return;
            }

            HotelData targetHotel;
            Room targetRoom;

            if (!FindRoomById(roomId, out targetHotel, out targetRoom))
            {
                SendReply(player, "No room was detected.");
                return;
            }

            if (args.Length - argsNum == 0)
            {
                SendReply(player, $"Room Id is: <color=orange>{targetRoom.roomId}</color> in hotel: <color=orange>{targetHotel.hotelName}</color>");
                SendReply(player, "Options are:");
                SendReply(player, "<color=green>/room \"optional:roomId\" reset </color> => to reset this room");
                //SendReply(player, "/room \"optional:roomId\
                //" give NAME/STEAMID => to give a player this room");
                SendReply(player,
                    "<color=green>/room \"optional:roomId\" duration</color> Seconds => to set a new duration time for a player (from the time you set the duration)");
                return;
            }

            if (!targetHotel.enabled)
            {
                SendReply(player, GetMsg(PluginMessages.MessageMaintenance, player.UserIDString));
                return;
            }

            switch (args[argsNum])
            {
                case "reset":
                    ResetRoom(targetRoom);
                    SendReply(player, $"The room {targetRoom.roomId} was reset.");
                    break;

                case "duration":
                    if (targetRoom.renter == null)
                    {
                        SendReply(player,
                            $"The room {targetRoom.roomId} has currently no renter, you can't set a duration for it");
                        return;
                    }

                    if (args.Length == argsNum + 1)
                    {
                        var timeLeft = targetRoom.CheckOutTime() - LogTime();
                        SendReply(player,
                            $"The room {targetRoom.roomId} renter will expire in {(targetRoom.CheckOutTime() == 0.0 ? "Unlimited" : ConvertSecondsToBetter(timeLeft))}");
                        return;
                    }

                    double newTimeLeft;
                    if (!double.TryParse(args[argsNum + 1], out newTimeLeft))
                    {
                        SendReply(player, "/room \"optional:roomId\" duration NewTimeLeft");
                        return;
                    }

                    targetRoom.intCheckoutTime = (newTimeLeft + LogTime());
                    targetRoom.checkoutTime = targetRoom.intCheckoutTime.ToString(CultureInfo.InvariantCulture);
                    SaveData();
                    SendReply(player, $"New time left for room Id {targetRoom.roomId} is {newTimeLeft}s");
                    break;

                case "give":
                    if (targetRoom.renter != null)
                    {
                        SendReply(player,
                            $"The room {targetRoom.roomId} is already rented by {targetRoom.renter}, reset the room first to set a new renter");
                        return;
                    }

                    if (args.Length == argsNum + 1)
                    {
                        SendReply(player, "/room \"optional:roomId\" give Player/SteamId");
                        return;
                    }

                    SendReply(player, "Future Feature to Give player the Room");
                    break;

                default:
                    SendReply(player, "This is not a valid option, say /room \"optional:roomId\" to see the options");
                    break;
            }
        }

        [ChatCommand("hotel_new")]
        void CmdChatHotelNew(BasePlayer player, string command, string[] args)
        {
            if (!HasAccess(player))
            {
                SendReply(player, GetMsg(PluginMessages.MessageErrorNotAllowed, player.userID));
                return;
            }

            if (EditHotel.ContainsKey(player.UserIDString))
            {
                SendReply(player, GetMsg(PluginMessages.MessageAlreadyEditing, player.userID));
                return;
            }

            if (args.Length == 0)
            {
                SendReply(player, GetMsg(PluginMessages.MessageHotelNewHelp, player.userID));
                return;
            }

            var hotelName = args[0];

            if (storedData.Hotels.Any(x =>
                string.Equals(x.hotelName, hotelName, StringComparison.CurrentCultureIgnoreCase)))
            {
                SendReply(player,
                    string.Format(GetMsg(PluginMessages.MessageErrorAlreadyExist, player.userID), hotelName));
                return;
            }

            var newHotel = new HotelData(hotelName);
            newHotel.Deactivate();

            EditHotel.Add(player.UserIDString, newHotel);

            SendReply(player, string.Format(GetMsg(PluginMessages.MessageHotelNewCreated, player.userID), hotelName));
            RefreshAdminHotelGui(player);
        }

        #endregion

        #region Extra Classes

        public class RoomTimeMessage
        {
            #region Properties and Indexers

            public HotelData HotelData { get; set; }
            public string TimeMessage { get; set; }
            public double TimeRemaining { get; set; }

            #endregion
        }

        public class HotelData
        {
            Vector3 _pos;
            public string currency;
            public string e;
            public bool enabled;
            public string hotelName;
            public bool kickHobos;
            public string markerColor;
            public string npc;
            public string p;
            public int price;
            public string r;
            public string rd;

            public Dictionary<string, Room> rooms;
            public string rr;
            public bool showMarker;
            public string x;
            public string y;
            public string z;

            #region Constructors

            public HotelData()
            {
                enabled = false;
                rooms = new Dictionary<string, Room>();
            }

            public HotelData(string hotelName)
            {
                this.hotelName = hotelName;
                x = "0";
                y = "0";
                z = "0";
                r = "60";
                rr = "10";
                rd = "86400";
                p = null;
                e = null;
                currency = "scrap";
                rooms = new Dictionary<string, Room>();
                enabled = false;
                kickHobos = true;
                markerColor = "1 1 1 1";
            }

            #endregion

            #region Methods (Public)

            public void Activate()
            {
                enabled = true;
            }

            public void AddRoom(Room newRoom)
            {
                if (rooms.ContainsKey(newRoom.roomId))
                    rooms.Remove(newRoom.roomId);

                rooms.Add(newRoom.roomId, newRoom);
            }

            public void Deactivate()
            {
                enabled = false;
            }

            public Vector3 Pos()
            {
                if (x == "0" && y == "0" && z == "0")
                    return default(Vector3);
                if (_pos == default(Vector3))
                    _pos = new Vector3(float.Parse(x), float.Parse(y), float.Parse(z));
                return _pos;
            }

            public int Price()
            {
                return e == null ? 0 : Convert.ToInt32(e);
            }

            public void RefreshRooms()
            {
                if (Pos() == default(Vector3))
                    return;
                var detectedRooms = FindAllRooms(Pos(), Convert.ToSingle(r), Convert.ToSingle(rr));

                var toAdd = new List<string>();
                var toDelete = new List<string>();
                if (rooms == null) rooms = new Dictionary<string, Room>();
                if (rooms.Count > 0)
                {
                    foreach (var pair in rooms)
                    {
                        if (pair.Value.renter != null)
                        {
                            detectedRooms.Remove(pair.Key);
                            Debug.Log($"[Hotel] {pair.Key} is occupied and can't be edited");
                            continue;
                        }

                        if (!detectedRooms.ContainsKey(pair.Key))
                        {
                            toDelete.Add(pair.Key);
                        }
                    }
                }

                foreach (var pair in detectedRooms)
                {
                    if (!rooms.ContainsKey(pair.Key))
                    {
                        toAdd.Add(pair.Key);
                    }
                    else
                    {
                        rooms[pair.Key] = pair.Value;
                    }
                }

                foreach (var roomId in toDelete)
                {
                    rooms.Remove(roomId);
                    Debug.Log($"[Hotel] {roomId} doesn't exist anymore, removing this room");
                }

                foreach (var roomId in toAdd)
                {
                    Debug.Log($"[Hotel] {roomId} is a new room, adding it");
                    rooms.Add(roomId, detectedRooms[roomId]);
                }
            }

            #endregion
        }

        public class Room
        {
            public string checkingTime;
            public string checkoutTime;

            public List<DeployableItem> defaultDeployables;

            public double intCheckoutTime;

            public string lastRenter;
            public Vector3 pos;
            public string renter;
            public string roomId;
            public string x;
            public string y;
            public string z;

            #region Constructors

            public Room(Vector3 position)
            {
                x = Math.Ceiling(position.x).ToString(CultureInfo.InvariantCulture);
                y = Math.Ceiling(position.y).ToString(CultureInfo.InvariantCulture);
                z = Math.Ceiling(position.z).ToString(CultureInfo.InvariantCulture);
                roomId = $"{x}:{y}:{z}";
            }

            #endregion

            #region Methods (Public)

            public double CheckOutTime()
            {
                if (intCheckoutTime == default(double))
                    intCheckoutTime = Convert.ToDouble(checkoutTime);
                return intCheckoutTime;
            }

            public void ExtendDuration(double duration)
            {
                intCheckoutTime = intCheckoutTime + duration;
                checkoutTime = intCheckoutTime.ToString(CultureInfo.InvariantCulture);
            }

            public Vector3 Pos()
            {
                if (pos == default(Vector3))
                    pos = new Vector3(float.Parse(x), float.Parse(y), float.Parse(z));
                return pos;
            }

            public void Reset()
            {
                intCheckoutTime = default(double);
            }

            #endregion
        }

        public class DeployableItem
        {
            Vector3 _pos;
            Quaternion _rot;
            public string prefabName;
            public string rw;
            public string rx;
            public string ry;
            public string rz;
            public ulong skinId;
            public string x;
            public string y;
            public string z;

            #region Constructors

            public DeployableItem()
            {

            }

            public DeployableItem(BaseEntity deployable)
            {
                prefabName = StringPool.Get(deployable.prefabID);

                x = deployable.transform.position.x.ToString(CultureInfo.InvariantCulture);
                y = deployable.transform.position.y.ToString(CultureInfo.InvariantCulture);
                z = deployable.transform.position.z.ToString(CultureInfo.InvariantCulture);

                rx = deployable.transform.rotation.x.ToString(CultureInfo.InvariantCulture);
                ry = deployable.transform.rotation.y.ToString(CultureInfo.InvariantCulture);
                rz = deployable.transform.rotation.z.ToString(CultureInfo.InvariantCulture);
                rw = deployable.transform.rotation.w.ToString(CultureInfo.InvariantCulture);

                skinId = deployable.skinID;
            }

            #endregion

            #region Methods (Public)

            public Vector3 Pos()
            {
                if (_pos == default(Vector3))
                    _pos = new Vector3(float.Parse(x), float.Parse(y), float.Parse(z));
                return _pos;
            }

            public Quaternion Rot()
            {
                if (_rot.w == 0f)
                    _rot = new Quaternion(float.Parse(rx), float.Parse(ry), float.Parse(rz), float.Parse(rw));
                return _rot;
            }

            #endregion
        }

        public class StoredData
        {
            #region Constructors

            public StoredData()
            {
                Hotels = new HashSet<HotelData>();
            }

            #endregion

            #region Properties and Indexers

            public HashSet<HotelData> Hotels { get; set; }

            #endregion
        }

        public class HotelPanelImage
        {
            #region Properties and Indexers

            public string AnchorX { get; set; }
            public string AnchorY { get; set; }
            public bool Available { get; set; }
            public string BackgroundColor { get; set; }
            public string Dock { get; set; }
            public double Height { get; set; }
            public string Margin { get; set; }
            public int Order { get; set; }
            public string Url { get; set; }
            public double Width { get; set; }

            #endregion
        }

        public class HotelPanelText
        {
            #region Properties and Indexers

            public string Align { get; set; }
            public string AnchorX { get; set; }
            public string AnchorY { get; set; }
            public bool Available { get; set; }
            public string BackgroundColor { get; set; }
            public string Content { get; set; }
            public string Dock { get; set; }
            public string FontColor { get; set; }
            public int FontSize { get; set; }
            public double Height { get; set; }
            public string Margin { get; set; }
            public int Order { get; set; }
            public double Width { get; set; }

            #endregion
        }

        public class HotelMarker
        {
            #region Properties and Indexers

            public MapMarkerGenericRadius GenericMapMarker { get; set; }
            public VendingMachineMapMarker VendingMachineMapMarker { get; set; }

            #endregion
        }

        #endregion

    }
}

// --- End of file: Hotel.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/heli-scrap ---
// --- Original File Path: H/HeliScrap/HeliScrap.cs ---

using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;
using System;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("Heli Scrap", "Camoec", "1.5.1")]
    [Description("Call heli with scrap")]

    public class HeliScrap : RustPlugin
    {
        private PluginConfig _config;
        [PluginReference]
        private readonly Plugin Economics;

        private class PluginConfig
        {
            [JsonProperty(PropertyName = "ChatPrefix")]
            public string ChatPrefix = "<color=#eb4213>HeliScrap</color>:";

            [JsonProperty(PropertyName = "Command")]
            public string Command = "CallHeli";

            [JsonProperty(PropertyName = "Scrap Amount (If Economics is enabled, use RP)")]
            public int ScrapAmount = 100;

            [JsonProperty(PropertyName = "UseEconomics")]
            public bool UseEconomics = false;

            [JsonProperty(PropertyName = "UsePermission")]
            public bool UsePermission = true;

            [JsonProperty(PropertyName = "MaxSpawnedHelis")]
            public int MaxSpawnedHelis = 1;

            [JsonProperty(PropertyName = "Player Cooldown (in seconds)")]
            public int Cooldown = 60;

            [JsonProperty(PropertyName = "Global Cooldown (in seconds)")]
            public int GCooldown = 30;
        }

        private const string UsePerm = "heliscrap.use";
        private const string HELI_PREFAB = "assets/prefabs/npc/patrol helicopter/patrolhelicopter.prefab";
        private HashSet<PatrolHelicopter> activeHelis = new HashSet<PatrolHelicopter>();
        private Dictionary<BasePlayer, DateTime> playerCooldown = new Dictionary<BasePlayer, DateTime>();
        private DateTime lastCall = new DateTime();


        private bool RemoveCost(BasePlayer player)
        {
            if(_config.UseEconomics)
            {
                var ret = (bool)Economics.Call("Withdraw", player.userID, (double)_config.ScrapAmount);
                
                return ret;
            }
            else if(CanRemoveItem(player, -932201673, _config.ScrapAmount))
            {
                RemoveItemsFromInventory(player, -932201673, _config.ScrapAmount);
                return true;
            }
            return false;
        }

        #region Config Setup

        protected override void SaveConfig() => Config.WriteObject(_config, true);
        protected override void LoadDefaultConfig()
        {
            //base.LoadDefaultConfig();
            _config = new PluginConfig();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<PluginConfig>();

                if (_config == null)
                    throw new Exception();

                SaveConfig(); // override posible obsolet / outdated config
            }
            catch (Exception)
            {
                PrintError("Loaded default config.");

                LoadDefaultConfig();
            }

            
        }

        void Loaded()
        {
            if (_config.UseEconomics == true && Economics == null)
            {
                Puts("Economics not found, disabling feature");
                _config.UseEconomics = false;
                return;
            }
            if(Economics != null)
            {
                Puts("Economics Found!");
            }
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Success"] = "Heli called successfuly",
                ["MaxSpawnedHelis"] = "Max heli in bound reached",
                ["NoRequiredScrap"] = "You don't have {0} of scrap in your inventory",
                ["NoPermission"] = "You don't have required permission to use this command",
                ["Cooldown"] = "You need to wait {0} seconds to use this command",
                ["NoRequiredRP"] = "You don't have {0} of RP"
            }, this);
        }

        private string Lang(string key, string userid) => lang.GetMessage(key, this, userid);

        #endregion

        private void Init()
        {
            cmd.AddChatCommand(_config.Command, this, "CallCommand");
            permission.RegisterPermission(UsePerm, this);
        }

        private void CallCommand(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, UsePerm) && _config.UsePermission)
            {
                PrintToChat(player, $"{_config.ChatPrefix} {Lang("NoPermission", player.UserIDString)}");
                return;
            }


            if (DateTime.Now - lastCall < TimeSpan.FromSeconds(_config.GCooldown))
            {
                PrintToChat(player, string.Format(Lang("Cooldown", player.UserIDString), _config.GCooldown - (int)(DateTime.Now - lastCall).TotalSeconds));
                return;
            }



            if (playerCooldown.ContainsKey(player) && DateTime.Now - playerCooldown[player] < TimeSpan.FromSeconds(_config.Cooldown))
            {
                PrintToChat(player, string.Format(Lang("Cooldown", player.UserIDString), _config.Cooldown - (int)(DateTime.Now - playerCooldown[player]).TotalSeconds));
                return;
            }


            CheckHelis();
            if(activeHelis.Count < _config.MaxSpawnedHelis)
            {
                if(RemoveCost(player))
                {
                    callHeli(player.transform.position, false);


                    if (playerCooldown.ContainsKey(player))
                    {
                        playerCooldown[player] = DateTime.Now;
                    }
                    else
                    {
                        playerCooldown.Add(player, DateTime.Now);
                    }
                    lastCall = DateTime.Now;


                    PrintToChat(player, $"{_config.ChatPrefix} {Lang("Success", player.UserIDString)}");
                }
                else
                {
                    if (_config.UseEconomics)
                    {
                        PrintToChat(player, $"{_config.ChatPrefix} {string.Format(Lang("NoRequiredRP", player.UserIDString), _config.ScrapAmount)}");
                    }
                    else
                    {
                        PrintToChat(player, $"{_config.ChatPrefix} {string.Format(Lang("NoRequiredScrap", player.UserIDString), _config.ScrapAmount)}");
                    }
                }
            }
            else
            {
                PrintToChat(player, $"{_config.ChatPrefix} {Lang("MaxSpawnedHelis", player.UserIDString)}");
            }
        }

        
        

        private void OnServerInitialized()
        {
            
            foreach(var entity in BaseNetworkable.serverEntities)
            {
                if (entity == null || (entity as PatrolHelicopter) == null)
                    continue;

                activeHelis.Add(entity as PatrolHelicopter);
            }
        }

        void OnEntitySpawned(PatrolHelicopter entity)
        {
            if (entity != null)
                activeHelis.Add(entity);
        }

        

        #region Misc

        private void CheckHelis()
        {
            activeHelis.RemoveWhere(heli => heli?.IsDestroyed ?? true);
        }

        private bool CanRemoveItem(BasePlayer player, int itemid, int amount)
        {
            var foundAmount = 0;
            foreach (var item in player.inventory.containerMain.itemList)
            {
                if (item != null && item.info.itemid == itemid)
                {
                    foundAmount = foundAmount + item.amount;
                }
            }

            if (foundAmount >= amount)
                return true;
            return false;
        }

        public void RemoveItemsFromInventory(BasePlayer player, int itemid, int amount)
        {
            var items = player.inventory.containerMain.itemList;

            int removeAmount = 0;
            int amountRemaining = amount;

            for(int i = 0; i < items.Count; i++ )
            {
                var item = items[i];
                if (item == null || item.info.itemid != itemid)
                    continue;

                removeAmount = amountRemaining;
                if (item.amount < removeAmount)
                    removeAmount = item.amount;

                if (item.amount > removeAmount)
                    item.SplitItem(removeAmount);
                else
                    item.UseItem(removeAmount);
                amountRemaining = amountRemaining - removeAmount;

                if (amountRemaining <= 0)
                    break;
            }
        }
        private PatrolHelicopter callHeli(Vector3 coordinates = new Vector3(), bool setPositionAfterSpawn = true)
        {
            var heli = (PatrolHelicopter)GameManager.server.CreateEntity(HELI_PREFAB, new Vector3(), new Quaternion(), true);
            if (heli == null)
            {
                PrintWarning("Failed to create heli prefab on " + nameof(callHeli));
                return null;
            }

            var heliAI = heli?.GetComponent<PatrolHelicopterAI>() ?? null;
            if (heliAI == null)
            {
                PrintWarning("Failed to get helicopter AI on " + nameof(callHeli));
                return null;
            }
            if (coordinates != Vector3.zero)
            {
                if (coordinates.y < 225)
                    coordinates.y = 225;
                heliAI.SetInitialDestination(coordinates, 0.25f);
                if (setPositionAfterSpawn)
                    heli.transform.position = heliAI.transform.position = coordinates;
            }
            heli.Spawn();
            
            return heli;
        }

        #endregion

    }
}

// --- End of file: HeliScrap.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/heli-ride ---
// --- Original File Path: H/HeliRide/HeliRide.cs ---

using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Heli Ride", "ColonBlow", "1.1.17")]
    [Description("Allows players to fly the Patrol Helicopter")]
    public class HeliRide : RustPlugin
    {

        //Rust update fixes

        #region Loadup

        [PluginReference]
        private Plugin Chute, Vanish;

        public bool CockpitOverlay => Config.Get<bool>("Show Custom Cockpit Overlay");
        public bool CrossHair => Config.Get<bool>("Show Custom Crosshair");

        private static Dictionary<ulong, HeliData> HeliFlying = new Dictionary<ulong, HeliData>();
        private static Dictionary<ulong, HeliDamage> DamagedHeli = new Dictionary<ulong, HeliDamage>();
        private static Dictionary<ulong, HasParachute> AddParachute = new Dictionary<ulong, HasParachute>();

        public class HeliData { public BasePlayer player; }

        public class HeliDamage { public BasePlayer player; }

        public class HasParachute { public BasePlayer player; }

        private void Loaded()
        {
            if (Chute == null)
            {
                PrintWarning("Chute plugin not found. To enable player parachutes when there helicopter dies, install Chute plugin!");
            }
            if (Vanish == null)
            {
                PrintWarning("Vanish plugin not found. Player will be visable and UseAutoVanish will be turned off");
                UseAutoVanish = false;
            }
            LoadVariables();
            permission.RegisterPermission("heliride.allowed", this);
        }

        #endregion

        #region Configuration

        private bool Changed;
        private static bool ShowCockpitOverlay = true;
        private static bool ShowCrosshair = true;
        private static bool UseParachutes = true;
        private static bool SpawnCrates = false;
        private static bool UseAutoVanish = false;
        private static double RocketDelay = 0.2;
        private static float RocketMax = 36f;
        private static float NapalmMax = 36f;
        private static double RocketNapalmReloadTime = 20;
        private static float BulletDamage = 50f;
        private static string RocketPrefab = "assets/prefabs/npc/patrol helicopter/rocket_heli.prefab";
        private static string NapalmPrefab = "assets/prefabs/npc/patrol helicopter/rocket_heli_napalm.prefab";

        private void LoadConfigVariables()
        {
            CheckCfg("ShowCockpitOverlay", ref ShowCockpitOverlay);
            CheckCfg("ShowCrosshair", ref ShowCrosshair);
            CheckCfg("UseParachutes", ref UseParachutes);
            CheckCfg("SpawnCrates", ref SpawnCrates);
            CheckCfg("UseAutoVanish", ref UseAutoVanish);
            CheckCfg("RocketDelay", ref RocketDelay);
            CheckCfg("RocketNapalmReloadTime", ref RocketNapalmReloadTime);
            CheckCfgFloat("BulletDamage", ref BulletDamage);
            CheckCfgFloat("Max Rockets Loaded", ref RocketMax);
            CheckCfgFloat("Max Napalm Loaded", ref NapalmMax);

            CheckCfg("Heli Rocket prefab : ", ref RocketPrefab);
            CheckCfg("Heli Napam prefab : ", ref NapalmPrefab);
        }

        protected override void LoadDefaultConfig()
        {
            Puts("Creating a new config file");
            Config.Clear();
            LoadVariables();
        }

        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }

        private void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T)
                var = (T)Config[Key];
            else
                Config[Key] = var;
        }

        private void CheckCfgFloat(string Key, ref float var)
        {
            if (Config[Key] != null)
                var = Convert.ToSingle(Config[Key]);
            else
                Config[Key] = var;
        }

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }

            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }

        #endregion

        #region Localization

        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"noheli", "You are not flying a helicopter."},
                {"notallowed", "You are not allowed to access that command."},
                {"notflying", "You must be noclipping to activate Helicopter."}
            }, this);
        }

        #endregion

        #region Commands

        [ChatCommand("flyheli")]
        private void chatFlyHeli(BasePlayer player, string command, string[] args)
        {
            string SteamID = player.userID.ToString();
            if (isAllowed(player, "heliride.allowed"))
            {
                var playerheli = player.GetComponent<FlyHelicopter>();

                if (HeliFlying.ContainsKey(player.userID))
                {
                    GameObject.Destroy(playerheli);
                    if (Vanish != null && UseAutoVanish) { Vanish.Call("Reappear", player); }
                    HeliFlying.Remove(player.userID);
                    return;
                }
                if (playerheli != null)
                {
                    GameObject.Destroy(playerheli);
                    if (Vanish != null && UseAutoVanish) { Vanish.Call("Reappear", player); }
                    HeliFlying.Remove(player.userID);
                    return;
                }

                if (playerheli == null)
                {
                    if (!player.IsFlying) { SendReply(player, lang.GetMessage("notflying", this, SteamID)); return; }
                    if (Vanish != null && UseAutoVanish) { Vanish.Call("Disappear", player); }
                    timer.Once(1f, () => AddHeli(player));
                    return;
                }
            }

            if (!isAllowed(player, "heliride.allowed"))
            {
                SendReply(player, lang.GetMessage("notallowed", this, SteamID));
            }
        }

        [ConsoleCommand("flyheli")]
        private void cmdConsoleFlyHeli(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            string SteamID = player.userID.ToString();
            if (isAllowed(player, "heliride.allowed"))
            {
                var playerheli = player.GetComponent<FlyHelicopter>();

                if (HeliFlying.ContainsKey(player.userID))
                {
                    GameObject.Destroy(playerheli);
                    HeliFlying.Remove(player.userID);
                    if (Vanish != null && UseAutoVanish) { Vanish.Call("Reappear", player); }
                    return;
                }
                if (playerheli != null)
                {
                    GameObject.Destroy(playerheli);
                    if (Vanish != null && UseAutoVanish) { Vanish.Call("Reappear", player); }
                    HeliFlying.Remove(player.userID);
                    return;
                }

                if (playerheli == null)
                {
                    if (!player.IsFlying) { SendReply(player, lang.GetMessage("notflying", this, SteamID)); return; }
                    if (Vanish != null && UseAutoVanish) { Vanish.Call("Disappear", player); }
                    timer.Once(1f, () => AddHeli(player));
                    return;
                }
            }

            if (!isAllowed(player, "heliride.allowed"))
            {
                SendReply(player, lang.GetMessage("notallowed", this, SteamID));
            }
        }

        [ConsoleCommand("showcockpit")]
        private void cmdConsoleShowCockpit(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            var playerheli = player.GetComponent<FlyHelicopter>();

            if (!playerheli)
            {
                string SteamID = player.userID.ToString();
                SendReply(player, lang.GetMessage("noheli", this, SteamID));
                return;
            }

            if (playerheli)
            {
                playerheli.CockpitOverlay(player);
                playerheli.CrosshairOverlay(player);
            }
        }

        [ConsoleCommand("hidecockpit")]
        private void cmdConsoleHideCockpit(ConsoleSystem.Arg arg)
        {
            BasePlayer player = arg.Player();
            var playerheli = player.GetComponent<FlyHelicopter>();

            if (!playerheli)
            {
                string SteamID = player.userID.ToString();
                SendReply(player, lang.GetMessage("noheli", this, SteamID));
                return;
            }

            if (playerheli)
            {
                CuiHelper.DestroyUi(player, "CockpitGuiOverlay");
                CuiHelper.DestroyUi(player, "CrosshairGuiOverlay");
                CuiHelper.DestroyUi(player, "DamageGuiOverlay");
            }
        }

        #endregion

        #region Hooks

        private void OnEntityTakeDamage(BasePlayer player, HitInfo hitInfo)
        {
            if (player == null || hitInfo == null) return;
            if (HeliFlying.ContainsKey(player.userID))
            {
                hitInfo.damageTypes.ScaleAll(0);
            }
        }

        private void OnPlayerTick(BasePlayer player)
        {
            if (!UseParachutes) return;
            if (UseParachutes)
            {
                if (!AddParachute.ContainsKey(player.userID)) return;
                if (AddParachute.ContainsKey(player.userID))
                {
                    if (Chute != null)
                    {
                        AddParachute.Remove(player.userID);
                        timer.Once(0.5f, () => Chute.Call("ExternalAddPlayerChute", player));
                        if (Vanish != null && UseAutoVanish)
                        {
                            timer.Once(0.5f, () => Vanish.Call("Reappear", player));
                        }
                    }
                    if (Chute == null)
                    {
                        AddParachute.Remove(player.userID);
                    }
                }
            }
        }

        private void AddHeli(BasePlayer player)
        {
            if (player.IsFlying)
            {
                player.gameObject.AddComponent<FlyHelicopter>();
                HeliFlying.Add(player.userID, new HeliData
                {
                    player = player
                });
                return;
            }

            if (!player.IsFlying)
            {
                string SteamID = player.userID.ToString();
                SendReply(player, lang.GetMessage("notflying", this, SteamID));
            }
        }

        private void Unload()
        {
            DestroyAll<FlyHelicopter>();
            foreach (var player in BasePlayer.activePlayerList)
            {
                RemoveHeliComponents(player);
            }
        }

        private static void DestroyAll<T>()
        {
            var objects = GameObject.FindObjectsOfType(typeof(T));
            if (objects != null)
            {
                foreach (var gameObj in objects)
                {
                    GameObject.Destroy(gameObj);
                }
            }
        }

        private void RemoveHeliComponents(BasePlayer player)
        {
            var playerheli = player.GetComponent<FlyHelicopter>();
            if (playerheli != null)
            {
                playerheli.DestroyCui(player);
                GameObject.Destroy(playerheli);
            }
        }

        private void OnPlayerDisconnected(BasePlayer player)
        {
            RemoveHeliComponents(player);
        }

        private void OnPlayerRespawned(BasePlayer player)
        {
            RemoveHeliComponents(player);
        }

        private bool isAllowed(BasePlayer player, string perm) => permission.UserHasPermission(player.UserIDString, perm);

        #endregion

        #region HeliRide Entity

        private class FlyHelicopter : MonoBehaviour
        {
            public BasePlayer player;
            public BaseEntity helicopterBase;
            private BaseEntity rockets;

            public PatrolHelicopterAI heliAI;
            public PatrolHelicopter heli;
            public HelicopterTurret heliturret;
            public InputState input;

            private RaycastHit hitInfo;

            public Vector3 PlayerPOS;
            public Vector3 target;
            public Vector3 CurrentPOS;
            private Vector3 direction;

            private float bulletDamage;
            private float rocketMax;
            private bool hasRockets;
            private float napalmMax;
            private bool hasNapalm;
            private double rocketcycletimer;
            private double reloadtimer;
            private double rocketDelay;
            private bool rocketcycle;
            private bool leftTubeFiredLast;
            private bool isReloading;
            private double rocketNapalmReploadTime;

            private void Awake()
            {
                player = GetComponent<BasePlayer>();
                if (player == null) { OnDestroy(); return; }
                input = player.serverInput;
                rocketcycletimer = 0.0;
                reloadtimer = 0.0;
                isReloading = false;
                rocketNapalmReploadTime = RocketNapalmReloadTime;
                rocketMax = RocketMax;
                hasRockets = true;
                napalmMax = NapalmMax;
                hasNapalm = true;
                rocketDelay = RocketDelay;
                bulletDamage = BulletDamage;
                rocketcycle = false;
                PlayerPOS = player.transform.position + player.eyes.BodyForward() * 3f;

                string prefab = "assets/prefabs/npc/patrol helicopter/patrolhelicopter.prefab";
                helicopterBase = GameManager.server.CreateEntity(prefab);
                heliAI = helicopterBase.GetComponent<PatrolHelicopterAI>();
                heliAI.enabled = false;

                heliturret = helicopterBase.GetComponent<HelicopterTurret>();

                heli = helicopterBase.GetComponent<PatrolHelicopter>();
                heli.OwnerID = player.userID;
                heli.InitalizeWeakspots();

                if (!SpawnCrates) heli.maxCratesToSpawn = 0;
                heli.bulletDamage = bulletDamage;

                heli.spotlightTarget = FindTarget(target);
                helicopterBase.Spawn();

                if (ShowCockpitOverlay) CockpitOverlay(player);
                if (ShowCrosshair) CrosshairOverlay(player);

                helicopterBase.transform.localPosition = PlayerPOS;
                helicopterBase.transform.rotation = player.eyes.rotation;
            }

            //////////////////////////////////////////////////////////////////////////////////////

            public void CockpitOverlay(BasePlayer player)
            {
                var cockpitcui = new CuiElementContainer();

                cockpitcui.Add(new CuiElement
                {
                    Name = "CockpitGuiOverlay",
                    Components =
                        {
                            new CuiRawImageComponent { Color = "1 1 1 1", Url = "http://i.imgur.com/6O0hMC5.png", Sprite = "assets/content/textures/generic/fulltransparent.tga" },
                            new CuiRectTransformComponent { AnchorMin = "0 0",  AnchorMax = "1 1"}
                        }
                });
                CuiHelper.AddUi(player, cockpitcui);
            }

            public void CrosshairOverlay(BasePlayer player)
            {
                var crosshaircui = new CuiElementContainer();

                crosshaircui.Add(new CuiElement
                {
                    Name = "CrosshairGuiOverlay",
                    Components =
                        {
                            new CuiRawImageComponent { Color = "1 1 1 1", Url = "http://i.imgur.com/yweKHFT.png", Sprite = "assets/content/textures/generic/fulltransparent.tga" },
                            new CuiRectTransformComponent { AnchorMin = "0.450 0.450",  AnchorMax = "0.540 0.550"}
                        }
                });
                CuiHelper.AddUi(player, crosshaircui);
            }

            public void DamageOverlay(BasePlayer player)
            {
                var damageoverlay = new CuiElementContainer();

                damageoverlay.Add(new CuiElement
                {
                    Name = "DamageGuiOverlay",
                    Components =
                        {
                            new CuiRawImageComponent { Color = "1 1 1 1", Url = "http://i.imgur.com/XrpqTdP.png", Sprite = "assets/content/textures/generic/fulltransparent.tga" },
                            new CuiRectTransformComponent { AnchorMin = "0.35 0.25",  AnchorMax = "0.60 0.70"}
                        }
                });
                CuiHelper.AddUi(player, damageoverlay);
            }

            public void HealthIndicator(BasePlayer player, float health)
            {
                CuiHelper.DestroyUi(player, "HealthGui");
                var healthstr = health.ToString();
                var rocketstr = isReloading ? "R" : rocketMax.ToString();
                var napalmstr = isReloading ? "R" : napalmMax.ToString();
                var dispalystr = isReloading ? "Reloading     " + healthstr + "     Reloading" : "N: " + napalmstr + "         " + healthstr + "         R: " + rocketstr;

                var healthindicator = new CuiElementContainer();
                healthindicator.Add(new CuiButton
                {
                    Button = { Command = "", Color = "0.0 0.0 0.0 1.0" },
                    RectTransform = { AnchorMin = "0.40 0.15", AnchorMax = "0.60 0.18" },
                    Text = { Text = dispalystr, FontSize = 18, Color = "1.0 0.0 0.0 0.2", Align = TextAnchor.MiddleCenter }
                }, "Overall", "HealthGui");
                CuiHelper.AddUi(player, healthindicator);
            }

            //////////////////////////////////////////////////////////////////////////////////////

            private void FixedUpdate()
            {
                player = GetComponent<BasePlayer>();
                if (player.IsDead() || !player.IsFlying)
                {
                    heliAI._currentState = PatrolHelicopterAI.aiState.DEATH;
                }
                if (heliAI._currentState == PatrolHelicopterAI.aiState.DEATH)
                {
                    heliAI.enabled = true;
                    DestroyCui(player);
                    GameObject.Destroy(this);
                    return;
                }

                if (rocketMax <= 0) hasRockets = false;
                if (napalmMax <= 0) hasNapalm = false;
                Vector3 PlayerPOS = player.transform.position - player.eyes.BodyForward() * 5 + Vector3.down * 0.45f;
                CurrentPOS = helicopterBase.transform.position;
                Vector3 direction = Quaternion.Euler(input.current.aimAngles) * Vector3.fwd;

                heli.spotlightTarget = FindTarget(target);

                helicopterBase.transform.localPosition = PlayerPOS;
                helicopterBase.transform.rotation = Quaternion.Lerp(helicopterBase.transform.rotation, player.eyes.rotation, 2f * Time.deltaTime);

                helicopterBase.transform.eulerAngles = new Vector3(0, helicopterBase.transform.eulerAngles.y, 0);

                BaseCombatEntity helientity = helicopterBase.GetComponent<BaseCombatEntity>();
                float health = helientity.Health();

                HealthIndicator(player, health);
                if (health <= 3000f && ShowCockpitOverlay)
                {
                    if (!DamagedHeli.ContainsKey(player.userID))
                    {
                        if (ShowCockpitOverlay)
                        {
                            DamageOverlay(player);
                            DamagedHeli.Add(player.userID, new HeliDamage
                            {
                                player = player
                            });
                        }
                    }
                }
                if (isReloading)
                {
                    reloadtimer += Time.deltaTime;
                    if (reloadtimer >= rocketNapalmReploadTime)
                    {
                        isReloading = false;
                        rocketMax = RocketMax;
                        hasRockets = true;
                        napalmMax = NapalmMax;
                        hasNapalm = true;
                        reloadtimer = 0.0;
                    }
                }
                if (rocketcycle)
                {
                    rocketcycletimer += Time.deltaTime;
                    if (rocketcycletimer >= rocketDelay)
                    {
                        rocketcycle = false;
                        rocketcycletimer = 0.0;
                    }
                }
                if (health > 3000f && ShowCockpitOverlay)
                {
                    if (DamagedHeli.ContainsKey(player.userID))
                    {
                        CuiHelper.DestroyUi(player, "DamageGuiOverlay");
                        DamagedHeli.Remove(player.userID);
                    }
                }

                if (input.IsDown(BUTTON.RELOAD))
                {
                    isReloading = true;
                }

                if (input.IsDown(BUTTON.DUCK))
                {
                    Vector3 downPos = player.transform.position + Vector3.down * (UnityEngine.Time.deltaTime * 3f);
                    player.ClientRPCPlayer(null, player, "ForcePositionTo", downPos);
                    player.SendNetworkUpdate();
                }

                if (input.IsDown(BUTTON.FIRE_PRIMARY))
                {
                    target = FindTarget(target);
                    FireGuns(target);
                }
                if (input.IsDown(BUTTON.FIRE_SECONDARY))
                {
                    if (!hasRockets || isReloading) return;
                    if (!rocketcycle) { leftTubeFiredLast = !leftTubeFiredLast; FireRocket(leftTubeFiredLast, direction, PlayerPOS, true); }
                    rocketcycle = true;
                }
                if (input.IsDown(BUTTON.FIRE_THIRD))
                {
                    if (!hasNapalm || isReloading) return;
                    if (!rocketcycle) { leftTubeFiredLast = !leftTubeFiredLast; FireRocket(leftTubeFiredLast, direction, PlayerPOS, false); }
                    rocketcycle = true;
                }
            }

            private void FireGuns(Vector3 target)
            {
                heliAI.FireGun(target, ConVar.PatrolHelicopter.bulletAccuracy, true);
                heliAI.FireGun(target, ConVar.PatrolHelicopter.bulletAccuracy, false);
            }

            private void FireRocket(bool leftTubeFiredLast, Vector3 direction, Vector3 PlayerPOS, bool isrocket)
            {
                RaycastHit hit;
                string projectile;
                if (isrocket) { rocketMax = rocketMax - 1f; }
                if (!isrocket) { napalmMax = napalmMax - 1f; }
                float num = 4f;
                projectile = isrocket ? RocketPrefab : NapalmPrefab;
                Vector3 origin = PlayerPOS + Vector3.down;
                if (num > 0f)
                {
                    direction = (Vector3)(Quaternion.Euler(UnityEngine.Random.Range((float)(-num * 0.5f), (float)(num * 0.5f)), UnityEngine.Random.Range((float)(-num * 0.5f), (float)(num * 0.5f)), UnityEngine.Random.Range((float)(-num * 0.5f), (float)(num * 0.5f))) * direction);
                }
                float maxDistance = 1f;
                if (Physics.Raycast(origin, direction, out hit, maxDistance, -1063040255))
                {
                    maxDistance = hit.distance - 0.1f;
                }
                Transform transform = !leftTubeFiredLast ? heliAI.helicopterBase.rocket_tube_right.transform : heliAI.helicopterBase.rocket_tube_left.transform;
                Effect.server.Run(heliAI.helicopterBase.rocket_fire_effect.resourcePath, heliAI.helicopterBase, StringPool.Get(!leftTubeFiredLast ? "rocket_tube_right" : "rocket_tube_left"), Vector3.zero, Vector3.forward, null, true);
                Vector3 rocketPos = !leftTubeFiredLast ? heliAI.helicopterBase.rocket_tube_right.transform.position : heliAI.helicopterBase.rocket_tube_left.transform.position;
                rockets = GameManager.server.CreateEntity(projectile, rocketPos);
                rockets.creatorEntity = player;
                if (rockets != null)
                {
                    rockets.SendMessage("InitializeVelocity", (Vector3)(direction * 50f));
                    rockets.Spawn();
                }
            }

            private Vector3 FindTarget(Vector3 target)
            {
                if (!UnityEngine.Physics.Raycast(player.eyes.HeadRay(), out hitInfo, Mathf.Infinity, -1063040255))
                {
                }
                Vector3 hitpoint = hitInfo.point;
                return hitpoint;
            }

            public void DestroyCui(BasePlayer player)
            {
                CuiHelper.DestroyUi(player, "CockpitGuiOverlay");
                CuiHelper.DestroyUi(player, "CrosshairGuiOverlay");
                CuiHelper.DestroyUi(player, "DamageGuiOverlay");
                CuiHelper.DestroyUi(player, "HealthGui");
                DamagedHeli.Remove(player.userID);
            }

            private void addplayerchute()
            {
                if (!UseParachutes) return;
                AddParachute.Add(player.userID, new HasParachute
                {
                    player = player
                });
            }

            public void OnDestroy()
            {
                player = GetComponent<BasePlayer>();

                DestroyCui(player);
                DamagedHeli.Remove(player.userID);
                HeliFlying.Remove(player.userID);

                if (helicopterBase == null) return;
                if (heliAI._currentState == PatrolHelicopterAI.aiState.DEATH)
                {
                    heliAI.enabled = true;
                    heli.bulletDamage = 0f;
                    GameObject.Destroy(this);
                    addplayerchute();
                    return;
                }
                helicopterBase.Kill();
                GameObject.Destroy(this);
            }
        }

        #endregion
    }
}


// --- End of file: HeliRide.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/heli-editor ---
// --- Original File Path: H/HeliEditor/HeliEditor.cs ---

using Oxide.Core;
using System;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Heli Editor", "Mabel", "1.0.0")]
    [Description("Modify several characteristics of aircrafts")]
    class HeliEditor : RustPlugin
    {
        #region Variables
        private PluginConfig _config;

        #region Permissions
        public string permissionTakeoff = "helieditor.takeoff";
        #endregion

        #endregion

        #region Config

        private class MinicopterSettings
        {
            public float maxHealth { get; set; } = 750;
            public bool invincible { get; set; } = false;
            public bool blockExplosions { get; set; } = false;
            public bool instantTakeoff { get; set; } = false;
            public bool hydrophobic { get; set; } = false;
        }

        private class ScrapheliSettings
        {
            public float maxHealth { get; set; } = 1000;
            public bool invincible { get; set; } = false;
            public bool blockExplosions { get; set; } = false;
            public bool instantTakeoff { get; set; } = false;
            public bool hydrophobic { get; set; } = false;
        }

        private class AttackHelicopterSettings
        {
            public float maxHealth { get; set; } = 850;
            public bool invincible { get; set; } = false;
            public bool blockExplosions { get; set; } = false;
            public bool instantTakeoff { get; set; } = false;
            public bool hydrophobic { get; set; } = false;
        }

        private class PluginConfig
        {
            public MinicopterSettings minicopter { get; set; }
            public ScrapheliSettings scrapheli { get; set; }
            public AttackHelicopterSettings attackHelicopter { get; set; }
            public VersionNumber version { get; set; }

            public static PluginConfig DefaultConfig()
            {
                return new PluginConfig
                {
                    minicopter = new MinicopterSettings(),
                    scrapheli = new ScrapheliSettings(),
                    attackHelicopter = new AttackHelicopterSettings(),
                    version = new VersionNumber()
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            bool shouldSaveConfig = false;

            try
            {
                _config = Config.ReadObject<PluginConfig>();

                if (_config == null)
                {
                    PrintWarning("No configuration file found, loading default configuration...");
                    LoadDefaultConfig();
                    _config = Config.ReadObject<PluginConfig>();
                    shouldSaveConfig = true;
                }

                if (_config.attackHelicopter == null)
                {
                    _config.attackHelicopter = new AttackHelicopterSettings
                    {
                        maxHealth = 850,
                        invincible = false,
                        blockExplosions = false,
                        instantTakeoff = false,
                        hydrophobic = false
                    };
                    shouldSaveConfig = true;
                }

                if (_config.version == null)
                {
                    _config.version = new VersionNumber(1,0,0);
                    shouldSaveConfig = true;
                }

                if (_config.version < Version)
                    UpdateConfig();
            }
            catch (Exception ex)
            {
                Debug.LogException(ex);
                PrintWarning("Error loading configuration, creating new configuration file...");
                LoadDefaultConfig();
                shouldSaveConfig = true;
            }
            finally
            {
                if (shouldSaveConfig)
                {
                    SaveConfig();
                }
            }
        }

        protected override void LoadDefaultConfig() => _config = PluginConfig.DefaultConfig();
        protected override void SaveConfig() => Config.WriteObject(_config);

        private void UpdateConfig()
        {
            PrintWarning("Config update detected! Updating config values...");

            PluginConfig baseConfig = PluginConfig.DefaultConfig();
            if (_config.version < new VersionNumber(1, 0, 0))
                _config = baseConfig;

            _config.version = Version;
            PrintWarning("Config update completed!");
        }
        #endregion

        #region Hooks
        private void Init()
        {
            permission.RegisterPermission(permissionTakeoff, this);
        }

        object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (entity is Minicopter && _config.minicopter.invincible)
            {
                info.damageTypes.Clear();
                return true;
            }
            if (entity is ScrapTransportHelicopter && _config.scrapheli.invincible)
            {
                info.damageTypes.Clear();
                return true;
            }
            if (entity is AttackHelicopter && _config.attackHelicopter.invincible)
            {
                info.damageTypes.Clear();
                return true;
            }
            return null;
        }

        private void OnServerInitialized()
        {
            foreach (var entity in BaseNetworkable.serverEntities)
            {
                if (entity == null) continue;

                if (entity is Minicopter minicopter)
                {
                    OnEntitySpawned(minicopter);
                }
                else if (entity is ScrapTransportHelicopter scraphelicopter)
                {
                    OnEntitySpawned(scraphelicopter);
                }
                else if (entity is AttackHelicopter attackhelicopter)
                {
                    OnEntitySpawned(attackhelicopter);
                }
            }
        }

        private void OnEntitySpawned(BaseHelicopter entity)
        {
            if (entity is Minicopter)
            {
                var miniEntity = entity as PlayerHelicopter;

                //Remove explosion effect references to not have it spawn
                if (_config.minicopter.blockExplosions)
                {
                    entity.explosionEffect.guid = null;
                    entity.serverGibs.guid = null;
                    entity.fireBall.guid = null;
                }

                //Set health set in config
                entity.SetMaxHealth(_config.minicopter.maxHealth);
                entity.health = _config.minicopter.maxHealth;

                //Unparent the water sample object to prevent it from moving with the minicopter
                if (_config.minicopter.hydrophobic)
                {
                    miniEntity.waterSample.transform.SetParent(null);
                    miniEntity.waterSample.position = new Vector3(1000, 1000, 1000);
                }

                //Remove killtriggers for invincibility
                if (_config.minicopter.invincible)
                {
                    entity.killTriggers = new GameObject[0];
                }
                    
            }
            if (entity is ScrapTransportHelicopter)
            {
                var scrapEntity = entity as PlayerHelicopter;

                //Remove explosion effect references to not have it spawn
                if (_config.scrapheli.blockExplosions)
                {
                    entity.explosionEffect.guid = null;
                    entity.serverGibs.guid = null;
                    entity.fireBall.guid = null;
                }

                //Set health set in config
                entity.SetMaxHealth(_config.scrapheli.maxHealth);
                entity.health = _config.scrapheli.maxHealth;

                //Unparent the water sample object to prevent it from moving with the minicopter
                if (_config.scrapheli.hydrophobic)
                {
                    scrapEntity.waterSample.transform.SetParent(null);
                    scrapEntity.waterSample.position = new Vector3(1000, 1000, 1000);
                }

                //Remove killtriggers for invincibility
                if (_config.scrapheli.invincible)
                {
                    entity.killTriggers = new GameObject[0];
                } 
                return;
            }
            if (entity is AttackHelicopter)
            {
                var attackEntity = entity as PlayerHelicopter;

                //Remove explosion effect references to not have it spawn
                if (_config.attackHelicopter.blockExplosions)
                {
                    entity.explosionEffect.guid = null;
                    entity.serverGibs.guid = null;
                    entity.fireBall.guid = null;
                }

                //Set health set in config
                entity.SetMaxHealth(_config.attackHelicopter.maxHealth);
                entity.health = _config.attackHelicopter.maxHealth;

                //Unparent the water sample object to prevent it from moving with the minicopter
                if (_config.attackHelicopter.hydrophobic)
                {
                    attackEntity.waterSample.transform.SetParent(null);
                    attackEntity.waterSample.position = new Vector3(1000, 1000, 1000);
                }

                //Remove killtriggers for invincibility
                if (_config.attackHelicopter.invincible)
                {
                    entity.killTriggers = new GameObject[0];
                }
                return;
            }
        }

        void OnEngineStarted(BaseVehicle vehicle, BasePlayer driver)
        {
            if (!permission.UserHasPermission(driver.UserIDString, permissionTakeoff)) return;

            if (vehicle is ScrapTransportHelicopter && _config.scrapheli.instantTakeoff)
            {
                (vehicle as PlayerHelicopter).engineController.FinishStartingEngine();
            }

            if (vehicle is Minicopter && _config.minicopter.instantTakeoff)
            {
                (vehicle as PlayerHelicopter).engineController.FinishStartingEngine();
            }

            if (vehicle is AttackHelicopter && _config.attackHelicopter.instantTakeoff)
            {
                (vehicle as PlayerHelicopter).engineController.FinishStartingEngine();
            }          
        }
        #endregion
    }
}

// --- End of file: HeliEditor.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/health-vehicles ---
// --- Original File Path: H/HealthVehicles/HealthVehicles.cs ---

﻿using Newtonsoft.Json;
namespace Oxide.Plugins
{
    [Info("Health Vehicles", "SwenenzY", "1.0.1")]
    [Description("Raises vehicles health.")]
    public class HealthVehicles : RustPlugin
    {
        #region Config

        private ConfigFile _config;
        public class ConfigFile
        {
            // Mini
            [JsonProperty(PropertyName = "Mini start health ( ex : 500 )")]
            public float MiniStartHealth;
            [JsonProperty(PropertyName = "Mini max health ( ex : 1000 )")]
            public float MiniMaxHealth;
            // Scrap
            [JsonProperty(PropertyName = "Scrap start health ( ex : 500 )")]
            public float ScrapStartHealth;
            [JsonProperty(PropertyName = "Scrap max health ( ex : 2000 )")]
            public float ScrapMaxHealth;
            // Balloon
            [JsonProperty(PropertyName = "Balloon start health ( ex : 500 )")]
            public float BalloonStartHealth;
            [JsonProperty(PropertyName = "Balloon max health ( ex : 2000 )")]
            public float BalloonMaxHealth;

            public static ConfigFile DefaultConfig()
            {
                return new ConfigFile
                {
                    // Mini
                    MiniStartHealth = 500f,
                    MiniMaxHealth = 1000f,
                    // Scrap
                    ScrapStartHealth = 500f,
                    ScrapMaxHealth = 2000f,
                    // Balloon
                    BalloonStartHealth = 500f,
                    BalloonMaxHealth = 2000f

                };
            }
        }
        protected override void LoadDefaultConfig() => _config = ConfigFile.DefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<ConfigFile>();
        }
        protected override void SaveConfig() => Config.WriteObject(_config);

        #endregion

        #region Vehicles

        #region Mini Copter

        void OnEntitySpawned(MiniCopter mini)
        {
            if (mini == null)
            {
                return;
            }

            mini.SetMaxHealth(_config.MiniMaxHealth);
            mini._health = _config.MiniStartHealth;
        }

        #endregion

        #region Scrap Copter

        void OnEntitySpawned(ScrapTransportHelicopter scrap)
        {
            if (scrap == null)
            {
                return;
            }

            scrap.SetMaxHealth(_config.ScrapMaxHealth); 
            scrap._health = _config.ScrapStartHealth;

        }

        #endregion

        #region Balloon

        void OnEntitySpawned(HotAirBalloon balloon)
        {
            if (balloon == null)
            {
                return;
            }

            balloon.SetMaxHealth(_config.BalloonMaxHealth);
            balloon._health = _config.BalloonStartHealth;

        }

        #endregion

        #endregion
    }
}

// --- End of file: HealthVehicles.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/hammer-time ---
// --- Original File Path: H/HammerTime/HammerTime.cs ---

using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Hammer Time", "Shady", "1.0.20", ResourceId = 1711)]
    [Description("Tweak settings for building blocks like demolish time, and rotate time.")]
    internal class HammerTime : RustPlugin
    {
        [PluginReference]
        private readonly Plugin Friends;
        [PluginReference]
        private readonly Plugin Clans;


        #region Config/Init
        private float DemolishTime;
        private float RotateTime;
        private float RepairCooldown;
        private float pluginInitTime = 0f;
        private bool DemolishAfterRestart;
        private bool RotateAfterRestart;
        private bool MustOwnDemolish;
        private bool MustOwnRotate;
        private bool FriendsCanDemolish;
        private bool FriendsCanRotate;
        private bool ClanCanDemolish;
        private bool ClanCanRotate;


        protected override void LoadDefaultConfig()
        {
            Config["DemolishTime"] = DemolishTime = GetConfig("DemolishTime", 600f);
            Config["RotateTime"] = RotateTime = GetConfig("RotateTime", 600f);
            Config["MustOwnToDemolish"] = MustOwnDemolish = GetConfig("MustOwnToDemolish", false);
            Config["MustOwnToRotate"] = MustOwnRotate = GetConfig("MustOwnToRotate", false);
            Config["AllowDemolishAfterServerRestart"] = DemolishAfterRestart = GetConfig("AllowDemolishAfterServerRestart", false);
            Config["AllowRotateAfterServerRestart"] = RotateAfterRestart = GetConfig("AllowRotateAfterServerRestart", false);
            Config["RepairDamageCooldown"] = RepairCooldown = GetConfig("RepairDamageCooldown", 8f);
            Config["FriendsCanDemolish"] = FriendsCanDemolish = GetConfig("FriendsCanDemolish", false);
            Config["FriendsCanRotate"] = FriendsCanRotate = GetConfig("FriendsCanRotate", false);
            Config["ClanCanDemolish"] = ClanCanDemolish = GetConfig("ClanCanDemolish", false);
            Config["ClanCanRotate"] = ClanCanRotate = GetConfig("ClanCanRotate", false);
            SaveConfig();
        }

        
        private void Init()
        {
            pluginInitTime = Time.realtimeSinceStartup;
            LoadDefaultMessages();
            LoadDefaultConfig();
            permission.RegisterPermission("hammertime.allowed", this);
            permission.RegisterPermission("hammertime.repaircooldown", this);
            permission.RegisterPermission("hammertime.demolishoverride", this);
            permission.RegisterPermission("hammertime.rotateoverride", this);
        }

        private void OnServerInitialized()
        {
            if ((Time.realtimeSinceStartup - pluginInitTime) < 1) return; //server was probably already running, and not first start up
            if (DemolishAfterRestart || RotateAfterRestart)
            {
                foreach (var entity in BaseEntity.saveList)
                {
                    if (entity == null) continue;
                    var block = entity as BuildingBlock;

                    if (block == null || block.grade == BuildingGrade.Enum.Twigs || !HasPerms(block.OwnerID, "hammertime.allowed")) continue;

                    var doRotate = false;
                    if (RotateAfterRestart) doRotate = block?.blockDefinition?.canRotateAfterPlacement ?? RotateAfterRestart;

                    if (!doRotate && !DemolishAfterRestart) continue;
                    DoInvokes(block, DemolishAfterRestart, doRotate);
                }
            }
        }


        #endregion;
        #region Commands
        [ConsoleCommand("hammertime.updateall")]
        private void consoleUpdateAll(ConsoleSystem.Arg arg)
        {
            if (arg == null || arg?.Connection != null) return;
            foreach(var entity in BaseEntity.saveList)
            {
                if (entity == null) continue;
                var block = entity as BuildingBlock;
                if (block == null || !HasPerms(block.OwnerID, "hammertime.allowed")) continue;
                DoInvokes(block, true, true);
            }
            arg.ReplyWith("Sent update to all building blocks.");
        }
        #endregion
        #region InvokeBlocks
        private void DoInvokes(BuildingBlock block, bool demo, bool rotate)
        {
            if (block == null || block.IsDestroyed) return;
            if (demo)
            {
                if (DemolishTime < 0)
                {
                    block.CancelInvoke(block.StopBeingDemolishable);
                    block.SetFlag(BaseEntity.Flags.Reserved2, true, false);
                }
                if (DemolishTime == 0) block.StopBeingDemolishable();
                if (DemolishTime > 0 && DemolishTime != 600) //if time is = to 600, then it's default, and there's no point in changing anything
                {
                    block.CancelInvoke(block.StopBeingDemolishable);
                    block.SetFlag(BaseEntity.Flags.Reserved2, true, false); //reserved2 is demolishable
                    block.Invoke(block.StopBeingDemolishable, DemolishTime);
                }
            }
            if (rotate)
            {
                if (RotateTime < 0)
                {
                    block.CancelInvoke(block.StopBeingRotatable);
                    block.SetFlag(BaseEntity.Flags.Reserved1, true, false); //reserved1 is rotatable
                }
                if (RotateTime == 0) block.StopBeingRotatable();
                if (RotateTime > 0 && RotateTime != 600) //if time is = to 600, then it's default, and there's no point in changing anything
                {
                    block.CancelInvoke(block.StopBeingRotatable);
                    block.SetFlag(BaseEntity.Flags.Reserved1, true, false); //reserved1 is rotatable
                    block.Invoke(block.StopBeingRotatable, RotateTime);
                }
            }
        }
        #endregion
        #region Hooks
      
        private void OnEntityBuilt(Planner plan, GameObject objectBlock)
        {
            var block = (objectBlock?.ToBaseEntity() ?? null) as BuildingBlock;
            if (block == null || !HasPerms(plan?.GetOwnerPlayer()?.UserIDString ?? string.Empty, "hammertime.allowed")) return;
            NextTick(() => DoInvokes(block, true, block?.blockDefinition?.canRotateAfterPlacement ?? true));
        }

        private void OnStructureUpgrade(BuildingBlock block, BasePlayer player, BuildingGrade.Enum grade)
        {
            if (block == null || player == null || !HasPerms(player.UserIDString, "hammertime.allowed")) return;
            NextTick(() => DoInvokes(block, false, block?.blockDefinition?.canRotateAfterPlacement ?? true));
        }

        private object OnStructureRepair(BaseCombatEntity block, BasePlayer player)
        {
            if (block == null || player == null || !HasPerms(player.UserIDString, "hammertime.repaircooldown") || RepairCooldown == 8f) return null;
            if (block.SecondsSinceAttacked < RepairCooldown) return false;
            return null;
        }

        private object OnHammerHit(BasePlayer player, HitInfo hitInfo)
        {
            if (player == null || !HasPerms(player.UserIDString, "hammertime.repaircooldown")) return null;
            var entity = (hitInfo?.HitEntity ?? null) as BaseCombatEntity;
            if (entity != null && entity.SecondsSinceAttacked < RepairCooldown) return false;
            return null;
        }

        private object OnStructureDemolish(BuildingBlock block, BasePlayer player)
        {
            if (!MustOwnDemolish || HasPerms(player.UserIDString, "hammertime.demolishoverride") || block.OwnerID == 0 || block.OwnerID == player.userID) return null;
            if (FriendsCanDemolish)
            {
                var hasFriend = Friends?.Call<bool>("HasFriend", block.OwnerID, player.userID) ?? false;
                if (hasFriend) return null;
            }
            if (ClanCanDemolish)
            {
                var ownerClan = Clans?.Call<string>("GetClanOf", block.OwnerID.ToString()) ?? string.Empty;
                var targetClan = Clans?.Call<string>("GetClanOf", player.UserIDString) ?? string.Empty;
                if (!string.IsNullOrEmpty(ownerClan) && !string.IsNullOrEmpty(targetClan) && (targetClan == ownerClan)) return null;
            }
            if (block.OwnerID != player.userID)
            {
                SendReply(player, GetMessage("doesNotOwnDemo", player.UserIDString));
                return true;
            }
            return null;
        }

        private object OnStructureRotate(BuildingBlock block, BasePlayer player)
        {
            if (!MustOwnRotate || HasPerms(player.UserIDString, "hammertime.rotateoverride") || block.OwnerID == 0) return null;
            if (block.OwnerID == player.userID) return null;
            if (FriendsCanRotate)
            {
                var hasFriend = Friends?.Call<bool>("HasFriend", block.OwnerID, player.userID) ?? false;
                if (hasFriend) return null;
            }
            if (ClanCanRotate)
            {
                var ownerClan = Clans?.Call<string>("GetClanOf", block.OwnerID.ToString()) ?? string.Empty;
                var targetClan = Clans?.Call<string>("GetClanOf", player.UserIDString) ?? string.Empty;
                if (!string.IsNullOrEmpty(ownerClan) && !string.IsNullOrEmpty(targetClan) && (targetClan == ownerClan)) return null;
            }

            if (block.OwnerID != player.userID)
            {
                SendReply(player, GetMessage("doesNotOwnRotate", player.UserIDString));
                return true;
            }
            return null;
        }
        #endregion
        #region Localization
        protected override void LoadDefaultMessages()
        {
            var messages = new Dictionary<string, string>
            {
                //DO NOT EDIT LANGUAGE FILES HERE! Navigate to oxide\lang
                {"doesNotOwnDemo", "You do not have access to demolish this object!"},
                {"doesNotOwnRotate", "You do not have access to rotate this object!" }
            };
            lang.RegisterMessages(messages, this);
        }
        private string GetMessage(string key, string steamId = null) => lang.GetMessage(key, this, steamId);
        #endregion
        #region Util
        private T GetConfig<T>(string name, T defaultValue) { return (Config[name] == null) ? defaultValue : (T)Convert.ChangeType(Config[name], typeof(T)); }
        private bool HasPerms(string userID, string perm) { return (string.IsNullOrEmpty(userID) || string.IsNullOrEmpty(perm)) ? false : permission.UserHasPermission(userID, perm); }
        private bool HasPerms(ulong userID, string perm) { return HasPerms(userID.ToString(), perm); }
        #endregion
    }
}


// --- End of file: HammerTime.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/hw-custom-map-name ---
// --- Original File Path: H/HWCustomMapName/HWCustomMapName.cs ---

using System;
using Steamworks;
using System.Linq;
using Newtonsoft.Json;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("HW Custom Map Name", "klauz24", "1.5.3"), Description("Changes map name at the server list.")]
    internal class HWCustomMapName : CovalencePlugin
    {
        private DateTime _nextWipe;

        private Configuration _config;

        private class Configuration
        {
            [JsonProperty("Map name")]
            public string MapName = "by klauz24";

            [JsonProperty("Random map name")]
            public RandomMapName RMN = new RandomMapName();

            [JsonProperty("Wipe countdown")]
            public WipeCountdown WPC = new WipeCountdown();

            public class RandomMapName
            {
                [JsonProperty("Enable random map name")]
                public bool EnableRandomMapName = false;

                [JsonProperty(PropertyName = "Random map names")]
                public List<string> RandomMapNames { get; set; } = new List<string>
                {
                    "by",
                    "klauz24"
                };
            }

            public class WipeCountdown
            {
                [JsonProperty("Enable wipe countdown")]
                public bool EnableWipeCountdown = false;

                [JsonProperty("Wipe countdown format")]
                public string WipeCountdownFormat = "Wipe in: {0}";

                [JsonProperty("Next wipe year")]
                public int NextWipeYear = 2020;

                [JsonProperty("Next wipe month")]
                public int NextWipeMonth = 7;

                [JsonProperty("Next wipe day")]
                public int NextWipeDay = 12;

                [JsonProperty("Next wipe hour")]
                public int NextWipeHours = 11;

                [JsonProperty("Next wipe minutes")]
                public int NextWipeMinutes = 0;
            }

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        protected override void LoadDefaultConfig() => _config = new Configuration();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null)
                {
                    throw new JsonException();
                }

                if (!_config.ToDictionary().Keys.SequenceEqual(Config.ToDictionary(x => x.Key, x => x.Value).Keys))
                {
                    PrintWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch
            {
                PrintWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            PrintWarning($"Configuration changes saved to {Name}.json");
            Config.WriteObject(_config, true);
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"Days", "{0}d. {1}h."},
                {"Hours", "{0}h. {1}m."},
                {"Minutes", "{0}m. {1}s."},
                {"Seconds", "{0}s."}
            }, this);
        }

        private void OnServerInitialized()
        {
            _nextWipe = new DateTime(_config.WPC.NextWipeYear, _config.WPC.NextWipeMonth, _config.WPC.NextWipeDay, _config.WPC.NextWipeHours, _config.WPC.NextWipeMinutes, 00);
            timer.Every(1f, () =>
            {
                var str = GetMapName();
                UpdateMapName(str);
            });
        }

        private string GetMapName()
        {
            if (_config.RMN.EnableRandomMapName && _config.WPC.EnableWipeCountdown)
            {
                PrintWarning("Random map name and wipe countdown are enabled, please choose one of them or disable both.");
                return "Error, check console.";
            }
            if (_config.RMN.EnableRandomMapName)
            {
                var randomEntry = _config.RMN.RandomMapNames[new Random().Next(0, _config.RMN.RandomMapNames.Count)];
                return randomEntry;
            }
            if (_config.WPC.EnableWipeCountdown)
            {
                var time = (_nextWipe - DateTime.Now).TotalSeconds;
                return string.Format(_config.WPC.WipeCountdownFormat, FormatTime(time));
            }
            return _config.MapName;
        }

        private string FormatTime(double time)
        {
            var timeSpan = TimeSpan.FromSeconds(time);
            if (timeSpan.TotalSeconds < 1)
            {
                return null;
            }
            if (Math.Floor(timeSpan.TotalDays) >= 1)
            {
                return string.Format(Lang("Days"), timeSpan.Days, timeSpan.Hours);
            }
            if (Math.Floor(timeSpan.TotalMinutes) >= 60)
            {
                return string.Format(Lang("Hours"), timeSpan.Hours, timeSpan.Minutes);
            }
            if (Math.Floor(timeSpan.TotalSeconds) >= 60)
            {
                return string.Format(Lang("Minutes"), timeSpan.Minutes, timeSpan.Seconds);
            }
            return string.Format(Lang("Seconds"), timeSpan.Seconds);
        }

        private string Lang(string key) => lang.GetMessage(key, this);

        private void UpdateMapName(string str)
        {
#if HURTWORLD
            SteamGameServer.SetMapName(str);
#endif
#if RUST
            SteamServer.MapName = str;
#endif
        }
    }
}

// --- End of file: HWCustomMapName.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/heal-gun ---
// --- Original File Path: H/HealGun/HealGun.cs ---

﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using ConVar;
using Newtonsoft.Json;
using Oxide.Core;
using UnityEngine;
using VLB;

namespace Oxide.Plugins
{

	[Info("Heal Gun", "Wolfleader101", "1.3.7")]
	[Description("A customizable heal gun")]
	class HealGun : RustPlugin
	{
		#region Variables

		private PluginConfig config;
		public const string HealgunPerms = "healgun.use";
		

		#endregion
		#region Hooks
		private void Init()
		{
			config = Config.ReadObject<PluginConfig>();
			
			permission.RegisterPermission(HealgunPerms, this);
		}
		
		void OnPlayerAttack(BasePlayer attacker, HitInfo info)
		{
			if (info == null) return;
			if (attacker == null) return;
			if (!permission.UserHasPermission(attacker.UserIDString, HealgunPerms)) return;
			var healgun = info.Weapon.ShortPrefabName;
			if (healgun != config.Healgun) return;
			if (!(info.HitEntity is BasePlayer)) return;
			
			info.damageTypes.ScaleAll(0); // disable damage
			var player = info.HitEntity as BasePlayer;

			if (player.IsWounded() && config.CanRevive)
			{
				ServerMgr.Instance.StartCoroutine(WoundTimer(player));
			}
			player.Heal(config.HealAmount);
			player.metabolism.pending_health.value += config.PendingHealAmount;
			
			info.ProjectilePrefab.remainInWorld = false;

		}
		#endregion

		#region Custom Methods

		IEnumerator WoundTimer(BasePlayer player)
		{
			yield return new WaitForSeconds(config.ReviveTime);
			player.StopWounded();

		}

		#endregion

		#region Config
		private class PluginConfig
		{
			[JsonProperty("Healgun")] public string Healgun { get; set; }
			[JsonProperty("Heal Amount")] public float HealAmount { get; set; }
			[JsonProperty("Pending Health Amount")] public float PendingHealAmount { get; set; }
			[JsonProperty("Can Revive")] public bool CanRevive { get; set; }
			[JsonProperty("Revive Time")] public float ReviveTime { get; set; }
		}

		private PluginConfig GetDefaultConfig()
		{
			return new PluginConfig
			{
				Healgun = "nailgun.entity",
				HealAmount = 5f,
				PendingHealAmount  = 10f,
				CanRevive = true,
				ReviveTime = 3f
			};
		}

		protected override void LoadDefaultConfig()
		{
			Config.WriteObject(GetDefaultConfig(), true);
		}

		

		#endregion
	}
}


// --- End of file: HealGun.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/highlight-player ---
// --- Original File Path: H/HighlightPlayer/HighlightPlayer.cs ---

﻿using System;
using System.Collections.Generic;
using UnityEngine;
using System.Linq;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Highlight Player", "Freakyy", "1.2.1")]
    [Description("Marks players on the map after using a command. So other players can find the target for pvp action.")]
    class HighlightPlayer : RustPlugin
    {
        #region variables

        public List<MapMarkerGenericRadius> Markers = new List<MapMarkerGenericRadius>();
        public List<BasePlayer> Players_To_Highlight = new List<BasePlayer>();

        //permissions stuff
        private string permission_can_highlight_other_players = "HighlightPlayer.CanHighlightOtherPlayers";
        private string permission_cant_be_highlighted_by_other_players = "HighlightPlayer.CantBeHighlightedByOtherPlayers";

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NotHighligted"] = "You are not highlighted.",
                ["NotHighligtedAnymore"] = "You are not highlighted anymore.",
                ["SuccessfullyHighlighted"] = "From now on for the next " + (Configuration.How_Long_Is_Player_Highlighted / 60) + " minutes, are you a highlighted target on the map. If you want to change this use the '/uhme' command.",
                ["NoPermissionToHighlightOtherPlayers"] = "You are not allowed to highlight other players.",
                ["SomethingWentWrongHighlightOtherPlayer"] = "Something went wrong please try again with '/h <playername>'.",
                ["HighlightedByOtherPlayer"] = "You just got highlighted by: ",
                ["OtherPlayerAlreadyHighlighted"] = " is already highlighted.",
                ["SuccessfullyHighlightedOtherPlayer"] = " is now highlighted.",
                ["UseOtherCommandToHighlightYourself"] = "Use /hme to highlight yourself.",
                ["CantHighlightThisPlayer"] = "You are not allowed to highlight this player.",
            }, this);
        }
        #endregion

        #region hooks
        void OnServerInitialized()
        {
            timer.Repeat(Configuration.Update_delay, 0, () =>
            {
                update_player_position_on_map();
            });
        }

        void Init() {
            permission.RegisterPermission(permission_can_highlight_other_players, this);
            permission.RegisterPermission(permission_cant_be_highlighted_by_other_players, this);
        }
        void OnPlayerConnected(BasePlayer player)
        {
            update_player_position_on_map();
        }

        void OnPlayerDisconnected(BasePlayer player)
        {
            clearplayermarker(player);
        }

        void Unload()
        {
            clearallmarkers();

            Players_To_Highlight.Clear();
        }
        #endregion

        #region commands

        [ChatCommand("hme")] // highlight me
        void highlight(BasePlayer player)
        {
            highlight_player(player);
            SendReply(player, lang.GetMessage("SuccessfullyHighlighted", this, player.UserIDString));
        }

        [ChatCommand("uhme")] // unhighlight me
        void unhighlight(BasePlayer player)
        {
            unhighlight_player(player);
        }

        [ChatCommand("h")]
        private void highlightOtherPlayer(BasePlayer player, string command, string[] args)
        {
            if(!has_user_permission(player.IPlayer, permission_can_highlight_other_players))
            {
                SendReply(player, lang.GetMessage("NoPermissionToHighlightOtherPlayers", this, player.UserIDString));
                return;
            }

            if (args.Length != 1 || args[0] == null)     
            {
                SendReply(player, lang.GetMessage("SomethingWentWrongHighlightOtherPlayer", this, player.UserIDString));
                return;
            }

            if (args[0] is string)
            {
                IPlayer player_to_highlight = covalence.Players.FindPlayer(args[0]);
                BasePlayer player_to_highlight_base = player_to_highlight.Object as BasePlayer;

                if(player_to_highlight_base.userID == player.userID && !player.IsAdmin)
                {
                    SendReply(player, lang.GetMessage("UseOtherCommandToHighlightYourself", this, player.UserIDString));
                    return;
                }

                if (has_user_permission(player_to_highlight, permission_cant_be_highlighted_by_other_players))
                {
                    SendReply(player, lang.GetMessage("CantHighlightThisPlayer", this, player.UserIDString));
                    return;
                }

                if (Players_To_Highlight.Contains(player_to_highlight_base))
                {
                    SendReply(player, player_to_highlight_base.displayName + " " + lang.GetMessage("OtherPlayerAlreadyHighlighted", this, player.UserIDString));
                    return;
                }
                else
                {
                    highlight_player(player_to_highlight_base);
                    SendReply(player, player_to_highlight_base.displayName + " " + lang.GetMessage("SuccessfullyHighlightedOtherPlayer", this, player.UserIDString));
                    SendReply(player_to_highlight_base, lang.GetMessage("HighlightedByOtherPlayer", this, player.UserIDString) + " " + player.displayName);
                }
            }
            else
            {
                SendReply(player, lang.GetMessage("SomethingWentWrongHighlightOtherPlayer", this, player.UserIDString));
                return;
            }
        }
        #endregion

        #region functions
        private void unhighlight_player(BasePlayer player)
        {
            if (Players_To_Highlight.Contains(player))
            {
                clearplayermarker(player);
            }
            else
            {
                SendReply(player, lang.GetMessage("NotHighligted", this, player.UserIDString));
            }
        }
        private void highlight_player(BasePlayer player)
        {
            Players_To_Highlight.Add(player);
            update_player_position_on_map();
            timer.Once(Configuration.How_Long_Is_Player_Highlighted, () =>
            {
                clearplayermarker(player);
            });
        }
        private bool has_user_permission(IPlayer player, string permission_name)
        {
            return player.IsAdmin || player.HasPermission(permission_name);
        }
        void clearplayermarker(BasePlayer player)
        {
            if (Players_To_Highlight.Contains(player))
            {
                Players_To_Highlight.Remove(player);
            }

            foreach (var marker in Markers)
            {
                if (marker == null)
                {
                    continue;
                }

                if (marker.transform.position == player.transform.position)
                {
                    if(!marker.IsDestroyed) marker.Kill();
                    marker.SendUpdate();
                }
            }
            update_player_position_on_map();
            SendReply(player, lang.GetMessage("NotHighligtedAnymore", this, player.UserIDString));
        }
        void clearallmarkers()
        {
            foreach (var marker in Markers)
            {
                if (marker != null)
                {
                    if (!marker.IsDestroyed) marker.Kill();
                    marker.SendUpdate();
                }
            }
            Markers.Clear();
        }
        void update_player_position_on_map()
        {
            clearallmarkers();
            foreach (BasePlayer player in Players_To_Highlight)
            {
                if (player == null)
                    continue;

                MapMarkerGenericRadius mapMarker = GameManager.server.CreateEntity("assets/prefabs/tools/map/genericradiusmarker.prefab", player.transform.position) as MapMarkerGenericRadius;

                if (mapMarker != null)
                {
                    mapMarker.alpha = 0.4f;
                    mapMarker.color1 = Color.black;
                    mapMarker.color2 = Color.red;
                    mapMarker.name = player.displayName;
                    mapMarker.radius = Configuration.Marker_Radius;
                    Markers.Add(mapMarker);
                    mapMarker.Spawn();
                    mapMarker.SendUpdate();
                }
            }
        }
        #endregion

        #region config
        private struct Configuration
        {
            public static float Update_delay = 10f; //seconds
            public static float Marker_Radius = 0.5f;
            public static float How_Long_Is_Player_Highlighted = 30f; //seconds
        }

        private new void LoadConfig()
        {
            GetConfig(ref Configuration.Update_delay, "Update Delay (seconds)", "10f");
            GetConfig(ref Configuration.Marker_Radius, "Marker Radius", "0.5f");
            GetConfig(ref Configuration.How_Long_Is_Player_Highlighted, "How Long Is Player Highlighted (seconds)", "30f");

            SaveConfig();
        }

        private void GetConfig<T>(ref T variable, params string[] path)
        {
            if (path.Length == 0)
            {
                return;
            }

            if (Config.Get(path) == null)
            {
                Config.Set(path.Concat(new object[] { variable }).ToArray());
                PrintWarning($"Added field to config: {string.Join("/", path)}");
            }

            variable = (T)Convert.ChangeType(Config.Get(path), typeof(T));
        }

        protected override void LoadDefaultConfig() => PrintWarning("Generating new config file...");
        #endregion
    }
}


// --- End of file: HighlightPlayer.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/horn-doors ---
// --- Original File Path: H/HornDoors/HornDoors.cs ---

﻿using Facepunch;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;
using System;
using System.Collections.Generic;
using System.Text;
using UnityEngine;
using Rust;

namespace Oxide.Plugins
{
	[Info("Horn Doors", "imthenewguy", "1.0.1")]
	[Description("Allows players to use the horn from their vehicle to open garage doors.")]
	class HornDoors : RustPlugin
	{
        #region Config       

        private Configuration config;
        public class Configuration
        {
            [JsonProperty("Maximum distance that the vehicle can be from the door before we attempt to open it?")]
            public float distance = 15;

            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonConvert.DeserializeObject<Dictionary<string, object>>(ToJson());
        }

        protected override void LoadDefaultConfig() => config = new Configuration();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null)
                {
                    throw new JsonException();
                }

                SaveConfig();
            }
            catch
            {
                PrintToConsole($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            PrintToConsole($"Configuration changes saved to {Name}.json");
            Config.WriteObject(config, true);
        }

        #endregion

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["ToggleOff"] = "You will no longer open doors when you honk your horn.",
                ["ToggleOn"] = "You can now open doors when you honk your horn.",
                ["NoPerms"] = "You do not have permission to use command."
            }, this);
        }

        #endregion

        #region Hooks

        const string perm_use = "horndoors.use";
        const string perm_off = "horndoors.off";

        void Init()
        {
            permission.RegisterPermission(perm_use, this);
            permission.RegisterPermission(perm_off, this);
        }

        Dictionary<BasePlayer, float> HornLastPressed = new Dictionary<BasePlayer, float>();

        void OnVehicleHornPressed(VehicleModuleSeating seat, BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, perm_use) || permission.UserHasPermission(player.UserIDString, perm_off)) return;

            float lastPressed;
            if (HornLastPressed.TryGetValue(player, out lastPressed) && lastPressed > Time.time) return;

            var vehicle = seat.GetParentEntity() as ModularCar;
            if (vehicle == null) return;

            HandleDoors(player, vehicle);
        }

        #endregion

        #region Commands

        [ConsoleCommand("togglehorn")]
        void ToggleConsole(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            if (player != null) Toggle(player);
        }

        [ChatCommand("togglehorn")]
        void ToggleChat(BasePlayer player) => Toggle(player);

        void Toggle(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, perm_use))
            {
                PrintToChat(player, lang.GetMessage("NoPerms", this, player.UserIDString));
                return;
            }

            if (permission.UserHasPermission(player.UserIDString, perm_off))
            {
                permission.RevokeUserPermission(player.UserIDString, perm_off);
                PrintToChat(player, lang.GetMessage("ToggleOn", this, player.UserIDString));
                return;
            }

            permission.GrantUserPermission(player.UserIDString, perm_off, this);
            PrintToChat(player, lang.GetMessage("ToggleOff", this, player.UserIDString));
        }

        #endregion

        #region Helpers

        public void HandleDoors(BasePlayer player, ModularCar car)
        {
            var doors = FindEntitiesOfType<Door>(car.transform.position, config.distance);
            doors.Sort((a, b) => (a.transform.position - car.transform.position).sqrMagnitude.CompareTo((b.transform.position - car.transform.position).sqrMagnitude));

            foreach (var door in doors)
            {
                if (!InRange(door.transform.position, car.transform.position, config.distance)) continue;
                if (door.transform.position.y > car.transform.position.y + 2) continue;
                if (!door.GetPlayerLockPermission(player)) continue;
                if (!IsVehicleDoor(door.ShortPrefabName)) continue;
                if (!CanSeeDoor(door, car)) continue;
                HornLastPressed[player] = Time.time + 1f;
                if (door.IsBusy()) return;
                door.SetOpen(!door.IsOpen());
                break;
            }
            Pool.FreeList(ref doors);
        }

        private bool CanSeeDoor(Door door, ModularCar car)
        {
            Vector3 adjustedPos = car.transform.position + car.transform.up * 1.5f;
            Vector3 adjustedDoorPos = door.transform.position + door.transform.up * 1.5f;
            var Distance = (adjustedDoorPos - adjustedPos).magnitude + 0.5f;
            RaycastHit raycastHit;
            bool flag = Physics.Raycast(adjustedPos, (adjustedDoorPos - adjustedPos).normalized, out raycastHit, Distance, Layers.Mask.Construction | Layers.Mask.Deployed);
            var targetEntity = flag ? raycastHit.GetEntity() : null;
            if (targetEntity != null && (targetEntity is BuildingBlock || targetEntity is IceFence || targetEntity is SimpleBuildingBlock)) return false;
            return true;
        }

        bool IsVehicleDoor(string prefab)
        {
            switch (prefab)
            {
                case "wall.frame.garagedoor":
                case "gates.external.high.wood":
                case "gates.external.high.stone":
                    return true;

                default: return false;
            }
        }

        private static List<T> FindEntitiesOfType<T>(Vector3 a, float n, int m = -1) where T : BaseEntity
        {
            int hits = Physics.OverlapSphereNonAlloc(a, n, Vis.colBuffer, m, QueryTriggerInteraction.Collide);
            List<T> entities = Pool.GetList<T>();
            for (int i = 0; i < hits; i++)
            {
                var entity = Vis.colBuffer[i]?.ToBaseEntity() as T;
                if (entity != null && !entities.Contains(entity) && !entity.IsDestroyed) entities.Add(entity);
                Vis.colBuffer[i] = null;
            }
            return entities;
        }

        private static bool InRange(Vector3 a, Vector3 b, float distance)
        {
            return (a - b).sqrMagnitude <= distance * distance;
        }

        #endregion        
    }
}


// --- End of file: HornDoors.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/healthy-guns ---
// --- Original File Path: H/HealthyGuns/HealthyGuns.cs ---

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

/*
 * Rewritten from scratch and maintained to present by VisEntities
 * Previous maintenance and contributions by Wulf and Arainrr
 * Originally created by Evano
 */

namespace Oxide.Plugins
{
    [Info("Healthy Guns", "VisEntities", "4.1.0")]
    [Description("Restores full condition to weapons spawned in loot crates and barrels.")]
    public class HealthyGuns : RustPlugin
    {
        #region Fields

        private static HealthyGuns _plugin;

        #endregion Fields

        #region Oxide Hooks

        private void Init()
        {
            Unsubscribe(nameof(OnLootSpawn));
            _plugin = this;
        }

        private void Unload()
        {
            CoroutineUtil.StopAllCoroutines();
            _plugin = null;
        }

        private void OnServerInitialized(bool isStartup)
        {
            Subscribe(nameof(OnLootSpawn));

            if (!isStartup)
                CoroutineUtil.StartCoroutine(Guid.NewGuid().ToString(), RepairAllContainersCoroutine());
        }

        private void OnLootSpawn(LootContainer container)
        {
            if (container != null
                && container.inventory != null
                && container.OwnerID == 0
                && container.inventory.itemList != null
                && container.inventory.itemList.Count > 0
                && (container.SpawnType == LootContainer.spawnType.ROADSIDE || container.SpawnType == LootContainer.spawnType.TOWN))
            {
                NextTick(() =>
                {
                    RepairContainerContents(container);
                });
            }
        }
        
        #endregion Oxide Hooks

        #region Functions

        private IEnumerator RepairAllContainersCoroutine()
        {
            foreach (LootContainer container in BaseNetworkable.serverEntities.OfType<LootContainer>())
            {
                OnLootSpawn(container);
                yield return CoroutineEx.waitForSeconds(0.1f);
            }
        }

        private void RepairContainerContents(LootContainer container)
        {
            foreach (Item item in container.inventory.itemList)
            {
                if (item != null && item.hasCondition && item.condition != item.info.condition.max && ItemOfCategory(item, ItemCategory.Weapon))
                    item.condition = item.info.condition.max;
            }
        }

        private bool ItemOfCategory(Item item, ItemCategory category)
        {
            return item.info.category == category;
        }

        #endregion Functions

        #region Coroutine Util

        private static class CoroutineUtil
        {
            private static readonly Dictionary<string, Coroutine> _activeCoroutines = new Dictionary<string, Coroutine>();
            
            public static void StartCoroutine(string coroutineName, IEnumerator coroutineFunction)
            {
                StopCoroutine(coroutineName);

                Coroutine coroutine = ServerMgr.Instance.StartCoroutine(coroutineFunction);
                _activeCoroutines[coroutineName] = coroutine;
            }

            public static void StopCoroutine(string coroutineName)
            {
                if (_activeCoroutines.TryGetValue(coroutineName, out Coroutine coroutine))
                {
                    if (coroutine != null)
                        ServerMgr.Instance.StopCoroutine(coroutine);

                    _activeCoroutines.Remove(coroutineName);
                }
            }

            public static void StopAllCoroutines()
            {
                foreach (string coroutineName in _activeCoroutines.Keys.ToArray())
                {
                    StopCoroutine(coroutineName);
                }
            }
        }

        #endregion Coroutine Util
    }
}

// --- End of file: HealthyGuns.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/heli-control ---
// --- Original File Path: H/HeliControl/HeliControl.cs ---

using Oxide.Core;
using System;
using System.Collections.Generic;
using UnityEngine;
using Oxide.Core.Plugins;
using System.Text;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("HeliControl", "Shady", "1.4.5", ResourceId = 1348)]
    [Description("Tweak various settings of helicopters.")]
    internal class HeliControl : RustPlugin
    {
        //Soli Deo gloria
        #region Constants
        private const uint ROCKET_PREFAB_ID = 129320027;
        private const uint AIRBURST_ROCKET_PREFAB_ID = 3253859536;
        private const uint NAPALM_ROCKET_PREFAB_ID = 200672762;
        private const uint HELI_CRATE_PREFAB_ID = 1314849795;
        private const uint NAPALM_FIREBALL_PREFAB_ID = 184893264;
        private const uint OIL_FIREBALL_PREFAB_ID = 3550347674;
        private const uint CHINOOK_EVENT_PREFAB_ID = 1514383717;
        private const uint HELI_EVENT_PREFAB_ID = 3029415845;

        private const uint CHINOOK_SCIENTISTS_PREFAB_ID = 1514383717;

        private const string HELI_PREFAB = "assets/prefabs/npc/patrol helicopter/patrolhelicopter.prefab";
        private const string CHINOOK_PREFAB = "assets/prefabs/npc/ch47/ch47scientists.entity.prefab";
        #endregion
        #region Fields
        #region Plugin References
        [PluginReference]
        private readonly Plugin Vanish;
        #endregion

        private PatrolHelicopterAI HeliInstance
        {
            get { return PatrolHelicopterAI.heliInstance; }
            set { PatrolHelicopterAI.heliInstance = value; }
        }

        private CH47HelicopterAIController CH47Instance { get; set; }

        private float _lastSpawnTimer;
        private float _lastSpawnTimerCH47;
        private DateTime _lastTimerStart;
        private DateTime _lastTimerStartCH47;
        private Timer _callTimer;
        private Timer _callTimerCH47;

        private Timer CallTimer
        {
            get { return _callTimer; }
            set
            {
                if (_callTimer != null) _callTimer.Destroy();
                _lastTimerStart = DateTime.UtcNow;
                _lastSpawnTimer = value.Delay;
                _callTimer = value;
            }
        }

        private Timer CallTimerCH47
        {
            get { return _callTimerCH47; }
            set
            {
                if (_callTimerCH47 != null) _callTimerCH47.Destroy();
                _lastTimerStartCH47 = DateTime.UtcNow;
                _lastSpawnTimerCH47 = value.Delay;
                _callTimerCH47 = value;
            }
        }

        private TriggeredEventPrefab[] _eventPrefabs = null;
        public TriggeredEventPrefab[] EventPrefabs
        {
            get
            {
                if (_eventPrefabs == null)
                {
                    _eventPrefabs = UnityEngine.Object.FindObjectsOfType<TriggeredEventPrefab>();
                }

                return _eventPrefabs;
            }
        }

        private NetworkableId _timerHeliId;
        private CH47HelicopterAIController _timerCH47;

        private bool _configChanged = false;
        private bool _terrainHookCalled = false;
        private bool _useNapalm = false; //not a config option!
        private bool _init;


        private StoredData _lootData = new StoredData();
        private StoredData2 _weaponsData = new StoredData2();
        private StoredData3 _cooldownData = new StoredData3();
        private StoredData4 _spawnsData = new StoredData4();

        private float _boundary;

        private readonly HashSet<PatrolHelicopter> _PatrolHelicopters = new HashSet<PatrolHelicopter>();
        private readonly HashSet<CH47HelicopterAIController> _chinooks = new HashSet<CH47HelicopterAIController>();
        private readonly HashSet<HelicopterDebris> _gibs = new HashSet<HelicopterDebris>();
        private readonly HashSet<FireBall> _fireBalls = new HashSet<FireBall>();
        private readonly HashSet<PatrolHelicopter> _forceCalled = new HashSet<PatrolHelicopter>();
        private readonly HashSet<CH47HelicopterAIController> _forceCalledCh = new HashSet<CH47HelicopterAIController>();
        private readonly HashSet<LockedByEntCrate> _lockedCrates = new HashSet<LockedByEntCrate>();
        private readonly HashSet<HackableLockedCrate> _hackLockedCrates = new HashSet<HackableLockedCrate>();

        private readonly Dictionary<PatrolHelicopter, int> _strafeCount = new Dictionary<PatrolHelicopter, int>();


        private static readonly System.Random _rng = new System.Random(); //used for loot crates

        private readonly int _groundLayer = LayerMask.GetMask("Terrain", "World", "Default");

        #endregion
        #region Config Fields


        private bool DisableHeli;
        private bool DisableDefaultHeliSpawns;
        private bool DisableDefaultChinookSpawns;
        private bool UseCustomLoot;
        private bool DisableGibs;
        private bool DisableNapalm;
        private bool AutoCallIfExists;
        private bool AutoCallIfExistsCH47;
        private bool DisableCratesDeath;
        private bool HelicopterCanShootWhileDying;
        private bool UseCustomHeliSpawns;
        private bool UseOldSpawning;
        private bool UseOldSpawningCH47;
        private bool SpawnHeliOnRestart;
        private bool SpawnChinookOnRestart;
        private bool SpawnHeliOnTarget;
        private float GlobalDamageMultiplier;
        private float HeliBulletDamageAmount;
        private float MainRotorHealth;
        private float TailRotorHealth;
        private float BaseHealth;
        private float BaseChinookHealth;
        private float HeliSpeed;
        private float HeliStartSpeed;
        private float HeliStartLength;
        private float HeliAccuracy;
        private float TimeBeforeUnlocking;
        private float TimeBeforeUnlockingHack;
        private float TurretFireRate;
        private float TurretBurstLength;
        private float TurretTimeBetweenBursts;
        private float TurretMaxRange;
        private float GibsTooHotLength;
        private float GibsHealth;
        private float TimeBetweenRockets;
        private float MinSpawnTime;
        private float MinSpawnTimeCH47;
        private float MaxSpawnTime;
        private float MaxSpawnTimeCH47;
        private float RocketDamageBlunt;
        private float RocketDamageExplosion;
        private float RocketExplosionRadius;
        private int MaxLootCrates;
        private int MaxHeliRockets;
        private int BulletSpeed;
        private int LifeTimeMinutes;
        private int LifeTimeMinutesCH47;
        private int MaxActiveHelicopters;
        private int HelicoptersToSpawn;
        private int ChinooksToSpawn;

        private Dictionary<string, float> Cds;

        private Dictionary<string, int> Limits;
        #endregion




        #region Config
        protected override void LoadDefaultConfig()
        {

            //this cooldown and limit garbage is to fix an issue that was causing duplicate entries in the config.
            //I hate it, but it was necessary unless I wanted to ask people to reset or clean up their own configs.
            var _coolDowns = GetConfig("Cooldowns", new Dictionary<string, object>());

            var _limits = GetConfig("Limits", new Dictionary<string, object>());

            Cds = new Dictionary<string, float>();
            foreach (var kvp in _coolDowns) Cds[kvp.Key.ToLower()] = Convert.ToSingle(kvp.Value);

            Limits = new Dictionary<string, int>();
            foreach (var kvp in _limits) Limits[kvp.Key.ToLower()] = Convert.ToInt32(kvp.Value);

            if (Limits.Count < _limits.Count || Cds.Count < _coolDowns.Count) _configChanged = true;

            for (int i = 0; i < 10; i++)
            {
                float outFloat;
                int outInt;

                var cd = "cooldown." + i;
                var limit = "limit." + i;
                var cdCh47 = "cooldown.ch47." + i;
                var limitCh47 = "limit.ch47." + i;

                if (!Cds.TryGetValue(cd, out outFloat)) Cds[cd] = 86400f;
                if (!Limits.TryGetValue(limit, out outInt)) Limits[limit] = 5;

                if (!Cds.TryGetValue(cdCh47, out outFloat)) Cds[cdCh47] = 86400f;
                if (!Limits.TryGetValue(limitCh47, out outInt)) Limits[limitCh47] = 5;
            }

            Config["Cooldowns"] = Cds;
            Config["Limits"] = Limits;


            DisableHeli = GetConfig("Spawning - Disable Helicopter", false);
            DisableDefaultHeliSpawns = GetConfig("Spawning - Disable Rust's default spawns", false);
            DisableDefaultChinookSpawns = GetConfig("Spawning - Disable CH47 default spawns", false);
            UseCustomLoot = GetConfig("Loot - Use Custom loot spawns", false);
            GlobalDamageMultiplier = GetConfig("Damage - Global damage multiplier", 1f);
            HeliBulletDamageAmount = GetConfig("Turrets - Helicopter bullet damage", 20f);
            HelicopterCanShootWhileDying = GetConfig("Misc - Helicopter can shoot while dying", true);
            MainRotorHealth = GetConfig("Health - Main rotor health", 750f);
            TailRotorHealth = GetConfig("Health - Tail rotor health", 375f);
            BaseHealth = GetConfig("Health - Base Helicopter health", 10000f);
            BaseChinookHealth = GetConfig("Health - Base CH47 health", 4000f);
            MaxLootCrates = GetConfig("Loot - Max Crates to drop", 4);
            HeliSpeed = GetConfig("Misc - Helicopter speed", 25f);
            HeliAccuracy = GetConfig("Turrets - Helicopter bullet accuracy", 2f);
            MaxHeliRockets = GetConfig("Rockets - Max helicopter rockets", 12);
            DisableGibs = GetConfig("Spawning - Disable helicopter gibs", false);
            DisableNapalm = GetConfig("Spawning - Disable helicopter napalm", false);
            BulletSpeed = GetConfig("Turrets - Helicopter bullet speed", 250);
            TimeBeforeUnlocking = GetConfig("Loot - Time before unlocking crates", -1f);
            TimeBeforeUnlockingHack = GetConfig("Loot - Time before unlocking CH47 crates", -1f);
            LifeTimeMinutes = GetConfig("Misc - Maximum helicopter life time in minutes", 15);
            LifeTimeMinutesCH47 = GetConfig("Misc - Maximum helicopter life time in minutes", 15);
            TimeBetweenRockets = GetConfig("Rockets - Time between each rocket in seconds", 0.2f);
            TurretFireRate = GetConfig("Turrets - Turret fire rate in seconds", 0.125f);
            TurretBurstLength = GetConfig("Turrets - Turret burst length in seconds", 3f);
            TurretTimeBetweenBursts = GetConfig("Turrets - Time between turret bursts in seconds", 3f);
            TurretMaxRange = GetConfig("Turrets - Max range", 300f);
            RocketDamageBlunt = GetConfig("Rockets - Blunt damage to deal", 175f);
            RocketDamageExplosion = GetConfig("Rockets - Explosion damage to deal", 100f);
            RocketExplosionRadius = GetConfig("Rockets - Explosion radius", 6f);
            GibsTooHotLength = GetConfig("Gibs - Time until gibs can be harvested in seconds", 480f);
            GibsHealth = GetConfig("Gibs - Health of gibs", 500f);
            MinSpawnTime = GetConfig("Spawning - Automatically call helicopter between min seconds", 0f);
            MaxSpawnTime = GetConfig("Spawning - Automatically call helicopter between max seconds", 0f);
            MinSpawnTimeCH47 = GetConfig("Spawning - Automatically call CH47 between min seconds", 0f);
            MaxSpawnTimeCH47 = GetConfig("Spawning - Automatically call CH47 between max seconds", 0f);
            UseOldSpawning = GetConfig("Spawning - Use static spawning", false);
            UseOldSpawningCH47 = GetConfig("Spawning - Use static spawning for CH47", false);
            SpawnHeliOnRestart = GetConfig("Spawning - Spawn helicopter after restart", false);
            SpawnChinookOnRestart = GetConfig("Spawning - Spawn CH47 after restart", false);
            AutoCallIfExists = GetConfig("Spawning - Automatically call helicopter if one is already flying", false);
            SpawnHeliOnTarget = GetConfig("Spawning - Spawn helicopters directly on target", true);
            AutoCallIfExistsCH47 = GetConfig("Spawning - Automatically call CH47 if one is already flying", false);
            HelicoptersToSpawn = GetConfig("Spawning - Helicopters to spawn", 1);
            ChinooksToSpawn = GetConfig("Spawning - Chinooks to spawn", 1);
            UseCustomHeliSpawns = GetConfig("Spawning - Use custom helicopter spawns", false);
            HeliStartSpeed = GetConfig("Misc - Helicopter startup speed", 25f);
            HeliStartLength = GetConfig("Misc - Helicopter startup length in seconds", 0f);
            DisableCratesDeath = GetConfig("Misc - Prevent crates from spawning when forcefully killing helicopter", true);
            MaxActiveHelicopters = GetConfig("Spawning - Max active helicopters", -1);
        }
        protected override void LoadDefaultMessages()
        {
            var messages = new Dictionary<string, string>
            {
                //DO NOT EDIT LANGUAGE FILES HERE! Navigate to oxide\lang
                {"noPerms", "You do not have permission to use this command!"},
                {"invalidSyntax", "Invalid Syntax, usage example: {0} {1}"},
                {"invalidSyntaxMultiple", "Invalid Syntax, usage example: {0} {1} or {2} {3}"},
                {"heliCalled", "Helicopter Inbound!"},
                {"helisCalledPlayer", "{0} Helicopter(s) called on: {1}"},
                {"entityDestroyed", "{0} {1}(s) were annihilated!"},
                {"helisForceDestroyed", "{0} Helicopter(s) were forcefully destroyed!"},
                {"heliAutoDestroyed", "Helicopter auto-destroyed because config has it disabled!" },
                {"playerNotFound", "Could not find player: {0}"},
                {"noHelisFound", "No active helicopters were found!"},
                {"cannotBeCalled", "This can only be called on a single Helicopter, there are: {0} active."},
                {"strafingOtherPosition", "Helicopter is now strafing {0}'s position."},
                {"destinationOtherPosition", "Helicopter's destination has been set to {0}'s position."},
                {"IDnotFound", "Could not find player by ID: {0}" },
                {"updatedHelis", "{0} helicopters were updated successfully!" },
                {"callheliCooldown", "You must wait before using this again! You've waited: {0}/{1}" },
                {"invalidCoordinate", "Incorrect argument supplied for {0} coordinate!" },
                {"coordinatesOutOfBoundaries", "Coordinates are out of map boundaries!" },
                {"callheliLimit", "You've used your daily limit of {0} heli calls!" },
                {"unlockedAllCrates", "Unlocked all Helicopter crates!" },
                {"teleportedToHeli", "You've been teleported to the ground below the active Helicopter!" },
                {"removeAddSpawn", "To remove a Spawn, type: /helispawn remove SpawnName\n\nTo add a Spawn, type: /helispawn add SpawnName -- This will add the spawn on your current position." },
                {"addedSpawn", "Added helicopter spawn {0} with the position of: {1}" },
                {"spawnExists", "A spawn point with this name already exists!" },
                {"noSpawnsExist", "No Helicopter spawns have been created!" },
                {"removedSpawn", "Removed Helicopter spawn point: {0}: {1}" },
                {"noSpawnFound", "No spawn could be found with that name!" },
                {"onlyCallSelf", "You can only call a Helicopter on yourself, try: /callheli {0}" },
                {"spawnCommandLiner", "<color=orange>----</color>Spawns<color=orange>----</color>\n" },
                {"spawnCommandBottom", "\n<color=orange>----------------</color>" },
                {"cantCallTargetOrSelf", "You do not have the permission to call a Helicopter on a target! Try: /callheli" },
                {"maxHelis", "Killing helicopter because the maximum active helicopters has been reached" },
                {"cmdError", "An error happened while using this command. Please report this to your server administrator." },
                {"ch47AlreadyDropped", "This CH47 has already dropped a crate!" },
                {"ch47DroppedCrate", "Dropped crate!" },
                {"noTimeFound", "No spawn time found for helicopter." },
                {"noTimeFoundCH47", "No spawn time found for CH47." },
                {"nextHeliSpawn", "Next helicopter spawn: {0}" },
                {"nextCH47Spawn", "Next CH47 spawn: {0}" },
                {"nextAlreadyActive", "A helicopter is already active." },
                {"tooManyActiveHelis", "The maximum amount of Helicopters active has been reached. Please try again later." },
                {"itemNotFound", "Item not found!" },
            };
            lang.RegisterMessages(messages, this);
        }
        private string GetMessage(string key, string steamId = null) => lang.GetMessage(key, this, steamId);
        #endregion

        #region Hooks
        #region Init
        private void Init()
        {
            Unsubscribe(nameof(OnEntitySpawned));

            _cooldownData = Interface.Oxide?.DataFileSystem?.ReadObject<StoredData3>("HeliControlCooldowns") ?? new StoredData3();

            if (!_configChanged) LoadDefaultConfig(); //don't call load again if it was already called because config file didn't exist. tiny optimization

            if (_configChanged) SaveConfig(); //config could have been changed after a manual call of loaddefaultconfig, so we check again

            LoadDefaultMessages();


            string[] perms = { "callheli", "callheliself", "callhelitarget", "callch47", "callch47self", "callch47target", "killch47", "killheli", "strafe", "update", "destination", "dropcrate", "killnapalm", "killgibs", "unlockcrates", "admin", "ignorecooldown", "ignorelimits", "tpheli", "tpch47", "helispawn", "callmultiple", "callmultiplech47", "dropcrates", "nextheli" };


            for (int j = 0; j < perms.Length; j++) permission.RegisterPermission("helicontrol." + perms[j], this);
            foreach (var limit in Limits.Keys) permission.RegisterPermission("helicontrol." + limit, this);
            foreach (var cd in Cds.Keys) permission.RegisterPermission("helicontrol." + cd, this);

            if (HelicopterCanShootWhileDying)
            {
                Unsubscribe(nameof(CanBeTargeted));
                Unsubscribe(nameof(OnHelicopterTarget));
                Unsubscribe(nameof(CanHelicopterStrafeTarget));
                Unsubscribe(nameof(CanHelicopterStrafe));
                Unsubscribe(nameof(CanHelicopterTarget));
            }

            if (!DisableNapalm) Unsubscribe(nameof(CanHelicopterUseNapalm));

            AddCovalenceCommand("unlockcrates", nameof(cmdUnlockCrates));
            AddCovalenceCommand("tpheli", nameof(cmdTeleportHeli));
            AddCovalenceCommand("killheli", nameof(cmdKillHeli));
            AddCovalenceCommand("killch47", nameof(cmdKillCH47));
            AddCovalenceCommand("dropcrate", nameof(cmdDropCH47Crate));
            AddCovalenceCommand("updatehelis", nameof(cmdUpdateHelicopters));
            AddCovalenceCommand("strafe", nameof(cmdStrafeHeli));
            AddCovalenceCommand("helidest", nameof(cmdDestChangeHeli));
            AddCovalenceCommand("killnapalm", nameof(cmdKillFB));
            AddCovalenceCommand("killgibs", nameof(cmdKillGibs));
            AddCovalenceCommand("nextheli", nameof(cmdNextHeli));

            AddCovalenceCommand("hcdebug", nameof(cmdDebug));

        }


        private void OnTerrainInitialized()
        {
            try
            {
                if (DisableDefaultHeliSpawns) ToggleHeliEvent(false); //OnServerInit may be too late to disable the event
                if (DisableDefaultChinookSpawns) ToggleCH47Event(false);
            }
            finally { _terrainHookCalled = true; }
        }

        private void OnServerInitialized()
        {
            try
            {
                _boundary = TerrainMeta.Size.x * 0.75f;
                Subscribe(nameof(OnEntitySpawned));

                if (ServerMgr.Instance != null) ServerMgr.Instance.InvokeRepeating(CheckHelicopter, 10f, 10f); //ServerMgr.Instance should never be null after server init, but we check anyway

                foreach (var entity in BaseNetworkable.serverEntities)
                {
                    if (entity == null) continue;
                    var heli = entity as PatrolHelicopter;
                    var ch47 = entity as CH47HelicopterAIController;
                    var crate = entity as LockedByEntCrate;
                    var hackCrate = entity as HackableLockedCrate;
                    var debris = entity as HelicopterDebris;
                    var fireball = entity as FireBall;
                    if (heli != null)
                    {
                        _PatrolHelicopters.Add(heli);
                        UpdateHeli(heli);
                    }

                    if (ch47?.prefabID == CHINOOK_SCIENTISTS_PREFAB_ID)
                    {
                        _chinooks.Add(ch47);
                        UpdateChinook(ch47);
                    }

                    if (crate != null) _lockedCrates.Add(crate);
                    if (hackCrate != null) _hackLockedCrates.Add(hackCrate);
                    if (debris != null) _gibs.Add(debris);
                    if (fireball != null && (fireball.prefabID == NAPALM_FIREBALL_PREFAB_ID || fireball.prefabID == OIL_FIREBALL_PREFAB_ID)) _fireBalls.Add(fireball);
                }


                ConVar.PatrolHelicopter.bulletAccuracy = HeliAccuracy;
                ConVar.PatrolHelicopter.lifetimeMinutes = LifeTimeMinutes;
                if (TimeBeforeUnlockingHack > 0f) HackableLockedCrate.requiredHackSeconds = TimeBeforeUnlockingHack;

                if (UseCustomLoot) LoadLootData();
                LoadHeliSpawns();
                LoadWeaponData();




                foreach (var ch47 in _chinooks)
                {
                    CH47Instance = ch47; //I feel like this is better than LINQ's FirstOrDefault for a hashset. maybe hashsets shouldn't have been used at all. who knows
                    break;
                }


                var randomHeliSpawnTime = GetRandomSpawnTime();
                var randomChinookSpawnTime = GetRandomSpawnTime(true);

                if (randomHeliSpawnTime > 0)
                {
                    var heliSpawnTime = UseOldSpawning ? GetRandomSpawnTime() : GetAdjustedSecondsToSpawn(GetRandomSpawnTime());

                    CallTimer = GetHeliSpawnTimer(heliSpawnTime);
                }

                if (randomChinookSpawnTime > 0)
                {
                    var chinookSpawnTime = UseOldSpawningCH47 ? GetRandomSpawnTime(true) : GetAdjustedSecondsToSpawn(GetRandomSpawnTime(true));

                    CallTimerCH47 = GetChinookSpawnTimer(chinookSpawnTime);
                }

                if (_terrainHookCalled)
                {
                    if (SpawnHeliOnRestart) callHelis(HelicoptersToSpawn, forced: false);
                    if (SpawnChinookOnRestart) callChinooks(ChinooksToSpawn, forced: false);
                }
                else
                {
                    if (DisableDefaultHeliSpawns) ToggleHeliEvent(false); //OnServerInit may be too late to disable the event
                    if (DisableDefaultChinookSpawns) ToggleCH47Event(false);
                }
            }
            finally { _init = true; }
        }
        #endregion

        private void Unload()
        {
            if (ServerMgr.Instance != null) ServerMgr.Instance.CancelInvoke(CheckHelicopter);

            ToggleHeliEvent(true);
            ToggleCH47Event(true);

            SaveCooldownData();
            SaveSpawnData();
        }

        /*/
        private void OnServerSave()
        {
            var saveAction = new Action(() =>
            {
                SaveCooldownData();
                SaveSpawnData();
            });
            if (ServerMgr.Instance != null) ServerMgr.Instance.Invoke(saveAction, 4f); //ServerMgr.Instance should never be null on a server save, but we'll check anyway. We want to delay saving a few seconds because a lot of things are often called on OnServerSave
            else saveAction.Invoke();
        }/*/

        private void OnEntitySpawned(BaseNetworkable entity)
        {
            if (entity == null || entity.IsDestroyed || entity.gameObject == null) return; //entity should never be destroyed on spawn, but lets do a check anyway
            var prefabname = entity?.ShortPrefabName ?? string.Empty;
            var longprefabname = entity?.PrefabName ?? string.Empty;
            if (string.IsNullOrEmpty(prefabname) || string.IsNullOrEmpty(longprefabname)) return; //another likely impossibility, but lets just check EVERYTHING



            var ownerID = (entity as BaseEntity)?.OwnerID ?? 0;

            var lockedEntCrate = entity as LockedByEntCrate;
            if (lockedEntCrate != null) _lockedCrates.Add(lockedEntCrate);

            var hackableCrate = entity as HackableLockedCrate;
            if (hackableCrate != null) _hackLockedCrates.Add(hackableCrate);

            var ch = entity as CH47HelicopterAIController;
            if (ch?.prefabID == CHINOOK_SCIENTISTS_PREFAB_ID && !ch.ShouldLand()) //ShouldLand will be true for oil rig chinooks. we want to ignore those; we don't control them
            {
                ch.Invoke(() =>
                {
                    if (!ch.IsDestroyed) ch.Kill();
                }, LifeTimeMinutesCH47 * 60);

                _chinooks.Add(ch);
                CH47Instance = ch;

                if (UseOldSpawningCH47) CallTimerCH47 = GetChinookSpawnTimer(GetRandomSpawnTime(true));

                UpdateChinook(ch, true);
            }

            var fireBall = entity as FireBall;
            if (fireBall != null && (fireBall.prefabID == NAPALM_FIREBALL_PREFAB_ID || fireBall.prefabID == OIL_FIREBALL_PREFAB_ID)) _fireBalls.Add(fireBall);

            if (entity.prefabID == ROCKET_PREFAB_ID || entity.prefabID == NAPALM_ROCKET_PREFAB_ID || entity.prefabID == AIRBURST_ROCKET_PREFAB_ID)
            {
                var explosion = entity as TimedExplosive;
                if (explosion == null || explosion.IsDestroyed || explosion.gameObject == null) return; //super ultra extra safe null checking


                _useNapalm = explosion.prefabID == NAPALM_ROCKET_PREFAB_ID && explosion.OwnerID != 1337; //is a napalm rocket & was not spawned by plugin (1337 owner id indicates that)


                if (MaxHeliRockets < 1) explosion.Kill();
                else
                {
                    explosion.explosionRadius = RocketExplosionRadius;
                    if (MaxHeliRockets > 12 && ownerID == 0)
                    {
                        PatrolHelicopter strafeHeli = null;
                        foreach (var heli in _PatrolHelicopters) //loop through all active helis to find one that's currently strafing
                        {
                            if (heli == null || heli.IsDestroyed || heli.gameObject == null || heli.IsDead()) continue; //super ultra extra safe null checking
                            var state = heli?.GetComponent<PatrolHelicopterAI>()?._currentState ?? PatrolHelicopterAI.aiState.IDLE;
                            if (state == PatrolHelicopterAI.aiState.STRAFE)
                            {
                                strafeHeli = heli;
                                break;
                            }
                        }

                        if (strafeHeli == null || strafeHeli.IsDestroyed || strafeHeli.gameObject == null || strafeHeli.IsDead()) return; //super ultra extra safe null checking
                        var curCount = 0;
                        if (!_strafeCount.TryGetValue(strafeHeli, out curCount)) curCount = _strafeCount[strafeHeli] = 1;
                        else curCount = _strafeCount[strafeHeli] += 1;
                        if (curCount >= 12)
                        {
                            var heliAI = strafeHeli?.GetComponent<PatrolHelicopterAI>() ?? null;
                            if (heliAI == null || heliAI.gameObject == null) return; //extra null checking
                            var actCount = 0;
                            Action fireAct = null;
                            fireAct = new Action(() =>
                            {
                                if (heliAI == null || heliAI.gameObject == null || actCount >= (MaxHeliRockets - 12))
                                {
                                    InvokeHandler.CancelInvoke(heliAI, fireAct);
                                    return;
                                }
                                actCount++;
                                FireRocket(heliAI);
                            });
                            InvokeHandler.InvokeRepeating(heliAI, fireAct, TimeBetweenRockets, TimeBetweenRockets);
                            _strafeCount[strafeHeli] = 0;
                        }
                    }
                    else if (MaxHeliRockets < 12 && HeliInstance != null && HeliInstance.gameObject != null && HeliInstance.ClipRocketsLeft() > MaxHeliRockets)
                    {
                        explosion.Kill();
                        return;
                    }


                    var dmgTypes = explosion?.damageTypes ?? null;

                    if (dmgTypes != null && dmgTypes.Count > 0)
                    {
                        for (int i = 0; i < dmgTypes.Count; i++)
                        {
                            var dmg = dmgTypes[i];
                            if (dmg == null) continue; //impossible? who knows. but we're gonna null check it anyway cause that's what you do
                            if (dmg.type == Rust.DamageType.Blunt) dmg.amount = RocketDamageBlunt;
                            if (dmg.type == Rust.DamageType.Explosion) dmg.amount = RocketDamageExplosion;
                        }
                    }
                }
            }

            if (entity.prefabID == HELI_CRATE_PREFAB_ID)
            {
                if (UseCustomLoot && _lootData?.HeliInventoryLists != null && _lootData.HeliInventoryLists.Count > 0)
                {
                    var heli_crate = entity as LootContainer;
                    if (heli_crate == null || heli_crate?.inventory == null) return; //possible that the inventory is somehow null? not sure

                    var index = _rng.Next(_lootData.HeliInventoryLists.Count);
                    var inv = _lootData.HeliInventoryLists[index];
                    if (inv?.lootBoxContents != null && inv.lootBoxContents.Count > 0)
                    {
                        if (heli_crate?.inventory?.itemList != null && heli_crate.inventory.itemList.Count > 0)
                        {
                            var itemList = new List<Item>(heli_crate.inventory.itemList);
                            if (itemList != null && itemList.Count > 0) for (int i = 0; i < itemList.Count; i++) RemoveFromWorld(itemList[i]); //completely remove all existing items in crate
                        }

                        for (int i = 0; i < inv.lootBoxContents.Count; i++)
                        {
                            var itemDef = inv.lootBoxContents[i];
                            if (itemDef == null) continue;

                            var amount = (itemDef.amountMin > 0 && itemDef.amountMax > 0) ? UnityEngine.Random.Range(itemDef.amountMin, itemDef.amountMax) : itemDef.amount;

                            var def = ItemManager.FindItemDefinition(itemDef.name);
                            if (def != null)
                            {
                                var item = ItemManager.Create(def, amount, itemDef.skinID);
                                if (item != null && !item.MoveToContainer(heli_crate.inventory)) RemoveFromWorld(item); //ensure the item is completely removed if we can't move it, so we're not causing issues
                            }
                        }

                        heli_crate.inventory.MarkDirty();
                    }
                }

                if (TimeBeforeUnlocking >= 0f)
                {
                    var crate2 = entity as LockedByEntCrate;
                    if (crate2 != null)
                    {
                        if (TimeBeforeUnlocking <= 0f) UnlockCrate(crate2);
                        else crate2.Invoke(() =>
                        {
                            if (entity == null || entity.IsDestroyed || crate2 == null) return;
                            UnlockCrate(crate2);
                        }, TimeBeforeUnlocking);
                    }
                }
            }

            var debris = entity as HelicopterDebris;
            if (debris != null)
            {
                if (DisableGibs || GibsHealth <= 0)
                {
                    NextTick(() => { if (!(entity?.IsDestroyed ?? true)) entity.Kill(); });
                    return;
                }

                if (GibsHealth != 500f)
                {
                    debris.InitializeHealth(GibsHealth, GibsHealth);
                    debris.SendNetworkUpdate();
                }

                _gibs.Add(debris);
                if (GibsTooHotLength != 480f) debris.tooHotUntil = Time.realtimeSinceStartup + GibsTooHotLength;
            }

            var BaseHeli = entity as PatrolHelicopter;
            if (BaseHeli != null)
            {
                var isMax = HeliCount >= MaxActiveHelicopters && MaxActiveHelicopters != -1;
                if (DisableHeli || isMax)
                {
                    NextTick(() => { if (!(entity?.IsDestroyed ?? true)) entity.Kill(); });
                }
                if (DisableHeli)
                {
                    Puts(GetMessage("heliAutoDestroyed"));
                    return;
                }
                else if (isMax)
                {
                    Puts(GetMessage("maxHelis"));
                    return;
                }

                var AIHeli = entity?.GetComponent<PatrolHelicopterAI>() ?? null;
                if (AIHeli == null) return;

                if (UseOldSpawning) CallTimer = GetHeliSpawnTimer(GetRandomSpawnTime());


                _PatrolHelicopters.Add(BaseHeli);
                UpdateHeli(BaseHeli, true);

                if (UseCustomHeliSpawns && _spawnsData?.HelicopterSpawns != null && _spawnsData.HelicopterSpawns.Count > 0 && !_forceCalled.Contains(BaseHeli))
                {
                    var valCount = _spawnsData.HelicopterSpawns.Count;
                    var rng = UnityEngine.Random.Range(0, valCount);
                    var pos = _spawnsData.HelicopterSpawns[rng].Position;
                    BaseHeli.transform.position = pos;
                    AIHeli.transform.position = pos;
                }

                if (HeliStartLength > 0.0f && HeliStartSpeed != HeliSpeed)
                {
                    AIHeli.maxSpeed = HeliStartSpeed;
                    AIHeli.Invoke(() =>
                    {
                        if (AIHeli == null || AIHeli.gameObject == null || BaseHeli == null || BaseHeli.IsDestroyed || BaseHeli.gameObject == null || BaseHeli.IsDead()) return;
                        AIHeli.maxSpeed = HeliSpeed;
                    }, HeliStartLength);
                }
            }
        }

        private object CanBeTargeted(BaseCombatEntity entity, MonoBehaviour monoTurret) //this hook is unsubscribed if the config option isn't enabled
        {
            if (!_init || entity == null || (entity?.IsDestroyed ?? true) || monoTurret == null) return null;
            var aiHeli = (monoTurret as HelicopterTurret)?._heliAI ?? null;
            if (aiHeli == null) return null;
            var player = entity as BasePlayer;
            if (player != null && !player.IsDestroyed && player.gameObject != null && !player.IsSleeping() && Vanish != null && (Vanish?.Call<bool>("IsInvisible", player) ?? false)) return null;
            if ((aiHeli?._currentState ?? PatrolHelicopterAI.aiState.DEATH) == PatrolHelicopterAI.aiState.DEATH) return false;
            return null;
        }

        private object OnHelicopterTarget(HelicopterTurret turret, BaseCombatEntity entity) //this hook is unsubscribed if the config option isn't enabled
        {
            if (turret == null || entity == null) return null;
            if ((turret?._heliAI?._currentState ?? PatrolHelicopterAI.aiState.DEATH) == PatrolHelicopterAI.aiState.DEATH) return false;
            return null;
        }

        private object CanHelicopterStrafeTarget(PatrolHelicopterAI entity, BasePlayer target) //this hook is unsubscribed if the config option isn't enabled
        {
            if (entity == null || target == null) return null;
            if ((entity?._currentState ?? PatrolHelicopterAI.aiState.DEATH) == PatrolHelicopterAI.aiState.DEATH) return false;
            return null;
        }

        private object CanHelicopterStrafe(PatrolHelicopterAI entity) //this hook is unsubscribed if the config option isn't enabled
        {
            if (entity == null) return null;
            if ((entity?._currentState ?? PatrolHelicopterAI.aiState.DEATH) == PatrolHelicopterAI.aiState.DEATH) return false;
            return null;
        }

        private object CanHelicopterTarget(PatrolHelicopterAI entity, BasePlayer player) //this hook is unsubscribed if the config option isn't enabled
        {
            if ((entity?._currentState ?? PatrolHelicopterAI.aiState.DEATH) == PatrolHelicopterAI.aiState.DEATH) return false;
            return null;
        }

        private object CanHelicopterUseNapalm(PatrolHelicopterAI entity) //this hook is unsubscribed if the config option isn't enabled
        {
            return false;
        }

        private void OnEntityKill(BaseNetworkable entity)
        {

            var crate = entity as LockedByEntCrate;
            var CH47 = entity as CH47HelicopterAIController;
            var baseHeli = entity as PatrolHelicopter;

            if (crate != null) _lockedCrates.Remove(crate);

            if (baseHeli != null)
            {
                var heliId = baseHeli.net.ID;
                _PatrolHelicopters.Remove(baseHeli);
                _forceCalled.Remove(baseHeli);

                if (!UseOldSpawning && (CallTimer == null || CallTimer.Destroyed) && (_timerHeliId.Value == 0 || heliId == _timerHeliId)) //this weird timer heli ID stuff is a workaround for an issue I just could not fix or figure out. sometimes the timer heli would not be equal after a server restart, so the timer would never ever restart.
                {
                    var rngTime = GetRandomSpawnTime();
                    if (rngTime > 0) CallTimer = GetHeliSpawnTimer(rngTime);
                } //otherwise, a timer is already firing (or heli is not a timer heli or old spawning is enabled)
            }

            if (CH47?.prefabID == CHINOOK_SCIENTISTS_PREFAB_ID && !CH47.ShouldLand()) //ShouldLand will be true for oil rig chinooks. we want to ignore those; we don't control them
            {
                _chinooks.Remove(CH47);
                _forceCalledCh.Remove(CH47);

                if (!UseOldSpawningCH47 && (CallTimerCH47 == null || CallTimerCH47.Destroyed) && CH47 == _timerCH47)
                {
                    var rngTime = GetRandomSpawnTime(true);
                    if (rngTime > 0) CallTimerCH47 = GetChinookSpawnTimer(rngTime);
                } //otherwise, a timer is already firing (or heli is not a timer heli or old spawning is enabled)
            }


            var fireball = entity as FireBall;
            if (fireball != null) _fireBalls.Remove(fireball);

            var debris = entity as HelicopterDebris;
            if (debris != null) _gibs.Remove(debris);
        }

        private void OnPlayerAttack(BasePlayer attacker, HitInfo hitInfo)
        {
            if (attacker == null || hitInfo?.HitEntity == null) return;

            if (hitInfo?.HitEntity is PatrolHelicopter)
            {
                if (GlobalDamageMultiplier != 1f && GlobalDamageMultiplier >= 0)
                {
                    hitInfo?.damageTypes?.ScaleAll(GlobalDamageMultiplier);
                    return;
                }
                var shortName = hitInfo?.Weapon?.GetItem()?.info?.shortname ?? string.Empty;
                var displayName = hitInfo?.Weapon?.GetItem()?.info?.displayName?.english ?? string.Empty;

                float weaponConfig;
                if (_weaponsData.WeaponList.TryGetValue(shortName, out weaponConfig) || _weaponsData.WeaponList.TryGetValue(displayName, out weaponConfig))
                {
                    if (weaponConfig != 0.0f && weaponConfig != 1.0f) hitInfo?.damageTypes?.ScaleAll(weaponConfig);
                }
            }
        }
        #endregion
        #region Main
        private void UpdateHeli(PatrolHelicopter heli, bool justCreated = false)
        {
            if (heli == null || heli.IsDestroyed || heli.IsDead()) return;

            heli.startHealth = BaseHealth;
            if (justCreated) heli.InitializeHealth(BaseHealth, BaseHealth);

            heli.maxCratesToSpawn = MaxLootCrates;
            heli.bulletDamage = HeliBulletDamageAmount;
            heli.bulletSpeed = BulletSpeed;

            var weakspots = heli.weakspots;
            if (weakspots != null && weakspots.Length > 1) //not even sure if this is needed, but may fix some very strange NRE
            {
                if (justCreated)
                {
                    weakspots[0].health = MainRotorHealth;
                    weakspots[1].health = TailRotorHealth;
                }
                weakspots[0].maxHealth = MainRotorHealth;
                weakspots[1].maxHealth = TailRotorHealth;
            }

            var heliAI = heli?.GetComponent<PatrolHelicopterAI>() ?? null;
            if (heliAI == null) return;

            heliAI.maxSpeed = Mathf.Clamp(HeliSpeed, 0.1f, 125);
            heliAI.timeBetweenRockets = Mathf.Clamp(TimeBetweenRockets, 0.1f, 1f);
            heliAI.numRocketsLeft = Mathf.Clamp(MaxHeliRockets, 0, 48);
            UpdateTurrets(heliAI);
            heli.SendNetworkUpdateImmediate(justCreated);
        }

        private void UpdateChinook(CH47HelicopterAIController chinook, bool justCreated = false)
        {
            if (chinook == null || chinook.IsDestroyed || chinook.gameObject == null) return;

            chinook.startHealth = BaseChinookHealth;
            chinook._maxHealth = BaseChinookHealth;

            if (justCreated)
            {
                chinook.InitializeHealth(BaseChinookHealth, BaseChinookHealth);
            }
        }

        //nearly exact code used by Rust to fire helicopter rockets
        private void FireRocket(PatrolHelicopterAI heliAI)
        {
            if (heliAI == null || !(heliAI?.IsAlive() ?? false)) return;


            var strafeTarget = heliAI.strafe_target_position;
            if (strafeTarget == Vector3.zero) return;

            var num1 = 4f;

            var vector3 = heliAI.transform.position + heliAI.transform.forward * 1f;
            var direction = (strafeTarget - vector3).normalized;
            if (num1 > 0.0) direction = Quaternion.Euler(UnityEngine.Random.Range((float)(-num1 * 0.5), num1 * 0.5f), UnityEngine.Random.Range((float)(-num1 * 0.5), num1 * 0.5f), UnityEngine.Random.Range((float)(-num1 * 0.5), num1 * 0.5f)) * direction;

            var leftTubeLast = heliAI.leftTubeFiredLast;
            heliAI.leftTubeFiredLast = !leftTubeLast;

            var sb = Facepunch.Pool.Get<StringBuilder>();
            try
            {
                Effect.server.Run(heliAI.helicopterBase.rocket_fire_effect.resourcePath, heliAI.helicopterBase, StringPool.Get(sb.Clear().Append("rocket_tube_").Append((!leftTubeLast ? "right" : "left")).ToString()), Vector3.zero, Vector3.forward, null, true);
            }
            finally { Facepunch.Pool.Free(ref sb); }


            var entity = GameManager.server.CreateEntity(!(_useNapalm && heliAI.CanUseNapalm()) ? heliAI.rocketProjectile.resourcePath : heliAI.rocketProjectile_Napalm.resourcePath, vector3, new Quaternion(), true);
            if (entity == null)
            {
                PrintWarning("Failed to create entity on " + nameof(FireRocket) + " !!");
                return;
            }

            var projectile = entity.GetComponent<ServerProjectile>();
            if (projectile != null) projectile.InitializeVelocity(direction * projectile.speed);

            entity.OwnerID = 1337; //assign ownerID so it doesn't infinitely loop on OnEntitySpawned
            entity.Spawn();
        }

        private PatrolHelicopter callHeli(Vector3 coordinates = new Vector3(), bool forced = true, bool setPositionAfterSpawn = true)
        {
            var heli = (PatrolHelicopter)GameManager.server.CreateEntity(HELI_PREFAB, new Vector3(), new Quaternion(), true);
            if (heli == null)
            {
                PrintWarning("Failed to create heli prefab on " + nameof(callHeli));
                return null;
            }

            var heliAI = heli?.GetComponent<PatrolHelicopterAI>() ?? null;
            if (heliAI == null)
            {
                PrintWarning("Failed to get helicopter AI on " + nameof(callHeli));
                return null;
            }
            
            if (coordinates != Vector3.zero)
            {
                if (coordinates.y < 225) coordinates.y = 225;
                heliAI.SetInitialDestination(coordinates, 0.25f);
                if (setPositionAfterSpawn) heli.transform.position = heliAI.transform.position = coordinates;
            }

            if (forced) _forceCalled.Add(heliAI.helicopterBase);
            
            heli.Spawn();
            
            return heli;
        }

        //chinook position setting code is based off of the same code used by patrolhelicopter in order to (try to) get it to spawn out of the map and fly in
        private CH47HelicopterAIController callChinook(Vector3 coordinates = new Vector3(), bool forced = true)
        {
            var heli = (CH47HelicopterAIController)GameManager.server.CreateEntity(CHINOOK_PREFAB, new Vector3(0, 100, 0), new Quaternion(), true);
            if (heli == null) return null;
            float x = TerrainMeta.Size.x;
            float num = coordinates.y + 50f;
            var mapScaleDistance = 0.8f; //high scale for further out distances/positions
            var vector3_1 = Vector3Ex.Range(-1f, 1f);
            vector3_1.y = 0.0f;
            vector3_1.Normalize();
            var vector3_2 = vector3_1 * (x * mapScaleDistance);
            vector3_2.y = num;
            heli.transform.position = vector3_2;
            if (forced) _forceCalledCh.Add(heli);
            heli.Spawn();
            if (coordinates != Vector3.zero)
            {
                heli.Invoke(() =>
                {
                    if (heli != null && !heli.IsDestroyed) SetDestination(heli, coordinates + new Vector3(0f, 10f, 0)); //worth noting that null checks inside of invokes are probably unnecessary, because the invoke should never happen if the object turned null... but we check anyway.
                }, 1f);
            }
            return heli;
        }

        private List<PatrolHelicopter> callHelis(int amount, Vector3 coordinates = new Vector3(), bool forced = true, bool setPositionAfterSpawn = true)
        {
            if (amount < 1) return null;
            var listHelis = new List<PatrolHelicopter>(amount);
            for (int i = 0; i < amount; i++) listHelis.Add(callHeli(coordinates, forced, setPositionAfterSpawn));
            return listHelis;
        }

        private List<CH47HelicopterAIController> callChinooks(int amount, Vector3 coordinates = new Vector3(), bool forced = true)
        {
            if (amount < 1) return null;
            var listHelis = new List<CH47HelicopterAIController>(amount);
            for (int i = 0; i < amount; i++) listHelis.Add(callChinook(coordinates, forced));
            return listHelis;
        }

        private PatrolHelicopter callCoordinates(Vector3 coordinates)
        {
            var heli = (PatrolHelicopter)GameManager.server.CreateEntity(HELI_PREFAB, new Vector3(), new Quaternion(), true);
            if (heli == null) return null;
            var heliAI = heli?.GetComponent<PatrolHelicopterAI>() ?? null;
            if (heliAI == null) return null;
            heliAI.SetInitialDestination(coordinates + new Vector3(0f, 10f, 0f), 0.25f);
            _forceCalled.Add(heliAI.helicopterBase);
            heli.Spawn();
            return heli;
        }

        private void UpdateTurrets(PatrolHelicopterAI helicopter)
        {
            if (helicopter == null || helicopter.leftGun == null || helicopter.rightGun == null) return;
            helicopter.leftGun.fireRate = helicopter.rightGun.fireRate = TurretFireRate;
            helicopter.leftGun.timeBetweenBursts = helicopter.rightGun.timeBetweenBursts = TurretTimeBetweenBursts;
            helicopter.leftGun.burstLength = helicopter.rightGun.burstLength = TurretBurstLength;
            helicopter.leftGun.maxTargetRange = helicopter.rightGun.maxTargetRange = TurretMaxRange;
        }

        private int KillAllHelis(bool isForced = false)
        {
            CheckHelicopter();
            var count = 0;
            if (_PatrolHelicopters.Count < 1) return count;

            var helis = new List<PatrolHelicopter>(_PatrolHelicopters);
            for (int i = 0; i < helis.Count; i++)
            {
                var helicopter = helis[i];
                if (helicopter != null && !helicopter.IsDead())
                {
                    if (DisableCratesDeath) helicopter.maxCratesToSpawn = 0;

                    if (isForced) helicopter.Kill(); //network kill if forced, else die 'naturally' with explosion
                    else helicopter.DieInstantly();

                    count++;
                }
            }

            CheckHelicopter();
            return count;
        }

        private int KillAllChinooks(bool isForced = false)
        {
            CheckHelicopter();
            var count = 0;
            if (_chinooks.Count < 1) return count;

            var chinooks = new List<CH47HelicopterAIController>(_chinooks);
            for (int i = 0; i < chinooks.Count; i++)
            {
                var ch47 = chinooks[i];
                if (ch47 != null && !ch47.IsDestroyed)
                {
                    if (isForced) ch47.Kill(); //network kill if forced, else die 'naturally' with explosion
                    else ch47.DieInstantly();

                    count++;
                }
            }

            CheckHelicopter();
            return count;
        }
        #endregion
        #region Commands
        [ChatCommand("helispawn")]
        private void cmdHeliSpawns(BasePlayer player, string command, string[] args)
        {
            if (!HasPerms(player.UserIDString, "helispawn"))
            {
                SendNoPerms(player);
                return;
            }
            if (args.Length < 1)
            {
                var msgSB = new StringBuilder();
                for (int i = 0; i < _spawnsData.HelicopterSpawns.Count; i++)
                {
                    var sp = _spawnsData.HelicopterSpawns[i];
                    msgSB.Append(sp.Name).Append(": ").Append(sp.Position).Append(", ");
                }

                if (msgSB.Length > 2) msgSB.Length -= 2;
                var msg = msgSB.ToString();

                if (!string.IsNullOrEmpty(msg)) SendReply(player, GetMessage("spawnCommandLiner", player.UserIDString) + msgSB + GetMessage("spawnCommandBottom", player.UserIDString));
                SendReply(player, GetMessage("removeAddSpawn"), player.UserIDString); //this isn't combined with a new line with the above because there is a strange character limitation per-message, so we send two messages
                return;
            }
            var arg0 = args[0];
            var spawn = args.Length > 1 ? FindSpawn(args[1]) : null;
            if (arg0.Equals("add", StringComparison.OrdinalIgnoreCase) && args.Length > 1)
            {
                if (spawn == null)
                {
                    var pos = player?.transform?.position ?? Vector3.zero;
                    if (pos == Vector3.zero) return;
                    _spawnsData.HelicopterSpawns.Add(new HelicopterSpawn { Position = pos, Name = args[1] });
                    SendReply(player, string.Format(GetMessage("addedSpawn", player.UserIDString), args[1], pos));
                }
                else SendReply(player, GetMessage("spawnExists", player.UserIDString));
            }
            else if (arg0.Equals("remove", StringComparison.OrdinalIgnoreCase) && args.Length > 1)
            {
                if (_spawnsData?.HelicopterSpawns == null || _spawnsData.HelicopterSpawns.Count < 1)
                {
                    SendReply(player, GetMessage("noSpawnsExist", player.UserIDString));
                    return;
                }
                if (spawn != null)
                {
                    var value = spawn.Position;
                    _spawnsData.HelicopterSpawns.Remove(spawn);
                    SendReply(player, string.Format(GetMessage("removedSpawn", player.UserIDString), args[1], value));
                }
                else SendReply(player, GetMessage("noSpawnFound", player.UserIDString));
            }
            else SendReply(player, string.Format(GetMessage("invalidSyntaxMultiple", player.UserIDString), "/helispawn add", "SpawnName", "/helispawn remove", "SpawnName"));
        }

        private void cmdUnlockCrates(IPlayer player, string command, string[] args)
        {
            if (!HasPerms(player.Id, "unlockcrates"))
            {
                SendNoPerms(player);
                return;
            }
            var chCrate = args.Length > 0 ? args[0].Equals("ch47", StringComparison.OrdinalIgnoreCase) : false;
            var bothCrates = args.Length > 0 ? args[0].Equals("all", StringComparison.OrdinalIgnoreCase) : false;

            if (bothCrates || !chCrate) foreach (var crate in _lockedCrates) UnlockCrate(crate);

            if (bothCrates || chCrate) foreach (var crate in _hackLockedCrates) UnlockCrate(crate);

            player.Message(GetMessage("unlockedAllCrates", player.Id));
        }

        private void cmdDebug(IPlayer player, string command, string[] args)
        {
            if (!player.IsAdmin) return;

            var testTimer = GetHeliSpawnTimer(GetRandomSpawnTime());
            player.Reply("got test timer: " + testTimer.Delay);
        }

        private void cmdNextHeli(IPlayer player, string command, string[] args)
        {
            if (!HasPerms(player.Id, "nextheli"))
            {
                SendNoPerms(player);
                return;
            }

            var nextHeli = GetNextHeliTime();
            var nextCh47 = GetNextCH47Time();

            if (nextHeli <= TimeSpan.Zero) player.Message(GetMessage("noTimeFound", player.Id));
            else
                player.Message(string.Format(GetMessage("nextHeliSpawn", player.Id), !(HeliInstance?.isDead ?? true) && !(HeliInstance?.helicopterBase?.IsDestroyed ?? true) ? GetMessage("nextAlreadyActive", player.Id) : ReadableTimeSpan(nextHeli)));
            
            if (nextCh47 <= TimeSpan.Zero) player.Message(GetMessage("noTimeFoundCH47", player.Id));
            else 
                player.Message(string.Format(GetMessage("nextCH47Spawn", player.Id), CH47Instance != null && !CH47Instance.IsDestroyed ? GetMessage("nextAlreadyActive", player.Id) : ReadableTimeSpan(nextCh47)));
        }

        private void cmdDropCH47Crate(IPlayer player, string command, string[] args)
        {
            if (!HasPerms(player.Id, "dropcrate"))
            {
                SendNoPerms(player);
                return;
            }
            if (CH47Instance == null || CH47Instance.IsDestroyed || CH47Instance.IsDead())
            {
                player.Message(GetMessage("noHelisFound", player.Id));
                return;
            }
            var all = args.Length > 0 && args[0].Equals("all", StringComparison.OrdinalIgnoreCase);
            if (CH47Count > 1 && !all)
            {
                player.Message(string.Format(GetMessage("cannotBeCalled", player.Id), HeliCount.ToString("N0")));
                return;
            }
            if (all) foreach (var ch47 in _chinooks) { if (ch47.CanDropCrate()) ch47.DropCrate(); }
            else
            {
                if (!CH47Instance.CanDropCrate())
                {
                    player.Message(GetMessage("ch47AlreadyDropped", player.Id));
                    return;
                }
                CH47Instance.DropCrate();
            }
            player.Message(GetMessage("ch47DroppedCrate", player.Id));
        }


        private void cmdTeleportHeli(IPlayer player, string command, string[] args)
        {
            if (player.IsServer) return;

            var ply = player?.Object as BasePlayer;
            if (ply == null || ply.IsDestroyed || ply.IsDead() || !ply.IsConnected || ply.IsSleeping()) return;

            var tpPos = Vector3.zero;
            var tpCh47 = args.Length > 0 ? args[0].Equals("ch47", StringComparison.OrdinalIgnoreCase) : false;
            if (!tpCh47)
            {
                if (!HasPerms(player.Id, "tpheli"))
                {
                    SendNoPerms(player);
                    return;
                }
                if (HeliInstance == null || HeliInstance?.transform == null)
                {
                    player.Message(GetMessage("noHelisFound", player.Id));
                    return;
                }
                if (HeliCount > 1)
                {
                    player.Message(string.Format(GetMessage("cannotBeCalled", player.Id), HeliCount.ToString("N0")));
                    return;
                }
                tpPos = HeliInstance.transform.position;
            }
            else
            {
                if (!HasPerms(player.Id, "tpch47"))
                {
                    SendNoPerms(player);
                    return;
                }
                if (CH47Instance == null || CH47Instance?.transform == null)
                {
                    player.Message(GetMessage("noHelisFound", player.Id));
                    return;
                }
                if (HeliCount > 1)
                {
                    player.Message(string.Format(GetMessage("cannotBeCalled", player.Id), HeliCount.ToString("N0")));
                    return;
                }
                tpPos = CH47Instance.transform.position;
            }

            if (tpPos == Vector3.zero)
            {
                player.Message(GetMessage("noHelisFound", player.Id));
                return;
            }
            TeleportPlayer(ply, GetGround(tpPos));
            player.Message(GetMessage("teleportedToHeli", player.Id));
        }

        private object CanPlayerCallHeli(BasePlayer player, bool ch47 = false)
        {
            if (player == null) return null;
            var permMsg = GetNoPerms(player.UserIDString);
            var callPerm = ch47 ? "callch47" : "callheli";
            var callMult = ch47 ? "callmultiplech47" : "callmultiple";
            var cooldownTime = GetLowestCooldown(player, ch47);
            var limit = GetHighestLimit(player, ch47);
            var now = DateTime.Now;
            var today = now.ToString("d");
            var cdd = GetCooldownInfo(player.userID);
            if (cdd == null)
            {
                cdd = new CooldownInfo(player);
                if (_cooldownData?.cooldownList != null) _cooldownData.cooldownList.Add(cdd);
            }
            var timesCalled = ch47 ? cdd.TimesCalledCH47 : cdd.TimesCalled;
            var lastCall = ch47 ? cdd.LastCallDayCH47 : cdd.LastCallDay;
            var coolTime = ch47 ? cdd.CooldownTimeCH47 : cdd.CooldownTime;
            if (limit < 1 && !IgnoreLimits(player) && !HasPerms(player.UserIDString, callPerm)) return permMsg;
            if (!IgnoreLimits(player) && limit > 0)
            {
                if (timesCalled >= limit && today == lastCall) return string.Format(GetMessage("callheliLimit", player.UserIDString), limit);
                else if (today != lastCall)
                {
                    if (ch47) cdd.TimesCalledCH47 = 0;
                    else cdd.TimesCalled = 0;
                }
            }
            if (!IgnoreCooldown(player) && cooldownTime > 0.0f && !string.IsNullOrEmpty(coolTime))
            {
                DateTime cooldownDT;
                if (!DateTime.TryParse(coolTime, out cooldownDT))
                {
                    PrintWarning("An error has happened while trying to parse date time ''" + coolTime + "''! Report this issue on plugin thread.");
                    return GetMessage("cmdError", player.UserIDString);
                }
                var diff = now - cooldownDT;
                if (diff.TotalSeconds < cooldownTime)
                {
                    var cooldownDiff = TimeSpan.FromSeconds(cooldownTime);
                    var waitedString = ReadableTimeSpan(diff);
                    var timeToWait = ReadableTimeSpan(cooldownDiff);
                    return string.Format(GetMessage("callheliCooldown", player.UserIDString), waitedString, timeToWait);
                }
            }
            if ((ch47 ? CH47Count : HeliCount) > 0 && !HasPerms(player.UserIDString, callMult)) return string.Format(GetMessage("cannotBeCalled", player.UserIDString), ch47 ? CH47Count : HeliCount);
            if (!ch47 && MaxActiveHelicopters >= 0 && (_PatrolHelicopters.Count + 1) > MaxActiveHelicopters) return string.Format(GetMessage("tooManyActiveHelis", player.UserIDString));

            return null;
        }


        [ChatCommand("callheli")]
        private void cmdCallToPlayer(BasePlayer player, string command, string[] args)
        {
            var argsStr = args.Length > 0 ? string.Join(" ", args) : string.Empty;
            try
            {
                var canCall = CanPlayerCallHeli(player) as string;
                if (!string.IsNullOrEmpty(canCall))
                {
                    SendReply(player, canCall);
                    return;
                }

                var now = DateTime.Now;
                var cdd = GetCooldownInfo(player.userID);
                if (cdd == null)
                {
                    cdd = new CooldownInfo(player);
                    _cooldownData.cooldownList.Add(cdd);
                }

                if (args.Length == 0)
                {
                    if (!HasPerms(player.UserIDString, "helicontrol.callheli"))
                    {
                        SendReply(player, GetNoPerms(player.UserIDString));
                        return;
                    }
                    var newHeli = callHeli();
                    if (!HasPerms(player.UserIDString, "helicontrol.dropcrates")) newHeli.maxCratesToSpawn = 0;
                    SendReply(player, GetMessage("heliCalled", player.UserIDString));
                    cdd.CooldownTime = now.ToString();
                    cdd.LastCallDay = now.ToString("d");
                    cdd.TimesCalled += 1;
                    return;
                }
                var ID = 0ul;
                var target = ulong.TryParse(args[0], out ID) ? FindPlayerByID(ID) : FindPlayerByPartialName(args[0]);
                if (target == null)
                {
                    SendReply(player, string.Format(GetMessage("playerNotFound", player.UserIDString), args[0]));
                    return;
                }

                if (target != null && HasPerms(player.UserIDString, "callheliself") && !HasPerms(player.UserIDString, "callhelitarget") && target != player)
                {
                    SendReply(player, string.Format(GetMessage("onlyCallSelf", player.UserIDString), player.displayName));
                    return;
                }
                if (target != null && !HasPerms(player.UserIDString, "callheliself") && !HasPerms(player.UserIDString, "callhelitarget"))
                {
                    SendReply(player, GetMessage("cantCallTargetOrSelf", player.UserIDString));
                    return;
                }

                var num = 1;
                if (args.Length == 2 && HasPerms(player.UserIDString, "callheli") && !int.TryParse(args[1], out num)) num = 1;

                var newHelis = callHelis(num, target.transform.position, setPositionAfterSpawn: SpawnHeliOnTarget);
                if (newHelis.Count > 0 && !permission.UserHasPermission(player.UserIDString, "helicontrol.dropcrates")) for (int i = 0; i < newHelis.Count; i++) newHelis[i].maxCratesToSpawn = 0;
                SendReply(player, string.Format(GetMessage("helisCalledPlayer", player.UserIDString), num, target.displayName));
                cdd.CooldownTime = now.ToString();
                cdd.TimesCalled += 1;
                cdd.LastCallDay = now.ToString("d");
            }
            catch (Exception ex)
            {
                var errorMsg = GetMessage("cmdError", player.UserIDString);
                if (!string.IsNullOrEmpty(errorMsg)) SendReply(player, errorMsg);
                PrintError("Error while using /callheli with args: " + argsStr + System.Environment.NewLine + ex.ToString());
            }
        }

        [ChatCommand("callch47")]
        private void cmdCallCH47(BasePlayer player, string command, string[] args)
        {
            var canCall = CanPlayerCallHeli(player, true) as string;
            if (!string.IsNullOrEmpty(canCall))
            {
                SendReply(player, canCall);
                return;
            }
            var now = DateTime.Now;
            var cdd = GetCooldownInfo(player.userID);
            if (cdd == null)
            {
                cdd = new CooldownInfo(player);
                _cooldownData.cooldownList.Add(cdd);
            }

            if (args.Length < 1)
            {
                callChinook();
                SendReply(player, GetMessage("heliCalled", player.UserIDString));
                cdd.CooldownTimeCH47 = now.ToString();
                cdd.LastCallDayCH47 = now.ToString("d");
                cdd.TimesCalledCH47 += 1;
                return;
            }
            ulong ID;
            var target = ulong.TryParse(args[0], out ID) ? FindPlayerByID(ID) : FindPlayerByPartialName(args[0]);
            if (target == null)
            {
                SendReply(player, string.Format(GetMessage("playerNotFound", player.UserIDString), args[0]));
                return;
            }
            if (target != null && HasPerms(player.UserIDString, "callch47self") && !HasPerms(player.UserIDString, "callch47target") && target != player)
            {
                SendReply(player, string.Format(GetMessage("onlyCallSelf", player.UserIDString), player.displayName));
                return;
            }
            if (target != null && !HasPerms(player.UserIDString, "callch47self") && !HasPerms(player.UserIDString, "callch47target"))
            {
                SendReply(player, GetMessage("cantCallTargetOrSelf", player.UserIDString));
                return;
            }
            var num = 1;
            if (args.Length == 2 && HasPerms(player.UserIDString, "callch47") && !int.TryParse(args[1], out num)) num = 1;

            callChinooks(num, target.transform.position);
            SendReply(player, string.Format(GetMessage("helisCalledPlayer", player.UserIDString), num, target.displayName));
            cdd.CooldownTimeCH47 = now.ToString();
            cdd.TimesCalledCH47 += 1;
            cdd.LastCallDayCH47 = now.ToString("d");
        }


        private void cmdKillHeli(IPlayer player, string command, string[] args)
        {
            if (!HasPerms(player.Id, "killheli"))
            {
                SendNoPerms(player);
                return;
            }
            var forced = args.Length > 0 ? args[0].Equals("forced", StringComparison.OrdinalIgnoreCase) : false;
            var numKilled = KillAllHelis(forced);
            player.Message(string.Format(GetMessage(forced ? "helisForceDestroyed" : "entityDestroyed", player.Id), numKilled.ToString("N0"), "helicopter"));
        }

        private void cmdKillCH47(IPlayer player, string command, string[] args)
        {
            if (!HasPerms(player.Id, "killch47"))
            {
                SendNoPerms(player);
                return;
            }
            var forced = args.Length > 0 ? args[0].Equals("forced", StringComparison.OrdinalIgnoreCase) : false;
            var numKilled = KillAllChinooks(forced);
            player.Message(string.Format(GetMessage(forced ? "helisForceDestroyed" : "entityDestroyed", player.Id), numKilled.ToString("N0"), "helicopter"));
        }

        private void cmdUpdateHelicopters(IPlayer player, string command, string[] args)
        {
            if (!HasPerms(player.Id, "update"))
            {
                SendNoPerms(player);
                return;
            }
            CheckHelicopter();
            if (HeliCount < 1 && CH47Count < 1)
            {
                player.Message(GetMessage("noHelisFound", player.Id));
                return;
            }
            var count = 0;

            foreach (var helicopter in _PatrolHelicopters)
            {
                if (helicopter == null) continue;
                UpdateHeli(helicopter, false);
                count++;
            }

            foreach (var ch47 in _chinooks)
            {
                if (ch47 == null) continue;
                UpdateChinook(ch47);
                count++;
            }

            player.Message(string.Format(GetMessage("updatedHelis", player.Id), count));
        }


        private void cmdStrafeHeli(IPlayer player, string command, string[] args)
        {
            if (!HasPerms(player.Id, "strafe"))
            {
                SendNoPerms(player);
                return;
            }
            if (HeliCount < 1)
            {
                player.Message(GetMessage("noHelisFound", player.Id));
                return;
            }
            var isAll = args.Length > 0 && args[0].Equals("all", StringComparison.OrdinalIgnoreCase);
            if (HeliCount > 1 && !isAll)
            {
                player.Message(string.Format(GetMessage("cannotBeCalled", player.Id), HeliCount));
                return;
            }
            if (args.Length < (isAll ? 2 : 1))
            {
                player.Message(string.Format(GetMessage("invalidSyntax", player.Id), "/strafe", "<player name>"));
                return;
            }

            var findArg = isAll ? args[1] : args[0];
            var target = FindPlayerByPartialName(findArg);
            ulong ID;
            if (ulong.TryParse(findArg, out ID)) target = FindPlayerByID(ID);
            if (target == null)
            {
                player.Message(string.Format(GetMessage("playerNotFound", player.Id), findArg));
                return;
            }
            var targPos = target?.transform?.position ?? Vector3.zero;
            if (isAll)
            {
                foreach (var heli in _PatrolHelicopters)
                {
                    var ai = heli?.GetComponent<PatrolHelicopterAI>() ?? null;
                    if (ai != null) StartStrafe(ai, targPos, ai.CanUseNapalm());
                }
            }
            else StartStrafe(HeliInstance, targPos, HeliInstance.CanUseNapalm());
            player.Message(string.Format(GetMessage("strafingOtherPosition", player.Id), target.displayName));
        }


        private void cmdDestChangeHeli(IPlayer player, string command, string[] args)
        {
            if (!HasPerms(player.Id, "destination") && !HasPerms(player.Id, "ch47destination"))
            {
                SendNoPerms(player);
                return;
            }
            if (args.Length < 1)
            {
                player.Message(string.Format(GetMessage("invalidSyntax", player.Id), "/strafe", "<player name>"));
                return;
            }
            var isCh47 = args.Last().Equals("ch47", StringComparison.OrdinalIgnoreCase);
            if ((isCh47 && !HasPerms(player.Id, "ch47destination")) || (!isCh47 && !HasPerms(player.Id, "destination")))
            {
                SendNoPerms(player);
                return;
            }
            if (isCh47 && CH47Count < 1)
            {
                player.Message(GetMessage("noHelisFound", player.Id));
                return;
            }
            else if (!isCh47 && HeliCount < 1)
            {
                player.Message(GetMessage("noHelisFound", player.Id));
                return;
            }

            var isAll = args.Length > 0 && args[0].Equals("all", StringComparison.OrdinalIgnoreCase);
            if (isAll && args.Length < 2)
            {
                player.Message(string.Format(GetMessage("invalidSyntax", player.Id), "/strafe", "<player name>"));
                return;
            }

            if ((isCh47 && CH47Count > 1 || !isCh47 && HeliCount > 1) && !isAll)
            {
                player.Message(string.Format(GetMessage("cannotBeCalled", player.Id), isCh47 ? CH47Count : HeliCount));
                return;
            }

            var findArg = isAll ? args[1] : args[0];
            var target = FindPlayerByPartialName(findArg);
            ulong ID;
            if (ulong.TryParse(findArg, out ID)) target = FindPlayerByID(ID);
            if (target == null)
            {
                player.Message(string.Format(GetMessage("playerNotFound", player.Id), findArg));
                return;
            }
            var targPos = target?.transform?.position ?? Vector3.zero;
            var newY = GetGround(targPos).y + 10f;
            if (newY > targPos.y) targPos.y = newY;
            if (isAll)
            {
                if (!isCh47)
                {
                    foreach (var heli in _PatrolHelicopters)
                    {
                        var ai = heli?.GetComponent<PatrolHelicopterAI>() ?? null;
                        if (ai != null) SetDestination(ai, targPos);
                    }
                }
                else foreach (var ch47 in _chinooks) SetDestination(ch47, targPos);
            }
            else
            {
                if (!isCh47) SetDestination(HeliInstance, targPos);
                else SetDestination(CH47Instance, targPos);
            }
            player.Message(string.Format(GetMessage("destinationOtherPosition", player.Id), target.displayName));
        }


        private void cmdKillFB(IPlayer player, string command, string[] args)
        {
            if (!HasPerms(player.Id, "killnapalm"))
            {
                SendNoPerms(player);
                return;
            }
            player.Message(string.Format(GetMessage("entityDestroyed", player.Id), KillAllFireballs().ToString("N0"), "fireball"));
        }


        private void cmdKillGibs(IPlayer player, string command, string[] args)
        {
            if (!HasPerms(player.Id, "killgibs"))
            {
                SendNoPerms(player);
                return;
            }
            player.Message(string.Format(GetMessage("entityDestroyed", player.Id), KillAllGibs().ToString("N0"), "helicopter gib"));
        }


        [ConsoleCommand("callheli")]
        private void consoleCallHeli(ConsoleSystem.Arg arg)
        {
            var player = arg?.Player() ?? null;
            if (player != null && !HasPerms(player.UserIDString, "callheli"))
            {
                SendNoPerms(player);
                return;
            }
            var userIDString = player?.UserIDString ?? string.Empty;
            var noDrop = (player != null) ? !HasPerms(player.UserIDString, "helicontrol.dropcrates") : false;
            List<PatrolHelicopter> newHelis;

            if (arg.Args == null || arg?.Args?.Length < 1)
            {
                var newHeli = callHeli();
                if (newHeli != null && noDrop) newHeli.maxCratesToSpawn = 0;
                SendReply(arg, GetMessage("heliCalled", userIDString));
                return;
            }

            var isPos = arg.Args[0].Equals("pos", StringComparison.OrdinalIgnoreCase);
            if (isPos && arg.Args.Length < 4)
            {
                SendReply(arg, "You must supply 3 args for coordinates!");
                return;
            }

            if (isPos)
            {
                var coords = default(Vector3);
                var callNum = 1;
                if (!float.TryParse(arg.Args[1], out coords.x))
                {
                    SendReply(arg, string.Format(GetMessage("invalidCoordinate", userIDString), "X"));
                    return;
                }
                if (!float.TryParse(arg.Args[2], out coords.y))
                {
                    SendReply(arg, string.Format(GetMessage("invalidCoordinate", userIDString), "Y"));
                    return;
                }
                if (!float.TryParse(arg.Args[3], out coords.z))
                {
                    SendReply(arg, string.Format(GetMessage("invalidCoordinate", userIDString), "Z"));
                    return;
                }
                if (!CheckBoundaries(coords.x, coords.y, coords.z))
                {
                    SendReply(arg, GetMessage("coordinatesOutOfBoundaries", userIDString));
                    return;
                }
                if (arg.Args.Length > 4) if (!int.TryParse(arg.Args[4], out callNum)) callNum = 1;
                newHelis = callHelis(callNum, coords, setPositionAfterSpawn: SpawnHeliOnTarget);
                if (newHelis.Count > 0 && noDrop) for (int i = 0; i < newHelis.Count; i++) newHelis[i].maxCratesToSpawn = 0;
                SendReply(arg, string.Format(GetMessage("helisCalledPlayer", userIDString), callNum, coords));
                return;
            }

            ulong ID;
            var target = ulong.TryParse(arg.Args[0], out ID) ? FindPlayerByID(ID) : FindPlayerByPartialName(arg.Args[0]);

            if (target == null)
            {
                SendReply(arg, string.Format(GetMessage("playerNotFound", userIDString), arg.Args[0]));
                return;
            }

            var num = 1;
            if (arg.Args.Length == 2 && !int.TryParse(arg.Args[1], out num)) num = 1;
            newHelis = callHelis(num, target?.transform?.position ?? Vector3.zero, setPositionAfterSpawn: SpawnHeliOnTarget);
            if (newHelis.Count > 0 && noDrop) for (int i = 0; i < newHelis.Count; i++) newHelis[i].maxCratesToSpawn = 0;
            SendReply(arg, string.Format(GetMessage("helisCalledPlayer", userIDString), num, target.displayName));
        }

        [ConsoleCommand("callch47")]
        private void consoleCallCH47(ConsoleSystem.Arg arg)
        {
            var player = arg?.Player() ?? null;
            if (player != null && !HasPerms(player.UserIDString, "callch47"))
            {
                SendNoPerms(player);
                return;
            }
            var userIDString = player?.UserIDString ?? string.Empty;

            if (arg.Args == null || arg.Args.Length < 1)
            {
                callChinook();
                SendReply(arg, GetMessage("heliCalled", userIDString));
                return;
            }
            var isPos = arg.Args[0].Equals("pos", StringComparison.OrdinalIgnoreCase);
            if (isPos && arg.Args.Length < 4)
            {
                SendReply(arg, "You must supply 3 args for coordinates!");
                return;
            }

            if (isPos)
            {
                var coords = default(Vector3);
                var callNum = 1;
                if (!float.TryParse(arg.Args[1], out coords.x))
                {
                    SendReply(arg, string.Format(GetMessage("invalidCoordinate", userIDString), "X"));
                    return;
                }
                if (!float.TryParse(arg.Args[2], out coords.y))
                {
                    SendReply(arg, string.Format(GetMessage("invalidCoordinate", userIDString), "Y"));
                    return;
                }
                if (!float.TryParse(arg.Args[3], out coords.z))
                {
                    SendReply(arg, string.Format(GetMessage("invalidCoordinate", userIDString), "Z"));
                    return;
                }
                if (!CheckBoundaries(coords.x, coords.y, coords.z))
                {
                    SendReply(arg, GetMessage("coordinatesOutOfBoundaries", userIDString));
                    return;
                }
                if (arg.Args.Length > 4) if (!int.TryParse(arg.Args[4], out callNum)) callNum = 1;
                callChinooks(callNum, coords);
                SendReply(arg, string.Format(GetMessage("helisCalledPlayer", userIDString), callNum, coords));
                return;
            }

            ulong ID;
            var target = ulong.TryParse(arg.Args[0], out ID) ? FindPlayerByID(ID) : FindPlayerByPartialName(arg.Args[0]);

            if (target == null)
            {
                SendReply(arg, string.Format(GetMessage("playerNotFound", userIDString), arg.Args[0]));
                return;
            }

            var num = 1;
            if (arg.Args.Length == 2 && !int.TryParse(arg.Args[1], out num)) num = 1;
            callChinooks(num, target?.transform?.position ?? Vector3.zero);
            SendReply(arg, string.Format(GetMessage("helisCalledPlayer", userIDString), num, target.displayName));
        }

        #endregion
        #region Util

        private TimeSpan GetNextHeliTime()
        {
            if (_lastTimerStart <= DateTime.MinValue || _lastSpawnTimer <= 0f)
                return TimeSpan.Zero;

            return _lastTimerStart.AddSeconds(_lastSpawnTimer) - DateTime.UtcNow;
        }

        private TimeSpan GetNextCH47Time()
        {
            if (_lastTimerStartCH47 <= DateTime.MinValue || _lastSpawnTimerCH47 <= 0f)
                return TimeSpan.Zero;
            

           return _lastTimerStartCH47.AddSeconds(_lastSpawnTimerCH47) - DateTime.UtcNow;
        }

        private Timer GetHeliSpawnTimer(float heliSpawnTime)
        {
            if (heliSpawnTime <= 0.0f) throw new ArgumentOutOfRangeException(nameof(heliSpawnTime));

            Timer newTimer = null;
            newTimer = timer.Once(heliSpawnTime, () =>
            {
                if (HeliCount < 1 || AutoCallIfExists)
                {
                    var helis = callHelis(HelicoptersToSpawn, forced: false);
                    if (helis != null && helis.Count > 0) _timerHeliId = helis[0]?.net?.ID ?? default(NetworkableId); //possible fix? i don't care much for it
                }

            });

            return newTimer;
        }

        private Timer GetChinookSpawnTimer(float chinookSpawnTime)
        {
            if (chinookSpawnTime <= 0.0f) throw new ArgumentOutOfRangeException(nameof(chinookSpawnTime));

            Timer newTimer = null;
            newTimer = timer.Once(chinookSpawnTime, () =>
            {
                if (CH47Count < 1 || AutoCallIfExistsCH47)
                {
                    var chinooks = callChinooks(ChinooksToSpawn, forced: false);
                    if (chinooks != null && chinooks.Count > 0) _timerCH47 = chinooks[0];
                }

            });

            return newTimer;
        }

        /// <summary>
        /// Adjusts the given amount of time (in seconds) to be in accord with when the server (re)started
        /// </summary>
        /// <param name="timeSecs"></param>
        /// <returns></returns>
        private float GetAdjustedSecondsToSpawn(float timeSecs)
        {
            if (timeSecs <= 0f) throw new ArgumentOutOfRangeException(nameof(timeSecs));

            var now = DateTime.UtcNow;

            var startTime = Facepunch.Math.Epoch.ToDateTime((long)(Facepunch.Math.Epoch.FromDateTime(now) - Time.realtimeSinceStartup));
            var useTime = startTime;

            var cur = 0;
            var max = 100;
            while (useTime < now)
            {
                useTime = useTime.AddSeconds(timeSecs);

                cur++;
                if (cur >= max)
                {
                    break;
                } //this should never happen, but in case, we don't want a stuck loop
            }


            return (float)(useTime - now).TotalSeconds; //t
        }

        private string ReadableTimeSpan(TimeSpan span, string stringFormat = "N0") //I'm sure some of you uMod code snobs absolutely LOVE this one
        {
            if (span == TimeSpan.MinValue) return string.Empty;
            var str = string.Empty;
            var repStr = stringFormat.StartsWith("0.0", StringComparison.CurrentCultureIgnoreCase) ? ("." + stringFormat.Replace("0.", string.Empty)) : "WORKAROUNDGARBAGETEXTTHATCANNEVERBEFOUNDINASTRINGTHISISTOPREVENTREPLACINGANEMPTYSTRINGFOROLDVALUEANDCAUSINGANEXCEPTION"; //this removes unnecessary values, for example for ToString("0.00"), 80.00 will show as 80 instead

            if (span.TotalHours >= 24)
            {

                var totalHoursWereGoingToShowToTheUserAsAString = (span.TotalHours - ((int)span.TotalDays * 24)).ToString(stringFormat).Replace(repStr, string.Empty);
                var totalHoursToShowAsNumber = (int)Math.Round(double.Parse(totalHoursWereGoingToShowToTheUserAsAString), MidpointRounding.AwayFromZero);
                var showHours = totalHoursToShowAsNumber < 24 && totalHoursToShowAsNumber > 0;

                str = (int)span.TotalDays + (!showHours && span.TotalHours > 24 ? 1 : 0) + " day" + (span.TotalDays >= 1.5 ? "s" : "") + (showHours ? (" " + totalHoursWereGoingToShowToTheUserAsAString + " hour(s)") : "");
            }
            else if (span.TotalMinutes > 60) str = (int)span.TotalHours + " hour" + (span.TotalHours >= 2 ? "s" : "") + " " + (span.TotalMinutes - ((int)span.TotalHours * 60)).ToString(stringFormat).Replace(repStr, string.Empty) + " minute(s)";
            else if (span.TotalMinutes > 1.0) str = span.Minutes + " minute" + (span.Minutes >= 2 ? "s" : "") + (span.Seconds < 1 ? "" : " " + span.Seconds + " second" + (span.Seconds >= 2 ? "s" : ""));
            if (!string.IsNullOrEmpty(str)) return str;
            return (span.TotalDays >= 1.0) ? span.TotalDays.ToString(stringFormat).Replace(repStr, string.Empty) + " day" + (span.TotalDays >= 1.5 ? "s" : "") : (span.TotalHours >= 1.0) ? span.TotalHours.ToString(stringFormat).Replace(repStr, string.Empty) + " hour" + (span.TotalHours >= 1.5 ? "s" : "") : (span.TotalMinutes >= 1.0) ? span.TotalMinutes.ToString(stringFormat).Replace(repStr, string.Empty) + " minute" + (span.TotalMinutes >= 1.5 ? "s" : "") : (span.TotalSeconds >= 1.0) ? span.TotalSeconds.ToString(stringFormat).Replace(repStr, string.Empty) + " second" + (span.TotalSeconds >= 1.5 ? "s" : "") : span.TotalMilliseconds.ToString("N0") + " millisecond" + (span.TotalMilliseconds >= 1.5 ? "s" : "");
        }

        private bool TeleportPlayer(BasePlayer player, Vector3 dest, bool distChecks = true, bool doSleep = true)
        {
            try
            {
                if (player == null || player?.transform == null) return false;
                var playerPos = player?.transform?.position ?? Vector3.zero;
                var isConnected = player?.IsConnected ?? false;
                var distFrom = Vector3.Distance(playerPos, dest);
                player.SetParent(null, false, false);

                if (distFrom >= 250 && isConnected && distChecks) player.ClientRPCPlayer(null, player, "StartLoading");
                if (doSleep && isConnected && !player.IsSleeping()) player.StartSleeping();
                player.MovePosition(dest);
                if (isConnected)
                {
                    player.ClientRPCPlayer(null, player, "ForcePositionTo", dest);
                    if (distFrom >= 250 && distChecks) player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, true);
                    player.UpdateNetworkGroup();
                    player.SendNetworkUpdate();
                    if (distFrom >= 50)
                    {
                        player.ClearEntityQueue();
                        player.SendFullSnapshot();
                    }
                }
                return true;
            }
            catch (Exception ex)
            {
                PrintError(ex.ToString());
                return false;
            }
        }

        private float GetRandomSpawnTime(bool ch47 = false)
        {
            if (!ch47) return (MinSpawnTime > 0 && MaxSpawnTime > 0 && MaxSpawnTime >= MinSpawnTime) ? UnityEngine.Random.Range(MinSpawnTime, MaxSpawnTime) : -1f;
            else return (MinSpawnTimeCH47 > 0 && MaxSpawnTimeCH47 > 0 && MaxSpawnTimeCH47 >= MinSpawnTimeCH47) ? UnityEngine.Random.Range(MinSpawnTimeCH47, MaxSpawnTimeCH47) : -1f;
        }

        private void StartStrafe(PatrolHelicopterAI heli, Vector3 target, bool useNapalm)
        {
            if (heli == null || !(heli?.IsAlive() ?? false) || (heli?._currentState ?? PatrolHelicopterAI.aiState.DEATH) == PatrolHelicopterAI.aiState.DEATH || target == Vector3.zero) return;
            heli.interestZoneOrigin = target;
            heli.ExitCurrentState();
            heli.State_Strafe_Enter(target, useNapalm);
        }

        private void SetDestination(PatrolHelicopterAI heli, Vector3 target)
        {
            if (heli == null || !heli.IsAlive() || (heli?._currentState ?? PatrolHelicopterAI.aiState.DEATH) == PatrolHelicopterAI.aiState.DEATH || target == Vector3.zero) return;
            heli.interestZoneOrigin = target;
            heli.ExitCurrentState();
            heli.State_Move_Enter(target);
        }

        private void SetDestination(CH47HelicopterAIController heli, Vector3 target)
        {
            if (heli == null || heli.IsDestroyed || heli.gameObject == null || heli.IsDead() || target == Vector3.zero) return;
            heli.SetMoveTarget(target);

            var brain = heli?.GetComponent<CH47AIBrain>() ?? null;
            if (brain != null) brain.mainInterestPoint = target;
        }

        private void ToggleCH47Event(bool value)
        {
            var eventPrefabs = EventPrefabs;
            for (int i = 0; i < eventPrefabs.Length; i++)
            {
                var eve = eventPrefabs[i];
                if (eve?.targetPrefab?.resourceID == CHINOOK_EVENT_PREFAB_ID)
                {
                    eve.gameObject.SetActive(value);
                    break;
                }
            }
        }

        private void ToggleHeliEvent(bool value)
        {
            var eventPrefabs = EventPrefabs;
            for (int i = 0; i < eventPrefabs.Length; i++)
            {
                var eve = eventPrefabs[i];
                if (eve?.targetPrefab?.resourceID == HELI_EVENT_PREFAB_ID)
                {
                    eve.gameObject.SetActive(value);
                    break;
                }
            }
        }

        private Action _checkHelicopter = null;
        private Action CheckHelicopter
        {
            get
            {
                if (_checkHelicopter == null)
                {
                    _checkHelicopter = new Action(() =>
                    {
                        _PatrolHelicopters.RemoveWhere(p => p?.IsDestroyed ?? true);
                        _chinooks.RemoveWhere(p => p?.IsDestroyed ?? true);
                        _gibs.RemoveWhere(p => p?.IsDestroyed ?? true);
                        _fireBalls.RemoveWhere(p => p?.IsDestroyed ?? true);
                        _forceCalled.RemoveWhere(p => p?.IsDestroyed ?? true);
                        _forceCalledCh.RemoveWhere(p => p?.IsDestroyed ?? true);
                        _lockedCrates.RemoveWhere(p => p?.IsDestroyed ?? true);
                    });
                }

                return _checkHelicopter;
            }
        }

        private void UnlockCrate(LockedByEntCrate crate)
        {
            if (crate == null || crate.IsDestroyed || crate.gameObject == null) return;
            var lockingEnt = (crate?.lockingEnt != null) ? crate.lockingEnt.GetComponent<FireBall>() : null;
            if (lockingEnt != null && !lockingEnt.IsDestroyed)
            {
                lockingEnt.Extinguish();
                //lockingEnt.CancelInvoke(lockingEnt.Extinguish);
               // lockingEnt.Invoke(lockingEnt.Extinguish, 30f);
            }

            crate.CancelInvoke(crate.Think);
            crate.SetLocked(false);
            crate.lockingEnt = null;
        }

        private void UnlockCrate(HackableLockedCrate crate)
        {
            if (crate == null || crate.IsDestroyed) return;
            crate.SetFlag(BaseEntity.Flags.Reserved1, true);
            crate.SetFlag(BaseEntity.Flags.Reserved2, true);
            crate.isLootable = true;
            crate.CancelInvoke(new Action(crate.HackProgress));
        }

        private int HeliCount { get { return _PatrolHelicopters?.Count ?? 0; } }

        private int CH47Count { get { return _chinooks?.Count ?? 0; } }

        private CooldownInfo GetCooldownInfo(ulong userId) //iterating here isn't optimal for performance, but it's old code
        {
            if (_cooldownData?.cooldownList != null)
            {
                for (int i = 0; i < _cooldownData.cooldownList.Count; i++)
                {
                    var cd = _cooldownData.cooldownList[i];
                    if (cd?.UserID == userId) return cd;
                }
            }
            return null;
        }

        private void SendNoPerms(IPlayer player) => player?.Message(GetMessage("noPerms", player.Id));
        private void SendNoPerms(BasePlayer player) { if (player != null && player.IsConnected) player.ChatMessage(GetMessage("noPerms", player.UserIDString)); }
        private string GetNoPerms(string userID = "") { return GetMessage("noPerms", userID); }

        //**Borrowed from Nogrod's NTeleportation, with permission**//
        private Vector3 GetGround(Vector3 sourcePos)
        {
            var oldPos = sourcePos;
            sourcePos.y = TerrainMeta.HeightMap.GetHeight(sourcePos);
            RaycastHit hitinfo;
            if (Physics.SphereCast(oldPos, .1f, Vector3.down, out hitinfo, 300f, _groundLayer)) sourcePos.y = hitinfo.point.y;
            return sourcePos;
        }

        public static Vector3 GetVector3FromString(string vectorStr)
        {
            if (string.IsNullOrEmpty(vectorStr)) return Vector3.zero;

            var sb = Facepunch.Pool.Get<StringBuilder>();
            try
            {
                var split = sb.Clear().Append(vectorStr).Replace("(", string.Empty).Replace(")", string.Empty).ToString().Split(',');
                return new Vector3(Convert.ToSingle(split[0]), Convert.ToSingle(split[1]), Convert.ToSingle(split[2]));
            }
            finally { Facepunch.Pool.Free(ref sb); }
        }

        private int KillAllFireballs()
        {
            CheckHelicopter();
            var countfb = 0;
            if (_fireBalls.Count < 1) return countfb;

            var fbs = new List<FireBall>(_fireBalls);
            for (int i = 0; i < fbs.Count; i++)
            {
                var fb = fbs[i];
                if (fb != null && !fb.IsDestroyed)
                {
                    fb.Kill();
                    countfb++;
                }
            }

            CheckHelicopter();
            return countfb;
        }

        private int KillAllGibs()
        {
            CheckHelicopter();
            var countgib = 0;
            if (_gibs.Count < 1) return countgib;

            var gibs = new List<HelicopterDebris>(_gibs);
            for (int i = 0; i < gibs.Count; i++)
            {
                var gib = gibs[i];
                if (gib != null && !gib.IsDestroyed)
                {
                    gib.Kill();
                    countgib++;
                }
            }

            CheckHelicopter();
            return countgib;
        }

        private T GetConfig<T>(string name, T defaultValue)
        {
            if (string.IsNullOrEmpty(name)) throw new ArgumentNullException(nameof(name));

            if (Config[name] == null)
            {
                SetConfig(name, defaultValue);

                return defaultValue;
            }

            return (T)Convert.ChangeType(Config[name], typeof(T));
        }

        private void SetConfig<T>(string name, T value)
        {
            if (string.IsNullOrEmpty(name)) throw new ArgumentNullException(nameof(name));

            Config[name] = value;

            _configChanged = true;
        }

        private bool HasPerms(string userId, string perm)
        {
            if (string.IsNullOrEmpty(userId)) throw new ArgumentNullException(nameof(userId));
            if (string.IsNullOrEmpty(perm)) throw new ArgumentNullException(nameof(perm));

            if (userId.Equals("server_console", StringComparison.OrdinalIgnoreCase) || permission.UserHasPermission(userId, "helicontrol.admin")) return true;

            var sb = Facepunch.Pool.Get<StringBuilder>();
            try { return permission.UserHasPermission(userId, !perm.StartsWith("helicontrol") ? sb.Clear().Append("helicontrol.").Append(perm).ToString() : perm); }
            finally { Facepunch.Pool.Free(ref sb); }
        }

        private int Fitness(string individual, string target)
        {
            var count = 0;
            var range = Enumerable.Range(0, Math.Min(individual.Length, target.Length));
            foreach (var i in range)
            {
                if (individual[i] == target[i]) count++;
            }
            return count;
        }

        private int ExactMatch(string comp1, string comp2, StringComparison options = StringComparison.CurrentCulture)
        {
            if (string.IsNullOrEmpty(comp1) || string.IsNullOrEmpty(comp2)) return 0;
            var val = 0;


            if (comp1.Length > 0 && comp2.Length > 0)
            {
                for (int i = 0; i < comp1.Length; i++)
                {
                    if ((comp2.Length - 1) >= i)
                    {
                        if (comp2[i].ToString().Equals(comp1[i].ToString(), options)) val++;
                    }
                }
            }

            return val;
        }

        public const string VALID_CHARACTERS = @"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-=[]{}\|\'\"",./`*!@#$%^&*()_+<>?~;: "; //extra space at end is to allow space as a valid character

        public string[] GetValidCharactersString()
        {
            var length = VALID_CHARACTERS.Length;
            var array = new string[length];
            for (int i = 0; i < length; i++) array[i] = VALID_CHARACTERS[i].ToString();
            return array;
        }

        private string CleanPlayerName(string str)
        {
            if (string.IsNullOrEmpty(str)) throw new ArgumentNullException(nameof(str));
            var strSB = new StringBuilder();
            var valid = GetValidCharactersString();
            for (int i = 0; i < str.Length; i++)
            {
                var chrStr = str[i].ToString();
                var skip = true;
                for (int j = 0; j < valid.Length; j++)
                {
                    var v = valid[j];
                    if (v.Equals(chrStr, StringComparison.OrdinalIgnoreCase))
                    {
                        skip = false;
                        break;
                    }
                }
                if (!skip) strSB.Append(chrStr);
            }
            return strSB.ToString().TrimStart().TrimEnd();
        }

        /// <summary>
        /// Finds a player using their entire or partial name. Entire names take top priority & will be returned over a partial match.
        /// </summary>
        /// <exception cref="ArgumentNullException"></exception>
        /// <param name="name"></param>
        /// <param name="sleepers"></param>
        /// <returns></returns>
        private BasePlayer FindPlayerByPartialName(string name, bool sleepers = false)
        {
            if (string.IsNullOrEmpty(name)) throw new ArgumentNullException(nameof(name));
            var matches = Facepunch.Pool.GetList<BasePlayer>();
            try
            {
                BasePlayer player = null;
                for (int i = 0; i < BasePlayer.activePlayerList.Count; i++)
                {
                    var p = BasePlayer.activePlayerList[i];
                    if (p == null) continue;
                    var pName = p?.displayName ?? string.Empty;
                    var cleanName = CleanPlayerName(pName);
                    if (!string.IsNullOrEmpty(cleanName)) pName = cleanName;
                    if (string.Equals(pName, name, StringComparison.OrdinalIgnoreCase))
                    {
                        if (player != null) return null;
                        player = p;
                        return player;
                    }

                }
                if (sleepers)
                {
                    for (int i = 0; i < BasePlayer.sleepingPlayerList.Count; i++)
                    {
                        var p = BasePlayer.sleepingPlayerList[i];
                        if (p == null) continue;
                        var pName = p?.displayName ?? string.Empty;
                        var cleanName = CleanPlayerName(pName);
                        if (!string.IsNullOrEmpty(cleanName)) pName = cleanName;
                        if (string.Equals(pName, name, StringComparison.OrdinalIgnoreCase))
                        {
                            if (player != null) return null;
                            player = p;
                            return player;
                        }
                    }
                }
                for (int i = 0; i < BasePlayer.activePlayerList.Count; i++)
                {
                    var p = BasePlayer.activePlayerList[i];
                    if (p == null) continue;
                    var pName = p?.displayName ?? string.Empty;
                    var cleanName = CleanPlayerName(pName);
                    if (!string.IsNullOrEmpty(cleanName)) pName = cleanName;
                    if (pName.IndexOf(name, StringComparison.OrdinalIgnoreCase) >= 0)
                    {
                        matches.Add(p);
                    }
                }
                if (sleepers)
                {

                    for (int i = 0; i < BasePlayer.sleepingPlayerList.Count; i++)
                    {
                        var p = BasePlayer.sleepingPlayerList[i];
                        if (p == null) continue;
                        var pName = p?.displayName ?? string.Empty;
                        var cleanName = CleanPlayerName(pName);
                        if (!string.IsNullOrEmpty(cleanName)) pName = cleanName;
                        if (pName.IndexOf(name, StringComparison.OrdinalIgnoreCase) >= 0)
                        {
                            matches.Add(p);
                        }
                    }
                }
                var topMatch = matches?.OrderByDescending(p => ExactMatch(CleanPlayerName(p?.displayName) ?? p?.displayName, name, StringComparison.OrdinalIgnoreCase)) ?? null;
                if (topMatch != null && topMatch.Any())
                {
                    var exactMatches = matches?.Select(p => ExactMatch(CleanPlayerName(p?.displayName) ?? p?.displayName, name, StringComparison.OrdinalIgnoreCase))?.OrderByDescending(p => p) ?? null;
                    if (exactMatches.All(p => p == 0))
                    {
                        topMatch = matches?.OrderByDescending(p => Fitness(CleanPlayerName(p?.displayName) ?? p?.displayName, name)) ?? null;
                    }
                }
                player = topMatch?.FirstOrDefault() ?? null;
                return player;
            }
            finally { Facepunch.Pool.FreeList(ref matches); }
        }

        /// <summary>
        /// Finds a player using their entire or partial name. Entire names take top priority & will be returned over a partial match.
        /// </summary>
        /// <exception cref="ArgumentNullException"></exception>
        /// <param name="name"></param>
        /// <param name="sleepers"></param>
        /// <returns></returns>
        private BasePlayer FindPlayerByPartialName(string name, bool sleepers = false, params BasePlayer[] ignore)
        {
            if (string.IsNullOrEmpty(name)) throw new ArgumentNullException(nameof(name));

            var matches = Facepunch.Pool.GetList<BasePlayer>();
            try
            {
                BasePlayer player = null;

                for (int i = 0; i < BasePlayer.activePlayerList.Count; i++)
                {
                    var p = BasePlayer.activePlayerList[i];
                    if (p == null || (ignore != null && ignore.Length > 0 && ignore.Contains(p))) continue;
                    var pName = p?.displayName ?? string.Empty;
                    var cleanName = CleanPlayerName(pName);
                    if (!string.IsNullOrEmpty(cleanName)) pName = cleanName;
                    if (string.Equals(pName, name, StringComparison.OrdinalIgnoreCase))
                    {
                        if (player != null) return null;
                        player = p;
                        return player;
                    }

                }

                if (sleepers)
                {
                    for (int i = 0; i < BasePlayer.sleepingPlayerList.Count; i++)
                    {
                        var p = BasePlayer.sleepingPlayerList[i];
                        if (p == null || (ignore != null && ignore.Length > 0 && ignore.Contains(p))) continue;
                        var pName = p?.displayName ?? string.Empty;
                        var cleanName = CleanPlayerName(pName);
                        if (!string.IsNullOrEmpty(cleanName)) pName = cleanName;
                        if (string.Equals(pName, name, StringComparison.OrdinalIgnoreCase))
                        {
                            if (player != null) return null;
                            player = p;
                            return player;
                        }
                    }
                }

                for (int i = 0; i < BasePlayer.activePlayerList.Count; i++)
                {
                    var p = BasePlayer.activePlayerList[i];
                    if (p == null || ignore.Contains(p)) continue;
                    var pName = p?.displayName ?? string.Empty;
                    var cleanName = CleanPlayerName(pName);
                    if (!string.IsNullOrEmpty(cleanName)) pName = cleanName;
                    if (pName.IndexOf(name, StringComparison.OrdinalIgnoreCase) >= 0)
                    {
                        matches.Add(p);
                    }
                }

                if (sleepers)
                {

                    for (int i = 0; i < BasePlayer.sleepingPlayerList.Count; i++)
                    {
                        var p = BasePlayer.sleepingPlayerList[i];
                        if (p == null || ignore.Contains(p)) continue;
                        var pName = p?.displayName ?? string.Empty;
                        var cleanName = CleanPlayerName(pName);
                        if (!string.IsNullOrEmpty(cleanName)) pName = cleanName;
                        if (pName.IndexOf(name, StringComparison.OrdinalIgnoreCase) >= 0)
                        {
                            matches.Add(p);
                        }
                    }
                }

                var topMatch = matches?.OrderByDescending(p => ExactMatch(CleanPlayerName(p?.displayName) ?? p?.displayName, name)) ?? null;
                if (topMatch != null && topMatch.Any())
                {
                    var exactMatches = matches?.Select(p => ExactMatch(CleanPlayerName(p?.displayName) ?? p?.displayName, name))?.OrderByDescending(p => p) ?? null;
                    if (exactMatches.All(p => p == 0))
                    {
                        topMatch = matches?.OrderByDescending(p => Fitness(CleanPlayerName(p?.displayName) ?? p?.displayName, name)) ?? null;
                    }
                }

                return topMatch?.FirstOrDefault() ?? null;
            }
            finally { Facepunch.Pool.FreeList(ref matches); }
        }

        private BasePlayer FindPlayerByID(ulong userID) { return BasePlayer.FindByID(userID) ?? BasePlayer.FindSleeping(userID) ?? null; }

        private void RemoveFromWorld(Item item)
        {
            if (item == null) return;
            item.RemoveFromWorld();
            item.RemoveFromContainer();
            item.Remove();
        }

        //CheckBoundaries taken from Nogrod's NTeleportation, with permission
        private bool CheckBoundaries(float x, float y, float z) { return x <= _boundary && x >= -_boundary && y < 2000 && y >= -100 && z <= _boundary && z >= -_boundary; }

        private float GetLowestCooldown(BasePlayer player, bool ch47 = false) //TO DO: CLEANUP THIS AND THE LIMITS METHOD BELOW IT
        {
            var perms = Facepunch.Pool.GetList<string>();
            var time = -1f;
            try
            {
                var getPerms = permission.GetUserPermissions(player.UserIDString);
                if (getPerms != null && getPerms.Length > 0)
                {
                    var sb = Facepunch.Pool.Get<StringBuilder>();
                    try
                    {
                        for (int i = 0; i < getPerms.Length; i++)
                        {
                            var perm = getPerms[i];

                            if ((!ch47 && perm.IndexOf("helicontrol.cooldown.", StringComparison.OrdinalIgnoreCase) >= 0) || (ch47 && perm.IndexOf("helicontrol.cooldown.ch47", StringComparison.OrdinalIgnoreCase) >= 0))
                            {
                                perms.Add(sb.Clear().Append(perm).Replace("helicontrol.", string.Empty).ToString());
                            }
                        }
                    }
                    finally { Facepunch.Pool.Free(ref sb); }
                }

                if (perms.Count > 0)
                {
                    var nums = Facepunch.Pool.GetList<float>();
                    try
                    {
                        for (int i = 0; i < perms.Count; i++)
                        {
                            var perm = perms[i];
                            float tempTime;

                            if (!Cds.TryGetValue(perm, out tempTime))
                            {
                                PrintWarning("Cooldowns dictionary does not contain: " + perm);
                                continue;
                            }

                            nums.Add(tempTime);
                        }

                        if (nums.Count > 0)
                        {
                            var lowest = -1f;
                            var last = 0f;
                            foreach (var num in nums)
                            {
                                last = num;
                                if (lowest < 0f || last < lowest) lowest = last;
                            }
                            time = lowest;
                        }
                    }
                    finally { Facepunch.Pool.FreeList(ref nums); }
                }

                return time;
            }
            finally { Facepunch.Pool.FreeList(ref perms); }
        }

        private int GetHighestLimit(BasePlayer player, bool ch47 = false)
        {
            var perms = Facepunch.Pool.GetList<string>();
            var limit = -1;
            try
            {
                var getPerms = permission.GetUserPermissions(player.UserIDString);
                if (getPerms != null && getPerms.Length > 0)
                {
                    var sb = Facepunch.Pool.Get<StringBuilder>();
                    try
                    {
                        for (int i = 0; i < getPerms.Length; i++)
                        {
                            var perm = getPerms[i];

                            if ((!ch47 && perm.IndexOf("helicontrol.limit.", StringComparison.OrdinalIgnoreCase) >= 0) || (ch47 && perm.IndexOf("helicontrol.limit.ch47", StringComparison.OrdinalIgnoreCase) >= 0))
                            {
                                perms.Add(sb.Clear().Append(perm).Replace("helicontrol.", string.Empty).ToString());
                            }
                        }
                    }
                    finally { Facepunch.Pool.Free(ref sb); }
                }

                if (perms.Count > 0)
                {
                    var nums = Facepunch.Pool.GetList<int>();
                    try
                    {
                        for (int i = 0; i < perms.Count; i++)
                        {
                            var perm = perms[i];
                            int tempInt;

                            if (!Limits.TryGetValue(perm, out tempInt))
                            {
                                PrintWarning("Limits dictionary does not contain: " + perm);
                                continue;
                            }

                            nums.Add(tempInt);
                        }

                        if (nums.Count > 0)
                        {
                            var highest = 0;
                            var last = 0;
                            foreach (var num in nums)
                            {
                                last = num;
                                if (last > highest) highest = last;
                            }
                            limit = highest;
                        }
                        return limit;
                    }
                    finally { Facepunch.Pool.FreeList(ref nums); }
                }

                return limit;
            }
            finally { Facepunch.Pool.FreeList(ref perms); }
        }

        private bool IgnoreCooldown(BasePlayer player) { return HasPerms(player.UserIDString, "helicontrol.ignorecooldown"); }

        private bool IgnoreLimits(BasePlayer player) { return HasPerms(player.UserIDString, "helicontrol.ignorelimits"); }


        #endregion
        #region Classes

        private class StoredData
        {
            public List<BoxInventory> HeliInventoryLists = new List<BoxInventory>();
            public StoredData() { }
        }

        private class StoredData2
        {
            public Dictionary<string, float> WeaponList = new Dictionary<string, float>();
            public StoredData2() { }
        }

        private class StoredData3
        {
            public List<CooldownInfo> cooldownList = new List<CooldownInfo>();
            public StoredData3() { }
        }

        public class HelicopterSpawn
        {
            public enum HeliType { Patrol, Chinook };
            public HeliType Type = HeliType.Patrol;

            [JsonRequired]
            private string _pos = string.Empty;

            [JsonIgnore]
            public Vector3 Position
            {
                get { return string.IsNullOrEmpty(_pos) ? Vector3.zero : GetVector3FromString(_pos); }
                set { _pos = value.ToString(); }
            }

            public string Name { get; set; } = string.Empty;

            public HelicopterSpawn() { }
            public HelicopterSpawn(Vector3 position, HeliType type)
            {
                Position = position;
                Type = type;
            }

        }

        private class StoredData4 //unnecessary class, but changing would likely break existing configurations
        {
            public List<HelicopterSpawn> HelicopterSpawns = new List<HelicopterSpawn>();
            public StoredData4() { }
        }

        public HelicopterSpawn FindSpawn(string name, StringComparison comparison = StringComparison.Ordinal)
        {
            if (!string.IsNullOrEmpty(name) && _spawnsData?.HelicopterSpawns != null)
            {
                for (int i = 0; i < _spawnsData.HelicopterSpawns.Count; i++)
                {
                    var spawn = _spawnsData.HelicopterSpawns[i];
                    if (spawn?.Name?.Equals(name, comparison) ?? false) return spawn;
                }
            }
            return null;
        }

        private class CooldownInfo
        {
            public string LastCallDay { get; set; }

            public string CooldownTime { get; set; }

            public int TimesCalled { get; set; }

            public string LastCallDayCH47 { get; set; } = string.Empty;

            public string CooldownTimeCH47 { get; set; } = string.Empty;

            public int TimesCalledCH47 { get; set; }

            public ulong UserID { get; set; }

            public CooldownInfo() { }

            public CooldownInfo(BasePlayer newPlayer) { UserID = newPlayer?.userID ?? 0; }

            public CooldownInfo(string userID)
            {
                ulong newUID;
                if (ulong.TryParse(userID, out newUID)) UserID = newUID;
            }

            public CooldownInfo(ulong userID) { UserID = userID; }

        }

        private class BoxInventory
        {
            public List<ItemDef> lootBoxContents = new List<ItemDef>();

            public BoxInventory() { }

            public BoxInventory(List<ItemDef> list) { lootBoxContents = list; }

            public BoxInventory(List<Item> list)
            {
                if (list == null || list.Count < 1) return;
                for (int i = 0; i < list.Count; i++)
                {
                    var item = list[i];
                    if (item == null) continue;

                    lootBoxContents.Add(new ItemDef(item.info.shortname, item.amount, item.skin));
                }
            }

            public BoxInventory(string name, int amount, int amountMin = 0, int amountMax = 0, ulong skinID = 0)
            {
                if (amountMin > 0 && amountMax > 0) amount = UnityEngine.Random.Range(amountMin, amountMax);
                lootBoxContents.Add(new ItemDef(name, amount, skinID));
            }

        }

        private class ItemDef
        {
            public string name;
            public int amountMin;
            public int amountMax;
            public int amount;
            public ulong skinID;

            public ItemDef() { }

            public ItemDef(string name, int amount, ulong skinID = 0)
            {
                this.name = name;
                this.amount = amount;
                this.skinID = skinID;
            }
        }
        #endregion
        #region Data
        private void LoadLootData()
        {
            _lootData = Interface.Oxide?.DataFileSystem?.ReadObject<StoredData>("HeliControlData") ?? null;
            var count = _lootData?.HeliInventoryLists?.Count ?? 0;
            //Create a default data file if there was none:
            if (_lootData == null || _lootData.HeliInventoryLists == null || count < 1)
            {
                Puts("No Lootdrop Data found, creating new file...");
                _lootData = new StoredData();
                BoxInventory inv;
                inv = new BoxInventory("rifle.ak", 1);
                inv.lootBoxContents.Add(new ItemDef("ammo.rifle.hv", 128));
                _lootData.HeliInventoryLists.Add(inv);

                inv = new BoxInventory("rifle.bolt", 1);
                inv.lootBoxContents.Add(new ItemDef("ammo.rifle.hv", 128));
                _lootData.HeliInventoryLists.Add(inv);

                inv = new BoxInventory("explosive.timed", 3);
                inv.lootBoxContents.Add(new ItemDef("ammo.rocket.hv", 3));
                _lootData.HeliInventoryLists.Add(inv);

                inv = new BoxInventory("lmg.m249", 1);
                inv.lootBoxContents.Add(new ItemDef("ammo.rifle", 100));
                _lootData.HeliInventoryLists.Add(inv);

                inv = new BoxInventory("rifle.lr300", 1);
                inv.lootBoxContents.Add(new ItemDef("ammo.rifle", 100));
                _lootData.HeliInventoryLists.Add(inv);

                SaveLootData();
            }
            else
            {
                var invalidSB = new StringBuilder();
                for (int i = 0; i < _lootData.HeliInventoryLists.Count; i++)
                {
                    var inv = _lootData.HeliInventoryLists[i];
                    if (inv == null || inv?.lootBoxContents == null || inv.lootBoxContents.Count < 1) continue;
                    for (int j = 0; j < inv.lootBoxContents.Count; j++)
                    {
                        var content = inv.lootBoxContents[j];
                        if (content == null) continue;
                        var findDef = ItemManager.FindItemDefinition(content.name);
                        if (findDef == null) invalidSB.AppendLine("Invalid item name in loot table: ").Append(content.name);
                    }
                }
                if (invalidSB.Length > 0) PrintWarning(invalidSB.ToString());
            }
        }

        private void LoadWeaponData()
        {
            _weaponsData = Interface.Oxide?.DataFileSystem?.ReadObject<StoredData2>("HeliControlWeapons") ?? null;
            var count = _weaponsData?.WeaponList?.Count ?? 0;
            if (_weaponsData == null || _weaponsData.WeaponList == null || count < 1)
            {
                Puts("No weapons data found, creating new file...");
                _weaponsData = new StoredData2();
                var itemDefs = ItemManager.itemList;
                if (itemDefs != null && itemDefs.Count > 0)
                {
                    for (int i = 0; i < itemDefs.Count; i++)
                    {
                        var itemdef = itemDefs[i];
                        if (itemdef == null) continue;
                        var category = itemdef.category;
                        if (category != ItemCategory.Weapon) continue;
                        var shortName = itemdef.shortname;
                        var englishName = itemdef.displayName?.english ?? shortName;
                        if (!shortName.Contains("weapon.mod")) _weaponsData.WeaponList[englishName] = 1f;
                    }
                }
                SaveWeaponData();
            }
        }

        private void LoadHeliSpawns() => _spawnsData = Interface.Oxide?.DataFileSystem?.ReadObject<StoredData4>("HeliControlSpawns") ?? new StoredData4();


        private void SaveLootData() => Interface.Oxide.DataFileSystem.WriteObject("HeliControlData", _lootData);
        private void SaveWeaponData() => Interface.Oxide.DataFileSystem.WriteObject("HeliControlWeapons", _weaponsData);
        private void SaveCooldownData() => Interface.Oxide.DataFileSystem.WriteObject("HeliControlCooldowns", _cooldownData);
        private void SaveSpawnData() => Interface.Oxide.DataFileSystem.WriteObject("HeliControlSpawns", _spawnsData);
    }
    #endregion
}


// --- End of file: HeliControl.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/high-wall-barricades ---
// --- Original File Path: H/HighWallBarricades/HighWallBarricades.cs ---

using System.Collections;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;
using Oxide.Core;
using Rust;
using UnityEngine;
using Random = UnityEngine.Random;

namespace Oxide.Plugins
{
	[Info("High Wall Barricades", "2CHEVSKII", "2.3.1")]
	[Description("Makes hgih external walls decay")]
	public class HighWallBarricades : RustPlugin
	{
		#region -Component-

		private class BarricadeDecay : FacepunchBehaviour
		{
			private float defaultProtection;
			private float lastTickTime;

			private DecayEntity Barricade { get; set; }

			void Start()
			{
				Barricade = GetComponent<DecayEntity>();

				if(Singleton.Settings.InitialHealth <= 0f)
				{
					Invoke(() => Barricade.Kill(BaseNetworkable.DestroyMode.Gib), 0.5f);

					return;
				}

				UpdateTickTime();

				defaultProtection = Barricade.baseProtection.Get(DamageType.Decay);

				if(Singleton.Settings.DisableStandartDecay)
					Barricade.baseProtection.amounts[(int)DamageType.Decay] = 100;

				Singleton.Barricades.Add(this);

				InvokeRandomized(CheckDecay, 1f, 0f, Random.Range(15f, 45f));
			}

			private void CheckDecay()
			{
				if(Barricade.GetBuildingPrivilege() == null)
				{
					TickDecay();

					return;
				}

				if(!Singleton.Settings.DecayInCupRange)
				{
					UpdateTickTime();

					return;
				}

				if(!Singleton.Settings.CheckBarricadeOwner)
				{
					TickDecay();

					return;
				}

				if(!Barricade.GetBuildingPrivilege().authorizedPlayers.Any(x => x.userid == Barricade.OwnerID))
				{
					TickDecay();

					return;
				}

				UpdateTickTime();
			}

			public void RemoveComponent() => DestroyImmediate(this);

			private void UpdateTickTime() => lastTickTime = Time.realtimeSinceStartup;

			private void TickDecay()
			{
				if(Time.realtimeSinceStartup - lastTickTime < Singleton.Settings.DecayTime) return;

				Barricade.health -= Barricade.MaxHealth() * (Singleton.Settings.DecayDamage * Mathf.FloorToInt((Time.realtimeSinceStartup - lastTickTime) / Singleton.Settings.DecayTime));

				if(Barricade.healthFraction <= 0) Invoke(() => Barricade.Kill(BaseNetworkable.DestroyMode.Gib), 0.5f);

				Barricade.SendNetworkUpdate();
				UpdateTickTime();
			}

			private void OnDestroy()
			{
				ServerMgr.Instance.Invoke(() =>
				{
					if(Singleton.Barricades.Contains(this))
					{
						Singleton.Barricades.Remove(this);
					}
				}, 1f);
				Barricade.baseProtection.amounts[(int)DamageType.Decay] = defaultProtection;
			}
		}

		#endregion

		#region -Fields-

		private Configuration Settings { get; set; }

		private static HighWallBarricades Singleton { get; set; }

		private HashSet<BarricadeDecay> Barricades { get; set; }

		#endregion

		#region -Configuration-

		private class Configuration
		{
			[JsonProperty(PropertyName = "Time between decay ticks")]
			internal int DecayTime { get; set; }

			[JsonProperty(PropertyName = "Decay tick damage")]
			internal float DecayDamage { get; set; }

			[JsonProperty(PropertyName = "Barricade initial health")]
			internal float InitialHealth { get; set; }

			[JsonProperty(PropertyName = "Should barricades decay while inside the cupboard range")]
			internal bool DecayInCupRange { get; set; }

			[JsonProperty(PropertyName = "Check if owner of barricade is authorized")]
			internal bool CheckBarricadeOwner { get; set; }

			[JsonProperty(PropertyName = "Disable standart decay for barricades")]
			internal bool DisableStandartDecay { get; set; }

			[JsonProperty(PropertyName = "Enabled types of barricades")]
			internal Dictionary<string, bool> EnabledEntities { get; set; }

			[JsonProperty(PropertyName = "Configuration version (Needed for auto-update, don't modify)")]
			internal VersionNumber ConfigVersion { get; set; }
		}

		private Configuration GetDefaultConfig() =>
			new Configuration {
				DecayTime = 600,
				DecayDamage = 0.2f,
				InitialHealth = 1.0f,
				DecayInCupRange = false,
				CheckBarricadeOwner = true,
				DisableStandartDecay = false,
				EnabledEntities = new Dictionary<string, bool> {
					{"assets/prefabs/building/wall.external.high.stone/wall.external.high.stone.prefab", true},
					{"assets/prefabs/building/wall.external.high.wood/wall.external.high.wood.prefab", true},
					{"assets/prefabs/deployable/barricades/barricade.concrete.prefab", true},
					{"assets/prefabs/deployable/barricades/barricade.metal.prefab", true},
					{"assets/prefabs/deployable/barricades/barricade.sandbags.prefab", true},
					{"assets/prefabs/deployable/barricades/barricade.stone.prefab", true},
					{"assets/prefabs/deployable/barricades/barricade.wood.prefab", true},
					{"assets/prefabs/deployable/barricades/barricade.woodwire.prefab", true},
					{"assets/prefabs/building/gates.external.high/gates.external.high.stone/gates.external.high.stone.prefab", true},
					{"assets/prefabs/building/gates.external.high/gates.external.high.wood/gates.external.high.wood.prefab", true}
				},
				ConfigVersion = Version
			};

		protected override void LoadConfig()
		{
			base.LoadConfig();

			try
			{
				Settings = Config.ReadObject<Configuration>();

				if(Settings == null)
					throw new JsonException("Configuration failed to load, creating new one!");
			}
			catch
			{
				Config.Clear();
				Settings = GetDefaultConfig();
				SaveConfig();
			}

			if(Settings.ConfigVersion < Version)
			{
				if(Settings.ConfigVersion == new VersionNumber(2, 1, 0))
				{
					Configuration tempconfig = new Configuration {
						DecayTime = Settings.DecayTime,
						DecayDamage = Settings.DecayDamage,
						InitialHealth = Settings.InitialHealth,
						DecayInCupRange = Settings.DecayInCupRange,
						CheckBarricadeOwner = true,
						DisableStandartDecay = Settings.DisableStandartDecay,
						EnabledEntities = Settings.EnabledEntities
					};
					Settings = tempconfig;
				}

				Settings.ConfigVersion = Version;
				SaveConfig();
				Puts("Configuration has been updated!");
			}

			if(Settings.EnabledEntities == null)
			{
				Settings.EnabledEntities = new Dictionary<string, bool> {
					{"assets/prefabs/building/wall.external.high.stone/wall.external.high.stone.prefab", true},
					{"assets/prefabs/building/wall.external.high.wood/wall.external.high.wood.prefab", true},
					{"assets/prefabs/deployable/barricades/barricade.concrete.prefab", true},
					{"assets/prefabs/deployable/barricades/barricade.metal.prefab", true},
					{"assets/prefabs/deployable/barricades/barricade.sandbags.prefab", true},
					{"assets/prefabs/deployable/barricades/barricade.stone.prefab", true},
					{"assets/prefabs/deployable/barricades/barricade.wood.prefab", true},
					{"assets/prefabs/deployable/barricades/barricade.woodwire.prefab", true},
					{"assets/prefabs/building/gates.external.high/gates.external.high.stone/gates.external.high.stone.prefab", true},
					{"assets/prefabs/building/gates.external.high/gates.external.high.wood/gates.external.high.wood.prefab", true}
				};
				SaveConfig();
			}
		}

		protected override void LoadDefaultConfig()
		{
			Settings = GetDefaultConfig();
			SaveConfig();
			Puts("New configuration file created...");
		}

		protected override void SaveConfig() => Config.WriteObject(Settings);

		#endregion

		#region -Oxide hooks-

		private void Init()
		{
			Singleton = this;
			Barricades = new HashSet<BarricadeDecay>();
		}

		private void OnServerInitialized() => ServerMgr.Instance.StartCoroutine(FindAllBarricades());

		private IEnumerator FindAllBarricades()
		{
			IEnumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();

			while(enumerator.MoveNext())
			{
				if(enumerator.Current == null || enumerator.Current.IsDestroyed) continue;

				if(NeedToDecay(enumerator.Current.gameObject)) enumerator.Current.gameObject.AddComponent<BarricadeDecay>();

				yield return new WaitForFixedUpdate();
			}
		}

		private bool NeedToDecay(GameObject obj) => obj != null && obj.GetComponent<DecayEntity>() != null && Settings.EnabledEntities.ContainsKey(obj.GetComponent<DecayEntity>().PrefabName) && Settings.EnabledEntities[obj.GetComponent<DecayEntity>().PrefabName] && obj.GetComponent<BarricadeDecay>() == null;

		private void OnEntityBuilt(Planner planner, GameObject gameObject)
		{
			if(NeedToDecay(gameObject)) gameObject.AddComponent<BarricadeDecay>();
		}

		private void Unload()
		{
			foreach(BarricadeDecay barricadeDecay in Barricades) barricadeDecay.RemoveComponent();
		}

		#endregion
	}
}


// --- End of file: HighWallBarricades.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/heli-support ---
// --- Original File Path: H/HeliSupport/HeliSupport.cs ---

using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
     [Info("Heli Support", "Vault Boy", "1.0.0")]
     [Description("Call a support from heli forces")]
     public class HeliSupport : RustPlugin
     {
         #region Vars

         private const string nocdperm = "helisupport.callnocd";

         private const string heliprefab = "assets/prefabs/npc/patrol helicopter/patrolhelicopter.prefab";

         #endregion
         
         #region Oxide hooks
         
         private void OnServerInitialized()
         {
             permission.RegisterPermission(nocdperm, this);
         }

         private bool CanHelicopterTarget(PatrolHelicopterAI heli, BasePlayer player)
         {
             var id = heli.GetComponent<BaseEntity>().net.ID;

             if (!helis.ContainsKey(id))
             {
                 return true;
             }

             if (helis[id] == player.userID) Server.Broadcast("Cant");

             return helis[id] != player.userID;
         }
         
         private bool CanHelicopterUseNapalm(PatrolHelicopterAI heli)
         {
             return !helis.ContainsKey(heli.GetComponent<BaseEntity>().net.ID);
         }

         #endregion

         #region Data

         private Dictionary<uint, ulong> helis = new Dictionary<uint, ulong>(); // Heli id - Heli owner

         #endregion
         
         #region Commands

         [ChatCommand("heli")]
         private void CmdCall(BasePlayer player)
         {
             if (permission.UserHasPermission(player.UserIDString, nocdperm))
             {
                 CallHeli(player);
                 return;
             }
             
             player.ChatMessage("You dont have acess to user this command!");
         }

         #endregion

         #region Helpers

         private void CallHeli(BasePlayer player)
         {
             var entity = GameManager.server.CreateEntity(heliprefab);
             entity.Spawn();

             helis.Add(entity.net.ID, player.userID);

             var heliai = entity.GetComponent<PatrolHelicopterAI>();
             heliai.SetInitialDestination(player.transform.position + new Vector3(0.0f, 50f, 0.0f));
             
             player.ChatMessage("Heli is coming for you!");

             timer.Every(10f, () =>
             {
                 if(heliai.isDead) return;
                 heliai.ExitCurrentState();
                 heliai.State_Strafe_Enter(player.transform.position);
             });
         }

         #endregion
         
     }
}

// --- End of file: HeliSupport.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/happy-hour ---
// --- Original File Path: H/HappyHour/HappyHour.cs ---

﻿using UnityEngine;
using Convert = System.Convert;
using System;
using System.Collections.Generic;
using UnityEngine;
using Oxide.Core.Configuration;
using Oxide.Core;
using System.Linq;
using Oxide.Game.Rust.Cui;


namespace Oxide.Plugins
{

    [Info("Happy Hour Plugin", "BuzZ", "2.0.2")]
    public class HappyHour : RustPlugin
    {

/*======================================================================================================================= 
*
*   
*   16th november 2018
*
*	THANKS TO THE OXIDE/UMOD TEAM for coding quality, ideas, and time spent for the community
*
*   2.0.0   20181116    complete plugin rewrite by new maintainer (only kept the name of it and main idea) with GUI homemade for all functions
*   2.0.2   20190907    +FIX on init
*
*   add randomized skin + config bool
*   add help on main panel at start with decomposed bar
*   message on give at happyhour and if not admin /happy
*
*********************************************
*   Original author :   Feramor on versions <2.0.0
*   Maintainer(s)   :   BuzZ since 20181116 from v2.0.0
*********************************************   
*
*=======================================================================================================================*/


///////////////////////
// LES VARIABLES
/////////////////////////

        bool debug = false;
        private string page;
        private string MainHappyPanel;
        private CuiElementContainer HoursCuiElement;
        private string InsideHappyPanel;
        private string hourbutton;
        private string hourstatus;
        private string houritem;
        private string itembutton;
        private string whathour;
        float rate = 20;
        const string admin = "HappyHour.admin"; 

        private Dictionary<int, int> temporary = new Dictionary<int, int>();

        public class StoredData
        {
            public Dictionary<int, Pack> hourpack = new Dictionary<int, Pack>();
            public StoredData()
            {
            }
        }
        private StoredData storedData;

        public class Pack
        {
            public Dictionary<int, int> intquantity = new Dictionary<int, int>();
            public bool status;
            public List<ulong> received = new List<ulong>();
        }

        void Init()
        {
            storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
            permission.RegisterPermission(admin, this);
        }

        void Unload()
        {
            Interface.Oxide.DataFileSystem.WriteObject(Name, storedData);
            //CleanZeroz();
        }

        void OnServerInitialized()
        {
            insidetimer();
            timer.Every(rate, () =>
            {   
                insidetimer();
            });
        }

        void insidetimer()
        {
            //float hournow = TOD_Sky.Instance.Cycle.Hour;    //ingame time
            float hournow = System.DateTime.Now.Hour;
            int gamehour = Convert.ToInt32(Math.Round(hournow-0.5));
            if (debug == true){Puts($"INGAME HOUR -> {hournow} => {gamehour}");}
            int game1 = gamehour - 1;
            int game2 = gamehour + 1;
            if (game1 == 0)game1=24;
            if (game2 == 0)game2=24;
            if (gamehour == 0)
            {
                gamehour = 24;
                game1 = 23;
                game2 = 1;
            }
            if (storedData.hourpack.Count() == 0) return;
            if (storedData.hourpack[game1] != null) storedData.hourpack[game1].received.Clear();
            if (storedData.hourpack[game2] != null) storedData.hourpack[game2].received.Clear();
            foreach (var hourz in storedData.hourpack)
            {
                if (hourz.Key == gamehour)
                {
                    if (storedData.hourpack[gamehour].status == true)
                    {
                        GiveDaHourGifts(gamehour);
                        if (debug == true){Puts($"launching GiveDaHourGifts from insidetimer ! -> {gamehour}");}
                    }
                }
            }
        }

        void CleanZeroz()
        {
            int round = -1;
            int Round = 1;

            /*for (Round = 1; Round <= 24 ; Round++)            
            {
                temporary = new Dictionary<int, int>();

                round = round + 1;
                foreach (KeyValuePair<int, int> togive in storedData.hourpack[round].intquantity.ToArray())
                {

                    temporary.Add(togive.Key, togive.Value);
                    bool etat = storedData.hourpack[round].status;
                    storedData.hourpack.Add(round, new Pack() {intquantity = temporary, status = etat});

                        //storedData.hourpack[round].intquantity.Remove(togive.Key);
                                        //storedData.hourpack.Add(round, new Pack() {intquantity = temporary, status = false}); un gros DEL

                }            
            }*/




        }

        void GiveDaHourGifts(int hour)
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList.ToList())
            {
                if (!storedData.hourpack[hour].received.Contains(player.userID))
                {
                    foreach (KeyValuePair<int, int> togive in storedData.hourpack[hour].intquantity.ToArray())
                    {
                        ulong skinitem = 0;
                        if (togive.Value != 0)
                        {
                            Item itemtogive = ItemManager.CreateByItemID(ItemManager.FindItemDefinition(togive.Key).itemid, togive.Value, skinitem);
                            if (itemtogive == null)return;
                            //itemtogive.name = name; 
                            player.GiveItem(itemtogive);
                            if (debug == true){Puts($"PLAYER GIVE !");}                            
                        }

                    }
                    storedData.hourpack[hour].received.Add(player.userID);
                    //CleanZeroz();
                    Interface.Oxide.DataFileSystem.WriteObject(Name, storedData);
                }      
            }
        }
//////////////////////////
// OUVERTURE DU MAIN PANEL
//////////////////////////

        [ChatCommand("happy")]
        private void OpenMainHappyPanel(BasePlayer player, string command, string[] args, int editing)
        {
            bool isadmin = permission.UserHasPermission(player.UserIDString, admin);
            if (isadmin == false)
            {
                return;
            }
            CuiHelper.DestroyUi(player, MainHappyPanel);
            if (debug == true){Puts($"DEBUT VOID PANEL");}

#region MAIN PANEL COLONNES & COULEURS

            string PanelColor = "0.0 0.0 0.0 1.0";
            string buttonCloseColor = "0.6 0.26 0.2 1";

#endregion

#region MAIN PANEL CUI de base

            var CuiElement = new CuiElementContainer();

            MainHappyPanel = CuiElement.Add(new CuiPanel

            {Image = {Color = $"{PanelColor}"},
                RectTransform = {AnchorMin = "0.0 0.0", AnchorMax = "1.0 1.0"},
                CursorEnabled = true
            }, new CuiElement().Parent = "Overlay", MainHappyPanel);
            
            var closeButton = new CuiButton
            {Button = {Close = MainHappyPanel, Color = $"{buttonCloseColor}"},
                RectTransform = {AnchorMin = "0.95 0.95", AnchorMax = "0.99 0.99"},
                Text = {Text = "[X]", FontSize = 16, Align = TextAnchor.MiddleCenter}
            };

            CuiElement.Add(closeButton, MainHappyPanel);

            var Title = CuiElement.Add(new CuiLabel
            {Text = {Text = $"HAPPY HOUR(s) !", Color = "1.0 1.0 1.0 1.0", FontSize = 24, Align = TextAnchor.MiddleRight},
            RectTransform = {AnchorMin = $"0.70 0.95", AnchorMax = $"0.94 0.99"}
            }, MainHappyPanel);

            var Editing = CuiElement.Add(new CuiLabel
            {Text = {Text = $"edit with <ITEMS> and toggle <ON/OFF> button(s) ", Color = "1.0 1.0 1.0 1.0", FontSize = 20, Align = TextAnchor.MiddleCenter},
            RectTransform = {AnchorMin = $"0.20 0.95", AnchorMax = $"0.65 0.99"}
            }, MainHappyPanel);

            CuiHelper.AddUi(player, CuiElement);

            DisplayHoursButtons (player, editing);
        }

#endregion

        void DisplayHoursButtons (BasePlayer player, int editing)
        {
#region MAIN MENU COLONNES & COULEURS

            var debutcolonne00 = 0.01;
            var fincolonne00 = 0.04;
            var debutcolonne01 = 0.04;
            var fincolonne01 = 0.07;
            var debutcolonne02 = 0.07;
            var fincolonne02 = 0.13;            
            var debutcolonne03 = 0.13;
            var fincolonne03 = 0.16;             
            var hauteurmax = 0.98;             
            var greencolor = "0.5 1.0 0.0 1.0";
            var redcolor = "1.0 0.1 0.1 1.0";
#endregion

#region HOURS AUTO EXPAND

            var HoursCuiElement = new CuiElementContainer();
            int round = -1;
            int Round = 1;
            int hour = 0;
            var status = "0";
            var statuscolor = "0";
            temporary = new Dictionary<int, int>();
            for (Round = 1; Round <= 24 ; Round++)            
            {
                round = round + 1;
                hour = hour + 1;
                string itemcolor = "0.0 0.0 0.0 1.0";
            if (!storedData.hourpack.ContainsKey(hour))
            {
                if (debug == true){Puts($"-> NULL");}
                storedData.hourpack.Add(hour, new Pack() {intquantity = temporary, status = false});
            }
            if (hour == editing)
            {
                itemcolor = "0.2 0.1 0.9 1.0";
            }
            double lignehaut = hauteurmax - (round * 0.04);   //lignebas = lignehaut - 0.03
            var hourbutton = HoursCuiElement.Add(new CuiButton
            {Button ={Command = $"",Color = $"0.0 0.0 0.0 1.0"},Text ={Text = $"{hour}h",Color = "1.0 1.0 1.0 1.0",FontSize = 16,Align = TextAnchor.MiddleCenter},
                RectTransform ={AnchorMin = $"{debutcolonne00} {lignehaut - 0.03}",   AnchorMax = $"{fincolonne00} {lignehaut}"}
            }, MainHappyPanel);

            if (storedData.hourpack[hour].status == true)
            {
                statuscolor = greencolor;
                status = "ON";
            }
            else
            {
                status = "OFF";
                statuscolor = redcolor;
            }
            int total = new int();
            foreach (KeyValuePair<int, int> old in storedData.hourpack[hour].intquantity.ToArray())
            {
                if (old.Value != 0)
                {
                    total = total + 1;
                }
            }

            var hourstatus = HoursCuiElement.Add(new CuiButton
            {Button ={Command = $"hour_toggle {hour}",Color = $"{statuscolor}"},Text ={Text = $"{status}",Color = "0.0 0.0 0.0 1.0",FontSize = 16,Align = TextAnchor.MiddleCenter},
                RectTransform ={AnchorMin = $"{debutcolonne01} {lignehaut - 0.03}",   AnchorMax = $"{fincolonne01} {lignehaut}"}
            }, MainHappyPanel);

            var houritem = HoursCuiElement.Add(new CuiButton
            {Button ={Command = $"hour_display {hour}",Color = $"{itemcolor}"},Text ={Text = $"ITEMS",Color = "1.0 1.0 1.0 1.0",FontSize = 16,Align = TextAnchor.MiddleCenter},
                RectTransform ={AnchorMin = $"{debutcolonne02} {lignehaut - 0.03}",   AnchorMax = $"{fincolonne02} {lignehaut}"}
            }, MainHappyPanel);

            var houritemcount = HoursCuiElement.Add(new CuiButton
            {Button ={Command = $"",Color = $"1.0 1.0 1.0 1.0"},Text ={Text = $"{total}",Color = "0.0 0.0 0.0 1.0",FontSize = 16,Align = TextAnchor.MiddleCenter},
                RectTransform ={AnchorMin = $"{debutcolonne03} {lignehaut - 0.03}",   AnchorMax = $"{fincolonne03} {lignehaut}"}
            }, MainHappyPanel);

#endregion
            }
            CuiHelper.AddUi(player, HoursCuiElement);
        }

        [ConsoleCommand("hour_toggle")]
        private void ToggleDaHourStatus(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            int hour = Convert.ToInt32(arg.Args[0]);
            storedData.hourpack[hour].status = !storedData.hourpack[hour].status;
            if (debug == true){Puts($"-> PACK FOR {hour}h TOGGLE");}
            hourbutton = null;
            hourstatus = null;
            houritem = null;
            DisplayHoursButtons (player, hour);
        }

        [ConsoleCommand("hour_display")]
        private void ItemCatalogForDaHour(ConsoleSystem.Arg arg)
        {
            var player = arg.Connection.player as BasePlayer;
            int hour = Convert.ToInt32(arg.Args[0]);
            ItemCatalogForDaHour(player, hour);
        }
        
        private void ItemCatalogForDaHour(BasePlayer player, int hour)
        {

            OpenMainHappyPanel(player, null, null, hour);

            var greencolor = "0.2 0.6 0.2 1.0";
            var redcolor = "0.9 0.1 0.2 1.0";
            var casecolor = "0.0 0.0 0.0 1.0";
            var debutcolonne00 = 0.17;
            var hauteurmax = 0.94;   
            int round = -1;
            int Round = 1;
            List<string> itemslist = new List<string>();
            foreach(var pair in items)
            {
                itemslist.Add(pair.Value);
            }
            string[] itemsarray = itemslist.ToArray();
            Array.Sort(itemsarray);
            int howmany = itemslist.Count();
            var ItemsCuiElement = new CuiElementContainer();
            whathour = ItemsCuiElement.Add(new CuiButton
            {Button ={Command = $"",Color = $"0.0 0.0 0.0 0.0"},Text ={Text = $"YOU ARE EDITING {hour}H HAPPY HOUR ITEMS",Color = "1.0 1.0 1.0 1.0",FontSize = 16,Align = TextAnchor.MiddleCenter},
                RectTransform ={AnchorMin = $"0.20 0.01",   AnchorMax = $"0.90 0.1"}
            }, MainHappyPanel);
            if (debug == true){Puts($"ITEMS =>{howmany}");}
            for (Round = 1; Round <= 112 ; Round++)            // replace with a count. max and add pages and optimize
            {
                round = round + 1;
                double lignehaut = hauteurmax - (round * 0.05);   //lignebas = lignehaut - 0.03

                if (round < 16) casecolor = "0.0 0.0 0.0 1.0";

                if (round >= 16 && round <= 32)
                {
                    debutcolonne00 = 0.285;
                    lignehaut = hauteurmax - ((round - 16) * 0.05);
                    casecolor = "0.5 0.5 0.5 1.0";
                }
                if (round >= 32 && round <= 48)
                {
                    debutcolonne00 = 0.405;
                    lignehaut = hauteurmax - ((round - 32) * 0.05);
                    casecolor = "0.0 0.0 0.0 1.0";
                }
                if (round >= 48 && round <= 64)
                {
                    debutcolonne00 = 0.52;
                    lignehaut = hauteurmax - ((round - 48) * 0.05);
                    casecolor = "0.5 0.5 0.5 1.0";

                }
                if (round >= 64 && round <= 80)
                {
                    debutcolonne00 = 0.635;
                    lignehaut = hauteurmax - ((round - 64) * 0.05);
                    casecolor = "0.0 0.0 0.0 1.0";
                }
                if (round >= 80 && round <= 96)
                {
                    debutcolonne00 = 0.75;
                    lignehaut = hauteurmax - ((round - 80) * 0.05);
                    casecolor = "0.5 0.5 0.5 1.0";
                }
                if (round >= 96 && round <= 112)
                {
                    debutcolonne00 = 0.865;
                    lignehaut = hauteurmax - ((round - 96) * 0.05);
                    casecolor = "0.0 0.0 0.0 1.0";
                }
                int qty = new int();
                int itemint = new int();
                foreach (var itemnow in items)
                {
                    if (itemnow.Value == itemsarray[round])
                    {
                        itemint = itemnow.Key;
                    }
                }
                foreach (KeyValuePair<int, int> old in storedData.hourpack[hour].intquantity.ToArray())
                {
                    if (itemint == old.Key)
                    {
                        if (old.Value == null)
                        {
                            qty = 0;
                        }
                        else
                        qty = old.Value;
                    }
                }
                if (qty != 0)
                {
                    casecolor = "0.0 0.0 1.0 1.0"; 

                }

                if (debug == true){Puts($"ITEMS =>{qty}x{itemint}");}

                itembutton = ItemsCuiElement.Add(new CuiButton
                {Button ={Command = $"",Color = $"0.0 0.0 0.0 1.0"},Text ={Text = $"",Color = "1.0 1.0 1.0 1.0",FontSize = 16,Align = TextAnchor.MiddleCenter},
                    RectTransform ={AnchorMin = $"{debutcolonne00} {lignehaut - 0.04}",   AnchorMax = $"{debutcolonne00 + 0.12} {lignehaut}"}
                }, MainHappyPanel);

                var itemname = ItemsCuiElement.Add(new CuiButton
                {Button ={Command = $"",Color = $"{casecolor}"},Text ={Text = $"{itemsarray[round]}",Color = "1.0 1.0 1.0 1.0",FontSize = 12,Align = TextAnchor.MiddleCenter},
                    RectTransform ={AnchorMin = $"0.01 0.5",   AnchorMax = $"0.99 0.99"}
                }, itembutton);

                var plus1button = ItemsCuiElement.Add(new CuiButton
                {Button ={Command = $"hour_item add {itemint} 1 {hour}",Color = $"{greencolor}"},Text ={Text = $"+1",Color = "1.0 1.0 1.0 1.0",FontSize = 10,Align = TextAnchor.MiddleCenter},
                    RectTransform ={AnchorMin = $"0.61 0.01",   AnchorMax = $"0.73 0.49"}
                }, itembutton);

                var plus10button = ItemsCuiElement.Add(new CuiButton
                {Button ={Command = $"hour_item add {itemint} 10 {hour}",Color = $"{greencolor}"},Text ={Text = $"+10",Color = "1.0 1.0 1.0 1.0",FontSize = 10,Align = TextAnchor.MiddleCenter},
                    RectTransform ={AnchorMin = $"0.74 0.01",   AnchorMax = $"0.86 0.49"}
                }, itembutton);

                var plus100button = ItemsCuiElement.Add(new CuiButton
                {Button ={Command = $"hour_item add {itemint} 100 {hour}",Color = $"{greencolor}"},Text ={Text = $"+100",Color = "1.0 1.0 1.0 1.0",FontSize = 10,Align = TextAnchor.MiddleCenter},
                    RectTransform ={AnchorMin = $"0.87 0.01",   AnchorMax = $"0.99 0.49"}
                }, itembutton);

                var minus1button = ItemsCuiElement.Add(new CuiButton
                {Button ={Command = $"hour_item remove {itemint} 1 {hour}",Color = $"{redcolor}"},Text ={Text = $"-1",Color = "1.0 1.0 1.0 1.0",FontSize = 10,Align = TextAnchor.MiddleCenter},
                    RectTransform ={AnchorMin = $"0.27 0.01",   AnchorMax = $"0.39 0.49"}
                }, itembutton);

                var minus10button = ItemsCuiElement.Add(new CuiButton
                {Button ={Command = $"hour_item remove {itemint} 10 {hour}",Color = $"{redcolor}"},Text ={Text = $"-10",Color = "1.0 1.0 1.0 1.0",FontSize = 10,Align = TextAnchor.MiddleCenter},
                    RectTransform ={AnchorMin = $"0.14 0.01",   AnchorMax = $"0.26 0.49"}
                }, itembutton);

                var minus100button = ItemsCuiElement.Add(new CuiButton
                {Button ={Command = $"hour_item remove {itemint} 100 {hour}",Color = $"{redcolor}"},Text ={Text = $"-100",Color = "1.0 1.0 1.0 1.0",FontSize = 10,Align = TextAnchor.MiddleCenter},
                    RectTransform ={AnchorMin = $"0.01 0.01",   AnchorMax = $"0.13 0.49"}
                }, itembutton);

                var countbutton = ItemsCuiElement.Add(new CuiButton
                {Button ={Command = $"",Color = $"0.9 0.82 0.65 1.0"},Text ={Text = $"{qty}",Color = "0.0 0.0 0.0 1.0",FontSize = 12,Align = TextAnchor.MiddleCenter},
                    RectTransform ={AnchorMin = $"0.41 0.01",   AnchorMax = $"0.60 0.49"}
                }, itembutton);
            }
            CuiHelper.AddUi(player, ItemsCuiElement);
        }

        [ConsoleCommand("hour_item")]
        private void AddItemOnHourPack(ConsoleSystem.Arg arg)
        {
            temporary = new Dictionary<int, int>();
            var player = arg.Connection.player as BasePlayer;
            string reason = arg.Args[0];
            int itemnow = Convert.ToInt32(arg.Args[1]);
            int qty = Convert.ToInt32(arg.Args[2]);
            int hour = Convert.ToInt32(arg.Args[3]);
            int oldqty = 0;
            foreach (KeyValuePair<int, int> old in storedData.hourpack[hour].intquantity.ToArray())
            {
                temporary.Add(old.Key, old.Value);
                if (itemnow == old.Key)
                {
                    if (old.Value == null)
                    {
                        oldqty = 0;
                    }
                        else
                        oldqty = old.Value;
                }
            }
            temporary.Remove(itemnow);

            if (reason == "add")
            {
            temporary.Add(itemnow, oldqty + qty);
            }
            else
            {
            int newqty = oldqty - qty;
            if (newqty < 0) newqty = 0;
            temporary.Add(itemnow, newqty);

            }


            storedData.hourpack.Remove(hour);
            storedData.hourpack.Add(hour, new Pack() {intquantity = temporary});
            if (debug == true){Puts($"OLD ITEMS {oldqty} => NEW {qty}x{itemnow}");}
            OpenMainHappyPanel(player, null, null, hour);
            ItemCatalogForDaHour(player, hour);
        }

        /*[ConsoleCommand("hour_item_remove")]
        private void RemoveItemOnHourPack(ConsoleSystem.Arg arg)
        {
            temporary = new Dictionary<int, int>();
            var player = arg.Connection.player as BasePlayer;
            int itemnow = Convert.ToInt32(arg.Args[0]);
            int qty = Convert.ToInt32(arg.Args[1]);
            int hour = Convert.ToInt32(arg.Args[2]);
            int oldqty = 0;
            foreach (KeyValuePair<int, int> old in storedData.hourpack[hour].intquantity.ToArray())
            {
                temporary.Add(old.Key, old.Value);
                if (itemnow == old.Key)
                {
                    if (old.Value == null)
                    {
                        oldqty = 0;
                    }
                    else
                    oldqty = old.Value;
                }
            }
            int newqty = oldqty - qty;
            if (newqty < 0) newqty = 0;
            temporary.Remove(itemnow);
            temporary.Add(itemnow, newqty);
            storedData.hourpack.Remove(hour);
            storedData.hourpack.Add(hour, new Pack() {intquantity = temporary});
            if (debug == true){Puts($"OLD ITEMS {oldqty} => NEW {qty}x{itemnow}");}
            OpenMainHappyPanel(player, null, null, hour);
            ItemCatalogForDaHour(player, hour);
        }*/

        public Dictionary<int, string> items = new Dictionary<int, string>
        {

            //{-702051347, "mask.bandana"},   //35
            //{-2012470695, "mask.balaclava"},
            //{1675639563, "hat.beenie"},
            //{-761829530, "burlap.shoes"},
            //{602741290, "burlap.shirt"},
            //{1992974553, "burlap.trousers"},
            //{1877339384, "burlap.headwrap"},
            {850280505, "bucket.helmet"},
            //{-23994173, "hat.boonie"},
            {-1022661119, "hat.cap"},
            //{-2025184684, "shirt.collared"},
            //{-803263829, "coffeecan.helmet"},
            {-1903165497, "deer.skull.mask"},
            //{-1773144852, "attire.hide.skirt"},
            //{196700171, "attire.hide.vest"}, // hide shirt ???!!
            //{1722154847, "attire.hide.pants"},
            //{794356786, "attire.hide.boots"},   // hide shoes
            //{3222790, "attire.hide.helterneck"},
            //{1751045826, "hoodie"},
            //{980333378, "attire.hide.poncho"},
            //{1366282552, "burlap.gloves"},  //Leather Gloves
            //{935692442, "tshirt.long"},
            {1110385766, "metal.plate.torso"},
            {-194953424, "metal.facemask"},
            {-1539025626, "hat.miner"},
            {237239288, "pants"},
            //{-2002277461, "roadsign.jacket"},   // roadside vest
            //{1850456855, "roadsign.kilt"},          // roadside pants
            {671063303, "riot.helmet"},
            {-48090175, "jacket.snow"},
            {-1695367501, "pants.shorts"},
            {1608640313, "shirt.tanktop"},
            {223891266, "tshirt"},
            {-1163532624, "jacket"},    // vagabond jacket ???????
            {-1549739227, "shoes.boots"},
////////////////////////----
            {1545779598, "rifle.ak"},   //29
            {1588298435, "rifle.bolt"},
            //{1711033574, "bone.club"},
            //{1814288539, "knife.bone"},
            {1965232394, "crossbow"},
            {-765183617, "shotgun.double"},
            {-75944661, "pistol.eoka"},
            {143803535, "grenade.f1"},
            {1326180354, "salvaged.sword"},
            {1318558775, "smg.mp5"},        //MP5A4
            {795371088, "shotgun.pump"},
            //{963906841, "rock"},
            {-1506397857, "hammer.salvaged"},
            {-1780802565, "icepick.salvaged"},
            //{-1878475007, "explosive.satchel"},
            {818877484, "pistol.semiauto"},
            {-1583967946, "stonehatchet"},
            {171931394, "stone.pickaxe"},
            {-1469578201, "longsword"},
            {-1758372725, "smg.thompson"},
            {200773292, "hammer"},
            {-1302129395, "pickaxe"},
            {649912614, "pistol.revolver"},
            {442886268, "rocket.launcher"},
            {-904863145, "rifle.semiauto"},
            //{-1367281941, "shotgun.waterpipe"},
            //{1796682209, "smg.2"},
            {1373971859, "pistol.python"},
            {-1812555177, "rifle.lr300"},
////////////////////////----
            //{1353298668, "door.hinged.toptier"},  //armore door
            {-1950721390, "barricade.concrete"},
            //{833533164, "box.wooden.large"},
            {-1736356576, "target.reactive"},
            //{-1754948969, "sleepingbag"},
            //{-2067472972, "door.hinged.metal"},    //sheet metal door
            //{2114754781, "water.purifier"},
            //{-180129657, "box.wooden"},     //wood storage box
            //{1729120840, "door.hinged.wood"},     //wooden door
////////////////////////----
            {-2124352573, "fun.guitar"},  //armore door
            {588596902, "ammo.handmade.shell"},
            //{-2097376851, "ammo.nailgun.nails"}, 
            {785728077, "ammo.pistol"}, 
            {51984655, "ammo.pistol.fire"}, 
            {-1691396643, "ammo.pistol.hv"}, 
            {-1211166256, "ammo.rifle"}, 
            {-1321651331, "ammo.rifle.explosive"}, 
            {1712070256, "ammo.rifle.hv"}, 
            {605467368, "ammo.rifle.incendiary"}, 
            {-742865266, "ammo.rocket.basic"}, 
            {1638322904, "ammo.rocket.fire"}, 
            {-1841918730, "ammo.rocket.hv"}, 
            {-17123659, "ammo.rocket.smoke"}, 
            {-1685290200, "ammo.shotgun"}, 
            {-1036635990, "ammo.shotgun.fire"}, 
            {-727717969, "ammo.shotgun.slug"}, 
            {-1432674913, "antiradpills"}, 
            {-989755543, "bearmeat.burned"},
            {1873897110, "bearmeat.cooked"},
            {1973684065, "chicken.burned"},
            {-1848736516, "chicken.cooked"},
            {-78533081, "deermeat.burned"},
            {-1509851560, "deermeat.cooked"},
            {1668129151, "fish.cooked"},
            {1917703890, "horsemeat.burned"},
            {-1162759543, "horsemeat.cooked"},
            {-682687162, "humanmeat.burned"},
            {1536610005, "humanmeat.cooked"},
            {1391703481, "meat.pork.burned"},
            {-242084766, "meat.pork.cooked"},
            {1827479659, "wolfmeat.burned"},
            {813023040, "wolfmeat.cooked"},
            {-151838493, "wood"}, 
            {215754713, "arrow.bone"},
            {14241751, "arrow.fire"},
            {-1023065463, "arrow.hv"}, 
            {-1234735557, "arrow.wooden"}, 
            {609049394, "battery.small"}, 
            {1099314009, "bbq"}, 
            {1121925526, "candycane"}, 
            {296519935, "diving.fins"}, 
            {-113413047, "diving.mask"}, 
            {-2022172587, "diving.tank"}, 
            {-1101924344, "diving.wetsuit"}, 
            {-265876753, "gunpowder"}, 
            {-1982036270, "hq.metal.ore"}, 
            {254522515, "largemedkit"}, 
            {-946369541, "lowgradefuel"}, 
            {69511070, "metal.fragments"}, 
            {-4031221, "metal.ore"}, 
            //{-1651220691, "pookie.bear"}, 
            {-1667224349, "xmas.decoration.baubels"},
            {-209869746, "xmas.decoration.candycanes"},
            {1686524871, "xmas.decoration.gingerbreadmen"},
            {1723747470, "xmas.decoration.lights"},
            {-129230242, "xmas.decoration.pinecone"}, 
            {-1331212963, "xmas.decoration.star"},
            {2106561762, "xmas.decoration.tinsel"},
            {674734128, "xmas.door.garland"},
            {1058261682, "xmas.lightstring"},
            {-1622660759, "xmas.present.large"},
            {756517185, "xmas.present.medium"},
            {-722241321, "xmas.present.small"},
            {794443127, "xmas.tree"},
            {-1379835144, "xmas.window.garland"},
            {2009734114, "xmasdoorwreath"},
            {952603248, "weapon.mod.flashlight"},
            {442289265, "weapon.mod.holosight"},
            {-132516482, "weapon.mod.lasersight"}, 
            {-1405508498, "weapon.mod.muzzleboost"},
            {1478091698, "weapon.mod.muzzlebrake"},
            {-1850571427, "weapon.mod.silencer"},
            {-855748505, "weapon.mod.simplesight"}, 
            {567235583, "weapon.mod.small.scope"}, 
        };
    }
}


// --- End of file: HappyHour.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-nudity ---
// --- Original File Path: N/NoNudity/NoNudity.cs ---

﻿using System.Collections.Generic;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("NoNudity", "Absolut", "1.0.3", ResourceId = 2394)]

    class NoNudity : RustPlugin
    {
        void OnServerInitialized()
        {
            LoadVariables();
            foreach (var player in BasePlayer.activePlayerList)
                OnPlayerInit(player);
        }
        void OnPlayerInit(BasePlayer player)
        {
            if (player.inventory.containerWear.itemList.Count() == 0) { GivePants(player); return; }
            Item valid = player.inventory.containerWear.itemList.Where(k => Pants.Contains(k.info.shortname)).Select(k => k).FirstOrDefault();
            if (valid == null) GivePants(player);
        }
        void OnPlayerRespawned(BasePlayer player)
        {
            GivePants(player);
        }
        void GivePants(BasePlayer player)
        {
            var definition = ItemManager.FindItemDefinition(configData.TypeOfPants_Shortname);
            if (definition == null) definition = ItemManager.FindItemDefinition("pants");
            Item newPants = ItemManager.Create(definition, 1, configData.PantsSkin);
            if (newPants == null) newPants = ItemManager.Create(definition, 1, 0);
            newPants.MoveToContainer(player.inventory.containerWear);
        }

        object CanMoveItem(Item item, PlayerInventory playerLoot, uint targetContainer, int targetSlot)
        {
            if (item == null || playerLoot == null) return null;
            if (playerLoot.containerWear.itemList.Contains(item) && Pants.Contains(item.info.shortname)) return false;
            Item valid = playerLoot.containerWear.itemList.Where(k => Pants.Contains(k.info.shortname)).Select(k => k).FirstOrDefault();
            if (Pants.Contains(item.info.shortname) && valid == null)
            {
                timer.Once(1, () => MovePants(item, playerLoot.containerWear));
                return false;
            }
            if (playerLoot.containerWear.uid == targetContainer && valid != null && !Pants.Contains(item.info.shortname) && targetSlot == valid.position) return false;
            return null;
        }

        void MovePants(Item item, ItemContainer cont)
        {
            item.MoveToContainer(cont);
        }


        object OnItemAction(Item item, string cmd)
        {
            if (item == null || item.parent == null || item.parent.playerOwner == null) return null;
            if (cmd == "drop" && item.parent.playerOwner.inventory.containerWear.itemList.Contains(item) && Pants.Contains(item.info.shortname)) return true;
            return null;
        }

        private List<string> Pants = new List<string>
        {
        {"pants"},
        {"pants.shorts"},
        {"hazmat.pants"},
        {"burlap.trousers"},
        {"attire.hide.pants"},
        {"attire.hide.skirt"},
        {"roadsign.kilt"},
        {"heavy.plate.pants"},
        {"wood.armor.pants"},
        {"hazmatsuit" },
        };

        private ConfigData configData;
        class ConfigData
        {
            public string TypeOfPants_Shortname { get; set; }
            public ulong PantsSkin { get; set; }
        }
        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }
        protected override void LoadDefaultConfig()
        {
            var config = new ConfigData
            {
                PantsSkin = 0,
                TypeOfPants_Shortname = "pants",
            };
            SaveConfig(config);
        }
        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();
        void SaveConfig(ConfigData config) => Config.WriteObject(config, true);

    }
}

// --- End of file: NoNudity.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-sleepers ---
// --- Original File Path: N/NoSleepers/NoSleepers.cs ---

﻿using System;
using System.Linq;
using System.Collections.Generic;
using UnityEngine;
using Newtonsoft.Json;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("NoSleepers", "collect_vood", "0.5.7")]
    [Description("Prevents players from sleeping and optionally removes player corpses and bags")]

    class NoSleepers : CovalencePlugin
    {

        #region Config     

        private ConfigurationFile Configuration;
        private class ConfigurationFile
        {
            [JsonProperty(PropertyName = "Kill existing")]
            public bool KillExisting = false;
            [JsonProperty(PropertyName = "Remove corpses")]
            public bool RemoveCorpses = true;
            [JsonProperty(PropertyName = "Remove bags")]
            public bool RemoveBags = false;
            [JsonProperty(PropertyName = "Save last position")]
            public bool SaveLastPosition = false;
            [JsonProperty(PropertyName = "Save last inventory")]
            public bool SaveLastInventory = false;

            [JsonProperty(PropertyName = "Exclude Permission")]
            public string PermExclude = "nosleepers.exclude";

            [JsonProperty(PropertyName = "Player Inactivity Data Removal (hours)")]
            public int InactivityRemovalTime = 168;
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            Configuration = new ConfigurationFile();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            Configuration = Config.ReadObject<ConfigurationFile>();
            SaveConfig();
        }

        protected override void SaveConfig() => Config.WriteObject(Configuration);

        #endregion

        #region Data

        private StoredData AllStoredData;
        private Dictionary<string, PlayerData> AllPlayerData => AllStoredData.AllPlayerData;

        private class StoredData
        {
            [JsonProperty("All Player Data", ObjectCreationHandling = ObjectCreationHandling.Replace)]
            public Dictionary<string, PlayerData> AllPlayerData { get; private set; } = new Dictionary<string, PlayerData>();
        }

        public class PlayerData
        {
            [JsonProperty("Player Items")]
            public List<PlayerItem> PlayerItems;

            [JsonProperty("Last position")]
            public Vector3 LastPosition;

            [JsonProperty("Last active")]
            public long LastActive = DateTimeOffset.UtcNow.ToUnixTimeSeconds();
          
            public PlayerData()
            {

            }
        }

        public class PlayerItem
        {
            public enum ContainerType { Wear, Main, Belt }

            [JsonProperty("Name")]
            public string Shortname;
            [JsonProperty("Amount")]
            public int Amount;
            [JsonProperty("SkinId")]
            public ulong SkinId;
            [JsonProperty("Position")]
            public int Position;
            [JsonProperty("Condition")]
            public float Condition;
            [JsonProperty("Magazine")]
            public int Magazine;
            [JsonProperty("Container")]
            public ContainerType Container;
            [JsonProperty("Mods")]
            public List<int> Mods;

            public PlayerItem(string shortName, int amount, ulong skinId, int position, float condition, int magazine, ContainerType container, List<int> mods)
            {
                Shortname = shortName;
                Amount = amount;
                SkinId = skinId;
                Position = position;
                Condition = condition;
                Magazine = magazine;
                Container = container;
                Mods = mods;
            }
        }

        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, AllStoredData);

        private void LoadData()
        {
            AllStoredData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
            if (AllStoredData == null) AllStoredData = new StoredData();

            SaveData();
        }

        private void OnServerSave() => ClearUpData();

        private void Unload() => SaveData();

        private void ClearUpData()
        {
            if (Configuration.InactivityRemovalTime == 0) 
                return;

            var copy = new Dictionary<string, PlayerData>(AllPlayerData);
            foreach (var colData in copy)
            {
                if (colData.Value.LastActive == 0) 
                    continue;
                if (colData.Value.LastActive + (Configuration.InactivityRemovalTime * 3600) < DateTimeOffset.UtcNow.ToUnixTimeSeconds()) 
                    AllPlayerData.Remove(colData.Key);
            }

            SaveData();
        }

        #endregion

        #region Initialization
       
        void OnServerInitialized()
        {
            #if !RUST
            throw new NotSupportedException("This plugin does not support this game");
            #endif

            permission.RegisterPermission(Configuration.PermExclude, this);

            LoadData();

            if (!Configuration.KillExisting) 
                return;

            var killCount = 0;
            foreach (var ply in BasePlayer.sleepingPlayerList.ToList())
            {
                if (BasePlayer.activePlayerList.Contains(ply)) continue;
                if (!ply.IsDestroyed && !permission.UserHasPermission(ply.UserIDString, Configuration.PermExclude))
                {
                    ply.Die();
                    killCount++;
                }
            }

            if (killCount > 0) 
                Puts($"Killed {killCount} {(killCount == 1 ? "sleeper" : "sleepers")}");
        }

        #endregion

        #region Hooks

        void OnPlayerRespawned(BasePlayer player)
        {
            if (player.IsSleeping() && !permission.UserHasPermission(player.UserIDString, Configuration.PermExclude))
            {
                player.EndSleeping();

                if (!AllPlayerData.ContainsKey(player.UserIDString)) 
                    return;

                var playerData = AllPlayerData[player.UserIDString];
                if (playerData.PlayerItems != null) 
                    GivePlayerItems(player, playerData.PlayerItems);

                AllPlayerData.Remove(player.UserIDString);
            }
        }

        object OnPlayerRespawn(BasePlayer player)
        {
            if (!AllPlayerData.ContainsKey(player.UserIDString)) 
                return null;

            var playerData = AllPlayerData[player.UserIDString];
            if (playerData.LastPosition == Vector3.zero) 
                return null;

            Vector3 latestPos = playerData.LastPosition;
            playerData.LastPosition = Vector3.zero;

            return new BasePlayer.SpawnPoint { pos = latestPos };
        }

        void OnPlayerDisconnected(BasePlayer player)
        {
            if (!player.IsDestroyed && !permission.UserHasPermission(player.UserIDString, Configuration.PermExclude))
            {
                if (Configuration.SaveLastPosition || Configuration.SaveLastInventory)
                {
                    var playerData = new PlayerData();

                    if (Configuration.SaveLastPosition)
                        playerData.LastPosition = player.transform.position;
                    if (Configuration.SaveLastInventory)
                        playerData.PlayerItems = GetAllItems(player.inventory);

                    if (AllPlayerData.ContainsKey(player.UserIDString))
                        AllPlayerData[player.UserIDString] = playerData;
                    else 
                        AllPlayerData.Add(player.UserIDString, playerData);
                }

                player.Die();
            }
        }

        object OnServerCommand(ConsoleSystem.Arg arg)
        {
            if (arg.cmd.Name == "sleep")
            {
                var bPlayer = arg.Player();
                if (bPlayer == null || bPlayer.IsAdmin || permission.UserHasPermission(bPlayer.UserIDString, Configuration.PermExclude)) 
                    return null;

                return false;
            }
            return null;
        }

        void OnEntitySpawned(BaseNetworkable entity)
        {
            if (Configuration.RemoveCorpses && entity.ShortPrefabName.Equals("player_corpse")) 
                entity.Kill();
            if (Configuration.RemoveBags && entity.ShortPrefabName.Equals("item_drop_backpack")) 
                entity.Kill();
        }

        //object OnPlayerSleep(BasePlayer player) => true; // TODO: Hook might be causing local player duplication

        #endregion

        #region Helpers

        List<PlayerItem> GetAllItems(PlayerInventory inventory)
        {           
            var playerItems = new List<PlayerItem>();

            foreach (var item in inventory.containerBelt.itemList)
            {
                List<int> mods = new List<int>();

                int magazine = 0;
                BaseProjectile weapon = item.GetHeldEntity() as BaseProjectile;
                if (weapon != null) magazine = weapon.primaryMagazine.contents;
                if (item.contents != null)
                {
                    foreach (var contentItem in item.contents.itemList)
                    {
                        mods.Add(contentItem.info.itemid);
                    };
                }
                playerItems.Add(new PlayerItem(item.info.shortname, item.amount, item.skin, item.position, item.condition, magazine, PlayerItem.ContainerType.Belt, mods));

            }
            foreach (var item in inventory.containerMain.itemList)
            {
                List<int> mods = new List<int>();

                int magazine = 0;
                BaseProjectile weapon = item.GetHeldEntity() as BaseProjectile;
                if (weapon != null) magazine = weapon.primaryMagazine.contents;
                if (item.contents != null)
                {
                    foreach (var contentItem in item.contents.itemList)
                    {
                        mods.Add(contentItem.info.itemid);
                    };
                }
                playerItems.Add(new PlayerItem(item.info.shortname, item.amount, item.skin, item.position, item.condition, magazine, PlayerItem.ContainerType.Main, mods));
            }
            foreach (var item in inventory.containerWear.itemList)
            {
                playerItems.Add(new PlayerItem(item.info.shortname, item.amount, item.skin, item.position, item.condition, 0, PlayerItem.ContainerType.Wear, new List<int>()));
            }
            return playerItems;
        }

        void GivePlayerItems(BasePlayer player, List<PlayerItem> playerItems)
        {
            player.inventory.containerBelt.Clear();
            player.inventory.containerMain.Clear();
            player.inventory.containerWear.Clear();
            ItemManager.DoRemoves();

            foreach (var playerItem in playerItems)
            {
                var item = ItemManager.CreateByName(playerItem.Shortname, playerItem.Amount, playerItem.SkinId);
                var weapon = item.GetHeldEntity() as BaseProjectile;
                if (weapon != null) weapon.primaryMagazine.contents = playerItem.Magazine;
                item.condition = playerItem.Condition;

                switch (playerItem.Container)
                {
                    case PlayerItem.ContainerType.Belt:
                        item.MoveToContainer(player.inventory.containerBelt, playerItem.Position);
                        break;
                    case PlayerItem.ContainerType.Main:
                        item.MoveToContainer(player.inventory.containerMain, playerItem.Position);
                        break;
                    case PlayerItem.ContainerType.Wear:
                        item.MoveToContainer(player.inventory.containerWear, playerItem.Position);
                        break;
                }

                foreach (var mod in playerItem.Mods)
                {
                    Item modItem = ItemManager.CreateByItemID(mod, 1, 0);

                    item.contents.AddItem(modItem.info, 1);
                }
            }
        }

        #endregion

    }
}

// --- End of file: NoSleepers.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-experiments ---
// --- Original File Path: N/NoExperiments/NoExperiments.cs ---

using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("No Experiments", "Orange", "1.0.1")]
    [Description("Plugin disables experiments in workbenches")]
    public class NoExperiments : RustPlugin
    {
        #region Oxide Hooks

        private object CanExperiment(BasePlayer player, Workbench workbench)
        {
            switch (workbench.Workbenchlevel)
            {
                case 1:
                    return config.block1 ? false : (object) null;
                case 2:
                    return config.block2 ? false : (object) null;
                case 3:
                    return config.block3 ? false : (object) null;
                default:
                    return false;
            }
        }

        #endregion
        
        #region Configuration
        
        private static ConfigData config;
        
        private class ConfigData
        {    
            [JsonProperty(PropertyName = "Block on lvl 1")]
            public bool block1;
            
            [JsonProperty(PropertyName = "Block on lvl 2")]
            public bool block2;
            
            [JsonProperty(PropertyName = "Block on lvl 3")]
            public bool block3;
        }
        
        private ConfigData GetDefaultConfig()
        {
            return new ConfigData 
            {
                block1 = true,
                block2 = true,
                block3 = true
            };
        }
        
        protected override void LoadConfig()
        {
            base.LoadConfig();
   
            try
            {
                config = Config.ReadObject<ConfigData>();
        
                if (config == null)
                {
                    LoadDefaultConfig();
                }
            }
            catch
            {
                LoadDefaultConfig();
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintError("Configuration file is corrupt(or not exists), creating new one!");
            config = GetDefaultConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }
        
        #endregion
    }
}

// --- End of file: NoExperiments.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/npc-vendor-modifier ---
// --- Original File Path: N/NPCVenderModifier/NPCVenderModifier.cs ---

﻿using System;
using System.Collections.Generic;


//TODO Blacklist, different multi based on each item. Different NPC vending shop support.
namespace Oxide.Plugins
{
    [Info("NPC Vender Modifier", "Default", "1.0.1")]
    [Description("Allows changing the multiplier of the NPC shops")]
    public class NPCVenderModifier : RustPlugin
    {
        int shopMulti;
        bool Changed = false;
        private const string permissionName = "npcvendermodifier.use";


        object OnGiveSoldItem(NPCVendingMachine vending, Item soldItem, BasePlayer buyer)
        {
            if (vending.OwnerID >= 1)
            {
                return null;
            }

            if (soldItem == null)
            {
                return null;
            }

            if (!permission.UserHasPermission(buyer.UserIDString, permissionName))
            {
                soldItem.amount = soldItem.amount * 1;
                buyer.GiveItem(soldItem);
                return soldItem.amount;
            }

            soldItem.amount = soldItem.amount * shopMulti;
            buyer.GiveItem(soldItem);

            return soldItem.amount;
        }


        void Init()
        {
            LoadVariables();
            permission.RegisterPermission(permissionName, this);
        }

        object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }

        void LoadVariables()
        {

            shopMulti = Convert.ToInt32(GetConfig("Vendor", "Multiplier", 2));
            //medkitPendingAmount = Convert.ToSingle(GetConfig("Medkits", "Pending health to add", 35f));

            if (!Changed) return;
            SaveConfig();
            Changed = false;
        }

        protected override void LoadDefaultConfig()
        {
            LoadVariables();
        }



    }
}

// --- End of file: NPCVenderModifier.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-clip-restrictions ---
// --- Original File Path: N/NoClipRestrictions/NoClipRestrictions.cs ---

﻿using System;
using System.Collections;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using UnityEngine;
using System.Linq;

namespace Oxide.Plugins
{
	[Info("NoClip Restrictions", "2CHEVSKII", "0.1.1")]
	[Description("Blocks usage of certain commands and items as well as dealing and receiving damage while in noclip mode")]
	internal class NoClipRestrictions : CovalencePlugin
	{
		#region Fields


		private const string PERMISSIONBYPASS = "nocliprestrictions.bypass";

		private bool check_running;

		private PluginSettings Settings { get; set; }


		#endregion

		#region Configuration


		private class PluginSettings
		{
			[JsonProperty("Blocked items (player cannot set them active while nocliping)")]
			public List<string> BlockedItems { get; set; }

			[JsonProperty("Blocked commands (player cannot execute them while nocliping)")]
			public List<string> BlockedCommands { get; set; }

			[JsonProperty("Block outgoing damage")]
			public bool BlockOutDamage { get; set; }

			[JsonProperty("Block incoming damage")]
			public bool BlockInDamage { get; set; }
		}

		protected override void LoadConfig()
		{
			base.LoadConfig();
			try
			{
				Settings = Config.ReadObject<PluginSettings>();
				if(Settings?.BlockedItems == null || Settings.BlockedCommands == null) throw new Exception();
			}
			catch
			{
				LoadDefaultConfig();
			}
		}

		protected override void LoadDefaultConfig()
		{
			Settings = new PluginSettings
			{
				BlockedItems = new List<string>
				{
					"rifle.ak"
				},
				BlockedCommands = new List<string>
				{
					"tpa"
				},
				BlockOutDamage = false,
				BlockInDamage = false
			};

			SaveConfig();
		}

		protected override void SaveConfig() => Config.WriteObject(Settings);


		#endregion

		#region LangAPI


		private readonly Dictionary<string, string> defaultmessages_en = new Dictionary<string, string>
		{
			[mprefix] = "NoClip restrictions: ",
			[mblockeditem] = "Item <color=#32a885>{0}</color> cannot be used while nocliping!",
			[mblockedcommand] = "Command '<color=#32a885>{0}</color>' cannot be used while nocliping!",
			[mblockedoutdmg] = "<color=#f7663e>You can't hurt anyone while nocliping!</color>",
			[mblockedindmg] = "<color=#f78b3e>You can't hurt person who is nocliping!</color>"
		};

		private const string mprefix = "Prefix",
							 mblockeditem = "Item blocked",
							 mblockedcommand = "Command blocked",
							 mblockedoutdmg = "Outgoing damage blocked",
							 mblockedindmg = "Incoming damage blocked",
							 mblockedusageitem = "Item usage blocked",
							 mblockedusageentity = "Entity usage blocked";

		protected override void LoadDefaultMessages() => lang.RegisterMessages(defaultmessages_en, this);

		private string GetLocalizedString(IPlayer player, string key, params object[] args) => string.Format(lang.GetMessage(key, this, player?.Id), args);

		private void SendMessageRaw(IPlayer player, string message) => player?.Message(message);

		private void SendMessage(IPlayer player, string key, params object[] args) => SendMessageRaw(player, GetLocalizedString(player, mprefix) + GetLocalizedString(player, key, args));

		private void SendMessage(BasePlayer player, string key, params object[] args) => SendMessage(player.IPlayer, key, args);


		#endregion

		#region Hooks


		private object OnPlayerAttack(BasePlayer attacker, HitInfo info)
		{
			if(attacker.IPlayer.HasPermission(PERMISSIONBYPASS)) return null;

			if(attacker.IsFlying && Settings.BlockOutDamage)
			{
				SendMessage(attacker, mblockedoutdmg);
				return true;
			}

			BasePlayer target = info?.HitEntity as BasePlayer;

			if(target == null) return null;

			if(!target.IsFlying || !Settings.BlockInDamage) return null;

			SendMessage(attacker, mblockedindmg);
			return true;

		}

		private void OnPlayerActiveItemChanged(BasePlayer player) => CheckHeld(player, true);

		private void OnServerInitialized() => timer.Every(10f, () =>
		{
			if(!check_running) ServerMgr.Instance.StartCoroutine(CheckRoutine());
		});

		

		//private object OnUserCommand(IPlayer player, string command)
		//{
		//	Puts($"OnUserCommand: {player.Name}\nCommand: {command}");
		//	BasePlayer basePlayer = player.Object as BasePlayer;

		//	if(basePlayer == null || !basePlayer.IsFlying || player.HasPermission(PERMISSIONBYPASS)) return null;

		//	if(Settings.BlockedCommands.Contains(command))
		//	{
		//		SendMessage(player, mblockedcommand, command);
		//		return true;
		//	}

		//	return null;
		//}

		object OnPlayerCommand(ConsoleSystem.Arg arg)
		{
			if(arg.cmd.Name != "say")
			{
				return null;
			}

			var player = arg.Player();
			if(player == null || !player.IsFlying || permission.UserHasPermission(player.UserIDString, PERMISSIONBYPASS))
			{
				return null;
			}
			var command = arg.Args?[0].TrimStart('/');
			if(!Settings.BlockedCommands.Contains(command))
			{
				return null;
			}

			SendMessage(player, mblockedcommand, command);
			return true;
		}


		#endregion

		#region Helpers


		private IEnumerator CheckRoutine()
		{
			check_running = true;
			foreach(BasePlayer player in BasePlayer.activePlayerList.Where(p => p.Connection.authLevel > 0))
			{
				CheckHeld(player);
				yield return new WaitForEndOfFrame();
			}

			check_running = false;
		}

		private void CheckHeld(BasePlayer player, bool message = false)
		{
			if(player == null || !player.IsFlying || player.IPlayer == null || player.IPlayer.HasPermission(PERMISSIONBYPASS)) return;

			Item item = player.GetActiveItem();
			HeldEntity ent = item?.GetHeldEntity() as HeldEntity;

			if(ent == null || !Settings.BlockedItems.Contains(item.info.shortname)) return;

			ent.SetHeld(false);
			if(message)
				SendMessage(player, mblockeditem, item.info.shortname);
		}


		#endregion

	}
}

// --- End of file: NoClipRestrictions.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-duds ---
// --- Original File Path: N/NoDuds/NoDuds.cs ---

﻿using Newtonsoft.Json;
namespace Oxide.Plugins
{
	[Info("No Duds", "bearr", 1.2)]
	[Description("Prevents explosives from becoming dud")]
	class NoDuds : RustPlugin
	{
		private GameConfig config;
		protected override void LoadConfig()
		{
			base.LoadConfig();
			try
			{
				config = Config.ReadObject<GameConfig>();
				if (config == null)
					PrintToConsole("Couldn't read config");

				Config.WriteObject(config);
			}
			catch
			{
				LoadDefaultConfig();
			}
		}

		private void Init()
		{
			permission.RegisterPermission("noduds.use", this);
		}

		object OnExplosiveDud(DudTimedExplosive explosive)
		{
			BasePlayer player = explosive.creatorEntity.ToPlayer();

			if (explosive.ShortPrefabName == "explosive.satchel.deployed" && permission.UserHasPermission(player.userID.ToString(), "noduds.use") == true)
			{
				if (config.satcheldud == false)
				{
					return true;
				}
				else if (config.satcheldud == true)
				{
					return null;
				}
			}
			else if (explosive.ShortPrefabName == "grenade.beancan.deployed" && permission.UserHasPermission(player.userID.ToString(), "noduds.use") == true)
			{
				if (config.beancandud == false)
				{
					return true;
				}
				else if (config.beancandud == true)
				{
					return null;
				}
			}
			return null;
		}

		private class GameConfig
		{
			[JsonProperty("Satchel Charge Dud")] public bool satcheldud { get; set; }
			[JsonProperty("Beancan Dud")] public bool beancandud { get; set; }
		}

		private GameConfig GetDefaultConfig()
		{
			return new GameConfig
			{
				satcheldud = false,
				beancandud = false
			};
		}

		protected override void LoadDefaultConfig()
		{
			Config.WriteObject(GetDefaultConfig(), true);
		}
	}
}

// --- End of file: NoDuds.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-metabolism ---
// --- Original File Path: N/NoMetabolism/NoMetabolism.cs ---

using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("No Metabolism", "MON@H", "1.1.3")]
    [Description("Allows the player to have a consistent metabolism.")]
    public class NoMetabolism : CovalencePlugin
    {
        #region Class Fields

        private const string PermissionUse = "nometabolism.use";

        #endregion Class Fields

        #region Initialization

        private void Init()
        {
            permission.RegisterPermission(PermissionUse, this);
        }

        #endregion Initialization

        #region Configuration

        private ConfigData _configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Activate for all players without permission")]
            public bool AllAllowed = false;

            [JsonProperty(PropertyName = "Activate for admins without permission")]
            public bool AdminsAllowed = false;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _configData = Config.ReadObject<ConfigData>();
                if (_configData == null)
                {
                    LoadDefaultConfig();
                    SaveConfig();
                }
            }
            catch
            {
                PrintError("The configuration file is corrupted");
                LoadDefaultConfig();
                SaveConfig();
            }
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            _configData = new ConfigData();
        }

        protected override void SaveConfig() => Config.WriteObject(_configData);

        #endregion Configuration

        #region OxideHooks

        object OnRunPlayerMetabolism(PlayerMetabolism metabolism, BasePlayer player)
        {
            if (player == null || metabolism == null)
            {
                return null;
            }

            if (_configData.AllAllowed || (_configData.AdminsAllowed && player.IsAdmin))
            {
                return HandlePlayerMetabolism(metabolism, player);
            }

            if (permission.UserHasPermission(player.UserIDString, PermissionUse))
            {
                return HandlePlayerMetabolism(metabolism, player);
            }

            return null;
        }

        #endregion OxideHooks

        #region Core

        private object HandlePlayerMetabolism(PlayerMetabolism metabolism, BasePlayer player)
        {
            if (metabolism.bleeding.value > metabolism.bleeding.min)
            {
                metabolism.bleeding.Reset();
                metabolism.isDirty = true;
                metabolism.SendChangesToClient();
            }

            if (metabolism.calories.value < metabolism.calories.max)
            {
                metabolism.calories.value = metabolism.calories.max;
            }

            if (metabolism.comfort.value < 0)
            {
                metabolism.comfort.value = 0;
            }

            if (metabolism.hydration.value < metabolism.hydration.max)
            {
                metabolism.hydration.value = metabolism.hydration.max;
            }

            if (metabolism.oxygen.value < metabolism.oxygen.max)
            {
                metabolism.oxygen.value = metabolism.oxygen.max;
            }

            if (metabolism.poison.value > metabolism.poison.min)
            {
                metabolism.poison.value = metabolism.poison.min;
            }

            if (metabolism.radiation_level.value > metabolism.radiation_level.min)
            {
                metabolism.radiation_level.value = metabolism.radiation_level.min;
            }

            if (metabolism.radiation_poison.value > metabolism.radiation_poison.min)
            {
                metabolism.radiation_poison.value = metabolism.radiation_poison.min;
            }

            if (metabolism.temperature.value > PlayerMetabolism.HotThreshold || metabolism.temperature.value < PlayerMetabolism.ColdThreshold)
            {
                metabolism.temperature.value = (PlayerMetabolism.HotThreshold + PlayerMetabolism.ColdThreshold) / 2;
            }

            if (metabolism.wetness.value > metabolism.wetness.min)
            {
                metabolism.wetness.value = metabolism.wetness.min;
            }

            if (metabolism.pending_health.value > 1)
            {
                player.Heal(1);
                metabolism.pending_health.value -= 1;
            }
            else if (metabolism.pending_health.value > 0)
            {
                player.Heal(metabolism.pending_health.value);
                metabolism.pending_health.value = 0;
            }

            player.SetPlayerFlag(BasePlayer.PlayerFlags.Workbench1, player.currentCraftLevel == 1f);
            player.SetPlayerFlag(BasePlayer.PlayerFlags.Workbench2, player.currentCraftLevel == 2f);
            player.SetPlayerFlag(BasePlayer.PlayerFlags.Workbench3, player.currentCraftLevel == 3f);

            player.SetPlayerFlag(BasePlayer.PlayerFlags.SafeZone, player.InSafeZone());

            return true;
        }

        #endregion Core
    }
}

// --- End of file: NoMetabolism.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/nav-mesh-error-fix ---
// --- Original File Path: N/NavMeshErrorFix/NavMeshErrorFix.cs ---

using System.Text.RegularExpressions;
using System.Collections.Generic;
using Rust;
using UnityEngine;
using Application = UnityEngine.Application;
using Server = ConVar.Server;

namespace Oxide.Plugins
{
    [Info("Nav Mesh Error Fix", "Ryz0r", "1.1.1")]
    [Description("Fixes the dreaded NavMesh Error Spam.")]
    class NavMeshErrorFix : CovalencePlugin
    {
        private void Init()
        {
            Application.logMessageReceived += HandleLog;
        }

        private void Unload()
        {
            Application.logMessageReceived -= HandleLog;
        }
        
        private void HandleLog(string message, string stackTrace, LogType type)
        {
            var navmeshMatch = new Regex(@"([^0-9()| ]*) failed to sample navmesh at position (.*) on area").Match(message);
            if (!navmeshMatch.Success) return;

            var mPrefab = navmeshMatch.Groups[1].ToString();
            var mPosition = navmeshMatch.Groups[2].ToString().ToVector3();
            
            var entities = new List<BaseEntity>();
            Vis.Entities(mPosition, 5f, entities);

            if (entities.Count < 1) return;
            
            foreach (var entity in entities) {
                if (entity.PrefabName == mPrefab && !entity.IsDestroyed) {
                    entity.Kill();
                    Puts($"Located & Killed Stuck {mPrefab} at {mPosition}");
                    break;
                }
            }
        }

    }
}

// --- End of file: NavMeshErrorFix.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/npc-vending-reset ---
// --- Original File Path: N/NPCVendingReset/NPCVendingReset.cs ---

﻿using Oxide.Core.Libraries.Covalence;
using System.Collections.Generic;


namespace Oxide.Plugins
{
    [Info("NPC Vending Reset", "Whispers88", "1.0.9")]
    [Description("Reset all NPC vending machines")]
    public class NPCVendingReset : CovalencePlugin
    {
        private void vendingreset()
        {
            foreach (var entity in BaseNetworkable.serverEntities)
            {
                var vending = entity as NPCVendingMachine;
                if (vending != null && !vending.IsDestroyed)
                {
                    vending.ClearSellOrders();
                    vending.ClearPendingOrder();
                    vending.inventory.Clear();
                    vending.InstallFromVendingOrders();
                }
            }
        }

        [Command("vendingreset"), Permission("npcvendingreset.allowed")]
        private void Resetvendingmachines(IPlayer player, string command, string[] args)
        {
                vendingreset();
                player.Reply(lang.GetMessage("VendingReset", this, player.Id));
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["VendingReset"] = "Vending Machines have been reset."

            }, this, "en");
        }
    }
}


// --- End of file: NPCVendingReset.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-respawn-cooldowns ---
// --- Original File Path: N/NoRespawnCooldowns/NoRespawnCooldowns.cs ---

﻿namespace Oxide.Plugins
{
    [Info("No Respawn Cooldowns", "Absolut", "1.0.3")]
    [Description("Disables respawn cooldown for players with permission")]
    class NoRespawnCooldowns : RustPlugin
    {
        private const string permAllow = "norespawncooldowns.allow";

        private void Init()
        {
            permission.RegisterPermission(permAllow, this);
        }

        private void OnPlayerDeath(BasePlayer player, HitInfo info)
        {
            if (permission.UserHasPermission(player.UserIDString, permAllow))
                ResetSpawnTargets(player);
        }

        private void ResetSpawnTargets(BasePlayer player)
        {
            SleepingBag[] bags = SleepingBag.FindForPlayer(player.userID, true);
            foreach (SleepingBag bag in bags)
                bag.unlockTime = 0f;
        }
    }
}


// --- End of file: NoRespawnCooldowns.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-engine-parts ---
// --- Original File Path: N/NoEngineParts/NoEngineParts.cs ---

﻿using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Serialization;
using Oxide.Core;
using System;
using System.Collections.Generic;
using System.Linq;
using Rust.Modular;

namespace Oxide.Plugins
{
    [Info("No Engine Parts", "WhiteThunder", "1.0.1")]
    [Description("Allows modular cars to be driven without engine parts.")]
    internal class NoEngineParts : CovalencePlugin
    {
        #region Fields

        private const string PermissionPresetPrefix = "noengineparts.preset";

        private Configuration pluginConfig;

        #endregion

        #region Hooks

        private void Init()
        {
            foreach (var preset in pluginConfig.presetsRequiringPermission)
                if (!string.IsNullOrWhiteSpace(preset.name))
                    permission.RegisterPermission(GetPresetPermission(preset.name), this);
        }

        private void OnEntityMounted(ModularCarSeat seat)
        {
            var car = seat.associatedSeatingModule?.Vehicle as ModularCar;
            if (car == null)
                return;

            // Only refresh engine loadout if engine cannot be started, else handle in OnEngineStarted
            if (car.HasDriver() && !car.HasAnyWorkingEngines())
                RefreshCarEngineLoadouts(car);
        }

        private void OnEngineStarted(ModularCar car) =>
            RefreshCarEngineLoadouts(car);

        private object OnEngineLoadoutRefresh(EngineStorage engineStorage)
        {
            var enginePreset = DetermineEnginePresetForStorage(engineStorage);
            if (enginePreset == null)
                return null;

            if (TryRefreshEngineLoadout(engineStorage, enginePreset))
                return false;

            return null;
        }

        #endregion

        #region Helper Methods

        private bool OverrideLoadoutWasBlocked(EngineStorage engineStorage)
        {
            object hookResult = Interface.CallHook("OnEngineLoadoutOverride", engineStorage);
            return hookResult is bool && (bool)hookResult == false;
        }

        private string GetPresetPermission(string presetName) => $"{PermissionPresetPrefix}.{presetName}";

        private void RefreshCarEngineLoadouts(ModularCar car)
        {
            var enginePreset = DetermineEnginePresetForOwner(car.OwnerID);
            if (enginePreset == null)
                return;

            foreach (var module in car.AttachedModuleEntities)
            {
                var engineModule = module as VehicleModuleEngine;
                if (engineModule == null)
                    continue;

                var engineStorage = engineModule.GetContainer() as EngineStorage;
                if (engineStorage == null)
                    continue;

                TryRefreshEngineLoadout(engineStorage, enginePreset);
            }
        }

        private bool TryRefreshEngineLoadout(EngineStorage engineStorage, EnginePreset enginePreset)
        {
            if (OverrideLoadoutWasBlocked(engineStorage))
                return false;

            var acceleration = 0f;
            var topSpeed = 0f;
            var fuelEconomy = 0f;

            for (var slot = 0; slot < engineStorage.inventory.capacity; slot++)
            {
                var engineItemType = engineStorage.slotTypes[slot];

                var item = engineStorage.inventory.GetSlot(slot);
                var itemValue = 0f;
                if (item != null && !item.isBroken)
                {
                    var component = item.info.GetComponent<ItemModEngineItem>();
                    if (component != null)
                        itemValue = item.amount * engineStorage.GetTierValue(component.tier);
                }

                if (engineItemType.BoostsAcceleration())
                    acceleration += Math.Max(itemValue, enginePreset.acceleration);

                if (engineItemType.BoostsFuelEconomy())
                    fuelEconomy += Math.Max(itemValue, enginePreset.fuelEconomy);

                if (engineItemType.BoostsTopSpeed())
                    topSpeed += Math.Max(itemValue, enginePreset.topSpeed);
            }

            engineStorage.isUsable = acceleration > 0 && topSpeed > 0 && fuelEconomy > 0;
            engineStorage.accelerationBoostPercent = acceleration / engineStorage.accelerationBoostSlots;
            engineStorage.fuelEconomyBoostPercent = fuelEconomy / engineStorage.fuelEconomyBoostSlots;
            engineStorage.topSpeedBoostPercent = topSpeed / engineStorage.topSpeedBoostSlots;
            engineStorage.SendNetworkUpdate();
            engineStorage.GetEngineModule()?.RefreshPerformanceStats(engineStorage);

            return true;
        }

        #endregion

        #region Configuration

        private EnginePreset DetermineEnginePresetForStorage(EngineStorage engineStorage)
        {
            var car = engineStorage.GetEngineModule()?.Vehicle as ModularCar;
            if (car == null)
                return pluginConfig.defaultPreset;

            return DetermineEnginePresetForOwner(car.OwnerID);
        }

        private EnginePreset DetermineEnginePresetForOwner(ulong ownerId)
        {
            if (ownerId == 0 || pluginConfig.presetsRequiringPermission == null)
                return pluginConfig.defaultPreset;

            var ownerIdString = ownerId.ToString();
            for (var i = pluginConfig.presetsRequiringPermission.Length - 1; i >= 0; i--)
            {
                var preset = pluginConfig.presetsRequiringPermission[i];
                if (!string.IsNullOrWhiteSpace(preset.name) &&
                    permission.UserHasPermission(ownerIdString, GetPresetPermission(preset.name)))
                {
                    return preset;
                }
            }

            return pluginConfig.defaultPreset;
        }

        private Configuration GetDefaultConfig() => new Configuration();

        internal class Configuration : SerializableConfiguration
        {
            [JsonProperty("DefaultPreset")]
            public EnginePreset defaultPreset = new EnginePreset()
            {
                acceleration = 0.3f,
                topSpeed = 0.3f,
                fuelEconomy = 0.3f,
            };

            [JsonProperty("PresetsRequiringPermission")]
            public EnginePreset[] presetsRequiringPermission = new EnginePreset[]
            {
                new EnginePreset ()
                {
                    name = "tier1",
                    acceleration = 0.6f,
                    topSpeed = 0.6f,
                    fuelEconomy = 0.6f,
                },
                new EnginePreset ()
                {
                    name = "tier2",
                    acceleration = 0.8f,
                    topSpeed = 0.8f,
                    fuelEconomy = 0.8f,
                },
                new EnginePreset ()
                {
                    name = "tier3",
                    acceleration = 1,
                    topSpeed = 1,
                    fuelEconomy = 1,
                },
                new EnginePreset ()
                {
                    name = "tier4",
                    acceleration = 2,
                    topSpeed = 2,
                    fuelEconomy = 2,
                },
                new EnginePreset()
                {
                    name = "tier5",
                    acceleration = 3,
                    topSpeed = 3,
                    fuelEconomy = 3,
                },
                new EnginePreset()
                {
                    name = "tier6",
                    acceleration = 4,
                    topSpeed = 4,
                    fuelEconomy = 4,
                },
            };
        }

        internal class EnginePreset
        {
            [JsonProperty("Name", DefaultValueHandling = DefaultValueHandling.Ignore)]
            public string name;

            [JsonProperty("Acceleration")]
            public float acceleration;

            [JsonProperty("TopSpeed")]
            public float topSpeed;

            [JsonProperty("FuelEconomy")]
            public float fuelEconomy;
        }

        #endregion

        #region Configuration Boilerplate

        internal class SerializableConfiguration
        {
            public string ToJson() => JsonConvert.SerializeObject(this);

            public Dictionary<string, object> ToDictionary() => JsonHelper.Deserialize(ToJson()) as Dictionary<string, object>;
        }

        internal static class JsonHelper
        {
            public static object Deserialize(string json) => ToObject(JToken.Parse(json));

            private static object ToObject(JToken token)
            {
                switch (token.Type)
                {
                    case JTokenType.Object:
                        return token.Children<JProperty>()
                                    .ToDictionary(prop => prop.Name,
                                                  prop => ToObject(prop.Value));

                    case JTokenType.Array:
                        return token.Select(ToObject).ToList();

                    default:
                        return ((JValue)token).Value;
                }
            }
        }

        private bool MaybeUpdateConfig(SerializableConfiguration config)
        {
            var currentWithDefaults = config.ToDictionary();
            var currentRaw = Config.ToDictionary(x => x.Key, x => x.Value);
            return MaybeUpdateConfigDict(currentWithDefaults, currentRaw);
        }

        private bool MaybeUpdateConfigDict(Dictionary<string, object> currentWithDefaults, Dictionary<string, object> currentRaw)
        {
            bool changed = false;

            foreach (var key in currentWithDefaults.Keys)
            {
                object currentRawValue;
                if (currentRaw.TryGetValue(key, out currentRawValue))
                {
                    var defaultDictValue = currentWithDefaults[key] as Dictionary<string, object>;
                    var currentDictValue = currentRawValue as Dictionary<string, object>;

                    if (defaultDictValue != null)
                    {
                        if (currentDictValue == null)
                        {
                            currentRaw[key] = currentWithDefaults[key];
                            changed = true;
                        }
                        else if (MaybeUpdateConfigDict(defaultDictValue, currentDictValue))
                            changed = true;
                    }
                }
                else
                {
                    currentRaw[key] = currentWithDefaults[key];
                    changed = true;
                }
            }

            return changed;
        }

        protected override void LoadDefaultConfig() => pluginConfig = GetDefaultConfig();

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                pluginConfig = Config.ReadObject<Configuration>();
                if (pluginConfig == null)
                {
                    throw new JsonException();
                }

                if (MaybeUpdateConfig(pluginConfig))
                {
                    LogWarning("Configuration appears to be outdated; updating and saving");
                    SaveConfig();
                }
            }
            catch
            {
                LogWarning($"Configuration file {Name}.json is invalid; using defaults");
                LoadDefaultConfig();
            }
        }

        protected override void SaveConfig()
        {
            Log($"Configuration changes saved to {Name}.json");
            Config.WriteObject(pluginConfig, true);
        }

        #endregion
    }
}


// --- End of file: NoEngineParts.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-fireworks-on-terrain ---
// --- Original File Path: N/NoFireworksOnTerrain/NoFireworksOnTerrain.cs ---

﻿using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("No Fireworks On Terrain", "0x89A", "1.0.4")]
    [Description("Restricts placement of fireworks")]

    public class NoFireworksOnTerrain : RustPlugin
    {
        const string bypassPermission = "nofireworksonterrain.bypass";

        private HashSet<uint> fireworkPrefabIds = new HashSet<uint> { 1538862213, 3537935076, 1303486792, 2125925416, 2059113456, 571344195,  //Big Boomers
                                                                       2628631722, 2847715782, 1410649145, 793494534,  //Roman Candles
                                                                       1311124308, 2771932546, 4042905807 };  //Volcanoes

        #region -Init-

        void Init() => permission.RegisterPermission(bypassPermission, this);

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["NotOnFoundationFloor"] = "Fireworks must be placed on a foundation or floor"
            }
            , this);
        }

        #endregion

        private object CanBuild(Planner planner, Construction prefab, Construction.Target target)
        {
            BasePlayer player = planner.GetOwnerPlayer();

            if (player != null && fireworkPrefabIds.Contains(prefab.prefabID) && !permission.UserHasPermission(player.UserIDString, bypassPermission) && target.entity == null)
            {
                PrintToChat(player, lang.GetMessage("NotOnFoundationFloor", this, player.UserIDString));

                return true;
            }

            return null;
        }
    }
}


// --- End of file: NoFireworksOnTerrain.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/npc-target ---
// --- Original File Path: N/NpcTarget/NpcTarget.cs ---

namespace Oxide.Plugins
{
    [Info("NPC Target", "misticos", "1.0.4")]
    [Description("Prevent NPCs from targeting each other")]
    class NpcTarget : RustPlugin
    {
        private object OnNpcTarget(BaseEntity attacker, BaseEntity entity)
        {
            if (IsNpc(entity))
                return true;

            return null;
        }

        private object CanBradleyApcTarget(BradleyAPC attacker, BaseEntity entity)
        {
            if (IsNpc(entity))
                return false;

            return null;
        }

        private bool IsNpc(BaseEntity entity) =>
            entity != null && entity.IsNpc;
    }
}

// --- End of file: NpcTarget.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/note-write-control ---
// --- Original File Path: N/NoteWriteControl/NoteWriteControl.cs ---

﻿using System;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Note Write Control", "Gachl", "1.0.1")]
    [Description("Control how players can write notes (create new, append to, or edit all)")]
    class NoteWriteControl : RustPlugin
    {
        private static readonly string PERMISSION_WRITE = "notewritecontrol.canwrite";
        private static readonly string PERMISSION_APPEND = "notewritecontrol.canappend";
        private static readonly string PERMISSION_EDIT = "notewritecontrol.canedit";

        private void Init()
        {
            permission.RegisterPermission(NoteWriteControl.PERMISSION_APPEND, this);
            permission.RegisterPermission(NoteWriteControl.PERMISSION_WRITE, this);
            permission.RegisterPermission(NoteWriteControl.PERMISSION_EDIT, this);
        }

        [ConsoleCommand("note.update")]
        void NoteUpdateCommand(ConsoleSystem.Arg arg)
        {
            if (arg.Args.Length != 2)
                return;

            uint noteUID = 0;
            if (!uint.TryParse(arg.Args[0], out noteUID))
                return;

            BasePlayer editor = arg.Player();

            if (editor == null)
                return;

            Item note = editor.inventory.FindItemUID(noteUID);
            if (note == null)
                return;

            string currentText = note.text ?? "";
            string newText = arg.Args[1];

            bool editPermOrAdmin = editor.IPlayer.HasPermission(NoteWriteControl.PERMISSION_EDIT) || editor.IsAdmin || editor.IsDeveloper;
            bool writePermAndEmpty = editor.IPlayer.HasPermission(NoteWriteControl.PERMISSION_WRITE) && String.IsNullOrEmpty(currentText);
            bool appendPermAndHasAppended = editor.IPlayer.HasPermission(NoteWriteControl.PERMISSION_APPEND) && currentText.Length > 0 && newText.Length > currentText.Length && newText.Substring(0, currentText.Length) == currentText;

            if (editPermOrAdmin || writePermAndEmpty || appendPermAndHasAppended)
                note.text = newText;

            note.MarkDirty();
        }
    }
}


// --- End of file: NoteWriteControl.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-green ---
// --- Original File Path: N/NoGreen/NoGreen.cs ---

using System;
using CompanionServer;
using ConVar;
using Facepunch;
using Facepunch.Math;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("No Green", "Iv Misticos", "1.3.10")]
    [Description("Remove admins' green names")]
    class NoGreen : RustPlugin
    {
	    private bool OnPlayerChat(BasePlayer player, string message, Chat.ChatChannel channel)
	    {
		    if (Chat.serverlog)
		    {
			    ServerConsole.PrintColoured(ConsoleColor.DarkYellow,
				    string.Concat("[", channel, "] ", player.displayName, ": "), ConsoleColor.DarkGreen, message);
			    
			    var str = (player != null ? player.ToString() : null) ??
			              $"{player.displayName}[{player.userID}]";
			    
			    if (channel == Chat.ChatChannel.Team)
			    {
				    DebugEx.Log("[TEAM CHAT] " + str + " : " + message);
			    }
			    else
			    {
				    DebugEx.Log("[CHAT] " + str + " : " + message);
			    }
		    }

		    var color = "#5af";
		    var displayName = player.displayName.EscapeRichText();
		    var chatEntry = new Chat.ChatEntry
		    {
			    Channel = channel,
			    Message = message,
			    UserId = player.UserIDString,
			    Username = displayName,
			    Color = color,
			    Time = Epoch.Current
		    };

		    RCon.Broadcast(RCon.LogType.Chat, chatEntry);
		    if (channel != Chat.ChatChannel.Global)
		    {
			    if (channel == Chat.ChatChannel.Team)
			    {
				    var playerTeam = RelationshipManager.ServerInstance.FindPlayersTeam(player.userID);
				    if (playerTeam == null)
				    {
					    return false;
				    }

				    var onlineMemberConnections = playerTeam.GetOnlineMemberConnections();
				    if (onlineMemberConnections != null)
				    {
					    ConsoleNetwork.SendClientCommand(onlineMemberConnections, "chat.add2", 1, player.userID,
						    message, displayName, color, 1f);
				    }

				    playerTeam.BroadcastTeamChat(player.userID, displayName, message, color);
				    return true;
			    }
		    }
		    else if (Chat.globalchat)
		    {
			    ConsoleNetwork.BroadcastToAllClients("chat.add2", 0, player.userID, message, displayName, color, 1f);
			    return true;
		    }

		    if (player == null)
			    return true;
		    
		    var radius = 2500f;
		    foreach (var basePlayer in BasePlayer.activePlayerList)
		    {
			    var sqrMagnitude = (basePlayer.transform.position - player.transform.position).sqrMagnitude;
			    if (sqrMagnitude <= radius)
			    {
				    ConsoleNetwork.SendClientCommand(basePlayer.net.connection, "chat.add2", 0, player.userID,
					    message,
					    displayName, color, Mathf.Clamp01(radius - sqrMagnitude + 0.2f));
			    }
		    }

		    return true;

	    }
    }
}

// --- End of file: NoGreen.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-workbench ---
// --- Original File Path: N/NoWorkbench/NoWorkbench.cs ---

﻿using Newtonsoft.Json;
using System.Linq;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("NoWorkbench", "k1lly0u", "0.1.51")]
    [Description("Eliminates the requirement of being near a bench to craft")]
    class NoWorkbench : RustPlugin
    {        
        private Dictionary<int, int> defaultBlueprints;

        #region Oxide Hooks  
        private void OnServerInitialized()
        {
            LoadVariables();
            defaultBlueprints = ItemManager.GetBlueprints().ToDictionary(x => x.targetItem.itemid, y => y.workbenchLevelRequired);

            foreach (ItemBlueprint bp in ItemManager.GetBlueprints())            
                bp.workbenchLevelRequired = 0;            

            foreach (BasePlayer player in BasePlayer.activePlayerList)
                OnPlayerConnected(player);
        }
       
        private void OnPlayerConnected(BasePlayer player)
        {
            if (player.HasPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot))
            {
                timer.In(3, () => OnPlayerConnected(player));
                return;
            }

            player.ClientRPCPlayer(null, player, "craftMode", 1);

            if (configData.NoBlueprints)
                UnlockAllBlueprints(player);             
        }        

        private void UnlockAllBlueprints(BasePlayer player)
        {
            ProtoBuf.PersistantPlayer playerInfo = SingletonComponent<ServerMgr>.Instance.persistance.GetPlayerInfo(player.userID);
            foreach (ItemBlueprint itemBlueprint in ItemManager.bpList)
            {
                if (itemBlueprint.userCraftable && !itemBlueprint.defaultBlueprint)
                {
                    if (!playerInfo.unlockedItems.Contains(itemBlueprint.targetItem.itemid))                   
                        playerInfo.unlockedItems.Add(itemBlueprint.targetItem.itemid);
                }
            }
            SingletonComponent<ServerMgr>.Instance.persistance.SetPlayerInfo(player.userID, playerInfo);
            player.SendNetworkUpdateImmediate(false);
            player.ClientRPCPlayer<int>(null, player, "UnlockedBlueprint", 0);
        }

        private void Unload()
        {
            foreach (ItemBlueprint bp in ItemManager.GetBlueprints())
                bp.workbenchLevelRequired = defaultBlueprints[bp.targetItem.itemid];
        }
        #endregion
       
        #region Config        
        private ConfigData configData;
        private class ConfigData
        {
            [JsonProperty(PropertyName = "Disable the need for blueprints")]
            public bool NoBlueprints { get; set; }            
        }

        private void LoadVariables()
        {
            LoadConfigVariables();
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            ConfigData config = new ConfigData
            {
                NoBlueprints = false
            };
            SaveConfig(config);
        }

        private void LoadConfigVariables() => configData = Config.ReadObject<ConfigData>();

        private void SaveConfig(ConfigData config) => Config.WriteObject(config, true);
        #endregion
    }
}


// --- End of file: NoWorkbench.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/npc-map-markers ---
// --- Original File Path: N/NPCMapMarkers/NPCMapMarkers.cs ---

﻿using System.Collections.Generic;
using UnityEngine;
using CompanionServer.Handlers;
using Newtonsoft.Json;


namespace Oxide.Plugins
{
    [Info("NPC Map Markers", "AK", "1.0.0")]
    [Description("Shows custom map markers for NPCs and animals on the server")]
    internal class NPCMapMarkers : CovalencePlugin
    {
        #region Vars

        private const string permAdmin = "npcmapmarkers.admin";
        public List<MapMarkerGenericRadius> npcMarkers = new List<MapMarkerGenericRadius>();

        #endregion

        #region Config       

        private ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "NPC Map Marker Options")]
            public NPCMapMarkerOptions NPCMapMarker { get; set; }

            [JsonProperty(PropertyName = "Human NPC Markers Options")]
            public NPCMarkersOptions NPCMarkers { get; set; }

            [JsonProperty(PropertyName = "Animal Markers Options")]
            public AnimalMarkersOptions AnimalMarkers { get; set; }

            public class NPCMapMarkerOptions
            {
                [JsonProperty(PropertyName = "Prefab Path")]
                public string PREFAB_MARKER { get; set; }

                [JsonProperty(PropertyName = "Update frequency")]
                public float updateFreq { get; set; }

                [JsonProperty(PropertyName = "Show to all? (true/false)")]
                public bool visibleToAll { get; set; }

                [JsonProperty(PropertyName = "Show Human NPC on map? (true/false)")]
                public bool showNPC { get; set; }

                [JsonProperty(PropertyName = "Show Animals on map? (true/false)")]
                public bool showAnimals { get; set; }

            }

            public class NPCMarkersOptions
            {
                [JsonProperty(PropertyName = "Color1 (hex)")]
                public string NPCColor1 { get; set; }

                [JsonProperty(PropertyName = "Color2 (hex)")]
                public string NPCColor2 { get; set; }

                [JsonProperty(PropertyName = "Alpha")]
                public float NPCAlpha { get; set; }

                [JsonProperty(PropertyName = "Radius")]
                public float NPCRadius { get; set; }
            }

            public class AnimalMarkersOptions
            {
                [JsonProperty(PropertyName = "Color1 (hex)")]
                public string AnimalColor1 { get; set; }

                [JsonProperty(PropertyName = "Color2 (hex)")]
                public string AnimalColor2 { get; set; }

                [JsonProperty(PropertyName = "Alpha")]
                public float AnimalAlpha { get; set; }

                [JsonProperty(PropertyName = "Radius")]
                public float AnimalRadius { get; set; }
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();
            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                NPCMapMarker = new ConfigData.NPCMapMarkerOptions
                {
                    PREFAB_MARKER = "assets/prefabs/tools/map/genericradiusmarker.prefab",
                    updateFreq = 5f,
                    visibleToAll = true,
                    showNPC = true,
                    showAnimals = true
                },
                NPCMarkers = new ConfigData.NPCMarkersOptions
                {
                    NPCColor1 = "#00FF00",
                    NPCColor2 = "#00FF00",
                    NPCAlpha = 1f,
                    NPCRadius = 0.08f
                },
                AnimalMarkers = new ConfigData.AnimalMarkersOptions
                {
                    AnimalColor1 = "#FF0000",
                    AnimalColor2 = "#FF0000",
                    AnimalAlpha = 1f,
                    AnimalRadius = 0.08f
                }
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        #endregion Config

        #region Oxide Hooks

        private void Init()
        {
            permission.RegisterPermission(permAdmin, this);
        }

        private void OnServerInitialized(bool initial)
        {
            LoadNPCMapMarkers();
            InvokeHandler.Instance.InvokeRepeating(UpdateMarkers, 5f, configData.NPCMapMarker.updateFreq);
        }

        private void Unload()
        {
            InvokeHandler.Instance.CancelInvoke(UpdateMarkers);
            RemoveNPCMapMarkers();         
        }

        private void OnPlayerConnected(BasePlayer player)
        {
            if (player.IsReceivingSnapshot)
            {
                timer.Once(1f, () => OnPlayerConnected(player));
                return;
            }
            foreach (var marker in npcMarkers)
            {
                if (marker != null)
                {
                    marker.SendUpdate();
                }
            }
        }

        object CanNetworkTo(MapMarkerGenericRadius marker, BasePlayer player)
        {
            if (!npcMarkers.Contains(marker)) return null;

            if (marker.name == "npc" && configData.NPCMapMarker.showNPC && (configData.NPCMapMarker.visibleToAll || player.IPlayer.HasPermission(permAdmin)))
            {
                return null;
            }
            else if(marker.name == "animal" && configData.NPCMapMarker.showAnimals && (configData.NPCMapMarker.visibleToAll || player.IPlayer.HasPermission(permAdmin)))
            {
                return null;
            }
            else
            {
                return false;
            }
        }

        #endregion

        #region Core

        private void UpdateMarkers()
        {
            RemoveNPCMapMarkers();
            LoadNPCMapMarkers();
        }

        private void LoadNPCMapMarkers()
        {
            foreach (var entity in BaseNetworkable.serverEntities)
            {
                if ((entity is NPCPlayer))
                {
                    var npc = (NPCPlayer)entity;
                    CreateNPCMapMarker(npc, "npc", configData.NPCMarkers.NPCColor1, configData.NPCMarkers.NPCColor2, configData.NPCMarkers.NPCAlpha, configData.NPCMarkers.NPCRadius);
                }

                if ((entity is BaseAnimalNPC))
                {
                    var animal = (BaseAnimalNPC)entity;
                    CreateNPCMapMarker(animal, "animal", configData.AnimalMarkers.AnimalColor1, configData.AnimalMarkers.AnimalColor2, configData.AnimalMarkers.AnimalAlpha, configData.AnimalMarkers.AnimalRadius);
                }
            }
        }

        private void RemoveNPCMapMarkers()
        {
            foreach (var marker in npcMarkers)
            {
                if (marker != null)
                {
                    marker.Kill();
                    marker.SendUpdate();
                }
            }
            npcMarkers.Clear();
        }

        private void CreateNPCMapMarker(BaseNetworkable entity, string type, string color1, string color2, float alpha, float radius)
        {
            MapMarkerGenericRadius mapMarker = GameManager.server.CreateEntity(configData.NPCMapMarker.PREFAB_MARKER, entity.transform.position) as MapMarkerGenericRadius;

            if (mapMarker != null)
            {
                mapMarker.alpha = alpha;
                if (!ColorUtility.TryParseHtmlString(color1, out mapMarker.color1))
                {
                    mapMarker.color1 = Color.black;
                    PrintError($"Invalid map marker color1: {color1}");
                }

                if (!ColorUtility.TryParseHtmlString(color2, out mapMarker.color2))
                {
                    mapMarker.color2 = Color.white;
                    PrintError($"Invalid map marker color2: {color2}");
                }

                mapMarker.name = type;
                mapMarker.radius = radius;
                npcMarkers.Add(mapMarker);
                mapMarker.Spawn();
                mapMarker.SendUpdate();
            }
        }

        #endregion

    }

}

// --- End of file: NPCMapMarkers.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/night-lantern ---
// --- Original File Path: N/NightLantern/NightLantern.cs ---

﻿using HarmonyLib;
using Newtonsoft.Json;
using Oxide.Core;
using Oxide.Core.Plugins;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using UnityEngine;
using VLB;

namespace Oxide.Plugins
{
    [Info("Night Lantern", "k1lly0u", "2.1.1")]
    [Description("Automatically turns ON and OFF lanterns after sunset and sunrise")]
    class NightLantern : RustPlugin
    {
        #region Fields

        [PluginReference]
        private Plugin NoFuelRequirements;

        private static Hash<ulong, Dictionary<EntityType, bool>> _toggleList = new Hash<ulong, Dictionary<EntityType, bool>>();
        private readonly HashSet<LightController> _lightControllers = new HashSet<LightController>();

        private static readonly Hash<BaseOven, LightController> OvenControllers = new Hash<BaseOven, LightController>();

        private bool _lightsOn = false;
        private bool _globalToggle = true;

        private Timer _timeCheck;
        
        private static Func<string, ulong, object> _ignoreFuelConsumptionFunction;

        #endregion Fields

        #region Oxide Hooks

        private void Init()
        {
            permission.RegisterPermission("nightlantern.global", this);
            
            foreach (EntityType type in (EntityType[])Enum.GetValues(typeof(EntityType)))
            {
                if (type == EntityType.CeilingLight)
                    continue;
                
                permission.RegisterPermission($"nightlantern.{type}", this);
            }

            _ignoreFuelConsumptionFunction = NoFuelRequirementsIgnoreFuelConsumption;

            LoadData();
            
            Unsubscribe(nameof(OnEntitySpawned));
            Unsubscribe(nameof(OnEntityKill));
        }

        protected override void LoadDefaultMessages()
            => lang.RegisterMessages(_messages, this);

        private void OnServerInitialized()
        {
            Subscribe(nameof(OnEntitySpawned));
            Subscribe(nameof(OnEntityKill));
            
            ServerMgr.Instance.StartCoroutine(CreateAllLights(BaseNetworkable.serverEntities.Where(x => x is BaseOven || x is SearchLight)));
        }

        private object OnFuelConsume(BaseOven baseOven, Item fuel, ItemModBurnable burnable)
        {
            if (!baseOven || baseOven.IsDestroyed)
                return null;
            
            if (!OvenControllers.TryGetValue(baseOven, out LightController lightController) || !lightController)
                return null;

            return lightController.OnConsumeFuel();
        }

        private void OnOvenToggle(BaseOven baseOven, BasePlayer player)
        {
            if (!baseOven || baseOven.IsDestroyed)
                return;
            
            if (baseOven.needsBuildingPrivilegeToUse && !player.CanBuild())
                return;
            
            if (!OvenControllers.TryGetValue(baseOven, out LightController lightController) || !lightController)
                return;

            lightController.OnOvenToggled();
        }

        private void OnEntitySpawned(BaseEntity entity) 
            => InitializeLightController(entity);

        private void OnEntityKill(BaseNetworkable entity)
        {
            LightController lightController = entity.GetComponent<LightController>();
            if (lightController)
            {
                _lightControllers.Remove(lightController);
                UnityEngine.Object.Destroy(lightController);
            }
        }

        private void OnServerSave() => SaveData();

        private void Unload()
        {
            foreach (LightController lightController in _lightControllers)
            {
                lightController.ToggleLight(false);
                UnityEngine.Object.DestroyImmediate(lightController);
            }

            _timeCheck?.Destroy();
            _lightControllers.Clear();

            _configData = null;
            _toggleList = null;
        }

        #endregion Oxide Hooks

        #region Functions

        private IEnumerator CreateAllLights(IEnumerable<BaseNetworkable> entities)
        {
            foreach (BaseNetworkable baseNetworkable in entities)
            {
                yield return new WaitForSeconds(UnityEngine.Random.Range(0.1f, 0.25f));
                
                if (!baseNetworkable || baseNetworkable.IsDestroyed)
                    continue;
                
                InitializeLightController(baseNetworkable as BaseEntity);
            }

            CheckCurrentTime();
        }

        private void InitializeLightController(BaseEntity entity)
        {
            if (!entity || entity.IsDestroyed)
                return;

            EntityType entityType = StringToType(entity.ShortPrefabName);

            if (entityType == EntityType.None || !_configData.Types[entityType].Enabled)
                return;

            _lightControllers.Add(entity.GetOrAddComponent<LightController>());
        }

        private void CheckCurrentTime()
        {
            if (_globalToggle)
            {
                float time = TOD_Sky.Instance.Cycle.Hour;
                if (time >= _configData.Sunset || (time >= 0 && time < _configData.Sunrise))
                {
                    if (!_lightsOn)
                    {
                        ServerMgr.Instance.StartCoroutine(ToggleAllLights(_lightControllers, true));
                        _lightsOn = true;
                    }
                }
                else if (time >= _configData.Sunrise && time < _configData.Sunset)
                {
                    if (_lightsOn)
                    {
                        ServerMgr.Instance.StartCoroutine(ToggleAllLights(_lightControllers, false));
                        _lightsOn = false;
                    }
                }
            }
            _timeCheck = timer.Once(20, CheckCurrentTime);
        }

        private static IEnumerator ToggleAllLights(IEnumerable<LightController> lights, bool status)
        {
            foreach (LightController lightController in lights)
            {
                yield return new WaitForSeconds(UnityEngine.Random.Range(0.1f, 0.25f));

                if (lightController)
                    lightController.ToggleLight(status);
            }
        }

        private static EntityType StringToType(string name)
        {
            return name switch
            {
                "campfire" => EntityType.Campfire,
                "skull_fire_pit" => EntityType.Firepit,
                "fireplace.deployed" => EntityType.Fireplace,
                "furnace" => EntityType.Furnace,
                "furnace.large" => EntityType.LargeFurnace,
                "lantern.deployed" => EntityType.Lanterns,
                "jackolantern.angry" => EntityType.JackOLantern,
                "jackolantern.happy" => EntityType.JackOLantern,
                "tunalight.deployed" => EntityType.TunaLight,
                "searchlight.deployed" => EntityType.Searchlight,
                "bbq.deployed" => EntityType.BBQ,
                "refinery_small_deployed" => EntityType.Refinery,
                "cursedcauldron.deployed" => EntityType.CursedCauldren,
                "chineselantern.deployed" => EntityType.ChineseLantern,
                "chineselantern_white.deployed" => EntityType.ChineseLantern,
                _ => EntityType.None
            };
        }

        private static EntityType ParseType(string type)
        {
            try
            {
                return (EntityType)Enum.Parse(typeof(EntityType), type, true);
            }
            catch
            {
                return EntityType.None;
            }
        }

        private static bool ConsumeTypeEnabled(ulong playerId, EntityType entityType)
        {
            if (_toggleList.TryGetValue(playerId, out Dictionary<EntityType, bool> userPreferences))
                return userPreferences[entityType];
            
            return _configData.Types[entityType].Enabled;
        }
        
        private object NoFuelRequirementsIgnoreFuelConsumption(string shortname, ulong playerId)
            => NoFuelRequirements?.Call("IgnoreFuelConsumption", shortname, playerId);
        
        #endregion Functions

        #region Component
        
        private class LightController : MonoBehaviour
        {
            private BaseEntity _entity;
            private ConfigData.LightSettings _config;
            private bool _isSearchlight;
            private bool _ignoreFuelConsumption;
            private bool _automaticallyToggled;
            public EntityType entityType;

            public bool ShouldIgnoreFuelConsumption
            {
                get
                {
                    if (_config.ConsumeFuelWhenToggled && !_automaticallyToggled)
                        return false;
                    
                    return _ignoreFuelConsumption || !_config.ConsumeFuel;
                }
            } 

            private void Awake()
            {
                _entity = GetComponent<BaseEntity>();
                entityType = StringToType(_entity.ShortPrefabName);
                _config = _configData.Types[entityType];
                _isSearchlight = _entity is SearchLight;

                object success = _ignoreFuelConsumptionFunction(entityType.ToString(), _entity.OwnerID);
                if (success != null)
                    _ignoreFuelConsumption = true;
            }

            private void OnEnable()
            {
                if (_entity is BaseOven baseOven)
                    OvenControllers[baseOven] = this;
            }

            private void OnDisable()
            {
                if (_entity is BaseOven baseOven)
                    OvenControllers.Remove(baseOven);
            }

            public void ToggleLight(bool status)
            {
                if (_config.Owner && !ConsumeTypeEnabled(_entity.OwnerID, entityType))
                    status = false;

                object success = Interface.CallHook("OnNightLanternToggle", _entity, status);
                if (success != null)
                    return;

                if (_isSearchlight)
                {
                    SearchLight searchLight = _entity as SearchLight;
                    if (searchLight)
                        searchLight.SetFlag(BaseEntity.Flags.On, status);
                }
                else
                {
                    BaseOven baseOven = _entity as BaseOven;
                    if (baseOven)
                    {
                        if (_config.ConsumeFuel)
                        {       
                            if (status)
                                baseOven.StartCooking();
                            else baseOven.StopCooking();
                        }
                        else
                        {
                            if (baseOven.IsOn() != status)
                            {
                                _automaticallyToggled = true;

                                if (_config.Cook)
                                {
                                    if (status)
                                    {
                                        baseOven.inventory.temperature = baseOven.cookingTemperature;
                                        baseOven.UpdateAttachmentTemperature();
                                        baseOven.InvokeRepeating(baseOven.Cook, 0.5f, 0.5f);
                                        baseOven.SetFlag(BaseEntity.Flags.On, true, false, true);
                                        Interface.CallHook("OnOvenStarted", this);
                                    }
                                    else
                                    {
                                        if (_automaticallyToggled)
                                        {
                                            baseOven.UpdateAttachmentTemperature();
                                            if (baseOven.inventory != null)
                                            {
                                                baseOven.inventory.temperature = 15f;
                                                foreach (Item item in baseOven.inventory.itemList)
                                                {
                                                    if (item.HasFlag(global::Item.Flag.OnFire))
                                                    {
                                                        item.SetFlag(global::Item.Flag.OnFire, false);
                                                        item.MarkDirty();
                                                    }
                                                    else if (item.HasFlag(global::Item.Flag.Cooking))
                                                    {
                                                        item.SetFlag(global::Item.Flag.Cooking, false);
                                                        item.MarkDirty();
                                                    }
                                                }
                                            }

                                            baseOven.CancelInvoke(baseOven.Cook);
                                        }
                                    }
                                }

                                baseOven.SetFlag(BaseEntity.Flags.On, status);
                            }
                        }
                    }
                }
                _entity.SendNetworkUpdate();
            }

            public void OnOvenToggled() => _automaticallyToggled = false;
            
            public object OnConsumeFuel() => ShouldIgnoreFuelConsumption ? true : (object)null;
            
            public bool IsOwner(ulong playerId) => _entity.OwnerID == playerId;
        }
        
        [AutoPatch]
        [HarmonyPatch(typeof(BaseOven))]
        [HarmonyPatch(nameof(BaseOven.CanRunWithNoFuel), MethodType.Getter)]
        private static class BaseOven_CanRunWithNoFuelPatch
        {
            [HarmonyPrefix]
            private static bool Prefix(BaseOven __instance, ref bool __result)
            {
                if (!OvenControllers.TryGetValue(__instance, out LightController lightController))
                    return false;

                if (lightController && lightController.ShouldIgnoreFuelConsumption)
                {
                    __result = true;
                    return false;
                }

                return true;
            }
        }

        #endregion Component

        #region Commands

        private StringBuilder _stringBuilder = new StringBuilder();

        [ChatCommand("lantern")]
        private void cmdLantern(BasePlayer player, string command, string[] args)
        {
            if (args.Length == 0)
            {
                _stringBuilder.Clear();
                _stringBuilder.AppendLine(GetMessage("global.title", player.userID));
                
                if (!_toggleList.TryGetValue(player.userID, out Dictionary<EntityType, bool> userPreferences))
                    userPreferences = _configData.Types.ToDictionary(x => x.Key, y => y.Value.Enabled);

                bool canToggle = false;
                foreach (KeyValuePair<EntityType, ConfigData.LightSettings> lightType in _configData.Types)
                {
                    if (lightType.Key == EntityType.CeilingLight)
                        continue;

                    if (lightType.Value.Owner)
                    {
                        if (lightType.Value.Permission && !permission.UserHasPermission(player.UserIDString, $"nightlantern.{lightType.Key}"))
                            continue;

                        _stringBuilder.AppendLine(string.Format(GetMessage("user.type", player.userID), lightType.Key, userPreferences[lightType.Key] ? GetMessage("user.enabled", player.userID) : GetMessage("user.disabled", player.userID)));
                        canToggle = true;
                    }
                }

                if (canToggle)
                    _stringBuilder.AppendLine(GetMessage("user.toggle.command", player.userID));
                
                player.ChatMessage(_stringBuilder.ToString());
                _stringBuilder.Clear();
                
                if (!permission.UserHasPermission(player.UserIDString, "nightlantern.global")) 
                    return;
                
                _stringBuilder.AppendLine(string.Format(GetMessage("global.toggle", player.userID), _globalToggle ? GetMessage("user.enabled", player.userID) : GetMessage("user.disabled", player.userID)));
                _stringBuilder.AppendLine(GetMessage("global.toggle.command", player.userID));
                
                player.ChatMessage(_stringBuilder.ToString());
                _stringBuilder.Clear();
                return;
            }

            if (args[0].ToLower() == "global" && permission.UserHasPermission(player.UserIDString, "nightlantern.global"))
            {
                _globalToggle = !_globalToggle;
                ServerMgr.Instance.StartCoroutine(ToggleAllLights(_lightControllers, _globalToggle));
                player.ChatMessage(string.Format(GetMessage("global.toggle", player.userID), _globalToggle ? GetMessage("user.enabled", player.userID) : GetMessage("user.disabled", player.userID)));
            }
            else
            {
                EntityType entityType = ParseType(args[0]);
                if ((entityType == EntityType.None || entityType == EntityType.CeilingLight) || !permission.UserHasPermission(player.UserIDString, $"nightlantern.{entityType}"))
                {
                    player.ChatMessage(string.Format(GetMessage("toggle.invalid", player.userID), entityType));
                    return;
                }

                if (!_toggleList.ContainsKey(player.userID))
                    _toggleList.Add(player.userID, _configData.Types.ToDictionary(x => x.Key, y => y.Value.Enabled));

                _toggleList[player.userID][entityType] = !_toggleList[player.userID][entityType];

                IEnumerable<LightController> ownedLights = _lightControllers.Where(x => x.IsOwner(player.userID) && x.entityType == entityType).ToList();
                if (ownedLights.Any())
                    ServerMgr.Instance.StartCoroutine(ToggleAllLights(ownedLights, _toggleList[player.userID][entityType]));

                player.ChatMessage(string.Format(GetMessage("user.type", player.userID), entityType, _toggleList[player.userID][entityType] ? GetMessage("user.enabled", player.userID) : GetMessage("user.disabled", player.userID)));
            }
        }

        #endregion Commands

        #region Config

        private enum EntityType { BBQ, Campfire, CeilingLight, ChineseLantern, CursedCauldren, Firepit, Fireplace, Furnace, LargeFurnace, Lanterns, JackOLantern, TunaLight, Searchlight, Refinery, None }

        private static ConfigData _configData;

        class ConfigData
        {
            [JsonProperty(PropertyName = "Light Settings")]
            public Dictionary<EntityType, LightSettings> Types { get; set; }

            [JsonProperty(PropertyName = "Time autolights are disabled")]
            public float Sunrise { get; set; }

            [JsonProperty(PropertyName = "Time autolights are enabled")]
            public float Sunset { get; set; }

            public class LightSettings
            {
                [JsonProperty(PropertyName = "This type is enabled")]
                public bool Enabled { get; set; }

                [JsonProperty(PropertyName = "This type consumes fuel")]
                public bool ConsumeFuel { get; set; }

                [JsonProperty(PropertyName = "This type consumes fuel when toggled by a player")]
                public bool ConsumeFuelWhenToggled { get; set; }

                [JsonProperty(PropertyName = "This type starts cooking items when toggled by plugin")]
                public bool Cook { get; set; }

                [JsonProperty(PropertyName = "This type can be toggled by the owner")]
                public bool Owner { get; set; }

                [JsonProperty(PropertyName = "This type requires permission to be toggled by the owner")]
                public bool Permission { get; set; }
            }

            public VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _configData = Config.ReadObject<ConfigData>();

            if (_configData.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(_configData, true);
        }

        protected override void LoadDefaultConfig() => _configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                Types = new Dictionary<EntityType, ConfigData.LightSettings>
                {
                    [EntityType.BBQ] = new ConfigData.LightSettings
                    {
                        ConsumeFuel = true,
                        Enabled = true,
                        Permission = true,
                        Owner = true
                    },
                    [EntityType.Campfire] = new ConfigData.LightSettings
                    {
                        ConsumeFuel = true,
                        Enabled = true,
                        Permission = true,
                        Owner = true
                    },                    
                    [EntityType.Firepit] = new ConfigData.LightSettings
                    {
                        ConsumeFuel = true,
                        Enabled = true,
                        Permission = true,
                        Owner = true
                    },
                    [EntityType.Fireplace] = new ConfigData.LightSettings
                    {
                        ConsumeFuel = true,
                        Enabled = true,
                        Permission = true,
                        Owner = true
                    },
                    [EntityType.Furnace] = new ConfigData.LightSettings
                    {
                        ConsumeFuel = true,
                        Enabled = true,
                        Permission = false
                    },
                    [EntityType.JackOLantern] = new ConfigData.LightSettings
                    {
                        ConsumeFuel = true,
                        Enabled = true,
                        Permission = true,
                        Owner = true
                    },
                    [EntityType.Lanterns] = new ConfigData.LightSettings
                    {
                        ConsumeFuel = true,
                        Enabled = true,
                        Permission = true,
                        Owner = true
                    },
                    [EntityType.LargeFurnace] = new ConfigData.LightSettings
                    {
                        ConsumeFuel = true,
                        Enabled = true,
                        Permission = true,
                        Owner = true
                    },
                    [EntityType.Searchlight] = new ConfigData.LightSettings
                    {
                        ConsumeFuel = true,
                        Enabled = true,
                        Permission = true,
                        Owner = true
                    },
                    [EntityType.TunaLight] = new ConfigData.LightSettings
                    {
                        ConsumeFuel = true,
                        Enabled = true,
                        Permission = true,
                        Owner = true
                    },
                    [EntityType.Refinery] = new ConfigData.LightSettings
                    {
                        ConsumeFuel = true,
                        Enabled = true,
                        Permission = true,
                        Owner = true
                    },
                    [EntityType.CursedCauldren] = new ConfigData.LightSettings
                    {
                        ConsumeFuel = true,
                        Enabled = true,
                        Permission = true,
                        Owner = true
                    },
                    [EntityType.ChineseLantern] = new ConfigData.LightSettings
                    {
                        ConsumeFuel = true,
                        Enabled = true,
                        Permission = true,
                        Owner = true
                    }
                },
                Sunrise = 7.5f,
                Sunset = 18.5f,
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(_configData, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();

            if (_configData.Version < new VersionNumber(2, 0, 9))
                _configData = baseConfig;

            foreach (EntityType entityType in (EntityType[])Enum.GetValues(typeof(EntityType)))
            {
                if (!_configData.Types.ContainsKey(entityType))
                {
                    _configData.Types[entityType] = new ConfigData.LightSettings
                    {
                        ConsumeFuel = true,
                        Enabled = true,
                        Cook = false,
                        Permission = true,
                        Owner = true
                    };
                }
            }

            _configData.Version = Version;
            PrintWarning("Config update completed!");
        }

        #endregion Config

        #region Data Management

        private void SaveData() => Interface.Oxide.DataFileSystem.GetFile("nightlantern_data").WriteObject(_toggleList);

        private void LoadData()
        {
            try
            {
                _toggleList = Interface.Oxide.DataFileSystem.GetFile("nightlantern_data")?.ReadObject<Hash<ulong, Dictionary<EntityType, bool>>>() ?? new Hash<ulong, Dictionary<EntityType, bool>>();
            }
            catch
            {
                _toggleList = new Hash<ulong, Dictionary<EntityType, bool>>();
            }
        }

        #endregion Data Management

        #region Localization

        private string GetMessage(string key, ulong playerId = 0U) => lang.GetMessage(key, this, playerId == 0U ? null : playerId.ToString());

        private readonly Dictionary<string, string> _messages = new Dictionary<string, string>
        {
            ["global.title"] = "<color=#FFA500>Night Lantern</color>",
            ["global.toggle"] = "Auto lights are {0} server wide",
            ["global.toggle.command"] = "You can toggle auto lights globally by typing '<color=#FFA500>/lantern global</color>'",
            ["user.disable"] = "You have disabled auto lights that you own of the type {0}",
            ["user.enable"] = "You have enabled auto lights that you own of the type {0}",
            ["user.type"] = "{0} : {1}",
            ["user.enabled"] = "<color=#8ee700>enabled</color>",
            ["user.disabled"] = "<color=#e90000>disabled</color>",
            ["user.toggle.command"] = "You can toggle the various types by typing '<color=#FFA500>/lantern <light type></color>'",
            ["toggle.invalid"] = "{0} is an invalid option!"
        };

        #endregion Localization
    }
}


// --- End of file: NightLantern.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-drone-sway ---
// --- Original File Path: N/NoDroneSway/NoDroneSway.cs ---

﻿using Network;

namespace Oxide.Plugins
{
    [Info("No Drone Sway", "WhiteThunder", "1.0.4")]
    [Description("Drones no longer sway in the wind, if they have attachments.")]
    internal class NoDroneSway : CovalencePlugin
    {
        #region Fields

        private const int DroneThrottleUpFlag = (int)Drone.Flag_ThrottleUp;
        private const int DroneFlyingFlag = (int)Drone.Flag_Flying;
        private readonly object False = false;

        #endregion

        #region Hooks

        private void OnEntitySaved(Drone drone, BaseNetworkable.SaveInfo saveInfo)
        {
            if ((saveInfo.msg.baseEntity.flags & DroneFlyingFlag) == 0
                || !drone.ControllingViewerId.HasValue
                || ShouldSway(drone))
                return;

            // Don't change flags for the remote controller because that would prevent viewing the pitch.
            // This approach is possible because network caching is disabled for RemoteControlEntity.
            var controllerSteamId = drone.ControllingViewerId.Value.SteamId;
            if (controllerSteamId != 0
                && controllerSteamId == (saveInfo.forConnection?.player as BasePlayer)?.userID
                && IsControllingDrone(saveInfo.forConnection, drone))
                return;

            saveInfo.msg.baseEntity.flags = ModifyDroneFlags(drone);
        }

        private object OnEntityFlagsNetworkUpdate(Drone drone)
        {
            if (((int)drone.flags & DroneFlyingFlag) == 0
                || !drone.ControllingViewerId.HasValue
                || ShouldSway(drone))
                return null;

            var subscribers = drone.GetSubscribers();
            if (subscribers is { Count: > 0 })
            {
                var controllerSteamId = drone.ControllingViewerId?.SteamId ?? 0;
                if (controllerSteamId == 0)
                {
                    // No player is controlling the drone, so send the same update to all subscribers.
                    SendFlagsUpdate(drone, ModifyDroneFlags(drone), new SendInfo(subscribers));
                }
                else
                {
                    // A player is controlling the drone, so we might need to send that player different flags.
                    var otherConnections = Facepunch.Pool.GetList<Connection>();

                    Connection controllerConnection = null;
                    foreach (var connection in subscribers)
                    {
                        if (connection.ownerid == controllerSteamId)
                        {
                            controllerConnection = connection;
                        }
                        else
                        {
                            otherConnections.Add(connection);
                        }
                    }

                    if (controllerConnection != null && !IsControllingDrone(controllerConnection, drone))
                    {
                        // The controller isn't using a computer station (e.g., RidableDrones plugin),
                        // so send them the same snapshot as other players.
                        otherConnections.Add(controllerConnection);
                        controllerConnection = null;
                    }

                    var flags = ModifyDroneFlags(drone);

                    if (otherConnections.Count > 0)
                    {
                        SendFlagsUpdate(drone, flags, new SendInfo(otherConnections));
                    }

                    if (controllerConnection != null)
                    {
                        SendFlagsUpdate(drone, (int)drone.flags, new SendInfo(controllerConnection));
                    }

                    Facepunch.Pool.FreeList(ref otherConnections);
                }
            }

            drone.gameObject.SendOnSendNetworkUpdate(drone);
            return False;
        }

        #endregion

        #region Helpers

        private static class RCUtils
        {
            public static T GetControlledEntity<T>(BasePlayer player) where T : class
            {
                var station = player.GetMounted() as ComputerStation;
                if ((object)station == null)
                    return null;

                return station.currentlyControllingEnt.Get(serverside: true) as T;
            }
        }

        private static bool IsControllingDrone(Connection connection, Drone drone)
        {
            var player = connection.player as BasePlayer;
            if ((object)player == null)
                return false;

            return RCUtils.GetControlledEntity<Drone>(player) == drone;
        }

        private static void SendFlagsUpdate(BaseEntity entity, int flags, SendInfo sendInfo)
        {
            var write = Net.sv.StartWrite();
            write.PacketID(Message.Type.EntityFlags);
            write.EntityID(entity.net.ID);
            write.Int32(flags);
            write.Send(sendInfo);
        }

        private static int ModifyDroneFlags(BaseEntity drone)
        {
            var flags = (int)drone.flags;

            if ((flags & DroneFlyingFlag) != 0)
            {
                flags = flags & ~DroneFlyingFlag | DroneThrottleUpFlag;
            }

            return flags;
        }

        private static bool ShouldSway(Drone drone)
        {
            // Drones with attachments should not sway.
            if (drone.children.Count > 0)
            {
                for (var i = 0; i < drone.children.Count; i++)
                {
                    var sphereChild = drone.children[i] as SphereEntity;
                    if ((object)sphereChild == null)
                        return false;

                    for (var j = 0; j < sphereChild.children.Count; j++)
                    {
                        var grandChild = sphereChild.children[j];

                        // Resized search lights are permitted (Drone Lights).
                        if (grandChild is SearchLight)
                            continue;

                        return false;
                    }
                }
            }

            // Drones with a re-parented rigid body are probably resized and should not sway.
            if (drone != null && drone.body.gameObject != drone.gameObject)
                return false;

            return true;
        }

        #endregion
    }
}


// --- End of file: NoDroneSway.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-escape ---
// --- Original File Path: N/NoEscape/NoEscape.cs ---

using System;
using System.Linq;
using System.Collections.Generic;
using System.Text.RegularExpressions;

using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Game.Rust.Cui;

using Newtonsoft.Json.Linq;

using UnityEngine;
using Facepunch;
using Rust;

namespace Oxide.Plugins
{
    [Info ("No Escape", "Calytic", "2.1.35")]
    [Description ("Prevent commands/actions while raid and/or combat is occuring")]
    class NoEscape : RustPlugin
    {
        #region Setup & Configuration

        List<string> blockTypes = new List<string> ()
        {
            "remove",
            "tp",
            "bank",
            "trade",
            "recycle",
            "shop",
            "bgrade",
            "build",
            "repair",
            "upgrade",
            "vend",
            "kit",
            "assignbed",
            "craft",
            "mailbox",
            "backpack"
        };

        // COMBAT SETTINGS
        bool combatBlock;
        static float combatDuration;
        bool combatOnHitPlayer;
        float combatOnHitPlayerMinCondition;
        float combatOnHitPlayerMinDamage;

        bool combatOnTakeDamage;
        float combatOnTakeDamageMinCondition;
        float combatOnTakeDamageMinDamage;

        bool combatOnHitNPC;
        bool combatOnTakeDamageNPC;

        // RAID BLOCK SETTINGS
        bool raidBlock;
        static float raidDuration;
        float raidDistance;
        bool blockOnDamage;
        float blockOnDamageMinCondition;
        bool blockOnDestroy;

        // RAID-ONLY SETTINGS
        bool ownerCheck;
        bool blockUnowned;
        bool blockAll;
        // IGNORES ALL OTHER CHECKS
        bool ownerBlock;
        bool cupboardShare;
        bool friendShare;
        bool clanShare;
        bool clanCheck;
        bool friendCheck;
        bool raiderBlock;
        List<string> raidDamageTypes;
        List<string> raidDeathTypes;
        List<string> combatDamageTypes;

        // RAID UNBLOCK SETTINGS
        bool raidUnblockOnDeath;
        bool raidUnblockOnWakeup;
        bool raidUnblockOnRespawn;

        // COMBAT UNBLOCK SETTINGS
        bool combatUnblockOnDeath;
        bool combatUnblockOnWakeup;
        bool combatUnblockOnRespawn;

        float cacheTimer;

        // MESSAGES
        bool raidBlockNotify;
        bool combatBlockNotify;

        bool useZoneManager;
        bool zoneEnter;
        bool zoneLeave;
        
        bool useRaidableBases;
        bool raidableZoneEnter;
        bool raidableZoneLeave;

        bool sendUINotification;
        bool sendChatNotification;
        bool sendGUIAnnouncementsNotification;
        bool sendLustyMapNotification;

        string GUIAnnouncementTintColor = "Red";
        string GUIAnnouncementTextColor = "White";

        string LustyMapIcon = "special";
        float LustyMapDuration = 150f;

        Dictionary<string, RaidZone> zones = new Dictionary<string, RaidZone> ();
        Dictionary<string, List<string>> memberCache = new Dictionary<string, List<string>> ();
        Dictionary<string, string> clanCache = new Dictionary<string, string> ();
        Dictionary<string, List<string>> friendCache = new Dictionary<string, List<string>> ();
        Dictionary<string, DateTime> lastClanCheck = new Dictionary<string, DateTime> ();
        Dictionary<string, DateTime> lastCheck = new Dictionary<string, DateTime> ();
        Dictionary<string, DateTime> lastFriendCheck = new Dictionary<string, DateTime> ();
        Dictionary<string, bool> prefabBlockCache = new Dictionary<string, bool> ();
        internal Dictionary<ulong, BlockBehavior> blockBehaviors = new Dictionary<ulong, BlockBehavior> ();

        public static NoEscape plugin;

        [PluginReference]
        Plugin Clans, Friends, ZoneManager, GUIAnnouncements, LustyMap;

        readonly int cupboardMask = LayerMask.GetMask ("Deployed");
        readonly int blockLayer = LayerMask.GetMask ("Player (Server)");
        Dictionary<string, bool> _cachedExcludedWeapons = new Dictionary<string, bool> ();

        List<string> blockedPrefabs = new List<string> ()
        {
            "door",
            "window.bars",
            "floor.ladder.hatch",
            "floor.frame",
            "wall.frame",
            "shutter",
            "external"
        };

        List<string> exceptionPrefabs = new List<string> ()
        {
            "ladder.wooden"
        };

        List<string> exceptionWeapons = new List<string> ()
        {
            "torch"
        };

        private List<string> GetDefaultRaidDamageTypes ()
        {
            return new List<DamageType> ()
            {
                DamageType.Bullet,
                DamageType.Blunt,
                DamageType.Stab,
                DamageType.Slash,
                DamageType.Explosion,
                DamageType.Heat
            }.Select (x => x.ToString ()).ToList<string> ();
        }

        private List<string> GetDefaultCombatDamageTypes ()
        {
            return new List<DamageType> ()
            {
                DamageType.Bullet,
                DamageType.Arrow,
                DamageType.Blunt,
                DamageType.Stab,
                DamageType.Slash,
                DamageType.Explosion,
                DamageType.Heat,
                DamageType.ElectricShock
            }.Select (x => x.ToString ()).ToList<string> ();
        }

        Dictionary<string, object> blockWhenRaidDamageDefault = new Dictionary<string, object> () {
            {"enabled", true},
            {"minCondition", 100f},
        };

        Dictionary<string, object> blockWhenCombatDamageDefault = new Dictionary<string, object> () {
            {"enabled", false},
            {"minCondition", 100f},
            {"minDamage", 1f},
        };

        static Regex _htmlRegex = new Regex ("<.*?>", RegexOptions.Compiled);

        protected override void LoadDefaultConfig ()
        {
            Config ["VERSION"] = Version.ToString ();

            // RAID SETTINGS
            Config ["Raid", "Block", "enabled"] = true;
            Config ["Raid", "Block", "duration"] = 300f; // 5 minutes
            Config ["Raid", "Block", "distance"] = 100f;
            Config ["Raid", "Block", "notify"] = true;
            Config ["Raid", "Block", "damageTypes"] = GetDefaultRaidDamageTypes ();
            Config ["Raid", "Block", "deathTypes"] = GetDefaultRaidDamageTypes();
            Config ["Raid", "Block", "includePrefabs"] = blockedPrefabs;
            Config ["Raid", "Block", "excludePrefabs"] = exceptionPrefabs;
            Config ["Raid", "Block", "excludeWeapons"] = exceptionWeapons;

            Config ["Raid", "BlockWhen", "damage"] = blockWhenRaidDamageDefault;

            Config ["Raid", "BlockWhen", "destroy"] = true;
            Config ["Raid", "BlockWhen", "unowned"] = false;

            Config ["Raid", "BlockWho", "everyone"] = true;
            Config ["Raid", "BlockWho", "owner"] = false;
            Config ["Raid", "BlockWho", "cupboardAuthorized"] = false;
            Config ["Raid", "BlockWho", "clan"] = false;
            Config ["Raid", "BlockWho", "friends"] = false;
            Config ["Raid", "BlockWho", "raider"] = false;

            Config ["Raid", "BlockExcept", "owner"] = true;
            Config ["Raid", "BlockExcept", "friends"] = false;
            Config ["Raid", "BlockExcept", "clan"] = false;

            Config ["Raid", "Zone", "enabled"] = false;
            Config ["Raid", "Zone", "enter"] = true;
            Config ["Raid", "Zone", "leave"] = false;

            Config ["Raid", "Map", "enabled"] = false;
            Config ["Raid", "Map", "icon"] = "special";
            Config ["Raid", "Map", "duration"] = 150f;

            Config ["Raid", "UnblockWhen", "death"] = true;
            Config ["Raid", "UnblockWhen", "wakeup"] = false;
            Config ["Raid", "UnblockWhen", "respawn"] = true;

            // COMBAT SETTINGS
            Config ["Combat", "Block", "enabled"] = false;
            Config ["Combat", "Block", "duration"] = 180f; // 3 minutes
            Config ["Combat", "Block", "notify"] = true;
            Config ["Combat", "Block", "damageTypes"] = GetDefaultCombatDamageTypes ();

            Config ["Combat", "BlockWhen", "giveDamage"] = blockWhenCombatDamageDefault;
            Config ["Combat", "BlockWhen", "takeDamage"] = blockWhenCombatDamageDefault;

            Config ["Combat", "BlockWhen", "npcGiveDamage"] = false;
            Config ["Combat", "BlockWhen", "npcTakeDamage"] = false;

            Config ["Combat", "UnblockWhen", "death"] = true;
            Config ["Combat", "UnblockWhen", "wakeup"] = false;
            Config ["Combat", "UnblockWhen", "respawn"] = true;

            Config ["Settings", "cacheMinutes"] = 1f;
            Config ["Settings", "Block", "Types"] = blockTypes;

            Config ["Notifications", "UI"] = true;
            Config ["Notifications", "Chat"] = true;
            Config ["Notifications", "GUIAnnouncements", "enabled"] = false;
            Config ["Notifications", "GUIAnnouncements", "backgroundColor"] = "Red";
            Config ["Notifications", "GUIAnnouncements", "textColor"] = "White";

            Config ["VERSION"] = Version.ToString ();
        }

        void Loaded ()
        {
            LoadMessages ();
        }

        void Unload ()
        {
            if (useZoneManager)
                foreach (var zone in zones.ToList ())
                    EraseZone (zone.Value.zoneid);

            var objects = GameObject.FindObjectsOfType (typeof (RaidBlock));
            if (objects != null)
                foreach (var gameObj in objects)
                    if (!((RaidBlock)gameObj).Active)
                        GameObject.Destroy (gameObj);

            objects = GameObject.FindObjectsOfType (typeof (CombatBlock));
            if (objects != null)
                foreach (var gameObj in objects)
                    if (!((CombatBlock)gameObj).Active)
                        GameObject.Destroy (gameObj);
        }

        void LoadMessages ()
        {
            lang.RegisterMessages (new Dictionary<string, string>
                {
                    { "Raid Blocked Message", "You may not do that while raid blocked ({time})" },
                    { "Combat Blocked Message", "You may do that while a in combat ({time})" },
                    { "Raid Block Complete", "You are no longer raid blocked." },
                    { "Combat Block Complete", "You are no longer combat blocked." },
                    { "Raid Block Notifier", "You are raid blocked for {time}" },
                    { "Combat Block Notifier", "You are combat blocked for {time}" },
                    { "Combat Block UI Message", "COMBAT BLOCK" },
                    { "Raid Block UI Message", "RAID BLOCK" },
                    { "Unit Seconds", "second(s)" },
                    { "Unit Minutes", "minute(s)" },
                    { "Prefix", string.Empty }
                }, this);
        }

        void CheckConfig ()
        {
            if (Config ["VERSION"] == null) {
                // FOR COMPATIBILITY WITH INITIAL VERSIONS WITHOUT VERSIONED CONFIG
                ReloadConfig ();
            } else if (GetConfig ("VERSION", string.Empty) != Version.ToString ()) {
                // ADDS NEW, IF ANY, CONFIGURATION OPTIONS
                ReloadConfig ();
            }
        }

        protected void ReloadConfig ()
        {
            Config ["VERSION"] = Version.ToString ();

            // NEW CONFIGURATION OPTIONS HERE
            // END NEW CONFIGURATION OPTIONS

            PrintToConsole ("Upgrading configuration file");
            SaveConfig ();
        }

        void OnServerInitialized ()
        {
            NoEscape.plugin = this;

            permission.RegisterPermission ("noescape.disable", this);

            blockTypes = GetConfig ("Settings", "Block", "Types", blockTypes);

            foreach (string command in blockTypes) {
                permission.RegisterPermission ("noescape.raid." + command + "block", this);
                permission.RegisterPermission ("noescape.combat." + command + "block", this);
            }

            CheckConfig ();

            // RAID SETTINGS
            raidBlock = GetConfig ("Raid", "Block", "enabled", true);
            raidDuration = GetConfig ("Raid", "Block", "duration", 300f);
            raidDistance = GetConfig ("Raid", "Block", "distance", 100f);
            raidBlockNotify = GetConfig ("Raid", "Block", "notify", true);
            raidDamageTypes = GetConfig ("Raid", "Block", "damageTypes", GetDefaultRaidDamageTypes ());
            raidDeathTypes = GetConfig("Raid", "Block", "deathTypes", GetDefaultRaidDamageTypes());
            blockedPrefabs = GetConfig ("Raid", "Block", "includePrefabs", blockedPrefabs);
            exceptionPrefabs = GetConfig ("Raid", "Block", "excludePrefabs", exceptionPrefabs);
            exceptionWeapons = GetConfig ("Raid", "Block", "excludeWeapons", exceptionWeapons);

            Dictionary<string, object> blockOnRaidDamageDetails = GetConfig ("Raid", "BlockWhen", "damage", blockWhenRaidDamageDefault);
            if (blockOnRaidDamageDetails.ContainsKey ("enabled")) {
                blockOnDamage = (bool)blockOnRaidDamageDetails ["enabled"];
            } else {
                blockOnDamage = true;
            }

            if (blockOnRaidDamageDetails.ContainsKey ("minCondition")) {
                blockOnDamageMinCondition = Convert.ToSingle (blockOnRaidDamageDetails ["minCondition"]);
            } else {
                blockOnDamageMinCondition = 100f;
            }

            blockOnDestroy = GetConfig ("Raid", "BlockWhen", "destroy", true);
            blockUnowned = GetConfig ("Raid", "BlockWhen", "unowned", false);

            blockAll = GetConfig ("Raid", "BlockWho", "everyone", true);
            ownerBlock = GetConfig ("Raid", "BlockWho", "owner", false);
            friendShare = GetConfig ("Raid", "BlockWho", "friends", false);
            clanShare = GetConfig ("Raid", "BlockWho", "clan", false);
            cupboardShare = GetConfig ("Raid", "BlockWho", "cupboardAuthorized", false);
            raiderBlock = GetConfig ("Raid", "BlockWho", "raider", false);

            ownerCheck = GetConfig ("Raid", "BlockExcept", "owner", true);
            friendCheck = GetConfig ("Raid", "BlockExcept", "friends", false);
            clanCheck = GetConfig ("Raid", "BlockExcept", "clan", false);

            useZoneManager = GetConfig ("Raid", "Zone", "enabled", false);
            zoneEnter = GetConfig ("Raid", "Zone", "enter", true);
            zoneLeave = GetConfig ("Raid", "Zone", "leave", false);
            
            useRaidableBases = GetConfig ("Raid", "RaidableBases", "enabled", false);
            raidableZoneEnter = GetConfig ("Raid", "RaidableBases", "enter", true);
            raidableZoneLeave = GetConfig ("Raid", "RaidableBases", "leave", false);

            sendLustyMapNotification = GetConfig ("Raid", "Map", "enabled", false);
            LustyMapIcon = GetConfig ("Raid", "Map", "icon", "special");
            LustyMapDuration = GetConfig ("Raid", "Map", "duration", 150f);

            raidUnblockOnDeath = GetConfig ("Raid", "UnblockWhen", "death", true);
            raidUnblockOnWakeup = GetConfig ("Raid", "UnblockWhen", "wakeup", false);
            raidUnblockOnRespawn = GetConfig ("Raid", "UnblockWhen", "respawn", true);

            // COMBAT SETTINGS
            combatBlock = GetConfig ("Combat", "Block", "enabled", false);
            combatDuration = GetConfig ("Combat", "Block", "duration", 180f);
            combatBlockNotify = GetConfig ("Combat", "Block", "notify", true);
            combatDamageTypes = GetConfig ("Combat", "Block", "damageTypes", GetDefaultCombatDamageTypes ());

            //combatOnHitPlayer = GetConfig ("Combat", "BlockWhen", "giveDamage", true);
            Dictionary<string, object> blockOnCombatGiveDamageDetails = GetConfig ("Combat", "BlockWhen", "giveDamage", blockWhenCombatDamageDefault);
            if (blockOnCombatGiveDamageDetails.ContainsKey ("enabled")) {
                combatOnHitPlayer = (bool)blockOnCombatGiveDamageDetails ["enabled"];
            } else {
                combatOnHitPlayer = false;
            }

            if (blockOnCombatGiveDamageDetails.ContainsKey ("minCondition")) {
                combatOnHitPlayerMinCondition = Convert.ToSingle (blockOnCombatGiveDamageDetails ["minCondition"]);
            } else {
                combatOnHitPlayerMinCondition = 100f;
            }

            //combatOnTakeDamage = GetConfig ("Combat", "BlockWhen", "takeDamage", true);
            Dictionary<string, object> blockOnCombatTakeDamageDetails = GetConfig ("Combat", "BlockWhen", "takeDamage", blockWhenCombatDamageDefault);
            if (blockOnCombatTakeDamageDetails.ContainsKey ("enabled")) {
                combatOnTakeDamage = (bool)blockOnCombatTakeDamageDetails ["enabled"];
            } else {
                combatOnTakeDamage = false;
            }

            if (blockOnCombatTakeDamageDetails.ContainsKey ("minCondition")) {
                combatOnTakeDamageMinCondition = Convert.ToSingle (blockOnCombatTakeDamageDetails ["minCondition"]);
            } else {
                combatOnTakeDamageMinCondition = 100f;
            }

            if (blockOnCombatTakeDamageDetails.ContainsKey ("minDamage")) {
                combatOnTakeDamageMinDamage = Convert.ToSingle (blockOnCombatTakeDamageDetails ["minDamage"]);
            } else {
                combatOnTakeDamageMinDamage = 1f;
            }

            combatOnHitNPC = GetConfig ("Combat", "BlockWhen", "npcGiveDamage", false);
            combatOnTakeDamageNPC = GetConfig ("Combat", "BlockWhen", "npcTakeDamage", false);

            combatUnblockOnDeath = GetConfig ("Combat", "UnblockWhen", "death", true);
            combatUnblockOnWakeup = GetConfig ("Combat", "UnblockWhen", "wakeup", false);
            combatUnblockOnRespawn = GetConfig ("Combat", "UnblockWhen", "respawn", true);

            cacheTimer = GetConfig ("Settings", "cacheMinutes", 1f);

            sendUINotification = GetConfig ("Notifications", "UI", true);
            sendChatNotification = GetConfig ("Notifications", "Chat", true);

            sendGUIAnnouncementsNotification = GetConfig ("Notifications", "GUIAnnouncements", "enabled", false);
            GUIAnnouncementTintColor = GetConfig ("Notifications", "GUIAnnouncements", "backgroundColor", "Red");
            GUIAnnouncementTextColor = GetConfig ("Notifications", "GUIAnnouncements", "textColor", "White");

            if ((clanShare || clanCheck) && !Clans) {
                clanShare = false;
                clanCheck = false;
                PrintWarning ("Clans not found! All clan options disabled. Cannot use clan options without this plugin. http://oxidemod.org/plugins/clans.2087");
            }

            if (friendShare && !Friends) {
                friendShare = false;
                friendCheck = false;
                PrintWarning ("Friends not found! All friend options disabled. Cannot use friend options without this plugin. http://oxidemod.org/plugins/friends-api.686");
            }

            if (useZoneManager && !ZoneManager) {
                useZoneManager = false;
                PrintWarning ("ZoneManager not found! All zone options disabled. Cannot use zone options without this plugin. http://oxidemod.org/plugins/zones-manager.739");
            }

            if (sendGUIAnnouncementsNotification && !GUIAnnouncements) {
                sendGUIAnnouncementsNotification = false;
                PrintWarning ("GUIAnnouncements not found! GUI announcement option disabled. Cannot use gui announcement integration without this plugin. http://oxidemod.org/plugins/gui-announcements.1222");
            }

            if (sendLustyMapNotification && !LustyMap) {
                sendLustyMapNotification = false;
                PrintWarning ("LustyMap not found! LustyMap notification option disabled. Cannot use LustyMap integration without this plugin. http://oxidemod.org/plugins/lustymap.1333");
            }

            if (sendLustyMapNotification && LustyMap && LustyMapDuration <= 0) {
                PrintWarning ("LustyMap icon duration is zero, no icon will be displayed");
            }

            UnsubscribeHooks ();
        }

        void UnsubscribeHooks ()
        {
            if (!blockOnDestroy && !raidUnblockOnDeath && !combatUnblockOnDeath)
                Unsubscribe ("OnEntityDeath");

            if (!raidUnblockOnWakeup && !combatUnblockOnWakeup)
                Unsubscribe ("OnPlayerSleepEnded");

            if (!combatOnTakeDamage && !combatOnHitPlayer)
                Unsubscribe ("OnPlayerAttack");

            if (!blockOnDamage)
                Unsubscribe ("OnEntityTakeDamage");

            if (!blockTypes.Contains ("repair"))
                Unsubscribe ("OnStructureRepair");

            if (!blockTypes.Contains ("upgrade"))
                Unsubscribe ("OnStructureUpgrade");

            if (!blockTypes.Contains ("mailbox"))
                Unsubscribe ("CanUseMailbox");

            if (!blockTypes.Contains ("vend"))
                Unsubscribe ("CanUseVending");

            if (!blockTypes.Contains ("build"))
                Unsubscribe ("CanBuild");

            if (!blockTypes.Contains ("assignbed"))
                Unsubscribe ("CanAssignBed");

            if (!blockTypes.Contains ("craft"))
                Unsubscribe ("CanCraft");
                
            if (!blockTypes.Contains ("backpack"))
                Unsubscribe ("CanOpenBackpack");
                
            if(!useZoneManager)
            {
                Unsubscribe ("OnEnterZone");
                Unsubscribe ("OnExitZone");
            }
            
            if(!useRaidableBases)
            {
                Unsubscribe ("OnPlayerEnteredRaidableBase");
                Unsubscribe ("OnPlayerExitedRaidableBase");
            }
        }

        #endregion

        #region Classes

        public class RaidZone
        {
            public string zoneid;
            public Vector3 position;
            public Timer timer;

            public RaidZone (string zoneid, Vector3 position)
            {
                this.zoneid = zoneid;
                this.position = position;
            }

            public float Distance (RaidZone zone)
            {
                return Vector3.Distance (position, zone.position);
            }

            public float Distance (Vector3 pos)
            {
                return Vector3.Distance (position, pos);
            }

            public RaidZone ResetTimer ()
            {
                if (timer is Timer && !timer.Destroyed)
                    timer.Destroy ();

                return this;
            }
        }

        public abstract class BlockBehavior : MonoBehaviour
        {
            protected BasePlayer player;
            public DateTime lastBlock = DateTime.MinValue;
            public DateTime lastNotification = DateTime.MinValue;
            internal DateTime lastUINotification = DateTime.MinValue;
            internal Timer timer;
            internal Action notifyCallback;
            internal string iconUID;
            internal bool moved;

            public void CopyFrom (BlockBehavior behavior)
            {
                lastBlock = behavior.lastBlock;
                lastNotification = behavior.lastNotification;
                lastUINotification = behavior.lastUINotification;
                timer = behavior.timer;
                notifyCallback = behavior.notifyCallback;
                iconUID = behavior.iconUID;
                NotificationWindow = behavior.NotificationWindow;
            }

            internal abstract float Duration { get; }

            internal abstract CuiRectTransformComponent NotificationWindow { get; set; }

            internal abstract string notifyMessage { get; }

            internal string BlockName {
                get {
                    return GetType ().Name;
                }
            }

            public bool Active {
                get {
                    if (lastBlock > DateTime.MinValue) {
                        TimeSpan ts = DateTime.Now - lastBlock;
                        if (ts.TotalSeconds < Duration) {
                            return true;
                        }
                    }

                    GameObject.Destroy (this);

                    return false;
                }
            }

            void Awake ()
            {
                player = GetComponent<BasePlayer> ();
                if (plugin.blockBehaviors.ContainsKey (player.userID)) {
                    plugin.blockBehaviors.Remove (player.userID);
                }
                plugin.blockBehaviors.Add (player.userID, this);
            }

            void Destroy ()
            {
                if (!moved) {
                    Stop ();
                }
                CancelInvoke ("Update");
            }

            void Update ()
            {
                if (!plugin.sendUINotification)
                    return;
                bool send = false;
                if (lastUINotification == DateTime.MinValue) {
                    lastUINotification = DateTime.Now;
                    send = true;
                } else {
                    TimeSpan ts = DateTime.Now - lastUINotification;
                    if (ts.TotalSeconds > 2) {
                        send = true;
                    } else {
                        send = false;
                    }
                }

                if (player is BasePlayer && player.IsConnected) {
                    if (!Active) {
                        CuiHelper.DestroyUi (player, "BlockMsg" + BlockName);
                    }

                    if (send && Active) {
                        lastUINotification = DateTime.Now;
                        SendGUI ();
                    }
                }
            }

            public void Stop ()
            {
                if (notifyCallback is Action)
                    notifyCallback.Invoke ();

                if (timer is Timer && !timer.Destroyed)
                    timer.Destroy ();

                if (plugin.sendUINotification && player is BasePlayer && player.IsConnected)
                    CuiHelper.DestroyUi (player, "BlockMsg" + BlockName);

                plugin.blockBehaviors.Remove (player.userID);

                GameObject.Destroy (this);
            }

            public void Notify (Action callback)
            {
                if (plugin.sendUINotification)
                    SendGUI ();

                notifyCallback = callback;
                if (timer is Timer && !timer.Destroyed)
                    timer.Destroy ();

                timer = plugin.timer.In (Duration, callback);
            }

            private string FormatTime (TimeSpan ts)
            {
                if (ts.Days > 0)
                    return string.Format ("{0}D, {1}H", ts.Days, ts.Hours);

                if (ts.Hours > 0)
                    return string.Format ("{0}H {1}M", ts.Hours, ts.Minutes);

                return string.Format ("{0}M {1}S", ts.Minutes, ts.Seconds);
            }

            void SendGUI ()
            {
                TimeSpan ts = lastBlock.AddSeconds (Duration) - DateTime.Now;

                string countDown = FormatTime (ts);
                CuiHelper.DestroyUi (player, "BlockMsg" + BlockName);
                var elements = new CuiElementContainer ();
                var BlockMsg = elements.Add (new CuiPanel {
                    Image =
                        {
                            Color = "0.95 0 0.02 0.67"
                        },
                    RectTransform =
                        {
                            AnchorMax = NotificationWindow.AnchorMax,
                            AnchorMin = NotificationWindow.AnchorMin
                        }
                }, "Hud", "BlockMsg" + BlockName);
                elements.Add (new CuiElement {
                    Parent = BlockMsg,
                    Components =
                        {
                            new CuiRawImageComponent
                            {
                                Sprite = "assets/icons/explosion.png",
                                Color = "0.95 0 0.02 0.67"
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0 0",
                                AnchorMax = "0.13 1"
                            }
                        }
                });
                elements.Add (new CuiLabel {
                    RectTransform =
                        {
                            AnchorMin = "0.15 0",
                            AnchorMax = "0.82 1"
                        },
                    Text =
                        {
                            Text = notifyMessage,
                            FontSize = 11,
                            Align = TextAnchor.MiddleLeft,
                        }
                }, BlockMsg);
                elements.Add (new CuiElement {
                    Name = "TimerPanel",
                    Parent = BlockMsg,
                    Components =
                        {
                            new CuiImageComponent
                            {
                                Color = "0 0 0 0.64",
                                ImageType = UnityEngine.UI.Image.Type.Filled
                            },
                            new CuiRectTransformComponent
                            {
                                AnchorMin = "0.73 0",
                                AnchorMax = "1 1"
                            }
                        }
                });
                elements.Add (new CuiLabel {
                    RectTransform =
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "1 1"
                        },
                    Text =
                        {
                            Text = countDown,
                            FontSize = 12,
                            Align = TextAnchor.MiddleCenter,
                        }
                }, "TimerPanel");
                CuiHelper.AddUi (player, elements);
            }


        }

        public class CombatBlock : BlockBehavior
        {
            internal override float Duration {
                get {
                    return combatDuration;
                }
            }

            internal override string notifyMessage {
                get { return GetMsg ("Combat Block UI Message", player); }
            }

            CuiRectTransformComponent _notificationWindow = null;

            internal override CuiRectTransformComponent NotificationWindow {
                get {
                    if (_notificationWindow != null) {
                        return _notificationWindow;
                    }
                    return _notificationWindow = new CuiRectTransformComponent () {
                        AnchorMin = "0.44 0.15",
                        AnchorMax = "0.56 0.18"
                    };
                }
                set {
                    _notificationWindow = value;
                }
            }
        }

        public class RaidBlock : BlockBehavior
        {
            internal override float Duration {
                get {
                    return raidDuration;
                }
            }

            internal override string notifyMessage {
                get { return GetMsg ("Raid Block UI Message", player); }
            }

            private CuiRectTransformComponent _notificationWindow = null;

            internal override CuiRectTransformComponent NotificationWindow {
                get {
                    if (_notificationWindow != null) {
                        return _notificationWindow;
                    }
                    return _notificationWindow = new CuiRectTransformComponent () {
                        AnchorMin = "0.87 0.39",
                        AnchorMax = "0.99 0.42"
                    };
                }
                set {
                    _notificationWindow = value;
                }
            }
        }

        #endregion

        #region Oxide Hooks

        void OnEntityTakeDamage (BaseCombatEntity entity, HitInfo hitInfo)
        {
            if (!blockOnDamage || !raidBlock)
                return;
            if (hitInfo == null || hitInfo.Initiator == null || !IsEntityBlocked (entity) || hitInfo.Initiator.transform == null)
                return;
            if (!IsRaidDamage (hitInfo.damageTypes))
                return;
            if (IsExcludedWeapon (hitInfo?.WeaponPrefab?.ShortPrefabName))
                return;

            if (GetHealthPercent (entity, hitInfo.damageTypes.Total ()) > blockOnDamageMinCondition) {
                return;
            }

            StructureAttack (entity, hitInfo.Initiator, hitInfo?.WeaponPrefab?.ShortPrefabName, hitInfo.HitPositionWorld);
        }

        void OnPlayerConnected (BasePlayer player)
        {
            BlockBehavior behavior;
            if (blockBehaviors.TryGetValue (player.userID, out behavior)) {
                if (behavior is RaidBlock) {
                    var raidBlockComponent = player.gameObject.AddComponent<RaidBlock> ();
                    raidBlockComponent.CopyFrom (behavior);
                } else if (behavior is CombatBlock) {
                    var combatBlockComponent = player.gameObject.AddComponent<CombatBlock> ();
                    combatBlockComponent.CopyFrom (behavior);
                }

                behavior.moved = true;
                GameObject.Destroy (behavior);
            }
        }

        void OnPlayerAttack (BasePlayer attacker, HitInfo hitInfo)
        {
            if (!combatBlock || !(hitInfo.HitEntity is BasePlayer))
                return;
            if (!combatOnHitNPC && hitInfo.HitEntity.IsNpc)
                return;
            if (!combatOnTakeDamageNPC && attacker.IsNpc) {
                return;
            }
            if (!IsCombatDamage (hitInfo.damageTypes))
                return;

            float totalDamage = hitInfo.damageTypes.Total ();
            BasePlayer target = hitInfo.HitEntity as BasePlayer;

            if (combatOnTakeDamage) {
                if (GetHealthPercent (target, hitInfo.damageTypes.Total ()) > combatOnTakeDamageMinCondition) {
                    return;
                }

                if (totalDamage < combatOnTakeDamageMinDamage) {
                    return;
                }


                StartCombatBlocking (target);
            }

            if (combatOnHitPlayer) {
                if (GetHealthPercent (attacker, hitInfo.damageTypes.Total ()) > combatOnHitPlayerMinCondition) {
                    return;
                }

                if (totalDamage < combatOnHitPlayerMinDamage) {
                    return;
                }

                StartCombatBlocking (attacker);
            }
        }

        void OnEntityDeath (BaseCombatEntity entity, HitInfo hitInfo)
        {
            if (blockOnDestroy && raidBlock) {
                if (hitInfo == null || hitInfo.Initiator == null || !IsDeathDamage (hitInfo.damageTypes) || !IsEntityBlocked (entity))
                    return;

                StructureAttack (entity, hitInfo.Initiator, hitInfo?.WeaponPrefab?.ShortPrefabName, hitInfo.HitPositionWorld);
            }

            if (entity.ToPlayer () == null)
                return;

            var player = entity.ToPlayer ();
            RaidBlock raidBlocker;
            if (raidBlock && raidUnblockOnDeath && TryGetBlocker (player, out raidBlocker)) {
                timer.In (0.3f, delegate () {
                    raidBlocker.Stop ();
                });
            }

            CombatBlock combatBlocker;
            if (combatBlock && combatUnblockOnDeath && TryGetBlocker (player, out combatBlocker)) {
                timer.In (0.3f, delegate () {
                    combatBlocker.Stop ();
                });
            }
        }

        void OnPlayerSleepEnded (BasePlayer player)
        {
            if (player == null) return;
            RaidBlock raidBlocker;
            if (raidBlock && raidUnblockOnWakeup && TryGetBlocker (player, out raidBlocker)) {
                timer.In (0.3f, delegate () {
                    raidBlocker.Stop ();
                });
            }

            CombatBlock combatBlocker;
            if (combatBlock && combatUnblockOnWakeup && TryGetBlocker (player, out combatBlocker)) {
                timer.In (0.3f, delegate () {
                    combatBlocker.Stop ();
                });
            }
        }

        void OnPlayerRespawned (BasePlayer player)
        {
            if (player == null) return;
            RaidBlock raidBlocker;
            if (raidBlock && raidUnblockOnRespawn && TryGetBlocker (player, out raidBlocker)) {
                timer.In (0.3f, delegate () {
                    raidBlocker.Stop ();
                });
            }

            CombatBlock combatBlocker;
            if (combatBlock && combatUnblockOnRespawn && TryGetBlocker (player, out combatBlocker)) {
                timer.In (0.3f, delegate () {
                    combatBlocker.Stop ();
                });
            }
        }

        object CanLootEntity(BasePlayer player, StorageContainer container)
        {
            if(container?.GetEntity() is Recycler)
            {
                object reply = CanDo("recycle", player);

                if (reply != null && IsBlocked(player))
                {
                    player.ChatMessage((string)reply);
                    return true;
                }
            }

            return null;
        }

        #endregion

        #region Block Handling

        void StructureAttack (BaseEntity targetEntity, BaseEntity sourceEntity, string weapon, Vector3 hitPosition)
        {
            BasePlayer source = null;

            if (sourceEntity.ToPlayer () is BasePlayer)
                source = sourceEntity.ToPlayer ();
            else {
                ulong ownerID = sourceEntity.OwnerID;
                if (ownerID.IsSteamId ())
                    source = BasePlayer.FindByID (ownerID);
                else
                    return;
            }

            if (source == null)
                return;

            List<string> sourceMembers = null;

            if (targetEntity.OwnerID.IsSteamId () || (blockUnowned && !targetEntity.OwnerID.IsSteamId ())) {
                if (clanCheck || friendCheck)
                    sourceMembers = getFriends (source.UserIDString);

                if (blockAll) {
                    BlockAll (source, targetEntity, sourceMembers);
                } else {
                    if (ownerBlock)
                        OwnerBlock (source, sourceEntity, targetEntity.OwnerID, targetEntity.transform.position, sourceMembers);

                    if (raiderBlock)
                        RaiderBlock (source, targetEntity.OwnerID, targetEntity.transform.position, sourceMembers);
                }
            }
        }

        float GetHealthPercent (BaseEntity entity, float damage = 0f)
        {
            return (entity.Health () - damage) * 100f / entity.MaxHealth ();
        }

        void BlockAll (BasePlayer source, BaseEntity targetEntity, List<string> sourceMembers = null)
        {
            if (ShouldBlockEscape (targetEntity.OwnerID, source.userID, sourceMembers)) {
                StartRaidBlocking (source, targetEntity.transform.position);
            }

            var checkSourceMembers = false;
            if (targetEntity.OwnerID == source.userID || (sourceMembers is List<string> && sourceMembers.Contains (targetEntity.OwnerID.ToString ()))) {
                checkSourceMembers = true;
            }

            var nearbyTargets = Pool.GetList<BasePlayer> ();
            Vis.Entities (targetEntity.transform.position, raidDistance, nearbyTargets, blockLayer);
            if (nearbyTargets.Count > 0) {
                RaidBlock blocker;
                foreach (BasePlayer nearbyTarget in nearbyTargets) {
                    if (nearbyTarget.IsNpc) continue;
                    if (nearbyTarget.userID == source.userID) continue;
                    if (TryGetBlocker (nearbyTarget, out blocker) && blocker.Active) {
                        StartRaidBlocking (nearbyTarget, targetEntity.transform.position);
                    } else if (ShouldBlockEscape (nearbyTarget.userID, source.userID, checkSourceMembers ? sourceMembers : null)) {
                        StartRaidBlocking (nearbyTarget, targetEntity.transform.position);
                    }
                }
            }

            Pool.FreeList (ref nearbyTargets);
        }

        void OwnerBlock (BasePlayer source, BaseEntity sourceEntity, ulong target, Vector3 position, List<string> sourceMembers = null)
        {
            if (!ShouldBlockEscape (target, source.userID, sourceMembers))
                return;

            var targetMembers = new List<string> ();

            if (clanShare || friendShare)
                targetMembers = getFriends (target.ToString ());

            var nearbyTargets = Pool.GetList<BasePlayer> ();
            Vis.Entities (position, raidDistance, nearbyTargets, blockLayer);
            if (cupboardShare)
                sourceMembers = CupboardShare (target.ToString (), position, sourceEntity, sourceMembers);

            if (nearbyTargets.Count > 0) {
                foreach (BasePlayer nearbyTarget in nearbyTargets) {
                    if (nearbyTarget.IsNpc) continue;
                    if (nearbyTarget.userID == target || (targetMembers != null && targetMembers.Contains (nearbyTarget.UserIDString)))
                        StartRaidBlocking (nearbyTarget, position);
                }
            }

            Pool.FreeList (ref nearbyTargets);
        }

        List<string> CupboardShare (string owner, Vector3 position, BaseEntity sourceEntity, List<string> sourceMembers = null)
        {
            var nearbyCupboards = Pool.GetList<BuildingPrivlidge> ();
            Vis.Entities (position, raidDistance, nearbyCupboards, cupboardMask);
            if (sourceMembers == null)
                sourceMembers = new List<string> ();

            List<string> cupboardMembers = new List<string> ();

            var sourcePlayer = sourceEntity as BasePlayer;

            if (sourcePlayer != null) {
                foreach (var cup in nearbyCupboards) {
                    if (cup.IsAuthed (sourcePlayer)) {
                        bool ownerOrFriend = false;

                        if (owner == cup.OwnerID.ToString ())
                            ownerOrFriend = true;

                        foreach (var member in sourceMembers) {
                            if (member == cup.OwnerID.ToString ())
                                ownerOrFriend = true;
                        }

                        if (ownerOrFriend)
                            foreach (var proto in cup.authorizedPlayers)
                                if (!sourceMembers.Contains (proto.userid.ToString ()))
                                    cupboardMembers.Add (proto.userid.ToString ());
                    }
                }
            }

            sourceMembers.AddRange (cupboardMembers);
            Pool.FreeList (ref nearbyCupboards);

            return sourceMembers;
        }

        void RaiderBlock (BasePlayer source, ulong target, Vector3 position, List<string> sourceMembers = null)
        {
            if (!ShouldBlockEscape (target, source.userID, sourceMembers))
                return;

            var targetMembers = new List<string> ();

            if ((clanShare || friendShare) && sourceMembers == null)
                sourceMembers = getFriends (source.UserIDString);

            var nearbyTargets = Pool.GetList<BasePlayer> ();
            Vis.Entities (position, raidDistance, nearbyTargets, blockLayer);
            if (nearbyTargets.Count > 0) {
                foreach (BasePlayer nearbyTarget in nearbyTargets) {
                    if (nearbyTarget.IsNpc) continue;
                    if (nearbyTarget == source || (sourceMembers != null && sourceMembers.Contains (nearbyTarget.UserIDString)))
                        StartRaidBlocking (nearbyTarget, position);
                }
            }

            Pool.FreeList (ref nearbyTargets);
        }

        #endregion

        #region API

        bool IsBlocked (string target)
        {
            var player = BasePlayer.Find (target);
            if (player is BasePlayer) {
                return IsBlocked (player);
            }

            return false;
        }

        bool IsBlocked (BasePlayer target)
        {
            if (IsBlocked<RaidBlock> (target) || IsBlocked<CombatBlock> (target))
                return true;

            return false;
        }

        public bool IsBlocked<T> (BasePlayer target) where T : BlockBehavior
        {
            T behavior;
            if (TryGetBlocker<T> (target, out behavior) && behavior.Active)
                return true;

            return false;
        }

        bool IsRaidBlocked (BasePlayer target)
        {
            return IsBlocked<RaidBlock> (target);
        }

        bool IsCombatBlocked (BasePlayer target)
        {
            return IsBlocked<CombatBlock> (target);
        }

        bool IsEscapeBlocked (string target)
        {
            var player = BasePlayer.Find (target);
            if (player is BasePlayer) {
                return IsBlocked (player);
            }

            return false;
        }

        bool IsRaidBlocked (string target)
        {
            var player = BasePlayer.Find (target);
            if (player is BasePlayer) {
                return IsBlocked<RaidBlock> (player);
            }

            return false;
        }

        bool IsCombatBlocked (string target)
        {
            var player = BasePlayer.Find (target);
            if (player is BasePlayer) {
                return IsBlocked<CombatBlock> (player);
            }

            return false;
        }

        bool ShouldBlockEscape (ulong target, ulong source, List<string> sourceMembers = null)
        {
            if (target == source) {
                if ((ownerBlock || raiderBlock || blockAll) && (!ownerCheck))
                    return true;

                return false;
            }

            if (sourceMembers is List<string> && sourceMembers.Contains (target.ToString ()))
                return false;

            return true;
        }

        //[ChatCommand ("bblocked")]
        //void cmdBBlocked (BasePlayer player, string command, string [] args)
        //{
        //    StartCombatBlocking (player);
        //    StartRaidBlocking (player);
        //}

        //[ChatCommand ("bunblocked")]
        //void cmdBUnblocked (BasePlayer player, string command, string [] args)
        //{
        //    StopCombatBlocking (player);
        //    StopRaidBlocking (player);
        //}

        void StartRaidBlocking (BasePlayer target, bool createZone = true)
        {
            StartRaidBlocking (target, target.transform.position, createZone);
        }

        void StartRaidBlocking (BasePlayer target, Vector3 position, bool createZone = true)
        {
            if (HasPerm (target.UserIDString, "disable")) {
                return;
            }

            if (target.gameObject == null) {
                return;
            }

            if (Interface.Call ("CanRaidBlock", target, position, createZone) != null) {
                return;
            }

            if (target.gameObject == null)
                return;
            var raidBlocker = target.gameObject.GetComponent<RaidBlock> ();
            if (raidBlocker == null) {
                raidBlocker = target.gameObject.AddComponent<RaidBlock> ();
            }

            Interface.CallHook ("OnRaidBlock", target, position);

            raidBlocker.lastBlock = DateTime.Now;

            if (raidBlockNotify)
                SendBlockMessage (target, raidBlocker, "Raid Block Notifier", "Raid Block Complete");

            if (useZoneManager && createZone && (zoneEnter || zoneLeave))
                CreateRaidZone (position);
        }

        void StartCombatBlocking (BasePlayer target)
        {
            if (HasPerm (target.UserIDString, "disable")) {
                return;
            }

            if (target.gameObject == null) {
                return;
            }

            if (Interface.Call ("CanCombatBlock", target) != null) {
                return;
            }

            var combatBlocker = target.gameObject.GetComponent<CombatBlock> ();
            if (combatBlocker == null) {
                combatBlocker = target.gameObject.AddComponent<CombatBlock> ();
            }

            Interface.CallHook ("OnCombatBlock", target);

            combatBlocker.lastBlock = DateTime.Now;

            if (combatBlockNotify)
                SendBlockMessage (target, combatBlocker, "Combat Block Notifier", "Combat Block Complete");
        }

        void StopBlocking (BasePlayer target)
        {
            if (IsRaidBlocked (target))
                StopBlocking<RaidBlock> (target);
            if (IsCombatBlocked (target))
                StopBlocking<CombatBlock> (target);
        }

        public void StopBlocking<T> (BasePlayer target) where T : BlockBehavior
        {
            if (target.gameObject == null)
                return;
            var block = target.gameObject.GetComponent<T> ();
            if (block is BlockBehavior)
                block.Stop ();

            if (block is RaidBlock) {
                Interface.CallHook ("OnRaidBlockStopped", target);
            } else if (block is CombatBlock) {
                Interface.CallHook ("OnCombatBlockStopped", target);
            }
        }

        void ClearRaidBlockingS (string target)
        {
            StopRaidBlocking (target);
        }

        void StopRaidBlocking (BasePlayer player)
        {
            if (player is BasePlayer && IsRaidBlocked (player))
                StopBlocking<RaidBlock> (player);
        }

        void StopRaidBlocking (string target)
        {
            var player = BasePlayer.Find (target);
            StopRaidBlocking (player);
        }

        void StopCombatBlocking (BasePlayer player)
        {
            if (player is BasePlayer && IsRaidBlocked (player))
                StopBlocking<CombatBlock> (player);
        }

        void StopCombatBlocking (string target)
        {
            var player = BasePlayer.Find (target);
            StopCombatBlocking (player);
        }

        void ClearCombatBlocking (string target)
        {
            StopCombatBlocking (target);
        }

        #endregion

        #region Zone Handling

        void EraseZone (string zoneid)
        {
            ZoneManager.CallHook ("EraseZone", zoneid);
            zones.Remove (zoneid);
        }

        void ResetZoneTimer (RaidZone zone)
        {
            zone.ResetTimer ().timer = timer.In (raidDuration, delegate () {
                EraseZone (zone.zoneid);
            });
        }

        void CreateRaidZone (Vector3 position)
        {
            var zoneid = position.ToString ();

            RaidZone zone;
            if (zones.TryGetValue (zoneid, out zone)) {
                ResetZoneTimer (zone);
                return;
            }

            foreach (var nearbyZone in zones) {
                if (nearbyZone.Value.Distance (position) < (raidDistance / 2)) {
                    ResetZoneTimer (nearbyZone.Value);
                    return;
                }
            }

            ZoneManager.CallHook ("CreateOrUpdateZone", zoneid, new string []
                {
                    "radius",
                    raidDistance.ToString()
                }, position);

            zones.Add (zoneid, zone = new RaidZone (zoneid, position));

            ResetZoneTimer (zone);
        }

        [HookMethod ("OnEnterZone")]
        void OnEnterZone (string zoneid, BasePlayer player)
        {
            if (!zoneEnter)
                return;
            if (!zones.ContainsKey (zoneid))
                return;

            StartRaidBlocking (player, player.transform.position, false);
        }

        [HookMethod ("OnExitZone")]
        void OnExitZone (string zoneid, BasePlayer player)
        {
            if (!zoneLeave)
                return;
            if (!zones.ContainsKey (zoneid))
                return;

            if (IsRaidBlocked (player)) {
                StopBlocking<RaidBlock> (player);
            }
        }
        
        [HookMethod ("OnPlayerEnteredRaidableBase")]
        void OnPlayerEnteredRaidableBase(BasePlayer player, Vector3 raidPos, bool allowPVP)
        {
            if (!raidableZoneEnter)
                return;
                
            StartRaidBlocking (player, false);
        }
        
        [HookMethod ("OnPlayerExitedRaidableBase")]
        void OnPlayerExitedRaidableBase(BasePlayer player, Vector3 raidPos, bool allowPVP)
        {
            if (!raidableZoneLeave)
                return;
                
            if (IsRaidBlocked (player)) {
                StopBlocking<RaidBlock> (player);
            }
        }

        #endregion

        #region Friend/Clan Integration

        public List<string> getFriends (string player)
        {
            var players = new List<string> ();
            if (player == null)
                return players;

            if (friendShare || friendCheck) {
                var friendList = getFriendList (player);
                if (friendList != null)
                    players.AddRange (friendList);
            }

            if (clanShare || clanCheck) {
                var members = getClanMembers (player);
                if (members != null)
                    players.AddRange (members);
            }
            return players;
        }

        public List<string> getFriendList (string player)
        {
            object friends_obj = null;
            DateTime lastFriendCheckPlayer;
            var players = new List<string> ();

            if (lastFriendCheck.TryGetValue (player, out lastFriendCheckPlayer)) {
                if ((DateTime.Now - lastFriendCheckPlayer).TotalMinutes <= cacheTimer && friendCache.TryGetValue (player, out players)) {
                    return players;
                } else {
                    friends_obj = Friends?.CallHook ("IsFriendOfS", player);
                    lastFriendCheck [player] = DateTime.Now;
                }
            } else {
                friends_obj = Friends?.CallHook ("IsFriendOfS", player);
                lastFriendCheck.Add (player, DateTime.Now);
            }

            if (friends_obj == null)
                return players;

            string [] friends = friends_obj as string [];

            foreach (string fid in friends)
                players.Add (fid);

            if (friendCache.ContainsKey (player))
                friendCache [player] = players;
            else
                friendCache.Add (player, players);

            return players;
        }

        public List<string> getClanMembers (string player)
        {
            string tag = null;
            DateTime lastClanCheckPlayer;
            string lastClanCached;
            if (lastClanCheck.TryGetValue (player, out lastClanCheckPlayer) && clanCache.TryGetValue (player, out lastClanCached)) {
                if ((DateTime.Now - lastClanCheckPlayer).TotalMinutes <= cacheTimer)
                    tag = lastClanCached;
                else {
                    tag = Clans.Call<string> ("GetClanOf", player);
                    clanCache [player] = tag;
                    lastClanCheck [player] = DateTime.Now;
                }
            } else {
                tag = Clans.Call<string> ("GetClanOf", player);
                if (lastClanCheck.ContainsKey (player))
                    lastClanCheck.Remove (player);

                if (clanCache.ContainsKey (player))
                    clanCache.Remove (player);

                clanCache.Add (player, tag);
                lastClanCheck.Add (player, DateTime.Now);
            }

            if (tag == null)
                return null;

            List<string> lastMemberCache;
            if (memberCache.TryGetValue (tag, out lastMemberCache))
                return lastMemberCache;

            var clan = GetClan (tag);

            if (clan == null)
                return null;

            return CacheClan (clan);
        }

        JObject GetClan (string tag)
        {
            if (string.IsNullOrEmpty (tag)) {
                return null;
            }
            return Clans.Call<JObject> ("GetClan", tag);
        }

        List<string> CacheClan (JObject clan)
        {
            string tag = clan ["tag"].ToString ();
            List<string> players = new List<string> ();
            foreach (string memberid in clan ["members"]) {
                if (clanCache.ContainsKey (memberid))
                    clanCache [memberid] = tag;
                else
                    clanCache.Add (memberid, tag);

                players.Add (memberid);
            }

            if (memberCache.ContainsKey (tag))
                memberCache [tag] = players;
            else
                memberCache.Add (tag, players);

            if (lastCheck.ContainsKey (tag))
                lastCheck [tag] = DateTime.Now;
            else
                lastCheck.Add (tag, DateTime.Now);

            return players;
        }

        [HookMethod ("OnClanCreate")]
        void OnClanCreate (string tag)
        {
            var clan = GetClan (tag);
            if (clan != null) {
                CacheClan (clan);
            } else {
                PrintWarning ("Unable to find clan after creation: " + tag);
            }
        }

        [HookMethod ("OnClanUpdate")]
        void OnClanUpdate (string tag)
        {
            var clan = GetClan (tag);
            if (clan != null) {
                CacheClan (clan);
            } else {
                PrintWarning ("Unable to find clan after update: " + tag);
            }
        }

        [HookMethod ("OnClanDestroy")]
        void OnClanDestroy (string tag)
        {
            if (lastCheck.ContainsKey (tag)) {
                lastCheck.Remove (tag);
            }

            if (memberCache.ContainsKey (tag)) {
                memberCache.Remove (tag);
            }
        }

        #endregion

        #region Permission Checking & External API Handling

        bool HasPerm (string userid, string perm)
        {
            return permission.UserHasPermission (userid, "noescape." + perm);
        }

        bool CanRaidCommand (BasePlayer player, string command)
        {
            return raidBlock && HasPerm (player.UserIDString, "raid." + command + "block") && IsRaidBlocked (player);
        }

        bool CanRaidCommand (string playerID, string command)
        {
            return raidBlock && HasPerm (playerID, "raid." + command + "block") && IsRaidBlocked (playerID);
        }

        bool CanCombatCommand (BasePlayer player, string command)
        {
            return combatBlock && HasPerm (player.UserIDString, "combat." + command + "block") && IsCombatBlocked (player);
        }

        bool CanCombatCommand (string playerID, string command)
        {
            return combatBlock && HasPerm (playerID, "combat." + command + "block") && IsCombatBlocked (playerID);
        }

        object CanDo (string command, BasePlayer player)
        {
            if (CanRaidCommand (player, command))
                return GetMessage<RaidBlock> (player, "Raid Blocked Message", raidDuration);
            else if (CanCombatCommand (player, command))
                return GetMessage<CombatBlock> (player, "Combat Blocked Message", combatDuration);

            return null;
        }

        object OnStructureRepair (BaseCombatEntity entity, BasePlayer player)
        {
            var result = CanDo ("repair", player);
            if (result is string) {
                if (entity.health > entity.MaxHealth ()) {
                    return null;
                }
                SendReply (player, result.ToString ());
                return true;
            }

            return null;
        }

        object OnStructureUpgrade (BuildingBlock block, BasePlayer player, BuildingGrade.Enum grade)
        {
            var result = CanDo ("upgrade", player);
            if (result is string) {
                SendReply (player, result.ToString ());
                return true;
            }

            return null;
        }

        object CanRedeemKit (BasePlayer player)
        {
            return CanDo ("kit", player);
        }

        object CanUseMailbox (BasePlayer player, Mailbox mailbox)
        {
            var result = CanDo ("mailbox", player);
            if (result is string) {
                SendReply (player, result.ToString ());
                return true;
            }

            return null;
        }

        object CanUseVending (VendingMachine machine, BasePlayer player)
        {
            var result = CanDo ("vend", player);
            if (result is string) {
                SendReply (player, result.ToString ());
                return true;
            }

            return null;
        }

        object CanBuild (Planner plan, Construction prefab)
        {
            var player = plan.GetOwnerPlayer ();
            var result = CanDo ("build", player);
            if (result is string) {
                if (isEntityException (prefab.fullName)) {
                    return null;
                }

                SendReply (player, result.ToString ());
                return true;
            }

            return null;
        }

        object CanAssignBed (SleepingBag bag, BasePlayer player, ulong targetPlayerId)
        {
            var result = CanDo ("assignbed", player);
            if (result is string) {
                SendReply (player, result.ToString ());
                return true;
            }

            return null;
        }
        
        object CanOpenBackpack(BasePlayer player, ulong backpackOwnerID)
        {
            return CanDo ("backpack", player);
        }

        object CanBank (BasePlayer player)
        {
            return CanDo ("bank", player);
        }

        object CanTrade (BasePlayer player)
        {
            return CanDo ("trade", player);
        }

        object canRemove (BasePlayer player)
        {
            return CanDo ("remove", player);
        }

        object canShop (BasePlayer player)
        {
            return CanDo ("shop", player);
        }

        object CanShop (BasePlayer player)
        {
            return CanDo ("shop", player);
        }

        object CanTeleport (BasePlayer player)
        {
            return CanDo ("tp", player);
        }

        object canTeleport (BasePlayer player) // ALIAS FOR MagicTeleportation
        {
            return CanTeleport (player);
        }

        object CanGridTeleport (BasePlayer player) // ALIAS FOR GrTeleport
        {
            return CanTeleport (player);
        }

        object CanCraft (ItemCrafter itemCrafter, ItemBlueprint bp, int amount)
        {
            BasePlayer player = itemCrafter.containers [0].GetOwnerPlayer ();

            if (player != null) {
                var result = CanDo ("craft", player);
                if (result is string) {
                    SendReply (player, result.ToString ());
                    return false;
                }
            }

            return null;
        }

        object CanRecycleCommand (BasePlayer player)
        {
            return CanDo ("recycle", player);
        }

        object CanBGrade (BasePlayer player, int grade, BuildingBlock buildingBlock, Planner planner)
        {
            if (CanRaidCommand (player, "bgrade") || CanCombatCommand (player, "bgrade"))
                return -1;
            return null;
        }

        #endregion

        #region Messages

        void SendBlockMessage (BasePlayer target, BlockBehavior blocker, string langMessage, string completeMessage)
        {
            var send = false;
            if (blocker.lastNotification != DateTime.MinValue) {
                TimeSpan diff = DateTime.Now - blocker.lastNotification;
                if (diff.TotalSeconds >= (blocker.Duration / 2))
                    send = true;
            } else
                send = true;

            if (send) {
                string message = string.Empty;

                if (sendChatNotification || sendGUIAnnouncementsNotification)
                    message = GetPrefix (target.UserIDString) + GetMsg (langMessage, target.UserIDString).Replace ("{time}", GetCooldownTime (blocker.Duration, target.UserIDString));

                if (sendChatNotification)
                    SendReply (target, message);

                if (sendGUIAnnouncementsNotification)
                    GUIAnnouncements?.Call ("CreateAnnouncement", message, GUIAnnouncementTintColor, GUIAnnouncementTextColor, target);

                if (sendLustyMapNotification && LustyMapDuration > 0) {
                    blocker.iconUID = Guid.NewGuid ().ToString ("N");
                    var obj = LustyMap?.Call ("AddMarker", target.transform.position.x, target.transform.position.z, blocker.iconUID, LustyMapIcon);
                    if (obj is bool && (bool)obj == true) {
                        timer.In (LustyMapDuration, delegate () {
                            LustyMap?.Call ("RemoveMarker", blocker.iconUID);
                        });
                    }
                }

                blocker.lastNotification = DateTime.Now;
            }

            blocker.Notify (delegate () {
                blocker.notifyCallback = null;
                if (target?.IsConnected == true) {
                    string message = string.Empty;

                    if (sendChatNotification || sendGUIAnnouncementsNotification)
                        message = GetPrefix (target.UserIDString) + GetMsg (completeMessage, target.UserIDString);

                    if (sendChatNotification)
                        SendReply (target, message);

                    if (sendGUIAnnouncementsNotification)
                        GUIAnnouncements?.Call ("CreateAnnouncement", message, GUIAnnouncementTintColor, GUIAnnouncementTextColor, target);

                    if (sendLustyMapNotification && LustyMapDuration > 0)
                        LustyMap?.Call ("RemoveMarker", blocker.iconUID);
                }
            });
        }

        string GetCooldownTime (float f, string userID)
        {
            if (f > 60)
                return Math.Round (f / 60, 1) + " " + GetMsg ("Unit Minutes", userID);

            return f + " " + GetMsg ("Unit Seconds", userID);
        }

        public string GetMessage (BasePlayer player)
        {
            if (IsRaidBlocked (player))
                return GetMessage<RaidBlock> (player, "Raid Blocked Message", raidDuration);
            else if (IsCombatBlocked (player))
                return GetMessage<CombatBlock> (player, "Combat Blocked Message", combatDuration);

            return null;
        }

        public string GetPrefix (string player)
        {
            string prefix = GetMsg ("Prefix", player);
            if (!string.IsNullOrEmpty (prefix)) {
                return prefix + ": ";
            }

            return string.Empty;
        }

        public string GetMessage<T> (BasePlayer player, string blockMsg, float duration) where T : BlockBehavior
        {
            T blocker;
            if (duration > 0 && TryGetBlocker<T> (player, out blocker)) {
                var ts = DateTime.Now - blocker.lastBlock;
                var unblocked = Math.Round ((duration / 60) - Convert.ToSingle (ts.TotalMinutes), 2);

                if (ts.TotalMinutes <= duration) {
                    if (unblocked < 1) {
                        var timelefts = Math.Round (Convert.ToDouble (duration) - ts.TotalSeconds);
                        return GetPrefix (player.UserIDString) + GetMsg (blockMsg, player).Replace ("{time}", timelefts.ToString () + " " + GetMsg ("Unit Seconds", player));
                    }

                    return GetPrefix (player.UserIDString) + GetMsg (blockMsg, player).Replace ("{time}", unblocked.ToString () + " " + GetMsg ("Unit Minutes", player));
                }
            }

            return null;
        }

        #endregion

        #region Utility Methods

        bool TryGetBlocker<T> (BasePlayer player, out T blocker) where T : BlockBehavior
        {
            blocker = null;
            if (player.gameObject == null)
                return false;
            if ((blocker = player.gameObject.GetComponent<T> ()) != null)
                return true;

            return false;
        }

        public bool isEntityException (string prefabName)
        {
            var result = false;

            foreach (string p in exceptionPrefabs) {
                if (prefabName.IndexOf (p) != -1) {
                    result = true;
                    break;
                }
            }

            return result;
        }

        public bool IsEntityBlocked (BaseCombatEntity entity)
        {
            if (entity is BuildingBlock) {
                if (((BuildingBlock)entity).grade == BuildingGrade.Enum.Twigs)
                    return false;

                return true;
            }

            var prefabName = entity.ShortPrefabName;
            var result = false;
            if (prefabBlockCache.TryGetValue (prefabName, out result))
                return result;

            result = false;

            foreach (string p in blockedPrefabs) {
                if (prefabName.IndexOf (p) != -1) {
                    result = true;
                    break;
                }
            }


            prefabBlockCache.Add (prefabName, result);
            return result;
        }

        bool IsRaidDamage (DamageType dt)
        {
            return raidDamageTypes.Contains (dt.ToString ());
        }

        bool IsDeathDamage (DamageType dt)
        {
            return raidDeathTypes.Contains (dt.ToString ());
        }

        bool IsRaidDamage (DamageTypeList dtList)
        {
            for (int index = 0; index < dtList.types.Length; ++index) {
                if (dtList.types [index] > 0 && IsRaidDamage ((DamageType)index)) {
                    return true;
                }
            }

            return false;
        }

        bool IsDeathDamage (DamageTypeList dtList)
        {
            for (int index = 0; index < dtList.types.Length; ++index) {
                if (dtList.types [index] > 0 && IsDeathDamage ((DamageType)index)) {
                    return true;
                }
            }

            return false;
        }

        bool IsExcludedWeapon (string name)
        {
            if (string.IsNullOrEmpty (name)) {
                return false;
            }

            bool cachedValue;

            if (_cachedExcludedWeapons.TryGetValue (name, out cachedValue)) {
                return cachedValue;
            }

            foreach (var weaponName in exceptionWeapons) {
                if (name.Contains (weaponName)) {
                    _cachedExcludedWeapons.Add (name, true);
                    return true;
                }
            }

            _cachedExcludedWeapons.Add (name, false);
            return false;
        }

        bool IsCombatDamage (DamageType dt)
        {
            return combatDamageTypes.Contains (dt.ToString ());
        }

        bool IsCombatDamage (DamageTypeList dtList)
        {
            for (int index = 0; index < dtList.types.Length; ++index) {
                if (dtList.types [index] > 0 && IsCombatDamage ((DamageType)index)) {
                    return true;
                }
            }

            return false;
        }

        T GetConfig<T> (string name, string name2, string name3, T defaultValue)
        {
            try {
                var val = Config [name, name2, name3];

                return ParseValue<T> (val, defaultValue);
            } catch (Exception ex) {
                //PrintWarning ("Invalid config value: " + name + "/" + name2 + "/" + name3 + " (" + ex.Message + ")");
                Config [name, name2, name3] = defaultValue;
                Config.Save ();
                return defaultValue;
            }
        }

        T GetConfig<T> (string name, string name2, T defaultValue)
        {
            try {
                var val = Config [name, name2];

                return ParseValue<T> (val, defaultValue);
            } catch (Exception ex) {
                //PrintWarning ("Invalid config value: " + name + "/" + name2 + " (" + ex.Message + ")");
                Config [name, name2] = defaultValue;
                Config.Save ();
                return defaultValue;
            }
        }

        T GetConfig<T> (string name, T defaultValue)
        {
            try {
                var val = Config [name];

                return ParseValue<T> (val, defaultValue);
            } catch (Exception ex) {
                //PrintWarning ("Invalid config value: " + name + " (" + ex.Message + ")");
                Config [name] = defaultValue;
                Config.Save ();
                return defaultValue;
            }
        }

        T ParseValue<T> (object val, T defaultValue)
        {
            if (val == null)
                return defaultValue;

            if (val is List<object>) {
                var t = typeof (T).GetGenericArguments () [0];
                if (t == typeof (String)) {
                    var cval = new List<string> ();
                    foreach (var v in val as List<object>)
                        cval.Add ((string)v);
                    val = cval;
                } else if (t == typeof (int)) {
                    var cval = new List<int> ();
                    foreach (var v in val as List<object>)
                        cval.Add (Convert.ToInt32 (v));
                    val = cval;
                }
            } else if (val is Dictionary<string, object>) {
                var t = typeof (T).GetGenericArguments () [1];
                if (t == typeof (int)) {
                    var cval = new Dictionary<string, int> ();
                    foreach (var v in val as Dictionary<string, object>)
                        cval.Add (Convert.ToString (v.Key), Convert.ToInt32 (v.Value));
                    val = cval;
                }
            }

            return (T)Convert.ChangeType (val, typeof (T));
        }

        static string GetMsg (string key, object user = null)
        {
            if (user is BasePlayer) {
                user = ((BasePlayer)user).UserIDString;
            }
            return plugin.lang.GetMessage (key, plugin, user == null ? null : user.ToString ());
        }

        #endregion
    }
}

// --- End of file: NoEscape.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/notify-to-discord ---
// --- Original File Path: N/NotifyToDiscord/NotifyToDiscord.cs ---

using Oxide.Core;
using Oxide.Core.Plugins;
using Rust;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using UnityEngine;
using Oxide.Core.Libraries.Covalence;
using Newtonsoft.Json;
using System.Net;

namespace Oxide.Plugins
{
    [Info("Notify To Discord", "BuzZ", "0.0.12")]
    [Description("Choose from a large range of server/player notifications to message to a Discord channel")]
    public class NotifyToDiscord : RustPlugin
    {
        [PluginReference]     
        Plugin BetterChat, HooksExtended, DangerousTreasures, HumanNPC, DiscordMessages; 

        bool debug = false;

        string Prefix = "[NTD] :";                       // CHAT PLUGIN PREFIX
        string PrefixColor = "#42d7f4";                 // CHAT PLUGIN PREFIX COLOR
        string ChatColor = "#b7f5ff";                   // CHAT MESSAGE COLOR
        ulong SteamIDIcon = 76561198044414155;          // SteamID FOR PLUGIN ICON
        bool countonline = true;
        string WebHookURL = string.Empty;
        bool WebHook = false;

        public List<string> queue = new List<string>();
        private static string BaseURLTemplate = "https://discordapp.com/api/channels/{{ChannelID}}/messages";
        bool discording;

#region HOOKS BOOL

        bool addvendingoffer, airdrop, apchunt, onattack, chatmessage, codelockchange, candemolish, canunlock = false;
        bool canmail = true;
        bool canmount, candismount = false;
        bool CH47attacked = true;
        bool CH47killed = true;
        bool codeenter = false;
        bool cratedrop, cratehack, cratehackend, dispenserbonus = false;
        bool doorknocked = true;
        bool dismounted, groupgrant, grouprevoke, lootitem, npcposition, onvoice, onoven = false;
        bool playerkick = true;
        bool playerban = true;
        bool playerunban = true;
        bool playerdie = false;
        bool playerdisconnect = true;
        bool playerrespawn, playerrespawned, playersleep, playersleepend, playerspawn ,playerspectate, playerspectateend, playerviolation, pluginloaded, pluginunloaded = false;
        bool playerconnect = true;
        bool lootplayer, lootentity, mounted = false;
        bool rconnection = true;
        bool rconcommand = true;
        bool serversave, shopcomplete, signupdate, servermessage, usernameupdate, usergrant, userrevoke, wounded = false;
        public string BotToken;
        public ulong ChannelID;
        //bool entitykill = false;

#endregion

        private bool ConfigChanged;
		private void Init()
        {
            LoadVariables();
            UnsubscribeMeSir();
        }

#region CONFIG

        protected override void LoadDefaultConfig()
        {
            LoadVariables();
        }

        private void LoadVariables()
        {
            Prefix = Convert.ToString(GetConfig("Chat Settings", "Prefix", "[NTD] :"));                       // CHAT PLUGIN PREFIX
            PrefixColor = Convert.ToString(GetConfig("Chat Settings", "PrefixColor", "#42d7f4"));                // CHAT PLUGIN PREFIX COLOR
            ChatColor = Convert.ToString(GetConfig("Chat Settings", "ChatColor", "#b7f5ff"));                    // CHAT  COLOR
            SteamIDIcon = Convert.ToUInt64(GetConfig("Settings", "SteamIDIcon", "76561198044414155"));        // SteamID FOR PLUGIN ICON - STEAM PROFILE CREATED FOR THIS PLUGIN / NOT YET /           
            BotToken = Convert.ToString(GetConfig("Discord Settings", "BotToken", "0"));
            ChannelID = Convert.ToUInt64(GetConfig("Discord Settings", "ChannelID", "0"));
            WebHook = Convert.ToBoolean(GetConfig("Discord Webhook", "Use WebHook via DicordMessages plugin dependency", false));
            WebHookURL = Convert.ToString(GetConfig("Discord Webhook", "URL from your Discord channel", ""));

//PLAYER CONNECT/SPAWN/SLEEP
            playerspawn = Convert.ToBoolean(GetConfig("NOTIFY -=- PLAYER -=- CONNECT/SPAWN/SLEEP", "Player Spawn", false));
            playerrespawn = Convert.ToBoolean(GetConfig("NOTIFY -=- PLAYER -=- CONNECT/SPAWN/SLEEP", "Player Respawn", false));
            playerrespawned = Convert.ToBoolean(GetConfig("NOTIFY -=- PLAYER -=- CONNECT/SPAWN/SLEEP", "Player Respawned", false));
            playersleep = Convert.ToBoolean(GetConfig("NOTIFY -=- PLAYER -=- CONNECT/SPAWN/SLEEP", "Player Sleep Started", false));
            playersleepend = Convert.ToBoolean(GetConfig("NOTIFY -=- PLAYER -=- CONNECT/SPAWN/SLEEP", "Player Sleep Ended", false));
            playerdisconnect = Convert.ToBoolean(GetConfig("NOTIFY -=- PLAYER -=- CONNECT/SPAWN/SLEEP", "Player has Disconnected", true));            //true player  connect
            playerconnect = Convert.ToBoolean(GetConfig("NOTIFY -=- PLAYER -=- CONNECT/SPAWN/SLEEP", "Player has Connected", true));             //true player disconnect
//MESSAGES
            chatmessage = Convert.ToBoolean(GetConfig("NOTIFY -=- MESSAGES -=- PLAYER/SERVER", "On Player Chat message", false));
            servermessage = Convert.ToBoolean(GetConfig("NOTIFY -=- MESSAGES -=- PLAYER/SERVER", "On Server message", false));
//ADMIN ACTION
            playerkick = Convert.ToBoolean(GetConfig("NOTIFY -=- ADMIN", "Player Kicked", true));                           //true player kick
            playerban = Convert.ToBoolean(GetConfig("NOTIFY -=- ADMIN", "Player Banned", true));                            //true player ban
            playerunban = Convert.ToBoolean(GetConfig("NOTIFY -=- ADMIN", "Player Unbanned", true));                        //true player unban
            usergrant = Convert.ToBoolean(GetConfig("NOTIFY -=- ADMIN", "User granted permission", false));
            userrevoke = Convert.ToBoolean(GetConfig("NOTIFY -=- ADMIN", "User revoked permission", false));
            groupgrant = Convert.ToBoolean(GetConfig("NOTIFY -=- ADMIN", "Group granted permission", false));
            grouprevoke = Convert.ToBoolean(GetConfig("NOTIFY -=- ADMIN", "Group revoked permission", false));
//PLAYER SPECTATE
            playerspectate = Convert.ToBoolean(GetConfig("NOTIFY -=- SPECTATE", "Player Spectate", false));
            playerspectateend = Convert.ToBoolean(GetConfig("NOTIFY -=- SPECTATE", "Player Spectate End", false));
//PLAYER HACK VIOLATION            
            playerviolation = Convert.ToBoolean(GetConfig("NOTIFY -=- HACK VIOLATION", "Player Hack Violation", false));        
//PLAYER LOOT          
            lootplayer = Convert.ToBoolean(GetConfig("NOTIFY -=- PLAYER -=- LOOT", "Player Loot Player", false));
            lootentity = Convert.ToBoolean(GetConfig("NOTIFY -=- PLAYER -=- LOOT", "Player Loot Entity", false));
            lootitem = Convert.ToBoolean(GetConfig("NOTIFY -=- PLAYER -=- LOOT", "Player is looting item", false));
//PLAYER HEALTH/KILL/DEMOLISH        
            playerdie = Convert.ToBoolean(GetConfig("NOTIFY -=- PLAYER -=- HEALTH/KILL/DEMOLISH", "Player Die", false));
            wounded = Convert.ToBoolean(GetConfig("NOTIFY -=- PLAYER -=- HEALTH/KILL/DEMOLISH", "Player wounded", false));
            //entitykill = Convert.ToBoolean(GetConfig("NOTIFY -=- PLAYER -=- HEALTH/KILL/DEMOLISH", "Killed entity", false));
            candemolish = Convert.ToBoolean(GetConfig("NOTIFY -=- PLAYER -=- HEALTH/KILL/DEMOLISH", "Player demolishing entity", false));
//PLAYER OPTIONS
            usernameupdate = Convert.ToBoolean(GetConfig("NOTIFY -=- PLAYER -=- ELSE", "Player updated name", false));
            onvoice = Convert.ToBoolean(GetConfig("NOTIFY -=- PLAYER -=- ELSE", "Player is speaking in a microphone", false));
//PLAYER /SHOP/BONUS (could be great for RolePlaying use)
            shopcomplete = Convert.ToBoolean(GetConfig("NOTIFY -=- SHOP -=- BONUS", "Player customer has complete a shop trade", false));
            addvendingoffer = Convert.ToBoolean(GetConfig("NOTIFY -=- SHOP -=- BONUS", "New sell offer added in VendingMachine", false));
            canmail = Convert.ToBoolean(GetConfig("NOTIFY -=- SHOP -=- BONUS", "a Player is accessing a mailbox", true));                   //true mailbox
            doorknocked = Convert.ToBoolean(GetConfig("NOTIFY -=- SHOP -=- BONUS", "a door has been knocked", true));                       //true knock
            onoven = Convert.ToBoolean(GetConfig("NOTIFY -=- SHOP -=- BONUS", "player start a oven", false));
            dispenserbonus = Convert.ToBoolean(GetConfig("NOTIFY -=- SHOP -=- BONUS", "player receive bonus item", false));
            signupdate = Convert.ToBoolean(GetConfig("NOTIFY -=- SHOP -=- BONUS", "player update a sign", false));
//PLAYER ACTIONS/ENTITY
            codelockchange = Convert.ToBoolean(GetConfig("NOTIFY -=- PLAYER -=- ACTIONS/ENTITY", "codelock change", false));
            canunlock = Convert.ToBoolean(GetConfig("NOTIFY -=- PLAYER -=- ACTIONS/ENTITY", "Player tries to unlock", false));
            codeenter = Convert.ToBoolean(GetConfig("PLAYER -=- ACTIONS/ENTITY", "code entered", false));
            canmount = Convert.ToBoolean(GetConfig("NOTIFY -=- PLAYER -=- ACTIONS/ENTITY", "Player is trying to mount", false));
            candismount = Convert.ToBoolean(GetConfig("NOTIFY -=- PLAYER -=- ACTIONS/ENTITY", "Player is trying to dismount", false));
            mounted = Convert.ToBoolean(GetConfig("NOTIFY -=- PLAYER -=- ACTIONS/ENTITY", "Players has mounted", false));
            dismounted = Convert.ToBoolean(GetConfig("NOTIFY -=- PLAYER -=- ACTIONS/ENTITY", "Player has dismounted", false));
// PLAYER FIGHT
            onattack = Convert.ToBoolean(GetConfig("NOTIFY -=- PLAYER -=- FIGHT", "Player is attacking", false));
//SERVEUR/PLUGINS
            pluginloaded = Convert.ToBoolean(GetConfig("NOTIFY -=- SERVER -=- PLUGIN", "Plugin Loaded", false));
            pluginunloaded = Convert.ToBoolean(GetConfig("NOTIFY -=- SERVER -=- PLUGIN", "Plugin Unloaded", false));
            serversave = Convert.ToBoolean(GetConfig("NOTIFY -=- SERVER -=- PLUGIN", "Server Save", false));
            rconcommand = Convert.ToBoolean(GetConfig("NOTIFY -=- SERVER -=- PLUGIN", "RCon Command", true));                      //true rcon com
            rconnection = Convert.ToBoolean(GetConfig("NOTIFY -=- SERVER -=- PLUGIN", "RCon Connection", true));                   //true rcon connect
//HELI/PLANE
            airdrop = Convert.ToBoolean(GetConfig("NOTIFY -=- PLANE/HELI", "airdrop", false));
            cratedrop = Convert.ToBoolean(GetConfig("NOTIFY -=- PLANE/HELI", "Hackable Crate Dropped", false));
            cratehack = Convert.ToBoolean(GetConfig("NOTIFY -=- PLANE/HELI", "Hack of Crate has started", false));
            cratehackend = Convert.ToBoolean(GetConfig("NOTIFY -=- PLANE/HELI", "Hack of Crate has ended", false));
            CH47attacked = Convert.ToBoolean(GetConfig("NOTIFY -=- PLANE/HELI", "CH47 is under attack", true));             //true CH47 attacked
            CH47killed = Convert.ToBoolean(GetConfig("NOTIFY -=- PLANE/HELI", "CH47 has been killed", true));               //true CH47 killed
//NPC / APC
            apchunt = Convert.ToBoolean(GetConfig("NOTIFY -=- BOTS -=- APC/NPC", "BRADLEY APC on hunt", false));               //true CH47 killed
//SPECIAL RAID/BIG WEAPONS
// EXTENDED
            extreceivedsnap = Convert.ToBoolean(GetConfig("NOTIFY EXTENDED -=- PLAYER -=- MISC & ROLEPLAY", "player received a snapshot", false));
            extnpcattack = Convert.ToBoolean(GetConfig("NOTIFY EXTENDED -=- BOTS -=- APC/NPC", "NPC is attacking entity", false));               
            extusesleepbag = Convert.ToBoolean(GetConfig("NOTIFY EXTENDED -=- PLAYER -=- MISC & ROLEPLAY", "NPC is attacking entity", false));               
            exthelispawned = Convert.ToBoolean(GetConfig("NOTIFY EXTENDED -=- HELI/PLANE -=- ", "Helicopter spawned", false));
            extusecar = Convert.ToBoolean(GetConfig("NOTIFY EXTENDED -=- VEHICLE -=- ", "Player using car", false));
            extchinookspawned = Convert.ToBoolean(GetConfig("NOTIFY EXTENDED -=- HELI/PLANE -=- ", "Chinook spawned", false));
// DANGEROUS TREASURES
            dangerousmessage = Convert.ToBoolean(GetConfig("NOTIFY DANGEROUS TREASURES -=- MESSAGE -=-", "DangerousTreasures message to player", false));
// HUMAN NPC
            //OVERFLOW npconenter = Convert.ToBoolean(GetConfig("NOTIFY HUMAN NPC -=- BOTS -=- ", "player approaching a HumanNPC", false));               
            //OVERFLOW npconuse = Convert.ToBoolean(GetConfig("NOTIFY HUMAN NPC -=- BOTS -=- ", "player approaching a HumanNPC", false));               
            // OVERFLOW    npcposition = Convert.ToBoolean(GetConfig("NOTIFY HUMAN NPC -=- BOTS -=- ", "HumanNPC reaches a waypoint and changes to an other", false));
// BONUS
            countonline = Convert.ToBoolean(GetConfig("NOTIFY BONUS -=- ONLINE PLAYERS REPORTER -=-", "Report online players count; refresh on players connections and every 15min", true));

            if (!ConfigChanged) return;
            SaveConfig();
            ConfigChanged = false;
        }

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                ConfigChanged = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                ConfigChanged = true;
            }
            return value;
        }

#endregion

    private void OnServerInitialized()
    {
        if (HooksExtended == false) {PrintWarning("HooksExtended.cs is needed for some functions. (https://umod.org/plugins/hooks-extended)");}
        if (DangerousTreasures == false) {PrintWarning("DangerousTreasures.cs is needed for some functions. (https://umod.org/plugins/dangerous-treasures)");}
        if (HumanNPC == false) {PrintWarning("HumanNPC.cs is needed for some functions. (https://umod.org/plugins/human-npc)");}
        if (DiscordMessages == false) {PrintWarning("DiscordMessages.cs is needed for some functions. (https://umod.org/plugins/discord-messages)");}

        if (countonline == true)
        {
            timer.Repeat(900, 0, () =>
            {
                var activcount = BasePlayer.activePlayerList.Count;
                if (activcount >= 1)
                {
                    string todiscord = $":family_wwgb:  --- PLAYER COUNT REPORT```css\n[ONLINE NOW] : {activcount} player(s)\n```";
                    NotifyDiscord(todiscord);  
                }
            });
        }
    }

#region MESSAGES

    protected override void LoadDefaultMessages()
    {
        lang.RegisterMessages(new Dictionary<string, string>
        {
            {"BetterChatMsg", ":lips: --- PLAYER {0} - BetterChat message```css\n{1}\n```"},
            {"ChatMsg", ":lips: --- {0} chat message```css\n{1}\n```"},
            {"OnGroupPermissionGrantedMsg", "```css\ngroup {0} - has been granted permission : {1}\n```"},
            {"OnGroupPermissionRevokedMsg", "```css\ngroup {0} - has been revoked permission : {1}\n```"},
            {"OnLootPlayerMsg", "```css\n[LOOT PvP] PLAYER {0} - STEAMID {1} - LOOTING : {2} - STEAMID {3}\n```"},
            {"OnLootEntityMsg", "```css\n[LOOT ENTITY] PLAYER {0} - STEAMID {1} - LOOTING : {2}\n```"},
            {"OnPlayerBannedMsg", ":no_pedestrians: --- BANNED PLAYER```css\nSTEAMID {0}: - PLAYER {1} - IP : {2} - REASON :{3}\n```"},
            {"OnPlayerUnbannedMsg", ":passport_control: --- UNBANNED PLAYER```css\nUNBANNED - STEAMID {0}: - PLAYER {1} - IP : {2}\n```"},
            {"OnPlayerDeathMsg", ":skull_crossbones: --- PLAYERDIE```css\nPLAYER {0} - STEAMID {1} - INFO : {2}\n```"},
            {"OnPlayerDisconnectedMsg", ":closed_book:  --- PLAYER DISCONNECTED```css\nPLAYER {0} - STEAMID {1} - disconnected - REASON : {2}\n```"},
            {"OnPlayerRespawnMsg", "```css\n[RESPAWN] - PLAYER {0} - STEAMID {1} - respawn\n```"},
            {"OnPlayerRespawnedMsg", "```css\n[RESPAWNED] - PLAYER {0} - STEAMID {1} - respawned\n```"},
            {"OnPlayerSleepMsg", ":zzz: --- PLAYER {0} - STEAMID {1} - is falling asleep"},
            {"OnPlayerSleepEndedMsg", "```css\n[RESPAWNED] - PLAYER {0} - STEAMID {1} - respawned\n```"},
            {"OnPlayerSpawnMsg", "```css\n[SPAWN] - PLAYER {0} - STEAMID {1} - spawn\n```"},
            {"OnPlayerSpectateMsg", ":eye: --- PLAYER {0} - STEAMID {1} - spectate start{2}"},
            {"OnPlayerSpectateEndMsg", ":eye: --- PLAYER {0} - STEAMID {1} - spectate end {2}"},
            {"OnPlayerViolationMsg", ":no_entry: --- HACK VIOLATION```css\nPLAYER {0} - STEAMID {1} - violation hack : {2}\n```"},
            {"OnPlayerConnectedMsg", ":green_book: --- PLAYER CONNECTED```css\n{0} - STEAMID {1} - has connected\n```"},
            {"OnPlayerKickedMsg", ":hockey: --- KICKED PLAYER```css\nSTEAMID {0}: - PLAYER {1} - REASON :{2}\n```"},
            {"OnPluginLoadedMsg", ":cyclone:   --- {0} - loaded"},
            {"OnPluginUnloadedMsg", ":cyclone:   --- {0} - unloaded"},
            {"OnServerSaveMsg", ":floppy_disk: --- SERVER IS SAVING."},
            {"OnServerMessageMsg", ":speech_balloon: --- {0}"},
            {"OnUserNameUpdatedMsg", "```css\nPLAYER : {0} - SteamID {1} - updated name to PLAYER : {2}\n```"},
            {"CanChangeCodeMsg", "```css\n{0} - STEAMID {1} - tries to changecodelock {2} - NEW CODE {3} - IS GUEST CODE : {4}\n```"},
            {"CanUnlockMsg", ":unlock: --- PLAYER {0} - STEAMID {1} - is trying to unlock"},
            {"OnCodeEnteredMsg", ":key: --- CODE ENTERED```css\nPLAYER {0} - SteamID {1} - has entered CODELOCK : {2}\n```"},
            {"CanBeWoundedMsg", "```css\n[WOUND TRY] - PLAYER {0} - STEAMID {1} - {2}\n```"},
            {"OnUserPermissionGrantedMsg", "```css\n[PERMISSION GRANTED] - STEAMID {0} - as been granted permission {1}\n```"},
            {"OnUserPermissionRevokedMsg", "```css\n[PERMISSION REVOKED] - STEAMID {0} - as been revoked permission {1}\n```"},
            {"CanMountEntityMsg", "```css\n[MOUNT TRY] - PLAYER {0} - STEAMID {1} - {2}\n```"},
            {"OnEntityMountedMsg", "```css\n[MOUNTED] - PLAYER {0} - STEAMID {1} - {2}\n```"},
            {"CanDismountEntity", "```css\n[DISMOUNT TRY] - PLAYER {0} - STEAMID {1} - {2}\n```"},
            {"OnEntityDismountedMsg", "```css\n[DISMOUNTED] - PLAYER {0} - STEAMID {1} - {2}\n```"},
            {"OnLootItemMsg", "```css\n[LOOT] - PLAYER {0} - STEAMID {1} - {2}\n```"},
            {"OnRconCommandMsg", "```css\n[RCON] command - IP : {0} - {1} - {2}\n```"},
            {"OnRconConnectionMsg", "```css\n[RCON] connected to - IP {0}\n```"},
            {"OnAddVendingOfferMsg", "```css\n[VENDINGMACHINE] {0} - new SellOrder added : {1}\n```"},
            {"OnShopCompleteTradeMsg", ":shopping_cart: --- PLAYER CUSTOMER : {0} - STEAMID {1} has complete a trade"},
            {"OnAirdropMsg", ":airplane: --- AIRDROP```css\nAIRDROP is on its way - PLANE : {0} - POSITION : {1}\n```"},
            {"OnCrateDroppedMsg", ":kaaba: --- Hackable Locked Crate Dropped"},
            {"OnCrateHackMsg", ":kaaba: --- Crate Hack has started"},
            {"OnCrateHackEndMsg", ":kaaba: --- Crate Hack has ended"},
            {"OnHelicopterAttackedMsg", ":helicopter: --- CH47 is under attack - HELI : {0}"},
            {"OnHelicopterKilledMsg", ":helicopter: --- CH47 has been killed - HELI : {0}"},
            {"OnBradleyApcHuntMsg", ":robot:  --- BRADLEY APC ON HUNT : {0}"},
            {"OnDoorKnockedMsg", ":door: --- PLAYER  {0} - has knocked here : {1}"},
            {"CanUseMailboxMsg", ":mailbox_closed: --- PLAYER {0} - is trying to acces mailbox {1}"},
            {"OnOvenToggleMsg", ":fire: --- [OVEN START] PLAYER {0}"},
            {"OnDispenserBonusMsg", ":trophy:  --- [BONUS] {0} - PLAYER {1} - ITEM {2}"},
            {"OnSignUpdatedMsg", ":frame_photo: --- [SIGN] {0} - PLAYER {1} - TEXT {2}"},
            {"OnPlayerAttackMsg", ":gun: --- PLAYER {0} launch an attack ! - INFO : {1}"},
            {"OnPlayerVoiceMsg", ":microphone2: --- PLAYER {0} is voice speaking !!!"},
            {"CanDemolishMsg", "ICONE --- [DEMOLISHING] - PLAYER {0} - {1} - OWNER IS {2}"},
            {"OnReceivedSnapshotMsg", ":camera_with_flash: --- [SNAPSHOT] received by - PLAYER {0}"},
            {"OnNPCAttackMsg", ":space_invader: --- [NPC] {0} - IS ATTACKING {1} - INFO {2}"},
            {"OnUseSleepingBagMsg", ":sleeping_accommodation: --- [SLEEPING BAG] {0} - PLAYER {1}"},
            {"OnHelicopterSpawnedMsg", ":helicopter: --- [HELICOPTER] {0}"},
            {"OnChinookSpawnedMsg", ":helicopter: --- [CHINOOK] SPAWNED {0}"},
            {"OnUseCarMsg", ":red_car: --- [CAR] {0} USED by - PLAYER {1}"},
            {"OnDangerousMessageMsg", ":volcano: --- ```html\n[DANGEROUS TRASURES] {0} - PLAYER {1}\n```"},

        }, this, "en");
    }

#endregion

#region UNSUBSCRIBE
        void UnsubscribeMeSir()
        {
            if (!playerspawn) Unsubscribe(nameof(OnPlayerSpawn));
            if (!playerrespawn) Unsubscribe(nameof(OnPlayerRespawn));
            if (!playerrespawned) Unsubscribe(nameof(OnPlayerRespawned));
            if (!playersleep) Unsubscribe(nameof(OnPlayerSleep));
            if (!playersleepend) Unsubscribe(nameof(OnPlayerSleepEnded));
            if (!playerdisconnect) Unsubscribe(nameof(OnPlayerDisconnected));
            if (!playerconnect) Unsubscribe(nameof(OnPlayerConnected));
            //MESSAGES
            if (!chatmessage && BetterChat != null && BetterChat.IsLoaded) Unsubscribe(nameof(OnPlayerChat));
            if (!chatmessage) Unsubscribe(nameof(OnBetterChat));
            if (!servermessage) Unsubscribe(nameof(OnServerMessage));
            //ADMIN ACTION
            if (!playerkick) Unsubscribe(nameof(OnPlayerKicked));
            if (!playerban) Unsubscribe(nameof(OnPlayerBanned));
            if (!playerunban) Unsubscribe(nameof(OnPlayerUnbanned));
            if (!usergrant) Unsubscribe(nameof(OnUserPermissionGranted));
            if (!userrevoke) Unsubscribe(nameof(OnUserPermissionRevoked));
            if (!groupgrant) Unsubscribe(nameof(OnGroupPermissionGranted));
            if (!grouprevoke) Unsubscribe(nameof(OnGroupPermissionRevoked));
            //PLAYER SPECTATE
            if (!playerspectate) Unsubscribe(nameof(OnPlayerSpectate));
            if (!playerspectateend) Unsubscribe(nameof(OnPlayerSpectateEnd));
            //PLAYER HACK VIOLATION            
            if (!playerviolation) Unsubscribe(nameof(OnPlayerViolation));
            //PLAYER LOOT 
            if (!lootplayer) Unsubscribe(nameof(OnLootPlayer));
            if (!lootentity) Unsubscribe(nameof(OnLootEntity));
            if (!lootitem) Unsubscribe(nameof(OnLootItem));
            //PLAYER HEALTH/KILL/DEMOLISH        
            if (!playerdie) Unsubscribe(nameof(OnPlayerDeath));
            if (!wounded) Unsubscribe(nameof(CanBeWounded));
            //if (!entitykill) Unsubscribe(nameof(CanBeWounded));
            if (!candemolish) Unsubscribe(nameof(CanDemolish));
            //PLAYER OPTIONS
            if (!usernameupdate) Unsubscribe(nameof(OnUserNameUpdated));
            if (!onvoice) Unsubscribe(nameof(OnPlayerVoice));
            //PLAYER /SHOP/BONUS (could be great for RolePlaying use)
            if (!shopcomplete) Unsubscribe(nameof(OnShopCompleteTrade));
            if (!addvendingoffer) Unsubscribe(nameof(OnAddVendingOffer));
            if (!canmail) Unsubscribe(nameof(CanUseMailbox));
            if (!doorknocked) Unsubscribe(nameof(OnDoorKnocked));
            if (!onoven) Unsubscribe(nameof(OnOvenToggle));
            if (!dispenserbonus) Unsubscribe(nameof(OnDispenserBonus));
            if (!signupdate) Unsubscribe(nameof(OnSignUpdated));
            //PLAYER ACTIONS/ENTITY
            if (!codelockchange) Unsubscribe(nameof(CanChangeCode));
            if (!canunlock) Unsubscribe(nameof(CanUnlock));
            if (!codeenter) Unsubscribe(nameof(OnCodeEntered));
            if (!canmount) Unsubscribe(nameof(CanMountEntity));
            if (!candismount) Unsubscribe(nameof(CanDismountEntity));
            if (!mounted) Unsubscribe(nameof(OnEntityMounted));
            if (!dismounted) Unsubscribe(nameof(OnEntityDismounted));
            // PLAYER FIGHT
            if (!onattack) Unsubscribe(nameof(OnPlayerAttack));
            //SERVEUR/PLUGINS
            if (!pluginloaded) Unsubscribe(nameof(OnPluginLoaded));
            if (!pluginunloaded) Unsubscribe(nameof(OnPluginUnloaded));
            if (!serversave) Unsubscribe(nameof(OnServerSave));
            if (!rconcommand) Unsubscribe(nameof(OnRconCommand));
            if (!rconnection) Unsubscribe(nameof(OnRconConnection));
            //HELI/PLANE
            if (!airdrop) Unsubscribe(nameof(OnAirdrop));
            if (!cratedrop) Unsubscribe(nameof(OnCrateDropped));
            if (!cratehack) Unsubscribe(nameof(OnCrateHack));
            if (!cratehackend) Unsubscribe(nameof(OnCrateHackEnd));
            if (!CH47attacked) Unsubscribe(nameof(OnHelicopterAttacked));
            if (!CH47killed) Unsubscribe(nameof(OnHelicopterKilled));
            //NPC / APC
            if (!apchunt) Unsubscribe(nameof(OnBradleyApcHunt));
            //SPECIAL RAID/BIG WEAPONS
            // EXTENDED
            if (!extreceivedsnap) Unsubscribe(nameof(OnReceivedSnapshot));
            if (!extnpcattack) Unsubscribe(nameof(OnNPCAttack));
            if (!extusesleepbag) Unsubscribe(nameof(OnUseSleepingBag));
            if (!exthelispawned) Unsubscribe(nameof(OnHelicopterSpawned));
            if (!extusecar) Unsubscribe(nameof(OnUseCar));
            if (!extchinookspawned) Unsubscribe(nameof(OnChinookSpawned));
            // DANGEROUS TREASURES
            if (!dangerousmessage) Unsubscribe(nameof(OnDangerousMessage));
        }
#endregion
        
#region WEBHOOK

void SendWithWebHook(string MessageText)
{
    if (String.IsNullOrEmpty(WebHookURL))
    {
        PrintWarning("Please set a WebHookURL");
        return;
    }
    DiscordMessages?.Call("API_SendTextMessage", WebHookURL, MessageText);
}

#endregion

#region DISCORD MESSAGE
        void SendMessage(string MessageText)
        {
            if (WebHook)
            {
                SendWithWebHook(MessageText);
                return;
            }

            string payloadJson = JsonConvert.SerializeObject(new DiscordPayload()
            {
                MessageText = MessageText
            });
            Dictionary<string, string> headers = new Dictionary<string, string>();
            if(BotToken.StartsWith("Bot "))
            {
                headers.Add("Authorization", BotToken);
            }
            else
            {
                headers.Add("Authorization", String.Format("Bot {0}", BotToken));
            }
            headers.Add("Content-Type", "application/json");

            string url = BaseURLTemplate.Replace("{{ChannelID}}", $"{ChannelID.ToString()}");
            webrequest.EnqueuePost(url, payloadJson, (code, response) => PostCallBack(code, response), this, headers);
        }

        void PostCallBack(int code, string response)
        {
            if(code != 200) PrintWarning(String.Format("Discord Api responded with {0}: {1}", code, response));
        }

        void NotifyDiscord(string todiscord)
        {
            if (queue.Contains(todiscord) == true)
            {
                if (debug) {Puts($"this message is already in the recent queue. sending cancelled.");}
                return;
            }
            queue.Add(todiscord);
            float count = queue.Count;
            if (discording == true)
            {
                count = count + 2;
                float format = count;
                if (debug == true) {Puts($"message will be send in {count} seconds");}
                timer.Once(count, () =>
                {
                    string time = DateTime.Now.ToShortTimeString();
                    string todisplay = $"{time} {todiscord}"; 
                    SendMessage(todisplay);
                    queue.Remove(todiscord);
                });
            }
            if (discording == false)
            {
                string time = DateTime.Now.ToShortTimeString();
                string todisplay = $"{time} {todiscord}"; 
                SendMessage(todisplay);
                queue.Remove(todiscord);
                discording = true;
                if (debug) {Puts($"a message has gone, discording is now -true");}
                timer.Once(2f, () =>
                {
                    discording = false;
                    if (debug) {Puts($"discording is now -false");}
                });
            }
        }

        class DiscordPayload
        {
            [JsonProperty("content")]
            public string MessageText { get; set; }
        }
#endregion

#region ON BETTERCHAT
        void OnBetterChat(Dictionary<string, object> dict)
        {
            if (chatmessage == false)
            {
                if (debug) {Puts($"BetterChat message IGNORED");}return;
            }
            var txt = (dict["Message"]);
            var iplayer = dict["Player"] as IPlayer;
            if (iplayer == null) return;
            var message = BetterChat.Call ("API_GetFormattedMessage", iplayer, txt, true);
            //var name = BetterChat?.Call ("API_GetFormattedUsername", iplayer);
            //string todiscord = $":lips: --- PLAYER {iplayer.Name} - BetterChat message```css\n{message}\n```";
            string todiscord = String.Format(lang.GetMessage("BetterChatMsg", this, null),iplayer.Name,message);
            NotifyDiscord(todiscord);   
        }
#endregion
#region ON PLAYER CHAT

        void OnPlayerChat(BasePlayer player, string message)
        {
            if (BetterChat == false)
            {
                if (chatmessage == false)
                {
                    if (debug) {Puts($"Chat message IGNORED");} return;
                }
                string playername = player.displayName;
                if (player.displayName.Length > 24) {playername = playername.Substring(0,24);}
                string messagelowered = message.ToLower();
                string todiscord = String.Format(lang.GetMessage("ChatMsg", this, null),playername,message);
                NotifyDiscord(todiscord);   
            }
        }

#endregion
        string playername;
        string GetPlayerName(BasePlayer player)
        {
            if (player == null){playername = "Unknown Player";}
            foreach (BasePlayer playeractiv in BasePlayer.activePlayerList.ToList())
                {
                    if (player == playeractiv)
                    {
                        playername = player.displayName;
                        if (player.displayName.Length > 24) {playername = playername.Substring(0,24);}
                        return(playername);
                    }
                }            
            return "Unknown";
        }

// *************************************************************************************************** HOOKS ****************

//************************************** PERMISSIONS *************** PERMISSIONS **************************************/

        void OnGroupPermissionGranted(string name, string perm)
        {
            string todiscord = String.Format(lang.GetMessage("OnGroupPermissionGrantedMsg", this, null),name,perm); NotifyDiscord(todiscord);
        }

        void OnGroupPermissionRevoked(string name, string perm)
        {
            string todiscord = String.Format(lang.GetMessage("OnGroupPermissionRevokedMsg", this, null),name,perm); NotifyDiscord(todiscord);
        }

        void OnLootPlayer(BasePlayer player, BasePlayer target)
        {
            string name = GetPlayerName(player); string targeted = GetPlayerName(target); string todiscord = String.Format(lang.GetMessage("OnLootPlayerMsg", this, null),name,player.UserIDString,targeted,target.UserIDString); NotifyDiscord(todiscord);
        }

        void OnLootEntity(BasePlayer player, BaseEntity entity)
        {
            string name = GetPlayerName(player); string todiscord = String.Format(lang.GetMessage("OnLootEntityMsg", this, null),name,player.UserIDString,entity.ToString()); NotifyDiscord(todiscord); 
        }

        void OnPlayerBanned(string name, ulong id, string address, string reason)
        {
            string todiscord = String.Format(lang.GetMessage("OnPlayerBannedMsg", this, null),id.ToString(),name,address,reason); NotifyDiscord(todiscord); 
        }

        void OnPlayerUnbanned(string name, ulong id, string address)
        {
            string todiscord = String.Format(lang.GetMessage("OnPlayerUnbannedMsg", this, null),id.ToString(),name,address); NotifyDiscord(todiscord);         
        }

        void OnPlayerDeath(BasePlayer player, HitInfo info)
        {
            string name = GetPlayerName(player);
            string todiscord = String.Format(lang.GetMessage("OnPlayerDeathMsg", this, null),name,player.UserIDString,info); NotifyDiscord(todiscord);   
        }

        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            string name = GetPlayerName(player); string todiscord = String.Format(lang.GetMessage("OnPlayerDisconnectedMsg", this, null),name,player.UserIDString,reason); NotifyDiscord(todiscord);  
        }

        void OnPlayerRespawn(BasePlayer player)
        {
            string name = GetPlayerName(player); string todiscord = String.Format(lang.GetMessage("OnPlayerRespawnMsg", this, null),name,player.UserIDString); NotifyDiscord(todiscord);  
        }

        void OnPlayerRespawned(BasePlayer player)
        {
            string name = GetPlayerName(player); string todiscord = String.Format(lang.GetMessage("OnPlayerRespawnedMsg", this, null),name,player.UserIDString); NotifyDiscord(todiscord);  
        }

        void OnPlayerSleep(BasePlayer player)
        {
            string name = GetPlayerName(player); string todiscord = String.Format(lang.GetMessage("OnPlayerSleepMsg", this, null),name,player.UserIDString); NotifyDiscord(todiscord);  
        }

        void OnPlayerSleepEnded(BasePlayer player)
        {
            string name = GetPlayerName(player); string todiscord = String.Format(lang.GetMessage("OnPlayerSleepEndedMsg", this, null),name,player.UserIDString); NotifyDiscord(todiscord);  
        }

        void OnPlayerSpawn(BasePlayer player)
        {
            string name = GetPlayerName(player); string todiscord = String.Format(lang.GetMessage("OnPlayerSpawnMsg", this, null),name,player.UserIDString); NotifyDiscord(todiscord);  
        }

        void OnPlayerSpectate(BasePlayer player, string spectateFilter)
        {
            string name = GetPlayerName(player); string todiscord = String.Format(lang.GetMessage("OnPlayerSpectateMsg", this, null),name,player.UserIDString,spectateFilter); NotifyDiscord(todiscord);  
        }

        void OnPlayerSpectateEnd(BasePlayer player, string spectateFilter)
        {
            string name = GetPlayerName(player); string todiscord = String.Format(lang.GetMessage("OnPlayerSpectateEndMsg", this, null),name,player.UserIDString,spectateFilter); NotifyDiscord(todiscord);  
        }

//***************************** ADMIN ****************** ADMIN ************************** ADMIN ************************/

        void OnPlayerViolation(BasePlayer player, AntiHackType type, float amount)
        {
            string name = GetPlayerName(player); string todiscord = String.Format(lang.GetMessage("OnPlayerViolationMsg", this, null),name,player.UserIDString,type.ToString()); NotifyDiscord(todiscord);  
        }

        void OnPlayerConnected(BasePlayer player)
        {
            string name = GetPlayerName(player); string todiscord = String.Format(lang.GetMessage("OnPlayerConnectedMsg", this, null),name,player.UserIDString); NotifyDiscord(todiscord); 
        }

        void OnPlayerKicked(BasePlayer player, string reason)
        {
            string name = GetPlayerName(player); string todiscord = String.Format(lang.GetMessage("OnPlayerKickedMsg", this, null),player.UserIDString,name,reason); NotifyDiscord(todiscord); 
        }

        void OnPluginLoaded(Plugin name)
        {
            string todiscord = String.Format(lang.GetMessage("OnPluginLoadedMsg", this, null),name); NotifyDiscord(todiscord); 
        }

        void OnPluginUnloaded(Plugin name)
        {
            string todiscord = String.Format(lang.GetMessage("OnPluginUnloadedMsg", this, null),name); NotifyDiscord(todiscord); 
        }

//***************************** MESSAGES ************** MESSAGES ************************* MESSAGES *************/

        void OnServerSave()
        {
            string todiscord = lang.GetMessage("OnServerSaveMsg", this, null); NotifyDiscord(todiscord); 
        }

        void OnServerMessage(string message, string name, string color, ulong id)
        {
            string todiscord = String.Format(lang.GetMessage("OnServerMessageMsg", this, null),message); NotifyDiscord(todiscord); 
        }

        void OnUserNameUpdated(string id, string oldName, string newName)
        {
            string todiscord = String.Format(lang.GetMessage("OnUserNameUpdatedMsg", this, null),oldName,id,newName); NotifyDiscord(todiscord); 
        }

//***************************** LOCK *********************/

        void CanChangeCode(CodeLock codeLock, BasePlayer player, string newCode, bool isGuestCode)
        {
            string name = GetPlayerName(player); string todiscord = String.Format(lang.GetMessage("CanChangeCodeMsg", this, null),name,player.UserIDString,codeLock.code,newCode,isGuestCode.ToString()); NotifyDiscord(todiscord); 
        }

        void CanUnlock(BasePlayer player, BaseLock baseLock)
        {
            string name = GetPlayerName(player);
            string todiscord = String.Format(lang.GetMessage("CanUnlockMsg", this, null),name,player.UserIDString); NotifyDiscord(todiscord); 
        }

        void OnCodeEntered(CodeLock codeLock, BasePlayer player, string code)
        {
            string name = GetPlayerName(player);
            string todiscord = String.Format(lang.GetMessage("OnCodeEnteredMsg", this, null),name,player.UserIDString,code);NotifyDiscord(todiscord); 
        }

        void CanBeWounded(BasePlayer player, HitInfo info)
        {
            string name = GetPlayerName(player);
            string todiscord = String.Format(lang.GetMessage("CanBeWoundedMsg", this, null),name,player.UserIDString,info); NotifyDiscord(todiscord); 
        }

//***************************** PERMISSION *********************/

        void OnUserPermissionGranted(string id, string perm)
        {
            string todiscord = String.Format(lang.GetMessage("OnUserPermissionGrantedMsg", this, null),id,perm); NotifyDiscord(todiscord); 
        }

        void OnUserPermissionRevoked(string id, string perm)
        {
            string todiscord = String.Format(lang.GetMessage("OnUserPermissionRevokedMsg", this, null),id,perm); NotifyDiscord(todiscord); 
        }

//*****************************  MOUNT DISMOUNT *********************/

        void CanMountEntity(BasePlayer player, BaseMountable entity)
        {
            string name = GetPlayerName(player);
            string todiscord = String.Format(lang.GetMessage("CanMountEntityMsg", this, null),name,player.UserIDString,entity.ToString()); NotifyDiscord(todiscord); 
        }

        void OnEntityMounted(BaseMountable entity, BasePlayer player)
        {
            string name = GetPlayerName(player);
            string todiscord = String.Format(lang.GetMessage("OnEntityMountedMsg", this, null),name,player.UserIDString,entity.ToString()); NotifyDiscord(todiscord); 
        }

        void CanDismountEntity(BasePlayer player, BaseMountable entity)
        {
            string name = GetPlayerName(player);
            string todiscord = String.Format(lang.GetMessage("CanDismountEntityMsg", this, null),name,player.UserIDString,entity.ToString()); NotifyDiscord(todiscord); 
        }

        void OnEntityDismounted(BaseMountable entity, BasePlayer player)
        {
            string name = GetPlayerName(player);
            string todiscord = String.Format(lang.GetMessage("OnEntityDismountedMsg", this, null),name,player.UserIDString,entity.ToString()); NotifyDiscord(todiscord); 
        }
//***************************** LOOT *********************/

        void OnLootItem(BasePlayer player, Item item)
        {
            string name = GetPlayerName(player);
            string todiscord = String.Format(lang.GetMessage("OnLootItemMsg", this, null),name,player.UserIDString,item.ToString()); NotifyDiscord(todiscord); 
        }

//***************************** RCON *********************/

        void OnRconCommand(IPAddress ip, string command, string[] args)
        {
            string todiscord = String.Format(lang.GetMessage("OnRconCommandMsg", this, null),ip.ToString(),command,args.ToString()); NotifyDiscord(todiscord); 
        }

        void OnRconConnection(IPAddress ip)
        {
            string todiscord = String.Format(lang.GetMessage("OnRconConnectionMsg", this, null),ip.ToString()); NotifyDiscord(todiscord); 
        }

//***************************** VENDING MACHINE & SHOP *********************/

        void OnAddVendingOffer(VendingMachine machine, ProtoBuf.VendingMachine.SellOrder sellOrder)
        {
            string todiscord = String.Format(lang.GetMessage("OnAddVendingOfferMsg", this, null),machine.ToString(),sellOrder.ToString()); NotifyDiscord(todiscord);
        }

        void OnShopCompleteTrade(ShopFront shop, BasePlayer customer)
        {
            string name = GetPlayerName(customer);
            string todiscord = String.Format(lang.GetMessage("OnShopCompleteTradeMsg", this, null),name,customer.UserIDString); NotifyDiscord(todiscord); 
        }
        
//***************************** PLANE / HELI *********************/

        void OnAirdrop(CargoPlane plane, Vector3 dropPosition)
        {
            string todiscord = String.Format(lang.GetMessage("OnAirdropMsg", this, null),plane.ToString(),dropPosition.ToString()); NotifyDiscord(todiscord); 
        }

        void OnCrateDropped(HackableLockedCrate crate)
        {
            string todiscord = lang.GetMessage("OnCrateDroppedMsg", this, null); NotifyDiscord(todiscord); 
        }

        void OnCrateHack(HackableLockedCrate crate)
        {
            string todiscord = lang.GetMessage("OnCrateHackMsg", this, null); NotifyDiscord(todiscord); 
        }

        void OnCrateHackEnd(HackableLockedCrate crate)
        {
            string todiscord = lang.GetMessage("OnCrateHackEndMsg", this, null); NotifyDiscord(todiscord); 
        }
        void OnHelicopterAttacked(CH47HelicopterAIController heli)
        {
            string todiscord = String.Format(lang.GetMessage("OnHelicopterAttackedMsg", this, null),heli.ToString()); NotifyDiscord(todiscord);
        }

        void OnHelicopterKilled(CH47HelicopterAIController heli)
        {
            string todiscord = String.Format(lang.GetMessage("OnHelicopterKilledMsg", this, null),heli.ToString()); NotifyDiscord(todiscord);
        }

        void OnBradleyApcHunt(BradleyAPC apc)
        {
            string todiscord = String.Format(lang.GetMessage("OnBradleyApcHuntMsg", this, null),apc.ToString()); NotifyDiscord(todiscord);
        }

//***************************** ROLEPPLAY USE *********************/

        void OnDoorKnocked(Door door, BasePlayer player)
        {
            string name = GetPlayerName(player);
            string todiscord = String.Format(lang.GetMessage("OnDoorKnockedMsg", this, null),name,door.ToString()); NotifyDiscord(todiscord);
        }

        void CanUseMailbox(BasePlayer player, Mailbox mailbox)
        {
            string name = GetPlayerName(player);
            string todiscord = String.Format(lang.GetMessage("CanUseMailboxMsg", this, null),name,mailbox.ToString()); NotifyDiscord(todiscord);
        }

        void OnOvenToggle(BaseOven oven, BasePlayer player)
        {
            string name = GetPlayerName(player);
            string todiscord = String.Format(lang.GetMessage("OnOvenToggleMsg", this, null),name); NotifyDiscord(todiscord);
        }

        void OnDispenserBonus(ResourceDispenser dispenser, BasePlayer player, Item item)
        {
            string name = GetPlayerName(player);
            string todiscord = String.Format(lang.GetMessage("OnDispenserBonusMsg", this, null),dispenser,name,item); NotifyDiscord(todiscord);
        }

        void OnSignUpdated(Signage sign, BasePlayer player, string text)
        {
            string name = GetPlayerName(player);
            string todiscord = String.Format(lang.GetMessage("OnSignUpdatedMsg", this, null),sign,name,text); NotifyDiscord(todiscord);
        }

        void OnPlayerAttack(BasePlayer attacker, HitInfo info)
        {
            string name = GetPlayerName(attacker);
            string todiscord = String.Format(lang.GetMessage("OnPlayerAttackMsg", this, null),name,info.ToString()); NotifyDiscord(todiscord);
        }

        void OnPlayerVoice(BasePlayer player, Byte[] data)
        {
            string name = GetPlayerName(player);
            string todiscord = String.Format(lang.GetMessage("OnPlayerVoiceMsg", this, null),name); NotifyDiscord(todiscord);
        }

/*
        void OnEntityKill(BaseNetworkable entity) //forcemment trop trop trop de choses, a voir a filtrer
        {
            if (entitykill == false) {if (debug == true) {Puts($"on entity kill IGNORED");} return;}    
            string todiscord = $"```css\n[KILL] - INFO : {entity.ToString()}```"; NotifyDiscord(todiscord);
        }
*/

/*
        void OnPlayerHealthChange(BasePlayer player, float oldValue, float newValue)
        {
            Puts("OnPlayerHealthChange works!");
            return null;
        }
*/

// RAID ORIENTED or not for moment

        void CanDemolish(BasePlayer player, BuildingBlock block, BuildingGrade.Enum grade)
        {
            string name = GetPlayerName(player);
            string todiscord = String.Format(lang.GetMessage("CanDemolishMsg", this, null),name,block,block.OwnerID); NotifyDiscord(todiscord);
        }

//********************************** HOOKS EXTENDED ******************************** */*/

        bool extreceivedsnap = false;
        bool extnpcattack = false;
        bool extusesleepbag = false;
        bool exthelispawned = false;
        bool extusecar = false;
        bool extchinookspawned = false;

        void OnReceivedSnapshot (BasePlayer player)
        {
            string name = GetPlayerName(player);
            string todiscord = String.Format(lang.GetMessage("OnReceivedSnapshotMsg", this, null),name); NotifyDiscord(todiscord);
        }

        void OnNPCAttack (BaseCombatEntity entity, NPCPlayer npc, HitInfo info)
        {
            string todiscord = String.Format(lang.GetMessage("OnNPCAttackMsg", this, null),npc,entity,info); NotifyDiscord(todiscord);
        }   

        void OnUseSleepingBag (BasePlayer source, SleepingBag bag)
        {
            string name = GetPlayerName(source);
            string todiscord = String.Format(lang.GetMessage("OnUseSleepingBagMsg", this, null),bag,name); NotifyDiscord(todiscord);
        }

        void OnHelicopterSpawned (BaseHelicopter helicopter)
        {
            string todiscord = String.Format(lang.GetMessage("OnHelicopterSpawnedMsg", this, null),helicopter); NotifyDiscord(todiscord);
        }

        void OnChinookSpawned (CH47Helicopter helicopter)
        {
            string todiscord = String.Format(lang.GetMessage("OnChinookSpawnedMsg", this, null),helicopter); NotifyDiscord(todiscord);
        }

        void OnUseCar (BasePlayer source, BasicCar target)
        {
            string todiscord = String.Format(lang.GetMessage("OnUseCarMsg", this, null),target,source); NotifyDiscord(todiscord);
        }

/********************************* DANEGROUS TREASURES *********** */

        bool dangerousmessage = false;

        void OnDangerousMessage(BasePlayer player, Vector3 eventPos, string message)
        {
            string todiscord = String.Format(lang.GetMessage("OnDangerousMessageMsg", this, null),message,player); NotifyDiscord(todiscord);
        }
    }
}


// --- End of file: NotifyToDiscord.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-flykick ---
// --- Original File Path: N/NoFlykick/NoFlykick.cs ---

using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("No Flykick", "August", "1.3.4")]
    [Description("Allows players with permission to bypass flyhack kicks.")]
    class NoFlykick : RustPlugin
    {
        #region Fields/Initialization
        private const string permUse = "noflykick.use";
        private const string permManage = "noflykick.manage";
        private bool IsEnabled;

        private void Init()
        {
            IsEnabled = true;

            permission.RegisterPermission(permUse, this);
            permission.RegisterPermission(permManage, this);
        }
        #endregion

        #region Localization
        protected override void LoadDefaultMessages()
        {
            // English
            lang.RegisterMessages(new Dictionary<string, string> {
                ["NoPerm"] = "Error: No Permission",
                ["Syntax"] = "Error: Syntax",
                ["Unknown Argument"] = " Error: Unknown Argument",

                ["Enabled"] = "Flyhack kick overrides are currently enabled for admins.",
                ["Disabled"] = "Flyhack kick overrides are currently disabled for admins.",

                ["NowEnabled"] = "Flyhack kick overrides are now enabled for admins",
                ["NowDisabled"] = "Flyhack kick overrides are now disabled for admins",

                ["Help Text"] = "Commands: \n" +
                                "/nokick stat/status - Prints whether or not flyhack kick override is enabled. \n" +
                                "/nokick toggle - Toggles flyhack kick override on or off."
        }, this);
        }
        #endregion

        #region Functions
        private void GetStatus(BasePlayer player)
        {
            if (IsEnabled)
            {
                player.ChatMessage(Lang("Enabled", player.UserIDString));
            }
            else
            {
                player.ChatMessage(Lang("Disabled", player.UserIDString));
            }
        }
        private void Toggle(BasePlayer player)
        {
            if (IsEnabled)
            {
                Unsubscribe(nameof(OnPlayerViolation));
                player.ChatMessage(Lang("NowDisabled", player.UserIDString));
            }
            else
            {
                Subscribe(nameof(OnPlayerViolation));
                player.ChatMessage(Lang("NowEnabled", player.UserIDString));
            }
            IsEnabled = !IsEnabled;
        }
        
        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);
        #endregion

        #region Commands
        [ChatCommand("nokick")]
        private void NoKickChatCommand(BasePlayer player, string cmd, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, permManage))
            {
                player.ChatMessage(Lang("NoPerm", player.UserIDString));
                return;
            }
            if (args.Length != 1)
            {
                player.ChatMessage(Lang("Syntax", player.UserIDString));
                return;
            }

            switch (args[0].ToLower())
            {
                case "stat":
                case "status":
                    GetStatus(player);                 
                    break;

                case "toggle":
                    Toggle(player);            
                    break;

                case "help":
                    player.ChatMessage(Lang("Help Text", player.UserIDString));
                    break;

                default:
                    player.ChatMessage(Lang("Unknown Argument", player.UserIDString));
                    break;
            }
        }
        #endregion

        #region Hooks
        object OnPlayerViolation(BasePlayer player, AntiHackType type, float amount)
        {
            if (type == AntiHackType.FlyHack)
            {
                if (permission.UserHasPermission(player.UserIDString, permUse))
                {
                    return true;
                }
            }
        return null;
        }
        #endregion
    }
}

// --- End of file: NoFlykick.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-teams ---
// --- Original File Path: N/NoTeams/NoTeams.cs ---

using Newtonsoft.Json;
using System.Collections.Generic;

namespace Oxide.Plugins
{
	[Info("No Teams", "OfficerJAKE", "1.0.4")]
	[Description("Players cannot create teams at all")]

	//Credits to Nivex for Language/Localization help

	public class NoTeams : RustPlugin
	{
		private const string BypassPerm = "noteams.bypass";
		
		#region Configuration

		private Configuration config;

		private class Configuration
		{
			[JsonProperty(PropertyName = "Settings")]
			public Settings settings = new Settings();

			public class Settings
			{
				[JsonProperty(PropertyName = "Enable Chat Reply")]
				public bool EnableChatReply = true;

				[JsonProperty(PropertyName = "Enable Console Logs")]
				public bool EnableConsoleLogs = true;
			}
		}

		protected override void LoadConfig()
		{
			base.LoadConfig();

			try
			{
				config = Config.ReadObject<Configuration>();				
			}
			catch
			{
			}

			if (config == null)
			{
				LoadDefaultConfig();
				Puts("Loaded Default Configuration!");
			}

			SaveConfig();
		}

		protected override void LoadDefaultConfig() => config = new Configuration();
		protected override void SaveConfig() => Config.WriteObject(config);

		#endregion

		#region Localization

		protected override void LoadDefaultMessages()
		{
			lang.RegisterMessages(new Dictionary<string, string>
			{
				["ChatPrefix"] = "<color=#359bf2>SOLO ONLY: </color>",
				["NoTeamsAllowed"] = "You are not able to create a team on this server."

			}, this);
		}

		#endregion Localization

		#region Hooks

		private void Init()
		{
			permission.RegisterPermission(BypassPerm, this);
		}
		
		private object OnTeamCreate(BasePlayer player)
		{
			if (!permission.UserHasPermission(player.UserIDString, BypassPerm))
			{
				if (config.settings.EnableConsoleLogs)
				{
					Puts("{0} [{1}] tried to make a team", player.displayName, player.userID);
				}
				if (config.settings.EnableChatReply)
				{
					SendChatMessage(player, "NoTeamsAllowed");				
				}
			return true;
			}
			return null;
		}

		private void SendChatMessage(BasePlayer player, string key)
		{
			string prefix = lang.GetMessage("ChatPrefix", this, player.UserIDString);
			string message = lang.GetMessage(key, this, player.UserIDString);

			SendReply(player, prefix + message);
		}

		#endregion
	}
}

// --- End of file: NoTeams.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-safe-zone-sleepers ---
// --- Original File Path: N/NoSafeZoneSleepers/NoSafeZoneSleepers.cs ---

﻿// Requires: ZoneManager



using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("No Safe Zone Sleepers", "NooBlet", "1.9")]
    [Description("Automaticly Creates a Zone to remove sleeping players from Outpost and Bandit Camp")]
    public class NoSafeZoneSleepers : CovalencePlugin
    {
        List<string> createdZones = new List<string>();
        int number = 0;

        #region Cached Variables

        private bool UseCustomZone = true;       
        private bool KillSleepers = false;
        private int TimeToKill = 60;
        private int OupostZoneRadius = 150;
        private int BanditCampZoneRadius = 150;
        private int OtherZones = 20;
        private bool UseMessages = false;         
        private string EnterMessage = "You are now Entering {0} a No Sleep Zone";
        private string ExitMessage = "You are now leaving {0} a No Sleep Zone";
        private string MessageColor = "#95a5a6";
        private List<object> CustomZones = new List<object> {
                "12345",
                "54321"
               
        };
        

        #endregion

        #region Config

        protected override void LoadDefaultConfig()
        {
            LogWarning("Creating a new configuration file");
        }
        private void LoadConfiguration()
        {
            CheckCfg<bool>("1 Use Custom SafeZone settings", ref UseCustomZone);
            CheckCfg<bool>("2 Kill Sleepers on disconnect", ref KillSleepers);
            CheckCfg<int>("3 Time to delay Kill", ref TimeToKill);
            CheckCfg<int>("4 Oupost Zone Radius", ref OupostZoneRadius);
            CheckCfg<int>("5 BanditCamp Zone Radius", ref BanditCampZoneRadius);
            CheckCfg<int>("6 Ranch and Fishing Village Zone Radius", ref OtherZones);
            CheckCfg<bool>("7 Use Enter and Leave Messages?", ref UseMessages);
            CheckCfg<string>("8 Enter Message", ref EnterMessage);
            CheckCfg<string>("9 Leave Message", ref ExitMessage);
            CheckCfg<string>("A Message Color", ref MessageColor);
            CheckCfg<List<object>>("Custom SafeZone Zoneid's", ref CustomZones);
            
            
            SaveConfig();
        }

        private void CheckCfg<T>(string Key, ref T var)
        {
            if (Config[Key] is T)
                var = (T)Config[Key];
            else
                Config[Key] = var;
        }



        #endregion config


        #region Hooks

        [PluginReference]
        private Plugin ZoneManager;


        private void OnServerInitialized()
        {
            LoadConfiguration();
            if (!UseCustomZone)
            {
                AddZones();
            }
                
        }

        void Unload()
        {
            ClearZones();
        }

        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            RemoveSleeper(player);
        }

        #endregion Hooks

        
        #region Methods

        bool isInPriv(BasePlayer player)
        {
            if(player == null) { return false; }
            var priv = player.GetBuildingPrivilege();
            if(priv == null) 
            { 
                return false; 
            } 
            else
            {
                player.SetPlayerFlag(BasePlayer.PlayerFlags.SafeZone, false) ;
                return true;
            }
        }

        string ZoneName(string message,string zonename)
        {
            string name = "";
            if (message.Contains("{0}")) { name = message.Replace("{0}", zonename); } else { name = message; }
            return name;
        }
        private bool CheckCustomZone(BasePlayer player)
        {
            foreach (var zid in CustomZones)
            {
                if (ZoneManager.Call<bool>("IsPlayerInZone", zid.ToString(), player))
                {
                    return true;
                }
            }

            return false;
        }

        private string GetPlayerZone(BasePlayer player)
        {
            string zone = "";
            foreach (var zid in CustomZones)
            {
                if (ZoneManager.Call<bool>("IsPlayerInZone", zid.ToString(), player))
                {
                    zone = zid.ToString();
                    return zone;
                }
            }
            return zone;
        }

        private void RemoveSleeper(BasePlayer sleeper)
        {
            if (!isInPriv(sleeper))
            {
                if (UseCustomZone)
                {

                    if (CheckCustomZone(sleeper))
                    {

                        if (KillSleepers)
                        {
                            float time = float.Parse(TimeToKill.ToString()) * 60;
                            timer.Once(time, () =>
                            {
                                if (!sleeper.IsConnected)
                                {
                                    Addflag(GetPlayerZone(sleeper), "killsleepers");
                                }
                            });
                        }
                        else
                        {
                            Addflag(GetPlayerZone(sleeper), "ejectsleepers");
                            sleeper.SetPlayerFlag(BasePlayer.PlayerFlags.SafeZone, false);
                        }

                    }
                    return;
                }
                else
                {
                    foreach (string zone in createdZones)
                    {
                        if (ZoneManager.Call<bool>("isPlayerInZone", zone, sleeper))
                        {


                            if (KillSleepers)
                            {
                                float time = float.Parse(TimeToKill.ToString()) * 60;
                                timer.Once(time, () =>
                                {
                                    if (!sleeper.IsConnected)
                                    {
                                        sleeper.Kill();
                                    }
                                });
                            }
                            else
                            {
                                Addflag(zone, "ejectsleepers");
                                sleeper.SetPlayerFlag(BasePlayer.PlayerFlags.SafeZone, false);
                            }

                        }
                    }
                }
            }
        }
       

        private void Addflag(string zone,string flag)
        {
            ZoneManager?.Call("AddFlag", zone, flag);
           

            timer.Once(10f, () =>
            {
               ZoneManager?.Call("RemoveFlag", zone, flag);
            });

        }

        private void ClearZones()
        {
            if (createdZones != null)
            {
                foreach (string zone in createdZones)
                {
                    ZoneManager?.Call("EraseZone", zone);
                    Puts($"{zone} has been Removed");
                }
            }
           
        }

        private void AddZones()
        {

            //  assets/bundled/prefabs/autospawn/monument/medium/stables_a.prefab
            // assets/bundled/prefabs/autospawn/monument/harbor/fishing_village_a.prefab
            // assets/bundled/prefabs/autospawn/monument/harbor/fishing_village_b.prefab
            //assets/bundled/prefabs/autospawn/monument/harbor/fishing_village_c.prefab
            

            foreach (var current in TerrainMeta.Path.Monuments)
            {
                if (current.name == "assets/bundled/prefabs/autospawn/monument/medium/compound.prefab" || current.name.Contains("assets/bundled/prefabs/autospawn/monument/medium/bandit_town.prefab")||current.name.Contains("fishing_village") || current.name.Contains("stables"))
                {
                    string[] messages = new string[4];
                    string name = "";
                    if (UseMessages)
                    {
                         messages = new string[8];
                    }
                    else
                    {
                         messages = new string[4];
                    }

                    if (current.displayPhrase.english.StartsWith("Bandit"))
                    {
                        name = "BanditCamp";
                    }
                    if (current.displayPhrase.english.StartsWith("Outpost"))
                    {
                        name = "OutPost";
                    }
                    if (current.displayPhrase.english.StartsWith("Ranch"))
                    {
                        name = "Ranch";
                    }
                    if (current.displayPhrase.english.StartsWith("Fishing Village"))
                    {
                        name = "Fishing Village";
                    }
                    if (current.displayPhrase.english.StartsWith("Large Fishing Village"))
                    {
                        name = "Large Fishing Village";
                    }

                    string zoneId = $"{name}.{number}";
                    string friendlyname = name;
                    string ID = zoneId;

                    
                    messages[0] = "name";
                    messages[1] = friendlyname;
                    //messages[2] = "ejectsleepers";
                    //messages[3] = "true";
                    messages[2] = "radius";
                    if (name == "OutPost")
                    {
                        messages[3] = OupostZoneRadius.ToString();
                    }
                    else
                    {
                        messages[3] = BanditCampZoneRadius.ToString();
                    }
                    if (name == "Ranch" || name == "Fishing Village" || name == "Large Fishing Village")
                    {
                        messages[3] = OtherZones.ToString();
                    }

                    if (UseMessages)
                    {
                        string entermsg = $"<color=red>[NSZS]</color> :<color={MessageColor}> {ZoneName(EnterMessage, current.displayPhrase.english)} </color> ";
                        string leavemsg = $"<color=red>[NSZS]</color> :<color={MessageColor}> {ZoneName(ExitMessage,current.displayPhrase.english)} </color> ";

                        messages[4] = "enter_message";
                        messages[5] = entermsg;
                        messages[6] = "leave_message";
                        messages[7] = leavemsg;
                    }

                    ZoneManager?.CallHook("CreateOrUpdateZone", ID, messages, current.transform.position);
                    number++;
                    createdZones.Add(zoneId);
                    Puts($"{ID} has been created");
                }
            }
        }



        #endregion Methods


        //#region Debug Testing
        //private BasePlayer findPlayer(string name)
        //{
        //    BasePlayer target = BasePlayer.FindAwakeOrSleeping(name);

        //    return target;
        //}

        //[Command("sleep")]
        //private void sleepCommand(IPlayer iplayer, string command, string[] args)
        //{
        //    BasePlayer player = iplayer.Object as BasePlayer;
        //    player.StartSleeping();
        //}

        //#endregion Debug Testing
    }
}

// --- End of file: NoSafeZoneSleepers.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/npc-vending-map-marker ---
// --- Original File Path: N/NPCVendingMapMarker/NPCVendingMapMarker.cs ---

/*
    NPCVendingMapMarker - A Rust umod plugin to add in-game vending map markers to NPC's.
    Copyright (C) 2020 by Pinguin

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Oxide.Core.Configuration;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("NPC Vending Map Marker", "PinguinNordpol", "0.1.0")]
    [Description("Adds in-game vending map markers to NPC's")]
    class NPCVendingMapMarker : CovalencePlugin
    {
        #region Fields
        [PluginReference]
        private Plugin HumanNPC;

        // Configuration data
        private NPCVendingMapMarkerConfig config_data;
        // List of currently spawned vending map markers
        private Dictionary<ulong, VendingMachineMapMarker> map_markers = new Dictionary<ulong, VendingMachineMapMarker>();
        // Structure to hold temporary config values while adding a new vending map marker
        private struct TempVmm
        {
            public ulong request_uid;
            public string shop_name;
        }
        // List of current temporary vending map markers values
        private List<TempVmm> TempVmms = new List<TempVmm>();
        #endregion

        #region Plugin Config
        /*
         * Classes & functions to load / store plugin configuration
         */
        private class MarkerData
        {
            public string shop_name;
            public UnityEngine.Vector3 position;

            /*
             * Constructor
             */
            public MarkerData(string _shop_name, UnityEngine.Vector3 _position)
            {
                this.shop_name = _shop_name;
                this.position = _position;
            }
        }
        private class NPCVendingMapMarkerConfig
        {
            public Dictionary<ulong, MarkerData> configured_markers = new Dictionary<ulong, MarkerData>();
            public string currency_sign = "RP";
            public bool debug = false;
        }
        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(GetDefaultConfig(), true);
        }
        private NPCVendingMapMarkerConfig GetDefaultConfig()
        {
            return new NPCVendingMapMarkerConfig();
        }
        #endregion

        #region ServerRewards structures / functions
        private class SR_NPCData
        {
            public Dictionary<string, SR_NPCInfo> npcInfo = new Dictionary<string, SR_NPCInfo>();

            public class SR_NPCInfo
            {
                public string name;
                public float x, z;
                public bool useCustom, sellItems, sellKits, sellCommands, canTransfer, canSell, canExchange;
                public List<string> items = new List<string>();
                public List<string> kits = new List<string>();
                public List<string> commands = new List<string>();
            }
        }
        private class SR_RewardData
        {
            public Dictionary<string, SR_RewardItem> items = new Dictionary<string, SR_RewardItem>();
            public SortedDictionary<string, SR_RewardKit> kits = new SortedDictionary<string, SR_RewardKit>();
            public SortedDictionary<string, SR_RewardCommand> commands = new SortedDictionary<string, SR_RewardCommand>();

            public class SR_RewardItem : SR_Reward
            {
                public string shortname, customIcon;
                public int amount;
                public ulong skinId;
                public bool isBp;
                public SR_Category category;
            }

            public enum SR_Category { None, Weapon, Construction, Items, Resources, Attire, Tool, Medical, Food, Ammunition, Traps, Misc, Component, Electrical, Fun }

            public class SR_RewardKit : SR_Reward
            {
                public string kitName, description, iconName;
            }

            public class SR_RewardCommand : SR_Reward
            {
                public string description, iconName;
                public List<string> commands = new List<string>();
            }

            public class SR_Reward
            {
                public string displayName;
                public int cost;
                public int cooldown;
            }
        }

        // ServerRewards data
        private SR_NPCData sr_npcdata;
        private SR_RewardData sr_rewarddata;
        private bool sr_enabled = false;

        /*
         * Try to read ServerRewards data files
         */
        private void ReadServerRewardsData()
        {
            bool flag = true;
            DynamicConfigFile npc_data, reward_data;

            // Load data files
            this.LogDebug("Trying to read ServerRewards plugin data files");
            if (!Interface.Oxide.DataFileSystem.ExistsDatafile("ServerRewards/npc_data") || !Interface.Oxide.DataFileSystem.ExistsDatafile("ServerRewards/reward_data"))
            {
                // If data files do not exist, do not try to load them to prevent creating empty files
                this.sr_enabled = false;
                return;
            }
            npc_data = Interface.Oxide.DataFileSystem.GetFile("ServerRewards/npc_data");
            reward_data = Interface.Oxide.DataFileSystem.GetFile("ServerRewards/reward_data");

            // Try parsing the data files
            try
            {
                this.sr_rewarddata = reward_data.ReadObject<SR_RewardData>();
                this.LogDebug(string.Format("Successfully read {0} ServerRewards reward entrie(s)", this.sr_rewarddata.items.Count));
            }
            catch
            {
                this.LogDebug("No ServerRewards reward data found");
                this.sr_rewarddata = new SR_RewardData();
                flag = false;
            }
            try
            {
                this.sr_npcdata = npc_data.ReadObject<SR_NPCData>();
                this.LogDebug(string.Format("Successfully read {0} ServerRewards NPC entrie(s)", this.sr_npcdata.npcInfo.Count));
            }
            catch
            {
                this.LogDebug("No ServerRewards npc data found");
                this.sr_npcdata = new SR_NPCData();
                flag = false;
            }

            this.sr_enabled = flag;
        }

        /*
         * 
         */
        private string GetServerRewardsData(string _npc_id)
        {
            string ret = "";

            // Make sure we ServerRewards data files were loaded
            if (!this.sr_enabled) return "";
            
            // Check if the given NPC has a shop configured
            this.LogDebug("Checking ServerRewards data for shop items to display");
            if (!this.sr_npcdata.npcInfo.ContainsKey(_npc_id)) return "";

            // Check if shop has items to sell
            if (this.sr_npcdata.npcInfo[_npc_id].items.Count == 0) return "";

            // Parse and add items
            this.LogDebug("ServerRewards has shop items to display for current NPC");
            foreach (string reward_item in this.sr_npcdata.npcInfo[_npc_id].items)
            {
                if (this.sr_rewarddata.items.ContainsKey(reward_item))
                {
                    this.LogDebug(string.Format("Found values for item '{0}'. Adding", reward_item));
                    ret += string.Format("\r\n{0} {1} | {2} {3}", this.sr_rewarddata.items[reward_item].amount, this.sr_rewarddata.items[reward_item].displayName, this.sr_rewarddata.items[reward_item].cost, this.config_data.currency_sign);
                }
                else
                {
                    this.LogDebug(string.Format("Did not find values for item '{0}'", reward_item));
                }
            }

            if (ret != "") ret = "\r\n" + ret;
            return ret;
        }
        #endregion

        #region Umod Hooks
        /*
         * Initialize plugin once loaded
         */
        void Loaded()
        {
            if (this.HumanNPC == null)
            {
                // Can't do much without HumanNPC
                LogWarning("This plugin requires the HumanNPC plugin in order to be of any use!");
            }

            // Unsubscribe from OnUseNPC until we actually need it
            Unsubscribe("OnUseNPC");

            // Try reading ServerRewards plugin data
            this.ReadServerRewardsData();
        }

        /*
         * Remove all vending map markers on unload
         */
        void Unload()
        {
            this.ClearVendingMapMarkers();
        }

        /*
         * Load plugin config as soon as possible
         */
        void Init()
        {
            // Load plugin config
            this.config_data = Config.ReadObject<NPCVendingMapMarkerConfig>();
        }
        #endregion

        #region HumanNPC Hooks
        /*
         * Add vending map marker when configured NPCs respawn
         */
        void OnNPCRespawn(BasePlayer npc)
        {
            // If new NPC has a vending map marker configured, display it
            foreach(KeyValuePair<ulong, MarkerData> cm in this.config_data.configured_markers)
            {
                if(cm.Key == npc.userID)
                {
                    this.AddMapMarker(cm.Key, cm.Value);
                    break;
                }
            }
        }

        /*
         * Remove vending map marker when configured NPCs die
         */
        void OnKillNPC(BasePlayer npc, HitInfo hitinfo)
        {
            // If NPC had a vending map marker, remove it
            Dictionary<ulong, MarkerData>.KeyCollection keys = this.config_data.configured_markers.Keys;
            foreach (ulong key in keys.ToList())
            {
                if(key == npc.userID)
                {
                    this.RemoveMapMarker(key);
                    break;
                }
            }
        }

        /*
         * Add vending map marker to NPC
         */
        void OnUseNPC(BasePlayer npc, BasePlayer player)
        {
            // Check if we have a temporary configuration from current player
            this.LogDebug(string.Format("Looping over {0} temp_vmms", this.TempVmms.Count));
            for(int i = 0; i < this.TempVmms.Count; i++)
            {
                if(this.TempVmms[i].request_uid == player.userID) {
                    // Found a temporary configuration, let's finish it
                    this.LogDebug(string.Format("Found temp_vmm for user id {0}", player.userID));

                    // Make sure selected NPC is unconfigured
                    if (this.map_markers.ContainsKey(npc.userID)) {
                        this.ReplyToPlayer(player.IPlayer, string.Format(lang.GetMessage("NpcAlreadyHasMapMarker", this, player.IPlayer.Id), npc.userID));
                        return;
                    }

                    // Try to re-read ServerRewards data files
                    this.ReadServerRewardsData();

                    // Create new vending map marker for NPC and display it
                    this.LogDebug(string.Format("Creating new npcvmm for npc id {0} with name '{1}' at position {2}", npc.userID, this.TempVmms[i].shop_name, npc.transform.position.ToString()));
                    MarkerData marker_data = new MarkerData(this.TempVmms[i].shop_name, npc.transform.position);
                    if(!this.AddMapMarker(npc.userID, marker_data))
                    {
                        this.ReplyToPlayer(player.IPlayer, string.Format(lang.GetMessage("FailedSpawningMarker", this, player.IPlayer.Id)));
                        return;
                    }

                    // Add marker permanently to config
                    this.config_data.configured_markers.Add(npc.userID, marker_data);
                    Config.WriteObject<NPCVendingMapMarkerConfig>(this.config_data, true);

                    // Remove temporary config values
                    this.TempVmms.RemoveAt(i);
                    this.ReplyToPlayer(player.IPlayer, string.Format(lang.GetMessage("AddingMapMarkerSuccess", this, player.IPlayer.Id), npc.userID));
                }
            }

            // Unsubscribe from OnUseNPC hook if it is not needed anymore
            if(this.TempVmms.Count == 0) Unsubscribe("OnUseNPC");
        }
        #endregion

        #region Localization
        /*
         * Load default messages
         */
        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["UsageHelp"] = "NPCVendingMapMarker v{0} - A Rust umod plugin to add in-game vending map markers to NPC's.\r\n" +
                                      "Copyright(C) 2020 by Pinguin and released under GPLv3\r\n" +
                                      "\r\n" +
                                      "The following commands are available:\r\n" +
                                      "  npcvmm.add : Add a new NPC vending map marker.\r\n" +
                                      "  npcvmm.reset : Reset temporary NPC vending map marker data for current player.\r\n" +
                                      "  npcvmm.list : List all configured NPC vending map markers.\r\n" +
                                      "  npcvmm.del : Delete a single NPC vending map marker.\r\n" +
                                      "  npcvmm.clear : Delete all configured NPC vending map markers.\r\n" +
                                      "  npcvmm.refresh : Refresh all configured NPC vending map markers.\r\n" +
                                      "  npcvmm.debug : Toggle internal debugging on/off.\r\n" +
                                      "\r\n" +
                                      "For commands that take arguments, more help is available by executing them without any arguments.\r\n" +
                                      "\r\n" +
                                      "To be able to execute any NPCVendingMapMarker commands, you need to have the umod 'npcvendingmapmarker.admin' right assigned to your user.",
                ["DebugOn"] = "Switched debugging ON",
                ["DebugOff"] = "Switched debugging OFF",
                ["MissingShopName"] = "Usage: npcvmm.add <shop name>",
                ["UseNpcToAdd"] = "The next NPC you use will get a vending map marker with the name '{0}'",
                ["NpcAlreadyHasMapMarker"] = "The selected NPC '{0}' already has a vending map marker configured!",
                ["FailedSpawningMarker"] = "Unable to spawn vending map marker!",
                ["AddingMapMarkerSuccess"] = "Successfully added vending map marker to NPC '{0}'",
                ["AlreadyHaveTempVmm"] = "You can't add another marker until you finished adding the previous one! Use an NPC to add your previously configured map marker or do npcvmm.reset",
                ["ResetSuccessful"] = "Successfully removed temporary config values",
                ["ResetFailed"] = "No temporary config values available",
                ["TotalConfiguredMarkers"] = "You have a total of {0} NPC vending map marker(s) configured",
                ["MarkerDetails"] = "{0} @ {1} : '{2}'",
                ["MissingNpcId"] = "Usage: npcvmm.del <npc_id>",
                ["InvalidNpcId"] = "The given NPC ID is not valid!",
                ["NpcvmmRemoved"] = "The vending map marker for NPC id {0} was removed",
                ["UnknownNpcId"] = "No vending map marker for NPC id {0} configured",
                ["AllCleared"] = "All vending map markers cleared",
            }, this);
        }
        #endregion

        #region Console Commands
        /*
         * Print Usage info
         */
        [Command("npcvmm")]
        void CmdInfo(IPlayer player, string command, string[] args)
        {
            this.ReplyToPlayer(player, string.Format(lang.GetMessage("UsageHelp", this, player.Id), Version));
        }

        /*
         * Toggle debug on/off
         */
        [Command("npcvmm.debug"), Permission("npcvendingmapmarker.admin")]
        void CmdDebug(IPlayer player, string command, string[] args)
        {
            this.config_data.debug = !this.config_data.debug;
            if(this.config_data.debug) this.ReplyToPlayer(player, string.Format(lang.GetMessage("DebugOn", this, player.Id)));
            else this.ReplyToPlayer(player, string.Format(lang.GetMessage("DebugOff", this, player.Id)));
            Config.WriteObject<NPCVendingMapMarkerConfig>(this.config_data, true);
        }

        /*
         * Add a new NPC vending map marker
         */
        [Command("npcvmm.add"), Permission("npcvendingmapmarker.admin")]
        void CmdAdd(IPlayer player, string command, string[] args)
        {
            BasePlayer base_player = player.Object as BasePlayer;

            // Check command line args
            if (args.Length != 1)
            {
                this.ReplyToPlayer(player, string.Format(lang.GetMessage("MissingShopName", this, player.Id)));
                return;
            }

            // Make sure we don't already have temporary config values
            bool flag = false;
            foreach(TempVmm temp_vmm in this.TempVmms)
            {
                if(temp_vmm.request_uid == base_player.userID)
                {
                    this.ReplyToPlayer(player, string.Format(lang.GetMessage("AlreadyHaveTempVmm", this, player.Id), args[0]));
                    flag = true;
                    break;
                }
            }
            if(flag) return;

            // Create temporary config values
            TempVmm temp_vmm2;
            temp_vmm2.request_uid = base_player.userID;
            temp_vmm2.shop_name = args[0];
            this.TempVmms.Add(temp_vmm2);

            // Subscribe to OnUseNPC to receive npc id & position and tell player to use NPC now
            Subscribe("OnUseNPC");
            this.ReplyToPlayer(player, string.Format(lang.GetMessage("UseNpcToAdd", this, player.Id), args[0]));
        }

        /*
         * Remove temporary config values
         */
        [Command("npcvmm.reset"), Permission("npcvendingmapmarker.admin")]
        void CmdReset(IPlayer player, string command, string[] args)
        {
            BasePlayer base_player = player.Object as BasePlayer;
            bool flag = false;
            for(int i = 0; i < this.TempVmms.Count; i++)
            {
                if(this.TempVmms[i].request_uid == base_player.userID)
                {
                    this.TempVmms.RemoveAt(i);
                    flag = true;
                    break;
                }
            }
            if(flag) this.ReplyToPlayer(player, string.Format(lang.GetMessage("ResetSuccessful", this, player.Id)));
            else this.ReplyToPlayer(player, string.Format(lang.GetMessage("ResetFailed", this, player.Id)));
        }

        /*
         * List all configured vending map markers
         */
        [Command("npcvmm.list"), Permission("npcvendingmapmarker.admin")]
        void CmdList(IPlayer player, string command, string[] args)
        {
            this.ReplyToPlayer(player, string.Format(lang.GetMessage("TotalConfiguredMarkers", this, player.Id), this.config_data.configured_markers.Count));
            foreach (KeyValuePair<ulong, MarkerData> cm in this.config_data.configured_markers)
            {
                this.ReplyToPlayer(player, string.Format(lang.GetMessage("MarkerDetails", this, player.Id), cm.Key, cm.Value.position.ToString(), cm.Value.shop_name));
            }
        }

        /*
         * Delete a configured vending map markers
         */
        [Command("npcvmm.del"), Permission("npcvendingmapmarker.admin")]
        void CmdDel(IPlayer player, string command, string[] args)
        {
            BasePlayer base_player = player.Object as BasePlayer;
            ulong npc_id = 0;

            // Check command line args
            if (args.Length != 1)
            {
                this.ReplyToPlayer(player, string.Format(lang.GetMessage("MissingNpcId", this, player.Id)));
                return;
            }
            if (!ulong.TryParse(args[0], out npc_id))
            {
                this.ReplyToPlayer(player, string.Format(lang.GetMessage("InvalidNpcId", this, player.Id)));
                return;
            }

            // Check if we have a configuration for the given NPC id
            if(this.config_data.configured_markers.ContainsKey(npc_id))
            {
                // Remove npcvmm from config and despawn it
                this.config_data.configured_markers.Remove(npc_id);
                Config.WriteObject<NPCVendingMapMarkerConfig>(this.config_data, true);
                this.RemoveMapMarker(npc_id);
                this.ReplyToPlayer(player, string.Format(lang.GetMessage("NpcvmmRemoved", this, player.Id), npc_id));
            }
            else
            {
                this.ReplyToPlayer(player, string.Format(lang.GetMessage("UnknownNpcId", this, player.Id), npc_id));
            }
        }

        /*
         * Delete all configured vending map markers
         */
        [Command("npcvmm.clear"), Permission("npcvendingmapmarker.admin")]
        void CmdClear(IPlayer player, string command, string[] args)
        {
            this.ClearVendingMapMarkers();
            this.config_data.configured_markers.Clear();
            Config.WriteObject<NPCVendingMapMarkerConfig>(this.config_data, true);
            this.ReplyToPlayer(player, string.Format(lang.GetMessage("AllCleared", this, player.Id)));
        }

        /*
         * Refresh all configured vending map markers
         */
        [Command("npcvmm.refresh"), Permission("npcvendingmapmarker.admin")]
        void CmdRefresh(IPlayer player, string command, string[] args)
        {
            // Try to re-read ServerRewards data files
            this.ReadServerRewardsData();

            // Iterate over all spawned vmms and re-add them
            Dictionary<ulong, VendingMachineMapMarker>.KeyCollection keys = this.map_markers.Keys;
            this.LogDebug(string.Format("Refreshing {0} npcvmm(s)", keys.Count));
            foreach (ulong key in keys.ToList())
            {
                // Update / remove npcvmms
                if (this.config_data.configured_markers.ContainsKey(key))
                {
                    this.LogDebug(string.Format("Refreshing npcvmm for npc {0}", key));
                    this.AddMapMarker(key, this.config_data.configured_markers[key]);
                }
                else
                {
                    this.LogDebug(string.Format("Found unconfigured npcvmm for npc {0}. Removing", key));
                    this.RemoveMapMarker(key);
                }
            }
        }
        #endregion

        #region Helper Functions
        /*
         * Add a vending map marker to the map
         */
        private bool AddMapMarker(ulong _npc_id, MarkerData _marker_data)
        {
            this.LogDebug(string.Format("Spawning npcvmm for npc id {0} with name '{1}' at position {2}", _npc_id, _marker_data.shop_name, _marker_data.position.ToString()));

            // Make sure to remove an already existing npcvmm first
            this.RemoveMapMarker(_npc_id);

            // Create and configure new marker
            VendingMachineMapMarker vmmm = GameManager.server.CreateEntity("assets/prefabs/deployable/vendingmachine/vending_mapmarker.prefab", _marker_data.position, UnityEngine.Quaternion.identity, true) as VendingMachineMapMarker;
            if (vmmm == null)
            {
                this.LogDebug("CreateEntity failed!");
                return false;
            }
            vmmm.server_vendingMachine = null;

            // Set busy flag to have a green symbol
            vmmm.SetFlag(BaseEntity.Flags.Busy, true, false, true);

            // Set shop name and add shop info if available
            vmmm.markerShopName = _marker_data.shop_name;
            vmmm.markerShopName += this.GetServerRewardsData(_npc_id.ToString());

            // Spawn marker on map
            vmmm.Spawn();
            vmmm.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);

            // Add marker to our marker list
            this.map_markers.Add(_npc_id, vmmm);

            this.LogDebug(string.Format("Successfully spawned npcvmm for npc id {0} with name '{1}' at position {2}", _npc_id, _marker_data.shop_name, _marker_data.position.ToString()));
            return true;
        }

        /*
         * Remove a vending map marker from the map
         */
        private bool RemoveMapMarker(ulong _npc_id)
        {
            // Search map marker, kill it and remove it from list
            if(this.map_markers.ContainsKey(_npc_id))
            {
                this.LogDebug(string.Format("npcvmm for npc id {0} exists. Removing", _npc_id));
                this.map_markers[_npc_id].Kill(BaseNetworkable.DestroyMode.None);
                this.map_markers.Remove(_npc_id);
                return true;
            }
            return false;
        }

        /*
         * Check if a given NPC already has a configured vending map marker
         */
        private bool HasMapMarker(ulong _npc_id)
        {
            return this.map_markers.ContainsKey(_npc_id);
        }

        /*
         * Remove all added vending map markers
         */
        private void ClearVendingMapMarkers()
        {
            Dictionary<ulong, VendingMachineMapMarker>.ValueCollection markers = this.map_markers.Values;
            this.LogDebug(string.Format("Removing {0} npcvmm(s)", markers.Count));
            foreach (VendingMachineMapMarker map_marker in markers)
            {
                // Remove map marker from map and our marker list
                map_marker.Kill(BaseNetworkable.DestroyMode.None);
            }
            this.map_markers.Clear();
        }

        /*
         * Helper functions to send messages to players / console
         */
        private void ReplyToPlayer(IPlayer player, string msg)
        {
            player.Reply(msg);
        }
        private void Log(string msg)
        {
            Puts(msg);
        }
        private void LogDebug(string msg)
        {
            if(this.config_data.debug)
            {
                this.Log("DEBUG :: " + msg);
            }
        }
        #endregion
    }
}


// --- End of file: NPCVendingMapMarker.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/nuke-wipe ---
// --- Original File Path: N/NukeWipe/NukeWipe.cs ---

﻿using System.Collections.Generic;
using UnityEngine;
using System.Linq;
using Facepunch;
using System;

namespace Oxide.Plugins
{
    [Info("NukeWipe", "LaserHydra/Razor", "1.0.1", ResourceId = 0)]
    [Description("Wipe with style - and propably lag lol")]
    class NukeWipe : RustPlugin
    {
        #region Global Declaration

        Type[] DestroyableTypes = new Type[]
        {
            typeof(BuildingBlock),
            typeof(Barricade),
            typeof(BaseOven),
            typeof(Door),
            typeof(StorageContainer),
            typeof(BuildingPrivlidge),
            typeof(SimpleBuildingBlock),
            typeof(Signage),
            typeof(RepairBench),
            typeof(ResearchTable),
            typeof(DroppedItem),
            typeof(MiningQuarry),
            typeof(WaterCatcher),
            typeof(AutoTurret),
            typeof(BaseCombatEntity)
        };

        #endregion

        #region Plugin General

        ////////////////////////////////////////
        ///     Plugin Related Hooks
        ////////////////////////////////////////

        void Loaded()
        {
#if !RUST
            throw new NotSupportedException("This plugin or the version of this plugin does not support this game!");
#endif

            RegisterPerm("use");

            LoadMessages();
            LoadConfig();
        }

        ////////////////////////////////////////
        ///     Config & Message Loading
        ////////////////////////////////////////

        void LoadConfig()
        {
            SetConfig("Settings", "Time Until Explosion", 20f);

            SaveConfig();
        }

        void LoadMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"No Permission", "You don't have permission to use this command."},
                {"Nuke About To Happen", "<color=red>A NUCLEAR EXPLOSION IS ABOUT TO HAPPEN!</color>"},
                {"Nuke Done", "<color=red>A NUCLEAR EXPLOSION DESTROYED EVERYTHING AND KILLED EVERYBODY!</color>"}
            }, this);
        }

        protected override void LoadDefaultConfig() => PrintWarning("Generating new config file...");
        #endregion

        #region Commands

        [ChatCommand("nuke")]
        void cmdNuke(BasePlayer player)
        {
            if(!HasPerm(player.userID, "use"))
            {
                SendChatMessage(player, GetMsg("No Permission", player.userID));
                return;
            }

            BroadcastChat(GetMsg("Nuke About To Happen"));

            timer.Once(GetConfig(20f, "Settings", "Time Until Explosion"), () => Nuke());
        }

        #endregion

        #region Subject Related

        void Nuke()
        {
            //  Make all Players explode
            foreach (var player in BasePlayer.activePlayerList.ToList())
                Explode(player);

            //  Make all Sleepers explode
            foreach (var player in BasePlayer.activePlayerList.ToList())
                Explode(player);

            //  Get all Entities
            var entities = GetEntities(new Vector3(0, 0, 0), Convert.ToInt32(ConVar.Server.worldsize * 0.8f));
			
            //  Kill all Entities which should be wiped
            foreach (var building in (from entity in entities where ShouldBeDestroyed(entity) select entity))
			{
				if (building.ShortPrefabName.Contains("door.hinged.security") || building.ShortPrefabName.Contains("pumpjack-static") || building.ShortPrefabName.Contains("bbq.static")) continue;
					building.Kill(BaseNetworkable.DestroyMode.None);
			}
            Pool.FreeList(ref entities);

            //  Remove Corpses
            timer.Once(8.51f, () =>
            {
                //  Get all Corpses
                List<BaseCorpse> corpses = GetCorps(Vector3.zero, Convert.ToInt32(ConVar.Server.worldsize * 0.8f));

                //  Kill all Corpses
                foreach (var corpse in corpses)
                    corpse.Kill(BaseNetworkable.DestroyMode.None);

                Pool.FreeList(ref corpses);

                BroadcastChat(GetMsg("Nuke Done"));
            });
        }

        void Explode(BasePlayer player)
        {
            //  Initialize DamageTypeEntry - Explosion
            Rust.DamageTypeEntry dmg = new Rust.DamageTypeEntry();
			
            dmg.amount = 1;
            dmg.type = Rust.DamageType.Radiation;

            //  Fire Effects
            Effect.server.Run("assets/bundled/prefabs/fx/fire/fire_v2.prefab", player.transform.position, Vector3.up);
            Effect.server.Run("assets/bundled/prefabs/fx/fire/fire_v2.prefab", player.transform.position + new Vector3(1, 0, 1), Vector3.up);
            Effect.server.Run("assets/bundled/prefabs/fx/fire/fire_v2.prefab", player.transform.position + new Vector3(1, 0, 0), Vector3.up);
            Effect.server.Run("assets/bundled/prefabs/fx/fire/fire_v2.prefab", player.transform.position + new Vector3(0, 0, 1), Vector3.up);

            //  Explosion Effect
            Effect.server.Run("assets/prefabs/tools/c4/effects/c4_explosion.prefab", player.transform.position, Vector3.up, null, true);

            //  Initialize HitInfo
            HitInfo hitInfo = new HitInfo()
            {
                Initiator = null,
                WeaponPrefab = null
            };

            //  Add DamageTypeEntry to HitInfo
            hitInfo.damageTypes.Add(new List<Rust.DamageTypeEntry> { dmg });

            //  Hurt Player
			timer.Repeat(0.5f, 20, () => { if (player != null)
			{	
				player.UpdateRadiation(4000.0f);
				player.metabolism.radiation_level.value = 4000f;
				player.metabolism.radiation_poison.value = 4000f;
				player.SendNetworkUpdate();
				DamageUtil.RadiusDamage(null, null, player.transform.position, 5, 10, new List<Rust.DamageTypeEntry> { dmg }, 133376, true);
			} } );
			

            //  Hurt Player
            //  player.Hurt(hitInfo, true);
				timer.Once(7, () => { if (player != null) player.Hurt(1000); } );
        }

        bool ShouldBeDestroyed(BaseEntity entity) => DestroyableTypes.Contains(entity.GetType());

#endregion

        #region General Methods

        ////////////////////////////////////////
        ///     Game Related
        ////////////////////////////////////////

        List<BaseEntity> GetEntities(Vector3 position, int radius)
		{
            List<BaseEntity> list = new List<BaseEntity>();
			
            Vis.Entities<BaseEntity>(position, radius, list, LayerMask.GetMask("Construction", "Deployed", "Default", "Ragdoll"));
			
            return list;
        }

        List<BaseCorpse> GetCorps(Vector3 position, int radius)
		{
            List<BaseCorpse> list = new List<BaseCorpse>();
			
            Vis.Entities<BaseCorpse>(position, radius, list, LayerMask.GetMask("Construction", "Deployed", "Default", "Ragdoll"));
			
            return list;
        }

        ////////////////////////////////////////
        ///     Converting etc.
        ////////////////////////////////////////

        string ListToString<BaseEntity>(List<BaseEntity> list, int first, string seperator) => string.Join(seperator, (from item in list select item.ToString()).Skip(first).ToArray());

        List<T> CopyList<T>(List<T> list)
        {
            T[] copy = new T[list.Count];
            list.CopyTo(copy);

            return copy.ToList();
        }

        ////////////////////////////////////////
        ///     Config Related
        ////////////////////////////////////////

        void SetConfig(params object[] args)
        {
            List<string> stringArgs = (from arg in args select arg.ToString()).ToList();
            stringArgs.RemoveAt(args.Length - 1);

            if (Config.Get(stringArgs.ToArray()) == null) Config.Set(args);
        }

        T GetConfig<T>(T defaultVal, params object[] args)
        {
            List<string> stringArgs = (from arg in args select arg.ToString()).ToList();
            if (Config.Get(stringArgs.ToArray()) == null)
            {
                PrintError($"The plugin failed to read something from the config: {ListToString(stringArgs, 0, "/")}{Environment.NewLine}Please reload the plugin and see if this message is still showing. If so, please post this into the support thread of this plugin.");
                return defaultVal;
            }

            return (T)Convert.ChangeType(Config.Get(stringArgs.ToArray()), typeof(T));
        }

        ////////////////////////////////////////
        ///     Data Related
        ////////////////////////////////////////

        void LoadData<T>(ref T data, string filename = "?") => data = Core.Interface.Oxide.DataFileSystem.ReadObject<T>(filename == "?" ? this.Title : filename);

        void SaveData<T>(ref T data, string filename = "?") => Core.Interface.Oxide.DataFileSystem.WriteObject(filename == "?" ? this.Title : filename, data);

        ////////////////////////////////////////
        ///     Message Related
        ////////////////////////////////////////

        string GetMsg(string key, object userID = null) => lang.GetMessage(key, this, userID == null ? null : userID.ToString());

        ////////////////////////////////////////
        ///     Permission Related
        ////////////////////////////////////////

        void RegisterPerm(params string[] permArray)
        {
            string perm = ListToString(permArray.ToList(), 0, ".");

            permission.RegisterPermission($"{PermissionPrefix}.{perm}", this);
        }

        bool HasPerm(object uid, params string[] permArray)
        {
            string perm = ListToString(permArray.ToList(), 0, ".");

            return permission.UserHasPermission(uid.ToString(), $"{PermissionPrefix}.{perm}");
        }

        string PermissionPrefix
        {
            get
            {
                return this.Title.Replace(" ", "").ToLower();
            }
        }

        ////////////////////////////////////////
        ///     Chat Related
        ////////////////////////////////////////

        void BroadcastChat(string prefix, string msg = null) => PrintToChat(msg == null ? prefix : "<color=#C4FF00>" + prefix + "</color>: " + msg);

        void SendChatMessage(BasePlayer player, string prefix, string msg = null) => rust.SendChatMessage(player, msg == null ? prefix : "<color=#C4FF00>" + prefix + "</color>: " + msg);

        #endregion

        #region Dev / Debug

        /*
        void OnPlayerInput(BasePlayer player, InputState input)
        {
            if (input.WasJustPressed(BUTTON.USE))
                Puts(GetViewEntity(player)?.GetType()?.ToString() ?? "unknown");
        }


        BaseEntity GetViewEntity(BasePlayer player)
        {
            RaycastHit hit;

            if (Physics.Raycast(player.eyes.HeadRay(), out hit))
                return hit.GetEntity();

            return null;
        }*/

        #endregion
    }
}

// --- End of file: NukeWipe.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-coil-drain ---
// --- Original File Path: N/NoCoilDrain/NoCoilDrain.cs ---

using UnityEngine;
using System.Collections.Generic;
using System.Linq;
namespace Oxide.Plugins
{
    [Info("No Coil Drain", "Lincoln/Orange", "1.0.5")]
    [Description("Prevent Tesla coils from damaging themselves while in use.")]
    public class NoCoilDrain : RustPlugin
    {
        private const string PermissionNoCoilDrainUnlimited = "NoCoilDrain.unlimited";

        private void OnServerInitialized()
        {
            permission.RegisterPermission(PermissionNoCoilDrainUnlimited, this);

            var teslaCoils = new List<TeslaCoil>();
            Vis.Entities<TeslaCoil>(Vector3.zero, 10000f, teslaCoils);
            foreach (var entity in teslaCoils)
            {
                OnEntitySpawned(entity);
            }
        }

        private void OnEntitySpawned(TeslaCoil entity)
        {
            var ownerId = entity.OwnerID.ToString();
            if (permission.UserHasPermission(ownerId, PermissionNoCoilDrainUnlimited))
            {
                entity.maxDischargeSelfDamageSeconds = 0f;
            }
        }

        private void Unload()
        {
            var teslaCoils = new List<TeslaCoil>();
            Vis.Entities<TeslaCoil>(Vector3.zero, 10000f, teslaCoils);
            foreach (var entity in teslaCoils)
            {
                entity.maxDischargeSelfDamageSeconds = 120f;
            }
        }
    }
}


// --- End of file: NoCoilDrain.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-supply-signal ---
// --- Original File Path: N/NoSupplySignal/NoSupplySignal.cs ---

namespace Oxide.Plugins
{
    [Info("NoSupplySignal", "Wulf/lukespragg, Whispers88", 0.2, ResourceId = 2375)]
    [Description("Prevents supply drops triggering from supply signals")]

    class NoSupplySignal : CovalencePlugin
    {
        void OnExplosiveThrown(BasePlayer player, BaseEntity entity)
        {
            if (entity.name.Contains("signal")) entity.KillMessage();
        }
		
		void OnExplosiveDropped(BasePlayer player, BaseEntity entity, ThrownWeapon item)
		{
			if (entity.name.Contains("signal")) entity.KillMessage();
		}
    }
}

// --- End of file: NoSupplySignal.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-blood ---
// --- Original File Path: N/NoBlood/NoBlood.cs ---

using System;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("No Blood", "birthdates", "1.0.1")]
    [Description("Removes bleeding from rust")]
    public class NoBlood : RustPlugin
    {
        #region Variables
        private string Perm = "noblood.use";
        #endregion

        #region Hooks
        private void Init()
        {
            LoadConfig();
            permission.RegisterPermission(Perm, this);
        }

        void OnRunPlayerMetabolism(PlayerMetabolism metabolism)
        {
            if (metabolism.bleeding.value < 1) return;
            var p = metabolism.GetComponent<BasePlayer>();
            if (p == null || !permission.UserHasPermission(p.UserIDString, Perm)) return;
            metabolism.bleeding.value = 0;
        }
        #endregion
    }
}
//Generated with birthdates' Plugin Maker


// --- End of file: NoBlood.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/neutral-npcs ---
// --- Original File Path: N/NeutralNPCs/NeutralNPCs.cs ---

﻿using System.Collections.Generic;

using UnityEngine;

using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("Neutral NPCs", "0x89A", "2.0.1")]
    [Description("NPCs only attack if they are attacked first")]
    class NeutralNPCs : RustPlugin
    {
        private const string _usePerm = "neutralnpcs.use";

        private void Init()
        {
            permission.RegisterPermission(_usePerm, this);

            if (_config.onlyAnimals)
            {
                Unsubscribe(nameof(CanBradleyApcTarget));
                Unsubscribe(nameof(CanHelicopterTarget));
            }

            if (_config.onlySelected)
            {
                if (!_config.selected.Contains("bradleyapc"))
                {
                    Unsubscribe(nameof(CanBradleyApcTarget));
                }

                if (!_config.selected.Contains("patrolhelicopter"))
                {
                    Unsubscribe(nameof(CanHelicopterTarget));
                }
            }
        }

        private object OnNpcTarget(BaseCombatEntity entity, BasePlayer target)
        {
            if (_config.onlyAnimals)
            {
                return null;
            }
            
            return CanTarget(entity, target) ? null : (object)true;
        }

        private object OnNpcTarget(BaseAnimalNPC animal, BasePlayer target)
        {
            return CanTarget(animal, target) ? null : (object)true;
        }

        private bool CanBradleyApcTarget(BradleyAPC entity, BasePlayer target)
        {
            return CanTarget(entity, target);
        }

        private bool CanHelicopterTarget(PatrolHelicopterAI entity, BasePlayer target)
        {
            return CanTarget(entity.helicopterBase, target);
        }

        #region -Helpers-

        private bool CanTarget(BaseCombatEntity entity, BasePlayer target)
        {
            if (target.IsNpc)
            {
                return true;
            }

            if (!HasPermission(target))
            {
                return true;
            }
            
            if (_config.onlySelected && !_config.selected.Contains(entity.ShortPrefabName))
            {
                return false;
            }

            return entity.lastAttacker == target && !HasForgotten(entity.lastAttackedTime);
        }

        private bool HasForgotten(float lastAttackedTime) => Time.time - lastAttackedTime > _config.forgetTime;
        private bool HasPermission(BasePlayer player) => !_config.usePermission || permission.UserHasPermission(player.UserIDString, _usePerm);

        #endregion -Helpers-

        #region -Configuration-

        private Configuration _config;
        
        private class Configuration
        {
            [JsonProperty("Use Permission")]
            public bool usePermission = false;
            
            [JsonProperty(PropertyName = "Forget time")]
            public float forgetTime = 30f;

            [JsonProperty(PropertyName = "Only animals")]
            public bool onlyAnimals = true;

            [JsonProperty(PropertyName = "Affect only selected")]
            public bool onlySelected = false;

            [JsonProperty(PropertyName = "Selected entities")]
            public List<string> selected = new List<string>();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new System.Exception();
                SaveConfig();
            }
            catch
            {
                PrintWarning("Error loading config, using default values");
                LoadDefaultConfig();
            }
        }

        protected override void LoadDefaultConfig() => _config = new Configuration();

        protected override void SaveConfig() => Config.WriteObject(_config);

        #endregion
    }
}


// --- End of file: NeutralNPCs.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-give-gametip ---
// --- Original File Path: N/NoGiveGametip/NoGiveGametip.cs ---

using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("No Give Gametip", "noname", "1.0.1")]
    [Description("Clears the GameTip from using the giveid command.")]
    class NoGiveGametip : CovalencePlugin
    {
        private void OnServerCommand(ConsoleSystem.Arg arg)
        {
            if (arg.Connection == null)
                return;

            if (arg.cmd.Name == "giveid")
            {
                NextTick(() => (arg.Connection.player as BasePlayer).SendConsoleCommand("gametip.hidegametip"));
            }
        }
    }
}

// --- End of file: NoGiveGametip.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-weapon-drop ---
// --- Original File Path: N/NoWeaponDrop/NoWeaponDrop.cs ---

﻿using System;
using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("No Weapon Drop", "Fujikura", "1.2.0")]
	[Description("Prevents dropping of active weapon when players start to die")]
    class NoWeaponDrop : CovalencePlugin
    {
        [PluginReference]
		Plugin RestoreUponDeath;
		
		private const string permissionName = "noweapondrop.active";

		private bool Changed = false;
		private bool usePermission;
		
		private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }
		
		void LoadVariables()
        {
			usePermission = Convert.ToBoolean(GetConfig("Settings", "Use permissions", false));

            if (!Changed) return;
            SaveConfig();
            Changed = false;
        }
		
		protected override void LoadDefaultConfig()
        {
            Config.Clear();
            LoadVariables();
        }
		
		void Init()
		{
			LoadVariables();
			permission.RegisterPermission(permissionName, this);
		}
		
		object CanDropActiveItem(BasePlayer player)
		{
			if (player.IsNpc || (usePermission && !permission.UserHasPermission(player.UserIDString, permissionName)))
				return null;
			return false;
		}
	}
}


// --- End of file: NoWeaponDrop.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/npc-tp ---
// --- Original File Path: N/Npctp/Npctp.cs ---

// Requires: HumanNPC
// Requires: PathFinding

using System.Collections.Generic;
using System;
using Oxide.Core;
using Oxide.Core.Plugins;
using Oxide.Core.Configuration;
using UnityEngine;
using Newtonsoft.Json.Linq;
using System.Linq;
using Oxide.Core.Libraries.Covalence;
using static UnityEngine.Vector3;
using Oxide.Game.Rust.Cui;
using System.Globalization;
using System.Reflection;
using Facepunch;

namespace Oxide.Plugins
{
    [Info("Npctp", "Razor", "2.5.1")]
    [Description("Some NPC Controle Thanks Wulf and k1lly0u")]
    class Npctp : RustPlugin
    {
        #region Initialization

        [PluginReference]
        Plugin Spawns, Economics, ServerRewards, Vanish, HumanNPC, Jail;

        PlayerCooldown pcdData;
        NPCTPDATA npcData;
        private DynamicConfigFile PCDDATA;
        private DynamicConfigFile NPCDATA;
        private FieldInfo serverinput;
        private bool backroundimage;
        private string backroundimageurl;
        private static int cooldownTime = 3600;
        private static int auth = 2;
        private bool Changed;
        private float Cost = 0;	
        private float DoorLocX = 0;
        private float DoorLocY = 0;
        private float DoorLocZ = 0;
        private ulong DoorId = 0;
        private static bool useEconomics = false;
        private static bool useRewards = false;
        // private static bool useItem = false;		
        private static bool useJail = true;
		 private static bool useSpawns = true;
        private static bool AutoCloseDoors = true;
        private static int AutoCloseTime = 10;
        private static int SleepKillDamage = 10;
        private static bool DoorOpenMessage = true;
        private static bool FollowDead = true;
        private static bool UseGunToKill = true;
        private static bool SetOnFire = false;
        private static int OnFireTime = 10;
        private static int OnFireDamage = 10;
        private string NpcName = "<color=#ffff00>Npc</color> : ";
        private string IDNPC = "";
        private string msg = "";
        private string SpawnFiles = "";


        #region Localization       
        Dictionary<string, string> messages = new Dictionary<string, string>()
        {
            {"title", "<color=#ffff00>Npc</color> : "},
            {"cdTime", "You must wait another {0} minutes and some seconds before using me again" },
            {"noperm", "You do not have permissions to talk to me!" },
            {"notenabled", "Sorry i am not enabled!" },
            {"nomoney", "Sorry you need {0} to talk to me!" },
            {"charged", "Thanks i only took {0} from you!" },
            {"npcCommand", "I just ran a Command!" },
            {"npcadd", "Added npcID {0} to datafile and not enabled edit NpcTP_Data ." },
            {"npcadds", "Added npcID {0} with spawnfile {1} to datafile and enabled edit NpcTP_Data for more options." },
            {"npcerror", "error example /npctp_add <npcID> <spawnfile> or /npctcp_add <npcID>" },
            {"nopermcmd", "You do not have permissions to use this command!" },
            {"commandyesno", "This will cost you " },
            {"commandyesno1", " do you want to pay?" },
            {"notfound", "The npc was not found check npcID" },
            {"npchelp", "Error: use /npctp <npcID>" },
            {"DeadCmd", "Sorry you can not kill me again that fast. Wait {0} seconds." },
            {"doorerror", "error example /npctp_door <npcID>" },
            {"DoorIsOpen", "The Door is already open." },
            {"DoorNotFound", "The Door Was Not Found!" },
            {"DoorMessage", "I Just opened the door for you." },
            {"chargedItem", "Thanks i only took {0} from you!" }			

       };
        #endregion


        void Loaded()
        {
            LoadData();
            LoadVariables();
            RegisterPermissions();
        }
		
		private void OnServerInitialized()
        {
			CheckDependencies();
		}
		
		void Init()
		{
            serverinput = typeof(BasePlayer).GetField("serverInput", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
            PCDDATA = Interface.Oxide.DataFileSystem.GetFile("NpcTp/NpcTP_Player");
            NPCDATA = Interface.Oxide.DataFileSystem.GetFile("NpcTp/NpcTP_Data");
            lang.RegisterMessages(messages, this);
            Puts("Thanks for using NPCTP drop me a line if you need anything added.");		
	}

        void Unload()
        {
            foreach (BasePlayer current in BasePlayer.activePlayerList)
            {
                CuiHelper.DestroyUi(current, "Npctp");
            }
        }

        object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                Changed = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                Changed = true;
            }
            return value;
        }

        private void RegisterPermissions()
        {
            permission.RegisterPermission("npctp.admin", this);
            permission.RegisterPermission("npctp.default", this);
            foreach (var perm in npcData.NpcTP.Values)
            {
                if (!string.IsNullOrEmpty(perm.permission) && !permission.PermissionExists(perm.permission))
                    permission.RegisterPermission(perm.permission, this);
            }
        }

        private void CheckDependencies()
        {
            if (Economics == null)
                if (useEconomics)
                {
                    PrintWarning($"Economics could not be found! Disabling money feature");
                    useEconomics = false;
                }
            if (ServerRewards == null)
                if (useRewards)
                {
                    PrintWarning($"ServerRewards could not be found! Disabling RP feature");
                    useRewards = false;
                }
            if (Jail == null)
                if (useJail)
                {
                    PrintWarning($"Jail could not be found! Disabling Jail Protection");
                    useJail = false;
                }                
            if (Spawns == null)
            {
                PrintWarning($"Spawns Database could not be found you only can use random spawns for teleport npc!");
				useSpawns = false;
            }
        }

        void LoadVariables()
        {
            useEconomics = Convert.ToBoolean(GetConfig("SETTINGS", "useEconomics", false));
            useRewards = Convert.ToBoolean(GetConfig("SETTINGS", "useRewards", false));
			// useItem = Convert.ToBoolean(GetConfig("SETTINGS", "useItem", false));
            AutoCloseDoors = Convert.ToBoolean(GetConfig("SETTINGS", "AutoCloseDoors", true));
            DoorOpenMessage = Convert.ToBoolean(GetConfig("SETTINGS", "DoorOpenMessage", true));
            AutoCloseTime = Convert.ToInt32(GetConfig("SETTINGS", "AutoCloseTime", 15));
            SleepKillDamage = Convert.ToInt32(GetConfig("KillSleepPlayer", "SleepKillDamage", 10));
            UseGunToKill = Convert.ToBoolean(GetConfig("KillNoPerms", "UseGunToKill", true));
            FollowDead = Convert.ToBoolean(GetConfig("KillNoPerms", "NpcFollowUntellDead", false));
            SetOnFire = Convert.ToBoolean(GetConfig("KillNoPerms", "SetOnFire", false));
            OnFireTime = Convert.ToInt32(GetConfig("KillNoPerms", "OnFireTime", 10));
            OnFireDamage = Convert.ToInt32(GetConfig("KillNoPerms", "OnFireDamage", 10));

            if (Changed)
            {
                SaveConfig();
                Changed = false;
            }
        }

        protected override void LoadDefaultConfig()
        {
            Puts("Creating a new configuration file!");
            Config.Clear();
            LoadVariables();
        }
        #endregion
        #region Classes and Data Management    
        void SaveNpcTpData()
        {
            NPCDATA.WriteObject(npcData);
        }

        class NPCTPDATA
        {
            public Dictionary<string, NPCInfo> NpcTP = new Dictionary<string, NPCInfo>();

            public NPCTPDATA() { }
        }
        class NPCInfo
        {
            public string NpcName;
            public string SpawnFile;
            public int Cooldown;
            public bool CanUse;
            public bool useUI;
            public float Cost;
            public string permission;
            public bool useItem;			
            public bool UseCommand;			
            public bool useMessage;
            public string MessageNpc;
            public bool EnableDead;
            public bool DeadOnPlayer;
            public string DeadCmd;
            public string DeadArgs;
            public bool OpenDoor;
            public float DoorLocX;
            public float DoorLocY;
            public float DoorLocZ;
            public ulong DoorId;
            public bool NoPermKill;
            public bool KillSleep;
			public Dictionary<string, NPCcommands> Commands = new Dictionary<string, NPCcommands>();
			public Dictionary<string, NPCitems> Items = new Dictionary<string, NPCitems>();
        }

        class PlayerCooldown
        {
            public Dictionary<ulong, PCDInfo> pCooldown = new Dictionary<ulong, PCDInfo>();


            public PlayerCooldown() { }
        }
        class PCDInfo
        {

            public Dictionary<string, long> npcCooldowns = new Dictionary<string, long>();

            public PCDInfo() { }
            public PCDInfo(long cd)
            {
            }
        }
        class NPCcommands
        {
            public string Command;
            public string Arrangements;
			public bool OnPlayer;
        }
		class NPCitems
        {
            public string ItemShortName;
            public int Amount;
        }
        void SaveData()
        {
            PCDDATA.WriteObject(pcdData);
        }
        void LoadData()
        {
            try
            {
                pcdData = Interface.Oxide.DataFileSystem.ReadObject<PlayerCooldown>("NpcTp/NpcTP_Player");
            }
            catch
            {
                Puts("Couldn't load NPCTP data, creating new Playerfile");
                pcdData = new PlayerCooldown();
            }
            try
            {
                npcData = Interface.GetMod().DataFileSystem.ReadObject<NPCTPDATA>("NpcTp/NpcTP_Data");
            }
            catch
            {
                Puts("Couldn't load NPCTP data, creating new datafile");
                npcData = new NPCTPDATA();
            }
        }

        #endregion
        #region Cooldown Management       

        static double GrabCurrentTime() => DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds;

        #endregion
        #region npctp_door
        [ChatCommand("npctp_door")]
        void SetDoor(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.userID.ToString(), "npctp.admin"))
            {
                SendReply(player, string.Format(lang.GetMessage(NpcName, this) + lang.GetMessage("nopermcmd", this)));
                return;
            }
            if (args.Length <= 0)
            {
                SendReply(player, string.Format(lang.GetMessage(NpcName, this) + lang.GetMessage("doorerror", this, player.UserIDString)));
                return;
            }
            var n = npcData.NpcTP;
            var npcId = (args[0]);
            var input = serverinput.GetValue(player) as InputState;
            var currentRot = Quaternion.Euler(input.current.aimAngles) * Vector3.forward;
            Vector3 eyesAdjust = new Vector3(0f, 1.5f, 0f);
            var rayResult = CastRay(player.transform.position + eyesAdjust, currentRot);
            if (!n.ContainsKey(npcId))
            {
                SendReply(player, "There is no NpcID {0} is the id correct and /npctp_add in the datafile", npcId);
                return;
            }
            if (rayResult is BaseEntity)
            {
                var entity = rayResult as BaseEntity;
                var DoorId = entity.net.ID.Value;
                var DoorLocX = entity.transform.position.x;
                var DoorLocY = entity.transform.position.y;
                var DoorLocZ = entity.transform.position.z;
                if (entity.GetComponent<Door>())
                    npcData.NpcTP[npcId].DoorId = DoorId;
                npcData.NpcTP[npcId].DoorLocX = DoorLocX;
                npcData.NpcTP[npcId].DoorLocY = DoorLocY;
                npcData.NpcTP[npcId].DoorLocZ = DoorLocZ;
                npcData.NpcTP[npcId].OpenDoor = true;
                SaveNpcTpData();
                SendReply(player, "Door added to NPCID {0}", npcId);
                return;
            }
            SendReply(player, "This is not a door or invalid NpcID {0}", npcId);
        }
        #endregion
        #region ItemAmount
        private int GetAmount(BasePlayer player, string shortname)
        {
            List<Item> items1 = Pool.GetList<Item>();
            player.inventory.GetAllItems(items1);

            List<Item> items = items1.FindAll(x => x.info.shortname == shortname);
            int num = 0;
            foreach (Item item in items)
            {
                if (!item.IsBusy())
                {
                    num = num + item.amount;
                }
            }
            Pool.FreeUnmanaged(ref items1);

            return num;
        }
		
        private bool TakeResources(BasePlayer player, string shortname, int iAmount)
        {
            int num = TakeResourcesFrom(player, player.inventory.containerMain.itemList, shortname, iAmount);
            if (num < iAmount)
                num += TakeResourcesFrom(player, player.inventory.containerBelt.itemList, shortname, iAmount);
            if (num < iAmount)
                num += TakeResourcesFrom(player, player.inventory.containerWear.itemList, shortname, iAmount);
            if (num >= iAmount)
                return true;
            return false;
        }
        private int TakeResourcesFrom(BasePlayer player, List<Item> container, string shortname, int iAmount)
        {
            List<Item> collect = new List<Item>();
            List<Item> items = new List<Item>();
            int num = 0;
            foreach (Item item in container)
            {
                if (item.info.shortname == shortname)
                {
                    int num1 = iAmount - num;
                    if (num1 > 0)
                    {
                        if (item.amount <= num1)
                        {
                            if (item.amount <= num1)
                            {
                                num = num + item.amount;
                                items.Add(item);
                                if (collect != null)
                                    collect.Add(item);
                            }
                            if (num != iAmount)
                                continue;
                            break;
                        }
                        else
                        {
                            item.MarkDirty();
                            Item item1 = item;
                            item1.amount = item1.amount - num1;
                            num = num + num1;
                            Item item2 = ItemManager.CreateByName(shortname, 1);
                            item2.amount = num1;
                            item2.CollectedForCrafting(player);
                            if (collect != null)
                                collect.Add(item2);
                            break;
                        }
                    }
                }
            }
            foreach (Item item3 in items)
                item3.RemoveFromContainer();
            return num;
        }		
		
		
        #endregion
        #region Teleport
        object CastRay(Vector3 Pos, Vector3 Aim)
        {
            var hits = Physics.RaycastAll(Pos, Aim);
            float distance = 100;
            object target = null;

            foreach (var hit in hits)
            {
                if (hit.collider.GetComponentInParent<BaseEntity>() != null)
                {
                    if (hit.distance < distance)
                    {
                        distance = hit.distance;
                        target = hit.collider.GetComponentInParent<BaseEntity>();
                    }
                }
            }
            return target;
        }
        private object ProcessRay(RaycastHit hitInfo)
        {
            if (hitInfo.collider != null)
            {
                if (hitInfo.collider?.gameObject.layer == UnityEngine.LayerMask.NameToLayer("Water"))
                    return null;
                if (hitInfo.collider?.gameObject.layer == UnityEngine.LayerMask.NameToLayer("Prevent Building"))
                    return null;
                if (hitInfo.GetEntity() != null)
                {
                    return hitInfo.point.y;
                }
                if (hitInfo.collider?.name == "areaTrigger")
                    return null;
                if (hitInfo.collider?.GetComponentInParent<SphereCollider>() || hitInfo.collider?.GetComponentInParent<BoxCollider>())
                {
                    return hitInfo.collider.transform.position + new Vector3(0, -1, 0);
                }
            }
            return hitInfo.point.y;
        }
        RaycastHit RayPosition(Vector3 sourcePos)
        {
            RaycastHit hitInfo;
            Physics.Raycast(sourcePos, Vector3.down, out hitInfo);

            return hitInfo;
        }

        private void TeleportPlayerPosition1(BasePlayer player, Vector3 destination)
        {
            if (player.net?.connection != null)
                player.ClientRPCPlayer(null, player, "StartLoading");
            player.inventory.crafting.CancelAll();
            StartSleeping(player);
            player.MovePosition(destination);
            if (player.net?.connection != null)
                player.ClientRPCPlayer(null, player, "ForcePositionTo", destination);
            if (player.net?.connection != null)
                player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, true);
            player.UpdateNetworkGroup();
            player.SendNetworkUpdateImmediate(false);
            if (player.net?.connection == null) return;
            try { player.ClearEntityQueue(null); } catch { }
            player.SendFullSnapshot();
        }
        private void StartSleeping(BasePlayer player)
        {
            if (player.IsSleeping())
                return;
            player.SetPlayerFlag(BasePlayer.PlayerFlags.Sleeping, true);
            if (!BasePlayer.sleepingPlayerList.Contains(player))
                BasePlayer.sleepingPlayerList.Add(player);
            player.CancelInvoke("InventoryUpdate");
        }

        object GetRandomVector(Vector3 position, float max, bool failed = false)
        {
            var targetPos = UnityEngine.Random.insideUnitCircle * max;
            var sourcePos = new Vector3(position.x + targetPos.x, 300, position.z + targetPos.y);
            var hitInfo = RayPosition(sourcePos);
            var success = ProcessRay(hitInfo);
            if (success == null)
            {
                return GetRandomVector(position, max, true);
            }
            else if (success is Vector3)
            {
                return GetRandomVector(new Vector3(sourcePos.x, ((Vector3)success).y, sourcePos.y), max, true);
            }
            else
            {
                sourcePos.y = Mathf.Max((float)success, TerrainMeta.HeightMap.GetHeight(sourcePos));
                return sourcePos;
            }
        }
        #endregion	
        #region USENPC

        [ChatCommand("npctp_add")]
        void cmdNpcAdD(BasePlayer player, string command, string[] args)
        {
            var n = npcData.NpcTP;
            if (!permission.UserHasPermission(player.userID.ToString(), "npctp.admin"))
            {
                SendReply(player, string.Format(lang.GetMessage(NpcName, this) + lang.GetMessage("nopermcmd", this)));
                return;
            }
            if (args.Length == 2)
            {
                SpawnFiles = args[1];
            }

            var setup = new NPCInfo { Cost = Cost, CanUse = false, useUI = false, permission = "npctp.default", UseCommand = false, useItem = false, useMessage = false, MessageNpc = "none", EnableDead = false, DeadOnPlayer = false, DeadCmd = "jail.send", DeadArgs = "5", OpenDoor = false, DoorLocX = DoorLocX, DoorLocY = DoorLocY, DoorLocZ = DoorLocZ, DoorId = DoorId, NpcName = NpcName, NoPermKill = false, KillSleep = false };
            var setups = new NPCInfo { Cost = Cost, CanUse = true, useUI = false, SpawnFile = SpawnFiles, permission = "npctp.default", UseCommand = false, useItem = false, useMessage = false, MessageNpc = "none", EnableDead = false, DeadOnPlayer = false, DeadCmd = "jail.send", DeadArgs = "5", OpenDoor = false, DoorLocX = DoorLocX, DoorLocY = DoorLocY, DoorLocZ = DoorLocZ, DoorId = DoorId, NpcName = NpcName, NoPermKill = false, KillSleep = false };

            if (args.Length <= 0)
            {
                SendReply(player, string.Format(lang.GetMessage(NpcName, this) + lang.GetMessage("npcerror", this, player.UserIDString)));
                return;
            }

            IDNPC = (args[0]);

            if (args.Length == 1)
            {
                if (!n.ContainsKey(IDNPC))
                    n.Add(IDNPC, setup);
                SaveNpcTpData();
                SendReply(player, string.Format(lang.GetMessage(NpcName, this) + lang.GetMessage("npcadd", this, player.UserIDString), (string)(IDNPC)));
                return;
            }
            if (args.Length == 2)
            {
                if (!n.ContainsKey(IDNPC))
                    n.Add(IDNPC, setups);
                SaveNpcTpData();
                SendReply(player, string.Format(lang.GetMessage(NpcName, this) + lang.GetMessage("npcadds", this, player.UserIDString), (string)(IDNPC), (string)(SpawnFiles)));
                return;
            }
        }

        [ChatCommand("npctp")]
        void cmdChatNPCEdit(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.userID.ToString(), "npctp.admin"))
            {
                SendReply(player, string.Format(lang.GetMessage(NpcName, this) + lang.GetMessage("nopermcmd", this)));
                return;
            }
            if (args.Length <= 0)
            {
                SendReply(player, string.Format(lang.GetMessage(NpcName, this) + lang.GetMessage("npchelp", this, player.UserIDString)));
                return;
            }
            var n = npcData.NpcTP;
            string npcId = (args[0]);
            int newvalueint = 0;
            bool newbool = false;
            float newfloat = 0;
            string newvalue = "";

            if (args.Length == 1 && n.ContainsKey(npcId))
            {
                SendReply(player, "====== Settings ======");
                SendReply(player, "SpawnFile" + ": " + npcData.NpcTP[npcId].SpawnFile);
                SendReply(player, "Cooldown" + ": " + npcData.NpcTP[npcId].Cooldown);
                SendReply(player, "Cost" + ": " + npcData.NpcTP[npcId].Cost);
                SendReply(player, "CanUse" + ": " + npcData.NpcTP[npcId].CanUse);
                SendReply(player, "useUI" + ": " + npcData.NpcTP[npcId].useUI);
                SendReply(player, "permission" + ": " + npcData.NpcTP[npcId].permission);
                SendReply(player, "UseCommand" + ": " + npcData.NpcTP[npcId].UseCommand);
                SendReply(player, "useMessage" + ": " + npcData.NpcTP[npcId].useMessage);
                SendReply(player, "MessageNpc" + ": " + npcData.NpcTP[npcId].MessageNpc);
                SendReply(player, "EnableDead" + ": " + npcData.NpcTP[npcId].EnableDead);
                SendReply(player, "DeadOnPlayer" + ": " + npcData.NpcTP[npcId].DeadOnPlayer);
                SendReply(player, "DeadCmd" + ": " + npcData.NpcTP[npcId].DeadCmd);
                SendReply(player, "DeadArgs" + ": " + npcData.NpcTP[npcId].DeadArgs);
                SendReply(player, "OpenDoor" + ": " + npcData.NpcTP[npcId].OpenDoor);
                SendReply(player, "====== End Settings ======");
                SendReply(player, "To change /npctp" + " " + npcId + " " + "<setting>" + " " + "<NewValue>");
				SendReply(player, "To add command /npctp" + " " + npcId + " command " + "<command refrence>" + " then edit in datafile");
				SendReply(player, "To add items to use /npctp" + " " + npcId + " item " + "<item shortname>");

                return;
            }

            if (!n.ContainsKey(npcId))
            {
                SendReply(player, string.Format(lang.GetMessage("notfound", this)));
                return;
            }
            string change = (args[1]).ToLower();
            if (args.Length >= 3 && change == "cooldown")
            {
                newvalue = (args[2]);
                newvalueint = Convert.ToInt32(newvalue);
                npcData.NpcTP[npcId].Cooldown = newvalueint;
                SaveNpcTpData();
                SendReply(player, "Cooldown value changed to {0}", newvalueint);
                return;
            }
            if (args.Length >= 3 && change == "spawnfile")
            {
                newvalue = (args[2]);
                npcData.NpcTP[npcId].SpawnFile = newvalue;
                SaveNpcTpData();
                SendReply(player, "SpawnFile value changed to {0}", newvalue);
                return;
            }
            if (args.Length >= 3 && change == "permission")
            {
                newvalue = (args[2]);
                npcData.NpcTP[npcId].permission = newvalue;
                SaveNpcTpData();
                SendReply(player, "permission value changed to {0}", newvalue);
                return;
            }
            if (args.Length >= 3 && change == "messagenpc")
            {
                newvalue = (args[2]);
                npcData.NpcTP[npcId].MessageNpc = newvalue;
                SaveNpcTpData();
                SendReply(player, "MessageNpc value changed to {0}", newvalue);
                return;
            }
            if (args.Length >= 3 && change == "deadcmd")
            {
                newvalue = (args[2]);
                npcData.NpcTP[npcId].DeadCmd = newvalue;
                SaveNpcTpData();
                SendReply(player, "DeadCmd value changed to {0}", newvalue);
                return;
            }
            if (args.Length >= 3 && change == "deadargs")
            {
                newvalue = (args[2]);
                npcData.NpcTP[npcId].DeadArgs = newvalue;
                SaveNpcTpData();
                SendReply(player, "DeadArgs value changed to {0}", newvalue);
                return;
            }
            if (args.Length >= 3 && change == "canuse")
            {
                newvalue = (args[2]);
                if (newvalue == "true" || newvalue == "false")
                    newbool = Convert.ToBoolean(newvalue);
                npcData.NpcTP[npcId].CanUse = newbool;
                SaveNpcTpData();
                SendReply(player, "canUse value changed to {0}", newbool);
                return;
                {
                    SendReply(player, "{0} is not true or false try again", newbool);
                    return;
                }
            }
            if (args.Length >= 3 && change == "useui")
            {
                newvalue = (args[2]);
                if (newvalue == "true" || newvalue == "false")
                    newbool = Convert.ToBoolean(newvalue);
                npcData.NpcTP[npcId].useUI = newbool;
                SaveNpcTpData();
                SendReply(player, "useUI value changed to {0}", newbool);
                return;
                {
                    SendReply(player, "{0} is not true or false try again", newbool);
                    return;
                }
            }
            if (args.Length >= 3 && change == "usecommand")
            {
                newvalue = (args[2]);
                if (newvalue == "true" || newvalue == "false")
                    newbool = Convert.ToBoolean(newvalue);
                npcData.NpcTP[npcId].UseCommand = newbool;
                SaveNpcTpData();
                SendReply(player, "UseCommand value changed to {0}", newbool);
                return;
                {
                    SendReply(player, "{0} is not true or false try again", newbool);
                    return;
                }
            }

            if (args.Length >= 3 && change == "usemessage")
            {
                newvalue = (args[2]);
                if (newvalue == "true" || newvalue == "false")
                    newbool = Convert.ToBoolean(newvalue);
                npcData.NpcTP[npcId].useMessage = newbool;
                SaveNpcTpData();
                SendReply(player, "useMessage value changed to {0}", newbool);
                return;
                {
                    SendReply(player, "{0} is not true or false try again", newbool);
                    return;
                }
            }
            if (args.Length >= 3 && change == "enabledead")
            {
                newvalue = (args[2]);
                if (newvalue == "true" || newvalue == "false")
                    newbool = Convert.ToBoolean(newvalue);
                npcData.NpcTP[npcId].EnableDead = newbool;
                SaveNpcTpData();
                SendReply(player, "EnableDead value changed to {0}", newbool);
                return;
                {
                    SendReply(player, "{0} is not true or false try again", newbool);
                    return;
                }
            }
            if (args.Length >= 3 && change == "deadonplayer")
            {
                newvalue = (args[2]);
                if (newvalue == "true" || newvalue == "false")
                    newbool = Convert.ToBoolean(newvalue);
                npcData.NpcTP[npcId].DeadOnPlayer = newbool;
                SaveNpcTpData();
                SendReply(player, "DeadOnPlayer value changed to {0}", newbool);
                return;
                {
                    SendReply(player, "{0} is not true or false try again", newbool);
                    return;
                }
            }
            if (args.Length >= 3 && change == "opendoor")
            {
                newvalue = (args[2]);
                if (newvalue == "true" || newvalue == "false")
                    newbool = Convert.ToBoolean(newvalue);
                npcData.NpcTP[npcId].OpenDoor = newbool;
                SaveNpcTpData();
                SendReply(player, "OpenDoor value changed to {0}", newbool);
                return;
                {
                    SendReply(player, "{0} is not true or false try again", newbool);
                    return;
                }
            }
            if (args.Length >= 3 && change == "cost")
            {
                newvalue = (args[2]);
                newfloat = float.Parse(newvalue);
                npcData.NpcTP[npcId].Cost = newfloat;
                SaveNpcTpData();
                SendReply(player, "Cost value changed to {0}", newfloat);
                return;
            }
            if (args.Length >= 3 && change == "command")
            {
				newvalue = (args[2]);
				if (!npcData.NpcTP[npcId].Commands.ContainsKey(newvalue))
				{
                    npcData.NpcTP[npcId].Commands.Add(newvalue, new NPCcommands());
				    npcData.NpcTP[npcId].Commands[newvalue].Command = newvalue;
				    npcData.NpcTP[npcId].Commands[newvalue].OnPlayer = false;
				    npcData.NpcTP[npcId].Commands[newvalue].Arrangements = "";
				    SaveNpcTpData();
				    SendReply(player, "Command value added {0} edit the data file to set the command", newvalue);
				    return;
				}
                else if (npcData.NpcTP[npcId].Commands.ContainsKey(newvalue))
				{
					SendReply(player, "Command {0} Already there edit the datafile or try adding a new command name.", newvalue);
				    return;
				}
			}	
            if (args.Length >= 3 && change == "item")
            {
				newvalue = (args[2].ToLower());
				if (!npcData.NpcTP[npcId].Items.ContainsKey(newvalue))
				{
                    npcData.NpcTP[npcId].Items.Add(newvalue, new NPCitems());
				    npcData.NpcTP[npcId].Items[newvalue].ItemShortName = newvalue;
				    npcData.NpcTP[npcId].Items[newvalue].Amount = 1;
				    SaveNpcTpData();
				    SendReply(player, "Item value added {0} edit the data file to change amounts", newvalue);
				    return;
				}
                else if (npcData.NpcTP[npcId].Items.ContainsKey(newvalue))
				{
					SendReply(player, "Item {0} Already there edit the datafile to set amounts.", newvalue);
				    return;
				}				
            }			
        }

        void OnKillNPC(BasePlayer npc, HitInfo hinfo)
        {

            if (!npcData.NpcTP.ContainsKey(npc.UserIDString)) return; // Check if this NPC is registered
            var attacker = hinfo.Initiator as BasePlayer;
            if (attacker == null) return;

            var player = hinfo.Initiator.ToPlayer();
            ulong playerId = player.userID;
            string npcId = npc.UserIDString;
            var EnableDead = npcData.NpcTP[npcId].EnableDead;
            var DeadOnPlayer = npcData.NpcTP[npcId].DeadOnPlayer;
            string DeadCmd = npcData.NpcTP[npcId].DeadCmd;
            string DeadArgs = npcData.NpcTP[npcId].DeadArgs;
            string NpcName = npcData.NpcTP[npcId].NpcName;
            double timeStamp = GrabCurrentTime();
            var cooldownTime = npcData.NpcTP[npcId].Cooldown;
            if (!EnableDead) return;
            if (!pcdData.pCooldown.ContainsKey(playerId))
            {
                pcdData.pCooldown.Add(playerId, new PCDInfo());
                //SaveData();
            }
            if (pcdData.pCooldown[playerId].npcCooldowns.ContainsKey(npcId)) // Check if the player already has a cooldown for this NPC
            {
                var cdTime = pcdData.pCooldown[playerId].npcCooldowns[npcId]; // Get the cooldown time of the NPC
                if (cdTime > timeStamp)
                {
                    SendReply(player, string.Format(lang.GetMessage(NpcName, this) + lang.GetMessage("DeadCmd", this, player.UserIDString), (int)(cdTime - timeStamp)));
                    return;
                }
            }

            if (EnableDead)
                if (!DeadOnPlayer) // Check if this is command on player
                {
                    pcdData.pCooldown[playerId].npcCooldowns[npcId] = (long)timeStamp + cooldownTime; // Store the new cooldown in the players data under the specified NPC
                    SaveData();
                    rust.RunServerCommand($"{DeadCmd} {DeadArgs}");

                }

            if (DeadOnPlayer) // Check if this is command on player
            {
                pcdData.pCooldown[playerId].npcCooldowns[npcId] = (long)timeStamp + cooldownTime; // Store the new cooldown in the players data under the specified NPC
                SaveData();
                rust.RunServerCommand($"{DeadCmd} {playerId} {DeadArgs}");
            }
        }

        [ConsoleCommand("hardestcommandtoeverguessnpctp")]
        void cmdRun(ConsoleSystem.Arg arg)
        {
            if (arg.Player() == null)
			{
				return;
			}			
            var player = arg.Player();
            var npcId = arg.Args[1];
            string spawn = npcData.NpcTP[npcId].SpawnFile;
            var cooldownTime = npcData.NpcTP[npcId].Cooldown;
            var UseCommand = npcData.NpcTP[npcId].UseCommand;
            var useItem = npcData.NpcTP[npcId].useItem;
            ulong playerId = player.userID;
            var DoorId = npcData.NpcTP[npcId].DoorId;
            var doorcheck = Convert.ToString(DoorId);
            var OpenDoor = npcData.NpcTP[npcId].OpenDoor;
            var buyMoney1 = npcData.NpcTP[npcId].Cost;
            string NpcName = npcData.NpcTP[npcId].NpcName;
            var bad = "somthing is not right somewhere with the teleportation";
            var bad1 = "somthing is not right somewhere on command not on player";
            var bad2 = "somthing is not right somewhere on command on player";
            float max = TerrainMeta.Size.x / 2;
            var time = 20;
            double timeStamp = GrabCurrentTime();
            

            if (useEconomics)
            {
                double money = (double)Economics?.CallHook("Balance", player.userID.Get());
                if (money < buyMoney1)
                {
                    SendReply(player, string.Format(lang.GetMessage(NpcName, this) + lang.GetMessage("nomoney", this, player.UserIDString), (int)(buyMoney1)));
                    return;
                }

                if (money >= buyMoney1)
                {
                    money = money - buyMoney1;
                    Economics?.CallHook("SetBalance", player.userID.Get(), money);
                    if (buyMoney1 >= 1)
                    {
                        SendReply(player, string.Format(lang.GetMessage(NpcName, this) + lang.GetMessage("charged", this, player.UserIDString), (int)(buyMoney1)));
                    }
                }
            }

            if (useRewards)
            {
                var money = (int)ServerRewards.Call("CheckPoints", player.userID.Get());
                if (money < buyMoney1)
                {
                    SendReply(player, string.Format(lang.GetMessage(NpcName, this) + lang.GetMessage("nomoney", this, player.UserIDString), (int)(buyMoney1)));
                    return;
                }

                if (money >= buyMoney1)
                {
                    ServerRewards.Call("TakePoints", player.userID.Get(), (int)buyMoney1);
                    if (buyMoney1 >= 1)
                    {
                        SendReply(player, string.Format(lang.GetMessage(NpcName, this) + lang.GetMessage("charged", this, player.UserIDString), (int)(buyMoney1)));
                    }
                }
            }			

            if (useItem)
            {
				List<string> listitems = new List<string>();
			    string joinlist = "";
				listitems.Clear();
				bool fail = false;
				foreach (var totals in npcData.NpcTP[npcId].Items.Values.ToList())
				{
					var amount = GetAmount(player, totals.ItemShortName);
					if (amount < totals.Amount)
					{
					    fail = true;
						var definition = ItemManager.FindItemDefinition(totals.ItemShortName);	
						var item = definition.displayName.english;
						listitems.Add(totals.Amount - amount + " " + item + " ");
					}
                }
				
				if (fail)
			    {	
						joinlist = string.Join("", listitems);
						SendReply(player, "You are short {0}.", joinlist);
						return;						
					
				}
				
			
								
				foreach (var totals in npcData.NpcTP[npcId].Items.Values.ToList())
				{
					var amount = GetAmount(player, totals.ItemShortName);					
					if (amount >= totals.Amount)
					{
						TakeResources(player, totals.ItemShortName, totals.Amount);
						var definition = ItemManager.FindItemDefinition(totals.ItemShortName);	
						var item = definition.displayName.english;
						listitems.Add(totals.Amount + " " + item + ", ");
                    }
                }
						joinlist = string.Join("", listitems);
						SendReply(player, string.Format(lang.GetMessage(NpcName, this) + lang.GetMessage("chargedItem", this, player.UserIDString), joinlist));
            }						
			
            if (Spawns != null)
            {
                pcdData.pCooldown[playerId].npcCooldowns[npcId] = (long)timeStamp + cooldownTime; // Store the new cooldown in the players data under the specified NPC
                SaveData();
                object success = null;
                if (useSpawns && spawn != "random" || Spawns != null)
                success = Spawns.Call("GetRandomSpawn", spawn);
                if (spawn == "random")
                success = GetRandomVector(new Vector3(0, 0, 0), max);
                if (success is Vector3) // Check if the returned type is Vector3
                {
                    TeleportPlayerPosition1(player, (Vector3)success);
                }
                else PrintError((string)bad); // Otherwise print the error message to console so server owners know there is a problem
            }

            if (UseCommand == true)
            {
                pcdData.pCooldown[playerId].npcCooldowns[npcId] = (long)timeStamp + cooldownTime;
                SaveData();

				foreach (var command in npcData.NpcTP[npcId].Commands.Values.ToList())
				{
					if (command.OnPlayer == true)
					{
					if (command.Command.StartsWith("chat.say"))				
						player.SendConsoleCommand($"{command.Command} {command.Arrangements}");
						else rust.RunServerCommand($"{command.Command} {player.userID} {command.Arrangements}");
						
					}
					if (command.OnPlayer == false)
					rust.RunServerCommand($"{command.Command} {command.Arrangements}");
				}
                    SendReply(player, string.Format(lang.GetMessage(NpcName, this) + lang.GetMessage("npcCommand", this)));
            }
			
            if (OpenDoor == true && DoorId > 0)
            {
                var newLocation = new Vector3(npcData.NpcTP[npcId].DoorLocX, npcData.NpcTP[npcId].DoorLocY, npcData.NpcTP[npcId].DoorLocZ);
                List<BaseEntity> doornear = new List<BaseEntity>();
                Vis.Entities(newLocation, 1.5f, doornear);
                var i = 0;
                foreach (var door in doornear)
                {
                    if (!door.IsOpen() && (door.GetComponent<Door>()))
                    {
                        i++;
                        door.SetFlag(BaseEntity.Flags.Open, true);
                        door.SendNetworkUpdateImmediate();
                        timer.Once(AutoCloseTime, () =>
                    {
                        if (!door.IsOpen()) return;
                        i++;
                        door.SetFlag(BaseEntity.Flags.Open, false);
                        door.SendNetworkUpdateImmediate();

                    });
                    }
                    else { }
                }

                if (DoorOpenMessage)
                    SendReply(player, string.Format(lang.GetMessage(NpcName, this) + lang.GetMessage("DoorMessage", this)));
                return;
            }
	}
        readonly Dictionary<ulong, Timer> timers = new Dictionary<ulong, Timer>();


        void OnEnterNPC(BasePlayer npc, BasePlayer player)
        {

	    if (!player.userID.IsSteamId()) return;
            string npcId = npc.UserIDString;
            if (!npcData.NpcTP.ContainsKey(npc.UserIDString)) return;
            string Perms = npcData.NpcTP[npcId].permission;
            var CanUse = npcData.NpcTP[npcId].CanUse;
            if (!CanUse) return;
            var NoPermDie = npcData.NpcTP[npcId].NoPermKill;
            var KillSleepA = npcData.NpcTP[npcId].KillSleep;
            if ((useJail) && (bool) (Jail?.CallHook("IsPrisoner", player) ?? false))
            {
                return;
            }

            if (player.IsSleeping() && KillSleepA == true)
                applySleepDamage(player);

            if (NoPermDie == false || permission.UserHasPermission(player.userID.ToString(), Perms) || KillSleepA == true || !player.userID.IsSteamId()) return;
            if (UseGunToKill)
                StartNpcAttack(npc, player);
            if (!SetOnFire) return;
            StartFire(player);
        }
        void OnLeaveNPC(BasePlayer npc, BasePlayer player)
        {
			if (!player.userID.IsSteamId()) return;
            string npcId = npc.UserIDString;
            if (!npcData.NpcTP.ContainsKey(npc.UserIDString)) return;
            string Perms = npcData.NpcTP[npcId].permission;
            var CanUse = npcData.NpcTP[npcId].CanUse;
            if (!CanUse) return;
            var NoPermDie = npcData.NpcTP[npcId].NoPermKill;

            if (timers.ContainsKey(player.userID))
                timers[player.userID].Destroy();
            if (NoPermDie == false || permission.UserHasPermission(player.userID.ToString(), Perms) || FollowDead == true) return;
            var humanPlayer = npc.GetComponent<HumanNPC.HumanPlayer>();
            humanPlayer.info.hostile = false;
            var locomotion = npc.GetComponent<HumanNPC.HumanLocomotion>();
            Interface.Oxide.CallHook("OnNPCStopTarget", player, locomotion.attackEntity);
            locomotion.attackEntity = null;
            locomotion.GetBackToLastPos();
        }

        void StartNpcAttack(BasePlayer npc, BasePlayer player)
        {
            var humanPlayer = npc.GetComponent<HumanNPC.HumanPlayer>();
            if (!(bool)(Vanish?.CallHook("IsInvisible", player) ?? false))
                humanPlayer.info.hostile = true;
            HumanNPC?.Call("OnEnterNPC", npc, player);
            return;
        }

        void StartFire(BasePlayer player)
        {

            var playerPos = player.transform.position;
            var playerRot = player.transform.rotation;
            BaseEntity FireBurn = GameManager.server.CreateEntity("assets/bundled/prefabs/oilfireballsmall.prefab", playerPos, playerRot);

            timer.Once(OnFireTime, () => FireBurn.Kill());
            FireBurn.Spawn();
            FireBurn.SetParent(player);
            FireBurn.transform.localPosition = new Vector3(0f, 0f, 0f);
            applyBlastDamage(player);
            ((Rigidbody)FireBurn.gameObject.GetComponent(typeof(Rigidbody))).isKinematic = true;
            return;
        }

        void applyBlastDamage(BasePlayer player)
        {
            if (player != null || !timers.ContainsKey(player.userID))
                timers[player.userID] = timer.Every(2, () =>
                {
                    if (player.IsDead() && timers.ContainsKey(player.userID))
                        timers[player.userID].Destroy();
                    else
                        player.Hurt(OnFireDamage);
                });
            return;
        }
        void applySleepDamage(BasePlayer player)
        {
            if (player != null)
            {
                if (player.IsDead())
                    return;
                else
                    player.Hurt(SleepKillDamage);
                return;
            }
        }

        void OnUseNPC(BasePlayer npc, BasePlayer player, Vector3 destination)
        {
            if (!npcData.NpcTP.ContainsKey(npc.UserIDString)) return; // Check if this NPC is registered

            ulong playerId = player.userID;
            string npcId = npc.UserIDString;
            double timeStamp = GrabCurrentTime();
            var CanUse = npcData.NpcTP[npcId].CanUse;
            var useUI = npcData.NpcTP[npcId].useUI;
            var cooldownTime = npcData.NpcTP[npcId].Cooldown;
            var Perms = npcData.NpcTP[npcId].permission;
            var amount = npcData.NpcTP[npcId].Cost;
            var useMessage = npcData.NpcTP[npcId].useMessage;
            var MessageNpc = npcData.NpcTP[npcId].MessageNpc;
            var DoorId = npcData.NpcTP[npcId].DoorId;
            var doorcheck = Convert.ToString(DoorId);
            var OpenDoor = npcData.NpcTP[npcId].OpenDoor;
            string NpcName = npcData.NpcTP[npcId].NpcName;

            if (!pcdData.pCooldown.ContainsKey(playerId))
            {
                pcdData.pCooldown.Add(playerId, new PCDInfo());
                //SaveData();
            }

            if (!CanUse)
            {
                SendReply(player, string.Format(lang.GetMessage(NpcName, this) + lang.GetMessage("notenabled", this)));
                return;
            }
            else
            {
                if (!permission.UserHasPermission(player.userID.ToString(), Perms))
                {
                    SendReply(player, string.Format(lang.GetMessage(NpcName, this) + lang.GetMessage("noperm", this)));
                    return;
                }
                if (pcdData.pCooldown[playerId].npcCooldowns.ContainsKey(npcId)) // Check if the player already has a cooldown for this NPC
                {
                    var cdTime = pcdData.pCooldown[playerId].npcCooldowns[npcId]; // Get the cooldown time of the NPC
                    if (cdTime > timeStamp)
                    {
                        SendReply(player, string.Format(lang.GetMessage(NpcName, this) + lang.GetMessage("cdTime", this, player.UserIDString), (int)(cdTime - timeStamp) / 60));
                        return;
                    }
                }
                if (OpenDoor == true && DoorId > 0)
                {
                    var newLocation = new Vector3(npcData.NpcTP[npcId].DoorLocX, npcData.NpcTP[npcId].DoorLocY, npcData.NpcTP[npcId].DoorLocZ);
                    List<BaseEntity> doornear = new List<BaseEntity>();
                    Vis.Entities(newLocation, 1.0f, doornear);
                    var i = 0;
                    foreach (var door in doornear)
                    {
                        if (door.ToString().Contains(doorcheck) && door.ToString().Contains("hinged"))
                            if (door.IsOpen())
                            {
                                SendReply(player, string.Format(lang.GetMessage(NpcName, this) + lang.GetMessage("DoorIsOpen", this)));
                                return;
                            }
                    }
                }
                if (!useUI && !useMessage)
                {
                    player.SendConsoleCommand($"hardestcommandtoeverguessnpctp {playerId} {npcId}");
                    return;
                }
                else
                if (useUI && amount >= 1 || useMessage)
                {

                    var elements = new CuiElementContainer();
                    msg = (useMessage && amount >= 1) ? MessageNpc + "\n \n" + lang.GetMessage("commandyesno", this, player.UserIDString) + amount + lang.GetMessage("commandyesno1", this) : "";
                    if (msg == "")
                        msg = (!useMessage && amount >= 1) ? "\n \n" + lang.GetMessage("commandyesno", this, player.UserIDString) + amount + lang.GetMessage("commandyesno1", this) : "";
                    if (msg == "")
                        msg = (useMessage && amount == 0) ? MessageNpc : "";
                    if (msg == "")
                        //Sets the msg to unknown as we could not find a correct variable to match it with.
                        msg = "Unknown";
                    {
                        var mainName = elements.Add(new CuiPanel
                        {
                            Image =
                {
                    Color = "0.1 0.1 0.1 1"
                },
                            RectTransform =
                {
                    AnchorMin = "0 0",
                    AnchorMax = "1 1"
                },
                            CursorEnabled = true
                        }, "Overlay", "Npctp");
                        if (backroundimage == true)
                        {
                            elements.Add(new CuiElement
                            {
                                Parent = "Npctp",
                                Components =
                    {
                        new CuiRawImageComponent
                        {
                            Url = backroundimageurl,
                            Sprite = "assets/content/textures/generic/fulltransparent.tga"
                        },
                        new CuiRectTransformComponent
                        {
                            AnchorMin = "0 0",
                            AnchorMax = "1 1"
                        }
                    }
                            });
                        }
                        var Agree = new CuiButton
                        {
                            Button =
                {
                    Command = $"hardestcommandtoeverguessnpctp {playerId} {npcId}",
                    Close = mainName,
                    Color = "0 255 0 1"
                },
                            RectTransform =
                {
                    AnchorMin = "0.2 0.16",
                    AnchorMax = "0.45 0.2"
                },
                            Text =
                {
                    Text = "Go",
                    FontSize = 22,
                    Align = TextAnchor.MiddleCenter
                }
                        };
                        var Disagree = new CuiButton
                        {


                            Button =
                {

                    Close = mainName,
                    Color = "255 0 0 1"

                },
                            RectTransform =
                {
                    AnchorMin = "0.5 0.16",
                    AnchorMax = "0.75 0.2"
                },
                            Text =
                {
                    Text = "Cancel",
                    FontSize = 22,
                    Align = TextAnchor.MiddleCenter
                }
                        };
                        elements.Add(new CuiLabel
                        {
                            Text =
                {
                    Text = msg,
                    FontSize = 22,
                    Align = TextAnchor.MiddleCenter
                },
                            RectTransform =
                {
                    AnchorMin = "0 0.20",
                    AnchorMax = "1 0.9"
                }
                        }, mainName);
                        elements.Add(Agree, mainName);
                        elements.Add(Disagree, mainName);
                        CuiHelper.AddUi(player, elements);
                    }
                }
            }

            #endregion
        }
    }
}







// --- End of file: Npctp.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-loot ---
// --- Original File Path: N/NoLoot/NoLoot.cs ---

namespace Oxide.Plugins
{
    [Info("No Loot", "Wulf", "1.1.0")]
    [Description("Removes all loot containers and prevents them from spawning")]
    class NoLoot : CovalencePlugin
    {
        #region Initialization

        private void Init() => Unsubscribe(nameof(OnEntitySpawned));

        private void OnServerInitialized()
        {
            int count = 0;
            foreach (LootContainer entity in UnityEngine.Resources.FindObjectsOfTypeAll<LootContainer>())
            {
                if (ProcessEntity(entity))
                {
                    count++;
                }
            }
            Subscribe(nameof(OnEntitySpawned));
            Puts($"Removed {count} loot containers");
        }

        #endregion Initialization

        #region Loot Handling

        private bool ProcessEntity(BaseEntity entity)
        {
            if (!entity.isActiveAndEnabled || entity.IsDestroyed || entity.OwnerID != 0)
            {
                return false;
            }

            if (entity is JunkPile)
            {
                JunkPile junkPile = entity as JunkPile;
                junkPile.CancelInvoke("TimeOut");
                junkPile.CancelInvoke("CheckEmpty");
                junkPile.CancelInvoke("Effect");
                junkPile.CancelInvoke("SinkAndDestroy");
                junkPile.Kill();
            }
            else
            {
                entity.Kill();
            }

            return true;
        }

        private void OnEntitySpawned(JunkPile junkPile) => ProcessEntity(junkPile);

        private void OnEntitySpawned(LootContainer container) => ProcessEntity(container);

        #endregion Loot Handling
    }
}


// --- End of file: NoLoot.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-raid-repair ---
// --- Original File Path: N/NoRaidRepair/NoRaidRepair.cs ---

﻿using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("NoRaidRepair", "Ryan", "1.0.0")]
    [Description("Prevents the player from repairing their base whilst raidblocked.")]

    class NoRaidRepair : RustPlugin
    {
        [PluginReference] RustPlugin NoEscape;

        void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CantRepair"] = "You can't repair whilst raidblocked."
            }, this);
        }

        bool isRaidBlocked(BasePlayer player) => (bool)NoEscape.Call("IsRaidBlocked", player);

        void OnHammerHit(BasePlayer player, HitInfo info)
        {
            if (NoEscape == null) return;
            if (isRaidBlocked(player)) PrintToChat(player, Lang("CantRepair"));
        }

        object OnStructureRepair(BaseCombatEntity entity, BasePlayer player)
        {
            if (NoEscape == null || !isRaidBlocked(player)) return null;
            return false;
        }

        string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);
    }
}

// --- End of file: NoRaidRepair.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-fuel-requirements ---
// --- Original File Path: N/NoFuelRequirements/NoFuelRequirements.cs ---

﻿using Oxide.Core;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("NoFuelRequirements", "k1lly0u", "1.8.0")]
    class NoFuelRequirements : RustPlugin
    {
        #region Fields 
        private readonly string[] ValidFuelTypes = new string[] { "wood", "lowgradefuel" };

        private readonly ConsumeType[] ObsoleteConsumeTypes = new ConsumeType[] 
        { ConsumeType.None, ConsumeType.CeilingLight, ConsumeType.Searchlight, ConsumeType.SmallCandle, ConsumeType.LargeCandle };
        #endregion

        #region Oxide Hooks        
        private void Loaded()
        {
            if (configData.UsePermissions)
            {
                foreach (ConsumeType consumeType in Enum.GetValues(typeof(ConsumeType)))
                {
                    if (!ObsoleteConsumeTypes.Contains(consumeType))
                        permission.RegisterPermission($"nofuelrequirements.{consumeType}", this);
                }
            }
        }

        private void OnFuelConsume(BaseOven baseOven, Item fuelItem, ItemModBurnable itemModBurnable)
        {
            if (!baseOven || fuelItem == null) 
                return;

            ConsumeType consumeType = ShortNameToConsumeType(baseOven.ShortPrefabName);
            if (consumeType == ConsumeType.None) 
                return;

            if (IsConsumeTypeEnabled(consumeType))
            {
                if (configData.UsePermissions && baseOven.OwnerID != 0U && !HasPermission(baseOven.OwnerID.ToString(), consumeType))                
                    return;
                
                fuelItem.amount += 1;

                baseOven.allowByproductCreation = false;
                
                NextTick(() =>
                {
                    if (baseOven)
                        baseOven.allowByproductCreation = true;
                });
            }
        }

        private void OnItemUse(Item item, int amount)
        {
            if (item == null || amount == 0 || !ValidFuelTypes.Contains(item.info.shortname))
                return;

            string shortPrefabName = string.Empty;
            ulong ownerId = 0UL;

            ItemContainer rootContainer = item.GetRootContainer();
            if (rootContainer != null && rootContainer.entityOwner)
            {
                if (rootContainer.entityOwner is BaseOven)
                    return;

                shortPrefabName = rootContainer.entityOwner.ShortPrefabName;
                ownerId = rootContainer.entityOwner.OwnerID;
            }
            else if (item.parent != null && item.parent.parent != null)
            {
                shortPrefabName = item.parent.parent.info.shortname;

                BasePlayer ownerPlayer = item.parent.GetOwnerPlayer();
                ownerId = ownerPlayer != null ? ownerPlayer.userID : 0UL;
            }
            else if (item.parent != null && item.parent.playerOwner != null)
            {                
                Item activeItem = item.parent.playerOwner.GetActiveItem();
                if (activeItem != null)
                {
                    HeldEntity heldEntity = activeItem.GetHeldEntity() as HeldEntity;
                    if (heldEntity)
                    {
                        if (heldEntity is FlameThrower || heldEntity is Chainsaw)
                            shortPrefabName = heldEntity.ShortPrefabName;
                    }
                }

                ownerId = item.parent.playerOwner.userID;
            }

            if (string.IsNullOrEmpty(shortPrefabName))
                return;

            ConsumeType consumeType = ShortNameToConsumeType(shortPrefabName);
            if (consumeType == ConsumeType.None)
                return;

            if (IsConsumeTypeEnabled(consumeType))
            {
                if (configData.UsePermissions && ownerId != 0UL && !HasPermission(ownerId, consumeType))
                    return;

                item.amount += amount;
            }
        }
        #endregion

        #region Functions        
        private object IgnoreFuelConsumption(string consumeTypeStr, ulong ownerId)
        {
            ConsumeType consumeType = ParseType(consumeTypeStr);
            if (consumeType != ConsumeType.None && configData.AffectedTypes[consumeType])
            {
                if (configData.UsePermissions && !HasPermission(ownerId.ToString(), consumeType))
                    return null;
                return true;
            }
            return null;
        }

        private bool HasPermission(string userId, ConsumeType consumeType) => permission.UserHasPermission(userId, $"nofuelrequirements.{consumeType}");

        private bool HasPermission(ulong userId, ConsumeType consumeType) => permission.UserHasPermission(userId.ToString(), $"nofuelrequirements.{consumeType}");

        private bool IsConsumeTypeEnabled(ConsumeType consumeType)
        {
            bool result = false;
            configData.AffectedTypes.TryGetValue(consumeType, out result);
            return result;
        }

        private ConsumeType ShortNameToConsumeType(string shortname)
        {
            switch (shortname)
            {
                case "campfire":
                    return ConsumeType.Campfire;
                case "skull_fire_pit":
                    return ConsumeType.Firepit;
                case "fireplace.deployed":
                    return ConsumeType.Fireplace;
                case "furnace":
                    return ConsumeType.Furnace;
                case "furnace.large":
                    return ConsumeType.LargeFurnace;
                case "refinery_small_deployed":
                    return ConsumeType.OilRefinery;                
                case "chainsaw.entity":
                    return ConsumeType.Chainsaw;
                case "flamethrower.entity":
                    return ConsumeType.FlameThrower;
                case "lantern.deployed":
                    return ConsumeType.Lanterns;
                case "hat.miner":
                    return ConsumeType.MinersHat;
                case "hat.candle":
                    return ConsumeType.CandleHat;
                case "fuelstorage":
                    return ConsumeType.Quarry;
                case "tunalight.deployed":
                    return ConsumeType.TunaLight;                
                case "fogmachine":
                    return ConsumeType.FogMachine;
                case "snowmachine":
                    return ConsumeType.SnowMachine;
                case "cursedcauldron.deployed":
                    return ConsumeType.CursedCauldren;
                case "chineselantern.deployed":
                    return ConsumeType.ChineseLantern;
                case "bbq.deployed":
                    return ConsumeType.Barbeque;
                case "hobobarrel.deployed":
                    return ConsumeType.HoboBarrel;
                case "small_fuel_generator.deployed":
                    return ConsumeType.SmallGenerator;
                default:
                    return ConsumeType.None;
            }
        }

        private ConsumeType ParseType(string type)
        {
            try
            {
                return (ConsumeType)Enum.Parse(typeof(ConsumeType), type, true);
            }
            catch
            {
                return ConsumeType.None;
            }
        }
        #endregion

        #region Config  
        private enum ConsumeType 
        {
            Barbeque,
            Campfire,
            CandleHat,
            CeilingLight, 
            Chainsaw,
            ChineseLantern, 
            CursedCauldren,
            Firepit, 
            Fireplace,
            FlameThrower,
            FogMachine,
            HoboBarrel,
            Furnace,
            Lanterns,
            LargeFurnace,
            MinersHat,
            OilRefinery,
            Quarry,            
            Searchlight,            
            SnowMachine,
            TunaLight,
            SmallCandle,
            LargeCandle,
            SmallGenerator,
            None 
        }
       
        private ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Entities that ignore fuel consumption")]
            public Dictionary<ConsumeType, bool> AffectedTypes { get; set; }

            [JsonProperty(PropertyName = "Require permission to ignore fuel consumption")]
            public bool UsePermissions { get; set; }

            public Oxide.Core.VersionNumber Version { get; set; }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            configData = Config.ReadObject<ConfigData>();

            if (configData.Version < Version)
                UpdateConfigValues();

            Config.WriteObject(configData, true);
        }

        protected override void LoadDefaultConfig() => configData = GetBaseConfig();

        private ConfigData GetBaseConfig()
        {
            return new ConfigData
            {
                AffectedTypes = new Dictionary<ConsumeType, bool>
                {
                    [ConsumeType.Barbeque] = true,
                    [ConsumeType.Campfire] = true,
                    [ConsumeType.CandleHat] = true,
                    [ConsumeType.Firepit] = true,
                    [ConsumeType.Fireplace] = true,
                    [ConsumeType.Furnace] = true,
                    [ConsumeType.Lanterns] = true,
                    [ConsumeType.LargeFurnace] = true,
                    [ConsumeType.MinersHat] = true,
                    [ConsumeType.OilRefinery] = true,
                    [ConsumeType.Quarry] = true,
                    [ConsumeType.TunaLight] = true,
                    [ConsumeType.FogMachine] = true,
                    [ConsumeType.SnowMachine] = true,
                    [ConsumeType.CursedCauldren] = true,
                    [ConsumeType.ChineseLantern] = true,
                    [ConsumeType.Chainsaw] = true,
                    [ConsumeType.FlameThrower] = true,
                    [ConsumeType.HoboBarrel] = true,
                    [ConsumeType.SmallGenerator] = true,
                },
                UsePermissions = false,
                Version = Version
            };
        }

        protected override void SaveConfig() => Config.WriteObject(configData, true);

        private void UpdateConfigValues()
        {
            PrintWarning("Config update detected! Updating config values...");

            ConfigData baseConfig = GetBaseConfig();
            if (configData.Version < new VersionNumber(1, 3, 6))
                configData = baseConfig;

            foreach (ConsumeType consumeType in Enum.GetValues(typeof(ConsumeType)))
            {
                if (!ObsoleteConsumeTypes.Contains(consumeType) && !configData.AffectedTypes.ContainsKey(consumeType))
                    configData.AffectedTypes.Add(consumeType, true);
            }

            for (int i = 0; i < ObsoleteConsumeTypes.Length; i++)
                configData.AffectedTypes.Remove(ObsoleteConsumeTypes[i]);

            configData.Version = Version;
            PrintWarning("Config update completed!");
        }

        #endregion
    }
}


// --- End of file: NoFuelRequirements.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/night-pvp ---
// --- Original File Path: N/NightPVP/NightPVP.cs ---

using Oxide.Game.Rust.Cui;
using UnityEngine;  //cui textanchor
using System.Collections.Generic;   //dict
using Convert = System.Convert;
using System.Linq;
using System;   //Math
using Oxide.Core;

namespace Oxide.Plugins
{
	[Info("Night PVP", "BuzZ[PHOQUE]", "0.1.7")]
	[Description("PVP only during night and PVE no damage during day")]

/*======================================================================================================================= 
*
*   
*   15th november 2018
*
*	THANKS TO THE OXIDE/UMOD TEAM for coding quality, ideas, and time spent for the community
*
*   0.1.6   20181123    null pve damage when not owner of entity    message timer/playerlist to avoid spamming
*
*=======================================================================================================================*/

	public class NightPVP : RustPlugin
	{
        string Prefix = "[NightPVP] ";                  // CHAT PLUGIN PREFIX
        string PrefixColor = "#bf0000";                 // CHAT PLUGIN PREFIX COLOR
        string ChatColor = "#dd8e8e";                   // CHAT MESSAGE COLOR
        ulong SteamIDIcon = 76561198079320022;  
        
        float starthour = 21;
        float stophour = 6;
        float rate = 10;

        private static string ONpvpHUD;
        private static string ONpveHUD;
        bool debug = false;
        private bool ConfigChanged;
        double leftmin = 0.95;
        double bottom = 0.86;
        int HUDtxtsize = 10;
        double HUDwidth = 0.05;
        double HUDheigth = 0.04;
        string HUDpvecolor = "0.5 1.0 0.0";
        string HUDpveopacity = "0.0";
        string HUDpvpcolor = "0.85 0.2 0.5";
        string HUDpvpopacity = "0.0";

        public List<BasePlayer> hasreceived = new List<BasePlayer>();

        void Init()
        {
            LoadVariables();
        }

        void OnServerInitialized()
        {
            if (storedData.NightPvpOn == false)NightIsOff();
            else NightIsOn();
            timer.Every(rate, () =>
            {   
                insidetimer();
            });
        }

        void insidetimer()
        {
            float gamehour = TOD_Sky.Instance.Cycle.Hour;
            int hournow = Convert.ToInt32(Math.Round(gamehour-0.5));
                if (hournow >= starthour || hournow < stophour)
                {
                    if (storedData.NightPvpOn == false){NightIsOn();}
                    storedData.NightPvpOn = true;
                }
                else
                {
                    if (storedData.NightPvpOn == true){NightIsOff();}
                    storedData.NightPvpOn = false;
                }
                if (debug == true){Puts($"{hournow} PVP is ON {storedData.NightPvpOn}");}
        }

        void Loaded()
        {
            storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
        }

        void Unload()
        {

            foreach (BasePlayer player in BasePlayer.activePlayerList.ToList())
            {
                KillHUD(player);
            }
            Interface.Oxide.DataFileSystem.WriteObject(Name, storedData);
        }

        class StoredData
        {
            public bool NightPvpOn;

            public StoredData()
            {
            }
        }
        private StoredData storedData;

#region MESSAGES

        protected override void LoadDefaultMessages()
        {

            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"PVEMsg", "Night PVP turned"},
                {"PVPMsg", "Night PVP turned"},
                {"nulledMsg", "PVP Damage nulled, this is PVE time"},
                {"daysafeMsg", "<size=11><color=green>DAY SAFE</color></size>\nPVE"},
                {"nightpvpMsg", "<size=11><color=red>NIGHT</color></size>\nPVP"},

            }, this, "en");

            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"PVEMsg", "La nuit PVP est terminée"},
                {"PVPMsg", "La nuit PVP a commencée"},
                {"nulledMsg", "Dommages PVP ignorés, vous êtes dans le créneau PVE"},
                {"daysafeMsg", "<size=11><color=green>PROTECTION</color></size>\nPVE"},
                {"nightpvpMsg", "<size=11><color=red>NUIT</color></size>\nPVP"},

            }, this, "fr");
        }

#endregion

#region CONFIG

    protected override void LoadDefaultConfig()
        {
            LoadVariables();
        }

        private void LoadVariables()
        {
            Prefix = Convert.ToString(GetConfig("Chat Settings", "Prefix", "[NightPVP] "));                       // CHAT PLUGIN PREFIX
            PrefixColor = Convert.ToString(GetConfig("Chat Settings", "PrefixColor", "#bf0000"));                // CHAT PLUGIN PREFIX COLOR
            ChatColor = Convert.ToString(GetConfig("Chat Settings", "ChatColor", "#dd8e8e"));                    // CHAT MESSAGE COLOR
            SteamIDIcon = Convert.ToUInt64(GetConfig("Chat Settings", "SteamIDIcon", "76561198079320022"));        // SteamID FOR PLUGIN ICON - STEAM PROFILE CREATED FOR THIS PLUGIN / NONE YET /
            starthour = Convert.ToSingle(GetConfig("Night Time Zone", "Start at", "21"));
            stophour = Convert.ToSingle(GetConfig("Night Time Zone", "Stop at", "6"));
            leftmin = Convert.ToDouble(GetConfig("HUD position", "left (0.95 by default)", "0.95"));
            bottom = Convert.ToDouble(GetConfig("HUD position", "bottom (0.86 by default)", "0.86"));
            HUDtxtsize = Convert.ToInt32(GetConfig("HUD text size", "(10 by default)", "10"));
            HUDwidth = Convert.ToDouble(GetConfig("HUD size", "width (0.05 by default)", "0.05"));
            HUDheigth = Convert.ToDouble(GetConfig("HUD size", "heigth (0.04 by default)", "0.04"));
            HUDpvecolor = Convert.ToString(GetConfig("HUD color", "for PVE", "0.5 1.0 0.0"));                    // CHAT MESSAGE COLOR
            HUDpveopacity = Convert.ToString(GetConfig("HUD opacity", "for PVE", "0.0"));                    // CHAT MESSAGE COLOR
            HUDpvpcolor = Convert.ToString(GetConfig("HUD color", "for PVP", "0.85 0.2 0.5"));                    // CHAT MESSAGE COLOR
            HUDpvpopacity = Convert.ToString(GetConfig("HUD opacity", "for PVP", "0.0"));                    // CHAT MESSAGE COLOR

            //rate = Convert.ToSingle(GetConfig("", "", "300"));

            if (!ConfigChanged) return;
            SaveConfig();
            ConfigChanged = false;
        }

        private object GetConfig(string menu, string datavalue, object defaultValue)
        {
            var data = Config[menu] as Dictionary<string, object>;
            if (data == null)
            {
                data = new Dictionary<string, object>();
                Config[menu] = data;
                ConfigChanged = true;
            }
            object value;
            if (!data.TryGetValue(datavalue, out value))
            {
                value = defaultValue;
                data[datavalue] = value;
                ConfigChanged = true;
            }
            return value;
        }

#endregion

        private void NightIsOn()
        {
            ChatPlayerOnline("pvp");
            if (debug == true){Puts($"Night PVP turned ON");}
            foreach (BasePlayer player in BasePlayer.activePlayerList.ToList())
            {
                CuiHelper.DestroyUi(player, ONpvpHUD);
                CuiHelper.DestroyUi(player, ONpveHUD);
                DisplayPVP(player);
            }
		}

        private void NightIsOff()
        {
            ChatPlayerOnline("pve");
            if (debug == true){Puts($"Night PVP turned OFF");}
            foreach (BasePlayer player in BasePlayer.activePlayerList.ToList())
            {
                CuiHelper.DestroyUi(player, ONpvpHUD);
                CuiHelper.DestroyUi(player, ONpveHUD);
                DisplayPVE(player);
            }
        }

        private void DisplayPVE(BasePlayer player)
        {
			    var CuiElement = new CuiElementContainer();
			    ONpveHUD = CuiElement.Add(new CuiPanel{Image ={Color = $"{HUDpvecolor} {HUDpveopacity}"},RectTransform ={AnchorMin = $"{leftmin} {bottom}",AnchorMax = $"{leftmin+HUDwidth} {bottom +HUDheigth}"},CursorEnabled = false
                }, new CuiElement().Parent = "Overlay", ONpveHUD);
          		
			    CuiElement.Add(new CuiLabel{Text ={Text = $"{lang.GetMessage("daysafeMsg", this, player.UserIDString)}",FontSize = HUDtxtsize,Align = TextAnchor.MiddleCenter,
                Color = "1 1 1 1"},RectTransform ={AnchorMin = "0.10 0.10",   AnchorMax = "0.90 0.79"}
				}, ONpveHUD);

			    CuiHelper.AddUi(player, CuiElement);
        }

        private void DisplayPVP(BasePlayer player)
        {
			    var CuiElement = new CuiElementContainer();
			    ONpvpHUD = CuiElement.Add(new CuiPanel{Image ={Color = $"{HUDpvpcolor} {HUDpvpopacity}"},RectTransform ={AnchorMin = $"{leftmin} {bottom}",AnchorMax = $"{leftmin+HUDwidth} {bottom +HUDheigth}"},CursorEnabled = false
                }, new CuiElement().Parent = "Overlay", ONpvpHUD);
          		
			    CuiElement.Add(new CuiLabel{Text ={Text = $"{lang.GetMessage("nightpvpMsg", this, player.UserIDString)}",FontSize = HUDtxtsize,Align = TextAnchor.MiddleCenter,
                Color = "1 1 1 1"},RectTransform ={AnchorMin = "0.10 0.10",   AnchorMax = "0.90 0.79"}
				}, ONpvpHUD);

			    CuiHelper.AddUi(player, CuiElement);
        }

        private void KillHUD(BasePlayer player)
        {
                CuiHelper.DestroyUi(player, ONpvpHUD);
                CuiHelper.DestroyUi(player, ONpveHUD);
        }

#region PVE FRIENDLY STYLE but can kill NPC and be killed by NPC

        void OnEntityTakeDamage(BaseEntity entity, HitInfo info)
        {
            if (storedData.NightPvpOn == true){return;}
            if (entity == null || info == null) return;
            BasePlayer goodguy = entity as BasePlayer;
            if (info.Initiator == null) return;
            BasePlayer badguy = info.Initiator as BasePlayer;
            if (badguy == null) return;
            ////// RAIDING
            bool raiding = IsRaid(entity, badguy, info);
            if (raiding)return;
            ////// PLAYER vs PLAYER
            if (goodguy == null || badguy == null) return;
            //if (debug == true){Puts($"{goodguy.UserIDString.IsSteamID()}");}
            bool goodonline = IsReal(goodguy);
            bool badonline = IsReal(badguy);
            if (debug == true){Puts($"BLESSE {goodonline} - TIREUR {badonline}");}
            if (goodonline == false || badonline == false) {return;}    // REAL PLAYER vs PLAYER FILTER
            info.damageTypes.ScaleAll(0);
            AntiSpamage(badguy);
            AntiSpamage(goodguy);
            if (debug == true){Puts($"damage nulled");}
        }

        public bool IsReal(BasePlayer check)
        {
            if (debug == true){Puts($"bool IsReal");}
            if (BasePlayer.activePlayerList.ToList().Contains(check) == true)
            {
                return true;
            }
            if (BasePlayer.sleepingPlayerList.ToList().Contains(check) == true)
            {
                return true;  
            }
            else
            {
                return false;
            }
        }   

        public bool IsRaid(BaseEntity entity, BasePlayer badguy, HitInfo info)
        {
            if (debug == true)Puts($"VOID RAID");
            if (entity is BuildingBlock || entity.name.Contains("deploy") || entity.name.Contains("building"))
            {
                if (entity.OwnerID != badguy.userID)
                {
                    if (debug == true)Puts($"RAID !!!");
                    info.damageTypes.ScaleAll(0);
                    AntiSpamage(badguy);
                    return true;
                }
                else
                {
                    if (debug == true)Puts($"OWNER DAMAGE OWN ENTITY {entity.OwnerID}");
                    return true;
                }
            }
            else
            {
                return false;
            }
        }

#endregion

        private void AntiSpamage(BasePlayer player)
        {
            if (hasreceived.Contains(player))return;
            else
            {
                Player.Message(player, $"<color={ChatColor}>{lang.GetMessage("nulledMsg", this, player.UserIDString)}</color>",$"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);
                hasreceived.Add(player);
                timer.Once(20f, () =>
                {
                    hasreceived.Remove(player);
                });
            }
        }

#region CHAT MESSAGE TO ONLINE PLAYER

        private void ChatPlayerOnline(string status)
        {
            foreach (BasePlayer player in BasePlayer.activePlayerList.ToList())
            {
                if (status == "pve")
                {
                    Player.Message(player, $"<color={ChatColor}>{lang.GetMessage("PVEMsg", this, player.UserIDString)}</color> <color=red>OFF</color>",$"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);
                }
                else
                {
                    Player.Message(player, $"<color={ChatColor}>{lang.GetMessage("PVPMsg", this, player.UserIDString)}</color> <color=green>ON</color>",$"<color={PrefixColor}> {Prefix} </color>", SteamIDIcon);
                }
            }
        }

#endregion

        void OnPlayerSleepEnded(BasePlayer player)
        {
            KillHUD(player);
            if (storedData.NightPvpOn == false){DisplayPVE(player);}
            else{DisplayPVP(player);}
        }

        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
                KillHUD(player);
        }


    }
}


// --- End of file: NightPVP.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/night-door ---
// --- Original File Path: N/NightDoor/NightDoor.cs ---

using Oxide.Core;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Night Door", "Slydelix", "1.7.2", ResourceId = 2684)]
    class NightDoor : RustPlugin
    {
        private bool hideTime, BypassAdmin, BypassPerm, UseRealTime, AutoDoor, useMulti, intialized = false;
        private string startTime, endTime;

        private const string usePerm = "nightdoor.use";
        private const string createIntervalPerm = "nightdoor.createinterval";
        private const string bypassPerm = "nightdoor.bypass";

        #region config

        protected override void LoadDefaultConfig()
        {
            Config["Allow admins to open time-limited door"] = BypassAdmin = GetConfig("Allow admins to open time-limited door", false);
            Config["Allow players with bypass permission to open time-limited door"] = BypassPerm = GetConfig("Allow players with bypass permission to open time-limited door", false);
            Config["Beginning time (HH:mm)"] = startTime = GetConfig("Beginning time (HH:mm)", "00:00");
            Config["Use multiple time intervals"] = useMulti = GetConfig("Use multiple time intervals", false);
            Config["End time (HH:mm)"] = endTime = GetConfig("End time (HH:mm)", "00:00");
            Config["Use system (real) time"] = UseRealTime = GetConfig("Use system (real) time", false);
            Config["Don't show time to player when unable to open door"] = hideTime = GetConfig("Don't show time to player when unable to open door", false);
            Config["Automatic door closing/opening"] = AutoDoor = GetConfig("Automatic door closing/opening", false);
            SaveConfig();
        }

        #endregion
        #region lang

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>()
            {
                //Default messages
                {"ServerWiped", "Wipe du serveur détecté, remise à zéro du fichier de données"},
                {"WipeManual", "Remise a zéro manuelle du fichier de données de Night Door"},
                {"Warning_StartBiggerThanEnd", "La configuration ne semble pas correcte ! (l'heure de début se situe après l'heure de fin)"},
                {"Warning_DefaultConfig", "00:00 défini comme fin et comme début ! Changez ces valeurs par celles que vous désirez"},
                {"NoPermission", "Vous n'avez pas la permission pour utiliser cette commande"},
                //Player messages
                {"PlayerCannotOpen", "Cette {0} ne peut pas être ouverte."},
                {"PlayerCannotOpenTime", "Cette {0} ne peut être ouverte avant {1}"},
                {"PlayerCannotPlace", "Un verrou ne peut pas être placé sur cette {0}"},           
                //Messages for /timeperiod
                {"TimeIntervalRemovedDoor", "La porte à {0} peut maintenant être ouverte car la période a été supprimée !"},
                {"TimeIntevalSyntax", "Erreur de syntaxe ! <color=silver>/timeperiod create <nom> <HH:mm>(heure de début) <HH:mm>(heure de fin)</color>"},
                {"TimeIntervalRemoveSyntax", "Erreur de syntaxe ! <color=silver>/timeperiod remove <nom></color>"},
                {"TimeIntervalCreated", "Nouvelle période créée sous le nom '{0}' ({1} - {2})"},
                {"TimeIntervalRemoved", "Période avec le nom '{0}' a été supprimée"},
                {"TimeIntervalNotSetUp", "Il n'y a aucune période enregistrée"},
                {"TimeIntervalList", "Liste de toutes les périodes: \n{0}"},
                {"TimeIntervalExists", "Une période avec ce nom existe déjà"},
                {"TimeIntervalDisabled", "Les périodes multiples ne sont pas activées." },
                {"TimeIntervalMissingTimePeriod", "Erreur de syntaxe ! /nd add <nom de la période que la porte doit utiliser>"},
                {"TimeIntervalNotFound", "Impossible de trouver une période avec ce nom '{0}'"},
                {"HowTo26Hour", "Pour créer une période incluant 2 jours différents, comme (22:00 - 02:00), ajouter 24 à la dernière valeur (22:00 - 26:00)" },
                {"HowToUseTimeIntervals", "Pour cr  éer une periode saisir <color=silver>/timeperiod create <nom de la période> <HH:mm> (heure de début) <HH:mm> (heure de fin)</color>\nPour supprimer une période saisir <color=silver>/timeperiod remove <nom></color>\nPour obtenir une liste de toutes les périodes saisir <color=silver>/timeperiod list</color>"},
                //Messages for /nd
                {"NoEntity", "Vous ne regardez pas d'entité valide" },
                {"EntityNotDoor", "L'entité que vous regardez n'est pas ouvrable" },
                {"NoLockedEnts", "Aucune entité avec période trouvée"},
                {"ShowingEnts", "Affiche toutes les entités avec période"},
                { "SyntaxError", "Erreur de syntaxe ! Saisir /nd help pour plus d'information"},
                {"DoorNowLocked", "Cette {0} est maintenant sous la période (temps par défaut)"},
                {"DoorCustomLocked", "Cette {0} est maintenant sous la période ('{1}' ({2} - {3})"},
                {"NotTimeLocked", "Cette {0} n'est pas restreinte à une période"},
                {"AlreadyLocked", "Cette {0} est déjà restreint à une période"},
                {"DoorUnlocked", "Cette {0} n'est plus restreinte à une période"},
                {"InfoAboutDoor", "Cette {0} est maintenant sous période\nLa période est {1} ({2} - {3})"},
                {"ListOfCommands", "Liste des commandes :\n<color=silver>*Vous devez être en train de regarder une porte/trappe/porche pour que la plupart de ces commandes*</color>\n<color=silver>/nd add</color> - Rend l'entité ouvrable uniquement pendant la période par défaut (voir config)\n<color=silver>/nd add <periode></color> Rend l'entité ouvrable uniquement pendant la période spécifiée (/timeperiod)\n<color=silver>/nd remove</color> Rend l'entité à son état 'normal' (ouvrable a tout moment)\n<color=silver>/nd show</color> Affiche toutes les entités sous période\n<color=silver>/nd info</color> Affiche si la porte/trappe/porche est sous période et informe sur la période le cas échéant\nPériode actuelle : {0} - {1}"}
            }, this, "fr");

            lang.RegisterMessages(new Dictionary<string, string>()
            {
                //Default messages
                {"ServerWiped", "Server wipe detected, wiping data file"},
                {"WipeManual", "Manually wiped Night Door data file"},
                {"Warning_StartBiggerThanEnd", "Config seems to be set up incorrectly! (Start time value is bigger than end time value)"},
                {"Warning_DefaultConfig", "Detected 00:00 as both end and start time! Change these to values you want"},
                {"NoPermission", "You don't have permission to use this command"},
                //Player messages
                {"PlayerCannotOpen", "This {0} cannot be opened."},
                {"PlayerCannotOpenTime", "This {0} cannot be opened until {1}"},
                {"PlayerCannotPlace", "A lock cannot be placed on this {0}"},           
                //Messages for /timeperiod
                {"TimeIntervalRemovedDoor", "Door at {0} can now be opened at any time because the time period got removed!"},
                {"TimeIntevalSyntax", "Wrong syntax! <color=silver>/timeperiod create <name> <HH:mm>(starting time) <HH:mm>(ending time)</color>"},
                {"TimeIntervalRemoveSyntax", "Wrong syntax! <color=silver>/timeperiod remove <name></color>"},
                {"TimeIntervalCreated", "Created a new time period with name '{0}' ({1} - {2})"},
                {"TimeIntervalRemoved", "Removed a time period with name '{0}'"},
                {"TimeIntervalNotSetUp", "There are no time periods set up"},
                {"TimeIntervalList", "List of all time periods: \n{0}"},
                {"TimeIntervalExists", "A time period with that name already exists"},
                {"TimeIntervalDisabled", "Multiple time intervals are disabled." },
                {"TimeIntervalMissingTimePeriod", "Wrong syntax! /nd add <name of time period the door will use>"},
                {"TimeIntervalNotFound", "Couldn't find a time period with name '{0}'"},
                {"HowTo26Hour", "To create time periods that includes 2 days, like 22:00 - 02:00 add 24 to the last value (22:00 - 26:00)" },
                {"HowToUseTimeIntervals", "To create a time period type <color=silver>/timeperiod create <name of time period> <HH:mm> (starting time) <HH:mm> (ending time)</color>\nTo delete a time period type <color=silver>/timeperiod remove <name></color>\nFor list of all time periods type <color=silver>/timeperiod list</color>"},
                //Messages for /nd
                {"NoEntity", "You are not looking at an entity" },
                {"EntityNotDoor", "The entity you are looking at is not openable" },
                {"NoLockedEnts", "No time locked entites found"},
                {"ShowingEnts", "Showing all time locked entites"},
                { "SyntaxError", "Wrong syntax! Type /nd help for more info"},
                {"DoorNowLocked", "This {0} is now time locked (default time)"},
                {"DoorCustomLocked", "This {0} is now time locked (Time period '{1}' ({2} - {3})"},
                {"NotTimeLocked", "This {0} isn't time locked"},
                {"AlreadyLocked", "This {0} is already time locked"},
                {"DoorUnlocked", "This {0} is not time locked anymore"},
                {"InfoAboutDoor", "This {0} is time locked\nTime period is {1} ({2} - {3})"},
                {"ListOfCommands", "List of commands:\n<color=silver>*You have to look at the door/hatch/gate for most of the commands to work*</color>\n<color=silver>/nd add</color> - Makes the entity openable only during default time period(config time)\n<color=silver>/nd add <time period></color> Makes the entity openable only during specified time period (/timeperiod)\n<color=silver>/nd remove</color> Makes the entity 'normal' again (openable at any time)\n<color=silver>/nd show</color> shows all time locked entites\n<color=silver>/nd info</color> shows if the door/hatch/gate is time locked and the time period if it is\nCurrent time period: {0} - {1}"}
            }, this, "en");
        }

        private T GetConfig<T>(string name, T defaultValue)
        {
            if (Config[name] == null) return defaultValue;
            return (T)Convert.ChangeType(Config[name], typeof(T));
        }

        #endregion
        #region DataFile

        private class StoredData
        {
            public Dictionary<uint, string> IDlist = new Dictionary<uint, string>();
            public HashSet<TimeInfo> TimeEntries = new HashSet<TimeInfo>();

            public StoredData()
            {
            }
        }

        private class TimeInfo
        {
            public string name;
            public string start;
            public string end;

            public TimeInfo(string nameIn, string startInput, string endInput)
            {
                name = nameIn;
                start = startInput;
                end = endInput;
            }
        }

        private StoredData storedData;

        #endregion
        #region Hooks

        private void OnNewSave(string filename)
        {
            PrintWarning(lang.GetMessage("ServerWiped", this));
            storedData.IDlist.Clear();
            SaveFile();
        }

        private void OnServerInitialized()
        {
            timer.In(10f, () =>
            {
                intialized = true;
            });
            Repeat();
            DoDefaultT();
        }

        private void Init()
        {
            LoadDefaultConfig();
            permission.RegisterPermission(usePerm, this);
            permission.RegisterPermission(createIntervalPerm, this);
            permission.RegisterPermission(bypassPerm, this);
            storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>("NightDoor_NEW");
            if (GetDateTime(startTime) > GetDateTime(endTime)) PrintWarning(lang.GetMessage("Warning_StartBiggerThanEnd", this));
            if (startTime == "00:00" && endTime == "00:00") PrintWarning(lang.GetMessage("Warning_DefaultConfig", this));
        }

        private void SaveFile() => Interface.Oxide.DataFileSystem.WriteObject("NightDoor_NEW", storedData);

        private void Unload() => SaveFile();

        private void OnServerSave() => CheckAllEntites();

        private void OnEntityKill(BaseNetworkable entity) => CheckAllEntites();

        private void OnDoorOpened(Door door, BasePlayer player)
        {
            BaseEntity doorEnt = door.GetEntity();
            if (doorEnt == null) return;

            string name = GetNameFromEntity(doorEnt);
            uint entID = doorEnt.net.ID;
            if (storedData.IDlist.ContainsKey(door.net.ID))
            {
                float time = ConVar.Env.time;
                if (CanOpen(player, entID, time)) return;
                door.CloseRequest();

                string entname = storedData.IDlist[entID];

                foreach (var entry in storedData.TimeEntries)
                {
                    if (entry.name == entname)
                    {
                        if (hideTime)
                        {
                            SendReply(player, lang.GetMessage("PlayerCannotOpen", this, player.UserIDString), name);
                            return;
                        }

                        SendReply(player, lang.GetMessage("PlayerCannotOpenTime", this, player.UserIDString), name, entry.start);
                        return;
                    }
                }
                return;
            }
        }

        private void OnItemDeployed(Deployer deployer, BaseEntity entity)
        {
            if (entity == null || deployer == null) return;

            BasePlayer player = deployer?.GetOwnerPlayer();
            string item = GetNameFromEntity(entity);

            if (entity is Door)
            {
                BaseEntity codelockent = entity?.GetSlot(BaseEntity.Slot.Lock);

                if (storedData.IDlist.ContainsKey(entity.net.ID))
                {
                    Item codelock;
                    if (codelockent?.PrefabName == "assets/prefabs/locks/keypad/lock.code.prefab") codelock = ItemManager.CreateByName("lock.code", 1);
                    else codelock = ItemManager.CreateByName("lock.key", 1);

                    if (codelock != null)
                    {
                        player.GiveItem(codelock);
                        SendReply(player, lang.GetMessage("PlayerCannotPlace", this, player.UserIDString), item);
                    }
                    codelockent?.KillMessage();
                    return;
                }
            }
        }

        private object CanPickupEntity(BaseCombatEntity entity, BasePlayer player)
        {
            if (entity == null) return null;
            if (storedData.IDlist.ContainsKey(entity.net.ID)) return true;
            return null;
        }

        #endregion
        #region stuff
        private string GetNameFromEntity(BaseEntity entity)
        {
            Dictionary<string, string> EntList = new Dictionary<string, string> {
                {"door.hinged.toptier", "Armored Door" },
                {"gates.external.high.wood", "High External Wooden Gate" },
                {"gates.external.high.stone", "High External Stone Gate" },
                {"wall.frame.shopfront", "Shop Front" },
                {"wall.frame.garagedoor", "Garage Door" },
                {"shutter.wood.a", "Wood Shutters" },
                {"floor.ladder.hatch", "Ladder Hatch" },
                {"wall.frame.cell.gate", "Prison Cell Gate" },
                {"wall.frame.fence.gate", "Chainlink Fence Gate" },
                {"door.double.hinged.wood", "Wood Double Door" },
                {"door.double.hinged.toptier", "Armored Double Door" },
                {"door.double.hinged.metal", "Sheet Metal Double Door" },
                {"door.hinged.metal", "Sheet Metal Door" }
            };

            string itemName = "entity";

            if (EntList.ContainsKey(entity?.ShortPrefabName))
                itemName = EntList[entity?.ShortPrefabName];

            return itemName;
        }
        private void Repeat()
        {
            timer.Every(5f, () => {
                CheckDoors();
                CheckAllEntites();
            });
        }

        private void DoDefaultT()
        {
            timer.Once(1f, () => {
                foreach (var entry in storedData.TimeEntries)
                {
                    if (entry.name == "default")
                    {
                        entry.start = startTime;
                        entry.end = endTime;
                        SaveFile();
                        return;
                    }
                }
                
                var cfgTime = new TimeInfo("default", startTime, endTime);
                storedData.TimeEntries.Add(cfgTime);
                SaveFile();
                return;
            });
        }

        private void CheckDoors()
        {
            if (!AutoDoor) return;

            float time = ConVar.Env.time;

            if (storedData.IDlist.Count == 0) return;

            foreach (var entry in storedData.IDlist.ToList())
            {
                BaseEntity ent = BaseNetworkable.serverEntities.Find(entry.Key) as BaseEntity;

                if (ent == null || ent.IsDestroyed) continue;

                if (CanOpen(null, ent.net.ID, time))
                {
                    ent.SetFlag(BaseEntity.Flags.Open, true);
                    ent.SendNetworkUpdateImmediate();
                }

                else
                {
                    ent.SetFlag(BaseEntity.Flags.Open, false);
                    ent.SendNetworkUpdateImmediate();
                }
            }
        }

        private bool CanOpen(BasePlayer player, uint ID, float now)
        {
            if (player != null)
            {
                if (player.IsAdmin && BypassAdmin) return true;
                if (permission.UserHasPermission(player.UserIDString, bypassPerm) && BypassPerm) return true;
            }

            if (UseRealTime)
            {
                foreach (var entry in storedData.IDlist)
                {
                    if (entry.Key == ID)
                    {
                        foreach (var ent in storedData.TimeEntries)
                        {
                            if (ent.name == entry.Value)
                            {
                                string ending = ent.end;
                                int valInt = int.Parse(ending.Split(':')[0]);
                                if (valInt > 24)
                                {
                                    DateTime start_changed = GetDateTime(ID, true);
                                    DateTime end_changed = GetDateTime(ID, false);
                                    start_changed = start_changed.AddDays(-1);
                                    end_changed = end_changed.AddDays(-1);
                                    if ((DateTime.Now >= start_changed) && (DateTime.Now <= end_changed)) return true;
                                    return false;
                                }

                                else
                                {
                                    DateTime start = GetDateTime(ID, true);
                                    DateTime end = GetDateTime(ID, false);
                                    if ((DateTime.Now >= start) && (DateTime.Now <= end)) return true;
                                    return false;
                                }
                            }
                        }
                    }
                }
            }

            //wtf is this even
            float a = GetFloat(ID, true);
            float b = GetFloat(ID, false);
            float c = b - 24f;
            if (c < 0) c = 99999f;
            if (now >= a && now <= b) return true;
            if (c != 99999f)
            {
                if (now >= 0f && now <= c) return true;
            }

            return false;
        }

        private void CheckAllEntites()
        {
            if (!intialized || storedData.IDlist.Count == 0) return;

            foreach (var entry in storedData.IDlist.ToList())
            {
                BaseNetworkable ent = BaseNetworkable.serverEntities.Find(entry.Key) ?? null;

                if (ent == null || ent.IsDestroyed)
                {
                    storedData.IDlist.Remove(entry.Key);
                    SaveFile();
                }
            }   
        }

        private float GetFloat(uint ID, bool start)
        {
            string input = "";
            foreach (var entry in storedData.TimeEntries)
            {
                if (entry.name == storedData.IDlist[ID])
                {
                    if (start) input = entry.start;
                    else input = entry.end;
                }
            }

            string[] parts = input.Split(':');
            int hourInt = int.Parse(parts[0]);
            int minInt = int.Parse(parts[1]);

            float min = (float)minInt / 60;

            return (hourInt + min);
        }

        private float GetFloat(string in2)
        {
            string[] parts = in2.Split(':');
            string h = "", m = "";
            int hourInt = int.Parse(parts[0]);
            int minInt = int.Parse(parts[1]);

            float min = (float)minInt / 60;
            return (hourInt + min);
        }

        private DateTime GetDateTime(uint ID, bool start)
        {
            DateTime final = new DateTime(DateTime.Now.Year, DateTime.Now.Month, DateTime.Now.Day, 0, 0, 0);
            string input = "";
            foreach (var entry in storedData.TimeEntries)
            {
                if (entry.name == storedData.IDlist[ID])
                {
                    if (start) input = entry.start;
                    else input = entry.end;
                }
            }

            string[] parts = input.Split(':');
            int mInt = int.Parse(parts[1]);
            int hInt = int.Parse(parts[0]);

            if (hInt > 24 && start)
            {
                final = final.AddHours(hInt);
                final = final.AddMinutes(mInt);
                final = final.AddDays(-1);
                return final;
            }

            final = final.AddHours(hInt);
            final = final.AddMinutes(mInt);
            return final;
        }

        private DateTime GetDateTime(string input)
        {
            DateTime final = new DateTime(DateTime.Now.Year, DateTime.Now.Month, DateTime.Now.Day, 0, 0, 0);
            string[] parts = input.Split(':');
            int mInt = int.Parse(parts[1]);
            int hInt = int.Parse(parts[0]);
            final = final.AddHours(hInt);
            final = final.AddMinutes(mInt);
            return final;
        }

        private BaseEntity GetLookAtEntity(BasePlayer player, float maxDist = 250, int coll = -1)
        {
            if (player == null || player.IsDead()) return null;
            RaycastHit hit;
            var currentRot = Quaternion.Euler(player?.serverInput?.current?.aimAngles ?? Vector3.zero) * Vector3.forward;
            var ray = new Ray((player?.eyes?.position ?? Vector3.zero), currentRot);
            if (Physics.Raycast(ray, out hit, maxDist))
            {
                var ent = hit.GetEntity() ?? null;
                if (ent != null && !(ent?.IsDestroyed ?? true)) return ent;
            }
            return null;
        }

        #endregion
        #region commands

        [ConsoleCommand("wipedoordata")]
        private void nightdoorwipeccmd(ConsoleSystem.Arg arg)
        {
            if (arg.Connection != null) return;
            storedData.IDlist.Clear();
            storedData.TimeEntries.Clear();
            SaveFile();
            Puts(lang.GetMessage("WipeManual", this));
        }

        [ChatCommand("timeperiod")]
        private void timeCmd(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, createIntervalPerm))
            {
                SendReply(player, lang.GetMessage("NoPermission", this, player.UserIDString));
                return;
            }

            if (!useMulti)
            {
                SendReply(player, lang.GetMessage("TimeIntervalDisabled", this, player.UserIDString));
                return;
            }

            if (args.Length < 1)
            {
                SendReply(player, lang.GetMessage("HowToUseTimeIntervals", this, player.UserIDString));
                return;
            }

            switch (args[0].ToLower())
            {
                case "create":
                    {
                        if (args.Length < 4)
                        {
                            SendReply(player, lang.GetMessage("TimeIntevalSyntax", this, player.UserIDString));
                            return;
                        }

                        string Inputname = args[1];
                        string time1 = args[2];
                        string time2 = args[3];

                        foreach (var timeEntry in storedData.TimeEntries)
                        {
                            if (timeEntry.name.ToLower() == Inputname.ToLower())
                            {
                                SendReply(player, lang.GetMessage("TimeIntervalExists", this, player.UserIDString));
                                return;
                            }
                        }

                        //Most complicated methods VVVVV

                        if (!time1.Contains(":") && !time2.Contains(":"))
                        {
                            SendReply(player, lang.GetMessage("TimeIntevalSyntax", this, player.UserIDString));
                            return;
                        }

                        string[] split1, split2;
                        split2 = time2.Split(':');
                        split1 = time1.Split(':');
                        string[] allNumbers = { split1[0], split1[1], split2[0], split2[1] };
                        foreach (string p in allNumbers)
                        {
                            foreach (var ew in p)
                            {
                                if (ew == '0' || ew == '1' || ew == '2' || ew == '3' || ew == '4' || ew == '5' || ew == '6' || ew == '7' || ew == '8' || ew == '9') continue;

                                else
                                {
                                    SendReply(player, lang.GetMessage("TimeIntevalSyntax", this, player.UserIDString));
                                    return;
                                }
                            }

                            if (p.Length != 2)
                            {
                                SendReply(player, lang.GetMessage("TimeIntevalSyntax", this, player.UserIDString));
                                return;
                            }
                        }

                        float a = GetFloat(time1);
                        float b = GetFloat(time2);

                        if (a > b)
                        {
                            SendReply(player, lang.GetMessage("HowTo26Hour", this, player.UserIDString));
                            return;
                        }

                        TimeInfo entry = new TimeInfo(Inputname, time1, time2);
                        storedData.TimeEntries.Add(entry);
                        SendReply(player, lang.GetMessage("TimeIntervalCreated", this, player.UserIDString), Inputname, time1, time2);
                        SaveFile();
                        return;
                    }

                case "remove":
                    {
                        if (args.Length < 2)
                        {
                            SendReply(player, lang.GetMessage("TimeIntervalRemoveSyntax", this, player.UserIDString));
                            return;
                        }

                        string Inputname = args[1];
                        List<TimeInfo> toRemove = new List<TimeInfo>();
                        List<uint> idList = new List<uint>();

                        foreach (var entry in storedData.TimeEntries)
                        {
                            if (entry.name == Inputname && entry.name != "default")
                            {
                                toRemove.Add(entry);
                                foreach (var ent in storedData.IDlist)
                                {
                                    if (ent.Value == Inputname)
                                    {
                                        idList.Add(ent.Key);
                                        BaseNetworkable entity = BaseNetworkable.serverEntities.Find(ent.Key);
                                        SendReply(player, lang.GetMessage("TimeIntervalRemovedDoor", this, player.UserIDString), entity.transform.position.ToString());
                                        player.SendConsoleCommand("ddraw.sphere", 10f, Color.green, entity.transform.position, 1f);
                                    }
                                }

                                SendReply(player, lang.GetMessage("TimeIntervalRemoved", this, player.UserIDString), entry.name);
                                foreach (var ent2 in toRemove) storedData.TimeEntries.Remove(ent2);
                                foreach (var ent3 in idList) storedData.IDlist.Remove(ent3);
                                SaveFile();
                                return;
                            }
                        }
                        SendReply(player, lang.GetMessage("TimeIntervalNotFound", this, player.UserIDString), Inputname);
                        return;
                    }

                case "list":
                    {
                        List<string> L = new List<string>();
                        if (storedData.TimeEntries.Count < 1)
                        {
                            SendReply(player, lang.GetMessage("TimeIntervalNotSetUp", this, player.UserIDString));
                            return;
                        }

                        foreach (var entry in storedData.TimeEntries)
                            L.Add(entry.name + " (" + entry.start + " - " + entry.end + ")");

                        string finished = string.Join("\n", L.ToArray());
                        SendReply(player, lang.GetMessage("TimeIntervalList", this, player.UserIDString), finished);
                        return;
                    }

                default:
                    {
                        SendReply(player, lang.GetMessage("TimeIntevalSyntax", this, player.UserIDString));
                        return;
                    }
            }

        }

        [ChatCommand("nd")]
        private void nightdoorcmd(BasePlayer player, string command, string[] args)
        {
            if (!permission.UserHasPermission(player.UserIDString, usePerm))
            {
                SendReply(player, lang.GetMessage("NoPermission", this, player.UserIDString));
                return;
            }

            if (args.Length < 1)
            {
                SendReply(player, lang.GetMessage("SyntaxError", this, player.UserIDString));
                return;
            }

            BaseEntity ent = GetLookAtEntity(player, 10f);  

            string name = GetNameFromEntity(ent);
            Puts(name);
            switch (args[0].ToLower())
            {
                case "add":
                    {
                        if (ent == null)
                        {
                            SendReply(player, lang.GetMessage("NoEntity", this, player.UserIDString));
                            return;
                        }

                        if (!(ent is Door))
                        {
                            SendReply(player, lang.GetMessage("EntityNotDoor", this, player.UserIDString));
                            return;
                        }

                        if (storedData.IDlist.ContainsKey(ent.net.ID))
                        {
                            SendReply(player, lang.GetMessage("AlreadyLocked", this, player.UserIDString), name);
                            return;
                        }

                        if (args.Length < 2)
                        {
                            storedData.IDlist.Add(ent.net.ID, "default");
                            SendReply(player, lang.GetMessage("DoorNowLocked", this, player.UserIDString), name);
                            SaveFile();
                            return;
                        }

                        string tiName = args[1];
                        if (string.IsNullOrEmpty(tiName))
                        {
                            SendReply(player, lang.GetMessage("TimeIntervalMissingTimePeriod", this, player.UserIDString));
                            return;
                        }

                        foreach (var entry in storedData.TimeEntries)
                        {
                            if (entry.name.ToLower() == tiName.ToLower())
                            {
                                storedData.IDlist.Add(ent.net.ID, entry.name);
                                SendReply(player, lang.GetMessage("DoorCustomLocked", this, player.UserIDString), name, entry.name, entry.start, entry.end);
                                SaveFile();
                                return;
                            }
                        }
                        SendReply(player, lang.GetMessage("TimeIntervalNotFound", this, player.UserIDString), tiName);
                        return;
                    }

                case "remove":
                    {
                        if (ent == null)
                        {
                            SendReply(player, lang.GetMessage("NoEntity", this, player.UserIDString));
                            return;
                        }

                        if (!(ent is Door))
                        {
                            SendReply(player, lang.GetMessage("EntityNotDoor", this, player.UserIDString));
                            return;
                        }

                        if (!storedData.IDlist.ContainsKey(ent.net.ID))
                        {
                            SendReply(player, lang.GetMessage("NotTimeLocked", this, player.UserIDString), name);
                            return;
                        }

                        storedData.IDlist.Remove(ent.net.ID);
                        SendReply(player, lang.GetMessage("DoorUnlocked", this, player.UserIDString), name);
                        SaveFile();
                        return;
                    }

                case "info":
                    {
                        if (ent == null)
                        {
                            SendReply(player, lang.GetMessage("NoEntity", this, player.UserIDString));
                            return;
                        }

                        if (!(ent is Door))
                        {
                            SendReply(player, lang.GetMessage("EntityNotDoor", this, player.UserIDString));
                            return;
                        }

                        if (!storedData.IDlist.ContainsKey(ent.net.ID))
                        {
                            SendReply(player, lang.GetMessage("NotTimeLocked", this, player.UserIDString), name);
                            return;
                        }

                        string type = storedData.IDlist[ent.net.ID];
                        string start = "", end = "";

                        if (type == "default")
                        {
                            string p1, p2, p3, p4;
                            p1 = (GetDateTime(startTime).Hour.ToString() == "0") ? "00" : GetDateTime(startTime).Hour.ToString();
                            p2 = (GetDateTime(startTime).Minute.ToString() == "0") ? "00" : GetDateTime(startTime).Minute.ToString();
                            p3 = (GetDateTime(endTime).Hour.ToString() == "0") ? "00" : GetDateTime(endTime).Hour.ToString();
                            p4 = (GetDateTime(endTime).Minute.ToString() == "0") ? "00" : GetDateTime(endTime).Minute.ToString();
                            start = p1 + ":" + p2;
                            end = p3 + ":" + p4;
                            SendReply(player, lang.GetMessage("InfoAboutDoor", this, player.UserIDString), name, type, start, end);
                            return;
                        }

                        foreach (var entry in storedData.TimeEntries)
                        {
                            if (entry.name == type)
                            {
                                start = entry.start;
                                end = entry.end;
                            }
                        }

                        SendReply(player, lang.GetMessage("InfoAboutDoor", this, player.UserIDString), name, type, start, end);
                        return;
                    }

                case "show":
                    {
                        if (storedData.IDlist.Count == 0)
                        {
                            SendReply(player, lang.GetMessage("NoLockedEnts", this, player.UserIDString));
                            return;
                        }

                        SendReply(player, lang.GetMessage("ShowingEnts", this, player.UserIDString));
                        foreach (var entry in storedData.IDlist)
                        {
                            BaseNetworkable EntityN = BaseNetworkable.serverEntities.Find(entry.Key);
                            if (EntityN == null)
                            {
                                CheckAllEntites();
                                continue;
                            }
                            Vector3 pos = EntityN.transform.position;
                            pos.y += 1f;
                            player.SendConsoleCommand("ddraw.sphere", 10f, Color.green, pos, 1f);
                        }
                        return;
                    }

                case "help":
                    {
                        string start, end;
                        string p1, p2, p3, p4;
                        p1 = (GetDateTime(startTime).Hour.ToString() == "0") ? "00" : GetDateTime(startTime).Hour.ToString();
                        p2 = (GetDateTime(startTime).Minute.ToString() == "0") ? "00" : GetDateTime(startTime).Minute.ToString();
                        p3 = (GetDateTime(endTime).Hour.ToString() == "0") ? "00" : GetDateTime(endTime).Hour.ToString();
                        p4 = (GetDateTime(endTime).Minute.ToString() == "0") ? "00" : GetDateTime(endTime).Minute.ToString();
                        start = p1 + ":" + p2;
                        end = p3 + ":" + p4;

                        SendReply(player, lang.GetMessage("ListOfCommands", this, player.UserIDString), start, end);
                        return;
                    }

                default:
                    {
                        SendReply(player, lang.GetMessage("SyntaxError", this, player.UserIDString));
                        return;
                    }
            }
        }
        #endregion
    }
}

// --- End of file: NightDoor.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-wounded-suicide ---
// --- Original File Path: N/NoWoundedSuicide/NoWoundedSuicide.cs ---

using UnityEngine;

namespace Oxide.Plugins
{
    [Info("No Wounded Suicide", "Orange", "1.0.1")]
    [Description("Blocks suicide when player is wounded")]
    public class NoWoundedSuicide : RustPlugin
    {
        private object OnServerCommand(ConsoleSystem.Arg arg)
        {
            var player = arg.Player();
            
            if (player == null)
            {
                return null;
            }

            if (arg.cmd?.FullName == "global.kill" && player.IsWounded())
            {
                return true;
            }
            
            return null;
        }
    }
}

// --- End of file: NoWoundedSuicide.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/name-changer ---
// --- Original File Path: N/NameChanger/NameChanger.cs ---

﻿// Requires: Coroutines

using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Name Changer", "birthdates", "1.0.1")]
    [Description("Listen for profile name changes")]
    public class NameChanger : CovalencePlugin
    {
        #region Hooks

        private void OnServerInitialized()
        {
            timer.Every(_config.CheckInterval, CheckProfiles);
        }

        #endregion

        #region Variables

        /// <summary>
        ///     The link for Steam profile's as XML
        /// </summary>
        private const string ProfileURL = "https://steamcommunity.com/profiles/{0}?xml=1";

        /// <summary>
        ///     The regex that captures the name of a XML profile
        /// </summary>
        private Regex NameRegex { get; } = new Regex("(?<=<steamID><!\\[CDATA\\[).*(?=]]>)");

        #endregion

        #region Core Logic

        /// <summary>
        ///     Asynchronously loop through all connected players and check for name changes
        /// </summary>
        private void CheckProfiles()
        {
            var coroutine = Coroutines.Instance.LoopListAsynchronously(this, new Action<IPlayer>(CheckProfile),
                new List<IPlayer>(covalence.Players.Connected), 0.05f, completePerTick: 3, id: "ProfileCheck");
            Coroutines.Instance.StartCoroutine(coroutine);
        }

        /// <summary>
        ///     Asynchronously enqueue a web request to check a player's Steam profile name
        /// </summary>
        /// <param name="player">Target name</param>
        private void CheckProfile(IPlayer player)
        {
            webrequest.Enqueue(string.Format(ProfileURL, player.Id), string.Empty,
                (code, response) => HandleProfile(player, code, response), this);
        }

        /// <summary>
        ///     Handle the web request's response from <see cref="CheckProfile" />
        /// </summary>
        /// <param name="player">Target player</param>
        /// <param name="code">Response code</param>
        /// <param name="response">Response data</param>
        private void HandleProfile(IPlayer player, int code, string response)
        {
            // See if Steam response was valid
            if (code != 200)
            {
                PrintError("Steam servers did not give code 200: {0} ({1})", response, code);
                return;
            }

            // Try match name
            var result = NameRegex.Match(response);
            if (!result.Success)
            {
                PrintError("Failed to retrieve name for: {0} ({1})", player.Name, player.Id);
                return;
            }
            
            // Rename
            var name = result.Value;
            if (player.Name.Equals(name)) return;
            // Notify
            foreach (var target in covalence.Players.Connected)
            {
                var msg = lang.GetMessage("UserNameChanged", this, target.Id);
                if (string.IsNullOrEmpty(msg)) break;
                target.Message(string.Format(msg, player.Name, name));
            }
            player.Rename(name);
            player.Name = name;
        }

        #endregion

        #region Configuration & Localization

        private ConfigFile _config;

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<ConfigFile>();
            if (_config == null) LoadDefaultConfig();
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"UserNameChanged", "{0} has changed their name to {1}"}
            }, this);
        }

        protected override void LoadDefaultConfig()
        {
            _config = ConfigFile.DefaultConfig();
            PrintWarning("Default configuration has been loaded.");
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }

        private class ConfigFile
        {
            [JsonProperty("Check Interval (seconds)")]
            public float CheckInterval { get; set; }

            public static ConfigFile DefaultConfig()
            {
                return new ConfigFile
                {
                    CheckInterval = 30f
                };
            }
        }

        #endregion
    }
}

// --- End of file: NameChanger.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-durability ---
// --- Original File Path: N/NoDurability/NoDurability.cs ---

﻿using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core.Plugins;

namespace Oxide.Plugins
{
    [Info("No Durability", "Wulf/lukespragg/Arainrr", "2.2.5", ResourceId = 1061)]
    public class NoDurability : RustPlugin
    {
        #region Fields

        [PluginReference] private readonly Plugin ZoneManager, DynamicPVP;
        private const string PERMISSION_USE = "nodurability.allowed";

        #endregion Fields

        #region Oxide Hooks

        private void Init() => permission.RegisterPermission(PERMISSION_USE, this);

        private void OnLoseCondition(Item item, ref float amount)
        {
            if (item == null) return;
            if (configData.itemListIsBlackList
                ? configData.itemList.Contains(item.info.shortname)
                : !configData.itemList.Contains(item.info.shortname))
            {
                return;
            }
            var player = item.GetOwnerPlayer() ?? item.GetRootContainer()?.GetOwnerPlayer();
            if (player == null || !permission.UserHasPermission(player.UserIDString, PERMISSION_USE)) return;
            if (configData.useZoneManager && ZoneManager != null)
            {
                var zoneIDs = GetPlayerZoneIDs(player);
                if (zoneIDs != null && zoneIDs.Length > 0)
                {
                    if (configData.excludeAllZone)
                    {
                        return;
                    }
                    if (configData.excludeDynPVPZone && DynamicPVP != null)
                    {
                        foreach (var zoneId in zoneIDs)
                        {
                            if (IsPlayerInZone(zoneId, player) && IsDynamicPVPZone(zoneId))
                            {
                                return;
                            }
                        }
                        return;
                    }

                    foreach (var zoneId in configData.zoneList)
                    {
                        if (IsPlayerInZone(zoneId, player))
                        {
                            return;
                        }
                    }
                }
            }

            amount = 0;
            if (configData.keepMaxDurability)
            {
                item.condition = item.maxCondition;
            }
        }

        #endregion Oxide Hooks

        #region Methods

        private bool IsDynamicPVPZone(string zoneID) => (bool)DynamicPVP.Call("IsDynamicPVPZone", zoneID);

        private bool IsPlayerInZone(string zoneID, BasePlayer player) => (bool)ZoneManager.Call("IsPlayerInZone", zoneID, player);

        private string[] GetPlayerZoneIDs(BasePlayer player) => (string[])ZoneManager.Call("GetPlayerZoneIDs", player);

        #endregion Methods

        #region ConfigurationFile

        private ConfigData configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Use ZoneManager")]
            public bool useZoneManager;

            [JsonProperty(PropertyName = "Keep Max Durability")]
            public bool keepMaxDurability = true;

            [JsonProperty(PropertyName = "Exclude all zone")]
            public bool excludeAllZone;

            [JsonProperty(PropertyName = "Exclude dynamic pvp zone")]
            public bool excludeDynPVPZone;

            [JsonProperty(PropertyName = "Zone exclude list (Zone ID)")]
            public HashSet<string> zoneList = new HashSet<string>();

            [JsonProperty(PropertyName = "Item list (Item short name)")]
            public HashSet<string> itemList = new HashSet<string>();

            [JsonProperty(PropertyName = "Item list is a blacklist? (If false, it's is a whitelist)")]
            public bool itemListIsBlackList = true;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                configData = Config.ReadObject<ConfigData>();
                if (configData == null)
                    LoadDefaultConfig();
            }
            catch (Exception ex)
            {
                PrintError($"The configuration file is corrupted. \n{ex}");
                LoadDefaultConfig();
            }
            SaveConfig();
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            configData = new ConfigData();
        }

        protected override void SaveConfig() => Config.WriteObject(configData);

        #endregion ConfigurationFile
    }
}

// --- End of file: NoDurability.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-tech-tree ---
// --- Original File Path: N/NoTechTree/NoTechTree.cs ---

using System;
using System.Collections.Generic;
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("No Tech Tree", "Sche1sseHund", 1.2)]
    [Description("Allows server owner to disable the use of the tech tree")]

    class NoTechTree: RustPlugin
    {    
    	
        private const string PERMISSION_ALLOWBLOCKBYPASS = "notechtree.bypass";		
        
        private void Init()
		{
			permission.RegisterPermission(PERMISSION_ALLOWBLOCKBYPASS, this);
			
		}       
		private object CanUnlockTechTreeNode(BasePlayer player, TechTreeData.NodeInstance node, TechTreeData techTree)
        {      	
            
        	if(permission.UserHasPermission(player.UserIDString, PERMISSION_ALLOWBLOCKBYPASS))
        		return null;             	                
				
			PrintToChat(player, lang.GetMessage("NoTechTree", this, player.UserIDString));                 
            return false;
        }
        
        
      
		protected override void LoadDefaultMessages()
		{
			// English
			lang.RegisterMessages(new Dictionary<string, string>
			{
				["NoTechTree"] = "The Tech Tree has been disabled.",				
			}, this, "en");
            
            // Espanol
			lang.RegisterMessages(new Dictionary<string, string>
			{
				["NoTechTree"] = "El ÃƒÆ’Ã‚Â¡rbol tecnolÃƒÆ’Ã‚Â³gico se ha desactivado",				
			}, this, "es");
            
            // Deutsch
			lang.RegisterMessages(new Dictionary<string, string>
			{
				["NoTechTree"] = "Der Forschungsbaum wurde deaktiviert.",				
			}, this, "de");
		}
        
    }
    
}
        

// --- End of file: NoTechTree.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-vood ---
// --- Original File Path: N/NoVood/NoVood.cs ---

﻿using System;
using Oxide.Core;
using Newtonsoft.Json;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("NoVood", "Sapnu Puas#3696", "1.0.4")]
    [Description("use furnaces with no wood and quick smelt options, by permission")]
    public class NoVood : RustPlugin
    {
        
        private void Init()
        {
            foreach (var entry in config.Permissions)
            {
                permission.RegisterPermission(entry.Key, this);
            }
        }

        private void OnServerInitialized()
        {
            config = Config.ReadObject<Configuration>();
            Config.WriteObject(config);
        }
        
        private object OnFindBurnable(BaseOven oven)
        {
            if (oven == null || oven.net == null) return null;

            string Permission = "";
            foreach (var check in config.Permissions)
            {
                if (permission.UserHasPermission(oven.OwnerID.ToString(), check.Key))
                {
                    Permission = check.Key;
                }
            }
            if (string.IsNullOrEmpty(Permission)) return null;
            

            var playerPermission = config.Permissions[Permission];
            FurnaceSetup configValue = null;
            
           if (playerPermission.furnaceSettings.ContainsKey(oven.ShortPrefabName))
                configValue = playerPermission.furnaceSettings[oven.ShortPrefabName];
            
             if (configValue != null)
            {
                bool usenowood = configValue.UseNoWood;
                bool raw = configValue.NeedRes;
                if (!string.IsNullOrEmpty(oven.ShortPrefabName))
                {
                    foreach (var check in oven.inventory.itemList)
                        if (check.info.shortname.Contains("wood"))
                            return null;

                    if (usenowood)
                    {
                        var fuel = ItemManager.CreateByItemID(-151838493);

                        if (!raw)
                        {
                            return fuel;
                        }

                        foreach (var check in oven.inventory.itemList)

                            if (config.AllowedRes.Contains(check.info.shortname))
                            {
                                return fuel;
                            }
                        return null;
                    }
                }
            }
            return null;
        }

        void OnOvenToggle(BaseOven oven, BasePlayer player)
        {
            if (oven == null || oven.IsDestroyed) return;
            string Permission = "";
            foreach (var check in config.Permissions)
            {
                if (permission.UserHasPermission(oven.OwnerID.ToString(), check.Key))
                {
                    Permission = check.Key;
                }
            }
            if (string.IsNullOrEmpty(Permission)) return;

            var playerPermission = config.Permissions[Permission];
            FurnaceSetup configValue = null;

            if (playerPermission.furnaceSettings.ContainsKey(oven.ShortPrefabName))
                configValue = playerPermission.furnaceSettings[oven.ShortPrefabName];

            if (configValue != null)
            {
                int ovenspeed = configValue.Speed;
                NextTick(() =>
                {
                    if (!string.IsNullOrEmpty(oven.ShortPrefabName))
                    {
                        if (!oven.HasFlag(BaseEntity.Flags.On))
                            NextTick(() =>
                            {
                                NextTick(oven.StopCooking);
                            });
                        else
                        {
                            var ovenCookingTemperature = 10 / (0.5 * (oven.cookingTemperature / 200));
                            var speed = 0.5f / ovenspeed;
                            oven.CancelInvoke(oven.Cook);
                            oven.inventory.temperature = (float)ovenCookingTemperature;
                            //oven.inventory.temperature = oven.cookingTemperature;
                            oven.UpdateAttachmentTemperature();
                            oven.InvokeRepeating(oven.Cook, speed, speed);
                            return;
                        }
                    }
                    return;
                });
            }
        }

        #region Config
        private Configuration config;
        protected override void LoadDefaultConfig()
        {
            Config.WriteObject(config = new Configuration()
            {
                Permissions = new Dictionary<string, Ovens>()
                {
                    [$"{Name}.vip"] = new Ovens()
                    {
                        furnaceSettings = new Dictionary<string, FurnaceSetup>()
                        {
                            ["furnace"] = new FurnaceSetup()
                            {
                                UseNoWood = false,
                                NeedRes = true,
                                Speed = 3
                            },
                            ["furnace.large"] = new FurnaceSetup
                            {
                                UseNoWood = false,
                                NeedRes = true,
                                Speed = 3
                            },
                            ["refinery_small_deployed"] = new FurnaceSetup
                            {
                                UseNoWood = false,
                                NeedRes = true,
                                Speed = 3
                            }
                           
                        }
                    },
                    [$"{Name}.vip+"] = new Ovens()
                    {
                        furnaceSettings = new Dictionary<string, FurnaceSetup>()
                        {
                            ["furnace"] = new FurnaceSetup()
                            {
                                UseNoWood = false,
                                NeedRes = true,
                                Speed = 5
                            },
                            ["furnace.large"] = new FurnaceSetup
                            {
                                UseNoWood = false,
                                NeedRes = true,
                                Speed = 5
                            },
                            ["refinery_small_deployed"] = new FurnaceSetup
                            {
                                UseNoWood = false,
                                NeedRes = true,
                                Speed = 5
                            },
                            ["bbq.deployed"] = new FurnaceSetup
                            {
                                UseNoWood = false,
                                NeedRes = true,
                                Speed = 5
                            }
                            
                        }
                    },
                    [$"{Name}.vip++"] = new Ovens()
                    {
                        furnaceSettings = new Dictionary<string, FurnaceSetup>()
                        {
                            ["furnace"] = new FurnaceSetup()
                            {
                                UseNoWood = true,
                                NeedRes = true,
                                Speed = 10
                            },
                            ["furnace.large"] = new FurnaceSetup
                            {
                                UseNoWood = true,
                                NeedRes = true,
                                Speed = 10
                            },
                            ["refinery_small_deployed"] = new FurnaceSetup
                            {
                                UseNoWood = true,
                                NeedRes = true,
                                Speed = 10
                            },
                            ["bbq.deployed"] = new FurnaceSetup
                            {
                                UseNoWood = true,
                                NeedRes = true,
                                Speed = 10
                            },


                            ["carvable.pumpkin"] = new FurnaceSetup
                            {
                                UseNoWood = true,
                                NeedRes = false,
                                Speed = 1
                            },
                            ["chineselantern.deployed"] = new FurnaceSetup
                            {
                                UseNoWood = true,
                                NeedRes = false,
                                Speed = 1
                            },
                            ["jackolantern.angry"] = new FurnaceSetup
                            {
                                UseNoWood = true,
                                NeedRes = false,
                                Speed = 1
                            },
                            ["jackolantern.happy"] = new FurnaceSetup
                            {
                                UseNoWood = true,
                                NeedRes = false,
                                Speed = 1
                            },
                            ["lantern.deployed"] = new FurnaceSetup
                            {
                                UseNoWood = true,
                                NeedRes = false,
                                Speed = 1
                            },
                            ["tunalight.deployed"] = new FurnaceSetup
                            {
                                UseNoWood = true,
                                NeedRes = false,
                                Speed = 1
                            },
                            
                            ["campfire"] = new FurnaceSetup
                            {
                                UseNoWood = true,
                                NeedRes = false,
                                Speed = 1
                            },
                            ["fireplace.deployed"] = new FurnaceSetup
                            {
                                UseNoWood = true,
                                NeedRes = false,
                                Speed = 1
                            },
                            ["hobobarrel.deployed"] = new FurnaceSetup
                            {
                                UseNoWood = true,
                                NeedRes = false,
                                Speed = 1
                            },
                            ["skull_fire_pit"] = new FurnaceSetup
                            {
                                UseNoWood = true,
                                NeedRes = false,
                                Speed = 1
                            }
                        }
                    },
                }
            }, true);
        }
        public class Configuration
        {
           [JsonProperty("Permissions", ObjectCreationHandling = ObjectCreationHandling.Replace)]
             public Dictionary<string, Ovens> Permissions = new Dictionary<string, Ovens>();

           [JsonProperty("Allowed Resources (Item Shortnames) items must be in this list to use without wood")]
           public HashSet<string> AllowedRes = new HashSet<string>()
            {
                { "metal.ore" },
                { "hq.metal.ore" },
                { "sulfur.ore" },
                { "crude.oil"},
                { "bearmeat" },
                { "chicken.raw" },
                { "horsemeat.raw" },
                { "meat.boar" },
                {"wolfmeat.raw" },
                { "deermeat.raw" },
                { "fish.raw"},
                {"humanmeat.raw" }
            };

        }

        public class Ovens
        {
            [JsonProperty("base oven short prefab name and settings")]
            public Dictionary<string, FurnaceSetup> furnaceSettings { get; set; }
        }

        public class FurnaceSetup
        {
            [JsonProperty("Uses no fuel ?")]
            public bool UseNoWood { get; set; }

            [JsonProperty("Require raw resources to start when using no fuel ?")]
            public bool NeedRes { get; set; }

            [JsonProperty("Quicksmelt speed (1 is default speed)")]
            public int Speed { get; set; }

        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                config = Config.ReadObject<Configuration>();
                if (config == null) throw new Exception();
                SaveConfig();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }
        protected override void SaveConfig() => Config.WriteObject(config);
        #endregion

    }
}


// --- End of file: NoVood.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/daynight-message ---
// --- Original File Path: N/NightMessage/NightMessage.cs ---

﻿//confirmed working with Hurtworld ItemV2, ROK, Rust, 7DaystoDie
using System;
using System.Collections.Generic;
using System.Linq;

namespace Oxide.Plugins
{
    [Info("NightMessage", "Mordeus", "1.0.1")]
    [Description("Universal Day/Night Message")]
    public class NightMessage : CovalencePlugin
    {
        public bool NightMessageSent = false;
        public bool DayMessageSent = false;
        //config
        public string ChatTitle;
        public bool UseNightMessage;
        public bool UseDayMessage;
        public float DawnTime;
        public float DuskTime;

        #region Lang API
        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>()
            {
                ["NightMessage"] = "{Title} [#add8e6]Night is upon us, beware![/#]",
                ["DayMessage"] = "{Title} [#add8e6]Dawn has arrived![/#]"
            }, this);
        }
        #endregion Lang API
        #region Config

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Generating new configurationfile...");
        }

        private new void LoadConfig()
        {
            ChatTitle = GetConfig<string>("Title", "[#00ffff]Server:[/#]");
            UseNightMessage = GetConfig<bool>("Use Night Message", true);
            UseDayMessage = GetConfig<bool>("Use Day Message", true);
            DawnTime = GetConfig<float>("Dawn Time", 7f);
            DuskTime = GetConfig<float>("Dusk Time", 19f);
            SaveConfig();
        }
        #endregion Config
        #region Oxide    
        private void OnServerInitialized()
        {
            timer.Repeat(1, 0, CheckTime);
        }
        private void Init()
        {
            LoadConfig();   
        }
        #endregion Oxide
        #region Time Helpers
        private void CheckTime()
        {            
            if (IsNight && !NightMessageSent)
            {
                SendMessage(true, false);
                NightMessageSent = true;
                DayMessageSent = false;
            }
            else
            if (!IsNight && !DayMessageSent)
            {
                SendMessage(false, true);
                DayMessageSent = true;
                NightMessageSent = false;
            }
        }
        bool IsNight => server.Time.TimeOfDay.Hours < DawnTime || server.Time.TimeOfDay.Hours >= DuskTime;      
        
        private void SendMessage(bool night, bool day)
        {
            if (day && DayMessageSent == false && UseDayMessage)
                Broadcast("DayMessage");             

            if (night && NightMessageSent == false && UseNightMessage)                           
                Broadcast("NightMessage");              
        }
        #endregion Time Helpers
        #region Helpers        
        private string Message(string key, string id = null, params object[] args)
        {
            return lang.GetMessage(key, this, id).Replace("{Title}", ChatTitle);
        }         
        private T GetConfig<T>(params object[] pathAndValue)
        {
            List<string> pathL = pathAndValue.Select((v) => v.ToString()).ToList();
            pathL.RemoveAt(pathAndValue.Length - 1);
            string[] path = pathL.ToArray();

            if (Config.Get(path) == null)
            {
                Config.Set(pathAndValue);
                PrintWarning($"Added field to config: {string.Join("/", path)}");
            }

            return (T)Convert.ChangeType(Config.Get(path), typeof(T));
        }
        private void Broadcast(string key)
        {
            foreach (var player in players.Connected) player.Reply(Message(key, player.Id));
        }
        #endregion Helpers
    }
}

// --- End of file: NightMessage.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/never-wear ---
// --- Original File Path: N/NeverWear/NeverWear.cs ---

﻿using System.Collections.Generic;
using Oxide.Core;

namespace Oxide.Plugins
{
    [Info("NeverWear", "k1lly0u / rostov114", "0.2.0")]
    class NeverWear : RustPlugin
    {
        #region Configuration
        private Configuration _config;
        public class Configuration
        {
            public bool useWeapons = false;
            public bool useTools = true;
            public bool useAttire = false;
            public bool useWhiteList = false;
            public List<string> WhitelistedItems = new List<string>();
            public bool useBlackList = false;
            public List<string> BlacklistedItems = new List<string>();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                SaveConfig();
            }
            catch
            {
                PrintError("Error reading config, please check!");

                Unsubscribe(nameof(OnLoseCondition));
            }
        }

        protected override void LoadDefaultConfig()
        {
            _config = new Configuration()
            {
                useWeapons = false,
                useTools = true,
                useAttire = false,
                useWhiteList = false,
                WhitelistedItems = new List<string>()
                {
                    "hatchet",
                    "pickaxe",
                    "rifle.bolt",
                    "rifle.ak"
                },
                useBlackList = false,
                BlacklistedItems = new List<string>()
                {
                    "pickaxe",
                    "hatchet#65535",
                }
            };

            SaveConfig();
        }

        protected override void SaveConfig()
        {
            Config.WriteObject(_config);
        }
        #endregion

        #region Oxide Hooks
        private void Loaded()
        {
            permission.RegisterPermission("neverwear.use", this);
            permission.RegisterPermission("neverwear.attire", this);
            permission.RegisterPermission("neverwear.weapons", this);
            permission.RegisterPermission("neverwear.tools", this);
        }

        private void OnLoseCondition(Item item, ref float amount)
        {
            if (item == null || !item.hasCondition || item.info == null)
                return;

            if (_config.useBlackList && (_config.BlacklistedItems.Contains($"{item.info.shortname}#{item.skin}") || _config.BlacklistedItems.Contains(item.info.shortname)))
                return;

            BasePlayer player = GetPlayer(item);
            if (player == null)
                return;

            if ((_config.useWhiteList && (_config.WhitelistedItems.Contains($"{item.info.shortname}#{item.skin}") || _config.WhitelistedItems.Contains(item.info.shortname)) && HasPerm(player, "neverwear.use"))
                || (item.info.category == ItemCategory.Weapon && _config.useWeapons && HasPerm(player, "neverwear.weapons"))
                || (item.info.category == ItemCategory.Attire && _config.useAttire && HasPerm(player, "neverwear.attire"))
                || (item.info.category == ItemCategory.Tool && _config.useTools && HasPerm(player, "neverwear.tools")))
            {
                object result = Interface.CallHook("OnNeverWear", item, amount);
                amount = (result is float) ? (float)result : 0f;
            }
        }
        #endregion

        #region Helpers
        public bool HasPerm(BasePlayer player, string perm)
        {
            return permission.UserHasPermission(player.UserIDString, perm);
        }

        public BasePlayer GetPlayer(Item item)
        {
            BasePlayer player = item.GetOwnerPlayer();
            if (player == null)
            {
                if (!item.info.shortname.Contains("mod"))
                    return null;

                player = item?.GetRootContainer()?.GetOwnerPlayer();
            }

            return (player == null || string.IsNullOrEmpty(player.UserIDString)) ? null : player;
        }
        #endregion
    }
}

// --- End of file: NeverWear.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-sun-glare ---
// --- Original File Path: N/NoSunGlare/NoSunGlare.cs ---

﻿using Newtonsoft.Json;
using Oxide.Core.Plugins;
using Oxide.Plugins;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("No Sun Glare", "Tryhard", "2.0.0")]
    [Description("Removes sun or sun glare")]
    public class NoSunGlare : RustPlugin
    {
        private WeatherConfig _config;

        #region Configuration

        public class WeatherConfig
        {
            [JsonProperty(PropertyName = "Clouds")]
            public float Clouds { get; set; } = 1;

            [JsonProperty(PropertyName = "Cloud Opacity")]
            public float CloudOpacity { get; set; } = 0.97f;

            [JsonProperty(PropertyName = "Cloud Brightness")]
            public float CloudBrightness { get; set; } = 1.5f;

            [JsonProperty(PropertyName = "Cloud Coloring")]
            public int CloudColoring { get; set; } = 0;

            [JsonProperty(PropertyName = "Cloud Saturation")]
            public int CloudSaturation { get; set; } = 1;

            [JsonProperty(PropertyName = "Cloud Scattering")]
            public int CloudScattering { get; set; } = 0;

            [JsonProperty(PropertyName = "Cloud Sharpness")]
            public int CloudSharpness { get; set; } = 0;

            [JsonProperty(PropertyName = "Cloud Size")]
            public int CloudSize { get; set; } = 0;

            [JsonProperty(PropertyName = "Cloud Coverage")]
            public int CloudCoverage { get; set; } = 1;

            [JsonProperty(PropertyName = "Cloud Attenuation")]
            public int CloudAttenuation { get; set; } = -1;

            [JsonProperty(PropertyName = "Wind")]
            public float Wind { get; set; } = 0;

            [JsonProperty(PropertyName = "Rain")]
            public float Rain { get; set; } = 0;

            [JsonProperty(PropertyName = "Fog")]
            public float Fog { get; set; } = 0;

            [JsonProperty(PropertyName = "Fogginess")]
            public float Fogginess { get; set; } = 0;

            [JsonProperty(PropertyName = "Dust Chance")]
            public float DustChance { get; set; } = 0;

            [JsonProperty(PropertyName = "Fog Chance")]
            public float FogChance { get; set; } = 0;

            [JsonProperty(PropertyName = "Overcast Chance")]
            public float OvercastChance { get; set; } = 0;

            [JsonProperty(PropertyName = "Storm Chance")]
            public float StormChance { get; set; } = 0;

            [JsonProperty(PropertyName = "Clear Chance")]
            public float ClearChance { get; set; } = 1;

            [JsonProperty(PropertyName = "Atmosphere Contrast")]
            public float AtmosphereContrast { get; set; } = 1.2f;

            [JsonProperty(PropertyName = "Atmosphere Directionality")]
            public float AtmosphereDirectionality { get; set; } = 0;

            [JsonProperty(PropertyName = "Atmosphere Mie")]
            public float AtmosphereMie { get; set; } = 0;

            [JsonProperty(PropertyName = "Atmosphere Rayleigh")]
            public float AtmosphereRayleigh { get; set; } = 1.3f;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();

            try
            {
                _config = Config.ReadObject<WeatherConfig>();

                if (_config == null) LoadDefaultConfig();
            }

            catch
            {
                PrintError("Configuration file is corrupt, check your config file at https://jsonlint.com/!");
                LoadDefaultConfig();
                return;
            }

            SaveConfig();
        }

        protected override void LoadDefaultConfig() => _config = new WeatherConfig();

        protected override void SaveConfig() => Config.WriteObject(_config);

        #endregion

        private void OnServerInitialized()
        {
            SetWeatherParameters(
                _config.Clouds,
                _config.CloudOpacity,
                _config.CloudBrightness,
                _config.CloudColoring,
                _config.CloudSaturation,
                _config.CloudScattering,
                _config.CloudSharpness,
                _config.CloudSize,
                _config.CloudCoverage,
                _config.CloudAttenuation,
                _config.Wind,
                _config.Rain,
                _config.Fog,
                _config.Fogginess,
                _config.DustChance,
                _config.FogChance,
                _config.OvercastChance,
                _config.StormChance,
                _config.ClearChance,
                _config.AtmosphereContrast,
                _config.AtmosphereDirectionality,
                _config.AtmosphereMie,
                _config.AtmosphereRayleigh
            );
        }

        private void SetWeatherParameters(
            float clouds,
            float cloudOpacity,
            float cloudBrightness,
            int cloudColoring,
            int cloudSaturation,
            int cloudScattering,
            int cloudSharpness,
            int cloudSize,
            int cloudCoverage,
            int cloudAttenuation,
            float wind,
            float rain,
            float fog,
            float fogginess,
            float dustChance,
            float fogChance,
            float overcastChance,
            float stormChance,
            float clearChance,
            float atmosphereContrast,
            float atmosphereDirectionality,
            float atmosphereMie,
            float atmosphereRayleigh)
        {
            var climate = SingletonComponent<Climate>.Instance;

            climate.Overrides.Clouds = clouds;
            climate.WeatherOverrides.Clouds.Opacity = cloudOpacity;
            climate.WeatherOverrides.Clouds.Brightness = cloudBrightness;
            climate.WeatherOverrides.Clouds.Coloring = cloudColoring;
            climate.WeatherOverrides.Clouds.Saturation = cloudSaturation;
            climate.WeatherOverrides.Clouds.Scattering = cloudScattering;
            climate.WeatherOverrides.Clouds.Sharpness = cloudSharpness;
            climate.WeatherOverrides.Clouds.Size = cloudSize;
            climate.WeatherOverrides.Clouds.Coverage = cloudCoverage;
            climate.WeatherOverrides.Clouds.Attenuation = cloudAttenuation;
            climate.Overrides.Wind = wind;
            climate.Overrides.Rain = rain;
            climate.Overrides.Fog = fog;
            climate.WeatherOverrides.Atmosphere.Fogginess = fogginess;
            climate.Weather.DustChance = dustChance;
            climate.Weather.FogChance = fogChance;
            climate.Weather.OvercastChance = overcastChance;
            climate.Weather.StormChance = stormChance;
            climate.Weather.ClearChance = clearChance;
            climate.WeatherOverrides.Atmosphere.Contrast = atmosphereContrast;
            climate.WeatherOverrides.Atmosphere.Directionality = atmosphereDirectionality;
            climate.WeatherOverrides.Atmosphere.MieMultiplier = atmosphereMie;
            climate.WeatherOverrides.Atmosphere.RayleighMultiplier = atmosphereRayleigh;

            ServerMgr.SendReplicatedVars("weather.");
        }
    }
}

// --- End of file: NoSunGlare.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/note-logger ---
// --- Original File Path: N/NoteLogger/NoteLogger.cs ---

﻿using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch.Extend;
using Newtonsoft.Json;
using Oxide.Core;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Note Logger", "un-boxing-man", "2.0.2")]
    [Description("Logs notes to a file.")]
    class NoteLogger : RustPlugin
    {
        const string permAdmin = "NoteLogger.admin";

        class NoteInfo
        {
            public string Text;
            public string DisplayName;
            public ulong UserID;
            public ItemId NoteID;
            public DateTime TimeStamp;

            public NoteInfo() { }

            public NoteInfo(BasePlayer player, string Text, ItemId NoteID)
            {
                this.Text = Text;
                this.DisplayName = player.displayName;
                this.UserID = player.userID;
                this.NoteID = NoteID;
                this.TimeStamp = DateTime.UtcNow;
            }
        }

        List<NoteInfo> NoteList = new List<NoteInfo>();

        #region Oxide Hooks

        void Init()
        {
            permission.RegisterPermission(permAdmin, this);

            lang.RegisterMessages(new Dictionary<string, string>()
            {
                { "NoPermission", "You don't have permission to use this." },
                { "NoteInfo-Tp-Usage", "Incorrect usage! /noteinfo tp {{UID}}" },
                { "NoNoteFound", "Please hold the note in the first slot of your hotbar :)" },
                { "NoteInfoTitle", "Info for note {NoteID}:" },
                { "NoteInfoItem", "[{TimeStamp}] {Name} ({UserID}): {Text}" },
                { "NoteInfoNone", "No updates to show." },
                { "CouldntFindNote", "The note #{UID} could not be found." },
                { "TeleportedToNote", "You have been teleported to note #{UID}." },
                { "ConsoleLogMessage", "[{TimeStamp}] {Name} ({UserID}) ID {UID}: {Text}" },
                { "LogMessage", "[{TimeStamp}] {Name} ({UserID}) ID {UID}: {Text}" }
            }, this);

            ReadData();
        }

        void OnServerSave()
        {
            SaveData();
        }

        #endregion

        #region Config

        ConfigFile config;

        class ConfigFile
        {
            [JsonProperty(PropertyName = "Log Notes To Console")]
            public bool LogToConsole;

            public static ConfigFile DefaultConfig()
            {
                return new ConfigFile
                {
                    LogToConsole = true
                };
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<ConfigFile>();
        }

        protected override void LoadDefaultConfig() => config = ConfigFile.DefaultConfig();

        protected override void SaveConfig() => Config.WriteObject(config);

        #endregion

        #region Commands

        [ChatCommand("note")]
        void NoteInfoCommand(BasePlayer player, string command, string[] args)
        {
            if (!HasPerm(player))
            {
                SendReply(player, GetMessage("NoPermission", player));
                return;
            }

            if (args != null && args.Length > 1 && args[0].ToLower() == "tp")
            {
                uint noteIDu;
                ulong noteIDl;
                ulong.TryParse(args[1], out noteIDl);


                if (!uint.TryParse(args[1], out noteIDu))
                {
                    SendReply(player, GetMessage("NoteInfo-Tp-Usage", player));
                    return;
                }
                ItemId noteID = new ItemId(noteIDl);
                var items = UnityEngine.Object.FindObjectsOfType(typeof(StorageContainer))?.Cast<StorageContainer>().Select(x => x.inventory.FindItemByUID(noteID)).Where(x => x != null);
                items.Concat(UnityEngine.Object.FindObjectsOfType(typeof(PlayerInventory))?.Cast<PlayerInventory>().Select(x => x.FindItemByUID(noteID)).Where(x => x != null));
                if (items.Count() == 0)
                {
                    SendReply(player, GetMessage("CouldntFindNote", player).Replace("{UID}", noteID.ToString()));
                    return;
                }
                var item = items.First();

                var container = item.GetRootContainer();
                Teleport(player, container.dropPosition);
                SendReply(player, GetMessage("TeleportedToNote", player).Replace("{UID}", noteID.ToString()));
                return;
            }

            var slotZero = player.inventory.containerBelt.GetSlot(0);

            if (slotZero == null || slotZero.info.displayName.english != "Note")
            {
                SendReply(player, GetMessage("NoNoteFound", player));
                return;
            }

            SendReply(player, GetMessage("NoteInfoTitle", player).Replace("{NoteID}", slotZero.uid.ToString()));
            var updateList = NoteList.Where(x => x.NoteID == slotZero.uid).OrderBy(x => x.TimeStamp).ToList();
            foreach (var update in updateList)
            {
                SendReply(player, GetMessage("NoteInfoItem", player)
                                    .Replace("{TimeStamp}", update.TimeStamp.ToString())
                                    .Replace("{Name}", update.DisplayName)
                                    .Replace("{UserID}", update.UserID.ToString())
                                    .Replace("{Text}", update.Text.TrimEnd('\n')));
            }
            if (updateList.Count == 0) SendReply(player, GetMessage("NoteInfoNone", player));
        }

        [ConsoleCommand("note.update")]
        void NoteUpdateCommand(ConsoleSystem.Arg arg)
        {
            uint num = arg.GetUInt(0, 0);
            string str = arg.GetString(1, string.Empty);
            Item item = arg.Player().inventory.FindItemByUID(new ItemId(num));
            if (item == null) return;
            item.text = str.Truncate(1024, null);
            item.MarkDirty();
            NoteList.Add(new NoteInfo(arg.Player(), item.text, item.uid));
            LogToConsole(arg.Player(), item.text, (uint)item.uid.Value);
            logTofile(arg.Player(), item.text, (uint)item.uid.Value);
        }

        #endregion

        #region Functions

        void LogToConsole(BasePlayer player, string text, uint uid)
        {
            if (!config.LogToConsole) return;
            Puts(GetMessage("ConsoleLogMessage", null)
                    .Replace("{TimeStamp}", DateTime.Now.ToString())
                    .Replace("{Name}", player.displayName)
                    .Replace("{UserID}", player.UserIDString)
                    .Replace("{UID}", uid.ToString())
                    .Replace("{Text}", text.TrimEnd('\n')));
        }
        void logTofile(BasePlayer player, string text, uint uid)
        {
            if (text == "") return;
            var filename = DateTime.Now.ToString("yyyy-MM-dd");
            var Message = (GetMessage("LogMessage", null)
                    .Replace("{TimeStamp}", DateTime.Now.ToString())
                    .Replace("{Name}", player.displayName)
                    .Replace("{UserID}", player.UserIDString)
                    .Replace("{UID}", uid.ToString())
                    .Replace("{Text}", text.TrimEnd('\n')));
            Puts(DateTime.UtcNow.ToString());
            LogToFile(filename, Message, this, false);

        }

        void Teleport(BasePlayer player, Vector3 position)
        {
            if (player.net?.connection != null)
                player.ClientRPCPlayer(null, player, "StartLoading");
            StartSleeping(player);
            player.MovePosition(position);
            if (player.net?.connection != null)
                player.ClientRPCPlayer(null, player, "ForcePositionTo", position);
            if (player.net?.connection != null)
                player.SetPlayerFlag(BasePlayer.PlayerFlags.ReceivingSnapshot, true);
            player.UpdateNetworkGroup();
            player.SendNetworkUpdateImmediate(false);
            if (player.net?.connection == null) return;
            try { player.ClearEntityQueue(null); } catch { }
            player.SendFullSnapshot();
        }

        void StartSleeping(BasePlayer player)
        {
            if (player.IsSleeping())
                return;
            player.SetPlayerFlag(BasePlayer.PlayerFlags.Sleeping, true);
            if (!BasePlayer.sleepingPlayerList.Contains(player))
                BasePlayer.sleepingPlayerList.Add(player);
            player.CancelInvoke("InventoryUpdate");
        }

        #endregion

        #region Helpers

        string GetMessage(string key, BasePlayer player) => lang.GetMessage(key, this, player?.UserIDString);

        bool HasPerm(BasePlayer player) => (player.IsAdmin || permission.UserHasPermission(player.UserIDString, permAdmin));

        void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(this.Title, NoteList);
        void ReadData() => NoteList = Interface.Oxide.DataFileSystem.ReadObject<List<NoteInfo>>(this.Title);

        #endregion
    }
}

// --- End of file: NoteLogger.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-craft ---
// --- Original File Path: N/NoCraft/NoCraft.cs ---

﻿using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("No Craft", "Ryan", "1.0.0")]
    [Description("Blacklist craft items or disable crafting altogether")]
    class NoCraft : RustPlugin
    {
        #region Declaration

        private ConfigFile CFile;
        private const string Perm = "nocraft.bypass";

        #endregion

        #region Config

        private class ConfigFile
        {
            public Dictionary<string, bool> BlockedItems { get; set; }

            public BlockAll BlockAll { get; set; }

            public ConfigFile()
            {
                BlockedItems = new Dictionary<string, bool>
                {
                    ["rock"] = true,
                    ["note"] = false
                };
                BlockAll = new BlockAll()
                {
                    Enabled = false,
                    SendMessage = true
                };
            }
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Generating default configuration file...");
            CFile = new ConfigFile();
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                CFile = Config.ReadObject<ConfigFile>();
                if(CFile == null) Regenerate();
            }
            catch { Regenerate(); }
        }

        protected override void SaveConfig() => Config.WriteObject(CFile);

        private void Regenerate()
        {
            PrintWarning($"Configuration file at 'oxide/config/{Name}.json' seems to be corrupt! Regenerating...");
            CFile = new ConfigFile();
            SaveConfig();
        }

        #endregion

        #region Lang

        private class Msg
        {
            public const string CantCraft = "CantCraft";
            public const string CraftingDisabled = "CraftingDisabled";
        }

        private new void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                [Msg.CantCraft] = "You're not allowed to craft {0}s!",
                [Msg.CraftingDisabled] = "Crafting is disabled on this server"
            }, this);
        }

        #endregion

        #region Classes

        private class BlockAll
        {
            public bool Enabled { get; set; }
            public bool SendMessage { get; set; }
        }

        #endregion

        #region Methods

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        #endregion

        #region Hooks

        private void Init() => permission.RegisterPermission(Perm, this);

        private object CanCraft(ItemCrafter itemCrafter, ItemBlueprint bp, int amount)
        {
            var player = itemCrafter.GetComponent<BasePlayer>();
            var item = bp.GetComponent<ItemDefinition>();

            if (permission.UserHasPermission(player.UserIDString, Perm))
                return null;

            if (CFile.BlockAll.Enabled)
            {
                if (CFile.BlockAll.SendMessage)
                    PrintToChat(player, Lang(Msg.CraftingDisabled, player.UserIDString));
                return false;
            }

            if (CFile.BlockedItems.ContainsKey(item.shortname))
            {
                if(CFile.BlockedItems[item.shortname])
                    PrintToChat(player, Lang(Msg.CantCraft, player.UserIDString, item.displayName.english));
                return false;
            }

            return null;
        }

        #endregion
    }
}

// --- End of file: NoCraft.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/npc-health ---
// --- Original File Path: N/NPCHealth/NPCHealth.cs ---

﻿using System;
using Newtonsoft.Json;

namespace Oxide.Plugins
{
    [Info("NPC Health", "Rustoholics", "0.1.1")]
    [Description("Boost or decrease the health of all NPC players by scaling damage dealt to them")]

    public class NPCHealth : CovalencePlugin
    {
        #region Config
        private Configuration _config;
        protected override void SaveConfig() => Config.WriteObject(_config);
        protected override void LoadDefaultConfig() => _config = new Configuration();

        private class Configuration
        {
            [JsonProperty("How strong are NPCs (1.0 = normal, 0.5 = half as strong, 2 = twice as strong, 10 = epic")]
            public double NPCHealthMultiplier = 2;
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _config = Config.ReadObject<Configuration>();
                if (_config == null) throw new Exception();

                SaveConfig();
            }
            catch
            {
                PrintError("Your configuration file contains an error. Using default configuration values.");
                LoadDefaultConfig();
            }
        }
        #endregion
        
        void OnEntityTakeDamage(BaseCombatEntity entity, HitInfo info)
        {
            if (info == null || info.HitEntity == null || !(info.HitEntity is NPCPlayer))
            {
                return;
            }

            var dmgModifier = (float)(1 / _config.NPCHealthMultiplier);

            info.damageTypes.ScaleAll(dmgModifier);
        }
    }
}

// --- End of file: NPCHealth.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/no-shelves-bug-raiding ---
// --- Original File Path: N/NoShelvesBugRaiding/NoShelvesBugRaiding.cs ---

using System.Collections.Generic;
using UnityEngine;
namespace Oxide.Plugins
{
    [Info("NoShelvesBugRaiding", "wazzzup", "1.1.0")]
    [Description("No bug raiding with shelfs")]
    public class NoShelvesBugRaiding : RustPlugin
    {
        bool OnShelves(BaseEntity entity)
        {
            GroundWatch component = entity.gameObject.GetComponent<GroundWatch>();
            List<Collider> list = Facepunch.Pool.GetList<Collider>();
            Vis.Colliders<Collider>(entity.transform.TransformPoint(component.groundPosition), component.radius, list, component.layers, QueryTriggerInteraction.Collide);
            foreach (Collider collider in list)
            {
                if (!((Object)collider.transform.root == (Object)entity.gameObject.transform.root))
                {
                    BaseEntity baseEntity = collider.gameObject.ToBaseEntity();
                    if ((!(bool)((Object)baseEntity) || !baseEntity.IsDestroyed && !baseEntity.isClient) && baseEntity.ShortPrefabName == "shelves")
                    {
                        Facepunch.Pool.FreeList<Collider>(ref list);
                        return true;
                    }
                }
            }
            Facepunch.Pool.FreeList<Collider>(ref list);
            return false;
        }


        void OnEntityBuilt(Planner plan, GameObject obj)
        {
            var entity = obj.GetComponent<BaseEntity>();
            if (entity != null && entity.ShortPrefabName == "shelves" && OnShelves(entity))
            {
                entity.Kill();
                BasePlayer player = plan.GetOwnerPlayer();
                SendReply(player, "Failed Check: Sphere Test (shelves/sockets/free/inside 1)");
                var newItem = ItemManager.CreateByItemID(2057749608, (int)1);
                if (newItem != null)
                {
                    player.inventory.GiveItem(newItem);
                }
            }
        }
    }
}

// --- End of file: NoShelvesBugRaiding.cs ---
// --- Next file ---

// --- Source Plugin URL: https://umod.org/plugins/npc-drop-gun ---
// --- Original File Path: N/NPCDropGun/NPCDropGun.cs ---

using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch;
using Newtonsoft.Json;
using UnityEngine;
using Random = UnityEngine.Random;

namespace Oxide.Plugins
{
	[Info("NPC Drop Gun", "2CHEVSKII", "2.0.8")]
	[Description("Forces NPC to drop used gun and other items after death")]
	public class NPCDropGun : RustPlugin
	{
		#region Fields

		Settings settings;
		Dictionary<BasePlayer, List<Item>> delayedItems;

		#endregion

		#region Oxide hooks

		v